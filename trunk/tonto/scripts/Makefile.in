#==============================================================================
#
# >>> Makefile for the TONTO system
#
# You will need GNU make and perl for this Makefile to work.
#
# For basic installation just type
#
#      perl -w Makefile.pl
#      make
#
# There should be nothing in this file that you need to change. 
# This file gets overwritten each time "Makefile.pl" is run!
#
# Type "make help" for common options.
#
# Type "make tests" to run the test suite. Failures should be checked but are
# usually due to small numerical differences. See the README in this directory.
#
# (c) Dylan Jayatilaka, Daniel Grimwood 
#     University of Western Australia, 1999-2004
#
# $Id$
#
#==============================================================================

#------------------------------------------------------------------------------
# >>> Site specific information
#
# Where to install programs, and where the source files are located.
# Utilities required such as perl are also listed here.
#
# For a known platform, everything is inserted by running "Makefile.pl".
# Use "Makefile.pl -fc=<your-fortran-compiler>" to override the default.
#
#------------------------------------------------------------------------------

# Where the program executable is copied to
installdir := @INSTALLDIR@

# The source directory
srcdir := @SRCDIR@

# The fortran compiler command
FC := @FC@

# The Perl command
PERL := @PERL@

# The gmake command
MAKE := @MAKE@

# The operating system this Makefile is for
OS := @OS@

# Fortran compiler and operating system identifier string
PLATFORM_ID := @PLATFORM_ID@
PLATFORM_ID_ := @PLATFORM_ID_@
COMPILER_ID_ := @COMPILER_ID_@

# Fortran default data type kind
INT_KIND := @INT_KIND@
BIN_KIND := @BIN_KIND@
REAL_KIND := @REAL_KIND@
CPX_KIND := @CPX_KIND@

# Shell to use for gmake command
SHELL = /bin/csh -f

# Platform specific information file - this has all the important info
PLATFORM_INFO_FILE := @PLATFORM_INFO_FILE@

# Build date for this executable
BUILD_DATE := $(shell date)

# Tonto version
VERSION := 2.3

#------------------------------------------------------------------------------
# Include platform specific information i.e. fortran compiler options and
# switches for bugs in the compiler, and error management switches.
#------------------------------------------------------------------------------

include $(PLATFORM_INFO_FILE) # <<<<<<<<<<<<

# Set some defaults, if not defined in the PLATFORM_INFO_FILE file.

ifndef FSUFFIX
       FSUFFIX := f90
endif

ifndef PROGSUFFIX
       PROGSUFFIX := exe
endif

ifndef MODSUFFIX
       MODSUFFIX := mod
endif

ifndef OBJSUFFIX
       OBJSUFFIX := o
endif

ifndef LIBSUFFIX
       LIBSUFFIX := a
endif

ifndef MKLIB
       MKLIB := ar -ru
endif

ifndef FOUTOBJ
       FOUTOBJ := -c -o
endif

ifndef FOUTEXE
       FOUTEXE := -o
endif

ifdef FCOLON
   FOUTOBJ := $(FOUTOBJ)$(FCOLON)
   FOUTEXE := $(FOUTEXE)$(FCOLON)
   LIBOUT  :=  $(LIBOUT)$(FCOLON)
else
   EMPTY   := 
   FOUTOBJ := $(FOUTOBJ)$(EMPTY) $(EMPTY)
   FOUTEXE := $(FOUTEXE)$(EMPTY) $(EMPTY)
   LIBOUT  :=  $(LIBOUT)$(EMPTY) $(EMPTY)
endif

#------------------------------------------------------------------------------
# >>> Locations of important directories.
#
# TONTO places its files neatly in subdirectories with sensible names.
#
# Binary objects go into subdirectories related to the compiler/vendor name,
# which allows builds for multiple architectures using the same source files.
#
#------------------------------------------------------------------------------

bindir      := $(srcdir)/$(PLATFORM_ID)/custom
ifeq ($(FOPTNS),$(FFAST))
bindir      := $(srcdir)/$(PLATFORM_ID)/fast
endif
ifeq ($(FOPTNS),$(FDEBUG))
bindir      := $(srcdir)/$(PLATFORM_ID)/debug
endif

f95depdir   := $(bindir)/f95dependencies
f95dir      := $(bindir)/f95files
objdir      := $(bindir)/objects
moddir      := $(bindir)/modules
incdir      := $(bindir)/includes
rcfdir      := $(bindir)/compactify
usddir      := $(bindir)/compactify

scriptdir   := $(srcdir)/scripts
foodir      := $(srcdir)/foofiles
foodepdir   := $(srcdir)/foodependencies

docdir      := $(srcdir)/documentation
f95docdir   := $(docdir)/f95files
htmldir     := $(docdir)/htmlfiles
htmldocdir  := $(docdir)/htmlmanual
testdir     := $(srcdir)/tests

#------------------------------------------------------------------------------
# >>> Some useful functions. Perl is used for portability.
#------------------------------------------------------------------------------
MKDIR      := perl -MExtUtils::Command -e mkpath
CP         := perl -MExtUtils::Command -e cp
RMDIR      := perl -w $(scriptdir)/rmdir.pl
RM         := perl -w $(scriptdir)/rm.pl
CAT        := perl -w $(scriptdir)/cat.pl

SET_NOGLOB := set noglob &&

PROTECT          = $(subst {,\{,$(1)) 
DOUBLE_PROTECT   = $(subst {,\\\{,$(1)) 

# These are long names for cryptic gmake short forms

#TARGET           = $(call PROTECT,$@)
#TARGET_FILE      = $(call DOUBLE_PROTECT,$(@F))
TARGET               = $@
TARGET_FILE          = $(@F)
TARGET_FILENAME_HEAD = $(*F)
TARGET_OBJECT        = $($(join $(TARGET_FILE),.associated_object))
TARGET_MODULES       = $($(join $(TARGET_FILE),.module_list))

#PREREQUISITES         = $(call PROTECT,$^)
PREREQUISITES         = $^
FIRST_PREREQUISITE    = $<
FORTRAN_PREREQUISITES = $(filter %.$(FSUFFIX),$(PREREQUISITES))

#ALL_OBJECT_FILES = $(wildcard $(call PROTECT,$(objdir)/*.$(OBJSUFFIX)))
#TARGET_OBJECT    = $(join $(basename $(TARGET)),.$(OBJSUFFIX))
#TARGET_MODULES   = $($(join $(join $(basename $(TARGET)),.$(MODSUFFIX)),.module_list))
ALL_OBJECT_FILES = $(wildcard $(objdir)/*.$(OBJSUFFIX))

# Whether to use -nogeneric, -nounknown, -used_routines, or -routine_calls

DO_STACK      = $(if $(filter -DUSE_CALL_STACK_MANAGEMENT,$(DEFS)),-stack)
DO_TIMER      = $(if $(filter -DUSE_TIME_PROFILING,$(DEFS)),-timer)
DO_MPI        = $(if $(filter -DMPI,$(DEFS)),-mpi)
NO_SYSTEM     = $(if $(DO_MPI),, \
                $(if $(filter -DNO_TONTO_SYSTEM_CALLS,$(DEFS)),-no_system))
NO_GENERIC    = $(if $(filter -DNO_GENERIC_NAMES,$(DEFS)),-no_generic)
NO_MOD_USE    = $(if $(filter -DNO_MOD_USE,$(DEFS)),-no_mod_use)
NO_MOD_ONLY   = $(if $(filter -DNO_MOD_ONLY,$(DEFS)),-no_mod_only)
NO_UNKNOWN    = $(if $(filter -DNO_CASE_OPTIONS,$(DEFS)),-no_unknown)
USED_ROUTINES = $(if $(wildcard $(usddir)/*.usd), \
                     -used_routines $(usddir)/$(TARGET_FILENAME_HEAD).usd)
ROUTINE_CALLS = $(if $(USED_ROUTINES),, \
                     -routine_calls $(rcfdir)/$(TARGET_FILENAME_HEAD).rcf)

#------------------------------------------------------------------------------
# >>> Construct lists of files.
#
# Program source files *must* have a name starting with "run_".
#
#------------------------------------------------------------------------------

foofiles    := $(wildcard $(foodir)/*.foo)
objfiles    := $(patsubst $(foodir)/%.foo,$(objdir)/%.$(OBJSUFFIX),$(filter-out $(foodir)/run_%,$(foofiles)))
runfiles    := $(patsubst $(foodir)/%.foo,$(bindir)/%.$(PROGSUFFIX),$(filter $(foodir)/run_%,$(foofiles)))
htmlfiles   := $(patsubst $(foodir)/%.foo,$(htmldir)/%.html,$(foofiles))
f95depfiles := $(patsubst $(foodir)/%.foo,$(f95depdir)/%.f95dep,$(foofiles))
foodepfiles := $(patsubst $(foodir)/%.foo,$(foodepdir)/%.foodep,$(foofiles))
rcffiles    := $(patsubst $(foodir)/%.foo,$(rcfdir)/%.rcf,$(foofiles))
usdfiles    := $(patsubst $(foodir)/%.foo,$(usddir)/%.usd,$(foofiles))
f95files    := $(patsubst $(foodir)/%.foo,$(f95dir)/%.$(FSUFFIX),$(foofiles))
f95docs     := $(patsubst $(f95dir)%,$(f95docdir)%,$(f95files))
intdocs     := $(patsubst $(intdir)%,$(f95docdir)%,$(intfiles))
usedocs     := $(patsubst $(usedir)%,$(f95docdir)%,$(usefiles))
htmlshortfiles := $(patsubst %.html,%_short.html,$(htmlfiles))

#------------------------------------------------------------------------------
# >>> Miscellaneous makefile stuff
#------------------------------------------------------------------------------

.DEFAULT :
.DELETE_ON_ERROR :
.SUFFIXES :
.SUFFIXES : .$(OBJSUFFIX) .$(PROGSUFFIX) .$(FSUFFIX) .$(MODSUFFIX) .foodep .f95dep .foo .html
.PHONY : clean distclean docsclean all directories install documentation \
         help distribution manual-pdf manual-html blas lapack tests tests_for_CX
.SECONDARY : $(f95files)

VPATH := $(scriptdir)
vpath %.foo $(foodir)
vpath %.$(FSUFFIX) $(f95dir)
vpath %.foodep $(foodepdir)
vpath %.f95dep $(f95depdir)
vpath %.$(MODSUFFIX) $(moddir)

#------------------------------------------------------------------------------
# >>> Targets and dependencies
#
# Immediately below are high level targets that the user will type.
#------------------------------------------------------------------------------

all : blas lapack $(bindir)/run_molecule.$(PROGSUFFIX)

help :
	@echo 
	@echo "Common arguments are:"
	@echo 
	@echo "    help            - displays this screen"
	@echo "    documentation   - makes the html documentation"
	@echo "    manual-pdf      - make the manual in pdf format"
	@echo "    manual-html     - make the manual in html format"
	@echo
	@echo "    all             - builds the program run_mol.$(PROGSUFFIX)"
	@echo "    run_mol.$(PROGSUFFIX)       - builds the program run_mol.$(PROGSUFFIX)"
	@echo "    run_XXXXX.$(PROGSUFFIX)       - builds the program run_XXXXX.$(PROGSUFFIX)"
	@echo "    install         - installs any compiled programs into $(installdir)"
	@echo
	@echo "    clean           - removes built program files"
	@echo "    docsclean       - removes built documentation files"
	@echo "    distclean       - removes all built files"
	@echo 
	@echo "    blas            - build basic BLAS library"
	@echo "    lapack          - build basic LAPACK library"
	@echo 

install : $(wildcard $(PLATFORM_ID)/*.$(PROGSUFFIX))
	@$(CP) $(PREREQUISITES) $(installdir)

clean :
	@$(SET_NOGLOB) $(RMDIR) $(foodepdir) 
	@$(SET_NOGLOB) $(RMDIR) $(PLATFORM_ID)
	@$(SET_NOGLOB) $(RMDIR) $(docdir)
	@$(SET_NOGLOB) $(MKDIR) $(PLATFORM_ID)
	@$(SET_NOGLOB) $(MKDIR) $(foodepdir) 

docsclean :
	@$(SET_NOGLOB) $(RMDIR) $(docdir)

distclean : clean docsclean
	@$(RM) $(srcdir)/Makefile

distribution :
	$(scriptdir)/make_dist

documentation : $(htmlfiles) $(docdir)/TONTO-nav-bar.html

manual-pdf : $(docdir)/tonto.pdf

manual-html : $(htmldocdir)/index.html

blas : $(objdir)/libblas.$(LIBSUFFIX)

lapack : $(objdir)/liblapack.$(LIBSUFFIX)

#------------------------------------------------------------------------------
# >>> Compactification
#
# "make compactify" is used to make the smallest possible executable by
# eliminating all "dead" code i.e. unused code. 
#
# NOTE: if you change the foo code to include new routines and calls to new
# routines then you will have to "make compactify" again. Alternatively, you can
# manually edit the .usd files to include the new routines. This procedure is
# not recommended because it is error-prone.  Compactification is designed for
# producing a clean final executable for distribution, not necessarily for
# development of new code.
#------------------------------------------------------------------------------
 
compactify: $(rcfdir)/run_molecule.rcf $(rcffiles)
	$(SET_NOGLOB) $(RM) $(usdfiles)
	$(SET_NOGLOB) touch $(foofiles)
	$(SET_NOGLOB) make $(f95files)
	cd $(rcfdir) && \
        $(SET_NOGLOB) ../../$(scriptdir)/compactify_calls.pl \
        -caller run_molecule.rcf \
        -called $(rcffiles)
	$(SET_NOGLOB) echo "*all*" > $(rcfdir)/system.usd
	$(SET_NOGLOB) touch $(foofiles)
	make

#------------------------------------------------------------------------------
# >>> Documentation.
#
# The manual can be converted to various formats from the docbook source.
#
# The html documentation for each module is generated from the .foo source.
# "foo.pl" also does this.
#
#------------------------------------------------------------------------------

$(htmldocdir)/index.html : $(docdir)/tonto.xml \
           $(docdir)/tonto.html.xsl $(docdir)/tonto.common.xsl
	@test -d $(htmldocdir) || $(MKDIR) $(htmldocdir)
	@setenv XML_CATALOG_FILES "$(docdir)/tonto.cat" && xsltproc $(docdir)/tonto.html.xsl $(docdir)/tonto.xml

$(docdir)/tonto.pdf : \
           $(docdir)/tonto.docbook \
           $(docdir)/tonto.dsl
	@docbook2pdf -d $(docdir)/tonto.dsl#print -o $(docdir) $(docdir)/tonto.docbook

$(docdir)/TONTO-nav-bar.html : \
           $(htmlfiles) \
           $(srcdir)/make_navbar.pl
	$(PERL) -w $(scriptdir)/make_navbar.pl $(htmldir) $(f95docdir) $(docdir) > $(TARGET)

$(htmldir)/%.html : \
           $(foodir)/%.foo \
           $(scriptdir)/foo.pl
	@test -d $(htmldir) || $(MKDIR) $(htmldir)
	@test -d $(f95docdir)  || $(MKDIR) $(f95docdir)
	@$(SET_NOGLOB) echo Compiling $(shell $(SET_NOGLOB) echo $(*F) | tr a-z A-Z) Foo code into HTML and Fortran ...
	@$(SET_NOGLOB) $(PERL) -w $(scriptdir)/foo.pl \
           -html_short  $(htmldir)/$(TARGET_FILENAME_HEAD)_short.html \
           -html_long   $(TARGET) \
           -fortran     $(f95docdir)/$(TARGET_FILENAME_HEAD).F95 $(FIRST_PREREQUISITE)


#-------------------------------------------------------------------------------
# >>> Dependency rules.
#
# The "make_f95_dependencies.pl" script makes a .f95dep file for each .foo file.
# These .f95dep files are placed in the "dependencies" directory and are
# combined together to form the main "f95dependfile" rules for the Makefile. 
# These rules arise from Fortran module or Fortran source dependencies.
#
# The "make_foo_dependencies.pl" script makes a .foodep file for each .foo file.
# These .foodep files are placed in the "foodependencies" directory and are
# combined together to form the main "foodependfile" rulse for the makefile. 
# These rules arise from foo-language textual or parameterised type inheritance.
#
#-------------------------------------------------------------------------------

skip_cmds := clean distclean docsclean distribution \
             foodependfile f95dependfile \
             documentation help manual-pdf manual-html \
             blas lapack tests tests_for_CX \
             compactify 

skip_depfile := $(filter $(skip_cmds),$(MAKECMDGOALS))

ifeq ($(skip_depfile),)
include $(srcdir)/$(PLATFORM_ID)/f95dependfile
include $(srcdir)/foodependfile
endif

$(srcdir)/foodependfile : $(foodepfiles)
	@$(SET_NOGLOB) $(CAT) $(PREREQUISITES) > $(TARGET)

$(srcdir)/$(PLATFORM_ID)/f95dependfile : $(f95depfiles)
	@$(SET_NOGLOB) $(CAT) $(PREREQUISITES) > $(TARGET)
#	@$(CAT) $(subst {,\{,$^) > $(TARGET)

$(f95depdir)/%.f95dep : \
           $(f95dir)/%.$(FSUFFIX) \
           $(scriptdir)/make_f95_dependencies.pl \
           Makefile \
           $(PLATFORM_INFO_FILE)                 # Now begin the rules ...
	@test -d $(f95depdir) || $(MKDIR) $(f95depdir)
	@$(SET_NOGLOB) echo Making $(shell $(SET_NOGLOB) echo $(TARGET_FILENAME_HEAD) | tr a-z A-Z) Fortran dependency rules ...
	@$(SET_NOGLOB) $(PERL) -w $(scriptdir)/make_f95_dependencies.pl \
           -I $(f95dir) -I . \
           -prog_ext $(PROGSUFFIX) \
           -mod_ext  $(MODSUFFIX) \
	   -skip_use mpi \
           -obj_ext  $(OBJSUFFIX) \
           -src      $(FIRST_PREREQUISITE) \
           $(MODCASE) -o $(TARGET)

$(foodepdir)/%.foodep : \
           $(foodir)/%.foo \
           $(scriptdir)/make_foo_dependencies.pl \
           Makefile \
           $(PLATFORM_INFO_FILE)                 # Now begin the rules ...
	@test -d $(foodepdir) || $(MKDIR) $(foodepdir)
	@$(SET_NOGLOB) echo Making $(shell $(SET_NOGLOB) echo $(TARGET_FILENAME_HEAD) | tr a-z A-Z) Foo dependency rules ...
	@$(SET_NOGLOB) $(PERL) -w $(scriptdir)/make_foo_dependencies.pl \
           -src $(FIRST_PREREQUISITE) \
           -o   $(TARGET)

#------------------------------------------------------------------------------
# >>> Convert the foo code to Fortran.
#
# Perl script "foo.pl" is used to generate Fortran files from .foo source code. 
#
#------------------------------------------------------------------------------

$(f95dir)/%.$(FSUFFIX) : \
           $(foodir)/%.foo \
           $(foodir)/macros \
           $(scriptdir)/foo.pl \
           $(foodir)/types.foo \
           Makefile \
           $(scriptdir)/filepp.pl \
           $(scriptdir)/tonto.pm \
           $(scriptdir)/literal.pm \
           $(PLATFORM_INFO_FILE)                          # Now begin the rules
	@test -d $(f95dir) || $(MKDIR) $(f95dir)
	@test -d $(incdir) || $(MKDIR) $(incdir)
	@test -d $(rcfdir) || $(MKDIR) $(rcfdir)
	@$(SET_NOGLOB) echo Compiling $(shell $(SET_NOGLOB) echo $(TARGET_FILENAME_HEAD) | tr a-z A-Z) Foo code into Fortran ...
	@$(SET_NOGLOB) $(PERL) -I$(scriptdir) -w $(scriptdir)/foo.pl \
           $(DO_STACK) $(DO_TIMER) $(NO_GENERIC) $(NO_MOD_USE) $(NO_MOD_ONLY) $(NO_UNKNOWN) $(NO_SYSTEM) \
           -fortran $(TARGET_FILENAME_HEAD).tmp \
           -incdir  $(incdir) \
           $(ROUTINE_CALLS) $(USED_ROUTINES) $(FIRST_PREREQUISITE)
	@$(SET_NOGLOB) $(PERL) -w $(scriptdir)/filepp.pl -w \
           -I$(foodir) -I$(incdir) -M$(scriptdir) \
           -m literal.pm -m tonto.pm \
           -DTONTO_VERSION="'$(VERSION)'" \
           -DTONTO_PLATFORM="'$(PLATFORM_ID)'" \
           -DTONTO_BUILD_DATE="'$(BUILD_DATE)'" \
           -DINT_KIND="$(INT_KIND)" \
           -DBIN_KIND="$(BIN_KIND)" \
           -DREAL_KIND="$(REAL_KIND)" \
           -DCPX_KIND="$(CPX_KIND)" \
           -D$(COMPILER_ID_) \
           -D$(PLATFORM_ID_) \
           -o $(TARGET) \
           $(DEFS) $(TARGET_FILENAME_HEAD).tmp
	@$(SET_NOGLOB) $(RM) $(TARGET_FILENAME_HEAD).tmp

#------------------------------------------------------------------------------
# >>> Object files and module files
#
# Use the script compile_mod.pl - this may speed up compilation for
# developers.  (The module files are only updated if required).
#
# The .$(OBJSUFFIX) files are placed in the "objects" directory and then added
# to the "$(objdir)/libtonto.$(LIBSUFFIX)" library archive as they are made; the
# archive is then used in the final link stage.
#
#------------------------------------------------------------------------------

$(objdir)/%.$(OBJSUFFIX) : $(PLATFORM_INFO_FILE)
	@test -d $(objdir) || $(MKDIR) $(objdir)
	@test -d $(moddir) || $(MKDIR) $(moddir)
	@$(SET_NOGLOB) echo Making $(TARGET) ...
	@$(if $^,,$(error "Don't know prerequisites for $(TARGET)"))
	@$(SET_NOGLOB) $(PERL) -w $(scriptdir)/compile_mod.pl \
           -fc "$(SET_NOGLOB) $(FC) $(FFLAGS) $(FOPTNS) $(FOUTOBJ)$(TARGET) $(FORTRAN_PREREQUISITES)" \
           -cmp "$(PERL) -w $(scriptdir)/compare_module_file.pl -compiler $(PLATFORM_ID)" \
           -provides $(TARGET_MODULES) $(TARGET) \
           -requires $(PREREQUISITES) 
	@$(SET_NOGLOB) touch $(TARGET_MODULES) $(TARGET) 

$(moddir)/%.$(MODSUFFIX) : $(PLATFORM_INFO_FILE)
	@test -d $(objdir) || $(MKDIR) $(objdir)
	@test -d $(moddir) || $(MKDIR) $(moddir)
	@$(SET_NOGLOB) echo Making $(TARGET) ...
	@$(if ^,,$(error "Don't know prerequisites for $(TARGET)"))
	@$(SET_NOGLOB) $(PERL) -w $(scriptdir)/compile_mod.pl \
           -fc "$(SET_NOGLOB) $(FC) $(FFLAGS) $(FOPTNS) $(FOUTOBJ)$(TARGET_OBJECT) $(FORTRAN_PREREQUISITES)" \
           -cmp "$(PERL) -w $(scriptdir)/compare_module_file.pl -compiler $(PLATFORM_ID)" \
           -provides $(TARGET_MODULES) $(TARGET_OBJECT) \
           -requires $(PREREQUISITES) 
	@$(SET_NOGLOB) touch $(TARGET_MODULES) $(TARGET_OBJRCT) 

#------------------------------------------------------------------------------
# >>> Generate the main run_XXXX.$(PROGSUFFIX) executable
#------------------------------------------------------------------------------

$(bindir)/%.$(PROGSUFFIX) : $(PLATFORM_INFO_FILE)
	@test -d $(bindir) || $(MKDIR) $(bindir)
	@echo 
	@echo This is the final link phase ...
	@echo Building $(objdir)/libtonto.$(LIBSUFFIX) from all object files ...
	@$(SET_NOGLOB) $(MKLIB) $(LIBOUT)$(objdir)/libtonto.$(LIBSUFFIX) $(ALL_OBJECT_FILES)
	@$(SET NO_GLOB) echo Making $(TARGET) ...
	@$(SET_NOGLOB) echo $(FC) $(FFLAGS) $(FOPTNS) $(FOUTEXE)$(TARGET) $(FORTRAN_PREREQUISITES) $(objdir)/libtonto.$(LIBSUFFIX) $(LIBS)
	@$(SET_NOGLOB) $(FC) $(FFLAGS) $(FOPTNS) $(FOUTEXE)$(TARGET) $(FORTRAN_PREREQUISITES) $(objdir)/libtonto.$(LIBSUFFIX) $(LIBS)
	@$(SET_NOGLOB) $(RM) $(*F).$(OBJSUFFIX)
	@$(SET_NOGLOB) $(RMDIR) $(incdir)
	@echo "Finished compilation."
	@echo "The program compiled is $(TARGET)"

#------------------------------------------------------------------------------
# >>> Lapack, blas
#------------------------------------------------------------------------------

$(objdir)/libblas.$(LIBSUFFIX) : lapack/blas.fpp
	@echo Building BLAS library
	@test -d $(objdir) || $(MKDIR) $(objdir)
	@$(SET_NOGLOB) $(PERL) -w $(scriptdir)/filepp.pl -w \
           -I./lapack -M$(scriptdir) \
           -m literal.pm -m tonto.pm \
           -DTONTO_VERSION="'$(VERSION)'" \
           -DTONTO_PLATFORM="'$(PLATFORM_ID)'" \
           -DTONTO_BUILD_DATE="'$(BUILD_DATE)'" \
           -DINT_KIND="$(INT_KIND)" \
           -DBIN_KIND="$(BIN_KIND)" \
           -DREAL_KIND="$(REAL_KIND)" \
           -DCPX_KIND="$(CPX_KIND)" \
           -D$(PLATFORM_ID_) \
           -o lapack/blas.$(FSUFFIX) \
           $(DEFS) lapack/blas.fpp
	$(FC) $(FOPTNS) $(F77) $(FOUTOBJ)blas.$(OBJSUFFIX) lapack/blas.$(FSUFFIX)
	@$(RM) lapack/blas.$(FSUFFIX)
	$(MKLIB) $(LIBOUT)$(TARGET) blas.$(OBJSUFFIX)
	@echo Deleting blas.$(OBJSUFFIX)
	@$(RM) blas.$(OBJSUFFIX)
	@echo "Finished BLAS library compilation."

$(objdir)/liblapack.$(LIBSUFFIX) : lapack/lapack.fpp
	@echo Building LAPACK library
	@test -d $(objdir) || $(MKDIR) $(objdir)
	@$(SET_NOGLOB) $(PERL) -w $(scriptdir)/filepp.pl -w \
           -I./lapack -M$(scriptdir) \
           -m literal.pm -m tonto.pm \
           -DTONTO_VERSION="'$(VERSION)'" \
           -DTONTO_PLATFORM="'$(PLATFORM_ID)'" \
           -DTONTO_BUILD_DATE="'$(BUILD_DATE)'" \
           -DINT_KIND="$(INT_KIND)" \
           -DBIN_KIND="$(BIN_KIND)" \
           -DREAL_KIND="$(REAL_KIND)" \
           -DCPX_KIND="$(CPX_KIND)" \
           -D$(PLATFORM_ID_) \
           -o lapack/lapack.$(FSUFFIX) \
           $(DEFS) lapack/lapack.fpp
	$(FC) $(FOPTNS) $(F77) $(FOUTOBJ)lapack.$(OBJSUFFIX) lapack/lapack.$(FSUFFIX)
	@$(RM) lapack/lapack.$(FSUFFIX)
	$(MKLIB) $(LIBOUT)$(TARGET) lapack.$(OBJSUFFIX)
	@echo Deleting lapack.$(OBJSUFFIX)
	@$(RM) lapack.$(OBJSUFFIX)
	@echo "Finished LAPACK library compilation."

#------------------------------------------------------------------------------
# >>> Regression tests
#
# "make tests" runs through the test jobs and makes sure that the results are
# the same as those given in the reference outputs.
#------------------------------------------------------------------------------

tests :
	@echo Running test suite
	@$(PERL) -w $(scriptdir)/perform_tests.pl \
           -testdir $(testdir) \
           -program $(bindir)/run_molecule.$(PROGSUFFIX) \
           -cmp "$(PERL) -w $(scriptdir)/compare_output.pl"

tests_for_CX :
	@echo Running CrystalExplorer test suite
	@$(PERL) -w $(scriptdir)/perform_tests.pl \
           -testdir ./tests_for_CX \
           -program $(bindir)/run_molecule.$(PROGSUFFIX) \
           -cmp "$(PERL) -w $(scriptdir)/compare_output.pl"

#------------------------------------------------------------------------------
# >>> Lazy targets.
#------------------------------------------------------------------------------

%.$(PROGSUFFIX) :
	@$(SET_NOGLOB) $(MAKE) $(bindir)/$(*F).$(PROGSUFFIX)

%.$(OBJSUFFIX) :
	@$(SET_NOGLOB) $(MAKE) $(objdir)/$(*F).$(OBJSUFFIX)

