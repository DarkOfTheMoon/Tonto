Welcome to Tonto!

---------------
Compiling Tonto
---------------

To compile Tonto, type :

   perl -w scripts/Makefile.pl
   make

If you want a specific compiler, type:

   perl -w scripts/Makefile.pl -fc=<insert-your-compiler-here>
   make

where you should replace <insert-your-comipler-here> with
the command for your specific compiler.

-------------------------------------
Where to get a free fortran compiler?
-------------------------------------

If you don't have a fortran compiler you can use gfortran.
Download from http://gcc.gnu.org/wiki/GFortranBinaries.
Or try also: http://quatramaran.ens.fr/~coudert/gfortran/

You can use tonto on windows if you install cygwin, the 
unix-like environment for windows.

----------------------
Running the test suite
----------------------

To run the test suite, type:

   make tests

---------------------------------
Where to find example input files
---------------------------------

Look in the directories in the tests/ directory for example
input files.  The example inputs are called "stdin" and the
example outputs are called "stdout"

----------------
How to run a job
----------------

Make an input file called "stdin", or copy one of those you
like from the directories within the tests/ directory, then
type:

   ./<your-compiler-on-your-OS>/<build>/run_molecule.exe

where:

   <your-compiler-on-your-OS> is the directory appropriate
   for your platform, which is created automatically when you 
   compile Tonto, and where 
   
   <build> is one of "fast", "debug" or "custom" depending on 
   what kind of executable has been set in the build instructions 
   (normally it is "fast").

Note:

   <your-compiler-on-your-OS>/ is called the platform specific
   directory, and 
   
   <build>/ is the build subfolder for your specific platform. 
   You can have three different kinds of builds for
   each platform: "fast", "debug", or "custom". See below.

-------------------------------
Vim, ctags, and code completion
-------------------------------

To get the documentation use vim!

Copy the supplied .vimrc and .vim directories in tonto/ to
your home directory. Start up vim or gvim on one of the
files in foofiles/ . And enjoy.  To unfold routines type
"zo", to close type "zc". Type F2 to get a side bar which
summarises the modeul. Click in the sidebar to go to the
routine you want (gvim only). F2 to get rid of the side bar.

If you get exuberant ctags (google it), copy the supplied
.ctags file into your home directory, then type:

   ctags *

Then in vim type "g Ctrl-]" on top of the routine you want
to go to --- you'll see the documentation(s). Type "Ctrl-t"
to go back. Wonderful!

Finally, for code completion when editing a .foo file
with vim, set up the ctags as above and type:

   :FooCompleteOn
   
Now try inserting a dot after a previously declared object 
and while still in vim insert mode, after the dot type

   Ctrl-X Ctrl-O

You will see a popup menu with the available object 
methods.  Type a few more characters to narrow down the 
choice. The type of the object is labelled as an 
attribute (a), subroutine (s), function (f), type (t),
macro (m), or global variable (g). For more details type 

   :help completion 
   
in vim and look at omni completion.

-----------------------------
Problems, bugs, contributions
-----------------------------

Let me know at 

   dylan@theochem.uwa.edu.au

If you can fix your own bugs, let me know too, and you can
easily check the fixes back into sourceforge. 

-----------------------------
Compiling compact executables
-----------------------------

Executables in tonto tend to be big. If you executable is
too big, you can remove all dead code from your application
by typing. 

   make compactify
   make

Consider also using the -DNO_GENERIC_NAMES compile option.
See below.

-------------------------
Compiling custom versions
-------------------------

By default, normally, a nearly production version of Tonto 
is compiled. This is called the "fast" version. 

You can also compile debug and custom versions of of Tonto
using the switches described for your platform in the 
platforms/ directory, in the file for <your-compiler-on-your-OS>. 

If you change $(FOPTNS) to one of: 

   $(FFAST), the executables will be placed in the fast/
   subdirectory of the platform-specific directory.

   $(FDEBUG), the executables will be placed in the debug/
   subdirectory of the platform-specific directory.

   $(FPROF), the executables will be placed in the custom/
   subdirectory of the platform-specific directory. You can
   also change the $(FPROF) to include your desired fortran
   compiler options.

There are also other kinds of compile options which control
the type of Fortran code which is generated. To access these
options you will have to add them to the $(DEFS) variable
in the platforms/<your-compiler-on-your-OS> compiler options
file.

A summary of switches which control the type of Fortran
generated is given below. You canm use multiple options if 
you want to:

-DMPI                        Parallel Tonto, using MPI.
                             Must specify your libraries
                             in the platforms file.

-DFLUSH                      Flush output to stdout.
                             Compiler must have flush().

-DNO_TONTO_SYSTEM_CALLS      No system checks, no parallel
                             calls

-DNO_TONTO_SYSTEM_CHECKS     No system checks, retain
                             parallel calls.  You must
                             still define MPI

-DNO_GENERIC_NAMES           Prepend module name to
                             routines.  May reduce compile
                             time by reducing namespace,
                             but will have nonstandard
                             routine names > 31 characters
                             long

-DUSE_ERROR_MANAGEMENT       Use die and warn, minimal
                             error checking (default)

-DUSE_PRECONDITIONS          Use routine preconditions.
                             More checking, but there will
                             be a perfomance hit. 
                             + USE_ERROR_MANAGEMENT     

-DUSE_CALL_STACK_MANAGEMENT  Tracks the call tree.
                             Good for tracking errors and
                             warnings. Big perfoamce hit. 
                             + USE_PRECONDITIONS

-DTRACK_MEMORY_LOCATIONS     Tracks all allocates and
                             deallocates, useful for
                             eliminating memory leaks.
                             Compiler must have loc()
                             pointer function.
                             + USE_CALL_STACK_MANAGEMENT

-DUSE_TIME_PROFILING         Time profile routines, not very
                             accurate
                             + BROKEN_PURE

-DBROKEN_PURE                Set if pure does not work; very
                             rare. Needed for time profiling
                             to allow IO

-DBROKEN_TYPE_INITIALIZATION Set if type initialisation fails

-DLANGUAGE_FORTRAN_90        + BROKEN_TYPE_INITIALIZATION      
                             + BROKEN_PURE

-DESSL                       Use ESSL math libraries
                             IBM only.

-DNO_CASE_OPTIONS            Removes informative error on
                             string-based case statements.
