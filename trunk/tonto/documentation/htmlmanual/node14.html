<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
  <META name="robots" content="noindex, nofollow">
  <TITLE>Actions performed by the foo preprocessor</TITLE>
  <LINK REL="previous" HREF="node13.html">
  <LINK REL="up" HREF="node12.html">
  <LINK REL="next" HREF="node15.html">
</HEAD>
<BODY BGCOLOR="#FFFBF0">
<!--Navigation Panel-->
<B> Up:</B> <A HREF="node12.html">The foo preprocessor language</A>
<B> Previous:</B> <A HREF="node13.html">Formal rules for valid</A>
<BR>
<BR>
<!--End of Navigation Panel-->

<H2>Actions performed by the <TT>foo</TT> preprocessor</H2>

<P>
The actions of the <TT>foo</TT> preprocessor are defined below.

<P>
<UL>
<P>
<LI>
The name of every routine declaration appearing in a <TT>foo</TT> module 
is changed by inserting the name of the module and an underscore 
before the routine name.

<P>
<BLOCKQUOTE>
Routine <TT>create</TT> in module <TT>STR</TT> is changed to the Fortran95 routine name <TT>STR_create</TT>.
</BLOCKQUOTE>
<P>
<LI>
A dummy variable <TT>self</TT> is automatically inserted as the first 
argument of every <TT>foo</TT> routine.

<P>
<LI>
Every routine declaration line appearing in a <TT>foo</TT> module <TT>M</TT> which does not
contain the string <TT>create</TT> or <TT>destroy</TT> as part of
its name has appended a type declaration of the form <TT>M :: self</TT>.

<P>
<BLOCKQUOTE>
The following transformation is performed by <TT>foo</TT> in module <TT>INT</TT>
<PRE>
factorial result(res) --&gt; 
     function INT_factorial(self) result(res); INT :: self
</PRE></BLOCKQUOTE>
<P>
<LI>
Every routine declaration line appearing in a <TT>foo</TT> module <TT>M</TT> which 
contains the string <TT>create</TT> or <TT>destroy</TT> as part of
its name has appended a type declaration of the form <TT>M, PTR :: self</TT>,
where <TT>PTR</TT> is a preprocessor macro which stands for <TT>pointer</TT>.

<P>
<BLOCKQUOTE>
The following transformation is performed by <TT>foo</TT> in module <TT>MAT</TT>
<PRE>
create(dim1,dim2) --&gt; 
     function MAT_create(self,dim1,dim2); MAT, PTR :: self
</PRE></BLOCKQUOTE>
<P>
<LI>
If <TT>x</TT>, <TT>y</TT>, ... , <TT>z</TT> stand for allowed Fortran95 names then
and <TT>x</TT> is the name of a record of the host module derived type,
the following transformation is performed:
<PRE>
.x(y, ... , z)  --&gt;  self%x(w,y, ... , z)
</PRE>If <TT>x</TT> is <EM>not</EM> the name of a record of the host module derived type,
the following transformation is performed if <TT>.x(y, ... , z)</TT> is <EM>not</EM>
part of an expression:
<PRE>
.x(y, ... , z)  --&gt;  call _x(self,y, ... , z)
</PRE>If <TT>x</TT> is <EM>not</EM> the name of a record of the host module derived type,
the following transformation is performed if <TT>.x(y, ... , z)</TT> <EM>is</EM> part of
an expression:
<PRE>
.x(y, ... , z)  --&gt;  _x(self,y, ... , z)
</PRE>The definition of the derived type (if any) is searched for in 
module <TT>TYPES</TT> in file <TT>types.foo</TT>.

<P>
<BLOCKQUOTE>
The following transformations are performed within module <TT>SHELL</TT>.
<PRE>
.ex(.n_cc)     --&gt;  self%ex(self%n_cc)
.unnormalize   --&gt;  call _unnormalize(self)
str =  .l_chr  --&gt;  str = _l_chr(self)
</PRE></BLOCKQUOTE>
<P>
<LI>
If <TT>x</TT>, <TT>y</TT>, ... , <TT>z</TT> stand for allowed Fortran95 names 
and <TT>w</TT> is a psuedo-name constructed from characters
described by the regular expression
<PRE>
   [a-zA-Z_][a-zA-Z_0-9\%():,+-]*
</PRE>then the following transformation is performed if <TT>w.x(y, ... , z)</TT> is <EM>not</EM>
part of an expression
<PRE>
w.x(y, ... , z)  --&gt;  call _x(w,y, ... , z)
</PRE>The following transformation is performed if <TT>w.x(y, ... , z)</TT> <EM>is</EM>
part of an expression
<PRE>
w.x(y, ... , z)  --&gt;  _x(w,y, ... , z)
</PRE>
<P>
<BLOCKQUOTE>
Warning: Due to the definition of the argument <TT>w</TT>, it does not stand for
the indended variable name. See the examples below.
</BLOCKQUOTE>
<P>
<BLOCKQUOTE>
The following transformations are performed by <TT>foo</TT>
<PRE>
e = shell.l*(shell.l+1)/2  --&gt;  e = _l(shell)*(_l(shell)+1)/2
e = shell.ex               --&gt;  e = _ex(shell)
e = shell.ex(n)            --&gt;  e = _ex(shell,n)
e = shell.ex(shell.n_cc)   --&gt;  e = _ex(shell,shell.n_cc)  
                           --&gt;  e = _n_cc(_ex(shell,shell)) 
e = shell.ex( shell.n_cc)  --&gt;  e = _ex(shell, shell.n_cc) 
                           --&gt;  e = _ex(shell, _n_cc(shell)) 
shell.unnormalize          --&gt;  call _unnormalize(shell)
sh%ex(b+1:b+nb).put        --&gt;  call _put(sh%ex(b+1:b+nb))
</PRE>Note that the extra space is important for the interpretation of the argument <TT>w</TT>.
In practice, the routine <TT>_ex(shell)</TT> would return <TT>shell%ex</TT>, so that the
dot notation <TT>.</TT> can be viewed as a synonym for the structure separator <TT>%</TT>.
They are not the same, however, since the internal type structure of the variable
<TT>shell</TT> may change at some later date so that component <TT>shell%ex</TT> is no longer present.
A routine <TT>_ex(shell)</TT> can always be arranged to exist to simulate
the missing structure component. This greatly facilitates the maintainability
of the code. It should be kept in mind for compute intensive routines
that the <TT>%</TT> notation is more efficient that the dot notation.
</BLOCKQUOTE>
<P>
<LI>
If the same routine name <TT>f</TT> is used in a <TT>foo</TT> module <TT>M</TT> (k+1) times, 
then the corresponding Fortran95 names of the routines are 
<TT>M_f</TT>, <TT>M_f_1</TT>, ..., <TT>M_f_k</TT>.

<P>
<LI>
The <TT>end</TT> keyword may be substituted for <TT>end do</TT>, <TT>end if</TT>,
<TT>end subroutine</TT>, <TT>end function</TT>, <TT>end module</TT>, <TT>end select</TT>
<TT>end type</TT>, <TT>end interface</TT>.

<P>
<BLOCKQUOTE>
The following transformation is performed by <TT>foo</TT> :
<PRE>
do i = 1,.n_shell               --&gt;  do i = 1,_n_shell(self)
   n_bf = n_bf + shell(i).n_bf  --&gt;     n_bf = n_bf + _n_bf(shell(i))
end                             --&gt;  end do
</PRE></BLOCKQUOTE>
<P>
<LI>
In module <TT>M</TT>, <TT>foo</TT> performs the following transformation for recursive functions:
<PRE>
recursive :: f(y, ... , z) result(w) --&gt;
        recursive function f(self,y, ... , z) result(w); M :: self
</PRE>There is a similar transformation for recursive procedures.
<TT>pure</TT> and <TT>elemental</TT> routines are transformed similarly, 
except that the declaration for <TT>self</TT> includes the <TT>intent(in)</TT> attribute.

<P>
<LI>
A generic interface file <TT>m.int</TT> is automatically generated for module <TT>M</TT>, 
where <TT>m</TT> is the lower-case name of the module. The generic name used
for every module is the same as the <TT>foo</TT> name with un underscore prepended.

<P>
<BLOCKQUOTE>
It is the responsibility of the programmer to ensure that the
module interface file in included.
</BLOCKQUOTE>
<P>
<LI>
In a <TT>foo</TT> module <TT>M</TT>, explicit interfaces are defined and translated as follows:
<PRE>
interface f         --&gt;  interface _f
   fa, fb, fc, ...  --&gt;  module procedure M_fa, M_fb, M_fc, ...
end                 --&gt;  end interface
</PRE>
<P>
</UL>
<P>
<HR>
</BODY>
</HTML>
