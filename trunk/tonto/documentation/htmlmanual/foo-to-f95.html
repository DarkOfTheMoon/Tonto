<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>What foo does to produce Fortran95 code</title><link rel="stylesheet" href="../tonto.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"><link rel="home" href="index.html" title="Tonto"><link rel="up" href="foo-chap.html" title="Chapter 11. The foo preprocessor"><link rel="previous" href="foo-rules.html" title="Rules for valid foo preprocessor code"><link rel="next" href="foo-modules.html" title="Chapter 12. Writing foo modules for TONTO"><meta name="robots" content="noindex,nofollow"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left"><a accesskey="p" href="foo-rules.html">Prev</a> </td><th width="60%" align="center"></th><td width="20%" align="right"> <a accesskey="n" href="foo-modules.html">Next</a></td></tr></table><IMG SRC="../hr.png" HEIGHT="10" WIDTH="100%"><BR></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="foo-to-f95"></a>What <span class="emphasis"><em>foo</em></span> does to produce Fortran95 code</h2></div></div><div></div></div><P>The actual text transformations that are performed by the <span class="emphasis"><em>foo</em></span>
preprocessor are now described.</P><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="automatic-functions"></a>Automatic <tt class="literal">function</tt> and <tt class="literal">subroutine</tt>
detection</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>The keyword <tt class="literal">function</tt> is automatically
prepended to every <span class="emphasis"><em>foo</em></span> routine name contained in a module or program which
uses the <tt class="literal">result</tt> syntax.  Otherwise the routine is assumed to
be a subroutine, and the <tt class="literal">subroutine</tt> keyword is
prepended.</P></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="self-arguments"></a>Automatic insertion of first argument to a routine</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>A dummy variable <tt class="literal">self</tt> is automatically
inserted as the first argument of every <span class="emphasis"><em>foo</em></span> routine.</P></li><li><P>Every <span class="emphasis"><em>foo</em></span> routine contained in a module
<tt class="literal">XXXX</tt> which is not deemed to be a functional or subroutinal
(see <a href="foo-to-f95.html#functionals-subroutinals" title="Functionals and subroutinals">the section called &#8220;Functionals and subroutinals&#8221;</a>) has appended a type declaration
of the form <tt class="literal">XXXX :: self</tt>.</P><div class="informalexample"><P>The following transformation is performed by <span class="emphasis"><em>foo</em></span> on routine
<tt class="literal">arcsin</tt> in module <tt class="literal">REAL</tt>
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
arcsin result(res)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
function arcsin(self) result(res); REAL :: self
</pre></td></tr></table></td></tr></tbody></table></div>
</P></div></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="end-completion"></a>Automatic <tt class="literal">end</tt> keyword completion</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>The <tt class="literal">end</tt> keyword may be substituted for
<tt class="literal">end do</tt>, <tt class="literal">end if</tt>, <tt class="literal">end
subroutine</tt>, <tt class="literal">end function</tt>, <tt class="literal">end
module</tt>, <tt class="literal">end select</tt> <tt class="literal">end type</tt>,
<tt class="literal">end interface</tt>.</P><div class="informalexample"><P>The following transformation is performed by <span class="emphasis"><em>foo</em></span> :
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
do i = 1,.n_shell
   n_bf = n_bf + shell(i).n_bf
end
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
do i = 1,self%n_shell
   n_bf = n_bf + n_bf_(shell(i))
end do
</pre></td></tr></table></td></tr></tbody></table></div>
</P></div></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dot-notation"></a>Dot notation</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>In module <tt class="literal">XXXX</tt>, if <tt class="literal">x</tt>,
<tt class="literal">y</tt>, <tt class="literal">...</tt>, <tt class="literal">z</tt> stand for
allowed Fortran95 names, and if <tt class="literal">x</tt> is the name of a record of
the derived type <tt class="literal">xxxx_type</tt> used in that module, and defined
in file <tt class="literal">types.foo</tt>, then the following transformation is
performed:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
.x(y, ... , z)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
self%x(y, ... , z)
</pre></td></tr></table></td></tr></tbody></table></div>
If <tt class="literal">x</tt> is <span class="emphasis"><em>not</em></span> the name of a record of the
derived type used in the module, and if <tt class="literal">.x(y, ... , z)</tt> is
<span class="emphasis"><em>not</em></span> part of an expression, then following transformation is
performed:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
.x(y, ... , z)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
call x_(self,y, ... , z)
</pre></td></tr></table></td></tr></tbody></table></div>
If <tt class="literal">x</tt> is <span class="emphasis"><em>not</em></span> the name of a record of the
derived type used in the module, and if <tt class="literal">.x(y, ... , z)</tt>
<span class="emphasis"><em>is</em></span> part of an expression, then the following transformation
is performed:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
.x(y, ... , z)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
x_(self,y, ... , z)
</pre></td></tr></table></td></tr></tbody></table></div>
<div class="informalexample"><P>Within module <tt class="literal">SHELL</tt>, the following transformation is
performed on <tt class="literal">.ex</tt> and <tt class="literal">.n_cc</tt>, since
<tt class="literal">ex</tt> and <tt class="literal">n_cc</tt> are both records of derived
type <tt class="literal">shell_type</tt>:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
.ex(.n_cc)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
self%ex(self%n_cc)
</pre></td></tr></table></td></tr></tbody></table></div>
The following transformations are performed on <tt class="literal">.unnormalise</tt>
and <tt class="literal">.l_chr</tt> since they are not records of derived
<tt class="literal">shell_type</tt>:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
.unnormalize
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
call unnormalize_(self)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
str = .l_chr
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
str = l_chr_(self)
</pre></td></tr></table></td></tr></tbody></table></div>
</P></div></P></li><li><P>If <tt class="literal">x</tt>, <tt class="literal">y</tt>,
<tt class="literal">...</tt>, <tt class="literal">z</tt> stand for allowed Fortran95 names,
and if <tt class="literal">w</tt> is the name of a Fortran variable, and if
<tt class="literal">w.x(y, ... , z)</tt> is <span class="emphasis"><em>not</em></span> part of an
expression, and if <tt class="literal">x</tt> is a type component of the variable
<tt class="literal">w</tt> then following transformation is performed:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
w.x(y, ... , z)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
w%x(y, ... , z)
</pre></td></tr></table></td></tr></tbody></table></div>
If <tt class="literal">w.x(y, ... , z)</tt> is <span class="emphasis"><em>not</em></span> part of an
expression, and If <tt class="literal">x</tt> is <span class="emphasis"><em>not</em></span> a type
component of the variable <tt class="literal">w</tt> the following transformation is
performed:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
w.x(y, ... , z)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
call x_(w,y, ... , z)
</pre></td></tr></table></td></tr></tbody></table></div>
If <tt class="literal">w.x(y, ... , z)</tt> <span class="emphasis"><em>is</em></span> part of an
expression, then the following and if <tt class="literal">x</tt> is a type component
of the variable <tt class="literal">w</tt> then following transformation is performed:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
w.x(y, ... , z)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
w%x(y, ... , z)
</pre></td></tr></table></td></tr></tbody></table></div>
If <tt class="literal">w.x(y, ... , z)</tt> <span class="emphasis"><em>is</em></span> part of an
expression, then the following and if <tt class="literal">x</tt> is
<span class="emphasis"><em>not</em></span> a type component of the variable <tt class="literal">w</tt>
then following transformation is performed:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
w.x(y, ... , z)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
x_(w,y, ... , z)
</pre></td></tr></table></td></tr></tbody></table></div>

<div class="informalexample"><P>
The following transformations are performed by <span class="emphasis"><em>foo</em></span> in module
<tt class="literal">SHELL</tt>:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
e = shell.l*(shell.l+1)/2
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
e = shell%l*(shell%l+1)/2
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
e = shell.ex
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
e = shell%ex
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
e = shell.ex(n)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
e = shell%ex(n)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
shell.unnormalize
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
call unnormalize_(shell)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
sh.ex(b+1:b+nb).put
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
call put_(sh%ex(b+1:b+nb))
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
e = shell.ex(shell.n_cc)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
e = shell%ex(shell%n_cc)
</pre></td></tr></table></td></tr></tbody></table></div>
</P></div>
<div class="informalexample"><P>
The dot notation <tt class="literal">.</tt> can be viewed as a synonym for the
structure separator <tt class="literal">%</tt>.  They are not the same, however, since
the internal type structure of the variable <tt class="literal">shell</tt> may change
at some later date so that component <tt class="literal">shell%ex</tt> is no longer
present.  A routine <tt class="literal">ex_(shell)</tt> can always be arranged to
exist to simulate the missing structure component. This greatly facilitates the
maintainability of the code supposing that the internal structure of the type
changes. However, it should be kept in mind for compute intensive routines that
the <tt class="literal">%</tt> notation is more efficient than a routine call.
</P></div></P></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="automatic-overloading"></a>Automatic overloading and interface files</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>A generic interface file <tt class="literal">xxxx.int</tt> is
automatically generated for module <tt class="literal">XXXX</tt>, The generic name
used for every routine <tt class="literal">f</tt> in the module is
<tt class="literal">f_</tt>.</P></li><li><P>If the same routine name <tt class="literal">f</tt> appears in a
module or program <tt class="literal">(k+1)</tt> times, then <span class="emphasis"><em>foo</em></span> changes these names
into the Fortran95 names <tt class="literal">f</tt>, <tt class="literal">f_1</tt>,
<tt class="literal">...</tt>, <tt class="literal">f_k</tt>.

<div class="informalexample"><P>
The following transformation is performed by <span class="emphasis"><em>foo</em></span> on the overloaded routine
names <tt class="literal">read</tt> in module <tt class="literal">ARCHIVE</tt>. Both
routines are called by the single generic name <tt class="literal">read_</tt>.
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
read(item,kind)
   REALVEC :: item
   ...
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
subroutine read(self,item,kind); ARCHIVE :: self
   REALVEC :: item
   ...
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
read(item,kind)
   CPXVEC :: item
   ...
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
subroutine read(self,item,kind); ARCHIVE :: self
   CPXVEC :: item
   ...
</pre></td></tr></table></td></tr></tbody></table></div>
</P></div></P></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="explicit-overloading"></a>Explicit overloading</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>The <tt class="literal">module procedure</tt> keyword is automatically
inserted within any explicit generic interface definition appearing in a module.

<div class="informalexample"><P>
The following transformation is performed by <span class="emphasis"><em>foo</em></span> :
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
interface f
   fa, fb, fc, ...
end
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
interface f_
   module procedure fa, fb, fc, ...
end interface
</pre></td></tr></table></td></tr></tbody></table></div>
</P></div>
</P></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="function-attributes"></a>New syntax for <tt class="literal">recursive</tt>, <tt class="literal">pure</tt> and
<tt class="literal">elemental</tt> routines</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>If the string <tt class="literal">[recursive]</tt> appears at the end
of the line where the routine name appears, the routine is deemed recursive, and
the keyword <tt class="literal">recursive</tt> is placed before the keyword
<tt class="literal">function</tt> or <tt class="literal">subroutine</tt> in the emitted
Fortran95 code.</P><div class="informalexample"><P>In module <tt class="literal">XXXX</tt>, <span class="emphasis"><em>foo</em></span> performs the following
transformation on the recursive routine shown below:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
f(y, ... , z) result(w) [recursive]
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
recursive function f(self,y, ... , z) result(w); XXXX :: self
</pre></td></tr></table></td></tr></tbody></table></div>
</P></div></li><li><P>If the string <tt class="literal">[pure]</tt> appears at the end of
the line where the routine name appears, the routine is deemed conditionally
pure, and the keyword <tt class="literal">PURE</tt> is placed before the keyword
<tt class="literal">function</tt> or <tt class="literal">subroutine</tt> in the emitted
Fortran95 code. The attribute <tt class="literal">intent(in)</tt> is also added to the
first argument <tt class="literal">self</tt>.</P><div class="informalexample"><P>A conditionally pure routine is one that can be declared
<tt class="literal">pure</tt> or not when the routine is compiled. In this way, write
statements may easily be placed within the routines, and later removed, for
debugging purposes.
</P></div></li><li><P>If the string <tt class="literal">[PURE]</tt> appears at the end of
the line where the routine name appears, the routine is deemed unconditionally
pure, and the keyword <tt class="literal">pure</tt> is placed before the keyword
<tt class="literal">function</tt> or <tt class="literal">subroutine</tt> in the emitted
Fortran95 code. The attribute <tt class="literal">intent(in)</tt> is also added to the
first argument <tt class="literal">self</tt>.

<div class="informalexample"><P>An unconditionally <tt class="literal">pure</tt> routine is one that must always
<tt class="literal">pure</tt> at compile time. This may be required, for example, for
routines which are used in the specification part of a variable
declaration.</P></div>
</P></li><li><P>If the string <tt class="literal">[elemental]</tt> appears at the end
of the line where the routine name appears, the routine is deemed conditionally
elemental, and the keyword <tt class="literal">ELEMENTAL</tt> is placed before the
keyword <tt class="literal">function</tt> or <tt class="literal">subroutine</tt> in the
emitted Fortran95 code. The attribute <tt class="literal">intent(in)</tt> is also
added to the first argument <tt class="literal">self</tt>.</P></li><li><P>If the string <tt class="literal">[ELEMENTAL]</tt> appears at the end
of the line where the routine name appears, the routine is deemed
unconditionally elemental, and the keyword <tt class="literal">elemental</tt> is
placed before the keyword <tt class="literal">function</tt> or
<tt class="literal">subroutine</tt> in the emitted Fortran95 code. The attribute
<tt class="literal">intent(in)</tt> is also added to the first argument
<tt class="literal">self</tt>.  In module <tt class="literal">XXXX</tt>, <span class="emphasis"><em>foo</em></span> performs the
following transformation on the recursive routine shown below:</P><div class="informalexample"><P>In module <tt class="literal">XXXX</tt>, <span class="emphasis"><em>foo</em></span> performs the following
transformation on the elemental routine shown below:
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
f(y, ... , z) result(w) [elemental]
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
elemental function f(self,y, ... , z) result(w); XXXX, IN :: self
</pre></td></tr></table></td></tr></tbody></table></div>
The macro <tt class="literal">IN</tt>, which stands for <tt class="literal">intent(in)</tt>, is also added 
as an attribute in the declaration for <tt class="literal">self</tt>.</P></div></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="functionals-subroutinals"></a>Functionals and subroutinals</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>In a module <tt class="literal">XXXX</tt>, if the string
<tt class="literal">[functional]</tt> appears at the end of the line where a function
name appears, the function is deemed to be a functional, meaning that its first
argument <tt class="literal">self</tt> is a routine, and the automatic declaration
<tt class="literal">XXXX :: self</tt> is suppressed.</P></li><li><P>In a module <tt class="literal">XXXX</tt>, if the string
<tt class="literal">[subroutinal]</tt> appears at the end of the line where a
subroutine name appears, the subroutine is deemed to be a subroutinal, meaning
that its first argument <tt class="literal">self</tt> is a routine, and the automatic
declaration <tt class="literal">XXXX :: self</tt> is suppressed.</P><div class="informalexample"><P>The reason for declaring a functional or subroutinal explicitly is that
the automatic declaration of the first argument, <tt class="literal">self</tt>, must
be suppressed, in order that it does not conflict with the required explicit
interface for the routine <tt class="literal">self</tt>. In addition, the intention of
the routine is made clearer.</P></div><div class="informalexample"><P>In module REAL, <span class="emphasis"><em>foo</em></span> performs the following transformation on the
functional shown below:</P><div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
integrate(self,a,b,accuracy) result(res) [recursive] [functional]
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
recursive function integrate(self,a,b,accuracy) result(res)
</pre></td></tr></table></td></tr></tbody></table></div><P>In addition, an explicit <tt class="literal">interface</tt> must be defined
for <tt class="literal">self</tt>, which is transformed as shown:</P><div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
      interface
         self(x) result(res)
            REAL :: x,res
         end
      end
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
   interface
      function self(x) result(res)
         REAL :: x,res
      end function
   end interface
</pre></td></tr></table></td></tr></tbody></table></div></div></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="error-management"></a>Preconditions, postconditions, and error management facilities</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>If the macro <tt class="literal">ENSURE(cond,"message")</tt>,
<tt class="literal">DIE_IF(cond,"message")</tt>, or
<tt class="literal">WARN_IF(cond,"message")</tt> appears in routine
<tt class="literal">f</tt> of module <tt class="literal">XXXX</tt>, where
<tt class="literal">cond</tt> stands for a logical expression and
<tt class="literal">message</tt> stands for the text of some error message, then <span class="emphasis"><em>foo</em></span>
will insert the name of the module and routine at the beginning of the error
message text, yielding the new error message text
<tt class="literal">"in XXXX:f ... message"</tt></P><div class="informalexample"><P>In routine <tt class="literal">read</tt> of module <tt class="literal">MOL</tt>, <span class="emphasis"><em>foo</em></span>
changes the precondition macro <tt class="literal">ENSURE</tt> as follows:</P><div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
ENSURE(word=="name","first keyword must be name")
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
ENSURE(word=="name","in MOL:read ... first keyword must be name")
</pre></td></tr></table></td></tr></tbody></table></div><P>If the &#8220;<span class="quote">first keyword is not name</span>&#8221;, i.e.
<tt class="literal">word/="name"</tt>, then the following error message is generated
by routine <tt class="literal">read</tt> in the output:
<table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
ERROR: in MOL:read ... first keywrord must be name
</pre></td></tr></table>
</P></div><div class="informalexample"><P>The macros <tt class="literal">ENSURE</tt>, <tt class="literal">DIE_IF</tt>, or
<tt class="literal">WARN_IF</tt> are commonly used to ensure that a specific set of
conditions hold before the start, or at the end of, a routine. In this way,
errors can be detected and handled at an early stage without propagation. They
are therefore called precondition or postconditon macros. 
</P></div></li><li><P>If the macro <tt class="literal">DIE("message")</tt> or
<tt class="literal">WARN("message")</tt> appears in routine <tt class="literal">f</tt> of
module <tt class="literal">XXXX</tt>, where <tt class="literal">message</tt> stands for the
text of some error message, then <span class="emphasis"><em>foo</em></span> will insert the name of the module and
routine at the beginning of the error message text, yielding the new error
message text <tt class="literal">"in XXXX:f ... message"</tt></P><div class="informalexample"><P>The macro <tt class="literal">DIE</tt> is used for graceful program termination.
The macro <tt class="literal">WARN</tt> is used to warn of an unusual, and most likely
erroneous situation.</P></div></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="memory-management"></a>Memory and call-stack management</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>If the string <tt class="literal">[leaky]</tt> appears at the end of
the line where the routine name appears, the routine is deemed to be leaky,
meaning that within the body of the routine more memory has been allocated than
deallocated.</P><div class="informalexample"><P>In module <tt class="literal">MOL</tt>, the <tt class="literal">read</tt> routine has
been deemed leaky:
<table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
read [leaky]
</pre></td></tr></table>
</P></div></li><li><P>Any routine with the string <tt class="literal">create</tt>, or
<tt class="literal">destroy</tt> as part of its name is automatically deemed to be
leaky.</P></li><li><P>For every routine <tt class="literal">f</tt> in module
<tt class="literal">XXXX</tt>, the macro <tt class="literal">STACK("XXXX:f")</tt> is
inserted before the first line of code which is not a precondition
macro.</P></li><li><P>For every routine <tt class="literal">f</tt> which is leaky or pure,
the macro <tt class="literal">UNSTACK</tt> is inserted before the <tt class="literal">end
function</tt> or <tt class="literal">end subroutine</tt> keywords in the last
line of the routine.</P></li><li><P>For every routine <tt class="literal">f</tt> which is not leaky or
pure, the macro <tt class="literal">CHECK</tt> is inserted before the first line of
code which is not a precondition macro.</P><div class="informalexample"><P>The macro <tt class="literal">STACK(X)</tt> stands for <tt class="literal">call
stack_(tonto,X)</tt>. <tt class="literal">tonto</tt> is a memory and call-stack
manager object used by TONTO. This routine call places the current routine
name <tt class="literal">X</tt> onto a call stack, which may later be used to print a
call-stack traceback in the event of controlled error. The routine call also
sets to zero a variable which is used to keep track of the memory used in this
routine.  The amount of memory used or released by dynamic allocation is
monitored in the <tt class="literal">tonto</tt> system variable.</P></div><div class="informalexample"><P>The macro <tt class="literal">UNSTACK</tt> stands for <tt class="literal">call
unstack_(tonto)</tt>. It removes the current routine name
<tt class="literal">X</tt> from the call stack.</P></div><div class="informalexample"><P>The macro <tt class="literal">CHECK</tt> stands for <tt class="literal">call
check_(tonto)</tt>. It removes the current routine name
<tt class="literal">X</tt> from the stack and checks if the routine has a memory leak
or not, by examining the memory usage variable for the routine.</P></div></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="template-routines"></a>Template routines</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>Sometimes the same operation can be performed on objects of
different types.  For example, the statement <tt class="literal">.create_copy(x)</tt>
might for example be referring to the creation of a copy of an atom, reflection,
or shellpair.  Apart from the declaration of the type of <tt class="literal">self</tt>
and <tt class="literal">x</tt>, the code might be identical in each module.  If this
is so, then it might be easier to use a template routine.</P><P>Since routine templates act on generic types, the template code is not put
into modules.  Instead, a new file extension, <tt class="literal">.get</tt>, is used
to signify the file to get the code from.  Examples of these files include
<tt class="literal">object.get</tt> for routines that act on any types,
<tt class="literal">mat.get</tt> for routines that act on matrices of any types, and
<tt class="literal">intrinsicvec.get</tt> for routines that act on vectors of
intrinsic types.  The template code is inserted into the current module by using
<tt class="literal">get_from()</tt> notation, for example,
<table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
routine_name(arguments) ::: get_from(object)
  ! Comment about routine.
  arguments declaration
end
</pre></td></tr></table>
The template code in the <tt class="literal">object.get</tt> file is similarly declared,
<table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
routine_name(arguments) ::: get_from(object)
  ! Comment about routine.
  arguments declaration
  actual routine contents
end
</pre></td></tr></table>
</P><P>It is important that the arguments are declared identically in the calling
module and in the template file, otherwise the preprocessor might not be able to
resolve the routine you wish to insert.  Attributes to the routine itself must
be identical, except for the get_from().  Similarly, any comments should also be
identical.  Note that these limitations are due to the preprocessor, and should
be lifted in a future version.  Only the type of the arguments should be
important.</P><P>It is common to have additional arguments to a routine of the type of
<tt class="literal">self</tt>, such as the above example of
<tt class="literal">create_copy(x)</tt>.  For this purpose the macro
<tt class="literal">SELF_TYPE</tt> refers to the type of self.  Another common
occurence for types that are arrays are arguments that are of the type of an
element of the array.  The macro <tt class="literal">ELEMENT_TYPE</tt> refers to this
type.</P><P>An Example:</P><P>Here a definition of the <tt class="literal">create_copy</tt> routine, in the
<tt class="literal">object.get</tt> file.
<table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
  create_copy(x) ::: [leaky]
  ! Create a copy of x
    x :: SELF_TYPE, IN
    .create
    .copy(x)
  end
</pre></td></tr></table>
The routine is then declared in any module by using
<table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
  create_copy(x) ::: get_from(OBJECT), [leaky]
  ! Create a copy of x
    x :: SELF_TYPE, IN
  end
</pre></td></tr></table>
As can be ascertained by this example, using routine templates is more
advantageous for long routines than short ones, at least in terms of code size.
The most useful aspect however is in the sense of algorithms, for example if one
wishes to change the algorithm used for sorting arrays.</P></li></ul></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="c-preprocessort"></a>C-preprocessor macros and type definitions</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><P>The following transformations are made by
<tt class="literal">foo</tt></P><P>
<div class="informaltable"><table width="100%" border="0"><colgroup><col><col><col></colgroup><tbody><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
STR
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
STR(STR_SIZE)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
BSTR
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
STR(BSTR_SIZE)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XVEC (for any X)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XVEC(:)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XMAT (for any X)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XMAT(:,:)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XMAT3 (for any X)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XMAT3(:,:,:)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XMAT4 (for any X)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XMAT4(:,:,:,:)
</pre></td></tr></table></td></tr><tr><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XMAT5 (for any X)
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
--&gt;
</pre></td></tr></table></td><td><table border="0" bgcolor="#E0E0E0"><tr><td><pre class="programlisting">
XMAT5(:,:,:,:,:)
</pre></td></tr></table></td></tr></tbody></table></div></P></li><li><P>The C preprocessor macros defined in the
<tt class="literal">macros</tt> file shall constitute part of the definition of the
<span class="emphasis"><em>foo</em></span> language.</P></li></ul></div></div></div><div class="navfooter"><IMG SRC="../hr.png" HEIGHT="10" WIDTH="100%"><BR><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="foo-rules.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="foo-chap.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="foo-modules.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Rules for valid foo preprocessor code </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 12. Writing foo modules for TONTO</td></tr></table></div></body></html>
