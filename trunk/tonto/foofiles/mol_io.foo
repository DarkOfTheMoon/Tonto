!-------------------------------------------------------------------------------
!
! MOL_io: these routines required by several modules in mol.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_IO

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use BUFFER
   use IVEC
   use VEC
   use MAT
   use OPVEC
   use OPMAT
   use TEXTFILE
   use ARCHIVE
   use VECDIIS
   use SHELL
   use SHELLVEC
   use BASIS
   use BASISVEC
   use ATOM
   use ATOMVEC
   use POINTGROUP
   use SPACEGROUP
   use CRYSTAL
   use PLOTGRID
   use DFTGRID
   use SCFDATA
   use MOL_COMMON
   use MOL_CRYSTAL

   implicit none         

#  include "macros"
#  include "mol_io.int"

contains

!  ************
!  Read methods
!  ************

   read_multiplicity
   ! Read in the spin multiplicity
      .in.read(.mult)
      ENSURE(.mult/=0,"cannot have zero multiplicity")
   end

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      .in.read(.gauge_origin)
      .delete_gauge_integrals
   end

   delete_gauge_integrals
   ! Delete all integral files which depend on the gauge origin. 
   ! This is required whenever the gauge origin is changed.
      ARCHIVE :: archive
      archive.set(.name,"Lx_matrix"); archive.delete
      archive.set(.name,"Ly_matrix"); archive.delete
      archive.set(.name,"Lz_matrix"); archive.delete
   end

   read_plotgrid [leaky]
   ! Read in the plot grid data
      if ( .crystal.destroyed) then
        .grid.read(.in,.atom)
      else if ( .crystal.created) then
        .grid.read(.in,.atom,.crystal)
      end
   end

   read_dftgrid [leaky]
   ! Read in the DFT grid data
      .dftgrid.destroy
      .dftgrid.create
      .dftgrid.read(.in)
      .dftgrid.archive.set_root_name(.name)
   end

   read_crystal [leaky]
   ! Read in the crystal data
      .crystal.destroy
      .crystal.create
      .crystal.read(.in)
      if (associated(.atom)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end

   read_pointgroup [leaky]
   ! Read in the pointgroup data
      .pointgroup.destroy
      .pointgroup.create
      .pointgroup.read(.in)
   end

   read_scfdata [leaky] 
   ! Read in the scf data
      .scfdata.destroy
      .scfdata.create
      .scfdata.read(.in)
      if (.scfdata.using_diis) then
      .scfdata.diis.set_archive_root_name(.name) 
      .scfdata.diis.set_archive_name("fock_matrix,DIIS")
      end
   end

   read_atoms [leaky]
   ! Read in the atom list information
      .atom.read
      DIE_IF(.atom.bases_are_part_labeled,"some empty basis labels exist")
      .resolve_basis_labels
      .set_atom_info
      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_reduced_group_data(.atom)
      end
   end
  
!  read_basis_labels
!  ! Read in a list of basis set labels for every atom in the molecule
!  ! If a basis set is defined, all atoms must have a resolved basis set
!     ENSURE( .atom.created,"no atoms in atom list")
!     .atom.read_basis_labels
!     .resolve_basis_labels
!  end

   read_basis_sets [leaky]
   ! Read in a list of atomic basis sets for the molecule
      .basis.read
      .resolve_basis_labels
   end

!  read_thermal_tensors
!  ! Read in the thermal tensor data for all atoms
!     .atom.read_thermal_tensors(.crystal)
!  end

   read_thermal_smearing_model
   ! Read an allowed thermal smearing model for Fourier transform calculations
      INT :: model
      .in.read(model)
      ENSURE(model>=0 AND model<=3, "unknown thermal smearing model")
      .thermal_smearing_model = model 
   end

   read_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g. "restricted".
   ! For use with TONTO generated archives.
      STR :: name,kind
      ARCHIVE :: archive
      ENSURE(.in.buffer.n_items==3, "must specify an archive and a kind")
      .in.read(name)
      .in.read(kind)
      .out.text("reading archive : " // trim(name))
      archive.set(.name,name,kind)
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals)
         case ("density_matrix");     archive.read(.density_matrix)
         case ("natural_orbitals");   archive.read(.natural_orbitals)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("covalent_orbitals");  archive.read(.natural_orbitals)
         case ("ionic_orbitals");     archive.read(.natural_orbitals)
         case default;                DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_ascii_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g. "restricted".
   ! If required, the input order may be specified as "by_row" (default) or "by_column".
      STR :: name,kind,order
      ARCHIVE :: archive
      ENSURE(.in.buffer.n_items==3, "must specify an archive and a kind")
      .in.read(name)
      .in.read(kind)
      order = "by_row"
      if ( .in.buffer.not_exhausted) .in.read(order)
      archive.set(.name,name,kind,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.read(.density_matrix,order=order)
         case ("natural_orbitals");   archive.read(.natural_orbitals,order=order)
         case ("occupation");         archive.read(.occupation)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("fock_matrix");        .fock_matrix.create("restricted")
                                      archive.read(.fock_matrix,order=order)
         case default; DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_g94_checkpoint_file [leaky]
   ! Read a g94 checkpoint file (after fchk conversion to ASCII) into TONTO
      STR :: name
      TEXTFILE, PTR :: chkfile
      IVEC, PTR :: shell_l, nps, shell_to_atom, e_atom
      IVEC, PTR :: tmp_nps, tmp_sta, tmp_shells
      VEC, PTR :: tmp_pe, tmp_cc
      VEC, PTR :: pe, cc, extra_cc, temp_vec
      MAT, PTR :: temp_mat
      OPMAT, PTR :: temp_spin, temp_total
      INT :: c, t, a, s, u, m1, m2, prims, i,n_basis
      INT :: n_shell, n_comp, n_cc
      BIN :: same
      BASIS, PTR :: basis
      ARCHIVE :: archive
      if ( .basis.created) .basis.destroy
      if ( .atom.created)  .atom.destroy
      name = trim(.name)       ! not name.fchk, so have to rename checkpoint file
      if ( .in.buffer.not_exhausted) .in.read(name)
      chkfile.create(name)
      chkfile.open_for_read
      chkfile.read_line
      chkfile.look_for("Number of atoms")
      chkfile.move_to_line_item(5); chkfile.read( .n_atom)
      chkfile.look_for("Charge")
      chkfile.move_to_line_item(3); chkfile.read( .charge)
      chkfile.look_for("Multiplicity")
      chkfile.move_to_line_item(3); chkfile.read( .mult)
      chkfile.look_for("Number of electrons")
      chkfile.move_to_line_item(5); chkfile.read( .n_e)
      chkfile.look_for("Number of alpha electrons")
      chkfile.move_to_line_item(6); chkfile.read( .n_a)
      chkfile.look_for("Number of beta electrons")
      chkfile.move_to_line_item(6); chkfile.read( .n_b)
      chkfile.look_for("Number of basis functions")
      chkfile.move_to_line_item(6); chkfile.read( .n_bf)
      chkfile.look_for("Number of contracted shells") 
      chkfile.move_to_line_item(6); chkfile.read( .n_shell)
      chkfile.look_for("Number of primitive shells")
      chkfile.move_to_line_item(6); chkfile.read( .n_prim)
      chkfile.look_for("Total Energy")
      chkfile.move_to_line_item(4)
      .scfdata.create; chkfile.read_dbl( .scfdata.energy )
      chkfile.look_for("Atomic numbers"); chkfile.read_line
      .atom.create( .n_atom)
      do a = 1, .n_atom
         chkfile.read( .atom(a).atomic_number )
         .atom(a).label = .atom(a).chemical_symbol.trim // a.to_str.trim
      end
      chkfile.look_for("Current cartesian coordinates")
      chkfile.read_line
      do a = 1, .n_atom
         chkfile.read( .atom(a).pos)
      end
      chkfile.look_for("Shell types"); chkfile.read_line
      tmp_shells.create( .n_shell); tmp_nps.create( .n_shell)
      tmp_sta.create( .n_shell); tmp_pe.create( .n_prim)
      tmp_cc.create( .n_prim)
      nps.create( .n_shell); shell_to_atom.create( .n_shell)
      extra_cc.create( .n_prim)
      chkfile.read( tmp_shells)
      chkfile.look_for("Number of primitives per shell")
      chkfile.read_line; chkfile.read( tmp_nps)
      chkfile.look_for("Shell to atom map"); chkfile.read_line
      chkfile.read( tmp_sta)
      chkfile.look_for("Primitive exponents"); chkfile.read_line
      chkfile.read( tmp_pe)
      chkfile.look_for("Contraction coefficients"); chkfile.read_line
      chkfile.read( tmp_cc)
      e_atom.create( .n_atom); e_atom.zero
      prims = .n_prim
      if (any( tmp_shells == (-1) )) then
        do a = 1, .n_shell
           if (tmp_shells(a) == (-1)) then
              e_atom(tmp_sta(a)) = e_atom(tmp_sta(a)) + 1
              prims = prims + tmp_nps(a)
           end
        end
        chkfile.look_for("P(S=P)"); chkfile.read_line
        chkfile.read( extra_cc)
      end
      s = .n_shell + sum(e_atom)
      shell_l.create(s); nps.create(s)
      pe.create( prims); cc.create( prims)
      shell_to_atom.create(s)
      a = 0
      m1 = 1; m2 = 1
      do c = 1, .n_shell
        a = a + 1
        if (tmp_shells(c) == (-1)) then
           shell_l(a) = 0
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)
           cc(m1:m1+tmp_nps(c)-1) = tmp_cc(m2:m2+tmp_nps(c)-1)
           a = a+1; m1=m1+tmp_nps(c)
           shell_l(a) = 1
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)
           cc(m1:m1+tmp_nps(c)-1) = extra_cc(m2:m2+tmp_nps(c)-1)
        else
           pe(m1:m1+tmp_nps(c)-1) = tmp_pe(m2:m2+tmp_nps(c)-1)    
           cc(m1:m1+tmp_nps(c)-1) = tmp_cc(m2:m2+tmp_nps(c)-1)
           shell_l(a) = tmp_shells(c)
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c) 
        end
        m1 = m1 + tmp_nps(c); m2 = m2 + tmp_nps(c)
      end
      tmp_shells.destroy; tmp_sta.destroy
      tmp_nps.destroy; tmp_pe.destroy; tmp_cc.destroy
      .n_shell = s
      .n_prim = prims
      c = 0      ! for recording number of primitives read
      t = 0      ! for recording number of shells read
      n_basis = 0
      .basis.create(n_basis)
      do a = 1, .n_atom
         basis.create
         basis.label = .atom(a).label.trim // "_g94_basis"
         n_shell = count(shell_to_atom==a)
         basis.n_shell = n_shell
         basis.shell.create(n_shell)
         basis.shell.nullify_ptr_part
         do s = 1, n_shell
            n_comp = shell_l(t+s).n_comp
            n_cc = nps(t+s)
            basis.shell(s).l = shell_l(t+s)
            basis.shell(s).n_comp = n_comp
            basis.shell(s).n_cc = n_cc
            basis.shell(s).ex.create( n_cc )
            basis.shell(s).cc.create( n_cc )
            basis.shell(s).ex = pe( c+1 : c+n_cc )
            basis.shell(s).cc = cc( c+1 : c+n_cc )
            c = c + n_cc
         end
         basis.n_bf = basis.no_of_basis_functions
         basis.n_prim = basis.no_of_primitives
         basis.unnormalise
         t = t + n_shell
         same = FALSE
         do i = 1,n_basis
            if (.basis(i).same_as(basis)) then
               same = TRUE
               exit
            end
         end
         .atom(a).basis.create
         if (same) then
            .atom(a).basis.label = .basis(i).label
         else
            .atom(a).basis.label =  basis.label
            n_basis = n_basis + 1
            .basis.expand(n_basis)
            .basis(n_basis).copy(basis)
         end
         basis.destroy
      end
      .resolve_basis_labels
      .set_atom_info
      temp_vec.create( .n_bf)
      chkfile.look_for("Alpha Orbital Energies")
      chkfile.read_line; chkfile.read( temp_vec)      
      if (chkfile.next_str == "Beta") then
         u = 1
         .scfdata.kind = "uhf"
         .orbital_energies.create( .n_bf, "beta")
         .orbital_energies.create( "alpha")
         chkfile.read_line; chkfile.read( .orbital_energies.beta)
         .orbital_energies.alpha = temp_vec
         temp_vec.destroy
      else
         u = 0
         .scfdata.kind = "rhf"
         .orbital_energies.create( .n_bf, "restricted")
         .orbital_energies.restricted = temp_vec
         temp_vec.destroy
      end
      temp_mat.create( .n_bf, .n_bf)
      chkfile.look_for("Alpha MO"); chkfile.read_line
      chkfile.read( temp_mat)
      temp_mat = transpose( temp_mat)
      if (chkfile.next_str == "Beta") then
         .molecular_orbitals.create( .n_bf, "beta")
         .molecular_orbitals.create( "alpha")
         chkfile.read_line; chkfile.read( .molecular_orbitals.beta)
         .molecular_orbitals.beta = transpose( .molecular_orbitals.beta)
         .molecular_orbitals.alpha = temp_mat
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.alpha,"row") 
         .swap_g94_orbital_order(.molecular_orbitals.beta, "row") 
      else
         .molecular_orbitals.create(.n_bf, "restricted")
         .molecular_orbitals.restricted = temp_mat
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.restricted,"row") 
      end
      if (u==0) then
         .density_matrix.create( .n_bf, "restricted")
         .density_matrix.triangle.create( .density_matrix.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( .density_matrix.triangle)
         .density_matrix.uncompress
         .swap_g94_orbital_order(.density_matrix.restricted,"row") 
         .swap_g94_orbital_order(.density_matrix.restricted,"column") 
         .make_restricted_NOs
      else
         temp_total.create( .n_bf, "restricted")
         temp_spin.create( .n_bf, "restricted")
         temp_total.triangle.create( temp_total.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( temp_total.triangle)
         temp_total.uncompress
         temp_spin.triangle.create( temp_spin.l_compress( "restricted"))
         chkfile.look_for( "Spin SCF Density"); chkfile.read_line    
         chkfile.read( temp_spin.triangle)
         temp_spin.uncompress
         .density_matrix.create( .n_bf, "alpha")
         .density_matrix.create( "beta")
         .density_matrix.beta = (temp_total.restricted - temp_spin.restricted)/2
         .density_matrix.alpha = (temp_spin.restricted + temp_total.restricted)/2 
         temp_spin.destroy
         temp_total.destroy
         .swap_g94_orbital_order(.density_matrix.alpha,"row") 
         .swap_g94_orbital_order(.density_matrix.alpha,"column") 
         .swap_g94_orbital_order(.density_matrix.beta, "row") 
         .swap_g94_orbital_order(.density_matrix.beta, "column") 
         .make_unrestricted_NOs
      end
      pe.destroy; cc.destroy; extra_cc.destroy
      shell_to_atom.destroy; nps.destroy; e_atom.destroy
      shell_l.destroy; chkfile.close; chkfile.destroy
      ! Save data in archive files
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)
    ! archive.set(.name,"HF_density_matrix")
    ! archive.write(.density_matrix)
    ! archive.set(.name,"HF_molecular_orbitals")
    ! archive.write(.molecular_orbitals)
    ! archive.set(.name,"HF_orbital_energies")
    ! archive.write(.orbital_energies)
   end

   swap_g94_orbital_order(X,swap) 
   ! Swap the order of f orbitals on matrix "X" after reading a g94 checkpoint file,
   ! for "swap" equal to "row" or "1", or "coloumn" or "2". 
      MAT :: X
      STR(*) :: swap
      INT :: n,f,l
      IVEC(10) :: ff = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8,10 /)
      select case (swap)
         case("row","1")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
            end
         case("column","2")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
            end
         case default
            DIE("unknown swap option")
      end
   end

   write_wfn_file [leaky]
   ! writes a .wfn file for input to morphy98
      STR :: name
      TEXTFILE, PTR :: wfnfile
      IVEC, PTR :: lvec
      VEC, PTR :: evec
      MAT, PTR :: dmatrix, cc
      INT :: i, j, pcount, n_orbitals, b, a, l
      STR, parameter :: title_format = "(A80)"
      STR, parameter :: n_vars_format = "(A8, 12X, I3, 17X, I3, 17X, I3, 17X)"
      STR, parameter :: atom_format = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      STR, parameter :: c_assignment_format = "('CENTRE ASSIGNMENTS  ', 20I3)"
      STR, parameter :: t_assignment_format = "('TYPE ASSIGNMENTS    ', 20I3)"
      STR, parameter :: exponent_format = "('EXPONENTS ', 5E14.7)"
      STR, parameter :: mol_title_format = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      STR, parameter :: coefficient_format = "(5E16.8)"
      STR, parameter :: e_v_format = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"
      name = .name 
      if (.in.buffer.not_exhausted) .in.read(name)
      wfnfile.create(name)
      wfnfile.open_for_write
      if (mod( .n_e, 2) == 0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end
      write( unit = wfnfile.unit, fmt = title_format) trim( name) // " computed by TONTO"
      write( unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write( unit = wfnfile.unit, fmt = atom_format) ( .atom(i).label, i, i, &
         .atom(i).pos, dble( .atom(i).atomic_number ) , i = 1, .n_atom)
      write( unit = wfnfile.unit, fmt = c_assignment_format) (( j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )
      pcount = 1
      lvec.create( .n_prim)
      evec.create( .n_prim)
      do a = 1, .n_atom
         do b = 1, .basis(a).n_shell
            l = .atom(a).basis.shell(b).l.n_comp_sum - .atom(a).basis.shell(b).n_comp
            do j = pcount, pcount + .atom(a).basis.shell(b).n_prim - 1, .atom(a).basis.shell(b).n_comp
               do i = 1, .atom(a).basis.shell(b).n_comp
                  evec( j + i - 1) = .atom(a).basis.shell(b).ex(1 + (j - pcount) / .atom(a).basis.shell(b).n_comp)
                  lvec( j + i - 1) = l + i
               end
            end
            pcount = pcount + .atom(a).basis.shell(b).n_prim
         end
      end
      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write( unit = wfnfile.unit, fmt = exponent_format) evec 
      lvec.destroy
      evec.destroy
      dmatrix.create( .n_prim, .n_bf)
      dmatrix.zero
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)
      dmatrix = matmul( cc, .molecular_orbitals.restricted)
      do i = 1, n_orbitals
         write( unit = wfnfile.unit, fmt = mol_title_format) "MO  ", i, "OCC NO = ", &
            .occupation.restricted(i), " ORB. ENERGY = ", .orbital_energies.restricted(i)
         write( unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end
      write( unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      write( unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy
   end
   
   write_ascii_archive
   ! Write the archive called "name". The kind is defined by the object to be written.
   ! If required, the output order may be specified as "by_row" (default) or "by_column".
      STR :: name,order
      ARCHIVE :: archive
      .in.read(name)
      order = "by_row"
      if ( .in.buffer.not_exhausted) .in.read(order)
      archive.set(.name,name,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.write(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.write(.density_matrix,order=order)
         case ("natural_orbitals");   archive.write(.natural_orbitals,order=order)
         case ("occupation");         archive.write(.occupation,order=order)
         case ("fock_matrix");        archive.write(.fock_matrix,order=order)
         case default;     DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

!  **************
!  Output methods
!  **************

   put
   ! Put all the available molecule information on file "out"
      stdout.flush
      stdout.text("Molecule information:")
      stdout.flush
      stdout.show("Name                   =",.name)
      stdout.show("Charge                 =",.charge)
      stdout.show("Multiplicity           =",.mult)
      stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
      stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
      stdout.show("B field Gauge origin   =",.gauge_origin)
      if (.atom.created)        .put_atoms
      if (.pointgroup.created)  .put_pointgroup
      if (.crystal.created)     .put_crystal
!     if (.grid.created)        .put_grid
      if (.dftgrid.created)     .put_dftgrid
   end

   put_atoms
   ! Output the atom coordinate and basis set information
      ENSURE(.atom.created,"no atom list")
      stdout.flush
      stdout.text("Molecule atom information:")
      stdout.flush
      stdout.show("Chemical Formula       =",trim(.chemical_formula))
      stdout.show("No of atoms            =",.n_atom)
      stdout.show("No of electrons        =",.n_e)
      stdout.show("No of alpha electrons  =",.n_a)
      stdout.show("No of beta  electrons  =",.n_b)
      .atom.put_coord_info
      .put_bases
      .put_atom_thermal_tensors
   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.
      ENSURE(.atom.created,"no atom list")
      RETURN_IF(.atom.bases_are_unresolved)
      ENSURE(.basis.created,"no basis set list")
      stdout.flush
      stdout.text("Molecule atom basis set information:")
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of shell quartets  =",.n_shell_quartets)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .basis.put
   end 

  put_atom_thermal_tensors
  ! Output the thermal tensors if they exist.
    INT :: i
    STR :: model
    stdout.flush
    stdout.put("Thermal tensor information:")
    stdout.flush
    select case (.thermal_smearing_model)
      case (0); model = "None"
      case (1); model = "Stewart"
      case (2); model = "Coppens"
      case (3); model = "Tanaka"
    end
    stdout.show("Thermal smearing model = ",model.trim)
    stdout.flush
    RETURN_IF(.thermal_smearing_model==0)
    ENSURE(.atom.created,"no atom list data")
    ENSURE(.crystal.created,"no crystal data")
    .atom.put_thermal_tensors(.crystal)
  end

   put_basis
   ! Output the molecule basis set information
      ENSURE(.basis.created,"no basis set list")
      stdout.flush
      stdout.text("Molecule atom basis set information:")
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of shell quartets  =",.n_shell_quartets)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .basis.put
   end 

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put(.out)
   end

  put_plotgrid
  ! Output the current grid.
    ENSURE(.grid.created,"no plot grid to output")
    .grid.put(.out)
  end

  put_dftgrid
  ! Output the current DFT grid.
    ENSURE(.dftgrid.created,"no DFT grid to output")
    .dftgrid.put(.out)
  end

   put_crystal
   ! Output the current crystal
      if (.atom.created) then; .crystal.put(.out,.atom)
      else;                    .crystal.put(.out)
      end
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      .out.flush
      .out.text("Molecular orbitals:")
      .out.put( .molecular_orbitals)
   end

   put_mos_and_energies
   ! Output the current associated molecular orbitals and their energies
      .out.flush
      .out.text("Molecular orbital energies:")
      .out.put( .orbital_energies, format="column")
      .out.flush
      .out.text("Molecular orbitals:")
      .out.put( .molecular_orbitals)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      .out.flush
      .out.text("Natural orbital occupations:")
      .out.put( .occupation, format="column")
      .out.flush
      .out.text("Natural orbitals:")
      .out.put( .natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix 
      ENSURE(.density_matrix.created,"no density matrix")
      .out.flush
      .out.text("Density matrix:")
      .out.put( .density_matrix)
   end

   put_fock_matrix
   ! Output the current associated fock matrix 
      ENSURE(.fock_matrix.created,"no fock matrix")
      .out.flush
      .out.text("Fock matrix:")
      .out.put( .fock_matrix)
   end

   put_PND_sf
   ! Output the magnetic structure factors
      CVEC, PTR :: FM_s, FM_l, FM_r
      ARCHIVE :: archive
      INT :: n
      FM_s.create( .crystal.n_refl)
      archive.set(.name,"PND_spin_sf")
      archive.read(FM_s)
      FM_l.create( .crystal.n_refl)
      archive.set(.name,"PND_nabla_sf")
      archive.read(FM_l)
      FM_r.create( .crystal.n_refl)
      archive.set(.name,"PND_r_sf")
      archive.read(FM_r)
      .out.text("PND magnetic structure factors:")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=4)
      .out.put("h", int_width=TRUE)
      .out.put("k", int_width=TRUE)
      .out.put("l", int_width=TRUE)
      .out.put("FM_s")
      .out.put("FM_l")
      .out.put("FM_r")
      .out.put("FM")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=4)
      do n = 1, .crystal.n_refl
         .out.put( .crystal.h(n))
         .out.put( .crystal.k(n))
         .out.put( .crystal.l(n))
         .out.put( real(FM_s(n)) )
         .out.put( real(FM_l(n)) )
         .out.put( real(FM_r(n)) )
         .out.put( real(FM_s(n)+FM_l(n)+FM_r(n)) )
         .out.flush
      end
      .out.dash(int_fields=3,dbl_fields=4)
      FM_r.destroy
      FM_l.destroy
      FM_s.destroy
   end

  put_cluster_operations
  ! Outputs a list of the symmetry operations and translations of the molecules
  ! which are within distance_max of the centre of the molecule.
    IMAT, PTR :: operation_list,indices
    VEC, PTR :: dist_list
    INT :: q
    DBL :: dist_max
    STR :: word,in_units
    BIN :: out_angstrom

    ! default input and output is atomic units.
    dist_max = 5
    out_angstrom = FALSE

    if (.in.buffer.not_exhausted ) then
      .in.read(word)
      if (word.is_dbl) then
        dist_max = word.to_dbl
        if (.in.buffer.not_exhausted ) then
          .in.read(word)
          word.to_lower_case
          select case (trim(word))
            case ("atomic");               out_angstrom = FALSE
            case ("angstrom");             out_angstrom = TRUE
                         dist_max = dist_max * BOHR_PER_ANGSTROM
            case default; DIE("unknown units " // trim(word))
          end
        end
      else
        word.to_lower_case
        select case (trim(word))
          case ("atomic");               out_angstrom = FALSE
          case ("angstrom");             out_angstrom = TRUE
                       dist_max = dist_max * BOHR_PER_ANGSTROM
          case default; DIE("unknown units " // trim(word))
        end
      end
      if (.in.buffer.not_exhausted ) then
        .in.read(word)
        word.to_lower_case
        select case (trim(word))
          case ("atomic");               out_angstrom = FALSE
          case ("angstrom");             out_angstrom = TRUE
          case default; DIE("unknown units " // trim(word))
        end
      end
    end

    .crystal.create_closest_molecule_list(operation_list,dist_list,.atom,dist_max,indices)

    q=size(dist_list)
    .out.flush
    .out.text("Cluster molecules closest to the centre of the molecule.")
    if (out_angstrom) then
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
       trim( dist_max.to_str ) // " angstroms of the centre of the molecule.")
    else
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
       trim( dist_max.to_str ) // " au of the centre of the molecule.")
    end
    .out.put("symop",int_width=TRUE)
    .out.put("h",int_width=TRUE)
    .out.put("k",int_width=TRUE)
    .out.put("l",int_width=TRUE)
    if (out_angstrom) then
      .out.put("distance (angstrom)")
    else
      .out.put("distance (au)")
    end
    .out.put("index 1",int_width=TRUE)
    .out.put("index 2",int_width=TRUE)
    .out.flush
    do q=1,size(dist_list)
      if (operation_list(1,q)==0) exit
      .out.put(operation_list(1,q))
      .out.put(operation_list(2,q))
      .out.put(operation_list(3,q))
      .out.put(operation_list(4,q))
      .out.put(dist_list(q))
      .out.put(indices(1,q))
      .out.put(indices(2,q))
      .out.flush
    end
    indices.destroy
    operation_list.destroy
    dist_list.destroy
  end

  put_cluster_input
  ! Outputs the input data for a cluster of molecules around the centre of the
  ! molecule.
    ATOMVEC, PTR :: atomvec_frac,atomvec
    IMAT, PTR :: operation_list
    VEC, PTR :: dist_list
    STR :: word,out_units
    INT :: s,h,k,l,n,q,i,j
    DBL :: dist_max
    BIN :: out_cartesian,out_angstrom,put_thermal

    ! default input and output is atomic units.
    dist_max = 5
    out_angstrom = FALSE
    out_cartesian = TRUE

    if (.in.buffer.not_exhausted ) then
      .in.read(word)
      if (word.is_dbl) then
        dist_max = word.to_dbl
        if (.in.buffer.not_exhausted ) then
          .in.read(word)
          word.to_lower_case
          select case (trim(word))
            case ("atomic");               out_angstrom = FALSE
            case ("angstrom");             out_angstrom = TRUE
                         dist_max = dist_max * BOHR_PER_ANGSTROM
            case ("fractional","crystal"); out_cartesian = FALSE
            case default; DIE("unknown units " // trim(word))
          end
        end
      else
        word.to_lower_case
        select case (trim(word))
          case ("atomic");               out_angstrom = FALSE
          case ("angstrom");             out_angstrom = TRUE
                       dist_max = dist_max * BOHR_PER_ANGSTROM
          case ("fractional","crystal"); out_cartesian = FALSE
          case default; DIE("unknown units " // trim(word))
        end
      end
      if (.in.buffer.not_exhausted ) then
        .in.read(word)
        word.to_lower_case
        select case (trim(word))
          case ("atomic");               out_angstrom = FALSE
          case ("angstrom");             out_angstrom = TRUE
          case ("fractional","crystal"); out_cartesian = FALSE
          case default; DIE("unknown units " // trim(word))
        end
      end
    end

    .crystal.create_closest_molecule_list(operation_list,dist_list,.atom,dist_max)

    q=size(dist_list)
    if (operation_list(1,q) == 0) q=0

    put_thermal = FALSE     ! decide whether to output thermal parameters.
    outer : do n=1, .n_atom
      do i=1,3
        do j=1,3
          if (abs( .atom(n).thermal_tensor(i,j) ) > TOL(10)) then 
            put_thermal = TRUE
            exit outer
          end
        end
      end
    end do outer

    .out.flush
    .out.text("Cluster input.")
    if (put_thermal) then
      if (out_cartesian) then
        .out.text("Thermal parameters in cartesian coordinates, A^2.")
      else
        .out.text("Thermal parameters in crystal coordinates, A^2.")
      end
    end
    if (out_angstrom) then
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
         trim( dist_max.to_str ) // &
         " angstroms of the centre of the molecule.")
    else
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
         trim( dist_max.to_str ) // &
         " atomic units of the centre of the molecule.")
    end
    .out.put_text("atoms ")
    if (NOT out_cartesian) then
      .out.put_text("crystal")
    else if (out_angstrom) then
      .out.put_text("angstrom")
    else
      .out.put_text("atomic")
    end
    .out.flush

    atomvec_frac.create_copy( .atom )
!    atomvec_frac.change_coord_axes_to("crystal",.crystal)
!    atomvec_frac.change_thermal_tensor_axes_to("crystal",.crystal)
!    atomvec_frac.rotate_coords_to("crystal",.crystal)
!    atomvec_frac.rotate_thermal_tensor_to("crystal",.crystal)
    atomvec.create( .n_atom )
    do q=1,size(dist_list)
      s = operation_list(1,q)
      if (s==0) exit
      h = operation_list(2,q)
      k = operation_list(3,q)
      l = operation_list(4,q)
      atomvec.copy(atomvec_frac)
      atomvec.seitz_multiply( transpose( .crystal.spacegroup.seitz(:,:,s) ))
      atomvec.translate((/ONE*h,ONE*k,ONE*l/))
!      if (out_cartesian) atomvec.change_coord_axes_from("crystal",.crystal)
!      if (out_cartesian) atomvec.change_thermal_tensor_axes_from("crystal",.crystal)
!      if (out_cartesian) atomvec.rotate_coords_from("crystal",.crystal)
!      if (out_cartesian) atomvec.rotate_thermal_tensor_to("crystal",.crystal)
      if (out_angstrom)  atomvec.convert_to_angstrom
      do n = 1, .n_atom
        .out.put_text(trim( .atom(n).label ),int_width=TRUE)
        .out.put(atomvec(n).pos(1))
        .out.put(atomvec(n).pos(2))
        .out.put(atomvec(n).pos(3))
        if ( .atom.bases_are_all_labeled ) .out.put_str(" " // .atom(n).basis.label)
        if (put_thermal) then
          atomvec(n).thermal_tensor = atomvec(n).thermal_tensor/(BOHR_PER_ANGSTROM)**2
          atomvec(n).put_thermal_tensor
        end
        .out.flush
      end
    end
    .out.text("end",flush=2)
    operation_list.destroy
    dist_list.destroy
    atomvec.nullify_ptr_part;       atomvec.destroy
    atomvec_frac.nullify_ptr_part;  atomvec_frac.destroy
  end

end 
