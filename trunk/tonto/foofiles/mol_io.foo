! $Id$
!-------------------------------------------------------------------------------
!
! MOL_io: these routines required by several modules in mol.
!
!-------------------------------------------------------------------------------
module MOL_IO

   use TYPES
   use ERROR
   use MM
   use STR
   use INT
   use DBL

   use BUFFER
   use INPUT
   use OUTPUT

   use VEC
   use IVEC
   use MAT
   use OPVEC
   use OPMAT

   use SHELL
   use SHELLVEC
   use BASIS
   use BASISVEC
   use ATOM
   use ATOMVEC

   use SCFDATA
   use ARCHIVE
   use VECDIIS

   use PLOTGRID
   use DFTGRID
   use POINTGROUP
   use XTAL
   use MOL_COMMON
   use MOL_XTAL

   implicit none         

#  include "macros"
#  include "mol_io.int"

contains

!  ************
!  Read methods
!  ************

   read_multiplicity
   ! Read in the spin multiplicity
      .in.read(.mult)
      ENSURE(.mult/=0,"cannot have zero multiplicity")
   end

   read_plotgrid [leaky]
   ! Read in the plot grid data
      if ( .xtal.destroyed) then
        .grid.read(.in,.atom)
      else if ( .xtal%unitcell.created) then
        .grid.read(.in,.atom,.xtal%unitcell)
      end
   end

   read_dftgrid [leaky]
   ! Read in the DFT grid data
      .dftgrid.destroy
      .dftgrid.create
      .dftgrid.read(.in)
   end

   read_xtal [leaky]
   ! Read in the xtal data
      .xtal.destroy
      .xtal.create
      .xtal.read(.in)
   end

   read_pointgroup [leaky]
   ! Read in the pointgroup data
      .pointgroup.destroy
      .pointgroup.create
      .pointgroup.read(.in)
   end

   read_scfdata [leaky] 
   ! Read in the scf data
      .scfdata.destroy
      .scfdata.create
      .scfdata.read(.in)
      if (.scfdata%using_diis) then
      .scfdata%diis.set_archive_root_name(.name) 
      .scfdata%diis.set_archive_name("fock_matrix,DIIS")
      end
   end

   read_atoms [leaky]
   ! Read in the atom list information
      if (.xtal.destroyed)  .atom.read(.in)
      if (.xtal.created)    .atom.read(.in, .xtal%unitcell)
      DIE_IF( .atom.basis_part_labeled,"some empty basis labels exist")
      .resolve_basis_labels
      .set_atom_info
   end
  
  read_partition_data [leaky]
  ! Read the molecule partitioning data.
    STR :: word
    INT :: n
    DIE_IF( .atom.destroyed, "must have atoms defined first")
    .partition_factors.destroy
    .partition_factors.create( .n_atom )
    .partition_factors = ONE
    .in.read( .partition_model )
    do
      .in.read(word)
      word.to_lower_case
      if (word.is_not_int) exit
      n = word.to_int
      .in.read(word)
      ENSURE( word.is_dbl, 'expecting a number, got ' // '"' // word.trim // '"' //' instead')
      .partition_factors(n) = word.to_dbl
    end
  end

   read_basis_labels
   ! Read in a list of basis set labels for every atom in the molecule
   ! If a basis set is defined, all atoms must have a resolved basis set
      ENSURE( .atom.created,"no atoms in atom list")
      .atom.read_basis_labels(.in)
      .resolve_basis_labels
   end

   read_basis_sets [leaky]
   ! Read in a list of atomic basis sets for the molecule
      .basis.read(.in)
      .resolve_basis_labels
   end

   read_thermal_tensors
   ! Read in the thermal tensor data for all atoms
      .atom.read_thermal_tensors(.in, .xtal%unitcell)
   end

   read_thermal_smearing_model
   ! Read an allowed thermal smearing model for Fourier transform calculations
      INT :: model
      model = .in.get_int
      ENSURE(model>=0 AND model<=3, "unknown thermal smearing model")
      .thermal_smearing_model = model 
   end

   read_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g. "restricted".
   ! For use with TONTO generated archives.
      STR :: name,kind
      ARCHIVE :: archive
      ENSURE(.in%buffer%n_items==3, "must specify an archive and a kind")
      .in.read(name)
      .in.read(kind)
      archive.set(.name,name,kind)
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals)
         case ("density_matrix");     archive.read(.density_matrix)
         case ("natural_orbitals");   archive.read(.natural_orbitals)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("covalent_orbitals");  archive.read(.natural_orbitals)
         case ("ionic_orbitals");     archive.read(.natural_orbitals)
         case default;                DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_ascii_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g. "restricted".
   ! If required, the input order may be specified as "by_row" (default) or "by_column".
      STR :: name,kind,order
      ARCHIVE :: archive
      ENSURE(.in%buffer%n_items==3, "must specify an archive and a kind")
      .in.read(name)
      .in.read(kind)
      order = "by_row"
      if ( .in%buffer.not_exhausted) .in.read(order)
      archive.set(.name,name,kind,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.read(.density_matrix,order=order)
         case ("natural_orbitals");   archive.read(.natural_orbitals,order=order)
         case ("occupation");         archive.read(.occupation)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("fock_matrix");        .fock_matrix.create("restricted")
                                      archive.read(.fock_matrix,order=order)
         case default; DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_g94_checkpoint_file [leaky]
   ! Read a g94 checkpoint file into TONTO
      STR :: name
      INPUT, PTR :: chkfile
      IVEC, PTR :: shell_l, nps, shell_to_atom, e_atom
      IVEC, PTR :: tmp_nps, tmp_sta, tmp_shells
      VEC, PTR :: tmp_pe, tmp_cc
      VEC, PTR :: pe, cc, extra_cc, temp_vec
      MAT, PTR :: temp_mat
      OPMAT, PTR :: temp_spin, temp_total
      INT :: c, t, a, s, u, m1, m2, prims
      INT :: n_shell, n_comp, n_cc
      ARCHIVE :: archive
      if ( .basis.created) .basis.destroy
      if ( .atom.created)  .atom.destroy
      name = trim(.name)       ! not name.fchk, so have to rename checkpoint file
      if ( .in%buffer.not_exhausted) name = .in.get_str
      chkfile.create(name)
      chkfile.open
      chkfile.read_line
      chkfile.look_for("Number of atoms")
      chkfile.move_to_item(5); chkfile.read( .n_atom)
      chkfile.look_for("Charge")
      chkfile.move_to_item(3); chkfile.read( .charge)
      chkfile.look_for("Multiplicity")
      chkfile.move_to_item(3); chkfile.read( .mult)
      chkfile.look_for("Number of electrons")
      chkfile.move_to_item(5); chkfile.read( .n_e)
      chkfile.look_for("Number of alpha electrons")
      chkfile.move_to_item(6); chkfile.read( .n_a)
      chkfile.look_for("Number of beta electrons")
      chkfile.move_to_item(6); chkfile.read( .n_b)
      chkfile.look_for("Number of basis functions")
      chkfile.move_to_item(6); chkfile.read( .n_bf)
      chkfile.look_for("Number of contracted shells") 
      chkfile.move_to_item(6); chkfile.read( .n_shell)
      chkfile.look_for("Number of primitive shells")
      chkfile.move_to_item(6); chkfile.read( .n_prim)
      chkfile.look_for("Total Energy")
      chkfile.move_to_item(4)
      .scfdata.create; chkfile.read_dbl( .scfdata%energy )
      chkfile.look_for("Atomic numbers"); chkfile.read_line
      .atom.create( .n_atom)
      do a = 1, .n_atom
         chkfile.move_to_next_item
         chkfile.read( .atom(a)%atomic_number )
         .atom(a)%label = .atom(a).chemical_symbol.trim // a.to_str.trim
      end
      chkfile.look_for("Current cartesian coordinates")
      chkfile.read_line
      do a = 1, .n_atom
         chkfile.move_to_next_item
         chkfile.read( .atom(a)%pos)
      end
      chkfile.look_for("Shell types"); chkfile.read_line
      tmp_shells.create( .n_shell); tmp_nps.create( .n_shell)
      tmp_sta.create( .n_shell); tmp_pe.create( .n_prim)
      tmp_cc.create( .n_prim)
      nps.create( .n_shell); shell_to_atom.create( .n_shell)
      pe.create( .n_prim); cc.create( .n_prim)
      extra_cc.create( .n_prim)
      chkfile.read( tmp_shells)
      chkfile.look_for("Number of primitives per shell")
      chkfile.read_line; chkfile.read( tmp_nps)
      chkfile.look_for("Shell to atom map"); chkfile.read_line
      chkfile.read( tmp_sta)
      chkfile.look_for("Primitive exponents"); chkfile.read_line
      chkfile.read( tmp_pe)
      chkfile.look_for("Contraction coefficients"); chkfile.read_line
      chkfile.read( tmp_cc)
      e_atom.create( .n_atom); e_atom.zero
      prims = .n_prim
      if (any( tmp_shells == (-1) )) then
        do a = 1, .n_prim
           if (tmp_shells(a) == (-1)) then
              e_atom(tmp_sta(a)) = e_atom(tmp_sta(a)) + 1
              prims = prims + tmp_nps(a)
           end
        end
        chkfile.look_for("P(S=P)"); chkfile.read_line
        chkfile.read( extra_cc)
       end
      s = .n_shell + sum(e_atom)
      shell_l.create(s); nps.create(s)
      pe.create( prims); cc.create( prims)
      shell_to_atom.create(s)
      a = 0
      m1 = 1; m2 = 1
      do c = 1, .n_shell
        a = a + 1
        if (tmp_shells(c) == (-1)) then
           shell_l(a) = 0
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)) = tmp_pe(m2:m2+tmp_nps(c))
           cc(m1:m1+tmp_nps(c)) = tmp_cc(m2:m2+tmp_nps(c))
           a = a+1; m1=m1+tmp_nps(c)
           shell_l(a) = 1
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)) = tmp_pe(m2:m2+tmp_nps(c))
           cc(m1:m1+tmp_nps(c)) = extra_cc(m2:m2+tmp_nps(c))
        else
           pe(m1:m1+tmp_nps(c)) = tmp_pe(m2:m2+tmp_nps(c))    
           cc(m1:m1+tmp_nps(c)) = tmp_cc(m2:m2+tmp_nps(c))
           shell_l(a) = tmp_shells(c)
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c) 
        end
        m1 = m1 + tmp_nps(c); m2 = m2 + tmp_nps(c)
      end
      tmp_shells.destroy; tmp_sta.destroy
      tmp_nps.destroy; tmp_pe.destroy; tmp_cc.destroy
      .n_shell = s
      .n_prim = prims
      c = 0      ! for recording number of primitives read
      t = 0      ! for recording number of shells read
      .basis.create( .n_atom)
      do a = 1, .n_atom
         .basis(a)%label = .atom(a)%label.trim // "_g94_basis"
         n_shell = count(shell_to_atom==a)
         .basis(a)%n_shell = n_shell
         .basis(a)%shell.create(n_shell)
         .basis(a)%shell.nullify_ptr_part
         do s = 1, n_shell
            n_comp = shell_l(t+s).n_comp
            n_cc = nps(t+s)
            .basis(a)%shell(s)%l = shell_l(t+s)
            .basis(a)%shell(s)%n_comp = n_comp
            .basis(a)%shell(s)%n_cc = n_cc
            .basis(a)%shell(s)%ex.create( n_cc )
            .basis(a)%shell(s)%cc.create( n_cc )
            .basis(a)%shell(s)%ex = pe( c+1 : c+n_cc )
            .basis(a)%shell(s)%cc = cc( c+1 : c+n_cc )
            c = c + n_cc
         end
         .basis(a)%n_bf = .basis(a).no_of_basis_functions
         .basis(a)%n_prim = .basis(a).no_of_primitives
         .basis(a).unnormalise
         t = t + n_shell
      .atom(a)%basis.create
      .atom(a)%basis%label = .basis(a)%label
      end
      .resolve_basis_labels
      temp_vec.create( .n_bf)
      chkfile.look_for("Alpha Orbital Energies")
      chkfile.read_line; chkfile.read( temp_vec)      
      if (chkfile.get_str == "Beta") then
         u = 1
         .orbital_energies.create( .n_bf, "beta")
         .orbital_energies.create( "alpha")
         chkfile.read_line; chkfile.read( .orbital_energies%beta)
         .orbital_energies%alpha = temp_vec
         temp_vec.destroy
      else
         u = 0
         .orbital_energies.create( .n_bf, "restricted")
         .orbital_energies%restricted = temp_vec
         temp_vec.destroy
      end
      temp_mat.create( .n_bf, .n_bf)
      chkfile.look_for("Alpha MO"); chkfile.read_line
      chkfile.read( temp_mat)
      temp_mat = transpose( temp_mat)
      if (chkfile.get_str == "Beta") then
         .molecular_orbitals.create( .n_bf, "beta")
         .molecular_orbitals.create( "alpha")
         chkfile.read_line; chkfile.read( .molecular_orbitals%beta)
         .molecular_orbitals%beta = transpose( .molecular_orbitals%beta)
         .molecular_orbitals%alpha = temp_mat
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals%alpha,"row") 
         .swap_g94_orbital_order(.molecular_orbitals%beta, "row") 
      else
         .molecular_orbitals.create(.n_bf, "restricted")
         .molecular_orbitals%restricted = temp_mat
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals%restricted,"row") 
      end
      if (u==0) then
         .density_matrix.create( .n_bf, "restricted")
         .density_matrix%triangle.create( .density_matrix.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( .density_matrix%triangle)
         .density_matrix.uncompress
         .swap_g94_orbital_order(.density_matrix%restricted,"row") 
         .swap_g94_orbital_order(.density_matrix%restricted,"column") 
         .make_restricted_NOs
      else
         temp_total.create( .n_bf, "restricted")
         temp_spin.create( .n_bf, "restricted")
         temp_total%triangle.create( temp_total.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( temp_total%triangle)
         temp_total.uncompress
         temp_spin%triangle.create( temp_spin.l_compress( "restricted"))
         chkfile.look_for( "Spin SCF Density"); chkfile.read_line    
         chkfile.read( temp_spin%triangle)
         temp_spin.uncompress
         .density_matrix.create( .n_bf, "alpha")
         .density_matrix.create( "beta")
         .density_matrix%beta = (temp_total%restricted - temp_spin%restricted)/2
         .density_matrix%alpha = (temp_spin%restricted + temp_total%restricted)/2 
         temp_spin.destroy
         temp_total.destroy
         .swap_g94_orbital_order(.density_matrix%alpha,"row") 
         .swap_g94_orbital_order(.density_matrix%alpha,"column") 
         .swap_g94_orbital_order(.density_matrix%beta, "row") 
         .swap_g94_orbital_order(.density_matrix%beta, "column") 
         .make_unrestricted_NOs
      end
      pe.destroy; cc.destroy; extra_cc.destroy
      shell_to_atom.destroy; nps.destroy; e_atom.destroy
      shell_l.destroy; chkfile.close; chkfile.destroy
      ! Save data in archive files
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)
    ! archive.set(.name,"HF_density_matrix")
    ! archive.write(.density_matrix)
    ! archive.set(.name,"HF_molecular_orbitals")
    ! archive.write(.molecular_orbitals)
    ! archive.set(.name,"HF_orbital_energies")
    ! archive.write(.orbital_energies)
   end

   swap_g94_orbital_order(X,swap) 
   ! Swap the order of f orbitals on matrix "X" after reading a g94 checkpoint file,
   ! for "swap" equal to "row" or "1", or "coloumn" or "2". 
      MAT :: X
      STR(*) :: swap
      INT :: n,f,l
      IVEC(10) :: ff = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8,10 /)
      select case (swap)
         case("row","1")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
            end
         case("column","2")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
            end
         case default
            DIE("unknown swap option")
      end
   end

   write_wfn_file [leaky]
   ! writes a .wfn file for input to morphy98
      STR :: name
      OUTPUT, PTR :: wfnfile
      IVEC, PTR :: lvec
      VEC, PTR :: evec
      MAT, PTR :: dmatrix, cc
      INT :: i, j, pcount, n_orbitals, b, a, l
      STR, parameter :: title_format = "(A80)"
      STR, parameter :: n_vars_format = "(A8, 12X, I3, 17X, I3, 17X, I3, 17X)"
      STR, parameter :: atom_format = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      STR, parameter :: c_assignment_format = "('CENTRE ASSIGNMENTS  ', 20I3)"
      STR, parameter :: t_assignment_format = "('TYPE ASSIGNMENTS    ', 20I3)"
      STR, parameter :: exponent_format = "('EXPONENTS ', 5E14.7)"
      STR, parameter :: mol_title_format = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      STR, parameter :: coefficient_format = "(5E16.8)"
      STR, parameter :: e_v_format = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"
      name = .name 
      if (.in%buffer.not_exhausted) name = .in.get_str
      wfnfile.create( name)
      wfnfile.open
      if (mod( .n_e, 2) == 0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end
      write( unit = wfnfile%unit, fmt = title_format) trim( name) // " computed by TONTO"
      write( unit = wfnfile%unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write( unit = wfnfile%unit, fmt = atom_format) ( .atom(i)%label, i, i, &
         .atom(i)%pos, dble( .atom(i)%atomic_number ) , i = 1, .n_atom)
      write( unit = wfnfile%unit, fmt = c_assignment_format) (( j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )
      pcount = 1
      lvec.create( .n_prim)
      evec.create( .n_prim)
      do a = 1, .n_atom
         do b = 1, .basis(a)%n_shell
            l = .atom(a)%basis%shell(b)%l.n_comp_sum - .atom(a)%basis%shell(b)%n_comp
            do j = pcount, pcount + .atom(a)%basis%shell(b).n_prim - 1, .atom(a)%basis%shell(b)%n_comp
               do i = 1, .atom(a)%basis%shell(b)%n_comp
                  evec( j + i - 1) = .atom(a)%basis%shell(b)%ex(1 + (j - pcount) / .atom(a)%basis%shell(b)%n_comp)
                  lvec( j + i - 1) = l + i
               end
            end
            pcount = pcount + .atom(a)%basis%shell(b).n_prim
         end
      end
      write(unit = wfnfile%unit, fmt = t_assignment_format) lvec
      write( unit = wfnfile%unit, fmt = exponent_format) evec 
      lvec.destroy
      evec.destroy
      dmatrix.create( .n_prim, .n_bf)
      dmatrix.zero
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)
      dmatrix = matmul( cc, .molecular_orbitals%restricted)
      do i = 1, n_orbitals
         write( unit = wfnfile%unit, fmt = mol_title_format) "MO  ", i, "OCC NO = ", &
            .occupation%restricted(i), " ORB. ENERGY = ", .orbital_energies%restricted(i)
         write( unit = wfnfile%unit, fmt = coefficient_format) dmatrix(:, i)
      end
      write( unit = wfnfile%unit, fmt = "(1A8)") "END DATA"
      write( unit = wfnfile%unit, fmt = e_v_format) .scfdata%energy, 2.0D00
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy
   end
   
   write_ascii_archive
   ! Write the archive called "name". The kind is defined by the object to be written.
   ! If required, the output order may be specified as "by_row" (default) or "by_column".
      STR :: name,order
      ARCHIVE :: archive
      .in.read(name)
      order = "by_row"
      if ( .in%buffer.not_exhausted) .in.read(order)
      archive.set(.name,name,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.write(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.write(.density_matrix,order=order)
         case ("natural_orbitals");   archive.write(.natural_orbitals,order=order)
         case ("occupation");         archive.write(.occupation,order=order)
         case ("fock_matrix");        archive.write(.fock_matrix,order=order)
         case default;     DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

!  **************
!  Output methods
!  **************

   put
   ! Put all the available molecule information on file "out"
      .out.flush
      .out.text("Molecule output:")
      .out.show("Name                   =",.name)
      .out.show("Chemical Formula       =",trim(.chemical_formula))
      .out.show("Charge                 =",.charge)
      .out.show("Multiplicity           =",.mult)
      .out.show("No of atoms            =",.n_atom)
      .out.show("No of electrons        =",.n_e)
      .out.show("No of alpha electrons  =",.n_a)
      .out.show("No of beta  electrons  =",.n_b)
      .out.show("No. of basis sets      =",.n_basis)
      .out.show("No. of shells          =",.n_shell)
      .out.show("No. of basis functions =",.n_bf)
      .out.show("No. of primitives      =",.n_prim)
      if (.atom.created)        .put_atoms
      if (.atom.basis_resolved) .put_basis
      if (.pointgroup.created)  .put_pointgroup
      if (.xtal.created)        .put_xtal
      if (.grid.created)        .put_grid
      if (.dftgrid.created)     .put_dftgrid
   end

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put(.out)
   end

  put_grid
  ! Output the current grid.
    if (.grid.created) then
      .grid.put(.out)
    else
      WARN("no grid to output")
    end
  end

  put_dftgrid
  ! Output the current DFT grid.
    if (.dftgrid.created) then
      .dftgrid.put(.out)
    else
      WARN("no DFT grid to output")
    end
  end

  put_thermal_tensors
  ! Output the thermal tensors if they exist.
    INT :: i
    if (NOT .thermal_smearing_model == 0) then
      .out.flush
      .out.put_text("Thermal smearing model =")
      select case (.thermal_smearing_model)
        case (1);  .out.put("Stewart")
        case (2);  .out.put("Coppens")
        case (3);  .out.put("Tanaka")
      end
      .out.flush(2)
      .out.text("Thermal parameters in cartesian coordinates.")
      .out.put("atom",int_width=TRUE)
      .out.put("U11")
      .out.put("U22")
      .out.put("U33")
      .out.put("U12")
      .out.put("U13")
      .out.put("U23")
      .out.flush
      do i = 1, .n_atom
        .out.put(i)
        .out.put(.atom(i)%thermal_tensor(1,1))
        .out.put(.atom(i)%thermal_tensor(2,2))
        .out.put(.atom(i)%thermal_tensor(3,3))
        .out.put(.atom(i)%thermal_tensor(1,2))
        .out.put(.atom(i)%thermal_tensor(1,3))
        .out.put(.atom(i)%thermal_tensor(2,3))
        .out.flush
      end
      .out.flush
      .out.text("Thermal parameters in crystal coordinates.")
      .out.put("atom",int_width=TRUE)
      .out.put("U11")
      .out.put("U22")
      .out.put("U33")
      .out.put("U12")
      .out.put("U13")
      .out.put("U23")
      .out.flush
      do i = 1, .n_atom
        .atom(i)%thermal_tensor = .atom(i)%thermal_tensor/(BOHR_PER_ANGSTROM)**2
        .atom(i).thermal_tensor_to_crystal( .xtal%unitcell )
        .out.put(i)
        .out.put(.atom(i)%thermal_tensor(1,1))
        .out.put(.atom(i)%thermal_tensor(2,2))
        .out.put(.atom(i)%thermal_tensor(3,3))
        .out.put(.atom(i)%thermal_tensor(1,2))
        .out.put(.atom(i)%thermal_tensor(1,3))
        .out.put(.atom(i)%thermal_tensor(2,3))
        .atom(i).treat_thermal_tensor( .xtal%unitcell )
        .atom(i)%thermal_tensor = .atom(i)%thermal_tensor*(BOHR_PER_ANGSTROM)**2
        .out.flush
      end
      .out.flush
    end
  end

   put_xtal
   ! Output the current xtal
      .put_thermal_tensors
      if (.xtal.F_calc_exists AND F_exp_exists_(self%xtal)) .xtal.update_gof_parameters
      .xtal.put(.out)
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      .out.flush
      .out.text("Molecular orbitals:")
      .out.put( .molecular_orbitals)
   end

   put_mos_and_energies
   ! Output the current associated molecular orbitals and their energies
      .out.flush
      .out.text("Molecular orbital energies:")
      .out.put( .orbital_energies, format="column")
      .out.flush
      .out.text("Molecular orbitals:")
      .out.put( .molecular_orbitals)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      .out.flush
      .out.text("Natural orbital occupations:")
      .out.put( .occupation, format="column")
      .out.flush
      .out.text("Natural orbitals:")
      .out.put( .natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix 
      if (.density_matrix.destroyed) then
        .out.flush(2)
        .out.put_text(" * * * Density matrix not available to print * * *",flush=2)
      else
        .out.flush
        .out.text("Density matrix:")
        .out.put( .density_matrix)
      end
   end

   put_fock_matrix
   ! Output the current associated fock matrix 
      if (.fock_matrix.destroyed) then
        .out.flush(2)
        .out.put_text(" * * * Fock matrix not available to print * * *",flush=2)
      else
        .out.flush
        .out.text("Fock matrix:")
        .out.put( .fock_matrix)
      end
   end

   put_atoms
   ! Output the atom basis set information
      INT :: i,n_dbl
      BIN :: basis_exists
      ENSURE( .atom.created,"no atom list")
      .out.flush
      .out.text("Atoms:")
      .out.flush
      basis_exists = .atom.basis_all_labeled
      n_dbl = 3
      if (basis_exists) n_dbl = 4
      .out.dash(int_fields=3,dbl_fields=n_dbl)
      .out.put("#",int_width=TRUE)
      .out.put("ID",int_width=TRUE)
      .out.put("Z",int_width=TRUE)
      .out.put("x")
      .out.put("y")
      .out.put("z")
      if (basis_exists) .out.put("Basis")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=n_dbl)
      do i = 1,.n_atom
         .out.put(i)
         .out.put(.atom(i)%label,int_width=TRUE)
         .out.put(.atom(i)%atomic_number)
         .out.put(.atom(i)%pos(1))
         .out.put(.atom(i)%pos(2))
         .out.put(.atom(i)%pos(3))
         if (basis_exists) .out.put(.atom(i)%basis%label)
         .out.flush
      end 
      .out.dash(int_fields=3,dbl_fields=n_dbl)
      .atom.put_bond_length_table(.out)
      .atom.put_bond_angle_table(.out)
      .atom.put_torsion_angle_table(.out)
      .out.flush
   end 

   put_basis
   ! Output the molecule basis set information
      .basis.put(.out)
   end 

   put_PND_sf
   ! Output the magnetic structure factors
      CVEC, PTR :: FM_s, FM_l, FM_r
      ARCHIVE :: archive
      INT :: n
      FM_s.create( .xtal%n_refl)
      archive.set(.name,"PND_spin_sf")
      archive.read(FM_s)
      FM_l.create( .xtal%n_refl)
      archive.set(.name,"PND_nabla_sf")
      archive.read(FM_l)
      FM_r.create( .xtal%n_refl)
      archive.set(.name,"PND_r_sf")
      archive.read(FM_r)
      .out.text("PND magnetic structure factors:")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=4)
      .out.put("h", int_width=TRUE)
      .out.put("k", int_width=TRUE)
      .out.put("l", int_width=TRUE)
      .out.put("FM_s")
      .out.put("FM_l")
      .out.put("FM_r")
      .out.put("FM")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=4)
      do n = 1, .xtal%n_refl
         .out.put( .xtal%h(n))
         .out.put( .xtal%k(n))
         .out.put( .xtal%l(n))
         .out.put( real(FM_s(n)) )
         .out.put( real(FM_l(n)) )
         .out.put( real(FM_r(n)) )
         .out.put( real(FM_s(n)+FM_l(n)+FM_r(n)) )
         .out.flush
      end
      .out.dash(int_fields=3,dbl_fields=4)
      FM_r.destroy
      FM_l.destroy
      FM_s.destroy
   end

  put_cluster_operations
  ! Outputs a list of the symmetry operations and translations of the molecules which
  ! are within distance_max of the centre of the molecule.
    IMAT, PTR :: operation_list
    VEC, PTR :: dist_list
    INT :: q
    DBL :: dist_max
    STR :: word,in_units,out_units

    dist_max = 5  ! au
    in_units = "atomic"
    out_units = "atomic"

    if (.in%buffer.not_exhausted ) then
      .in.read(word)
      if (word.is_dbl) then
        dist_max = word.to_dbl
      else
        word.to_lower_case
        in_units = word
        out_units = word
      end
      if (.in%buffer.not_exhausted ) then
        .in.read(word)
        word.to_lower_case
        out_units = word
      end
    end

    select case (trim(in_units))
      case ("atomic")
      case ("angstrom");  dist_max = dist_max * BOHR_PER_ANGSTROM
      case default; DIE("unknown units " // in_units.trim)
    end

    .xtal.create_closest_molecule_list(operation_list,dist_list,.atom,dist_max)

    select case (trim(out_units))
      case ("atomic")
      case ("angstrom");  dist_list = dist_list * ANGSTROM_PER_BOHR
      case default; DIE("unknown units " // in_units.trim)
    end

    q=size(dist_list)
    .out.flush
    .out.text("Cluster molecules closest to the centre of the molecule.")
    if (trim(out_units)=="angstrom") then
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
         trim( dist_max.to_str ) // &
         " angstroms of the centre of the molecule.")
    else
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
         trim( dist_max.to_str ) // &
         " atomic units of the centre of the molecule.")
    end
    .out.put("symop",int_width=TRUE)
    .out.put("h",int_width=TRUE)
    .out.put("k",int_width=TRUE)
    .out.put("l",int_width=TRUE)
    .out.put("distance (" // trim(out_units) //")",flush=1)
    do q=1,size(dist_list)
      if (operation_list(1,q)==0) exit
      .out.put(operation_list(1,q))
      .out.put(operation_list(2,q))
      .out.put(operation_list(3,q))
      .out.put(operation_list(4,q))
      .out.put(dist_list(q),flush=1)
    end
    operation_list.destroy
    dist_list.destroy
  end

  put_cluster_input
  ! Outputs the input data for a cluster of molecules around the centre of the molecule.
    ATOMVEC, PTR :: atomvec_frac,atomvec
    IMAT, PTR :: operation_list
    VEC, PTR :: dist_list
    STR :: word,in_units,out_units
    INT :: s,h,k,l,n,q,i,j
    DBL :: dist_max,max_thermal
    BIN :: out_cartesian,out_angstrom,put_thermal

    dist_max = 5  ! au
    in_units = "atomic"
    out_units = "atomic"
    out_cartesian = TRUE

    if (.in%buffer.not_exhausted ) then
      .in.read(word)
      if (word.is_dbl) then
        dist_max = word.to_dbl
      else
        word.to_lower_case
        in_units = word
        out_units = word
      end
      if (.in%buffer.not_exhausted ) then
        .in.read(word)
        word.to_lower_case
        out_units = word
      end
    end

    select case (trim(in_units))
      case ("atomic")
      case ("angstrom");  dist_max = dist_max * BOHR_PER_ANGSTROM
      case default; DIE("unknown input units " // in_units.trim)
    end
    select case (trim(out_units))
      case ("angstrom");             out_angstrom = TRUE
      case ("atomic");               out_angstrom = FALSE
      case ("fractional","crystal"); out_cartesian = FALSE
      case default; DIE("unknown output units " // in_units.trim)
    end

    .xtal.create_closest_molecule_list(operation_list,dist_list,.atom,dist_max)

    q=size(dist_list)
    if (operation_list(1,q) == 0) q=0

    max_thermal = ZERO      ! decide whether to output thermal parameters.
    put_thermal = FALSE
    do n=1, .n_atom
      do i=1,3
        do j=1,3
          if (.atom(n)%thermal_tensor(i,j) > max_thermal) &
            max_thermal = .atom(n)%thermal_tensor(i,j)
        end
      end
    end
    if (max_thermal > TOL(10)) put_thermal = TRUE

    .out.flush
    .out.text("Cluster input.")
    if (put_thermal) .out.text("Thermal parameters in crystal coordinates, A^2.")
    if (out_angstrom) then
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
         trim( dist_max.to_str ) // &
         " angstroms of the centre of the molecule.")
    else
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
         trim( dist_max.to_str ) // &
         " atomic units of the centre of the molecule.")
    end
    .out.put_text("atoms ")
    if (NOT out_cartesian) then
      .out.put_text("crystal")
    else if (out_angstrom) then
      .out.put_text("angstrom")
    else
      .out.put_text("atomic")
    end
    .out.flush

    atomvec_frac.create_copy( .atom )
    atomvec_frac.convert_to_crystal( .xtal%unitcell ) ! Put into fractionals
    atomvec.create( .n_atom )
    do q=1,size(dist_list)
      s = operation_list(1,q)
      if (s==0) exit
      h = operation_list(2,q)
      k = operation_list(3,q)
      l = operation_list(4,q)
      atomvec.copy(atomvec_frac)
      atomvec.seitz_multiply( transpose( .xtal%spacegroup%seitz(:,:,s) ))
      atomvec.translate((/ONE*h,ONE*k,ONE*l/))
      if (out_cartesian) atomvec.convert_from_crystal( .xtal%unitcell )   ! Convert to cartesians
      if (out_angstrom) atomvec.convert_to_angstrom
      do n = 1, .n_atom
        .out.put_text(trim( .atom(n)%label ),int_width=TRUE)
        .out.put(atomvec(n)%pos(1))
        .out.put(atomvec(n)%pos(2))
        .out.put(atomvec(n)%pos(3))
        if ( .atom.basis_all_labeled ) .out.put_str(" " // .atom(n)%basis%label)
        if (put_thermal) then
          atomvec(n)%thermal_tensor = atomvec(n)%thermal_tensor/(BOHR_PER_ANGSTROM)**2
          atomvec(n).thermal_tensor_to_crystal( .xtal%unitcell )
          .out.put(atomvec(n)%thermal_tensor(1,1))
          .out.put(atomvec(n)%thermal_tensor(2,2))
          .out.put(atomvec(n)%thermal_tensor(3,3))
          .out.put(atomvec(n)%thermal_tensor(1,2))
          .out.put(atomvec(n)%thermal_tensor(1,3))
          .out.put(atomvec(n)%thermal_tensor(2,3))
        end
        .out.flush
      end
    end
    .out.text("end",flush=2)
    operation_list.destroy
    dist_list.destroy
    atomvec.nullify_ptr_part;       atomvec.destroy
    atomvec_frac.nullify_ptr_part;  atomvec_frac.destroy
  end

end 
