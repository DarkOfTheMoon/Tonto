!-------------------------------------------------------------------------------
!
! MOL_io: these routines required by several modules in mol.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_IO

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL

   use BUFFER
   use INPUT
   use OUTPUT

   use VEC
   use IVEC
   use MAT
   use OPVEC
   use OPMAT

   use SHELL
   use SHELLVEC
   use BASIS
   use BASISVEC
   use ATOM
   use ATOMVEC

   use SCFDATA
   use ARCHIVE
   use VECDIIS

   use PLOTGRID
   use DFTGRID
   use POINTGROUP
   use XTAL
   use MOL_COMMON
   use MOL_XTAL

   implicit none         

#  include "macros"
#  include "mol_io.int"

contains

!  ************
!  Read methods
!  ************

   read_multiplicity
   ! Read in the spin multiplicity
      .in.read(.mult)
      ENSURE(.mult/=0,"cannot have zero multiplicity")
   end

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      .in.read(.gauge_origin)
      .delete_gauge_integrals
   end

   delete_gauge_integrals
   ! Delete all integral files which depend on the gauge origin. 
   ! This is required whenever the gauge origin is changed.
      ARCHIVE :: archive
      archive.set(.name,"Lx_matrix"); archive.delete
      archive.set(.name,"Ly_matrix"); archive.delete
      archive.set(.name,"Lz_matrix"); archive.delete
   end

   read_plotgrid [leaky]
   ! Read in the plot grid data
      if ( .xtal.destroyed) then
        .grid.read(.in,.atom)
      else if ( .xtal%unitcell.created) then
        .grid.read(.in,.atom,.xtal%unitcell)
      end
   end

   read_dftgrid [leaky]
   ! Read in the DFT grid data
      .dftgrid.destroy
      .dftgrid.create
      .dftgrid.read(.in)
      .dftgrid%archive.set_root_name(.name)
   end

   read_xtal [leaky]
   ! Read in the xtal data
      .xtal.destroy
      .xtal.create
      .xtal.read(.in)
   end

   read_pointgroup [leaky]
   ! Read in the pointgroup data
      .pointgroup.destroy
      .pointgroup.create
      .pointgroup.read(.in)
   end

   read_scfdata [leaky] 
   ! Read in the scf data
      .scfdata.destroy
      .scfdata.create
      .scfdata.read(.in)
      if (.scfdata%using_diis) then
      .scfdata%diis.set_archive_root_name(.name) 
      .scfdata%diis.set_archive_name("fock_matrix,DIIS")
      end
   end

   read_atoms [leaky]
   ! Read in the atom list information
      if (.xtal.destroyed)  .atom.read(.in)
      if (.xtal.created)    .atom.read(.in, .xtal%unitcell)
      DIE_IF( .atom.basis_part_labeled,"some empty basis labels exist")
      .resolve_basis_labels
      .set_atom_info
   end
  
  read_partition_data [leaky]
  ! Read the molecule partitioning data.
    STR :: word
    INT :: n
    DIE_IF( .atom.destroyed, "must have atoms defined first")
    .partition_factors.destroy
    .partition_factors.create( .n_atom )
    .partition_factors = ONE
    .in.read( .partition_model )
    do
      .in.read(word)
      word.to_lower_case
      if (word.is_not_int) exit
      n = word.to_int
      .in.read(word)
      ENSURE( word.is_dbl, 'expecting a number, got ' // '"' // word.trim // '"' //' instead')
      .partition_factors(n) = word.to_dbl
    end
  end

   read_basis_labels
   ! Read in a list of basis set labels for every atom in the molecule
   ! If a basis set is defined, all atoms must have a resolved basis set
      ENSURE( .atom.created,"no atoms in atom list")
      .atom.read_basis_labels(.in)
      .resolve_basis_labels
   end

   read_basis_sets [leaky]
   ! Read in a list of atomic basis sets for the molecule
      .basis.read(.in)
      .resolve_basis_labels
   end

   read_thermal_tensors
   ! Read in the thermal tensor data for all atoms
      .atom.read_thermal_tensors(.in, .xtal%unitcell)
   end

   read_thermal_smearing_model
   ! Read an allowed thermal smearing model for Fourier transform calculations
      INT :: model
      .in.read(model)
      ENSURE(model>=0 AND model<=3, "unknown thermal smearing model")
      .thermal_smearing_model = model 
   end

   read_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g. "restricted".
   ! For use with TONTO generated archives.
      STR :: name,kind
      ARCHIVE :: archive
      ENSURE(.in%buffer%n_items==3, "must specify an archive and a kind")
      .in.read(name)
      .in.read(kind)
      .out.text("reading archive : " // trim(name))
      archive.set(.name,name,kind)
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals)
         case ("density_matrix");     archive.read(.density_matrix)
         case ("natural_orbitals");   archive.read(.natural_orbitals)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("covalent_orbitals");  archive.read(.natural_orbitals)
         case ("ionic_orbitals");     archive.read(.natural_orbitals)
         case default;                DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_ascii_archive [leaky]
   ! Read the archive called "name". Must also specify a basis "kind", e.g. "restricted".
   ! If required, the input order may be specified as "by_row" (default) or "by_column".
      STR :: name,kind,order
      ARCHIVE :: archive
      ENSURE(.in%buffer%n_items==3, "must specify an archive and a kind")
      .in.read(name)
      .in.read(kind)
      order = "by_row"
      if ( .in%buffer.not_exhausted) .in.read(order)
      archive.set(.name,name,kind,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.read(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.read(.density_matrix,order=order)
         case ("natural_orbitals");   archive.read(.natural_orbitals,order=order)
         case ("occupation");         archive.read(.occupation)
         case ("occupation_numbers"); archive.read(.occupation)
         case ("fock_matrix");        .fock_matrix.create("restricted")
                                      archive.read(.fock_matrix,order=order)
         case default; DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

   read_g94_checkpoint_file [leaky]
   ! Read a g94 checkpoint file into TONTO
      STR :: name
      INPUT, PTR :: chkfile
      IVEC, PTR :: shell_l, nps, shell_to_atom, e_atom
      IVEC, PTR :: tmp_nps, tmp_sta, tmp_shells
      VEC, PTR :: tmp_pe, tmp_cc
      VEC, PTR :: pe, cc, extra_cc, temp_vec
      MAT, PTR :: temp_mat
      OPMAT, PTR :: temp_spin, temp_total
      INT :: c, t, a, s, u, m1, m2, prims
      INT :: n_shell, n_comp, n_cc
      ARCHIVE :: archive
      if ( .basis.created) .basis.destroy
      if ( .atom.created)  .atom.destroy
      name = trim(.name)       ! not name.fchk, so have to rename checkpoint file
      if ( .in%buffer.not_exhausted) .in.read(name)
      chkfile.create(name)
      chkfile.open
      chkfile.read_line
      chkfile.look_for("Number of atoms")
      chkfile.move_to_item(5); chkfile.read( .n_atom)
      chkfile.look_for("Charge")
      chkfile.move_to_item(3); chkfile.read( .charge)
      chkfile.look_for("Multiplicity")
      chkfile.move_to_item(3); chkfile.read( .mult)
      chkfile.look_for("Number of electrons")
      chkfile.move_to_item(5); chkfile.read( .n_e)
      chkfile.look_for("Number of alpha electrons")
      chkfile.move_to_item(6); chkfile.read( .n_a)
      chkfile.look_for("Number of beta electrons")
      chkfile.move_to_item(6); chkfile.read( .n_b)
      chkfile.look_for("Number of basis functions")
      chkfile.move_to_item(6); chkfile.read( .n_bf)
      chkfile.look_for("Number of contracted shells") 
      chkfile.move_to_item(6); chkfile.read( .n_shell)
      chkfile.look_for("Number of primitive shells")
      chkfile.move_to_item(6); chkfile.read( .n_prim)
      chkfile.look_for("Total Energy")
      chkfile.move_to_item(4)
      .scfdata.create; chkfile.read_dbl( .scfdata%energy )
      chkfile.look_for("Atomic numbers"); chkfile.read_line
      .atom.create( .n_atom)
      do a = 1, .n_atom
         chkfile.move_to_next_item
         chkfile.read( .atom(a)%atomic_number )
         .atom(a)%label = .atom(a).chemical_symbol.trim // a.to_str.trim
      end
      chkfile.look_for("Current cartesian coordinates")
      chkfile.read_line
      do a = 1, .n_atom
         chkfile.move_to_next_item
         chkfile.read( .atom(a)%pos)
      end
      chkfile.look_for("Shell types"); chkfile.read_line
      tmp_shells.create( .n_shell); tmp_nps.create( .n_shell)
      tmp_sta.create( .n_shell); tmp_pe.create( .n_prim)
      tmp_cc.create( .n_prim)
      nps.create( .n_shell); shell_to_atom.create( .n_shell)
      pe.create( .n_prim); cc.create( .n_prim)
      extra_cc.create( .n_prim)
      chkfile.read( tmp_shells)
      chkfile.look_for("Number of primitives per shell")
      chkfile.read_line; chkfile.read( tmp_nps)
      chkfile.look_for("Shell to atom map"); chkfile.read_line
      chkfile.read( tmp_sta)
      chkfile.look_for("Primitive exponents"); chkfile.read_line
      chkfile.read( tmp_pe)
      chkfile.look_for("Contraction coefficients"); chkfile.read_line
      chkfile.read( tmp_cc)
      e_atom.create( .n_atom); e_atom.zero
      prims = .n_prim
      if (any( tmp_shells == (-1) )) then
        do a = 1, .n_prim
           if (tmp_shells(a) == (-1)) then
              e_atom(tmp_sta(a)) = e_atom(tmp_sta(a)) + 1
              prims = prims + tmp_nps(a)
           end
        end
        chkfile.look_for("P(S=P)"); chkfile.read_line
        chkfile.read( extra_cc)
       end
      s = .n_shell + sum(e_atom)
      shell_l.create(s); nps.create(s)
      pe.create( prims); cc.create( prims)
      shell_to_atom.create(s)
      a = 0
      m1 = 1; m2 = 1
      do c = 1, .n_shell
        a = a + 1
        if (tmp_shells(c) == (-1)) then
           shell_l(a) = 0
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)) = tmp_pe(m2:m2+tmp_nps(c))
           cc(m1:m1+tmp_nps(c)) = tmp_cc(m2:m2+tmp_nps(c))
           a = a+1; m1=m1+tmp_nps(c)
           shell_l(a) = 1
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+tmp_nps(c)) = tmp_pe(m2:m2+tmp_nps(c))
           cc(m1:m1+tmp_nps(c)) = extra_cc(m2:m2+tmp_nps(c))
        else
           pe(m1:m1+tmp_nps(c)) = tmp_pe(m2:m2+tmp_nps(c))    
           cc(m1:m1+tmp_nps(c)) = tmp_cc(m2:m2+tmp_nps(c))
           shell_l(a) = tmp_shells(c)
           nps(a) = tmp_nps(c)
           shell_to_atom(a) = tmp_sta(c) 
        end
        m1 = m1 + tmp_nps(c); m2 = m2 + tmp_nps(c)
      end
      tmp_shells.destroy; tmp_sta.destroy
      tmp_nps.destroy; tmp_pe.destroy; tmp_cc.destroy
      .n_shell = s
      .n_prim = prims
      c = 0      ! for recording number of primitives read
      t = 0      ! for recording number of shells read
      .basis.create( .n_atom)
      do a = 1, .n_atom
         .basis(a)%label = .atom(a)%label.trim // "_g94_basis"
         n_shell = count(shell_to_atom==a)
         .basis(a)%n_shell = n_shell
         .basis(a)%shell.create(n_shell)
         .basis(a)%shell.nullify_ptr_part
         do s = 1, n_shell
            n_comp = shell_l(t+s).n_comp
            n_cc = nps(t+s)
            .basis(a)%shell(s)%l = shell_l(t+s)
            .basis(a)%shell(s)%n_comp = n_comp
            .basis(a)%shell(s)%n_cc = n_cc
            .basis(a)%shell(s)%ex.create( n_cc )
            .basis(a)%shell(s)%cc.create( n_cc )
            .basis(a)%shell(s)%ex = pe( c+1 : c+n_cc )
            .basis(a)%shell(s)%cc = cc( c+1 : c+n_cc )
            c = c + n_cc
         end
         .basis(a)%n_bf = .basis(a).no_of_basis_functions
         .basis(a)%n_prim = .basis(a).no_of_primitives
         .basis(a).unnormalise
         t = t + n_shell
      .atom(a)%basis.create
      .atom(a)%basis%label = .basis(a)%label
      end
      .resolve_basis_labels
      .set_atom_info
      temp_vec.create( .n_bf)
      chkfile.look_for("Alpha Orbital Energies")
      chkfile.read_line; chkfile.read( temp_vec)      
      if (chkfile.next_str == "Beta") then
         u = 1
         .scfdata%kind = "uhf"
         .orbital_energies.create( .n_bf, "beta")
         .orbital_energies.create( "alpha")
         chkfile.read_line; chkfile.read( .orbital_energies%beta)
         .orbital_energies%alpha = temp_vec
         temp_vec.destroy
      else
         u = 0
         .scfdata%kind = "rhf"
         .orbital_energies.create( .n_bf, "restricted")
         .orbital_energies%restricted = temp_vec
         temp_vec.destroy
      end
      temp_mat.create( .n_bf, .n_bf)
      chkfile.look_for("Alpha MO"); chkfile.read_line
      chkfile.read( temp_mat)
      temp_mat = transpose( temp_mat)
      if (chkfile.next_str == "Beta") then
         .molecular_orbitals.create( .n_bf, "beta")
         .molecular_orbitals.create( "alpha")
         chkfile.read_line; chkfile.read( .molecular_orbitals%beta)
         .molecular_orbitals%beta = transpose( .molecular_orbitals%beta)
         .molecular_orbitals%alpha = temp_mat
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals%alpha,"row") 
         .swap_g94_orbital_order(.molecular_orbitals%beta, "row") 
      else
         .molecular_orbitals.create(.n_bf, "restricted")
         .molecular_orbitals%restricted = temp_mat
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals%restricted,"row") 
      end
      if (u==0) then
         .density_matrix.create( .n_bf, "restricted")
         .density_matrix%triangle.create( .density_matrix.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( .density_matrix%triangle)
         .density_matrix.uncompress
         .swap_g94_orbital_order(.density_matrix%restricted,"row") 
         .swap_g94_orbital_order(.density_matrix%restricted,"column") 
         .make_restricted_NOs
      else
         temp_total.create( .n_bf, "restricted")
         temp_spin.create( .n_bf, "restricted")
         temp_total%triangle.create( temp_total.l_compress( "restricted"))
         chkfile.look_for( "Total SCF Density"); chkfile.read_line
         chkfile.read( temp_total%triangle)
         temp_total.uncompress
         temp_spin%triangle.create( temp_spin.l_compress( "restricted"))
         chkfile.look_for( "Spin SCF Density"); chkfile.read_line    
         chkfile.read( temp_spin%triangle)
         temp_spin.uncompress
         .density_matrix.create( .n_bf, "alpha")
         .density_matrix.create( "beta")
         .density_matrix%beta = (temp_total%restricted - temp_spin%restricted)/2
         .density_matrix%alpha = (temp_spin%restricted + temp_total%restricted)/2 
         temp_spin.destroy
         temp_total.destroy
         .swap_g94_orbital_order(.density_matrix%alpha,"row") 
         .swap_g94_orbital_order(.density_matrix%alpha,"column") 
         .swap_g94_orbital_order(.density_matrix%beta, "row") 
         .swap_g94_orbital_order(.density_matrix%beta, "column") 
         .make_unrestricted_NOs
      end
      pe.destroy; cc.destroy; extra_cc.destroy
      shell_to_atom.destroy; nps.destroy; e_atom.destroy
      shell_l.destroy; chkfile.close; chkfile.destroy
      ! Save data in archive files
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)
    ! archive.set(.name,"HF_density_matrix")
    ! archive.write(.density_matrix)
    ! archive.set(.name,"HF_molecular_orbitals")
    ! archive.write(.molecular_orbitals)
    ! archive.set(.name,"HF_orbital_energies")
    ! archive.write(.orbital_energies)
   end

   swap_g94_orbital_order(X,swap) 
   ! Swap the order of f orbitals on matrix "X" after reading a g94 checkpoint file,
   ! for "swap" equal to "row" or "1", or "coloumn" or "2". 
      MAT :: X
      STR(*) :: swap
      INT :: n,f,l
      IVEC(10) :: ff = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8,10 /)
      select case (swap)
         case("row","1")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
            end
         case("column","2")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               DIE_IF((l-f)>9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
            end
         case default
            DIE("unknown swap option")
      end
   end

   write_wfn_file [leaky]
   ! writes a .wfn file for input to morphy98
      STR :: name
      OUTPUT, PTR :: wfnfile
      IVEC, PTR :: lvec
      VEC, PTR :: evec
      MAT, PTR :: dmatrix, cc
      INT :: i, j, pcount, n_orbitals, b, a, l
      STR, parameter :: title_format = "(A80)"
      STR, parameter :: n_vars_format = "(A8, 12X, I3, 17X, I3, 17X, I3, 17X)"
      STR, parameter :: atom_format = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      STR, parameter :: c_assignment_format = "('CENTRE ASSIGNMENTS  ', 20I3)"
      STR, parameter :: t_assignment_format = "('TYPE ASSIGNMENTS    ', 20I3)"
      STR, parameter :: exponent_format = "('EXPONENTS ', 5E14.7)"
      STR, parameter :: mol_title_format = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      STR, parameter :: coefficient_format = "(5E16.8)"
      STR, parameter :: e_v_format = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"
      name = .name 
      if (.in%buffer.not_exhausted) .in.read(name)
      wfnfile.create( name)
      wfnfile.open
      if (mod( .n_e, 2) == 0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end
      write( unit = wfnfile%unit, fmt = title_format) trim( name) // " computed by TONTO"
      write( unit = wfnfile%unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write( unit = wfnfile%unit, fmt = atom_format) ( .atom(i)%label, i, i, &
         .atom(i)%pos, dble( .atom(i)%atomic_number ) , i = 1, .n_atom)
      write( unit = wfnfile%unit, fmt = c_assignment_format) (( j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )
      pcount = 1
      lvec.create( .n_prim)
      evec.create( .n_prim)
      do a = 1, .n_atom
         do b = 1, .basis(a)%n_shell
            l = .atom(a)%basis%shell(b)%l.n_comp_sum - .atom(a)%basis%shell(b)%n_comp
            do j = pcount, pcount + .atom(a)%basis%shell(b).n_prim - 1, .atom(a)%basis%shell(b)%n_comp
               do i = 1, .atom(a)%basis%shell(b)%n_comp
                  evec( j + i - 1) = .atom(a)%basis%shell(b)%ex(1 + (j - pcount) / .atom(a)%basis%shell(b)%n_comp)
                  lvec( j + i - 1) = l + i
               end
            end
            pcount = pcount + .atom(a)%basis%shell(b).n_prim
         end
      end
      write(unit = wfnfile%unit, fmt = t_assignment_format) lvec
      write( unit = wfnfile%unit, fmt = exponent_format) evec 
      lvec.destroy
      evec.destroy
      dmatrix.create( .n_prim, .n_bf)
      dmatrix.zero
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)
      dmatrix = matmul( cc, .molecular_orbitals%restricted)
      do i = 1, n_orbitals
         write( unit = wfnfile%unit, fmt = mol_title_format) "MO  ", i, "OCC NO = ", &
            .occupation%restricted(i), " ORB. ENERGY = ", .orbital_energies%restricted(i)
         write( unit = wfnfile%unit, fmt = coefficient_format) dmatrix(:, i)
      end
      write( unit = wfnfile%unit, fmt = "(1A8)") "END DATA"
      write( unit = wfnfile%unit, fmt = e_v_format) .scfdata%energy, 2.0D00
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy
   end
   
   write_ascii_archive
   ! Write the archive called "name". The kind is defined by the object to be written.
   ! If required, the output order may be specified as "by_row" (default) or "by_column".
      STR :: name,order
      ARCHIVE :: archive
      .in.read(name)
      order = "by_row"
      if ( .in%buffer.not_exhausted) .in.read(order)
      archive.set(.name,name,format="ascii")
      select case (name)
         case ("molecular_orbitals"); archive.write(.molecular_orbitals,order=order)
         case ("density_matrix");     archive.write(.density_matrix,order=order)
         case ("natural_orbitals");   archive.write(.natural_orbitals,order=order)
         case ("occupation");         archive.write(.occupation,order=order)
         case ("fock_matrix");        archive.write(.fock_matrix,order=order)
         case default;     DIE("unknown ascii archive name, " // trim(name))
      end
      archive.close
   end

!  **************
!  Output methods
!  **************

   put
   ! Put all the available molecule information on file "out"
      .out.flush
      .out.text("Molecule output:")
      .out.show("Name                   =",.name)
      .out.show("Chemical Formula       =",trim(.chemical_formula))
      .out.show("Charge                 =",.charge)
      .out.show("Multiplicity           =",.mult)
      .out.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
      .out.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
      .out.show("B field Gauge origin   =",.gauge_origin)
      .out.show("No of atoms            =",.n_atom)
      .out.show("No of electrons        =",.n_e)
      .out.show("No of alpha electrons  =",.n_a)
      .out.show("No of beta  electrons  =",.n_b)
      .out.show("No. of basis sets      =",.n_basis)
      .out.show("No. of shells          =",.n_shell)
      .out.show("No. of shell pairs     =",.n_shell_pairs)
      .out.show("No. of shell quartets  =",.n_shell_quartets)
      .out.show("No. of basis functions =",.n_bf)
      .out.show("No. of primitives      =",.n_prim)
      if (.atom.created)        .put_atoms
      if (.atom.basis_resolved) .put_basis
      if (.pointgroup.created)  .put_pointgroup
      if (.xtal.created)        .put_xtal
      if (.grid.created)        .put_grid
      if (.dftgrid.created)     .put_dftgrid
   end

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put(.out)
   end

  put_grid
  ! Output the current grid.
    if (.grid.created) then
      .grid.put(.out)
    else
      WARN("no grid to output")
    end
  end

  put_dftgrid
  ! Output the current DFT grid.
    if (.dftgrid.created) then
      .dftgrid.put(.out)
    else
      WARN("no DFT grid to output")
    end
  end

  put_thermal_tensors
  ! Output the thermal tensors if they exist.
    INT :: i
    if (NOT .thermal_smearing_model == 0) then
      .out.flush
      .out.put_text("Thermal smearing model =")
      select case (.thermal_smearing_model)
        case (1);  .out.put("Stewart")
        case (2);  .out.put("Coppens")
        case (3);  .out.put("Tanaka")
      end
      .out.flush(2)
      .out.text("Thermal parameters in cartesian coordinates.")
      .out.put("atom",int_width=TRUE)
      .out.put("U11")
      .out.put("U22")
      .out.put("U33")
      .out.put("U12")
      .out.put("U13")
      .out.put("U23")
      .out.flush
      do i = 1, .n_atom
        .out.put(i)
        .atom(i).put_thermal_tensor( .out )
        .out.flush
      end
      .out.flush
      .out.text("Thermal parameters in crystal coordinates.")
      .out.put("atom",int_width=TRUE)
      .out.put("U11")
      .out.put("U22")
      .out.put("U33")
      .out.put("U12")
      .out.put("U13")
      .out.put("U23")
      .out.flush
      do i = 1, .n_atom
        .atom(i)%thermal_tensor = .atom(i)%thermal_tensor/(BOHR_PER_ANGSTROM)**2
        .atom(i).thermal_tensor_to_crystal( .xtal%unitcell )
        .out.put(i)
        .atom(i).put_thermal_tensor( .out )
        .out.flush
        .atom(i).treat_thermal_tensor( .xtal%unitcell )
        .atom(i)%thermal_tensor = .atom(i)%thermal_tensor*(BOHR_PER_ANGSTROM)**2
      end
      .out.flush
    end
  end

   put_xtal
   ! Output the current xtal
      .put_thermal_tensors
      if (.xtal.F_calc_exists AND F_exp_exists_(self%xtal)) .xtal.update_gof_parameters
      .xtal.put(.out)
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      .out.flush
      .out.text("Molecular orbitals:")
      .out.put( .molecular_orbitals)
   end

   put_mos_and_energies
   ! Output the current associated molecular orbitals and their energies
      .out.flush
      .out.text("Molecular orbital energies:")
      .out.put( .orbital_energies, format="column")
      .out.flush
      .out.text("Molecular orbitals:")
      .out.put( .molecular_orbitals)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      .out.flush
      .out.text("Natural orbital occupations:")
      .out.put( .occupation, format="column")
      .out.flush
      .out.text("Natural orbitals:")
      .out.put( .natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix 
      if (.density_matrix.destroyed) then
        .out.flush(2)
        .out.put_text(" * * * Density matrix not available to print * * *",flush=2)
      else
        .out.flush
        .out.text("Density matrix:")
        .out.put( .density_matrix)
      end
   end

   put_fock_matrix
   ! Output the current associated fock matrix 
      if (.fock_matrix.destroyed) then
        .out.flush(2)
        .out.put_text(" * * * Fock matrix not available to print * * *",flush=2)
      else
        .out.flush
        .out.text("Fock matrix:")
        .out.put( .fock_matrix)
      end
   end

   put_atoms
   ! Output the atom basis set information
      INT :: i,n_dbl,temp1,temp2
      BIN :: basis_exists
      ENSURE( .atom.created,"no atom list")
      .out.flush
      .out.text("Atoms:")
      .out.flush
      basis_exists = .atom.basis_all_labeled
      n_dbl = 3
      if (basis_exists) n_dbl = 4
      temp1 = .out%dbl_width
      temp2 = (80-3*.out%int_width)/n_dbl
      .out.set_dbl_width(temp2)
      .out.dash(int_fields=3,dbl_fields=n_dbl)
      .out.put("#",int_width=TRUE)
      .out.put("ID",int_width=TRUE)
      .out.put("Z",int_width=TRUE)
      .out.put("x")
      .out.put("y")
      .out.put("z")
      if (basis_exists) .out.put("Basis")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=n_dbl)
      do i = 1,.n_atom
         .out.put(i)
         .out.put(.atom(i)%label,int_width=TRUE)
         .out.put(.atom(i)%atomic_number)
         .out.put(.atom(i)%pos(1))
         .out.put(.atom(i)%pos(2))
         .out.put(.atom(i)%pos(3))
         if (basis_exists) .out.put(.atom(i)%basis%label)
         .out.flush
      end 
      .out.dash(int_fields=3,dbl_fields=n_dbl)
      .out.set_dbl_width(temp1)
      .atom.put_bond_length_table(.out)
      .atom.put_bond_angle_table(.out)
      .atom.put_torsion_angle_table(.out)
      .out.flush
   end 

   put_basis
   ! Output the molecule basis set information
      .basis.put(.out)
   end 

   put_PND_sf
   ! Output the magnetic structure factors
      CVEC, PTR :: FM_s, FM_l, FM_r
      ARCHIVE :: archive
      INT :: n
      FM_s.create( .xtal%n_refl)
      archive.set(.name,"PND_spin_sf")
      archive.read(FM_s)
      FM_l.create( .xtal%n_refl)
      archive.set(.name,"PND_nabla_sf")
      archive.read(FM_l)
      FM_r.create( .xtal%n_refl)
      archive.set(.name,"PND_r_sf")
      archive.read(FM_r)
      .out.text("PND magnetic structure factors:")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=4)
      .out.put("h", int_width=TRUE)
      .out.put("k", int_width=TRUE)
      .out.put("l", int_width=TRUE)
      .out.put("FM_s")
      .out.put("FM_l")
      .out.put("FM_r")
      .out.put("FM")
      .out.flush
      .out.dash(int_fields=3,dbl_fields=4)
      do n = 1, .xtal%n_refl
         .out.put( .xtal%h(n))
         .out.put( .xtal%k(n))
         .out.put( .xtal%l(n))
         .out.put( real(FM_s(n)) )
         .out.put( real(FM_l(n)) )
         .out.put( real(FM_r(n)) )
         .out.put( real(FM_s(n)+FM_l(n)+FM_r(n)) )
         .out.flush
      end
      .out.dash(int_fields=3,dbl_fields=4)
      FM_r.destroy
      FM_l.destroy
      FM_s.destroy
   end

  put_cluster_operations
  ! Outputs a list of the symmetry operations and translations of the molecules which
  ! are within distance_max of the centre of the molecule.
    IMAT, PTR :: operation_list,indices
    VEC, PTR :: dist_list
    INT :: q
    DBL :: dist_max
    STR :: word,in_units
    BIN :: out_angstrom

    ! default input and output is atomic units.
    dist_max = 5
    out_angstrom = FALSE

    if (.in%buffer.not_exhausted ) then
      .in.read(word)
      if (word.is_dbl) then
        dist_max = word.to_dbl
        if (.in%buffer.not_exhausted ) then
          .in.read(word)
          word.to_lower_case
          select case (trim(word))
            case ("atomic");               out_angstrom = FALSE
            case ("angstrom");             out_angstrom = TRUE
                         dist_max = dist_max * BOHR_PER_ANGSTROM
            case default; DIE("unknown units " // trim(word))
          end
        end
      else
        word.to_lower_case
        select case (trim(word))
          case ("atomic");               out_angstrom = FALSE
          case ("angstrom");             out_angstrom = TRUE
                       dist_max = dist_max * BOHR_PER_ANGSTROM
          case default; DIE("unknown units " // trim(word))
        end
      end
      if (.in%buffer.not_exhausted ) then
        .in.read(word)
        word.to_lower_case
        select case (trim(word))
          case ("atomic");               out_angstrom = FALSE
          case ("angstrom");             out_angstrom = TRUE
          case default; DIE("unknown units " // trim(word))
        end
      end
    end

    .xtal.create_closest_molecule_list(operation_list,dist_list,.atom,dist_max,indices)

    q=size(dist_list)
    .out.flush
    .out.text("Cluster molecules closest to the centre of the molecule.")
    if (out_angstrom) then
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
       trim( dist_max.to_str ) // " angstroms of the centre of the molecule.")
    else
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
       trim( dist_max.to_str ) // " au of the centre of the molecule.")
    end
    .out.put("symop",int_width=TRUE)
    .out.put("h",int_width=TRUE)
    .out.put("k",int_width=TRUE)
    .out.put("l",int_width=TRUE)
    if (out_angstrom) then
      .out.put("distance (angstrom)")
    else
      .out.put("distance (au)")
    end
    .out.put("index 1",int_width=TRUE)
    .out.put("index 2",int_width=TRUE)
    .out.flush
    do q=1,size(dist_list)
      if (operation_list(1,q)==0) exit
      .out.put(operation_list(1,q))
      .out.put(operation_list(2,q))
      .out.put(operation_list(3,q))
      .out.put(operation_list(4,q))
      .out.put(dist_list(q))
      .out.put(indices(1,q))
      .out.put(indices(2,q))
      .out.flush
    end
    indices.destroy
    operation_list.destroy
    dist_list.destroy
  end

  put_cluster_input
  ! Outputs the input data for a cluster of molecules around the centre of the molecule.
    ATOMVEC, PTR :: atomvec_frac,atomvec
    IMAT, PTR :: operation_list
    VEC, PTR :: dist_list
    STR :: word,out_units
    INT :: s,h,k,l,n,q,i,j
    DBL :: dist_max,max_thermal
    BIN :: out_cartesian,out_angstrom,put_thermal

    ! default input and output is atomic units.
    dist_max = 5
    out_angstrom = FALSE
    out_cartesian = TRUE

    if (.in%buffer.not_exhausted ) then
      .in.read(word)
      if (word.is_dbl) then
        dist_max = word.to_dbl
        if (.in%buffer.not_exhausted ) then
          .in.read(word)
          word.to_lower_case
          select case (trim(word))
            case ("atomic");               out_angstrom = FALSE
            case ("angstrom");             out_angstrom = TRUE
                         dist_max = dist_max * BOHR_PER_ANGSTROM
            case ("fractional","crystal"); out_cartesian = FALSE
            case default; DIE("unknown units " // trim(word))
          end
        end
      else
        word.to_lower_case
        select case (trim(word))
          case ("atomic");               out_angstrom = FALSE
          case ("angstrom");             out_angstrom = TRUE
                       dist_max = dist_max * BOHR_PER_ANGSTROM
          case ("fractional","crystal"); out_cartesian = FALSE
          case default; DIE("unknown units " // trim(word))
        end
      end
      if (.in%buffer.not_exhausted ) then
        .in.read(word)
        word.to_lower_case
        select case (trim(word))
          case ("atomic");               out_angstrom = FALSE
          case ("angstrom");             out_angstrom = TRUE
          case ("fractional","crystal"); out_cartesian = FALSE
          case default; DIE("unknown units " // trim(word))
        end
      end
    end

    .xtal.create_closest_molecule_list(operation_list,dist_list,.atom,dist_max)

    q=size(dist_list)
    if (operation_list(1,q) == 0) q=0

    max_thermal = ZERO      ! decide whether to output thermal parameters.
    put_thermal = FALSE
    do n=1, .n_atom
      do i=1,3
        do j=1,3
          if (.atom(n)%thermal_tensor(i,j) > max_thermal) &
            max_thermal = .atom(n)%thermal_tensor(i,j)
        end
      end
    end
    if (max_thermal > TOL(10)) put_thermal = TRUE

    .out.flush
    .out.text("Cluster input.")
    if (put_thermal) .out.text("Thermal parameters in crystal coordinates, A^2.")
    if (out_angstrom) then
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
         trim( dist_max.to_str ) // &
         " angstroms of the centre of the molecule.")
    else
      .out.text("There are " // trim( q.to_str ) // " molecules within " // &
         trim( dist_max.to_str ) // &
         " atomic units of the centre of the molecule.")
    end
    .out.put_text("atoms ")
    if (NOT out_cartesian) then
      .out.put_text("crystal")
    else if (out_angstrom) then
      .out.put_text("angstrom")
    else
      .out.put_text("atomic")
    end
    .out.flush

    atomvec_frac.create_copy( .atom )
    atomvec_frac.convert_to_crystal( .xtal%unitcell ) ! Put into fractionals
    atomvec.create( .n_atom )
    do q=1,size(dist_list)
      s = operation_list(1,q)
      if (s==0) exit
      h = operation_list(2,q)
      k = operation_list(3,q)
      l = operation_list(4,q)
      atomvec.copy(atomvec_frac)
      atomvec.seitz_multiply( transpose( .xtal%spacegroup%seitz(:,:,s) ))
      atomvec.translate((/ONE*h,ONE*k,ONE*l/))
      if (out_cartesian) atomvec.convert_from_crystal( .xtal%unitcell )   ! Convert to cartesians
      if (out_angstrom) atomvec.convert_to_angstrom
      do n = 1, .n_atom
        .out.put_text(trim( .atom(n)%label ),int_width=TRUE)
        .out.put(atomvec(n)%pos(1))
        .out.put(atomvec(n)%pos(2))
        .out.put(atomvec(n)%pos(3))
        if ( .atom.basis_all_labeled ) .out.put_str(" " // .atom(n)%basis%label)
        if (put_thermal) then
          atomvec(n)%thermal_tensor = atomvec(n)%thermal_tensor/(BOHR_PER_ANGSTROM)**2
          atomvec(n).thermal_tensor_to_crystal( .xtal%unitcell )
          .atom(i).put_thermal_tensor( .out )
        end
        .out.flush
      end
    end
    .out.text("end",flush=2)
    operation_list.destroy
    dist_list.destroy
    atomvec.nullify_ptr_part;       atomvec.destroy
    atomvec_frac.nullify_ptr_part;  atomvec_frac.destroy
  end

  output_for_steves_program
  ! Output files for Steve's program.
    OUTPUT, PTR :: out1,out2,out3
    BASIS, PTR :: basis
    SHELL, PTR :: shell
    STR :: label
    INT :: i,j,k
    ENSURE( .xtal.created, "need crystal info")
    ENSURE( .molecular_orbitals.any_created, "need MOs")

    out1.create("mol." // trim(.name))
    out1%labels = FALSE
    out1.open
    out1.show("MOL:MOL     ", trim(.name), int_width=TRUE)
    out1.show("ENERGY(au): ", "I dunno", int_width=TRUE)
    out1.flush
    out1.show("NUMBERS:    ",1)
    out1.show("NBAS:       ", .n_bf)
    out1.show("NALPH:      ", .n_a)
    out1.show("NBETA:      ", .n_b)
    out1.flush
    out1.show("DET:        ", 0)
    out1.flush
    out1.show("COORD:      ", .n_atom)
    do i = 1, .n_atom
      out1.put_text( .atom(i).chemical_symbol , int_width=TRUE)
      out1.put( .atom(i)%pos )
    end
    out1.flush
    out1.text("BASIS")
    out1.flush
    do i = 1, size(.basis)
      basis => .basis(i)
      do j = 1, .n_atom
        if (.atom(j)%basis%label == basis%label) then
          label = .atom(j).chemical_symbol
          exit
        end
      end
      out1.put_text( trim(label) , int_width=TRUE)
      out1.put_text( trim( basis%n_shell.to_str ) , int_width=TRUE, flush=1)
      do j = 1, basis%n_shell
        shell => basis%shell(j)
        out1.put( shell%l.to_str, int_width=TRUE)
        out1.put(shell%n_cc)
        out1.put(ONE, flush=1)
        do k = 1, shell%n_cc
          out1.put( shell%ex(k))
          out1.put( shell%cc(k))
          out1.flush
        end
      end
    end
    out1.flush
    out1.set_dbl_width(15)
    out1.set_dbl_style("d")
    out1.set_dbl_precision(7)
    out1.set_fields(5)
    select case (.scfdata.spinorbital_kind)
      case ("unrestricted")
        out1.text("COEFF-A:")
        do i = 1, .n_bf
          out1.put_vec(.molecular_orbitals%alpha(:,i))
        end
        out1.flush
        out1.text("COEFF-B:")
        do i = 1, .n_bf
          out1.put_vec(.molecular_orbitals%beta(:,i))
        end
      case ("restricted")
        out1.text("COEFF-A:")
        do i = 1, .n_bf
          out1.put_vec(.molecular_orbitals%restricted(:,i))
        end
        out1.flush
        out1.text("COEFF-B:")
        do i = 1, .n_bf
          out1.put_vec(.molecular_orbitals%restricted(:,i))
        end
      case default
    end
    out1.close
    out1.destroy

    out2.create("sf.run")
    out2.open
    out2.show("CRYSTAL:", trim(.name))
    out2.show("TFMODEL:", 0)
    out2.show("DENSITY:", "C")
    out2.show("OUTPUT: ", 3)
    out2.put_text("HKL: IN:")
    out2.put(.xtal%n_refl,flush=1)
    do i = 1, .xtal%n_refl
      out2.put(.xtal%h(i))
      out2.put(.xtal%k(i))
      out2.put(.xtal%l(i))
      out2.flush
    end
    out2.close
    out2.destroy

    out3.create("cx." // trim(.name))
    out3%labels = FALSE
    out3.set_dbl_width(15)
    out3%int_width = 4
    out3.open
    out3.text("CRYSTAL:" // trim(.name))
    out3.flush
    out3.put_text("SYM:    " // trim(.xtal%spacegroup%IT_symbol), flush=1)
    out3.put_text("ANGLES:")
    out3.put(.xtal%unitcell%angle(1)*DEGREE_PER_RADIAN)
    out3.put(.xtal%unitcell%angle(2)*DEGREE_PER_RADIAN)
    out3.put(.xtal%unitcell%angle(3)*DEGREE_PER_RADIAN)
    out3.put_text(" deg",flush=1)
    out3.put_text("LENGTH:")
    out3.put(.xtal%unitcell%length(1)*ANGSTROM_PER_BOHR)
    out3.put(.xtal%unitcell%length(2)*ANGSTROM_PER_BOHR)
    out3.put(.xtal%unitcell%length(3)*ANGSTROM_PER_BOHR)
    out3.put_text(" ang",flush=2)
    out3.show("NMOL: ",1)
    out3.flush
    out3.show("MOL:  ",trim(.name))
    out3.put_text("COORD:")
    out3.put(.xtal%spacegroup%position(1))
    out3.put(.xtal%spacegroup%position(2))
    out3.put(.xtal%spacegroup%position(3))
    out3.put_text(" none",flush=1)
    out3.show("RMAT: ",1)
    out3.put(.xtal%unitcell%rotation_matrix)
    out3.show("MSDMAT:", .n_atom)
    do i = 1, .n_atom
      out3.put(i)
      .atom(i).put_thermal_tensor(out3)
      out3.flush
    end
    out3.close
    out3.destroy
  end

end 
