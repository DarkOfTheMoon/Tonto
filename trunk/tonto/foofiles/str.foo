!---------------------------------------------------------------------------
!  STR: methods of dealing with arbitrary length character strings
!
!  Notes
!          
!  Normally, a STR variable means a character string of length STR_SIZE.
!  However, in this module we use arbitrary length character strings.
!
!  (c) dylan jayatilaka, 1998
!
! $Id$
!
!---------------------------------------------------------------------------
module STR

   use TYPES
   use SYSTEM

   implicit none

#  include "macros"
#  undef  STR_SIZE 
#  define STR_SIZE  *
#  include "str.int"

   interface scan
      index_of_character_in
   end

   interface verify
      index_of_character_not_in
   end

contains

   create
   ! Create space for a string variable
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(len(self)*CHR_SIZE)
      self = " "
   end

   destroy
   ! Destroy space for a string variable
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(len(self)*CHR_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   same_as(string) result (same)
   ! Test to see if the string is the same as another string
      STR, IN :: string
      BIN :: same
      same = self==string
   end
     
   item(n) result(word)
   ! Return the item no. "n" in the string as a "word"
      INT :: n
      CHR(len(self)) :: word
      .get_item(word,n)
   end
     
   get_item(word,n)
   ! Get the item no. "n" in the string
      INT :: n
      CHR(len(self)) :: word
      INT :: i,f,l
      f = 1
      do i = 1,n
         self(f:).get_next_item(word,last=l)
         if (word=="") exit
         f = f + l 
      end
   end

   get_next_item(word,first,last,comment_chars,quote_chars)
   ! Get the first sequence of non-blank characters in the string (i.e. a "word")
   ! and the first and last character positions of the word in the string.
   ! If the first character of the word is a double quote, then all text between
   ! it and the next double quote is treated as one word.
   ! If comment_chars is present, the rest of the string following these
   ! comment characters is ignored .
      INT, OUT, optional :: first,last
      STR, optional :: comment_chars,quote_chars
      STR(16) :: quotes
      CHR(len(self)) :: word
      CHR(len(comment_chars)) :: cc
      INT :: f,l
      quotes = '"'
      if (present(quote_chars)) quotes = quote_chars
      self.get_next_item_position(f,l) 
      cc = ""
      if (present(comment_chars)) cc = comment_chars    
      if (f==0) then                            ! all characters are blanks
         word = ""
      else if (scan(self(f:f),quotes) /= 0) then           ! quotes
         f = f+1
         l = self(f:).quote_position(trim(quotes))
         DIE_IF(l==0,"unclosed quotes")
         l = f+l-2
         word = self(f:l)
         l = l+1
      else if ( self(f:f).has_any_characters_in(cc) ) then   ! comments
         l = f-1
         word = ""
      else
         word = self(f:l)
      end
      if(present(first)) first = f 
      if(present(last))  last  = l
   end

   get_next_item_position(first,last) 
   ! Get the first and last character positions of the first sequence of 
   ! non-blank characters in the string (i.e. a "word")
      INT, OUT :: first,last
      first = verify(self," ")   
      last = scan(self(max(first,1):)//" "," ") - 1 
      last = last + max(first,1) - 1
      last = max(last,0)
   end 

   quote_position(quote_chars) result (pos)
   ! Find the position of the first double quote character.
     INT :: pos
     STR, optional :: quote_chars
     if (present(quote_chars)) then
       pos = scan(self,quote_chars)
     else
       pos = index(self,'"')
     end
   end

   insert(string,position)
   ! Insert "string" at "position" into the original string
      STR, IN :: string
      INT, IN :: position
      self(position:) = string
   end 

   left_justify
   ! Remove leftmost blank characters by shifting all characters to the left
      self = adjustl(self)
   end

   right_justify
   ! Remove rightmost blank characters by shifting all characters to the right
      self = adjustr(self)
   end

   index_of_substring(substring,backwards) result(ind)
   ! Return the starting index of a substring in the original string
      STR, IN :: substring
      BIN, optional:: backwards
      INT :: ind
      if (present(backwards)) then
         ind = index(self,substring,backwards)
      else
         ind = index(self,substring)
      end
   end

   is_included_in(string) result(res)
   ! Return true if self is included in string. Traling blanks in self are ignored
      STR, IN :: string
      BIN :: res
      INT :: ind
      ind = index(string,self(1:len_trim(self)))
      res = (ind/=0)
   end

   includes(string) result(res)
   ! Return true if self includes string. Traling blanks in self are ignored
      STR, IN :: string
      BIN :: res
      INT :: ind
      ind = index(self(1:len_trim(self)),string)
      res = (ind/=0)
   end

   does_not_include(string) result(res)
   ! Return true if self does not include string. Traling blanks in self are ignored
      STR, IN :: string
      BIN :: res
      INT :: ind
      ind = index(self(1:len_trim(self)),string)
      res = (ind==0)
   end

   has_any_characters_in(set) result(res)
   ! Return TRUE if self has any of the characters in "set".
      STR, IN :: set
      BIN :: res
      res = .scan(set)/=0
   end

   index_of_character_in(set,backwards) result(ind)
   ! In self, scan from left to right for the index of the character in "set".
   ! If backwards is present and true, scan from right to left
      STR, IN :: set
      BIN, optional:: backwards
      INT :: ind
      if (present(backwards)) then
         ind = scan(self,set,backwards)
      else
         ind = scan(self,set)
      end
   end

   index_of_character_not_in(set,backwards) result(ind)
   ! In self, scan from left to right for the index of the character *not* in "set".
   ! If backwards is present and true, scan from right to left
      STR, IN  :: set
      BIN, optional:: backwards
      INT :: ind
      if (present(backwards)) then
         ind = verify(self,set,backwards)
      else
         ind = verify(self,set)
      end
   end

   to_lower_case 
   ! Change upper case charaters to lower case in the original string
      INT :: i
      do i = 1,len(self)
         if("A"<=self(i:i) AND self(i:i)<="Z") then
            self(i:i) = achar(iachar(self(i:i))+32)
         end
      end
   end

   to_upper_case 
   ! Change lower case charaters to upper case in the original string
      INT :: i
      do i = 1,len(self)
         if("a"<=self(i:i) AND self(i:i)<="z") then
            self(i:i) = achar(iachar(self(i:i))-32)
         end
      end
   end

!  *****************
!  Inquiry functions
!  *****************
      
   is_dbl result(res)
   ! Returns true if the string can be interpred as a dbl number
      BIN :: res
      DBL :: value
      INT :: i,ios

! Stupid DEC compiler returns ios=0 for any word starting with "F".
! Had to add some other tests.
!      read(unit=self,fmt=*,iostat=ios) value
!      res = ios==0

! I've probably missed some here, so just put them in.
      i = .index_of_character_not_in("0123456789.dDqQeE_ ")
      if (i>0) then
        res = FALSE
      else
        read(unit=self,fmt=*,iostat=ios) value
        res = ios==0
      end
   end

   is_int result(res)
   ! Returns true if the string can be interpred as an integer number
      BIN :: res
      INT :: value,ios
      BIN :: char
      char = NOT self(1:1).has_any_characters_in("0123456789")
      if (char) then 
         res = FALSE
      else
         read(unit=self,fmt=*,iostat=ios) value
         res = ios==0
      end
   end
      
   is_bin result(res)
   ! Returns true if the string can be interpred as a logical
      BIN :: res
      STR(len(self)) :: word
      read(unit=self,fmt=*) word
      word.to_lower_case
      select case (word)
         case("true", "t","on", "yes","y"); res = TRUE
         case("false","f","off","no", "n"); res = TRUE
         case default;                      res = FALSE
      end
   end
      
   is_not_dbl result(res)
   ! Returns true if the string can't be interpred as a dbl number
      BIN :: res
      DBL :: value
      INT :: ios
      read(unit=self,fmt=*,iostat=ios) value
      res = ios/=0
   end
      
   is_not_int result(res)
   ! Returns true if the string can't be interpred as an integer number
      BIN :: res
      INT :: value
      INT :: ios
      read(unit=self,fmt=*,iostat=ios) value
      res = ios/=0
   end
      
   is_not_bin result(res)
   ! Returns true if the string can't be interpred as a logical
      BIN :: res
      STR(len(self)) :: word
      read(unit=self,fmt=*) word
      word.to_lower_case
      select case (word)
         case("true", "t","on", "yes","y"); res = FALSE
         case("false","f","off","no", "n"); res = FALSE
         case default;                      res = TRUE
      end
   end

!  **********************************
!  Conversion to value type variables
!  **********************************
      
   to_dbl result(value)
   ! Returns the dbl number corresponding to the first token string
      DBL :: value
      read(unit=self,fmt=*) value
   end
      
   to_int result (value)
   ! Returns the integer number corresponding to the first token string
      INT :: value
      read(unit=self,fmt=*) value
   end
      
   to_bin result(value)
   ! Returns the logical corresponding to the first token string
      BIN :: value
      STR(len(self)) :: word
      word = self
      word.to_lower_case
      select case (word)
         case("true", "t","on", "yes","y"); value=TRUE
         case("false","f","off","no", "n"); value=FALSE
         case default; DIE("cant change to logical type, "//self)
      end
   end

!  ******************************
!  Conversion to self variables
!  ******************************

   from_int(value)
   ! Set the original string to the result from changing integer "value" to a string
      INT :: value
      self = ""
      write(self,fmt=*) value
      self.left_justify
   end

   from_bin(value)
   ! Set the original string to the result from changing logical "value" to a string
      BIN :: value
      self = ""
      write(self,*) value
      self.left_justify
   end

   from_dbl(value)
   ! Set the original string to the result from changing dbl "value" to a string
      DBL :: value
      self = ""
      write(self,*) value
      self.left_justify
   end

!  ****************
!  Units conversion
!  ****************

   is_known_unit result (res)
   ! Return TRUE if the string represents a known unit string
      BIN :: res
      CHR(len(self)) :: word
      INT :: l
      word = self
      word.to_lower_case
      l = len_trim(word)
      if (word(l:l)=="s" AND l>1) word = word(1:l-1)
      select case (word)
         case ("degree");        res = TRUE
         case ("angstrom");      res = TRUE
         case ("angstrom^2");    res = TRUE
         case ("meter");         res = TRUE
         case ("amu");           res = TRUE
         case ("wavenumber");    res = TRUE
         case ("ev");            res = TRUE
         case ("kelvin");        res = TRUE
         case ("joule");         res = TRUE
         case ("kilojoule");     res = TRUE
         case ("kjoule");        res = TRUE
         case ("kj");            res = TRUE
         case ("kcal/mol");      res = TRUE
         case default;           res = FALSE
      end
   end

   conversion_factor result (res)
   ! Return the conversion factor which converts a value into the specified
   ! unit "self", assuming that the value has default units. In most cases 
   ! the default units are atomic units, or radians for angles.
      DBL :: res
      CHR(len(self)) :: word
      INT :: l
      word = self
      word.to_lower_case
      l = len_trim(word)
      if (word(l:l)=="s" AND l>1) word = word(1:l-1)
      select case (word)
        case ("degree");        res = DEGREE_PER_RADIAN
        case ("angstrom");      res = ANGSTROM_PER_BOHR
        case ("angstrom^2");    res = ANGSTROM_PER_BOHR**2
        case ("meter");         res = ANGSTROM_PER_BOHR*METER_PER_ANGSTROM
        case ("amu");           res = AMU_PER_MASS_OF_ELECTRON
        case ("wavenumber");    res = WAVENUMBER_PER_HARTREE
        case ("ev");            res = EV_PER_HARTREE
        case ("kelvin");        res = KELVIN_PER_HARTREE
        case ("joule");         res = JOULE_PER_HARTREE
        case ("kilojoule");     res = KJOULE_PER_HARTREE
        case ("kjoule");        res = KJOULE_PER_HARTREE
        case ("kj");            res = KJOULE_PER_HARTREE
        case ("kcal/mol");      res = KCALMOL_PER_HARTREE
        case default;           DIE("unknown unit, "// trim(word))
      end
   end
      
end 
