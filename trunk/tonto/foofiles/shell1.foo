!-------------------------------------------------------------------------------
!
! For describing contracted cartesian gaussian shells. 
! (c) Dylan Jayatilaka, november 1997
!
! $Id$
!
!-------------------------------------------------------------------------------
module SHELL1

   use TYPES
   use STR
   use ERROR
   use MM
   use INT
   use INPUT
   use OUTPUT
   use VEC
   use IMAT
   use MAT
   use MAT3

   implicit none         

#  include "macros"
#  include "shell1.int"

!  type shell1_type
!     INT :: l 
!     INT :: n_comp 
!     INT :: n_cc 
!     VEC(3) :: pos
!     VEC, PTR :: ex
!     VEC, PTR :: cc
!  end 

contains

   create 
   ! Create a shell object
      PTR :: self
      nullify(self)
      allocate(self)
      std_mm.add(SHELL1_SIZE)
      .nullify_ptr_part
   end

   create(shell)
   ! Create a shell object from another copy
      PTR :: self
      SHELL1, IN :: shell
      .create
      .copy(shell)
   end

   create(shell,pos)
   ! Create a shell object from another copy
      PTR :: self
      SHELL, IN :: shell
      VEC(3), IN :: pos
      .create
      .copy(shell,pos)
   end

   destroy 
   ! Destroy a shell object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      std_mm.delete(SHELL1_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
     nullify(.ex)
     nullify(.cc)
   end

   destroy_ptr_part
   ! Destroy pointer part of a shell object
      .ex.destroy
      .cc.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

  copy(shell,pos) [leaky]
  ! Make a shell1 object from the shell and its position.
    SHELL :: shell
    VEC(3), IN :: pos
    .l = shell%l
    .n_comp = shell%n_comp
    .n_cc = shell%n_cc
    .pos = pos
    .ex.destroy
    .ex.create(.n_cc)
    .ex = shell%ex
    .cc.destroy
    .cc.create(.n_cc)
    .cc = shell%cc
  end

  copy(shell)
  ! Make a shell1 object from a shell1 object.
    SHELL1, IN :: shell
    .l = shell%l
    .n_comp = shell%n_comp
    .n_cc = shell%n_cc
    .pos = shell%pos
    .ex.destroy
    .ex.create(.n_cc)
    .ex = shell%ex
    .cc.destroy
    .cc.create(.n_cc)
    .cc = shell%cc
  end

   set(shell,pos) 
   ! Set a shell1 object. 
      VEC, optional :: pos
      SHELL, optional :: shell
      if (present(pos)) .pos = pos
      if (present(shell)) then
         .l = shell%l
         .n_comp = shell%n_comp
         .n_cc = shell%n_cc
         .ex => shell%ex
         .cc => shell%cc
      end
   end

   set(shell) 
   ! Set a shell1 object
      SHELL1 :: shell
      .pos = shell%pos
      .l = shell%l
      .n_comp = shell%n_comp
      .n_cc = shell%n_cc
      .ex => shell%ex
      .cc => shell%cc
   end

   set_default
      .l = 0
      .n_comp = 1
      .n_cc = 1
      .pos = ZERO
      .ex.create(1)
      .cc.create(1)
      .ex(1) = ONE
      .cc(1) = ONE
   end

   read_from_input(in) 
   ! Read a contracted gaussian self from file "in"
      INPUT :: in
      CHR :: l_c
      INT :: l,i
      in.read(.pos)
      in.read_chr(l_c)
      in.read(.n_cc)
      l_c.to_lower_case
      select case (l_c) 
         case ("s"); l = 0
         case ("p"); l = 1
         case ("d"); l = 2
         case ("f"); l = 3
         case ("g"); l = 4
         case default; 
            DIE_IF(l_c<"g","unknown angular momentum character:"//l_c)
            l = 4 + iachar(l_c)-iachar("g")
      end 
      .l = l
      .n_comp = l.n_comp
      nullify(.ex)
      nullify(.cc)
      .ex.create(.n_cc)
      .cc.create(.n_cc)
      do i = 1,.n_cc
         in.read(.ex(i))
         in.read(.cc(i))
      end
   end

  put(out)
  ! put the shell1 information to file "out"
    OUTPUT :: out
    INT :: i
    out.flush
    out.show("L quantum number = ", .l)
    out.dash(int_fields=1,dbl_fields=2)
    out.put("position = ")
    do i=1,3
      out.put( .pos(i))
    end
    out.flush
    out.dash(int_fields=1,dbl_fields=2)
    out.put("N", int_width=TRUE)
    out.put("Exponents")
    out.put("Contraction")
    out.flush
    out.dash(int_fields=1,dbl_fields=2)
    do i = 1, .n_cc
      out.put(i)
      out.put( .ex(i))
      out.put( .cc(i), flush=1)
    end
    out.flush
  end

!******************************************************************************
! The Routines
!******************************************************************************

   l_chr result(res)
   ! Return a character representation for the angular mtm
      CHR :: res
      INT :: l
      l = .l
      select case (l) 
         case (0); res="s"
         case (1); res="p"
         case (2); res="d"
         case (3); res="f"
         case (4); res="g"
         case default; 
            DIE_IF(l>23,"angular momentum too large:"// l.to_str.trim)
            res = achar(l-4+iachar("g"))
      end select
   end
    
!   make_contraction_matrix(ccm)
!   ! Return the contraction coefficient matrix
!   ! Size of ccm is .n_prim,.n_comp.
!      MAT :: ccm
!      INT :: b,p,i
!      DBL :: f
!      VEC, PTR :: fac
!!     ccm = ZERO
!      fac.create( .n_comp );   fac.normalizing_factors( .l )
!      do b = 1,.n_comp       ! do over basis components
!         p = b               ! primitive p 
!         f = fac(b)
!         do i = 1,.n_cc      ! do over contractions
!            ccm(p,b) = f*.cc(i) 
!            p = p + .n_comp
!         end
!      end
!      fac.destroy
!   end

   unnormalise
   ! Unnormalise self for cartesian component x^l.
   ! It is up to you to correct this factor with appropriate
   ! double factorial square roots for other components.
      INT :: i,j
      DBL :: sum,a,b,ab,pi2,norm,fac
      sum=0
      do i = 1,.n_cc
         a = .ex(i)
         do j = 1,i-1
            b = .ex(j)  
            ab = TWO*sqrt(a*b)/(a+b);
            sum = sum + TWO*.cc(i)*.cc(j)*ab**(.l+ONE+HALF);
         end
         sum = sum + .cc(i)*.cc(i)
      end
   !  Take the normalization factor out of the primitive
      pi2 = (HALF/PI)**(THREE/FOUR)
      norm = pi2/sqrt(sum)
      do i = 1,.n_cc
         a = FOUR*.ex(i)
         fac = .l.double_factorial
         fac = ONE/sqrt(fac)
   !     this factor should be: fac = 1/sqrt(df(nx)*df(ny)*df(nz))
   !     where n are the cartesian powers of the basis component
         .cc(i) = .cc(i)*norm*fac*a**(HALF*.l+HALF+QUARTER)
      end
   end

   make_grid(g,pt)
   ! Return "g(i,n)", the value of the shell component "n" on grid point "i"
   ! given a set of grid points "pt(i,1:3)"
      MAT :: pt
      MAT :: g
      VEC, PTR :: grid_p,fac
      IMAT, PTR :: nn
      INT :: n_pt,n,b,p,i,j
      DBL :: aa,ccp,x,y,z,rr
      DIE_IF(size(pt,2)/=3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
      g = ZERO
      nullify(grid_p); grid_p.create(n_pt)
      nn.create(3, .n_comp );   nn.make_cartesian_components( .l )
      fac.create( .n_comp );  fac.normalizing_factors( .l )
      pt(:,1) = pt(:,1) - .pos(1)             ! Make the grid relative to this atom center
      pt(:,2) = pt(:,2) - .pos(2)
      pt(:,3) = pt(:,3) - .pos(3)
      grid_p = ZERO
      do p = 1,.n_cc                          ! Loop over primitives
         aa = .ex(p)
         ccp = .cc(p)
         do n = 1,n_pt                        ! Do the exponential part of the gaussian
            x=pt(n,1); y=pt(n,2); z=pt(n,3)
            rr = x*x + y*y + z*z
            grid_p(n) = grid_p(n) + ccp*exp(-aa*rr)
         end 
      end
      do b = 1,.n_comp                        ! Loop over all basis functions
         g(:,b) = fac(b)*grid_p(:)            ! Combine exponential and cartesian part
         do i = 1,3                           ! Do the cartesian i^j, i=x,y,z part of the gaussian
            do j = 1,nn(i,b)                  ! power of the xyz part 
               g(:,b) = pt(:,i)*g(:,b)
            end 
         end
      end 
      fac.destroy
      nn.destroy
      grid_p.destroy
      pt(:,1) = pt(:,1) + .pos(1)             ! Put back the grid points
      pt(:,2) = pt(:,2) + .pos(2)
      pt(:,3) = pt(:,3) + .pos(3)
   end

   make_grid(g,x,y,z)
   ! Return "g(i,n)", the value of the shell component "n" on grid point "i"
   ! given a set of grid points "(x(i),y(i),z(i))"
      VEC :: x,y,z
      MAT :: g
      VEC, PTR :: grid_p,fac
      IVEC, PTR :: nx,ny,nz
      INT :: n_pt,n,b,p,j
      DBL :: aa,ccp,rr,xx,yy,zz
      n_pt = size(x)
      g = ZERO
      nullify(grid_p); grid_p.create(n_pt)
      nx.create(.n_comp); ny.create(.n_comp); nz.create(.n_comp)
      .l.make_gaussian_xyz_powers(nx,ny,nz)
      fac.create(.n_comp)
      fac.normalizing_factors( .l )
      x(:) = x(:) - .pos(1)                   ! Make the grid relative to this atom center
      y(:) = y(:) - .pos(2)
      z(:) = z(:) - .pos(3)
      grid_p = ZERO
      do p = 1,.n_cc                          ! Loop over primitives
         aa = .ex(p)
         ccp = .cc(p)
         do n = 1,n_pt                        ! Do the exponential part of the gaussian
            xx=x(n); yy=y(n); zz=z(n)
            rr = xx*xx + yy*yy + zz*zz
            grid_p(n) = grid_p(n) + ccp*exp(-aa*rr)
         end
      end
      do b = 1,.n_comp                        ! Loop over all basis functions
         g(:,b) = fac(b)*grid_p(:)            ! Combine exponential and cartesian part
         do j = 1,nx(b)                       ! power of the x part
            g(:,b) = x(:)*g(:,b)
         end
         do j = 1,ny(b)                       ! power of the y part
            g(:,b) = y(:)*g(:,b)
         end
         do j = 1,nz(b)                       ! power of the z part
            g(:,b) = z(:)*g(:,b)
         end
      end
      fac.destroy
      nz.destroy; ny.destroy; nx.destroy
      grid_p.destroy
      x(:) = x(:) + .pos(1)                   ! Put back the grid points
      y(:) = y(:) + .pos(2)
      z(:) = z(:) + .pos(3)
   end

   make_nabla_grid(g,pt) 
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n" on grid point "i"
   ! given a set of grid points "pt(i,1:3)"
      MAT :: pt
      MAT3 :: g
      VEC, PTR :: grid_p
      MAT, PTR :: grid_d
      VEC, PTR :: fac
      IMAT, PTR :: nn
      INT :: n_pt,n,b,p,i,j,k
      DBL :: aa,a2,ccp,x,y,z,rr,val
      DIE_IF(size(pt,2)/=3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
      g = ZERO
      nullify(grid_p); grid_p.create(n_pt)
      nullify(grid_d); grid_d.create(n_pt,3)
      nn.create(3, .n_comp );   nn.make_cartesian_components( .l )
      fac.create( .n_comp );  fac.normalizing_factors( .l )
      pt(:,1) = pt(:,1) - .pos(1)             ! Make the grid relative to this atom center
      pt(:,2) = pt(:,2) - .pos(2)
      pt(:,3) = pt(:,3) - .pos(3)
      grid_p = ZERO
      grid_d = ZERO
      do p = 1,.n_cc                          ! Loop over primitives
         aa = .ex(p)
         a2 = aa+aa
         ccp = .cc(p)
         do n = 1,n_pt                        ! Do the exponential part of the gaussian
            x=pt(n,1); y=pt(n,2); z=pt(n,3)
            rr = x*x + y*y + z*z
            val = ccp*exp(-aa*rr)
            grid_p(n)   = grid_p(n)   + val
            grid_d(n,1) = grid_d(n,1) - a2*x*val
            grid_d(n,2) = grid_d(n,2) - a2*y*val
            grid_d(n,3) = grid_d(n,3) - a2*z*val
         end 
      end
      do b = 1,.n_comp                        ! Loop over basis functions
         do k = 1,3                           ! Loop over gradient component k
            if (nn(k,b)==0) then              ! Derivative d/d(x_k) (x_k)^j (sum cc(p)*e^{-a(p) rr})
               g(:,b,k) = grid_d(:,k)
            else
               g(:,b,k) = nn(k,b)*grid_p(:)+pt(:,k)*grid_d(:,k)
               do j = 1,nn(k,b)-1             ! (n-1)th power of the xyz part
                  g(:,b,k) = pt(:,k)*g(:,b,k)
               end 
            end
            g(:,b,k) = g(:,b,k)*fac(b)        ! Correction to basis fn. normalization factor
            do i = 1,3                        ! Do the cartesian (x_i)^j, i/=k part of the gaussian
               if (k==i) cycle
               do j = 1,nn(i,b)               ! power of the xyz part not equal to gradient component k
                  g(:,b,k) = pt(:,i)*g(:,b,k)
               end 
            end 
         end
      end 
      fac.destroy
      nn.destroy
      grid_d.destroy
      grid_p.destroy
      pt(:,1) = pt(:,1) + .pos(1)             ! Put back the grid points
      pt(:,2) = pt(:,2) + .pos(2)
      pt(:,3) = pt(:,3) + .pos(3)
   end

!*****************
!  Inquiry methods
!*****************

   l result(res)
   ! Return the angular momentum l
      INT :: res
      res = .l
   end

   n_comp result(res)
   ! Return the number of components in the shell
      INT :: res
      res = .n_comp
   end

   n_cc result(res)
   ! Return the degree of contraction of the shell
      INT :: res
      res = .n_cc
   end

   n_prim result(res)
   ! Return the number of primitive gaussians in the shell
      INT :: res
      res = .n_comp*.n_cc
   end

   ex result(res)
   ! Return the exponent vector
      VEC(size(.ex)) :: res
      res = .ex
   end

   ex(i) result(res)
   ! Return the exponent
      INT :: i
      DBL :: res
      res = .ex(i)
   end

   cc result(res)
   ! Return the contraction coefficient vector
      VEC(size(.cc)) :: res
      res = .cc
   end

   cc(i) result(res)
   ! Return the contraction coefficient
      INT :: i
      DBL :: res
      res = .cc(i)
   end

   pos result(res)
   ! Return the position.
      VEC(3) :: res
      res = .pos
   end

end 
