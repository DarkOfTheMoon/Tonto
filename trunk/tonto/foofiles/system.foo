!-------------------------------------------------------------------------------
!
! SYSTEM: Contains system level routines, including memory management and error
! messages.  It allows for the graceful termination of a program.
!
! An error status is simply an integer, the value is set to 1 if the program
! terminates, or -1 if a warning condition is encountered.
!
! The memory part stores the total and maximum memory used (in bytes), and the
! the total and maximum number of blocks of memory allocated.
! A memory limit is also stored.  It is a fatal error to use more than the
! allocated limit.
!
! The file part contains the file name and record number of the last acessed
! file, in the event that this file should cause an error, the exact position
! will be known.
!
! A standard system object, "tonto", is provided to hold system information
! in the current program. In most cases it should not be neccesary to
! create any other system objects.
!
!  (c) Dylan Jayatilaka, 1998-1999
!  (c) Daniel Grimwood, 1999
!
! $Id$
!-------------------------------------------------------------------------------
module SYSTEM
   
   use TYPES

    implicit none

#  include "macros"
#  include "system.int"

!   type system_type
!
!   INT :: error_status
!   ! Set non-zero on errors
!
!   INT :: error_unit
!   ! Unit number for error messages
!
!   INT :: mem_used
!   ! Memory used so far
!
!   INT :: mem_blocks
!   ! No of blocks allocated so far
!
!   INT :: mem_max_used
!   ! Maximum memory used so far
!
!   INT :: mem_max_blocks
!   ! Maximum memory blocks allocated
!
!   INT :: mem_limit
!   ! Soft memory limit
!
!   BIN :: mem_exceeded
!   ! True if memory soft limit exceeded
!
!   STR :: mem_units
!   ! Memory usage units
!
!   INT :: stack_level
!   ! The current call-stack level
!
!   INT :: stack_max_level
!   ! Maximum call-stack level
!
!   INT :: stack_check_level
!   ! Enable memory checking for all routines at this level or higher in the
!   ! call-stack
!
!   IVEC* :: used_stack
!   ! Stores the amount of memory used at each call-level
!
!   STRVEC* :: call_stack
!   ! Stores the name of each subroutine at each call-level for tracebacks
! 
!   STR :: io_file_name
!   ! Last file used
! 
!   STR :: io_file_action
!   ! The action (read or write) assciated with the io_file
! 
!   INT :: io_file_record
!   ! Record number of last file
! 
!   BSTR :: io_file_buffer
!   ! The buffer string associated with the io_file
! 
!   INT :: io_file_pos
!   ! The position of the cursor in the buffer string
!
!   end


#define STACK(X)
#define UNSTACK
#define CHECK

   SYSTEM, target, public, save :: tonto &
      SYSTEM_TONTO1 
      SYSTEM_TONTO2 

contains

   reset
   ! Reset the error flag
      .error_status = 0
   end

   set_unit(number)
   ! Set the error unit "number"
      INT :: number
      .error_unit = number
   end

   set_put_file(file)
   ! Set the error output file to "file"
      TEXTFILE :: file
      .error_unit = file.unit
   end

!  *****************
!  Creation routines
!  *****************

   create(mem_limit)
   !  Create a memory manager object with soft limit given in "limit"
      PTR :: self
      INT, optional :: mem_limit
      allocate(self)
      self.initialize(mem_limit)
      tonto.add_mem(SYSTEM_SIZE) ! increment internal memory manager
   end

   destroy
   !  Destroy the memory manager object
      PTR :: self
      if (.destroyed) return
      deallocate(self)
      tonto.delete_mem(SYSTEM_SIZE)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   initialize(limit) 
   !  Initialize the memory manager object and set default memory limit
   !  Pour les americain ordures
      INOUT :: self
      INT, optional :: limit
      .initialise(limit) 
   end

   initialise(mem_limit)
   !  Initialise the system object and set defaults
      INOUT :: self
      INT, optional :: mem_limit
      .error_status = 0
      .error_unit = SYSTEM_STD_ERROR_UNIT
      .mem_used = 0
      .mem_blocks = 0
      .mem_max_used = 0
      .mem_max_blocks = 0
      .mem_limit = SYSTEM_MEMORY_LIMIT
      .mem_exceeded = FALSE
      .mem_units = SYSTEM_MEMORY_UNITS
      .stack_level = 0
      .stack_max_level = 0
      .stack_check_level = 0
      .io_file_name   = "unknown"
      .io_file_action = "unknown"
      .io_file_record = 0
      .io_file_buffer = " "
      .io_file_pos    = 0
      nullify(.call_stack)
      nullify(.used_stack) 
      if (present(mem_limit)) .mem_limit = mem_limit
   end

   unit_conversion_factor result(res) [elemental]
   ! Change the units used to display the memory
      IN :: self
      INT :: res
      select case(.mem_units)
         case("Words");  res = 8
         case("Bytes");  res = 1
         case("MBytes"); res = 1000000
         case("MWords"); res = 8000000
      end
   end

   reset_limit(limit) [pure]
   !  Reset memory limit for the memory manager
   !  "limit" is in bytes.
      INOUT :: self
      INT, IN :: limit
      INT :: fac
      fac = .unit_conversion_factor
      .mem_limit = fac*limit
   end

!*******************************************************************************
! Error messages.
!*******************************************************************************

   die
   ! Set the error flag to 1 and terminate the program
      .error_status = 1
      write(.error_unit,*)
      write(.error_unit,"(a)") "Error!"
      .report_io_file_info
      .report_stack_info
      stop    
   end

   die(message,iostat)
   ! Set the error flag to 1 and terminate the program with a message
      CHR(*) :: message
      INT, IN, optional :: iostat
      .error_status = 1
      write(.error_unit,*)
      if (associated(.call_stack)) then
         write(.error_unit,"(a)") &
         "Error in routine "// trim(.call_stack(.stack_level)) // " ... " // trim(message)
      else
         write(.error_unit,"(a)") &
         "Error ... " // trim(message)
         write(.error_unit,"(a)") " "
         write(.error_unit,"(a)") "To see which routine this error was in, try compiling with"
         write(.error_unit,"(a)") "the FDEBUG option; or turn on the call STACK macros. See the"
         write(.error_unit,"(a)") "manual for more details"
      end
      if (present(iostat)) write(.error_unit,"(a,i4)") "Fortran error ",iostat
      .report_io_file_info
      .report_stack_info
      stop    
   end

   die_if(condition,message,iostat)
   ! Set the error flag to 1 and terminate the program with a message
   ! provided "condition" is TRUE
      BIN :: condition
      CHR(*) :: message
      INT, IN, optional :: iostat
      if (condition) .die(message,iostat)
   end 

   warn(message,iostat)
   ! Set the error flag to -1 and issue a warning message
      CHR(*) :: message
      INT, IN, optional :: iostat
      .error_status = -1
      write(.error_unit,*)
      if (associated(.call_stack)) then
         write(.error_unit,"(a)") &
         "Warning in routine "// trim(.call_stack(.stack_level)) // " ... " // trim(message)
      else
         write(.error_unit,"(a)") &
         "Warning ... " // trim(message)
         write(.error_unit,"(a)") " "
         write(.error_unit,"(a)") "To see which routine this warning was in, try compiling with"
         write(.error_unit,"(a)") "the FDEBUG option; or turn on the call STACK macros. See the"
         write(.error_unit,"(a)") "manual for more details"
      end
      if (present(iostat)) write(.error_unit,"(a,i4)") "Fortran error ",iostat
   end

   warn_if(condition,message,iostat)
   ! If "condition" is true, issue a warning and continue, but set the error
   ! flag to -1 and 
      BIN :: condition
      CHR(*) :: message
      INT, IN, optional :: iostat
      if (condition) .warn(message,iostat)
   end

   ensure(condition,message,iostat)
   ! Ensure "condition" is true, otherwise set the error flag to 1 and 
   ! terminate the program with a "message"
      BIN :: condition
      CHR(*) :: message
      INT, IN, optional :: iostat
      if (NOT condition) .die(message,iostat)
   end 

!  **********************************
!  Memory reporting and leak checking
!  **********************************

   add_mem(used) [pure]
   !  Add memory usage data to the memory manager
      INOUT :: self
      INT, IN :: used
      .mem_used       = .mem_used + used
      .mem_max_used   = max(.mem_max_used,.mem_used)
      .mem_blocks     = .mem_blocks + 1
      .mem_max_blocks = max(.mem_max_blocks,.mem_blocks)
      .used_stack(1:.stack_level) = .used_stack(1:.stack_level) + used
   end

   delete_mem(used) [pure]
   !  Delete memory usage data to the memory manager
      INOUT :: self
      INT, IN :: used
      .mem_used = .mem_used - used
      .mem_blocks = .mem_blocks - 1
      .used_stack(1:.stack_level) = .used_stack(1:.stack_level) - used
   end

   stack(routine_name) 
   ! Add another level to the call stack. Placed at the start of every
   ! non-pure routine
      INOUT :: self
      STR(*), optional :: routine_name
      .stack_level = .stack_level + 1
      .expand_stack
      .used_stack(.stack_level) = 0
      if (present(routine_name)) then
        .call_stack(.stack_level) = routine_name
      else
        .call_stack(.stack_level) = "Unknown routine"
      end
   end

   unstack
   ! Remove a level from the call level. Placed at the end of every non-pure
   ! routine, including leaky routines. A stack report is produced if the
   ! current level does not exceed the check_level set by start_leak_test.
   ! AND if there is a memory leak.
     INOUT :: self
     if (.used_stack(.stack_level)/=0 AND .stack_level<=.stack_check_level) then
        .warn("memory leak")
        .report_stack_info
     end
     .call_stack(.stack_level) = " "
     .stack_level = .stack_level - 1
   end

   check
   ! Check for memory leaks at this level. Placed at the end of every non-pure,
   ! non-leaky routine. A stack report is produced only if there is a leak, AND
   ! if the level is greater than the check_level set by start_leak_test (since 
   ! for levels less or equal to than the check_level, unstack produces a stack
   ! report).
      .check_exceeded
      if (.used_stack(.stack_level) >0) .warn("memory leak")
      if (.used_stack(.stack_level) <0) .warn("memory sink")
      if (.used_stack(.stack_level)/=0 AND .stack_level>.stack_check_level) &
                                    .report_stack_info
      .unstack
   end

   start_check(depth)
   ! Start memory leak testing at this level by printing out the memory stack
   ! for all routines that are called (i.e. at the next level). This command 
   ! is undone by the following routine. If present, the check extends to
   ! to the current level plus "depth".
      INT, optional :: depth
      .stack_check_level = .stack_level + 1
      if (present(depth)) .stack_check_level = .stack_level + depth
   end

   end_check
   ! Ends memory leak testing at this level
      .stack_check_level = 0
   end

   check_exceeded
   !  Checks whether memory limit is exceeded
      STR :: name
      name = .call_stack(.stack_level)
      if (.mem_used>.mem_limit AND NOT .mem_exceeded) then
         .warn("memory limit exceeded in routine "//trim(name))
         .report
         .mem_exceeded = TRUE
      end
   end

   expand_stack
   ! Expand both stacks to a length at least equal to ".level"
      INT :: dim
      dim = .stack_level - .stack_max_level
      if (dim>0) then
         .expand_used_stack(dim)
         .expand_call_stack(dim)
         .stack_max_level = .stack_level
      end
   end

   expand_used_stack(dim) 
   ! Expands used_stack by amount "dim".  Contents are retained.
   ! Elements added are set to zero.
     IVEC* :: old
     INT, IN :: dim
     INT :: n
     ENSURE(dim>0,"cannot expand stack by less than 1")
     n = .stack_max_level
     if (n==0) then
        allocate(.used_stack(dim))
        .used_stack(n+1:n+dim) = 0
     else
        old => .used_stack
        nullify(.used_stack)
        allocate(.used_stack(n+dim))
        .used_stack(1:n) = old
        .used_stack(n+1:n+dim) = 0
        deallocate(old)
     end
  end

   expand_call_stack(dim)
   ! Expands call_stack by amount "dim".  Contents are retained.
   ! Elements added are set to "Unknown routine".
     STRVEC* :: old
     INT, IN :: dim
     INT :: n
     ENSURE(dim>0,"cannot expand stack by less than 1")
     n = .stack_max_level
     if (n==0) then
        allocate(.call_stack(n+dim))
        .call_stack(n+1:n+dim) = "Unknown routine"
     else
        old => .call_stack
        nullify(.call_stack)
        allocate(.call_stack(n+dim))
        .call_stack(1:n) = old
        .call_stack(n+1:n+dim) = "Unknown routine"
        deallocate(old)
     end
  end

!-------------------------------------------------------------------------------
! Output routines.
!-------------------------------------------------------------------------------
  report(out)
  !  Report memory usage
    TEXTFILE, optional :: out
    INT :: unit,fac
    if (.mem_max_used /= 0) then
      unit = tonto.error_unit
      fac = .unit_conversion_factor
      if (present(out)) unit = out.unit
      write(unit,'(/"SYSTEM: Memory usage report:"/)')
      write(unit,'("Memory used         = ",i9," ",a6)') &
                                      .mem_used/fac, .mem_units
      write(unit,'("Maximum memory used = ",i9," ",a6)') &
                                      .mem_max_used/fac, .mem_units
      write(unit,'("Blocks used         = ",i9)')    .mem_blocks
      write(unit,'("Maximum blocks used = ",i9)')    .mem_max_blocks
      write(unit,'("Level               = ",i9)')    .stack_level
      write(unit,'("Maximum level  used = ",i9)')    .stack_max_level
      .report_stack_info(out)
    end
  end

  report_stack_info(out,full_report)
  ! Report memory stack usage. Use the unit number for file "out", if present.
  ! If present and TRUE, "full_report" requests a full stack output.
    TEXTFILE, optional :: out
    BIN, optional :: full_report
    INT :: unit,fac,l
    BIN :: full
    if (.stack_max_level /= 0) then
      unit = tonto.error_unit
      full = FALSE
      fac = .unit_conversion_factor
      if (present(out)) unit = out.unit
      if (present(full_report)) full = full_report
      if (.stack_level>0 AND associated(.call_stack)) then
        write(unit,*)
        write(unit,'(a)') "Routine call stack:"
        write(unit,*)
        write(unit,'("   Call   Routine name        ",a37)') "Memory Used"
        do l = 1,.stack_level
          write(unit,'(3x,i3,".",3x,a48,i9)') &
                        l,adjustl(.call_stack(l)),.used_stack(l)/fac
        end
      end
      if (.stack_max_level>.stack_level AND full AND associated(.call_stack)) then
        write(unit, &
      '("   ----------------------------------------------------------------")')
        do l = .stack_level+1,.stack_max_level
          write(unit,'(3x,i3,".",3x,a48,i9)') &
                        l,adjustl(.call_stack(l)),.used_stack(l)/fac
        end
      end
    end
  end

  report_io_file_info(out)
  ! Report info about the most recent open file.
    TEXTFILE, optional :: out
    INT :: unit
    BSTR :: cursor
    INT :: pos,f
    RETURN_IF(.io_file_name=="unknown")
    unit = tonto.error_unit
    if (present(out)) unit = out.unit
    pos = max(1,.io_file_pos-1)
    f = scan(.io_file_buffer(pos:),"abcdefghijklmnopqrstuvwxyz")
    pos = pos + f - 1
    if (pos>0) cursor = repeat("-",pos-1)//"^"
    write(unit,*)
    write(unit,"(a)") "Text file most recently accessed:"
    write(unit,*)
    write(unit,'("   File name   = ",a)')  trim(.io_file_name)
    write(unit,'("   I/O action  = ",a)')  trim(.io_file_action)
    write(unit,'("   Line number = ",i4)') .io_file_record
    write(unit,'("   File buffer = ",a)')  trim(.io_file_buffer)
    if (pos>0) &
    write(unit,'("   Cursor -------",a)')  trim(cursor)
  end

end 
