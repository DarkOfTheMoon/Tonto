!-------------------------------------------------------------------------------
!
! SYSTEM: 
!
! This is the second most basic module in the Tonto system. It depends only on
! the TYPES module.
!
! The SYSTEM module contains all functions which are deemed to provided by the
! "system" i.e. error messages, graceful error termination, memory management,
! call stack management, I/O buffer tracking, timing and profiling, and parallel
! message passing betwen processes -- including reduction, broadcast and
! synchronisation. The latter prallel operations are completely inherited from
! another stand-alone module, PARALLEL. Inheritance is implemented as text
! inclusion, so there is no fortran dependence betwen the SYSTEM and PARALLEL
! module.
!
! Most of the system functionalities are activated by C macros at compile-time.
! So, you can turn them off to obtain a lean executable for production. You can
! see all the macros, which call routines in this module, in the "macros" file.
! The normal "make" process produces pure Fortran where all the C macros have
! been expanded.
!
! An .error_status is simply an integer, the value is set to 1 if the program
! terminates, or -1 if a warning condition is encountered. Use the
! -DUSE_ERROR_MANAGEMENT macro at compile time. Use
! -DUSE_PRE_AND_POST_CONDITIONS to turn on stricted error checking at the start
! and sometimes at the end of every routine.
!
! The memory management part stores the total and maximum memory used (in
! bytes), and the the total and maximum number of blocks of memory allocated.  A
! memory limit is also stored.  It is a fatal error to use more than the
! allocated limit.
!
! The call stack management keeps track of the current call stack, which makes
! tracking down errors easier. Use the -DUSE_CALL_STACK_MANAGEMENT macro to
! activate memory management and call stack management together.
!
! The I/O part contains the file name and record number of the last acessed
! file, in the event that this file should cause an error, the exact position
! will be known. This feature is always on, but you get more detailed feedback
! if using call stack management.
!
! The timing part provides methods to profile and time routines in the program,
! and to print out the results acording the the call stack level. This part is
! currently limited by the clock size set by fortran, but it may be useful for
! rudimentary profiling. This is activated by -DUSE_TIME_PROFILING.
!
! The parallel part keeps track of the number of processors, the processor rank,
! and uses a model where only the rank 0 processor performs I/O. Currently the
! implementation is tied to MPI, so activate using -DMPI. Appropriate MPI
! libraries should be available, and supplied in the platform speicific file,
! and you should also provide MPI.mod file.
!
! A standard system object, "tonto", is provided to hold all this system
! information in the current program. It should not be neccesary to create any
! other system objects (except for the stdin, stdou, and stdtim objects).
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module SYSTEM

! NOTE: Below, typing capital "USE" (rather than lower cased "use") means that
! the modules are not listed as dependencies in the Makefile.

#ifdef MPI
   USE mpi
#endif

#ifdef INTEL_ifort
   USE ifport, only: flush
#endif

#ifdef SERVICE_ROUTINES
   USE service_routines, only: flush
#endif

#ifdef F90_UNIX_IO
   USE f90_unix_io, only: flush
#endif

   implicit none

#undef STACK 
#undef UNSTACK 
#undef CHECK 
#undef START_TIMER 
#undef STOP_TIMER 

#define STACK(X)
#define UNSTACK(X)
#define CHECK(X)
#define START_TIMER(X)
#define STOP_TIMER

   tonto :: SYSTEM*, public

contains

!  *****************
!  Creation routines
!  *****************

   create ::: leaky
   ! Create the system object
      self :: PTR
      allocate(self)
      .initialise
   end

   destroy ::: leaky
   !  Destroy the memory manager object
      self :: PTR
      if (.destroyed) return
      .finalise
      .destroy_ptr_part
      deallocate(self)
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      self :: INOUT
      nullify(.io_file)
      nullify(.call_stack)
      nullify(.memory_used_stack)
      nullify(.memory_address_stack)
      nullify(.memory_amount_stack)
      nullify(.memory_call_stack)
      nullify(.leaky_call_stack)
      nullify(.time_call_stack)
      nullify(.time_strt_stack)
      nullify(.time_for_routine)
      nullify(.name_for_routine)
      nullify(.n_calls_for_routine)
   end

   destroy_ptr_part
   ! Nullify the pointer parts of self
      self :: INOUT
      nullify(.io_file)
      if (.call_stack.created)            deallocate(.call_stack)
      if (.memory_used_stack.created)     deallocate(.memory_used_stack)
      if (.memory_address_stack.created)  deallocate(.memory_address_stack)
      if (.memory_amount_stack.created)   deallocate(.memory_amount_stack)
      if (.memory_call_stack.created)     deallocate(.memory_call_stack)
      if (.time_call_stack.created)       deallocate(.time_call_stack)
      if (.time_strt_stack.created)       deallocate(.time_strt_stack)
      if (.time_for_routine.created)      deallocate(.time_for_routine)
      if (.name_for_routine.created)      deallocate(.name_for_routine)
      if (.n_calls_for_routine.created)   deallocate(.n_calls_for_routine)
   end

   set_defaults(memory_limit)
   !  Set defaults
      self :: INOUT
      memory_limit :: INT, optional
      .error_status = 0
      .warnings_issued = FALSE
      .error_output_unit = SYSTEM_ERROR_OUTPUT_UNIT
      .keyword_echo = TRUE
      .memory_used = 0
      .memory_blocks_used = 0
      .max_memory_used = 0
      .max_memory_blocks_used = 0
      .memory_limit = SYSTEM_MEMORY_LIMIT
      .memory_limit_exceeded = FALSE
      .memory_leak_detected = FALSE
      .memory_leak_level = 0
      .memory_units = SYSTEM_MEMORY_UNITS
      .n_addresses = 0
      .max_addresses = 0
      .leaky_address = 0
      .leaky_routine = " "
      .stack_level = 0
      .max_stack_level = 0
      .stack_show_level = -1
      .show_call_stack = FALSE
      ! Timing stuff ...
      .time_stack_level = 0
      .n_timed_routines = 0
      .time_limit = ZERO
      .show_cumulative_time = FALSE ! Note: there are usually roundoff errors in this case
      if (present(memory_limit)) .memory_limit = memory_limit
      .parallel_initialise
   end

   initialise
   !  Initialise the system object and set defaults
      .nullify_ptr_part
      .set_defaults
   end

   finalise
   !  Finalise the system object
      .parallel_finalise
   end

   unit_conversion_factor result (res) ::: private
   ! Change the units used to display the memory
      self :: IN
      res :: INT
      select case(.memory_units)
         case("Words");  res = 8
         case("Bytes");  res = 1
         case("MBytes"); res = 1000000
         case("MWords"); res = 8000000
         case default;   DIE("unknown memory units, "//trim(.memory_units))
      end
   end

   reset_memory_limit(limit)
   !  Reset memory limit for the memory manager.  "limit" is in the units
   !  ".memory_units" which is Words by default.
      self :: INOUT
      limit :: INT, IN
      fac :: INT
      fac = .unit_conversion_factor
      .memory_limit = fac*limit
   end

!  ****************
!  Error operations
!  ****************

!   reset_error_status
!   ! Reset the error flag
!      .error_status = 0
!   end

   set_error_output_unit(number)
   ! Set the error unit "number"
      number :: INT
      .error_output_unit = number
   end

   set_error_output_file(file)
   ! Set the error output file to "file"
      file :: TEXTFILE
      .error_output_unit = file.unit
   end

   set_keyword_echo(echo)
   ! Set whether to echo user-input keywords
      echo :: BIN
      .keyword_echo = echo
   end

!  **************
!  Error messages
!  **************

   die(message)
   ! Set the error flag to 1 and terminate the program with a message
      message :: STR
      .error_status = 1
      if (.IO_is_allowed) then
        write(.error_output_unit,*)
        write(.error_output_unit,"(a)") &
         "Error in "// trim(message) ! message should include the routine name via foo
        if (.error_output_unit/=TEXTFILE_STDOUT_UNIT) then
        write(TEXTFILE_STDOUT_UNIT,*)
        write(TEXTFILE_STDOUT_UNIT,"(a)") &
         "Error in "// trim(message) ! message should include the routine name via foo
        end
      end
!      .report_stack_see_info
      .report_io_file_info
      .report_keyword_info
      .report_stack_info
#ifdef MPI
      call MPI_ABORT(MPI_COMM_WORLD,.error_status,.mpi_status)
#endif
      stop
   end

   die_if(condition,message)
   ! Set the error flag to 1 and terminate the program with a message
   ! provided "condition" is TRUE
      condition :: BIN
      message :: STR
      if (condition) .die(message)
   end

   warn(message,iostat,use_stack_name)
   ! Set the error flag to -1 and issue a warning message.
   ! If "use_stack_name" is present, the call stacl routine name is used
   ! in the warning messsage, assuming that the call stack is associated.
      message :: STR
      iostat :: INT, IN, optional
      use_stack_name :: BIN, IN, optional
      name :: STR
      .error_status = -1
    ! if (.IO_is_allowed) then
    !   write(.error_output_unit,*)
    ! end
      if (present(use_stack_name)) then
         if (associated(.call_stack)) then
            name = .call_stack(.stack_level)
            if (.IO_is_allowed) then
              write(.error_output_unit,"(a)") &
              "Warning from "// trim(name) // " ... " // trim(message)
              if (.error_output_unit/=TEXTFILE_STDOUT_UNIT) then
              write(TEXTFILE_STDOUT_UNIT,"(a)") &
              "Warning from "// trim(name) // " ... " // trim(message)
              end
            end
         else
            if (.IO_is_allowed) then
              write(.error_output_unit,"(a)") &
              "Warning: " // trim(message)
              if (.error_output_unit/=TEXTFILE_STDOUT_UNIT) then
              write(TEXTFILE_STDOUT_UNIT,"(a)") &
              "Warning: " // trim(message)
              end
            end
         end
      else
        if (.IO_is_allowed) then
           write(.error_output_unit,"(a)") &
           "Warning from "// trim(message) ! message should include the routine name
           if (.error_output_unit/=TEXTFILE_STDOUT_UNIT) then
           write(TEXTFILE_STDOUT_UNIT,"(a)") &
           "Warning from "// trim(message) ! message should include the routine name
           end
        end
      end
!      .report_stack_see_info
      if (present(iostat)) then
        if (.IO_is_allowed) then
           write(.error_output_unit,"(a,i4)") "Fortran error ",iostat
           if (.error_output_unit/=TEXTFILE_STDOUT_UNIT) then
           write(TEXTFILE_STDOUT_UNIT,"(a,i4)") "Fortran error ",iostat
           end
        end
      end
      .flush_buffer
      .warnings_issued = TRUE
   end

   warn_if(condition,message,iostat)
   ! If "condition" is true, issue a warning and continue, but set the error
   ! flag to -1 and
      condition :: BIN, IN
      message :: STR, IN
      iostat :: INT, IN, optional
      if (condition) .warn(message,iostat)
   end

   ensure(condition,message)
   ! Ensure "condition" is true, otherwise set the error flag to 1 and
   ! terminate the program with a "message"
      condition :: BIN, IN
      message :: STR, IN
      if (NOT condition) .die(message)
   end

   report_stack_see_info ::: private
   ! Report information about how to compile to see call stack management
   ! information
      unit :: INT
      if (associated(.call_stack)) return
      unit = .error_output_unit
      if (.IO_is_allowed) then
        write(unit,"(a)") " "
        write(unit,"(a)") "To see a routine call stack locating this error more precisely,"
        write(unit,"(a)") "try compiling with USE_CALL_STACK_MANAGEMENT enabled."
        if (unit/=TEXTFILE_STDOUT_UNIT) then
        write(TEXTFILE_STDOUT_UNIT,"(a)") " "
        write(TEXTFILE_STDOUT_UNIT,"(a)") "To see a routine call stack locating this error more precisely,"
        write(TEXTFILE_STDOUT_UNIT,"(a)") "try compiling with USE_CALL_STACK_MANAGEMENT enabled."
        end
      end
   end

!  ***********************************************************
!  Unknown keywords: the preprocessor can define the "options"
!  ***********************************************************

   unknown(word,name,options)
   ! Set the error flag to 1 and terminate the program with a message
   ! "Unknown option". The list of known keywords is dumped.
      word :: STR, IN
      name :: STR, IN
      options :: VEC{STR}, IN
      .error_status = 1
      if (.IO_is_allowed) then
        write(.error_output_unit,*)
        write(.error_output_unit,"(a)") &
        "Error in routine "// trim(name) // " ... unknown option " // trim(word)
        if (.error_output_unit/=TEXTFILE_STDOUT_UNIT) then
        write(TEXTFILE_STDOUT_UNIT,*)
        write(TEXTFILE_STDOUT_UNIT,"(a)") &
        "Error in routine "// trim(name) // " ... unknown option " // trim(word)
        end
      end
!      .report_stack_see_info
      .report_io_file_info
      .report_keyword_info(options)
      .report_stack_info
#ifdef MPI
      call MPI_ABORT(MPI_COMM_WORLD,.error_status,.mpi_status)
#endif
      stop
   end

   unknown(word,name)
   ! Set the error flag to 1 and terminate the program with a message
   ! "Unknown option". The list of known keywords is dumped.
      word :: STR, IN
      name :: STR, IN
      .error_status = 1
      if (.IO_is_allowed) then
        write(.error_output_unit,*)
        write(.error_output_unit,"(a)") &
        "Error in routine "// trim(name) // " ... unknown option " // trim(word)
        if (.error_output_unit/=TEXTFILE_STDOUT_UNIT) then
        write(TEXTFILE_STDOUT_UNIT,*)
        write(TEXTFILE_STDOUT_UNIT,"(a)") &
        "Error in routine "// trim(name) // " ... unknown option " // trim(word)
        end
      end
!      .report_stack_see_info
      .report_io_file_info
      if (associated(.known_keywords)) .report_keyword_info(.known_keywords)
      .report_stack_info
#ifdef MPI
      call MPI_ABORT(MPI_COMM_WORLD,.error_status,.mpi_status)
#endif
      stop
   end

!  ********************************
!  Basic memory allocation tracking
!  ********************************

   add_memory(used) ::: pure
   !  Add memory usage data to the memory manager
      self :: INOUT
      used :: INT, IN
      .memory_used = .memory_used + used
      .max_memory_used = max(.memory_used,.max_memory_used)
      .memory_blocks_used = .memory_blocks_used + 1
      .max_memory_blocks_used = max(.memory_blocks_used,.max_memory_blocks_used)
      .memory_used_stack(1:.stack_level) = .memory_used_stack(1:.stack_level) + used
   end

   delete_memory(used) ::: pure
   !  Delete memory usage data from the memory manager
      self :: INOUT
      used :: INT, IN
      .memory_used = .memory_used - used
      .memory_blocks_used = .memory_blocks_used - 1
      .memory_used_stack(1:.stack_level) = .memory_used_stack(1:.stack_level) - used
   end

! More advanced memory tracking


   add_memory(used,address) ::: pure
   !  Add memory usage data and address data to the memory manager
      self :: INOUT
      used :: INT, IN
      address :: INT, IN
      dim,n :: INT
      name :: STR
      .memory_used = .memory_used + used
      .max_memory_used = max(.memory_used,.max_memory_used)
      .memory_blocks_used = .memory_blocks_used + 1
#ifdef TRACK_MEMORY_LOCATIONS
      .n_addresses = .n_addresses + 1
      dim = .n_addresses - .max_addresses
      if (dim>0) then
         .expand_int(.memory_address_stack,dim)
         .expand_int(.memory_amount_stack,dim)
         .expand_str(.memory_call_stack,dim)
      end
      .max_addresses = max(.n_addresses,.max_addresses)
      n = .n_addresses
      .memory_address_stack(n) = address                  ! Address of block
      .memory_amount_stack(n) = used
      if (.stack_level<=1) then; name = "top routine"
      else;                      name = .call_stack(.stack_level-1)
      end
      .memory_call_stack(n) = name ! Calling routine
      if (.leaky_address/=0 AND .leaky_amount/=0 AND .leaky_routine/=" ") then
         if (address==.leaky_address) then
         if (.leaky_amount==used) then
         if (name==.leaky_routine) then
            allocate(.leaky_call_stack(.stack_level))
            .leaky_call_stack = .call_stack(1:.stack_level)
            .leaky_address = 0
         end
         end
         end
      end
#endif
      .max_memory_blocks_used = max(.memory_blocks_used,.max_memory_blocks_used)
      .memory_used_stack(1:.stack_level) = .memory_used_stack(1:.stack_level) + used
   end

   delete_memory(used,address) ::: pure
   !  Delete memory usage data and address data from the memory manager
      self :: INOUT
      used :: INT, IN
      address :: INT, IN
      n,i,j :: INT
      .memory_used = .memory_used - used
#ifdef TRACK_MEMORY_LOCATIONS
      j = 0
      do i = .n_addresses,1,-1
         if (address/=.memory_address_stack(i)) cycle
         j = i
         exit
      end
      if (j==0) then
      !    write(.error_output_unit,"(a)") "can't find memory address"
      else ! remove the address
          .n_addresses = .n_addresses - 1
          n = .n_addresses
          .memory_address_stack(j:n) = .memory_address_stack(j+1:n+1)
          .memory_amount_stack(j:n) = .memory_amount_stack(j+1:n+1)
          .memory_call_stack(j:n)  = .memory_call_stack(j+1:n+1)
      end
#endif
      .memory_blocks_used = .memory_blocks_used - 1
      .memory_used_stack(1:.stack_level) = .memory_used_stack(1:.stack_level) - used
   end

   report_undeleted_memory(out) ::: private
   ! Report undeleted memory allocation info i.e. a profile. If present, use the
   ! unit number for file "out", otherwise use "tonto.error_output_unit".  
      out :: TEXTFILE, optional
      unit,i :: INT
      if (.n_addresses == 0) return
      if (NOT .IO_is_allowed) return
#ifdef TRACK_MEMORY_LOCATIONS
      ! Process arguments ...
      unit = tonto.error_output_unit
      if (present(out)) unit = out.unit
       write(unit,*)
       write(unit,'(a)') "Undeleted memory calls:"
       write(unit,*)
       write(unit,'("Routine",36x,"    Amount      Address")')
      do i = 1,.n_addresses
       write(unit,'(a43,i10,i13)') adjustl(.memory_call_stack(i)), &
                                   .memory_amount_stack(i), &
                                   .memory_address_stack(i)
      end
      if (unit/=TEXTFILE_STDOUT_UNIT) then
       write(TEXTFILE_STDOUT_UNIT,*)
       write(TEXTFILE_STDOUT_UNIT,'(a)') "Undeleted memory calls:"
       write(TEXTFILE_STDOUT_UNIT,*)
       write(TEXTFILE_STDOUT_UNIT,'("Routine",36x,"    Amount      Address")')
      do i = 1,.n_addresses
       write(TEXTFILE_STDOUT_UNIT,'(a43,i10,i13)') adjustl(.memory_call_stack(i)), &
                                   .memory_amount_stack(i), &
                                   .memory_address_stack(i)
      end
      end
      if (.leaky_call_stack.created) then
       write(unit,*)
       write(unit,'(a)') "Requested leaky call stack:"
       write(unit,*)
      do i = 1,size(.leaky_call_stack)
       write(unit,'(i4,". ",a43)') i,adjustl(.leaky_call_stack(i))
      end
      if (unit/=TEXTFILE_STDOUT_UNIT) then
       write(TEXTFILE_STDOUT_UNIT,*)
       write(TEXTFILE_STDOUT_UNIT,'(a)') "Requested leaky call stack:"
       write(TEXTFILE_STDOUT_UNIT,*)
      do i = 1,size(.leaky_call_stack)
       write(TEXTFILE_STDOUT_UNIT,'(i4,". ",a43)') i,adjustl(.leaky_call_stack(i))
      end
      end
      end
      .flush_buffer
#endif
   end


!  ************************************************************************
!  Call stack management, per-call level memory reporting and leak checking
!  ************************************************************************

   stack(routine_name)
   ! Add another level to the call stack. Placed at the start of every
   ! non-pure routine. (Pure routines may not have I/O which this has).
      self :: INOUT
      routine_name :: STR, optional
      .stack_level = .stack_level + 1
      .expand_call_stacks
      .memory_used_stack(.stack_level) = 0
      if (present(routine_name)) then
        .call_stack(.stack_level) = routine_name
      else
        .call_stack(.stack_level) = "Unknown routine"
      end
      if (.show_call_stack) then
        if (.IO_is_allowed) then
          write(.error_output_unit,"(a)") repeat("   ",.stack_level)//trim(routine_name)//" {"
        end
      end
      .flush_buffer
      .memory_leak_detected = FALSE ! reset any memory leaks
      if (.stack_level<.memory_leak_level) .memory_leak_level = 0
      ! allow leak reports again at higher levels
   end

   unstack(routine_name)
   ! Remove a level from the call level. Placed at the end of every non-pure
   ! routine, *including* leaky routines.  If the current level exceeds
   ! stack_show_level then a stack report is produced --- provided that
   ! show_call_stack is not set; but if it is set, then an indented stack report
   ! is made instead.
      self :: INOUT
      routine_name :: STR, optional
      report_stack,show_call_stack :: BIN
      rout_name :: STR
      mem :: INT
      memory :: STR(9)
      l :: INT
      l = .stack_level
      if (l<=0) then
        if (.IO_is_allowed) then
           write(.error_output_unit,*)
           write(.error_output_unit,"(a,I2)") &
              "Warning from SYSTEM:unstack ... stack level is not positive, ", l
        end
        .report_io_file_info
        .report_stack_info(full_report=TRUE)
#ifdef MPI
        call MPI_ABORT(MPI_COMM_WORLD,.error_status,.mpi_status)
#endif
        stop
      else if (l>.max_stack_level) then
        if (.IO_is_allowed) then
           write(.error_output_unit,*)
           write(.error_output_unit,"(a,2I2)") &
              "Warning from SYSTEM:unstack ... stack level greater than max, ", &
              l,.max_stack_level
        end
#ifdef MPI
        call MPI_ABORT(MPI_COMM_WORLD,.error_status,.mpi_status)
#endif
        stop
      else
        show_call_stack =             & ! Show indented call stack if:
           .show_call_stack           & ! ... switch was set
        AND l >=.stack_show_level       ! ... stack is greater than check
        report_stack =                & ! Report tabular stack info if:
            l >= .stack_show_level    & ! ... greater than check level
        AND .stack_show_level > 0     & ! ... check level was set
        AND NOT show_call_stack         ! ... NOT doing indented view
        if (report_stack) then
           .report_stack_info
        else if (show_call_stack) then
           rout_name = .call_stack(l)
           if (present(routine_name)) then
              if(rout_name/=routine_name) then
              if (.IO_is_allowed) then
                 write(.error_output_unit,*)
                 write(.error_output_unit,"(a)") &
                    "Start routine "//trim(rout_name)// &
                    " does not match end routine "//trim(routine_name)
              end
              end
           end
           mem = .memory_used_stack(l)/.unit_conversion_factor
           if (.IO_is_allowed) then
             write(memory,"(I9)") mem
           end
           if (mem==0) then
             if (.IO_is_allowed) then
               write(.error_output_unit,"(a)") &
                repeat("   ",l)//trim(rout_name)//" } "//adjustl(memory)
             end
           else
             if (.IO_is_allowed) then
               write(.error_output_unit,"(a)") &
                repeat("---",l)//trim(rout_name)//" } "//adjustl(memory)
             end
           end
        end
      end
      .call_stack(l) = " "
      .stack_level   = .stack_level - 1
      .flush_buffer
   end

   check(routine_name)
   ! Check for memory leaks at this level. Placed at the end of every non-pure,
   ! non-leaky routine. A stack report is produced only if there is a leak, AND
   ! if the level is greater than the check_level set by start_leak_test (since
   ! for levels less or equal to than the check_level, unstack produces a stack
   ! report).
      routine_name :: STR, optional
      if (.stack_level<=0) then
        if (.IO_is_allowed) then
          write(.error_output_unit,*)
          write(.error_output_unit,"(a,I2)") &
          "Warning from SYSTEM:check ... stack level is not positive, ", &
          .stack_level
        end
        .report_io_file_info
        .report_stack_info(full_report=TRUE)
#ifdef MPI
        call MPI_ABORT(MPI_COMM_WORLD,.error_status,.mpi_status)
#endif
        stop
      end
      .check_exceeded
      .check_if_leaky
      .unstack(routine_name)
   end

   will_exceed_memory_limit(amount) result (res)
   !  Returns TRUE if memory limit will be exceeded after an allocation of
   !  "amount" units of memory
      amount :: INT
      res :: BIN
      res = (.memory_used+amount)>.memory_limit
   end

   check_exceeded ::: private
   !  Checks whether memory limit is exceeded
      name :: STR
      if (.memory_used>.memory_limit AND NOT .memory_limit_exceeded) then
         name = .call_stack(.stack_level)
         .warn("Memory limit first exceeded in routine "//trim(name))
         .report
         .memory_limit_exceeded = TRUE
      end
   end

   check_if_leaky ::: private
   ! Checks whether there is a memory leak, and if so produce a warning.
   ! A stack report is made only if the stack_show_level was not set,
   ! or if it was set, it the leak occurs below the stack_show_level
   ! (since otherwise the unstack routine will make a stack report).
      produce_warning,produce_report :: BIN
      l :: INT
      l = .stack_level
      produce_warning =  &               ! produce warning if:
         .memory_used_stack(l) /= 0    & ! ... there is a leak at this level,
         AND NOT .memory_leak_detected & ! ... it hasn't yet been seen,
         AND l > .memory_leak_level      ! ... it wasn't reported already
      if (produce_warning) then
         if (.memory_used_stack(l)>0) .warn("memory leak",use_stack_name=TRUE)
         if (.memory_used_stack(l)<0) .warn("memory sink",use_stack_name=TRUE)
         .memory_leak_detected = TRUE
         if (.memory_leak_level==0) then
            .memory_leak_level = .stack_level - 1
         else
            .memory_leak_level = min(.memory_leak_level,.stack_level-1)
         end
      end
      produce_report  =  &               ! produce stack report if:
         produce_warning               & ! ... there was a warning made AND
         AND (0 > .stack_show_level    & ! ... stack level was not set OR
         OR   l < .stack_show_level)     ! ... unstack makes no report
      if (produce_report) then
         .report_stack_info
      end
   end

   ignore_memory_leak(memory_blocks_gained)
   ! If called, this routine will reset any memory leak in the current
   ! procedure at the point of call. This is highly dangerous and should be used
   ! only in special cases when you are sure the leak can be tolerated.
   ! "memory_blocks_gained" is the number of blocks that were gained in the leak
   ! process: it is negative for a loss in memory, and positive for a gain in
   ! memory.
      memory_blocks_gained :: INT
      if (NOT associated(.memory_used_stack)) return
      .delete_memory(.memory_used_stack(.stack_level))
      .memory_blocks_used = .memory_blocks_used + 1 - memory_blocks_gained
   end

   start_memory_trace(depth,show_call_stack)
   ! Start printing out the memory stack for all routines that are called (i.e.
   ! at the next level). This command is undone by the "end_show" routine. If
   ! "depth" is present, the show starts at the current level plus "depth".
   ! If "show_call_stack" is present and FALSE, then a tabular style output is
   ! shown rather than the default indented style.
      depth :: INT, optional
      show_call_stack :: BIN, optional
      .stack_show_level = .stack_level + 1
      if (present(depth)) .stack_show_level = .stack_level + depth
      .show_call_stack = TRUE
      if (present(show_call_stack)) .show_call_stack = FALSE
   end

   end_memory_trace
   ! Ends memory leak testing at this level
      .stack_show_level = -1
      .show_call_stack = FALSE
   end

   expand_call_stacks ::: private
   ! Expand both stacks to a length at least equal to ".stack_level".
      dim :: INT
      dim = .stack_level - .max_stack_level
      if (dim>0) then
         .expand_int(.memory_used_stack,dim)
         .expand_str(.call_stack,dim)
         .max_stack_level = .stack_level
      end
   end

   report(out)
   !  Report memory usage
      out :: TEXTFILE, optional
      unit,fac :: INT
      if (.max_memory_used /= 0) then
       unit = tonto.error_output_unit
       if (present(out)) unit = out.unit
       fac = .unit_conversion_factor
       if (.IO_is_allowed) then
         write(unit,'(/"SYSTEM: Memory usage report:"/)')
         write(unit,'("Memory currently used      = ",i9," ",a6)') .memory_used/fac,.memory_units
         write(unit,'("Maximum memory used        = ",i9," ",a6)') .max_memory_used/fac,.memory_units
         write(unit,'("Memory blocks used         = ",i9)') .memory_blocks_used
         write(unit,'("Maximum memory blocks used = ",i9)') .max_memory_blocks_used
         write(unit,'("Memory limit               = ",i9)') .memory_limit
         write(unit,'("Call stack level           = ",i9)') .stack_level
         write(unit,'("Maximum call stack depth   = ",i9)') .max_stack_level
         if (unit/=TEXTFILE_STDOUT_UNIT) then
         write(TEXTFILE_STDOUT_UNIT,'(/"SYSTEM: Memory usage report:"/)')
         write(TEXTFILE_STDOUT_UNIT,'("Memory currently used      = ",i9," ",a6)') .memory_used/fac,.memory_units
         write(TEXTFILE_STDOUT_UNIT,'("Maximum memory used        = ",i9," ",a6)') .max_memory_used/fac,.memory_units
         write(TEXTFILE_STDOUT_UNIT,'("Memory blocks used         = ",i9)') .memory_blocks_used
         write(TEXTFILE_STDOUT_UNIT,'("Maximum memory blocks used = ",i9)') .max_memory_blocks_used
         write(TEXTFILE_STDOUT_UNIT,'("Memory limit               = ",i9)') .memory_limit
         write(TEXTFILE_STDOUT_UNIT,'("Call stack level           = ",i9)') .stack_level
         write(TEXTFILE_STDOUT_UNIT,'("Maximum call stack depth   = ",i9)') .max_stack_level
         end
       end
       .report_stack_info(out)
      end
      .report_timing_info 
#ifdef TRACK_MEMORY_LOCATIONS
      .report_undeleted_memory
#endif
      .flush_buffer
   end

   report_stack_info(out,full_report) ::: private
   ! Report memory stack usage. Use the unit number for file "out", if present.
   ! If present and TRUE, "full_report" requests a full stack output.
      out :: TEXTFILE, optional
      full_report :: BIN, optional
      unit,fac,l :: INT
      full :: BIN
      if (.max_stack_level /= 0) then
       unit = tonto.error_output_unit
       if (present(out)) unit = out.unit
       full = FALSE
       if (present(full_report)) full = full_report
       fac = .unit_conversion_factor
       if (.stack_level>0 AND associated(.call_stack)) then
         if (.IO_is_allowed) then
           write(unit,*)
           write(unit,'(a)') "Routine call stack:"
           write(unit,*)
           write(unit,'("   Call   Routine name           ",a37)') "Memory Used"
           if (unit/=TEXTFILE_STDOUT_UNIT) then
           write(TEXTFILE_STDOUT_UNIT,*)
           write(TEXTFILE_STDOUT_UNIT,'(a)') "Routine call stack:"
           write(TEXTFILE_STDOUT_UNIT,*)
           write(TEXTFILE_STDOUT_UNIT,'("   Call   Routine name        ",a37)') "Memory Used"
           end
         end
         do l = 1,.stack_level
           if (.IO_is_allowed) then
             write(unit,'(3x,i3,".",3x,a48,i9)') &
                         l,adjustl(.call_stack(l)),.memory_used_stack(l)/fac
             if (unit/=TEXTFILE_STDOUT_UNIT) then
             write(TEXTFILE_STDOUT_UNIT,'(3x,i3,".",3x,a48,i9)') &
                         l,adjustl(.call_stack(l)),.memory_used_stack(l)/fac
             end
           end
         end
       end
       if (full AND .max_stack_level>.stack_level AND associated(.call_stack)) then
           if (.IO_is_allowed) then
             write(unit, &
           '("   ----------------------------------------------------------------")')
             if (unit/=TEXTFILE_STDOUT_UNIT) then
             write(TEXTFILE_STDOUT_UNIT, &
           '("   ----------------------------------------------------------------")')
             end
           end
         do l = .stack_level+1,.max_stack_level
           if (.IO_is_allowed) then
             write(unit,'(3x,i3,".",3x,a48,i9)') &
             l,adjustl(.call_stack(l)),.memory_used_stack(l)/fac
             if (unit/=TEXTFILE_STDOUT_UNIT) then
             write(TEXTFILE_STDOUT_UNIT,'(3x,i3,".",3x,a48,i9)') &
             l,adjustl(.call_stack(l)),.memory_used_stack(l)/fac
             end
           end
         end
       end
      end
      .flush_buffer
   end

   report_io_file_info ::: private
   ! Report info about the most recent open file.
      unit :: INT
      cursor :: STR(len=BSTR_SIZE)
      item_end :: INT
      if (NOT associated(.io_file)) return
      unit = tonto.error_output_unit
      item_end = max(1,.io_file.buffer.item_end)
      if (item_end>0) cursor = repeat("-",item_end-1)//"^"
      if (.IO_is_allowed) then
       write(unit,*)
       write(unit,'("File name   = ",a)')  trim(.io_file.name)
       write(unit,'("Line number = ",i4)') .io_file.record
       write(unit,'("File buffer = ",a)')  trim(.io_file.buffer.string)
       if (unit/=TEXTFILE_STDOUT_UNIT) then
       write(TEXTFILE_STDOUT_UNIT,*)
       write(TEXTFILE_STDOUT_UNIT,'("File name   = ",a)')  trim(.io_file.name)
       write(TEXTFILE_STDOUT_UNIT,'("Line number = ",i4)') .io_file.record
       write(TEXTFILE_STDOUT_UNIT,'("File buffer = ",a)')  trim(.io_file.buffer.string)
       end
      end
      if (.IO_is_allowed) then
       if (item_end>0) then
         write(unit,'("Cursor -------",a)')  trim(cursor)
         if (unit/=TEXTFILE_STDOUT_UNIT) then
         write(TEXTFILE_STDOUT_UNIT,'("Cursor -------",a)')  trim(cursor)
         end
       end
      end
      .flush_buffer
   end

   report_keyword_info(options) ::: private
   ! Report info about the most recent keywords used
      options :: VEC{STR}, optional
      n :: INT
      unit :: INT
      unit = tonto.error_output_unit
      if (present(options)) then
        if (.IO_is_allowed) then
          write(unit,*)
          write(unit,'("Allowed keyword options:")')
          write(unit,*)
          do n = 1,size(options)
            write(unit,'("   ",a)') trim(options(n))
          end
          if (unit/=TEXTFILE_STDOUT_UNIT) then
          write(TEXTFILE_STDOUT_UNIT,*)
          write(TEXTFILE_STDOUT_UNIT,'("Allowed keyword options:")')
          write(TEXTFILE_STDOUT_UNIT,*)
          do n = 1,size(options)
            write(TEXTFILE_STDOUT_UNIT,'("   ",a)') trim(options(n))
          end
          end
        end
      end
      .flush_buffer
   end

!  ******************************************************************
!  Timing and profiling: is limited by fortrans poor clock resolution
!  ******************************************************************

   start_timer(routine_name)
   ! Start timing routine "routine_name". Placed at the start of every routine
   ! when profiling is requested. 
      self :: INOUT
      routine_name :: STR, IN
      start_time :: REAL
      .time_stack_level = .time_stack_level + 1
      call cpu_time(start_time)
      .expand_time_stacks(routine_name,start_time) 
   end

   stop_timer
   ! Stop the timer for the routine at the current ".time_stack_level". Placed
   ! at the end of every routine when profiling is requested. 
      self :: INOUT
      routine_name :: STR
      index,i :: INT
      start_time,finish_time,elapsed_time,total_time,total :: REAL
      index = .time_call_stack(.time_stack_level)
      routine_name = .name_for_routine(index)
      ! Get the finishing time
      call cpu_time(finish_time)
      ! Get the starting time and elapsed time
      start_time = .time_strt_stack(.time_stack_level)
      elapsed_time = finish_time - start_time
      ! Increment the elapsed time for the current routine
      .time_for_routine(index) = .time_for_routine(index) + elapsed_time
      if (NOT .show_cumulative_time) then
         ! Remove this elapsed time from all the parent routines 
         do i = 1,.time_stack_level-1
            index = .time_call_stack(i) ! This is a parent routine index
            .time_for_routine(index) = .time_for_routine(index) - elapsed_time
         end
      end
      ! See whether to stop program if total time exceeded
      if (.time_limit>ZERO) then
         ! Get total time: Add up total time so far
         total_time = ZERO
         do i = 1,.n_timed_routines
            total = .time_for_routine(i)
            if (total<ZERO) cycle ! These have not completed
            total_time = total_time + total
         end
         ! Make a report and stop if total time exceeded 
         if (total_time>.time_limit) then
            .report_timing_info
            ! stop
         end
      end
      ! Remove the routine from the call stack
      .time_call_stack(.time_stack_level) = 0
      .time_stack_level = .time_stack_level - 1
    ! write(*,*) "---- returning, time_stack_level=",.time_stack_level
   end

   expand_time_stacks(routine_name,start_time) ::: pure, leaky, private
   ! Expand all the time stacks (if required) by adding "routine_name" in the
   ! ".name_for_routine" stack, for example. Also add the starting time.
      self :: INOUT
      routine_name :: STR, IN
      start_time :: REAL, IN
      index,dim :: INT
      ! First expand the list of akll timed routines
      index = .index_for_routine(routine_name)
      if (index==0) then  ! NEW routine. 
        ! dim = .n_timed_routines
        ! if (associated(.time_for_routine)) dim = dim - .time_for_routine.dim
        ! if (dim>=0) then ! Not enough space? Expand stack ...
           .expand_real(.time_for_routine,1)
           .expand_str( .name_for_routine,1)
           .expand_int( .n_calls_for_routine,1)
        ! end
        index = .n_timed_routines + 1
        .n_timed_routines = index
        .time_for_routine(index) = ZERO
        .name_for_routine(index) = routine_name
        .n_calls_for_routine(index) = 1
        ! write(*,*) "NEW=",index,"name=",trim(routine_name)
      else
        .n_calls_for_routine(index) = .n_calls_for_routine(index) + 1
        ! write(*,*) "old=",index,"name=",trim(routine_name)
      end
      ! Now expand the timed call stack ...
      dim = 0
      if (associated(.time_call_stack)) dim = .time_stack_level - .time_call_stack.dim
      if (dim==1 OR NOT associated(.time_call_stack)) then
        .expand_int( .time_call_stack,1)
        .expand_real(.time_strt_stack,1)
      else
      end
      .time_call_stack(.time_stack_level) = index
      .time_strt_stack(.time_stack_level) = start_time
   end

   index_for_routine(routine_name) result (index) ::: pure, leaky, private
   ! Return the "index" for routine "routine_name" in the ".name_for_routine"
   ! stack. 
      self :: IN
      routine_name :: STR, IN
      index :: INT
      i :: INT
      index = 0
      do i = 1,.n_timed_routines
        if (.name_for_routine(i)/=routine_name) cycle
        index = i
        exit
      end
   end

   report_timing_info(out,full_report) ::: private
   ! Report routine timing info i.e. a profile. If present, use the unit number for file
   ! "out", otherwise use "tonto.error_output_unit".  If present and TRUE,
   ! "full_report" requests a full stack output, otherwise only the top 20 are
   ! reported.
      out :: TEXTFILE, optional
      full_report :: BIN, optional
      full :: BIN
      order :: VEC{INT}*
      total_time,total :: REAL
      unit,i,j,n_routine :: INT
      if (.n_timed_routines == 0) return
      if (NOT .IO_is_allowed) return
      ! Process arguments ...
      unit = tonto.error_output_unit
      if (present(out)) unit = out.unit
      full = TRUE
      if (present(full_report)) full = full_report
      if (full) then; n_routine = .n_timed_routines
      else;           n_routine = min(20,.n_timed_routines)
      end
      ! Set any negative times to zero and sort
      total_time = ZERO
      do i = 1,.n_timed_routines
        total = .time_for_routine(i)
        if (total<ZERO) cycle
        total_time = total_time + total
      end
      allocate(order(.n_timed_routines))
      order = [(i,i=1,.n_timed_routines)] ! initialise order
      .quick_sort_decreasing(.time_for_routine,order)
      write(unit,*)
      if (.show_cumulative_time) then
      write(unit,'(a,f10.3)') "Total cumulative time used = ",total_time
      write(unit,*)
      write(unit,'(a)')       "This time will exceed the total used CPU time because it includes"
      write(unit,'(a)')       "the elapsed time of all routines called by the named routine."
      else
      write(unit,'(a,f10.3)') "Total elapsed time used = ",total_time
      write(unit,*)
      write(unit,'(a)')       "This may lead to negative elapsed times for some routines because"
      write(unit,'(a)')       "of roundoff errors when subtracting the elapsed times of all the"
      write(unit,'(a)')       "routine called by a particular named routine, below."
      end
      write(unit,*)
      write(unit,'(a)') "Timed routine call stack:"
      write(unit,*)
      write(unit,'("   Call ",43x,a10,a10,a10)') "      Time","   % total","   # calls"
      do i = 1,n_routine
        j = order(i) 
        write(unit,'(3x,i3,".",1x,a43,f10.3,f10.3,i10)') &
                         i, &
                         adjustl(.name_for_routine(j)), &
                         .time_for_routine(j), &
                         .time_for_routine(j)*100d0/total_time, &
                         .n_calls_for_routine(j)
      end
      if (unit/=TEXTFILE_STDOUT_UNIT) then
      write(TEXTFILE_STDOUT_UNIT,*)
      if (.show_cumulative_time) then
      write(TEXTFILE_STDOUT_UNIT,'(a,f10.3)') "Total cumulative time used = ",total_time
      write(TEXTFILE_STDOUT_UNIT,*)
      write(TEXTFILE_STDOUT_UNIT,'(a)')       "This time will exceed the total used CPU time because it includes"
      write(TEXTFILE_STDOUT_UNIT,'(a)')       "the elapsed time of all routines called by the named routine."
      else
      write(TEXTFILE_STDOUT_UNIT,'(a,f10.3)') "Total elapsed time used = ",total_time
      write(TEXTFILE_STDOUT_UNIT,*)
      write(TEXTFILE_STDOUT_UNIT,'(a)')       "This may lead to negative elapsed times for some routines because"
      write(TEXTFILE_STDOUT_UNIT,'(a)')       "of roundoff errors when subtracting the elapsed times of all the"
      write(TEXTFILE_STDOUT_UNIT,'(a)')       "routine called by a particular named routine, below."
      end
      write(TEXTFILE_STDOUT_UNIT,*)
      write(TEXTFILE_STDOUT_UNIT,'(a)') "Timed routine call stack:"
      write(TEXTFILE_STDOUT_UNIT,*)
      write(TEXTFILE_STDOUT_UNIT,'("   Call ",43x,a10,a10,a10)') "      Time","   % total","   # calls"
      do i = 1,n_routine
        j = order(i) 
        write(TEXTFILE_STDOUT_UNIT,'(3x,i3,".",1x,a43,f10.3,f10.3,i10)') &
                         i, &
                         adjustl(.name_for_routine(j)), &
                         .time_for_routine(j), &
                         .time_for_routine(j)*100d0/total_time, &
                         .n_calls_for_routine(j)
      end
      end
      deallocate(order)
      .flush_buffer
   end

   flush_buffer(unit)
   ! Flush the output
      unit :: INT, IN, optional
      f_unit :: INT
      if (present(unit)) then
       f_unit = unit
      else
       f_unit = tonto.error_output_unit
      end
      if (.IO_is_allowed) then
#ifdef FLUSH
#ifdef GNU_gfortran
       call flush
#else
       call flush(f_unit)
#endif
#endif
      end
   end

! ************************************
! These would be inherited if possible
! ************************************

   expand_real(stack,dim) ::: pure, leaky, private
   ! Expands "stack" by amount "dim". Contents are retained.
   ! Elements added are set to zero.
      self :: INOUT
      stack :: VEC{REAL}*
      dim :: INT, IN
   ENSURE(dim>0,"cannot expand stack by less than 1")
      old_stack :: VEC{REAL}*
      n :: INT
      if (NOT associated(stack)) then
      ! write(*,*) "NOT associated, dim=",dim
        allocate(stack(dim))
        stack = ZERO
      else
        n = stack.dim
        old_stack => stack
      ! write(*,*) "Associated, copying, n=",n," dim=",dim
        nullify(stack)
        allocate(stack(n+dim))
        stack(1:n) = old_stack
        stack(n+1:n+dim) = ZERO
        deallocate(old_stack)
      end
   end

   expand_int(stack,dim) ::: pure, leaky, private
   ! Expands "stack" by amount "dim". Contents are retained.
   ! Elements added are set to zero.
      self :: INOUT
      stack :: VEC{INT}*
      dim :: INT, IN
   ENSURE(dim>0,"cannot expand stack by less than 1")
      old_stack :: VEC{INT}*
      n :: INT
      if (NOT associated(stack)) then
        allocate(stack(dim))
        stack = 0
      else
        n = stack.dim
        old_stack => stack
        nullify(stack)
        allocate(stack(n+dim))
        stack(1:n) = old_stack
        stack(n+1:n+dim) = 0
        deallocate(old_stack)
      end
   end

   expand_str(stack,dim) ::: pure, leaky, private
   ! Expands "stack" by amount "dim". Contents are retained.
   ! Elements added are set to blank.
      self :: INOUT
      stack :: VEC{STR}*
      dim :: INT, IN
   ENSURE(dim>0,"cannot expand stack by less than 1")
      old_stack :: VEC{STR}*
      n :: INT
      if (NOT associated(stack)) then
        allocate(stack(dim))
        stack = " "
      else
        n = stack.dim
        old_stack => stack
        nullify(stack)
        allocate(stack(n+dim))
        stack(1:n) = old_stack
        stack(n+1:n+dim) = " "
        deallocate(old_stack)
      end
   end

   quick_sort_decreasing(vec,indices) ::: pure, recursive, private
   ! Return the indices which sort vector from largest to smallest, i.e. on
   ! return "vec(indices)" is sorted. NOTE: vec is *not* sorted.
      self :: IN
      vec :: VEC{REAL}, IN
      indices :: VEC{INT}, INOUT
      list,small,equal,large,small_indices,equal_indices,large_indices :: VEC{INT}*
      n, i, ns, ne, nl :: INT
      chosen :: REAL
      if (indices.dim<=1) return
      n = indices.dim
      allocate(list(n)); list = [(i,i=1,n)]
      chosen = vec(1)
      ns = count(vec>chosen)
      nl = count(vec<chosen)
      ne = n - ns - nl
      allocate(small(ns)); allocate(small_indices(ns))
      allocate(equal(ne)); allocate(equal_indices(ne))
      allocate(large(nl)); allocate(large_indices(nl))
      small = pack(list,vec >chosen) ! indices of large vec elements
      equal = pack(list,vec==chosen) ! indices of equal vec elements
      large = pack(list,vec <chosen) ! indices of small vec elements
      small_indices = indices(small)
      equal_indices = indices(equal)
      large_indices = indices(large)
      if (ns>1) .quick_sort_decreasing(vec(small),small_indices)
      if (nl>1) .quick_sort_decreasing(vec(large),large_indices)
      indices(1:ns)       = small_indices
      indices(ns+1:ns+ne) = equal_indices
      indices(ns+ne+1:)   = large_indices
      deallocate(large_indices); deallocate(large)
      deallocate(equal_indices); deallocate(equal)
      deallocate(small_indices); deallocate(small)
      deallocate(list)
   end


! *************************************
! These are all inherited from PARALLEL
! *************************************

   parallel_initialise ::: get_from(PARALLEL:initialise)
   ! Initialise the parallel environment.
   end

   parallel_finalise ::: get_from(PARALLEL:finalise)
   ! Finalise the parallel environment.
   end

! Inquiry routines.

   is_master_processor result (res) ::: get_from(PARALLEL), pure
   ! Return TRUE if this is the master processor. The index of the master
   ! processor is normally 0.
   end

   master_processor result (res) ::: get_from(PARALLEL), pure
   ! Return the index of the master processor, which is normally 0.
   end

   this_processor result (res) ::: get_from(PARALLEL), pure
   ! Return the index of this processor.  First index is zero!
   end

! Parallel do loops

   parallel_do_start(first,stride) result (res) ::: get_from(PARALLEL), pure
   ! Return the starting index to be used in a parallel do statement. The
   ! "first" index and the loop "stride" can optionally be supplied, if they are
   ! not equal to 1.  In this model, each processor skips through the whole
   ! length of the loop.  This should be load balanced --- assuming there is no
   ! systematic dependence in the work for each element of the loop which
   ! depends on a multiple of the number of processors. See the "do_stride"
   ! routine.
   end

   parallel_do_stride(stride) result (res) ::: get_from(PARALLEL), pure
   ! Return the stride to be used in a parallel do statement.  The "stride"
   ! length can be optionally supplied, if it is not 1.
   end

   do_in_parallel result (res) ::: get_from(PARALLEL), pure
   ! Return TRUE if we are allowed to start to implement a given do-loop in
   ! parallel. NOTE: Once you have parallelised a loop, remember to prevent
   ! further parallelisation, using the ".lock_parallel_do" method. This is
   ! typically used as the first statement after the parallel do loop is
   ! entered.
   end

   lock_parallel_do(name) ::: get_from(PARALLEL)
   ! Sets the parallel do-loop lock to the "name" of the locking routine.
   ! Only the routine with the same "name" may unlock the loop. WARNING: This
   ! assumes that the names of the routines are all distinct. NOTE: It is
   ! currently an error if the routine is recursive. Nested parallel loops are
   ! OK but disabled.
   end

   unlock_parallel_do(name) ::: get_from(PARALLEL)
   ! Allow parallelisation again, if the name matches the original.
   end

! Summation routines.

   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL), public
   ! This routine adds the versions of "vec" with dimension "dim" from all
   ! processors, and gives the result to all processors.
   end

   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER), public
   ! This routine adds the versions of "vec" with dimension "dim" from all
   ! processors, and gives the result to all processors.
   end

   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION), public
   ! This routine adds the versions of "vec" with dimension "dim" from all
   ! processors, and gives the result to all processors.
   end

   parallel_vector_sum(vec,dim) ::: get_from(PARALLEL, VEC_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX), public
   ! This routine adds the versions of "vec" with dimension "dim" from all
   ! processors, and gives the result to all processors.
   end

   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL)
   ! This routine adds the versions of "vec" from all processors, and gives the
   ! result to all processors.
   end

   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER)
   ! This routine adds the versions of "vec" from all processors, and gives the
   ! result to all processors.
   end

   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)
   ! This routine adds the versions of "vec" from all processors, and gives the
   ! result to all processors.
   end

   parallel_sum(vec) ::: get_from(PARALLEL, VEC_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)
   ! This routine adds the versions of "vec" from all processors, and gives the
   ! result to all processors.
   end

   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)
   ! This routine adds the versions of "mat" from all processors, and gives the
   ! result to all processors.
   end

   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)
   ! This routine adds the versions of "mat" from all processors, and gives the
   ! result to all processors.
   end

   parallel_symmetric_sum(mat) ::: get_from(PARALLEL)
   ! This routine adds the versions of "mat" from all processors, and gives the
   ! result to all processors. The matrix "mat" is assumed to be symmetric, and
   ! only the lower half of "mat" is summed; the upper triangle is forced to be
   ! the same as the lower triangle.
   end

   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT3{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)
   ! This routine adds the versions of a 3d "mat" from all processors, and gives
   ! the result to all processors.
   end

   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT3{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)
   ! This routine adds the versions of a 3d "mat" from all processors, and gives
   ! the result to all processors.
   end

   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT4{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)
   ! This routine adds the versions of a 4d "mat" from all processors, and gives
   ! the result to all processors.
   end

   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT4{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)
   ! This routine adds the versions of a 4d "mat" from all processors, and gives
   ! the result to all processors.
   end

   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT5{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION)
   ! This routine adds the versions of a 5d "mat" from all processors, and gives
   ! the result to all processors.
   end

   parallel_sum(mat) ::: get_from(PARALLEL, MAT_TYPE=>MAT5{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX)
   ! This routine adds the versions of a 5d "mat" from all processors, and gives
   ! the result to all processors.
   end

   compress_to_triangle(tr,mat) ::: get_from(PARALLEL)
   ! Converts the lower triangle of matrix "mat" to the triangle "tr".
   ! using row order.
   end

   uncompress_from_triangle(tr,mat) ::: get_from(PARALLEL)
   ! Converts the triangle "tr" into the symmetric matrix "mat".
   end

! Broadcast variables to all processors.

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>STR, MPI_TYPE=>MPI_CHARACTER, LEN=>len(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>BIN, MPI_TYPE=>MPI_LOGICAL, LEN=>1)
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>INT, MPI_TYPE=>MPI_INTEGER, LEN=>1)
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>REAL, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>1)
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>CPX, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>1)
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end


   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>VEC{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end


   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end


!   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))
!   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
!   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT3{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end


!   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))
!   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
!   end

!   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))
!   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
!   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT4{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end


!   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{STR}, MPI_TYPE=>MPI_CHARACTER, LEN=>size(var)*len(var))
!   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
!   end

!   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{BIN}, MPI_TYPE=>MPI_LOGICAL, LEN=>size(var))
!   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
!   end

!   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{INT}, MPI_TYPE=>MPI_INTEGER, LEN=>size(var))
!   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
!   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{REAL}, MPI_TYPE=>MPI_DOUBLE_PRECISION, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   broadcast(var,processor) ::: get_from(PARALLEL, VAR_TYPE=>MAT5{CPX}, MPI_TYPE=>MPI_DOUBLE_COMPLEX, LEN=>size(var))
   ! Broadcast variable "var" from processoressor "processor" to all the other processoressors.
   end

   IO_is_allowed result (res)
   ! Return whether or not this processor is allowed to do the I/O operation.
   ! Here, only the master processor does I/O in a parallel job.
      res :: BIN
      res = .is_master_processor OR (NOT .is_parallel)
   end

   synchronise_processors ::: get_from(PARALLEL)
   ! Synchronise all processors at this point.
   end

end
