!==============================================================================-
!
! MOLECULE.TAD: Transferable atomic densities (including invarioms).
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.main.foo 2881 2006-06-27 11:15:21Z dylan_ $
!==============================================================================-


module MOLECULE.TAD

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

contains

!  ===============
!  Invariom labels
!  ===============

   put_smiles_invariom_labels
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      labels :: VEC{STR}*
      invariom_kind :: VEC{VEC_{INT}}*
      n_kind,n_elem,n_dash,k,l :: INT

      ! Get the invariom labels
      labels => .atom.smiles_invariom_labels

      ! Put labels out
      stdout.flush
      stdout.text("SMILES invariom labels:")
      stdout.put(labels,left=TRUE)

      ! Make the invariom kind table
      invariom_kind.repetitions_in(labels)

      ! Maximum no. of elements
      n_kind = invariom_kind.dim
      n_elem = 0
      do k = 1,n_kind
         n_elem = max(n_elem,invariom_kind(k).element.dim)
      end

      ! Put invariom kind table out
      stdout.flush
      stdout.show("No. of distinct labels =",invariom_kind.dim)                                  
      stdout.flush
      stdout.text("Table of invariom kinds")
      stdout.flush
      n_dash = min(10,n_elem)
      stdout.dash(width=5*(n_dash+1))
      stdout.put("Kind",width=5)
      stdout.put(" #'s",width=5)
      stdout.flush
      stdout.dash(width=5*(n_dash+1))
      do k = 1,n_kind
         stdout.put(k,width=5)
         n_elem = invariom_kind(k).element.dim
         stdout.put(invariom_kind(k)[1],width=5)
         l = 1
         do 
            l = l + 1
            if (l>n_elem) exit
            if (mod(l,10)==1) then
            stdout.flush
            stdout.tab(width=5)
            end
            stdout.put(invariom_kind(k)[l],width=5)
         end
         stdout.flush
      end
      stdout.dash(width=5*(n_dash+1))

      ! Cleanup
      invariom_kind.destroy
      labels.destroy

   end

   put_invariom_labels
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      labels :: VEC{STR}*
      invariom_kind :: VEC{VEC_{INT}}*

      n_kind,n_elem,n_dash,k,l :: INT

      ! Get the invariom labels
      labels => .atom.invariom_labels

      ! Put labels out
      stdout.flush
      stdout.text("Atom names and their invariom labels:")

      do k = 1,labels.dim
         stdout.put(k,width=5)
         stdout.put(.atom(k).label,width=10,left=TRUE)
         stdout.put(labels(k),width=25,left=TRUE)
         stdout.flush
      end
      stdout.flush


      ! Make the invariom kind table
      invariom_kind.repetitions_in(labels)

      ! Maximum no. of elements
      n_kind = invariom_kind.dim
      n_elem = 0
      do k = 1,n_kind
         n_elem = max(n_elem,invariom_kind(k).element.dim)
      end

      ! Put invariom kind table out
      stdout.flush
      stdout.show("No. of distinct labels =",invariom_kind.dim)                                  
      stdout.flush
      stdout.text("Table of invariom kinds")
      stdout.flush
      n_dash = min(10,n_elem)
      stdout.dash(width=5*(n_dash+1))
      stdout.put("Kind",width=5)
      stdout.put(" #'s",width=5)
      stdout.flush
      stdout.dash(width=5*(n_dash+1))
      do k = 1,n_kind
         stdout.put(k,width=5)
         n_elem = invariom_kind(k).element.dim
         stdout.put(invariom_kind(k)[1],width=5)
         l = 1
         do 
            l = l + 1
            if (l>n_elem) exit
            if (mod(l,10)==1) then
            stdout.flush
            stdout.tab(width=5)
            end
            stdout.put(invariom_kind(k)[l],width=5)
         end
         stdout.flush
      end
      stdout.dash(width=5*(n_dash+1))

      ! Cleanup
      invariom_kind.destroy
      labels.destroy

   end

   put_invariom_label
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      label :: STR
      i :: INT
      stdin.read(i)
      label = .atom.invariom_label_of(i)
      stdout.flush
      stdout.show("Invariom label for atom "//trim(i.to_str)//" = ",label)
   end

   put_next_neighbour_handedness
   ! Put the next neighbour handedness out, for the atom with the
   ! index specified in the input.
   ENSURE(.atom.created,"no atoms")
      hand :: STR
      i :: INT
      stdin.read(i)
      hand = .atom.next_neighbour_handedness_of(i)
      stdout.flush
      stdout.show("Next-neighbour handedness of atom "//trim(i.to_str)//" = ",hand)
   end

end
