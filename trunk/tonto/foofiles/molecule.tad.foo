!==============================================================================-
!
! MOLECULE.TAD: Transferable atomic densities (including invarioms).
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.main.foo 2881 2006-06-27 11:15:21Z dylan_ $
!==============================================================================-


module MOLECULE.TAD

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

contains

!  ======================
!  Hirshfeld atom fitting
!  ======================

   refine_Hirshfeld_atoms ::: leaky
   ! Do an iterative Hirshfeld atom refinement, alternating scf and
   ! fitting, until appropriately converged, normally to 0.001\sigma

   ENSURE(.atom.created, "no atoms to fit")
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created,"no crystal data")
   ENSURE(.crystal.xray_data.created,"no crystal xray data")

      ! Initialize 
      .crystal.initialise_refinement_data

      ! Turn off unwanted printing ...
      .crystal.data.set_refine_structure(TRUE)
      .crystal.data.set_fit_structure(FALSE)
      .scfdata.set_output(FALSE)

      ! Banner, options/switches, initial parameters,
      ! start banner, and iteration table header
      .crystal.put_refinement_header_info

      do 

         ! SCF @ new geometry
         .scf

         ! Reset scf initial guess
         if (.crystal.data.ref_iteration==0) &
         .scfdata.set_initial_density(.scfdata.spinorbital_kind)

         ! Refit hirshfeld atoms
         .TAD:fit_Hirshfeld_atoms

         ! Update
         .crystal.update_refinement_parameters
         .crystal.update_refinement_errors

         ! Put the iteration results
         .crystal.put_refinement_iteration_results
 
         ! Finished?
         if (.crystal.refinement_finished) exit
 
      end

      ! Table footer and final results
      .crystal.put_refinement_footer_info

      ! Print out bond length, angle, torsion tables with errors
      .crystal.data.set_refine_structure(FALSE) ! Allow to print
      .crystal.put_bond_info_with_errors

      ! Set geometry type
      .crystal.asymmetric_unit_source = "tonto-refinement"

   end

   fit_Hirshfeld_atoms ::: leaky
   ! Fit the Hirshfeld atoms to the calculated structure factors.
   ! Exactly which atom coordinates are used for refinement is a bit
   ! confusing:
   ! * Cartesian (bohr) coordinates are used because structure factors
   !   are aspherical and calculated from the QM wavefunction
   ! * Also, structure factors are calculated only for unique fragment
   !   atoms for the same reason 
   ! * Asymmetric unit atoms are used to "store" the updating
   !   geometry; thus unique atom positions and shifts are calculated
   !   (and derivatives with respect to) but these geometries and
   !   shifts are later transformed back into asymetric unit.
   ! * Note: this routine does only one cycle of fitting with the
   !   current density matrix

   ENSURE(.atom.created, "no atoms to fit")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.becke_grid.finalized,"becke_grid not finalized")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created,"no crystal data")
   ENSURE(.crystal.xray_data.created,"no crystal xray data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      sf_n :: MAT{CPX}*

      ! Set up becke integration grid (leaky)
      .set_up_Hirshfeld_info

      ! Static atomic SF's for symmetry-unique atoms (sf_n)
      if      (.invariom_refinement) then;            .TAD:get_unique_invariom_SFs(sf_n)
      else if (.crystal.data.use_Voronoi_atoms) then; .TAD:get_unique_Voronoi_atom_SFs(sf_n)
      else;                                           .TAD:get_unique_Hirshfeld_atom_SFs(sf_n)
      end

      ! >>>>> Do the fit <<<<<<
      .crystal.fit_rigid_atoms(sf_n)

      ! Write the CIF files
      .TAD:put_cif          ! Standard CIF
      .TAD:put_accurate_cif ! Has covariances, accurate geom
      .TAD:put_molecule_cif ! Has current fragment, accurate
      .TAD:put_NKA_cartesian
      .TAD:put_excel_crystal
 
      ! Clean up
      sf_n.destroy

      ! Delete stored matrices
      .delete_scf_integrals
      .delete_scf_archives(keep_DM=TRUE)
      .destroy_scf_results(keep_MOs=TRUE)

      ! Make sure MO's are orthonormal at new geometry
      .symmetrically_orthonormalise(.molecular_orbitals)

   end
   
   get_unique_Hirshfeld_atom_SFs(sf_n) ::: leaky, private
   ! Get "sf_n", the static structure factors for the symmetry related
   ! K points with *no* thermal smearing, for every unique atom.
   ! NOTE: "sf_n" is the FT rho_a(r), eqn (3) in Jayatilaka 2008,
   ! Acta Cryst A 64 p. 383-393. It is also f_a(q) in eqn (11) except
   ! without the thermal smearing factor.
      sf_n :: MAT{CPX}*

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.becke_grid.finalized,"becke_grid not finalized")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created, "no reflection data")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.crystal.fragment_info_made, "no crystal fragment info")

      sf_u :: VEC{CPX}*
      Wc,wt, xa,ya,za,a2 :: VEC{REAL}*
      rho, k1,k2,k3, r1,r2,r3, ga,gb :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab,skipa,skipb :: VEC{BIN}*
      D,DD,k_pts,pt,grida,gridb,bf_save :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      sf,dc   :: CPX
      cutoff,rf, k1k,k2k,k3k,kr, Dab, fac, val :: REAL
      n_atom,n_k,n_pt,n_keep, u,c,ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, as, a,b,i,j,k,n,p :: INT
 
      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim
 
      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts

      ! Allocate structure factor array (leaky)
      sf_n.create(n_k,n_atom)
 
      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      k1 => k_pts(:,1)
      k2 => k_pts(:,2)
      k3 => k_pts(:,3)

      ! Density matrix (leaky)
      .make_ao_density_matrix
      ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
      D => .density_matrix.restricted

      ! Set up grids, atomic densities, overlapping_atoms (leaky)
      .set_up_Hirshfeld_info(skip_NOs=TRUE) 
 
      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Make the SF's
      sf_n = ZERO

      ! Loop over integration atoms "c"
      parallel do u = 1,.crystal.n_unique_frag_atoms

         c = .crystal.unique_frag_atom(u)
         a = .crystal.asym_atom_for_frag_atom(c)

         ! Repetition factor for this atom
         rf = .crystal.asym_atom_rep_factor(a)
         if (rf.is_zero) cycle
         rf = ONE/rf

         ! Overlapping atoms
         overlapping_atom => .overlapping_atoms_for_atom(c).element

         ! Get the Becke grid for atom "c" (leaky)
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms 
         ! are used ... otherwise nothing is skipped
         Wc.create(n_pt)
         if (.use_interpolators) then; .make_stockholder_atom_grid(Wc,c,pt,overlapping_atom)
         else;                         .make_stockholder_atom_grid(Wc,c,pt)
         end

         ! Incorporate integration weight
         wt = Wc*wt
         Wc.destroy

         ! Prune the grid with new "wt", get saved bf grid bf_save, 
         ! and new no of points, n_pt (leaky)
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Density for atom "c"
         rho.create(n_pt)
         rho = ZERO

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .precomputed_basis_shellpair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element => skipa

               ! Make/copy the "sa" basis function grida
               ! This must be copied since skipa could be TRUE
               grida.create(n_keep,na)
               if (oa/=c) then
                  ! Calculate grid if necessary
                  sha.make_skip_grid(grida,n_keep,na,xa,ya,za,a2,skipa,n_pt)
               else
                  ! Extract grid values from saved grid values
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        grida(i,a) = bf_save(n,a+fa-fba)
                     end
                  end
               end
               bf_grid(sa).element => grida

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points ... save time!
                     if (bf_skip(sb).element.destroyed) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb => bf_skip(sb).element 
                     gridb => bf_grid(sb).element 

                     ! How many points in common? Save time?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block
                     DD => D(fa:la,fb:lb)

                     if (na*nb==1) then ! s.s product

                        ! Add density contribution to rho
                        ga => grida(:,1)
                        gb => gridb(:,1)
                        Dab = fac*DD(1,1)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                     else              ! not s.s product

                        ! Create space for gathered index info
                        pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)
      
                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end
   
                        ! Add density contribution to rho
                        do a = 1,na
                           ga => grida(:,a)
                           do b = 1,nb
                              gb  => gridb(:,b)
                              Dab = fac*DD(a,b)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val
                              end
                           end
                        end
   
                        ! Clean up
                        pn.destroy; pj.destroy; pi.destroy

                     end

                  end
               end
            end
         end

         ! Grid points
         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)

         ! Weight the atom "c" density
         rho = rho*wt

         ! Make the (unique) matrix elements
         sf_u => sf_n(:,u)
         do k = 1,n_k
            k1k = k1(k)
            k2k = k2(k)
            k3k = k3(k)
            sf = IMAGIFY(ZERO)
            do i = 1,n_pt 
               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
               sf = sf + rho(i)*cmplx(cos(kr),sin(kr))
            end
            sf_u(k) = sf * rf
         end
            
         ! Clean up atom "c" stuff
         rho.destroy
         bf_grid.destroy
         bf_skip.destroy
         bf_save.destroy
         wt.destroy
         pt.destroy

         ! Add the dispersion correction
         if (NOT .crystal.correct_dispersion) cycle
         dc   = .atom(c).dispersion_correction(.crystal.wavelength)
         sf_u = sf_u + dc

      end ! -- loop over atom "c"

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
      k_pts.destroy

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_n)
      end

   end
   
   get_unique_Voronoi_atom_SFs(sf_n) ::: leaky, private
   ! Get "sf_n", the structure factors for the symmetry related 
   ! K points with *no* thermal smearing, for every unique atom. 
      sf_n :: MAT{CPX}*

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created, "no reflection data")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_atom_for_frag_atom.created,"no crystal asym_atom_for_frag_atom")
   ENSURE(.density_matrix.created, "no density matrix")

      sf_u :: VEC{CPX}*
      wt :: VEC{REAL}*
      rho, k1,k2,k3, r1,r2,r3 :: VEC{REAL}*
      D,k_pts,pt :: MAT{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      sf  :: CPX
      rf, k1k,k2k,k3k,kr :: REAL
      n_atom,n_k,n_pt, u,c,a, i,k :: INT
 
      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim
 
      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts

      ! Allocate structure factor array (leaky)
      sf_n.create(n_k,n_atom)
 
      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      k_pts.create(n_k,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      k1 => k_pts(:,1)
      k2 => k_pts(:,2)
      k3 => k_pts(:,3)

      ! Density matrix
      .make_ao_density_matrix
      ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
      D => .density_matrix.restricted

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Make the SF's
      sf_n = ZERO

      ! Loop over integration atoms "c"
      parallel do u = 1,.crystal.n_unique_frag_atoms

         c = .crystal.unique_frag_atom(u)
         a = .crystal.asym_atom_for_frag_atom(c)

         ! Repetition factor for this atom
         rf = .crystal.asym_atom_rep_factor(a)
         if (rf.is_zero) cycle
         rf = ONE/rf

         ! Make the Voronoi atom
         .make_rho_becke_atom_grid(rho,pt,wt,bf_skip,bf_grid,c,D)
         bf_grid.destroy
         bf_skip.destroy

         ! Weight the atom density
         rho = rho*wt
         n_pt = pt.dim1

         ! Grid points
         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)

         ! Make the (unique) matrix elements
         sf_u => sf_n(:,u)
         do k = 1,n_k
            k1k = k1(k); k2k = k2(k); k3k = k3(k)
            sf = (ZERO,ZERO)
            do i = 1,n_pt 
               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
               sf = sf + rho(i)*cmplx(cos(kr),sin(kr))
            end
            sf_u(k) = sf * rf
         end
            
         ! Clean up atom "c" stuff
         rho.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Clean up
      k_pts.destroy

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_n)
      end

   end

   get_unique_invariom_SFs(sf_n) ::: private
   ! Get "sf_n", the structure factors for the symmetry related 
   ! K points with *no* thermal smearing, for every unique invariom. 
      sf_n :: MAT{CPX}*

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created, "no reflection data")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_atom_for_frag_atom.created,"no crystal asym_atom_for_frag_atom")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(sf_n.dim1==.crystal.n_unique_SF_k_pts, "wrong dim1, sf_n")
   ENSURE(sf_n.dim2==.crystal.asymmetric_unit_atom.dim, "wrong dim2, sf_n")

      k_pt,pt :: MAT{REAL}*
      wt,rho,Wa, k1,k2,k3,r1,r2,r3 :: VEC{REAL}*
      k1k,k2k,k3k,kr,rf :: REAL
      n_k,n_pt,f,a,u,k,i,n_ui,ui :: INT
      sf_u :: VEC{CPX}*
      sf :: CPX
      labels :: VEC{STR}*
      invariom_kind :: VEC{VEC_{INT}}*

      ! Set up grids, atomic densities, and NO's
      .set_up_Hirshfeld_info

      ! Make the symmetry generated k's
      n_k = .crystal.n_unique_SF_k_pts
      k_pt.create(n_k,3)     
      .crystal.make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! Get the invariom labels
      labels => .atom.invariom_labels
      ! Make the invariom kind table
      ! For making the sf's we first check which invarioms are 
      ! unique as the unique atoms could be assigned the same invariom
      ! We need to get the unique invarioms for the assymetric unit
      invariom_kind.repetitions_in(labels(.crystal.unique_frag_atom))
      stdout.put(labels(.crystal.unique_frag_atom))
      n_ui = invariom_kind.dim
      sf_n.create(n_k,n_ui)
      stop
      ! Make the structure factors
      sf_n = ZERO
      parallel do ui = 1,n_ui
         u = invariom_kind(ui)[1]
         f = .crystal.unique_frag_atom(u)
         a = .crystal.asym_atom_for_frag_atom(f)
         .becke_grid.make_grid(pt,wt,[f])
         n_pt = pt.dim1
         Wa.create(n_pt)
         rho.create(n_pt)
         .make_density_grid(rho,pt)
         .make_stockholder_atom_grid(Wa,f,pt)
         Wa = rho*Wa*wt
         rf = ONE/.crystal.asym_atom_rep_factor(a)
         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)
         sf_u => sf_n(:,ui)
         do k = 1,n_k
            k1k = k1(k); k2k = k2(k); k3k = k3(k)
            sf = ZERO
            do i = 1,n_pt ! integrate over all space
               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
               sf = sf + Wa(i)*exp(cmplx(ZERO,kr))
            end
            sf_u(k) = sf * rf
         end
         rho.destroy; Wa.destroy
         wt.destroy; pt.destroy
      end
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_n)
      end

      .put_debug(sf_n,"get_unique_atom_sfs")

   end

!  =====================
!  Hirshfeld atom kappas
!  =====================

   fit_Hirshfeld_atom_kappas ::: leaky
   ! Fit the kappa scale factors for the Hirshfeld atoms so as to get
   ! the same G and K kinetic energies for each atom.
   ENSURE(.atom.created, "no atoms to fit")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created,"no crystal data")
   ENSURE(.crystal.xray_data.created,"no crystal xray data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")

      max_shift,max_allowed_shift,shift_convergence,delta,fac :: REAL
      kappa,kappa_old,kappa_del,G :: VEC{REAL}*
      H :: MAT{REAL}*
      iter,max_iter :: INT
      finished :: BIN

      ! Fit parameters
      max_iter = 50
      max_allowed_shift = 0.10d0
      shift_convergence = 0.001d0

      ! Set up grids, atomic densities
      .set_up_Hirshfeld_info

      ! Parameter vectors, shifts
      kappa.create(.n_atom)
      kappa_old.create(.n_atom)
      kappa_del.create(.n_atom)
      kappa = ONE

      ! Gradient and Hessian
      G.create(.n_atom)
      H.create(.n_atom,.n_atom)

      ! Begin kappa refinement loop
      iter = 0
      stdout.flush
      do
 
         iter = iter + 1

         ! Get the gradient G and Hessian H
         .TAD:make_scaled_stockholder_derivs(G,H,kappa,delta,skip_NOs=TRUE)

         ! Solve for the shifts
         G = -G
         H.solve_linear_equation(G,kappa_del)

         ! Get the maximum shift
       ! kappa_del = G
         max_shift = maxval(abs(kappa_del))

         ! Renormalise shift if too big
         if (max_shift>max_allowed_shift) then
            fac = max_allowed_shift/max_shift
            kappa_del = fac * kappa_del
         end

         ! Put the results
         stdout.put(iter)
         stdout.put(max_shift)
         stdout.put(delta)
         stdout.flush
       ! stdout.text("G:")
       ! stdout.put(G)

         ! Finished?
         finished = max_shift<shift_convergence OR iter>max_iter
         if (finished) exit

         ! Store parameters, add shift
         kappa_old = kappa
         kappa     = kappa + kappa_del
 
      end

      ! Put the results
      stdout.flush
      stdout.text("Final kinetic energies:")
      .TAD:put_Hirshfeld_G_and_K_energy(kappa,skip_NOs=TRUE)
      stdout.flush
      stdout.text("kappa values:")
      stdout.put(kappa)

      ! Clean up
      H.destroy; G.destroy
      kappa_del.destroy; kappa_old.destroy; kappa.destroy

   end

   put_Hirshfeld_G_and_K_energy(kappa,skip_NOs)
   ! Put the Hirshfeld G and K energies.

      kappa :: VEC{REAL}
      skip_NOs :: BIN, optional

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

      pt :: MAT{REAL}*
      E_G,E_K,wt,Wa,G_grid,K_grid :: VEC{REAL}*
      E_GT,E_KT :: REAL
      a,n_pt :: INT

      ! Set up grids, atomic densities
      .set_up_Hirshfeld_info(skip_NOs)

      ! Atomic kinetic energy arrays
      E_G.create(.n_atom)
      E_K.create(.n_atom)

      ! Make the atomic energies
      do a = 1,.n_atom
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1
         Wa.create(n_pt)
         .TAD:make_stockholder_atom_grid(Wa,a,kappa,pt)
         G_grid.create(n_pt)
         K_grid.create(n_pt)
         .make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
         E_G(a) = sum(G_grid*Wa*wt)
         E_K(a) = sum(K_grid*Wa*wt)
         K_grid.destroy; G_grid.destroy
         Wa.destroy; wt.destroy; pt.destroy
      end

      ! Check total kinetic energies
      .becke_grid.make_grid(pt,wt)
      n_pt = pt.dim1
      G_grid.create(n_pt)
      K_grid.create(n_pt)
      .make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
      E_GT = sum(G_grid*wt)
      E_KT = sum(K_grid*wt)
      K_grid.destroy; G_grid.destroy
      wt.destroy; pt.destroy

      ! Put the table
      stdout.flush
      stdout.show("Numerical E_G       =",E_GT)
      stdout.show("Sum of atomic E_G's =",sum(E_G))
      stdout.show("Numerical E_K       =",E_KT)
      stdout.show("Sum of atomic E_K's =",sum(E_K))
      stdout.flush
      stdout.dash(int_fields=2,real_fields=2)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Label",int_width=TRUE)
      stdout.put("E_G")
      stdout.put("E_K")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=2)
      do a = 1,.n_atom
         stdout.put(a)
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(E_G(a))
         stdout.put(E_K(a))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=2)

      ! Clean up
      E_K.destroy; E_G.destroy

   end

!  ===============
!  Invariom labels
!  ===============

   put_smiles_invariom_labels
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      labels :: VEC{STR}*
      invariom_kind :: VEC{VEC_{INT}}*
      n_kind,n_elem,n_dash,k,l :: INT

      ! Get the invariom labels
      labels => .atom.smiles_invariom_labels

      ! Put labels out
      stdout.flush
      stdout.text("SMILES invariom labels:")
      stdout.put(labels,left=TRUE)

      ! Make the invariom kind table
      invariom_kind.repetitions_in(labels)

      ! Maximum no. of elements
      n_kind = invariom_kind.dim
      n_elem = 0
      do k = 1,n_kind
         n_elem = max(n_elem,invariom_kind(k).element.dim)
      end

      ! Put invariom kind table out
      stdout.flush
      stdout.show("No. of distinct labels =",invariom_kind.dim)                                  
      stdout.flush
      stdout.text("Table of invariom kinds")
      stdout.flush
      n_dash = min(10,n_elem)
      stdout.dash(width=5*(n_dash+1))
      stdout.put("Kind",width=5)
      stdout.put(" #'s",width=5)
      stdout.flush
      stdout.dash(width=5*(n_dash+1))
      do k = 1,n_kind
         stdout.put(k,width=5)
         n_elem = invariom_kind(k).element.dim
         stdout.put(invariom_kind(k)[1],width=5)
         l = 1
         do 
            l = l + 1
            if (l>n_elem) exit
            if (mod(l,10)==1) then
            stdout.flush
            stdout.tab(width=5)
            end
            stdout.put(invariom_kind(k)[l],width=5)
         end
         stdout.flush
      end
      stdout.dash(width=5*(n_dash+1))

      ! Cleanup
      invariom_kind.destroy
      labels.destroy

   end

   put_invariom_labels
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      labels :: VEC{STR}*
      invariom_kind :: VEC{VEC_{INT}}*

      n_kind,n_elem,n_dash,k,l :: INT

      ! Get the invariom labels
      labels => .atom.invariom_labels

      ! Put labels out
      stdout.flush
      stdout.text("Atom names and their invariom labels:")

      do k = 1,labels.dim
         stdout.put(k,width=5)
         stdout.put(.atom(k).label,width=10,left=TRUE)
         stdout.put(labels(k),width=25,left=TRUE)
         stdout.flush
      end
      stdout.flush


      ! Make the invariom kind table
      invariom_kind.repetitions_in(labels)

      ! Maximum no. of elements
      n_kind = invariom_kind.dim
      n_elem = 0
      do k = 1,n_kind
         n_elem = max(n_elem,invariom_kind(k).element.dim)
      end

      ! Put invariom kind table out
      stdout.flush
      stdout.show("No. of distinct labels =",invariom_kind.dim)                                  
      stdout.flush
      stdout.text("Table of invariom kinds")
      stdout.flush
      n_dash = min(10,n_elem)
      stdout.dash(width=5*(n_dash+1))
      stdout.put("Kind",width=5)
      stdout.put(" #'s",width=5)
      stdout.flush
      stdout.dash(width=5*(n_dash+1))
      do k = 1,n_kind
         stdout.put(k,width=5)
         n_elem = invariom_kind(k).element.dim
         stdout.put(invariom_kind(k)[1],width=5)
         l = 1
         do 
            l = l + 1
            if (l>n_elem) exit
            if (mod(l,10)==1) then
            stdout.flush
            stdout.tab(width=5)
            end
            stdout.put(invariom_kind(k)[l],width=5)
         end
         stdout.flush
      end
      stdout.dash(width=5*(n_dash+1))

      ! Cleanup
      invariom_kind.destroy
      labels.destroy

   end

   put_invariom_label
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      label :: STR
      i :: INT
      stdin.read(i)
      label = .atom.invariom_label_of(i)
      stdout.flush
      stdout.show("Invariom label for atom "//trim(i.to_str)//" = ",label)
   end

   put_next_neighbour_handedness
   ! Put the next neighbour handedness out, for the atom with the
   ! index specified in the input.
   ENSURE(.atom.created,"no atoms")
      hand :: STR
      i :: INT
      stdin.read(i)
      hand = .atom.next_neighbour_handedness_of(i)
      stdout.flush
      stdout.show("Next-neighbour handedness of atom "//trim(i.to_str)//" = ",hand)
   end

! =======================================
! Scaled and derivative stockholder grids
! =======================================

   make_scaled_stockholder_derivs(G,H,kappa,delta,skip_NOs) ::: private
   ! Make the scaled stockholder atom derivatives "G" and hessian "H"
   ! for used in a Newton-Raphson procedure to find the best scale
   ! factors.
      self :: IN
      G :: VEC{REAL}, OUT
      H :: MAT{REAL}, OUT
      kappa :: VEC{REAL}, IN
      delta :: REAL
      skip_NOs :: BIN, optional

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(H.is_square,"H is not square")
   ENSURE(G.dim==H.dim1,"G and H are inconsistent")

      Wa_cd :: MAT3{REAL}*
      pt,Wa_c :: MAT{REAL}*
      wt,Wa,G_grid,K_grid,Ga :: VEC{REAL}*
      delta2 :: REAL
      a,c,d,n_pt :: INT

      ! Set up grids, spherical atomic densities, and NO's
      .set_up_Hirshfeld_info(skip_NOs)

      ! Make the stockholder derivatives D and H
      delta = ZERO
      G = ZERO
      H = ZERO
      do a = 1,.n_atom

         ! Make integration grids
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1

         ! Make G and K kinetic densities
         G_grid.create(n_pt)
         K_grid.create(n_pt)
         .make_G_and_K_kinetic_grids(G_grid,K_grid,pt)

         ! Make Hirshfeld atoms
         Wa.create(n_pt)
         .TAD:make_stockholder_atom_grid(Wa,a,kappa,pt)

         ! Make delta kinetic grid
         G_grid = (G_grid - K_grid)*wt
         delta2 = TWO*sum(G_grid*Wa)
         delta  = delta + QUARTER*delta2*delta2
         Wa.destroy
         K_grid.destroy

         ! Stockholder 1st derivatives
         Ga.create(.n_atom)
         Wa_c.create(n_pt,.n_atom)
         .TAD:make_d_stockholder_atom_grid(Wa_c,a,kappa,pt)
         do c = 1,.n_atom
            Ga(c) = sum(Wa_c(:,c)*G_grid)
         end
         Wa_c.destroy

         ! Add contribution from 1st derivatives
         G = G + delta2*Ga
         H.plus_outer_product_of(Ga,TWO)
         Ga.destroy

         ! Stockholder 2nd derivatives
         Wa_cd.create(n_pt,.n_atom,.n_atom)
         .TAD:make_d2_stockholder_atom_grid(Wa_cd,a,kappa,pt)

         ! Add contribution from 2nd derivatives
         G_grid = delta2*G_grid
         do c = 1,.n_atom
         do d = 1,.n_atom
            H(c,d) = H(c,d) + sum(Wa_cd(:,c,d)*G_grid)
         end
         end
         Wa_cd.destroy

         ! Clean
         G_grid.destroy
         wt.destroy; pt.destroy
      end

      delta = sqrt(delta)

   end

   make_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the scaled stockholder desity "grid" for the atom with index
   ! "a" and with scale parameters "kappa" using supplied points "pt".
   ! This uses gaussian atomic densities.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      kappa :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")
      rho_a :: VEC{REAL}*
      n_pt,i :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_density_grid(rho_a,pt)

      ! Make total density in "grid"
      grid = kappa(a)*rho_a
      do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_density_grid(grid,pt,kappa(i))
      end

      ! Make the stockholder weight
      do i = 1,n_pt
       if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
       else;                           grid(i) = ZERO
       end
      end
      rho_a.destroy

   end

   make_d_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the derivative scaled stockholder desity "grid" for the atom
   ! with index "a" and with scale parameters "kappa" using supplied
   ! points "pt".  This uses gaussian atomic densities.
      self :: IN
      grid :: MAT{REAL}, OUT
      a  :: INT, IN
      kappa :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim1==pt.dim1,"wrong dim1, grid")
   ENSURE(grid.dim2==.n_atom,"wrong dim2, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

      rho_a,rho_c,rho :: VEC{REAL}*
      n_pt,i,c :: INT

      ! Allocate temporary densities
      n_pt = grid.dim1
      rho_a.create(n_pt)
      rho_c.create(n_pt)
      rho.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_density_grid(rho_a,pt)

      ! Make total density in "rho" with kappa factors
      rho_a = kappa(a)*rho_a
      rho = rho_a
      do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_density_grid(rho,pt,kappa(i))
      end

      where (rho>epsilon(ONE)); rho_a = rho_a/(rho*rho)
      elsewhere;                rho_a = ZERO
      end

      ! Make the derivative stockholder weight
      do c = 1,.n_atom

        .atom(c).make_density_grid(rho_c,pt)

        grid(:,c) = -rho_a*rho_c

        if (c/=a) cycle
        where (rho>epsilon(ONE)) grid(:,c) = grid(:,c) + rho_c/rho
         
      end

      ! Clean
      rho.destroy
      rho_c.destroy; rho_a.destroy

   end

   make_d2_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the 2nd derivative scaled stockholder desity "grid" for the
   ! atom with index "a" and with scale parameters "kappa" using
   ! supplied points "pt".  This uses gaussian atomic densities.
      self :: IN
      grid :: MAT3{REAL}, OUT
      a  :: INT, IN
      kappa :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim1==pt.dim1,"wrong dim1, grid")
   ENSURE(grid.dim2==.n_atom,"wrong dim2, grid")
   ENSURE(grid.dim3==.n_atom,"wrong dim3, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

      rho_a,rho_c,rho_d,rho :: VEC{REAL}*
      n_pt,i,c,d :: INT

      ! Allocate temporary densities
      n_pt = grid.dim1
      rho_a.create(n_pt)
      rho_c.create(n_pt)
      rho_d.create(n_pt)
      rho.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_density_grid(rho_a,pt)

      ! Make total density in "rho" with kappa factors
      rho_a = kappa(a)*rho_a
      rho = rho_a
      do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_density_grid(rho,pt,kappa(i))
      end

      where (rho>epsilon(ONE)); rho_a = TWO*rho_a/(rho*rho*rho)
      elsewhere;                rho_a = ZERO
      end

      where (rho>epsilon(ONE)); rho = ONE/(rho*rho)
      elsewhere;                rho = ZERO
      end

      ! Make the derivative stockholder weight
      do c = 1,.n_atom

        .atom(c).make_density_grid(rho_c,pt)

        do d = 1,.n_atom

           .atom(d).make_density_grid(rho_d,pt)
   
           grid(:,c,d) =  rho_a*rho_c*rho_d
   
           if (c==a) grid(:,c,d) = grid(:,c,d) - rho_d*rho
           if (d==a) grid(:,c,d) = grid(:,c,d) - rho_c*rho
         
        end

      end

      ! Clean
      rho.destroy
      rho_d.destroy; rho_c.destroy; rho_a.destroy

   end

!  =======
!  Put cif
!  =======

   put_cif
   ! Prints out a cif file for the crystal asymmetric unit
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      scf_type :: STR
      mass,radius :: REAL

      ! Create the cif file
      stdout.redirect(trim(.name)//".standard.cif")
      stdout.open(for="write")

      ! Put the header information
      stdout.text("# ========================")
      stdout.text("# TONTO generated CIF file")
      stdout.text("# ========================")
      stdout.flush 
      stdout.text("data_"//trim(.name))
      stdout.flush 
      stdout.text("_audit_creation_date               "//trim(std_time.current_date_YMD_str))
      stdout.text("_audit_creation_method             'Tonto v"//TONTO_VERSION//" ($Rev: 3699 $)'")
      stdout.flush 
      stdout.text("# ==================--")
      stdout.text("# Chemical information")
      stdout.text("# ==================--")
      stdout.flush 
      stdout.text("_chemical_name_common              "//trim(.name))
      stdout.text("_chemical_formula_moiety           '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_sum              '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      mass = .atom.mass
      stdout.text("_chemical_formula_weight           "//trim(mass.to_str("f8.2")))
      stdout.text("_chemical_compound_source          'see text'")
      stdout.text("_chemical_absolute_configuration   unk")

      ! Put the crystal information
      scf_type = " "
      if (.scfdata.created) then
         scf_type = .scfdata.scf_kind
         if (.scfdata.is_DFT_calculation) then
            scf_type = trim(scf_type)//" "// &
                       trim(.scfdata.dft_exchange_functional)// &
                       trim(.scfdata.dft_correlation_functional)
         end
         if (.scfdata.using_cluster_charges) then
            radius = .scfdata.cluster_radius.to_units("angstrom")
            scf_type = trim(scf_type)//" using cluster charges, radius="// &
                       trim(radius.to_str("f5.1"))//" angstrom"
         end
      end
      .crystal.put_cif(.basis_name,scf_type)

      ! Clean up
      stdout.revert

   end

   put_accurate_cif
   ! Prints out an accurate cif file for the crystal asymmetric unit
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      scf_type :: STR
      mass,radius :: REAL

      ! Create the cif file
      stdout.redirect(trim(.name)//".accurate.cif")
      stdout.open(for="write")

      ! Put the header information
      stdout.text("# ========================")
      stdout.text("# TONTO generated CIF file")
      stdout.text("# ========================")
      stdout.flush 
      stdout.text("data_"//trim(.name))
      stdout.flush 
      stdout.text("_audit_creation_date               "//trim(std_time.current_date_YMD_str))
      stdout.text("_audit_creation_method             'Tonto v"//TONTO_VERSION//" ($Rev: 3699 $)'")
      stdout.flush 
      stdout.text("# ==================--")
      stdout.text("# Chemical information")
      stdout.text("# ==================--")
      stdout.flush 
      stdout.text("_chemical_name_common              "//trim(.name))
      stdout.text("_chemical_formula_moiety           '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_sum              '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      mass = .atom.mass
      stdout.text("_chemical_formula_weight           "//trim(mass.to_str("f8.2")))
      stdout.text("_chemical_compound_source          'see text'")
      stdout.text("_chemical_absolute_configuration   unk")

      ! Put the crystal information
      scf_type = " "
      if (.scfdata.created) then
         scf_type = .scfdata.scf_kind
         if (.scfdata.is_DFT_calculation) then
            scf_type = trim(scf_type)//" "// &
                       trim(.scfdata.dft_exchange_functional)// &
                       trim(.scfdata.dft_correlation_functional)
         end
         if (.scfdata.using_cluster_charges) then
            radius = .scfdata.cluster_radius.to_units("angstrom")
            scf_type = trim(scf_type)//" using cluster charges, radius="// &
                       trim(radius.to_str("f5.1"))//" angstrom"
         end
      end
      .crystal.put_accurate_cif(.basis_name,scf_type)

      ! Clean up
      stdout.revert

   end

   put_molecule_cif
   ! Prints out an accurate cif file for the actual molecule
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      scf_type :: STR
      mass,radius :: REAL

      ! Create the cif file
      stdout.redirect(trim(.name)//".molecule.cif")
      stdout.open(for="write")

      ! Put the header information
      stdout.text("# ========================")
      stdout.text("# TONTO generated CIF file")
      stdout.text("# ========================")
      stdout.flush 
      stdout.text("data_"//trim(.name))
      stdout.flush 
      stdout.text("_audit_creation_date               "//trim(std_time.current_date_YMD_str))
      stdout.text("_audit_creation_method             'Tonto v"//TONTO_VERSION//" ($Rev: 3699 $)'")
      stdout.flush 
      stdout.text("# ==================--")
      stdout.text("# Chemical information")
      stdout.text("# ==================--")
      stdout.flush 
      stdout.text("_chemical_name_common              "//trim(.name))
      stdout.text("_chemical_formula_moiety           '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_sum              '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      mass = .atom.mass
      stdout.text("_chemical_formula_weight           "//trim(mass.to_str("f8.2")))
      stdout.text("_chemical_compound_source          'see text'")
      stdout.text("_chemical_absolute_configuration   unk")

      ! Put the crystal information
      scf_type = " "
      if (.scfdata.created) then
         scf_type = .scfdata.scf_kind
         if (.scfdata.is_DFT_calculation) then
            scf_type = trim(scf_type)//" "// &
                       trim(.scfdata.dft_exchange_functional)// &
                       trim(.scfdata.dft_correlation_functional)
         end
         if (.scfdata.using_cluster_charges) then
            radius = .scfdata.cluster_radius.to_units("angstrom")
            scf_type = trim(scf_type)//" using cluster charges, radius="// &
                       trim(radius.to_str("f5.1"))//" angstrom"
         end
      end
      .crystal.put_molecule_cif(.atom,.basis_name,scf_type)

      ! Clean up
      stdout.revert

   end

   put_NKA_cartesian
   ! Prints out (some of) the data for an NKA analysis
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      ! Create the NKA file
      stdout.redirect("stdout.nka_cartesian")
      stdout.open(for="write")

      ! Reset accuracy
      stdout.save
      stdout.set_real_width(11)
      stdout.set_real_precision(6)

      ! Name
      stdout.text(.name)

      ! Put the NKA data
      .crystal.put_NKA_cartesian

      ! Clean up
      stdout.unsave
      stdout.revert

   end

!   put_NKA_crystal
!   ! Prints out (some of) the data for an NKA analysis
!   ENSURE(.crystal.created, "No crystal")
!   ENSURE(.atom.created, "No atom")
!
!      ! Create the NKA file
!      stdout.redirect("stdout.nka_crystal")
!      stdout.open(for="write")
!
!      ! Reset accuracy
!      stdout.save
!      stdout.set_real_width(11)
!      stdout.set_real_precision(6)
!
!      ! Name
!      stdout.text(.name)
!
!      ! Put the NKA data
!      .crystal.put_NKA_crystal
!
!      ! Clean up
!      stdout.unsave
!      stdout.revert
!
!   end

   put_excel_crystal
   ! Prints out crystal data in excel format for easy comparison
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      ! Create the NKA file
      stdout.redirect("stdout.nka_excel")
      stdout.open(for="write")

      ! Reset accuracy
      stdout.save
      stdout.set_real_width(11)
      stdout.set_real_precision(6)

      ! Name
      stdout.text(.name)

      ! Put the Excel data
      .crystal.put_excel_crystal

      ! Clean up
      stdout.unsave
      stdout.revert

   end

end
