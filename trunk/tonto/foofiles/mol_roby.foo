!-------------------------------------------------------------------------------
!
! MOL: roby population analysis routines.
!
! $Id$
!
! (c) chris taylor, uwa, 1999.
!-------------------------------------------------------------------------------
module MOL_ROBY

   use TYPES
   use SYSTEM
   use TIME

   use STR
   use INT
   use DBL
   use BUFFER

   use IVEC
   use IVECVEC
   use VEC
   use VECVEC
   use MAT
   use MATVEC
   use OPVEC
   use OPMAT

   use INPUT
   use OUTPUT
   use ARCHIVE

   use ATOM
   use ATOMVEC

   use SCFDATA

   use MOL_COMMON
   use MOL_INTEGRALS
   use MOL_XTAL
   use MOL_IO
   use MOL_SCF
   use MOL_PLOT

   implicit none         

#  include "macros"
#  include "mol_roby.int"

contains

   prepare_roby_data  [leaky]
   ! Provides the preliminary data required to do the Roby population analysis
      if ( .mult /= 1) then; .make_ANSO_data
      else;                  .make_ANO_data
      end
   end

   make_ANO_data [leaky]
   ! Prepare the restricted atomic natural orbital (ANO) data 
      INT :: k,u,n_no, j
      MOL, PTR :: mol
      BIN :: output
      output = TRUE
      do k = 1,.n_atom_kind ! Do an SCF for every different kind of atom
         mol.create
         u = .unique_atom(k)
         .make_molecule_from_atom(u,mol)
         mol%scfdata%output = FALSE
         mol.scf
         mol.make_ao_density_matrix
         mol%pointgroup.create("oh")
         mol.symmetrise(mol%density_matrix)
         mol.make_natural_orbitals
         .atom(u)%natural_orbitals => mol%natural_orbitals
         .atom(u)%occupation       => mol%occupation
         do j = u+1,.n_atom
            if (.atom_kind(j)/=k) cycle
            .atom(j)%natural_orbitals => .atom(u)%natural_orbitals
            .atom(j)%occupation       => .atom(u)%occupation
         end
         mol%atom.nullify_ptr_part     ! do not destroy these
         nullify(mol%natural_orbitals) ! do not destroy this
         nullify(mol%occupation)       ! do not destroy this
         nullify(mol%basis)            ! do not destroy this
         mol.destroy
         if (NOT output) cycle
         n_no = .atom(u)%occupation%restricted.no_of_elements_larger_than(0.05d0)
         .out.show("n_no=",n_no)
         .atom(u).put_natural_orbitals(.out)
      end
   end

   make_ANSO_data [leaky]
   ! Prepare the unrestricted atomic natural spin orbital (ASNO) data 
      INT :: k,u,a
      MOL, PTR :: mol
      BIN :: output
      output = TRUE
      do k = 1,.n_atom_kind ! Do an SCF for every different kind of atom
         mol.create
         u = .unique_atom(k)
         .make_molecule_from_atom(u,mol)
         mol%scfdata%output = FALSE
         mol.scf
         mol%density_matrix.convert_to("unrestricted",factor=HALF)
         mol%density_matrix%restricted.destroy
         mol%pointgroup.create("oh")
         mol.symmetrise(mol%density_matrix)
         mol.make_natural_orbitals
         .atom(u)%natural_orbitals => mol%natural_orbitals
         .atom(u)%occupation       => mol%occupation
         do a = u+1,.n_atom
            if (.atom_kind(a)/=k) cycle
            .atom(a)%natural_orbitals => .atom(u)%natural_orbitals
            .atom(a)%occupation       => .atom(u)%occupation
         end
         mol%atom.nullify_ptr_part     ! do not destroy these
         nullify(mol%natural_orbitals) ! do not destroy this
         nullify(mol%occupation)       ! do not destroy this
         nullify(mol%basis)            ! do not destroy this
         mol.destroy
         if (NOT output) cycle
         .atom(u).put_natural_orbitals(.out)
      end
   end

!
!      read_loop: do
!         .in.read(word)
!         select case(word)
!            case("end");        exit read_loop
!            case("plot_theta_c"); 
!                o_no = .in.next_int
!                .plot_theta_orbitals( orb_type="covalent_orbitals", orb_no=o_no)
!            case("plot_theta_i");
!                o_no = .in.next_int
!                .plot_theta_orbitals( orb_type="ionic_orbitals", orb_no=o_no)
!            case("plot_density"); .plot_subspace_density( S)
!            case("plot_diff");    .plot_density_difference( S)
!            case("energy");     
!               .read_shared_energy_atoms( S)
!         end
!      end do read_loop

   put_roby_shared_population
   ! Evaluate and put the Roby shared population for a group of atoms
      DBL :: shared_population
      INT :: n_roby_atom,k,n_k,total_combs,count,m,a
      IVEC, PTR :: roby_atom
      VEC, PTR :: population,pop
      IMAT, PTR :: comb_mat
      n_roby_atom = .in%buffer%n_items - 1
      roby_atom.create(n_roby_atom)
      do k = 1,n_roby_atom
         roby_atom(k) = .in.next_int
      end
      !
      do k = 1,n_roby_atom ! isnt this just 2^k ?
         n_k = n_roby_atom.choose(k)
         total_combs = total_combs + n_k   ! gets number of combinations
      end
      !
      population.create(total_combs)       ! This is a very big array
      pop.create(n_roby_atom)
      shared_population = 0
      count = 0
      do k = 1,n_roby_atom
         n_k = n_roby_atom.choose(k)
         comb_mat.create(k,n_k)
         comb_mat = roby_atom.get_combination_matrix_from(k)
         pop(k) = 0
         do m = 1,n_k
            count = count + 1
            population(count) = .roby_population(comb_mat(:,m))
            pop(k) = pop(k) + population(count)
         end      
         comb_mat.destroy
         shared_population = shared_population - ((-1)**k)*pop(k)
      end
      !
      .out.flush
      .out.text("Roby multi-atom shared population analysis:")
      .out.flush
      .out.put_text("Atom list         =")
      do k = 1,n_roby_atom
         a = roby_atom(k)
         .out.put_text( " " )
         .out.put_text( .atom(a).chemical_symbol.trim)
         .out.put_text( "(" )
         .out.put_text( a.to_str.trim )
         .out.put_text( ")" )
      end
      .out.flush
      .out.show("Shared population =",shared_population)
      .out.flush
      .out.text("Shared populations by group order:")
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("Order",int_width=TRUE)
      .out.put("Population")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      do k = 1,n_roby_atom
         .out.put(k)
         .out.put(pop(k))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=1)
      pop.destroy
      population.destroy
      roby_atom.destroy
   end

   make_roby_projected_density(rho,roby_atom)
   ! Make the Roby-projected density matrix in the concatenated basis 
   ! of AO functions of the atoms in "roby_atoms" and copy it into
   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
   ! corresponding to basis functions in "roby_atoms" are made zero.
      MAT :: rho
      IVEC :: roby_atom
      MAT, PTR :: D,P,rho_W
      INT :: n_bf
      ENSURE(size(rho,1)==.n_bf,"rho has wrong shape")
      ENSURE(size(rho,2)==.n_bf,"rho has wrong shape")
      n_bf = .atom(roby_atom).no_of_basis_functions
      D.create(n_bf,n_bf)
      .roby_overlap_transform( .density_matrix%restricted,D,col_atom=roby_atom)
      P.create(n_bf,n_bf)
      .make_roby_projection_matrix(P,roby_atom)
      rho_W.create(n_bf,n_bf)
      .roby_project(D,rho_W,P) ! rho_W(small) = P_W(small) D(small) P_W(small)
      .AO_subspace_set(rho,rho_W,A_row_atom=roby_atom,A_col_atom=roby_atom)
      rho_W.destroy
      P.destroy
      D.destroy
   end

   put_roby_shared_energy
   ! Evaluate and put the Roby shared energy for a group of atoms
      DBL :: shared_energy
      INT :: n_roby_atom,k,n_k,total_combs,count,m,a
      IVEC, PTR :: roby_atom
      VEC, PTR :: energy,en
      IMAT, PTR :: comb_mat
      n_roby_atom = .in%buffer%n_items - 1
      roby_atom.create(n_roby_atom)
      do k = 1,n_roby_atom
         roby_atom(k) = .in.next_int
      end
      !
      do k = 1,n_roby_atom ! isnt this just 2^k ?
         n_k = n_roby_atom.choose(k)
         total_combs = total_combs + n_k   ! gets number of combinations
      end
      !
      energy.create(total_combs)       ! This is a very big array
      en.create(n_roby_atom)
      shared_energy = 0
      count = 0
      do k = 1,n_roby_atom
         n_k = n_roby_atom.choose(k)
         comb_mat.create(k,n_k)
         comb_mat = roby_atom.get_combination_matrix_from(k)
         en(k) = 0
         do m = 1,n_k
            count = count + 1
            energy(count) = .roby_energy(comb_mat(:,m))
            en(k) = en(k) + energy(count)
         end      
         comb_mat.destroy
         shared_energy = shared_energy - ((-1)**k)*en(k)
      end
      !
      .out.flush
      .out.text("Roby multi-atom shared energy analysis:")
      .out.flush
      .out.put_text("Atom list         =")
      do k = 1,n_roby_atom
         a = roby_atom(k)
         .out.put_text( " " )
         .out.put_text( .atom(a).chemical_symbol.trim)
         .out.put_text( "(" )
         .out.put_text( a.to_str.trim )
         .out.put_text( ")" )
      end
      .out.flush
      .out.show("Shared energy =",shared_energy)
      .out.flush
      .out.text("Shared energies by group order:")
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("Order",int_width=TRUE)
      .out.put("Population")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      do k = 1,n_roby_atom
         .out.put(k)
         .out.put(en(k))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=1)
      en.destroy
      energy.destroy
      roby_atom.destroy
   end

   roby_energy(roby_atom) result(energy)
   ! Return the (total) Roby energy for the group of atoms whose
   ! indices are given in "roby_atom".
      IVEC :: roby_atom
      DBL :: energy
      OPMAT, PTR :: D,D_save
      MAT, PTR :: P
      P.create(.n_bf, .n_bf)
      .make_roby_projected_density(P,roby_atom)
      D_save => .density_matrix
      D.create(.n_bf,"restricted")
      D%restricted = P ! P is projected density
      .density_matrix => D
      .make_fock_matrix
      energy = .scf_electronic_energy(D)
      .density_matrix => D_save
      D.destroy
      P.destroy
   end
   
   roby_population_analysis [leaky]
   ! Do a Roby population analysis of a molecule
   VEC, PTR :: n1, less
   MAT, PTR :: n2
   INT :: n_atom, n_bf, i, j, o_no
   MAT, PTR :: index, cov
   DBL :: bi, c, d1, d2
   STR :: word
      .prepare_roby_data
      n_atom = .n_atom
      n1.create(n_atom)           ! Roby populations
      less.create(n_atom)         ! ?
      less = ZERO
      n2.create(n_atom,n_atom)    ! Roby pair populations
      index.create(n_atom,n_atom) !
      cov.create(n_atom,n_atom)   !
      do i = 1,n_atom
         n1(i) = .roby_population((/i/)) 
      end
      do i = 2,n_atom
      do j = 1,i-1
         n2(i,j) = .roby_population((/i,j/)) 
         index(i,j) = .roby_gould_bond_index((/i,j/), d1, d2, cov(i,j)) 

         less(i) = (n1(i) + n1(j) - n2(i,j))*(d2/(d1+d2)) + less(i)
         less(j) = less(j) + (n1(i) + n1(j) -n2(i,j))*(d1/(d1+d2))

      end
      end
      .put_roby_populations( n1, n2, index, cov)
      n1.destroy; n2.destroy; less.destroy 
      cov.destroy; index.destroy
   end

   put_roby_populations(n1, n2, index, covalency)
   ! Put .out the Roby population analysis data
      VEC  :: n1
      ! charge = fitted excess charge
      ! charge2 =  roby_gould charge
      ! charge3 = equally distributed charge
      ! charge4 = fitted equally distributed charge
      ! charge5 = proportionate fitin gto Roby Gould charge
      VEC, PTR :: charge, charge2, charge3, charge4, charge5
      MAT, PTR :: index, covalency
      DBL :: polarization, polarization2, sum_n
      MAT  :: n2
      INT :: k,l,kk,ll,a,b
      STR :: symbol_a,symbol_b
      .out.flush
      .out.text("Roby populations:",flush=2)
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("Atom",int_width=TRUE)
      .out.put("Population")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      do a = 1,.n_atom
         symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
         .out.put( symbol_a,int_width=TRUE)
         .out.put( n1(a))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=1)
      !
      .out.flush
      .out.text("Roby pair populations:",flush=2)
      .out.dash(int_fields=2,dbl_fields=4)
      .out.put("Atom_a",int_width=TRUE)
      .out.put("Atom_b",int_width=TRUE)
      .out.put("n_ab")
      .out.put("s_ab")
      .out.put("Bond Index")
      .out.put("% Covalency")
      .out.flush
      .out.dash(int_fields=2,dbl_fields=4)
      do a = 1,.n_atom
      do b = 1,a-1
         symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
         symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
         .out.put(symbol_a,int_width=TRUE)
         .out.put(symbol_b,int_width=TRUE)
         .out.put(n2(a,b))
         .out.put(n1(a)+n1(b)-n2(a,b))
         .out.put(index(a,b))
         .out.put(covalency(a,b))
         .out.flush
      end
      end
      .out.dash(int_fields=2,dbl_fields=4)
   end

   roby_population(roby_atom) result (pop) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom".
      IVEC :: roby_atom
      DBL :: pop
      MAT, PTR :: X,Y
      INT :: n_bf,i
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      Y.create(.n_bf, .n_bf)
      .make_roby_projection_matrix(X,roby_atom)
      .roby_overlap_transform(X,Y,roby_atom)
      pop = Y.trace_product_with( .density_matrix%restricted)
      Y.destroy
      X.destroy
   end

   roby_population(roby_atom,ANO) result (pop) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom" and for which the roby projection
   ! operator orbitals are defined by columns of "ANO"
      IVEC :: roby_atom
      MAT :: ANO
      DBL :: pop
      MAT, PTR :: X,Y
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      Y.create(.n_bf, .n_bf)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      .roby_overlap_transform(X,Y,roby_atom)
      pop = Y.trace_product_with( .density_matrix%restricted)
      Y.destroy
      X.destroy
   end

   roby_population(roby_atom,ANO,atom) result (pop) 
   ! Return the (total) Roby population for atom "atom" of the group of atoms whose
   ! indices are given in "roby_atom" and for which the roby projection operator 
   ! orbitals are defined by columns of "ANO"
      IVEC :: roby_atom
      MAT :: ANO
      INT :: atom
      DBL :: pop
      MAT, PTR :: X,Y,PA,Z,W
      INT :: n_bf,n_af
      n_bf = .atom(roby_atom).no_of_basis_functions
      n_af = .atom(roby_atom(atom)).no_of_basis_functions
      X.create(n_bf, n_bf)
      Y.create(n_af, n_af)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      .roby_overlap_transform(X,Y,roby_atom,roby_atom(atom:atom))
      PA.create(n_af,n_af)
      .make_roby_projection_matrix(PA,roby_atom(atom:atom))
      Z.create(n_af,n_af)
      .roby_project(Y,Z,PA)
      W.create(.n_bf,.n_bf)
      .roby_overlap_transform(Z,W,roby_atom(atom:atom))
      pop = W.trace_product_with( .density_matrix%restricted)
      W.destroy
      Z.destroy
      PA.destroy
      Y.destroy
      X.destroy
   end

   make_roby_projection_matrix(P,roby_atom)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom"
      MAT :: P
      IVEC :: roby_atom
      STR :: kind
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      ENSURE(size(P,1)==n_bf,"P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,"P is incorrectly dimensioned")
      n_occ = .atom(roby_atom).no_of_occupied_ANOs(tol=0.05d0)
      n_roby_atom = size(roby_atom)
      W.create(n_bf,n_occ)                   ! W = columns of ANO's
      .make_ANO_matrix(W,roby_atom)          
      Y.create(n_bf,n_bf)                    ! Y = overlap matrix for roby_atoms(:) basis
      .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
      X.create(n_occ,n_occ)
      Y.change_basis(X,W)                    ! X = S in the ANO basis
      Y.destroy
      Y.create(n_occ,n_occ)
      Y.to_inverse_of(X)                     ! Y = (ANO overlap matrix)^{-1}
      X.destroy
      Y.back_transform(P,W)                  ! P = Y in the roby_atom(:) AO basis
      Y.destroy
      W.destroy
   end

   make_roby_projection_matrix(P,roby_atom,ANO)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom" using the columns of "ANO" as 
   ! orbital coefficients to form the projection operator.
      MAT :: P
      IVEC :: roby_atom
      MAT :: ANO
      STR :: kind
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      ENSURE(size(P,1)==n_bf,  "P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,  "P is incorrectly dimensioned")
      ENSURE(size(ANO,1)==n_bf,"ANO is incorrectly dimensioned")
      n_occ = size(ANO,2)
      n_roby_atom = size(roby_atom)
      W.create(n_bf,n_occ)                   ! W = columns of ANO's
      W = ANO                                
      Y.create(n_bf,n_bf)                    ! Y = overlap matrix for roby_atoms(:) basis
      .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
      X.create(n_occ,n_occ)
      Y.change_basis(X,W)                    ! X = S in the ANO basis
      Y.destroy
      Y.create(n_occ,n_occ)
      Y.to_inverse_of(X)                     ! Y = (ANO overlap matrix)^{-1}
      X.destroy
      Y.back_transform(P,W)                  ! P = Y in the roby_atom(:) AO basis
      Y.destroy
      W.destroy
   end

   make_roby_overlap_matrix(SS,row_atom,col_atom)
   ! Make an overlap section "SS" from the basis functions of the atoms
   ! specified in "row_atom" and "col_atom".
      MAT :: SS
      IVEC, optional :: row_atom,col_atom
      MAT, PTR :: S
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      .AO_subspace_set(SS,S,B_row_atom=row_atom,B_col_atom=col_atom)
      S.destroy
   end

   make_ANO_matrix(ANO,roby_atom)
   ! Make the ANO matrix "ANO" comprised of columns of the occupied atomic natural orbitals,
   ! for each atom whose index appears in "roby_atom".
      MAT :: ANO
      IVEC :: roby_atom
      INT :: n_roby_atom,a, n_bf,n_occ,B,N
      n_roby_atom = size(roby_atom)
      ANO = ZERO
      b = 0; n = 0
      do a = 1,n_roby_atom
         n_bf  = .atom(roby_atom(a)).no_of_basis_functions
         n_occ = .atom(roby_atom(a)).no_of_occupied_NOs(tol=0.05d0)
         ANO(b+1:b+n_bf,n+1:n+n_occ) &
          = .atom(roby_atom(a))%natural_orbitals%restricted(:,1:n_occ)
         b = b + n_bf
         n = n + n_occ
      end      
   end

   roby_gould_bond_index(roby_atom, d1, d2, pcc) result(bond_index)
   ! Calculates the Roby-Gould bond index for two atoms
      IVEC :: roby_atom
      DBL :: d1,d2, pcc, bond_index
      MAT, PTR :: P_A, P_B, P_AB
      MAT, PTR :: C, theta_c, S, theta_s
      VEC, PTR :: cos_eigenvalue, c_p, sin_eigenvalue, s_p
      VEC, PTR :: covalency, ionicity, c_a, c_b
      IVEC, PTR :: c_pair, s_pair
      DBL :: total_c, total_i, bi, pci
      INT :: n_a, n_b, n_ab, i, j, a, b
      BIN :: output
      ENSURE(size(roby_atom)==2,"roby_atom has wrong size")
      output = TRUE
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      C.create(n_ab,n_ab); theta_c.create(n_ab, n_ab); cos_eigenvalue.create(n_ab)
      S.create(n_ab,n_ab); theta_s.create(n_ab, n_ab); sin_eigenvalue.create(n_ab)
      P_A.create(n_a,n_a); P_B.create(n_b,n_b); P_AB.create(n_ab,n_ab)
      .make_roby_projection_matrix(P_A ,(/a/)  )
      .make_roby_projection_matrix(P_B ,(/b/)  )
      .make_roby_projection_matrix(P_AB,(/a,b/))
      C = ZERO
      C(    1:n_a ,     1:n_a ) =  P_A
      C(n_a+1:n_ab, n_a+1:n_ab) =  P_B
      C = C - P_AB
      .make_gould_theta_orbitals(C,roby_atom,theta_c,cos_eigenvalue)
      S = ZERO
      S(    1:n_a ,     1:n_a ) =  P_A
      S(n_a+1:n_ab, n_a+1:n_ab) = -P_B
      .make_gould_theta_orbitals(S,roby_atom,theta_s,sin_eigenvalue)
      P_AB.destroy
      P_B.destroy
      P_A.destroy
    ! .archive_orbitals( theta_c, theta_s, a, b)
      c_pair.create(n_ab); s_pair.create(n_ab)
      cos_eigenvalue.find_opposite_pairs(c_pair,TOL(5),ONE-TOL(5))
      sin_eigenvalue.find_opposite_pairs(s_pair,TOL(5),ONE-TOL(5))
      c_p.create(n_ab); s_p.create(n_ab)
      c_a.create(n_ab); c_b.create(n_ab)
      do i = 1, n_ab 
        c_p(i) = .roby_population(roby_atom,theta_c(:,i:i)) 
        s_p(i) = .roby_population(roby_atom,theta_s(:,i:i)) 
        c_a(i) = .roby_population(roby_atom,theta_c(:,i:i),1) 
        c_b(i) = .roby_population(roby_atom,theta_c(:,i:i),2) 
      end
      covalency.create(n_ab)
      ionicity.create( n_ab)
    ! where (c_pair>0)
    !    covalency = (c_p - c_p(c_pair))/2
    !    d1 = sum(c_a) + sum(c_a(c_pair))
    !    d2 = sum(c_b) + sum(c_b(c_pair))
    ! end
    ! where (s_pair>0)
    !    ionicity = (s_p - s_p(s_pair))/2
    ! end
      d1 = 0; d2 = 0
      do i = 1, n_ab
         if (c_pair(i) <= 0) then
           covalency(i) = 0
         else
           covalency(i) = (c_p(i) - c_p(c_pair(i)))/2
           d1 = d1 + c_a(i) + c_a(c_pair(i))
           d2 = d2 + c_b(i) + c_b(c_pair(i))
         end
      end
      do i = 1, n_ab
         if (s_pair(i) == 0) then
           ionicity(i) = 0
         else if (s_pair(i) < 0) then
           ionicity(i) = 0
         else
           ionicity(i) = (s_p(i) - s_p(s_pair(i)))/2
         end
      end      
      total_i = sum(ionicity) 
      total_c = sum(covalency)
      bond_index = sqrt(total_i**2 + total_c**2)
      bi = bond_index
      pcc = (total_c/bond_index)**2
      pci = (total_i/bond_index)**2
      if (output) &
      .put_roby_gould_data(roby_atom,bi,pcc,pci,d1,d2,cos_eigenvalue,covalency,ionicity,c_p,c_a,c_b,c_pair)
      ionicity.destroy
      covalency.destroy
      C.destroy; theta_c.destroy; cos_eigenvalue.destroy
      S.destroy; theta_s.destroy; sin_eigenvalue.destroy
      c_p.destroy; c_pair.destroy; c_b.destroy
      s_p.destroy; s_pair.destroy; c_a.destroy
   end   

   put_roby_gould_data(roby,bi,pcc,pci,da,db,cos_theta,cov,ion,c_p,c_a,c_b,pair)
   ! Output detailed Roby-Gould bond index information
      DBL :: bi,pcc,pci,da,db
      VEC :: cos_theta,cov,ion,c_p,c_a,c_b
      IVEC :: roby,pair
      STR :: symbol_a,symbol_b
      INT :: i, n_ab, a,b
      .out.flush
      a = roby(1)
      b = roby(2)
      symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
      symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
      .out.text("Gould bond index data:",flush=2)
      .out.show("Atom_a           =",symbol_a)
      .out.show("Atom_b           =",symbol_b)
      .out.show("Total bond_index =",bi)
      .out.show("% Covalency      =",pcc)
      .out.show("% Ionicity       =",pci)
      .out.show("d_a              =",da)
      .out.show("d_b              =",db)
      .out.flush
      .out.dash(int_fields=1,dbl_fields=6)
      .out.put("Theta/dg",int_width=TRUE)
      .out.put("Theta(+) pop")
      .out.put("Theta(-) pop")
      .out.put("Theta(a) pop")
      .out.put("Theta(b) pop")
      .out.put("Covalent Index")
      .out.put("Ionic Index")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=6)
      n_ab = size(pair)
      do i = 1, n_ab
         if (pair(i) <= 0) cycle
         .out.put(nint(180* cos_theta(i).arccos/ PI))
         .out.put(c_p(i))
         .out.put(c_p(pair(i)))
         .out.put(c_a(i)+c_a(pair(i)))
         .out.put(c_b(i)+c_b(pair(i)))
         .out.put(cov(i))
         .out.put(ion(i))
         .out.flush
      end
      .out.dash(int_fields=1,dbl_fields=6)
   end

   make_gould_theta_orbitals(X,roby_atom,theta,eigenvalues)
   ! For a given operator "X" (either cos theta or sin theta) in the concatenated
   ! AO basis of the atoms in "roby_atom", make the Gould "theta" bonding orbitals 
   ! and corresponding "eigenvalues"
      MAT :: X,theta
      IVEC :: roby_atom
      VEC :: eigenvalues
      MAT, PTR :: XX,XV, SS,SI,SH
      INT :: a,b,n_a,n_b, n_ab
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      XX.create(n_ab,n_ab); XV.create(n_ab,n_ab)
      SS.create(n_ab,n_ab); SI.create(n_ab,n_ab); SH.create(n_ab,n_ab)
      .make_roby_overlap_matrix(SS,(/a,b/),(/a,b/))
      SH.to_sqrt(SS)
      SI.to_inverse_of(SH)
      X.back_transform(XX,SH)
      XX.solve_eigenproblem(eigenvalues,XV)
      theta.to_product(SI,XV)
      SH.destroy; SI.destroy; SS.destroy
      XV.destroy; XX.destroy
   end

   roby_project(X,Y,P)
   ! Do: Y = P X P
      MAT :: X,Y,P
      X.change_basis(Y,P)
   end

   roby_overlap_transform(X,Y,row_atom,col_atom)
   ! Do: Y = S(col_atom,row_atom) X S(row_atom,col_atom)
   ! where S(col_atom,row_atom) is the AO subspace section of the full
   ! overlap matrix specified by the basis functions on the atom indices
   ! in "row_atom" and "col_atom".
      MAT :: X,Y
      IVEC, optional :: row_atom, col_atom
      MAT, PTR :: S,SS
      INT :: n_row,n_col
      n_row = .n_bf
      if (present(row_atom)) then
      n_row = .atom(row_atom).no_of_basis_functions
      end
      n_col = .n_bf
      if (present(col_atom)) then
      n_col = .atom(col_atom).no_of_basis_functions
      end
      S.create(.n_bf,.n_bf)
      SS.create(n_row,n_col)
      .get_overlap_matrix(S)
      .AO_subspace_set(SS,S,B_row_atom=row_atom,B_col_atom=col_atom)
      X.change_basis(Y,SS) 
      SS.destroy
      S.destroy
   end

   AO_subspace_set(A,B,A_row_atom,A_col_atom,B_row_atom,B_col_atom)
   ! If either "B_row_atom" or "B_col_atom" is present, then:
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom 
   ! indices in "B_row_atom" and "B_col_atom". If either is missing,
   ! then copy the entire row. (i.e. A(small) = B(big))
   ! If either "A_row_atom" or "A_col_atom" is present, then:
   ! Set the AO subspace blocks of "A" specified by the atom 
   ! indices in "A_row_atom" and "A_col_atom" equal to "B". If either
   ! "A_row_atom" and "A_col_atom" is missing then copy the entire row.
   ! Uncopied blocks are set to zero. (i.e. A(big) = B(small))
      MAT :: A,B
      IVEC, optional :: A_row_atom,A_col_atom
      IVEC, optional :: B_row_atom,B_col_atom
      INT :: n_row_atoms,n_col_atoms, a1,a2, b1,b2 
      INT :: i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j
      if (present(B_row_atom) OR present(B_col_atom)) then
         ENSURE(size(B,1)==.n_bf,"B has wrong shape")
         ENSURE(size(B,2)==.n_bf,"B has wrong shape")
         if (present(B_row_atom) AND present(B_col_atom)) then
            n_row_atoms = size(B_row_atom)
            n_col_atoms = size(B_col_atom)
            a1 = .atom(B_row_atom).no_of_basis_functions
            a2 = .atom(B_col_atom).no_of_basis_functions
            ENSURE(size(A,1)==a1,   "A has wrong shape")
            ENSURE(size(A,2)==a2,   "A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(B_row_atom(i))
               l_i = .last_basis_fn_for_atom( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).no_of_basis_functions
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = .first_basis_fn_for_atom(B_col_atom(j))
                  l_j = .last_basis_fn_for_atom( B_col_atom(j))
                  n_j = .atom(B_col_atom(j)).no_of_basis_functions
                  A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
                  b_j = b_j + n_j
               end 
               b_i = b_i + n_i
            end
         else if (present(B_row_atom)) then
            n_row_atoms = size(B_row_atom)
            a1 = .atom(B_row_atom).no_of_basis_functions
            a2 = .n_bf
            ENSURE(size(A,1)==a1,"A has wrong shape")
            ENSURE(size(A,2)==a2,"A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(B_row_atom(i));
               l_i = .last_basis_fn_for_atom( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).no_of_basis_functions
               A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
               b_i = b_i + n_i
            end
         else if (present(B_col_atom)) then
            n_col_atoms = size(B_col_atom)
            a1 = .n_bf
            a2 = .atom(B_col_atom).no_of_basis_functions
            ENSURE(size(A,1)==a1,"A has wrong shape")
            ENSURE(size(A,2)==a2,"A has wrong shape")
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(B_col_atom(j));
               l_j = .last_basis_fn_for_atom( B_col_atom(j))
               n_j = .atom(B_col_atom(j)).no_of_basis_functions
               A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)
               b_j = b_j + n_j
            end
         end
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      else if (present(A_row_atom) OR present(A_col_atom)) then
         ENSURE(size(A,1)==.n_bf,"A has wrong shape")
         ENSURE(size(A,2)==.n_bf,"A has wrong shape")
         A = ZERO
         if (present(A_row_atom) AND present(A_col_atom)) then
            n_row_atoms = size(A_row_atom)
            n_col_atoms = size(A_col_atom)
            b1 = .atom(A_row_atom).no_of_basis_functions
            b2 = .atom(A_col_atom).no_of_basis_functions
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(A_row_atom(i))
               l_i = .last_basis_fn_for_atom( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).no_of_basis_functions
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = .first_basis_fn_for_atom(A_col_atom(j))
                  l_j = .last_basis_fn_for_atom( A_col_atom(j))
                  n_j = .atom(A_col_atom(j)).no_of_basis_functions
                  A(f_i:l_i,f_j:l_j) = B(b_i+1:b_i+n_i,b_j+1:b_j+n_j) 
                  b_j = b_j + n_j
               end 
               b_i = b_i + n_i
            end
         else if (present(A_row_atom)) then
            n_row_atoms = size(A_row_atom)
            b1 = .atom(A_row_atom).no_of_basis_functions
            b2 = .n_bf
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(A_row_atom(i));
               l_i = .last_basis_fn_for_atom( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).no_of_basis_functions
               A(f_i:l_i,:) = B(b_i+1:b_i+n_i,:)
               b_i = b_i + n_i
            end
         else if (present(A_col_atom)) then
            n_col_atoms = size(A_col_atom)
            b1 = .atom(A_col_atom).no_of_basis_functions
            b2 = .n_bf
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(A_col_atom(j));
               l_j = .last_basis_fn_for_atom( A_col_atom(j))
               n_j = .atom(A_col_atom(j)).no_of_basis_functions
               A(:,f_j:l_j) = B(:,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end
         end
      else
         DIE("must specify A or B row atoms")
      end
   end
!!!
!!!   archive_orbitals( mat1, mat2, a, b)
!!!   ! archives the orbitals created in the previous routine
!!!   MAT, PTR :: mat1, mat2
!!!   OPMAT, PTR :: tmp_mat1, tmp_mat2
!!!   INT :: a, b, j, count
!!!   ARCHIVE :: archive
!!!      tmp_mat1.create(.n_bf, "restricted")
!!!      tmp_mat2.create( .n_bf, "restricted")
!!!      tmp_mat1%restricted.zero; tmp_mat2%restricted.zero
!!!      count = 0
!!!      tmp_mat1%restricted( 1:size(mat1,1), .first(a) : .last(a)) & 
!!!         = mat1(:, 1 : .atom(a)%basis%n_bf)
!!!      tmp_mat2%restricted( 1:size(mat2,1), .first(a) : .last(a)) &
!!!         = mat2(:, 1 : .atom(a)%basis%n_bf)
!!!      count = count + .atom(a)%basis%n_bf
!!!      tmp_mat1%restricted( 1:size(mat1,1), count + 1 : count + .atom(b)%basis%n_bf) &
!!!          = mat1(: , .atom(a)%basis%n_bf + 1 : size(mat1, 2))
!!!      tmp_mat2%restricted(1:size(mat2,1), count + 1 : count + .atom(b)%basis%n_bf) &
!!!          = mat2(:, .atom(a)%basis%n_bf + 1 : size(mat2, 2))
!!!      archive.set( .name, "covalent_orbitals", "restricted")
!!!      archive.write( tmp_mat1)
!!!      archive.set( .name, "ionic_orbitals", "restricted")
!!!      archive.write( tmp_mat2)
!!!      tmp_mat1.destroy; tmp_mat2.destroy   
!!!    end  
!!!
!!!   plot_theta_orbitals( orb_type, orb_no)
!!!   ARCHIVE :: archive
!!!   STR(*) :: orb_type
!!!   OPMAT, PTR :: temp_NOs
!!!   INT :: orb_no
!!!      .grid.put( .out)
!!!      print *, orb_type
!!!      archive.set( .name, orb_type.trim, "restricted")
!!!      temp_NOs.create( .n_bf, "restricted")
!!!      temp_NOs = .natural_orbitals
!!!      archive.read( .natural_orbitals)
!!!      archive.close
!!!      .make_orbital_density_grid( orb_no, make_NOs=FALSE)
!!!      .natural_orbitals = temp_NOs; temp_NOs.destroy
!!!   end
!!!
!!!   plot_subspace_density( S)
!!!   ! plots the density of the subspace given in the mol.in file
!!!   MAT, PTR :: S   ! The overlap matrix
!!!   MAT, PTR :: sub_NOs, saved_NOs, sub_density, saved_rho
!!!   VEC, PTR :: proj_grid
!!!   IVEC, PTR :: comb
!!!   INT :: i
!!!   DBL ::pop
!!!   ARCHIVE :: archive
!!!      comb.create( .in%buffer%n_items - 1)
!!!      print *, 1
!!!      do i = 1, .in%buffer%n_items - 1
!!!         comb(i) = .in%buffer.get_item.to_int
!!!      end
!!!      print *, comb
!!!      sub_density.create( .n_bf, .n_bf)
!!!      sub_NOs.create( .n_bf, .n_bf)
!!!      pop = .roby_population( comb, S, rho=sub_density, proj_NOs=sub_NOs)
!!!      saved_NOs.create( .n_bf, .n_bf)
!!!      saved_rho.create( .n_bf, .n_bf)
!!!      saved_NOs = .natural_orbitals%restricted
!!!      saved_rho = .density_matrix%restricted
!!!      .natural_orbitals%restricted = sub_NOs
!!!      .density_matrix%restricted = sub_density
!!!      proj_grid.create( .grid%n_pt)
!!!      print *, 2
!!!      .make_density_grid(proj_grid, make_NOs=FALSE)
!!!      print *, 3
!!!      archive.set(.name,"proj_density_grid,gnuplot",format="ascii")
!!!      archive.write_gnuplot(proj_grid, .grid%n_x, .grid%n_y, .grid%n_z)
!!!      .natural_orbitals%restricted = saved_NOs
!!!      .density_matrix%restricted = saved_rho
!!!      saved_rho.destroy; saved_NOs.destroy
!!!      comb.destroy; sub_NOs.destroy; sub_density.destroy
!!!   end
!!!   
!!!   plot_density_difference( S)
!!!   ! plots the difference density map for the molecule
!!!   ARCHIVE  :: archive
!!!   MAT, PTR :: S
!!!   MAT, PTR :: sub_NOs, saved_NOs, sub_density, saved_rho
!!!   VEC, PTR :: density_grid, proj_grid, grid
!!!   IVEC, PTR :: comb
!!!   INT :: i
!!!   DBL :: pop
!!!      density_grid.create( .grid%n_pt)
!!!      .make_density_grid(density_grid)
!!!      comb.create( .n_atom)
!!!      do i = 1, .n_atom
!!!       comb(i) = i
!!!      end
!!!      sub_NOs.create( .n_bf, .n_bf)
!!!      sub_density.create( .n_bf, .n_bf)
!!!      pop = .roby_population( comb, S, rho=sub_density, proj_NOs=sub_NOs)
!!!      comb.destroy
!!!      saved_NOs.create( .n_bf, .n_bf)
!!!      saved_rho.create( .n_bf, .n_bf)
!!!      saved_NOs = .natural_orbitals%restricted
!!!      saved_rho = .density_matrix%restricted
!!!      .natural_orbitals%restricted = sub_NOs
!!!      .density_matrix%restricted = sub_density
!!!      proj_grid.create( .grid%n_pt)
!!!      .make_density_grid(proj_grid, make_NOs=FALSE)
!!!      grid.create( .grid%n_pt)
!!!      grid = density_grid - proj_grid
!!!      archive.set(.name,"diff_proj_density_grid,gnuplot",format="ascii")
!!!      archive.write_gnuplot(grid, .grid%n_x, .grid%n_y, .grid%n_z)
!!!      .natural_orbitals%restricted = saved_NOs
!!!      .density_matrix%restricted = saved_rho
!!!      saved_NOs.destroy; saved_rho.destroy
!!!      grid.destroy; proj_grid.destroy; density_grid.destroy
!!!   end      
!!!         
!!!
!!!
!!!  
!!!   read_atoms_to_bond( a, b)
!!!   ! reads in from the buffer the two atoms for the bond_index routine
!!!      INT :: a, b
!!!      ENSURE(.in%buffer%n_items==3, "Two atoms required for bond index calculation.")
!!!      a = .in%buffer.get_item.to_int      
!!!      b = .in%buffer.get_item.to_int
!!!   end
!!!
!!!   read_shared_energy_atoms( S)
!!!   ! runs the shared_energy calculations
!!!   ! after reading in the atom list
!!!      DBL :: shared
!!!      IVEC, PTR :: sel
!!!      MAT, PTR :: S
!!!      STRVEC, PTR :: comb_list
!!!      VEC, PTR :: energy 
!!!      INT :: i, total_combs
!!!      sel.create( .in%buffer%n_items - 1)
!!!      do i = 1, .in%buffer%n_items
!!!         sel(i) = .in%buffer.get_item.to_int
!!!      end
!!!      do i = 1, size(sel)
!!!         total_combs = total_combs + size(sel).choose(i)   ! gets number of combinations
!!!      end
!!!      energy.create( total_combs)
!!!      comb_list.create( total_combs)
!!!      shared = .get_shared_energy( sel, energy, comb_list, S)
!!!      .out.dash(dbl_fields = 3)
!!!      .out.text("Shared Energy analysis")
!!!      .out.flush
!!!      .out.dash(dbl_fields = 3)
!!!      do i = 1, size( sel)
!!!         .out.put( trim( .atom(sel(i))%label), int_width=TRUE, flush=1)
!!!      end
!!!      .out.flush
!!!      .out.put(shared)
!!!      .out.flush
!!!      .out.dash(dbl_fields = 3)
!!!      sel.destroy
!!!      comb_list.destroy
!!!      energy.destroy
!!!   end

!!    dylans_population_analysis
!!    ! Analyse the SCF orbitals into dylans populations
!!       INT :: n_k
!!       MAT, PTR  :: p
!!       VEC, PTR  :: n1
!!       MAT, PTR  :: n2
!!       MAT3, PTR :: n3
!!       TIME :: timer
!!       ENSURE( .density_matrix.created,"need a density matrix")
!!       .out.flush
!!       .out.text("Starting dylans_population_analysis ...")
!!       timer.start
!!       .density_matrix.convert_to("unrestricted",factor=HALF)
!!       .density_matrix%restricted.destroy
!!       .make_natural_orbitals
!!       .atom.make_atom_kind_list( .atom_kind)
!!       .atom.make_atom_kind_map( .atom_kind_map)
!!       n_k = size( .atom_kind)
!!       p.create(.n_atom+1,.n_atom+1)
!!       n1.create(.n_atom)
!!       n2.create(.n_atom,.n_atom)
!!       n3.create(.n_atom,.n_atom,.n_atom)
!!       .make_ANSO_data
!!       .make_dylans_populations(p,n1)
!!       .put_dylans_populations(p,n1)
!! !      .make_dylans_populations(p,n1,n2,n3)
!! !      .put_dylans_populations(p,n1,n2,n3)
!!       n3.destroy; n2.destroy; n1.destroy; p.destroy
!!       .out.put( timer.time_taken("dylans_population_analysis"))
!!    end
!! 
!!    make_dylans_populations(p,n1)
!! !   make_dylans_populations(p,n1,n2,n3,atom_kind_map,NOa,NOb,occa,occb)
!!    ! Make dylans populations, for closed shells only
!!       MAT :: p
!!       VEC  :: n1
!! !      MAT  :: n2
!! !      MAT3 :: n3
!!       INT :: k,a,fa,la,n,na
!!       DBL :: pop
!!       MAT, PTR :: S,D,W,X
!! !     MAT, PTR :: Y
!! !     INT :: b,c,fb,lb,fc,lc,l,m,mm,nb,nc,nabc,nk,nl,nm,nkl,nklm
!! !     DBL :: bot
!! !     VEC, PTR :: lambda
!!       .atom.make_atom_basis_fn_limits( .first, .last)
!!       S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
!!       D.create(.n_bf,.n_bf)
!!       D.from_diagonal(sqrt(.occupation%alpha))
!!       D.back_transform(.natural_orbitals%alpha)
!!       p = ZERO
!!       n = .n_atom+1
!!       p(n,n) = .n_e
!!       n1 = ZERO
!!       do a = 1,.n_atom
!!          k = .atom_kind_map(a)
!!          .out.show("a=",a)
!!          .out.show("k=",k)
!!          fa = .first(a); la = .last(a); na = la-fa+1
!!          X.create(na,na)
!!          X.from_diagonal(sqrt( .atom(a)%occupations%alpha))
!!          X.back_transform( .atom(a)%natural_orbitals%alpha)
!!          W.create(.n_bf,.n_bf)
!!          X.change_basis(W,S(fa:la,:))
!!          pop = W.trace_product_with(D)
!!          X.from_diagonal(sqrt( .atom(a)%occupations%beta))
!!          X.back_transform( .atom(a)%natural_orbitals%beta)
!!          X.change_basis(W,S(fa:la,:))
!!          pop = pop + W.trace_product_with(D)
!!          p(a,a) = .atom(a)%atomic_number
!!          p(a,n) = pop
!!          p(n,a) = pop
!!          n1(a) = pop*pop/p(a,a)
!!          W.destroy
!!          X.destroy
!!       end
!! !     n2 = ZERO
!! !     do k = 1,n_k
!! !     do kk = 1,size(atom_kind(k)%vec) 
!! !     do l = 1,n_k
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        if (a<=b) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !        fa = first(a); la = last(a); na = la-fa+1
!! !        fb = first(b); lb = last(b); nb = lb-fb+1
!! !        nk = size(NO(k)%mat,2)
!! !        nl = size(NO(l)%mat,2)
!! !        nab = na + nb
!! !        nkl = nk + nl
!! !        lambda.create(nkl)
!! !        lambda(   1:nk ) = sqrt(occ(k)%vec)
!! !        lambda(nk+1:nkl) = sqrt(occ(l)%vec)
!! !        W.create(nab,nkl)
!! !        W = ZERO
!! !        W(   1:na ,   1:nk ) = NO(k)%mat
!! !        W(na+1:nab,nk+1:nkl) = NO(l)%mat
!! !        Y.create(nab,nab)
!! !        Y(   1:na ,   1:na ) = S(fa:la,fa:la)
!! !        Y(na+1:nab,na+1:nab) = S(fb:lb,fb:lb)
!! !        Y(na+1:nab,   1:na ) = S(fb:lb,fa:la)
!! !        Y(   1:na ,na+1:nab) = S(fa:la,fb:lb)
!! !        X.create(nkl,nkl)
!! !        Y.change_basis(X,W)
!! !        Y.destroy
!! !        Y.create(nkl,nkl)
!! !        Y.to_inverse_of(X)  ! Y = S^-1
!! !        X.destroy
!! !        X.create(nkl,nkl)
!! !        X.to_product_with_diagonal(lambda,Y)
!! !        Y.destroy
!! !        Y.create(nab,nab)
!! !        X.back_transform(Y,W)
!! !        X.destroy
!! !        W.destroy
!! !        W.create(.n_bf,.n_bf)
!! !        X.create(nab,.n_bf)
!! !        X(   1:na ,:) = S(fa:la,:)
!! !        X(na+1:nab,:) = S(fb:lb,:)
!! !        Y.change_basis(W,X)
!! !        W = transpose(W)
!! !        pop = W.trace_product_with(.density_matrix%restricted)
!! !        bot = W.trace_product_with(X)
!! !        pop = pop*pop/bot
!! !        n2(a,b) = pop
!! !        n2(b,a) = pop
!! !        X.destroy
!! !        W.destroy
!! !        Y.destroy
!! !        lambda.destroy
!! !     end
!! !     end
!! !     end
!! !     end
!! !     n3 = ZERO
!! !     do k = 1,n_k
!! !     do kk = 1,size(atom_kind(k)%vec) 
!! !     do l = 1,n_k
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !     do m = 1,n_k
!! !     do mm = 1,size(atom_kind(m)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        c = atom_kind(m)%vec(mm)
!! !        if (a<=b OR b<=c) cycle
!! !      ! if (a==b OR b==c OR c==a) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !      ! if ( .atom.not_bonded(b,c)) cycle
!! !        fa = first(a); la = last(a); na = la-fa+1
!! !        fb = first(b); lb = last(b); nb = lb-fb+1
!! !        fc = first(c); lc = last(c); nc = lc-fc+1
!! !        nk = size(NO(k)%mat,2)
!! !        nl = size(NO(l)%mat,2)
!! !        nm = size(NO(m)%mat,2)
!! !        nabc = na + nb + nc
!! !        nklm = nk + nl + nm
!! !        lambda.create(nkl)
!! !        lambda(      1:nk   ) = sqrt(occ(k)%vec)
!! !        lambda(nk   +1:nk+nl) = sqrt(occ(l)%vec)
!! !        lambda(nk+nl+1:nklm ) = sqrt(occ(m)%vec)
!! !        W.create(nabc,nklm)
!! !        W = ZERO
!! !        W(      1:na   ,      1:nk   ) = NO(k)%mat
!! !        W(na   +1:na+nb,nk   +1:nk+nl) = NO(l)%mat
!! !        W(na+nb+1:nabc ,nk+nl+1:nklm ) = NO(m)%mat
!! !        Y.create(nabc,nabc)
!! !        Y(      1:na   ,      1:na   ) = S(fa:la,fa:la)
!! !        Y(na   +1:na+nb,na   +1:na+nb) = S(fb:lb,fb:lb)
!! !        Y(na+nb+1:nabc ,na+nb+1:nabc ) = S(fc:lc,fc:lc)
!! !        Y(na+1:nab,   1:na ) = S(fb:lb,fa:la)
!! !        Y(   1:na ,na+1:nab) = S(fa:la,fb:lb)
!! !        Y(na+nb+1:nabc,      1:na  ) = S(fc:lc,fa:la)
!! !        Y(      1:na  ,na+nb+1:nabc) = S(fa:la,fc:lc)
!! !        Y(na+nb+1:nabc ,na   +1:na+nb) = S(fc:lc,fb:lb)
!! !        Y(na   +1:na+nb,na+nb+1:nabc ) = S(fb:lb,fc:lc)
!! !        X.create(nklm,nklm)
!! !        Y.change_basis(X,W)
!! !        Y.destroy
!! !        Y.create(nklm,nklm)
!! !        Y.to_inverse_of(X)  ! Y = S^-1
!! !        X.destroy
!! !        X.create(nklm,nklm)
!! !        X.to_product_with_diagonal(lambda,Y)
!! !        Y.destroy
!! !        Y.create(nabc,nabc)
!! !        X.back_transform(Y,W)
!! !        X.destroy
!! !        W.destroy
!! !        W.create(.n_bf,.n_bf)
!! !        X.create(nabc,.n_bf)
!! !        X(      1:na   ,:) = S(fa:la,:)
!! !        X(na   +1:na+nb,:) = S(fb:lb,:)
!! !        X(na+nb+1:nabc ,:) = S(fc:lc,:)
!! !        Y.change_basis(W,X)
!! !        W = transpose(W)
!! !        pop = W.trace_product_with(.density_matrix%restricted)
!! !        bot = W.trace_product_with(X)
!! !        pop = pop*pop/bot
!! !        n3(a,b,c) = pop
!! !        n3(a,c,b) = pop
!! !        n3(b,a,c) = pop
!! !        n3(b,c,a) = pop
!! !        n3(c,a,b) = pop
!! !        n3(c,b,a) = pop
!! !        X.destroy
!! !        W.destroy
!! !        Y.destroy
!! !        lambda.destroy
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!!       D.destroy
!!       S.destroy
!!    end
!! 
!!    put_dylans_populations(p,n1)
!! !   put_dylans_populations(p,n1,n2,n3,atom_kind)
!!    ! Put .out the roby populations
!!       MAT :: p
!!       VEC  :: n1
!! !      MAT  :: n2
!! !      MAT3 :: n3
!!       INT :: k,kk,a,b
!!       STR :: symbol_a,symbol_b
!! !     INT :: l,m,ll,mm,c
!! !     STR :: symbol_c
!!       .out.flush
!!       .out.text("Dylan's population analysis",flush=2)
!!       .out.text("Pair overlaps (last atom is the molecule itself):",flush=2)
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       .out.put("Atom_a",int_width=TRUE)
!!       .out.put("Atom_b",int_width=TRUE)
!!       .out.put("p_ab",flush=1)
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       do a = 1,.n_atom+1
!!       do b = 1,a-1
!!        ! if ( .atom.not_bonded(a,b)) cycle
!!          if (a==.n_atom+1) then; symbol_a = "M"
!!          else; symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!!          end
!!          symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!!          .out.put(symbol_a,int_width=TRUE)
!!          .out.put(symbol_b,int_width=TRUE)
!!          .out.put(p(a,b))
!!          .out.flush
!!       end
!!       end
!!       .out.dash(int_fields=2,dbl_fields=1)
!!       .out.text("Dylan's atomic populations",flush=2)
!!       .out.dash(int_fields=1,dbl_fields=1)
!!       .out.put("Atom",int_width=TRUE)
!!       .out.put("Population",flush=1)
!!       .out.dash(int_fields=1,dbl_fields=1)
!!       do k = 1,size( .atom_kind)
!!       do kk = 1,size( .atom_kind(k)%vec)
!!          a = .atom_kind(k)%vec(kk)
!!          symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!!          .out.put(symbol_a,int_width=TRUE)
!!          .out.put(n1(a))
!!          .out.flush
!!       end
!!       end
!!       .out.dash(int_fields=1,dbl_fields=1)
!! !     .out.flush
!! !     .out.text("Pair populations:",flush=2)
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     .out.put("Atom_a",int_width=TRUE)
!! !     .out.put("Atom_b",int_width=TRUE)
!! !     .out.put("n_ab")
!! !     .out.put("s_ab",flush=1)
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     do k = 1,size(atom_kind)
!! !     do kk = 1,size(atom_kind(k)%vec)
!! !     do l = 1,size(atom_kind)
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        if (a==b) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !        symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!! !        symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!! !        .out.put(symbol_a,int_width=TRUE)
!! !        .out.put(symbol_b,int_width=TRUE)
!! !        .out.put(n2(a,b))
!! !        .out.put(n1(a)+n1(b)-n2(a,b))
!! !        .out.flush
!! !     end
!! !     end
!! !     end
!! !     end
!! !     .out.dash(int_fields=2,dbl_fields=2)
!! !     .out.flush
!! !     .out.text("Triple populations:",flush=2)
!! !     .out.dash(int_fields=3,dbl_fields=2)
!! !     .out.put("Atom_a",int_width=TRUE)
!! !     .out.put("Atom_b",int_width=TRUE)
!! !     .out.put("Atom_c",int_width=TRUE)
!! !     .out.put("n_abc")
!! !     .out.put("s_abc",flush=1)
!! !     .out.dash(int_fields=3,dbl_fields=2)
!! !     do k = 1,size(atom_kind)
!! !     do kk = 1,size(atom_kind(k)%vec)
!! !     do l = 1,size(atom_kind)
!! !     do ll = 1,size(atom_kind(l)%vec) 
!! !     do m = 1,size(atom_kind)
!! !     do mm = 1,size(atom_kind(m)%vec) 
!! !        a = atom_kind(k)%vec(kk)
!! !        b = atom_kind(l)%vec(ll)
!! !        c = atom_kind(m)%vec(mm)
!! !        if (a==b OR b==c OR c==a) cycle
!! !      ! if ( .atom.not_bonded(a,b)) cycle
!! !      ! if ( .atom.not_bonded(b,c)) cycle
!! !        symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
!! !        symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
!! !        symbol_c = .atom(c).chemical_symbol.trim // " (" // c.to_str.trim // ")"
!! !        .out.put(symbol_a,int_width=TRUE)
!! !        .out.put(symbol_b,int_width=TRUE)
!! !        .out.put(symbol_c,int_width=TRUE)
!! !        .out.put(n3(a,b,c))
!! !        .out.put(n1(a)+n1(b)+n1(c)-n2(a,b)-n2(b,c)-n2(c,a)+n3(a,b,c))
!! !        .out.flush
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     end
!! !     .out.dash(int_fields=3,dbl_fields=2)
!!    end

end 

