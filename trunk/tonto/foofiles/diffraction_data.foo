!-------------------------------------------------------------------------------
!
! DIFFRACTION_DATA: Diffraction data structure for crystals
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module DIFFRACTION_DATA

   implicit none

   saved_self :: DIFFRACTION_DATA*, private

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  **************************
!  Create and destroy methods
!  **************************

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the diffraction data object
      nullify(.reflections)
      nullify(.scale_factors)
      nullify(.near_0_eigenvalues)
      nullify(.near_0_eigenvectors)
      nullify(.delta_p)
      nullify(.covariance_matrix)
      nullify(.correlation_matrix)
      nullify(.fragment_covariance_matrix)
      nullify(.refine_atom_parameters)
   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information
      .destroy_reflection_data
      .near_0_eigenvalues.destroy
      .near_0_eigenvectors.destroy
      .delta_p.destroy
      .covariance_matrix.destroy
      .correlation_matrix.destroy
      .fragment_covariance_matrix.destroy
      .refine_atom_parameters.destroy
   end

   destroy_reflection_data ::: leaky
   ! Erase all reflection data
      if (.reflection_data_exists) then
       .scale_factor = ONE
       .exp_scale_factor = ONE
       .extinction_factor = ZERO
       .reflections.destroy
       .scale_factors.destroy
      end
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(diffraction_data) ::: leaky
   ! Set self to be crystal.
      diffraction_data :: DIFFRACTION_DATA, IN
      self = diffraction_data
      .nullify_ptr_part
      if (diffraction_data.reflections.created) &
        .reflections.create_copy(diffraction_data.reflections)
      if (diffraction_data.scale_factors.created) &
        .scale_factors.create_copy(diffraction_data.scale_factors)
      if (diffraction_data.near_0_eigenvalues.created) &
        .near_0_eigenvalues.create_copy(diffraction_data.near_0_eigenvalues)
      if (diffraction_data.near_0_eigenvectors.created) &
        .near_0_eigenvectors.create_copy(diffraction_data.near_0_eigenvectors)
      if (diffraction_data.delta_p.created) &
        .delta_p.create_copy(diffraction_data.delta_p)
      if (diffraction_data.covariance_matrix.created) &
        .covariance_matrix.create_copy(diffraction_data.covariance_matrix)
      if (diffraction_data.correlation_matrix.created) &
        .correlation_matrix.create_copy(diffraction_data.correlation_matrix)
      if (diffraction_data.fragment_covariance_matrix.created) &
        .fragment_covariance_matrix.create_copy(diffraction_data.fragment_covariance_matrix)
      if (diffraction_data.refine_atom_parameters.created) &
        .refine_atom_parameters.create_copy(diffraction_data.refine_atom_parameters)
   end

   set_defaults ::: leaky
   ! Set up a default diffraction_data object
      .destroy_reflection_data
      .synthesize_sigma_I     = DIFFRACTION_DATA_SYNTHESISE_SIGMA_I
      .optimise_scale         = DIFFRACTION_DATA_OPTIMISE_SCALE
      .optimise_extinction    = DIFFRACTION_DATA_OPTIMISE_EXTINCTION
      .correct_dispersion     = DIFFRACTION_DATA_CORRECT_DISPERSION
      .scale_factor           = DIFFRACTION_DATA_SCALE_FACTOR
      .exp_scale_factor       = DIFFRACTION_DATA_EXP_SCALE_FACTOR
      .extinction_factor      = DIFFRACTION_DATA_EXTINCTION_FACTOR
      .SF_mixing_parameter    = ZERO
      .wavelength             = DIFFRACTION_DATA_WAVELENGTH
      .data_kind              = DIFFRACTION_DATA_DATA_KIND
      .thermal_smearing_model = DIFFRACTION_DATA_THERMAL_SMEARING_MODEL
      .partition_model        = DIFFRACTION_DATA_PARTITION_MODEL
      .F_exp_min              = DIFFRACTION_DATA_F_EXP_MIN
      .F_sigma_min            = DIFFRACTION_DATA_F_SIGMA_MIN
      .F_sigma_max            = DIFFRACTION_DATA_F_SIGMA_MAX
      .F_sigma_cutoff         = DIFFRACTION_DATA_F_SIGMA_CUTOFF
      .temperature            = ZERO
      .NKA_T_sequence_no      = 0

      .refine_structure         = FALSE
      .refine_positions_only    = FALSE
      .refine_ADPs_only         = FALSE
      .refine_H_ADPs            = TRUE
      .refine_H_U_iso           = FALSE
      .iteration                = ZERO
      .chi2                     = ZERO
      .chi2_old                 = ZERO
      .max_iterations           = DIFFRACTION_DATA_MAX_ITER
      .min_iterations           = DIFFRACTION_DATA_MIN_ITER  
      .tol_shift_convergence    = DIFFRACTION_DATA_TOL_SHIFT_CONV
      .max_allowed_shift        = DIFFRACTION_DATA_MAX_SHIFT
      .tol_0                    = DIFFRACTION_DATA_TOL_0
      .n_0                      = 0
      .tol_near_0               = DIFFRACTION_DATA_TOL_NEAR_0
      .n_near_0                 = 0
      .min_correlation          = DIFFRACTION_DATA_MIN_CORRELATION

   end

   update(unit_cell,spacegroup)
   ! Update the crystal information after setting values. If the
   ! "unit_cell" is provided, then that is used to define the reflection
   ! .theta values.
      unit_cell :: UNIT_CELL, optional
      spacegroup :: SPACEGROUP, optional
 
      if (.reflections.destroyed) return
 
      if (.reflections.have_F_exp) then
         .reflections.scale_F_exp(.exp_scale_factor)
      else
         .optimise_scale = FALSE
         .optimise_extinction = FALSE
      end

      if (.reflections.have_F_sigma) then
         .reflections.scale_F_sigma(.exp_scale_factor)
      else
         .optimise_scale = FALSE
         .optimise_extinction = FALSE
      end

      .exp_scale_factor = ONE

      if (present(unit_cell))  .set_theta_angles(unit_cell.reciprocal_matrix)
      if (present(spacegroup)) .set_equivalence_factors(spacegroup)

   end

   set_equivalence_factors(spacegroup) 
   ! Set the equivalence factors, the number of distinct reflections
   ! which are symmetry equivalent to a particular (hkl) triple, for all
   ! the reflections.
      spacegroup :: SPACEGROUP 
   ENSURE(.reflections.created,"no reflection data")
      hkl,new :: VEC{INT}(3)
      n,s,u,n_refl :: INT
      n_refl = .reflections.n_refl
      do n = 1,n_refl
         hkl = .reflections.indices(n)
         u = 1
         do s = 2,spacegroup.n_seitz
            new = matmul(hkl,spacegroup.seitz(1:3,1:3,s))
            if (hkl(1)/=new(1) OR hkl(2)/=new(2) OR hkl(3)/=new(3)) u = u + 1
         end
         .reflections(n).equivalence_factor = u
      end
   end

   set_theta_angles(reciprocal_matrix)
   ! This routine is called after the reflections are read in, in order to set
   ! all the .theta values, which are used later all over the place ...
      reciprocal_matrix :: MAT{REAL}(3,3)

      hkl :: VEC{INT}(3)
      kx,ky,kz,sin_theta :: REAL
      n :: INT

      do n = 1,.reflections.n_refl

        hkl = .reflections.indices(n)

        kx = dot_product(reciprocal_matrix(1,:),hkl(:))
        ky = dot_product(reciprocal_matrix(2,:),hkl(:))
        kz = dot_product(reciprocal_matrix(3,:),hkl(:))

        sin_theta = HALF*sqrt(kx*kx+ky*ky+kz*kz)*.wavelength
        .reflections(n).theta = asin(sin_theta)

      end
   end

!  ************
!  Read methods
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: PTR
      keyword :: STR
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
        case ("}                           ")  ! exit read_loop
        case ("correct_dispersion=         "); .read_correct_dispersion
        case ("convergence_tolerance=      "); .read_convergence_tolerance
        case ("debug_off                   "); .read_debug_off
        case ("debug_on                    "); .read_debug_on
        case ("destroy_reflection_data     "); .destroy_reflection_data
        case ("display_correlation_matrix= "); .read_display_corr_matrix
        case ("display_near_0_eigenvectors="); .read_display_near_0_evecs
        case ("erase_reflection_data       "); .destroy_reflection_data
        case ("exp_scale_factor=           "); .read_exp_scale_factor
        case ("f_exp_min=                  "); .read_f_exp_min
        case ("f_sigma_cutoff=             "); .read_f_sigma_cutoff
        case ("f_sigma_min=                "); .read_f_sigma_min
        case ("f_sigma_max=                "); .read_f_sigma_max
        case ("junk=                       "); DIFFRACTION_DATA::read_junk
        case ("kind=                       "); .read_data_kind
        case ("make_f_predicted            "); .make_F_predicted
        case ("max_allowed_shift=          "); .read_max_allowed_shift
        case ("max_iterations=             "); .read_max_iterations
        case ("min_iterations=             "); .read_min_iterations
        case ("nka_t_sequence_no=          "); .read_NKA_T_seq_no
        case ("optimise_extinction=        "); .read_optimise_extinction
        case ("optimize_extinction=        "); .read_optimise_extinction
        case ("optimise_scale_factor=      "); .read_optimise_scale
        case ("optimize_scale_factor=      "); .read_optimise_scale
        case ("optimise_scale_factors=     "); .read_optimise_scale
        case ("optimize_scale_factors=     "); .read_optimise_scale
        case ("partition_model=            "); .read_partition_model
        case ("refine_adps_only=           "); .read_refine_ADPs_only
        case ("refine_h_adps=              "); .read_refine_H_ADPs
        case ("refine_h_u_iso=             "); .read_refine_H_U_iso
        case ("refine_positions_only=      "); .read_refine_positions_only
        case ("reflection_data=            "); .read_reflection_data
        case ("sf_mixing_parameter=        "); .read_SF_mixing_parameter
        case ("synthesize_sigma_i=         "); .read_synthesize_sigma_I
        case ("thermal_smearing_model=     "); .read_thermal_smearing_model
        case ("temperature=                "); .read_temperature
        case ("tolerance_0=                "); .read_tol_0
        case ("tolerance_near_0=           "); .read_tol_near_0
        case ("tolerance_shift_convergence="); .read_tol_shift_convergence
        case ("wavelength=                 "); .read_wavelength
        case ("prune_bad_reflections       "); .prune_bad_reflections
        case ("prune_bad_sigmas            "); .prune_bad_sigmas
        case ("prune_high_angle_reflections"); .prune_high_angle_reflections
        case ("prune_low_angle_reflections "); .prune_low_angle_reflections
        case ("prune_weak_reflections      "); .prune_weak_reflections
        case ("put_debug_list              "); .put_debug_list
        case ("zero_negative_f_exp         "); .zero_negative_F_exp       
        case ("put                         "); .put
        case ("put_sin_theta_on_lambda     "); .put_sin_theta_on_lambda
        case ("redirect                    "); .redirect
        case ("revert                      "); .revert
        case ("units=                      "); DIFFRACTION_DATA::read_units
        case default;                       UNKNOWN(word)
      end
   end

   redirect ::: leaky, get_from(OBJECT)
   ! Redirect input
   end

   revert ::: leaky, get_from(OBJECT)
   ! Revert back to previous stdin file
   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), selfless, private
   ! Read in a junk string, useful for ignoring a field
   end

   read_data_kind
   ! Read the data kind of crystal experiment
      stdin.read(.data_kind)
      .data_kind.to_lower_case
      select case (.data_kind)
         case("x-ray")
         case("pnd  ")
         case default; UNKNOWN(.data_kind)
      end
   end

   read_f_exp_min ::: private
   ! Read the minimum acceptable value for F_exp
      stdin.read(.F_exp_min)
      ENSURE(.F_exp_min>=ZERO,"must be positive")
   end

   read_f_sigma_min ::: private
   ! Read the minimum acceptable value for F_sigma
      stdin.read(.F_sigma_min)
      ENSURE(.F_sigma_min>ZERO,"must be positive")
   end

   read_f_sigma_max ::: private
   ! Read the maximum acceptable value for F_sigma
      stdin.read(.F_sigma_max)
      ENSURE(.F_sigma_max>ZERO,"must be positive")
   end

   read_f_sigma_cutoff ::: private
   ! Read the maximum acceptable value for F_cutoff
      stdin.read(.F_sigma_cutoff)
      ENSURE(.F_sigma_cutoff>ZERO,"cutoff must be positive")
   end


   read_exp_scale_factor ::: private
   ! Read the structure factor multiplier
      stdin.read(.exp_scale_factor)
   end

   read_wavelength ::: private
   ! Read the experimental wavelength
      stdin.read(.wavelength)
   end

   read_optimise_scale ::: private
   ! Read the switch whether to use and overall scale factor to minimise
   ! the chi2 statistic when calculating the structure factors.
   ! NOTE: this is not the same at the overall .scale_factor which is applied
   ! to the experimental structure factors.
      stdin.read(.optimise_scale)
   end

   read_SF_mixing_parameter ::: private
   ! Read the SF mixining parameter which inlcudes some percentage of
   ! the experimental structure factors into the predicted structure
   ! factors. This may help convergence in constrained HF problems.
      stdin.read(.SF_mixing_parameter)
   end

   read_synthesize_sigma_I ::: private
   ! Read the switch whether to artificially create sigma(I) errors when
   ! evaluating the chi2 statistics based on intensities. Refer to routine
   ! .I_sigma
      stdin.read(.synthesize_sigma_I)
   end

   read_optimise_extinction ::: private
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.optimise_extinction)
   end

   read_correct_dispersion ::: private
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model ::: private
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      select case (.thermal_smearing_model)
         case("         ")
         case("none     ")
         case("coppens  ")
         case("hirshfeld")
         case("stewart  ")
         case("tanaka   ")
         case default;    UNKNOWN(.thermal_smearing_model)
      end
   end

   read_partition_model ::: private
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
      .partition_model.to_lower_case
      select case(.partition_model)
         case("        ")
         case("none    ")
         case("mulliken")
         case("gaussian")
         case default;    UNKNOWN(.partition_model)
      end
   end

   prune_high_angle_reflections ::: leaky
   ! This routine eliminates all the reflections which have sin(theta)/lambda
   ! greater than "stl".
      self :: PTR
   DIE_IF(NOT .reflections.created,"no reflection data")
      reflections :: VEC{REFLECTION}*
      list :: VEC{INT}*
      n,i :: INT
      stl :: REAL
      stdin.read(stl)
      n = 0
      do i = 1,.reflections.n_refl
        if (.sin_theta_on_lambda(i)>stl) cycle
        n = n + 1
      end
      DIE_IF(n==0,"There are no elements greater than "//stl.to_str.trim)
      list.create(n)
      n = 0
      do i = 1,.reflections.n_refl
        if (.sin_theta_on_lambda(i)>stl) cycle
        n = n + 1
        list(n) = i
      end
      reflections => .reflections
      .reflections.create_copy(reflections(list))
      reflections.destroy
      list.destroy
   end

   prune_low_angle_reflections ::: leaky
   ! This routine eliminates all the reflections which have sin(theta)/lambda
   ! less than "stl".
      self :: PTR
   DIE_IF(NOT .reflections.created,"no reflection data")
      reflections :: VEC{REFLECTION}*
      list :: VEC{INT}*
      n,i :: INT
      stl :: REAL
      stdin.read(stl)
      n = 0
      do i = 1,.reflections.n_refl
        if (.sin_theta_on_lambda(i)<stl) cycle
        n = n + 1
      end
      DIE_IF(n==0,"There are no elements lesthan "//stl.to_str.trim)
      list.create(n)
      n = 0
      do i = 1,.reflections.n_refl
        if (.sin_theta_on_lambda(i)<stl) cycle
        n = n + 1
        list(n) = i
      end
      reflections => .reflections
      .reflections.create_copy(reflections(list))
      reflections.destroy
      list.destroy
   end

   prune_bad_reflections ::: leaky
   ! This routine eliminates all the reflections which have a F_z
   ! value greater than "val" read from input.
      self :: PTR
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_exp,"no experimental data")
   DIE_IF(NOT .reflections.have_F_calc,"no calculated data")
   DIE_IF(NOT .reflections.have_F_pred,"no predicted data")
      reflections :: VEC{REFLECTION}*
      list :: VEC{INT}*
      n,i :: INT
      val :: REAL
      stdin.read(val)
      n = 0
      do i = 1,.reflections.n_refl
        if (abs(.reflections(i).F_z)>val) cycle
        n = n + 1
      end
      DIE_IF(n==0,"There are no elements less than "//val.to_str.trim)
      list.create(n)
      n = 0
      do i = 1,.reflections.n_refl
        if (abs(.reflections(i).F_z)>val) cycle
        n = n + 1
        list(n) = i
      end
      reflections => .reflections
      .reflections.create(n)
      .reflections.copy(reflections(list))
      reflections.destroy
      list.destroy
   end

   prune_bad_sigmas ::: leaky
   ! This routine will prune away all reflections with sigmas not
   ! between .F_sigma_min to .F_sigma_max
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_exp,"no experimental data")
      low,high,val :: REAL
      i,dim :: INT
      i = 0
      loop: do 
        i = i + 1
        dim = .reflections.dim
        if (i>dim) exit
        low  = .F_sigma_min 
        high = .F_sigma_max
        val  = .reflections(i).F_sigma
        if (val>=low AND val<=high) cycle
        .reflections(i:dim-1) = .reflections(i+1:dim)
        .reflections.shrink(dim-1)
      end do loop
   end

   prune_weak_reflections ::: leaky
   ! This routine eliminates all the reflections which have 
   ! F_exp/F_sigma less than value "val" read from the input.
      self :: PTR
   DIE_IF(NOT .reflections.created,"No reflection data")
   DIE_IF(NOT .reflections.have_F_exp,"No experimental data")
      reflections :: VEC{REFLECTION}*
      list :: VEC{INT}*
      n,i :: INT
!   read_f_sigma_cutoff 
      val :: REAL
      val = .F_sigma_cutoff
      n = 0
      do i = 1,.reflections.n_refl
        WARN_IF(.reflections(i).F_sigma.equals(ZERO), "Zero sigma occured") 
        if (.reflections(i).F_sigma.equals(ZERO)) cycle
        if (abs(.reflections(i).F_exp/.reflections(i).F_sigma)<val) cycle
        n = n + 1
      end
      DIE_IF(n==0,"There are no elements less than "//val.to_str.trim)
      list.create(n)
      n = 0
      do i = 1,.reflections.n_refl
        if (.reflections(i).F_sigma.equals(ZERO)) cycle
        if (abs(.reflections(i).F_exp/.reflections(i).F_sigma)<val) cycle
        n = n + 1
        list(n) = i
      end
      reflections => .reflections
      .reflections.create(n)
      .reflections.copy(reflections(list))
      reflections.destroy
      list.destroy
   end

   zero_negative_F_exp ::: leaky
   ! This routine zero negative F_exp value 
      self :: PTR
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_exp,"no experimental data")
      i :: INT
      do i = 1,.reflections.n_refl
        if (.reflections(i).F_exp < ZERO) then
           .reflections(i).F_exp = ZERO
           .reflections(i).F_sigma = .reflections(i).F_sigma + abs(.reflections(i).F_exp)
        end
      end
   end

   read_temperature
   ! Read the temperature
      stdin.read(.temperature)
      ENSURE(.temperature>=0,"temperature is not positive!")
   end

   read_NKA_T_seq_no
   ! Read the temperature sequence no for NKA output file
      stdin.read(.NKA_T_sequence_no)
      ENSURE(.NKA_T_sequence_no>0,"sequence no is not positive!")
   end

!  Refinement options

   read_max_allowed_shift
   ! Read the maximum alllowed shift in a structure refinement
      stdin.read(.max_allowed_shift)
      ENSURE(.max_allowed_shift>ZERO,"convergence_tolerance is positive")
   end

   read_max_iterations
   ! Read the maximum number of iterations
      stdin.read(.max_iterations)
      ENSURE(.max_iterations>-1,"max_iterations must be non-negative")
      ENSURE(.max_iterations>.min_iterations,"max_iterations must be greater than min_iterations")
   end

   read_min_iterations
   ! Read the minimum number of iterations
      stdin.read(.min_iterations)
      ENSURE(.min_iterations>-1,"min_iterations must be non-negative")
      ENSURE(.max_iterations>.min_iterations,"min_iterations must be smaller than max_iterations")
   end

   read_reflection_data ::: leaky, private
   ! Read in reflection data in the standard order from "stdin".
      .reflections.read_list_keywords
   end

   read_refine_ADPs_only
   ! Read whether to refine only the ADP's
      stdin.read(.refine_ADPs_only)
   end

   read_refine_H_ADPs
   ! Read whether to refine only the H atom ADP's
      stdin.read(.refine_H_ADPs)
   end

   read_refine_H_U_iso
   ! Read whether to refine only the H atom U_iso's
      stdin.read(.refine_H_U_iso)
   end

   read_refine_positions_only
   ! Read whether to refine only the atom positions
      stdin.read(.refine_positions_only)
   end

   read_tol_0
   ! Read the tolerance for deciding on zero eigenvalues in solving
   ! the normal equations.
      stdin.read(.tol_0)
      ENSURE(.tol_0>ZERO,"tol_0 must be positive")
      ENSURE(.tol_0<.tol_near_0,"tol_0 must be smaller than tol_near_0")
   end

   read_tol_near_0
   ! Read the tolerance for deciding on *near* zero eigenvalues in
   ! solving the normal equations.
      stdin.read(.tol_near_0)
      ENSURE(.tol_near_0>ZERO,"tol_near_0 must be positive")
      ENSURE(.tol_0<.tol_near_0,"tol_near_0 must be bigger than tol_0")
   end

   read_tol_shift_convergence
   ! Read the tolerance for deciding when the normal equations are converged.
      stdin.read(.tol_shift_convergence)
      ENSURE(.tol_shift_convergence>ZERO,"tol_near_0 must be positive")
   end

   read_convergence_tolerance
   ! Read the convergence tolerance for the shifts in a structure
   ! refinement
      stdin.read(.tol_shift_convergence)
      ENSURE(.tol_shift_convergence>ZERO,"convergence_tolerance is positive")
   end

   read_display_corr_matrix
   ! Read whether to display the correlation matrix.
      stdin.read(.display_correlation_matrix)
   end

   read_display_near_0_evecs
   ! Read whether to display the near 0 eigenvectros of the correlation matrix.
      stdin.read(.display_near_0_eigenvectors)
   end

!  **************
!  Debug printing
!  **************

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>SHELL2)
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

!  ***************
!  General methods
!  ***************

   lp_factor result (res)
   ! Return the array of the Lorentz Polarization factors for all the
   ! reflections
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflections.created,"no reflection data")
      n :: INT
      c,s,two_theta :: REAL
      do n=1, .reflections.n_refl
       two_theta = TWO*.reflections(n).theta
       c = cos(two_theta)
       s = sin(two_theta)
       if (s.is_zero(TOL(8))) then
         res(n) = ZERO
         WARN("lp_factor for (000) reflection set to zero")
       else
         res(n) = (1+c*c)/(TWO*s)
       end
      end
   end

   I_pred result (res)
   ! Return the array of predicted Intensities. Only the Lorentz Polarization
   ! factor and the angular velocity factor for a single crystal are used.
   ! Fundamental constants appearing in front of this are not calculated
   ! NOTE: unlike I_exp, these may include extinction and dispersion effects.
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_exp, "no calculated structure factors")
      n :: INT
      c,s,two_theta,F2 :: REAL
      do n=1, .reflections.n_refl
       two_theta = TWO*.reflections(n).theta
       c = cos(two_theta)
       s = sin(two_theta)
       F2 = .reflections(n).F_pred
       F2 = F2*F2
       if (s.is_zero(TOL(8))) then
         res(n) = F2
       else
         res(n) = (1+c*c)/(TWO*s)*F2
       end
      end
   end

   I_exp result (res)
   ! Return the array of experimental Intensities. Only the Lorentz Polarization
   ! factor and the angular velocity factor for a single crystal are used.
   ! Fundamental constants appearing in front of this are not calculated
   ! NOTE: extinction factors, dispersion, multiple scattering corrections
   ! are not included. These are the experimental intensities with these effects
   ! removed.
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_exp, "no calculated structure factors")
      n :: INT
      c,s,two_theta,F2 :: REAL
      do n=1, .reflections.n_refl
       two_theta = TWO*.reflections(n).theta
       c = cos(two_theta)
       s = sin(two_theta)
       F2 = abs(.reflections(n).F_exp)
       F2 = F2*F2
       if (s.is_zero(TOL(8))) then
          res(n) = F2
       else
          res(n) = (1+c*c)/(TWO*s)*F2
       end
      end
   end

   I_sigma result (res)
   ! Return the array of experimental sigma's in the Intensities.
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_I_pred OR .reflections.have_F_exp, "no structure factors")
      n :: INT
      c,s,two_theta,F2 :: REAL
      if (NOT .reflections.have_F_exp AND NOT .synthesize_sigma_I) then
       WARN("The synthesize_sigma_I flag was not set; it is now set")
       .synthesize_sigma_I = TRUE
      end
      if (.synthesize_sigma_I) then
       res = .reflections.I_pred
       res = sqrt(res/.reflections.equivalence_factor)
      else
       do n=1, .reflections.n_refl
         two_theta = TWO*.reflections(n).theta
         c = cos(two_theta)
         s = sin(two_theta)
         F2 = abs(.reflections(n).F_exp)
         if (s.is_zero(TOL(8))) then
           res(n) = F2
         else
           res(n) = TWO*(1+c*c)/(TWO*s)*F2
         end
       end
      end
   end

   sin_theta_on_lambda(n) result (res)
   ! Return the value of sin(theta) / lambda for reflection n.
   ! NOTE: the wavelength is changed to be in Angstrom since that is usually the
   ! units sin theta on lamba is reported.
      self :: IN
      n :: INT, IN
      res :: REAL
      res = sin(.reflections(n).theta)/.wavelength.to_units("angstrom")
   end

   make_F_predicted
   ! Make the predicted magnitude of the structure factors, including
   ! possibly an overall scale factor and extinction correction.
      self :: INOUT
   DIE_IF(NOT .reflections.created,"no reflection data")
      F_pred :: VEC{REAL}*
      n_r,n_p :: INT

      ! The number of parameters is assumed set before the refinement
      if (NOT .refine_structure) then
        .n_param = 0
      end

      ! Get optimum scale factors, extinction, etc.
      if (.optimise_extinction OR .optimise_scale) .get_optimum_parameters

      ! Make F_predicted
      F_pred.create(.reflections.n_refl)
      if (.data_kind=="pnd") then; F_pred =     .reflections.F_calc  * .extinction_correction
      else;                        F_pred = abs(.reflections.F_calc) * .extinction_correction
      end

      ! Mix in some F_exp
      if (.SF_mixing_parameter>ZERO) then
      if (.have_F_exp) then
       F_pred = (ONE-.SF_mixing_parameter)*F_pred + .SF_mixing_parameter*.reflections.F_exp
      end 
      end 

      ! Set F_predicted
      .reflections.set_F_pred(F_pred)
      F_pred.destroy

      ! Calculate the chi^2
      n_r = .reflections.dim - 1
      n_p = .reflections.dim - .n_param
      .chi2_old = .chi2
      .chi2     = max(n_r,1)*.reflections.F_chi2/max(n_p,1)

   end

   update_n_param_and_chi2
   ! Update the number of parameters and recalculate the chi2
   DIE_IF(NOT .refine_structure,"must be doing a structure refinement")
   DIE_IF(.n_param<=0,"n_param must be +ve")

      n_r,n_p :: INT

      ! Add on extra parameters
      if (.optimise_extinction) then
       DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
       .n_param = .n_param + 2
      else if (.optimise_scale) then
       if (.use_multiple_scale_factors) then
          .n_param = .n_param + maxval(.reflections.group)
       else
          .n_param = .n_param + 1
       end
      end

      ! Update the chi2
      n_r = .reflections.dim - 1
      n_p = .reflections.dim - .n_param
      .chi2_old = .chi2
      .chi2     = max(n_r,1)*.reflections.F_chi2/max(n_p,1)

   end

   get_optimum_parameters ::: private
   ! Get the scale factors, extinction parameters, etc, which minimise the chi2.
   ! (To get the corrections cooresponding to these parameters see routine
   ! .extinction_correction)
      if (.optimise_extinction) then
       DIE_IF(.use_multiple_scale_factors,"must use optimize_extinction= no")
       .optimise_extinction_factor
      else if (.optimise_scale) then
       if (.use_multiple_scale_factors) then; .optimise_scale_factors
       else;                                  .optimise_scale_factor
       end
      end
   end

   extinction_correction result (res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: also does scale factor
      res :: VEC{REAL}(size(.reflections))
      if (.use_multiple_scale_factors) then
        res = .extinction_correction(.scale_factors,.extinction_factor)
      else
        res = .extinction_correction(.scale_factor,.extinction_factor)
      end
   end

   extinction_correction(scale_factor,extinction_factor) result (res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: this routine also does scaling
   ! corrections without extinction.
      scale_factor,extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")

      F_calc :: CPX
      F_abs2,val :: REAL
      angle_part :: VEC{REAL}*
      n_refl,n :: INT

      n_refl = .reflections.n_refl
      if (extinction_factor.is_zero(TOL(9))) then
        res(:) = scale_factor
      else
       angle_part.create(n_refl)
       angle_part = .extinction_angle_part
       do n=1, n_refl
         F_calc = .reflections(n).F_calc
         F_abs2 = F_calc*conjg(F_calc)
         val    = ONE + extinction_factor*F_abs2*angle_part(n)
         res(n) = scale_factor/sqrt(sqrt(val))
       end
       angle_part.destroy
      end

   end

   extinction_correction(scale_factors,extinction_factor) result (res)
   ! Return the extinction correction factors "res" to the calculated
   ! individual structure factors. WARNING: this routine in fact does no
   ! extinction correction, only multiple scale factors.
      scale_factors :: VEC{REAL}, IN
      extinction_factor :: REAL, IN
      res :: VEC{REAL}(size(.reflections))
      F_calc :: CPX
      angle_part :: VEC{REAL}*
      g,n,n_refl,n_group :: INT
      n_refl = .reflections.n_refl
      ENSURE(.reflections.created,"no reflection data")
      ENSURE(.reflections.have_F_calc, "no calculated structure factors")
      ENSURE(scale_factors.dim==maxval(.reflections.group),"no. of scale factors does not match no. of groups")
      n_group = scale_factors.dim
      if (extinction_factor.is_zero(TOL(9))) then
       do g = 1,n_group
          do n = 1, n_refl
            if (.reflections(n).group/=g) cycle
            res(n) = scale_factors(g) 
          end
       end
      else
       angle_part.create(n_refl)
       angle_part = .extinction_angle_part
       do g = 1,n_group
          do n = 1, n_refl
            if (.reflections(n).group/=g) cycle
            F_calc = .reflections(n).F_calc
            res(n) = scale_factors(g) / sqrt(sqrt(ONE + &
                extinction_factor*F_calc*conjg(F_calc)*angle_part(n)))
          end
       end
       angle_part.destroy
      end
   end

   extinction_angle_part result (res) ::: private
   ! Return the angular part of the extinction correction.
      res :: VEC{REAL}(size(.reflections))
      n :: INT
      twotheta,c,s :: REAL
      do n = 1, .reflections.n_refl
       twotheta=TWO*.reflections(n).theta
       c = cos(twotheta)
       s = sin(twotheta)
       res(n) = (ONE+c*c)/(ONE+c*s)
      end
   end

   optimise_scale_factor
   ! Determine the structure factor scale factor to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")

      top,bot,sg2,F_pred :: REAL
      n,n_refl :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      top = ZERO
      bot = ZERO
      do n = 1,n_refl
       ref => .reflections(n)
       if (.data_kind=="pnd") then; F_pred = ref.F_calc
       else;                   F_pred = abs(ref.F_calc)
       end
       ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")
       sg2 = ONE / (ref.F_sigma * ref.F_sigma)
       top = top + F_pred * ref.F_exp * sg2
       bot = bot + F_pred * F_pred * sg2
      end

      .scale_factor = top/bot

      if (NOT .refine_structure) .n_param = .n_param + 1

   end

   optimise_scale_factors ::: leaky
   ! Multiple scale factors are determined here ...
   ! Determine the structure factor scale factors to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")
   DIE_IF(NOT .use_multiple_scale_factors, "no reflection group numbers")

      top,bot,F_pred :: REAL
      g,n,n_refl,n_group :: INT
      ref :: REFLECTION*

      n_group = maxval(.reflections.group)
      n_refl = .reflections.n_refl

      .scale_factors.destroy
      .scale_factors.create(n_group)

      do g = 1,n_group
        top = ZERO
        bot = ZERO
        do n = 1,n_refl
          ref => .reflections(n)
          if (ref.group/=g) cycle
          if (.data_kind=="pnd") then; F_pred = ref.F_calc
          else;                   F_pred = abs(ref.F_calc)
          end
          ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")
          top = top + F_pred * ref.F_exp  / (ref.F_sigma * ref.F_sigma)
          bot = bot + F_pred * F_pred / (ref.F_sigma * ref.F_sigma)
        end
        .scale_factors(g) = top/bot
      end

      if (NOT .refine_structure) .n_param = .n_param + n_group

   end

   optimise_extinction_factor
   ! Optimize the .scale_factor and .extinction_factor parameter of Larson's
   ! method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! Reference: Larson, A. C., in <I>Crystallographic Computing</I>
   !            Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      self :: target
      p :: VEC{REAL}(2)
      chi2_min :: REAL

      ! Get starting scale factor
      .optimise_scale_factor

      ! Do a 2-variable minimisation
      p(1) = .scale_factor
      p(2) = ZERO          ! This is the .extinction_factor
      saved_self => self
      VEC{REAL}:minimise_BFGS(DIFFRACTION_DATA::chi2,DIFFRACTION_DATA::d_chi2 & 
                              ,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))
      .scale_factor = p(1)
      .extinction_factor = p(2)

      ! One was already added to .n_param when getting the initial scale
      if (NOT .refine_structure) .n_param = .n_param + 1

   end

   chi2(p) result (res) ::: selfless
   ! Make the chi2 between the calculated and experimental structure factors
   ! with extinction and scale parameters stored in vector p.
      p :: VEC{REAL}, IN
      res :: REAL
   ENSURE(saved_self.reflections.created,"no reflection data")
   ENSURE(saved_self.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(saved_self.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(saved_self.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")
      tmp,tmp1 :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT
      self :: DIFFRACTION_DATA*
      self => saved_self
      n_refl = .reflections.n_refl
      ext.create(n_refl)
      ext = .extinction_correction(p(1),p(2))
      tmp = ZERO
      do n=1,n_refl
       ref => .reflections(n)
       tmp1 = (abs(ref.F_calc) * ext(n) - ref.F_exp) / ref.F_sigma
       tmp = tmp + tmp1 * tmp1
      end
       res = tmp / max(n_refl-.n_param,1)
      ext.destroy
   end

   d_chi2(p) result (res) ::: selfless
   ! Return the derivative of the chi2 with respect to the .scale_factor in
   ! p(1), and with respect to .extinction_factor in p(2). This routine is for
   ! use in the BFGS minimiser.
      p :: VEC{REAL}, IN
      res :: VEC{REAL}(size(p))
   ENSURE(size(p)==2, "wrong size, p")
      self :: DIFFRACTION_DATA*
      self => saved_self
      res(1) = .d_chi2_d_scale(p)
      res(2) = .d_chi2_d_ext(p)
   end

   d_chi2_d_scale(p) result (res)
   ! Derivative of the chi^2 with respect to the scale factor
      p :: VEC{REAL}, IN
      res :: REAL
   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")
      tmp,F_pred :: REAL
      ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT
      n_refl = .reflections.n_refl
      ext.create(n_refl)
      ext = .extinction_correction(p(1),p(2))
      tmp = ZERO
      do n=1,n_refl
       ref => .reflections(n)
       F_pred = abs(ref.F_calc) * ext(n)
       tmp = tmp + F_pred*F_pred - ref.F_exp*F_pred / (ref.F_sigma*ref.F_sigma)
      end
      res = TWO*tmp/(p(1)*max(n_refl-.n_param,1))
      ext.destroy
   end

   d_chi2_d_ext(p) result (res)
   ! Derivative of the chi^2 with respect to the extinction parameter.
      p :: VEC{REAL}, IN
      res :: REAL
   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(size(p)==2, "wrong size, p")
      tmp,extn,p1 :: REAL
      angle_bit,ext :: VEC{REAL}*
      ref :: REFLECTION*
      n,n_refl :: INT
      n_refl = .reflections.n_refl
      angle_bit.create(n_refl)
      ext.create(n_refl)
      angle_bit = .extinction_angle_part
      p1 = p(1)
      ext = .extinction_correction(ONE,p(2))
      tmp = ZERO
      do n = 1,n_refl
       ref => .reflections(n)
       extn = ext(n)
       tmp = tmp + (p1 * abs(ref.F_calc) * extn - ref.F_exp) * &
           extn*extn*extn*extn*extn* ref.F_calc*ref.F_calc*ref.F_calc * &
           angle_bit(n) / (ref.F_sigma * ref.F_sigma)
      end
      res = -p1*tmp/(TWO * max(n_refl-.n_param,1))
      ext.destroy
      angle_bit.destroy
   end

!   d_chi2_dU(dF) result (res)
!   ! Evaluate the derivative of the chi^2 with respect to parameters U
!   ! (e.g. thermal parameters) given the derivatives "dF" of where
!   ! .F_calc with respect to these parameters U. NOTE: this routine
!   ! assumes that the .scale_factor and .extinction_factor are fixed.
!     dF :: MAT{CPX}
!     res :: VEC{REAL}(dF.dim1)
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
!   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
!   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
!   ENSURE(dF.dim1==.reflections.n_refl, "wrong size, dF")
!     Fc_conjgFcalc :: VEC{CPX}*
!     ref :: REFLECTION*
!     ext,angle_bit :: VEC{REAL}*
!     fac,Fc,Fc1,extn :: REAL
!     u,n_refl,n :: INT
!     n_refl = .reflections.n_refl
!     angle_bit.create(n_refl)
!     angle_bit = .extinction_angle_part
!     ext.create(n_refl)
!     ext = .extinction_correction(ONE,.extinction_factor)
!     Fc_conjgFcalc.create(n_refl)
!     do n = 1,n_refl
!       ref => .reflections(n)
!       extn = ext(n)
!       Fc1 = abs(ref.F_calc)
!       Fc = ( (.scale_factor*extn*Fc1 - ref.F_exp) / &
!          (ref.F_sigma * ref.F_sigma) ) * &
!          (extn / Fc1 - HALF * extn * extn * extn * extn * extn * &
!          .extinction_factor * Fc1 * angle_bit(n))
!       Fc_conjgFcalc(n) = Fc * conjg(ref.F_calc)
!     end
!     fac = TWO*.scale_factor/max(n_refl-.n_param,1)
!     do u = 1,size(dF,2)
!        res(u) = fac * sum( Fc_conjgFcalc(:) * dF(:,u) )
!     end
!     Fc_conjgFcalc.destroy
!     ext.destroy
!     angle_bit.destroy
!   end

!   d_chi2_dX(res,dFdX)
!   ! Evaluate "res", the derivative of the chi^2 with respect to some
!   ! parameters X (e.g. thermal parameters) given the derivatives
!   ! "dFdX" w.r.t. the X parameters. NOTE: this routine assumes that
!   ! the .scale_factor and .extinction_factor are fixed.
!     res :: VEC{REAL}, OUT
!     dFdX :: MAT{CPX}, IN
!
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
!   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
!   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
!   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
!
!     Fc_conjgFcalc :: VEC{CPX}*
!     ref :: REFLECTION*
!     ext,angle_bit :: VEC{REAL}*
!     fac,Fc,Fc1,extn :: REAL
!     n_refl,u,n :: INT
!
!     n_refl = .reflections.n_refl
!     angle_bit.create(n_refl)
!     angle_bit = .extinction_angle_part
!     ext.create(n_refl)
!     ext = .extinction_correction(ONE,.extinction_factor)
!     Fc_conjgFcalc.create(n_refl)
!     do n = 1,n_refl
!       ref => .reflections(n)
!       extn = ext(n)
!       Fc1 = abs(ref.F_calc)
!       Fc = ( (.scale_factor*extn*Fc1 - ref.F_exp) / &
!          (ref.F_sigma * ref.F_sigma) ) * &
!          (extn / Fc1 - HALF * extn * extn * extn * extn * extn * &
!          .extinction_factor * Fc1 * angle_bit(n))
!       Fc_conjgFcalc(n) = Fc * conjg(ref.F_calc)
!     end
!     fac = TWO*.scale_factor/max(n_refl-.n_param,1)
!     do u = 1,dFdX.dim2
!        res(u) = fac * sum( Fc_conjgFcalc * dFdX(:,u) )
!     end
!     Fc_conjgFcalc.destroy
!     ext.destroy
!     angle_bit.destroy
!   end

!  ****************************
!  Structure refinement methods
!  ****************************

   d_chi2_dX(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters.  NOTE: this routine assumes the .extinction_factor
   ! is fixed.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dFdX.dim2==res.dim, "incompatible dFdX and res")

      Fcd_conjgFcalc :: VEC{CPX}*
      ref :: REFLECTION*
      ext,angle_bit,d_scale :: VEC{REAL}*
      Fcd,Fca,fac,extn,ext5,sg2,sdk,nrinv :: REAL
      n_refl,n_p,p,n :: INT
 
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      Fcd_conjgFcalc.create(n_refl)

      ext.create(n_refl)
      ext = .extinction_correction(ONE,.extinction_factor)

      angle_bit.create(n_refl)
      angle_bit = .extinction_angle_part

      sdk = ZERO
      do n = 1,n_refl
         ref => .reflections(n)
         extn = ext(n)
         ext5 = extn*extn*extn*extn*extn*.extinction_factor
         Fca = abs(ref.F_calc)
         sg2 = ONE/(ref.F_sigma*ref.F_sigma)
         fac = (.scale_factor*extn*Fca - ref.F_exp)*sg2
         Fcd = fac * (extn/Fca - HALF*ext5*angle_bit(n))
         Fcd_conjgFcalc(n) = Fcd * conjg(ref.F_calc)
         sdk = sdk + fac*extn*Fca
      end
      angle_bit.destroy
      ext.destroy

      d_scale.create(n_p)
      .d_scale_dX(d_scale,dFdX)

      nrinv = ONE/max(n_refl-.n_param,1)
      sdk = TWO*nrinv*sdk
      fac = TWO*.scale_factor*nrinv

      do p = 1,n_p
         res(p) = sdk*d_scale(p) + fac * sum( Fcd_conjgFcalc * dFdX(:,p) )
      end
      d_scale.destroy
      Fcd_conjgFcalc.destroy

   end

   d_chi2_dX_plus_se(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters. Two extra derivatives are included, w.r.t. the
   ! extinction parameter and the scale factor.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dFdX.dim2==res.dim-2, "incompatible dFdX and res")

      Fcd_conjgFcalc :: VEC{CPX}*
      ref :: REFLECTION*
      ext,angle_bit :: VEC{REAL}*
      Fcd,Fca,fac,extn,ext5,extf, Fe,Fs :: REAL
      n_refl,n_p,p,n :: INT
 
      ! Constants
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      ! Temporaries
      angle_bit.create(n_refl)
      ext.create(n_refl)
      Fcd_conjgFcalc.create(n_refl)

      ! Different parts of the extinction
      angle_bit = .extinction_angle_part
      ext = .extinction_correction(ONE,.extinction_factor)

      ! Make parameter prefactor derivative
      Fe = ZERO
      Fs = ZERO
      do n = 1,n_refl
         ref => .reflections(n)
         extn = ext(n)
         ext5 = extn*extn*extn*extn*extn
         extf = ext5*.extinction_factor
         Fca = abs(ref.F_calc)
         fac = (.scale_factor*extn*Fca - ref.F_exp)/(ref.F_sigma*ref.F_sigma)
         Fcd = fac * (extn/Fca - HALF*extf*angle_bit(n))
         Fcd_conjgFcalc(n) = Fcd * conjg(ref.F_calc)
         ! Extinction part
         Fe = Fe - fac*QUARTER*.scale_factor*ext5*Fca*Fca*Fca*angle_bit(n)
         ! Scale part
         Fs = Fs + fac*extn*Fca
      end

      ! Parameter derivatives
      fac = TWO*.scale_factor/max(n_refl-.n_param,1)
      do p = 1,n_p
         res(p) = fac * sum( Fcd_conjgFcalc * dFdX(:,p) )
      end

      ! Extinction and scale derivatives
      res(n_p+1) = fac*Fe
      res(n_p+2) = fac*Fs

      ! Cleanup
      Fcd_conjgFcalc.destroy
      ext.destroy
      angle_bit.destroy

   end

   d_F_abs_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the *complex* structure factors  w.r.t. the X
   ! parameters. 
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")

      F_con :: VEC{CPX}*
      F_abi :: VEC{REAL}*
      F_cal :: CPX
      n_refl,n_p,p,n :: INT
 
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      F_con.create(n_refl)
      F_abi.create(n_refl)

      do n = 1,n_refl
         F_cal    = .reflections(n).F_calc
         F_con(n) = conjg(F_cal)
         F_abi(n) = ONE/abs(F_cal)
      end

      do p = 1,n_p
      do n = 1,n_refl
         res(n,p) = F_abi(n) * F_con(n) * dFdX(n,p)
      end
      end

      F_abi.destroy
      F_con.destroy

   end

!   d_F_pred_dX(res,dFdX)
!   ! Evaluate "res", the derivative of the F_pred with respect to some
!   ! parameters X (e.g. thermal parameters) given "dFdX", the
!   ! derivatives of the complex structure factors  w.r.t. the X
!   ! parameters. NOTE: this routine assumes that the .scale_factor and
!   ! .extinction_factor are fixed.
!      res :: MAT{REAL}, OUT
!      dFdX :: MAT{CPX}, IN
!
!   ENSURE(.reflections.created,"no reflection data")
!   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
!   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
!   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
!   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
!   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
!   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")
!
!      Fcd_conjgFcalc :: VEC{CPX}*
!      ref :: REFLECTION*
!      ext,angle_bit :: VEC{REAL}*
!      Fcd,Fca,extn,ext5 :: REAL
!      n_refl,u,n :: INT
! 
!      n_refl = .reflections.n_refl
!      angle_bit.create(n_refl)
!      ext.create(n_refl)
!      angle_bit = .extinction_angle_part
!      ext = .extinction_correction(ONE,.extinction_factor)
!      Fcd_conjgFcalc.create(n_refl)
!      do n = 1,n_refl
!         ref => .reflections(n)
!         extn = ext(n)
!         ext5 = extn*extn*extn*extn*extn*.extinction_factor
!         Fca = abs(ref.F_calc)
!         Fcd = extn/Fca - HALF*ext5*angle_bit(n)
!         Fcd = .scale_factor * Fcd
!         Fcd_conjgFcalc(n) = Fcd * conjg(ref.F_calc)
!      end
!      do u = 1,dFdX.dim2
!      do n = 1,n_refl
!         res(n,u) = Fcd_conjgFcalc(n) * dFdX(n,u) 
!      end
!      end
!      Fcd_conjgFcalc.destroy
!      ext.destroy
!      angle_bit.destroy
!   end

   d_F_pred_dX(res,sig,del,dFdX)
   ! Evaluate "res", the derivative of the F_pred with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the absolute structure factors  w.r.t. the X
   ! parameters. Includes derivatives w.r.t. the scale factor, but
   ! extinction is treated as a constant and should be OFF for exact
   ! results. Also makes "sig" and "del" required for the normal
   ! equations.
      res :: MAT{REAL}, OUT
      sig,del :: VEC{REAL}, OUT
      dFdX :: MAT{REAL}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_calc, "no calculated structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE( del.dim1==.reflections.n_refl, "wrong size, del")
   ENSURE( res.dim1==.reflections.n_refl, "wrong size, res")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dFdX.dim2==res.dim2, "incompatible res, dFdX")

      ref :: REFLECTION*
      Ft,Fx,dt,db,ext,angle_bit,d_scale :: VEC{REAL}*
      top,bot,extn,F_exp,F_sig,F_abs,F_til,sig2,F_es2,F_ts2,fac,dsp,ext4,dX :: REAL
      n_refl,n_p,p,n :: INT
 
      ! Constants
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2

      ! Temporaries
      Ft.create(n_refl)
      Fx.create(n_refl)
      dt.create(n_refl)
      db.create(n_refl)
 
      ! Extinction factor part
      ext.create(n_refl)
      ext = .extinction_correction(ONE,.extinction_factor)

      ! Angle bit, extinction factor folded in
      angle_bit.create(n_refl)
      angle_bit = .extinction_factor*.extinction_angle_part

      ! Make temporaries for derivative of scale, extinction, F_abs
      top = ZERO
      bot = ZERO

      do n = 1,n_refl

         extn   = ext(n)
         ref    => .reflections(n)

         F_exp  = ref.F_exp
         F_sig  = ref.F_sigma
         F_abs  = abs(ref.F_calc)
         F_til  = extn*F_abs
         sig2   = ONE/(F_sig*F_sig)

         F_es2  = F_exp*sig2
         F_ts2  = F_til*sig2

         top    = top + F_til*F_es2
         bot    = bot + F_til*F_ts2

         ext4   = extn*extn
         ext4   = ext4*ext4
         dX     = -HALF*ext4*angle_bit(n)*F_abs
         dX     = ONE + F_abs*dX

         dt(n)  = F_es2*extn*dX
         db(n)  = extn*F_ts2*dX
         Ft(n)  = F_til
         Fx(n)  = .scale_factor*extn*dX

         ! Return these
         sig(n) = sig2
         del(n) = (F_exp - ref.F_pred)*sig2

      end

      angle_bit.destroy
      ext.destroy
 
      ! Derivative of the scale factor
      d_scale.create(n_p)
      bot = ONE/bot
      fac = -TWO*top*bot*bot
      do p = 1,n_p
         d_scale(p) = bot*sum(dt*dFdX(:,p)) + fac*sum(db*dFdX(:,p))
      end

      db.destroy
      dt.destroy

      ! Derivative of F_pred or F^m
      do p = 1,n_p
         dsp = d_scale(p)
         do n = 1,n_refl
            res(n,p) = dsp*Ft(n) + Fx(n) * dFdX(n,p) 
         end
      end

      ! Clean up
      d_scale.destroy
      Fx.destroy; Ft.destroy

   end

   d_scale_dX(res,dFdX)
   ! Return "res" the derivative of the scale factor with respect to
   ! parameters X, where the *complex* structure factor parameter
   ! derivatives are given in "dFdX". This takes into account an
   ! existing extinction factor.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN

   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
   DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
   DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")
   ENSURE(.data_kind=="x-ray","only valie for X-ray data, so far")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dF")
   ENSURE(dFdX.dim2==res.dim, "incompatible res, dFdX")

      top,bot,fac,sg2,F_abs,F_exp,F_sig,extn :: REAL
      dt,db :: VEC{CPX}*
      ext   :: VEC{REAL}*
      F_cal :: CPX
      n,n_refl,p :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      dt.create(n_refl)
      db.create(n_refl)

      ext.create(n_refl)
      ext = .extinction_correction(ONE,.extinction_factor)

      top = ZERO
      bot = ZERO
      do n = 1,n_refl
       ref => .reflections(n)
       extn = ext(n)
       F_cal = extn*conjg(ref.F_calc)
       F_abs = abs(F_cal)
       F_exp = abs(ref.F_exp)
       F_sig = ref.F_sigma
       ENSURE(F_sig/=ZERO,"Structure factor has zero error!")
       sg2 = ONE / (F_sig * F_sig)
       dt(n) = extn * F_exp * sg2 * F_cal / F_abs
       db(n) = extn * sg2 * F_cal
       F_abs = extn * F_abs
       top = top + F_abs * F_exp * sg2
       bot = bot + F_abs * F_abs * sg2
      end
      ext.destroy

      bot = ONE/bot
      fac = -TWO*top*bot*bot
      do p = 1,dFdX.dim2
        res(p) = bot*sum(dt*dFdX(:,p)) + fac*sum(db*dFdX(:,p))
      end

      db.destroy
      dt.destroy

   end

   solve_normal_equations(shifts,dFdX) ::: leaky
   ! Get the "shifts" in the parameters by solving the normal
   ! equations, given "F" and "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters. "n_0" is the number of
   ! eigenvalues equal to zero (as determined by .tol_0) and
   ! "n_near_0" is the number of eigenvalues nearly equal to zero (as
   ! determined by .tol_near_0).
      shifts :: VEC{REAL}, OUT
      dFdX :: MAT{REAL}, IN

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_F_pred, "no predicted structure factors")
   ENSURE(.reflections.have_F_exp, "no experimental structure factors")
   ENSURE(.reflections.have_F_sigma, "no structure factor errors")
   ENSURE(dFdX.dim1==.reflections.n_refl, "wrong size, dFdX")
   ENSURE(dFdX.dim2==shifts.dim, "incompatible shifts and dFdX")

      A,dF :: MAT{REAL}*
      rhs,sig,del :: VEC{REAL}*
      n_refl,n_p,i,j :: INT
      debg :: BIN
      fac :: REAL
 
      ! Constants
      n_refl = .reflections.n_refl
      n_p = dFdX.dim2
 
      ! Arrays
      A.create(n_p,n_p)
      rhs.create(n_p)
      del.create(n_refl)
      dF.create(n_refl,n_p)
      sig.create(n_refl)

      ! Make derivatives of F_pred
      .d_F_pred_dX(dF,sig,del,dFdX)

      ! Checked using FD, setting optimise extinction 
      ! and optimise scale OFF
      if (.debugging("solve_normal_equations")) then 
      stdout.text("dF:")
      stdout.put(dF)
      end

      ! Make the normal matrix
      do i = 1,n_p
      do j = 1,n_p
         A(i,j) = sum(sig*dF(:,i)*dF(:,j))
      end
      end
      sig.destroy

      ! Make the rhs
      do i = 1,n_p
         rhs(i) = sum(del*dF(:,i))
      end

      dF.destroy
      del.destroy

      if (.debugging("solve_normal_equations")) then 
      stdout.text("A:")
      stdout.put(A)
      stdout.text("rhs:")
      stdout.put(rhs,"column")
      end

      ! Solve for the shifts (leaky)
      A.solve_ill_linear_equations(rhs,shifts,.tol_0,.n_0,.tol_near_0,.n_near_0 &
                                  ,.near_0_eigenvalues,.near_0_eigenvectors &
                                  ,.delta_p,.covariance_matrix,.correlation_matrix)

      ! Get the maximum shift
      .max_shift = maxval(abs(shifts))

      ! Set the number of parameters
      .n_param = n_p - .n_near_0 

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts:")
      stdout.put(shifts,"column")
      stdout.show("Normal equations check = ",maxval(abs(matmul(A,shifts)-rhs)))
      stdout.show("Smallest eigenvalue    = ",minval(abs(.near_0_eigenvalues)))
      stdout.show("tol_0                  = ",.tol_0)
      stdout.show("n_0                    = ",.n_0)
      stdout.show("tol_near_0             = ",.tol_near_0)
      stdout.show("n_near_0               = ",.n_near_0)
      end

      rhs.destroy
      A.destroy

      ! Renormalise shift if too big
      if (.max_shift>.max_allowed_shift) then
         fac = .max_allowed_shift/.max_shift
         shifts = fac * shifts
      end

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts after renormalisation:")
      stdout.put(shifts,"column")
      stdout.text("delta:")
      stdout.put(.delta_p,"column")
      end

   end

   initialise_refinement(n_p)
   ! Ininitalise the refienement. Set the number of parameters to
   ! "n_p, put out the banner.
      n_p :: INT, IN

      ! Set the # of parameters. Used for getting the correct
      ! chi^2 statistic
      .n_param = n_p

      ! Turn on refinement. This switch is for turning off code
      ! which resets the # of parameters
      .refine_structure = TRUE

      ! Initially chi^2 is as big as you can get
      .chi2_old = huge(ONE)

      ! Beginning of the iterations
      .iteration = 0

   end

   put_refinement_params
   ! Put the refinement parameters

      stdout.flush
      stdout.text("****************************")
      stdout.text("Crystal structure refinement")
      stdout.text("****************************")
      stdout.flush
      stdout.show("Refine scale factor         =",.optimise_scale)
      stdout.show("Refine multiple scales      =",.use_multiple_scale_factors)
      stdout.show("Refine extinction parameter =",.optimise_extinction)
      stdout.flush
      stdout.show("Refine H ADP's              =",.refine_H_ADPs)
      stdout.show("Refine H U_iso              =",.refine_H_U_iso)
      stdout.show("Refine ADP's only           =",.refine_ADPs_only)
      stdout.show("Refine positions only       =",.refine_positions_only)
      stdout.flush
      stdout.show("Shift convergence criteria  =",.tol_shift_convergence)
      stdout.show("Max allowed parameter shift =",.max_allowed_shift)
      stdout.show("Zero eigenvalue tolerance   =",.tol_0)
      stdout.show("Nearly zero tolerance       =",.tol_near_0)
      stdout.show("Max iterations              =",.max_iterations)
      stdout.show("Min iterations              =",.min_iterations)

   end

   put_iteration_header
   ! Put the interation table header

      stdout.flush
      stdout.text("****************")
      stdout.text("Start refinement")
      stdout.text("****************")

      stdout.flush
      stdout.dash(int_fields=3,real_fields=4)
      stdout.put("Iter",int_width=TRUE)
      stdout.put("chi2")
      stdout.put("R")
      stdout.put("R_w")
      stdout.put("Max Shft")
      stdout.put("n_param",int_width=TRUE)
      stdout.put("n_near_0",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=3,real_fields=4)

   end

   put_iteration_results
   ! Print out the current iterations results
   ! WARNING: it increments the iteration count

      .iteration = .iteration + 1

      ! Iteration results
      stdout.put(.iteration)
      stdout.put(.chi2)
      stdout.put(.F_r_factor)
      stdout.put(.F_weighted_r_factor)
      stdout.put(.max_shift)
      stdout.put(.n_param)
      stdout.put(.n_near_0)
      stdout.flush

   end

   put_iteration_footer
   ! Put the iteration footer
      chi2_increased :: BIN
      finished,converged,too_many_iters :: BIN

      ! Table footer
      stdout.dash(int_fields=3,real_fields=4)

      stdout.flush
      stdout.text("******************")
      stdout.text("Refinement results")
      stdout.text("******************")
      stdout.flush

      ! How did it finish?
      finished = .refinement_finished(chi2_increased,too_many_iters,converged)
      DIE_IF(NOT finished,"Structure refinement seems not finished?")

      ! Print how it finished
      if (converged) then;           stdout.text("Structure refinement converged.")
      else if (chi2_increased) then; stdout.text("Structure refinement stopped; chi2 has increased.")
      else if (too_many_iters) then; stdout.text("Structure refinement stopped; too many iterations.")
      end

      ! Put final fitting statistics
      .reflections.put_F_statistics(show_chi2=FALSE)
      stdout.show("# of fit parameters, N_p    =", .n_param)
      stdout.show("chi^2(N_p)                  =",.chi2)
      stdout.show("Goodness of fit (N_p)       =", sqrt(.chi2))

   end
 
   refinement_finished(chi2_increased,too_many,converged) result (res)
   ! Return whether the refinement has finished
      chi2_increased,too_many,converged :: BIN, OUT, optional
      res :: BIN
      tmp :: BIN
      tmp = .max_shift<.tol_shift_convergence
      if (present(converged)) converged = tmp
      res = tmp
      tmp = .chi2>.chi2_old AND .iteration>.min_iterations
      if (present(chi2_increased)) chi2_increased = tmp
      res = res OR tmp
      tmp = .iteration>.max_iterations
      if (present(too_many)) too_many = tmp
      res = res OR tmp
   end

   set_parameter_errors
   ! Set the parameter errors
   ENSURE(.delta_p.created,"no delta_p")
   ENSURE(.covariance_matrix.created,"no covariance_matrix")

      ! Delta's and full covariance matrix
      .delta_p           = sqrt(abs(.chi2*.delta_p))
      .covariance_matrix = .chi2*.covariance_matrix

   end

!   finalise_refinement
!   ! Finalise refinement
!
!      ! Turn off refinement. This switch is for turning off code
!      ! which resets the # of parameters.
!      .refine_structure = FALSE
!
!   end
 
   refine_positions_and_ADPs result (res)
   ! A refinement of all positions and ADP's
      res :: BIN
      res =   NOT .refine_positions_only &
          AND NOT .refine_ADPs_only 
   end

!  **************
!  Output methods
!  **************

   put
   ! Put out the diffraction data to file "out"
      stdout.flush
      stdout.text("Diffraction information:")
      stdout.show("data_kind                        = ", .data_kind)
      if (.reflections.created) then
      stdout.text("Reflection data:")
      stdout.flush
      .put_reflection_data
      stdout.flush
      end
   end

   put_sin_theta_on_lambda
   ! Output sin(theta)/lambda for all reflections.
   ENSURE(.reflections.created,"No list of reflections")
   ENSURE(.reflections.have_indices,"No list of reflections")
      n :: INT
      stdout.text("sin(theta)/lambda for the reflections")
      stdout.dash(int_fields=3,real_fields=1)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.put("stl")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=1)
      do n=1,size(.reflections)
       stdout.put(.reflections(n).h)
       stdout.put(.reflections(n).k)
       stdout.put(.reflections(n).l)
       stdout.put(.sin_theta_on_lambda(n))
       stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=1)
   end

   put_F_calc
   ! Put the hkl Miller index triple followed by the calculated
   ! structure factor to add onto existing structure factors.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.set_keys(["indices","F_calc "])
      .reflections.put
      .reflections.clear_keys
   end

   put_F_statistics
   ! Output the structure factor goodness of fit statistics
   ! stdout.
      .reflections.put_F_statistics
   end

   put_I_stats ::: private
   ! Output the intensity goodness of fit statistics
      .reflections.put_I_stats
      .put_correction_data
   end

   put_correction_data
   ! Output the correction data
      real_width :: BIN
      real_width = TRUE
      stdout.flush
      stdout.show("Using scale factor(s)         = ", .optimise_scale,real_width=TRUE)
      stdout.show("Using extinction              = ", .optimise_extinction,real_width)
      stdout.show("Thermal smearing model        = ", .thermal_smearing_model)
      stdout.show("Fragment partition model      = ", .partition_model)
      stdout.show("Correct dispersion?           = ", .correct_dispersion,real_width=TRUE)
      if (.optimise_extinction) then;
      stdout.show("Optimize extinction           = ", TRUE,real_width)
      stdout.show("Secondary extinction factor   = ", .extinction_factor)
      else
      stdout.show("Optimize extinction           = ", FALSE,real_width)
      end
      if (.optimise_scale) then
        if (.use_multiple_scale_factors) then
      stdout.show("Using multiple scale factors  = ", TRUE,real_width=TRUE)
      stdout.show("Scale factors                 = ", .scale_factors)
        else
      stdout.show("Using single scale factor     = ", TRUE,real_width=TRUE)
      stdout.show("Scale factor                  = ", .scale_factor)
        end
      else
      stdout.show("Optimize scale factor         = ", FALSE,real_width)
      end
   end

   put_gof_data
   ! Output the goodness-of-fit data
      stdout.show("Chi2                          = ", .F_chi2)
      stdout.show("Goodness of fit in F          = ", .F_goodness_of_fit)
      stdout.show("R factor in F                 = ", .F_r_factor)
      stdout.show("Weighted R factor in F        = ", .F_weighted_r_factor)
   end

   put_free_gof_data
   ! Output the free goodness-of-fit data
      stdout.show("Free Chi2 in F                = ", .F_chi2)
      stdout.show("Free Goodness of fit in F     = ", .F_goodness_of_fit)
      stdout.show("Free R factor in F            = ", .F_r_factor)
      stdout.show("Free weighted R factor in F   = ", .F_weighted_r_factor)
   end

   put_reflection_data(core_reflection)
   ! Output the reflection data
      core_reflection :: VEC{REFLECTION}*, optional

   ENSURE(.reflections.created,"no reflections")

      if (.have_F_calc OR .have_F_pred) .put_correction_data
      .reflections.put(core_reflection)

   end

   put_reflection_phases ::: private
   ! Output the reflection phases
   ENSURE(.reflections.created, "no reflection data")
      .reflections.set_keys(["indices","F_calc ","F_phase"])
      .reflections.put
      .reflections.clear_keys
   end

   put_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.put_F_qq_plot
   end

   put_labelled_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.put_labelled_F_qq_plot
   end

   put_chi2_vs_angle_plot
   ! Output a table with the chi^2 for the structure factor data set broken
   ! into sections.
   ! Reads from stdin the number of divisions in the plot.
      num_sections :: INT
      n,num,k,n_refl :: INT
      section_for :: VEC{INT}*
      stl,stl_min,stl_max,chi2,width,stl_mean :: REAL

      stdin.read(num_sections)
   ENSURE(num_sections > 0, "number of sections to plot not positive")
   ENSURE(.reflections.created,"no structure factors")
      n_refl = .reflections.n_refl

      ! Work out the limits of the sin(theta)/lambda.
      stl_min = 1000
      stl_max = ZERO
      do n=1, n_refl
       stl = .sin_theta_on_lambda(n)
       if (stl < stl_min) stl_min = stl
       if (stl > stl_max) stl_max = stl
      end
      width = (TOL(3) + stl_max - stl_min)/num_sections

      section_for.create(n_refl)
      ! Determine which section each reflection belongs to.
      do n=1, n_refl
       stl = .sin_theta_on_lambda(n) 
       section_for(n) = ceiling((TOL(3) + stl - stl_min) / width)
      end

      stdout.flush
      stdout.text("Chi^2 vs angle plot")
      stdout.flush
      stdout.text("sin(theta)/lambda in Angstrom^(-1)")
      stdout.show("Smallest sin(theta)/lambda  = ",stl_min)
      stdout.show("Largest sin(theta)/lambda   = ",stl_max)
      stdout.flush
      stdout.put("stl")
      stdout.put("chi^2",flush=1)
      stdout.dash(real_fields=2)
      do n = 1, num_sections
       chi2 = ZERO
       num = 0
       stl_mean = stl_min + (n - HALF) * width
       do k = 1, n_refl
         if (n==section_for(k)) then
           chi2 = chi2 + .reflections(k).F_z2
           num = num + 1
         end
       end
       stdout.put(stl_mean)
       if (num==0) then
         stdout.flush
         cycle
       else
         chi2 = chi2 / max(num - .n_param,1)
         stdout.put(chi2,flush=1)
       end
      end
      stdout.flush
      section_for.destroy
   end

   put_fcalc_plots
   ! Output some different plots about the calculated structure factors.
      ext :: VEC{REAL}*
      ext_refs :: VEC{REFLECTION}*
      n,n_refl :: INT
      y,w :: REAL

      n_refl = .reflections.n_refl

      stdout.text("The effects of angle.")
      stdout.text("Scatter plot of F_z = (Fexp-Fpred)/F_sigma vs sin(theta)/lambda")
      do n=1,n_refl
       stdout.put(.sin_theta_on_lambda(n))
       stdout.put(.reflections(n).F_z)
       stdout.flush
      end
      stdout.flush

      stdout.text("The effects of intensity.")
      stdout.text("Scatter plot of F_z = (Fexp-Fpred)/F_sigma vs Fexp")
      do n=1,n_refl
       stdout.put(.reflections(n).F_exp)
       stdout.put(.reflections(n).F_z)
       stdout.flush
      end
      stdout.flush

      ext_refs.create(n_refl)
      ext.create(n_refl)
      ext = .extinction_correction
      ext_refs.set_F_exp(.reflections.F_pred)
      ext_refs.set_F_pred(.reflections.F_pred * ext)
      ext_refs.set_F_sigma(.reflections.F_sigma)
      ext.destroy

      if (NOT .optimise_extinction) return

      stdout.text("The effects of extinction.")

      w = ZERO
      y = ZERO
      do n=1,n_refl
       y = y + abs(ext_refs(n).F_z)
       w = w + abs(ext_refs(n).F_r)
      end
      y = y / n_refl
      w = w / n_refl
      stdout.show("Average value of abs[Fcalc(with ext)-Fcalc(without ext)]/F_sigma is ",y)
      stdout.show("Average value of abs(extinction correction) is ",w)
      stdout.flush

      stdout.text("The effects of intensity on extinction.")
      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/F_sigma vs F_pred")
      do n=1,n_refl
       stdout.put(ext_refs(n).F_pred)
       stdout.put(ext_refs(n).F_z)
       stdout.flush
      end
      stdout.flush

      stdout.text("The effects of scattering angle on extinction.")
      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/F_sigma vs sin(theta)/lambda")
      do n=1,n_refl
       stdout.put(.sin_theta_on_lambda(n))
       stdout.put(ext_refs(n).F_z)
       stdout.flush
      end
      ext_refs.destroy

      stdout.flush
   end

   put_PND_sf(name)
   ! Output the magnetic structure factors
       name :: STR
       FM_s,FM_l :: VEC{CPX}*
       arch :: ARCHIVE
        n :: INT
       FM_s.create(.reflections.n_refl)
       arch.set(name,"PND_spin_sf")
       arch.read(FM_s)
       FM_l.create(.reflections.n_refl)
       arch.set(name,"PND_nabla_sf")
       arch.read(FM_l)
       stdout.text("PND magnetic structure factors:")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       stdout.put("h", int_width=TRUE)
       stdout.put("k", int_width=TRUE)
       stdout.put("l", int_width=TRUE)
       stdout.put("FM_s")
       stdout.put("FM_l")
       stdout.put("FM")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       do n = 1, .reflections.n_refl
          stdout.put(.reflections(n).h)
          stdout.put(.reflections(n).k)
          stdout.put(.reflections(n).l)
          stdout.put(real(FM_s(n)) )
          stdout.put(real(FM_l(n)) )
          stdout.put(real(FM_s(n)+FM_l(n)) )
          stdout.flush
       end
       stdout.dash(int_fields=3,real_fields=3)
       FM_l.destroy
       FM_s.destroy
   end

   put_cif(basis,scf_type)
   ! Put data information in CIF format
      basis,scf_type :: STR

      n :: INT
      R :: REAL

      stdout.flush
      stdout.text("_refine_special_details")
      stdout.text(";")
      stdout.text("  .  Hirshfeld atom refinement:")
      stdout.text("     .  Uses aspherical atomic scattering factors")
      stdout.text("        obtained from Hirshfeld partitioning of a ")
      stdout.text("        gaussian quantum chemical wavefunction.")
      stdout.text("     .  Hirshfeld weight functions obtained from")
      stdout.text("        spherically averaged unrestricted atomic")
      stdout.text("        densities.")
      stdout.text("  .  Wavefunction type : "//trim(scf_type))
      stdout.text("  .  Gaussian basis set: "//trim(basis))
      stdout.text("  .  Refinement based on |F| with weight=1/sigma(|F|)")
      stdout.text("  .  Negative |F|^^2 were pruned from the data")
      stdout.text("  .  |F| < "//trim(.F_sigma_cutoff.to_str("f5.1"))//" sigma(|F|) were pruned from the data")
      stdout.text("  .  Eigenvalues < "//trim(.tol_near_0.to_str("e9.1"))//" removed from normal equations")
      stdout.text("  .  Reflection used in the refinement appear below")
      stdout.text("  .  Refined using the Tonto program:")
      stdout.text("     .  Version: "//TONTO_VERSION//" ($Rev$)")
      stdout.text("     .  Platform: "//TONTO_PLATFORM)
      stdout.text("     .  Build-date: "//TONTO_BUILD_DATE)
      stdout.text(";")

      stdout.flush

      stdout.text("_refine_ls_structure_factor_coef        F")
      stdout.text("_refine_ls_matrix_type                  full")
      stdout.text("_refine_ls_weighting_details            'w=1/\s(F)'")

      if (.refine_H_ADPs) then
         if (.refine_positions_and_ADPs) &
         stdout.text("_refine_ls_hydrogen_treatment           refall")
         if (.refine_ADPs_only) &
         stdout.text("_refine_ls_hydrogen_treatment           refU")
      else
         if (.refine_positions_only) then
         stdout.text("_refine_ls_hydrogen_treatment           refxyz")
         else
         stdout.text("_refine_ls_hydrogen_treatment           constr")
         end
      end

      stdout.text("_refine_ls_extinction_method            none")
      n = .reflections.dim
      stdout.text("_refine_ls_number_reflns                "//trim(n.to_str))
      stdout.text("_refine_ls_number_parameters            "//trim(.n_param.to_str))
      stdout.text("_refine_ls_number_restraints            0")
      stdout.text("_refine_ls_number_constraints           "//trim(.n_near_0.to_str))
      R = .F_r_factor
      stdout.text("_refine_ls_R_factor_all                 "//trim(R.to_str("f10.4")))
      R = .F_weighted_r_factor
      stdout.text("_refine_ls_wR_factor_ref                "//trim(R.to_str("f10.4")))
      stdout.text("_refine_ls_goodness_of_fit_ref          "//trim(.chi2.to_str("f10.4")))
      stdout.text("_refine_ls_shift/su_max                 ?")
      stdout.text("_refine_ls_shift/su_mean                ?")

   end

   put_cif_reflections
   ! Put data information in CIF format

      i :: INT

      stdout.flush
      stdout.text("loop_")
      stdout.text("    _diffrn_refln_index_h")
      stdout.text("    _diffrn_refln_index_k")
      stdout.text("    _diffrn_refln_index_l")
      stdout.text("    _diffrn_refln_F_meas")
      stdout.text("    _diffrn_refln_F_sigma")

      do i = 1,.reflections.dim
         stdout.put(.reflections(i).h)
         stdout.put(.reflections(i).k)
         stdout.put(.reflections(i).l)
         stdout.put(.reflections(i).F_exp)
         stdout.put(.reflections(i).F_sigma)
         stdout.flush
      end

   end

!  *******************
!  Tests for existence
!  *******************

   reflection_data_exists result (res)
   ! Return TRUE if reflection data exists
      res :: BIN
      res = associated(.reflections)
   end

   have_F_exp result (res)
   ! Return TRUE if have some experimental structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_exp
   end

   have_F_calc result (res)
   ! Return TRUE if have some calculated structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_calc
   end

   have_F_pred result (res)
   ! Return TRUE if have some predicted structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_pred
   end

   have_F_sigma result (res)
   ! Return TRUE if have some structure factor errors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_sigma
   end

   use_multiple_scale_factors result (res)
   ! Return TRUE if we are supposed to use multiple scale factors.
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = any(.reflections.group>0)
   end

!*******************************************************************************
!                     Inherited reflection routines
!*******************************************************************************

   n_refl result (res)
   ! The number of reflections
      res :: INT
   ENSURE(.reflections.created, "no reflection data")
      res = .reflections.n_refl
   end

   F_calc result (res)
   ! The calculated structure factors
      res :: VEC{CPX}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_calc
   end

   F_pred result (res)
   ! The predicted structure factors
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_pred
   end

   F_sigma result (res)
   ! The structure factor errors
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_sigma
   end

   F_exp result (res)
   ! The experimental structure factors
      res :: VEC{REAL}(size(.reflections))
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_exp
   end

   set_F_calc(F_calc)
   ! Set the calculated structure factors
      F_calc :: VEC{CPX}, IN
   ENSURE(.reflection_data_exists,"no reflection data")
      .reflections.set_F_calc(F_calc)
   end

   F_chi2 result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_chi2
   end

   F_goodness_of_fit result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_goodness_of_fit
   end

   F_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_r_factor
   end

   F_weighted_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_weighted_r_factor
   end

   F_val_r_factor(core_reflection) result (res) 
   ! Valence r factor . The set of "core_reflections" must be supplied.
      self :: IN
      core_reflection :: VEC{REFLECTION}
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.F_val_r_factor(core_reflection)
   end

   I_chi2 result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_chi2
   end

   I_goodness_of_fit result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_goodness_of_fit
   end

   I_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_r_factor
   end

   I_weighted_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.reflection_data_exists,"no reflection data")
      res = .reflections.I_weighted_r_factor
   end

   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.
   ENSURE(.reflection_data_exists,"no reflection data")
   ENSURE(.have_F_exp,"no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")
      F_exp :: VEC{REAL}*
      n :: INT
      chi2,z :: REAL
      stdout.flush
      stdout.text("Adding simulated errors to F_exp using F_sigma.")
      F_exp.create(.n_refl)
      F_exp = .reflections.F_exp
      .reflections.simulate_new_F_exp
      chi2=ZERO
      do n=1,.n_refl
       z=(F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
       chi2 = chi2 + z*z
      end
      chi2 = chi2 / max(.n_refl - 1,1)
      stdout.text("chi^2 of old F_exp to new F_exp is " // trim(chi2.to_str))
      stdout.flush
      stdout.dash(real_fields=4)
      stdout.put("F_exp (old)")
      stdout.put("F_exp (new)")
      stdout.put("F_sigma")
      stdout.put("dF/sigma")
      stdout.flush
      stdout.dash(real_fields=4)
      do n=1,.n_refl
       z=(F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
       stdout.put(F_exp(n))
       stdout.put(.reflections(n).F_exp)
       stdout.put(.reflections(n).F_sigma)
       stdout.put(z)
       stdout.flush
      end
      stdout.dash(real_fields=4)
      F_exp.destroy
   end

end
