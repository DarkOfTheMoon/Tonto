!-------------------------------------------------------------------------------
!
! DIFFRACTION_DATA: Diffraction data structure for crystals
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module DIFFRACTION_DATA

   implicit none

   saved_self :: DIFFRACTION_DATA*, private

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========================
!  Create and destroy methods
!  ==========================

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the diffraction data object

      nullify(.reflections)

      nullify(.scale_factors)

      nullify(.refine_U_iso_for_atom)
      nullify(.refine_3rd_order_for_atom)
      nullify(.refine_4th_order_for_atom)
      nullify(.refine_atom_parameters)

      nullify(.fit_table)
      nullify(.ref_table)

      nullify(.dX)
      nullify(.X_fit)
      nullify(.X_fit0)
      nullify(.X_ref)
      nullify(.X_ref0)

      nullify(.near_0_eigenvalues)
      nullify(.near_0_eigenvectors)

      nullify(.esd)
      nullify(.covariance_matrix)
      nullify(.correlation_matrix)
      nullify(.fragment_covariance_matrix)

   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information

      ! Reflection related data
      .destroy_reflection_data

      ! Refinement/fit related data
      .refine_U_iso_for_atom.destroy 

      .refine_3rd_order_for_atom.destroy 
      .refine_4th_order_for_atom.destroy 
      .refine_atom_parameters.destroy 

      ! Least-squares-related data
      .destroy_LS_rigid_fit_data
      .destroy_LS_refinement_data

   end

   destroy_reflection_data ::: leaky
   ! Erase all reflection data

      if (.reflections.created) then

         .scale_factor = ONE
         .exp_scale_factor = ONE
         .extinction_factor = ZERO
         .reflections.destroy
         .scale_factors.destroy

      end

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(data) ::: leaky
   ! Set self to be crystal.
      data :: DIFFRACTION_DATA, IN

      self = data

      .nullify_ptr_part

      ! Reflection-related data
      if (data.reflections.created)                .reflections.create_copy(data.reflections)
      if (data.scale_factors.created)              .scale_factors.create_copy(data.scale_factors)

      if (data.refine_U_iso_for_atom.created)      .refine_U_iso_for_atom.create_copy(data.refine_U_iso_for_atom)
      ! Refinement/fit related data

      if (data.refine_3rd_order_for_atom.created)  .refine_3rd_order_for_atom.create_copy(data.refine_3rd_order_for_atom)
      if (data.refine_4th_order_for_atom.created)  .refine_4th_order_for_atom.create_copy(data.refine_4th_order_for_atom)
      if (data.refine_atom_parameters.created)     .refine_atom_parameters.create_copy(data.refine_atom_parameters)

      if (data.fit_table.created)                  .fit_table.create_copy(data.fit_table)
      if (data.ref_table.created)                  .ref_table.create_copy(data.ref_table)

      if (data.dX.created)                         .dX.create_copy(data.dX)
      if (data.X_fit.created)                      .X_fit.create_copy(data.X_fit)
      if (data.X_fit0.created)                     .X_fit0.create_copy(data.X_fit0)
      if (data.X_ref.created)                      .X_ref.create_copy(data.X_ref)
      if (data.X_ref0.created)                     .X_ref0.create_copy(data.X_ref0)

      if (data.near_0_eigenvalues.created)         .near_0_eigenvalues.create_copy(data.near_0_eigenvalues)
      if (data.near_0_eigenvectors.created)        .near_0_eigenvectors.create_copy(data.near_0_eigenvectors)

      if (data.esd.created)                        .esd.create_copy(data.esd)
      if (data.covariance_matrix.created)          .covariance_matrix.create_copy(data.covariance_matrix)
      if (data.correlation_matrix.created)         .correlation_matrix.create_copy(data.correlation_matrix)
      if (data.fragment_covariance_matrix.created) .fragment_covariance_matrix.create_copy(data.fragment_covariance_matrix)
   
   end

!  ===========
!  Set methods
!  ===========

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self
   end

   set_from_saved_self ::: get_from(OBJECT)
   ! Set from saved_self
   end

   set_defaults ::: leaky
   ! Set up a default diffraction_data object

      .destroy_reflection_data

      ! Set the data kind
      .data_kind              = " "

      ! Experimental data
      .wavelength             = DIFFRACTION_DATA_WAVELENGTH
      .temperature            = ZERO
      .NKA_T_sequence_no      = 0

      ! Data treatment options
      .obs_on sigma_cutoff    = DIFFRACTION_DATA_OBS_ON_SIGMA_CUTOFF
      .z_statistic_cutoff     = -ONE
      .stl_cutoff             = -ONE
      .show_rejects           = TRUE

      ! Structure factor calculation parameters
      .partition_model        = DIFFRACTION_DATA_PARTITION_MODEL
      .thermal_smearing_model = DIFFRACTION_DATA_THERMAL_SMEARING_MODEL
      .use_Voronoi_atoms      = FALSE

      ! Experimental corrections
      .exp_scale_factor       = ONE
      .optimise_extinction    = DIFFRACTION_DATA_OPTIMISE_EXTINCTION
      .extinction_factor      = DIFFRACTION_DATA_EXTINCTION_FACTOR
      .correct_dispersion     = DIFFRACTION_DATA_CORRECT_DISPERSION

      ! Agreement statistics
      .n_param                  = 0
      .chi2                     = ZERO

      ! Refine/fit switches
      .fit_structure            = FALSE
      .refine_structure         = FALSE
      .refine_positions_only    = FALSE
      .refine_ADPs_only         = FALSE
      .refine_H_ADPs            = TRUE
      .refine_H_U_iso           = FALSE
      .refine_anharmonicity     = FALSE
      .restart_HAR_with_promolecule = FALSE

      ! Refine/fit iteration termination
      .max_iterations           = DIFFRACTION_DATA_MAX_ITER
      .min_iterations           = DIFFRACTION_DATA_MIN_ITER  
      .max_allowed_param_shift  = DIFFRACTION_DATA_MAX_ALLOWED_SHIFT

      ! Least squares options (zero/near zero eigenvalues)
      .tol_for_shift_on_esd     = DIFFRACTION_DATA_TOL_FOR_SHIFT_ON_ESD
      .tol_0                    = DIFFRACTION_DATA_TOL_0
      .tol_near_0               = DIFFRACTION_DATA_TOL_NEAR_0

      ! Refinement/fit output control
      .show_fit_output             = FALSE
      .display_near_0_eigenvectors = FALSE
      .display_correlation_matrix  = FALSE
      .min_correlation             = DIFFRACTION_DATA_MIN_CORRELATION

      ! Set the for a LS rigid-atom fit
      .destroy_LS_rigid_fit_data
      .set_LS_rigid_fit_data

      ! Set the for a LS refinement
      .destroy_LS_refinement_data
      .set_LS_refinement_data

   end

   update(unit_cell,spacegroup)
   ! Update the crystal information after setting values. If the
   ! "unit_cell" is provided, then that is used to define the reflection
   ! .theta values.
      unit_cell :: UNIT_CELL, optional
      spacegroup :: SPACEGROUP, optional
 
      ! Any reflections?
      if (.reflections.destroyed) return
 
      ! If reflections are to be manuially scaled
      if (.reflections.have_obs AND NOT .exp_scale_factor.equals(ONE)) then
         .reflections.scale_obs_and_sigma(.exp_scale_factor)
         .exp_scale_factor = ONE
      end

      if (present(unit_cell))  .set_theta_angles(unit_cell.reciprocal_matrix)

      if (present(spacegroup)) .set_equivalence_factors(spacegroup)

   end

   set_data_kind(kind) 
   ! Set the kind of reflection data that is being used.
      kind :: STR, IN

      .data_kind = kind

      .data_kind.to_lower_case

      select case (.data_kind)
         case ("free-neutron-f")
         case ("free-neutron-f2")
         case ("free-pnd-f")
         case ("free-x-ray-f")
         case ("free-x-ray-f2")
         case ("neutron-f")
         case ("neutron-f2")
         case ("pnd-f")
         case ("x-ray-f")
         case ("x-ray-f2")
         case default; UNKNOWN(.data_kind)
      end
   
   end

   set_obs_on_sigma_cutoff(val) 
   ! Set the obs/sigma cutoff to use for rejecting weak reflections.
      val :: REAL, IN

   DIE_IF(val<=ZERO,"cutoff must be positive")

      .obs_on_sigma_cutoff = val

   end

   set_z_statistic_cutoff(val) 
   ! Set the z_statistic_cutoff to use for rejecting weak reflections.
      val :: REAL, IN

   DIE_IF(val<=ZERO,"cutoff must be positive")

      .z_statistic_cutoff = val

   end

   set_equivalence_factors(spacegroup) 
   ! Set the equivalence factors, the number of distinct reflections
   ! which are symmetry equivalent to a particular (hkl) triple, for all
   ! the reflections.
      spacegroup :: SPACEGROUP 

   ENSURE(.reflections.created,"no reflection data")

      hkl,new :: VEC{INT}(3)
      n,s,u,n_refl :: INT

      n_refl = .reflections.n_refl

      do n = 1,n_refl

         hkl = .reflections.indices(n)

         ! Count the times (hkl) maps to itself
         u = 1
         do s = 2,spacegroup.n_seitz
            new = int(matmul(REALIFY(hkl),spacegroup.seitz(1:3,1:3,s)))
            if (hkl(1)/=new(1) OR hkl(2)/=new(2) OR hkl(3)/=new(3)) u = u + 1
         end

         .reflections(n).equivalence_factor = spacegroup.n_seitz/u

      end
   
   end

   set_theta_angles(reciprocal_matrix)
   ! This routine is called after the reflections are read in, in order to set
   ! all the .theta values, which are used later all over the place ...
      reciprocal_matrix :: MAT{REAL}(3,3)

      hkl,k :: VEC{INT}(3)
      ,sin_theta :: REAL
      n :: INT

      do n = 1,.reflections.n_refl

         hkl = .reflections.indices(n)
 
         K.to_product_of(reciprocal_matrix,hkl)
 
         sin_theta = HALF* K.norm * .wavelength
         .reflections(n).theta = asin(sin_theta)

      end

   end

   set_refine_structure(val)
   ! Generic set
      val :: BIN

      .refine_structure = val

      ! If refining you can't be fitting
      if (val) .fit_structure = NOT val 

   end

   set_fit_structure(val)
   ! Generic set
      val :: BIN

      .fit_structure = val

      ! If fitting, you can't be refining
      if (NOT val) .refine_structure = NOT val

   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: PTR
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)

         case ("}                             ")  ! exit read_loop

         case ("correct_dispersion=           "); .read_correct_dispersion

         case ("data_kind=                    "); .read_data_kind
         case ("debug_off                     "); .read_debug_off
         case ("debug_on                      "); .read_debug_on
         case ("destroy_reflection_data       "); .destroy_reflection_data

         case ("exp_scale_factor=             "); .read_exp_scale_factor

         case ("junk=                         "); .read_junk

         case ("make_predictions              "); .make_predictions

         case ("nka_t_sequence_no=            "); .read_NKA_T_seq_no

         case ("obs_on_sigma_cutoff=          "); .read_obs_on_sigma_cutoff
         case ("optimise_extinction=          "); .read_optimise_extinction
         case ("optimize_extinction=          "); .read_optimise_extinction

         case ("partition_model=              "); .read_partition_model
         case ("prune_bad_reflections         "); .prune_bad_reflections
         case ("prune_high_angle_reflections  "); .prune_high_angle_reflections
         case ("prune_low_angle_reflections   "); .prune_low_angle_reflections
         case ("prune_negative_reflections    "); .prune_negative_F_reflections
         case ("prune_weak_reflections        "); .prune_weak_reflections
         case ("put                           "); .put
         case ("put_debug_list                "); .put_debug_list
         case ("put_sin_theta_on_lambda       "); .put_sin_theta_on_lambda

         case ("read_cif                      "); .read_CIF
         case ("redirect                      "); .redirect
         case ("refine_3rd_order_for_atoms=   "); .read_refine_3rd_order
         case ("refine_4th_order_for_atoms=   "); .read_refine_4th_order
         case ("refine_adps_only=             "); .read_refine_ADPs_only
         case ("refine_h_adps=                "); .read_refine_H_ADPs
         case ("refine_h_u_iso=               "); .read_refine_H_U_iso
         case ("refine_positions_only=        "); .read_refine_positions_only
         case ("refine_u_iso_for_atoms=       "); .read_refine_U_iso_atoms
         case ("reflection_data=              "); .read_reflection_data
         case ("restart_har_with_promolecule= "); .read_restart_with_promolecule
         case ("revert                        "); .revert

         case ("show_rejects=                 "); .read_show_rejects
         case ("stl_cutoff=                   "); .read_stl_cutoff

         case ("thermal_smearing_model=       "); .read_thermal_smearing_model
         case ("temperature=                  "); .read_temperature

         case ("units=                        "); .read_units
         case ("use_voronoi_atoms=            "); .read_use_Voronoi_atoms

         case ("wavelength=                   "); .read_wavelength


         case ("z_statistic_cutoff=           "); .read_z_statistic_cutoff
         case ("zero_negative_obs             "); .zero_negative_obs

         case default;                       UNKNOWN(word)

      end

   end

! Reading

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

   read_data_kind
   ! Read the kind of diffraction data kind obtained in the experiment
      kind :: STR

      stdin.read(kind)

      .set_data_kind(kind)

   end

   read_obs_on_sigma_cutoff ::: private
   ! Read obs_on_sigma_cutoff

      val :: REAL

      stdin.read(val)

      .set_obs_on_sigma_cutoff(val)

   end

   read_z_statistic_cutoff ::: private
   ! Read the z_statistic_cutoff for prune_bad_reflections

      val :: REAL

      stdin.read(val)

      .set_z_statistic_cutoff(val)

   end

   read_stl_cutoff ::: private
   ! Read the stl_cutoff for prune_high_angle_reflections

      stdin.read(.stl_cutoff)

      ENSURE(.stl_cutoff>=ZERO,"must be positive")

   end

   read_show_rejects ::: private
   ! Read wether to show the rejected reflections
      stdin.read(.show_rejects)
   end

   read_exp_scale_factor ::: private
   ! Read the structure factor multiplier
      stdin.read(.exp_scale_factor)
   end

   read_wavelength ::: private
   ! Read the experimental wavelength
      stdin.read_quantity(.wavelength)
   end

   read_optimise_extinction ::: private
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.optimise_extinction)
   end

   read_correct_dispersion ::: private
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model ::: private
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      select case (.thermal_smearing_model)
         case("         ")
         case("none     ")
         case("coppens  ")
         case("hirshfeld")
         case("stewart  ")
         case("tanaka   ")
         case default;    UNKNOWN(.thermal_smearing_model)
      end
   end

   read_partition_model ::: private
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
      .partition_model.to_lower_case
      select case(.partition_model)
         case("        ")
         case("none    ")
         case("mulliken")
         case("gaussian")
         case default;    UNKNOWN(.partition_model)
      end
   end

   zero_negative_obs ::: leaky
   ! This routine zero's negative observations, and adjusts the sigma
   ! to be appropriately larger. This is intended for use with
   ! structure factor maghnitude data, |F|'s.
      self :: PTR

   DIE_IF(NOT .reflections.created,"no reflection data")
   DIE_IF(NOT .reflections.have_F_exp,"no experimental data")

      n_refl,i :: INT
      ref :: REFLECTION*

      n_refl = .reflections.n_refl

      do i = 1,n_refl

         ref => .reflections(i)

         if (ref.obs < ZERO) then
            ref.sigma = ref.sigma + abs(ref.obs)
            ref.obs   = ZERO
         end

      end

   end

   read_temperature
   ! Read the temperature
      stdin.read(.temperature)
      ENSURE(.temperature>=0,"temperature is not positive!")
   end

   read_NKA_T_seq_no
   ! Read the temperature sequence no for NKA output file
      stdin.read(.NKA_T_sequence_no)
      ENSURE(.NKA_T_sequence_no>0,"sequence no is not positive!")
   end

   read_reflection_data ::: leaky, private
   ! Read in reflection data in the standard order from "stdin".
      DIE_IF(.data_kind==" ","Use data_kind= to say the kind data to be inputted")
      .reflections.read_list_keywords
   end


   read_refine_ADPs_only
   ! Read whether to refine only the ADP's
      stdin.read(.refine_ADPs_only)
   end

   read_refine_H_ADPs
   ! Read whether to refine only the H atom ADP's
      stdin.read(.refine_H_ADPs)
   end

   read_refine_H_U_iso
   ! Read whether to refine only the H atom U_iso's
      stdin.read(.refine_H_U_iso)
   end

   read_refine_positions_only
   ! Read whether to refine only the atom positions
      stdin.read(.refine_positions_only)
   end

   read_refine_3rd_order ::: leaky
   ! Read the list of atoms for which third-order anharmonicty
   ! parameters are to be refined.
      stdin.read_ptr(.refine_3rd_order_for_atom)
      .refine_anharmonicity = TRUE
   end

   read_refine_4th_order ::: leaky
   ! Read the list of atoms for which fourth-order anharmonicty
   ! parameters are to be refined.
      stdin.read_ptr(.refine_4th_order_for_atom)
      .refine_anharmonicity = TRUE
   end

   read_refine_U_iso_atoms ::: leaky
   ! Read the list of atoms refined isotropically
      stdin.read_ptr(.refine_U_iso_for_atom)
      stdout.text("Check input")
      stdout.put(.refine_U_iso_for_atom)
   end

   read_use_Voronoi_atoms
   ! Read whether to use Voronoi atoms in refinement
      stdin.read(.use_Voronoi_atoms)
   end

   read_restart_with_promolecule ::: leaky
   ! Read whether to restart with promolecule initial guess.
      stdin.read(.restart_HAR_with_promolecule)
   end


! ========
! Read CIF
! ========

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File
   ! with the "name" taken from stdin.

      name :: STR
      found :: BIN
      cif :: CIF*

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif,n_pADPs) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN
      n_pADPs :: INT, IN, optional

      ! Read reflections
      .read_CIF_reflections(cif)

      ! Read covariance matrix
      if (present(n_pADPs)) .read_CIF_covariance(cif,n_pADPs)

   end

   read_CIF_reflections(cif) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN

      there :: VEC{BIN}(5)
      h,k,l :: VEC{INT}*
      Fm,Sg,cov :: VEC{REAL}*

      ! Find reflections
      cif.find_looped_item("_diffrn_refln_index_h",there(1))
      cif.find_looped_item("_diffrn_refln_index_k",there(2))
      cif.find_looped_item("_diffrn_refln_index_l",there(3))
      cif.find_looped_item("_diffrn_refln_F_meas" ,there(4))
      cif.find_looped_item("_diffrn_refln_F_sigma",there(5))

      ! Read reflections
      if (all(there)) then

         ! Read
         cif.read_looped_item("_diffrn_refln_index_h",h)
         cif.read_looped_item("_diffrn_refln_index_h",k)
         cif.read_looped_item("_diffrn_refln_index_h",l)
         cif.read_looped_item("_diffrn_refln_F_meas" ,Fm)
         cif.read_looped_item("_diffrn_refln_F_sigma",Sg)

         ! Create and assign
         .reflections.create(h.dim)
         .reflections.set_h(h)
         .reflections.set_k(k)
         .reflections.set_l(l)
         .reflections.set_F_exp(Fm)
         .reflections.set_F_sigma(Sg)

         ! Clean
         Sg.destroy; Fm.destroy
         l.destroy; k.destroy; h.destroy

      end

   end

   read_CIF_covariance(cif,n_pADPs) ::: leaky
   ! Read information from a Crystallographic Information File "cif".
      cif :: CIF, IN
      n_pADPs :: INT, IN

      there :: VEC{BIN}(5)
      h,k,l :: VEC{INT}*
      Fm,Sg,cov :: VEC{REAL}*
      np :: INT

      ! Find Tonto asymmetric unit covariance matrix
      cif.find_item("_covariance_matrix",there(1))

      ! Read reflections -- must have n_pADPs
      if (there(1)) then

         ! Dimension
         np = n_pADPs

         ! Create
         .covariance_matrix.create(np,np)

         ! Read and set
         cov.create(np*np)
         cif.read_item("_covariance_matrix",cov)
         .covariance_matrix = reshape(cov,[np,np])

         ! Clean
         cov.destroy

      end

   end


! ===================
! Pruning reflections
! ===================

   prune ::: template
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
      self :: PTR

   ENSURE(.created,"No data")
   ENSURE(.reflections.created,"No reflection data")
   ENSURE(.reflections.have_F_exp,"No experimental data")

      old_reflections :: VEC{REFLECTION}*
      good,bad :: VEC{INT}*
      n_refl,n,i,ib,g,b :: INT
      title :: STR

      ! No. of old reflections
      n_refl = .reflections.n_refl

      ! Find out how many rejects "n" there are
      n = 0
      do i = 1,n_refl
         if (NOT .reflections(i).TEST?(CUTOFF?)) cycle
         n = n + 1
      end

      ! Are there any weak reflections?
      if (n==0) return

      ! Create the "good" and "bad" lists and how many of each
      bad.create(n)
      good.create(n_refl-n)
      g = 0
      b = 0
      do i = 1,n_refl
         if (.reflections(i).TEST?(CUTOFF?)) then
            b = b + 1
            bad(b) = i
         else
            g = g + 1
            good(g) = i
         end
      end

      ! Copy the non-rejects
      old_reflections => .reflections
      .reflections.create(g)
      .reflections.copy(old_reflections(good))

      ! Print out
      stdout.flush
      title = "Reflections pruned"

      stdout.text(repeat("=",len_trim(title)))
      stdout.text(trim(title))
      stdout.text(repeat("=",len_trim(title)))

      ! Banner
      stdout.flush
      stdout.show("Rejection criteria      =","TEST?")
      stdout.show("Cutoff                  =",CUTOFF?)
      stdout.flush
      stdout.show("No. of reflections      =",n_refl)
      stdout.show("No. of rejects          =",b)
      stdout.show("No. of kept reflections =",g)

      if (.show_rejects) then

         stdout.flush
         stdout.text("Table of rejects:")
         stdout.dash(int_fields=3,real_fields=1)
         stdout.put("h",int_width=TRUE)
         stdout.put("k",int_width=TRUE)
         stdout.put("l",int_width=TRUE)
         stdout.put(SHOW?)
         stdout.flush
         stdout.dash(int_fields=3,real_fields=1)
         stdout.flush
         do i = 1,b
            ib = bad(i)
            stdout.put(old_reflections(ib).h)
            stdout.put(old_reflections(ib).k)
            stdout.put(old_reflections(ib).l)
            stdout.put(old_reflections(ib).SHOW?)
            stdout.flush
         end
         stdout.dash(int_fields=3,real_fields=1)

      end

      ! Clean
      old_reflections.destroy
      bad.destroy
      good.destroy

   end

   prune_bad_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_z_statistic, CUTOFF?=>.z_cutoff, SHOW?=>"Z stat"), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_high_angle_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_high_stl, CUTOFF?=>.stl_cutoff, SHOW?=>"stl"), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_low_angle_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>has_low_stl, CUTOFF?=>.stl_cutoff SHOW?=>"stl"), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_negative_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>is_weak_obs, CUTOFF?=>ZERO, SHOW?=>"Obs"), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end

   prune_weak_reflections ::: get_from(DIFFRACTION_DATA:prune, TEST?=>is_weak_obs, CUTOFF?=>.obs_on_sigma_cutoff, SHOW?=>"Obs/sigma"), leaky
   ! This routine eliminates all the reflections with respect to a
   ! rejection test on the reflections
   end


!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end


!  ===========
!  Intensities
!  ===========

   lp_factor result (res)
   ! Return the array of the Lorentz Polarization factors for all the
   ! reflections
      res :: VEC{REAL}(size(.reflections))

   ENSURE(.reflections.created,"no reflection data")

      n_refl,n :: INT
      c,s,two_theta :: REAL

      n_refl = .reflections.n_refl

      do n = 1,n_refl

         two_theta = TWO*.reflections(n).theta
         c = cos(two_theta)
         s = sin(two_theta)

         if (s.is_zero(TOL(8))) then
            res(n) = ZERO
            WARN("lp_factor for (000) reflection set to zero")
         else
            res(n) = (1+c*c)/(TWO*s)
         end

      end

   end


! New

!  ==========
!  Model F's
!  ==========

   make_xray_F_pred ::: leaky
   ! Make predicted X-ray F's by optimizing all requested experimental
   ! parameters.

      ! Initialize (leaky)
      .init_xray_F

      ! Do the least squares (leaky)
      .set_saved_self
      .LS_corrections.do_fit(::put_xray_F_to,::put_xray_dF_to,::set_xray_F_params_to)

   end

! F set/put routines

   init_xray_F ::: leaky
   ! Initialize least-squares for fitting X-ray F's with experimental
   ! phenomenological parameters.

   ENSURE(.data_kind=="xray-f","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   DIE_IF(NOT .reflections.have_obs,"no F_obs")
   DIE_IF(NOT .reflections.have_sigma,"no F_sigma")

      n_g,n_p,n_d :: INT
      X,Y0,sigma :: VEC{REAL}*
      X_labels :: VEC{STR}*

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs
      n_d = .reflections.dim

      ! Reset scale factors
      .scale_factors.destroy
      .scale_factors.create(n_g)
      .scale_factors = ONE

      ! Reset extinction
      .Larsen_extinction_factor = ZERO

      ! Create parameter vector and labels
      X.create(n_p)
      X_label.create(n_p)

      ! Set parameter vector and labels
      do p = 1,n_p
         X(p) = .scale_factors(p)                   
         X_labels(p) = "Scale factor "//trim(p.to_str)
      end
      if (.use_Larsen_extinction) then
         X(n_p)       = .Larsen_extinction_factor
         X_label(n_p) = "Larsen extinction factor"
      end

      ! Initialize F data
      Y0.create(n_d)
      sigma.create(n_d)
      .reflections.put_obs_to(Y0)
      .reflections.put_sigma_to(sigma)

      ! Set up least squares
      .LS_corrections.create
      .LS_corrections.initialize(X,Y0,sigma,X_labels)

      ! Clean
      sigma.destroy
      Y0.destroy
      Y.destroy
      X_label.destroy
      X.destroy

   end

   set_xray_F_params_to(X) ::: selfless
   ! Set the non-pADP parameters for predicting x-ray F's to "X"
   ! This version for least-squares optimization.
      X :: VEC{REAL}, OUT

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Set parameters
      .set_xray_F_params(X)

   end

   set_xray_F_params(X)
   ! Set the non pADP parameters for predicting x-ray F's to "X"
      X :: VEC{REAL}, OUT

   ENSURE(.data_kind=="xray-f","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   ENSURE(X.dim==.no_of_non_pADPs,"wrong size, X")

      n_g,n_p :: INT

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs

      ! Set scale factors
      do p = 1,n_g
         .scale_factors(p) = X(p)
      end

      ! Set extinction parameter
      if (.use_Larsen_extinction) then
         .Larsen_extinction_factor = X(n_p)
      end

   end

   put_xray_F_to(Y) ::: selfless
   ! Make and put the *predicted* x-ray F's in "Y"
   ! This version for least-squares optimization.
      Y :: VEC{REAL}, OUT

      self :: DIFFRACTION_DATA*

      ! Recover self
      .set_from_saved_self

      ! Get F_pred
      .put_F(Y)

   end

   put_xray_F(Y)
   ! Make and put the *predicted* x-ray F's in "Y"
   ! NOTE: This routine sets .reflections(:).pred
   ! NOTE: Also sets reflections(:).cal to abs(reflections(:).calc)
      Y :: VEC{REAL}, OUT

      F,C,ext :: VEC{REAL}*
      n_d :: INT

      ! No. of data
      n_d = Y.dim

      ! Set F_cal = |F_calc|
      ! >> NOTE: calc must be set <<
      .reflections.set_cal_to_abs_calc

      ! Temporaries
      F.create(n_d)
      C.create(n_d)

      ! Get the (uncorrected) values
      .reflections.put_cal_to(F)

      ! Get experimental corrections
      .put_scale_correction_to(C)
      if (.use_Larsen_extinction) then
         ext.create(n_d)
         .put_Larsen_correction_to(ext,.Larsen_extinction_factor)
         C = ext*C
         ext.destroy
      end

      ! Apply corrections
      Y = C*F

      ! >> Set predicted data <<
      .reflections.set_pred_to(Y)

      ! Clean
      C.destroy
      F.destroy

   end

   put_xray_dF_to(dY) ::: selfless
   ! Make and put the derivative of the *predicted* x-ray F's in "dY"
   ! This version for least-squares optimization.
      dF_pred :: MAT{REAL}, OUT

      self :: DIFFRACTION_DATA*

      .set_from_saved_self

      ! Get F_pred derivatives
      .put_dF_pred(dY)

   end

   put_xray_dF(dY)
   ! Make and put the derivative of the *predicted* x-ray F's in "dY"
      dY :: MAT{REAL}, OUT

      n_p,n_g :: INT

      ! No. of data
      n_p = dY.dim2
      n_g = .reflections.no_of_groups

      ! Set scale derivatives
      .put_dF_dscales(dY(:,1:n_g))

      ! Set extinction correction
      if (.use_Larsen_extinction) .put_dF_dLarsen(dY(:,n_p))

   end

! Larsen extinction correction for F's

   put_dF_dLarsen(dF)
   ! Get derivative of structure factor magnitudes wrt Larsen
   ! extinction parameter in "dF(n_refl,1)"
      dF :: VEC{REAL}, OUT

   ENSURE(dF.dim1==saved_self.reflections.dim1,"wrong dim1, dF")
   ENSURE(dF.dim2==1,"wrong dim2, dF")

      dL,s :: VEC{REAL}*
      n_d :: INT

      ! No. of data
      n_d = dF.dim1

      ! Get scale correction only
      s.create(n_d)
      .put_scale_correction_to(s,.scale_factors)

      ! Get derivative extinction correction
      dL.create(n_d)
      .put_dLarsen_correction_to(dL)

      ! Get derivatives
      dF(:,1) = s(:) * dL(:)

      ! Clean
      dL.destroy
      s.destroy

   end

   put_Larsen_correction_to(C,extinction_factor) ::: private
   ! Return the Larsen extinction correction in "C".
   ! NOTE: F_cal must be set to abs(F_calc).
      C :: VEC{REAL}, OUT
      extinction_factor :: REAL, IN

   ENSURE(C.dim==.reflections.dim1,"wrong dim1, dF")

      F_abs2,F_abs,val :: REAL
      angle_part :: VEC{REAL}*
      n,n_refl :: INT

      if (extinction_factor.is_zero(TOL(9))) then

         C = ONE

      else

         ! Get the angle part
         angle_part.create(n_refl)
         .put_Larsen_angle_part_to(angle_part)

         ! Make Larsen correction without scale factors
         do n = 1,.reflections.dim

            F_abs  = .reflections(n).cal
            F_abs2 = F_abs*F_abs

            val    = ONE + extinction_factor*F_abs2*angle_part(n)
            val    = ONE/sqrt(sqrt(val))

            C(n)   = val

         end

         ! Clean
         angle_part.destroy

      end

   end

   put_dLarsen_correction_to(dC) ::: private
   ! Return the derivative Larsen extinction correction in "res".
   ! NOTE: F_cal must be set to abs(F_calc).
      dC :: VEC{REAL}, OUT

   ENSURE(dC.dim==.reflections.dim1,"wrong dim1, dF")

      F_abs2,F_abs,val,ang :: REAL
      angle_part :: VEC{REAL}*
      g,n :: INT

      if (.Larsen_extinction_factor.is_zero(TOL(9))) then

         res = ZERO

      else

         ! Get the Larsen angle part
         angle_part.create(n_refl)
         .put_Larsen_angle_part_to(angle_part)

         do n = 1,.reflections.dim

            F_abs  = .reflections(n).cal
            F_abs2 = F_abs*F_abs
    
            ang = angle_part(n)

            val = ONE + .Larsen_extinction_factor*F_abs2*ang
            val = ONE/val

            dC(n) = -HALF * extinction_correction * sqrt(F_abs2*sqrt(val)) * val * ang

         end

         ! Clean
         angle_part.destroy

      end

   end

   put_Larsen_angle_part_to(res) ::: private
   ! Return the angular part of the Larsen extinction correction.
      res :: VEC{REAL}, OUT

      n :: INT
      twotheta,c,s :: REAL

      do n = 1,.reflections.dim

         twotheta = TWO*.reflections(n).theta

         c = cos(twotheta)
         s = sin(twotheta)

         res(n) = (ONE+c*c)/(ONE+c*s)

      end

   end


!  ==========
!  Model F2's
!  ==========

   make_F2_predicted ::: leaky
   ! Make predicted x-ray F2's by optimizing all requested experimental
   ! parameters. NOTE: extinction not available yet.

   ENSURE(.data_kind=="xray-f2","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")

      n_g,n_p,n_d :: INT
      X,Y,Y0,sigma :: VEC{REAL}*
      X_labels :: VEC{STR}*

      ! Get no. of parameters
      n_g = .reflections.no_of_groups
      n_p = .no_of_non_pADPs
      n_d = .reflections.dim

      ! Reset scale factors
      .scale_factors.destroy
      .scale_factors = ONE

      ! Create parameter vector and labels
      X.create(n_p)
      X_label.create(n_p)

      ! Set parameter vector and labels
      do p = 1,n_p
         X(p) = .scale_factors                   
         X_labels(p) = "Scale factor "//trim(p.to_str)
      end

      ! Initial predicted values
      Y.create(n_d)
      .put_F2_pred_to(Y)

      ! Initialize observation data
      Y0.create(n_d)
      sigma.create(n_d)
      .reflections.put_obs_to(Y0)
      .reflections.put_sigma_to(sigma)

      ! Set up least squares
      .LS_corrections.create
      .LS_corrections.initialize(X,Y,Y0,sigma,X_labels)

      ! Clean
      sigma.destroy
      Y0.destroy
      Y.destroy
      X_label.destroy
      X.destroy

      ! Do the least squares
      .set_saved_self
      .LS_corrections.do_fit(::put_F2_pred_to,::put_dF2_pred_to,::set_F2_non_pADPs_to)

   end

   set_F2_non_pADPs_to(X) ::: selfless
   ! Set the F2 non pADP parameters to "X".
   ! This version for least-squares optimization.
      X :: VEC{REAL}, OUT

      self :: DIFFRACTION_DATA*

      .set_from_saved_self

      ! Set parameters
      .set_F2_non_pADPs_to(X)

   end

   set_F2_non_pADPs_to(X)
   ! Set the F2 non pADP parameters to "X"
      X :: VEC{REAL}, OUT

   ENSURE(.data_kind=="xray-f","wrong data_kind, "//trim(.data_kind))
   ENSURE(.reflections.created,"no reflections")
   ENSURE(X.dim==.no_of_non_pADPs,"wrong size, X")

      n_g :: INT

      ! Get no. of parameters
      n_g = .reflections.no_of_groups

      ! Set scale factors
      do p = 1,n_g
         .scale_factors(p) = X(p)
      end

   end

   put_F2_pred_to(Y) ::: selfless
   ! Get the current *predicted* F2's in "Y"
   ! This version for least-squares optimization.
      Y :: VEC{REAL}, OUT

      self :: DIFFRACTION_DATA*

      .set_from_saved_self

      ! Get F2_pred
      .put_F2_pred_to(Y)

   end

   put_F2_pred_to(Y)
   ! Get the current *predicted* F2's in "Y"
   ! NOTE: This routine sets .reflections(:).pred
   ! NOTE: Also sets reflections(:).cal to |reflections(:).calc|^2
      Y :: VEC{REAL}, OUT

      F2,C,ext :: VEC{REAL}*
      n_d :: INT

      ! No. of data
      n_d = Y.dim

      ! NOTE: Set F_cal = |F_calc|^2
      .reflections.set_cal_to_abs_calc_2

      ! Temporaries
      F2.create(n_d)
      C.create(n_d)

      ! Get the (uncorrected) values
      .reflections.put_cal_to(F2)

      ! Get experimental corrections
      .put_scale_correction_to(C)

      ! Apply corrections
      Y = C*F2

      ! Set predicted data
      .reflections.set_pred_to(Y)

      ! Clean
      C.destroy
      F.destroy

   end

   put_dF2_pred_to(dY) ::: selfless
   ! Get the derivative of the predicted F2's in "dY"
   ! This version for least-squares optimization.
      dY :: MAT{REAL}, OUT

      self :: DIFFRACTION_DATA*

      .set_from_saved_self

      ! Get F_pred derivatives
      .put_dF2_pred_to(dY)

   end

   put_dF2_pred_to(dY)
   ! Get the derivative of the predicted F2's in "dY"
      dY :: MAT{REAL}, OUT

      F2,C,ext :: VEC{REAL}*
      n_d,n_g :: INT

      ! No. of data
      n_d = dY.dim1
      n_g = .reflections.no_of_groups

      ! Set scale derivatives
      .put_dF2_dscales(dY)

      ! Temporaries
      F2.create(n_d)
      C.create(n_d,n_g)

      ! Get the (uncorrected) values
      .reflections.put_cal_to(F2)

      ! Get experimental corrections
      .put_scale_correction_to(C)

      ! Apply corrections
      F_pred = C*F2

      ! Set predicted data
      .reflections.set_pred_to(F_pred)

      ! Clean
      C.destroy
      F2.destroy

   end


! =======================================
! Scale corrections (same for all models)
! =======================================

   put_dF_dscales(dF)
   ! Get derivative of structure factor magnitudes wrt scale factors
   ! in "dF(n_refl,n_group)"
      dF :: VEC{REAL}, OUT

   ENSURE(dF.dim1==.reflections.dim1,"wrong dim1, dF")
   ENSURE(dF.dim2==.reflections.no_of_groups,"wrong dim2, dF")

      ext :: VEC{REAL}*
      n_p,n_d :: INT

      ! No. of parameters
      n_d = dF.dim1
      n_p = dF.dim2

      ! Get extinction corrections only
      ext.create(n_d)
      ext = ONE
      .put_Larsen_correction_to(ext,.extinction_factor)

      ! Get derivatives
      do g = 1,n_p
      do n = 1,n_d

         if (.reflections(n).group==g) then
            dF(n,g) = ext(n) * .reflections(n).F_cal
         else
            dF(n,g) = ZERO
         end

      end
      end

      ! Clean
      ext.destroy

   end

   put_scale_correction_to(C,scale_factors) ::: private
   ! Return experimental scale factor correction in "C".
      C :: VEC{REAL}, OUT
      scale_factors :: VEC{REAL}, IN

      n_group,n_refl :: INT

      ! Sizes
      n_group = .reflections.no_of_groups
      n_refl  = .reflections.dim

      ! Make scale factor correction
      do g = 1,n_group
      do n = 1,n_refl
      
         if (.reflections(n).group/=g) cycle
      
         C(n) = scale_factors(g)
      
      end
      end

   end


!  =====================
!  Parameters to refine?
!  =====================

   no_of_non_pADPs result (res) 
   ! Return the number of parameters which are *not* positions or
   ! ADPs which are refined, e.g. scale factors and extinction.
      res :: INT

   ENSURE(.data_kind/=" ","no data kind set")

      select case (.data_kind)

         case ("free-neutron-f","neutron-f")
            DIE("not implemented")

         case ("free-neutron-f2","neutron-f2")
            DIE("not implemented")

         case ("free-pnd-f","pnd-f")
            DIE("not implemented")

         case ("free-x-ray-f","x-ray-f")
            res = .reflections.no_of_groups
            if (.use_Larsen_extinction) res = res + 1

         case ("free-x-ray-f2","x-ray-f2")
            res = .reflections.no_of_groups
            ! Extinction not available yet

         case default
            UNKNOWN(.data_kind)

      end
   
   end
 
   refine_positions_and_ADPs result (res)
   ! A refinement of all positions and ADP's
      res :: BIN
      res =   NOT .refine_positions_only &
          AND NOT .refine_ADPs_only 
   end
 
   refine_3rd_order result (res)
   ! Refineme third-order anharmonicity for any atoms?
      res :: BIN
      res =  .refine_3rd_order_for_atom.created
   end
 
   refine_4th_order result (res)
   ! Refineme fourth-order anharmonicity for any atoms?
      res :: BIN
      res =  .refine_4th_order_for_atom.created
   end
 
   no_of_3rd_order_atoms result (res)
   ! The number of atoms on which there are third-order anharmonicity
   ! parameters
      res :: INT
      res = 0
      if (.refine_3rd_order_for_atom.created) res = .refine_3rd_order_for_atom.dim
   end
 
   no_of_4th_order_atoms result (res)
   ! The number of atoms on which there are third-order anharmonicity
   ! parameters
      res :: INT
      res = 0
      if (.refine_4th_order_for_atom.created) res = .refine_4th_order_for_atom.dim
   end

! Old

!  =============================
!  Least-squares: initialization
!  =============================

   destroy_LS_rigid_fit_data ::: leaky
   ! Erase rigid-atom fit arrays

      .fit_table.destroy

      .dX.destroy
      .X_fit.destroy
      .X_fit0.destroy

      .near_0_eigenvalues.destroy
      .near_0_eigenvectors.destroy

      .esd.destroy
      .covariance_matrix.destroy
      .correlation_matrix.destroy
      .fragment_covariance_matrix.destroy

   end

   destroy_LS_refinement_data ::: leaky
   ! Erase the refinement arrays

      .ref_table.destroy

      .X_ref.destroy
      .X_ref0.destroy

   end


   set_rigid_fit_data(n_p,n_f,labels) ::: leaky
   ! Create the rigid-atom-fit data arrays & initialize if needed.
   ! "n_p" is the number of unique pADP's to refine.
   ! "n_f" is the number of non-unique fragment atom pADP's.
   ! Some of these arrays will already be created if refining.
      n_p,n_f :: INT, IN
      labels :: VEC{STR}, IN

      ! Make sure we are at least doing a rigid fit ...
      if (NOT .refine_structure) .set_fit_structure(TRUE)

      ! Reset fit data 
      .destroy_LS_fit_data
      .set_LS_rigid_fit_data

      ! Initially chi^2 is as big as you can get
      .chi2_fit0 = huge(ONE)

      ! Set the uique # of parameters. Used for getting the correct
      ! chi^2 statistic. Note: zero eigenvalues in the least squares
      ! will modify this value.
      .n_param = n_p

      ! Create parameter vectors & shifts (leaky)
      .dX.create(n_p)
      .X_fit.create(n_p)
      .X_fit0.create(n_p)

      ! Create esd's and covariances
      .esd.create(n_p)
      .covariance_matrix.create(n_p,n_p)
      .correlation_matrix.create(n_p,n_p)
      .fragment_covariance_matrix.create(n_f,n_f)

      ! Set esd's to zero
      .esd = ZERO

      ! Set up rigid-fit table headings
      .set_LS_rigid_fit_table(labels)

   end

   set_LS_rigid_fit_data 
   ! Set the defaults internal variables for a fit

      ! Refinement/fit iteration data
      .fit_iteration           = 0
      .chi2_fit                = ZERO
      .chi2_fit0               = ZERO
      .max_shift               = ZERO
      .max_shift_on_esd        = ZERO
      .max_shift_on_esd_ind    = 0
      .max_shift_on_esd_par    = " "
      .fit_converged           = FALSE
      .chi2_increased          = FALSE
      .too_many_fit_iterations = FALSE

      ! Near zero eigenvalues in the least-squares
      .n_0                 = 0
      .n_near_0            = 0

   end

   set_LS_rigid_fit_data(n_p,n_f) ::: leaky
   ! Create the rigid-atom-fit data arrays & initialize if needed.
   ! "n_p" is the number of unique pADP's to refine.
   ! "n_f" is the number of non-unique fragment atom pADP's.
      n_p,n_f :: INT, IN

      ! Reset fit data 
      .destroy_LS_fit_data
      .set_LS_rigid_fit_data

      ! Initially chi^2 is as big as you can get
      .chi2_fit0 = huge(ONE)

      ! Set the uique # of parameters. Used for getting the correct
      ! chi^2 statistic. Note: zero eigenvalues in the least squares
      ! will modify this value.
      .n_param = n_p

      ! Create parameter vectors & shifts (leaky)
      .dX.create(n_p)
      .X_fit.create(n_p)
      .X_fit0.create(n_p)

      ! Create esd's and covariances
      .esd.create(n_p)
      .covariance_matrix.create(n_p,n_p)
      .correlation_matrix.create(n_p,n_p)
      .fragment_covariance_matrix.create(n_f,n_f)

      ! Set esd's to zero
      .esd = ZERO

   end

   set_LS_rigid_fit_table(n_p,n_f,labels) ::: leaky
   ! Create the rigid-fit table for output.
   ! "labels" are descriptors for the refined parameters.
      labels :: VEC{STR}, IN

      ! Create the table (leaky)
      .fit_table.create(8)

      ! Fit table headings
      .fit_table(1).set_heading("Fit")
      .fit_table(1).set_subhead("Iter")
      .fit_table(2).set_heading("chi2")
      .fit_table(3).set_heading("R")
      .fit_table(4).set_heading("R_w")
      .fit_table(5).set_heading("Max.")
      .fit_table(5).set_subhead("Shift")
      .fit_table(5).set_sb3head("/esd")
      .fit_table(6).set_heading("Max.")
      .fit_table(6).set_subhead("Shift")
      .fit_table(6).set_sb3head("param")
      .fit_table(7).set_heading("No. of")
      .fit_table(7).set_subhead("params")
      .fit_table(8).set_heading("No. of")
      .fit_table(8).set_subhead("eig's")
      .fit_table(8).set_sb3head("near 0")

      ! Table widths (needs to be here because of label width)
      .fit_table(1).set_width_from(.max_iterations) ! Iter
      .fit_table(2).set_width_from(TEN**3)          ! chi2
      .fit_table(3).set_width_from(ONE)             ! R
      .fit_table(4).set_width_from(ONE)             ! Rw
      .fit_table(5).set_width_from(TEN*TEN)         ! Max shift/esd
      .fit_table(6).set_width_from(labels)          ! Max shift par
      .fit_table(7).set_width(3)                    ! n_param
      .fit_table(8).set_width(3)                    ! n_near_0

   end


   set_refinement_data(n_p,labels) ::: leaky
   ! Create the refinement data arrays & initialize if needed
   ! "n_p" is the number of parameters to refine.
   ! "labels" are descriptors for the refined parameters.
      n_p :: INT, IN
      labels :: VEC{STR}, IN

   ENSURE(.ref_iteration==0,"ref_iteration is not 0!")

      ! Set up LS arrays
      .set_LS_refinement_data(n_p)

      ! Set up refinement table headings
      .set_LS_refinement_table(labels) 

   end

   set_LS_refinement_data 
   ! Set the defaults internal variables for a refinement

      ! Refinement/fit iteration data
      .ref_iteration           = 0
      .chi2_ref                = ZERO
      .chi2_ref0               = ZERO
      .max_refshift            = ZERO
      .max_refshift_on_esd     = ZERO
      .max_refshift_on_esd_ind = 0
      .max_refshift_on_esd_par = " "
      .refinement_converged    = FALSE
      .too_many_ref_iterations = FALSE

   end

   set_LS_refinement_data(n_p) ::: leaky
   ! Create the least-squares refinement data arrays & initialize.
   ! "n_p" is the number of parameters to refine.
      n_p :: INT, IN

   ENSURE(.ref_iteration==0,"ref_iteration is not 0!")

      ! Destroy existing data (leaky)
      .destroy_LS_refinement_data
      .set_LS_refinement_data

      ! Initially chi^2 is as big as you can get
      .chi2_ref0 = huge(ONE)

      ! Create parameter vectors (leaky)
      .X_ref.create(n_p)
      .X_ref0.create(n_p)

   end

   set_LS_refinement_table(labels) ::: leaky
   ! Create the refinement table for output.
   ! "labels" are descriptors for the refined parameters.
      labels :: VEC{STR}, IN

   ENSURE(.ref_iteration==0,"ref_iteration is not 0!")

      ! Refinement table headings
      .ref_table.create(9)
      .ref_table(1).set_heading("Ref.")
      .ref_table(1).set_subhead("Iter")
      .ref_table(2).set_heading("No of")
      .ref_table(2).set_subhead("  Fit")
      .ref_table(2).set_sb3head("iters")
      .ref_table(3).set_heading("chi2")
      .ref_table(3).set_subhead("initial")
      .ref_table(4).set_heading("chi2")
      .ref_table(4).set_subhead("final")
      .ref_table(5).set_heading("R")
      .ref_table(6).set_heading("R_w")
      .ref_table(7).set_heading("Max.")
      .ref_table(7).set_subhead("Shift")
      .ref_table(7).set_sb3head(" /esd")
      .ref_table(8).set_heading("Max.")
      .ref_table(8).set_subhead("Shift")
      .ref_table(8).set_sb3head("param")
      .ref_table(9).set_heading("No. of")
      .ref_table(9).set_subhead("params")

      ! Table widths (needs to be here because of label width)
      .ref_table(1).set_width_from(.max_iterations) ! Iter
      .ref_table(2).set_width_from(.max_iterations) ! # of fit iters
      .ref_table(3).set_width_from(TEN**3)          ! chi2 initial
      .ref_table(4).set_width_from(TEN**3)          ! chi2 final
      .ref_table(5).set_width_from(ONE)             ! R
      .ref_table(6).set_width_from(ONE)             ! Rw
      .ref_table(7).set_width_from(TEN*TEN)         ! Max shift/esd
      .ref_table(8).set_width_from(labels)          ! Max shift par
      .ref_table(9).set_width(3)                    ! n_param

   end




!  Fit/refinement iteration control

   update_fit_parameters
   ! Update i.e. increment the fit parameters

      ! Next iteration
      .fit_iteration = .fit_iteration + 1

      ! Save and increment parameters
      .X_fit0 = .X_fit
      .X_fit  = .X_fit + .dX

   end

   update_refinement_parameters
   ! Update the refinement parameters

      ! Increment 
      .ref_iteration = .ref_iteration + 1
 
      ! Transfer parameters
      .X_ref0 = .X_ref ! From previous or 1st iteration
      .X_ref  = .X_fit ! This iteration

   end

!  Fit/refinement iteration control
 
   fit_finished result (res)
   ! Return whether the (rigid) HA refinement has finished
      res :: BIN

      ! Converged?
      .fit_converged = .max_shift_on_esd<.tol_for_shift_on_esd &
                       AND .fit_iteration>=.min_iterations

      ! chi2 inceased?
      .chi2_increased = .chi2_fit>.chi2_fit0 AND .fit_iteration>.min_iterations

      ! debug
      if (.debugging("fit_finished")) then
         stdout.text("In fit finished:")
         stdout.text("chi2_fit0 ="//trim(.chi2_fit0.to_str))
         stdout.text("chi2_fit  ="//trim(.chi2_fit.to_str ))
      end

      ! Roll back the parameters is chi2 increases
      ! WARNING: covariances are not rolled back ...
    ! if (.chi2_increased) then
    !    .X_fit    = .X_fit0
    !    .chi2_fit = .chi2_fit0
    ! end

      ! Too many fit iterations?
      .too_many_fit_iterations = .fit_iteration>.max_iterations

      ! Set finished
      res = .fit_converged OR .chi2_increased OR .too_many_fit_iterations

      ! If refining, store initial & final chi2
      if (.refine_structure) then
         if (.fit_iteration==1) .chi2_ref0 = .chi2_fit ! Store initial chi2
         if (res)               .chi2_ref  = .chi2_fit ! Stoire final chi2
      end

   end
 
   refinement_finished result (res)
   ! Return whether the refinement has finished
      res :: BIN

      ! Has fit finished?
      .refinement_converged = .max_refshift_on_esd<.tol_for_shift_on_esd &
                            AND .ref_iteration>=.min_iterations

      ! Too many refinement iterations?
      .too_many_ref_iterations = .ref_iteration>.max_iterations

      ! Set finished; finish also if chi2 increases in fit iteration
      res = .refinement_converged OR .chi2_increased OR .too_many_ref_iterations

   end

!  Fit/refinement output

   put_fit_header ::: selfless
   ! Put the fit header
      stdout.flush
      stdout.text("===================================")
      stdout.text("Crystal structure fit (rigid atoms)")
      stdout.text("===================================")
      stdout.flush
      stdout.text("A single SCF/rigid hirshfeld atom fit is performed.")
      stdout.flush
      stdout.text("Consider non-rigid hirshfeld_atom_refinement instead.")
   end

   put_refinement_header ::: selfless
   ! Put the fit header

      stdout.flush
      stdout.text("==============================================")
      stdout.text("Crystal structure refinement (non-rigid atoms)")
      stdout.text("==============================================")

      stdout.flush
      stdout.text("Repeated SCF/rigid hirshfeld atom fits are performed")
      stdout.text("which eventually removes the rigid atom constraint.")

      stdout.flush
      stdout.text("Agreement statistics are shown at the start and end")
      stdout.text("of each 'micro' rigid fit cycle.")

      stdout.flush
      stdout.text("Convergence criteria for each fit-cycle are the same")
      stdout.text("as for convergence of the overall refinement")

   end

   put_refinement_switches
   ! Put the refinement switches

      stdout.flush
      stdout.show("Refine hydrogen ADP's       =",.refine_H_ADPs)
      stdout.show("Refine hydrogen U_iso       =",.refine_H_U_iso)
      stdout.show("Refine only ADP's           =",.refine_ADPs_only)
      stdout.show("Refine only positions       =",.refine_positions_only)

      if (.refine_anharmonicity) then
      stdout.flush
      stdout.show("Refine anharmonicity        =",TRUE)
      stdout.show("Anharmonic atoms            =",TRUE)
      end

      stdout.flush
      stdout.show("Refine multiple scales      =",.use_multiple_scale_factors)
      stdout.show("Refine extinction parameter =",.optimise_extinction)

      stdout.flush
      stdout.show("Max allowed parameter shift =",.max_allowed_param_shift)
      stdout.show("Max iterations              =",.max_iterations)
      stdout.show("Min iterations              =",.min_iterations)

      stdout.flush
      stdout.show("Conv. tol. for shift on esd =",.tol_for_shift_on_esd)
      stdout.show("Zero eigenvalue tolerance   =",.tol_0)
      stdout.show("Nearly zero tolerance       =",.tol_near_0)

   end

   put_fit_table_headings
   ! Put the fit table header

      stdout.flush
      stdout.text("====================")
      stdout.text("Begin rigid-atom fit")
      stdout.text("====================")
      stdout.flush

      ! Put table headings
      .fit_table.put_headings

   end

   put_refinement_table_headings
   ! Put the refinement table header

      stdout.flush
      stdout.text("================")
      stdout.text("Begin refinement")
      stdout.text("================")
      stdout.flush

      ! Put table headings
      .ref_table.put_headings

   end

   put_fit_table_body
   ! Print the current iterations results

      ! Set table body (leaky)
      .fit_table(1).create_values([.fit_iteration])
      .fit_table(2).create_values([.chi2_fit])
      .fit_table(3).create_values([.F_r_factor])
      .fit_table(4).create_values([.F_weighted_r_factor])
      .fit_table(5).create_values([.max_shift_on_esd])
      .fit_table(6).create_values([.max_shift_on_esd_par])
      .fit_table(7).create_values([.n_param])
      .fit_table(8).create_values([.n_near_0])

      ! Put out the body
      .fit_table.put_body

      ! Clear thje columns for next time (UNleaky!)
      .fit_table.clear_columns

   end

   put_refinement_table_body
   ! Print the current iterations results

      ! Set table body (leaky)
      .ref_table(1).create_values([.ref_iteration])
      .ref_table(2).create_values([.fit_iteration])
      .ref_table(3).create_values([.chi2_ref0])
      .ref_table(4).create_values([.chi2_ref])
      .ref_table(5).create_values([.F_r_factor])
      .ref_table(6).create_values([.F_weighted_r_factor])
      .ref_table(7).create_values([.max_refshift_on_esd])
      .ref_table(8).create_values([.max_refshift_on_esd_par])
      .ref_table(9).create_values([.n_param])

      ! Put out the body
      .ref_table.put_body

      ! Clear thje columns for next time (UNleaky!)
      .ref_table.clear_columns

   end

   put_fit_results
   ! Put the fit-iteration footer and fit results

      ! Table footer
      .fit_table.put_footer

      ! Results
      stdout.flush
      stdout.text("======================")
      stdout.text("Rigid-atom fit results")
      stdout.text("======================")
      stdout.flush

      ! Print how it finished
      if      (.fit_converged)            then; stdout.text("Structure fit converged.")
      else if (.chi2_increased)           then; stdout.text("WARNING: fit stopped: chi2 has increased.")
                                                stdout.text("WARNING: fit results are unreliable.")
      else if (.too_many_fit_iterations)  then; stdout.text("WARNING: fit stopped: too many iterations.")
      end

      ! Put final fitting statistics
      .reflections.put_F_statistics(show_chi2=FALSE)
      stdout.show("# of fit parameters, N_p    =", .n_param)
      stdout.show("chi^2(N_p)                  =",.chi2)
      stdout.show("Goodness of fit (N_p)       =", sqrt(.chi2))
      stdout.show("Effective (mean) sigma^2    =",.reflections.sigma2_eff)

      ! Analysis
      stdout.flush
      stdout.text("An analysis of the fit is in the file 'stdout.fit_analysis'")

   end

   put_refinement_results
   ! Put the iteration footer and refinement results

      ! Table footer
      .ref_table.put_footer

      ! Results
      stdout.flush
      stdout.text("============================")
      stdout.text("Structure refinement results")
      stdout.text("============================")
      stdout.flush

      ! Print how it finished
      if      (.refinement_converged)     then; stdout.text("Structure refinement converged.")
      else if (.chi2_increased)           then; stdout.text("WARNING: refinement stopped: chi2 has increased.")
      else if (.too_many_ref_iterations)  then; stdout.text("WARNING: refinement stopped: too many iterations.")
      end

      ! Put final fitting statistics
      .reflections.put_F_statistics(show_chi2=FALSE)
      stdout.show("# of fit parameters, N_p    =", .n_param)
      stdout.show("chi^2(N_p)                  =",.chi2)
      stdout.show("Goodness of fit (N_p)       =", sqrt(.chi2))
      stdout.show("Effective (mean) sigma^2    =",.reflections.sigma2_eff)

      ! Analysis
      stdout.flush
      stdout.text("An analysis of the fit is in the file 'stdout.fit_analysis'")

   end

   put_near_0_eigenvectors
   ! Put the near zero (linearly dependent) parameter eigenvectors

      if (.near_0_eigenvectors.created) then
      if (.near_0_eigenvectors.dim>0) then

         stdout.flush
         stdout.text("Near 0 eigenvalues of the normal matrix:")
         stdout.put(.near_0_eigenvalues)
         stdout.flush
         stdout.text("Near 0 eigenvectors of the normal matrix:")
         stdout.put(.near_0_eigenvectors)

      end
      end

   end


!  ==============
!  Output methods
!  ==============

   put
   ! Put out the diffraction data to file "out"

      stdout.flush
      stdout.text("Diffraction information:")
      stdout.show("data_kind                     =", .data_kind)

      if (.reflections.created) then
      stdout.text("Reflection data:")
      stdout.flush
      .put_reflection_data
      end

   end

   put_reflection_data
   ! Output the reflection data

   ENSURE(.reflections.created,"no reflections")

      if (.have_calc OR .have_pred) .put_correction_data

      .reflections.put

   end

!   put_sin_theta_on_lambda
!   ! Output sin(theta)/lambda for all reflections.
!   ENSURE(.reflections.created,"No list of reflections")
!   ENSURE(.reflections.have_indices,"No list of reflections")
!      n :: INT
!
!      REFLECTION:set_wavelength(.wavelength)
!
!      stdout.text("sin(theta)/lambda for the reflections")
!      stdout.dash(int_fields=3,real_fields=1)
!      stdout.put("h",int_width=TRUE)
!      stdout.put("k",int_width=TRUE)
!      stdout.put("l",int_width=TRUE)
!      stdout.put("stl")
!      stdout.flush
!      stdout.dash(int_fields=3,real_fields=1)
!      do n=1,size(.reflections)
!         stdout.put(.reflections(n).h)
!         stdout.put(.reflections(n).k)
!         stdout.put(.reflections(n).l)
!         stdout.put(.reflections(n).sin_theta_on_lambda)
!         stdout.flush
!      end
!      stdout.dash(int_fields=3,real_fields=1)
!
!   end

   put_statistics(show_chi2)
   ! Output the structure factor goodness of fit statistics.
      show_chi2 :: BIN, optional

      select case (.data_kind)
         case ("free-neutron-f");  .reflections.put_statistics("Free Neutron F's",show_chi2)
         case ("free-neutron-f2"); .reflections.put_statistics("Free Neutron F2's",show_chi2)
         case ("free-pnd-f");      .reflections.put_statistics("Free PND F's",show_chi2)
         case ("free-x-ray-f");    .reflections.put_statistics("Free X-ray F's",show_chi2)
         case ("free-x-ray-f2");   .reflections.put_statistics("Free X-ray F2's",show_chi2)
         case ("neutron-f");       .reflections.put_statistics("Neutron F's",show_chi2)
         case ("neutron-f2");      .reflections.put_statistics("Neutron F2's",show_chi2)
         case ("pnd-f");           .reflections.put_statistics("PND F's",show_chi2)
         case ("x-ray-f");         .reflections.put_statistics("X-ray F's",show_chi2)
         case ("x-ray-f2");        .reflections.put_statistics("X-ray F2's",show_chi2)
         case default; UNKNOWN(.data_kind)
      end

   end

   put_F2_free_stats
   ! Output the F2 goodness of fit statistics
      .reflections.put_F2_free_stats
      .put_correction_data
   end

   put_correction_data
   ! Output the correction data

      stdout.flush
      stdout.show("Using extinction               =", .optimise_extinction)
      stdout.show("Thermal smearing model         =", .thermal_smearing_model)
      stdout.show("Fragment partition model       =", .partition_model)
      stdout.show("Correct dispersion?            =", .correct_dispersion)

      if (.optimise_extinction) then;
      stdout.show("Optimize extinction            =", TRUE)
      stdout.show("Secondary extinction factor    =", .extinction_factor)
      else
      stdout.show("Optimize extinction            =", FALSE)
      end

      if (.use_multiple_scale_factors) then
      stdout.show("Using multiple scale factors   =", TRUE)
      stdout.show("Scale factors                  =", .scale_factors)
      else
      stdout.show("Using single scale factor      =", TRUE)
      stdout.show("Scale factor                   =", .scale_factors(1))
      end

   end

   put_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.put_qq_plot
   end

   put_labelled_qq_plot
   ! Output a qq plot to stdout.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.reflections.created, "no reflection data")
      .reflections.put_labelled_qq_plot
   end

   put_chi2_vs_angle_plot
   ! Output a table with the chi2 for the structure factor data set
   ! broken into 20 sections.
      num_sections :: INT
      n,num,k,n_refl :: INT
      section_for :: VEC{INT}*
      stl,stl_min,stl_max,chi2,width,stl_mean :: REAL

      num_sections = 20
      n_refl = .reflections.n_refl
      REFLECTION:set_wavelength(.wavelength)

      ! Work out the limits of the sin(theta)/lambda.
      stl_min = 1000
      stl_max = ZERO
      do n =1,n_refl
         stl = .reflections(n).sin_theta_on_lambda
         if (stl < stl_min) stl_min = stl
         if (stl > stl_max) stl_max = stl
      end
      width = (TOL(3) + stl_max - stl_min)/num_sections

      section_for.create(n_refl)
      ! Determine which section each reflection belongs to.
      do n = 1,n_refl
         stl = .reflections(n).sin_theta_on_lambda
         section_for(n) = ceiling((TOL(3) + stl - stl_min) / width)
      end

      stdout.flush
      stdout.text("Chi^2 vs angle plot")
      stdout.flush
      stdout.text("sin(theta)/lambda in Angstrom^(-1)")
      stdout.show("Smallest sin(theta)/lambda  =",stl_min)
      stdout.show("Largest sin(theta)/lambda   =",stl_max)
      stdout.flush
      stdout.put("stl")
      stdout.put("chi^2")
      stdout.flush
      stdout.dash(real_fields=2)

      do n = 1, num_sections

         chi2 = ZERO
         num = 0
         stl_mean = stl_min + (n - HALF) * width
         do k = 1, n_refl
           if (n==section_for(k)) then
             chi2 = chi2 + .reflections(k).z_statistic_squared
             num = num + 1
           end
         end

         stdout.put(stl_mean)

         if (num==0) then
           stdout.flush
           cycle
         else
           chi2 = chi2 / max(num - .n_param,1)
           stdout.put(chi2)
           stdout.flush
         end

      end

      stdout.flush

      section_for.destroy

   end

   put_pred_vs_obs_plots
   ! Output some different plots about the obs vs. predicted structure factors.
      ext :: VEC{REAL}*
      ext_refs :: VEC{REFLECTION}*
      n,n_refl :: INT
      y,w :: REAL

      n_refl = .reflections.n_refl
      REFLECTION:set_wavelength(.wavelength)

      stdout.text("The effects of angle.")
      stdout.text("Scatter plot of z = (pred-obs)/sigma vs. sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(.reflections(n).z_statistic)
         stdout.flush
      end
      stdout.flush

      stdout.text("The effects of angle.")
      stdout.text("Scatter plot of Delta = (pred-obs) vs. sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(.reflections(n).delta)
         stdout.flush
      end
      stdout.flush

      stdout.text("The effects of intensity.")
      stdout.text("Scatter plot of z = (pred-obs)/sigma vs obs")
      do n = 1,n_refl
         stdout.put(.reflections(n).obs)
         stdout.put(.reflections(n).z_statistic)
         stdout.flush
      end
      stdout.flush

      ext_refs.create(n_refl)
      ext.create(n_refl)
      ext = .F_extinction_correction
      ext_refs.set_F_exp(.reflections.F_pred)
      ext_refs.set_F_pred(.reflections.F_pred * ext)
      ext_refs.set_F_sigma(.reflections.F_sigma)
      ext.destroy

      if (NOT .optimise_extinction) return

      stdout.text("The effects of extinction.")

      w = ZERO
      y = ZERO
      do n=1,n_refl
       y = y + abs(ext_refs(n).F_z)
       w = w + abs(ext_refs(n).F_r)
      end
      y = y / n_refl
      w = w / n_refl
      stdout.show("Average value of abs[Fcalc(with ext)-Fcalc(without ext)]/F_sigma is ",y)
      stdout.show("Average value of abs(extinction correction) is ",w)
      stdout.flush

      stdout.text("The effects of intensity on extinction.")
      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/F_sigma vs F_pred")
      do n=1,n_refl
       stdout.put(ext_refs(n).F_pred)
       stdout.put(ext_refs(n).F_z)
       stdout.flush
      end
      stdout.flush

      stdout.text("The effects of scattering angle on extinction.")
      stdout.text("Scatter plot of [Fcalc(with ext)-Fcalc(without ext)]/F_sigma vs sin(theta)/lambda")
      do n = 1,n_refl
         stdout.put(.reflections(n).sin_theta_on_lambda)
         stdout.put(ext_refs(n).F_z)
         stdout.flush
      end
      ext_refs.destroy

      stdout.flush
   end

   put_PND_sf(name)
   ! Output the magnetic structure factors
       name :: STR
       FM_s,FM_l :: VEC{CPX}*
       arch :: ARCHIVE
        n :: INT
       FM_s.create(.reflections.n_refl)
       arch.set(name,"PND_spin_sf")
       arch.read(FM_s)
       FM_l.create(.reflections.n_refl)
       arch.set(name,"PND_nabla_sf")
       arch.read(FM_l)
       stdout.text("PND magnetic structure factors:")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       stdout.put("h", int_width=TRUE)
       stdout.put("k", int_width=TRUE)
       stdout.put("l", int_width=TRUE)
       stdout.put("FM_s")
       stdout.put("FM_l")
       stdout.put("FM")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       do n = 1, .reflections.n_refl
          stdout.put(.reflections(n).h)
          stdout.put(.reflections(n).k)
          stdout.put(.reflections(n).l)
          stdout.put(real(FM_s(n)) )
          stdout.put(real(FM_l(n)) )
          stdout.put(real(FM_s(n)+FM_l(n)) )
          stdout.flush
       end
       stdout.dash(int_fields=3,real_fields=3)
       FM_l.destroy
       FM_s.destroy
   end

   put_CIF_refinement(basis,scf_type)
   ! Put refinement information in CIF format
   ! No refinement info. possible without reflections!
      basis,scf_type :: STR

      n :: INT
      R :: REAL

      if (.reflections.destroyed) return

      stdout.flush
      stdout.text("# ------------------")
      stdout.text("# Refinement details")
      stdout.text("# ------------------")
      stdout.flush
      stdout.text("_refine_special_details")
      stdout.text(";")
      stdout.text("  .  Hirshfeld atom refinement:")
      stdout.text("     .  Uses aspherical atomic scattering factors")
      stdout.text("        obtained from Hirshfeld partitioning of a ")
      stdout.text("        gaussian quantum chemical wavefunction.")
      stdout.text("     .  Hirshfeld weight functions obtained from")
      stdout.text("        spherically averaged unrestricted atomic")
      stdout.text("        densities.")
      stdout.text("  .  Wavefunction type : "//trim(scf_type))
      stdout.text("  .  Gaussian basis set: "//trim(basis))
      stdout.text("  .  Refinement based on |F| with weight=1/sigma(|F|)")
      stdout.text("  .  Negative |F|^^2 were pruned from the data")
      stdout.text("  .  |F| < "//trim(.F_sigma_cutoff.to_str("f5.1"))//" sigma(|F|) were pruned from the data")
      stdout.text("  .  Eigenvalues < "//trim(.tol_near_0.to_str("e9.1"))//" removed from normal equations")
      stdout.text("  .  Reflection used in the refinement appear below")
      stdout.text("  .  Refined using the Tonto program:")
      stdout.text("     .  Version: "//TONTO_VERSION//" v. "//SVN_VERSION)
      stdout.text("     .  Platform: "//TONTO_PLATFORM)
      stdout.text("     .  Build-date: "//TONTO_BUILD_DATE)
      stdout.text(";")

      stdout.flush

      stdout.text("_refine_ls_structure_factor_coef        F")
      stdout.text("_refine_ls_matrix_type                  full")
      stdout.text("_refine_ls_weighting_details            'w=1/\s(F)'")

      if (.refine_H_ADPs) then
         if (.refine_positions_and_ADPs) &
         stdout.text("_refine_ls_hydrogen_treatment           refall")
         if (.refine_ADPs_only) &
         stdout.text("_refine_ls_hydrogen_treatment           refU")
      else
         if (.refine_positions_only) then
         stdout.text("_refine_ls_hydrogen_treatment           refxyz")
         else
         stdout.text("_refine_ls_hydrogen_treatment           constr")
         end
      end

      stdout.text("_refine_ls_extinction_method            none")
      n = .reflections.dim
      stdout.text("_refine_ls_number_reflns                "//trim(n.to_str))
      stdout.text("_refine_ls_number_parameters            "//trim(.n_param.to_str))
      stdout.text("_refine_ls_number_restraints            0")
      stdout.text("_refine_ls_number_constraints           "//trim(.n_near_0.to_str))
      R = .F_r_factor
      stdout.text("_refine_ls_R_factor_all                 "//trim(R.to_str("f10.4")))
      R = .F_weighted_r_factor
      stdout.text("_refine_ls_wR_factor_ref                "//trim(R.to_str("f10.4")))
      stdout.text("_refine_ls_goodness_of_fit_ref          "//trim(.chi2.to_str("f10.4")))
      stdout.text("_refine_ls_shift/su_max                 ?")
      stdout.text("_refine_ls_shift/su_mean                ?")

   end

   put_CIF_reflections
   ! Put reflection information in CIF format

      i :: INT

      if (.reflections.destroyed) return

      stdout.flush
      stdout.text("# ---------------")
      stdout.text("# Reflection data")
      stdout.text("# ---------------")
      stdout.flush
      stdout.text("loop_")
      stdout.text("    _diffrn_refln_index_h")
      stdout.text("    _diffrn_refln_index_k")
      stdout.text("    _diffrn_refln_index_l")
      stdout.text("    _diffrn_refln_F_meas")
      stdout.text("    _diffrn_refln_F_sigma")

      do i = 1,.reflections.dim
         stdout.put(.reflections(i).h)
         stdout.put(.reflections(i).k)
         stdout.put(.reflections(i).l)
         stdout.put(.reflections(i).F_exp)
         stdout.put(.reflections(i).F_sigma)
         stdout.flush
      end

   end


!  =============================
!  Inherited reflection routines
!  =============================

   use_multiple_scale_factors result (res)
   ! Return TRUE if we are supposed to use multiple scale factors.
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = any(.reflections.group>1)
   end

   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.

   ENSURE(.reflections.created,"no reflection data")
   ENSURE(.have_F_exp,"no experimental structure factors")
   ENSURE(.have_F_sigma,"no experimental structure factor errors")

      F_exp :: VEC{REAL}*
      n_refl,n :: INT
      chi2,z :: REAL

      stdout.flush
      stdout.text("Adding simulated errors to F_exp using F_sigma.")

      n_refl = .reflections.n_refl
      F_exp.create(n_refl)
      F_exp = .reflections.F_exp

      .reflections.simulate_new_F_exp

      chi2 = ZERO
      do n = 1,n_refl
         z = (F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
         chi2 = chi2 + z*z
      end
      chi2 = chi2 / max(n_refl - 1,1)

      stdout.text("chi^2 of old F_exp to new F_exp is " // trim(chi2.to_str))
      stdout.flush
      stdout.dash(real_fields=4)
      stdout.put("F_exp (old)")
      stdout.put("F_exp (new)")
      stdout.put("F_sigma")
      stdout.put("dF/sigma")
      stdout.flush
      stdout.dash(real_fields=4)

      do n=1,n_refl
         z = (F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
         stdout.put(F_exp(n))
         stdout.put(.reflections(n).F_exp)
         stdout.put(.reflections(n).F_sigma)
         stdout.put(z)
         stdout.flush
      end

      stdout.dash(real_fields=4)
      F_exp.destroy

   end

end
