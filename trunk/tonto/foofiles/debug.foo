!---------------------------------------------------------------------------
!
! DEBUG: Debug print options ...
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: object.foo 3026 2007-03-04 10:45:02Z dylan_ $
!---------------------------------------------------------------------------

virtual module DEBUG

   implicit none

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  **************
!  Debug printing
!  **************

   read_debug_on ::: leaky
   ! Read a debug descriptor and add it to the list.
      name :: STR
      stdin.read(name)
      debug_list.append(name)
   end

   read_debug_off ::: leaky
   ! Read a debug descriptor and remove it from the list.
      name :: STR
      stdin.read(name)
      debug_list.prune(name)
   end

   debugging(name) result (res)
   ! Return TRUE if the debug switch "name" has been set.
      name :: STR
      res :: BIN
      res = FALSE
      if (debug_list.destroyed) return
      res = name.is_included_in_any(debug_list) 
   end

   put_debug_list
   ! Put of the list of debug switches
      if (debug_list.destroyed) return
      stdout.put(debug_list)
   end

   put_debug(X,name) ::: template
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
      X :: TYPE
      name :: STR
      if (NOT .debugging(name)) return
      stdout.save
      stdout.set_real_style("e")
      stdout.show(trim(name)//" = ",X)
      stdout.unsave
   end

   put_debug(X,name) ::: template
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
      X :: TYPE
      name :: STR
      if (NOT .debugging(name)) return
      stdout.save
      stdout.set_real_style("e")
      stdout.flush
      stdout.text(trim(name)//":")
      stdout.put(X)
      stdout.unsave
   end

   put_debug(X,name) ::: template
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
      X :: TYPE
      name :: STR
      if (NOT .debugging(name)) return
      stdout.save
      stdout.set_real_style("e")
      stdout.text(trim(name)//":")
      X.put
      stdout.unsave
   end

   put_debug(X,name) ::: template
   ! Put *opmatrix* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
      X :: OPMATRIX
      name :: STR
      if (NOT .debugging(name)) return
      stdout.save
      stdout.set_real_style("e")
      if (X.restricted.created) then
        stdout.flush
        stdout.text(trim(name)//", restricted:")
        stdout.put(X.restricted)
      end
      if (X.alpha.created) then
        stdout.flush
        stdout.text(trim(name)//", alpha:")
        stdout.put(X.alpha)
      end
      if (X.beta.created) then
        stdout.flush
        stdout.text(trim(name)//", beta:")
        stdout.put(X.beta)
      end
      if (X.general.created) then
        stdout.flush
        stdout.text(trim(name)//", general:")
        stdout.put(X.general)
      end
      if (X.restricted_complex.created) then
        stdout.flush
        stdout.text(trim(name)//", restricted_complex:")
        stdout.put(X.restricted_complex)
      end
      if (X.alpha_complex.created) then
        stdout.flush
        stdout.text(trim(name)//", alpha_complex:")
        stdout.put(X.alpha_complex)
      end
      if (X.beta_complex.created) then
        stdout.flush
        stdout.text(trim(name)//", beta_complex:")
        stdout.put(X.beta_complex)
      end
      if (X.general_complex.created) then
        stdout.flush
        stdout.text(trim(name)//", general_complex:")
        stdout.put(X.general_complex)
      end
      stdout.unsave
   end

end

