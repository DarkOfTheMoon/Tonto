!-------------------------------------------------------------------------------
!
! ATOM: can be a quantum mechanical atom, with a basis set
!       or a molecular mechanical atom with a force field potential
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module ATOM

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

!  ===============
!  Data statements
!  ===============

   !  The Periodic Table

   element_symbols :: VEC{STR}(len=2,-1:103)

   data element_symbols/ &
    "El","Q ", &
    "H ",                                                                                "He", &
    "Li","Be",                                                  "B ","C ","N ","O ","F ","Ne", &
    "Na","Mg",                                                  "Al","Si","P ","S ","Cl","Ar", &
    "K ","Ca","Sc","Ti","V ","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr", &
    "Rb","Sr","Y ","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I ","Xe", &
    "Cs","Ba","La",     "Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu", &
                   "Hf","Ta","W ","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn", &
    "Fr","Ra","Ac",     "Th","Pa","U ","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr"/

   element_names :: VEC{STR}(len=12,-1:103)

   data element_names/ &
    "Electron    ","Dummy       ", &
    "Hydrogen    ","Helium      ", &
    "Lithium     ","Beryllium   ", &
    "Boron       ","Carbon      ","Nitrogen    ","Oxygen      ","Fluorine    ","Neon        ", &
    "Sodium      ","Magnesium   ", &
    "Aluminium   ","Silicon     ","Phosphorous ","Sulfur      ","Chlorine    ","Argon       ", &
    "Potassium   ","Calcium     ", &
    "Scandium    ","Titanium    ","Vanadium    ","Chromium    ","Manganese   ", &
    "Iron        ","Cobalt      ","Nickel      ","Copper      ","Zinc        ", &
    "Gallium     ","Germanium   ","Arsenic     ","Selinium    ","Bromine     ","Krypton     ", &
    "Rubidium    ","Strontium   ", &
    "Yttrium     ","Zirconium   ","Niobium     ","Molybdenum  ","Technitium  ", &
    "Ruthenium   ","Rhodium     ","Palladium   ","Silver      ","Cadmium     ", &
    "Indium      ","Tin         ","Antimony    ","Tellurium   ","Iodine      ","Xenon       ", &
    "Cesium      ","Barium      ", &
    "Lanthanum   ", &
    "Cerium      ","Praseodymium","Neodymium   ","Promethium  ","Samarium    ","Europium    ","Gadolinium  ", &
    "Terbium     ","Dysprosium  ","Holmium     ","Erbium      ","Thulium     ","Ytterbium   ","Lutetium    ", &
                   "Haffnium    ","Tantalum    ","Tangsten    ","Rhenium     ", &
    "Osmium      ","Iridium     ","Platinum    ","Gold        ","Mercury     ", &
    "Thallium    ","Lead        ","Bismuth     ","Polonium    ","Astatine    ","Radon       ", &
    "Francium    ","Radium      ", &
    "Actinium    ", &
    "Thorium     ","Protactinium","Uranium     ","Neptunium   ","Plutonium   ","Americium   ","Curium      ", &
    "Berkellium  ","Californium ","Einsteinium ","Fermium     ","Mendelevium ","Nobelium    ","Lawrencium  "/

   !  Bragg-Slater radii taken from Aaron Lee's code
   !  WARNING: this is in Angstroms!

   bragg_slater_radii :: VEC{REAL}(54)

   data bragg_slater_radii/ &
      0.35d0,                                          0.35d0, &
      1.45d0,1.05d0,0.85d0,0.70d0,0.65d0,0.60d0,0.50d0,0.45d0, &
      1.80d0,1.50d0,1.25d0,1.10d0,1.00d0,1.00d0,1.00d0,1.00d0, &
      2.20d0,1.80d0, &
                    1.60d0,1.40d0,1.35d0,1.40d0,1.40d0,1.40d0,1.35d0,1.35d0,1.35d0,1.35d0, &
                    1.30d0,1.25d0,1.15d0,1.15d0,1.15d0,1.15d0, &
      1.30d0,1.30d0, &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0, &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0  /

   atom_bonded_range_factor :: REAL = 0.4d0*BOHR_PER_ANGSTROM
   atom_vdw_bonded_range_pc :: REAL = 1.0d0

   ! Covalent radii, where do they come from? in Angstrom x 100

   covalent_radii_invariom :: VEC{INT}(109)

   data covalent_radii_invariom/ &
      37,                                                                                   0, &
      123,  90,                                                    80,  77,  74,  71,  72,   0, &
      154, 136,                                                   118, 111, 106, 102,  99,   0, &
      203, 174, 144, 132, 122, 118, 117, 117, 116, 115, 117, 125, 126, 122, 120, 116, 114,   0, &
      218, 191, 162, 145, 134, 130, 127, 125, 125, 128, 134, 148, 144, 141, 140, 136, 133,   0, &
      235, 198, &
               169, 165, 165, 164, 164, 162, 185, 161, 159, 159, 157, 157, 156, 170, &
               156, 144, 134, 130, 128, 126, 127, 130, 134, 149, 148, 147, 146, 146, 145,   0, &
       0,   0, &
               188, 165, 161, 142, 130, 151, 182,   0,   0,   0,   0,   0,   0,   0, &
                 0,   0,   0,   0,   0,   0,   0 /

   ! Allred-Rochow electronegativities, where do they come from?
   ! Values x 100

   allred_rochow_electronegs :: VEC{INT}(85)
   
   data allred_rochow_electronegs/ &
      220,                                                                                 550, &
      97, 147,                                                   201, 250, 307, 350, 440, 480, &
      101, 123,                                                   147, 174, 206, 244, 283, 320, &
      91, 104, 120, 132, 145, 156, 160, 164, 170, 175, 175, 166, 182, 202, 220, 248, 274, 290, &
      89,  99, 111, 122, 123, 130, 136, 142, 145, 130, 142, 146, 149, 172, 182, 201, 221, 240, &
      86,  97, &
               108, 108, 107, 107, 107, 107, 110, 111, 110, 110, 110, 111, 111, 106, &
               114, 123, 133, 140, 146, 152, 155, 142, 142, 144, 144, 155, 167, 176, 190 /

   covalent_radii_ccdc :: VEC{REAL}(110)
   
   data covalent_radii_ccdc/ &
      0.23d0, 1.50d0, 1.28d0, 0.96d0, 0.83d0, 0.68d0, 0.68d0, 0.68d0, 0.64d0, 1.50d0, &
      1.66d0, 1.41d0, 1.21d0, 1.20d0, 1.05d0, 1.02d0, 0.99d0, 1.51d0, 2.03d0, 1.76d0, &
      1.70d0, 1.60d0, 1.53d0, 1.39d0, 1.61d0, 1.52d0, 1.26d0, 1.24d0, 1.32d0, 1.22d0, &
      1.22d0, 1.17d0, 1.21d0, 1.22d0, 1.21d0, 1.50d0, 2.20d0, 1.95d0, 1.90d0, 1.75d0, &
      1.64d0, 1.54d0, 1.47d0, 1.46d0, 1.45d0, 1.39d0, 1.45d0, 1.44d0, 1.42d0, 1.39d0, &
      1.39d0, 1.47d0, 1.40d0, 1.50d0, 2.44d0, 2.15d0, 2.07d0, 2.04d0, 2.03d0, 2.01d0, &
      1.99d0, 1.98d0, 1.98d0, 1.96d0, 1.94d0, 1.92d0, 1.92d0, 1.89d0, 1.90d0, 1.87d0, &
      1.87d0, 1.75d0, 1.70d0, 1.62d0, 1.51d0, 1.44d0, 1.41d0, 1.36d0, 1.50d0, 1.32d0, &
      1.45d0, 1.46d0, 1.48d0, 1.40d0, 1.21d0, 1.50d0, 2.60d0, 2.21d0, 2.15d0, 2.06d0, &
      2.00d0, 1.96d0, 1.90d0, 1.87d0, 1.80d0, 1.69d0, 1.54d0, 1.83d0, 1.50d0, 1.50d0, &
      1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0, 1.50d0  /

   ! Van der Waals radii from CCDC, in Angstrom

   vdw_radii_ccdc :: VEC{REAL}(110)
   
   data vdw_radii_ccdc/ &
      1.09d0, 1.40d0, 1.82d0, 2.00d0, 2.00d0, 1.70d0, 1.55d0, 1.52d0, 1.47d0, 1.54d0, &
      2.27d0, 1.73d0, 2.00d0, 2.10d0, 1.80d0, 1.80d0, 1.75d0, 1.88d0, 2.75d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.63d0, 1.40d0, 1.39d0, &
      1.87d0, 2.00d0, 1.85d0, 1.90d0, 1.85d0, 2.02d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.63d0, 1.72d0, 1.58d0, 1.93d0, 2.17d0, &
      2.00d0, 2.06d0, 1.98d0, 2.16d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 1.72d0, 1.66d0, 1.55d0, &
      1.96d0, 2.02d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 1.86d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, &
      2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0, 2.00d0 /

   ! Abundance weighted atomic masses taken from the WWW to be the
   ! same as Turbomol

   atomic_masses :: VEC{REAL}(92)

   data atomic_masses/ &
       1.007970d0,   4.002600d0, &
       6.939000d0,   9.012200d0,  10.811000d0,  12.011150d0,  14.006700d0,  15.999400d0,  18.998400d0,  20.183000d0, &
      22.989800d0,  24.312000d0,  26.981500d0,  28.086000d0,  30.973800d0,  32.064000d0,  35.453000d0,  39.948000d0, &
      39.102000d0,  40.080000d0, &
                    44.956000d0,  47.900000d0,  50.942000d0,  51.996000d0,  54.938000d0, &
                    55.850000d0,  58.933200d0,  58.710000d0,  63.540000d0,  65.370000d0, &
                                  69.720000d0,  72.590000d0,  74.921600d0,  78.960000d0,  79.909000d0,  83.800000d0, &
      85.470000d0,  87.620000d0,  &
                    88.905000d0,  91.220000d0,  92.906000d0,  95.940000d0,  99.000000d0, &
                   101.070000d0, 102.905000d0, 106.400000d0, 107.870000d0, 112.400000d0, &
                                 114.820000d0, 118.690000d0, 121.750000d0, 127.600000d0, 126.904000d0, 131.300000d0, &
      132.905000d0, 137.330000d0, &
                   138.910000d0, 140.115000d0, 140.908000d0, 144.240000d0, 146.920000d0, 150.360000d0, 151.965000d0, &
                   157.250000d0, 158.925000d0, 162.500000d0, 164.930000d0, 167.260000d0, 168.930000d0, 173.040000d0, &
                   174.970000d0, 178.490000d0, 180.950000d0, 183.850000d0, 186.210000d0, &
                   190.200000d0, 192.220000d0, 195.080000d0, 196.070000d0, 200.590000d0, &
                                 204.380000d0, 207.200000d0, 208.980000d0, 208.980000d0, 209.990000d0, 222.020000d0, &
      223.020000d0, 226.030000d0, &
                   227.030000d0, 232.040000d0, 231.040000d0, 238.030000d0/

   ! Abundance-weighted coherent neutron scattering lengths in fm
   ! taken from: International Tables for Crystallography, Vol. C,
   ! 1992, pp 384-391

   neutron_scattering_lengths :: VEC{REAL}(95)

   data neutron_scattering_lengths/ &
      -3.7390,  3.2600, &
      -1.9000,  7.7900,  5.3000,  6.6460,  9.3600,  5.8030,  5.6540,  4.5470, &
       3.6300,  5.3750,  3.4490,  4.1490,  5.1300,  2.8470,  9.5770,  1.9090, &
       3.7100,  4.9000, &
               12.2900, -3.4380,  -.3824,  3.6350, -3.7300, &
                9.5400,  2.5000, 10.3000,  7.7180,  5.6890, &
                         7.2879,  8.1929,  6.5800,  7.9700,  6.7950,  7.8000, &
       7.0800,  7.0200, &
                7.7500,  7.1600,  7.0540,  6.9500,  6.8000, &
                7.2100,  5.8800,  5.9100,  5.9220,  5.1000, &
                         4.0650,  6.2257,  5.5700,  5.8000,  5.2800,  4.8500, &
       5.4200,  5.0600, &
                8.2400,  4.8400,  4.4500,  7.6900, 12.6000,  4.2000,  6.7300, &
                9.5000,  7.3800, 16.9000,  8.0800,  8.0300,  7.0700, 12.4100, &
                7.2100,  7.7700,  6.9100,  4.7700,  9.2000, &
               11.0000, 10.6000,  9.6000,  7.6300, 12.6920, &
                         8.7760,  9.4017,  8.5307,  0.0000,  0.0000,  0.0000, &
       0.0000, 10.0000, &
                0.0000, 10.6300,  9.1000,  8.4170, 10.5500, 14.1000,  8.3000/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f". Cr wavelength = 2.289620A.

   dispersion_correction_Cr :: VEC{CPX}(92)

   data dispersion_correction_Cr/ &
    (  0.0,  0.0), (  0.0,  0.0), (  0.0023,  0.0008), (  0.0083,  0.0033), (0.0190,  0.0094), &
    (  0.0364,  0.0213), (  0.0606,  0.0416), (  0.0928,  0.0731), (  0.1324,  0.1192), (  0.1793,  0.1837), &
    (  0.2295,  0.2699), (  0.2778,  0.3812), (  0.3260,  0.5212), (  0.3647,  0.6921), (  0.3898,  0.8984), &
    (  0.3899,  1.1410), (  0.3508,  1.4222), (  0.2609,  1.7458), (  0.0914,  2.1098), ( -0.1987,  2.5138), &
    ( -0.6935,  2.9646), ( -1.6394,  3.4538), ( -4.4818,  0.4575), ( -2.1308,  0.5468), ( -1.5980,  0.6479), &
    ( -1.2935,  0.7620), ( -1.0738,  0.8897), ( -0.9005,  1.0331), ( -0.7338,  1.1930), ( -0.6166,  1.3712), &
    ( -0.4989,  1.5674), ( -0.3858,  1.7841), ( -0.2871,  2.0194), ( -0.1919,  2.2784), ( -0.1095,  2.5578), &
    ( -0.0316,  2.8669), (  0.0247,  3.1954), (  0.1037,  3.6029), (  0.1263,  3.9964), (  0.1338,  4.4226), &
    (  0.1211,  4.8761), (  0.0801,  5.3484), ( -0.0025,  5.8597), ( -0.1091,  6.4069), ( -0.2630,  6.9820), &
    ( -0.4640,  7.5938), ( -0.7387,  8.2358), ( -1.1086,  8.9174), ( -1.5975,  9.6290), ( -2.2019, 10.3742), &
    ( -3.0637, 11.1026), ( -4.2407, 11.8079), ( -5.6353, 12.6156), ( -8.1899, 11.7407), (-10.3310, 12.8551), &
    (-11.0454, 10.0919), (-12.8190,  3.5648), ( -9.3304,  3.8433), ( -7.9841,  4.1304), ( -7.1451,  4.4278), &
    ( -6.5334,  4.7422), ( -6.0570,  5.0744), ( -5.6630,  5.4178), ( -5.3778,  5.7756), ( -5.0951,  6.1667), &
    ( -4.8149,  6.5527), ( -4.5887,  6.9619), ( -4.4106,  7.3910), ( -4.2698,  7.8385), ( -4.1523,  8.2969), &
    ( -4.0630,  8.7649), ( -4.0564,  9.2832), ( -3.9860,  9.8171), ( -3.9270, 10.3696), ( -3.9052, 10.9346), &
    ( -3.9016, 11.5251), ( -3.9049, 12.1453), ( -3.9435, 12.7910), ( -3.9908, 13.4551), ( -4.1029, 14.1473), &
    ( -4.2233, 14.8643), ( -4.4167, 15.5987), ( -4.6533, 16.3448), ( -4.9604, 17.1410), ( -5.3399, 17.9390), &
    ( -5.7275, 18.7720), ( -6.2180, 19.6009), ( -6.7502, 20.4389), ( -7.4161, 21.3053), ( -8.2118, 22.2248), &
    ( -9.4459, 23.1548), ( -9.9362, 23.1239)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f". Cu wavelength = 1.540520A.

   dispersion_correction_Cu :: VEC{CPX}(92)

   data dispersion_correction_Cu/ &
    (  0.0000,  0.0000), (  0.0000,  0.0000), (  0.0008,  0.0003), (  0.0038,  0.0014), (  0.0090,  0.0039), &
    (  0.0181,  0.0091), (  0.0311,  0.0180), (  0.0492,  0.0322), (  0.0727,  0.0534), (  0.1019,  0.0833), &
    (  0.1353,  0.1239), (  0.1719,  0.1771), (  0.2130,  0.2455), (  0.2541,  0.3302), (  0.2955,  0.4335), &
    (  0.3331,  0.5567), (  0.3639,  0.7018), (  0.3843,  0.8717), (  0.3868,  1.0657), (  0.3641,  1.2855), &
    (  0.3119,  1.5331), (  0.2191,  1.8069), (  0.0687,  2.1097), ( -0.1635,  2.4439), ( -0.5299,  2.8052), &
    ( -1.1336,  3.1974), ( -2.3653,  3.6143), ( -3.0029,  0.5091), ( -1.9646,  0.5888), ( -1.5491,  0.6778), &
    ( -1.2846,  0.7763), ( -1.0885,  0.8855), ( -0.9300,  1.0051), ( -0.7943,  1.1372), ( -0.6763,  1.2805), &
    ( -0.5657,  1.4385), ( -0.4688,  1.6079), ( -0.3528,  1.8200), ( -0.2670,  2.0244), ( -0.1862,  2.2449), &
    ( -0.1121,  2.4826), ( -0.0483,  2.7339), (  0.0057,  3.0049), (  0.0552,  3.2960), (  0.0927,  3.6045), &
    (  0.1215,  3.9337), (  0.1306,  4.2820), (  0.1185,  4.6533), (  0.0822,  5.0449), (  0.0259,  5.4591), &
    ( -0.0562,  5.8946), ( -0.1759,  6.3531), ( -0.3257,  6.8362), ( -0.5179,  7.3500), ( -0.7457,  7.9052), &
    ( -1.0456,  8.4617), ( -1.4094,  9.0376), ( -1.8482,  9.6596), ( -2.4164, 10.2820), ( -3.1807, 10.9079), &
    ( -4.0598, 11.5523), ( -5.3236, 12.2178), ( -8.9294, 11.1857), ( -8.8380, 11.9157), ( -9.1472,  9.1891), &
    ( -9.8046,  9.8477), (-14.9734,  3.7046), ( -9.4367,  3.9380), ( -8.0393,  4.1821), ( -7.2108,  4.4329), &
    ( -6.6179,  4.6937), ( -6.1794,  4.9776), (  5.7959,  5.2718), ( -5.4734,  5.5774), ( -5.2083,  5.8923), &
    ( -4.9801,  6.2216), ( -4.7710,  6.5667), ( -4.5932,  6.9264), ( -4.4197,  7.2980), ( -4.2923,  7.6849), &
    ( -4.1627,  8.0900), ( -4.0753,  8.5060), ( -4.0111,  8.9310), ( -3.9670,  9.3834), ( -3.9588,  9.8433), &
    ( -3.9487, 10.3181), ( -3.9689, 10.8038), ( -4.0088, 11.2969), ( -4.0794, 11.7994), ( -4.1491, 12.3296), &
    ( -4.2473, 12.8681), ( -4.3638, 13.4090)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f". Mo wavelength = 0.709260A.

   dispersion_correction_Mo :: VEC{CPX}(92)

   data dispersion_correction_Mo/ &
    (  0.0000,  0.0000), (  0.0000,  0.0000), ( -0.0003,  0.0001), (  0.0005,  0.0002), (  0.0013,  0.0007),  &
    (  0.0033,  0.0016), (  0.0061,  0.0033), (  0.0106,  0.0060), (  0.0171,  0.0103), (  0.0259,  0.0164),  &
    (  0.0362,  0.0249), (  0.0486,  0.0363), (  0.0645,  0.0514), (  0.0817,  0.0704), (  0.1023,  0.0942),  &
    (  0.1246,  0.1234), (  0.1484,  0.1585), (  0.1743,  0.2003), (  0.2009,  0.2494), (  0.2262,  0.3064),  &
    (  0.2519,  0.3716), (  0.2776,  0.4457), (  0.3005,  0.5294), (  0.3209,  0.6236), (  0.3368,  0.7283),  &
    (  0.3463,  0.8444), (  0.3494,  0.9721), (  0.3393,  1.1124), (  0.3201,  1.2651), (  0.2839,  1.4301),  &
    (  0.2307,  1.6083), (  0.1547,  1.8001), (  0.0499,  2.0058), ( -0.0929,  2.2259), ( -0.2901,  2.4595),  &
    ( -0.5574,  2.7079), ( -0.9393,  2.9676), ( -1.5307,  3.2498), ( -2.7962,  3.5667), ( -2.9673,  0.5597),  &
    ( -2.0727,  0.6215), ( -1.6857,  0.6857), ( -1.4390,  0.7593), ( -1.2594,  0.8363), ( -1.1178,  0.9187),  &
    ( -0.9988,  1.0072), ( -0.8971,  1.1015), ( -0.8075,  1.2024), ( -0.7276,  1.3100), ( -0.6537,  1.4246),  &
    ( -0.5866,  1.5461), ( -0.5308,  1.6751), ( -0.4742,  1.8119), ( -0.4205,  1.9578), ( -0.3680,  2.1192),  &
    ( -0.3244,  2.2819), ( -0.2871,  2.4523), ( -0.2486,  2.6331), ( -0.2180,  2.8214), ( -0.1943,  3.0179),  &
    ( -0.1753,  3.2249), ( -0.1638,  3.4418), ( -0.1578,  3.6682), ( -0.1653,  3.9035), ( -0.1723,  4.1537),  &
    ( -0.1892,  4.4098), ( -0.2175,  4.6783), ( -0.2586,  4.9576), ( -0.3139,  5.2483), ( -0.3850,  5.5486),  &
    ( -0.4720,  5.8584), ( -0.5830,  6.1852), ( -0.7052,  6.5227), ( -0.8490,  6.8722), ( -1.0185,  7.2310),  &
    ( -1.2165,  7.6030), ( -1.4442,  7.9887), ( -1.7033,  8.3905), ( -2.0133,  8.8022), ( -2.3894,  9.2266),  &
    ( -2.8358,  9.6688), ( -3.3944, 10.1111), ( -4.1077, 10.2566), ( -5.1210, 11.0496), ( -7.9122,  9.9777),  &
    ( -8.0659, 10.4580), ( -7.2224,  7.7847), ( -6.7704,  8.1435), ( -6.8494,  8.5178), ( -7.2400,  8.8979),  &
    ( -8.0334,  9.2807), ( -9.6767,  9.6646)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f". Ag wavelength = 0.559360A.

   dispersion_correction_Ag :: VEC{CPX}(92)

   data dispersion_correction_Ag/ &
    (  0.0000,  0.0000), (  0.0000,  0.0000), ( -0.0004,  0.0000), (  0.0001,  0.0001), (  0.0004,  0.0004),  &
    (  0.0015,  0.0009), (  0.0030,  0.0019), (  0.0056,  0.0036), (  0.0096,  0.0061), (  0.0152,  0.0098),  &
    (  0.0218,  0.0150), (  0.0298,  0.0220), (  0.0406,  0.0313), (  0.0522,  0.0431), (  0.0667,  0.0580),  &
    (  0.0826,  0.0763), (  0.0998,  0.0984), (  0.1191,  0.1249), (  0.1399,  0.1562), (  0.1611,  0.1926),  &
    (  0.1892,  0.2348), (  0.2060,  0.2830), (  0.2276,  0.3376), (  0.2496,  0.3992), (  0.2704,  0.4681),  &
    (  0.2886,  0.5448), (  0.3050,  0.6296), (  0.3147,  0.7232), (  0.3240,  0.8257), (  0.3242,  0.9375),  &
    (  0.3179,  1.0589), (  0.3016,  1.1903), (  0.2758,  1.3314), (  0.2367,  1.4831), (  0.1811,  1.6452),  &
    (  0.1067,  1.8192), (  0.0068,  2.0025), ( -0.1172,  2.2025), ( -0.2879,  2.4099), ( -0.5364,  2.6141),  &
    ( -0.8282,  2.8404), ( -1.2703,  3.0978), ( -2.0087,  3.3490), ( -5.3630,  3.6506), ( -2.5280,  0.5964),  &
    ( -1.9556,  0.6546), ( -1.6473,  0.7167), ( -1.4396,  0.7832), ( -1.2843,  0.8542), ( -1.1587,  0.9299),  &
    ( -1.0547,  1.0104), ( -0.9710,  1.0960), ( -0.8919,  1.1868), ( -0.8200,  1.2838), ( -0.7527,  1.3916),  &
    ( -0.6940,  1.5004), ( -0.6411,  1.6148), ( -0.5890,  1.7358), ( -0.5424,  1.8624), ( -0.5012,  1.9950),  &
    ( -0.4626,  2.1347), ( -0.4287,  2.2815), ( -0.3977,  2.4351), ( -0.3741,  2.5954), ( -0.3496,  2.7654),  &
    ( -0.3302,  2.9404), ( -0.3168,  3.1241), ( -0.3091,  3.3158), ( -0.3084,  3.5155), ( -0.3157,  3.7229),  &
    ( -0.3299,  3.9377), ( -0.3548,  4.1643), ( -0.3831,  4.3992), ( -0.4201,  4.6430), ( -0.4693,  4.8944),  &
    ( -0.5280,  5.1558), ( -0.5977,  5.4269), ( -0.6812,  5.7081), ( -0.7638,  5.9978), ( -0.8801,  6.2989),  &
    ( -1.0117,  6.6090), ( -1.1676,  6.9287), ( -1.3494,  7.2566), ( -1.5613,  7.5986), ( -1.8039,  7.9509),  &
    ( -2.0847,  8.3112), ( -2.4129,  8.6839), ( -2.8081,  9.0614), ( -3.2784,  9.4502), ( -3.8533,  9.8403),  &
    ( -4.6067, 10.2413), ( -5.7225, 10.6428)/

   saved_self :: ATOM*, private  DEFAULT_NULL

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==================
!  Allocation methods
!  ==================

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   nullify_ptr_part 
   ! Nullify the pointer parts of the atom
   ! WARNING: all of these are usually pointer assigned in MOLECULE
   ! when defining the (spherically averaged) atomic natural orbitals.
   ! Therefore, the appropriate MOLECULE destructor should be called
   ! before using this routine.

      nullify(.basis)          
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      nullify(.pADP_vector)
      nullify(.pADP_errors)

      nullify(.atomic_orbitals)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation_numbers)

      nullify(.interpolator)

      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.precomputed_basis_shellpair)

   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of an atom
   ! WARNING: take care using this, you may need
   ! a unique-atom or all-atom destruction for the
   ! different pointer parts depending on how they
   ! were created.

      ! Never destroy these ... they are always 
      ! resolved outside the atom object.
      nullify(.basis)          
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      ! WARNING: this may not be correct
      ! The destroy should be done outside of this module
      if (.kind==0 OR .is_unique_kind) then

         .atomic_orbitals.destroy
         .density_matrix.destroy
         .natural_orbitals.destroy
         .occupation_numbers.destroy
   
         .interpolator.destroy
   
         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

      else
   
         nullify(.atomic_orbitals)
         nullify(.density_matrix)
         nullify(.natural_orbitals)
         nullify(.occupation_numbers)
   
         nullify(.interpolator)
   
         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

      end

      ! Do always destroy these
      .pADP_vector.destroy
      .pADP_errors.destroy

   end

   destroy_ANOs ::: leaky
   ! Destroy the (unique-atom) ANO pointer parts
   ! (and related info)
   DIE_IF(.kind==0,"The kind has not been set")

      if (NOT .ANOs_made) return

      if (.is_unique_kind) then

         .atomic_orbitals.destroy
         .density_matrix.destroy
         .natural_orbitals.destroy
         .occupation_numbers.destroy

      else

         nullify(.atomic_orbitals)
         nullify(.density_matrix)
         nullify(.natural_orbitals)
         nullify(.occupation_numbers)

      end

      .ANOs_made = FALSE

   end

   destroy_ANO_interpolators ::: leaky
   ! Destroy the (unique-atom) ANO interpolators
   DIE_IF(.kind==0,"The kind has not been set")

      if (NOT .ANO_interpolators_made) return

      if (.is_unique_kind) then; .interpolator.destroy
      else;                      nullify(.interpolator)
      end

      .ANO_interpolators_made = FALSE

   end

   destroy_spherical_atom_data ::: leaky
   ! Destroy the (non-unique) ANO pointer parts

      if (NOT .spherical_atom_data_made) return

      .atomic_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy

      .interpolator.destroy

      .spherical_atom_data_made = FALSE

   end

   destroy_interpolators ::: leaky
   ! Destroy the (non-unique) interpolators

      if (NOT .interpolators_made) return

      .interpolator.destroy

      .interpolators_made = FALSE

   end

   destroy_shell_info ::: leaky
   ! Destroy the (unique-atom) shell info 
   DIE_IF(.kind==0,"The kind has not been set")

      if (NOT .shell_info_made) return

      if (.is_unique_kind) then
   
         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

      else
   
         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

      end

      .shell_info_made = FALSE

   end

!  ====
!  Copy
!  ====

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(atom) ::: leaky
   ! Make self to be a copy of atom.  
   ! WARNING: This method only nullifies pointer parts. It is your
   ! responsibility to destroy pointer parts (if you want to) before
   ! calling this method.
      atom :: ATOM, IN

      self = atom

      .nullify_ptr_part

      ! Copy the pADP data
      if (atom.pADP_vector.created)     .pADP_vector.create_copy(atom.pADP_vector)
      if (atom.pADP_errors.created)     .pADP_errors.create_copy(atom.pADP_errors)

      ! Re-assign bases
      if (atom.basis.created)           .basis        => atom.basis
      if (atom.slaterbasis.created)     .slaterbasis  => atom.slaterbasis
      if (atom.coppensbasis.created)    .coppensbasis => atom.coppensbasis

      ! Re-assign unique-atom ANO data
      .copy_ANOs(atom)
      .copy_ANO_interpolators(atom)
      .copy_shell_info(atom)

      ! Re-assign unique-atom ANO data
      .copy_spherical_atom_data(atom)
      .copy_interpolators(atom)

      ! Set kind via VEC{ATOM}:update?
      ! Do it yourself if you want to
    ! .kind = 0

   end

   copy_ANOs(atom) ::: leaky
   ! Copy the (unique-atom) ANO pointer parts (and related info)
      atom :: ATOM, IN

      if (NOT atom.ANOs_made) return

      if (.kind==0 OR .is_unique_kind) then

         .atomic_orbitals.destroy
         .density_matrix.destroy
         .natural_orbitals.destroy
         .occupation_numbers.destroy

         .atomic_orbitals.create_copy(atom.atomic_orbitals)
         .density_matrix.create_copy(atom.density_matrix)
         .natural_orbitals.create_copy(atom.natural_orbitals)
         .occupation_numbers.create_copy(atom.occupation_numbers)

      else

         nullify(.atomic_orbitals)
         nullify(.density_matrix)
         nullify(.natural_orbitals)
         nullify(.occupation_numbers)

         .atomic_orbitals    => atom.atomic_orbitals
         .density_matrix     => atom.density_matrix
         .natural_orbitals   => atom.natural_orbitals
         .occupation_numbers => atom.occupation_numbers

      end

      ! Kinds may not be sequential
      .ANOs_made = TRUE

   end

   copy_ANO_interpolators(atom) ::: leaky
   ! Copy the (unique-atom) ANO interpolators
      atom :: ATOM, IN

      if (NOT atom.ANO_interpolators_made) return

      if (.kind==0 OR .is_unique_kind) then

         .interpolator.destroy
         .interpolator.create_copy(atom.interpolator)

      else

         nullify(.interpolator)
         .interpolator => atom.interpolator

      end

      ! Kinds may not be sequential
      .ANO_interpolators_made = TRUE

   end

   copy_shell_info(atom) ::: leaky
   ! Destroy the (unique-atom) shell info 
      atom :: ATOM, IN

      if (NOT atom.shell_info_made) return

      if (.kind==0 OR .is_unique_kind) then
   
         .first_basis_fn_for_shell.destroy
         .last_basis_fn_for_shell.destroy
         .precomputed_basis_shellpair.destroy

         .first_basis_fn_for_shell.create_copy(atom.first_basis_fn_for_shell)
         .last_basis_fn_for_shell.create_copy(atom.last_basis_fn_for_shell)
         .precomputed_basis_shellpair.create_copy(atom.precomputed_basis_shellpair)

      else
   
         nullify(.first_basis_fn_for_shell)
         nullify(.last_basis_fn_for_shell)
         nullify(.precomputed_basis_shellpair)

         .first_basis_fn_for_shell    => atom.first_basis_fn_for_shell
         .last_basis_fn_for_shell     => atom.last_basis_fn_for_shell
         .precomputed_basis_shellpair => atom.precomputed_basis_shellpair

      end

      ! Kinds may not be sequential
      .shell_info_made = TRUE

   end

   copy_spherical_atom_data(atom) ::: leaky
   ! Copy the (non-unique) ANO pointer parts
      atom :: ATOM, IN

      if (NOT atom.spherical_atom_data_made) return

      .atomic_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy

      .atomic_orbitals.create_copy(atom.atomic_orbitals)
      .density_matrix.create_copy(atom.density_matrix)
      .natural_orbitals.create_copy(atom.natural_orbitals)
      .occupation_numbers.create_copy(atom.occupation_numbers)

      .interpolator.destroy
      .interpolator.create_copy(atom.interpolator)

      ! Kinds may not be sequential
      .spherical_atom_data_made = TRUE

   end

   copy_interpolators(atom) ::: leaky
   ! Destroy the (non-unique) interpolators
      atom :: ATOM

      if (NOT atom.interpolators_made) return

      .interpolator.destroy
      .interpolator.create_copy(atom.interpolator)

      ! Kinds may not be sequential
      .interpolators_made = TRUE

   end

!  ===========
!  Set methods
!  ===========

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self. This version has self a target.
   end

   set_defaults
   ! Set a default atom

      .label = "?"
      .tag = " "

      .atomic_number = 0
      .nuclear_charge = ZERO
      .oxidation_state = 0

      .set_position([ ZERO,ZERO,ZERO ])
      .set_position_error([ ZERO,ZERO,ZERO ])

      .axis_system = "cartesian"
      .group  = 1

      .site_occupancy = ONE
      .site_disorder_group = 0

      ! ADP

      .U_iso = ZERO
      .set_ADP_tensor(ZERO)
      .ADP_axis_system = "cartesian"

      ! Charges

      .charge = ZERO
      .dipole = ZERO
      .quadrupole = ZERO
      .spin = ZERO
      .spin_dipole = ZERO
      .spin_quadrupole = ZERO
      .charge_polarisability = ZERO
      .dipole_polarisability = ZERO

      ! Basis

      .basis_label = " "
      .basis_kind = " "
      .slaterbasis_label = " "
      .coppensbasis_label = " "
      .kind = 0
      .is_unique_kind = FALSE

      ! ANO

      .energy = ZERO
      .ANOs_made = FALSE
      .spherical_atom_data_made = FALSE

      ! Interpolator

      .use_interpolator = TRUE
      .ANO_interpolators_made = FALSE
      .interpolators_made = FALSE

      .shell_info_made = FALSE

      ! Protien defaults
      .invariom_label = " "
      .protein_strand = 0
      .residue_atom_code = " "
      .residue_code = " "
      .residue_sequence_number = 0

      ! MM
      .mm_forcefield_name = " "
      .mm_atom_type = " "
      .mm_charge = ZERO
      .restraining_position = [ ZERO,ZERO,ZERO ]
      .restraining_force_constant = ZERO

   end

!  ============================
!  Set labels, dummies, charges
!  ============================

   set_label(label)
   ! Set the atom "label" and related variables
      label :: STR

   DIE_IF(NOT label(1:1).is_alphabetical,"unacceptable atom symbol: "// trim(label))

      lensym,z :: INT
      symbol :: STR(len=2)

      ! Label ends on nonalphabetical character
      lensym = label.index_of_nonalphabetical - 1

      ! Check label is no more than two character long
      DIE_IF(lensym>2,"unacceptable atom symbol: "// trim(label(1:lensym)))

      ! Set the tag - may not be unique
      .tag = label(lensym+1:)

      ! lensym could be negative -- if no nonalphabetical chars!
      if (lensym<0) lensym = len_trim(label)

      ! Recheck label is no more than two character long
      DIE_IF(lensym>2,"unacceptable atom symbol: "// trim(label(1:lensym)))

      ! Get chemical symbol
      symbol = label(1:lensym)
      symbol(1:1).to_upper_case
      if (lensym>1 AND symbol(2:2).is_upper_case) symbol(2:2).to_lower_case

      ! Assign atomic number from symbol
      if (symbol(1:2)=="El") then               ! This is an electron
         .atomic_number = -1
         .nuclear_charge = -ONE
      else if (symbol=="D" OR symbol=="T") then ! This is dueterium/tritium
         .atomic_number = 1
         .nuclear_charge = ONE
      else                                      ! Regular element
         z = element_symbols(1:).index_of(symbol(1:2))
         DIE_IF(z==0,"unknown element symbol: "//trim(symbol))
         .atomic_number = z
         .nuclear_charge = z*ONE
      end

      ! Set label
      .label = label

   end

   set_label_and_atomic_number(label)
   ! Set the atom label, atomic_number and nuclear_charge
      label :: STR

      z :: INT

      if (label.is_int) then    

         ! Integer label must be the atomic number
         z = label.to_int
         .set_atomic_number(z)

      else if (label(1:2)==ATOM_DUMMY_CHARGE_INPUT_SYMBOL) then

         ! This is a dummy charge, e.g Q:-0.3
         .set_dummy_charge(label)

      else

         ! Valid chemical symbol at start, followed by other stuff ...
         .set_label(label)

      end

   end

   set_dummy_charge(label)
   ! Set a dummy charge (integer) and related variables
      label :: STR
   DIE_IF(label(1:2)/=ATOM_DUMMY_CHARGE_INPUT_SYMBOL,"invalid q-charge label: "//trim(label(1:2)))
   DIE_IF(NOT label(3:).is_real,"invalid q-charge: "//trim(label(3:)))

      .label = ATOM_DUMMY_CHARGE_LABEL
      .atomic_number = 0
      .nuclear_charge = label(3:).to_real ! extract the charge

   end

   set_atomic_number(val)
   ! Set the atomic number (integer) and related variables
      val :: INT
      DIE_IF(val<=0 OR val>103,"unknown atomic number: "//trim(val.to_str))

      .atomic_number = val
      .nuclear_charge = val
      .label = .chemical_symbol

   end

   set_nuclear_charge(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.nuclear_charge)
   ! Generic set
   end

   set_oxidation_state(val) ::: get_from(OBJECT:set, TYPE=>INT, VAL=>.oxidation_state)
   ! Generic set
   end

!  =============
!  Set positions
!  =============

   set_position(val) ::: pure
   ! Set positions. Also set the pADP_vector *only* if created.
      self :: INOUT
      val :: VEC{REAL}(3), IN

      .position = val

      if (.pADP_vector.created) .pADP_vector(1:3) = val

   end

   set_position_error(val) ::: pure
   ! Set position error. Also set the pADP_error *only* if created.
      self :: INOUT
      val :: VEC{REAL}(3), IN
      .position_error = val
      if (.pADP_errors.created) .pADP_errors(1:3) = val
   end

   set_axis_system(word)
   ! Set the axis system type to "word". Currently allowed is
   ! "cartesian" or "crystal". NOTE: .ADP_axis_system is changed too.
      word :: STR, IN

      .axis_system     = word
      .ADP_axis_system = word

      select case (.axis_system)
         case ("cartesian")
         case ("crystal  ")
         case default
            UNKNOWN(.axis_system)
      end

   end

!  ========
!  Set ADPs
!  ========

   set_U_iso(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.U_iso)
   ! Generic set
   end

   set_ADP_tensor(val) ::: pure
   ! Set the ADP tensor.  Also set the pADP_vector *only* if created.
      self :: INOUT
      val :: REAL, IN

      .ADP_tensor = val

      if (.pADP_vector.created) .pADP_vector(4:9) = val

   end

   set_ADP_tensor(val) ::: pure
   ! Set the ADP tensor.  Also set the pADP_vector if created.
      self :: INOUT
      val :: MAT{REAL}(3,3), IN

      ! Set tensor
      .ADP_tensor = val

      ! Set *only* the ADP part of pADP 
      if (.pADP_vector.created) then
         .pADP_vector(4) = val(1,1)
         .pADP_vector(5) = val(2,2)
         .pADP_vector(6) = val(3,3)
         .pADP_vector(7) = val(1,2)
         .pADP_vector(8) = val(1,3)
         .pADP_vector(9) = val(2,3)
      end

   end

   set_ADP_tensor(val)
   ! Set from vector in the order xx, yy, zz, xy, xz, yz.
   ! Also set the pADP_vector if created.
      self :: INOUT
      val :: VEC{REAL}, IN

   DIE_IF(val.dim/=6,"val: wrong size")

      ! Set symmetric tensor
      .ADP_tensor(1,1) = val(1)
      .ADP_tensor(2,2) = val(2)
      .ADP_tensor(3,3) = val(3)
      .ADP_tensor(1,2) = val(4)
      .ADP_tensor(2,1) = val(4)
      .ADP_tensor(1,3) = val(5)
      .ADP_tensor(3,1) = val(5)
      .ADP_tensor(2,3) = val(6)
      .ADP_tensor(3,2) = val(6)

      ! Set *all* ADP parameters
      if (.pADP_vector.created) .set_ADP2_vector_to(val)

   end

   set_ADP_axis_system(word)
   ! Set the ADP axis system type to "word".  Currently allowed, is
   ! "cartesian" or "crystal".
      word :: STR, IN

      .ADP_axis_system = word

      select case (.ADP_axis_system)
         case ("cartesian")
         case ("crystal  ")
         case default
            UNKNOWN(.ADP_axis_system)
      end

   end

!  =======================================
!  Parameter vector (position/ADP) setting
!  =======================================

! Put tensors

   put_ADP2_to(adp2,fac)
   ! Put the ADP2s into the "adp2" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp2 :: MAT{REAL}(3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.created,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=9,"pADP_vector too small")

      fac2 :: REAL
      v2   :: VEC{REAL}(6)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_2_to_lower_pyramid(.pADP_vector( 4: 9),v2)

      ! Uncompress lower pyramid -> tensor
      adp2.uncompress_from_pyramid(v2)

      DIE_IF(NOT adp2.same_as(.ADP_tensor),"inconsistent ADP_vector and ADP_tensor")

      if (present(fac)) then

         fac2 = fac*fac
         adp2 = fac2*adp2

      end

   end

   put_ADP3_to(adp3,fac)
   ! Put the ADP3s into the "adp3" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp3 :: MAT3{REAL}(3,3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.created,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=19,"pADP_vector too small")

      fac3 :: REAL
      v3   :: VEC{REAL}(10)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_3_to_lower_pyramid(.pADP_vector(10:19),v3)

      ! Uncompress lower pyramid -> tensor
      adp3.uncompress_from_pyramid(v3)

      ! Change units
      if (present(fac)) then
         fac3 = fac*fac*fac
         adp3 = fac3*adp3
      end

   end

   put_ADP4_to(adp4,fac)
   ! Put the ADP4s into the "adp4" tensor from the pADP_vector.
   ! If present, include length-conversion factor "fac".
      self :: IN
      adp4 :: MAT4{REAL}(3,3,3,3), OUT
      fac :: REAL, optional, IN

   ENSURE(.pADP_vector.created,"no pADP_vector")
   ENSURE(.pADP_vector.dim>=34,"pADP_vector too small")

      fac4 :: REAL
      v4   :: VEC{REAL}(15)

      ! Reorder from lexical -> lower pyramid
      GAUSSIAN_DATA:lexical_4_to_lower_pyramid(.pADP_vector(20:34),v4)

      ! Uncompress lower pyramid -> tensor
      adp4.uncompress_from_pyramid(v4)

      ! Change units
      if (present(fac)) then
         fac4 = fac*fac*fac*fac
         adp4 = fac4*adp4
      end

   end

! Reset

   reset_pADPs_and_errors(dim) ::: leaky
   ! Reset the positional-ADP parameters and errors to size "dim".
   ! NOTE: the pADPs and errors are *expanded*.
      self :: INOUT
      dim  :: INT, IN

      X,dX :: VEC{REAL}*
      n :: INT

      ! Create pADPs, and set to existing pADPs 
      if (.pADP_vector.destroyed OR .pADP_errors.destroyed) then

         ! Space for X, dX
         n = .no_of_pADPs
          X.create(n)
         dX.create(n)

         ! Get existing pADPs in X
         .put_pADP_vector_to(X)
         dX = ZERO

         ! Create pADPs (leaky)
         .pADP_errors.destroy
         .pADP_vector.destroy
         .pADP_vector.create(n)
         .pADP_errors.create(n)

         ! Set the pADPs and errors
         .set_pADP_vector_to(X)
         .set_pADP_errors_to(dX)

         ! Clean
         dX.destroy
          X.destroy
      
      end

      ! Expand if necessary.
      ! New (if any) values to zero.
      if (dim>.pADP_vector.dim) then
         .pADP_vector.resize(dim,init=ZERO)
         .pADP_errors.resize(dim,init=ZERO)
      end

   end

! Set vector

   set_pADP_vector_to(X)
   ! Set the pADP vector from vector "X".
   ! NOTE: Also sets positions and ADP_tensor.
   ! NOTE: "X" musts be correct size.
      self :: INOUT
      X :: VEC{REAL}, IN

   DIE_IF(X.dim<9,"X too small")

      ! Set positions
      .position(1) = X(1)
      .position(2) = X(2)
      .position(3) = X(3)

      ! Set ADP tensor
      .ADP_tensor(1,1) = X(4)
      .ADP_tensor(2,2) = X(5)
      .ADP_tensor(3,3) = X(6)
      .ADP_tensor(1,2) = X(7)
      .ADP_tensor(2,1) = X(7)
      .ADP_tensor(1,3) = X(8)
      .ADP_tensor(3,1) = X(8)
      .ADP_tensor(2,3) = X(9)
      .ADP_tensor(3,2) = X(9)

      ! Set. Must be correct size
      if (.pADP_vector.created) then
         DIE_IF(.pADP_vector.dim/=X.dim,"wrong size, X")
         .pADP_vector = X
      end

   end

   set_ADP2_vector_to(U) ::: private
   ! Set the ADP2s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<9,"pADP_vector: wrong size")
   DIE_IF(U.dim/=6,"wrong size, U")

      .pADP_vector( 4: 9) = U( 1: 6)

   end

   set_ADP3_vector_to(U)
   ! Set the ADP3s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<19,"no pADP3s")
   DIE_IF(U.dim/=10,"wrong size, U")

      .pADP_vector(10:19) = U( 1:10)

   end

   set_ADP4_vector_to(U)
   ! Set the ADP4s from vector "U".
      self :: INOUT
      U :: VEC{REAL}, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<34,"no pADP4s")
   DIE_IF(U.dim/=15,"wrong size, U")

      .pADP_vector(20:34) = U( 1:15)

   end

! Set errors

   set_pADP_errors_to(dX) 
   ! Set the parameter errors (positions and ADPs) to "dX".
   ! NOTE: The pADP's and errors must be already created
   ! NOTE: "dX" must be correct size.
      self :: INOUT
      dX :: VEC{REAL}, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim/=dX.dim,"wrong size, dX")

      .pADP_errors = dX

   end

   set_ADP2_errors_to(dU)
   ! Set the second-order ADP errors from vector "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<9,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=6,"wrong size, dU")

      .pADP_errors( 4: 9) = dU( 1: 6)

   end

   set_ADP3_errors_to(dU)
   ! Set the ADP3 errors from vector "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<19,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=10,"wrong size, dU")

      .pADP_errors(10:19) = dU( 1:10)

   end

   set_ADP4_errors_to(dU)
   ! Set the ADP4 errors from "dU".
      self :: INOUT
      dU :: VEC{REAL}, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<34,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=15,"wrong size, dU")

      .pADP_errors(20:34) = dU( 1:15)

   end

! Put vector

   put_pADP_vector_to(X,fac)
   ! Put the pADP vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from position
         X(1)     =      .position(1)
         X(2)     =      .position(2)
         X(3)     =      .position(3)

         ! Set from ADP_tensor
         X(4)     =      .ADP_tensor(1,1)
         X(5)     =      .ADP_tensor(2,2)
         X(6)     =      .ADP_tensor(3,3)
         X(7)     =      .ADP_tensor(1,2)
         X(8)     =      .ADP_tensor(1,3)
         X(9)     =      .ADP_tensor(2,3)

         ! Set remaining ADPs
         if (.pADP_vector.created) then

         ENSURE(.pADP_vector(1:3).equals(X(1:3)),"inconsistent position and pADP_vector")
         ENSURE(.pADP_vector(4:9).equals(X(4:9)),"inconsistent ADP_tensor and pADP_vector")

         if (.pADP_vector.dim>=19) then
         DIE_IF(X.dim<19,"wrong size, X")
         X(10:19) =      .pADP_vector(10:19)
         end

         if (.pADP_vector.dim>=34) then
         DIE_IF(X.dim<34,"wrong size, X")
         X(20:34) =      .pADP_vector(20:34)
         end

         end

      else ! Change length units

         ! Length scales
         fac2     = fac *fac
         fac3     = fac *fac2
         fac4     = fac *fac3

         ! Set from position
         X(1)     = fac *.position(1)
         X(2)     = fac *.position(2)
         X(3)     = fac *.position(3)

         ! Set from ADP_tensor
         X(4)     = fac2*.ADP_tensor(1,1)
         X(5)     = fac2*.ADP_tensor(2,2)
         X(6)     = fac2*.ADP_tensor(3,3)
         X(7)     = fac2*.ADP_tensor(1,2)
         X(8)     = fac2*.ADP_tensor(1,3)
         X(9)     = fac2*.ADP_tensor(2,3)

         ! Set remaining ADPs
         if (.pADP_vector.created) then

         ENSURE(.pADP_vector(1:3).equals(X(1:3)/fac ),"inconsistent position and pADP_vector")
         ENSURE(.pADP_vector(4:9).equals(X(4:9)/fac2),"inconsistent ADP_tensor and pADP_vector")

         if (.pADP_vector.dim>=19) then
         DIE_IF(X.dim<19,"wrong size, X")
         X(10:19) = fac3*.pADP_vector(10:19)
         end

         if (.pADP_vector.dim>=34) then
         DIE_IF(X.dim<34,"wrong size, X")
         X(20:34) = fac4*.pADP_vector(20:34)
         end

         end

      end

   end

   put_pADP2_vector_to(X,fac)
   ! Put the pADP2 vector into vector "X".
   ! If present, include length-conversion factor "fac".
      self :: IN
      X :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(X.dim/=9,"wrong size, X")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from position
         X(1)     =      .position(1)
         X(2)     =      .position(2)
         X(3)     =      .position(3)

         ! Set from ADP_tensor
         X(4)     =      .ADP_tensor(1,1)
         X(5)     =      .ADP_tensor(2,2)
         X(6)     =      .ADP_tensor(3,3)
         X(7)     =      .ADP_tensor(1,2)
         X(8)     =      .ADP_tensor(1,3)
         X(9)     =      .ADP_tensor(2,3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(1:3).equals(X(1:3)),"inconsistent position and pADP_vector")
         ENSURE(.pADP_vector(4:9).equals(X(4:9)),"inconsistent ADP_tensor and pADP_vector")
         end

      else ! Change length units

         ! Length scales
         fac2     = fac *fac

         ! Set from position
         X(1)     = fac *.position(1)
         X(2)     = fac *.position(2)
         X(3)     = fac *.position(3)

         ! Set from ADP_tensor
         X(4)     = fac2*.ADP_tensor(1,1)
         X(5)     = fac2*.ADP_tensor(2,2)
         X(6)     = fac2*.ADP_tensor(3,3)
         X(7)     = fac2*.ADP_tensor(1,2)
         X(8)     = fac2*.ADP_tensor(1,3)
         X(9)     = fac2*.ADP_tensor(2,3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(1:3).equals(X(1:3)/fac ),"inconsistent position and pADP_vector")
         ENSURE(.pADP_vector(4:9).equals(X(4:9)/fac2),"inconsistent ADP_tensor and pADP_vector")
         end

      end

   end

   put_ADP2_vector_to(U,fac)
   ! Put the second-order ADPs into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(U.dim/=6,"wrong size, U")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         ! Set from ADP tensor
         U(1)     =      .ADP_tensor(1,1)
         U(2)     =      .ADP_tensor(2,2)
         U(3)     =      .ADP_tensor(3,3)
         U(4)     =      .ADP_tensor(1,2)
         U(5)     =      .ADP_tensor(1,3)
         U(6)     =      .ADP_tensor(2,3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(4:9).equals(U(1:6)),"inconsistent ADP_tensor and pADP_vector")
         end

      else ! Change length units

         ! Length scales
         fac2     = fac *fac

         ! Set from ADP tensor
         U(1)     = fac2*.ADP_tensor(1,1)
         U(2)     = fac2*.ADP_tensor(2,2)
         U(3)     = fac2*.ADP_tensor(3,3)
         U(4)     = fac2*.ADP_tensor(1,2)
         U(5)     = fac2*.ADP_tensor(1,3)
         U(6)     = fac2*.ADP_tensor(2,3)

         if (.pADP_vector.created) then
         ENSURE(.pADP_vector(4:9).equals(U(1:6)/fac2),"inconsistent ADP_tensor and pADP_vector")
         end

      end

   end

   put_ADP3_vector_to(U,fac)
   ! Put the ADP3s into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<19,"no pADP3s")
   DIE_IF(U.dim/=10,"wrong size, U")

      fac2,fac3 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         U( 1:10) =      .pADP_vector(10:19)

      else ! Change length units

         ! Length scales
         fac2     = fac *fac
         fac3     = fac *fac2

         U( 1:10) = fac3*.pADP_vector(10:19)

      end

   end

   put_ADP4_vector_to(U,fac)
   ! Put the ADP4s into vector "U".
   ! If present, include length-conversion factor "fac".
      self :: IN
      U :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_vector.destroyed,"no pADPs")
   DIE_IF(.pADP_vector.dim<34,"no pADP4s")
   DIE_IF(U.dim/=15,"wrong size, U")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         U( 1:15) =      .pADP_vector(20:34)

      else ! Change length units

         ! Length scales
         fac2     = fac *fac
         fac3     = fac *fac2
         fac4     = fac *fac3

         U( 1:15) = fac4*.pADP_vector(20:34)

      end

   end

! Put errors

   put_pADP_errors_to(dX,fac)
   ! Put the pADP errors into vector "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim/=dX.dim,"wrong size, dX")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then
      
         ! Copy all errors
         dX( 1: 3) =      .pADP_errors( 1: 3)
         dX( 4: 9) =      .pADP_errors( 4: 9)

         if (.pADP_errors.dim>=19) then
         dX(10:19) =      .pADP_errors(10:19)
         end

         if (.pADP_errors.dim>=34) then
         dX(20:34) =      .pADP_errors(20:34)
         end

      else ! Change length units

         ! Length scales
         fac2      = fac *fac
         fac3      = fac *fac2
         fac4      = fac *fac3

         ! Copy all errors
         dX( 1: 3) = fac *.pADP_errors( 1: 3)
         dX( 4: 9) = fac2*.pADP_errors( 4: 9)

         if (.pADP_errors.dim>=19) then
         dX(10:19) = fac3*.pADP_errors(10:19)
         end

         if (.pADP_errors.dim>=34) then
         dX(20:34) = fac4*.pADP_errors(20:34)
         end

      end

   end

   put_pADP2_errors_to(dX,fac)
   ! Put the pADP2 errors into vector "dX".
   ! If present, include length conversion factor "fac".
      self :: IN
      dX :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<9,"wrong size, pADP_errors")
   DIE_IF(dX.dim/=9,"wrong size, dX")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then
      
         ! Copy all errors
         dX( 1: 3) =      .pADP_errors( 1: 3)
         dX( 4: 9) =      .pADP_errors( 4: 9)

      else ! Change length units

         ! Length scales
         fac2      = fac *fac

         ! Copy all errors
         dX( 1: 3) = fac *.pADP_errors( 1: 3)
         dX( 4: 9) = fac2*.pADP_errors( 4: 9)

      end

   end

   put_ADP2_errors_to(dU,fac)
   ! Put the second-order ADP errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<9,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=6,"wrong size, dU")

      fac2 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1: 6) =      .pADP_errors( 4: 9)

      else ! Change length units

         fac2      = fac *fac

         dU( 1: 6) = fac2*.pADP_errors( 4: 9)

      end


   end

   put_ADP3_errors_to(dU,fac)
   ! Put the ADP3 errors into vector "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<19,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=10,"wrong size, dU")

      fac2,fac3 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1:10) =      .pADP_errors(10:19)

      else ! Change length units

         ! Length scales
         fac2      = fac *fac
         fac3      = fac *fac2

         dU( 1:10) = fac3*.pADP_errors(10:19)

      end


   end

   put_ADP4_errors_to(dU,fac)
   ! Put the ADP4 errors into "dU".
   ! If present, include length conversion factor "fac".
      self :: IN
      dU :: VEC{REAL}, OUT
      fac :: REAL, optional, IN

   DIE_IF(.pADP_errors.destroyed,"no pADP_errors")
   DIE_IF(.pADP_errors.dim<34,"wrong size, pADP_errors")
   DIE_IF(dU.dim/=15,"wrong size, dU")

      fac2,fac3,fac4 :: REAL

      ! In atomic units
      if (NOT present(fac)) then

         dU( 1:15) =      .pADP_errors(20:34)

      else ! Change length units

         ! Length scales
         fac2      = fac *fac
         fac3      = fac *fac2
         fac4      = fac *fac3

         dU( 1:15) = fac4*.pADP_errors(20:34)

      end


   end

! Put labels

   put_pADP_labels_to(lab)
   ! Set positional-ADP labels for parameter with index "par_index"
      lab :: VEC{STR}(.no_of_pADPs)

      i,n :: INT

      n = .no_of_pADPs

      do i = 1,n
         lab(i) = .pADP_label(i)
      end

   end

   put_ADP2_labels_to(lab)
   ! Set the second order ADP labels for parameter with 
   ! index "par_index"
      lab :: VEC{STR}(6)

      i :: INT

      do i = 1,6
         lab(i) = .ADP_label(i)
      end

   end

   put_ADP3_labels_to(lab)
   ! Set the ADP3 labels for parameter with index "par_index"
      lab :: VEC{STR}(10)

      i :: INT

      do i = 1,10
         lab(i) = .ADP3_label(i)
      end

   end

   put_ADP4_labels_to(lab)
   ! Set the ADP4 labels for parameter with index "par_index"
      lab :: VEC{STR}(15)

      i :: INT

      do i = 1,15
         lab(i) = .ADP4_label(i)
      end

   end

! Transform

   transform_pADP_vector_with(R)
   ! Transform the pADP vector, using the rotation matrix "R".
      R :: MAT{REAL}(3,3), IN

   DIE_IF(.pADP_vector.destroyed,"no pADP_vector")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      W :: MAT{REAL}*
      X :: VEC{REAL}*

      ! Create
      X.create(.no_of_pADPs)

      ! Transform position
      X(1:3).to_product_of(R,.pADP_vector(1:3))

      ! Transform ADP's
      W.create(6,6)
      GAUSSIAN_DATA:symmetric_tensor_2_product_mx(W,R)
      X(4:9).to_product_of(W,.pADP_vector(4:9))
      W.destroy

      ! Transform ADP3's
      if (.pADP_vector.created) then
      if (.pADP_vector.dim>=19) then
      W.create(10,10)
      GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,R)
      X(10:19).to_product_of(W,.pADP_vector(10:19))
      W.destroy
      end
      end

      ! Transform ADP4's
      if (.pADP_vector.created) then
      if (.pADP_vector.dim>=34) then
      W.create(15,15)
      GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,R)
      X(20:34).to_product_of(W,.pADP_vector(20:34))
      W.destroy
      end
      end

      ! Set pADPs
      .set_pADP_vector_to(X)

      ! Clean
      X.destroy

   end

!  ===============
!  Set atom groups
!  ===============

   set_isotropic_ADP
   ! Set the ADP to be isotropic.
      val :: REAL

      ! The averaged trace
      val = THIRD * (.ADP_tensor(1,1)+.ADP_tensor(2,2)+.ADP_tensor(3,3))

      ! Make it isotropic
      .ADP_tensor      = ZERO
      .ADP_tensor(1,1) = val
      .ADP_tensor(2,2) = val
      .ADP_tensor(3,3) = val

   end

   set_group(val) ::: get_from(OBJECT:set, TYPE=>INT, VAL=>.group)
   ! Generic set
   end

!  ==================
!  Set site occupancy
!  ==================

   set_site_occupancy(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.site_occupancy)
   ! Generic set
   end

   set_site_disorder_group(val) ::: get_from(OBJECT:set, TYPE=>INT, VAL=>.site_disorder_group)
   ! Generic set
   end

!  =====================
!  Set atomic properties
!  =====================

   set_charge(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.charge)
   ! Generic set
   end

   set_dipole(val) ::: get_from(OBJECT:set, TYPE=>VEC{REAL}(3), VAL=>.dipole)
   ! Generic set
   end

   set_quadrupole(val) ::: get_from(OBJECT:set, TYPE=>MAT{REAL}(3,3), VAL=>.quadrupole)
   ! Generic set
   end

   set_spin(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.spin)
   ! Generic set
   end

   set_spin_dipole(val) ::: get_from(OBJECT:set, TYPE=>VEC{REAL}(3), VAL=>.spin_dipole)
   ! Generic set
   end

   set_spin_quadrupole(val) ::: get_from(OBJECT:set, TYPE=>MAT{REAL}(3,3), VAL=>.spin_quadrupole)
   ! Generic set
   end

   set_charge_polarisability(val) ::: get_from(OBJECT:set, TYPE=>VEC{REAL}(3), VAL=>.charge_polarisability)
   ! Generic set
   end

   set_dipole_polarisability(val) ::: get_from(OBJECT:set, TYPE=>MAT{REAL}(3,3), VAL=>.dipole_polarisability)
   ! Generic set
   end

   set_energy(val) ::: get_from(OBJECT:set, TYPE=>REAL, VAL=>.energy)
   ! Generic set
   end

   set_atom_bonded_range_factor(fac) ::: selfless
   ! Set the range factor to decide when atoms are bonded.
      fac :: REAL
   ENSURE(fac>ZERO,"range factor must be grreater than zero")
      atom_bonded_range_factor = fac
   end

   set_covalent_radii_ccdc
   ! Set the the covalent radii for a given atomic number.
      an :: INT
      new_radius :: REAL

      if (FALSE) self = self

      stdin.read(an)
      ENSURE(an>0 AND an<111,"atomic number out of range")
      stdin.read_quantity(new_radius)

      covalent_radii_ccdc(an) = new_radius*ANGSTROM_PER_BOHR

   end

   set_vdw_radii_ccdc
   ! Set the the VDW radii for a given atomic number.
      an :: INT
      new_radius :: REAL

      if (FALSE) self = self

      stdin.read(an)
      ENSURE(an>0 AND an<111,"atomic number out of range")
      stdin.read_quantity(new_radius)

      vdw_radii_ccdc(an) = new_radius*ANGSTROM_PER_BOHR

   end

!  ==============
!  Set basis info
!  ==============

   set_basis_kind(val) ::: get_from(OBJECT:set, TYPE=>STR, VAL=>.basis_kind)
   ! Generic set
   end

   set_basis_label(val) ::: get_from(OBJECT:set, TYPE=>STR, VAL=>.basis_label)
   ! Generic set
   end

   set_slaterbasis_label(val) ::: get_from(OBJECT:set, TYPE=>STR, VAL=>.slaterbasis_label)
   ! Generic set
   end

   set_coppensbasis_label(val) ::: get_from(OBJECT:set, TYPE=>STR, VAL=>.coppensbasis_label)
   ! Generic set
   end

!  ============================
!  Set atom (unique) kind index
!  ============================

   set_kind(val) ::: get_from(OBJECT:set, TYPE=>INT, VAL=>.kind)
   ! Generic set
   end

   set_is_unique_kind(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.is_unique_kind)
   ! Generic set
   end

!  ================================
!  Set ANO data and shell info made
!  ================================

   set_ANOs_made(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.ANOs_made)
   ! Generic set
   end

   set_spherical_atom_data_made(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.spherical_atom_data_made)
   ! Generic set
   end

   set_shell_info_made(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.shell_info_made)
   ! Generic set
   end

!  =======================
!  Set interpolators made?
!  =======================

   set_use_interpolator(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.use_interpolator)
   ! Generic set
   end

   set_ANO_interpolators_made(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.ANO_interpolators_made)
   ! Generic set
   end

   set_interpolators_made(val) ::: get_from(OBJECT:set, TYPE=>BIN, VAL=>.interpolators_made)
   ! Generic set
   end

!  ============
!  I/O Routines
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR, IN
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
         case ("}                            ")  ! exit case
         case ("adp_axis_system=             "); .read_ADP_axis_system
         case ("adp_tensor=                  "); .read_ADP_tensor
         case ("adp2_tensor=                 "); .read_ADP_tensor
         case ("adp3_tensor=                 "); .read_ADP3_tensor
         case ("adp4_tensor=                 "); .read_ADP4_tensor
         case ("axis_system=                 "); .read_axis_system
         case ("basis_label=                 "); .read_basis_label
         case ("b_eq=                        "); .read_B_iso
         case ("b_iso=                       "); .read_B_iso
         case ("charge=                      "); .read_charge
         case ("coppensbasis_label=          "); .read_coppensbasis_label
         case ("debug_off                    "); .read_debug_off
         case ("debug_on                     "); .read_debug_on
         case ("dipole=                      "); .read_dipole
         case ("group=                       "); .read_group
         case ("junk=                        "); .read_junk
         case ("label=                       "); .read_label
         case ("mm_atom_type=                "); .read_mm_atom_type
         case ("mm_charge=                   "); .read_mm_charge
         case ("mm_forcefield_name=          "); .read_mm_forcefield_name
         case ("nuclear_charge=              "); .read_nuclear_charge
         case ("oxidation_state=             "); .read_oxidation_state
         case ("pdb_input_line=              "); .read_pdb_input_line
         case ("pos=                         "); .read_position ! deprecated
         case ("position=                    "); .read_position
         case ("put                          "); .put
         case ("put_interpolator             "); .put_interpolator
         case ("residue_atom_code=           "); .read_residue_atom_code
         case ("residue_code=                "); .read_residue_code
         case ("restraining_position=        "); .read_restraining_position
         case ("restraining_force_constant=  "); .read_restraining_force
         case ("residue_sequence_number=     "); .read_residue_sequence_number
         case ("set_covalent_radii_ccdc      "); .set_covalent_radii_ccdc
         case ("set_vdw_radii_ccdc           "); .set_vdw_radii_ccdc
         case ("site_disorder_group=         "); .read_site_disorder_group
         case ("site_occupancy=              "); .read_site_occupancy
         case ("slaterbasis_label=           "); .read_slaterbasis_label
         case ("thermal_axis_system=         "); .read_ADP_axis_system ! deprecated
         case ("thermal_tensor=              "); .read_ADP_tensor ! deprecated
         case ("u_eq=                        "); .read_U_iso
         case ("u_iso=                       "); .read_U_iso
         case ("u_tensor=                    "); .read_ADP_tensor
         case ("u2_tensor=                   "); .read_ADP_tensor
         case ("u3_tensor=                   "); .read_ADP3_tensor
         case ("u4_tensor=                   "); .read_ADP4_tensor
         case ("units=                       "); .read_units
         case  default;                        UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   read_group
   ! Read the index which describes the group the atom belongs to.
      stdin.read(.group)
   end

   read_position ::: leaky
   ! Read in the position. The pADP_vector is set also.
      pos :: VEC{REAL}(3)

      ! Read
      stdin.read_quantity(pos)

      ! Set
      .reset_pADPs_and_errors(9)
      .set_position(pos)

   end

   read_label
   ! Read an ATOM label.
      label :: STR
      stdin.read(label)
      .set_label_and_atomic_number(label)  ! Input atom label
   end

   read_charge
   ! Read the charge
      stdin.read(.charge)
   end

   read_nuclear_charge
   ! Read the charge
      stdin.read(.nuclear_charge)
   end

   read_dipole
   ! Read the dipole
      stdin.read_quantity(.dipole)
   end

   read_oxidation_state
   ! Read the oxidation state
      stdin.read(.oxidation_state)
   end

   read_residue_atom_code
   ! Read the atom code describing where in the residue this atom
   ! resides (case sensitive).
      stdin.read(.residue_atom_code)
   end

   read_residue_code
   ! Read the residue name that this atom belongs to.
      stdin.read(.residue_code)
   end

   read_pdb_input_line
   ! Read a line in the PDB input style
      word :: STR
      stdin.read(word)
      word.to_lower_case
      ENSURE(word=="atom","PDB line does not begin with 'atom'")
      .read_residue_atom_code
      .read_residue_code
      .read_residue_sequence_number
      .read_position
      .read_junk
      .read_junk
      .read_label
   end

   read_residue_sequence_number
   ! Read the residue sequence number of the atom in the molecule
      stdin.read(.residue_sequence_number)
   end

   read_mm_atom_type
   ! Read the atom type potential, used to define the force field potential
      stdin.read(.mm_atom_type)
   end

   read_mm_charge
   ! Read the MM charge on this atom
      stdin.read(.mm_charge)
   end

   read_mm_forcefield_name
   ! Read the MM forcefield name for this atom
      stdin.read(.mm_forcefield_name)
   end

   read_restraining_position
   ! Read the restraining position
      stdin.read_quantity(.restraining_position)
   end

   read_restraining_force
   ! Read the restrain force constant for this atom
      stdin.read_quantity(.restraining_force_constant)
   end

   read_site_disorder_group
   ! Read the site disorder group, used mainly for crystallographic applications.
      stdin.read(.site_disorder_group)
      DIE_IF(.site_disorder_group<0,"site_disorder_group must be non -ve")
   end

   read_site_occupancy
   ! Read the site occupancy, used mainly for crystallographic applications.
      stdin.read(.site_occupancy)
      DIE_IF(.site_occupancy<=ZERO,"site_occupancy must be +ve")
      DIE_IF(.site_occupancy> ONE ,"site_occupancy must be less than one")
   end

   read_axis_system
   ! Read a string which describes the axis system. Currently allowed is
   ! "cartesian" or "crystal". NOTE: .ADP_axis_system is changed too.
      stdin.read(.axis_system)
      .ADP_axis_system = .axis_system
      select case (.axis_system)
        case ("cartesian")
        case ("crystal  ")
        case default
          UNKNOWN(.axis_system)
      end
   end

   read_ADP_axis_system
   ! Read a string which describes the ADP (thermal tensor) axis system.
   ! Currently allowed, is "cartesian" or "crystal".
      stdin.read(.ADP_axis_system)
      select case (.ADP_axis_system)
        case ("cartesian")
        case ("crystal  ")
        case default
          UNKNOWN(.ADP_axis_system)
      end
   end

   read_basis_label ::: leaky
   ! Read the basis set label from "stdin" which will be used to match
   ! a basis set to ... the element symbol will be prepended.

      stdin.read(.basis_label)

      ! If no element symbol, prepend it
    ! if (.basis_label.does_not_include(':')) then
    !    .basis_label = trim(.chemical_symbol) // ':' // trim(.basis_label)
    ! end

   end

   read_slaterbasis_label ::: leaky
   ! Read the slater basis set label from "stdin" which will be used
   ! to match a basis set to ... the element symbol may be prepended

      stdin.read(.slaterbasis_label)

      ! If no element symbol, prepend it
      if (.basis_label.does_not_include(':')) then
         .basis_label = trim(.chemical_symbol) // ':' // trim(.basis_label)
      end

   end

   read_coppensbasis_label ::: leaky
   ! Read the Coppens basis set label from "stdin" which will be used to match a
   ! basis set to ... (in fact there is only one coppens basis type)

      stdin.read(.coppensbasis_label)

      ! If no element symbol, prepend it
      if (.basis_label.does_not_include(':')) then
         .basis_label = trim(.chemical_symbol) // ':' // trim(.basis_label)
      end

   end

   read_U_iso
   ! Read the isotropic thermal parameters from "stdin".  NOTE: units are
   ! Bohr^2, not Angstrom^2.
      stdin.read_quantity(.U_iso)
   end

   read_B_iso
   ! Read the isotropic B factor.NOTE: units are Bohr^2, not Angstrom^2.
      B_iso :: REAL

      ! Read
      stdin.read_quantity(B_iso)

      ! Set
      .U_iso = B_iso/(EIGHT*PI*PI)

   end

   read_ADP_tensor ::: leaky
   ! Read the ADP (thermal) from "stdin". These are assumed to be in the
   ! cartesian axis system, and in bohr^2.  The expansion of the thermal
   ! smearing temperature factor term is:
   !              TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where (h) are the miller indices and (a^*) are the reciprocal lattice
   ! constants in angstrom^{-2}.
   ! NOTE: The pADP_vector/pADP_errors are set also.
      ADP :: VEC{REAL}(6)

      ! Read elements in lexical order
      stdin.read_quantity(ADP)

      ! Set the tensor
      .reset_pADPs_and_errors(9)
      .set_ADP_tensor(ADP)

   end

   read_ADP3_tensor ::: leaky
   ! Read the third-order ADP (thermal) tensor, assumed to be in the
   ! cartesian axis system, and in bohr^2. The interpretation of these
   ! coefficients as Gram-Charlier, Edgeworth, cumulants or other is
   ! not specified.
      tensor :: VEC{REAL}(10)

      ! Read elements in lexical order
      stdin.read_quantity(tensor)

      ! Set the tensor
      .reset_pADPs_and_errors(19)
      .set_ADP3_vector_to(tensor)

   end

   read_ADP4_tensor ::: leaky
   ! Read the fourth-order ADP (thermal) tensor, assumed to be in the
   ! cartesian axis system, and in bohr^2. The interpretation of these
   ! coefficients as Gram-Charlier, Edgeworth, cumulants or other is
   ! not specified.
      tensor :: VEC{REAL}(15)

      ! Read elements in lexical order
      stdin.read_quantity(tensor)

      ! Set the tensor
      .reset_pADPs_and_errors(34)
      .set_ADP4_vector_to(tensor)

   end

!  ====================
!  Key related routines
!  ====================

   read_keys ::: get_from(OBJECT), leaky
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   ENSURE(keys.created,"no keys")
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT), leaky
   ! This is for destroying the "keys" externally.
   end

!  ===================
!  Axis change methods
!  ===================

   resolve_axis_system(cell)
   ! Change the axis system for the position and ADP (thermal) tensors to
   ! "cartesian". "crystal" holds the axis system information.
      cell :: UNIT_CELL, IN

      .position_from(cell)
      .ADP_tensors_from(cell)

   end

   change_axis_system_to(axiskind,cell)
   ! Change the axis system for the position *and* ADP (thermal) tensors
   ! to "axiskind", either crystal or cartesian.
   ! NOTE: Errors are *not* transformed since that needs covariances.
   !       The errors must be transformed outside this routine.
      axiskind :: STR, IN
      cell :: UNIT_CELL, IN

      select case (axiskind)

         case ("cartesian")
            .position_from(cell)
            .ADP_tensors_from(cell)

         case ("crystal  ")
            .position_to(cell)
            .ADP_tensors_to(cell)

         case default
            UNKNOWN(axiskind)

      end


   end

   position_from(cell)
   ! Change atom positions in the crystal axis system to the
   ! cartesian axis system
      cell :: UNIT_CELL, IN

      pos :: VEC{REAL}(3)

      select case (.axis_system)

         case ("crystal  ")
            pos.to_product_of(cell.direct_matrix,.position)
            .set_position(pos)
            .axis_system = "cartesian"

         case ("cartesian")
            ! do nothing

         case default
            UNKNOWN(.axis_system)

      end

   end

   position_to(cell)
   ! Change atom positions in the cartesian axis system to the
   ! the crystal axis system
      cell :: UNIT_CELL, IN

      pos :: VEC{REAL}(3)

      select case (.axis_system)

         case ("crystal  ")
            ! do nothing

         case ("cartesian")
            pos.to_product_of(cell.inverse_matrix,.position)
            .set_position(pos)
            .axis_system = "crystal"

         case default
           UNKNOWN(.axis_system)

      end

   end

   ADP_tensors_from(cell)
   ! Change *all* ADP tensor from the crystal axis system to the
   ! cartesian axis system
      cell :: UNIT_CELL, IN

      select case (.axis_system)

         case ("crystal  ")
            .ADP4_tensor_from(cell)
            .ADP3_tensor_from(cell)
            .ADP2_tensor_from(cell)
            .ADP_axis_system = "cartesian"

         case ("cartesian")
            ! do nothing

         case default
            UNKNOWN(.axis_system)

      end

   end

   ADP_tensors_to(cell)
   ! Change *all* ADP tensor in the cartesian axis system to the
   ! crystal axis system.
      cell :: UNIT_CELL, IN

      select case (.axis_system)

         case ("crystal  ")
            ! do nothing

         case ("cartesian")
            .ADP4_tensor_to(cell)
            .ADP3_tensor_to(cell)
            .ADP2_tensor_to(cell)
            .ADP_axis_system = "crystal"

         case default
           UNKNOWN(.axis_system)

      end

   end

   ADP2_tensor_from(cell) ::: private
   ! Change ADP (thermal) tensor from the crystal axis system to the
   ! cartesian axis system
      cell :: UNIT_CELL, IN

      ADP :: MAT{REAL}(3,3)
      chk :: BIN
      val :: REAL

      select case (.ADP_axis_system)

         case ("crystal  ")
  
            chk = FALSE

            ! Convert U_iso to an ADP and use it if necessary
            if (.U_iso>ZERO) then 

               if (.ADP_tensor.is_zero) then 

                  ! U_iso/U_eq always in cartesian
                  ! Change ADP to crystal axis system
                  ADP.to_unit_matrix
                  ADP = ADP*.U_iso       
                  ADP.change_basis_using(cell.reciprocal_U_matrix)
                  .set_ADP_tensor(ADP)   

               else                  

                  ! ADP exists already
                  ! Check U_iso later ...
                  chk = TRUE         

               end

            end 
   
            ! Change to cartesians
            .ADP_tensor.change_basis_to(ADP,cell.direct_U_matrix)
            .set_ADP_tensor(ADP)   

            ! Check if the supplied U_iso was correct
            if (chk) then
               val = THIRD*.ADP_tensor.trace
             ! WARN_IF(NOT .U_iso.equals(val),"inconsistent U_iso and ADP; replacing U_iso")
               .U_iso = val
            end

            ! Set axis system
            .ADP_axis_system = "cartesian"

         case ("cartesian")
            ! do nothing

         case default
            UNKNOWN(.ADP_axis_system)

      end

   end

   ADP3_tensor_from(cell) ::: private
   ! Change ADP3 vector from the crystal axis system to the
   ! cartesian axis system.
   ! NOTE: must call *before ADP2_tensor_from().
      cell :: UNIT_CELL, IN

      W :: MAT{REAL}*

      if (NOT .has_ADP3s_and_errors) return

      select case (.ADP_axis_system)

         case ("crystal  ")
  
            ! Transform ADP3's -- direct U cell matrix
            W.create(10,10)
            GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,cell.direct_U_matrix)
            .pADP_vector(10:19).to_product_of(W,.pADP_vector(10:19))
            W.destroy

         case ("cartesian")
            ! do nothing

         case default
            UNKNOWN(.ADP_axis_system)

      end

   end

   ADP4_tensor_from(cell) ::: private
   ! Change ADP4 vector from the crystal axis system to the
   ! cartesian axis system
   ! NOTE: must call *before ADP2_tensor_from().
      cell :: UNIT_CELL, IN

      W :: MAT{REAL}*

      if (NOT .has_ADP4s_and_errors) return

      select case (.ADP_axis_system)

         case ("crystal  ")
  
            ! Transform ADP4's -- direct U cell matrix
            W.create(15,15)
            GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,cell.direct_U_matrix)
            .pADP_vector(20:34).to_product_of(W,.pADP_vector(20:34))
            W.destroy

         case ("cartesian")
            ! do nothing

         case default
            UNKNOWN(.ADP_axis_system)

      end

   end

   ADP2_tensor_to(cell) ::: private
   ! Change ADP (thermal) tensor in the cartesian axis system to the
   ! crystal axis system
      cell :: UNIT_CELL, IN

      ADP :: MAT{REAL}(3,3)

      select case (.ADP_axis_system)

         case ("crystal  ")
            ! do nothing

         case ("cartesian")

            .ADP_tensor.change_basis_to(ADP,cell.reciprocal_U_matrix)
            .set_ADP_tensor(ADP)   

            ! Set axis system
            .ADP_axis_system = "crystal"

         case default
            UNKNOWN(.ADP_axis_system)

      end

   end

   ADP3_tensor_to(cell) ::: private
   ! Change ADP3 vector from the crystal axis system to the
   ! cartesian axis system.
   ! NOTE: must call *before ADP2_tensor_to().
      cell :: UNIT_CELL, IN

      W :: MAT{REAL}*

      if (NOT .has_ADP3s_and_errors) return

      select case (.ADP_axis_system)

         case ("crystal  ")
  
            ! Transform ADP3's -- reciprocal U cell matrix
            W.create(10,10)
            GAUSSIAN_DATA:symmetric_tensor_3_product_mx(W,cell.reciprocal_U_matrix)
            .pADP_vector(10:19).to_product_of(W,.pADP_vector(10:19))
            W.destroy

         case ("cartesian")
            ! do nothing

         case default
            UNKNOWN(.ADP_axis_system)

      end

   end

   ADP4_tensor_to(cell) ::: private
   ! Change ADP4 vector from the crystal axis system to the
   ! cartesian axis system.
   ! NOTE: must call *before ADP2_tensor_to().
      cell :: UNIT_CELL, IN

      W :: MAT{REAL}*

      if (NOT .has_ADP4s_and_errors) return

      select case (.ADP_axis_system)

         case ("crystal  ")
  
            ! Transform ADP4's -- reciprocal U cell matrix
            W.create(15,15)
            GAUSSIAN_DATA:symmetric_tensor_4_product_mx(W,cell.reciprocal_U_matrix)
            .pADP_vector(20:34).to_product_of(W,.pADP_vector(20:34))
            W.destroy

         case ("cartesian")
            ! do nothing

         case default
            UNKNOWN(.ADP_axis_system)

      end

   end

   change_coordinate_axes(axes)
   ! Change the coordiantes and ADP (thermal) tensors to be expressed
   ! in terms of a new set of orthogonal "axes". We must be n the
   ! cartesian axis system.
      axes :: MAT{REAL}(3,3), IN

   ENSURE(.axis_system=="cartesian","positions must be in cartesian axis system")
   ENSURE(.ADP_axis_system=="cartesian","U's must be in cartesian axis system")

      pos :: VEC{REAL}(3)
      ADP :: MAT{REAL}(3,3)

      pos.to_product_of(axes,.position)
      .set_position(pos)

      ! WARNING: this may not be correct
      .ADP_tensor.change_basis_to(ADP,axes) 
      .set_ADP_tensor(ADP)

   end

!  ========================
!  Basis resolution methods
!  ========================

   resolve_basis(basis,suffix,found) ::: template
   ! Resolve the basis BASE from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels 
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
      basis :: VEC{BASIS}*
      suffix :: STR, optional
      found :: BIN, optional

   DIE_IF(basis.destroyed,"no basis")

      library_label,symbol :: STR
      fnd :: BIN    

      fnd = FALSE

      ! First, try matching the basis from the "suffix" 
      ! e.g. like "Mg:STO-3G"
      if (present(suffix)) then
      if (suffix/=" ") then

        ! This makes "Mg:STO-3G"
        library_label = .library_basis_label(suffix)

        ! Pointer assign into "basis"
        BASE.resolve_by_label(library_label,basis,clobber=TRUE,found=fnd)

        ! Set the basis label
        if (fnd) LABEL = library_label

      end
      end

      ! Next, try matching the basis to an existing label, if there ...
      if (NOT fnd AND LABEL/=" ") then
         BASE.resolve_by_label(LABEL,basis,clobber=TRUE,found=fnd)
      end

      ! Last chance: try (minimal) matching using only the chemical symbol ...
      if (NOT fnd) then
         symbol = trim(.chemical_symbol)//":"
         BASE.resolve_by_label(symbol,basis,clobber=TRUE,minmatch=TRUE,found=fnd)
         if (fnd) LABEL = BASE.label
      end

      if (present(found)) found = fnd

   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASE=>.basis, LABEL=>.basis_label)
   ! Resolve the basis BASE from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels 
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS=>SLATERBASIS, BASE=>.slaterbasis, LABEL=>.slaterbasis_label)
   ! Resolve the basis BASE from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels 
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

   resolve_basis(basis,suffix,found) ::: get_from(ATOM, BASIS=>COPPENSBASIS, BASE=>.coppensbasis, LABEL=>.coppensbasis_label)
   ! Resolve the basis BASE from the list of them in "basis"
   ! . First, if "suffix" is present and not blank, generate a
   !   library basis label by concatenating the element symbol with
   !   the "suffix" e.g. "Mg:STO-3G"
   ! . If that fails, try to match any existing basis label with one
   !   of the labels from "basis" e.g. if the user entered their own
   !   basis with user-defined labels 
   ! . If that fails, try to matching using only the chemical symbol
   !   e.g. if the basis was obtained from reading an external
   !   program, like gaussian.
   end

!  =========================
!  Atom-kind inquiry methods
!  =========================

   has_a_dummy_label result (res) ::: elemental
   ! Return TRUE if this has a dummy charge label (charged or not,
   ! with basis set or not)
      self :: IN
      res :: BIN
      res = .label==ATOM_DUMMY_CHARGE_LABEL
   end

   is_a_dummy_atom result (res) ::: elemental
   ! Return TRUE if this is a dummy atom (no charge, no basis)
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND .nuclear_charge==ZERO AND .basis.destroyed
   end

   is_a_nondummy_atom result (res) ::: elemental
   ! Return TRUE if this is a *not* dummy atom
      self :: IN
      res :: BIN
      res = NOT .has_a_dummy_label OR .nuclear_charge/=ZERO OR .basis.created
   end

   is_a_ghost_atom result (res) ::: elemental
   ! Return TRUE if this is a ghost atom 
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND .nuclear_charge==ZERO AND .has_basis
   end

   is_a_point_charge result (res) ::: elemental
   ! Return TRUE if this is a point-charge (no basis set)
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND .nuclear_charge>ZERO AND .basis.destroyed
   end

   is_a_pseudo_atom result (res) ::: elemental
   ! Return TRUE if this is a pseudo atom without integral charge
      self :: IN
      res :: BIN
      res = .has_a_dummy_label AND NOT .nuclear_charge.is_int AND .has_basis
   end

   same_kind_as(atom) result (res)
   ! Return TRUE if self is the same kind of atom as "atom". The
   ! position and label are not compared since the same kind of atom
   ! can have a different position and label.  To check if the basis
   ! set is the same, only the label is used.
      atom :: ATOM
      res :: BIN

      bases_created,coppens_created,slater_created :: BIN
      bases_destroyed,coppens_destroyed,slater_destroyed :: BIN
      mixed :: BIN

      bases_created     = .basis.created        AND atom.basis.created
      coppens_created   = .coppensbasis.created AND atom.coppensbasis.created
      slater_created    = .slaterbasis.created  AND atom.slaterbasis.created

      bases_destroyed   = .basis.destroyed        AND atom.basis.destroyed
      coppens_destroyed = .coppensbasis.destroyed AND atom.coppensbasis.destroyed
      slater_destroyed  = .slaterbasis.destroyed  AND atom.slaterbasis.destroyed

      mixed = NOT (bases_created   OR bases_destroyed)   OR &
              NOT (coppens_created OR coppens_destroyed) OR &
              NOT (slater_created  OR slater_destroyed) 

      if (mixed) then
         res = FALSE
      else
         res = .atomic_number==atom.atomic_number 
         if (bases_created)   res = res AND .basis.label       ==atom.basis.label 
         if (coppens_created) res = res AND .coppensbasis.label==atom.coppensbasis.label 
         if (slater_created)  res = res AND .slaterbasis.label ==atom.slaterbasis.label 
      end

   end

   is_xtal_distinct_from(atom) result (res)
   ! Return true if self and "atom" are crystallographically
   ! distinct based on occupancy and atomic number
      atom :: ATOM
      res :: BIN
      res =        .atomic_number       /= atom.atomic_number 
      res = res OR .site_disorder_group /= atom.site_disorder_group 
      res = res OR NOT .site_occupancy.equals(atom.site_occupancy )
   end

   is_xtal_identical_to(atom) result (res)
   ! Return true if self and "atom" are crystallographically
   ! identical based on occupancy and atomic number
      atom :: ATOM
      res :: BIN
      res =         .atomic_number      ==atom.atomic_number 
      res = res AND .site_disorder_group==atom.site_disorder_group 
      res = res AND .site_occupancy.equals(atom.site_occupancy )

      if (.debugging("is_xtal_identical")) then
         stdout.text("Atoms not xtal identical ...")
         stdout.text("self:")
         .put
         stdout.text("atom:")
         atom.put
      end

   end

!  =====================
!  Basis inquiry methods
!  =====================

   has_basis result (res) ::: elemental
   ! Return TRUE if this is a pseudo atom without integral charge
      self :: IN
      res :: BIN
      res = .basis.created AND .basis.is_resolved
   end

   basis_descriptor result (res) ::: elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
      self :: IN
      res :: STR

      if (.basis.created) then
         res = .basis.label
         if (.is_a_ghost_atom) then
            res = trim(res)//" (ghost atom)"
         else if (.is_a_pseudo_atom) then
            res = trim(res)//" (pseudo atom)"
         end
      else if (.is_a_point_charge) then
         res = "n/a (pt. charge)"
      else if (.is_a_dummy_atom) then
         res = "n/a (dummy atom)"
      else
         res = "??"
      end

   end

   slaterbasis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, basis=>slaterbasis), elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
   end

   coppensbasis_descriptor result (res) ::: get_from(ATOM:basis_descriptor, basis=>coppensbasis), elemental
   ! Return a basis descriptor, either the .basis_label or whether the
   ! atom is a dummy or a ghost.
   end

   library_basis_label(suffix) result (label)
   ! Return a library basis set label by appending "suffix" to the
   ! chemical symbol.
      suffix :: STR

      label :: STR
      symbol :: STR

      symbol = .chemical_symbol

      select case (suffix)

         case ("Coppens","Clementi-Roetti")

            ! Replace bases for high atomic numbers
            ! where bases do not exist
            if (.atomic_number>55) then

               select case (.atomic_number)
                  case (56);     symbol = "Sr"
                  case (57:71);  symbol = "Y"
                  case (72:86);  symbol = .chemical_symbol(.atomic_number-32)
                  case (87);     symbol = "Rb"
                  case (88);     symbol = "Sr"
                  case (89:103); symbol = "Y"
               end

               WARN("Replaced basis for atom "//.chemical_symbol.trim//" with that for atom "//symbol.trim)

            end

            label = trim(symbol)//trim(.oxidation_state_str)//":"//trim(suffix)

         case default

            label = trim(symbol)//":"//trim(suffix)

      end

   end

   library_basis_label(Z,suffix) result (label) ::: selfless, leaky
   ! Return a library basis set label for the atom with atomic number
   ! "Z", by appending "suffix" to the chemical symbol.
      Z :: INT, IN
      suffix :: STR
   ENSURE(Z>=1 AND Z<=103,"Z out of range")

      label :: STR
      symbol :: STR

      symbol = element_symbols(Z)
      select case (suffix)
         case ("Coppens","Thakkar","Clementi-Roetti")
            if (Z>55) then
               select case (Z)
                  case (56);     symbol = "Sr"
                  case (57:71);  symbol = "Y"
                  case (72:86);  symbol = element_symbols(Z-32)
                  case (87);     symbol = "Rb"
                  case (88);     symbol = "Sr"
                  case (89:103); symbol = "Y"
               end
            end
            label = trim(symbol)//":"//trim(suffix)
         case default
            label = trim(symbol)//":"//trim(suffix)
      end

   end

   no_of_shells result (res) ::: pure
   ! Return the no of shells
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.no_of_shells
   end

   n_shell result (res) ::: pure
   ! Return the no of shells
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.n_shell
   end

   no_of_basis_functions result (res) ::: pure
   ! Evaluate and return the no. of basis functions
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.no_of_basis_functions
   end

   no_of_sph_basis_functions result (res) ::: pure
   ! Evaluate and return the no. of spherical basis functions
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.no_of_sph_basis_functions
   end

   n_bf result (res) ::: pure
   ! Return the no. of basis functions
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.n_bf
   end

   no_of_primitives result (res) ::: pure
   ! Return the no of primitives for this atom
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.no_of_primitives
   end

   no_of_sph_primitives result (res) ::: pure
   ! Return the no of primitives for this atom
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.no_of_sph_primitives
   end

   n_prim result (res) ::: pure
   ! Return the no of primitives for this atom
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.n_prim
   end

!  =============================
!  Chemical-data related inquiry
!  =============================

   chemical_symbol(Z) result (res) ::: elemental
   ! Return the chemical symbol for this atom. If "Z" is present then the symbol
   ! returned is the one for the atom with atomic number "Z".
      self :: IN
      Z :: INT, IN, optional
      res :: STR(len=2)

      atomic_number :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      if      (atomic_number==0) then;                      res = ATOM_DUMMY_CHARGE_LABEL
      else if (atomic_number<-1 OR atomic_number>103) then; res = "?"
      else;                                                 res = element_symbols(atomic_number)
      end

   end

   chemical_symbol(Z) result (res) ::: elemental, selfless
   ! Return the element symbol for the atom with atoic number "Z".
      Z :: INT, IN
      res :: STR
      if      (Z==0) then;          res = ATOM_DUMMY_CHARGE_LABEL
      else if (Z<-1 OR Z>103) then; res = "?"
      else;                         res = element_symbols(Z)
      end
   end

   mass result (res)
   ! Return the atomic mass for this atom
      res :: REAL
      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                                            res = atomic_masses(.atomic_number)
      end
   end

   mean_neutron_number result (res)
   ! Return the average (abundance weighted) number of neutrons for this atom,
   ! calculated roughly by subtracting the number of protons from the atomic mass.
      res :: REAL
      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                                            res = .mass - .atomic_number
      end
   end

   bragg_slater_radius result (res)
   ! Return the Bragg-Slater radius for this atom
   ! WARNING: this is in Angstroms!
      res :: REAL
      if      (.atomic_number<1 ) then; res = ZERO
      else if (.atomic_number>54) then; res = 1.30d0
      else;                             res = bragg_slater_radii(.atomic_number)
      end
   end

   neutron_scattering_length result (res)
   ! Return the neutron scattering length for this atom
      res :: REAL
      if (.atomic_number<1 OR .atomic_number>95) then; res = ZERO
      else;                                            res = neutron_scattering_lengths(.atomic_number)
      end
   end

   n_core_electrons(Z) result(noble)
   ! Return the number of core electrons for the atom in the n-shell
   ! one less than the valence shell.  If "Z" is present it is used as
   ! the atomic number.
      Z :: INT, optional
      noble :: INT

      p :: INT
      atomic_number,tmp,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      noble = 0
      if (atomic_number<1) return

      p = 1
      do
         n = (p+2)/2
         tmp = noble + 2*n**2
         if (atomic_number <= tmp) exit
         noble = tmp   ! add core electrons
         p = p + 1     ! next period
      end

   end

   period_number(Z) result(p)
   ! Return the period (i.e. row) on which the atom lies.
   ! If "Z" is present it is used as the atomic number.
      Z :: INT, optional

      p :: INT
      atomic_number,noble,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      p = 0
      if (atomic_number<1) return

      p = 1
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (atomic_number <= noble) exit
         p = p + 1
      end

   end

   column_number(Z) result(col)
   ! Return the periodic table column of the atom.
   ! If "Z" is present it is used as the atomic number.
       Z :: INT, optional
      col :: INT
      atomic_number,p,noble,n :: INT

      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      col = 0
      if (atomic_number<1) return

      p = 1
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (atomic_number <= noble) exit
         p = p + 1
      end
      noble = noble - 2*n**2
      col = atomic_number - noble

   end

   period_block(Z) result(b)
   ! Return the period block character in which the atom lies.
   ! If "Z" is present it is used as the atomic number.
       Z :: INT, optional
       b :: STR(len=1)
      p,col :: INT
      p   = .period_number(Z)
      col = .column_number(Z)
      if (p<4) then
         select case (col)
            case (1:2);   b = "s"
            case (3:8);   b = "p"
         end
      else if (p<6) then
         select case (col)
            case (1:2);   b = "s"
            case (3:12);  b = "d"
            case (13:18); b = "p"
         end
      else if (p<8) then
         select case (col)
            case (1:2);   b = "s"
            case (3:16);  b = "f"
            case (17:26); b = "d"
            case (27:32); b = "p"
         end
      else
         DIE("cannot assign for period "// trim(p.to_str))
      end
   end

   is_a_nonmetal(Z) result(res) ::: elemental
   ! Return whether the atom is a nonmetal.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      atomic_number :: INT

      ! Get atomic number
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      res = FALSE

      select case (atomic_number)
         case( 1: 2); res = TRUE !  H - He
         case( 6:10); res = TRUE !  C - Ne
         case(15:18); res = TRUE !  P - Ar
         case(34:36); res = TRUE ! Se - Kr
         case(53:54); res = TRUE !  I - Xe
         case(86   ); res = TRUE !  Rn     
      end

   end

   is_a_metalloid(Z) result(res) ::: elemental
   ! Return whether the atom is a metalloid.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      atomic_number :: INT

      ! Get atomic number
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z

      res = FALSE

      select case (atomic_number)
         case( 5   ); res = TRUE !  B
         case(14   ); res = TRUE ! Si
         case(32:33); res = TRUE ! Ge - As
         case(51:52); res = TRUE ! Sb - Te
         case(85   ); res = TRUE ! As
      end

   end

   is_a_metal(Z) result(res) ::: elemental
   ! Return whether the atom is a metalloid.
   ! If "Z" is present it is used as the atomic number.
      self :: IN
      Z :: INT, IN, optional
      res :: BIN

      metalloid,nonmetal :: BIN

      nonmetal  = .is_a_nonmetal(Z)
      metalloid = .is_a_metalloid(Z)

      res = NOT nonmetal AND NOT metalloid

   end

   ground_state_multiplicity(Z) result(mult)
   ! Return the ground state multiplicity for this atom according to Hunds rule
   ! (Note this is not neccesarily the real ground state, esp. for Cu)
   ! If "Z" is present it is used as the atomic number.
      Z :: INT, optional
      mult :: INT

      p,col :: INT

      ! Get period and column
      p   = .period_number(Z)
      col = .column_number(Z)

      mult = 0

      select case (p)

         case (0)

            ! Dummy atom or Electron
            mult = 1

         case (1,2,3) 

            ! First three periods
            select case (col)
               case (2,8);   mult = 1
               case (1,3,7); mult = 2
               case (4,6);   mult = 3
               case (5);     mult = 4
            end

         case (4,5)

            ! First two transition metal periods
            select case (col)
               case (2,12,18);      mult = 1
               case (1,3,11,13,17); mult = 2
               case (4,10,14,16);   mult = 3
               case (5,9,15);       mult = 4
               case (6,8);          mult = 5
               case (7);            mult = 6
            end

         case (6,7)

            ! First two actinide metal periods
            select case (col)
               case (2,16,26,32);         mult = 1
               case (1,3,15,17,25,27,31); mult = 2
               case (4,14,18,24,28,30);   mult = 3
               case (5,13,19,23,29);      mult = 4
               case (6,12,20,22);         mult = 5
               case (7,11,21);            mult = 6
               case (8,10);               mult = 7
               case (9);                  mult = 8
            end

         case default 

            DIE("cannot assign for period "// trim(p.to_str))

      end

   end

   dispersion_correction(wavelength) result (res)
   ! The dispersion correction which best matches the wavelength.
      self :: IN
      wavelength :: REAL
      res :: CPX

      if (.atomic_number<1 OR .atomic_number>92) then
         res = ZERO
      else
         ! The ranges for deciding these wavelengths are a bit arbirary!
         if      (wavelength < 1.15) then; res = dispersion_correction_Ag(.atomic_number) ! 0.559A=1.06au
         else if (wavelength < 2.1 ) then; res = dispersion_correction_Mo(.atomic_number) ! 0.709A=1.34au
         else if (wavelength < 3.6 ) then; res = dispersion_correction_Cu(.atomic_number) ! 1.541A=2.91au
         else;                             res = dispersion_correction_Cr(.atomic_number) ! 2.29A=4.33au
         end
      end

   end

   oxidation_state_str result (res) 
   ! Return the oxidation state string, i.e. if the oxidation state is +3, then
   ! the returned string is "3+"; or if the oxidation state is -1 then the
   ! returned string is "-". This is useful for resolving certain library basis
   ! labels.
      res :: STR
      charge :: INT
      charge = .oxidation_state
      if (charge==0) then
         res = " "
      else
         if (charge>0) then; res = "+"
         else;               res = "-"
         end
         charge = abs(charge)
         if (charge/=1) res = trim(charge.to_str)//trim(res)
      end
   end

   no_of_occupied_NOs(axiskind,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      axiskind :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT
   ENSURE(.occupation_numbers.created,"no occupation numbers")
      res = .occupation_numbers.no_of_occupied(axiskind,tol)
   end

   has_ANOs result (res)
   ! Return TRUE if the ANOs exists for the atom.
      res :: BIN
      res = .natural_orbitals.created AND .occupation_numbers.created
   end

   is_bonded_to(b,range_factor) result (res) ::: pure
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      self :: IN
      b :: ATOM, IN
      range_factor :: REAL, IN, optional
      res :: BIN

      t,bond,bond_min,bond_max,dx,dy,dz,r2 :: REAL

      if      ( .atomic_number<1) then; res = FALSE
      else if (b.atomic_number<1) then; res = FALSE
      else if ( .atomic_number>covalent_radii_ccdc.dim) then; res = FALSE
      else if (b.atomic_number>covalent_radii_ccdc.dim) then; res = FALSE
      else if (.site_disorder_group*b.site_disorder_group>0 AND .site_disorder_group/=b.site_disorder_group) then; res = FALSE
      else

         t = atom_bonded_range_factor 
         if (present(range_factor)) t = range_factor

         bond = .covalent_radius_ccdc + b.covalent_radius_ccdc
         bond_min = max(bond - t,ZERO)
         bond_max =     bond + t

         ! For HH, nothing closer than 0.9A
         if (self.atomic_number==1 AND b.atomic_number==1) bond_min = 0.7d0*BOHR_PER_ANGSTROM 

         dx = abs(.position(1) - b.position(1))
         dy = abs(.position(2) - b.position(2))
         dz = abs(.position(3) - b.position(3))
         if      (dx>bond_max) then; res = FALSE
         else if (dy>bond_max) then; res = FALSE
         else if (dz>bond_max) then; res = FALSE
         else
            r2 = dx*dx + dy*dy + dz*dz
            res = (r2 < bond_max*bond_max) AND (r2 > bond_min*bond_min)
         end

      end

   end

   is_nearby_to(b,dist) result (res)
   ! Return TRUE if atom "self" and atom "b" are nearby, i.e. within length
   ! "dist".
      b :: ATOM
      dist :: REAL
      res :: BIN
      tmp :: VEC{REAL}(3)
      r2 :: REAL
      tmp = .position - b.position
      tmp = abs(tmp)
      if      (tmp(1)>dist) then; res = FALSE
      else if (tmp(2)>dist) then; res = FALSE
      else if (tmp(3)>dist) then; res = FALSE
      else
         r2 = dot_product(tmp,tmp)
         res = (r2 < dist*dist)
      end
   end

   is_vdw_bonded_to(b,range_factor,vdw_range_pc) result (res)
   ! Return true if "self" is vdw bonded to "b". Atoms which are
   ! covalently bonded are not vand-der-waals bonded.  If present,
   ! "range_factor" is used to determine the distance range in which
   ! the atoms are regarded as covalent bonded. If present
   ! "vdw_range_pc" is the percentage increase in the vdw radius to be
   ! tolerated while still regarding the atoms vdw bonded (default
   ! 0%). This uses the CCDC method, as documented on their web page.
      b :: ATOM
      range_factor,vdw_range_pc :: REAL, optional
      res :: BIN

      t,bond,bond_max,dx,dy,dz,r2 :: REAL

      if      ( .atomic_number<1) then; res = FALSE
      else if (b.atomic_number<1) then; res = FALSE
      else if ( .atomic_number>covalent_radii_ccdc.dim) then; res = FALSE
      else if (b.atomic_number>covalent_radii_ccdc.dim) then; res = FALSE
      else if (.site_disorder_group*b.site_disorder_group>0 AND .site_disorder_group/=b.site_disorder_group) then; res = FALSE
      else if (.is_bonded_to(b,range_factor)) then; res = FALSE
      else

         t = atom_vdw_bonded_range_pc
         if (present(range_factor)) t = vdw_range_pc

         bond = .vdw_radius_ccdc + b.vdw_radius_ccdc
         bond_max = bond*t

         dx = abs(.position(1) - b.position(1))
         dy = abs(.position(2) - b.position(2))
         dz = abs(.position(3) - b.position(3))
         if      (dx>bond_max) then; res = FALSE
         else if (dy>bond_max) then; res = FALSE
         else if (dz>bond_max) then; res = FALSE
         else
            r2 = dx*dx + dy*dy + dz*dz
            res = (r2 < bond_max*bond_max)
         end

      end

   end

   minimum_basis_exponent result (res)
   ! Return the minimum exponent in the basis.
      res :: REAL
      res = ZERO
      if (.coppensbasis.created)     then; res = .coppensbasis.min_exponent
      else if (.slaterbasis.created) then; res = .slaterbasis.min_exponent
      else if (.basis.created)       then; res = .basis.min_exponent
      else
          DIE("no basis")
      end
   end

   r_max(cutoff) result (res)
   ! Return the distance "r_max" at which the basis function with the lowest
   ! exponent is less than the value "cutoff".
      cutoff :: REAL, IN
      res :: REAL

      if (.basis.destroyed) then; res = ZERO
      else;                       res = .basis.r_max(cutoff)
      end

   end

   r2_max(cutoff) result (res)
   ! Return the squared distance "r2_max" at which the basis function with the
   ! lowest exponent is less than the value "cutoff".
      cutoff :: REAL, IN
      res :: REAL

      if (.basis.destroyed) then; res = ZERO
      else;                       res = .basis.r2_max(cutoff)
      end

   end

   has_dipole result (res)
   ! Return TRUE if the atomic dipole is nonzero.
      res :: BIN
      res = NOT .dipole.is_zero
   end

   has_polarisability result (res)
   ! Return TRUE if the atomic dipole is nonzero.
      res :: BIN
      res =  NOT .charge_polarisability.is_zero &
          OR NOT .dipole_polarisability.is_zero
   end

   has_recognised_label result (res)
   ! Return TRUE if the label corresponds to a recognised chemical element.
      res :: BIN

      label,symbol :: STR
      lensym :: INT
      error :: BIN

      .label = label
      if (label.is_int) then    ! The label must be the atomic number
         res = TRUE
      else                      ! First part of the label is the element symbol
         lensym = label.index_of_nonalphabetical-1
         error = lensym>2 OR lensym==0
         if (error) then
            res = FALSE
            return
         end
         symbol = label(1:lensym)
         symbol(1:1).to_upper_case
         symbol(2:2).to_lower_case
         if (symbol=="D" OR symbol=="T" OR symbol(1:2)=="El") then
            res = TRUE
         else if (any(element_symbols(1:)==symbol(1:2))) then
            res = TRUE 
         else
            res = FALSE
         end
      end
   end

   covalent_radius_ccdc result (res) ::: pure
   ! Returns the CCDC covalent radius for this atom
      self :: IN
      res :: REAL
      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = covalent_radii_ccdc(.atomic_number)*BOHR_PER_ANGSTROM
      end
   end

   vdw_radius_ccdc result (res)
   ! Returns the CCDC vdw radius for this atom
      res :: REAL
      if      (.atomic_number<1  ) then; res = ZERO
      else if (.atomic_number>110) then; res = ZERO
      else;                              res = vdw_radii_ccdc(.atomic_number)*BOHR_PER_ANGSTROM
      end
   end

!  ====================
!  pADP inquiry methods
!  ====================

   has_pADPs_and_errors result (res) ::: pure
   ! Return TRUE if there are pADP's *and* their errors
   ! Also check if the dimensions are equal.
      self :: IN
      res :: BIN
      res = .pADP_vector.created AND .pADP_errors.created
      if (NOT res) return
      res = .pADP_vector.dim==.pADP_errors.dim
   end

!   has_pADP2s_and_errors result (res) ::: pure
!   ! Return TRUE if there are second-order ADP's and errors
!      self :: IN
!      res :: BIN
!      res = .has_pADPs_and_errors
!      if (NOT res) return
!      res = .pADP_vector.dim==9 AND .pADP_errors.dim==9
!   end

   has_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are third-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim>9
   end

   has_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are fourth-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim>19
   end

   has_only_ADP3s_and_errors result (res) ::: pure
   ! Return TRUE if there are *only* third-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim==19
   end

   has_only_ADP4s_and_errors result (res) ::: pure
   ! Return TRUE if there are *only* fourth-order ADP's and errors
      self :: IN
      res :: BIN
      res = .has_pADPs_and_errors
      if (NOT res) return
      res = res AND .pADP_vector.dim==34
   end

   has_anharmonic_ADPs result (res) ::: pure
   ! Return TRUE if there are anharmonic ADP's
      self :: IN
      res :: BIN
      res = .has_only_ADP3s_and_errors OR .has_only_ADP4s_and_errors
   end

   no_of_pADPs result (res) ::: pure
   ! Return the no. of positional/ADP parameters for refinement.
   ! NOTE: positions and second-order ADP's are always refined.
   ! i.e. there are always at least 9 pADPs, even if the pADP 
   ! vector is not created.
      self :: IN
      res :: INT

      if (.pADP_vector.created) then; res = .pADP_vector.dim
      else;                           res = 9
      end

   end

   tag_pADP_label(par_index) result (res)
   ! Return the unique tag with the positional-ADP label for parameter
   ! with index "par_index" e.g. "N13 Uxxy".
      par_index :: INT, IN
      res :: STR

   ENSURE(par_index.is_in_range([1,34]),"par_index out of range")

      res = trim(.tag)//" "//trim(.pADP_label(par_index))

   end

   pADP_label(par_index,form) result (res)
   ! Return the positional-ADP label for parameter with index
   ! "par_index". The specific "form" of the ADP's may be given;
   ! the default is "xyz-repeated" e.g. "xxyy. For other forms see 
   ! the code below.
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,34]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      fmt :: STR

      if (FALSE) self = self

      ! Set the symbol
      if (par_index<=3) then
      
         res = trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))

      else

         fmt = "xyz-repeated"
         if (present(form)) fmt = form

         res = " "

         select case (fmt)
            case ("underscore-123-repeated"); res = "U_"//trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("underscore-xyz-repeated"); res = "U_"//trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("underscore-xyz-power   "); res = "U_"//trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
            case ("123-repeated           "); res = "U" //trim(GAUSSIAN_DATA::p123_rep(par_index+1))
            case ("xyz-repeated           "); res = "U" //trim(GAUSSIAN_DATA::pxyz_rep(par_index+1))
            case ("xyz-power              "); res = "U" //trim(GAUSSIAN_DATA::pxyz_pow(par_index+1))
            case default; UNKNOWN(fmt)
         end

      end

   end

   ADP_label(par_index,form) result (res)
   ! Return the ADP label for parameter with index "par_index".
   ! Higher order indices can be obtained assuming they follow on in
   ! the usual pADP/gaussian lexical order.
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,31]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = .pADP_label(par_index+3,form)

   end

   ADP3_label(par_index,form) result (res)
   ! Return the ADP3 label for parameter with index "par_index"
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,10]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = .pADP_label(par_index+9,form)

   end

   ADP4_label(par_index,form) result (res)
   ! Return the ADP4 label for parameter with index "par_index"
      par_index :: INT, IN
      form :: STR, IN, optional
      res :: STR

   ENSURE(par_index.is_in_range([1,15]),"par_index out of range")
   DIE_IF(GAUSSIAN_DATA::l_max_saved<4,"not enough gaussian data")

      res = .pADP_label(par_index+19,form)

   end

!  =========
!  Invarioms
!  =========

   allred_rochow_en result (res)
   ! Returns the Allred-Rochow EN for this atom
      res :: REAL
      if      (.atomic_number<0 ) then; res = ZERO
      else if (.atomic_number>82) then; res = 1.0d0
      else;                             res = allred_rochow_electronegs(.atomic_number)*0.01d0
      end
   end

   invariom_covalent_radius result (res)
   ! Returns the covalent radius for this atom
      res :: REAL
      if      (.atomic_number<0  ) then; res = ZERO
      else if (.atomic_number>109) then; res = 1.0d0
      else;                              res = covalent_radii_invariom(.atomic_number)*0.01d0
      end
   end

   get_invariom_rotation(U,actual,reference,L,fail) ::: selfless
   ! Returns the invariom rotation matrix "U" which matches
   ! coordinates "reference" to "actual" in a least squares sense.
   ! Return the mean fitting error "L" or else "fail"  for failure.
      U :: MAT{REAL}, OUT
      actual,reference :: MAT{REAL}, IN
      L :: REAL
      fail :: BIN

   ENSURE(U.is_square,"U must be square")
   ENSURE(U.dim==actual.dim2,"U incompatible with actual")
   ENSURE(reference.dim2==actual.dim2,"reference incompatible with actual")

      U0,X,Rd :: MAT{REAL}*
      d,n,p,q,i,iteration :: INT
      val :: REAL

      ! Set dimension, number of points to fit
      d = U.dim1
      n = reference.dim2

      ! Set minimum L value
      L = ZERO

      ! Start with U being unit matrix
      U.to_unit_matrix

      ! Create antisymmetric matrix X, temporary rotation U
      X.create(d,d)
      U0.create(d,d)
      Rd.create(reference.dim1,reference.dim2)

      ! Repeatedly update U until converged
      iteration = 0
      fail = FALSE
      do

         iteration = iteration + 1

         ! Rotate actual positions
         Rd.to_product_of(U,actual,transpose_A=TRUE)

         ! Get the derivative of L wrt. X_pq
         do p = 1,d
            do q = 1,p
               val = ZERO
               do i = 1,n
                  val = val + Rd(p,i)*reference(q,i) - Rd(q,i)*reference(p,q)
               end
               val = -TWO*val
               X(p,q) =  val
               X(q,p) = -val
            end
            X(p,p) = ZERO
         end

         ! Get maximum gradient
         val = maxval(abs(X))

         ! Exit if gradient converged or too many iteration
         if (val<TOL(4)) exit
         fail = iteration==1000
         if (fail) exit

         ! Otherwise scale X so the maximum value is less than 0.1
         val = TOL(1)/val
         X = X*val

         ! Exponentiate X
         X.exponentiate_to(U0)

         ! Update U
         X.to_product_of(U,U0)
         U = X

      end

      ! Clean up
      Rd.destroy; U0.destroy; X.destroy

      ! If failed, return, otherwise calculate L
      if (fail) return

      Rd.create(reference.dim1,reference.dim2)
      Rd.to_product_of(U,reference)

      L = ZERO
      do i = 1,d
         L = L + dot_product(actual(:,i),actual(:,i)) &
               + dot_product(reference(:,i),reference(:,i)) &
               - TWO*dot_product(actual(:,i),Rd(:,i))
      end
      L = sqrt(L)/d

      Rd.destroy
      
   end

!  =========================
!  Density plotting routines
!  =========================

   make_density_grid(density_grid,pt,occ)
   ! Make the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector. 
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")

      select case (.basis_kind)

         case ("gaussian")
            if (.use_interpolator AND .interpolator.created) then
               .make_interpolated_density(density_grid,pt,occ)
            else
               ENSURE(.basis.created,"no basis")
               ENSURE(.natural_orbitals.created,"no natural_orbitals")
               if (.natural_orbitals.number_kind=="real") then; .make_density_grid_r(density_grid,pt,occ)
               else;                                            .make_density_grid_c(density_grid,pt,occ)
               end
            end

         case ("slater")
            ENSURE(.slaterbasis.created,"no slaterbasis")
            .slaterbasis.make_density_grid(density_grid,pt,.position,occ)

         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppensbasis")
            .coppensbasis.make_density_grid(density_grid,pt,.position,occ)

         case default
            UNKNOWN(.basis_kind)

      end

   end

   add_density_grid(density_grid,pt,occ)
   ! Add the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector. 
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")

      select case (.basis_kind)
         case ("gaussian")
            if (.use_interpolator AND .interpolator.created) then
               .add_interpolated_density(density_grid,pt,occ)
            else
               ENSURE(.basis.created,"no basis")
               ENSURE(.natural_orbitals.created,"no natural orbitals")
               if (.natural_orbitals.number_kind=="real") then; .add_density_grid_r(density_grid,pt,occ)
               else;                                            .add_density_grid_c(density_grid,pt,occ)
               end
            end
         case ("slater")
            ENSURE(.slaterbasis.created,"no slaterbasis")
            .slaterbasis.add_density_grid(density_grid,pt,.position,occ)
         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppensbasis")
            .coppensbasis.add_density_grid(density_grid,pt,.position,occ)
         case default
            UNKNOWN(.basis_kind)
      end

   end

   make_density_grid_r(density_grid,pt,occ)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      NO :: VEC{REAL}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      density_grid = ZERO ! set to zero

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
       .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
       density_grid = density_grid + .occupation_numbers.restricted(n)*NO*NO
      end

      if (do_occ) density_grid = occ*density_grid

      NO.destroy

   end

   add_density_grid_r(density_grid,pt,occ)
   ! Add the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      NO :: VEC{REAL}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      if (do_occ) then
        do n = 1,n_occ
          .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
          density_grid = density_grid + occ*.occupation_numbers.restricted(n)*NO*NO
        end
      else
        do n = 1,n_occ
          .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.position)
          density_grid = density_grid +     .occupation_numbers.restricted(n)*NO*NO
        end
      end

      NO.destroy

   end

   make_density_grid_c(density_grid,pt,occ)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted_complex"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      NO :: VEC{CPX}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
         do_occ = TRUE
      end
      end

      density_grid = ZERO ! set to zero

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      do n = 1,n_occ
         .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
         density_grid = density_grid + .occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
      end

      if (do_occ) density_grid = occ*density_grid 

      NO.destroy

   end

   add_density_grid_c(density_grid,pt,occ)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted_complex"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      NO :: VEC{CPX}*
      n_occ,n :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
         do_occ = TRUE
      end
      end

      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs

      if (do_occ) then
         do n = 1,n_occ
            .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
            density_grid = density_grid &
                         + occ*.occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
         end
      else
         do n = 1,n_occ
            .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.position)
            density_grid = density_grid &
                         + .occupation_numbers.restricted(n)*REALIFY(conjg(NO)*NO)
         end
      end

      NO.destroy

   end

   make_density_grid(density_grid,pt,D,occ)
   ! Make the "density_grid" for the supplied points "pt" from a
   ! density matrix "D"
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(D.is_square,"D, not square")
   ENSURE(D.dim1==.basis.no_of_basis_functions,"D, wrong size")

      g :: MAT{REAL}*
      W :: VEC{REAL}*
      i :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      W.create(D.dim1)
      g.create(pt.dim1,D.dim1)

      .make_AO_grid(g,pt,.position)

      do i = 1,pt.dim1
        W = matmul(g(i,:),D)
        density_grid(i) = sum(W*g(i,:))
      end

      if (do_occ) density_grid = occ*density_grid

      W.destroy
      g.destroy

   end

   add_density_grid(density_grid,pt,D,occ)
   ! Add the "density_grid" for the supplied points "pt" from a
   ! density matrix "D"
      self :: IN
      density_grid :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      D :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(D.is_square,"D, not square")
   ENSURE(D.dim1==.basis.no_of_basis_functions,"D, wrong size")

      g :: MAT{REAL}*
      W :: VEC{REAL}*
      i :: INT
      do_occ :: BIN

      ! Do occupation factor?
      do_occ = FALSE
      if (present(occ)) then
      if (NOT occ.equals(ONE)) then
        do_occ = TRUE
      end
      end

      W.create(D.dim1)
      g.create(pt.dim1,D.dim1)

      .make_AO_grid(g,pt,.position)

      if (do_occ) then
        do i = 1,pt.dim1
           W = matmul(g(i,:),D)
           density_grid(i) = density_grid(i) + occ*sum(W*g(i,:))
        end
      else
        do i = 1,pt.dim1
           W = matmul(g(i,:),D)
           density_grid(i) = density_grid(i) + sum(W*g(i,:))
        end
      end

      W.destroy
      g.destroy

   end


!   make_d_density_grid(d0_density,d1_density,d2_density,pt)
!   ! Work out the 1st derivative density "d1_density" and 2nd
!   ! derivative "d2_density" on a set of points "pt" for interpolated
!   ! densities.
!      self :: IN
!      d0_density :: VEC{REAL}, OUT
!      d1_density :: MAT{REAL}, OUT
!      d2_density :: MAT3{REAL}, OUT
!      pt :: MAT{REAL}, IN
!   ENSURE(d0_density.dim==pt.dim1,"inconsistent number of points")
!      select case (.basis_kind)
!         case ("gaussian")
!            DIE("gaussian case, use different routines")
!         case ("slater")
!            ENSURE(.slaterbasis.created,"no slaterbasis")
!            .slaterbasis.make_d_density_grid(d0_density,d1_density,d2_density,pt,.position)
!         case ("coppens")
!            DIE("not implemented yet")
!         case default
!            UNKNOWN(.basis_kind)
!      end
!      if (NOT .site_occupancy.same_as(ONE)) then
!         d0_density = .site_occupancy*d0_density
!         d1_density = .site_occupancy*d1_density
!         d2_density = .site_occupancy*d2_density
!      end
!   end

!  ========================
!  Orbital density routines
!  ========================

   make_AO_grid(g,pt,pos)
   ! Evaluate the AO density grid "g" on a set of grid points "pt" for an atom at position
   ! "pos". 
      g :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim1==g.dim1,"pt and g, incompatible")
   ENSURE(.basis.no_of_basis_functions==g.dim2,"pt and g, incompatible")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sh :: SHELL1
      f,l,s :: INT

      l = 0
      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),pos)
         f = l + 1
         l = l + sh.n_comp
         sh.make_grid(g(:,f:l),pt)
      end

   end

   make_orbital_grid_r(g,orb,pt,pos,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt" for an atom at position
   ! "pos". If "square" is present and TRUE, the square of the orbital density
   ! is returned.
      g :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN
      square :: BIN, optional, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,f,l,s :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      g = ZERO
      l = 0
      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),pos)
         f = l + 1
         l = f + sh.n_comp - 1
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product_of(sh_grid,orb(f:l))
         sh_grid.destroy
      end

      if (sq) g = g*g

   end

   make_orbital_grid_c(g,orb,pt,pos,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt" for an atom at position
   ! "pos". If "square" is present and TRUE, the square of the orbital density
   ! is returned.
      self :: IN
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN
      square :: BIN, optional, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(pt.dim2==3,"wrong size, pt")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,f,l,s :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1
      g = ZERO
      l = 0
      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),pos)
         f = l + 1
         l = f + sh.n_comp - 1
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product_of(sh_grid,orb(f:l))
         sh_grid.destroy
      end

      if (sq) g = conjg(g)*g

   end

!  ======================
!  Spherical density at R
!  ======================

   density_at_radius(R) result (res)
   ! Work out the electron at radius "R".
      R :: REAL, IN
      res :: REAL

      density_grid :: VEC{REAL}(1)
      pt :: MAT{REAL}(1,3)

      res = ZERO
      select case (.basis_kind)
         case ("gaussian")
            ENSURE(.basis.created,"no basis")
            pt(1,:) = .position + [R,ZERO,ZERO]
            if (.natural_orbitals.number_kind == "real") then; .make_density_grid_r(density_grid,pt)
            else;                                              .make_density_grid_c(density_grid,pt)
            end
            res = density_grid(1)
         case ("slater")
            ENSURE(.slaterbasis.created,"no slaterbasis")
            ENSURE(.slaterbasis.shell.created,"no slaterbasis shells")
            res = .slaterbasis.density_at_radius(R)
         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppensbasis")
            ENSURE(.coppensbasis.orbital.created,"no coppensbasis orbital")
            res = .coppensbasis.density_at_radius(R)
         case default
            UNKNOWN(.basis_kind)
      end

   end

   density_value_at_radius(R) result (res) ::: selfless, public
   ! Return the density values at the radial value "R".
   ! This assumes that the atomic density is spherical!
      R :: REAL, IN
      res :: REAL
      self :: ATOM*
      self => saved_self
      res = .density_at_radius(R)
   end

!   density_at_sqrt_radius2(R2) result (res) ::: selfless, public
!   ! Return the density values at the square root of radial value "R2".
!   ! This assumes that the atomic density is spherical!
!     R2 :: REAL, IN
!     res :: REAL
!     R :: REAL
!     self :: ATOM*
!     self => saved_self
!     R = sqrt(R2)
!     res = .density_at_radius(R)
!   end

!   density_at_sqrt_x1x(x) result (res) ::: selfless, public
!   ! The function r2 = (x/1-x) maps [0,1] -> [0,inf]. An even spacing
!   ! of points in x will lead to a distribution of points in r in the
!   ! range [0,inf] on which the density rho can be calculated. An
!   ! interpolation table of rho vs. x can be made.  The inverse of the
!   ! function is x = (r2/1+r2). These values of x can easily be
!   ! calculated from a given r2. The value of rho can then be
!   ! interpolated. This assumes that the atomic density is spherical!
!     x :: REAL, IN
!     res :: REAL
!
!     R :: REAL
!     self :: ATOM*
!
!
!     if (x>=ONE) then
!        res = ZERO
!     else
!        self => saved_self
!        R = .bragg_slater_radius*BOHR_PER_ANGSTROM*sqrt(x/(ONE-x))
!        res = .density_at_radius(R)
!     end
!
!   end

!  ============
!  Interpolator
!  ============

   make_interpolator(interpolator) ::: leaky
   ! Make the .interpolator for the atom density. If present,
   ! "interpolator" is used as a template to get the settings needed. 
   ! NOTE: This is for a gaussian basis set; for slater or coppens
   ! bases use the interpolators stored in those bases. 
      interpolator :: INTERPOLATOR*, optional

   ENSURE(.basis_kind=="gaussian","interpolation must be for a gaussian basis")

      ! Create a copy of the template if it exists
      if (present(interpolator)) then
      if (interpolator.created) then
         .interpolator.destroy
         .interpolator.create_copy(interpolator)
      end
      end

      ! If no template, create a default interpolator
      if (.interpolator.destroyed) .interpolator.create

      ! Set domain scale factor. May not be required.
      .interpolator.set_domain_scale_factor(.bragg_slater_radius*BOHR_PER_ANGSTROM)

      ! Set the interpolation table
      .set_saved_self ! Used by ATOM: function below
      .interpolator.set_even_spaced_data(ATOM::density_value_at_radius)

   end

   interpolator_table_length(tol) result (length)
   ! Return the interpolator table "length" for a given tolerance "tol" for the
   ! atom density. The interpolator is a default one.
      tol,length :: REAL

      interpolator :: INTERPOLATOR*

      interpolator.create  
      .set_saved_self   ! Used by function below
      length = interpolator.the_table_length(ATOM::density_value_at_radius,tol)
      interpolator.destroy

   end

   make_interpolated_density(density,pt,occ)
   ! Make the spherical atomic "density" for the supplied points "pt"
   ! using a precalculated interpolator.
      self :: IN
      density :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.interpolator.created,"no interpolator defined!")
   ENSURE(.interpolator.domain_mapping(1:4)=="sqrt","must using sqrt-like mapping")

      R2 :: VEC{REAL}*
      n_pt,n :: INT
      x,y,z :: REAL

      ! Space for R2
      n_pt = pt.dim1
      R2.create(n_pt)

      ! Get squared distances R2
      do n = 1,n_pt
        x = pt(n,1) - .position(1)
        y = pt(n,2) - .position(2)
        z = pt(n,3) - .position(3)
        R2(n) = x*x + y*y + z*z
      end

      ! Get the interpolated density values
      .interpolator.values_for(R2,density,occ)

      ! Clean up
      R2.destroy

   end

   add_interpolated_density(density,pt,occ)
   ! Add the spherical atomic "density" for the supplied points "pt"
   ! using a precalculated interpolator.
      self :: IN
      density :: VEC{REAL}, INOUT
      pt :: MAT{REAL}, IN
      occ :: REAL, IN, optional

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.interpolator.created,"no interpolator defined!")
   ENSURE(.interpolator.domain_mapping(1:4)=="sqrt","must using sqrt-like mapping")

      R2 :: VEC{REAL}*
      n_pt,n :: INT
      x,y,z :: REAL

      ! Space for R2
      n_pt = pt.dim1
      R2.create(n_pt)

      ! Get squared distances R2
      do n = 1,n_pt
        x = pt(n,1) - .position(1)
        y = pt(n,2) - .position(2)
        z = pt(n,3) - .position(3)
        R2(n) = x*x + y*y + z*z
      end

      ! Get the interpolated density values
      .interpolator.add_values_for(R2,density,occ)

      ! Clean up
      R2.destroy

   end

!  ===========================
!  Nabla density grid routines
!  ===========================

   make_nabla_density_grid(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid" on the set of point "pts".
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN
      if (.natural_orbitals.number_kind == "real") then
         .make_nabla_density_grid_r(nabla_grid,pts)
      else
         DIE("complex case not yet implemented")
      end
   end

   make_nabla_density_grid(nabla_grid,grid,pts)
   ! Work nabla of the density, "nabla_grid", and the density, "grid", evaluated
   ! on the set of points "pts".
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN
      if (.natural_orbitals.number_kind == "real") then
         .make_nabla_density_grid_r(nabla_grid,grid,pts)
      else
         DIE("complex case not yet implemented")
      end
   end

   make_nabla_density_grid_r(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid", on the grid "pts" using
   ! ".natural_orbitals" and the ".occupation" number vector.
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN
   ENSURE(pts.dim2==3,"wrong dimension for points array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong 1st dimension for nabla_grid array")
   ENSURE(nabla_grid.dim2==3,"wrong 2nd dimension for nabla_grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT
      n_pts = size(pts,1)
      nabla_grid = ZERO
      orb.create(n_pts)
      nabla_orb.create(n_pts,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
      end
      nabla_grid = TWO*nabla_grid
      orb.destroy
      nabla_orb.destroy
   end

   make_nabla_density_grid_r(nabla_grid,grid,pts)
   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
   ! using the grid "pts" and the ".natural_orbitals" and the ".occupation"
   ! number vector.
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN
   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT
      n_pts = size(pts,1)
      nabla_grid = ZERO
      grid = ZERO
      orb.create(n_pts)
      nabla_orb.create(n_pts,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
       grid(:) = grid(:) + occ*orb(:)*orb(:)
      end
      nabla_grid = TWO*nabla_grid
      orb.destroy
      nabla_orb.destroy
   end

   make_nabla_orbital_grid_r(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{REAL}
      h :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN
   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")
      orb_a :: VEC{REAL}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_pt,f,l,a :: INT
      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      l = 0
      do a = 1,.basis.n_shell
         sh.set(.basis.shell(a),.position)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         f = l + 1
         l = f + sh.n_comp - 1
         orb_a => orb(f:l)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h = h + matmul(sh_grid0,orb_a)
         sh_grid0.destroy
         sh_grid.destroy
      end
   end

!  ==========================
!  Laplacian density routines
!  ==========================

   make_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind == "real") then
        .make_laplacian_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_laplacian_grid_r(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1

      laplacian_grid = ZERO

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       laplacian_grid = laplacian_grid +  occ * (NO*(D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3)))
      end

      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_laplacian_orbital_grid_r(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{REAL}
      i :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid,sh_grid1 :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      orb_a :: VEC{REAL}*
      n_pt,f,l,a :: INT

      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      i = ZERO
      l = 0

      do a = 1,.basis.n_shell
         sh.set(.basis.shell(a),.position)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid1.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)
         f = l + 1
         l = f + sh.n_comp - 1
         orb_a => orb(f:l)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h(:,1) = h(:,1) + matmul(sh_grid1(:,:,1),orb_a)
         h(:,2) = h(:,2) + matmul(sh_grid1(:,:,2),orb_a)
         h(:,3) = h(:,3) + matmul(sh_grid1(:,:,3),orb_a)
         i = i + matmul(sh_grid0,orb_a)
         sh_grid0.destroy
         sh_grid1.destroy
         sh_grid.destroy
      end

   end

   make_rL_grid(laplacian_grid,pt)
   ! Work out the reduced "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind == "real") then
        .make_rL_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rL_grid_r(laplacian_grid,pt)
   ! Make the reduced "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL
      n_pt = pt.dim1
      laplacian_grid = ZERO
      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       laplacian_grid = laplacian_grid +  occ * ( &
          NO * (D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3)))
       rho = rho + occ*NO*NO
      end
      laplacian_grid = TWO*laplacian_grid/rho
      D.destroy
      P.destroy
      NO.destroy
      rho.destroy
   end

!  =============================
!  Energy density from rho grids
!  =============================

   make_E_hf_dens_from_rho_grid(E_grid,pt)
   ! Work out the energy density as the scaled electron density.
      E_grid :: VEC{REAL}
      pt :: MAT{REAL}

      fac :: REAL
      if (.atomic_number<1) then
         E_grid = ZERO
      else
         .make_density_grid(E_grid,pt)
         fac = .energy/.atomic_number
         E_grid = fac*E_grid
      end

   end

!  ===================================
!  Virial type energy density routines
!  ===================================

   make_H_from_virial_grid(H_grid,pt)
   ! Work out the energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(H_grid.dim)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_rH_from_virial_grid(H_grid,pt)
   ! Work out the reduced energy density using the virial relationsip 
   ! 2G + V = (1/4) L, or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(H_grid.dim)
      .make_rG_kinetic_energy_grid(G_grid,pt)
      .make_rL_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_H_Kirzhnits_grid(H_grid,pt)
   ! Work out the energy density using the Kirzhnits relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(H_grid.dim)
      .make_G_Kirzhnits_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_V_from_virial_grid(V,pt)
   ! Work out the potential energy density from using the 
   ! virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(V.dim)
      .make_G_kinetic_energy_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

   make_rV_from_virial_grid(V,pt)
   ! Work out the reduced potenbtial energy density from using the 
   ! virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(V.dim)
      .make_rG_kinetic_energy_grid(G,pt)
      .make_rL_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

   make_V_Kirzhnits_grid(V,pt)
   ! Work out the potential energy density from using the 
   ! Kirzhnits theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(V.dim)
      .make_G_Kirzhnits_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

!  ===============================
!  G-type kinetic density routines
!  ===============================

   make_G_kinetic_energy_grid(G_grid,pt)
   ! Work out the G-type kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_G_kinetic_energy_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_G_kinetic_energy_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      n_pt = pt.dim1
      G_grid = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       G_grid(:) = G_grid(:) &
                 + .occupation_numbers.restricted(n) &
                 * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
      end
      G_grid(:) = HALF*G_grid(:)
      P.destroy
      NO.destroy
   end

   make_rG_kinetic_energy_grid(G_grid,pt)
   ! Work out the reduced G-type kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_rG_kinetic_energy_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rG_kinetic_energy_grid_r(G_grid,pt)
   ! Make the reduced G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      rho,NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL
      n_pt = pt.dim1
      G_grid = ZERO
      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
       rho = rho + occ*NO*NO
      end
      G_grid = HALF*G_grid/rho
      P.destroy
      NO.destroy
      rho.destroy
   end

   make_G_Kirzhnits_grid(G_grid,pt)
   ! Work out the G-type Kirzhnits kinetic energy density (using nabla phi.nabla phi) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_G_Kirzhnits_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_G_Kirzhnits_grid_r(G_grid,pt)
   ! Make the G-type Kirzhnits kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      NO,rho,nab_ro2,lap_rho :: VEC{REAL}*
      G,L,nab_rho :: MAT{REAL}*
      lambda,k2,fac,occ,occ2 :: REAL
      n_occ,n,n_pt :: INT
      n_pt = pt.dim1
      rho.create(n_pt);       rho = ZERO
      lap_rho.create(n_pt);   lap_rho = ZERO 
      nab_ro2.create(n_pt)
      nab_rho.create(n_pt,3); nab_rho = ZERO 
      NO.create(n_pt)
      G.create(n_pt,3)
      L.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(L,G,NO,.natural_orbitals.restricted(:,n), pt)
       occ  = .occupation_numbers.restricted(n)
       occ2 = TWO*occ
       rho  = rho + occ *NO*NO
       nab_rho(:,1) = nab_rho(:,1) + occ2*NO*G(:,1)
       nab_rho(:,2) = nab_rho(:,2) + occ2*NO*G(:,1)
       nab_rho(:,3) = nab_rho(:,3) + occ2*NO*G(:,1)
       lap_rho = lap_rho + occ2*(NO*(L(:,1)+L(:,2)+L(:,3)) + (G(:,1)*G(:,1) + G(:,2)*G(:,2) + G(:,3)*G(:,3)))
      end
      L.destroy; G.destroy; NO.destroy
      nab_ro2 = nab_rho(:,1)*nab_rho(:,1) + nab_rho(:,2)*nab_rho(:,2) + nab_rho(:,3)*nab_rho(:,3)
      nab_rho.destroy
      lambda = ONE/72.0d0
      k2 = HALF/SIX
      fac = 0.3d0*(THREE*PI*PI)**(TWOTHIRDS)
      G_grid = fac*rho**(FIVE/THREE) + lambda*nab_ro2/rho + k2*lap_rho
      nab_ro2.destroy; lap_rho.destroy; rho.destroy
   end

!  ===============================
!  K-type kinetic density routines
!  ===============================

   make_K_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type kinetic energy density (using the nabla^2) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_K_kinetic_energy_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_K_kinetic_energy_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      n_pt = pt.dim1
      K_grid = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       K_grid(:) = K_grid(:) &
                 + .occupation_numbers.restricted(n) * NO * (D(:,1)+D(:,2)+D(:,3)) 
      end
      K_grid(:) = -HALF*K_grid(:)
      D.destroy
      P.destroy
      NO.destroy
   end

   make_rK_kinetic_energy_grid(K_grid,pt)
   ! Work out the reduced K-type kinetic energy density (using the nabla^2) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_rK_kinetic_energy_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rK_kinetic_energy_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL
      n_pt = pt.dim1
      K_grid = ZERO
      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       K_grid = K_grid + occ * NO * (D(:,1)+D(:,2)+D(:,3)) 
       rho = rho + occ*NO*NO
      end
      K_grid = -HALF*K_grid/rho
      D.destroy
      P.destroy
      NO.destroy
      rho.destroy
   end

!  =============
!  DFT potential
!  =============

   make_dft_xc_pot_grid(V,pt,exchange,correlation)
   ! Work out the DFT exchange-correlation potential "V" at a series of points
   ! "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR
      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      V = ZERO
      dft.new_r_potential(exchange,V,rho)
      dft.new_r_potential(correlation,V,rho)
      rho.destroy
   end

   make_dft_eff_pot_grid(V,pt,exchange,correlation)
   ! Work out the DFT effective potential "V" (i.e. the DFT potential plus the
   ! classical electric potential) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR
      rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL
      .make_electric_potential_grid(V,pt)
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.new_r_potential(exchange,V,rho)
      dft.new_r_potential(correlation,V,rho)
      rho.destroy
   end

   make_dft_energy_grid(V,pt,exchange,correlation)
   ! Work out the Slater DFT energy "V" (i.e. the Slater potential times the
   ! density plus the classical electric energy) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
      Ve,rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL
      .nuclear_potential(V,pt)
      Ve.create(V.dim)
      .make_electronic_pot_grid_r(Ve,pt,.density_matrix.restricted)
      V = -V - HALF*Ve
      Ve.destroy
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.new_r_energy_density(exchange,V,rho)
      dft.new_r_energy_density(correlation,V,rho)
      V = V*rho
      rho.destroy
   end

   make_H_dft_energy_grid(H_grid,pt,exchange,correlation)
   ! Work out the H DFT energy density "H_grid" on a set ofpoints "pt"
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      exchange,correlation :: STR
      G_grid :: VEC{REAL}*
      G_grid.create(H_grid.dim)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_dft_energy_grid(H_grid,pt,exchange,correlation)
      H_grid = H_grid + G_grid
      G_grid.destroy
   end

!  ==================
!  Electric potential
!  ==================

   make_electric_potential_grid(pot_grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
      if (.density_matrix.number_kind == "real") then
       .make_electric_potential_grid_r(pot_grid,pt,.density_matrix.restricted)
      else
       DIE("complex case not yet implemented")
      end
   end

   make_electric_potential_grid_r(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}
      elec_grid :: VEC{REAL}*
      .nuclear_potential(pot_grid,pt)
      elec_grid.create(size(pot_grid))
      .make_electronic_pot_grid_r(elec_grid,pt,dens)
      pot_grid.plus(elec_grid)
      elec_grid.destroy
   end

   make_electronic_pot_grid_r(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}, target

   ENSURE(.basis.created,"no basis set")

      Vab,Dba :: MAT{REAL}*
      sh :: SHELL2
      n_pt,n_shell_pairs,q,fa,fb,la,lb,k :: INT

      n_pt = pt.dim1
      n_shell_pairs = .basis.n_shell.triangle_number

      pot_grid = ZERO

      do q = 1,n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)

         Dba => dens(fa:la,fb:lb)

         Vab.create(sh.a.n_comp,sh.b.n_comp)

         if (fa/=fb) then
           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*Dba)
           end
         else
           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             pot_grid(k) = pot_grid(k) -     sum(Vab*Dba)
           end
         end

         Vab.destroy
         sh.destroy_ptr_part

      end

   end

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      i :: INT
      r,x,y,z,xi,yi,zi :: REAL

      values = ZERO
      x = .position(1)
      y = .position(2)
      z = .position(3)

      do i = 1,values.dim
         xi = pts(i,1) - x
         yi = pts(i,2) - y
         zi = pts(i,3) - z
         r  = sqrt(xi*xi + yi*yi + zi*zi)
         if (r>tiny(r)) then; values(i) = values(i) + .atomic_number/r
         else;                values(i) = values(i) + huge(ONE)
         end
      end

   end

!  =================================
!  DFT grids for all basis functions
!  =================================

   make_bf_grid(grid,pt)
   ! Make a "grid" on which all the atom basis functions are
   ! evaluated, for the supplied points "pt".
      self :: IN
      grid :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid.dim1==pt.dim1,"incompatible grid and pt arrays")
   ENSURE(grid.dim2==.no_of_basis_functions,"wrong size, grid array")

      sh :: SHELL1
      s,f,l :: INT

      l = 0
      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         l = l + sh.n_comp
         sh.make_grid(grid(:,f:l),pt)
      end

   end

   make_nabla_bf_grid(nabla_grid,pt)
   ! Make a "nabla_grid" on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt". 
      self :: IN
      nabla_grid :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(nabla_grid.dim1==pt.dim1,"incompatible nabla_grid and pt arrays")
   ENSURE(nabla_grid.dim2==.no_of_basis_functions,"wrong size, nabla_grid array")
   ENSURE(nabla_grid.dim3==3,"wrong size, nabla_grid array")

      sh :: SHELL1
      s :: INT

      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),.position)
         sh.make_nabla_grid(nabla_grid,pt)
      end

   end

   make_nabla_bf_grid(nabla_grid,grid,pt)
   ! Make a "nabla_grid" on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt". Also
   ! return "grid", which tabluates the values of all the atom basis
   ! functions on the grid points.
      self :: IN
      nabla_grid :: MAT3{REAL}, OUT
      grid :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(nabla_grid.dim1==pt.dim1,"incompatible nabla_grid and pt arrays")
   ENSURE(nabla_grid.dim2==.no_of_basis_functions,"wrong size, nabla_grid array")
   ENSURE(nabla_grid.dim3==3,"wrong size, nabla_grid array")
   ENSURE(grid.dim1==pt.dim1,"incompatible grid and pt arrays")
   ENSURE(grid.dim2==.no_of_basis_functions,"wrong size, grid array")

      sh :: SHELL1
      s,f,l :: INT

      l = 0
      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         l = l + sh.n_comp
         sh.make_nabla_grid(nabla_grid(:,f:l,1),nabla_grid(:,f:l,2),nabla_grid(:,f:l,3),grid(:,f:l),pt)
      end

   end


   make_bf_grid(grid0,pt,cutoff)
   ! Make a "grid0" on which all the atom basis functions are evaluated, for the
   ! supplied points "pt".
      self :: IN
      grid0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid0.dim1==pt.dim1,"incompatible grid0 and pt arrays")
   ENSURE(grid0.dim2==.no_of_basis_functions,"wrong size, grid0 array")

      x,y,z,r2 :: VEC{REAL}*
      sh :: SHELL1
      n_pt,s,f,l :: INT

      n_pt = pt.dim1 

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      l = 0
      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         l = l + sh.n_comp
         sh.make_grid(grid0(:,f:l),x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

   make_nabla_bf_grid(grid1,pt,cutoff)
   ! Make a nabla grid, "grid1", on which the gradient of all the atom basis
   ! functions are evaluated, for the supplied points "pt". 
      self :: IN
      grid1 :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL

   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid1.dim1==pt.dim1,"incompatible grid1 and pt arrays")
   ENSURE(grid1.dim2==.no_of_basis_functions,"wrong size, grid1 array")
   ENSURE(grid1.dim3==3,"wrong size, grid1 array")
      x,y,z,r2 :: VEC{REAL}*
      sh :: SHELL1
      n_pt,s :: INT

      n_pt = pt.dim1 

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),.position)
         sh.make_nabla_grid(grid1,x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

   make_nabla_bf_grid(grid1,grid0,pt,cutoff)
   ! Make a nabla grid "grid1" on which the gradient of all the atom basis functions
   ! are evaluated, for the supplied points "pt". Also return "grid0", which
   ! tabluates the values of all the atom basis functions on the grid points.
      self :: IN
      grid1 :: MAT3{REAL}, OUT
      grid0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      cutoff :: REAL
   ENSURE(.basis.created,"no basis set")
   ENSURE(pt.dim2==3,"wrong dimension for pt array")
   ENSURE(grid1.dim1==pt.dim1,"incompatible grid1 and pt arrays")
   ENSURE(grid1.dim2==.no_of_basis_functions,"wrong size, grid1 array")
   ENSURE(grid1.dim3==3,"wrong size, grid1 array")
   ENSURE(grid0.dim1==pt.dim1,"incompatible grid0 and pt arrays")
   ENSURE(grid0.dim2==.no_of_basis_functions,"wrong size, grid array")
      sh :: SHELL1
      n_pt,s,f,l :: INT
      x,y,z,r2 :: VEC{REAL}*

      n_pt = pt.dim1 

      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      .make_displaced_pts(x,y,z,r2,pt,n_pt)

      l = 0
      do s = 1,.basis.n_shell
         sh.set(.basis.shell(s),.position)
         f = l + 1
         l = l + sh.n_comp
         sh.make_nabla_grid(grid1(:,f:l,1),grid1(:,f:l,2),grid1(:,f:l,3),grid0(:,f:l),x,y,z,r2,cutoff)
      end

      r2.destroy
      z.destroy
      y.destroy
      x.destroy

   end

!  ================
!  Make point lists
!  ================

   make_logval(logval,r2,n_pt) ::: public
   ! For a list of points with distances "r2" from an atom center,
   ! return the log of the mkaximuk value "logval" which can be used
   ! to implement a cutoff.
      n_pt :: INT, IN
      logval :: VEC{INT}(n_pt), OUT
      r2 :: VEC{REAL}(n_pt), IN

   ENSURE(.basis.created,"no basis set")

      rr,ex :: REAL
      n :: INT

      ex = .basis.min_exponent

      do n = 1,n_pt

         rr = r2(n)
         logval(n) = ceiling(log10(exp(-ex*rr)))

      end

   end


   make_displaced_pts(dx,dy,dz,r2,pt,n_pt) ::: public
   ! For a list of points "pt" of length "n_pt", return displacements
   ! "dx", "dy", "dz", and their square "r2".
      n_pt :: INT, IN
      dx,dy,dz,r2 :: VEC{REAL}(n_pt), OUT
      pt :: MAT{REAL}(n_pt,3), IN

   ENSURE(.basis.created,"no basis set")

      px,py,pz, xx,yy,zz, rr :: REAL
      n :: INT

      px = .position(1) 
      py = .position(2) 
      pz = .position(3) 

      do n = 1,n_pt

         xx = pt(n,1) - px 
         yy = pt(n,2) - py
         zz = pt(n,3) - pz 
         rr = xx*xx + yy*yy + zz*zz

         dx(n)   = xx
         dy(n)   = yy
         dz(n)   = zz
         r2(n)   = rr

      end

   end

   make_displaced_skip_pts(dx,dy,dz,r2,skip,pt,n_pt,cutoff) ::: public
   ! For a list of points "pt" of length "n_pt", return displacements
   ! "dx", "dy", "dz", their square "r2" and "skip" which tells when
   ! the basis function is less than "cutoff".
      n_pt :: INT, IN
      dx,dy,dz,r2 :: VEC{REAL}(n_pt), OUT
      skip :: VEC{BIN}(n_pt), OUT
      pt :: MAT{REAL}(n_pt,3), IN
      cutoff :: REAL, IN

   ENSURE(.basis.created,"no basis set")

      px,py,pz, xx,yy,zz, rr,r2_max :: REAL
      n :: INT

      px = .position(1) 
      py = .position(2) 
      pz = .position(3) 

      r2_max = .r2_max(cutoff)

      do n = 1,n_pt

         xx = pt(n,1) - px 
         yy = pt(n,2) - py
         zz = pt(n,3) - pz 
         rr = xx*xx + yy*yy + zz*zz

         dx(n)   = xx
         dy(n)   = yy
         dz(n)   = zz
         r2(n)   = rr
         skip(n) = rr>r2_max

      end

   end


   make_significant_points(x,y,z,r2,skip,pt,cutoff) ::: leaky
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE.
      x,y,z,r2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      cutoff :: REAL, IN

   ENSURE(.basis.created,"no basis set")

      px,py,pz,xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1

      skip.create(n_pt)
      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      r2_max = .r2_max(cutoff)

      px = .position(1) 
      py = .position(2) 
      pz = .position(3) 

      k = 0
      do n = 1,n_pt
         xx = pt(n,1) - px 
         yy = pt(n,2) - py 
         zz = pt(n,3) - pz 
         rr = xx*xx + yy*yy + zz*zz
         skip(n) = rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy; y.destroy; z.destroy
         r2.destroy
      else
         x.shrink(k); y.shrink(k); z.shrink(k)
         r2.shrink(k)
      end

   end

   make_significant_points(x,y,z,r2,d2,skip,pt,cutoff) ::: leaky
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE.
      x,y,z,r2,d2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      cutoff :: REAL, IN
   ENSURE(.basis.created,"no basis set")

      px,py,pz,xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1
      skip.create(n_pt)
      x.create(n_pt); y.create(n_pt); z.create(n_pt)
      r2.create(n_pt); d2.create(n_pt)

      r2_max = .r2_max(cutoff)

      px = .position(1) 
      py = .position(2) 
      pz = .position(3) 

      k = 0
      do n = 1,n_pt
         xx = pt(n,1) - px 
         yy = pt(n,2) - py 
         zz = pt(n,3) - pz 
         rr = xx*xx + yy*yy + zz*zz
         d2(n) = rr
         skip(n) = rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy; y.destroy; z.destroy
         r2.destroy; d2.destroy
      else
         x.shrink(k); y.shrink(k); z.shrink(k)
         r2.shrink(k) ! don't shrink d2 or skip
      end
   
   end

   make_significant_points(x,y,z,r2,skip,pt,skip2,cutoff) ::: leaky
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE. "skip2" is an array
   ! which skips (in addition) some preselcted points.
      x,y,z,r2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      skip2 :: VEC{BIN}, IN
      cutoff :: REAL, IN
   ENSURE(.basis.created,"no basis set")
      xx,yy,zz,rr, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1

      skip.create(n_pt)
      x.create(n_pt)
      y.create(n_pt)
      z.create(n_pt)
      r2.create(n_pt)

      r2_max = .r2_max(cutoff)
      k = 0

      do n = 1,n_pt
         xx = pt(n,1) - .position(1) 
         yy = pt(n,2) - .position(2) 
         zz = pt(n,3) - .position(3) 
         rr = xx*xx + yy*yy + zz*zz
         skip(n) = skip2(n) OR rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy; y.destroy; z.destroy
         r2.destroy
      else
         x.shrink(k); y.shrink(k); z.shrink(k)
         r2.shrink(k) ! don't shrink skip
      end

   end

!  ============================
!  Make basis shell information
!  ============================

   make_shell_info ::: leaky
   ! Define a vector of atom numbers corresponding to the molecule
   ! basis set shell numbers; also define a vector of atom shell numbers
   ! corresponding to the molecule basis set shell number
   ENSURE(.basis.created,"no basis set")

      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .set_shell_limits(.first_basis_fn_for_shell,.last_basis_fn_for_shell)

      .make_precomputed_shellpairs

      GAUSSIAN_DATA:set_indices(maxval(.basis.shell.l))

   end

   set_shell_limits(first,last) ::: leaky
   ! Set the indices of first and last basis functions in a particular shell
   ! "s", first(s) and last(s), respectively.
      first,last :: VEC{INT}*
      n_shell,f,l,s :: INT

      n_shell = .basis.n_shell
      first.create(n_shell)
      last.create(n_shell)

      l = 0
      do s = 1,n_shell
         f = l + 1
         l = f + .basis.shell(s).n_bf - 1
         first(s) = f
         last(s)  = l
      end

   end

   make_precomputed_shellpairs ::: leaky
   ! Make a SHELLPAIR vector "shellpair" which includes precomputed data for the
   ! basis set.
   ! NOTE for later: n_unique_shells should be a basisvec routine.
   ! NOTE for later: precomputed_basis_shellpair should be a MAT{REAL} type

   ENSURE(.basis.created,"no basis set")

      n,a,b :: INT

      n = .basis.n_shell

      .precomputed_basis_shellpair.destroy
      .precomputed_basis_shellpair.create(n,n)

      do a = 1,n
      do b = 1,n
         .precomputed_basis_shellpair(a,b).copy_a(.basis.shell(a))
         .precomputed_basis_shellpair(a,b).copy_b(.basis.shell(b))
         .precomputed_basis_shellpair(a,b).make_precalculated_data
      end
      end

   end

   get_precomputed_shell_pair(shell,q,fa,la,fb,lb) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "q"
   ! Also return the basis function start indices "fa", "la", etc ...
      shell :: SHELL2, OUT
      q :: INT, IN
      fa,la,fb,lb :: INT, OUT

   ENSURE(.precomputed_basis_shellpair.created,"no precomputed basis shellpair data")
   ENSURE(.first_basis_fn_for_shell.created,"no first_basis_fn data")
   ENSURE(.last_basis_fn_for_shell.created,"no last_basis_fn data")

      a,b :: INT

      a  = (1+int(sqrt(8.0d0*q-7.0d0)))/2
      b  = q - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      shell.set_and_precompute_from(.precomputed_basis_shellpair(a,b),.position,.position,same_center=TRUE,skip=FALSE)

   end

!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), private, leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), private, leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG), private
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG), private
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL), private
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT}), private
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL}), private
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL}), private
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX}), private
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT3{REAL}), private
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("label",.label)
      stdout.dump("tag",.tag)
      stdout.dump("atomic_number",.atomic_number)
      stdout.dump("nuclear_charge",.nuclear_charge)
      stdout.dump("oxidation_state",.oxidation_state)
      stdout.dump("position",.position)
      stdout.dump("position_error",.position_error)
      stdout.dump("axis_system",.axis_system)
      stdout.dump("group",.group)
 
      stdout.dump("site_occupancy",.site_occupancy)
      stdout.dump("site_disorder_group",.site_disorder_group)
 
      stdout.dump("U_iso",.U_iso)
      stdout.dmpp("pADP_vector",.pADP_vector)
      stdout.dmpp("pADP_errors",.pADP_errors)
      stdout.dump("ADP_axis_system",.ADP_axis_system)
 
      stdout.dump("charge",.charge)
      stdout.dump("dipole",.dipole)
      stdout.dump("quadrupole",.quadrupole)
      stdout.dump("spin",.spin)
      stdout.dump("spin_dipole",.spin_dipole)
      stdout.dump("spin_quadrupole",.spin_quadrupole)
 
      stdout.dump("charge_polarisability",.charge_polarisability)
      stdout.dump("dipole_polarisability",.dipole_polarisability)
 
      stdout.dump("basis_label",.basis_label)
      stdout.dump("basis_kind",.basis_kind)
      .basis.dmpp("basis")
      stdout.dump("slaterbasis_label",.slaterbasis_label)
      .slaterbasis.dmpp("slaterbasis")
      stdout.dump("coppensbasis_label:STR",.coppensbasis_label)
      .coppensbasis.dmpp("coppensbasis")
      stdout.dump("kind",.kind)
      stdout.dump("is_unique_kind",.is_unique_kind)
 
      stdout.dump("energy",.energy)
      stdout.dmpp("atomic_orbitals",.atomic_orbitals)
      stdout.dmpp("density_matrix",.density_matrix)
      stdout.dmpp("natural_orbitals",.natural_orbitals)
      stdout.dmpp("occupation_numbers",.occupation_numbers)
      stdout.dump("ANOs_made",.ANOs_made)
      stdout.dump("spherical_atom_data_made",.spherical_atom_data_made)
 
      stdout.dump("use_interpolator",.use_interpolator)
      .interpolator.dmpp("interpolator")
      stdout.dump("ANO_interpolators_made",.ANO_interpolators_made)
      stdout.dump("interpolators_made",.interpolators_made)
 
      stdout.dmpp("first_basis_fn_for_shell",.first_basis_fn_for_shell)
      stdout.dmpp("last_basis_fn_for_shell",.last_basis_fn_for_shell)
      .precomputed_basis_shellpair.dmpp("precomputed_basis_shellpair",lower_triangle=TRUE)
      stdout.dump("shell_info_made",.shell_info_made)
 
      stdout.dump("invariom_label",.invariom_label)
      stdout.dump("protein_strand",.protein_strand)
      stdout.dump("residue_atom_code",.residue_atom_code)
      stdout.dump("residue_code",.residue_code)
      stdout.dump("residue_sequence_number",.residue_sequence_number)
 
      stdout.dump("mm_forcefield_name",.mm_forcefield_name)
      stdout.dump("mm_atom_type",.mm_atom_type)
      stdout.dump("mm_chargeL",.mm_charge)
      stdout.dump("restraining_position",.restraining_position)
      stdout.dump("restraining_force_constant",.restraining_force_constant)

   end

   dump(object_name,ptr) ::: get_from(OBJECT, TYPE=>ATOM)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT, TYPE=>ATOM)
   ! Dump pointer object data as text
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put out the atom information to file "stdout"

      .put_short

      if (.residue_sequence_number/=0) .put_mm_info

      if (.basis.created)              .basis.put
      if (.slaterbasis.created)        .slaterbasis.put
      if (.coppensbasis.created)       .coppensbasis.put

      .put_ANOs

   end

   put_short
   ! Put out the atom information to file "stdout"

      stdout.flush

      stdout.show("Label                  =",trim(.label))
      stdout.show("Unique tag             =",trim(.tag))
      stdout.show("Atomic No.             =",.atomic_number)
      stdout.show("Chemical symbol        =",trim(.chemical_symbol))
      stdout.show("Atom position          =",.position(1),.position(2),.position(3))

      stdout.show("Site disorder group    =",.site_disorder_group)
      stdout.show("Site occupancy         =",.site_occupancy)

   end

   put_ANOs
   ! Put out the ANO information to file "stdout"

      stdout.flush

      if (.atomic_orbitals.created) then
         stdout.flush
         stdout.text("Atomic orbitals:")
         stdout.flush
         stdout.put(.atomic_orbitals)
      end

      if (.density_matrix.created) then
         stdout.flush
         stdout.text("Density matrix:")
         stdout.flush
         stdout.put(.atomic_orbitals)
      end

      if (.natural_orbitals.created) then
         stdout.flush
         stdout.text("Natural occupations and orbitals:")
         stdout.flush
         stdout.put(.occupation_numbers)
         stdout.flush
         stdout.put(.natural_orbitals)
      end

   end

   put_mm_info
   ! Put out the MM/protien part of the atom information to file "stdout"
      stdout.flush
      stdout.show("Residue atom code       =",trim(.residue_atom_code))
      stdout.show("Residue code            =",trim(.residue_code))
      stdout.show("Residue sequence number =",.residue_sequence_number)
      stdout.show("MM forcefield name      =",.mm_forcefield_name)
      stdout.show("MM atom type            =",.mm_atom_type)
      stdout.show("MM charge               =",.mm_charge)
      stdout.show("Restraining position    =",.restraining_position)
      stdout.show("Restraining force       =",.restraining_force_constant)
   end

   put_natural_orbitals
   ! Put out the current associated molecular orbitals to file "out"
   ENSURE(.natural_orbitals.created,"no natural orbitals")
   ENSURE(.occupation_numbers.created,"no natural orbital occupations")
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put(.occupation_numbers)
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.natural_orbitals)
   end

   put_interpolator
   ! Put out the atom information to file "stdout"
      select case (.basis_kind)
         case ("slater")
            ENSURE(.slaterbasis.created,"no slaterbasis")
            stdout.flush
            stdout.text("Atom slaterbasis info:")
            .slaterbasis.interpolator.put
         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppensbasis")
            stdout.flush
            stdout.text("Atom coppensbasis info:")
            .coppensbasis.interpolator.put
         case default
            DIE("no interpolator for basis "//trim(.basis_kind)) 
      end
   end

end
