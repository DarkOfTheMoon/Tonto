!-------------------------------------------------------------------------------
!
! ATOM: a quantum mechanical atom, with a basis set
!
! (c) Dylan Jayatilaka, University of Western Asutralia, November 1997
!
! $Id$
!-------------------------------------------------------------------------------
module ATOM

   use TYPES
   use SYSTEM
   use STR
   use INT
   use BUFFER
   use TEXTFILE
   use VEC
   use MAT
   use MAT3
   use OPVEC
   use OPMAT
   use SHELL
   use BASIS

   implicit none         

#  include "macros"
#  include "atom.int"

!   type atom_type
!
!   STR :: label
!   ! The label for the atom (not necessarily unique)
!
!   INT :: atomic_number
!   ! The atomic number
!
!   STR :: axis_system
!   ! Specifies the coordinate axis system
!
!   VEC(3) :: pos
!   ! Atom position
!
!   MAT(3,3) :: thermal_tensor DEFAULT(ZERO)
!   ! The thermal tensor for the atom
!
!   STR :: thermal_axis_system
!   ! Specifies the thermal tensor coordinate axis system
!
!   BASIS, PTR :: basis DEFAULT_NULL
!   ! The basis for the atom
!
!   OPMAT, PTR :: natural_orbitals DEFAULT_NULL
!   ! The natural orbitals for the atom
!
!   OPVEC, PTR :: occupation DEFAULT_NULL
!   ! The occupation numbers for the atom
!
!   end

   !  The Periodic Table

   CHR(2), private :: element_symbols(103) = (/ &
    "H ",                                                                                "He", &
    "Li","Be",                                                  "B ","C ","N ","O ","F ","Ne", &
    "Na","Mg",                                                  "Al","Si","P ","S ","Cl","Ar", &
    "K ","Ca","Sc","Ti","V ","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr", &
    "Rb","Sr","Y ","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I ","Xe", &
    "Cs","Ba","La",     "Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu", &
                   "Hf","Ta","W ","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn", &
    "Fr","Ra","Ac",     "Th","Pa","U ","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr" /)

   !  Bragg-Slater radii taken from Aaron Lee's code

   VEC(54) :: bragg_slater_radii = (/ &
      0.35d0,0.35d0,                                           &
      1.45d0,1.05d0,0.85d0,0.70d0,0.65d0,0.60d0,0.50d0,0.45d0, &
      1.80d0,1.50d0,1.25d0,1.10d0,1.00d0,1.00d0,1.00d0,1.00d0, &
      2.20d0,1.80d0,                                           &
      1.60d0,1.40d0,1.35d0,1.40d0,1.40d0,                      &
      1.40d0,1.35d0,1.35d0,1.35d0,1.35d0,                      &
                    1.30d0,1.25d0,1.15d0,1.15d0,1.15d0,1.15d0, &
      1.30d0,1.30d0,                                           &
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      &
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0  /)

   !  Abundance weighted atomic masses taken from the WWW to be the same as Turbomol

   VEC(92) :: atomic_masses = (/ &
       1.007970d0,   4.002600d0, &
       6.939000d0,   9.012200d0,  10.811000d0,  12.011150d0,  14.006700d0,  15.999400d0,  18.998400d0,  20.183000d0, &
      22.989800d0,  24.312000d0,  26.981500d0,  28.086000d0,  30.973800d0,  32.064000d0,  35.453000d0,  39.948000d0, &
      39.102000d0,  40.080000d0, &
                    44.956000d0,  47.900000d0,  50.942000d0,  51.996000d0,  54.938000d0, &
                    55.850000d0,  58.933200d0,  58.710000d0,  63.540000d0,  65.370000d0, &
                                  69.720000d0,  72.590000d0,  74.921600d0,  78.960000d0,  79.909000d0,  83.800000d0, &
      85.470000d0,  87.620000d0,  &
                    88.905000d0,  91.220000d0,  92.906000d0,  95.940000d0,  99.000000d0, &
                   101.070000d0, 102.905000d0, 106.400000d0, 107.870000d0, 112.400000d0, &
                                 114.820000d0, 118.690000d0, 121.750000d0, 127.600000d0, 126.904000d0, 131.300000d0, &
     132.905000d0, 137.330000d0, &
                   138.910000d0, 140.115000d0, 140.908000d0, 144.240000d0, 146.920000d0, 150.360000d0, 151.965000d0, &
                   157.250000d0, 158.925000d0, 162.500000d0, 164.930000d0, 167.260000d0, 168.930000d0, 173.040000d0, &
                   174.970000d0, 178.490000d0, 180.950000d0, 183.850000d0, 186.210000d0, &
                   190.200000d0, 192.220000d0, 195.080000d0, 196.070000d0, 200.590000d0, &
                                 204.380000d0, 207.200000d0, 208.980000d0, 208.980000d0, 209.990000d0, 222.020000d0, &
     223.020000d0, 226.030000d0, &
                   227.030000d0, 232.040000d0, 231.040000d0, 238.030000d0 /)

   !  Abundance-weighted coherent neutron scattering lengths in fm taken from:
   !  International Tables for Crystallography, Vol. C, 1992, pp 384-391

   VEC(95) :: neutron_scattering_lengths = (/ &
      -3.7390,  3.2600, &
      -1.9000,  7.7900,  5.3000,  6.6460,  9.3600,  5.8030,  5.6540,  4.5470, &
       3.6300,  5.3750,  3.4490,  4.1490,  5.1300,  2.8470,  9.5770,  1.9090, &
       3.7100,  4.9000, & 
               12.2900, -3.4380,  -.3824,  3.6350, -3.7300, &
                9.5400,  2.5000, 10.3000,  7.7180,  5.6890, &
                         7.2879,  8.1929,  6.5800,  7.9700,  6.7950,  7.8000, &
       7.0800,  7.0200, &
                7.7500,  7.1600,  7.0540,  6.9500,  6.8000, &
                7.2100,  5.8800,  5.9100,  5.9220,  5.1000, &
                         4.0650,  6.2257,  5.5700,  5.8000,  5.2800,  4.8500, &
       5.4200,  5.0600, &
                8.2400,  4.8400,  4.4500,  7.6900, 12.6000,  4.2000,  6.7300, &
                9.5000,  7.3800, 16.9000,  8.0800,  8.0300,  7.0700, 12.4100, &
                7.2100,  7.7700,  6.9100,  4.7700,  9.2000, &
               11.0000, 10.6000,  9.6000,  7.6300, 12.6920, &
                         8.7760,  9.4017,  8.5307,  0.0000,  0.0000,  0.0000, & 
       0.0000, 10.0000, &
                0.0000, 10.6300,  9.1000,  8.4170, 10.5500, 14.1000,  8.3000 /)


   ! X-ray dispersion correction factors.
   ! First element is f', second is f".  Cr wavelength = 2.291A.

   CVEC(92) :: dispersion_correction_Cr = (/ &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),  (0.0d0, 0.0d0), &
     (0.0d0, 0.1d0),   (0.0d0, 0.1d0),   (0.1d0, 0.1d0),   (0.1d0, 0.2d0),  (0.1d0, 0.3d0), &
     (0.2d0, 0.4d0),   (0.2d0, 0.5d0),   (0.2d0, 0.6d0),   (0.3d0, 0.8d0),  (0.3d0, 0.9d0), &
     (0.3d0, 1.2d0),   (0.3d0, 1.4d0),   (0.2d0, 1.7d0),   (0.0d0, 2.1d0),  (-0.2d0, 2.6d0), &
     (-0.7d0, 3.1d0),  (-1.7d0, 3.7d0),  (-4.4d0, 0.5d0),  (-2.2d0, 0.6d0), (-1.8d0, 0.7d0), &
     (-1.6d0, 0.8d0),  (-1.4d0, 0.9d0),  (-1.2d0, 1.1d0),  (-1.1d0, 1.2d0), (-1.0d0, 1.4d0), &
     (-0.9d0, 1.6d0),  (-0.8d0, 1.8d0),  (-0.7d0, 2.1d0),  (-0.7d0, 2.3d0), (-0.7d0, 2.5d0), &
     (-0.7d0, 2.8d0),  (-0.7d0, 3.2d0),  (-0.7d0, 3.6d0),  (-0.7d0, 3.9d0), (-0.8d0, 4.3d0), &
     (-0.8d0, 4.8d0),  (-0.9d0, 5.3d0),  (-1.1d0, 5.9d0),  (-1.2d0, 6.4d0), (-1.4d0, 6.9d0), &
     (-1.7d0, 7.5d0),  (-2.0d0, 8.2d0),  (-2.3d0, 8.8d0),  (-2.8d0, 9.5d0), (-3.3d0, 10.3d0), &
     (-4.0d0, 11.1d0), (-5.0d0, 11.9d0), (-7.1d0, 13.1d0), (-9d0, 10d0),    (-12d0, 11d0), &
     (-11d0, 8d0),     (-14d0, 3d0),     (-10d0, 3d0),     (-9d0, 3d0),     (-8d0, 4d0), &
     (-7d0, 4d0),      (-7d0, 4d0),      (-6d0, 5d0),      (-6d0, 5d0),     (-6d0, 6d0), &
     (-6d0, 6d0),      (-5d0, 7d0),      (-5d0, 7d0),      (-5d0, 8d0),     (-5d0, 8d0), &
     (-5d0, 9d0),      (-5d0, 9d0),      (-5d0, 10d0),     (-5d0, 10d0),    (-5d0, 11d0), &
     (-5d0, 12d0),     (-5d0, 13d0),     (-5d0, 14d0),     (-5d0, 14d0),    (-5d0, 15d0), &
     (-5d0, 16d0),     (-6d0, 17d0),     (-6d0, 18d0),     (-7d0, 19d0),    (-8d0, 20d0), &
     (-9d0, 22d0),     (-10d0, 23d0),    (-11d0, 24d0),    (-12d0, 26d0),   (-13d0, 27d0), &
     (-15d0, 28d0),    (-17d0, 27d0)/)

   ! X-ray dispersion correction factors.
   ! First element is f', second is f".  Cu wavelength = 1.542A.

   CVEC(92) :: dispersion_correction_Cu = (/ &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),  (0.0d0, 0.0d0),   (0.0d0, 0.0d0), &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.1d0),  (0.0d0, 0.1d0),   (0.1d0, 0.1d0), &
     (0.1d0, 0.2d0),   (0.1d0, 0.2d0),   (0.1d0, 0.3d0),  (0.2d0, 0.4d0),   (0.2d0, 0.5d0), &
     (0.3d0, 0.6d0),   (0.3d0, 0.7d0),   (0.3d0, 0.8d0),  (0.3d0, 1.0d0),   (0.3d0, 1.3d0), &
     (0.3d0, 1.5d0),   (0.2d0, 1.8d0),   (0.1d0, 2.2d0),  (-0.1d0, 2.5d0),  (-0.5d0, 2.9d0), &
     (-1.1d0, 3.3d0),  (-2.2d0, 3.8d0),  (-3.1d0, 0.5d0), (-2.1d0, 0.6d0),  (-1.7d0, 0.7d0), &
     (-1.5d0, 0.8d0),  (-1.3d0, 0.9d0),  (-1.2d0, 1.0d0), (-1.1d0, 1.1d0),  (-1.0d0, 1.3d0), &
     (-1.0d0, 1.5d0),  (-0.9d0, 1.7d0),  (-0.8d0, 1.8d0), (-0.8d0, 2.0d0),  (-0.7d0, 2.2d0), &
     (-0.7d0, 2.5d0),  (-0.6d0, 2.7d0),  (-0.6d0, 3.0d0), (-0.6d0, 3.3d0),  (-0.6d0, 3.6d0), &
     (-0.6d0, 3.9d0),  (-0.6d0, 4.3d0),  (-0.7d0, 4.6d0), (-0.8d0, 5.0d0),  (-0.9d0, 5.4d0), &
     (-1.0d0, 5.8d0),  (-1.1d0, 6.2d0),  (-1.3d0, 6.7d0), (-1.6d0, 7.2d0),  (-1.9d0, 7.7d0), &
     (-2.3d0, 8.3d0),  (-2.7d0, 8.9d0),  (-3.1d0, 9.6d0), (-3.6d0, 10.2d0), (-4.4d0, 10.9d0), &
     (-5.3d0, 11.5d0), (-6.7d0, 12.4d0), (-9d0, 10.2d0),  (-12d0, 11.2d0),  (-11d0, 7d0), &
     (-10d0, 8d0),     (-13d0, 3d0),     (-9d0, 3d0),     (-8d0, 4d0),      (-8d0, 4d0), &
     (-7d0, 4d0),      (-7d0, 4d0),      (-6d0, 5d0),     (-6d0, 5d0),      (-6d0, 5d0), &
     (-6d0, 6d0),      (-6d0, 6d0),      (-5d0, 7d0),     (-5d0, 7d0),      (-5d0, 8d0), &
     (-5d0, 8d0),      (-5d0, 9d0),      (-5d0, 9d0),     (-5d0, 10d0),     (-5d0, 10d0), &
     (-5d0, 11d0),     (-5d0, 11d0),     (-5d0, 12d0),    (-5d0, 12d0),     (-5d0, 13d0), &
     (-5d0, 14d0),     (-5d0, 15d0) /)

   ! X-ray dispersion correction factors.
   ! First element is f', second is f".  Mo wavelength = 0.7107A.

   CVEC(92) :: dispersion_correction_Mo = (/ &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),  &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),  &
     (0.0d0, 0.1d0),   (0.0d0, 0.1d0),   (0.1d0, 0.1d0),   (0.1d0, 0.1d0),   (0.1d0, 0.1d0),  &
     (0.1d0, 0.2d0),   (0.1d0, 0.2d0),   (0.1d0, 0.2d0),   (0.2d0, 0.3d0),   (0.2d0, 0.3d0),  &
     (0.2d0, 0.4d0),   (0.2d0, 0.5d0),   (0.3d0, 0.6d0),   (0.3d0, 0.7d0),   (0.3d0, 0.8d0),  &
     (0.3d0, 0.9d0),   (0.3d0, 1.0d0),   (0.3d0, 1.1d0),   (0.3d0, 1.3d0),   (0.3d0, 1.5d0),  &
     (0.2d0, 1.6d0),   (0.2d0, 1.8d0),   (0.1d0, 2.0d0),   (-0.1d0, 2.2d0),  (-0.3d0, 2.4d0),  &
     (-0.6d0, 2.7d0),  (-0.9d0, 3.0d0),  (-1.4d0, 3.4d0),  (-2.3d0, 3.7d0),  (-2.8d0, 0.6d0),  &
     (-2.1d0, 0.6d0),  (-1.7d0, 0.7d0),  (-1.5d0, 0.8d0),  (-1.3d0, 0.8d0),  (-1.2d0, 0.9d0),  &
     (-1.1d0, 1.0d0),  (-1.0d0, 1.1d0),  (-0.9d0, 1.3d0),  (-0.8d0, 1.4d0),  (-0.8d0, 1.5d0),  &
     (-0.8d0, 1.6d0),  (-0.7d0, 1.8d0),  (-0.7d0, 1.9d0),  (-0.6d0, 2.1d0),  (-0.6d0, 2.3d0),  &
     (-0.6d0, 2.5d0),  (-0.5d0, 2.7d0),  (-0.5d0, 2.9d0),  (-0.5d0, 3.1d0),  (-0.5d0, 3.3d0),  &
     (-0.5d0, 3.5d0),  (-0.5d0, 3.7d0),  (-0.5d0, 3.9d0),  (-0.6d0, 4.1d0),  (-0.6d0, 4.3d0),  &
     (-0.7d0, 4.7d0),  (-0.7d0, 5.0d0),  (-0.7d0, 5.3d0),  (-0.8d0, 5.6d0),  (-0.8d0, 5.9d0),  &
     (-0.9d0, 6.1d0),  (-1.0d0, 6.4d0),  (-1.1d0, 6.7d0),  (-1.3d0, 7.1d0),  (-1.5d0, 7.5d0),  &
     (-1.7d0, 7.9d0),  (-2.0d0, 8.3d0),  (-2.2d0, 8.7d0),  (-2.5d0, 9.2d0),  (-2.9d0, 9.7d0),  &
     (-3.5d0, 10.2d0), (-4.1d0, 10.7d0), (-4.8d0, 11.1d0), (-5.5d0, 11.7d0), (-7d0, 9d0),  &
     (-8d0, 10d0),     (-8d0, 7d0),      (-7d0, 7d0),      (-7d0, 8d0),      (-7d0, 7d0),  &
     (-7d0, 8d0),      (-8d0, 8d0) /)

contains

!  ******************
!  Allocation methods
!  ******************

   create
   ! Create an atom
      PTR :: self
      nullify(self)
      allocate(self)
      .nullify_ptr_part
      ADD_MEM(ATOM_SIZE)
      .thermal_tensor = ZERO
      .axis_system = "cartesian"
      .thermal_axis_system = "cartesian"
   end

  create_copy(atom)
  ! Create a copy of atom.
    ATOM :: atom
    PTR :: self
    .create
    .copy(atom)
  end

  copy(atom)
  ! Make self a copy of atom.
    ATOM :: atom
    .label = atom.label
    .atomic_number = atom.atomic_number
    .pos = atom.pos
    .thermal_tensor = atom.thermal_tensor
    if (associated(atom.basis)) self.basis => atom.basis
  end

   destroy 
   ! Destroy an atom
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      deallocate(self)
      DELETE_MEM(ATOM_SIZE)
   end
  
   nullify_ptr_part
   ! Nullify the pointer parts of the atom
      nullify(.basis)
      nullify(.natural_orbitals)
      nullify(.occupation)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of an atom
      .basis.destroy
      .natural_orbitals.destroy
      .occupation.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end
 
   set_default
   ! Set a default atom
      .thermal_tensor = ZERO
      .label = "H"
      .atomic_number = 1
      .pos = (/ZERO,ZERO,ZERO/)
      .axis_system = "cartesian"
      .thermal_axis_system = "cartesian"
      .basis.create
      .basis.set_default
   end

!  *************
!  Input methods
!  *************

   read [leaky]
   ! Read data from "stdin" using keyword style input.
      STR :: word
      read_loop: do          ! Loop over keywords
         stdin.read(word)
         if (stdin.reverted) exit read_loop
         if (word=="end")    exit read_loop
         .process(word)      
      end do read_loop
!     .update
   end

   process(word) [leaky]
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case, 
   ! the sequence is processed as if it were a separate file.
      STR(*) :: word
      if (word.includes(" ")) then
         stdin.redirect([word])
         .read
      else
         select case (word)
            case("end");                  ! exit surrounding loop
            case("atom");                 .read
            case("units");                .read_units
            case("label");                .read_label
            case("axis_system");          .read_axis_system
            case("thermal_axis_system");  .read_thermal_axis_system
            case("pos");                  .read_pos
            case("thermal_tensor");       .read_thermal_tensor
            case("basis_label");          .read_basis_label
            case("basis");                .read_basis
            case default;                 DIE("unknown keyword, "//trim(word))
         end
      end
   end

   process(keyword) [leaky]
   ! Process each of the words in the "keyword" list.
      STRVEC :: keyword
      INT :: k,n_key
      n_key = size(keyword)
      do k = 1,n_key
         if (keyword(k)=="end") exit 
         .process(keyword(k)) 
      end
      ENSURE(k>=n_key,"unprocessed words remain in the keyword list")
!     .update
   end

   read_units
   ! Read a string which describes the units to be used
      stdin.set_default_units(stdin.next_str)
   end

   read_label
   ! Read an ATOM label followed by three coordinates (without basis set)
   ! from "stdin". 
      INT :: lensym,z
      STR :: symbol
      BIN :: error
      stdin.read(.label)         ! Input atom label
      if (.label.is_int) then    ! The label must be the atomic number
         z = .label.to_int
         .atomic_number = z
      else                       ! First part of the label is the element symbol
         lensym = .label.scan("123456789 ")-1
         error = lensym>2 OR lensym==0
         DIE_IF(error,"unacceptable atom symbol, "// trim(.label))
         symbol = .label(1:lensym)
         symbol(1:1).to_upper_case
         symbol(2:2).to_lower_case
         if (any(element_symbols==symbol(1:2))) then
            do z=1,size(element_symbols)
               if (element_symbols(z)==symbol(1:2)) exit
            end
           .atomic_number = z
         else
            DIE("unknown element symbol: "//trim(symbol))
         end
      end
   end

   read_axis_system
   ! Read a string which describes the axis system. Currently allowed is 
   ! "cartesian" or "crystal". NOTE: .thermal_axis_system is changed too.
      stdin.read(.axis_system)
      .thermal_axis_system = .axis_system
      select case (.axis_system)
        case ("cartesian","crystal")
        case default
          DIE("unknown axis system " // .axis_system.trim)
      end
   end

   read_thermal_axis_system
   ! Read a string which describes the thermal tensor axis system.
   ! Currently allowed, is "cartesian" or "crystal".
      stdin.read(.thermal_axis_system)   
      select case (.thermal_axis_system)
        case ("cartesian","crystal")
        case default
          DIE("unknown axis system " // .thermal_axis_system.trim)
      end
   end

   read_pos
   ! Read the ATOM coordinates from "stdin". 
      stdin.read(.pos)   
   end

   read_basis [leaky]
   ! Read an ATOM basis set from "stdin"
      if (.basis.destroyed) .basis.create 
      .basis.read
   end

   read_basis_label [leaky]
   ! Read only the ATOM basis set label from "stdin"
      if (.basis.destroyed) .basis.create 
      .basis.read_label
   end

   read_thermal_tensor
   ! Read thermal parameters from "stdin". These are normally in the crystal
   ! axis system.
   ! The thermal tensors are assumed to be in units (angstrom^2); the expansion
   ! of the thermal smearing temperature factor term is:
   !              TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where (h) are the miller indices and (a^*) are the reciprocal lattice
   ! constants in angstrom^{-2}.
      VEC(6) :: tensor
      BIN :: unknown_unit
      stdin.read(tensor)
      .thermal_tensor(1,1) = tensor(1) ! Units must be bohr^2
      .thermal_tensor(2,2) = tensor(2) ! unless over-ridden by stdin.default_units
      .thermal_tensor(3,3) = tensor(3) ! ... see below
      .thermal_tensor(1,2) = tensor(4)
      .thermal_tensor(1,3) = tensor(5)
      .thermal_tensor(2,3) = tensor(6)
      .thermal_tensor(2,1) = .thermal_tensor(1,2)
      .thermal_tensor(3,1) = .thermal_tensor(1,3)
      .thermal_tensor(3,2) = .thermal_tensor(2,3)
      if (stdin.default_units=="angstrom^2") &
         .thermal_tensor.convert_from("angstrom^2")
   end

  resolve_axis_system(crystal)
  ! Change the axis system for the position and thermal tensors to
  ! "cartesian". "crystal" holds the axis system information.
    CRYSTAL, IN :: crystal
    if (.axis_system=="crystal")         .position_from(crystal)
    if (.thermal_axis_system=="crystal") .thermal_tensor_from(crystal)
  end

  change_axis_system_to(kind,crystal)
  ! Change the axis system for the position and thermal tensors
  ! to "kind", either crystal or cartesian.
    STR(*), IN :: kind
    CRYSTAL, IN :: crystal
    select case (kind)
      case ("cartesian")
        .position_from(crystal)
        .thermal_tensor_from(crystal)
      case ("crystal")
        .position_to(crystal)
        .thermal_tensor_to(crystal)
      case default
        DIE("unknown axis system, " // trim(kind))
    end
  end

  change_thermal_axis_system_to(kind,crystal)
  ! Change the axis system for the thermal tensors to "kind",
  ! either crystal or cartesian.
    STR(*), IN :: kind
    CRYSTAL, IN :: crystal
    select case (kind)
      case ("cartesian")
        .thermal_tensor_from(crystal)
      case ("crystal")
        .thermal_tensor_to(crystal)
      case default
        DIE("unknown axis system, " // trim(kind))
    end
  end

  thermal_tensor_from(crystal)
  ! Change thermal parameters in the crystal axis system to the
  ! cartesian axis system
    CRYSTAL, IN :: crystal
    select case (.thermal_axis_system)
      case ("crystal")
        .thermal_tensor.change_basis(crystal.direct_U_cell_matrix)
        .thermal_axis_system = "cartesian"
      case ("cartesian")
        ! do nothing
      case default
        DIE("unknown axis system, " // trim(.thermal_axis_system))
    end
  end

  thermal_tensor_to(crystal)
  ! Change thermal parameters in the cartesian axis system to the
  ! crystal axis system
    CRYSTAL, IN :: crystal
    select case (.thermal_axis_system)
      case ("crystal")
        ! do nothing
      case ("cartesian")
        .thermal_tensor.change_basis(crystal.reciprocal_U_cell_matrix)
        .thermal_axis_system = "crystal"
      case default
        DIE("unknown axis system, " // trim(.thermal_axis_system))
    end
  end

  position_from(crystal)
  ! Change atom positions in the crystal axis system to the
  ! cartesian axis system
    CRYSTAL, IN :: crystal
    select case (.axis_system)
      case ("crystal")
        .pos = matmul(crystal.direct_cell_matrix,.pos)
        .axis_system = "cartesian"
      case ("cartesian")
        ! do nothing
      case default
        DIE("unknown axis system, " // trim(.axis_system))
    end
  end

  position_to(crystal)
  ! Change atom positions in the cartesian axis system to the
  ! the crystal axis system
    CRYSTAL, IN :: crystal
    select case (.axis_system)
      case ("crystal")
        ! do nothing
      case ("cartesian")
        .pos = matmul(crystal.inverse_cell_matrix,.pos)
        .axis_system = "crystal"
      case default
        DIE("unknown axis system, " // trim(.axis_system))
    end
  end

!  **************
!  Output methods
!  **************

  put
  ! Put out the atom information to file "stdout"
    stdout.flush
    stdout.show("Label                  =",.label)
    stdout.show("Atom coordinates       =",.pos(1),.pos(2),.pos(3))
    stdout.show("Atomic No.             =",.atomic_number)
    stdout.show("Chemical symbol        =",trim(.chemical_symbol))
    if (.basis.created) .basis.put
  end 

  put_thermal_tensor
  ! Output the thermal tensor.  Does not put a header or carriage return.
  ! Only outputs the 6 independent ones, not all 9.
    stdout.put(.thermal_tensor(1,1))
    stdout.put(.thermal_tensor(2,2)) 
    stdout.put(.thermal_tensor(3,3)) 
    stdout.put(.thermal_tensor(1,2)) 
    stdout.put(.thermal_tensor(1,3)) 
    stdout.put(.thermal_tensor(2,3)) 
  end

   put_natural_orbitals
   ! Put out the current associated molecular orbitals to file "out"
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put( .occupation, format="column")
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put( .natural_orbitals)
   end

!  ***************
!  Inquiry methods
!  ***************

   same_kind_as(atom) result(res)
   ! Return TRUE if self is the same kind of atom as "atom". The position and
   ! label are not compared since the same kind of atom can have a different
   ! position and label.  To check if the basis set is the same, only the
   ! label is used.
      ATOM :: atom
      BIN :: res
      ENSURE( .basis.created,"no basis set to compare")
      res = .atomic_number==atom.atomic_number AND &
            .basis.label==atom.basis.label
   end

   no_of_shells result(res) 
   ! Return the no of shells
      INT :: res
      res = .basis.n_shell
   end

   n_shell result(res) 
   ! Return the no of shells
      INT :: res
      res = .basis.n_shell
   end

   no_of_basis_functions result (res)
   ! Return the no of basis functions
      INT :: res
      res = .basis.no_of_basis_functions
   end

   n_bf result (res)
   ! Return the no of basis functions
      INT :: res
      res = .basis.n_bf
   end

   no_of_primitives result (res)
   ! Return the no of primitives for this atom
      INT :: res
      res = .basis.no_of_primitives
   end

   n_prim result (res)
   ! Return the no of primitives for this atom
      INT :: res
      res = .basis.n_prim
   end

   no_of_occupied_NOs(kind,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose, 
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      STR, optional :: kind
      DBL, optional :: tol
      INT :: res
      STR :: itemkind
      DBL :: eps
      INT :: n,n_bf
      ENSURE( .occupation.created, "no occupation numbers")
      itemkind = .occupation.spinorbital_kind
      if (present(kind)) itemkind=kind
      eps = TOL(7)
      if (present(tol)) eps = tol 
      select case (itemkind)
         case ("restricted")
            n_bf = .occupation.n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation.restricted(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("unrestricted")
            n_bf = .occupation.n_bf
            res = 2*n_bf
            do n = 1,n_bf
               if (.occupation.alpha(n)<eps) then
                  res = n-1
                  exit
               end
            end
            do n = 1,n_bf
               if (.occupation.beta(n)<eps) then
                  res = res + n-1
                  exit
               end
            end
         case ("alpha")
            n_bf= .occupation.n_bf
            res = 2*n_bf 
            do n = 1, n_bf
               if (.occupation.alpha(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("beta")
            n_bf= .occupation.n_bf
            res = 2*n_bf 
            do n = 1, n_bf
               if (.occupation.beta(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("general")
            n_bf = 2*.occupation.n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation.general(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case default
            DIE("unknown occupation number kind, "// itemkind.trim)
      end
   end
   
   chemical_symbol result(res)
   ! Return the chemical symbol for this atom
      CHR(2) :: res
      if (.atomic_number<1 OR .atomic_number>103) then; res = "??"
      else;                  res = element_symbols(.atomic_number)
      end
   end

   mass result (res)
   ! Return the atomic mass for this atom
      DBL :: res
      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                  res = atomic_masses(.atomic_number)
      end
   end

   mean_neutron_number result (res)
   ! Return the average (abundance weighted) number of neutrons for this atom,
   ! calculated roughly by subtracting the number of protons from the atomic mass.
      DBL :: res
      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                  res = .mass - .atomic_number
      end
   end

   bragg_slater_radius result (res)
   ! Return the Bragg-Slater radius for this atom
      DBL :: res
      if (.atomic_number<1 OR .atomic_number>54) then; res = ZERO
      else;                  res = bragg_slater_radii(.atomic_number)
      end
   end

   neutron_scattering_length result (res)
   ! Return the neutron scattering length for this atom
      DBL :: res
      if (.atomic_number<1 OR .atomic_number>95) then; res = ZERO
      else;            res = neutron_scattering_lengths(.atomic_number)
      end
   end

   period_number result(p)
   ! Return the period (i.e. row) on which the atom lies
      INT :: p
      INT :: noble,n
      p = 1
      if (.atomic_number<1) return
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (.atomic_number <= noble) exit
         p = p + 1
      end 
   end

   column_number result(col)
   ! Return the period column (i.e. row) on which the atom lies
      INT :: col
      INT :: p,noble,n
      p = 1
      if (.atomic_number<1) return
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (.atomic_number <= noble) exit
         p = p + 1
      end 
      noble = noble - 2*n**2
      col = .atomic_number - noble
   end

   period_block result(b)
   ! Return the period bloc character in which the atom lies
      CHR :: b
      INT :: p,col
      p   = .period_number
      col = .column_number
      if (p<4) then
         select case (col)
            case (1:2);   b = "s"
            case (3:8);   b = "p"
         end
      else if (p<6) then
         select case (col)
            case (1:2);   b = "s"
            case (3:12);  b = "d"
            case (13:18); b = "p"
         end
      else if (p<8) then
         select case (col)
            case (1:2);   b = "s"
            case (3:16);  b = "f"
            case (17:26); b = "d"
            case (27:32); b = "p"
         end
      else 
         DIE("cannot assign for period "// p.to_str.trim)
      end
   end

   ground_state_multiplicity result(mult)
   ! Return the ground state multiplicity for this atom according to Hunds rule
   ! (Note this is not neccesarily the real ground state, esp. for Cu)
      INT :: mult
      INT :: p,col
      p   = .period_number
      col = .column_number
      if (p<4) then
         select case (col)
            case (2,8);   mult = 1
            case (1,3,7); mult = 2
            case (4,6);   mult = 3
            case (5);     mult = 4
         end
      else if (p<6) then
         select case (col)
            case (2,12,18);      mult = 1
            case (1,3,11,13,17); mult = 2
            case (4,10,14,16);   mult = 3
            case (5,9,15);       mult = 4
            case (6,8);          mult = 5
            case (7);            mult = 6
         end
      else if (p<8) then
         select case (col)
            case (2,16,26,32);         mult = 1
            case (1,3,15,17,25,27,31); mult = 2
            case (4,14,18,24,28,30);   mult = 3
            case (5,13,19,23,29);      mult = 4
            case (6,12,20,22);         mult = 5
            case (7,11,21);            mult = 6
            case (8,10);               mult = 7
            case (9);                  mult = 8
         end
      else 
         DIE("cannot assign for period "// p.to_str.trim)
      end
   end

  dispersion_correction(wavelength) result(res)
  ! The dispersion correction which best matches the wavelength.
    IN :: self
    DBL :: wavelength
    CDBL :: res
    if (.atomic_number<1 OR .atomic_number>92) then
      res = ZERO
    else
      if (wavelength < 1.1) then
        res = dispersion_correction_Mo( .atomic_number )
      else if (wavelength < 1.9) then
        res = dispersion_correction_Cu( .atomic_number )
      else
        res = dispersion_correction_Cr( .atomic_number )
      end
    end
  end

end 
