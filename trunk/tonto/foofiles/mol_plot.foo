!-------------------------------------------------------------------------------
!
! MOL_plot: plot routines for mol.
!
! $Id$
!
!-------------------------------------------------------------------------------
module MOL_PLOT

   use TYPES
   use SYSTEM
   use STR
   use BUFFER

   use DBL
   use VEC
   use MAT
   use CVEC
   use CMAT
   use OPMAT
   use MAT3

   use OUTPUT
   use ARCHIVE
   use SHELL1
   use SHELL2
   use ATOMVEC
   use PLOTGRID
   use DFTGRID
   use XTAL

   use MOL_COMMON
   use MOL_IO
   use MOL_XTAL
   use MOL_SCF

   implicit none

#  include "macros"
#  include "mol_plot.int"

   public make_density_grid_1

contains

  plot [leaky]
  ! Do one of the many kinds of plot calculations
    ENSURE( .grid.created, "no grid")
    .grid.put(.out)
    select case (.grid%kind)
       case("electron_density_grid");    .make_electron_density_grid
       case("orbital_density_grid");     .make_orbital_density_grid( .grid%orbital)
       case("orbital_grid");             .make_orbital_grid( .grid%orbital)
       case("difference_density_grid");  .make_difference_density_grid
       case("xtal_density_grid");        .make_xtal_density_grid
       case("fermi_mobility_grid");      .make_fermi_mobility_grid
       case("xtal_diff_density_grid");   .make_xtal_diff_density_grid
       case("spin_density_grid");        .make_spin_density_grid
       case("current_density_grid");     .make_j_density_grid
       case("j_density_grid");           .make_j_density_grid
       case("jp_density_grid");          .make_jp_density_grid
       case("jd_density_grid");          .make_jd_density_grid
       case("elf_grid");                 .make_ELF_grid
       case("electric_potential_grid");  .make_electric_potential_grid
       case("potential_grid");           .make_electric_potential_grid
       case("solenoidal_jp_grid");       .make_solenoidal_jp_grid
       case default;                     DIE("unknown plot type")
    end
  end

   bounding_cube_width result(width)
   ! Return "width", the width of a cube in which the molecule nicely sits.
   ! Suitable for generating plot widths.
      DBL :: width
      width = .atom.bounding_cube_width
   end

   get_electron_density_grid(density_grid) [leaky]
   ! Set "density_grid" to the electron density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      archive.set(.name,"electron_density_grid")
      if ( archive.doesnt_exist) .make_electron_density_grid
      archive.read(density_grid)
   end

   make_electron_density_grid [leaky]
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: density_grid
      ENSURE( .grid.created, "no grid")
      density_grid.create( .grid%n_pt)
      .make_density_grid(density_grid)
      archive.set(.name,"electron_density_grid")
      archive.write(density_grid)
      archive.set(.name,"electron_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid%n_x, .grid%n_y, .grid%n_z)
      density_grid.destroy
   end

  make_difference_density_grid [leaky]
  ! Make a Gnuplot ascii file containing the difference density grid.
    ARCHIVE :: archive
    VEC, PTR :: density_grid,atom_grid,grid
    MAT, PTR :: old_density_matrix
    ENSURE( .grid.created, "no grid")
    ENSURE( .density_matrix%restricted.created, "no density matrix")
    density_grid.create( .grid%n_pt)
    atom_grid.create( .grid%n_pt)
    grid.create( .grid%n_pt)
    old_density_matrix.create( .n_bf, .n_bf)
    old_density_matrix = .density_matrix%restricted

    .get_atom_density
    .make_density_grid(atom_grid)

    .density_matrix%restricted = old_density_matrix
    .make_density_grid(density_grid)
    grid = density_grid - atom_grid

    archive.set(.name,"difference_density_grid,gnuplot",format="ascii")
    archive.write_gnuplot(grid, .grid%n_x, .grid%n_y, .grid%n_z)
    old_density_matrix.destroy
    grid.destroy
    atom_grid.destroy
    density_grid.destroy
  end

  make_xtal_diff_density_grid
  ! Make a Gnuplot ascii file containing the difference density grid.
    ARCHIVE :: archive
    VEC, PTR :: density_grid,atom_grid,grid
    MAT, PTR :: old_density_matrix
    STR :: word,units
    DBL :: distance_max

    distance_max = 5  ! au
    units = "atomic"
    do !                                         read any output parameters.
      if( .in%buffer.exhausted ) exit
      .in.read(word)
      if (word.is_dbl) then
        distance_max = word.to_dbl
      else
        units = word
        units.to_lower_case
      end
    end
    select case(units) !                         treat output directives.
      case ("atomic")
      case ("angstrom");     distance_max = distance_max * BOHR_PER_ANGSTROM
      case default; DIE("unknown keyword " // units.trim)
    end

    ENSURE( .grid.created, "no grid")
    ENSURE( .density_matrix%restricted.created, "no density matrix")
    density_grid.create( .grid%n_pt)
    atom_grid.create( .grid%n_pt)
    grid.create( .grid%n_pt)
    old_density_matrix.create( .n_bf, .n_bf)
    old_density_matrix = .density_matrix%restricted

    .get_atom_density
    .make_xtal_density_grid(atom_grid,distance_max)

    .density_matrix%restricted = old_density_matrix
    .make_xtal_density_grid(density_grid,distance_max)
    grid = density_grid - atom_grid

    archive.set(.name,"crystal_difference_density_grid,gnuplot",format="ascii")
    archive.write_gnuplot(grid, .grid%n_x, .grid%n_y, .grid%n_z)
    old_density_matrix.destroy
    grid.destroy
    atom_grid.destroy
    density_grid.destroy
  end

  make_xtal_density_grid
  ! Work out the density on ".grid" using ".natural orbitals" and the
  ! ".occupation" number vector. A Gnuplot ascii file is generated.
    ARCHIVE :: archive
    STR :: word,units
    DBL :: distance_max
    VEC, PTR :: density_grid

    distance_max = 5  ! au
    units = "atomic"
    do !                                         read any output parameters.
      if( .in%buffer.exhausted ) exit
      .in.read(word)
      if (word.is_dbl) then
        distance_max = word.to_dbl
      else
        units = word
        units.to_lower_case
      end
    end
    select case(units) !                         treat output directives.
      case ("atomic")
      case ("angstrom");     distance_max = distance_max * BOHR_PER_ANGSTROM
      case default; DIE("unknown keyword " // units.trim)
    end

    ENSURE( .grid.created, "no grid")
    density_grid.create( .grid%n_pt)
    .make_xtal_density_grid(density_grid,distance_max)

    archive.set(.name,"crystal_electron_density_grid")
    archive.write(density_grid)
    archive.set(.name,"crystal_electron_density_grid,gnuplot",format="ascii")
    archive.write_gnuplot(density_grid, .grid%n_x, .grid%n_y, .grid%n_z)
    density_grid.destroy
  end

  make_xtal_density_grid(density_grid,max_cell_distance)
  ! Work out the density on ".grid" using ".natural orbitals" and the
  ! ".occupation" number vector. A Gnuplot ascii file is generated.
  ! If "grid" is present, it is returned, else the grid is written to disk.
    VEC, OUT :: density_grid
    DBL, IN :: max_cell_distance
    VEC, PTR :: temp
    PLOTGRID, PTR :: grid_old,grid
    INT :: s,h,k,l,q
    IMAT, PTR :: op_list
    VEC, PTR :: dist_list
    MAT(3,3) :: inverse_cell,cell_matrix
    MAT(4,4) :: seitz,inverse_seitz
    VEC(3) :: delta,grid_centre,molecule_translation

    ENSURE( .grid.created, "no grid")

    grid_old.create_copy( .grid )
    grid.create_copy( .grid )
    temp.create( .grid%n_pt)
    inverse_cell = .xtal%unitcell%inverse_cell_matrix
    cell_matrix  = .xtal%unitcell%cell_matrix

    .make_restricted_NOs

    molecule_translation = .atom.centre_of_mass          ! Make the lattice
    molecule_translation.rotate(inverse_cell)            ! point closest to
    molecule_translation = floor( molecule_translation ) ! the centre of
    molecule_translation.rotate(cell_matrix)             ! mass the origin.
    grid%centre.translate( - molecule_translation )
    .atom.translate( - molecule_translation )

    grid%centre.rotate(inverse_cell)         ! Convert grid to fractionals.
    grid%x_axis.rotate(inverse_cell)
    grid%y_axis.rotate(inverse_cell)
    grid%z_axis.rotate(inverse_cell)

    delta = floor( grid%centre )             ! Move the grid near the origin.
    grid%centre.translate( - delta )
    grid_centre = grid%centre
    grid_centre.rotate(cell_matrix)

    .xtal.create_closest_molecule_list(op_list,dist_list,.atom, &
                                 grid_centre,max_cell_distance)

    density_grid = ZERO
    do q=1,size(dist_list)
      s = op_list(1,q)
      if (s==0) exit
      h = op_list(2,q)
      k = op_list(3,q)
      l = op_list(4,q)
      .grid.copy(grid)

      seitz = .xtal%spacegroup%seitz(:,:,s)
      seitz = transpose(seitz)
      inverse_seitz.to_inverse_of(seitz)

      .grid%centre.translate((/-ONE*h,-ONE*k,-ONE*l/)) ! Translate and rotate
      .grid%centre.seitz_multiply(inverse_seitz)     ! grid origin, but don't
      .grid%x_axis.rotate(inverse_seitz(1:3,1:3))    ! not translate axis
      .grid%y_axis.rotate(inverse_seitz(1:3,1:3))    ! directions.
      .grid%z_axis.rotate(inverse_seitz(1:3,1:3))

      .grid%centre.rotate(cell_matrix)               ! Put into cartesians.
      .grid%x_axis.rotate(cell_matrix)
      .grid%y_axis.rotate(cell_matrix)
      .grid%z_axis.rotate(cell_matrix)

      .grid.update(.atom)  ! To get normalisation and origin right.

      .make_density_grid(temp,make_NOs=FALSE)
      density_grid = density_grid + temp
    end

    op_list.destroy
    dist_list.destroy

    .atom.translate( molecule_translation )
    .grid.copy(grid_old)
    temp.destroy
    grid.destroy
    grid_old.destroy
  end

   get_spin_density_grid(density_grid) [leaky]
   ! Set "density_grid" to the electron spin density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      archive.set(.name,"spin_density_grid")
      if ( archive.doesnt_exist) .make_spin_density_grid
      archive.read(density_grid)
   end

   make_spin_density_grid [leaky]
   ! Work out the spin density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: density_grid
      ENSURE( .grid.created, "no grid")
      .make_ao_sz_density_matrix
      density_grid.create( .grid%n_pt)
      .make_density_grid(density_grid)
      archive.set(.name,"spin_density_grid")
      archive.write(density_grid)
      archive.set(.name,"spin_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid%n_x, .grid%n_y, .grid%n_z)
      density_grid.destroy
   end

   make_density_grid(density_grid,make_NOs) [leaky]
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector.
      VEC :: density_grid
      BIN, optional :: make_NOs
      STR :: kind
      BIN :: do_make_NOs
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      do_make_NOs = TRUE
      if (present(make_NOs)) do_make_NOs = make_NOs
      kind = .density_matrix.spinorbital_kind
      if (kind.does_not_include("complex")) then
         if (do_make_NOs) .make_restricted_NOs
         .make_density_grid_r(density_grid)
      else
         if (do_make_NOs) .make_restricted_complex_NOs
         .make_density_grid_c(density_grid)
      end
   end

   make_density_grid_r(density_grid)
   ! Make the density grid from restricted real natural orbitals
      VEC :: density_grid
      MAT, PTR :: pt
      INT :: n_pt
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .natural_orbitals.created, "no density matrix")
      density_grid = ZERO
      n_pt = .grid%n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_density_grid_r(density_grid,pt)
      pt.destroy
   end

   make_density_grid_c(density_grid)
   ! Make the density from restricted complex natural orbitals
      VEC :: density_grid
      MAT, PTR :: pt
      INT :: n_pt
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .natural_orbitals.created, "no density matrix")
      density_grid = ZERO
      n_pt = .grid%n_pt
      pt.create(n_pt,3); .grid.points(pt)
      .make_density_grid_c(density_grid,pt)
      pt.destroy
   end

   make_density_grid(density_grid,pts) [leaky]
   ! Work out the electron "density_grid" on "pts" using ".natural orbitals" and
   ! the ".occupation" number vector.
      VEC :: density_grid
      MAT :: pts
      STR :: kind
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if (kind.does_not_include("complex")) then
         .make_density_grid_r(density_grid,pts)
      else
         .make_density_grid_c(density_grid,pts)
      end
   end

   make_density_grid_r(density_grid,pts)
   ! Make the "density_grid" for the supplied points "pts" from restricted real
   ! natural orbitals
     VEC :: density_grid
     MAT :: pts
     VEC, PTR :: NO
     INT :: n_occ,n,n_pts
     ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
     ENSURE( .atom.basis_resolved, "no basis set")
     ENSURE( .natural_orbitals.created, "no orbitals")
     n_pts = size(pts,1)
     density_grid = ZERO
     NO.create(n_pts)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_orbital_grid(NO,.natural_orbitals%restricted(:,n), pts)
       density_grid(:) = density_grid(:) + .occupation%restricted(n)*NO(:)*NO(:)
     end
     NO.destroy
   end

   make_density_grid_c(density_grid,pts)
   ! Make the "density_grid" for the supplied points "pts" from restricted
   ! complex natural orbitals.
      VEC :: density_grid
      MAT :: pts
      CVEC, PTR :: NO
      INT :: n_occ,n,n_pts
      ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .natural_orbitals.created("restricted_complex"), "no density matrix")
      n_pts = size(pts,1)
      density_grid = ZERO
      NO.create(n_pts)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_orbital_grid(NO,.natural_orbitals%restricted_complex(:,n), pts)
         density_grid(:) = density_grid(:) + .occupation%restricted(n)*conjg(NO(:))*NO(:)
      end
      NO.destroy
   end

   get_orbital_density_grid(g,orb) [leaky]
   ! Set "g" to the orbital density grid for orbital "orb".
   ! If the archive file exists, read it; otherwise make it.
      VEC :: g
      INT :: orb
      ARCHIVE :: archive
      archive.set(.name,"orbital_density_grid"//trim( orb.to_str))
      if ( archive.doesnt_exist) .make_orbital_density_grid(orb)
      archive.read(g)
   end

   make_orbital_density_grid(orb,make_NOs) [leaky]
   ! Work out the orbital on ".grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
      INT :: orb
      BIN, optional :: make_NOs
      ARCHIVE :: archive
      VEC, PTR  :: gr
      CVEC, PTR :: gc
      BIN :: do_make_NOs
      STR :: kind
      do_make_NOs = TRUE
      if (present(make_NOs)) do_make_NOs = make_NOs
      ENSURE( .grid.created, "no grid")
      kind = .density_matrix.spinorbital_kind
      if (kind.does_not_include("complex")) then
        if (do_make_NOs) .make_restricted_NOs
        gr.create(.grid%n_pt)
        .make_orbital_grid(gr,orb,square=TRUE)
        archive.set(.name,"orbital_density_grid")
        archive.write(gr)
        archive.set(.name,"orbital_density_grid"//trim( orb.to_str)//",gnuplot",format="ascii")
        archive.write_gnuplot(gr, .grid%n_x, .grid%n_y, .grid%n_z)
        gr.destroy
      else
        if (do_make_NOs) .make_restricted_complex_NOs
        gr.create(.grid%n_pt)
        gc.create(.grid%n_pt)
        .make_orbital_grid(gc,orb,square=TRUE)
        gr = gc
        archive.set(.name,"complex_orbital_density_grid")
        archive.write(gr)
        archive.set(.name,"complex_orbital_density_grid,gnuplot",format="ascii")
        archive.write_gnuplot(gr, .grid%n_x, .grid%n_y, .grid%n_z)
        gc.destroy
        gr.destroy
      end
   end

   make_orbital_grid(orb,make_NOs) [leaky]
   ! Work out the orbital on ".grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
      INT :: orb
      BIN, optional :: make_NOs
      ARCHIVE :: archive
      VEC, PTR  :: gr
      CVEC, PTR :: gc
      BIN :: do_make_NOs
      STR :: kind
      do_make_NOs = TRUE
      if (present(make_NOs)) do_make_NOs = make_NOs
      ENSURE( .grid.created, "no grid")
      kind = .density_matrix.spinorbital_kind
      if (kind.does_not_include("complex")) then
         if (do_make_NOs) .make_restricted_NOs
         gr.create(.grid%n_pt)
         .make_orbital_grid(gr,orb)
         archive.set(.name,"orbital_grid")
         archive.write(gr)
         archive.set(.name,"orbital_grid"//trim( orb.to_str)//",gnuplot",format="ascii")
         archive.write_gnuplot(gr, .grid%n_x, .grid%n_y, .grid%n_z)
         gr.destroy
      else
         if (do_make_NOs) .make_restricted_complex_NOs
         gc.create(.grid%n_pt)
         .make_orbital_grid(gc,orb)
         archive.set(.name,"complex_orbital_grid")
         archive.write(gc)
         archive.set(.name,"complex_orbital_grid,gnuplot",format="ascii")
         ! archive.write_gnuplot(gc, .grid%n_x, .grid%n_y, .grid%n_z)
         gc.destroy
      end
   end

   make_orbital_grid(g,orb,square) [leaky]
   ! Make the orbital density grid "g" for orbital
   ! no. "orb" of the restricted real natural orbitals.
   ! If present and TRUE, "square" will produce the square of the
   ! orbital density (i.e. probability density)
      VEC :: g
      INT :: orb,n_pt
      BIN, optional :: square
      VEC, PTR :: NO
      MAT, PTR :: pt
      BIN :: sq
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .natural_orbitals.created, "no natural orbitals")
      sq = FALSE
      if (present(square)) sq = square
      g = ZERO
      n_pt = .grid%n_pt
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      .make_orbital_grid(NO,.natural_orbitals%restricted(:,orb), pt)
      if (sq) then; g(:) = NO(:)*NO(:)
      else;         g(:) = NO(:)
      end
      NO.destroy
      pt.destroy
   end

   make_orbital_grid(g,orb,square)
   ! Make the orbital density grid "g" for orbital
   ! no. "orb" of the restricted complex natural orbitals.
   ! If present and TRUE, "square" will produce the square of the
   ! orbital density (i.e. probability density)
      CVEC :: g
      INT :: orb,n_pt
      BIN, optional :: square
      CVEC, PTR :: NO
      MAT, PTR :: pt
      BIN :: sq
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .natural_orbitals.created, "no natural orbitals")
      sq = FALSE
      if (present(square)) sq = square
      g = ZERO
      n_pt = .grid%n_pt
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      .make_orbital_grid(NO,.natural_orbitals%restricted_complex(:,orb), pt)
      if (sq) then; g(:) = conjg(NO(:))*NO(:)
      else;         g(:) = NO(:)
      end
      NO.destroy
      pt.destroy
   end

   make_orbital_grid(g,orb)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points defined by ".grid"
      VEC, OUT :: g
      VEC, IN :: orb
      MAT, PTR :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_pt = .grid%n_pt
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh%n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_orbital_grid(g,orb)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points defined by ".grid"
      CVEC, OUT :: g
      CVEC, IN :: orb
      MAT, PTR :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_pt = .grid%n_pt
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh%n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_orbital_grid(g,orb,pt)
   ! Evaluate the orbital density grid "g" for *one* AO-basis orbital vector
   ! "orb" on a set of grid points "pt"
      VEC, OUT :: g
      VEC, IN :: orb
      MAT, IN :: pt
      SHELL1 :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_pt = size(pt,1)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh%n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_orbital_grid(g,orb,pt)
   ! Evaluate the orbital density for *one* AO-basis orbital vector "orb"
   ! on a set of grid points "pt"
      CVEC, OUT :: g
      CVEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1, PTR :: sh
      MAT, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_pt = size(pt,1)
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh%n_comp)
         sh.make_grid(sh_grid,pt)
         g.plus_product(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_j_density_grid
   ! Make the current density on ".grid" using ".natural orbitals"
   ! and the ".occupation" number vector.
   !    J(r) = J_p(r) + J_d(r)
      ARCHIVE :: archive
      MAT, PTR :: j,jp
      ENSURE( .grid.created, "no grid")
      j.create(.grid%n_pt,3);  .get_jd_density_grid(j)
      jp.create(.grid%n_pt,3); .get_jp_density_grid(jp)
      j = j + jp
      jp.destroy
      archive.set(.name,"current_density")
      archive.write(j)
      archive.set(.name,"current_density,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z)
      archive.set(.name,"current_norm_density,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
      archive.set(.name,"current_density,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
      j.destroy
   end

   get_jd_density_grid(jd)
   ! Set "jd" to the diamagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      MAT :: jd
      ARCHIVE :: archive
      archive.set(.name,"jd_density_grid")
      if ( archive.doesnt_exist) .make_jd_density_grid
      archive.read(jd)
   end

   make_jd_density_grid
   ! Work out the diamagnetic current density on ".grid" using ".natural
   ! orbitals" and the ".occupation" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)
      ARCHIVE :: archive
      MAT, PTR :: jd,r
      VEC, PTR :: rho
      ENSURE( .grid.created, "no grid")
      nullify(r)
      if ( .B_field.norm<TOL(10)) return
      jd.create(.grid%n_pt,3)
      r.create(.grid%n_pt,3)
      .grid.make_points(r)
      jd(:,1) = .B_field(2)*r(:,3) - .B_field(3)*r(:,2)
      jd(:,2) = .B_field(3)*r(:,1) - .B_field(1)*r(:,3)
      jd(:,3) = .B_field(1)*r(:,2) - .B_field(2)*r(:,1)
      r.destroy
      rho.create(.grid%n_pt)
      .get_electron_density_grid(rho)
      jd(:,1) = -HALF*jd(:,1)*rho
      jd(:,2) = -HALF*jd(:,2)*rho
      jd(:,3) = -HALF*jd(:,3)*rho
      rho.destroy
      archive.set(.name,"jd_density")
      archive.write(jd)
      archive.set(.name,"jd_density,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid%n_x, .grid%n_y, .grid%n_z)
      archive.set(.name,"jd_norm_density,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
      archive.set(.name,"jd_density,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jd, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
      jd.destroy
   end

   get_jp_density_grid(jp)
   ! Set "jp" to the paramagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      MAT :: jp
      ARCHIVE :: archive
      archive.set(.name,"jp_density_grid")
      if ( archive.doesnt_exist) .make_jp_density_grid
      archive.read(jp)
   end

   make_jp_density_grid
   ! Work out the paramagnetic current density on ".grid" using ".natural
   ! orbitals".  A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      MAT, PTR :: jp
      BIN :: complex
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .natural_orbitals.created, "no density matrix")
      complex = .density_matrix.spinorbital_kind.includes("complex")
      ENSURE(complex, "need a complex density matrix")
      .make_ao_density_matrix
      .make_restricted_complex_NOs
      jp.create(.grid%n_pt,3)
      .make_jp_density_grid(jp)
      archive.set(.name,"jp_density_grid")
      archive.write(jp)
      archive.set(.name,"jp_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z)
      archive.set(.name,"jp_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
      archive.set(.name,"jp_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
      jp.destroy
   end

   make_jp_density_grid(jp)
   ! Work out the paramagnetic current density "jp" on ".grid" using ".natural
   ! orbitals" .
   !    J_p(r) = - (eh/m) Re [ \sum_i n_i \phi^*_i(r) \nabla \phi^*_i(r) ]
     MAT :: jp
     MAT, PTR :: pt
     CMAT, PTR :: P
     CVEC, PTR :: D
     INT :: n_occ,n,n_pt
     ENSURE( .grid.created,  "no grid")
     ENSURE( .atom.basis_resolved, "no basis set")
     ENSURE( .natural_orbitals.created, "no density matrix")
     jp = ZERO
     n_pt = .grid%n_pt
     pt.create(n_pt,3); .grid.points(pt)
     D.create(n_pt)
     P.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_orbital_grid(D,.natural_orbitals%restricted_complex(:,n), pt)
       .make_nabla_orbital_grid(P,.natural_orbitals%restricted_complex(:,n), pt)
       jp(:,1) = jp(:,1) - .occupation%restricted(n)*aimag(conjg(D(:))*P(:,1))
       jp(:,2) = jp(:,2) - .occupation%restricted(n)*aimag(conjg(D(:))*P(:,2))
       jp(:,3) = jp(:,3) - .occupation%restricted(n)*aimag(conjg(D(:))*P(:,3))
     end
     P.destroy
     D.destroy
     pt.destroy
   end

   make_nabla_orbital_grid(g,orb)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points defined by ".grid"
      MAT :: g
      VEC, IN, target :: orb
      MAT, PTR :: pt
      SHELL1 :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_pt = .grid%n_pt
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh%n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_nabla_orbital_grid(g,orb)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points defined by ".grid"
      CMAT :: g
      CVEC, IN, target :: orb
      MAT, PTR :: pt
      SHELL1 :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_pt = .grid%n_pt
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      pt.create(n_pt,3); .grid.points(pt)
      g = ZERO
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh%n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      pt.destroy
   end

   make_nabla_orbital_grid(g,orb,pt)
   ! Evaluate the nabla orbital density grid "g" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      MAT :: g
      VEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1, PTR :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh%n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_nabla_orbital_grid(g,orb,pt)
   ! Evaluate the nabla orbital density for *one* complex AO-basis orbital "orb"
   ! on a set of grid points "pt"
      CMAT :: g
      CVEC, IN, target :: orb
      MAT, IN :: pt
      SHELL1, PTR :: sh
      MAT3, PTR :: sh_grid
      INT :: n_pt,fa,la,a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      n_pt = size(pt,1)
      ENSURE( size(g,1)==n_pt, "grid array has wrong 1st dimension")
      ENSURE( size(g,2)==3,    "grid array has wrong 2nd dimension")
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell1(a,sh,fa,la)
         sh_grid.create(n_pt,sh%n_comp,3)
         sh.make_nabla_grid(sh_grid,pt)
         g(:,1).plus_product(sh_grid(:,:,1),orb(fa:la))
         g(:,2).plus_product(sh_grid(:,:,2),orb(fa:la))
         g(:,3).plus_product(sh_grid(:,:,3),orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
   end

   make_ELF_grid
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      ARCHIVE :: archive
      VEC, PTR :: ELF_grid
      ENSURE( .grid.created, "no grid")
      ELF_grid.create( .grid%n_pt)
      .make_ELF_grid(ELF_grid)
      archive.set(.name,"ELF_grid")
      archive.write(ELF_grid)
      archive.set(.name,"ELF_grid,gnuplot",format="ascii")
      archive.write_gnuplot(ELF_grid, .grid%n_x, .grid%n_y, .grid%n_z)
      ELF_grid.destroy
   end

   make_ELF_grid(ELF_grid)
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      VEC :: ELF_grid
      STR :: kind
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if (kind.does_not_include("complex")) then
         .make_restricted_NOs
         .make_ELF_grid_real(ELF_grid)
      else
         .make_restricted_complex_NOs
         .make_ELF_grid_complex(ELF_grid)
      end
   end

   make_ELF_grid_real(ELF_grid)
   ! Work out the Electron Localisation Function (ELF) density on ".grid"
   ! using ".natural orbitals" and the ".occupation" number vector.
   ! Grid, basis set, and natural orbitals are required to exist.
   ! A Gnuplot ascii file is also generated.
      VEC :: ELF_grid
      MAT, PTR :: pt
      VEC, PTR :: mo_val,gx,gy,gz,rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s
      DBL :: occu,factor
      VEC, PTR :: NO
      MAT, PTR :: DD
      INT :: n_occ,n,n_pt
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .natural_orbitals.created, "no density matrix")
      ELF_grid = ZERO
      n_pt = .grid%n_pt
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      pt.create(n_pt,3); .grid.points(pt)
      NO.create(n_pt)
      DD.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_orbital_grid(NO,.natural_orbitals%restricted(:,n), pt)
         .make_nabla_orbital_grid(DD,.natural_orbitals%restricted(:,n), pt)
         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)
         occu   = HALF*.occupation%restricted(n)
         rho_s  = rho_s  + occu*mo_val*mo_val
         tau    = tau    + occu*(gx*gx+gy*gy+gz*gz)
         rho_sx = rho_sx + occu*gx*mo_val ! this is half grad_x rho_s
         rho_sy = rho_sy + occu*gy*mo_val
         rho_sz = rho_sz + occu*gz*mo_val
      end
      DD.destroy
      NO.destroy
      pt.destroy
      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s
      rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy
      d0_s.create(n_pt)
      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)
      rho_s.destroy
      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))
      d0_s.destroy; d_s.destroy
   end

  make_ELF_grid_complex(ELF_grid)
  ! Work out the Electron Localisation Function (ELF) density on ".grid"
  ! using ".natural orbitals" and the ".occupation" number vector.
  ! Grid, basis set, and natural orbitals are required to exist.
  ! A Gnuplot ascii file is also generated.
    VEC :: ELF_grid
    MAT, PTR :: pt
    CVEC, PTR :: mo_val,gx,gy,gz
    VEC, PTR  :: rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s
    DBL :: occu,factor
    CVEC, PTR :: NO
    CMAT, PTR :: DD
    INT :: n_occ,n,n_pt
    ENSURE( .grid.created,  "no grid")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( .natural_orbitals.created, "no density matrix")
    ELF_grid = ZERO
    n_pt = .grid%n_pt
    rho_s.create(n_pt);  rho_s  = ZERO
    tau.create(n_pt);    tau    = ZERO
    rho_sx.create(n_pt); rho_sx = ZERO
    rho_sy.create(n_pt); rho_sy = ZERO
    rho_sz.create(n_pt); rho_sz = ZERO
    pt.create(n_pt,3); .grid.points(pt)
    NO.create(n_pt)
    DD.create(n_pt,3)
    n_occ = .no_of_occupied_NOs
    do n = 1,n_occ
      .make_orbital_grid(NO,.natural_orbitals%restricted_complex(:,n), pt)
      .make_nabla_orbital_grid(DD,.natural_orbitals%restricted_complex(:,n), pt)
      mo_val => NO(:)
      gx     => DD(:,1)
      gy     => DD(:,2)
      gz     => DD(:,3)
      occu   = HALF*.occupation%restricted(n)
      rho_s  = rho_s  + occu*conjg(mo_val)*mo_val
      tau    = tau    + occu*(conjg(gx)*gx+conjg(gy)*gy+conjg(gz)*gz)
      rho_sx = rho_sx + occu*conjg(gx)*mo_val ! this is half grad_x rho_s
      rho_sy = rho_sy + occu*conjg(gy)*mo_val
      rho_sz = rho_sz + occu*conjg(gz)*mo_val
    end
    DD.destroy
    NO.destroy
    pt.destroy
    d_s.create(n_pt)
    d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s
    rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy
    d0_s.create(n_pt)
    factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
    d0_s = factor*rho_s**(FIVE/THREE)
    rho_s.destroy
    ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))
    d0_s.destroy; d_s.destroy
  end

  make_electric_potential_grid
  ! Make the electric potential "pot_grid" on ".grid"
    ARCHIVE :: archive
    VEC, PTR :: pot_grid
    BIN :: complex
    ENSURE( .grid.created,  "no grid")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( .density_matrix.created, "no density matrix")
    .make_ao_density_matrix
    complex = .density_matrix.spinorbital_kind.includes("complex")
    pot_grid.create(.grid%n_pt)
    if (complex) then
      .make_electric_potential_grid(pot_grid,.density_matrix%restricted_complex)
    else
      .make_electric_potential_grid(pot_grid,.density_matrix%restricted)
    end
    archive.set(.name,"electric_potential_grid")
    archive.write(pot_grid)
    archive.set(.name,"electric_potential_grid,gnuplot",format="ascii")
    archive.write_gnuplot(pot_grid, .grid%n_x, .grid%n_y, .grid%n_z)
    pot_grid.destroy
  end

   make_electric_potential_grid(pot_grid,dens)
   ! Make the electric potential "pot_grid" on ".grid" using AO density matrix
   ! "dens"
      VEC :: pot_grid
      MAT, target :: dens
      MAT, PTR :: pt,Vab,Dba
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      pt.create(.grid%n_pt,3); .grid.points(pt)
      pot_grid = ZERO
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         Dba => dens(fb:lb,fa:la)
         fac = TWO; if (a==b) fac=ONE
         Vab.create(shell%a%n_comp,shell%b%n_comp)
         do k = 1,.grid%n_pt
            shell.make_nuclear_attraction_ints(Vab,pt(k,:))
            pot_grid(k) = pot_grid(k) - fac*Vab.trace_of_product(Dba)
         end
         Vab.destroy
         shell.destroy_ptr_part
      end
      pt.destroy
   end

   make_electric_potential_grid(pot_grid,dens)
   ! Make the electric potential "pot_grid" on ".grid" using AO density matrix
   ! "dens"
      VEC :: pot_grid
      CMAT, target :: dens
      MAT, PTR :: pt,Vab
      CMAT, PTR :: Dba
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      pt.create(.grid%n_pt,3); .grid.points(pt)
      pot_grid = ZERO
      do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         Dba => dens(fb:lb,fa:la)
         fac = TWO; if (a==b) fac=ONE
         Vab.create(shell%a%n_comp,shell%b%n_comp)
         do k = 1,.grid%n_pt
            shell.make_nuclear_attraction_ints(Vab,pt(k,:))
            pot_grid(k) = pot_grid(k) - fac*Vab.trace_of_product(real(Dba,kind=DBL_KIND))
         end
         Vab.destroy
         shell.destroy_ptr_part
      end
      pt.destroy
   end

   make_solenoidal_jp_grid
   ! Make the solenoidal paramagnetic current density grid "jp" on ".grid"
     ARCHIVE :: archive
     MAT, PTR :: jp
     BIN :: complex
     ENSURE( .grid.created,  "no grid")
     ENSURE( .atom.basis_resolved, "no basis set")
     ENSURE( .density_matrix.created, "no density matrix")
     .make_ao_density_matrix
     complex = .density_matrix.spinorbital_kind.includes("complex")
     ENSURE(complex, "no complex density matrix")
     jp.create(.grid%n_pt,3)
     .make_solenoidal_jp_grid(jp,.density_matrix%restricted_complex)
     archive.set(.name,"solenoidal_jp_density_grid")
     archive.write(jp)
     archive.set(.name,"solenoidal_jp_density_grid,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z)
     archive.set(.name,"solenoidal_jp_norm_density_grid,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
     archive.set(.name,"solenoidal_jp_density_grid,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
     jp.destroy
   end

   make_solenoidal_jp_grid(jp,dens)
   ! Make the solenoidal paramagnetic current density grid "jp" on ".grid"
   ! using AO density matrix "dens"
      MAT :: jp
      CMAT, target :: dens
      CMAT, PTR :: Dba
      MAT, PTR :: pt,Jxab,Jyab,Jzab
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      pt.create(.grid%n_pt,3); .grid.points(pt)
      jp = ZERO
      do q = 1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (a==b) fac=ONE
        Jxab.create(shell%a%n_comp,shell%b%n_comp)
        Jyab.create(shell%a%n_comp,shell%b%n_comp)
        Jzab.create(shell%a%n_comp,shell%b%n_comp)
        do k = 1,.grid%n_pt
          shell.make_solenoidal_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_of_product(real(aimag(Dba),kind=DBL_kind))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_of_product(real(aimag(Dba),kind=DBL_kind))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_of_product(real(aimag(Dba),kind=DBL_kind))
        end
        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        shell.destroy_ptr_part
      end
      pt.destroy
      jp.zero_small_values(TOL(10))
   end

   make_irrotational_jp_grid
   ! Make the irrotational paramagnetic current density grid "jp" on ".grid"
      ARCHIVE :: archive
      MAT, PTR :: jp
      BIN :: complex
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      .make_ao_density_matrix
      complex = .density_matrix.spinorbital_kind.includes("complex")
      ENSURE(complex, "no complex density matrix")
      jp.create(.grid%n_pt,3)
      .make_irrotational_jp_grid(jp,.density_matrix%restricted_complex)
      archive.set(.name,"irrotational_jp_density_grid")
      archive.write(jp)
      archive.set(.name,"irrotational_jp_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z)
      archive.set(.name,"irrotational_jp_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
      archive.set(.name,"irrotational_jp_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(jp, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
      jp.destroy
   end

   make_irrotational_jp_grid(jp,dens)
   ! Make the irrotational paramagnetic current density grid "jp" on ".grid"
   ! using AO density matrix "dens"
      MAT :: jp
      CMAT, target :: dens
      CMAT, PTR :: Dba
      MAT, PTR :: pt,Jxab,Jyab,Jzab
      INT :: q,a,b,fa,fb,la,lb,k
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      pt.create(.grid%n_pt,3); .grid.points(pt)
      jp = ZERO
      do q = 1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (a==b) fac=ONE
        Jxab.create(shell%a%n_comp,shell%b%n_comp)
        Jyab.create(shell%a%n_comp,shell%b%n_comp)
        Jzab.create(shell%a%n_comp,shell%b%n_comp)
        do k = 1,.grid%n_pt
          shell.make_irrotational_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_of_product(real(aimag(Dba),kind=DBL_kind))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_of_product(real(aimag(Dba),kind=DBL_kind))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_of_product(real(aimag(Dba),kind=DBL_kind))
        end
        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        shell.destroy_ptr_part
      end
      pt.destroy
      jp.zero_small_values(TOL(10))
   end

   get_vib_averaged_rho_grid(density_grid)
   ! Set "density_grid" to the vibrationally averaged electron density grid.
   ! If the archive file exists, read it; otherwise make it.
      VEC :: density_grid
      ARCHIVE :: archive
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE(.n_atom==2,"can only do diatomics")
      archive.set(.name,"vib_averaged_rho_grid")
      if ( archive.doesnt_exist) .make_vib_averaged_rho_grid
      archive.read(density_grid)
   end

   make_vib_averaged_rho_grid
   ! Work out the averaged density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: density_grid
      ENSURE( .grid.created,  "no grid")
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.basis_resolved, "no basis set")
      ENSURE(.n_atom==2,"can only do diatomics")
      .move_origin_to_centre_of_mass

      density_grid.create(.grid%n_pt)
      .integrate_rho_grid(density_grid,-FOUR,FOUR,TOL(4))

      archive.set(.name,"vib_averaged_rho_grid")
      archive.write(density_grid)
      archive.set(.name,"vib_averaged_rho_grid,gnuplot",format="ascii")
      archive.write_gnuplot(density_grid, .grid%n_x, .grid%n_y, .grid%n_z)
      density_grid.destroy
   end

   integrate_rho_grid(res,a,b,accuracy,fa0,fb0) [recursive]
   ! Integrate the rho grid between the limits "a" and "b" using adaptive
   ! trapezoidal rule with Simpsons approximation.  If present, "accuracy"
   ! is the required accuracy of the integral. If present, "fa0" and
   ! "fb0" are the value of the rho_grid at "a" and "b" respectively.
   ! size of "res" is .grid%n_pt.
      DBL :: a,b
      DBL, optional :: accuracy
      VEC, PTR, optional :: fa0,fb0
      VEC, PTR :: res
      INT :: n_pt
      BIN :: same
      DBL :: tol,h,m
      VEC,PTR :: fa,fb,fm,one_trap,two_trap,left,right
      INT :: depth = 0
      ENSURE( .grid.created, "no grid")
      n_pt = .grid%n_pt
      depth = depth+1
      .out.show("depth =",depth)
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h  = b-a
      m  = (a+b)/TWO
      if (present(fb0)) then; fb => fb0
      else;                   fb.create(n_pt); .make_rho_grid_at(b,fb)
      end
      if (present(fa0)) then; fa => fa0
      else;                   fa.create(n_pt); .make_rho_grid_at(a,fa)
      end
      fm.create(n_pt);    .make_rho_grid_at(m,fm)
      one_trap.create(n_pt)
      two_trap.create(n_pt)
      one_trap = h*(fa+fb)/TWO
      two_trap = h*(fa+TWO*fm+fb)/FOUR
      res = abs(one_trap-two_trap)
      same = maxval(res) < THREE*tol
      if (same AND depth>1) then
        res = (FOUR*two_trap - one_trap)/THREE
        two_trap.destroy
        one_trap.destroy
        fm.destroy
        fa.destroy
      else
        two_trap.destroy
        one_trap.destroy
        left.create(n_pt);  .integrate_rho_grid(left ,a,m,tol/TWO,fa0=fa,fb0=fm)
        right.create(n_pt); .integrate_rho_grid(right,m,b,tol/TWO,fa0=fm,fb0=fb)
        res = left + right
        right.destroy
        left.destroy
      end
      if (depth==1) fb.destroy
      depth = depth-1
   end

   make_rho_grid_at(q,rho)
   ! Work out the electron density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector at nuclear separation "q", where "q" is a
   ! dimensionless normal coordinate
   ! size or "rho" is .grid%n_pt.
      DBL :: q
      VEC :: rho
      DBL :: re,w,mu, gamma,d,r, wt
      INT :: n
      re = 2.0460259 ! N2
      w  = 2708      ! N2
      re = 1.3848617 ! H2
      w  = 4658      ! H2
      mu = .atom.reduced_mass
      n = 1
      gamma = sqrt( (w/WAVENUMBER_PER_HARTREE) &
                  * mu * MASS_OF_ELECTRON_PER_AMU ) ! This is gamma^(1/2)
      d = q/gamma ! d is the cartesian displacement in Bohr
      r = re + d  ! r is the actual separation of atoms in Bohr
      .out.show("q =",q)
      .out.show("d =",d)
      .out.show("r =",r)
      .out.show("g =",gamma)
      .atom(1)%pos = ZERO
      .atom(2)%pos = ZERO
      .atom(1)%pos(3) = -r/TWO
      .atom(2)%pos(3) = +r/TWO
      .move_origin_to_centre_of_mass
      .delete_scf_integrals
      .scf
      .make_density_grid(rho)
      wt = q.harmonic_vibrational_fn(n)
      wt = wt*wt
      rho = wt * rho
   end

   make_fermi_mobility_grid [leaky]
   ! Work out the density on ".grid" using ".natural orbitals" and the
   ! ".occupation" number vector. A Gnuplot ascii file is generated.
      ARCHIVE :: archive
      VEC, PTR :: fermi_grid
      MAT, PTR :: pt
      ENSURE( .grid.created, "no grid")
      fermi_grid.create( .grid%n_pt)
      pt.create( .grid%n_pt, 3 );       .grid.points(pt)
      .make_fermi_mobility_grid(fermi_grid,pt)
      archive.set(.name,"fermi_mobility_grid,gnuplot",format="ascii")
      archive.write_gnuplot(fermi_grid, .grid%n_x, .grid%n_y, .grid%n_z)
      pt.destroy
      fermi_grid.destroy
   end

   make_fermi_mobility_grid(g,pt) [leaky]
   ! Evaluate the Fermi hole mobility grid "g" on a set of grid points "pt".
      MAT, IN :: pt
      VEC, OUT :: g
      MAT, PTR :: del_gi,del_gj,gigj_gjgi
      VEC, PTR :: gi,gj,density_grid,T
      INT :: n_pt,i,j,n_occ
      ENSURE( .grid.created,  "no grid")
      .make_restricted_NOs
      n_pt = .grid%n_pt

      n_occ = .no_of_occupied_NOs
      T.create(n_pt)

      gi.create(n_pt)
      gj.create(n_pt)
      del_gi.create(n_pt,3)
      del_gj.create(n_pt,3)
      gigj_gjgi.create(n_pt,3)
      g = ZERO
      do j=1, n_occ
        .make_nabla_orbital_grid(del_gj,.natural_orbitals%restricted(:,j), pt)
        .make_orbital_grid(gj,.natural_orbitals%restricted(:,j), pt)
        do i=j+1, n_occ
          .make_nabla_orbital_grid(del_gi,.natural_orbitals%restricted(:,i), pt)
          .make_orbital_grid(gi,.natural_orbitals%restricted(:,i), pt)
          gigj_gjgi(:,1) = gi * del_gj(:,1) - gj * del_gi(:,1)
          gigj_gjgi(:,2) = gi * del_gj(:,2) - gj * del_gi(:,2)
          gigj_gjgi(:,3) = gi * del_gj(:,3) - gj * del_gi(:,3)
          gigj_gjgi = gigj_gjgi * gigj_gjgi
          g = g + gigj_gjgi(:,1)  ! sum over the axes. x,y,z.
          g = g + gigj_gjgi(:,2)
          g = g + gigj_gjgi(:,3)
        end
      end
      gigj_gjgi.destroy
      del_gj.destroy
      del_gi.destroy

!      ENSURE( .molecular_orbitals%restricted.created, "no molecular orbitals")
!      kinetic.create( .n_bf, .n_bf)
!      .get_kinetic_matrix(kinetic)
!      kinetic.change_basis( .molecular_orbitals%restricted )
!      T = ZERO
!      do i=1, n_occ
!        .make_orbital_grid(gi,.natural_orbitals%restricted(:,i), pt)
!        do j=1, n_occ
!          .make_orbital_grid(gj,.natural_orbitals%restricted(:,j), pt)
!          T = T + gi * gj * kinetic(i,j)
!        end
!      end
!      kinetic.destroy
      gj.destroy
      gi.destroy

      density_grid.create( .grid%n_pt )
      .make_density_grid(density_grid)
      g = TWO * g / (density_grid * density_grid)
!      T = TWO * T / density_grid
  T = ((3.0d0*PI/4.0d0) / 2.0d0**0.666666666667d0) * density_grid**0.666666666667d0
      g = g - T
      density_grid.destroy
      T.destroy

   end

   integrate_density_numerically
   ! Integrate the density numerically
      INT :: n_pts
      MAT, PTR :: pt
      VEC, PTR :: wt,rho
      DBL :: n_e
      ENSURE( .dftgrid.created, "no dftgrid information supplied")
      n_pts = .dftgrid%n_atom_pts * .n_atom
      pt.create(n_pts,3)
      wt.create(n_pts)
      rho.create(n_pts)
      .dftgrid.make_grid(pt,wt,.atom)
      .make_density_grid(rho,pt)
      n_e = sum(rho*wt)
      .out.show("numerically integrated charge =",n_e)
      rho.destroy
      wt.destroy
      pt.destroy
   end

end
