!-------------------------------------------------------------------------------
!
! MOL: An object representation of a molecule.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_MAIN

   use TYPES
   use SYSTEM
   use TIME
   use STR
   use TEXTFILE
   use ATOMVEC
   use CRYSTAL
   use MOL
   use MOL_DYLAN
   use MOL_CHRIS

   implicit none

#  include "macros"
#  include "mol_main.int"

!   type mol_type
!
!   STR :: name
!   ! Name of molecule
!
!   INT :: charge
!   ! Electric charge of the molecule
!
!   INT :: mult
!   ! Spin multiplicity of the molecule
!
!   VEC(3) :: E_field
!   ! Applied electric field in atomic units
!
!   VEC(3) :: B_field
!   ! Applied magnetic field in atomic units
!
!   VEC(3) :: gauge_origin
!   ! Global gauge origin for magnetic field
!
!   VEC(3) :: quantization_axis
!   ! Axis for quantizing any momenta
!
!   ATOMVEC, PTR :: atom DEFAULT_NULL
!   ! List of atoms in molecule
!
!   BASISVEC, PTR :: basis DEFAULT_NULL
!   ! List of basis sets used
!
!   PLOTGRID, PTR :: grid DEFAULT_NULL
!   ! Rectangular grid data, for plots
!
!   DFTGRID, PTR :: dftgrid DEFAULT_NULL
!   ! DFT integration grid data
!
!   CRYSTAL, PTR :: crystal DEFAULT_NULL
!   ! Crystal data for the enclosing crystal
!
!   POINTGROUP, PTR :: pointgroup DEFAULT_NULL
!   ! Pointgroup symmetry of the molecule
!
!   INT :: n_e
!   ! No of electrons
!
!   INT :: n_a
!   ! No of alpha electrons
!
!   INT :: n_b
!   ! No of beta electrons
!
!   INT :: n_atom
!   ! No of atoms
!
!   INT :: n_atom_kind
!   ! No of atoms of a different kind
!
!   INT :: n_basis
!   ! No of basis sets
!
!   INT :: n_shell
!   ! Total number of shells in the molecular basis set
!
!   INT :: n_shell_pairs
!   ! Total number of shell pairs in the molecular basis set
!
!   INT :: n_bf
!   ! Total number of basis functions in the molecular basis set
!
!   INT :: n_prim
!   ! Total number of primitives in the molecular basis set
!
!   IVEC, PTR :: atom_for_shell DEFAULT_NULL
!   ! Atom index for molecular shell index array
!
!   IVEC, PTR :: atom_shell_for_shell DEFAULT_NULL
!   ! Atom shell index for molecular shell index array
!
!   IVEC, PTR :: first_shell_for_atom DEFAULT_NULL
!   ! First molecule shell index for an atom
!
!   IVEC, PTR :: first_basis_fn_for_shell DEFAULT_NULL
!   ! First basis function for a given shell
!
!   IVEC, PTR :: last_basis_fn_for_shell DEFAULT_NULL
!   ! Last basis function for a given shell
!
!   IVEC, PTR :: atom_kind DEFAULT_NULL
!   ! The unique kind of each atom in .atom
!
!   IVEC, PTR :: unique_atom DEFAULT_NULL
!   ! List of the unique atoms (of different kind)
!
!   IVEC, PTR :: first_basis_fn_for_atom DEFAULT_NULL
!   ! For the atom basis function limits
!
!   IVEC, PTR :: last_basis_fn_for_atom DEFAULT_NULL
!   ! For the atom basis function limits
!
!   SCFDATA, PTR :: scfdata DEFAULT_NULL
!   ! SCF data object
!
!   OPVEC, PTR :: orbital_energies DEFAULT_NULL
!   ! The orbital energies
!
!   OPMAT, PTR :: molecular_orbitals DEFAULT_NULL
!   ! The (real) molecular orbitals
!
!   OPMAT, PTR :: density_matrix DEFAULT_NULL
!   ! The real density matrix
!
!   OPMAT, PTR :: natural_orbitals DEFAULT_NULL
!   ! The natural orbitals
!
!   OPVEC, PTR :: occupation DEFAULT_NULL
!   ! The associated occupation numbers
!
!   OPMAT, PTR :: fock_matrix DEFAULT_NULL
!   ! The real fock matrix
!
!   MAT4VEC, PTR :: ab_ab_ERI DEFAULT_NULL
!   ! The two electron integrals of the form ab|ab
!
!   BIN :: optimise_thermals
!   ! Whether to optimise the thermal parameters
!
!   TEXTFILE, PTR :: in DEFAULT_NULL
!   ! Input file for this molecule
!
!   TEXTFILE, PTR :: out DEFAULT_NULL
!   ! Output file for the molecule
!
!   end

contains

   main
   ! Main molecule run-loop; creates a file "input" from which the molecule
   ! object can "read(in)" information.
      PTR :: self
      .create
      .set_io_defaults
      .read
      .destroy
   end

   set_io_defaults [leaky]
   ! Sets the input/output defaults to "input" and "output"
     stdin.create("input")
     stdin.open_for_read
     stdout.create("output")
     stdout.open_for_write
     tonto.set_put_file(stdout)
   end

   reset_molecule [leaky]
   ! Resets the mol data type and reruns the read routine
      PTR :: self
      STR :: word
      .destroy
      .create
      stdin.read(word); word.to_lower_case         ! First keyword must be "name"
      ENSURE(word=="name","first keyword must be name")
      stdin.read(.name)
   end

  read [leaky]
  ! Read in the molecule data from input file "in"
     PTR :: self
     STR :: word
     TIME :: timer
     timer.start
     std_time.start
     stdout.text( std_time.start_time )
     stdin.read(word); word.to_lower_case         ! First keyword must be "name"
     ENSURE(word=="name","first keyword must be name")
     stdin.read( .name)
     read_loop : do                             ! Loop over other keywords
        stdin.read(word); word.to_lower_case
        stdout.flush
        stdout.text("keyword found --> " // word.trim)
        select case (word)
           case("end");                           exit read_loop
           case("output_style_options");          stdout.read_output_style_options(stdin)
           case("multiplicity");                  .read_multiplicity
           case("charge");                        stdin.read( .charge)
           case("e_field");                       stdin.read(.E_field)
           case("b_field");                       stdin.read(.B_field)
           case("gauge_origin");                  .read_gauge_origin
           case("atoms");                         .read_atoms
           case("basis_sets");                    .read_basis_sets
           case("optimise_thermal_parameters");   stdin.read(.optimise_thermals)
           case("fit_thermal_parameters");  .fit_thermal_parameters(output=TRUE)
                                                  .put_atom_thermal_tensors
           case("read_thermal_tensors");          .atom.read_thermal_tensors(.crystal)
           case("crystal");                       .read_crystal
           case("pointgroup");                    .read_pointgroup
           case("plotgrid");                      .read_plotgrid
           case("plot");                          .plot
           case("dftgrid");                       .read_dftgrid
           case("make_roby_atoms" );              .make_roby_atoms
           case("atomic_roby_population" );       .atomic_roby_population
           case("roby_energy_analysis");          .roby_energy_analysis
           case("roby_population_analysis");      .roby_population_analysis
           case("put_roby_shared_population");    .put_roby_shared_population
           case("get_homoleptic_bond_index");     .get_homoleptic_bond_index
           case("put_roby_atom_energy");          .put_roby_atom_energy
           case("put_roby_ionic_energy");         .put_roby_ionic_energy
           case("put_roby_shared_energy");        .put_roby_shared_energy
           case("plot_subspace_density");         .plot_subspace_density
           case("plot_ionic_orbitals");           .plot_ionic_orbitals
           case("plot_ionic_density_orbitals");   .plot_ionic_density_orbitals
           case("plot_covalent_orbitals");        .plot_covalent_orbitals
           case("plot_covalent_density_orbitals"); .plot_covalent_density_orbitals
         ! case("dylans_population_analysis");    .dylans_population_analysis
           case("scfdata");                       .read_scfdata
           case("scf");                           .scf
           case("dvpt_scf");                      .DVPT_scf
           case("canonicalize_mos");              .canonicalize_mos
           case("delete_scf_integrals");          .delete_scf_integrals
           case("make_atom_density");             .make_atom_density
           case("get_atom_density");              .get_atom_density
           case("make_fock_guess");               .make_fock_guess
           case("make_fock_matrix");              .make_fock_matrix
           case("make_scf_density_matrix");       .make_scf_density_matrix
           case("make_ao_density_matrix");        .make_ao_density_matrix
           case("make_ao_sz_density_matrix");     .make_ao_sz_density_matrix
           case("assign_natural_orbitals");       .assign_natural_orbitals
           case("make_natural_orbitals");         .make_natural_orbitals
           case("make_structure_factors");        .make_structure_factors
           case("make_sz_structure_factors");     .make_sz_structure_factors
           case("make_pnd_scalar_magnetic_sf");   .make_PND_scalar_magnetic_sf
           case("make_mulliken_matrix");          .make_mulliken_matrix
           case("make_irrotational_jp_grid");     .make_irrotational_jp_grid
           case("make_vib_averaged_rho_grid");    .make_vib_averaged_rho_grid
           case("make_fermi_mobility_grid");      .make_fermi_mobility_grid
           case("read_archive");                  .read_archive
           case("read_ascii_archive");            .read_ascii_archive
           case("convert_cadpac_ft_ints");        .convert_cadpac_ft_ints
           case("read_g94_checkpoint_file");      .read_g94_checkpoint_file
           case("read_repetition_factors");       .read_repetition_factors
           case("write_wfn_file");                .write_wfn_file
           case("write_ascii_archive");           .write_ascii_archive
           case("put");                           .put
           case("put_pointgroup");                .put_pointgroup
           case("put_crystal");                   .put_crystal
           case("put_crystal_reflection_data");   .put_crystal_reflection_data
           case("put_molecular_orbitals");        .put_molecular_orbitals
           case("put_mos_and_energies");          .put_mos_and_energies
           case("put_density_matrix");            .put_density_matrix
           case("put_fock_matrix");               .put_fock_matrix
           case("put_pnd_sf");                    .put_PND_sf
           case("put_plotgrid");                  .put_plotgrid
           case("put_scf_energy");                .put_scf_energy
           case("put_scf_energy_in_mo_pairs");    .put_scf_energy_in_mo_pairs
           case("start_timer");                   timer.start
           case("put_time_taken");                stdout.text(timer.time_taken)
           case("put_current_time");              stdout.text(timer.current_time)
           case("put_total_time");                stdout.text(std_time.time_taken)
           case("add_f_calc");                    .crystal.add_F_calc
           case("put_f_calc");                    .crystal.put_F_calc
           case("put_qq_plot");                   .crystal.put_qq_plot(.name)
           case("put_cluster_operations");        .put_cluster_operations
           case("put_cluster_input");             .put_cluster_input
           case("make_weak_force_energy_shift");  .make_weak_force_energy_shift
           case("put_g_tensor_information");      .put_g_tensor_information
           case("make_pcc_L_matrices");           .make_pcc_L_matrices
           case("make_pcc_densities");            .make_pcc_densities
           case("make_pcc_structure_factors");    .make_pcc_structure_factors
           case("make_pcc_b_field");              .make_pcc_b_field
           case("test_spin_orbit_b_matrices");    .test_spin_orbit_B_matrices
           case("test_eigen");                    .test_eigen
           case("put_atom_kind_map");             .put_atom_kind_map
           case("start_new_molecule");            .reset_molecule
           case("put_vrml");                      .atom.put_vrml(.name.trim // achar(46) // "wrl")
           case("put_chi2_vs_angle");             .crystal.put_chi2_vs_angle_plot
           case default;  DIE("unknown directive " // '"' // word.trim // '"')
        end
     end do read_loop
     stdout.flush
     stdout.text( std_time.time_taken("job "//'"'// .name.trim //'"') )
     stdout.text( std_time.cpu_time_taken("job "//'"'// .name.trim //'"') )
     tonto.report
  end

end
