! Macros file
! $Id$

!----------------------------------------------------------------------
! Kind parameters for scalar intrinsic types. Note that kind type 
! parameters may not match with byte size length, especially for CPX
! Normally, the double precision kind type is "8".
!----------------------------------------------------------------------

# define CHR_KIND      1

# ifndef INT_KIND
# define INT_KIND      4
# endif
# define INT_1_KIND    1
# define INT_2_KIND    2
# define INT_4_KIND    4
# define INT_8_KIND    8

# ifndef BIN_KIND
# define BIN_KIND      4
# endif
# define BIN_1_KIND    1
# define BIN_4_KIND    4

# ifndef REAL_KIND
# define REAL_KIND     8
# endif
# define REAL_4_KIND   4
# define REAL_8_KIND   8
# define REAL_16_KIND  16

# define CPX_KIND      8
# define CPX_4_KIND    4
# define CPX_8_KIND    8
# define CPX_16_KIND   16

!----------------------------------------------------------------------
! Byte Size parameters for scalar intrinsic types
!----------------------------------------------------------------------

# define CHR_SIZE      1

# define STR_SIZE    512
# define BSTR_SIZE   512

# define INT_SIZE      4
# define INT_1_SIZE    1
# define INT_2_SIZE    2
# define INT_4_SIZE    4
# define INT_8_SIZE    8

# define BIN_SIZE      4
# define BIN_1_SIZE    1
# define BIN_4_SIZE    4

# define PTR_SIZE      8

# define REAL_SIZE     8
# define REAL_4_SIZE   4
# define REAL_8_SIZE   8
# define REAL_16_SIZE  16

# define CPX_SIZE      16
# define CPX_4_SIZE    8
# define CPX_8_SIZE    16
# define CPX_16_SIZE   32

!----------------------------------------------------------------------
! Intrinsic scalar types ... 
!----------------------------------------------------------------------

# define INT        integer(INT_KIND)
# define INT_1      integer(INT_1_KIND)
# define INT_2      integer(INT_2_KIND)
# define INT_4      integer(INT_4_KIND)
# define INT_8      integer(INT_8_KIND)

# define BIN        logical(BIN_KIND)
# define BIN_1      logical(BIN_1_KIND)
# define BIN_4      logical(BIN_4_KIND)

# define REAL       real(REAL_KIND)
# define REAL_4     real(REAL_4_KIND)
# define REAL_8     real(REAL_8_KIND)
# define REAL_16    real(REAL_16_KIND)

# define CPX        complex(CPX_KIND)
# define CPX_4      complex(CPX_4_KIND)
# define CPX_8      complex(CPX_8_KIND)
# define CPX_16     complex(CPX_16_KIND)

# define CHR        character

!----------------------------------------------------------------------
! Array types ... 
!----------------------------------------------------------------------

# define STR(X)                     character(X)
# define BSTR(X)                    character(X)
# define VEC(X,A)                   X, dimension(A)
# define MAT(X,A,B)                 X, dimension(A,B)
# define MAT3(X,A,B,C)              X, dimension(A,B,C)
# define MAT4(X,A,B,C,D)            X, dimension(A,B,C,D)
# define MAT5(X,A,B,C,D,E)          X, dimension(A,B,C,D,E)
# define MAT6(X,A,B,C,D,E,F)        X, dimension(A,B,C,D,E,F)
# define MAT7(X,A,B,C,D,E,F,G)      X, dimension(A,B,C,D,E,F,G)

!----------------------------------------------------------------------
! Memory addressing
!----------------------------------------------------------------------

# if   defined INTEL_ifc_on_LINUX
#    define ADDRESS_OF(X)             ,loc(X)
# elif defined LAHEY_lf95_on_WINDOWS
#    define ADDRESS_OF(X)             ,pointer(X)
# else
#    define ADDRESS_OF(X)             
# endif

!----------------------------------------------------------------------
! How the tonto system calls are to appear in the fortran code ...
! Parallel systems calls are treated separately, later on ...
!----------------------------------------------------------------------

# if defined NO_TONTO_SYSTEM_CALLS || defined NO_TONTO_SYSTEM_CHECKS

#    define DIE0(X)                   print *,X; stop
#    define DIE_IF0(X,Y)              if (X) then; print *,Y; stop; end if
#    define WARN0(X)                  print *,X
#    define WARN_IF0(X,Y)             if (X) print *,Y
#    define ENSURE0(X,Y)              if (.not. (X)) then; print *,Y; stop; end if

#    define STACK0(X)                 ! Starting routine X
#    define UNSTACK0(X)               ! Ending routine ...
#    define CHECK0(X)                 ! Normally check for memory leaks here ...
#
#    define ADD_LOCATION0(X,Y)        ! Keep track of memory location
#    define ADD_MEMORY0(X)            ! Keep track of memory location
#    define DELETE_MEMORY0(X)         ! Keep track of memory location
#    define IGNORE_MEMORY_LEAK0(X)    ! An intentional memory leak occurs in this routine ...

#    define START_TIMER0(X)           ! Start routine timer ...
#    define STOP_TIMER0               ! Stop routine timer ...

#    define TONTO_FLUSH_BUFFER0(X)    ! Normally, flush output buffer
#    define TONTO_CREATE0             ! Normally, create tonto defaults (memory, parallel, etc ...)
#    define TONTO_DESTROY0            ! Normally, destroy tonto object
#    define TONTO_REPORT0             ! Normally, produce a tonto report
#    define TONTO_SET_STDERR0(X)      ! Normally, set the tonto error outpurt file

# elif defined NO_GENERIC_NAMES

#    define DIE0(X)                   call SYSTEM_die(tonto,X)
#    define DIE_IF0(X,Y)              call SYSTEM_die_if(tonto,X,Y)
#    define WARN0(X)                  call SYSTEM_warn(tonto,X)
#    define WARN_IF0(X,Y)             call SYSTEM_warn_if(tonto,X,Y)
#    define ENSURE0(X,Y)              call SYSTEM_ensure(tonto,X,Y)

#    define STACK0(X)                 call SYSTEM_stack(tonto,X)
#    define UNSTACK0(X)               call SYSTEM_unstack(tonto,X)
#    define CHECK0(X)                 call SYSTEM_check(tonto,X)

#    define ADD_LOCATION0(X,Y)        call SYSTEM_add_memory(tonto,X ADDRESS_OF(Y))
#    define ADD_MEMORY0(X)            call SYSTEM_add_memory(tonto,X ADDRESS_OF(self))
#    define DELETE_MEMORY0(X)         call SYSTEM_delete_memory(tonto,X ADDRESS_OF(self))
#    define IGNORE_MEMORY_LEAK0(X)    call SYSTEM_ignore_memory_leak(tonto,X)

#    define START_TIMER0(X)           call SYSTEM_start_timer(tonto,X)
#    define STOP_TIMER0               call SYSTEM_stop_timer(tonto)

#    define TONTO_FLUSH_BUFFER0(X)    call SYSTEM_flush_buffer(tonto,X)
#    define TONTO_CREATE0             call SYSTEM_create(tonto)
#    define TONTO_DESTROY0            call SYSTEM_destroy(tonto)
#    define TONTO_REPORT0             call SYSTEM_report(tonto)
#    define TONTO_SET_STDERR0(X)      call SYSTEM_set_error_output_file(tonto,X)

# else

#    define DIE0(X)                   call die_(tonto,X)
#    define DIE_IF0(X,Y)              call die_if_(tonto,X,Y)
#    define WARN0(X)                  call warn_(tonto,X)
#    define WARN_IF0(X,Y)             call warn_if_(tonto,X,Y)
#    define ENSURE0(X,Y)              call ensure_(tonto,X,Y)

#    define STACK0(X)                 call stack_(tonto,X)
#    define UNSTACK0(X)               call unstack_(tonto,X)
#    define CHECK0(X)                 call check_(tonto,X)

#    define ADD_LOCATION0(X,Y)        call add_memory_(tonto,X ADDRESS_OF(Y))
#    define ADD_MEMORY0(X)            call add_memory_(tonto,X ADDRESS_OF(self))
#    define DELETE_MEMORY0(X)         call delete_memory_(tonto,X ADDRESS_OF(self))
#    define IGNORE_MEMORY_LEAK0(X)    call ignore_memory_leak_(tonto,X)

#    define START_TIMER0(X)           call start_timer_(tonto,X)
#    define STOP_TIMER0               call stop_timer_(tonto)

#    define TONTO_FLUSH_BUFFER0(X)    call flush_buffer_(tonto,X)
#    define TONTO_CREATE0             call create_(tonto)
#    define TONTO_DESTROY0            call destroy_(tonto)
#    define TONTO_REPORT0             call report_(tonto)
#    define TONTO_SET_STDERR0(X)      call set_error_output_file_(tonto,X)

# endif

! These are system calls involving the tonto variable

# define TONTO_FLUSH_BUFFER(X)        TONTO_FLUSH_BUFFER0(X)
# define TONTO_CREATE                 TONTO_CREATE0    
# define TONTO_DESTROY                TONTO_DESTROY0 
# define TONTO_REPORT                 TONTO_REPORT0
# define TONTO_SET_STDERR(X)          TONTO_SET_STDERR0(X)

!----------------------------------------------------------------------
! How parallelisation appear in the fortran code ... 
!----------------------------------------------------------------------

# if defined NO_TONTO_SYSTEM_CALLS

#    define PARALLEL_DO_START0(X,Y)   X
#    define PARALLEL_DO_STRIDE0(X)    X
#    define LOCK_PARALLEL_DO0(X)      ! Normally this is a parallel do loop ...
#    define UNLOCK_PARALLEL_DO0(X)    ! End parallel do loop ...
#    define IO_IS_ALLOWED0            TRUE
#    define DO_IN_PARALLEL0           FALSE
#    define PARALLEL_SUM0(X)        
#    define PARALLEL_VECTOR_SUM0(X,Y)        
#    define PARALLEL_SYMMETRIC_SUM0(X)        
#    define PARALLEL_BROADCAST0(X,Y)

# elif defined NO_GENERIC_NAMES 

#    define PARALLEL_DO_START0(X,Y)   call SYSTEM_parallel_do_start(tonto,X,Y)
#    define PARALLEL_DO_STRIDE0(X)    call SYSTEM_parallel_do_stride(tonto,X)
#    define LOCK_PARALLEL_DO0(X)      call SYSTEM_lock_parallel_do(tonto,X)
#    define UNLOCK_PARALLEL_DO0(X)    call SYSTEM_unlock_parallel_do(tonto,X)
#    define IO_IS_ALLOWED0            SYSTEM_IO_is_allowed(tonto)
#    define DO_IN_PARALLEL0           SYSTEM_do_in_parallel(tonto)
#    define PARALLEL_SUM0(X)           if (DO_IN_PARALLEL0) call SYSTEM_parallel_sum(tonto,X)
#    define PARALLEL_VECTOR_SUM0(X,Y)  if (DO_IN_PARALLEL0) call SYSTEM_parallel_vector_sum(tonto,X,Y)
#    define PARALLEL_SYMMETRIC_SUM0(X) if (DO_IN_PARALLEL0) call SYSTEM_parallel_symmetric_sum(tonto,X)
#    define PARALLEL_BROADCAST0(X,Y)   if (DO_IN_PARALLEL0) call SYSTEM_broadcast(tonto,X,Y)

# else

#    define PARALLEL_DO_START0(X,Y)   parallel_do_start_(tonto,X,Y)
#    define PARALLEL_DO_STRIDE0(X)    parallel_do_stride_(tonto,X)
#    define LOCK_PARALLEL_DO0(X)      call lock_parallel_do_(tonto,X)
#    define UNLOCK_PARALLEL_DO0(X)    call unlock_parallel_do_(tonto,X)
#    define IO_IS_ALLOWED0            IO_is_allowed_(tonto)
#    define DO_IN_PARALLEL0           do_in_parallel_(tonto)
#    define PARALLEL_SUM0(X)           if (DO_IN_PARALLEL0) call parallel_sum_(tonto,X)
#    define PARALLEL_VECTOR_SUM0(X,Y)  if (DO_IN_PARALLEL0) call parallel_vector_sum_(tonto,X,Y)
#    define PARALLEL_SYMMETRIC_SUM0(X) if (DO_IN_PARALLEL0) call parallel_symmetric_sum_(tonto,X)
#    define PARALLEL_BROADCAST0(X,Y)   if (DO_IN_PARALLEL0) call broadcast_(tonto,X,Y)

# endif

!----------------------------------------------------------------------
! Parallelisation macros ... 
!----------------------------------------------------------------------

# ifdef MPI
#    define PARALLEL_DO_START(X,Y)    PARALLEL_DO_START0(X,Y)
#    define PARALLEL_DO_STRIDE(X)     PARALLEL_DO_STRIDE0(X)
#    define LOCK_PARALLEL_DO(X)       LOCK_PARALLEL_DO0(X)
#    define UNLOCK_PARALLEL_DO(X)     UNLOCK_PARALLEL_DO0(X)
#    define IO_IS_ALLOWED             IO_IS_ALLOWED0
#    define DO_IN_PARALLEL            DO_IN_PARALLEL0
#    define PARALLEL_SUM(X)           PARALLEL_SUM0(X)
#    define PARALLEL_VECTOR_SUM(X,Y)  PARALLEL_VECTOR_SUM0(X,Y)
#    define PARALLEL_SYMMETRIC_SUM(X) PARALLEL_SYMMETRIC_SUM0(X)
#    define PARALLEL_BROADCAST(X,Y)   PARALLEL_BROADCAST0(X,Y)
# else
#    define PARALLEL_DO_START(X,Y)    X
#    define PARALLEL_DO_STRIDE(X)     X
#    define LOCK_PARALLEL_DO(X)       ! Normally this is a parallel do loop ...
#    define UNLOCK_PARALLEL_DO(X)     ! End parallel do loop ...
#    define IO_IS_ALLOWED             TRUE
#    define DO_IN_PARALLEL            FALSE
#    define PARALLEL_SUM(X)        
#    define PARALLEL_VECTOR_SUM(X,Y)        
#    define PARALLEL_SYMMETRIC_SUM(X)        
#    define PARALLEL_BROADCAST(X,Y)
# endif

!----------------------------------------------------------------------
! Memory/Call stack management macros ... 
!----------------------------------------------------------------------

# ifdef TRACK_MEMORY_LOCATIONS
#    define USE_CALL_STACK_MANAGEMENT
# endif

# ifdef USE_CALL_STACK_MANAGEMENT
#    define USE_PRECONDITIONS
#    define STACK(X)                  STACK0(X)     
#    define UNSTACK(X)                UNSTACK0(X)
#    define CHECK(X)                  CHECK0(X)
#    define ADD_LOCATION(X,Y)         ADD_LOCATION0(X,Y)
#    define ADD_MEMORY(X)             ADD_MEMORY0(X)
#    define DELETE_MEMORY(X)          DELETE_MEMORY0(X)
#    define IGNORE_MEMORY_LEAK(X)     IGNORE_MEMORY_LEAK0(X)
# else
#    define STACK(X)                  ! Starting routine X
#    define UNSTACK(X)                ! Ending routine ...
#    define CHECK(X)                  ! Normally check for memory leaks here ...
#    define ADD_LOCATION(X,Y)         ! Normally keep track of new memory usage here ...
#    define ADD_MEMORY(X)             ! Normally keep track of new memory usage here ...
#    define DELETE_MEMORY(X)          ! Normally delete old memory usage here ...
#    define IGNORE_MEMORY_LEAK(X)     ! An intentional memory leak occurs in this routine ...
# endif

!----------------------------------------------------------------------
! Precondition and Postcodition macros ... 
!----------------------------------------------------------------------

# ifdef USE_PRECONDITIONS
#    define USE_ERROR_MANAGEMENT
#    define ENSURE(X,Y)               ENSURE0(X,Y)
# else
#    define ENSURE(X,Y)               ! Ensure (X) or die and print: Y
# endif

!----------------------------------------------------------------------
! Error macros ... 
!----------------------------------------------------------------------

# ifdef USE_ERROR_MANAGEMENT
#    define DIE(X)                    DIE0(X)            
#    define DIE_IF(X,Y)               DIE_IF0(X,Y)     
#    define WARN(X)                   WARN0(X)           
#    define WARN_IF(X,Y)              WARN_IF0(X,Y)      
# else
#    define DIE(X)                    ! Die and print: X
#    define DIE_IF(X,Y)               ! Die if (X) and print: Y 
#    define WARN(X)                   ! Warning message: X
#    define WARN_IF(X,Y)              ! Warn if (X) and print: Y
# endif

!----------------------------------------------------------------------
! Time profiling macros ... 
!----------------------------------------------------------------------

# ifdef USE_TIME_PROFILING
#    define BROKEN_PURE
#    define START_TIMER(X)            START_TIMER0(X)
#    define STOP_TIMER                STOP_TIMER0
# else
#    define START_TIMER(X)            ! Start routine timer ...
#    define STOP_TIMER                ! Stop routine timer ...
# endif

!----------------------------------------------------------------------
! Unknown case macro ...
!----------------------------------------------------------------------

# define UNKNOWN(X)    DIE("unknown case option: " // trim(X))

!-------------------------------------------------------------------------------
! Some compilers cannot handle Fortran 95 features ...
!-------------------------------------------------------------------------------

# ifdef LANGUAGE_FORTRAN_90
#    define BROKEN_TYPE_INITIALIZATION
#    define BROKEN_PURE
# endif

!-------------------------------------------------------------------------------
! Some Fortran 95 compilers can't handle pure routines ...
!-------------------------------------------------------------------------------

# ifdef BROKEN_PURE
#    define PURE 
#    define ELEMENTAL 
#    define ALWAYS_PURE 
#    define ALWAYS_ELEMENTAL 
# else
#    define PURE                      pure
#    define ELEMENTAL                 elemental
#    define ALWAYS_PURE               pure
#    define ALWAYS_ELEMENTAL          elemental
# endif

!-------------------------------------------------------------------------------
! Some Fortran 95 compilers can't handle default initialisation properly ...
!-------------------------------------------------------------------------------

# ifdef BROKEN_TYPE_INITIALIZATION
#    define DEFAULT_NULL
#    define DEFAULT(X)
# else
#    define DEFAULT(X)                = X
#    define DEFAULT_NULL              => NULL()
# endif

!----------------------------------------------------------------------
! Convenience macros ... 
!----------------------------------------------------------------------

# define AND        .and.
# define OR         .or.
# define NOT        .not.
# define FALSE      .false.
# define TRUE       .true.
# define EQV        .eqv.
# define NEQV       .neqv.

# define PTR        pointer
# define IN         intent(in)
# define OUT        intent(out)
# define INOUT      intent(inout)
# define PAR        parameter

# define ZERO          0.0d0
# define ONE           1.0d0
# define TWO           2.0d0
# define THREE         3.0d0
# define FOUR          4.0d0
# define FIVE          5.0d0
# define SIX           6.0d0
# define SEVEN         7.0d0
# define EIGHT         8.0d0
# define NINE          9.0d0
# define TEN          10.0d0

# define HALF              0.50d0
# define QUARTER           0.25d0
# define EIGHTH            0.125d0
# define SIXTEENTH         0.0625d0
# define THIRD             0.33333333333333333333333d0
# define ONETHIRD          0.33333333333333333333333d0
# define TWOTHIRD          0.66666666666666666666667d0
# define TWOTHIRDS         0.66666666666666666666667d0
# define FOURTHIRD         1.33333333333333333333333d0
# define FOURTHIRDS        1.33333333333333333333333d0
# define SIXTH             0.16666666666666666666667d0
# define NINTH             0.11111111111111111111111d0
# define TENTH             0.10d0

# define PI                3.141592653589793d0
# define SQRT_2PI          2.5066282746310005d0
# define EULER             2.718281828459045d0
# define PI32              5.568327996831707
# define TWOPI5ON2         34.98683665524973d0

# define TOL(N)                   TEN**(-N)

!----------------------------------------------------------------------
! Fundamental constants and conversion factors ...
! Most taken from CODATA 2002 so do not change!
!----------------------------------------------------------------------

# define AVOGADROS_NUMBER         6.0221415d+23
# define SPEED_OF_LIGHT_SI        2.99792458d+8
# define CHARGE_OF_ELECTRON_SI    1.60217653d-19
# define AMU_SI                   1.66053886d-27
# define MASS_OF_ELECTRON_SI      9.1093826d-31
# define MASS_OF_PROTON_SI        1.67262171d-27
# define MASS_OF_NEUTRON_SI       1.67492728d-27
# define BOHR_MAGNETON_SI         9.27400949d-24
# define NUCLEAR_MAGNETON_SI      5.05078343d-27
# define G_FACTOR                 2.0023193043718
# define BOLTZMANN_SI             1.3806505d-23
# define HARTREE_SI               4.35974417d-18
# define ANGSTROM_SI              1.0d-10
# define PLANCK_SI                6.6260693d-34
# define BOHR_MAGNETON_AU         HALF      
# define SPEED_OF_LIGHT_AU        137.03599d0

# define AMU_PER_MASS_OF_ELECTRON (MASS_OF_ELECTRON_SI/AMU_SI)
# define MASS_OF_ELECTRON_PER_AMU (AMU_SI/MASS_OF_ELECTRON_SI)
# define ANGSTROM_PER_BOHR        0.5291772108d0
# define METER_PER_ANGSTROM       1.0d-10
# define BOHR_PER_BOHR            ONE
# define BOHR_PER_ANGSTROM        (1/0.5291772108d0)
# define WAVENUMBER_PER_HARTREE   2.194746313705d+5
# define EV_PER_HARTREE           27.2113845           
# define KELVIN_PER_HARTREE       3.1577465d+5         
# define JOULE_PER_HARTREE        4.35974417d-18
# define KJOULE_PER_HARTREE       4.35974417d-21
# define CAL_PER_HARTREE          1.042d-18        
# define KCAL_PER_HARTREE         1.042d-21        
# define KCALMOL_PER_HARTREE      627.5            
# define KJOULEMOL_PER_HARTREE    2625.46          
# define JOULE_PER_CAL            4.184            
# define DEGREE_PER_RADIAN        (180d0/PI)
# define RADIAN_PER_DEGREE        (PI/180d0)
# define DEBYE_PER_AU             2.5418d0
# define AU_PER_DEBYE             (ONE/2.5418d0)

!----------------------------------------------------------------------
! Module constants ...
! The first word identifies the module to which the constant belongs
!----------------------------------------------------------------------

# define ADAPTIVE_QUADRATURE_ACCURACY         TOL(3)

# define ATOM_BONDED_RANGE_FACTOR             0.4*BOHR_PER_ANGSTROM

# define BECKE_GRID_KIND                      "mura_knowles"
# define BECKE_GRID_EXTRA_POINTS_PER_SHELL    5
# define BECKE_GRID_REDUCE_CORE_ANGULAR_GRID  TRUE
# define BECKE_GRID_REDUCE_H_ANGULAR_GRID     TRUE
# define BECKE_GRID_SCALE_ATOMIC_GRIDS        TRUE
# define BECKE_GRID_PARTITION_POWER           3
# define BECKE_GRID_STRATMANN_SCUSERIA_A      0.64d0
# define BECKE_GRID_PARTITION_SCHEME          "stratmann_scuseria"
# define BECKE_GRID_PARTITION_SCALING_SCHEME  "none"
# define BECKE_GRID_PRUNING_SCHEME            "treutler_ahlrichs"
# define BECKE_GRID_ACCURACY                  "low"
# define BECKE_GRID_BASIS_FUNCTION_CUTOFF     TOL(3)
# define BECKE_GRID_PARTITION_CUTOFF          TOL(4)
# define BECKE_GRID_RHO_CUTOFF                TOL(6)

# define BUFFER_COMMENT_CHARS             "!#"
# define BUFFER_QUOTE_CHARS               "'"//'"'

# define CIF_CH_BOND_LENGTH               1.083d0
# define CIF_NH_BOND_LENGTH               1.009d0
# define CIF_OH_BOND_LENGTH               0.983d0

# define CLUSTER_GENERATION_METHOD        "fragment"
# define CLUSTER_RADIUS                   ZERO
# define CLUSTER_ATOM_DENSITY_CUTOFF      TOL(9)
# define CLUSTER_DEFRAGMENT               FALSE

# define COPPENSORBITAL_VALUES_CUTOFF     TOL(6)

# define DIFFRACTION_DATA_SYNTHESISE_SIGMA_I       FALSE                             
# define DIFFRACTION_DATA_OPTIMISE_SCALE           TRUE
# define DIFFRACTION_DATA_OPTIMISE_EXTINCTION      TRUE                               
# define DIFFRACTION_DATA_CORRECT_DISPERSION       FALSE                             
# define DIFFRACTION_DATA_SCALE_FACTOR             ONE
# define DIFFRACTION_DATA_EXP_SCALE_FACTOR         ONE                             
# define DIFFRACTION_DATA_EXTINCTION_FACTOR        ZERO                             
# define DIFFRACTION_DATA_WAVELENGTH               0.71069d0 * BOHR_PER_ANGSTROM
# define DIFFRACTION_DATA_DATA_KIND                "x-ray"
# define DIFFRACTION_DATA_THERMAL_SMEARING_MODEL   " "                                   
# define DIFFRACTION_DATA_PARTITION_MODEL          " "
# define DIFFRACTION_DATA_F_EXP_MIN                ZERO
# define DIFFRACTION_DATA_F_SIGMA_MIN              TOL(3)
# define DIFFRACTION_DATA_F_SIGMA_MAX              10000

# define DFT_FUNCTIONAL_XALPHA            0.7d0
# define DFT_FUNCTIONAL_RHO_CUTOFF        TOL(30)

# define DFTGRID_SPHERICAL_GRID_KIND      "lebedev"
# define DFTGRID_SPHERICAL_GRID_ORDER     35
# define DFTGRID_RADIAL_GRID_KIND         "gauss-chebyshev"
# define DFTGRID_RADIAL_GRID_ORDER        60
# define DFTGRID_BECKE_M_PARTITION_POWER  TWO
# define DFTGRID_GAUSS_CHEBYSHEV_M        ONE
# define DFTGRID_GAUSS_CHEBYSHEV_ALPHA    THREE
# define DFTGRID_EULER_MACLAURIN_M        TWO
# define DFTGRID_EULER_MACLAURIN_ALPHA    TWO
# define DFTGRID_ARCHIVE_ROOT_NAME        "dftgrid"
# define DFTGRID_ARCHIVE_NAME             "grid"

# define DIIS_GENRE                       "diis"
# define DIIS_START_ITERATION             3
# define DIIS_SAVE_ITERATION              1
# define DIIS_KEEP                        8
# define DIIS_CONVERGENCE_TOLERANCE       TOL(3)
# define DIIS_START_TOLERANCE             TOL(2)
# define DIIS_ENCORE_ITERATIONS           4
# define DIIS_REPLACEMENT_METHOD          "worst"
# define DIIS_FORCE_CONVEXITY             FALSE
# define DIIS_MICRO_ITERATION_METHOD      "bfgs"
# define DIIS_MICRO_STARTING_GUESS        "diis"
# define DIIS_MICRO_CONVERGENCE_TOL       TOL(6)
# define DIIS_MICRO_MAX_ITERATIONS        10000
# define DIIS_MICRO_DAMP_FACTOR           0.9d0
# define DIIS_ERROR_TEMP_CUTOFF           TOL(2)

# define FILE_BUFFER_LENGTH               1024

# define INTERPOLATOR_INTERPOLATION_KIND  "linear"
# define INTERPOLATOR_TABLE_LENGTH        30.0d0
# define INTERPOLATOR_TABLE_ORIGIN        ZERO
# define INTERPOLATOR_TABLE_SPACING       0.02d0
# define INTERPOLATOR_TABLE_EPS           TOL(6)
# define INTERPOLATOR_Y1_INITIAL          huge(ONE) 
# define INTERPOLATOR_Y1_FINAL            huge(ONE) 
# define INTERPOLATOR_Y2_INITIAL          ZERO
# define INTERPOLATOR_Y2_FINAL            ZERO

# define ISOSURFACE_ISO_VALUE             ONE
# define ISOSURFACE_MINIMUM_SCAN_LEVEL    4         
# define ISOSURFACE_MINIMUM_SCAN_DIVISION  HALF
# define ISOSURFACE_VOXEL_PROXIMITY_FACTOR 1.5d0
# define ISOSURFACE_SURFACE_POINT         (/TOL(6),TOL(6),TOL(6)/)
# define ISOSURFACE_PROPERTY_LB           -huge(ONE)
# define ISOSURFACE_PROPERTY_UB           huge(ONE)
# define ISOSURFACE_PROPERTY_LB_ABS       TOL(10)
# define ISOSURFACE_PROPERTY_UB_ABS       huge(ONE)
# define ISOSURFACE_N_POINT               10000
# define ISOSURFACE_N_FACE                20000
# define ISOSURFACE_INTERPOLATION_KIND    "logarithmic_linear"
# define ISOSURFACE_TABLE_LENGTH          30.0d0
# define ISOSURFACE_TABLE_ORIGIN          ZERO
# define ISOSURFACE_TABLE_SPACING         0.02d0
# define ISOSURFACE_TABLE_EPS             TOL(9)

# define MAT_LINEAR_DEPENDENCE_TOL        TOL(10)

# define MO_LOCALISER_ALGORITHM           "boys"
# define MO_LOCALISER_ACCURACY            TOL(3)
# define MO_LOCALISER_MAXIT               20

# define PLOTGRID_MAXIMUM_CELL_DISTANCE   5
# define PLOTGRID_NX                      75
# define PLOTGRID_NY                      75
# define PLOTGRID_NZ                      1
# define PLOTGRID_X_AXIS                  (/ ONE,ZERO,ZERO/)
# define PLOTGRID_Y_AXIS                  (/ZERO, ONE,ZERO/)
# define PLOTGRID_Z_AXIS                  (/ZERO,ZERO, ONE/)
# define PLOTGRID_WIDTH                   (/ TWO, TWO,ZERO/)

# define QUADRATURE_ACCURACY              TOL(6)
# define QUADRATURE_EPS                   TOL(13)
# define QUADRATURE_MAXIT                 10

# define REAL_EPSILON                     TOL(6)

# define ROBY_OCCUPIED_ANO_CUTOFF         0.05d0
# define ROBY_COVALENT_CUTOFF             89.0d0
# define ROBY_IONIC_CUTOFF                77.0d0
# define ROBY_ZERO_CUTOFF                 TOL(4)
# define ROBY_PI_ON_2_CUTOFF              90.0d0
# define ROBY_OUTPUT_THETA_INFO           TRUE
# define ROBY_ANALYSE_ALL_ATOM_PAIRS      FALSE
# define ROBY_BOND_SCALE_FACTOR           1.33

# define SCFDATA_DFT_EXCHANGE_FUNCTIONAL  "becke88"
# define SCFDATA_USING_GGA_EXCHANGE       TRUE
# define SCFDATA_DFT_CORRELATION_FUNCTIONAL "lyp"
# define SCFDATA_USING_GGA_CORRELATION    TRUE
# define SCFDATA_CONVERGENCE              TOL(3)
# define SCFDATA_GUESS_CONVERGENCE        TOL(3)
# define SCFDATA_USING_ROUGH_CONVERGENCE  TRUE
# define SCFDATA_ROUGH_CONVERGENCE        0.100
# define SCFDATA_ROUGH_DIIS_CONVERGENCE   0.150
# define SCFDATA_GUESS_DIIS_CONVERGENCE   0.050
# define SCFDATA_USING_DAMPING            TRUE 
# define SCFDATA_USING_LEVEL_SHIFT        TRUE 
# define SCFDATA_ERI_LIMIT                TOL(12)
# define SCFDATA_ROUGH_ERI_LIMIT          TOL(7)
# define SCFDATA_ERI_PAIR_CUTOFF          TOL(6)
# define SCFDATA_ATOM_OVERLAP_CUTOFF      TOL(9)
# define SCFDATA_XC_ATOM_SEPARATION_CUTOFF 15.0
# define SCFDATA_MIN_ITERATIONS           1
# define SCFDATA_MAX_ITERATIONS           100
# define SCFDATA_DAMP_FACTOR              0.5d0
# define SCFDATA_DAMP_FINISH              3
# define SCFDATA_LEVEL_SHIFT              0.3d0
# define SCFDATA_LEVEL_SHIFT_FINISH       3

# define SHELL_IS_SPHERICAL               FALSE

# define SHELL1_IS_SPHERICAL              FALSE

# define SHELL2_PAIR_CUTOFF               TOL(6)

# define SHELL4_ERI_CUTOFF                1.0d-15

# define SHELL1QUARTET_ERI_PAIR_CUTOFF    TOL(6)

# define SPACEGROUP_MAX_UNIQUE_SYMOPS     1000

# define SYSTEM_ERROR_OUTPUT_UNIT         6
# define SYSTEM_MEMORY_UNITS              "Words"
# define SYSTEM_MEMORY_LIMIT              6*8000000
# define SYSTEM_STACK_LIMIT               20

# define TEXTFILE_STDIN_UNIT              5
# define TEXTFILE_STDOUT_UNIT             6
# define TEXTFILE_STDERR_UNIT             7
# define TEXTFILE_COMMENT_CHARS           "!#"
# define TEXTFILE_QUOTE_CHARS             "'"""
# define TEXTFILE_USE_FIELDS              TRUE
# define TEXTFILE_USE_LABELS              TRUE
# define TEXTFILE_MARGIN_WIDTH            0
# define TEXTFILE_N_FIELDS                5
# define TEXTFILE_REAL_WIDTH              16
# define TEXTFILE_INT_WIDTH               9
# define TEXTFILE_REAL_PRECISION          6
# define TEXTFILE_REAL_STYLE              " f"

# define UNIT_CELL_ANGLES                 (/90.0d0,90.0d0,90.0d0/)        
# define UNIT_CELL_LENGTHS                (/10.0d0,10.0d0,10.0d0/)         

# define UNIT_NUMBER_STARTING_UNIT        10
