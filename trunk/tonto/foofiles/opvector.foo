!-------------------------------------------------------------------------------
!
! OPVEC: Diagonals of operator matrices, e.g. eigenvalues an occupation numbers
!
! Provide a basis set (matrix) representation of the diagonal of a one-electron 
! quantum mechanical operator. Can cope with polymorphic types of basis 
! representations, including restricted, unrestricted, and general basis 
! orbitals. Complex types aren't needed sice operators are hermitian.
!
! (c) dylan jayatilaka 1998
!
! $Id$
!-------------------------------------------------------------------------------
module OPVEC

   use TYPES
   use SYSTEM
   use STR
   use VEC

   implicit none         

#  include "macros"
#  include "opvec.int"

!   type opvec_type
!
!   INT :: n_bf
!   ! No of spatial basis functions (i.e. AO's)
!
!   VEC* :: restricted
!   ! Restricted spinorbital representation
!
!   VEC* :: alpha
!   ! Alpha part of a DODS representation
!
!   VEC* :: beta
!   ! Beta  part of a DODS representation
!
!   VEC* :: general
!   ! General mixed alpha-beta matrix representation
!
!   end

contains

   create(n_bf,kind)
   ! Create an opmat object, in a basis set with "n_bf" spatial orbitals
      PTR :: self
      INT :: n_bf
      STR(*), optional :: kind
      nullify(self)
      allocate(self)
      ADD_MEM(OPVEC_SIZE)
      .nullify_ptr_part
      .n_bf = n_bf
      if (present(kind)) .create(kind)
   end

   destroy 
   ! Destroy an opmat object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(OPVEC_SIZE)
      deallocate(self)
   end

   create(kind)
   ! Create the appropriate spinorbital kind of the opvec
      STR(*) :: kind
      INT :: n_bf
      n_bf = .n_bf
      select case (kind)
         case ("restricted","restricted_complex");     .restricted.create(n_bf)
         case ("unrestricted","unrestricted_complex"); .alpha.create(n_bf)
                                                       .beta.create(n_bf)
         case ("alpha","alpha_complex");               .alpha.create(n_bf)
         case ("beta","beta_complex");                 .beta.create(n_bf)
         case ("general","general_complex");           .general.create(2*n_bf)
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   destroy(kind)
   ! Destroy the appropriate spinorbital kind of the opmat
      STR(*) :: kind
      select case (kind)
         case ("restricted","restriced_complex");       .restricted.destroy
         case ("unrestricted","unrestricted_complex");  .alpha.destroy; .beta.destroy
         case ("alpha","alpha_complex");                .alpha.destroy
         case ("beta","beta_complex");                  .beta.destroy
         case ("general","general_complex");            .general.destroy
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the opmat object
      nullify(.restricted)
      nullify(.alpha)
      nullify(.beta)
      nullify(.general)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of the opmat object
      .restricted.destroy
      .alpha.destroy
      .beta.destroy
      .general.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   created(kind) result(res)
   ! Returns true if subkind "kind" of self has been created
      PTR :: self
      STR(*) :: kind
      BIN :: res
      if (NOT associated(self)) then
                                    res = FALSE; return
      else
         select case (kind)
            case ("restricted");    res = .restricted.created
            case ("unrestricted");  res = .alpha.created
            case ("general");       res = .general.created
            case default; DIE("unknown spinorbital kind, " // kind.trim)
         end
      end
   end

  destroyed(kind) result(res)
  ! Returns true if subkind "kind" of self has *not* been created
    PTR :: self
    STR(*) :: kind
    BIN :: res
    if (NOT associated(self)) then
                                res = TRUE; return
    else
      select case (kind)
        case ("restricted");    res = .restricted.destroyed
        case ("unrestricted");  res = .alpha.destroyed
        case ("general");       res = .general.destroyed
        case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
    end
  end

   any_created result(res)
   ! Returns true if any component of self has been created
      BIN :: res
      BIN, dimension(3) :: c
      c(1) = .restricted.created
      c(2) = .alpha.created
      c(3) = .general.created
      res = any(c)
   end

   all_destroyed result(res)
   ! Returns true if all components of self have been destroyed
      BIN :: res
      BIN, dimension(3) :: d
      d(1) = .restricted.destroyed
      d(2) = .alpha.destroyed
      d(3) = .general.destroyed
      res = all(d)
   end

   set(n_bf)
   ! Set with "n_bf" spatial orbitals
      INT :: n_bf
      .n_bf = n_bf
   end

   set_to(v) [leaky]
   ! Set self to "v". 
      OPVEC :: v
      .set( v.n_bf)
      if ( v.all_destroyed) return
      if ( v.restricted.created) then
         .destroy("restricted"); .create("restricted")
         .restricted = v.restricted
      end
      if ( v.alpha.created) then
         .destroy("alpha"); .create("alpha")
          .alpha = v.alpha
      end
      if ( v.beta.created) then
         .destroy("beta"); .create("beta")
         .beta = v.beta
      end
      if ( v.general.created) then
         .destroy("general"); .create("general")
         .general = v.general
      end
   end

   spinorbital_kind result(res)
   ! Return the kind of spinorbitals used in the representation.
   ! The simplest spinorbital kind in use is the one returned.
      STR :: res
      if      ( .restricted.created ) then; res = "restricted"
      else if ( .alpha.created )      then; res = "unrestricted"
      else if ( .general.created )    then; res = "general"
      else; DIE("no object created")
      end
   end

   zero
   ! Set self to zero
      STR :: kind
      kind = .spinorbital_kind
      select case(kind)
         case("restricted");      .restricted = ZERO
         case("unrestricted");    .alpha = ZERO; .beta = ZERO
         case("general");         .general = ZERO
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

  convert_to(newkind) [leaky]
  ! Convert self to a new basis kind "newkind"
    STR(*) :: newkind
    STR :: oldkind
    oldkind = .spinorbital_kind
    if (newkind==oldkind) return
    .create(newkind)
    select case (oldkind)
      case("restricted")
        select case (newkind)
          case("unrestricted")
            .alpha = .restricted
            .beta  = .restricted
          case("general")
            .general = ZERO
            .general.set_alpha(.restricted)
            .general.set_beta(.restricted)
          case default
            DIE("cant convert kind " // oldkind.trim // " to kind " // newkind.trim)
        end
      case("unrestricted")
        select case (newkind)
          case("restricted")
            .restricted = .alpha
          case("general")
            .general.set_alpha(.alpha)
            .general.set_beta(.beta)
          case default
            DIE("cant convert kind " // oldkind.trim // " to kind " // newkind.trim)
        end
      case("general")
        select case (newkind)
          case("unrestricted")
            .alpha = .general.alpha
            .beta  = .general.beta
          case default
            DIE("cant convert kind " // oldkind.trim // " to kind " // newkind.trim)
        end
      case default; DIE("cant convert old kind " // oldkind.trim)
    end
    .destroy(oldkind)
  end

end 
