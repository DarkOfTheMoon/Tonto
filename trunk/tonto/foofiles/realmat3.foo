!---------------------------------------------------------------------------
!
!  MAT3: 3 dimensional matrices
!
!  (c) dylan jayatilaka, 1998
!
! $Id$
!---------------------------------------------------------------------------
module MAT3

   use SYSTEM

   implicit none         

#include "macros"
#include "mat3.int"

contains

   create(dim1,dim2,dim3)
   ! Create a mat3 with the given dimensions
      PTR :: self
      INT :: dim1,dim2,dim3
      nullify(self)
      allocate(self(dim1,dim2,dim3))
      ADD_MEM(dim1*dim2*dim3*DBL_SIZE)
   end

   create(lb1,ub1,lb2,ub2,lb3,ub3)
   ! Create a mat3 with the given bounds
      PTR :: self
      INT, IN :: lb1,lb2,lb3,ub1,ub2,ub3
      nullify(self)
      allocate(self(lb1:ub1,lb2:ub2,lb3:ub3))
      ADD_MEM((ub1-lb1+1)*(ub2-lb2+1)*(ub3-lb3+1)*DBL_SIZE)
   end

   create(bounds1,bounds2,bounds3)
   ! Create a mat3 with the given bounds for each dimension
      PTR :: self
      IVEC(2), IN :: bounds1,bounds2,bounds3
      .create(bounds1(1),bounds1(2),bounds2(1),bounds2(2),bounds3(1),bounds3(2))
   end

   create(bounds)
   ! Create a mat3 with the given bounds for all dimensions
      PTR :: self
      IMAT(3,2), IN :: bounds
      .create(bounds(1,1),bounds(1,2),bounds(2,1),bounds(2,2), &
              bounds(3,1),bounds(3,2))
   end

   destroy
   ! Destroy at mat3 object
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(size(self)*DBL_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   zero
      self = ZERO
   end

   make_symmetric
   ! Make the upper pyramid of "self" the same as the lower pyramid
      INT :: dim, i,j,k
      DBL :: val
      ENSURE(size(self,1)==size(self,2),"non-cube tensor")
      ENSURE(size(self,1)==size(self,3),"non-cube tensor")
      dim = size(self,1)
      do i = 1,dim
      do j = 1,i
      do k = 1,j
         val = self(i,j,k)
         self(i,k,j) = val
         self(j,i,k) = val
         self(j,k,i) = val
         self(k,i,j) = val
         self(k,j,i) = val
      end
      end
      end
   end

  symmetric_reflect_12
  ! Makes the matrix formed by the 1st and 2nd columns symmetrical.
    INT :: dim1,dim2,i,j
    dim1 = size(self,1)
    dim2 = size(self,2)
    DIE_IF(dim1/=dim2,"non-square matrix")
    do i = 1,dim1
    do j = 1,i-1
      self(j,i,:) = self(i,j,:)
    end
    end
  end

  symmetric_reflect_23
  ! Makes the matrix formed by the 2nd and 3rd columns symmetrical.
    INT :: dim,i,j
    .check_square_23
    dim = size(self,2)
    do i = 1,dim
    do j = 1,i-1
      self(:,j,i) = self(:,i,j)
    end
    end
  end

  to_tri_23(tr)
  ! Converts the matrix self to the lower triangle tr.
  ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
    IN :: self
    VEC :: tr
    INT :: dim1,dim2,h,i,j,ij,ltr
    dim1 = size(self,1)
    dim2 = size(self,2)
    .check_square_23
    ltr = dim1*dim2*(dim2+1)/2
    DIE_IF(size(tr)<ltr,"triangle array too small")
    ij = 0
    do h = 1,dim1
      do i = 1,dim2
        do j = 1,i
          ij = ij+1
          tr(ij) = self(h,j,i)
        end
      end
    end
  end

  from_tri_23(tr)
  ! Converts the matrix self to the lower triangle tr.
  ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
    VEC, IN :: tr
    INT :: dim1,dim2,h,i,j,ij,ltr
    dim1 = size(self,1)
    dim2 = size(self,2)
    .check_square_23
    ltr = dim1*dim2*(dim2+1)/2
    DIE_IF(size(tr)<ltr,"triangle array too small")
    ij = 0
    do h = 1,dim1
      do i = 1,dim2
        do j = 1,i
          ij = ij+1
          self(h,j,i) = tr(ij)
          self(h,i,j) = tr(ij)
        end
      end
    end
  end

  tri_size_23 result (ltr)
  ! Returns the size of the lower triangle needed to store the matrix self.
  ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
    IN :: self
    INT :: dim1,dim2,ltr
    dim1 = size(self,1)
    dim2 = size(self,2)
    .check_square_23
    ltr = dim1*dim2*(dim2+1)/2
  end

  check_square_23
  ! Checks to see that the matrix formed by the 2nd and 3rd columns is square.
    INT :: dim2,dim3
    dim2 = size(self,2)
    dim3 = size(self,3)
    DIE_IF(dim2/=dim3,"non-square matrix")
  end

end
