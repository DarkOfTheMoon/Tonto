! $Id$
!---------------------------------------------------------------------------
!
!  MAT3: 3 dimensional matrices
!
!  (c) dylan jayatilaka, 1998
!
!---------------------------------------------------------------------------
module MAT3

   use ERROR
   use MM

   implicit none         

#include "macros"
#include "mat3.int"

contains

   create(dim1,dim2,dim3)
   ! Create a mat3 with the given dimensions
      PTR :: self
      INT :: dim1,dim2,dim3
      nullify(self)
      allocate(self(dim1,dim2,dim3))
      std_mm.add(dim1*dim2*dim3*DBL_SIZE)
   end

   create(lb1,ub1,lb2,ub2,lb3,ub3)
   ! Create a mat3 with the given bounds
      PTR :: self
      INT, IN :: lb1,lb2,lb3,ub1,ub2,ub3
      nullify(self)
      allocate(self(lb1:ub1,lb2:ub2,lb3:ub3))
      std_mm.add((ub1-lb1+1)*(ub2-lb2+1)*(ub3-lb3+1)*DBL_SIZE)
   end

   create(bounds1,bounds2,bounds3)
   ! Create a mat3 with the given bounds for each dimension
      PTR :: self
      IVEC(2), IN :: bounds1,bounds2,bounds3
      .create(bounds1(1),bounds1(2),bounds2(1),bounds2(2),bounds3(1),bounds3(2))
   end

   create(bounds)
   ! Create a mat3 with the given bounds for all dimensions
      PTR :: self
      IMAT(3,2), IN :: bounds
      .create(bounds(1,1),bounds(1,2),bounds(2,1),bounds(2,2), &
              bounds(3,1),bounds(3,2))
   end

   destroy
   ! Destroy at mat3 object
      PTR :: self
      if (.destroyed) return
      std_mm.delete(size(self)*DBL_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   zero
      self = ZERO
   end

  symmetric_reflect_12
  ! Makes the matrix formed by the 1st and 2nd columns symmetrical.
    INT :: dim1,dim2,i,j
    dim1 = size(self,1)
    dim2 = size(self,2)
    DIE_IF(dim1/=dim2,"non-square matrix")
    do i = 1,dim1
    do j = 1,i-1
      self(j,i,:) = self(i,j,:)
    end
    end
  end

  symmetric_reflect_23
  ! Makes the matrix formed by the 2nd and 3rd columns symmetrical.
    INT :: dim,i,j
    .check_square_23
    dim = size(self,2)
    do i = 1,dim
    do j = 1,i-1
      self(:,j,i) = self(:,i,j)
    end
    end
  end

  to_tri_23(tr)
  ! Converts the matrix self to the lower triangle tr.
  ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
    IN :: self
    TRI :: tr
    INT :: dim1,dim2,h,i,j,ij,ltr
    dim1 = size(self,1)
    dim2 = size(self,2)
    .check_square_23
    ltr = dim1*dim2*(dim2+1)/2
    DIE_IF(size(tr)<ltr,"triangle array too small")
    ij = 0
    do h = 1,dim1
      do i = 1,dim2
        do j = 1,i
          ij = ij+1
          tr(ij) = self(h,j,i)
        end
      end
    end
  end

  from_tri_23(tr)
  ! Converts the matrix self to the lower triangle tr.
  ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
    TRI, IN :: tr
    INT :: dim1,dim2,h,i,j,ij,ltr
    dim1 = size(self,1)
    dim2 = size(self,2)
    .check_square_23
    ltr = dim1*dim2*(dim2+1)/2
    DIE_IF(size(tr)<ltr,"triangle array too small")
    ij = 0
    do h = 1,dim1
      do i = 1,dim2
        do j = 1,i
          ij = ij+1
          self(h,j,i) = tr(ij)
          self(h,i,j) = tr(ij)
        end
      end
    end
  end

  tri_size_23 result (ltr)
  ! Returns the size of the lower triangle needed to store the matrix self.
  ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
    IN :: self
    INT :: dim1,dim2,ltr
    dim1 = size(self,1)
    dim2 = size(self,2)
    .check_square_23
    ltr = dim1*dim2*(dim2+1)/2
  end

  check_square_23
  ! Checks to see that the matrix formed by the 2nd and 3rd columns is square.
    INT :: dim2,dim3
    dim2 = size(self,2)
    dim3 = size(self,3)
    DIE_IF(dim2/=dim3,"non-square matrix")
  end

end
