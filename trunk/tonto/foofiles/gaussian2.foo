!---------------------------------------------------------------------------
!
!  GAUSSIAN2 : Pairs of gaussian functions
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module GAUSSIAN2

   implicit none

   pi212 :: REAL, private  = 1.1283791670955d+0

!  The i-th point and weight for n-point Gauss-Hermite quadrature

   first_pt :: VEC{INT}(9), private = [ 1,2,4, 7,11,16,22,29,37 ]
   last_pt  :: VEC{INT}(9), private = [ 1,3,6,10,15,21,28,36,45 ]

   gauss_hermite_pt :: VEC{REAL}(45), private

   data gauss_hermite_pt/                                                                      &
       0.000000000000000e+0,                                                                   & ! H_11
      -0.707106781186548e+0, 0.707106781186548e+0,                                             & ! H_12 H_22
      -1.224744871391590e+0, 0.000000000000000e+0, 1.224744871391590e+0,                       & ! H_13 H_23 H_33
      -1.650680123885780e+0,-0.524647623275290e+0, 0.524647623275290e+0, 1.650680123885780e+0, & ! H_*4
      -2.020182870456090e+0,-0.958572464613819e+0, 0.000000000000000e+0, 0.958572464613819e+0, & ! H_*5
       2.020182870456090e+0,                                                                   &
      -2.350604973674000e+0,-1.335849074014000e+0,-0.436077411928000e+0, 0.436077411928000e+0, & ! H_*6
       1.335849074014000e+0, 2.350604973674000e+0,                                             &
      -2.651961356835233e+0,-1.673551628767471e+0,-0.816287882858965e+0, 0.000000000000000e+0, & ! H_*7
       0.816287882858965e+0, 1.673551628767471e+0, 2.651961356835233e+0,                       &
      -2.930637420257244e+0,-1.981656756695843e+0,-1.157193712446780e+0,-0.381186990207322e+0, & ! H_*8
       0.381186990207322e+0, 1.157193712446780e+0, 1.981656756695843e+0, 2.930637420257244e+0, &
      -3.190993201781528e+0,-2.266580584531843e+0,-1.468553289216668e+0,-0.723551018752838e+0, & ! H_*9
       0.000000000000000e+0, 0.723551018752838e+0, 1.468553289216668e+0, 2.266580584531843e+0, &
       3.190993201781528e+0/

   gauss_hermite_wt :: VEC{REAL}(45), private

   data gauss_hermite_wt/                                                                      &
       1.772453850905520e+0,                                                                   & ! W_11
       0.886226925452800e+0, 0.886226925452800e+0,                                             & ! W_12 W_22
       0.295408975150900e+0, 1.181635900604000e+0, 0.295408975150900e+0,                       & ! W_13 W_23 W_33
       8.131283544725000e-2, 8.049140900055000e-1, 8.049140900055000e-1, 8.131283544725000e-2, & ! W_*4
       1.995324205905000e-2, 3.936193231522000e-1, 9.453087204829000e-1, 3.936193231522000e-1, & ! W_*5
       1.995324205905000e-2,                                                                   &
       4.530009905509000e-3, 1.570673203229000e-1, 7.246295952244000e-1, 7.246295952244000e-1, & ! W_*6
       1.570673203229000e-1, 4.530009905509000e-3,                                             &
       9.717812450995000e-4, 5.451558281913000e-2, 4.256072526101000e-1, 8.102646175568000e-1, & ! W_*7
       4.256072526101000e-1, 5.451558281913000e-2, 9.717812450995000e-4,                       &
       1.996040722114000e-4, 1.707798300741000e-2, 2.078023258149000e-1, 6.611470125582000e-1, & ! W_*8
       6.611470125582000e-1, 2.078023258149000e-1, 1.707798300741000e-2, 1.996040722114000e-4, &
       3.960697726326000e-5, 4.943624275537000e-3, 8.847452739438000e-2, 4.326515590026000e-1, & ! W_*9
       7.202352156061000e-1, 4.326515590026000e-1, 8.847452739438000e-2, 4.943624275537000e-3, &
       3.960697726326000e-5/

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object. This does not nullify point parts or set
   ! defaults.
   end

   create(Ga,Gb) ::: leaky
   ! Create a gaussian pair, and optionally set it to "Ga" and "Gb"
      self :: PTR
      Ga,Gb :: GAUSSIAN
      .create
      .set(Ga,Gb)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object. This version does not destroy pointer parts.
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(G) ::: leaky
   ! Create a copy of "G"
      self :: PTR
       G :: GAUSSIAN2
      .create
      .copy(G)
   end

   copy(G)
   ! Set the gaussian pair object to "G"
      G :: GAUSSIAN2
      self = G
   end

   set(Ga,Gb)
   ! Set the gaissian pair object to "Ga" and "Gb"
      Ga,Gb :: GAUSSIAN
      .a.set(Ga)
      .b.set(Gb)
   end

   set(l_a,pos_a,ex_a,l_b,pos_b,ex_b)
   ! Set a gaussian object
      l_a,l_b :: INT
      pos_a,pos_b :: VEC{REAL}(3)
      ex_a,ex_b :: REAL
      .a.set_l(l_a)
      .a.set_pos(pos_a)
      .a.set_ex(ex_a)
      .b.set_l(l_b)
      .b.set_pos(pos_b)
      .b.set_ex(ex_b)
   end

   set(ex_a,ex_b)
   ! Set the exponents of the pair
      ex_a,ex_b :: REAL, optional
      if (present(ex_a)) .a.set_ex(ex_a)
      if (present(ex_b)) .b.set_ex(ex_b)
   end

   make_e_coeff(e,comp) 
   ! Return the McMurchie-Davidson "e" coefficients for component "comp"
   ! (c) dylan jayatilaka, april 1995
   ! Checked using mathematica, may 1995
      e :: MAT3{REAL}(0:,0:,0:), OUT 
      comp :: INT, IN

      t,a,b,ap,am,bp,bm,abp,ab,abm,max,l_a,l_b :: INT
      R,gamma,g1,g2,a1,b1,e000 :: REAL

      l_a = .a.l
      l_b = .b.l
      max = l_a+l_b

      R = .a.pos(comp) - .b.pos(comp)

      gamma = .a.ex + .b.ex
      g1 = ONE/gamma
      b1 = .b.ex*g1*R

      e000 = exp(-.a.ex*b1*R)
      e(0,0,0) = e000

      ! Return for e000
      if (max==0) return               

      g2 = HALF*g1
      a1 = .a.ex*g1*R
      if (l_a>=1) then
         e(1,1,0) =  g2*e000
         e(0,1,0) = -b1*e000
      end
      if (l_b>=1) then
         e(1,0,1) =  g2*e000
         e(0,0,1) =  a1*e000
      end

      ! Return for eXX1
      if (max==1) return               

      ! Consider case b=0
      do a = 1,l_a-1                   
         ap = a + 1
         am = a - 1
         e(ap,ap,0) =  g2*e( a,a,0)
         e( a,ap,0) =  g2*e(am,a,0) - b1*e(a,a,0)
         e( 0,ap,0) = -b1*e( 0,a,0) +    e(1,a,0)
         do t = 1,am
            e(t,ap,0) = g2*e(t-1,a,0) - b1*e(t,a,0) + (t+1)*e(t+1,a,0)
         end
      end

      ! Consider case a=0
      do b = 1,l_b-1                   
         bp = b + 1
         bm = b - 1
         e(bp,0,bp) =  g2*e( b,0,b)
         e( b,0,bp) =  g2*e(bm,0,b) + a1*e(b,0,b)
         e( 0,0,bp) =  a1*e( 0,0,b) +    e(1,0,b)
         do t = 1,bm
            e(t,0,bp) = g2*e(t-1,0,b) + a1*e(t,0,b) + (t+1)*e(t+1,0,b)
         end
      end

      ! Now do the rest, a/=0 & b/=0
      do b = 1,l_b                     
         do a = 0,l_a-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e(abp,ap,b) =  g2*e( ab,a,b)
            e( ab,ap,b) =  g2*e(abm,a,b) - b1*e(ab,a,b)
            e(  0,ap,b) = -b1*e(  0,a,b) +    e( 1,a,b)
            do t = 1,abm
               e(t,ap,b) = g2*e(t-1,a,b) - b1*e(t,a,b) + (t+1)*e(t+1,a,b)
            end
         end
      end

   end

   make_e_coeff_derivative(e1,comp,e0) ::: pure, private
   ! Return the derivative McMurchie-Davidson "e1" coefficients for
   ! component "comp" with repect to R = .a.pos - .b.pos. The zero order
   ! derivative E coefficients "e0" for the same component must be supplied.
   ! This routine is based on Helgaker & Taylor, TCA 83, p. 177 (1992)
   ! (c) dylan jayatilaka, may 1998
      self :: IN
      comp :: INT, IN
      e0 :: MAT3{REAL}(0:,0:,0:), IN
      e1 :: MAT3{REAL}(0:,0:,0:), OUT ! Generic e coefficient table
      t,a,b,ap,am,bp,bm,abp,ab,abm,max :: INT
      R,gamma,g1,g2,a0,a1,b0,b1,e0000,e1000 :: REAL
      max = .a.l+.b.l
      R = .a.pos(comp)-.b.pos(comp)
      gamma = .a.ex + .b.ex
      g1 = 1/gamma
      b0 = .b.ex*g1
      b1 = b0*R
      e0000  = e0(0,0,0)
      e1000 = -2*.a.ex*b1*e0000
      e1(0,0,0) = e1000
      if (max==0) return                ! Return for e000
      a0 = .a.ex*g1
      a1 = a0*R
      g2 = HALF*g1
      if (.a.l>=1) then
         e1(1,1,0) =  g2*e1000
         e1(0,1,0) = -b1*e1000 - b0*e0000
      end
      if (.b.l>=1) then
         e1(1,0,1) =  g2*e1000
         e1(0,0,1) =  a1*e1000 + a0*e0000
      end
      if (max==1) return                ! Return for eXX1
      do a = 1,.a.l-1                   ! Consider case b=0
         ap = a + 1
         am = a - 1
         e1(ap,ap,0) =  g2*e1( a,a,0)
         e1( a,ap,0) =  g2*e1(am,a,0) - b1*e1(a,a,0) - b0*e0(a,a,0)
         e1( 0,ap,0) = -b1*e1( 0,a,0) - b0*e0(0,a,0) +    e1(1,a,0)
         do t = 1,am
            e1(t,ap,0) = g2*e1(t-1,a,0) - b1*e1(t,a,0) - b0*e0(t,a,0) + (t+1)*e1(t+1,a,0)
         end
      end
      do b = 1,.b.l-1                   ! Consider case a=0
         bp = b + 1
         bm = b - 1
         e1(bp,0,bp) =  g2*e1( b,0,b)
         e1( b,0,bp) =  g2*e1(bm,0,b) + a1*e1(b,0,b) + a0*e0(b,0,b)
         e1( 0,0,bp) =  a1*e1( 0,0,b) + a0*e0(0,0,b) +    e1(1,0,b)
         do t = 1,bm
            e1(t,0,bp) = g2*e1(t-1,0,b) + a1*e1(t,0,b) + a0*e0(t,0,b) + (t+1)*e1(t+1,0,b)
         end
      end
      do b = 1,.b.l                     ! Now do the rest, a/=0 & b/=0
         do a = 0,.a.l-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e1(abp,ap,b) =  g2*e1( ab,a,b)
            e1( ab,ap,b) =  g2*e1(abm,a,b) - b1*e1(ab,a,b) - b0*e0(ab,a,b)
            e1(  0,ap,b) = -b1*e1(  0,a,b) - b0*e0( 0,a,b) +    e1( 1,a,b)
            do t = 1,abm
               e1(t,ap,b) = g2*e1(t-1,a,b) - b1*e1(t,a,b) - b0*e0(t,a,b) + (t+1)*e1(t+1,a,b)
            end
         end
      end
   end

!   make_ft_component_old(res,comp,k_pts)
!   ! Do the Fourier transform of component "comp" of the guassian pair
!   ! evaluated at the points "k_pts"
!      self :: IN
!      res :: MAT3{CPX}(1:,0:,0:), OUT
!      comp :: INT, IN
!      k_pts :: VEC{REAL}, IN
!
!      kn,kn_t :: REAL
!      a,b,t,t_max,k_max,n :: INT
!      e :: MAT3{REAL}*
!      val1,val2,k2 :: VEC{REAL}*   
!      k1 :: MAT{REAL}*
!
!      k_max = k_pts.dim
!      t_max = .a.l+.b.l
!
!      ! Make the E coefficients
!      e.create([0,t_max],[0,.a.l],[0,.b.l])
!      .make_e_coeff(e,comp)
!
!      select case (t_max)
!        case (0)
!          res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!        case (1)
!          if (.a.l==1) then ! ps
!            res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!            res(:,1,0) = cmplx(e(0,1,0),e(1,1,0)*k_pts(:),kind=CPX_KIND)
!          else !              sp
!            res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!            res(:,0,1) = cmplx(e(0,0,1),e(1,0,1)*k_pts(:),kind=CPX_KIND)
!          end
!        case (2)
!          select case (.a.l)
!            case (0) ! sd
!              res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!              res(:,0,1) = cmplx(e(0,0,1),e(1,0,1)*k_pts(:),kind=CPX_KIND)
!              res(:,0,2) = cmplx(e(0,0,2)-e(2,0,2)*k_pts(:)*k_pts(:),e(1,0,2)*k_pts(:),kind=CPX_KIND)
!            case (1) ! pp
!              res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!              res(:,0,1) = cmplx(e(0,0,1),e(1,0,1)*k_pts(:),kind=CPX_KIND)
!              res(:,1,0) = cmplx(e(0,1,0),e(1,1,0)*k_pts(:),kind=CPX_KIND)
!              res(:,1,1) = cmplx(e(0,1,1)-e(2,1,1)*k_pts(:)*k_pts(:),e(1,1,1)*k_pts(:),kind=CPX_KIND)
!            case (2) ! ds
!              res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!              res(:,1,0) = cmplx(e(0,1,0),e(1,1,0)*k_pts(:),kind=CPX_KIND)
!              res(:,2,0) = cmplx(e(0,2,0)-e(2,2,0)*k_pts(:)*k_pts(:),e(1,2,0)*k_pts(:),kind=CPX_KIND)
!          end
!        case (3)
!          select case (.a.l)
!            case (0) ! sf
!              k2.create(k_max)
!              k2(:) = k_pts(:)*k_pts(:)
!              res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!              res(:,0,1) = cmplx(e(0,0,1),e(1,0,1)*k_pts(:),kind=CPX_KIND)
!              res(:,0,2) = cmplx(e(0,0,2)-e(2,0,2)*k2(:),e(1,0,2)*k_pts(:),kind=CPX_KIND)
!              res(:,0,3) = cmplx(e(0,0,3)-e(2,0,3)*k2(:),(e(1,0,3)-e(3,0,3)*k2(:))*k_pts(:),kind=CPX_KIND)
!              k2.destroy
!            case (1) ! pd
!              k2.create(k_max)
!              k2(:) = k_pts(:)*k_pts(:)
!              res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!              res(:,0,1) = cmplx(e(0,0,1),e(1,0,1)*k_pts(:),kind=CPX_KIND)
!              res(:,1,0) = cmplx(e(0,1,0),e(1,1,0)*k_pts(:),kind=CPX_KIND)
!              res(:,0,2) = cmplx(e(0,0,2)-e(2,0,2)*k2(:),e(1,0,2)*k_pts(:),kind=CPX_KIND)
!              res(:,1,1) = cmplx(e(0,1,1)-e(2,1,1)*k2(:),e(1,1,1)*k_pts(:),kind=CPX_KIND)
!              res(:,1,2) = cmplx(e(0,1,2)-e(2,1,2)*k2(:),(e(1,1,2)-e(3,1,2)*k2(:))*k_pts(:),kind=CPX_KIND)
!              k2.destroy
!            case (2) ! dp
!              k2.create(k_max)
!              k2(:) = k_pts(:)*k_pts(:)
!              res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!              res(:,0,1) = cmplx(e(0,0,1),e(1,0,1)*k_pts(:),kind=CPX_KIND)
!              res(:,1,0) = cmplx(e(0,1,0),e(1,1,0)*k_pts(:),kind=CPX_KIND)
!              res(:,1,1) = cmplx(e(0,1,1)-e(2,1,1)*k2(:),e(1,1,1)*k_pts(:),kind=CPX_KIND)
!              res(:,2,0) = cmplx(e(0,2,0)-e(2,2,0)*k2(:),e(1,2,0)*k_pts(:),kind=CPX_KIND)
!              res(:,2,1) = cmplx(e(0,2,1)-e(2,2,1)*k2(:),(e(1,2,1)-e(3,2,1)*k2(:))*k_pts(:),kind=CPX_KIND)
!              k2.destroy
!            case (3) ! fs
!              k2.create(k_max)
!              k2(:) = k_pts(:)*k_pts(:)
!              res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!              res(:,1,0) = cmplx(e(0,1,0),e(1,1,0)*k_pts(:),kind=CPX_KIND)
!              res(:,2,0) = cmplx(e(0,2,0)-e(2,2,0)*k2(:),e(1,2,0)*k_pts(:),kind=CPX_KIND)
!              res(:,3,0) = cmplx(e(0,3,0)-e(2,3,0)*k2(:),(e(1,3,0)-e(3,3,0)*k2(:))*k_pts(:),kind=CPX_KIND)
!              k2.destroy
!          end
!        case default                            ! general routine
!          k1.create([1,k_max],[0,t_max])    ! Define k1 array containing
!          do n = 1,k_max                        ! powers k^n of k_pts
!            kn = k_pts(n)
!            kn_t = kn          ! t=0 is 1, has been optimised out below.
!            do t = 2,t_max     ! t=1 is k_pts(n), explicity written below.
!              kn_t = kn_t * kn
!              k1(n,t) = kn_t
!            end
!          end
!          val1.create(k_max)   ! val1 is real part
!          val2.create(k_max)   ! val2 is imaginary part
!          do a = 0,.a.l
!            do b = 0,.b.l
!              t_max = a+b
!              select case (t_max)
!                case (0)
!                  res(:,0,0) = cmplx(e(0,0,0),ZERO,kind=CPX_KIND)
!                case (1)
!                  res(:,a,b) = cmplx(e(0,a,b),e(1,a,b)*k_pts(:),kind=CPX_KIND)
!                case (2)
!                  val1(:) = e(0,a,b) - e(2,a,b)*k1(:,2)
!                  val2(:) = e(1,a,b)*k_pts(:)
!                  res(:,a,b) = cmplx(val1(:),val2(:),kind=CPX_KIND)
!                case default
!                  val1(:) = e(0,a,b)          - e(2,a,b)*k1(:,2)
!                  val2(:) = e(1,a,b)*k_pts(:) - e(3,a,b)*k1(:,3)
!                  do t = 3,t_max-3,4
!                    val1(:) = val1(:) + e(t,a,b)  *k1(:,t)  - e(t+2,a,b)*k1(:,t+2)
!                    val2(:) = val2(:) + e(t+1,a,b)*k1(:,t+1)- e(t+3,a,b)*k1(:,t+3)
!                  end
!                  select case (mod(t_max+1,4))
!                    case (0)
!                    case (1)
!                      val1(:) = val1(:) + e(t_max,a,b)*k1(:,t_max)
!                    case (2)
!                      val1(:) = val1(:) + e(t_max-1,a,b)*k1(:,t_max-1)
!                      val2(:) = val2(:) + e(t_max,a,b)  *k1(:,t_max)
!                    case (3)
!                      val1(:) = val1(:) + e(t_max-2,a,b)*k1(:,t_max-2) - &
!                                          e(t_max,a,b)  *k1(:,t_max)
!                      val2(:) = val2(:) + e(t_max-1,a,b)*k1(:,t_max-1)
!                  end
!                  res(:,a,b) = cmplx(val1(:),val2(:),kind=CPX_KIND)
!              end
!            end
!          end
!          val2.destroy
!          val1.destroy
!          k1.destroy
!      end
!      e.destroy
!   end

   make_ft_component(res,comp,k_pts)
   ! Do the Fourier transform of component "comp" of the gaussian pair
   ! evaluated at the points "k_pts", without the prefactors.
      res :: MAT3{CPX}(1:,0:,0:), OUT
      comp  :: INT, IN
      k_pts :: VEC{REAL}, IN

      e  :: MAT3{REAL}*
      kp :: MAT{REAL}*
      vr,vi :: VEC{REAL}*   
      a,b,t,k_max,t_max :: INT

      k_max = k_pts.dim
      t_max = .a.l+.b.l

      ! Make the E coefficients
      e.create([0,t_max],[0,.a.l],[0,.b.l])
      .make_e_coeff(e,comp)

      ! Define kp array containing powers k_pts(n)^t
      nullify(kp)
      if (t_max>0) then
         kp.create([1,k_max],[1,t_max])    
         kp(:,1) = k_pts
         do t = 2,t_max 
            kp(:,t) = kp(:,t-1)*k_pts
         end
         do t = 2,t_max 
            if (mod(t,4)<=1) cycle
            kp(:,t) = -kp(:,t)
         end
      end

      ! Real, imaginary parts of answer: (vr,vi)
      vr.create(k_max)   
      vi.create(k_max)   

      do a = 0,.a.l
      do b = 0,.b.l

         t_max = a + b

         ! Real part
         vr = e(0,a,b)
         do t = 2,t_max,2
            vr = vr + e(t,a,b)*kp(:,t)
         end

         ! Imaginary part
         vi = ZERO
         do t = 1,t_max,2
            vi = vi + e(t,a,b)*kp(:,t)
         end

         res(:,a,b) = cmplx(vr,vi,kind=CPX_KIND)

      end
      end

      vi.destroy; vr.destroy
      kp.destroy; e.destroy
   end

   make_ft_dab_component(res,comp,k_pts,k_max) ::: private
   ! Do the Fourier transform of the derivative of component a minus b
   ! of a a pair of gaussians, for component "comp" of the guassian
   ! product pair, evaliated for the points "k_pts".
   ! Dimensions of res are [[1,size(k_pts)],[0,.a.l],[0,.b.l]].
      self :: IN
      comp,k_max :: INT, IN
      k_pts :: VEC{REAL}, IN
      res :: MAT3{CPX}(1:,0:,0:)
      kn,fac :: REAL
      a,b,t,t_max,n :: INT
      e0,e1 :: MAT3{REAL}*
      val :: VEC{REAL}*                      ! Local variables
      k1 :: MAT{REAL}*
      t_max = .a.l+.b.l
      k1.create([1,k_max],[0,t_max+1]) ! Define k1 array containing
      do n = 1,k_max                       ! powers k^n of k_pts
         k1(n,0) = ONE
         kn = k_pts(n)
         do t = 1,t_max+1
            k1(n,t) = k1(n,t-1)*kn
         end
      end
      val.create(k_max)       ! Now evaluate; use real arithmetic where possible
      e0.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(e0,comp)
      e1.create([0, .a.l+.b.l ],[0, .a.l ],[0, .b.l ])
      .make_e_coeff_derivative(e1,comp,e0)
      do a = 0,.a.l
         do b = 0,.b.l
            t_max = a+b
            val = ZERO                         ! Do the real part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            val = TWO*val
            res(:,a,b) = cmplx(val(:),ZERO,kind=CPX_KIND)
            val = ZERO                         ! Now do imaginary part ...
            do t = 1,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 3,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            val = TWO*val
            res(:,a,b) = res(:,a,b) + cmplx(ZERO,val(:),kind=CPX_KIND)
         end
      end
      fac = (.a.ex-.b.ex)/(.a.ex+.b.ex)
      do a = 0,.a.l
         do b = 0,.b.l
            t_max = a+b
            val = ZERO                         ! Do the imaginary part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            val = fac*val
            res(:,a,b) = res(:,a,b) + cmplx(ZERO,val(:),kind=CPX_KIND)
            val = ZERO                         ! Now do real part ...
            do t = 1,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            do t = 3,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            val = fac*val
            res(:,a,b) = res(:,a,b) + cmplx(val(:),ZERO,kind=CPX_KIND)
         end
      end
      e1.destroy
      e0.destroy
      val.destroy
      k1.destroy
   end

   make_ft_da_db_component(da,db,comp,k_pts) ::: private
   ! Do the Fourier transform of the derivative w.r.t. the position of component
   ! a, "da", and the derivative w.r.t. the position of component b, "db", of
   ! the gaussian pair, for component "comp" (either x, y, z), evaluated for the
   ! points "k_pts".  Dimensions of "da", "db" are ([1,size(k_pts)],[0,.a.l],[0,.b.l]).
      self :: IN
      da,db :: MAT3{CPX}(1:,0:,0:)
      comp :: INT, IN
      k_pts :: VEC{REAL}, IN
      kn,fac_a,fac_b :: REAL
      a,b,t,t_max,k_max,n :: INT
      e0,e1 :: MAT3{REAL}*
      val :: VEC{REAL}*                      ! Local variables
      k1 :: MAT{REAL}*
      t_max = .a.l+.b.l
      k_max = da.dim1
      k1.create([1,k_max],[0,t_max+1]) ! Define k1 array containing
      do n = 1,k_max                       ! powers k^n of k_pts
         k1(n,0) = ONE
         kn = k_pts(n)
         do t = 1,t_max+1
            k1(n,t) = k1(n,t-1)*kn
         end
      end
      val.create(k_max)       ! Now evaluate; use real arithmetic where possible
      e0.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(e0,comp)
      e1.create([0, .a.l+.b.l ],[0, .a.l ],[0, .b.l ])
      .make_e_coeff_derivative(e1,comp,e0)
      do a = 0,.a.l
         do b = 0,.b.l
            t_max = a+b
            val = ZERO                         ! Do the real part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            da(:,a,b) =  cmplx(val(:),ZERO,kind=CPX_KIND)
            val = ZERO                         ! Now do imaginary part ...
            do t = 1,t_max,4
               val(:) = val(:) + e1(t,a,b)*k1(:,t)
            end
            do t = 3,t_max,4
               val(:) = val(:) - e1(t,a,b)*k1(:,t)
            end
            da(:,a,b) =  da(:,a,b) + cmplx(ZERO,val(:),kind=CPX_KIND)
            db(:,a,b) = -da(:,a,b)
         end
      end
      fac_a = .a.ex/(.a.ex+.b.ex)
      fac_b = .b.ex/(.a.ex+.b.ex)
      do a = 0,.a.l
         do b = 0,.b.l
            t_max = a+b
            val = ZERO                         ! Do the imaginary part first ...
            do t = 0,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            do t = 2,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            da(:,a,b) = da(:,a,b) + fac_a*cmplx(ZERO,val(:),kind=CPX_KIND)
            db(:,a,b) = db(:,a,b) + fac_b*cmplx(ZERO,val(:),kind=CPX_KIND)
            val = ZERO                         ! Now do real part ...
            do t = 1,t_max,4
               val(:) = val(:) - e0(t,a,b)*k1(:,t+1)
            end
            do t = 3,t_max,4
               val(:) = val(:) + e0(t,a,b)*k1(:,t+1)
            end
            da(:,a,b) = da(:,a,b) + fac_a*cmplx(val(:),ZERO,kind=CPX_KIND)
            db(:,a,b) = db(:,a,b) + fac_b*cmplx(val(:),ZERO,kind=CPX_KIND)
         end
      end
      e1.destroy
      e0.destroy
      val.destroy
      k1.destroy
   end

   make_ft_dab(res,ft)
   ! Form the Fourier transform of the derivative of the product
   ! of two gaussians w.r.t. coordinates in shell b, from the zeroth
   ! derivative Fourier transform.  Dimensions of res are
   ! [[1,size(k_pts)],[0,l_a],[0,l_b]].
      self :: IN
      ft :: MAT3{CPX}(1:,0:,0:), IN
      res :: MAT3{CPX}(1:,0:,0:)
      a,b,l_a,l_b :: INT
      l_a = ubound(ft,2)-1
      l_b = ubound(ft,3)-1
      res = ZERO
      do a = 0,l_a
         do b = 0,l_b
            res(:,a,b) = res(:,a,b) - TWO*.b.ex*ft(:,a,b+1)
            res(:,a,b) = res(:,a,b) + TWO*.a.ex*ft(:,a+1,b)
            if (b>0) res(:,a,b) = res(:,a,b) + b*ft(:,a,b-1)
            if (a>0) res(:,a,b) = res(:,a,b) - a*ft(:,a-1,b)
         end
      end
   end

   make_ft(ft,k_pts)
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      ft :: MAT3{CPX}, OUT
      k_pts :: MAT{REAL}, IN
   ENSURE(ft.dim1==k_pts.dim1,"inconsistent first dimension")
   ENSURE(k_pts.dim2==3,"second dimension of k_pts must be 3")
      select case (.a.l+.b.l)
       case (0);      .make_ft_00(ft(:,1,1),k_pts)
       case default;  .make_ft_XX(ft,k_pts)
      end
   end

   make_ft_00(ft,k_pts) 
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! Specialised routine for .a.l=0 and .b.l=0.
      ft :: VEC{CPX}, OUT
      k_pts :: MAT{REAL}, target
      
      pos :: VEC{REAL}(3)
      k_x,k_y,k_z :: VEC{REAL}*
      g1_exa,g1_exb,e00,fac :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      k :: INT
      I :: CPX
 
      ! Constants
      I = cmplx(ZERO,ONE,kind=CPX_KIND)
      gamma = .a.ex+.b.ex
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma
 
      ! Gaussian pair center
      g1_exa = g1*.a.ex
      g1_exb = g1*.b.ex
      P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
      P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
      P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
 
      ! Reciprocal lattice K points
      k_x => k_pts(:,1)
      k_y => k_pts(:,2)
      k_z => k_pts(:,3)
 
      ! E coefficient
      pos = .a.pos - .b.pos
      e00 = exp(-.a.ex*.b.ex*dot_product(pos,pos)/gamma)
      pifac = pifac*e00

      ! Do the Fourier transform
      do k = 1,k_x.dim
         k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
         ft(k) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
      end

   end

   make_ft_XX(ft,k_pts) 
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      self :: IN
      ft :: MAT3{CPX}
      k_pts :: MAT{REAL}, target
      ft_x,ft_y,ft_z :: MAT3{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      prefac,ft_xb,ft_yb,ft_zb :: VEC{CPX}*
      ft_xbx,ft_yby,ft_zbz :: MAT{CPX}*
      k_x,k_y,k_z :: VEC{REAL}*
      g1_exa,g1_exb :: REAL
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      k_max,a,b,k,xa,ya,za,xb,yb,zb,bxlast,bylast,bzlast,fa,la,fb,lb :: INT
      k_max = k_pts.dim1
      ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
      prefac.create(k_max)
      gamma = .a.ex+.b.ex
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma
      g1_exa = g1*.a.ex
      g1_exb = g1*.b.ex
      P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
      P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
      P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
      k_x => k_pts(:,1)
      k_y => k_pts(:,2)
      k_z => k_pts(:,3)
      .make_ft_component(ft_x,1,k_x)        ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_y)        ! of each component.
      .make_ft_component(ft_z,3,k_z)
      do k = 1,k_max
        k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
        dot1 = k1*P1+k2*P2+k3*P3
        dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
        prefac(k) = pifac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
      end
      select case (.a.l)
        case (0)
          select case(.b.l)
            case (0)
              ft(:,1,1) = ft_x(:,0,0)*ft_y(:,0,0)*ft_z(:,0,0)*prefac(:)
            case (1)
              ft(:,1,1) = ft_x(:,0,1)*ft_y(:,0,0)*ft_z(:,0,0)*prefac(:)
              ft(:,1,2) = ft_x(:,0,0)*ft_y(:,0,1)*ft_z(:,0,0)*prefac(:)
              ft(:,1,3) = ft_x(:,0,0)*ft_y(:,0,0)*ft_z(:,0,1)*prefac(:)
            case default
              do b = 0,.b.l ! incorporate prefac into ft_z
                ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
              end
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              bxlast = bx(1)
              bylast = by(1)
              bzlast = bz(1)
              ft_xb => ft_x(:,0,bxlast)
              ft_yb => ft_y(:,0,bylast)
              ft_zb => ft_z(:,0,bzlast)
              do b = 1,.b.n_comp    ! Loop over all elements and multiply prefactor
                xb = bx(b)
                yb = by(b)
                zb = bz(b)
                if (bxlast/=xb) then
                  ft_xb => ft_x(:,0,xb)
                  bxlast = xb
                end
                if (bylast/=yb) then
                  ft_yb=> ft_y(:,0,yb)
                  bylast = yb
                end
                if (bzlast/=zb) then
                  ft_zb=> ft_z(:,0,zb)
                  bzlast = zb
                end
                ft(:,1,b) = ft_xb(:)*ft_yb(:)*ft_zb(:)
              end
          end
        case (1)
          select case (.b.l)
            case (0)
              ft(:,1,1) = ft_x(:,1,0)*ft_y(:,0,0)*ft_z(:,0,0)*prefac(:)
              ft(:,2,1) = ft_x(:,0,0)*ft_y(:,1,0)*ft_z(:,0,0)*prefac(:)
              ft(:,3,1) = ft_x(:,0,0)*ft_y(:,0,0)*ft_z(:,1,0)*prefac(:)
            case (1)
              ft_z(:,0,0) = ft_z(:,0,0) * prefac(:)
              ft(:,1,1) = ft_x(:,1,1)*ft_y(:,0,0)*ft_z(:,0,0)
              ft(:,2,1) = ft_x(:,0,1)*ft_y(:,1,0)*ft_z(:,0,0)
              ft(:,3,1) = ft_x(:,0,1)*ft_y(:,0,0)*ft_z(:,1,0)*prefac(:)
              ft(:,1,2) = ft_x(:,1,0)*ft_y(:,0,1)*ft_z(:,0,0)
              ft(:,2,2) = ft_x(:,0,0)*ft_y(:,1,1)*ft_z(:,0,0)
              ! don't change the order.
              ft_x(:,0,0) = ft_x(:,0,0) * prefac(:)
              ft(:,3,2) = ft_x(:,0,0)*ft_y(:,0,1)*ft_z(:,1,0)
              ft(:,1,3) = ft_x(:,1,0)*ft_y(:,0,0)*ft_z(:,0,1)*prefac(:)
              ft(:,2,3) = ft_x(:,0,0)*ft_y(:,1,0)*ft_z(:,0,1)
              ft(:,3,3) = ft_x(:,0,0)*ft_y(:,0,0)*ft_z(:,1,1)
            case default
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              do b = 0,.b.l
                ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
              end
              do b = 1,.b.n_comp    ! Loop over all elements and multiply prefactor
                xb = bx(b)
                yb = by(b)
                zb = bz(b)
                ft_xb => ft_x(:,0,xb)
                ft_yb => ft_y(:,0,yb)
                ft_zb => ft_z(:,0,zb)
                ft(:,1,b) = ft_x(:,1,xb)*ft_yb        *ft_zb
                ft(:,2,b) = ft_xb        *ft_y(:,1,yb)*ft_zb
                ft(:,3,b) = ft_xb        *ft_yb        *ft_z(:,1,zb) * prefac(:)
              end
          end
        case default
          select case (.b.l)
            case (0)
              do a = 0,.a.l
                ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
              end
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              do a = 1,.a.n_comp
                xa = ax(a)
                ya = ay(a)
                za = az(a)
                ft(:,a,1) = ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,0)
              end
            case (1)
              do a = 0,.a.l ! incorporate prefac into ft_z
                ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                ft_z(:,a,1) = ft_z(:,a,1) * prefac(:)
              end
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              do a = 1,.a.n_comp
                xa = ax(a)
                ya = ay(a)
                za = az(a)
                ft(:,a,1) = ft_x(:,xa,1)*ft_y(:,ya,0)*ft_z(:,za,0)
                ft(:,a,2) = ft_x(:,xa,0)*ft_y(:,ya,1)*ft_z(:,za,0)
                ft(:,a,3) = ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,1)
              end
            case default
    ! This is the general routine.  It includes reduced multiplication, and use
    ! of pointers to minimise array finding.
              do b = 0,.b.l ! incorporate prefac into ft_z
              do a = 0,.a.l
                 ft_z(:,a,b) = ft_z(:,a,b) * prefac(:)
              end
              end
              fa = .a.first_gaussian; la = .a.last_gaussian
              fb = .b.first_gaussian; lb = .b.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              bxlast = bx(1)
              bylast = by(1)
              bzlast = bz(1)
              ft_xbx => ft_x(:,:,bxlast)
              ft_yby => ft_y(:,:,bylast)
              ft_zbz => ft_z(:,:,bzlast)
              do b = 1,.b.n_comp    ! Loop over all elements and multiply prefactor
                xb = bx(b)
                yb = by(b)
                zb = bz(b)
                if (bxlast/=xb) then
                  ft_xbx => ft_x(:,:,xb)
                  bxlast = xb
                end
                if (bylast/=yb) then
                  ft_yby=> ft_y(:,:,yb)
                  bylast = yb
                end
                if (bzlast/=zb) then
                  ft_zbz=> ft_z(:,:,zb)
                  bzlast = zb
                end
                do a = 1,.a.n_comp
                  xa = ax(a)
                  ya = ay(a)
                  za = az(a)
                  ft(:,a,b) = ft_xbx(:,xa+1)*ft_yby(:,ya+1)*ft_zbz(:,za+1)
                end
              end
          end
      end
      prefac.destroy
      ft_z.destroy; ft_y.destroy; ft_x.destroy
   end

   make_ft_v2(ft,k_pts) 
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      ft :: MAT3{CPX}
      k_pts :: MAT{REAL}, target

      ft_x,ft_y,ft_z :: MAT3{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      prefac,ft_xb,ft_yb,ft_zb :: VEC{CPX}*
      k_x,k_y,k_z,pre :: VEC{REAL}*
      g1_exa,g1_exb :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      k_max,a,b,k,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      I :: CPX

      ! Constants
      I = cmplx(ZERO,ONE,kind=CPX_KIND)
      gamma = .a.ex+.b.ex
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma

      ! Space for fourier transform of each component
      k_max = k_pts.dim1
      ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_z.create([1,k_max],[0,.a.l],[0,.b.l])

      ! Reciprocal lattice K points
      k_x => k_pts(:,1)
      k_y => k_pts(:,2)
      k_z => k_pts(:,3)

      ! Gaussian pair center
      g1_exa = g1*.a.ex
      g1_exb = g1*.b.ex
      P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
      P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
      P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)

      ! Make prefactor
      prefac.create(k_max)
      do k = 1,k_max
         k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
         prefac(k) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
      end

      ! Fourier transforms of each component.
      .make_ft_component(ft_x,1,k_x)        
      .make_ft_component(ft_y,2,k_y)        
      .make_ft_component(ft_z,3,k_z)

      ! Incorporate prefactor into ft_z
      do b = 0,.b.l 
      do a = 0,.a.l
         ft_z(:,a,b) = ft_z(:,a,b) * prefac
      end
      end
      prefac.destroy

      ! Gaussian function power arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
      bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)

      ! Do the Fourier transform
      ft = ft_x(:,ax,bx)*ft_y(:,ay,by)*ft_z(:,az,bz)

      ! Clean up
      ft_z.destroy; ft_y.destroy; ft_x.destroy

   end

   make_ft_nabla(ft,k_pts)
   ! Calculates the Fourier transform of the current integrals for the product
   ! of two primitive gaussian functions, evaluated at a series of points
   ! "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! size of "ft" is [k_max],[.a.l.n_comp],[.b.l.n_comp],[3
      self :: IN
      k_pts :: MAT{REAL}, IN
      ft :: MAT4{CPX}
      ci,prefac :: CPX
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3 :: REAL
      k_max,a,b,k,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      ax,ay,az,bx,by,bz :: VEC{INT}*
      ft_x,ft_y,ft_z,fd_x,fd_y,fd_z :: MAT3{CPX}*
      ci = (ZERO,ONE)                         ! A few useful constants ...
      k_max = size(k_pts,1)
      gamma = .a.ex+.b.ex
      g1 = 1/gamma
      g4 = QUARTER*g1
      pifac = (PI/gamma)**(1.5)
      P1 = g1*(.a.ex*.a.pos(1)+.b.ex*.b.pos(1))
      P2 = g1*(.a.ex*.a.pos(2)+.b.ex*.b.pos(2))
      P3 = g1*(.a.ex*.a.pos(3)+.b.ex*.b.pos(3))
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
      bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
      ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
      .make_ft_component(ft_x,1,k_pts(:,1))       ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_pts(:,2))       ! of each component.
      .make_ft_component(ft_z,3,k_pts(:,3))
      fd_x.create([1,k_max],[0,.a.l],[0,.b.l])
      fd_y.create([1,k_max],[0,.a.l],[0,.b.l])
      fd_z.create([1,k_max],[0,.a.l],[0,.b.l])
      .make_ft_dab_component(fd_x,1,k_pts(:,1),k_max)   ! Get the Fourier transforms
      .make_ft_dab_component(fd_y,2,k_pts(:,2),k_max)   ! of the derivative of each
      .make_ft_dab_component(fd_z,3,k_pts(:,3),k_max)   ! component.
      do b = 1,.b.n_comp         ! Loop over all elements and multiply prefactor
         xb = bx(b)
         yb = by(b)
         zb = bz(b)
         do a = 1,.a.n_comp 
            xa = ax(a)
            ya = ay(a)
            za = az(a)
            do k = 1,k_max
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               dot1 = k1*P1+k2*P2+k3*P3
               dot2 = k1*k1+k2*k2+k3*k3
               dot2 = -dot2*g4
               prefac = pifac*exp(ci*dot1)*exp(dot2)
               ft(k,a,b,1) = prefac*fd_x(k,xa,xb)*ft_y(k,ya,yb)*ft_z(k,za,zb)
               ft(k,a,b,2) = prefac*ft_x(k,xa,xb)*fd_y(k,ya,yb)*ft_z(k,za,zb)
               ft(k,a,b,3) = prefac*ft_x(k,xa,xb)*ft_y(k,ya,yb)*fd_z(k,za,zb)
            end
         end
      end
      fd_z.destroy; fd_y.destroy; fd_x.destroy
      ft_z.destroy; ft_y.destroy; ft_x.destroy
   end

   make_ft_da_db(ft_da,ft_db,k_pts)
   ! Calculates the Fourier transform of the derivatives of the product
   ! of two primitive gaussian functions, w.r.t. positions of center a and b,
   ! "ft_ad", and "ft_db" respectively, evaluated at a series of points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! size of "ft_da" and "ft_db" is ([k_max],[.a.l.n_comp],[.b.l.n_comp],3)
      self :: IN
      k_pts :: MAT{REAL}, IN
      ft_da,ft_db :: MAT4{CPX}
      ci,prefac :: CPX
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3 :: REAL
      k_max,a,b,k,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      ax,ay,az,bx,by,bz :: VEC{INT}*
      ft_x,ft_y,ft_z,fa_x,fa_y,fa_z,fb_x,fb_y,fb_z :: MAT3{CPX}*
      ci = (ZERO,ONE)                                    ! The imaginary constant i ...
      k_max = k_pts.dim1
      gamma = .a.ex+.b.ex
      g1 = 1/gamma
      g4 = QUARTER*g1
      pifac = (PI/gamma)**(1.5)
      P1 = g1*(.a.ex*.a.pos(1)+.b.ex*.b.pos(1))
      P2 = g1*(.a.ex*.a.pos(2)+.b.ex*.b.pos(2))
      P3 = g1*(.a.ex*.a.pos(3)+.b.ex*.b.pos(3))
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
      bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
      ft_x.create(1,k_max,0,.a.l,0,.b.l)
      ft_y.create(1,k_max,0,.a.l,0,.b.l)
      ft_z.create(1,k_max,0,.a.l,0,.b.l)
      .make_ft_component(ft_x,1,k_pts(:,1))        ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_pts(:,2))        ! of each component.
      .make_ft_component(ft_z,3,k_pts(:,3))
      fa_x.create(1,k_max,0,.a.l,0,.b.l)
      fa_y.create(1,k_max,0,.a.l,0,.b.l)
      fa_z.create(1,k_max,0,.a.l,0,.b.l)
      fb_x.create(1,k_max,0,.a.l,0,.b.l)
      fb_y.create(1,k_max,0,.a.l,0,.b.l)
      fb_z.create(1,k_max,0,.a.l,0,.b.l)
      .make_ft_da_db_component(fa_x,fb_x,1,k_pts(:,1)) ! Get the Fourier transforms
      .make_ft_da_db_component(fa_y,fb_y,2,k_pts(:,2)) ! of the derivative of each
      .make_ft_da_db_component(fa_z,fb_z,3,k_pts(:,3)) ! component.
      do a = 1,.a.n_comp         ! Loop over all elements and multiply prefactor
         xa = ax(a)
         ya = ay(a)
         za = az(a)
         do b = 1,.b.n_comp
            xb = bx(b)
            yb = by(b)
            zb = bz(b)
            do k = 1,k_max
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               dot1 = k1*P1+k2*P2+k3*P3
               dot2 = k1*k1+k2*k2+k3*k3
               dot2 = -dot2*g4
               prefac = pifac*exp(ci*dot1)*exp(dot2)
               ft_da(k,a,b,1) = prefac*fa_x(k,xa,xb)*ft_y(k,ya,yb)*ft_z(k,za,zb)
               ft_da(k,a,b,2) = prefac*ft_x(k,xa,xb)*fa_y(k,ya,yb)*ft_z(k,za,zb)
               ft_da(k,a,b,3) = prefac*ft_x(k,xa,xb)*ft_y(k,ya,yb)*fa_z(k,za,zb)
               ft_db(k,a,b,1) = prefac*fb_x(k,xa,xb)*ft_y(k,ya,yb)*ft_z(k,za,zb)
               ft_db(k,a,b,2) = prefac*ft_x(k,xa,xb)*fb_y(k,ya,yb)*ft_z(k,za,zb)
               ft_db(k,a,b,3) = prefac*ft_x(k,xa,xb)*ft_y(k,ya,yb)*fb_z(k,za,zb)
            end
         end
      end
      fb_z.destroy; fb_y.destroy; fb_x.destroy
      fa_z.destroy; fa_y.destroy; fa_x.destroy
      ft_z.destroy; ft_y.destroy; ft_x.destroy
   end

   make_ft_r(ft,k_pts)
   ! Calculates the Fourier transform of the derivative of a product of two
   ! primitive gaussian functions, times vector r, evaluated at a series of
   ! points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! size of "ft" is [k_max,.a.n_comp,.b.n_comp,3]
      k_pts :: MAT{REAL}
      ft :: MAT4{CPX}
      ci,prefac :: CPX
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3 :: REAL
      k_max,a,b,k,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      ax,ay,az,bx,by,bz :: VEC{INT}*
      ft_x,ft_y,ft_z :: MAT3{CPX}*
      ci = (ZERO,ONE)                         ! A few useful constants ...
      k_max = size(k_pts,1)
      gamma = .a.ex+.b.ex
      g1 = 1/gamma
      g4 = QUARTER*g1
      pifac = (PI/gamma)**(1.5)
      P1 = g1*(.a.ex*.a.pos(1)+.b.ex*.b.pos(1))
      P2 = g1*(.a.ex*.a.pos(2)+.b.ex*.b.pos(2))
      P3 = g1*(.a.ex*.a.pos(3)+.b.ex*.b.pos(3))
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
      bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
      ft_x.create([1,k_max],[0,.a.l],[0,.b.l+1])
      ft_y.create([1,k_max],[0,.a.l],[0,.b.l+1])
      ft_z.create([1,k_max],[0,.a.l],[0,.b.l+1])
      .make_ft_component(ft_x,1,k_pts(:,1))        ! Get the Fourier transforms
      .make_ft_component(ft_y,2,k_pts(:,2))        ! of each component.
      .make_ft_component(ft_z,3,k_pts(:,3))
      do a = 1,.a.n_comp         ! Loop over all elements and multiply prefactor
         xa = ax(a)
         ya = ay(a)
         za = az(a)
         do b = 1,.b.n_comp
            xb = bx(b)
            yb = by(b)
            zb = bz(b)
            do k = 1,k_max
               k1 = k_pts(k,1)
               k2 = k_pts(k,2)
               k3 = k_pts(k,3)
               dot1 = k1*P1+k2*P2+k3*P3
               dot2 = k1*k1+k2*k2+k3*k3
               dot2 = -dot2*g4
               prefac = pifac*exp(ci*dot1)*exp(dot2)
               ft(k,a,b,1) = prefac*(ft_x(k,xa,xb+1)+.b.pos(1)*ft_x(k,xa,xb))*ft_y(k,ya,yb)*ft_z(k,za,zb)
               ft(k,a,b,2) = prefac*ft_x(k,xa,xb)*(ft_y(k,ya,yb+1)+.b.pos(2)*ft_y(k,ya,yb))*ft_z(k,za,zb)
               ft(k,a,b,3) = prefac*ft_x(k,xa,xb)*ft_y(k,ya,yb)*(ft_z(k,za,zb+1)+.b.pos(3)*ft_z(k,za,zb))
            end
         end
      end
      ft_z.destroy
      ft_y.destroy
      ft_x.destroy
   end

   put_e_coeff(out)
   ! Put the McMurchie Davidson E coefficients to file "out"
      out :: TEXTFILE
      a,b,t :: INT
      Ex :: MAT3{REAL}*
      Ey :: MAT3{REAL}*
      Ez :: MAT3{REAL}*
      out.flush
      out.text("GAUSSIAN2 output:",flush=2)
      out.text("Dylan Jayatilaka, University of Western Australia, March 1998",flush=2)
      out.show("l_a   =",.a.l,real_width=TRUE)
      out.show("l_b   =",.a.l,real_width=TRUE)
      out.show("Ra    =",.a.pos)
      out.show("Rb    =",.b.pos)
      out.show("R     =",.a.pos-.b.pos)
      out.show("alpha =",.a.ex)
      out.show("beta  =",.b.ex)
      out.flush
      out.put_dash(int_fields=3,real_fields=3,flush=1)
      out.put("a",int_width=TRUE)
      out.put("b",int_width=TRUE)
      out.put("t",int_width=TRUE)
      out.put("Ex(t,a,b)")
      out.put("Ey(t,a,b)")
      out.put("Ez(t,a,b)",flush=1)
      Ex.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(Ex,1)
      Ey.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(Ey,2)
      Ez.create([0,.a.l+.b.l],[0,.a.l],[0,.b.l])
      .make_e_coeff(Ez,3)
      out.put_dash(int_fields=3,real_fields=3,flush=1)
      do a = 0,.a.l
      do b = 0,.b.l
      do t = 0,a+b
         out.put(a)
         out.put(b)
         out.put(t)
         out.put(Ex(t,a,b))
         out.put(Ey(t,a,b))
         out.put(Ez(t,a,b),flush=1)
      end
      end
      end
      Ez.destroy
      Ey.destroy
      Ex.destroy
   end

!  **********************
!  CADPAC-style integrals
!  **********************

   n_comp(l) result (res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of cartesian components in a gaussian shell of momentum "l".
   end

   n_comp_up_to(l) result (res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
   end

!   normalise(I)
!   ! Multiply the matrix "I" by the atomic orbital normalisation coefficients
!     self :: IN
!      I :: MAT{REAL}
!     anorm,bnorm :: VEC{REAL}*
!     a,b,fa,la,fb,lb :: INT
!
!     ! Return if no normalising factors required
!     if (.a.l<2 AND .b.l<2) return
!
!     fa = .a.first_gaussian; la = .a.last_gaussian
!     fb = .b.first_gaussian; lb = .b.last_gaussian
!     anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
!     bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)
!     do b = 1,.a.n_comp
!     do a = 1,.b.n_comp
!        I(a,b) = I(a,b)*anorm(a)*bnorm(b)
!     end
!     end
!   end

   normalise(ab)
   ! Multiply the matrix by the orbital normalisation coefficients
   ! for basis functions a and b.
      self :: IN
      ab :: MAT{REAL}, INOUT
      anorm,bnorm :: VEC{REAL}*
      a,b,fa,la,fb,lb :: INT
      faca,facb,fac :: REAL

      ! Return if no normalising factors required
      if (.a.l<2 AND .b.l<2) return

      if (.a.l >=2 AND .b.l>=2) then

        ! Get normalising factors
        fa = .a.first_gaussian; la = .a.last_gaussian
        fb = .b.first_gaussian; lb = .b.last_gaussian
        anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
        bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)

        ! Do it
        do b = 1,.b.n_comp
           facb = bnorm(b)
           do a = 1, .a.n_comp
              fac = anorm(a)*facb
              ab(a,b) = ab(a,b)*fac
           end
        end

      else if (.a.l >=2) then

        ! Get normalising factors
        fa = .a.first_gaussian; la = .a.last_gaussian
        anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
   
        ! Do it
        do a = 1, .a.n_comp
           faca = anorm(a)
           do b = 1,.b.n_comp
              ab(a,b) = ab(a,b)*faca
           end
        end

      else if (.b.l >=2) then

        ! Get normalising factors
        fb = .b.first_gaussian; lb = .b.last_gaussian
        bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)
   
        ! Do it
        do b = 1,.b.n_comp
           facb = bnorm(b)
           do a = 1, .a.n_comp
              ab(a,b) = ab(a,b)*facb
           end
        end

      end

   end

   normalise(ab)
   ! Multiply the matrix by the orbital normalisation coefficients
   ! for basis functions a and b.
     self :: IN
     ab :: MAT{CPX}, INOUT
     anorm,bnorm :: VEC{REAL}*
     a,b,fa,la,fb,lb :: INT
     faca,facb,fac :: REAL

     ! Return if no normalising factors required
     if (.a.l<2 AND .b.l<2) return

     if (.a.l >=2 AND .b.l>=2) then

        ! Get normalising factors
        fa = .a.first_gaussian; la = .a.last_gaussian
        fb = .b.first_gaussian; lb = .b.last_gaussian
        anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
        bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)

        ! Do it
        do b = 1,.b.n_comp
           facb = bnorm(b)
           do a = 1, .a.n_comp
              fac = anorm(a)*facb
              ab(a,b) = ab(a,b)*fac
           end
        end

     else if (.a.l >=2) then

        ! Get normalising factors
        fa = .a.first_gaussian; la = .a.last_gaussian
        anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
   
        ! Do it
        do a = 1, .a.n_comp
           faca = anorm(a)
           do b = 1,.b.n_comp
              ab(a,b) = ab(a,b)*faca
           end
        end

     else if (.b.l >=2) then

        ! Get normalising factors
        fb = .b.first_gaussian; lb = .b.last_gaussian
        bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)
   
        ! Do it
        do b = 1,.b.n_comp
           facb = bnorm(b)
           do a = 1, .a.n_comp
              ab(a,b) = ab(a,b)*facb
           end
        end

     end

   end

   make_normalised_overlap_ints(S)
   ! Make the normalised overlap integral matrix "S". 
      S :: MAT{REAL}
      .make_overlap_ints(S)
      .normalise(S)
   end

   make_overlap_ints(S)
   ! Make the overlap integral matrix "S". Uses Gauss-Hermite quadrature.
      S :: MAT{REAL}
      Sx,Sy,Sz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      .make_overlap_ints(Sx,1)
      .make_overlap_ints(Sy,2)
      .make_overlap_ints(Sz,3)
!     The following loops can be simplified by the one line statement:
!     S = Sx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          S(a,b) = Sx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
        end
      end
      Sz.destroy; Sy.destroy; Sx.destroy
      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      S = prefac*S
   end

   make_overlap_ints(Sx,x,max_a,max_b)
   ! Make the 1-D overlap xyz integral matrix "Sx" for component "x".
   ! If present, "max_a" and "max_b" are used for the maximum angular momenta
   ! of centers (a) and (b) respectively -- for derivative integrals.
   ! Uses Gauss-Hermite quadrature.
      Sx :: MAT{REAL}
      x :: INT
      max_a,max_b :: INT, optional
      p,t,rp,ax,bx,wt,pt,ra,rb :: REAL
      l_a,l_b, a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      rp = (.a.ex*ax + .b.ex*bx)/p
      Sx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
         end
      end
      end
   end

   make_S_1st_deriv_ints(AAx,AAy,AAz)
   ! Make the first derivative overlap integrals "AAx", "AAy" and "AAz" which are
   ! the derivatives of the overlap matrix elements with respect to position A.
   ! The derivatives with respect to position B are not evaluated. By translational
   ! invariance, they are just the negative of the derivatives w.r.t. A.
      AAx,AAy,AAz :: MAT{REAL}
      Sx,Sy,Sz, Dx,Dy,Dz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+2,.b.l+1); Sy.create(.a.l+2,.b.l+1); Sz.create(.a.l+2,.b.l+1)
      Dx.create(.a.l+1,.b.l+1); Dy.create(.a.l+1,.b.l+1); Dz.create(.a.l+1,.b.l+1)
      .make_overlap_ints(Sx,1,.a.l+1)
      .make_overlap_ints(Sy,2,.a.l+1)
      .make_overlap_ints(Sz,3,.a.l+1)
      .differentiate(Sx,"left",Dx) ! with respect to electron coordinates !
      .differentiate(Sy,"left",Dy)
      .differentiate(Sz,"left",Dz)
!     The following loops can be simplified by the statements:
!     AAx = -Dx(ax,bx)*Sy(ay,by)*Sz(az,bz)
!     AAy = -Sx(ax,bx)*Dy(ay,by)*Sz(az,bz)
!     AAz = -Sx(ax,bx)*Sy(ay,by)*Dz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          ! Minus sign for nuclear derivative
          AAx(a,b) = -Dx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
          AAy(a,b) = -Sx(aix,bix)*Dy(aiy,biy)*Sz(aiz,biz)
          AAz(a,b) = -Sx(aix,bix)*Sy(aiy,biy)*Dz(aiz,biz)
        end
      end
      Dz.destroy; Dy.destroy; Dx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      AAx = prefac*AAx
      AAy = prefac*AAy
      AAz = prefac*AAz
   end

   make_oscillator_overlap_ints(S,c,d,lc_min,lc_max,ld_min,ld_max)
   ! Make the oscillator overlap integral matrix "S". "c" and "d" are the centroid
   ! positions of the bra and ket. "lc_min", "lc_max", "ld_min" and "ld_max" are
   ! the corresponding minimum and maximum angular momenta for the centroid
   ! polynomials on "c" and "d". 
      S :: MAT4{REAL}
      c,d :: VEC{REAL}(3)
      lc_min,lc_max,ld_min,ld_max :: INT
   ENSURE(S.dim3==(GAUSSIAN2::n_comp_up_to(lc_max)-GAUSSIAN2::n_comp_up_to(lc_min-1)),"wrong size for S")
   ENSURE(S.dim4==(GAUSSIAN2::n_comp_up_to(ld_max)-GAUSSIAN2::n_comp_up_to(ld_min-1)),"wrong size for S")
      Sx,Sy,Sz :: MAT4{REAL}*
      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      n_c,n_d,fa,la,fb,lb,fc,lc,fd,ld :: INT
      n_c = lc_max.n_comp_sum - (lc_min-1).n_comp_sum
      n_d = ld_max.n_comp_sum - (ld_min-1).n_comp_sum
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      fc = GAUSSIAN2::n_comp_up_to(lc_min-1)+1; lc = GAUSSIAN2::n_comp_up_to(lc_max)
      fd = GAUSSIAN2::n_comp_up_to(ld_min-1)+1; ld = GAUSSIAN2::n_comp_up_to(ld_max)
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      cx => GAUSSIAN_DATA::nx(fc:lc); cy => GAUSSIAN_DATA::ny(fc:lc); cz => GAUSSIAN_DATA::nz(fc:lc)
      dx => GAUSSIAN_DATA::nx(fd:ld); dy => GAUSSIAN_DATA::ny(fd:ld); dz => GAUSSIAN_DATA::nz(fd:ld)
      Sx.create(.a.l+1,.b.l+1,lc_max+1,ld_max+1)
      Sy.create(.a.l+1,.b.l+1,lc_max+1,ld_max+1)
      Sz.create(.a.l+1,.b.l+1,lc_max+1,ld_max+1)
      .make_oscillator_overlap_ints(Sx,1,c(1),lc_max,d(1),ld_max)
      .make_oscillator_overlap_ints(Sy,2,c(2),lc_max,d(2),ld_max)
      .make_oscillator_overlap_ints(Sz,3,c(3),lc_max,d(3),ld_max)
      S = Sx(ax,bx,cx,dx)*Sy(ay,by,cy,dy)*Sz(az,bz,cz,dz)
      Sz.destroy; Sy.destroy; Sx.destroy
      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      S = prefac*S
   end

   make_oscillator_overlap_ints(Sx,x,cx,l_c,dx,l_d,max_a,max_b)
   ! Make the 1-D overlap xyz integral matrix "Sx" for component "x".
   ! The oscillator polynomials are centered at "cx" and "dx". "l_c" and "l_d"
   ! are the corresponding maximum angular momenta of each oscillator. If
   ! present, "max_a" and "max_b" specify the maximum angular momenta on centers
   ! a and b respectively. Uses Gauss-Hermite quadrature.
      Sx :: MAT4{REAL}
      x,l_c,l_d :: INT
      cx,dx :: REAL
      max_a,max_b :: REAL, optional
      p,t,rp,ax,bx,wt,pt,ra,rb,rc,rd :: REAL
      l_a,l_b, a,b,c,d, i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      rp = (.a.ex*ax + .b.ex*bx)/p
      Sx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
      do c = 1,l_c+1
      do d = 1,l_d+1
         i = (a+b+c+d)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rc = pt - cx
            rd = pt - dx
            if (a>1) wt = wt*ra**(a-1)
            if (b>1) wt = wt*rb**(b-1)
            if (c>1) wt = wt*rc**(c-1)
            if (d>1) wt = wt*rd**(d-1)
            Sx(a,b,c,d) = Sx(a,b,c,d) + wt
         end
      end
      end
      end
      end
   end

   make_normalised_kinetic_ints(T)
   ! Make the normalised kinetic integrals "T". 
      T :: MAT{REAL}
      .make_kinetic_ints(T)
      .normalise(T)
   end

   make_kinetic_ints(T)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      T :: MAT{REAL}
      Sx,Sy,Sz, Dx,Dy,Dz, Tx,Ty,Tz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT

      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)

      Sx.create(.a.l+1,.b.l+3); Sy.create(.a.l+1,.b.l+3); Sz.create(.a.l+1,.b.l+3)
      Tx.create(.a.l+1,.b.l+1); Ty.create(.a.l+1,.b.l+1); Tz.create(.a.l+1,.b.l+1)
      Dx.create(.a.l+1,.b.l+2); Dy.create(.a.l+1,.b.l+2); Dz.create(.a.l+1,.b.l+2)

      .make_overlap_ints(Sx,1,max_b=.b.l+2)
      .make_overlap_ints(Sy,2,max_b=.b.l+2)
      .make_overlap_ints(Sz,3,max_b=.b.l+2)

      .differentiate(Sx,"right",Dx) ! with respect to electron coordinates !
      .differentiate(Sy,"right",Dy)
      .differentiate(Sz,"right",Dz)
      .differentiate(Dx,"right",Tx) ! with respect to electron coordinates !
      .differentiate(Dy,"right",Ty)
      .differentiate(Dz,"right",Tz)
      Dz.destroy; Dy.destroy; Dx.destroy

!     The following loops can be simplified by the statement:
!     T = Tx(ax,bx)*Sy(ay,by)*Sz(az,bz) &
!       + Sx(ax,bx)*Ty(ay,by)*Sz(az,bz) &
!       + Sx(ax,bx)*Sy(ay,by)*Tz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          T(a,b) = Tx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz) + &
                   Sx(aix,bix)*Ty(aiy,biy)*Sz(aiz,biz) + &
                   Sx(aix,bix)*Sy(aiy,biy)*Tz(aiz,biz)
        end
      end

      Tz.destroy; Ty.destroy; Tx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy

      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      T = -HALF*prefac*T

   end

   make_T_1st_deriv_ints(AAx,AAy,AAz)
   ! Make the first derivative kinetic integrals "AAx", "AAy" and "AAz" which are
   ! the derivatives of the kinetic matrix elements with respect to position A.
   ! The derivatives with respect to position B are not evaluated. By translational
   ! invariance, they are just the negative of the derivatives w.r.t. A.
   ! This includes the factor of -1/2 in T = -1/2 \nabla^2.
      AAx,AAy,AAz :: MAT{REAL}
      SSx,SSy,SSz, SAx,SAy,SAz, TTx,TTy,TTz, TAx,TAy,TAz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      SSx.create(.a.l+4,.b.l+1); SSy.create(.a.l+4,.b.l+1); SSz.create(.a.l+4,.b.l+1)
      SAx.create(.a.l+3,.b.l+1); SAy.create(.a.l+3,.b.l+1); SAz.create(.a.l+3,.b.l+1)
      TTx.create(.a.l+2,.b.l+1); TTy.create(.a.l+2,.b.l+1); TTz.create(.a.l+2,.b.l+1)
      TAx.create(.a.l+1,.b.l+1); TAy.create(.a.l+1,.b.l+1); TAz.create(.a.l+1,.b.l+1)
      .make_overlap_ints(SSx,1,.a.l+3)
      .make_overlap_ints(SSy,2,.a.l+3)
      .make_overlap_ints(SSz,3,.a.l+3)
      .differentiate(SSx,"left",SAx)   ! with respect to electron coordinates !
      .differentiate(SSy,"left",SAy)
      .differentiate(SSz,"left",SAz)
      .differentiate(SAx,"left",TTx)   ! with respect to electron coordinates !
      .differentiate(SAy,"left",TTy)
      .differentiate(SAz,"left",TTz)
      .differentiate(TTx,"left",TAx)   ! with respect to electron coordinates !
      .differentiate(TTy,"left",TAy)
      .differentiate(TTz,"left",TAz)
!     The following loops can be simplified by the statements:
!     AAx = TAx(ax,bx)*SSy(ay,by)*SSz(az,bz) &
!         + SAx(ax,bx)*TTy(ay,by)*SSz(az,bz) &
!         + SAx(ax,bx)*SSy(ay,by)*TTz(az,bz)
!     AAy = TTx(ax,bx)*SAy(ay,by)*SSz(az,bz) &
!         + SSx(ax,bx)*TAy(ay,by)*SSz(az,bz) &
!         + SSx(ax,bx)*SAy(ay,by)*TTz(az,bz)
!     AAz = TTx(ax,bx)*SSy(ay,by)*SAz(az,bz) &
!         + SSx(ax,bx)*TTy(ay,by)*SAz(az,bz) &
!         + SSx(ax,bx)*SSy(ay,by)*TAz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          ! No minus sign for nuclear derivative ... see below for reason
          AAx(a,b) = TAx(aix,bix)*SSy(aiy,biy)*SSz(aiz,biz) + &
                     SAx(aix,bix)*TTy(aiy,biy)*SSz(aiz,biz) + &
                     SAx(aix,bix)*SSy(aiy,biy)*TTz(aiz,biz)
          AAy(a,b) = TTx(aix,bix)*SAy(aiy,biy)*SSz(aiz,biz) + &
                     SSx(aix,bix)*TAy(aiy,biy)*SSz(aiz,biz) + &
                     SSx(aix,bix)*SAy(aiy,biy)*TTz(aiz,biz)
          AAz(a,b) = TTx(aix,bix)*SSy(aiy,biy)*SAz(aiz,biz) + &
                     SSx(aix,bix)*TTy(aiy,biy)*SAz(aiz,biz) + &
                     SSx(aix,bix)*SSy(aiy,biy)*TAz(aiz,biz)
        end
      end
      TAz.destroy; TAy.destroy; TAx.destroy
      TTz.destroy; TTy.destroy; TTx.destroy
      SAz.destroy; SAy.destroy; SAx.destroy
      SSz.destroy; SSy.destroy; SSx.destroy
      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = HALF*exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      AAx = prefac*AAx ! should be -1/2 factor on line above, but derivatives are
      AAy = prefac*AAy ! wrt electrons not nuclei so that reverses the sign
      AAz = prefac*AAz
   end

!   make_oscillator_kinetic_ints(T,c,l_c,d,l_d)
!   ! Make the oscillator kinetic integral matrix "T". "c" and "d" are the
!   ! centroid positions of the bra and ket. "l_c" and "l_d" are the
!   ! corresponding maximum angular momenta for the centroid polynomials on "c"
!   ! and "d". This includes the factor of -1/2 in T = -1/2 \nabla^2.
!      T :: MAT4{REAL}
!      c,d :: VEC{REAL}(3)
!      l_c,l_d :: INT
!   ENSURE(T.dim3==l_c*(l_c+1)/2,"wrong size for S")
!   ENSURE(T.dim4==l_d*(l_d+1)/2,"wrong size for S")
!      Sx,Sy,Sz, Dx,Dy,Dz, Tx,Ty,Tz :: MAT4{REAL}*
!      ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: VEC{INT}*
!      rab :: VEC{REAL}(3)
!      p,prefac :: REAL
!      n_a,n_b,n_c,n_d,a,b :: INT
!      n_a = (.a.l+1)*(.a.l+2)/2
!      n_b = (.b.l+1)*(.b.l+2)/2
!      n_c = (l_c+1)*(l_c+2)/2
!      n_d = (l_d+1)*(l_d+2)/2
!      ax.create(n_a); ay.create(n_a); az.create(n_a); .a.l.make_gaussian_xyz_indices(ax,ay,az)
!      bx.create(n_b); by.create(n_b); bz.create(n_b); .b.l.make_gaussian_xyz_indices(bx,by,bz)
!      cx.create(n_c); cy.create(n_c); cz.create(n_c);  l_c.make_gaussian_xyz_indices(cx,cy,cz)
!      dx.create(n_c); dy.create(n_c); dz.create(n_c);  l_d.make_gaussian_xyz_indices(dx,dy,dz)
!      Sx.create(.a.l+1,.b.l+3,l_c+1,l_d+3)
!      Sy.create(.a.l+1,.b.l+3,l_c+1,l_d+3)
!      Sz.create(.a.l+1,.b.l+3,l_c+1,l_d+3)
!      Tx.create(.a.l+1,.b.l+1,l_c+1,l_d+1)
!      Ty.create(.a.l+1,.b.l+1,l_c+1,l_d+1)
!      Tz.create(.a.l+1,.b.l+1,l_c+1,l_d+1)
!      Dx.create(.a.l+1,.b.l+2,l_c+1,l_d+2)
!      Dy.create(.a.l+1,.b.l+2,l_c+1,l_d+2)
!      Dz.create(.a.l+1,.b.l+2,l_c+1,l_d+2)
!      .make_oscillator_overlap_ints(Sx,1,c(1),l_c,d(1),l_d+2,max_b=.b.l+2)
!      .make_oscillator_overlap_ints(Sy,2,c(2),l_c,d(2),l_d+2,max_b=.b.l+2)
!      .make_oscillator_overlap_ints(Sz,3,c(3),l_c,d(3),l_d+2,max_b=.b.l+2)
!      .differentiate(Sx,"right",Dx) ! with respect to electron coordinates !
!      .differentiate(Sy,"right",Dy)
!      .differentiate(Sz,"right",Dz)
!      .differentiate(Dx,"right",Tx) ! with respect to electron coordinates !
!      .differentiate(Dy,"right",Ty)
!      .differentiate(Dz,"right",Tz)
!      Dz.destroy; Dy.destroy; Dx.destroy
!      The following loops can be simplified by the statement:
!      T = Tx(ax,bx,cx,dx)*Sy(ay,by,cx,dx)*Sz(az,bz,cx,dx) & ! del_x^2
!        + Sx(ax,bx,cx,dx)*Ty(ay,by,cx,dx)*Sz(az,bz,cx,dx) & ! del_y^2
!        + Sx(ax,bx,cx,dx)*Sy(ay,by,cx,dx)*Tz(az,bz,cx,dx)   ! del_z^2
!      Tz.destroy; Ty.destroy; Tx.destroy
!      Sz.destroy; Sy.destroy; Sx.destroy
!      bz.destroy; by.destroy; bx.destroy
!      az.destroy; ay.destroy; ax.destroy
!      p = .a.ex + .b.ex
!      rab = .a.pos - .b.pos
!      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
!      T = -HALF*prefac*T
!   end

!   differentiate_oscillator(I,index,D)
!   ! Differentiate a gaussian oscillator integral matrix "I" with respect to the
!   ! *electron* coordinate on basis function "index", which can be "left" or
!   ! "right". Place the result in "D".
!      I,D :: MAT4{REAL}
!      index :: STR
!      i_a,i_b,i_c,i_d,d_a,d_b,d_c,d_d,a,b :: INT
!      a2,b2 :: REAL
!      i_a = I.dim1; i_b = I.dim2; i_c = I.dim3; i_d = I.dim4
!      d_a = D.dim1; d_b = D.dim2; d_c = D.dim3; d_d = D.dim4
!      D = ZERO
!      select case (index)
!         case("l","left")
!            ENSURE(i_a>1,   "I array too small to differentiate")
!            ENSURE(i_c>1,   "I array too small to differentiate")
!            ENSURE(i_a>d_a, "I and D arrays are incompatible")
!            ENSURE(i_c>d_c, "I and D arrays are incompatible")
!            ENSURE(i_b>=d_b,"I and D arrays are incompatible")
!            ENSURE(i_d>=d_d,"I and D arrays are incompatible")
!            a2 = TWO*.a.ex
!            D(1,:,) = -a2*I(2  ,1:d_b)
!            do a = 2,d_a
!            D(a,:) = -a2*I(a+1,1:d_b) + (a-1)*I(a-1,1:d_b)
!            end
!         case("r","right")
!            ENSURE(i_b>1,   "I array too small to differentiate")
!            ENSURE(i_b>d_b, "I and D arrays are incompatible")
!            ENSURE(i_a>=d_a,"I and D arrays are incompatible")
!            b2 = TWO*.b.ex
!            D(:,1) = -b2*I(1:d_a,2  )
!            do b = 2,d_b
!            D(:,b) = -b2*I(1:d_a,b+1) + (b-1)*I(1:d_a,b-1)
!            end
!      end
!   end

   make_dipole_ints(Dx,Dy,Dz,origin)
   ! Make the dipole integral matrices "Dx", "Dy", and "Dz".
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      Dx,Dy,Dz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      Sx,Sy,Sz,Rx,Ry,Rz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac,Sx_ab,Sy_ab,Sz_ab :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Rx.create(.a.l+1,.b.l+1); Ry.create(.a.l+1,.b.l+1); Rz.create(.a.l+1,.b.l+1)
      .make_dipole_ints(Sx,Rx,1,origin(1))
      .make_dipole_ints(Sy,Ry,2,origin(2))
      .make_dipole_ints(Sz,Rz,3,origin(3))
!     The following loops can be simplified by the statements:
!     Dx = Rx(ax,bx)*Sy(ay,by)*Sz(az,bz)
!     Dy = Sx(ax,bx)*Ry(ay,by)*Sz(az,bz)
!     Dz = Sx(ax,bx)*Sy(ay,by)*Rz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          Sx_ab = Sx(aix,bix)
          Sy_ab = Sy(aiy,biy)
          Sz_ab = Sz(aiz,biz)
          Dx(a,b) = Rx(aix,bix)*Sy_ab*Sz_ab
          Dy(a,b) = Sx_ab*Ry(aiy,biy)*Sz_ab
          Dz(a,b) = Sx_ab*Sy_ab*Rz(aiz,biz)
        end
      end
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      Dx = prefac*Dx
      Dy = prefac*Dy
      Dz = prefac*Dz
   end

   make_dipole_ints(Sx,Dx,x,ox,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx" and dipole integrals "Dx" for component
   ! "x".
   ! "ox" is the origin for the dipole terms. If present, "max_a" and "max_b"
   ! override the l value for gaussian a or b. Uses Gauss-Hermite quadrature.
      Sx,Dx :: MAT{REAL}
       x :: INT
      ox :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,rp,wt,pt,ra,rb,rd :: REAL
      l_a,l_b,a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      rp = (.a.ex*ax + .b.ex*bx)/p
      Sx = ZERO
      Dx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+1)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
         end
      end
      end
   end

   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin)
   ! Make the qudrupole integral matrices "Qxx", ..., "Qyz".
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      Sx,Sy,Sz,Rx,Ry,Rz,Qx,Qy,Qz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      Sx_ab,Sy_ab,Sz_ab,Rx_ab,Ry_ab,Rz_ab,Qx_ab,Qy_ab,Qz_ab :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Rx.create(.a.l+1,.b.l+1); Ry.create(.a.l+1,.b.l+1); Rz.create(.a.l+1,.b.l+1)
      Qx.create(.a.l+1,.b.l+1); Qy.create(.a.l+1,.b.l+1); Qz.create(.a.l+1,.b.l+1)
      .make_quadrupole_ints(Sx,Rx,Qx,1,origin(1))
      .make_quadrupole_ints(Sy,Ry,Qy,2,origin(2))
      .make_quadrupole_ints(Sz,Rz,Qz,3,origin(3))
!     The following loops can be simplified by the statements:
!     Qxx = Qx(ax,bx)*Sy(ay,by)*Sz(az,bz)
!     Qyy = Sx(ax,bx)*Qy(ay,by)*Sz(az,bz)
!     Qzz = Sx(ax,bx)*Sy(ay,by)*Qz(az,bz)
!     Qxy = Rx(ax,bx)*Ry(ay,by)*Sz(az,bz)
!     Qxz = Rx(ax,bx)*Sy(ay,by)*Rz(az,bz)
!     Qyz = Sx(ax,bx)*Ry(ay,by)*Rz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          Qx_ab = Qx(aix,bix)
          Qy_ab = Qy(aiy,biy)
          Qz_ab = Qz(aiz,biz)
          Rx_ab = Rx(aix,bix)
          Ry_ab = Ry(aiy,biy)
          Rz_ab = Rz(aiz,biz)
          Sx_ab = Sx(aix,bix)
          Sy_ab = Sy(aiy,biy)
          Sz_ab = Sz(aiz,biz)
          Qxx(a,b) = Qx_ab*Sy_ab*Sz_ab
          Qyy(a,b) = Sx_ab*Qy_ab*Sz_ab
          Qzz(a,b) = Sx_ab*Sy_ab*Qz_ab
          Qxy(a,b) = Rx_ab*Ry_ab*Sz_ab
          Qxz(a,b) = Rx_ab*Sy_ab*Rz_ab
          Qyz(a,b) = Sx_ab*Ry_ab*Rz_ab
        end
      end
      Qz.destroy; Qy.destroy; Qx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      Qxx = prefac*Qxx
      Qyy = prefac*Qyy
      Qzz = prefac*Qzz
      Qxy = prefac*Qxy
      Qxz = prefac*Qxz
      Qyz = prefac*Qyz
   end

   make_quadrupole_ints(Sx,Dx,Qx,x,ox,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx" and quadruple
   ! integrals "Qx" for component "x". "ox" is the origin for the dipole terms.
   ! If present, "max_a" and "max_b" override the l value for gaussian a or b.
   ! Uses Gauss-Hermite quadrature.
      Sx,Dx,Qx :: MAT{REAL}
       x :: INT
      ox :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,rp,wt,pt,ra,rb,rd :: REAL
      l_a,l_b,a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      rp = (.a.ex*ax + .b.ex*bx)/p
      Sx = ZERO
      Dx = ZERO
      Qx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+2)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Qx(a,b) = Qx(a,b) + rd*rd*wt
         end
      end
      end
   end

   make_octupole_ints(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz,origin)
   ! Make the octupole integral matrices "Oxxx", ..., "Oxyz".
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      Sx,Sy,Sz,Rx,Ry,Rz,Qx,Qy,Qz,Ox,Oy,Oz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      Sx_ab,Sy_ab,Sz_ab,Rx_ab,Ry_ab,Rz_ab :: REAL
      Qx_ab,Qy_ab,Qz_ab,Ox_ab,Oy_ab,Oz_ab :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Rx.create(.a.l+1,.b.l+1); Ry.create(.a.l+1,.b.l+1); Rz.create(.a.l+1,.b.l+1)
      Qx.create(.a.l+1,.b.l+1); Qy.create(.a.l+1,.b.l+1); Qz.create(.a.l+1,.b.l+1)
      Ox.create(.a.l+1,.b.l+1); Oy.create(.a.l+1,.b.l+1); Oz.create(.a.l+1,.b.l+1)
      .make_octupole_ints(Sx,Rx,Qx,Ox,1,origin(1))
      .make_octupole_ints(Sy,Ry,Qy,Oy,2,origin(2))
      .make_octupole_ints(Sz,Rz,Qz,Oz,3,origin(3))
!     The following loops can be simplified by the statements:
!     Oxxx = Ox(ax,bx)*Sy(ay,by)*Sz(az,bz)
!     Oyyy = Sx(ax,bx)*Oy(ay,by)*Sz(az,bz)
!     Ozzz = Sx(ax,bx)*Sy(ay,by)*Oz(az,bz)
!     Oxxy = Qx(ax,bx)*Ry(ay,by)*Sz(az,bz)
!     Oxxz = Qx(ax,bx)*Sy(ay,by)*Rz(az,bz)
!     Oyyx = Rx(ax,bx)*Qy(ay,by)*Sz(az,bz)
!     Oyyz = Sx(ax,bx)*Qy(ay,by)*Rz(az,bz)
!     Ozzx = Rx(ax,bx)*Sy(ay,by)*Qz(az,bz)
!     Ozzy = Sx(ax,bx)*Ry(ay,by)*Qz(az,bz)
!     Oxyz = Rx(ax,bx)*Ry(ay,by)*Rz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          Ox_ab = Ox(aix,bix); Oy_ab = Oy(aiy,biy); Oz_ab = Oz(aiz,biz)
          Qx_ab = Qx(aix,bix); Qy_ab = Qy(aiy,biy); Qz_ab = Qz(aiz,biz)
          Rx_ab = Rx(aix,bix); Ry_ab = Ry(aiy,biy); Rz_ab = Rz(aiz,biz)
          Sx_ab = Sx(aix,bix); Sy_ab = Sy(aiy,biy); Sz_ab = Sz(aiz,biz)
          Oxxx(a,b) = Ox_ab*Sy_ab*Sz_ab
          Oyyy(a,b) = Sx_ab*Oy_ab*Sz_ab
          Ozzz(a,b) = Sx_ab*Sy_ab*Oz_ab
          Oxxy(a,b) = Qx_ab*Ry_ab*Sz_ab
          Oxxz(a,b) = Qx_ab*Sy_ab*Rz_ab
          Oyyx(a,b) = Rx_ab*Qy_ab*Sz_ab
          Oyyz(a,b) = Sx_ab*Qy_ab*Rz_ab
          Ozzx(a,b) = Rx_ab*Sy_ab*Qz_ab
          Ozzy(a,b) = Sx_ab*Ry_ab*Qz_ab
          Oxyz(a,b) = Rx_ab*Ry_ab*Rz_ab
        end
      end
      Oz.destroy; Oy.destroy; Ox.destroy
      Qz.destroy; Qy.destroy; Qx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      Oxxx = prefac*Oxxx
      Oyyy = prefac*Oyyy
      Ozzz = prefac*Ozzz
      Oxxy = prefac*Oxxy
      Oxxz = prefac*Oxxz
      Oyyx = prefac*Oyyx
      Oyyz = prefac*Oyyz
      Ozzx = prefac*Ozzx
      Ozzy = prefac*Ozzy
      Oxyz = prefac*Oxyz
   end

   make_octupole_ints(Sx,Dx,Qx,Ox,x,og,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx", quadruple
   ! integrals "Qx", and the ocupole integrals "Ox", for component "x". "og" is
   ! the origin for the dipole terms.
   ! If present, "max_a" and "max_b" override the l value for gaussian a or b.
   ! Uses Gauss-Hermite quadrature.
      Sx,Dx,Qx,Ox :: MAT{REAL}
       x :: INT
      og :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,rp,wt,pt,ra,rb,rd,rd2 :: REAL
      l_a,l_b,a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      rp = (.a.ex*ax + .b.ex*bx)/p
      Sx = ZERO
      Dx = ZERO
      Qx = ZERO
      Ox = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+3)/2
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + rp
            ra = pt - ax
            rb = pt - bx
            rd = pt - og
            rd2 = rd*rd
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Qx(a,b) = Qx(a,b) + rd2*wt
            Ox(a,b) = Ox(a,b) + rd2*rd*wt
         end
      end
      end
   end

   make_normalised_NA_ints(NA,c)
   ! Make the normalised nuclear attraction integral matrix "NA" for a
   ! nucleus at position "c". 
      NA :: MAT{REAL}
      c :: VEC{REAL}(3)
      .make_nuclear_attraction_ints(NA,c)
      .normalise(NA)
   end

   make_nuclear_attraction_ints(NA,c)
   ! Make the nuclear attraction integral matrix "NA" for a nucleus at
   ! position "c". Uses Rys decomposition of 1/r_c and Gauss-Hermite
   ! quadrature.
      NA :: MAT{REAL}
      c :: VEC{REAL}(3)
      NAx,NAy,NAz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,a,b,bix,biy,biz,fa,la,fb,lb :: INT
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      NAx.create(.a.l+1,.b.l+1); NAy.create(.a.l+1,.b.l+1); NAz.create(.a.l+1,.b.l+1)
      n_roots = (.a.l+.b.l+2)/2
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      NA = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_nuclear_attraction_ints(NAx,1,uu,c(1))
         .make_nuclear_attraction_ints(NAy,2,uu,c(2))
         .make_nuclear_attraction_ints(NAz,3,uu,c(3))
         NAz = NAz*wt
!     The following loops can be simplified by the statement
!        NA = NA + NAx(ax,bx)*NAy(ay,by)*NAz(az,bz)
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             NA(a,b) = NA(a,b) + NAx(ax(a),bix)*NAy(ay(a),biy)*NAz(az(a),biz)
           end
         end
      end
      rys.destroy
      NAz.destroy; NAy.destroy; NAx.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      NA = prefac*NA
   end

   make_nuclear_attraction_ints(Nx,x,uu,cx,max_a,max_b)
   ! Make the 1-D nuclear attraction xyz integrals "Nx", for component "x", for
   ! a particular Rys-gaussian with exponent "uu", used in the decomposition of
   ! 1/r_c centred at position "cx". If present, "max_a" and "max_b" override
   ! the l value for gaussian a or b.
   ! Uses Gauss-Hermite quadrature.
      Nx :: MAT{REAL}
       x :: INT
      uu,cx :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,r0,wt,pt,ra,rb :: REAL
      l_a,l_b,a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex + uu
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      r0 = (.a.ex*ax + .b.ex*bx + uu*cx)/p
      Nx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b)/2 ! should be max((a+b-1)/2,1) ?
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Nx(a,b) = Nx(a,b) + wt
         end
      end
      end
   end

   make_NA_1st_deriv_ints(DAx,DAy,DAz,DBx,DBy,DBz,c)
   ! Make the derivatives nuclear attraction integrals w.r.t. centers A and B in
   ! "DAx", "DAy" and "DAz", and "DBx", "DBy" and "DBz" for a nucleus at position
   ! "c". Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature
      DAx,DAy,DAz,DBx,DBy,DBz :: MAT{REAL}
      c :: VEC{REAL}(3)
      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,a,b,bix,biy,biz,fa,la,fb,lb :: INT
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      NAx.create(.a.l+2,.b.l+2); NAy.create(.a.l+2,.b.l+2); NAz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+1); AAy.create(.a.l+1,.b.l+1); AAz.create(.a.l+1,.b.l+1)
      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)
    ! n_roots = (.a.l+.b.l+3)/2
      n_roots = (.a.l+.b.l+1)/2 + 1
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      DAx = ZERO; DAy = ZERO; DAz = ZERO
      DBx = ZERO; DBy = ZERO; DBz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)
         .differentiate(NAx,"right",BBx) ! with respect to electron coordinates !
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)
         .differentiate(NAx,"left ",AAx) ! with respect to electron coordinates !
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)
         NAz = NAz*wt
         AAz = AAz*wt
         BBz = BBz*wt
!     The following loops can be simplified by the statement:
!     DAx = DAx - AAx(ax,bx)*NAy(ay,by)*NAz(az,bz)
!     DAy = DAy - NAx(ax,bx)*AAy(ay,by)*NAz(az,bz)
!     DAz = DAz - NAx(ax,bx)*NAy(ay,by)*AAz(az,bz)
!     DBx = DBx - BBx(ax,bx)*NAy(ay,by)*NAz(az,bz)
!     DBy = DBy - NAx(ax,bx)*BBy(ay,by)*NAz(az,bz)
!     DBz = DBz - NAx(ax,bx)*NAy(ay,by)*BBz(az,bz)
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             ! Minus sign for nuclear derivative
             DAx(a,b) = DAx(a,b) - AAx(ax(a),bix)*NAy(ay(a),biy)*NAz(az(a),biz)
             DAy(a,b) = DAy(a,b) - NAx(ax(a),bix)*AAy(ay(a),biy)*NAz(az(a),biz)
             DAz(a,b) = DAz(a,b) - NAx(ax(a),bix)*NAy(ay(a),biy)*AAz(az(a),biz)
             DBx(a,b) = DBx(a,b) - BBx(ax(a),bix)*NAy(ay(a),biy)*NAz(az(a),biz)
             DBy(a,b) = DBy(a,b) - NAx(ax(a),bix)*BBy(ay(a),biy)*NAz(az(a),biz)
             DBz(a,b) = DBz(a,b) - NAx(ax(a),bix)*NAy(ay(a),biy)*BBz(az(a),biz)
           end
         end
      end
      rys.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      DAx = prefac*DAx; DAy = prefac*DAy; DAz = prefac*DAz
      DBx = prefac*DBx; DBy = prefac*DBy; DBz = prefac*DBz
   end

   make_normalised_DKH_ints(T,SOx,SOy,SOz,c)
   ! Make the normalised Douglas-Kroll-Hess spin orbit integrals.
      T,SOx,SOy,SOz :: MAT{REAL}
      c :: VEC{REAL}(3)
      .make_DKH_ints(T,SOx,SOy,SOz,c)
      .normalise(T)
      .normalise(SOx)
      .normalise(SOy)
      .normalise(SOz)
   end

   make_DKH_ints(T,SOx,SOy,SOz,c)
   ! Make the Douglas-Kroll-Hess spin orbit integrals.
   ! "c" is a given nuclear center.
      T,SOx,SOy,SOz :: MAT{REAL}
      c :: VEC{REAL}(3)

      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS*

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
!      NAx.create(.a.l+2,.b.l+3); NAy.create(.a.l+2,.b.l+3); NAz.create(.a.l+2,.b.l+3)
      NAx.create(.a.l+2,.b.l+2); NAy.create(.a.l+2,.b.l+2); NAz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+2); AAy.create(.a.l+1,.b.l+2); AAz.create(.a.l+1,.b.l+2)
      BBx.create(.a.l+2,.b.l+1); BBy.create(.a.l+2,.b.l+1); BBz.create(.a.l+2,.b.l+1)
!      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      n_roots = (.a.l+.b.l+4)/2
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)

      ! Assemble the integrals
      T = ZERO
      SOx = ZERO; SOy = ZERO; SOz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt = rys.weight(k)

         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)

         .differentiate(NAx,"right",BBx) 
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         NAz = NAz*wt
         AAz = AAz*wt
         BBz = BBz*wt
         ABz = ABz*wt

         T = T + ABx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*ABz(az,bz) 
               
         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)  

         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)  

         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)  

      end

      ! Clean up
      rys.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

      ! Include prefactor
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      T = prefac*T
      SOx = prefac*SOx; SOy = prefac*SOy; SOz = prefac*SOz

   end

   make_normalised_DK3_ppZpp_ints(ppZpp,c)
   ! Make the normalised Douglas-Kroll-Hess spin orbit integrals.
      ppZpp :: MAT{REAL}
      c :: VEC{REAL}(3)
      .make_DK3_ppZpp_ints(ppZpp,c)
      .normalise(ppZpp)
   end

   make_DK3_ppZpp_ints_ori(ppZpp,c)
   ! Make the Douglas-Kroll-Hess p2Zp2 integrals for teh DK3 hamiltonian 
   ! "c" is a given nuclear center.
      ppZpp :: MAT{REAL}
      c :: VEC{REAL}(3)

      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}*
      AB2x,AB2y,AB2z :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS*

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      ! the dimension ???  
      NAx.create(.a.l+3,.b.l+3); NAy.create(.a.l+3,.b.l+3); NAz.create(.a.l+3,.b.l+3)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      ABx.create(.a.l+2,.b.l+2); ABy.create(.a.l+2,.b.l+2); ABz.create(.a.l+2,.b.l+2)
      BBx.create(.a.l+1,.b.l+2); BBy.create(.a.l+1,.b.l+2); BBz.create(.a.l+1,.b.l+2)
      AB2x.create(.a.l+1,.b.l+1); AB2y.create(.a.l+1,.b.l+1); AB2z.create(.a.l+1,.b.l+1)

      ! Roots and weights
      n_roots = (.a.l+.b.l+6)/2
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)

      ! Assemble the integrals
      ppZpp = ZERO
!      SOx = ZERO; SOy = ZERO; SOz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt = rys.weight(k)

         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+2,.b.l+2)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+2,.b.l+2)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+2,.b.l+2)


         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         .differentiate(ABx,"left",BBx) 
         .differentiate(ABy,"left",BBy)
         .differentiate(ABz,"left",BBz)

         .differentiate(BBx,"right",AB2x)
         .differentiate(BBy,"right",AB2y)
         .differentiate(BBz,"right",AB2z)

         NAz = NAz*wt
         ABz = ABz*wt
!         AAz = AAz*wt
!         BBz = BBz*wt
         AB2z = AB2z*wt

         ppZpp = ppZpp + TWO*ABx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + TWO*NAx(ax,bx)*ABy(ay,by)*ABz(az,bz) &
               + TWO*ABx(ax,bx)*NAy(ay,by)*ABz(az,bz) &
               + AB2x(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*AB2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*AB2z(az,bz) 
 
! I leave out the SO ints at the moment
!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)  
 
!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)  

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)  

      end

      ! Clean up
      rys.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      AB2z.destroy; AB2y.destroy; AB2x.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

      ! Include prefactor
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      ppZpp = prefac*ppZpp
!      SOx = prefac*SOx; SOy = prefac*SOy; SOz = prefac*SOz

   end

   make_DK3_ppZpp_ints(ppZpp,c)
   ! Make the Douglas-Kroll-Hess p2Zp2 integrals for teh DK3 hamiltonian 
   ! "c" is a given nuclear center.
      ppZpp :: MAT{REAL}
      c :: VEC{REAL}(3)

      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}*
      AB2x,AB2y,AB2z,A2x,A2y,A2z,B2x,B2y,B2z :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS*

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      ! the dimension ???  
      NAx.create(.a.l+3,.b.l+3); NAy.create(.a.l+3,.b.l+3); NAz.create(.a.l+3,.b.l+3)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      A2x.create(.a.l+1,.b.l+3); A2y.create(.a.l+1,.b.l+3); A2z.create(.a.l+1,.b.l+3)
      BBx.create(.a.l+3,.b.l+2); BBy.create(.a.l+3,.b.l+2); BBz.create(.a.l+3,.b.l+2)
      B2x.create(.a.l+3,.b.l+1); B2y.create(.a.l+3,.b.l+1); B2z.create(.a.l+3,.b.l+1)
      ABx.create(.a.l+2,.b.l+1); ABy.create(.a.l+2,.b.l+1); ABz.create(.a.l+2,.b.l+1)
      AB2x.create(.a.l+1,.b.l+1); AB2y.create(.a.l+1,.b.l+1); AB2z.create(.a.l+1,.b.l+1)

      ! Roots and weights
!      n_roots = (.a.l+.b.l+8)/2
      n_roots = (.a.l+.b.l+6)/2
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)

      ! Assemble the integrals
      ppZpp = ZERO
!      SOx = ZERO; SOy = ZERO; SOz = ZERO

      do k = 1,n_roots

         uu = p*rys.root(k)
         wt = rys.weight(k)

         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+2,.b.l+2)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+2,.b.l+2)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+2,.b.l+2)


         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)
         .differentiate(AAx,"left ",A2x)
         .differentiate(AAy,"left ",A2y)
         .differentiate(AAz,"left ",A2z)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)
         .differentiate(BBx,"right",B2x)
         .differentiate(BBy,"right",B2y)
         .differentiate(BBz,"right",B2z)

         .differentiate(B2x,"left",ABx) 
         .differentiate(B2y,"left",ABy)
         .differentiate(B2z,"left",ABz)

         .differentiate(ABx,"left",AB2x)
         .differentiate(ABy,"left",AB2y)
         .differentiate(ABz,"left",AB2z)

         NAz = NAz*wt
         A2z = A2z*wt
         B2z = B2z*wt
!         AAz = AAz*wt
!         BBz = BBz*wt
         AB2z = AB2z*wt

         ppZpp = ppZpp + A2x(ax,bx)*B2y(ay,by)*NAz(az,bz) &
               + B2x(ax,bx)*A2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*A2y(ay,by)*B2z(az,bz) &
               + NAx(ax,bx)*B2y(ay,by)*A2z(az,bz) &
               + A2x(ax,bx)*NAy(ay,by)*B2z(az,bz) &
               + B2x(ax,bx)*NAy(ay,by)*A2z(az,bz) &
               + AB2x(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*AB2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*AB2z(az,bz) 
 
! I leave out the SO ints at the moment
!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)  
 
!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)  

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)  

      end

      ! Clean up
      rys.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      AB2z.destroy; AB2y.destroy; AB2x.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      B2z.destroy; B2y.destroy; B2x.destroy
      A2z.destroy; A2y.destroy; A2x.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

      ! Include prefactor
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      ppZpp = prefac*ppZpp
!      SOx = prefac*SOx; SOy = prefac*SOy; SOz = prefac*SOz

   end

   make_spin_orbit_ints(Lx,Ly,Lz,c)
   ! Make the spin orbit integral matrices "Lx", "Ly", and "Lz" around nucleus
   ! "c".
   ! This integrals is for: (r - r_c) x nabla / |r - r_c|^3, with no minus sign
   ! on nabla.
   ! Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature.
      Lx,Ly,Lz :: MAT{REAL}
       c :: VEC{REAL}(3)
      NAx,NAy,NAz,AAx,AAy,AAz,BBx,BBy,BBz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      AAx_ab,AAy_ab,AAz_ab,BBx_ab,BBy_ab,BBz_ab :: REAL
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      NAx.create(.a.l+2,.b.l+2); NAy.create(.a.l+2,.b.l+2); NAz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+1); AAy.create(.a.l+1,.b.l+1); AAz.create(.a.l+1,.b.l+1)
      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)
      n_roots = (.a.l+.b.l+3)/2
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Lx = ZERO
      Ly = ZERO
      Lz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)
         NAz = NAz*wt
         .differentiate(NAx,"right",BBx) ! with respect to electron coordinates !
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)
         .differentiate(NAx,"left ",AAx) ! with respect to electron coordinates !
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)
!        The following loops can be simplified by the statement:
!        Lx = Lx + NAx(ax,bx)*(AAy(ay,by)*BBz(az,bz)-BBy(ay,by)*AAz(az,bz))
!        Ly = Ly + NAy(ay,by)*(AAz(az,bz)*BBx(ax,bx)-BBz(az,bz)*AAx(ax,bx))
!        Lz = Lz + NAz(az,bz)*(AAx(ax,bx)*BBy(ay,by)-BBx(ax,bx)*AAy(ay,by))
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             aix = ax(a)
             aiy = ay(a)
             aiz = az(a)
             AAx_ab = AAx(aix,bix)
             AAy_ab = AAy(aiy,biy)
             AAz_ab = AAz(aiz,biz)
             BBx_ab = BBx(aix,bix)
             BBy_ab = BBy(aiy,biy)
             BBz_ab = BBz(aiz,biz)
             Lx(a,b) = Lx(a,b) + NAx(aix,bix)*(AAy_ab*BBz_ab-BBy_ab*AAz_ab)
             Ly(a,b) = Ly(a,b) + NAy(aiy,biy)*(AAz_ab*BBx_ab-BBz_ab*AAx_ab)
             Lz(a,b) = Lz(a,b) + NAz(aiz,biz)*(AAx_ab*BBy_ab-BBx_ab*AAy_ab)
           end
         end
      end
      rys.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      Lx = prefac*Lx
      Ly = prefac*Ly
      Lz = prefac*Lz
   end

   make_E_field_ints(Ex,Ey,Ez,c)
   ! Make the electric field integral matrices "Ei" at position "c". If present,
   ! Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature.
      Ex,Ey,Ez :: MAT{REAL}
       c :: VEC{REAL}(3)
      Sx,Sy,Sz,Fx,Fy,Fz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      ! a,b,aix,aiy,aiz,bix,biy,biz :: INT
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Fx.create(.a.l+1,.b.l+1); Fy.create(.a.l+1,.b.l+1); Fz.create(.a.l+1,.b.l+1)
      n_roots = (.a.l+.b.l+3)/2 
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Ex = ZERO; Ey = ZERO; Ez = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_E_field_ints(Sx,Fx,1,uu,c(1))
         .make_E_field_ints(Sy,Fy,2,uu,c(2))
         .make_E_field_ints(Sz,Fz,3,uu,c(3))
         Sz = Sz*wt
         Fz = Fz*wt
         Ex = Ex + Fx(ax,bx)*Sy(ay,by)*Sz(az,bz)
         Ey = Ey + Sx(ax,bx)*Fy(ay,by)*Sz(az,bz)
         Ez = Ez + Sx(ax,bx)*Sy(ay,by)*Fz(az,bz)
!        do b=1,n_b
!          bix=bx(b)
!          biy=by(b)
!          biz=bz(b)
!          do a=1,n_a
!            aix=ax(a)
!            aiy=ay(a)
!            aiz=az(a)
!            Ex(a,b) = Ex(a,b) + Fx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
!            Ey(a,b) = Ey(a,b) + Sx(aix,bix)*Fy(aiy,biy)*Sz(aiz,biz)
!            Ez(a,b) = Ez(a,b) + Sx(aix,bix)*Sy(aiy,biy)*Fz(aiz,biz)
!          end
!        end
      end
      rys.destroy
      Fz.destroy; Fy.destroy; Fx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      Ex = prefac*Ex
      Ey = prefac*Ey
      Ez = prefac*Ez
   end

   make_E_field_ints(Sx,Fx,x,uu,cx,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", and the electric field integrals "Fx"
   ! for component "x", for a particular Rys-gaussian with exponent "uu", used
   ! in the decomposition of (c-r)/|c-r|^3 centred at position "cx". Uses
   ! Gauss-Hermite quadrature.
   ! If present, "max_a" and "max_b" indicate the l value to be used for
   ! gaussian a or b.
      Sx,Fx :: MAT{REAL}
       x :: INT
      uu,cx :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,r0,ff,pt,wt,ra,rb,ru :: REAL
      l_a,l_b,a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex + uu
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      r0 = (.a.ex*ax + .b.ex*bx + uu*cx)/p
      Sx = ZERO; Fx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+1)/2 ! should be max((a+b)/2,1) ?
         do k = first_pt(i),last_pt(i)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            ru = TWO*uu*(cx-pt)
            ff = ONE
            if(a>1) ff = ff*ra**(a-1)
            if(b>1) ff = ff*rb**(b-1)
            wt = gauss_hermite_wt(k)
            Sx(a,b) = Sx(a,b) + ff*wt
            Fx(a,b) = Fx(a,b) + ru*ff*wt
         end
      end
      end
   end

   make_E_gradient_ints(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)
   ! Make the electric field gradient integral matrices "Ei" at position "c".
   ! This does not contain the density contribution from the delta function.
   ! Uses Rys decomposition of 1/r_c and Gauss-Hermite quadrature.
      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}
      c :: VEC{REAL}(3)
      Sx,Sy,Sz,Fx,Fy,Fz,Gx,Gy,Gz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      ! a,b,aix,aiy,aiz,bix,biy,biz :: INT
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Fx.create(.a.l+1,.b.l+1); Fy.create(.a.l+1,.b.l+1); Fz.create(.a.l+1,.b.l+1)
      Gx.create(.a.l+1,.b.l+1); Gy.create(.a.l+1,.b.l+1); Gz.create(.a.l+1,.b.l+1)
      n_roots = (.a.l+.b.l+4)/2
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Exx = ZERO; Eyy = ZERO; Ezz = ZERO
      Exy = ZERO; Exz = ZERO; Eyz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_E_gradient_ints(Sx,Fx,Gx,1,uu,c(1))
         .make_E_gradient_ints(Sy,Fy,Gy,2,uu,c(2))
         .make_E_gradient_ints(Sz,Fz,Gz,3,uu,c(3))
         Sz = Sz*wt
         Fz = Fz*wt
         Gz = Gz*wt
         Exx = Exx + Gx(ax,bx)*Sy(ay,by)*Sz(az,bz)
         Eyy = Eyy + Sx(ax,bx)*Gy(ay,by)*Sz(az,bz)
         Ezz = Ezz + Sx(ax,bx)*Sy(ay,by)*Gz(az,bz)
         Exy = Exy - Fx(ax,bx)*Fy(ay,by)*Sz(az,bz) ! cancel the extra minus sign on Fy
         Exz = Exz - Fx(ax,bx)*Sy(ay,by)*Fz(az,bz)
         Eyz = Eyz - Sx(ax,bx)*Fy(ay,by)*Fz(az,bz)
!        do b=1,n_b
!          bix=bx(b)
!          biy=by(b)
!          biz=bz(b)
!          do a=1,n_a
!            aix=ax(a)
!            aiy=ay(a)
!            aiz=az(a)
!            Exx(a,b) = Exx(a,b) + Gx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
!            Eyy(a,b) = Eyy(a,b) + Sx(aix,bix)*Gy(aiy,biy)*Sz(aiz,biz)
!            Ezz(a,b) = Ezz(a,b) + Sx(aix,bix)*Sy(aiy,biy)*Gz(aiz,biz)
!            Exy(a,b) = Exy(a,b) + THREE*Fx(aix,bix)*Fy(aiy,biy)*Sz(aiz,biz)
!            Exz(a,b) = Exz(a,b) + THREE*Fx(aix,bix)*Sy(aiy,biy)*Fz(aiz,biz)
!            Eyz(a,b) = Eyz(a,b) + THREE*Sx(aix,bix)*Fy(aiy,biy)*Fz(aiz,biz)
!          end
!        end
      end
      rys.destroy
      Gz.destroy; Gy.destroy; Gx.destroy
      Fz.destroy; Fy.destroy; Fx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      Exx = prefac*Exx; Eyy = prefac*Eyy; Ezz = prefac*Ezz
      Exy = prefac*Exy; Exz = prefac*Exz; Eyz = prefac*Eyz
   end

   make_E_gradient_ints(Sx,Fx,Gx,x,uu,cx,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", and the electric field integrals "Fx",
   ! and the electric field gradient integral "Gx" for component "x", for a
   ! particular Rys-gaussian with exponent "uu", used in the decomposition of
   ! (c-r)/|c-r|^3 centred at position "cx". Uses Gauss-Hermite quadrature.
   ! If present, "max_a" and "max_b" indicate the l value to be used for
   ! gaussian a or b.
      Sx,Fx,Gx :: MAT{REAL}
       x :: INT
      uu,cx :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,r0,ff,pt,ra,rb,ru,rg :: REAL
      l_a,l_b,a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex + uu
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      r0 = (.a.ex*ax + .b.ex*bx + uu*cx)/p
      Sx = ZERO; Fx = ZERO; Gx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+2)/2 ! should be max((a+b)/2,1) ?
         do k = first_pt(i),last_pt(i)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            ru = TWO*uu*(cx-pt)          ! this is Ex = - d/dcx phi(c)
            rg = TWO*uu*(ONE-ru*(cx-pt)) ! this is dEx/dcx
            ff = gauss_hermite_wt(k)
            if(a>1) ff = ff*ra**(a-1)
            if(b>1) ff = ff*rb**(b-1) ! this is \int dx g(a;ax) g(b;bx) e^(-uu*(cx-r)^2)
            Sx(a,b) = Sx(a,b) + ff    ! integrand = 1
            Fx(a,b) = Fx(a,b) + ru*ff ! integrand = (cx-r)/|c-r|^3
            Gx(a,b) = Gx(a,b) + rg*ff ! integrand = 3*(cx-r)^2/|c-r|^5 - 1/|c-r|^3
         end
      end
      end
   end

   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)
   ! Make gauge modified (B field) spin orbit integral matrices "Qij" around
   ! nucleus "c".  using gauge origin "origin".  The integrals are:
   !    Qij(a,b) = <a| (r-o)_i (r-c)_j / |r-c|^3 |b>
   ! Uses Rys decomposition of 1/|r-c| and Gauss-Hermite quadrature.
      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}
      c,origin :: VEC{REAL}(3)
      Sx,Sy,Sz,Dx,Dy,Dz,Fx,Fy,Fz,Qx,Qy,Qz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      Dx.create(.a.l+1,.b.l+1); Dy.create(.a.l+1,.b.l+1); Dz.create(.a.l+1,.b.l+1)
      Fx.create(.a.l+1,.b.l+1); Fy.create(.a.l+1,.b.l+1); Fz.create(.a.l+1,.b.l+1)
      Qx.create(.a.l+1,.b.l+1); Qy.create(.a.l+1,.b.l+1); Qz.create(.a.l+1,.b.l+1)
      n_roots = (.a.l+.b.l+3)/2
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Qxx = ZERO; Qyx = ZERO; Qzx = ZERO
      Qxy = ZERO; Qyy = ZERO; Qzy = ZERO
      Qxz = ZERO; Qyz = ZERO; Qzz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_q_field_ints(Sx,Dx,Fx,Qx,1,uu,c(1),origin(1))
         .make_q_field_ints(Sy,Dy,Fy,Qy,2,uu,c(2),origin(2))
         .make_q_field_ints(Sz,Dz,Fz,Qz,3,uu,c(3),origin(3))
         Sz = Sz*wt; Dz = Dz*wt; Fz = Fz*wt; Qz = Qz*wt
!        The following loops can be simplified by the statements:
!        Qxx = Qxx + Qx(ax,bx)*Sy(ay,by)*Sz(az,bz)
!        Qyx = Qyx + Fx(ax,bx)*Dy(ay,by)*Sz(az,bz)
!        Qzx = Qzx + Fx(ax,bx)*Sy(ay,by)*Dz(az,bz)
!        Qxy = Qxy + Dx(ax,bx)*Fy(ay,by)*Sz(az,bz)
!        Qyy = Qyy + Sx(ax,bx)*Qy(ay,by)*Sz(az,bz)
!        Qzy = Qzy + Sx(ax,bx)*Fy(ay,by)*Dz(az,bz)
!        Qxz = Qxz + Dx(ax,bx)*Sy(ay,by)*Fz(az,bz)
!        Qyz = Qyz + Sx(ax,bx)*Dy(ay,by)*Fz(az,bz)
!        Qzz = Qzz + Sx(ax,bx)*Sy(ay,by)*Qz(az,bz)
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             aix = ax(a)
             aiy = ay(a)
             aiz = az(a)
             Qxx(a,b) = Qxx(a,b) + Qx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
             Qyx(a,b) = Qyx(a,b) + Fx(aix,bix)*Dy(aiy,biy)*Sz(aiz,biz)
             Qzx(a,b) = Qzx(a,b) + Fx(aix,bix)*Sy(aiy,biy)*Dz(aiz,biz)
             Qxy(a,b) = Qxy(a,b) + Dx(aix,bix)*Fy(aiy,biy)*Sz(aiz,biz)
             Qyy(a,b) = Qyy(a,b) + Sx(aix,bix)*Qy(aiy,biy)*Sz(aiz,biz)
             Qzy(a,b) = Qzy(a,b) + Sx(aix,bix)*Fy(aiy,biy)*Dz(aiz,biz)
             Qxz(a,b) = Qxz(a,b) + Dx(aix,bix)*Sy(aiy,biy)*Fz(aiz,biz)
             Qyz(a,b) = Qyz(a,b) + Sx(aix,bix)*Dy(aiy,biy)*Fz(aiz,biz)
             Qzz(a,b) = Qzz(a,b) + Sx(aix,bix)*Sy(aiy,biy)*Qz(aiz,biz)
           end
         end
      end
      rys.destroy
      Qz.destroy; Qy.destroy; Qx.destroy
      Fz.destroy; Fy.destroy; Fx.destroy
      Dz.destroy; Dy.destroy; Dx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      Qxx = prefac*Qxx; Qyx = prefac*Qyx; Qzx = prefac*Qzx
      Qxy = prefac*Qxy; Qyy = prefac*Qyy; Qzy = prefac*Qzy
      Qxz = prefac*Qxz; Qyz = prefac*Qyz; Qzz = prefac*Qzz
   end

   make_q_field_ints(Sx,Dx,Fx,Qx,x,uu,cx,ox,max_a,max_b)
   ! Make the 1-D overlap integrals "Sx", dipole integrals "Dx", electric field
   ! integrals "Fx", and the dipole-electric field integrals "Qx" for component
   ! "x". "uu" is the Rys-gaussian exponent used in the decomposition of
   ! (c-r)/|c-r|^3 centred at position "cx".
   ! "ox" is the origin for the dipole terms. If present, "max_a" and "max_b"
   ! override the l value for gaussian a or b. Uses Gauss-Hermite quadrature.
      Sx,Dx,Fx,Qx :: MAT{REAL}
       x :: INT
      uu,cx,ox :: REAL
      max_a,max_b :: INT, optional
      p,t,ax,bx,r0,wt,pt,ra,rb,ru,rd :: REAL
      l_a,l_b,a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
      p = .a.ex + .b.ex + uu
      t = sqrt(p)
      ax = .a.pos(x)
      bx = .b.pos(x)
      r0 = (.a.ex*ax + .b.ex*bx + uu*cx)/p
      Sx = ZERO; Dx = ZERO; Fx = ZERO; Qx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         i = (a+b+2)/2 ! should be max((a+b+1)/2,1) ?
         do k = first_pt(i),last_pt(i)
            wt = gauss_hermite_wt(k)
            pt = gauss_hermite_pt(k)/t + r0
            ra = pt - ax
            rb = pt - bx
            ru = TWO*uu*(cx-pt)
            rd = pt - ox
            if(a>1) wt = wt*ra**(a-1)
            if(b>1) wt = wt*rb**(b-1)
            Sx(a,b) = Sx(a,b) + wt
            Dx(a,b) = Dx(a,b) + rd*wt
            Fx(a,b) = Fx(a,b) + ru*wt
            Qx(a,b) = Qx(a,b) + ru*rd*wt
         end
      end
      end
   end

   make_L_ints(Lx,Ly,Lz,origin)
   ! Make the angular momentum integral matrices "Lx", "Ly", and "Lz".
   ! The integrals are for (r x nabla) with *no* minus sign on nabla.
   ! "origin" is the gauge origin for the integrals.
   ! Uses Gauss-Hermite quadrature.
      Lx,Ly,Lz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      Sx,Sy,Sz,Rx,Ry,Rz,Dx,Dy,Dz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      Dx_ab,Dy_ab,Dz_ab,Rx_ab,Ry_ab,Rz_ab :: REAL
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+2); Sy.create(.a.l+1,.b.l+2); Sz.create(.a.l+1,.b.l+2)
      Rx.create(.a.l+1,.b.l+2); Ry.create(.a.l+1,.b.l+2); Rz.create(.a.l+1,.b.l+2)
      Dx.create(.a.l+1,.b.l+1); Dy.create(.a.l+1,.b.l+1); Dz.create(.a.l+1,.b.l+1)
      .make_dipole_ints(Sx,Rx,1,origin(1),max_b=.b.l+1)
      .make_dipole_ints(Sy,Ry,2,origin(2),max_b=.b.l+1)
      .make_dipole_ints(Sz,Rz,3,origin(3),max_b=.b.l+1)
      .differentiate(Sx,"right",Dx)
      .differentiate(Sy,"right",Dy)
      .differentiate(Sz,"right",Dz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          Dx_ab = Dx(aix,bix)
          Dy_ab = Dx(aiy,biy)
          Dz_ab = Dx(aiz,biz)
          Rx_ab = Rx(aix,bix)
          Ry_ab = Rx(aiy,biy)
          Rz_ab = Rx(aiz,biz)
          Lx(a,b) = Sx(aix,bix)*(Ry_ab*Dz_ab-Dy_ab*Rz_ab)
          Ly(a,b) = Sy(aiy,biy)*(Rz_ab*Dx_ab-Dz_ab*Rx_ab)
          Lz(a,b) = Sz(aiz,biz)*(Rx_ab*Dy_ab-Dx_ab*Ry_ab)
!      Lx = Sx(ax,bx)*(Ry(ay,by)*Dz(az,bz)-Dy(ay,by)*Rz(az,bz))
!      Ly = Sy(ay,by)*(Rz(az,bz)*Dx(ax,bx)-Dz(az,bz)*Rx(ax,bx))
!      Lz = Sz(az,bz)*(Rx(ax,bx)*Dy(ay,by)-Dx(ax,bx)*Ry(ay,by))
        end
      end
      Dz.destroy; Dy.destroy; Dx.destroy
      Rz.destroy; Ry.destroy; Rx.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      p = .a.ex + .b.ex
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
      Lx = prefac*Lx
      Ly = prefac*Ly
      Lz = prefac*Lz
   end

   differentiate(I,index,D)
   ! Differentiate a gaussian-integral matrix "I" with respect to the
   ! *electron* coordinate on basis function "index", which can be "left"
   ! or "right". Place the result in "D".
      I,D :: MAT{REAL}
      index :: STR
      i_a,i_b,d_a,d_b,a,b :: INT
      a2,b2 :: REAL
      i_a = ubound(I,1); i_b = ubound(I,2)
      d_a = ubound(D,1); d_b = ubound(D,2)
      D = ZERO
      select case (index)
         case("l","left")
            ENSURE(i_a>1,   "I array too small to differentiate")
            ENSURE(i_a>d_a, "I and D arrays are incompatible")
            ENSURE(i_b>=d_b,"I and D arrays are incompatible")
            a2 = TWO*.a.ex
            D(1,:) = -a2*I(2  ,1:d_b)
            do a = 2,d_a
            D(a,:) = -a2*I(a+1,1:d_b) + (a-1)*I(a-1,1:d_b)
            end
         case("r","right")
            ENSURE(i_b>1,   "I array too small to differentiate")
            ENSURE(i_b>d_b, "I and D arrays are incompatible")
            ENSURE(i_a>=d_a,"I and D arrays are incompatible")
            b2 = TWO*.b.ex
            D(:,1) = -b2*I(1:d_a,2  )
            do b = 2,d_b
            D(:,b) = -b2*I(1:d_a,b+1) + (b-1)*I(1:d_a,b-1)
            end
      end
   end

   make_magnetic_jp_ints(Jx,Jy,Jz,c)
   ! Make the magnetic Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = \int dr [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! These are used to get the magnetic field from the paramegnetic current
   ! density,
   !      B(c) = ( mu_o / 4 pi ) \int dr J(r) x (c - r)/|c - r|^3
   ! Note: in atomic units mu_o = 4 pi / c^2.
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      Jx,Jy,Jz :: MAT{REAL}
       c :: VEC{REAL}(3)
      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxmm,Symm,Szmm :: MAT{REAL}*
      Fx00,Fy00,Fz00 :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxmm.create(.a.l+1,.b.l+1); Symm.create(.a.l+1,.b.l+1); Szmm.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      n_roots = (.a.l+.b.l+2)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+1,.b.l+1)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+1,.b.l+1)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+1,.b.l+1)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         Sxmm = Sx01 - Sx10
         Symm = Sy01 - Sy10
         Szmm = Sz01 - Sz10
         Szmm = Szmm*wt
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             aix = ax(a)
             aiy = ay(a)
             aiz = az(a)
             Jx(a,b) = Jx(a,b) + Sx00(aix,bix) * &
                     (Symm(aiy,biy)*Fz00(aiz,biz) - Fy00(aiy,biy)*Szmm(aiz,biz))
             Jy(a,b) = Jy(a,b) + Sy00(aiy,biy) * &
                     (Fx00(aix,bix)*Szmm(aiz,biz) - Sxmm(aix,bix)*Fz00(aiz,biz))
             Jz(a,b) = Jz(a,b) + Sz00(aiz,biz) * &
                     (Sxmm(aix,bix)*Fy00(aiy,biy) - Fx00(aix,bix)*Symm(aiy,biy))
           end
         end
!         Jx = Jx + Sx00(ax,bx)*Symm(ay,by)*Fz00(az,bz) &
!                 - Sx00(ax,bx)*Fy00(ay,by)*Szmm(az,bz)
!         Jy = Jy + Fx00(ax,bx)*Sy00(ay,by)*Szmm(az,bz) &
!                 - Sxmm(ax,bx)*Sy00(ay,by)*Fz00(az,bz)
!         Jz = Jz + Sxmm(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
!                 - Fx00(ax,bx)*Symm(ay,by)*Sz00(az,bz)
      end
      rys.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,c)
   ! Make the magnetic spin density integrals "Mij", evaluated at point "c",
   !    <a|Mij(c)|b> = \int dr grad_i ( g_a(r) g_b(r) ) (c - r)_j/ |c - r|^3
   ! These are used to get the magnetic field from the spin density,
   !      B(c) = -(g mu_b mu_o / 4 pi)
   !             \int dr curl rho_spin(r) x (c - r)/|c - r|3
   ! Note: in atomic units mu_o = 4 pi / c^2.
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz :: MAT{REAL}
      c :: VEC{REAL}(3)
      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp :: MAT{REAL}*
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      n_roots = (.a.l+.b.l+2)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Mxx = ZERO; Mxy = ZERO; Mxz = ZERO
      Myx = ZERO; Myy = ZERO; Myz = ZERO
      Mzx = ZERO; Mzy = ZERO; Mzz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+1,.b.l+1)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+1,.b.l+1)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+1,.b.l+1)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)
         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10
         Mxx = Mxx + Fxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz) ! x has pp
         Mxy = Mxy + Sxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)
         Mxz = Mxz + Sxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)
         Myx = Myx + Fx00(ax,bx)*Sypp(ay,by)*Sz00(az,bz) ! y has pp
         Myy = Myy + Sx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz)
         Myz = Myz + Sx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz)
         Mzx = Mzx + Fx00(ax,bx)*Sy00(ay,by)*Szpp(az,bz) ! z has pp
         Mzy = Mzy + Sx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz)
         Mzz = Mzz + Sx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz)
      end
      rys.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      Mxx = prefac*Mxx; Mxy = prefac*Mxy; Mxz = prefac*Mxz
      Myx = prefac*Myx; Myy = prefac*Myy; Myz = prefac*Myz
      Mzx = prefac*Mzx; Mzy = prefac*Mzy; Mzz = prefac*Mzz
   end

   make_magnetic_S_ints(M,c)
   ! Make the magnetic spin density integrals "Mij", evaluated at point "c",
   !    <a|Mij(c)|b> = \int dr grad_i ( g_a(r) g_b(r) ) (c - r)_j/ |c - r|^3
   ! These are used to get the magnetic field from the spin density,
   !      B(c) = -(g mu_b mu_o / 4 pi)
   !             \int dr curl rho_spin(r) x (c - r)/|c - r|3
   ! Note: in atomic units mu_o = 4 pi / c^2.
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      M :: MAT4{REAL}
      c :: VEC{REAL}(3)
      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp :: MAT{REAL}*
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,fa,la,fb,lb :: INT
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      n_roots = (.a.l+.b.l+2)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      M = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+1,.b.l+1)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+1,.b.l+1)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+1,.b.l+1)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)
         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10
         M(:,:,1,1) = M(:,:,1,1) + Fxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz) ! x has pp
         M(:,:,1,2) = M(:,:,1,2) + Sxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)
         M(:,:,1,3) = M(:,:,1,2) + Sxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)
         M(:,:,2,1) = M(:,:,2,1) + Fx00(ax,bx)*Sypp(ay,by)*Sz00(az,bz) ! y has pp
         M(:,:,2,2) = M(:,:,2,2) + Sx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz)
         M(:,:,2,3) = M(:,:,2,3) + Sx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz)
         M(:,:,3,1) = M(:,:,3,1) + Fx00(ax,bx)*Sy00(ay,by)*Szpp(az,bz) ! z has pp
         M(:,:,3,2) = M(:,:,3,2) + Sx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz)
         M(:,:,3,3) = M(:,:,3,3) + Sx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz)
      end
      rys.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/p
      M = prefac*M
   end

   make_solenoidal_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr curl [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      Jx,Jy,Jz :: MAT{REAL}
      c :: VEC{REAL}(3)
      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp,Sxmm,Symm,Szmm :: MAT{REAL}*
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp,Fxmm,Fymm,Fzmm :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      Sx00_ab,Sy00_ab,Sz00_ab,Sxpp_ab,Sypp_ab,Szpp_ab :: REAL
      Fxpp_ab,Fypp_ab,Fzpp_ab :: REAL
      Sxmm_ab,Symm_ab,Szmm_ab,Fxmm_ab,Fymm_ab,Fzmm_ab :: REAL
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Sxmm.create(.a.l+1,.b.l+1); Symm.create(.a.l+1,.b.l+1); Szmm.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)
      Fxmm.create(.a.l+1,.b.l+1); Fymm.create(.a.l+1,.b.l+1); Fzmm.create(.a.l+1,.b.l+1)
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      n_roots = (.a.l+.b.l+2)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+1,.b.l+1)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+1,.b.l+1)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+1,.b.l+1)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)
         Sxpp = Sx01 + Sx10; Sxmm = Sx01 - Sx10
         Sypp = Sy01 + Sy10; Symm = Sy01 - Sy10
         Szpp = Sz01 + Sz10; Szmm = Sz01 - Sz10
         Fxpp = Fx01 + Fx10; Fxmm = Fx01 - Fx10
         Fypp = Fy01 + Fy10; Fymm = Fy01 - Fy10
         Fzpp = Fz01 + Fz10; Fzmm = Fz01 - Fz10
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             aix = ax(a)
             aiy = ay(a)
             aiz = az(a)
             Sx00_ab = Sx00(aix,bix)
             Sy00_ab = Sy00(aiy,biy)
             Sz00_ab = Sz00(aiz,biz)
             Sxpp_ab = Sxpp(aix,bix)
             Sypp_ab = Sypp(aiy,biy)
             Szpp_ab = Szpp(aiz,biz)
             Fxpp_ab = Fxpp(aix,bix)
             Fypp_ab = Fypp(aiy,biy)
             Fzpp_ab = Fzpp(aiz,biz)
             Sxmm_ab = Sxmm(aix,bix)
             Symm_ab = Symm(aiy,biy)
             Szmm_ab = Szmm(aiz,biz)
             Fxmm_ab = Fxmm(aix,bix)
             Fymm_ab = Fymm(aiy,biy)
             Fzmm_ab = Fzmm(aiz,biz)
             Jx(a,b) = Jx(a,b) &
                + Sxmm_ab*Sy00_ab*Fzpp_ab &
                - Sxpp_ab*Sy00_ab*Fzmm_ab &
                - Sxpp_ab*Fymm_ab*Sz00_ab &
                + Sxmm_ab*Fypp_ab*Sz00_ab
             Jy(a,b) = Jy(a,b) &
                + Fxpp_ab*Symm_ab*Sz00_ab &
                - Fxmm_ab*Sypp_ab*Sz00_ab &
                - Sx00_ab*Sypp_ab*Fzmm_ab &
                + Sx00_ab*Symm_ab*Fzpp_ab
             Jz(a,b) = Jz(a,b) &
                + Sx00_ab*Fypp_ab*Szmm_ab &
                - Sx00_ab*Fymm_ab*Szpp_ab &
                - Fxmm_ab*Sy00_ab*Szpp_ab &
                + Fxpp_ab*Sy00_ab*Szmm_ab
           end
         end
!         Jx = Jx &
!            + Sxmm(ax,bx)*Sy00(ay,by)*Fzpp(az,bz) &
!            - Sxpp(ax,bx)*Sy00(ay,by)*Fzmm(az,bz) &
!            - Sxpp(ax,bx)*Fymm(ay,by)*Sz00(az,bz) &
!            + Sxmm(ax,bx)*Fypp(ay,by)*Sz00(az,bz)
!         Jy = Jy &
!            + Fxpp(ax,bx)*Symm(ay,by)*Sz00(az,bz) &
!            - Fxmm(ax,bx)*Sypp(ay,by)*Sz00(az,bz) &
!            - Sx00(ax,bx)*Sypp(ay,by)*Fzmm(az,bz) &
!            + Sx00(ax,bx)*Symm(ay,by)*Fzpp(az,bz)
!         Jz = Jz &
!            + Sx00(ax,bx)*Fypp(ay,by)*Szmm(az,bz) &
!            - Sx00(ax,bx)*Fymm(ay,by)*Szpp(az,bz) &
!            - Fxmm(ax,bx)*Sy00(ay,by)*Szpp(az,bz) &
!            + Fxpp(ax,bx)*Sy00(ay,by)*Szmm(az,bz)
      end
      rys.destroy
      Fzmm.destroy; Fymm.destroy; Fxmm.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   make_solenoidal_jd_ints(Jx,Jy,Jz,B_field,origin,c)
   ! Make the solenoidal Jd integrals "Ji", with external magnetic field
   ! "B_field", gauge origin "origin",evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr (curl J^d_ab(r)) x (c - r)/ |c - r|^3
   !     curl J^d_ab(r) = B (2 g_a(r)g_b(r) + (r-r_o).grad g_a(r)g_b(r))
   !                      - (r-r_o)(B.grad g_a(r)g_b(r))
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      Jx,Jy,Jz :: MAT{REAL}
      B_field,origin,c :: VEC{REAL}(3)
      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxpp,Sypp,Szpp :: MAT{REAL}*
      Dx00,Dy00,Dz00,Dx10,Dy10,Dz10,Dx01,Dy01,Dz01,Dxpp,Dypp,Dzpp :: MAT{REAL}*
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxpp,Fypp,Fzpp :: MAT{REAL}*
      Qx00,Qy00,Qz00,Qx10,Qy10,Qz10,Qx01,Qy01,Qz01,Qxpp,Qypp,Qzpp :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac,B_x,B_y,B_z :: REAL
      n_roots,k,a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      rys :: RYS*
      Sx00_ab,Sy00_ab,Sz00_ab,Fx00_ab,Fy00_ab,Fz00_ab :: REAL
      Dx00_ab,Dy00_ab,Dz00_ab :: REAL
      Sxpp_ab,Sypp_ab,Szpp_ab,Fxpp_ab,Fypp_ab,Fzpp_ab :: REAL
      Dxpp_ab,Dypp_ab,Dzpp_ab,Qxpp_ab,Qypp_ab,Qzpp_ab :: REAL
      B_x = B_field(1)
      B_y = B_field(2)
      B_z = B_field(3)
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Dx00.create(.a.l+2,.b.l+2); Dy00.create(.a.l+2,.b.l+2); Dz00.create(.a.l+2,.b.l+2)
      Dx10.create(.a.l+1,.b.l+1); Dy10.create(.a.l+1,.b.l+1); Dz10.create(.a.l+1,.b.l+1)
      Dx01.create(.a.l+1,.b.l+1); Dy01.create(.a.l+1,.b.l+1); Dz01.create(.a.l+1,.b.l+1)
      Dxpp.create(.a.l+1,.b.l+1); Dypp.create(.a.l+1,.b.l+1); Dzpp.create(.a.l+1,.b.l+1)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)
      Qx00.create(.a.l+2,.b.l+2); Qy00.create(.a.l+2,.b.l+2); Qz00.create(.a.l+2,.b.l+2)
      Qx10.create(.a.l+1,.b.l+1); Qy10.create(.a.l+1,.b.l+1); Qz10.create(.a.l+1,.b.l+1)
      Qx01.create(.a.l+1,.b.l+1); Qy01.create(.a.l+1,.b.l+1); Qz01.create(.a.l+1,.b.l+1)
      Qxpp.create(.a.l+1,.b.l+1); Qypp.create(.a.l+1,.b.l+1); Qzpp.create(.a.l+1,.b.l+1)
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      n_roots = (.a.l+.b.l+3)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_q_field_ints(Sx00,Dx00,Fx00,Qx00,1,uu,c(1),origin(1),.a.l+1,.b.l+1)
         .make_q_field_ints(Sy00,Dy00,Fy00,Qy00,2,uu,c(2),origin(2),.a.l+1,.b.l+1)
         .make_q_field_ints(Sz00,Dz00,Fz00,Qz00,3,uu,c(3),origin(3),.a.l+1,.b.l+1)
         Sz00 =  Sz00*wt
         Dz00 =  Dz00*wt
         Fx00 = -Fx00     ! minus sign to give (c-r) instead of (r-c)
         Fy00 = -Fy00
         Fz00 = -Fz00*wt
         Qx00 = -Qx00
         Qy00 = -Qy00
         Qz00 = -Qz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Dx00,"left",Dx10); .differentiate(Dx00,"right",Dx01)
         .differentiate(Dy00,"left",Dy10); .differentiate(Dy00,"right",Dy01)
         .differentiate(Dz00,"left",Dz10); .differentiate(Dz00,"right",Dz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)
         .differentiate(Qx00,"left",Qx10); .differentiate(Qx00,"right",Qx01)
         .differentiate(Qy00,"left",Qy10); .differentiate(Qy00,"right",Qy01)
         .differentiate(Qz00,"left",Qz10); .differentiate(Qz00,"right",Qz01)
         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Dxpp = Dx01 + Dx10
         Dypp = Dy01 + Dy10
         Dzpp = Dz01 + Dz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10
         Qxpp = Qx01 + Qx10
         Qypp = Qy01 + Qy10
         Qzpp = Qz01 + Qz10
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             aix = ax(a)
             aiy = ay(a)
             aiz = az(a)
             Sx00_ab = Sx00(aix,bix)
             Sy00_ab = Sy00(aiy,biy)
             Sz00_ab = Sz00(aiz,biz)
             Fx00_ab = Fx00(aix,bix)
             Fy00_ab = Fy00(aiy,biy)
             Fz00_ab = Fz00(aiz,biz)
             Sxpp_ab = Sxpp(aix,bix)
             Sypp_ab = Sypp(aiy,biy)
             Szpp_ab = Szpp(aiz,biz)
             Fxpp_ab = Fxpp(aix,bix)
             Fypp_ab = Fypp(aiy,biy)
             Fzpp_ab = Fzpp(aiz,biz)
             Dx00_ab = Dx00(aix,bix)
             Dy00_ab = Dy00(aiy,biy)
             Dz00_ab = Dz00(aiz,biz)
             Dxpp_ab = Dxpp(aix,bix)
             Dypp_ab = Dypp(aiy,biy)
             Dzpp_ab = Dzpp(aiz,biz)
             Qxpp_ab = Qxpp(aix,bix)
             Qypp_ab = Qypp(aiy,biy)
             Qzpp_ab = Qzpp(aiz,biz)
             Jx(a,b) = Jx(a,b) &
              + B_y*( TWO*Sx00_ab*Sy00_ab*Fz00_ab &
              + Dxpp_ab*Sy00_ab*Fz00_ab  &
              + Sx00_ab*Dypp_ab*Fz00_ab  &
              + Sx00_ab*Sy00_ab*Qzpp_ab) &
              - B_z*( TWO*Sx00_ab*Fy00_ab*Sz00_ab &
              + Dxpp_ab*Fy00_ab*Sz00_ab  &
              + Sx00_ab*Qypp_ab*Sz00_ab  &
              + Sx00_ab*Fy00_ab*Dzpp_ab) &
              - B_x*(Sxpp_ab*Dy00_ab*Fz00_ab - Sxpp_ab*Fy00_ab*Dz00_ab) &
              - B_y*(Sx00_ab*Dypp_ab*Fz00_ab - Sx00_ab*Fypp_ab*Dz00_ab) &
              - B_z*(Sx00_ab*Dy00_ab*Fzpp_ab - Sx00_ab*Fy00_ab*Dzpp_ab)
             Jy(a,b) = Jy(a,b) &
              + B_z*( TWO*Fx00_ab*Sy00_ab*Sz00_ab &
              + Qxpp_ab*Sy00_ab*Sz00_ab  &
              + Fx00_ab*Dypp_ab*Sz00_ab  &
              + Fx00_ab*Sy00_ab*Dzpp_ab) &
              - B_x*( TWO*Sx00_ab*Sy00_ab*Fz00_ab &
              + Dxpp_ab*Sy00_ab*Fz00_ab  &
              + Sx00_ab*Dypp_ab*Fz00_ab  &
              + Sx00_ab*Sy00_ab*Qzpp_ab) &
              - B_x*(Fxpp_ab*Sy00_ab*Dz00_ab - Dxpp_ab*Sy00_ab*Fz00_ab) &
              - B_y*(Fx00_ab*Sypp_ab*Dz00_ab - Dx00_ab*Sypp_ab*Fz00_ab) &
              - B_z*(Fx00_ab*Sy00_ab*Dzpp_ab - Dx00_ab*Sy00_ab*Fzpp_ab)
             Jz(a,b) = Jz(a,b) &
              + B_x*( TWO*Sx00_ab*Fy00_ab*Sz00_ab &
              + Dxpp_ab*Fy00_ab*Sz00_ab  &
              + Sx00_ab*Qypp_ab*Sz00_ab  &
              + Sx00_ab*Fy00_ab*Dzpp_ab) &
              - B_y*( TWO*Fx00_ab*Sy00_ab*Sz00_ab &
              + Qxpp_ab*Sy00_ab*Sz00_ab  &
              + Fx00_ab*Dypp_ab*Sz00_ab  &
              + Fx00_ab*Sy00_ab*Dzpp_ab) &
              - B_x*(Dxpp_ab*Fy00_ab*Sz00_ab - Fxpp_ab*Dy00_ab*Sz00_ab) &
              - B_y*(Dx00_ab*Fypp_ab*Sz00_ab - Fx00_ab*Dypp_ab*Sz00_ab) &
              - B_z*(Dx00_ab*Fy00_ab*Szpp_ab - Fx00_ab*Dy00_ab*Szpp_ab)
           end
         end
!         Jx = Jx &
!          + B_field(2)*( TWO*Sx00(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
!          + Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)  &
!          + Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz)  &
!          + Sx00(ax,bx)*Sy00(ay,by)*Qzpp(az,bz)) &
!          - B_field(3)*( TWO*Sx00(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
!          + Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)  &
!          + Sx00(ax,bx)*Qypp(ay,by)*Sz00(az,bz)  &
!          + Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz)) &
!          - B_field(1)*(Sxpp(ax,bx)*Dy00(ay,by)*Fz00(az,bz) - Sxpp(ax,bx)*Fy00(ay,by)*Dz00(az,bz)) &
!          - B_field(2)*(Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz) - Sx00(ax,bx)*Fypp(ay,by)*Dz00(az,bz)) &
!          - B_field(3)*(Sx00(ax,bx)*Dy00(ay,by)*Fzpp(az,bz) - Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz))
!         Jy = Jy &
!          + B_field(3)*( TWO*Fx00(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
!          + Qxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz)  &
!          + Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)  &
!          + Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz)) &
!          - B_field(1)*( TWO*Sx00(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
!          + Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)  &
!          + Sx00(ax,bx)*Dypp(ay,by)*Fz00(az,bz)  &
!          + Sx00(ax,bx)*Sy00(ay,by)*Qzpp(az,bz)) &
!          - B_field(1)*(Fxpp(ax,bx)*Sy00(ay,by)*Dz00(az,bz) - Dxpp(ax,bx)*Sy00(ay,by)*Fz00(az,bz)) &
!          - B_field(2)*(Fx00(ax,bx)*Sypp(ay,by)*Dz00(az,bz) - Dx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz)) &
!          - B_field(3)*(Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz) - Dx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz))
!         Jz = Jz &
!          + B_field(1)*( TWO*Sx00(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
!          + Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz)  &
!          + Sx00(ax,bx)*Qypp(ay,by)*Sz00(az,bz)  &
!          + Sx00(ax,bx)*Fy00(ay,by)*Dzpp(az,bz)) &
!          - B_field(2)*( TWO*Fx00(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
!          + Qxpp(ax,bx)*Sy00(ay,by)*Sz00(az,bz)  &
!          + Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)  &
!          + Fx00(ax,bx)*Sy00(ay,by)*Dzpp(az,bz)) &
!          - B_field(1)*(Dxpp(ax,bx)*Fy00(ay,by)*Sz00(az,bz) - Fxpp(ax,bx)*Dy00(ay,by)*Sz00(az,bz)) &
!          - B_field(2)*(Dx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz) - Fx00(ax,bx)*Dypp(ay,by)*Sz00(az,bz)) &
!          - B_field(3)*(Dx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz) - Fx00(ax,bx)*Dy00(ay,by)*Szpp(az,bz))
      end
      rys.destroy
      Qzpp.destroy; Qypp.destroy; Qxpp.destroy
      Qz01.destroy; Qy01.destroy; Qx01.destroy
      Qz10.destroy; Qy10.destroy; Qx10.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Qzpp.destroy; Qypp.destroy; Qxpp.destroy
      Qz01.destroy; Qy01.destroy; Qx01.destroy
      Qz10.destroy; Qy10.destroy; Qx10.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   make_irrotational_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal Jp integrals "Ji", evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr curl [g_a grad g_b - g_b grad g_a] x (c - r)/ |c - r|^3
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      Jx,Jy,Jz :: MAT{REAL}
       c :: VEC{REAL}(3)
      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01,Sxmm,Symm,Szmm :: MAT{REAL}*
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01,Fxmm,Fymm,Fzmm :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac :: REAL
      n_roots,k,a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      Sx00_ab,Sy00_ab,Sz00_ab,Fx00_ab,Fy00_ab,Fz00_ab :: REAL
      Sxmm_ab,Symm_ab,Szmm_ab,Fxmm_ab,Fymm_ab,Fzmm_ab :: REAL
      rys :: RYS*
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx00.create(.a.l+3,.b.l+3); Sy00.create(.a.l+3,.b.l+3); Sz00.create(.a.l+3,.b.l+3)
      Sx10.create(.a.l+2,.b.l+2); Sy10.create(.a.l+2,.b.l+2); Sz10.create(.a.l+2,.b.l+2)
      Sx01.create(.a.l+2,.b.l+2); Sy01.create(.a.l+2,.b.l+2); Sz01.create(.a.l+2,.b.l+2)
      Sxmm.create(.a.l+2,.b.l+2); Symm.create(.a.l+2,.b.l+2); Szmm.create(.a.l+2,.b.l+2)
      Fx00.create(.a.l+3,.b.l+3); Fy00.create(.a.l+3,.b.l+3); Fz00.create(.a.l+3,.b.l+3)
      Fx10.create(.a.l+2,.b.l+2); Fy10.create(.a.l+2,.b.l+2); Fz10.create(.a.l+2,.b.l+2)
      Fx01.create(.a.l+2,.b.l+2); Fy01.create(.a.l+2,.b.l+2); Fz01.create(.a.l+2,.b.l+2)
      Fxmm.create(.a.l+2,.b.l+2); Fymm.create(.a.l+2,.b.l+2); Fzmm.create(.a.l+2,.b.l+2)
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      n_roots = (.a.l+.b.l+3)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_E_field_ints(Sx00,Fx00,1,uu,c(1),.a.l+2,.b.l+2)
         .make_E_field_ints(Sy00,Fy00,2,uu,c(2),.a.l+2,.b.l+2)
         .make_E_field_ints(Sz00,Fz00,3,uu,c(3),.a.l+2,.b.l+2)
         Sz00 =  Sz00*wt
         Fz00 =  Fz00*wt
         .differentiate(Sx00,"right",Sx01); .differentiate(Sx01,"right",Sxmm)
         .differentiate(Sx00,"left" ,Sx10); .differentiate(Sx10,"left" ,Sx01)
         .differentiate(Sy00,"right",Sy01); .differentiate(Sy01,"right",Symm)
         .differentiate(Sy00,"left" ,Sy10); .differentiate(Sy10,"left" ,Sy01)
         .differentiate(Sz00,"right",Sz01); .differentiate(Sz01,"right",Szmm)
         .differentiate(Sz00,"left" ,Sz10); .differentiate(Sz10,"left" ,Sz01)
         .differentiate(Fx00,"right",Fx01); .differentiate(Fx01,"right",Fxmm)
         .differentiate(Fx00,"left" ,Fx10); .differentiate(Fx10,"left" ,Fx01)
         .differentiate(Fy00,"right",Fy01); .differentiate(Fy01,"right",Fymm)
         .differentiate(Fy00,"left" ,Fy10); .differentiate(Fy10,"left" ,Fy01)
         .differentiate(Fz00,"right",Fz01); .differentiate(Fz01,"right",Fzmm)
         .differentiate(Fz00,"left" ,Fz10); .differentiate(Fz10,"left" ,Fz01)
         Sxmm = Sxmm - Sx01
         Symm = Symm - Sy01
         Szmm = Szmm - Sz01
         Fxmm = Fxmm - Fx01
         Fymm = Fymm - Fy01
         Fzmm = Fzmm - Fz01
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             aix = ax(a)
             aiy = ay(a)
             aiz = az(a)
             Sx00_ab = Sx00(aix,bix)
             Sy00_ab = Sy00(aiy,biy)
             Sz00_ab = Sz00(aiz,biz)
             Fx00_ab = Fx00(aix,bix)
             Fy00_ab = Fy00(aiy,biy)
             Fz00_ab = Fz00(aiz,biz)
             Sxmm_ab = Sxmm(aix,bix)
             Symm_ab = Symm(aiy,biy)
             Szmm_ab = Szmm(aiz,biz)
             Fxmm_ab = Fxmm(aix,bix)
             Fymm_ab = Fymm(aiy,biy)
             Fzmm_ab = Fzmm(aiz,biz)
             Jx(a,b) = Jx(a,b) + Fxmm_ab*Sy00_ab*Sz00_ab &
                               + Fx00_ab*Symm_ab*Sz00_ab &
                               + Fx00_ab*Sy00_ab*Szmm_ab
             Jy(a,b) = Jy(a,b) + Sxmm_ab*Fy00_ab*Sz00_ab &
                               + Sx00_ab*Fymm_ab*Sz00_ab &
                               + Sx00_ab*Fy00_ab*Szmm_ab
             Jz(a,b) = Jz(a,b) + Sxmm_ab*Sy00_ab*Fz00_ab &
                               + Sx00_ab*Symm_ab*Fz00_ab &
                               + Sx00_ab*Sy00_ab*Fzmm_ab
           end
         end
!         Jx = Jx + Fxmm(ax,bx)*Sy00(ay,by)*Sz00(az,bz) &
!                 + Fx00(ax,bx)*Symm(ay,by)*Sz00(az,bz) &
!                 + Fx00(ax,bx)*Sy00(ay,by)*Szmm(az,bz)
!         Jy = Jy + Sxmm(ax,bx)*Fy00(ay,by)*Sz00(az,bz) &
!                 + Sx00(ax,bx)*Fymm(ay,by)*Sz00(az,bz) &
!                 + Sx00(ax,bx)*Fy00(ay,by)*Szmm(az,bz)
!         Jz = Jz + Sxmm(ax,bx)*Sy00(ay,by)*Fz00(az,bz) &
!                 + Sx00(ax,bx)*Symm(ay,by)*Fz00(az,bz) &
!                 + Sx00(ax,bx)*Sy00(ay,by)*Fzmm(az,bz)
      end
      rys.destroy
      Fzmm.destroy; Fymm.destroy; Fxmm.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Szmm.destroy; Symm.destroy; Sxmm.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   make_irrotational_jd_ints(Jx,Jy,Jz,B_field,origin,c)
   ! Make the solenoidal Jd integrals "Ji", with external magnetic field
   ! "B_field", gauge origin at "origin", and evaluated at point "c",
   !    <a|J(c)|b> = (1/8 PI) \int dr (div J^d_ab(r)) (c - r)/|c - r|3
   !     J^d_ab(r) = B (2 g_a(r)g_b(r) + (r-r_o).grad g_a(r)g_b(r))
   !                 - (r-r_o)(B.grad g_a(r)g_b(r))
   ! Uses a double quadrature based on Rys method and Gauss-Hermite quadrature.
      Jx,Jy,Jz :: MAT{REAL}
      B_field,origin,c :: VEC{REAL}(3)
      Sx00,Sy00,Sz00,Sx10,Sy10,Sz10,Sx01,Sy01,Sz01 :: MAT{REAL}*
      Sxpp,Sypp,Szpp,Dx00,Dy00,Dz00 :: MAT{REAL}*
      Fx00,Fy00,Fz00,Fx10,Fy10,Fz10,Fx01,Fy01,Fz01 :: MAT{REAL}*
      Fxpp,Fypp,Fzpp,Qx00,Qy00,Qz00 :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rpc,rab :: VEC{REAL}(3)
      p,xx,uu,wt,prefac,B_x,B_y,B_z :: REAL
      n_roots,k,a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      Sx00_ab,Sy00_ab,Sz00_ab,Fx00_ab,Fy00_ab,Fz00_ab :: REAL
      Dx00_ab,Dy00_ab,Dz00_ab,Qx00_ab,Qy00_ab,Qz00_ab :: REAL
      Sxpp_ab,Sypp_ab,Szpp_ab,Fxpp_ab,Fypp_ab,Fzpp_ab :: REAL
      rys :: RYS*
      B_x = B_field(1)
      B_y = B_field(2)
      B_z = B_field(3)
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx00.create(.a.l+2,.b.l+2); Sy00.create(.a.l+2,.b.l+2); Sz00.create(.a.l+2,.b.l+2)
      Sx10.create(.a.l+1,.b.l+1); Sy10.create(.a.l+1,.b.l+1); Sz10.create(.a.l+1,.b.l+1)
      Sx01.create(.a.l+1,.b.l+1); Sy01.create(.a.l+1,.b.l+1); Sz01.create(.a.l+1,.b.l+1)
      Sxpp.create(.a.l+1,.b.l+1); Sypp.create(.a.l+1,.b.l+1); Szpp.create(.a.l+1,.b.l+1)
      Dx00.create(.a.l+2,.b.l+2); Dy00.create(.a.l+2,.b.l+2); Dz00.create(.a.l+2,.b.l+2)
      Fx00.create(.a.l+2,.b.l+2); Fy00.create(.a.l+2,.b.l+2); Fz00.create(.a.l+2,.b.l+2)
      Fx10.create(.a.l+1,.b.l+1); Fy10.create(.a.l+1,.b.l+1); Fz10.create(.a.l+1,.b.l+1)
      Fx01.create(.a.l+1,.b.l+1); Fy01.create(.a.l+1,.b.l+1); Fz01.create(.a.l+1,.b.l+1)
      Fxpp.create(.a.l+1,.b.l+1); Fypp.create(.a.l+1,.b.l+1); Fzpp.create(.a.l+1,.b.l+1)
      Qx00.create(.a.l+2,.b.l+2); Qy00.create(.a.l+2,.b.l+2); Qz00.create(.a.l+2,.b.l+2)
      p = .a.ex + .b.ex
      rpc = (.a.ex*.a.pos + .b.ex*.b.pos)/p - c
      n_roots = (.a.l+.b.l+2)/2 + 1
      rys.create(n_roots)
      xx = p*sum(rpc*rpc)
      rys.get_weights_and_u_roots(xx)
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      do k = 1,n_roots
         uu = p*rys.root(k)
         wt =   rys.weight(k)
         .make_q_field_ints(Sx00,Dx00,Fx00,Qx00,1,uu,c(1),origin(1),.a.l+1,.b.l+1)
         .make_q_field_ints(Sy00,Dy00,Fy00,Qy00,2,uu,c(2),origin(2),.a.l+1,.b.l+1)
         .make_q_field_ints(Sz00,Dz00,Fz00,Qz00,3,uu,c(3),origin(3),.a.l+1,.b.l+1)
         Sz00 =  Sz00*wt
         Dz00 =  Dz00*wt
         Fz00 =  Fz00*wt
         Qz00 =  Qz00*wt
         .differentiate(Sx00,"left",Sx10); .differentiate(Sx00,"right",Sx01)
         .differentiate(Sy00,"left",Sy10); .differentiate(Sy00,"right",Sy01)
         .differentiate(Sz00,"left",Sz10); .differentiate(Sz00,"right",Sz01)
         .differentiate(Fx00,"left",Fx10); .differentiate(Fx00,"right",Fx01)
         .differentiate(Fy00,"left",Fy10); .differentiate(Fy00,"right",Fy01)
         .differentiate(Fz00,"left",Fz10); .differentiate(Fz00,"right",Fz01)
         Sxpp = Sx01 + Sx10
         Sypp = Sy01 + Sy10
         Szpp = Sz01 + Sz10
         Fxpp = Fx01 + Fx10
         Fypp = Fy01 + Fy10
         Fzpp = Fz01 + Fz10
         do b = 1,.b.n_comp
           bix = bx(b)
           biy = by(b)
           biz = bz(b)
           do a = 1,.a.n_comp
             aix = ax(a)
             aiy = ay(a)
             aiz = az(a)
             Sx00_ab = Sx00(aix,bix)
             Sy00_ab = Sy00(aiy,biy)
             Sz00_ab = Sz00(aiz,biz)
             Fx00_ab = Fx00(aix,bix)
             Fy00_ab = Fy00(aiy,biy)
             Fz00_ab = Fz00(aiz,biz)
             Dx00_ab = Dx00(aix,bix)
             Dy00_ab = Dy00(aiy,biy)
             Dz00_ab = Dz00(aiz,biz)
             Qx00_ab = Qx00(aix,bix)
             Qy00_ab = Qy00(aiy,biy)
             Qz00_ab = Qz00(aiz,biz)
             Sxpp_ab = Sxpp(aix,bix)
             Sypp_ab = Sypp(aiy,biy)
             Szpp_ab = Szpp(aiz,biz)
             Fxpp_ab = Fxpp(aix,bix)
             Fypp_ab = Fypp(aiy,biy)
             Fzpp_ab = Fzpp(aiz,biz)
             Jx(a,b) = Jx(a,b) &
                 + B_y*Fxpp_ab*Sy00_ab*Dz00_ab - B_z*Fxpp_ab*Dy00_ab*Sz00_ab &
                 + B_z*Qx00_ab*Sypp_ab*Sz00_ab - B_x*Fx00_ab*Sypp_ab*Dz00_ab &
                 + B_x*Fx00_ab*Dy00_ab*Szpp_ab - B_y*Qx00_ab*Sy00_ab*Szpp_ab
             Jy(a,b) = Jy(a,b) &
                 + B_y*Sxpp_ab*Fy00_ab*Dz00_ab - B_z*Sxpp_ab*Qy00_ab*Sz00_ab &
                 + B_z*Dx00_ab*Fypp_ab*Sz00_ab - B_x*Sx00_ab*Fypp_ab*Dz00_ab &
                 + B_x*Sx00_ab*Qy00_ab*Szpp_ab - B_y*Dx00_ab*Fy00_ab*Szpp_ab
             Jz(a,b) = Jz(a,b) &
                 + B_y*Sxpp_ab*Sy00_ab*Qz00_ab - B_z*Sxpp_ab*Dy00_ab*Fz00_ab &
                 + B_z*Dx00_ab*Sypp_ab*Fz00_ab - B_x*Sx00_ab*Sypp_ab*Qz00_ab &
                 + B_x*Sx00_ab*Dy00_ab*Fzpp_ab - B_y*Dx00_ab*Sy00_ab*Fzpp_ab
           end
         end
!         Jx = Jx + B_field(2)*Fxpp(ax,bx)*Sy00(ay,by)*Dz00(az,bz) - B_field(3)*Fxpp(ax,bx)*Dy00(ay,by)*Sz00(az,bz) &
!                 + B_field(3)*Qx00(ax,bx)*Sypp(ay,by)*Sz00(az,bz) - B_field(1)*Fx00(ax,bx)*Sypp(ay,by)*Dz00(az,bz) &
!                 + B_field(1)*Fx00(ax,bx)*Dy00(ay,by)*Szpp(az,bz) - B_field(2)*Qx00(ax,bx)*Sy00(ay,by)*Szpp(az,bz)
!         Jy = Jy + B_field(2)*Sxpp(ax,bx)*Fy00(ay,by)*Dz00(az,bz) - B_field(3)*Sxpp(ax,bx)*Qy00(ay,by)*Sz00(az,bz) &
!                 + B_field(3)*Dx00(ax,bx)*Fypp(ay,by)*Sz00(az,bz) - B_field(1)*Sx00(ax,bx)*Fypp(ay,by)*Dz00(az,bz) &
!                 + B_field(1)*Sx00(ax,bx)*Qy00(ay,by)*Szpp(az,bz) - B_field(2)*Dx00(ax,bx)*Fy00(ay,by)*Szpp(az,bz)
!         Jz = Jz + B_field(2)*Sxpp(ax,bx)*Sy00(ay,by)*Qz00(az,bz) - B_field(3)*Sxpp(ax,bx)*Dy00(ay,by)*Fz00(az,bz) &
!                 + B_field(3)*Dx00(ax,bx)*Sypp(ay,by)*Fz00(az,bz) - B_field(1)*Sx00(ax,bx)*Sypp(ay,by)*Qz00(az,bz) &
!                 + B_field(1)*Sx00(ax,bx)*Dy00(ay,by)*Fzpp(az,bz) - B_field(2)*Dx00(ax,bx)*Sy00(ay,by)*Fzpp(az,bz)
      end
      rys.destroy
      Qz00.destroy; Qy00.destroy; Qx00.destroy
      Fzpp.destroy; Fypp.destroy; Fxpp.destroy
      Fz01.destroy; Fy01.destroy; Fx01.destroy
      Fz10.destroy; Fy10.destroy; Fx10.destroy
      Fz00.destroy; Fy00.destroy; Fx00.destroy
      Dz00.destroy; Dy00.destroy; Dx00.destroy
      Szpp.destroy; Sypp.destroy; Sxpp.destroy
      Sz01.destroy; Sy01.destroy; Sx01.destroy
      Sz10.destroy; Sy10.destroy; Sx10.destroy
      Sz00.destroy; Sy00.destroy; Sx00.destroy
      rab = .a.pos - .b.pos
      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)*pi212/(8*PI*p)
      Jx = prefac*Jx
      Jy = prefac*Jy
      Jz = prefac*Jz
   end

   put
   ! Put the object to file "stdout"
      stdout.flush
      stdout.text("GAUSSIAN2:")
      stdout.flush
      stdout.show("l_a   =",.a.l,real_width=TRUE)
      stdout.show("l_b   =",.b.l,real_width=TRUE)
      stdout.show("pos_a =",.a.pos(1),.a.pos(2),.a.pos(3))
      stdout.show("pos_b =",.b.pos(1),.b.pos(2),.b.pos(3))
      stdout.show("ex_a  =",.a.ex)
      stdout.show("ex_b  =",.b.ex)
   end

!!!!!!!!!!!!!!!!!!!!
!!! new staff on the PCE correction of visualized densities
!!!!!!!!!!!!!!!!!!!!
   make_normalised_density_gg(S,x,y,z)
   ! Make the normalised overlap integral matrix "S". 
      S :: MAT{REAL}
      x,y,z :: REAL
      .make_density_gg(S,x,y,z)
      .normalise(S)
   end

   make_density_gg(S,x,y,z)
   ! Make the overlap integral matrix "S". Uses Gauss-Hermite quadrature.
      S :: MAT{REAL}
      x,y,z :: REAL
      Sx,Sy,Sz :: MAT{REAL}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      rab :: VEC{REAL}(3)
      p,prefac :: REAL
      a,b,aix,aiy,aiz,bix,biy,biz,fa,la,fb,lb :: INT
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)
      Sx.create(.a.l+1,.b.l+1); Sy.create(.a.l+1,.b.l+1); Sz.create(.a.l+1,.b.l+1)
      .make_density_part(Sx,1,x)
      .make_density_part(Sy,2,y)
      .make_density_part(Sz,3,z)
!     The following loops can be simplified by the one line statement:
!     S = Sx(ax,bx)*Sy(ay,by)*Sz(az,bz)
      do b = 1,.b.n_comp
        bix = bx(b)
        biy = by(b)
        biz = bz(b)
        do a = 1,.a.n_comp
          aix = ax(a)
          aiy = ay(a)
          aiz = az(a)
          S(a,b) = Sx(aix,bix)*Sy(aiy,biy)*Sz(aiz,biz)
        end
      end
      Sz.destroy; Sy.destroy; Sx.destroy
!      p = .a.ex + .b.ex
!      rab = .a.pos - .b.pos
!      prefac = exp(-.a.ex*.b.ex*sum(rab*rab)/p)/(p*sqrt(p))
!      S = prefac*S
   end

   make_density_part(Sx,x,pos,max_a,max_b)
   ! Make the 1-D overlap xyz integral matrix "Sx" for component "x".
   ! If present, "max_a" and "max_b" are used for the maximum angular momenta
   ! of centers (a) and (b) respectively -- for derivative integrals.
   ! Uses Gauss-Hermite quadrature.
      Sx :: MAT{REAL}
      x :: INT
      pos :: REAL
      max_a,max_b :: INT, optional
      p,t,rp,ax,bx,wt,pt,ra,rb :: REAL
      l_a,l_b, a,b,i,k :: INT
      l_a = .a.l; if (present(max_a)) l_a = max_a
      l_b = .b.l; if (present(max_b)) l_b = max_b
!     p = .a.ex + .b.ex
!     t = sqrt(p)
      ax = pos-.a.pos(x)
      bx = pos-.b.pos(x)
      rp = (.a.ex*ax**2 + .b.ex*bx**2)
      Sx = ZERO
      do a = 1,l_a+1
      do b = 1,l_b+1
         Sx(a,b) = exp(-rp)*ax**(a-1)*bx**(b-1) 
      end
      end
   end

   make_normalised_pDp_gg(T,x,y,z)
   ! Make the normalised kinetic integrals "T". 
      T :: MAT{REAL}
      x,y,z :: REAL
      .make_pDp_gg(T,x,y,z)
      .normalise(T)
   end

   make_pDp_gg(T,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      T :: MAT{REAL}
      x,y,z :: REAL
      ax,ay,az,bx,by,bz :: VEC{INT}*
      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}*
      rpc,rab :: VEC{REAL}(3)
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      NAx.create(.a.l+2,.b.l+2); NAy.create(.a.l+2,.b.l+2); NAz.create(.a.l+2,.b.l+2)
      AAx.create(.a.l+1,.b.l+2); AAy.create(.a.l+1,.b.l+2); AAz.create(.a.l+1,.b.l+2)
      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      T = ZERO

      .make_density_part(NAx,1,x,.a.l+1,.b.l+1)
      .make_density_part(NAy,2,y,.a.l+1,.b.l+1)
      .make_density_part(NAz,3,z,.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)

         .differentiate(NAx,"right",BBx) 
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         T = T + ABx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*ABz(az,bz) 
               
!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)  

!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)  

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)  


      ! Clean up
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_ppDpp_gg(T,x,y,z)
   ! Make the normalised kinetic integrals "T". 
      T :: MAT{REAL}
      x,y,z :: REAL
      .make_ppDpp_gg(T,x,y,z)
      .normalise(T)
   end

   make_ppDpp_gg_ori(ppDpp,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      ppDpp :: MAT{REAL}
      x,y,z :: REAL
      ax,ay,az,bx,by,bz :: VEC{INT}*
      NAx,NAy,NAz,AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}*
!     A2x,A2y,A2z,B2x,B2y,B2z :: MAT{REAL}*
      AB2x,AB2y,AB2z :: MAT{REAL}*
      rpc,rab :: VEC{REAL}(3)
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+3,.b.l+3); NAy.create(.a.l+3,.b.l+3); NAz.create(.a.l+3,.b.l+3)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      ABx.create(.a.l+2,.b.l+2); ABy.create(.a.l+2,.b.l+2); ABz.create(.a.l+2,.b.l+2)
      BBx.create(.a.l+1,.b.l+2); BBy.create(.a.l+1,.b.l+2); BBz.create(.a.l+1,.b.l+2)
      AB2x.create(.a.l+1,.b.l+1); AB2y.create(.a.l+1,.b.l+1); AB2z.create(.a.l+1,.b.l+1)


      ! Assemble the integrals
      ppDpp = ZERO
!      SOx = ZERO; SOy = ZERO; SOz = ZERO

         .make_density_part(NAx,1,x,.a.l+2,.b.l+2)
         .make_density_part(NAy,2,y,.a.l+2,.b.l+2)
         .make_density_part(NAz,3,z,.a.l+2,.b.l+2)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)
         
         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

         .differentiate(ABx,"left",BBx) 
         .differentiate(ABy,"left",BBy)
         .differentiate(ABz,"left",BBz)

         .differentiate(BBx,"right",AB2x)
         .differentiate(BBy,"right",AB2y)
         .differentiate(BBz,"right",AB2z)

         ppDpp = TWO*ABx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
               + TWO*NAx(ax,bx)*ABy(ay,by)*ABz(az,bz) &
               + TWO*ABx(ax,bx)*NAy(ay,by)*ABz(az,bz) &
               + AB2x(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*AB2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*AB2z(az,bz) 
 
! I leave out the SO ints at the moment
!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)  
 
!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)  

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)  

      AB2z.destroy; AB2y.destroy; AB2x.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
!      A2z.destroy; A2y.destroy; A2x.destroy
!      B2z.destroy; B2y.destroy; B2x.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_ppDpp_gg(ppDpp,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      ppDpp :: MAT{REAL}
      x,y,z :: REAL
      ax,ay,az,bx,by,bz :: VEC{INT}*
      NAx,NAy,NAz,AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}*
      A2x,A2y,A2z,B2x,B2y,B2z :: MAT{REAL}*
      AB2x,AB2y,AB2z :: MAT{REAL}*
      rpc,rab :: VEC{REAL}(3)
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)

      NAx.create(.a.l+3,.b.l+3); NAy.create(.a.l+3,.b.l+3); NAz.create(.a.l+3,.b.l+3)
      AAx.create(.a.l+2,.b.l+3); AAy.create(.a.l+2,.b.l+3); AAz.create(.a.l+2,.b.l+3)
      A2x.create(.a.l+1,.b.l+3); A2y.create(.a.l+1,.b.l+3); A2z.create(.a.l+1,.b.l+3)
      BBx.create(.a.l+3,.b.l+2); BBy.create(.a.l+3,.b.l+2); BBz.create(.a.l+3,.b.l+2)
      B2x.create(.a.l+3,.b.l+1); B2y.create(.a.l+3,.b.l+1); B2z.create(.a.l+3,.b.l+1)
      ABx.create(.a.l+2,.b.l+1); ABy.create(.a.l+2,.b.l+1); ABz.create(.a.l+2,.b.l+1)
      AB2x.create(.a.l+1,.b.l+1); AB2y.create(.a.l+1,.b.l+1); AB2z.create(.a.l+1,.b.l+1)


      ! Assemble the integrals
      ppDpp = ZERO
!      SOx = ZERO; SOy = ZERO; SOz = ZERO

         .make_density_part(NAx,1,x,.a.l+2,.b.l+2)
         .make_density_part(NAy,2,y,.a.l+2,.b.l+2)
         .make_density_part(NAz,3,z,.a.l+2,.b.l+2)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)
         .differentiate(AAx,"left ",A2x)
         .differentiate(AAy,"left ",A2y)
         .differentiate(AAz,"left ",A2z)

         .differentiate(NAx,"right",BBx)
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)
         .differentiate(BBx,"right",B2x)
         .differentiate(BBy,"right",B2y)
         .differentiate(BBz,"right",B2z)

         .differentiate(B2x,"left",ABx) 
         .differentiate(B2y,"left",ABy)
         .differentiate(B2z,"left",ABz)

         .differentiate(ABx,"left",AB2x)
         .differentiate(ABy,"left",AB2y)
         .differentiate(ABz,"left",AB2z)

         ppDpp = A2x(ax,bx)*B2y(ay,by)*NAz(az,bz) &
               + B2x(ax,bx)*A2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*A2y(ay,by)*B2z(az,bz) &
               + NAx(ax,bx)*B2y(ay,by)*A2z(az,bz) &
               + A2x(ax,bx)*NAy(ay,by)*B2z(az,bz) &
               + B2x(ax,bx)*NAy(ay,by)*A2z(az,bz) &
               + AB2x(ax,bx)*NAy(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*AB2y(ay,by)*NAz(az,bz) &
               + NAx(ax,bx)*NAy(ay,by)*AB2z(az,bz) 
 
! I leave out the SO ints at the moment
!         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
!                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)  
 
!         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
!                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)  

!         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
!                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)  

      AB2z.destroy; AB2y.destroy; AB2x.destroy
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      A2z.destroy; A2y.destroy; A2x.destroy
      B2z.destroy; B2y.destroy; B2x.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

   make_normalised_pDp_SO_gg(Dx,Dy,Dz,x,y,z)
   ! Make the normalised kinetic integrals "T". 
      Dx,Dy,Dz :: MAT{REAL}
      x,y,z :: REAL
      .make_pDp_SO_gg(Dx,Dy,Dz,x,y,z)
      .normalise(Dx)
      .normalise(Dy)
      .normalise(Dz)
   end

   make_pDp_SO_gg(SOx,SOy,SOz,x,y,z)
   ! Make the kinetic integrals "T". Uses Gauss-Hermite quadrature. This routine is
   ! very inefficient. This includes the factor of -1/2 in T = -1/2 \nabla^2.
      SOx,SOy,SOz :: MAT{REAL}
      x,y,z :: REAL
      ax,ay,az,bx,by,bz :: VEC{INT}*
      NAx,NAy,NAz, AAx,AAy,AAz,BBx,BBy,BBz,ABx,ABy,ABz :: MAT{REAL}*
      rpc,rab :: VEC{REAL}(3)
      fa,la,fb,lb :: INT

      ! Indexing array limits
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::nx(fa:la); ay => GAUSSIAN_DATA::ny(fa:la); az => GAUSSIAN_DATA::nz(fa:la)
      bx => GAUSSIAN_DATA::nx(fb:lb); by => GAUSSIAN_DATA::ny(fb:lb); bz => GAUSSIAN_DATA::nz(fb:lb)

      ! 2D integrals
      NAx.create(.a.l+2,.b.l+3); NAy.create(.a.l+2,.b.l+3); NAz.create(.a.l+2,.b.l+3)
      AAx.create(.a.l+1,.b.l+2); AAy.create(.a.l+1,.b.l+2); AAz.create(.a.l+1,.b.l+2)
      BBx.create(.a.l+1,.b.l+1); BBy.create(.a.l+1,.b.l+1); BBz.create(.a.l+1,.b.l+1)
      ABx.create(.a.l+1,.b.l+1); ABy.create(.a.l+1,.b.l+1); ABz.create(.a.l+1,.b.l+1)

      ! Roots and weights
      SOx = ZERO
      SOy = ZERO
      SOz = ZERO

      .make_density_part(NAx,1,x,.a.l+1,.b.l+1)
      .make_density_part(NAy,2,y,.a.l+1,.b.l+1)
      .make_density_part(NAz,3,z,.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAx,1,uu,c(1),.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAy,2,uu,c(2),.a.l+1,.b.l+1)
!         .make_nuclear_attraction_ints(NAz,3,uu,c(3),.a.l+1,.b.l+1)

         .differentiate(NAx,"right",BBx) 
         .differentiate(NAy,"right",BBy)
         .differentiate(NAz,"right",BBz)

         .differentiate(NAx,"left ",AAx)
         .differentiate(NAy,"left ",AAy)
         .differentiate(NAz,"left ",AAz)

         .differentiate(AAx,"right",ABx)
         .differentiate(AAy,"right",ABy)
         .differentiate(AAz,"right",ABz)

!        T = T + ABx(ax,bx)*NAy(ay,by)*NAz(az,bz) &
!              + NAx(ax,bx)*ABy(ay,by)*NAz(az,bz) &
!              + NAx(ax,bx)*NAy(ay,by)*ABz(az,bz) 
               
         SOx = SOx + NAx(ax,bx)*AAy(ay,by)*BBz(az,bz) &
                   - NAx(ax,bx)*BBy(ay,by)*AAz(az,bz)  

         SOy = SOy + BBx(ax,bx)*NAy(ay,by)*AAz(az,bz) &
                   - AAx(ax,bx)*NAy(ay,by)*BBz(az,bz)  

         SOz = SOz + AAx(ax,bx)*BBy(ay,by)*NAz(az,bz) &
                   - BBx(ax,bx)*AAy(ay,by)*NAz(az,bz)  


      ! Clean up
      ABz.destroy; ABy.destroy; ABx.destroy
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      NAz.destroy; NAy.destroy; NAx.destroy

   end

!!! new stuff on ft

   normalise_ft(ft)
   ! Multiplies the ft product at a series of k points, by the normalisation
   ! factors for the two gaussian shells.
     ft :: MAT{CPX}, target
     ft_ab :: CPX*
     anorm,bnorm :: VEC{REAL}* 
     a,b,i,fa,fb,la,lb :: INT
!     if (.a.l<=1 AND .b.l<=1) return  line from shell2.foo
     if (.a.l<2 AND .b.l<2) return

     if (.a.l >=2 AND .b.l>=2) then

        ! Get normalising factors
        fa = .a.first_gaussian; la = .a.last_gaussian
        fb = .b.first_gaussian; lb = .b.last_gaussian
        anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
        bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)

        i = 0
        do b = 1,.b.n_comp
        do a = 1,.a.n_comp
            i = i + 1
            ft_ab => ft(a,b)
            ft_ab = ft_ab * anorm(a) * bnorm(b) 
!            ft_ab = ft_ab * .normalising_factors(i)
        end
        end
     end
     
   end

   make_normalised_ft_00(ft_ab,h,k,l)
   ! Make the normalised kinetic integrals "T". 
      ft_ab :: MAT{CPX}
      h,k,l :: REAL
      .make_dkh_ft_00(ft_ab,h,k,l)
      .normalise_ft(ft_ab)
   end

   make_dkh_ft_00(ft,h,k,l) 
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
   ! Specialised routine for .a.l=0 and .b.l=0.
      ft :: MAT{CPX}, OUT
      h,k,l :: REAL, target
      
      pos :: VEC{REAL}(3)
      k_x,k_y,k_z :: REAL*
      g1_exa,g1_exb,e00,fac :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      I :: CPX
 
      ! Constants
      I = cmplx(ZERO,ONE,kind=CPX_KIND)
      gamma = .a.ex+.b.ex
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma
 
      ! Gaussian pair center
      g1_exa = g1*.a.ex
      g1_exb = g1*.b.ex
      P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
      P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
      P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
 
      ! Reciprocal lattice K points
      !k_x => k_pts(:,1)
      !k_y => k_pts(:,2)
      !k_z => k_pts(:,3)
      k_x => h 
      k_y => k
      k_z => l
 
      ! E coefficient
      pos = .a.pos - .b.pos
      e00 = exp(-.a.ex*.b.ex*dot_product(pos,pos)/gamma)
      pifac = pifac*e00

      ! Do the Fourier transform
    !  do k = 1,k_x.dim
    !     k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
         k1 = k_x; k2 = k_y; k3 = k_z
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
         ft(1,1) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
    !     ft(k) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
    !  end

   end

   make_normalised_ft_v2(ft_ab,h,k,l)
   ! Make the normalised kinetic integrals "T". 
      ft_ab :: MAT{CPX}
      h,k,l :: REAL
      .make_dkh_ft_v2(ft_ab,h,k,l)
   !   .normalise_ft(ft_ab)
      .normalise(ft_ab)
   end

   make_dkh_ft_v2(ft,h1,h2,h3) 
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      ft :: MAT{CPX}
      h1,h2,h3 :: REAL, target

      ft_x,ft_y,ft_z :: MAT{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      ft_xb,ft_yb,ft_zb :: VEC{CPX}*
      k_x,k_y,k_z :: REAL*
      g1_exa,g1_exb,prefac :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      k_max,a,b,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      I :: CPX

      ! Constants
      I = cmplx(ZERO,ONE,kind=CPX_KIND)
      gamma = .a.ex+.b.ex
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma

      ! Space for fourier transform of each component
!      k_max = k_pts.dim1
!      ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
!      ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
!      ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_x.create([0,.a.l],[0,.b.l])
      ft_y.create([0,.a.l],[0,.b.l])
      ft_z.create([0,.a.l],[0,.b.l])

      ! Reciprocal lattice K points
!      k_x => k_pts(:,1)
!      k_y => k_pts(:,2)
!      k_z => k_pts(:,3)
      k_x => h1 
      k_y => h2
      k_z => h3

      ! Gaussian pair center
      g1_exa = g1*.a.ex
      g1_exb = g1*.b.ex
      P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
      P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
      P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)

      ! Make prefactor
!      prefac.create(k_max)
!     do k = 1,k_max
!        k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
        k1 = k_x; k2 = k_y; k3 = k_z
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
!        prefac(k) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
        prefac = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
!     end

      ! Fourier transforms of each component.
      .make_ft_component(ft_x,1,k_x)        
      .make_ft_component(ft_y,2,k_y)        
      .make_ft_component(ft_z,3,k_z)

      ! Incorporate prefactor into ft_z
      do b = 0,.b.l 
      do a = 0,.a.l
         ft_z(a,b) = ft_z(a,b) * prefac
      end
      end
!      prefac.destroy

      ! Gaussian function power arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
      bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)

      ! Do the Fourier transform
      ft = ft_x(ax,bx)*ft_y(ay,by)*ft_z(az,bz)

      ! Clean up
      ft_z.destroy; ft_y.destroy; ft_x.destroy

   end

   make_normalised_pftp_v2(ft_ab,h,k,l)
   ! Make the normalised kinetic integrals "T". 
      ft_ab :: MAT{CPX}
      h,k,l :: REAL
      .make_dkh_ft_dadb_v2(ft_ab,h,k,l)
   !   .normalise_ft(ft_ab)
      .normalise(ft_ab)
   end

   make_dkh_ft_dadb_v2(ft,h1,h2,h3) 
   ! Calculates the Fourier transform for a product of two primitive
   ! gaussian functions, evaluated at a series of k points "k_pts".
   ! This routine is based on formula (9) in Jayatilaka, CPL 230, p. 228 (1995)
      ft :: MAT{CPX}
      h1,h2,h3 :: REAL, target

      ft_x,ft_y,ft_z :: MAT{CPX}*
      pftp_x,pftp_y,pftp_z :: MAT{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      ft_xb,ft_yb,ft_zb :: VEC{CPX}*
      k_x,k_y,k_z :: REAL*
      g1_exa,g1_exb,prefac :: REAL
      pifac,gamma,g1,g4,th,kk,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      k_max,a,b,xa,ya,za,xb,yb,zb,fa,la,fb,lb :: INT
      I :: CPX

      ! Constants
      I = cmplx(ZERO,ONE,kind=CPX_KIND)
      gamma = .a.ex+.b.ex
      g1 = ONE/gamma
      g4 = QUARTER*g1
      PI_on_gamma = PI*g1
      pifac = sqrt(PI_on_gamma) * PI_on_gamma

      ! Space for fourier transform of each component
!      k_max = k_pts.dim1
!      ft_x.create([1,k_max],[0,.a.l],[0,.b.l])
!      ft_y.create([1,k_max],[0,.a.l],[0,.b.l])
!      ft_z.create([1,k_max],[0,.a.l],[0,.b.l])
      ft_x.create([0,.a.l],[0,.b.l])
      ft_y.create([0,.a.l],[0,.b.l])
      ft_z.create([0,.a.l],[0,.b.l])
      pftp_x.create([0,.a.l],[0,.b.l])
      pftp_y.create([0,.a.l],[0,.b.l])
      pftp_z.create([0,.a.l],[0,.b.l])

      ! Reciprocal lattice K points
!      k_x => k_pts(:,1)
!      k_y => k_pts(:,2)
!      k_z => k_pts(:,3)
      k_x => h1 
      k_y => h2
      k_z => h3

      ! Gaussian pair center
      g1_exa = g1*.a.ex
      g1_exb = g1*.b.ex
      P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
      P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
      P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)

      ! Make prefactor
!      prefac.create(k_max)
!     do k = 1,k_max
!        k1 = k_x(k); k2 = k_y(k); k3 = k_z(k)
        k1 = k_x; k2 = k_y; k3 = k_z
         th = k1*P1 + k2*P2 + k3*P3
         kk = k1*k1 + k2*k2 + k3*k3
!        prefac(k) = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
        prefac = pifac*(cos(th)+I*sin(th))*exp(-kk*g4)
!     end

      ! Fourier transforms of each component.
      .make_ft_component(ft_x,1,k_x)        
      .make_ft_component(ft_y,2,k_y)        
      .make_ft_component(ft_z,3,k_z)
      .make_ft_dadb_component(pftp_x,1,k_x)        
      .make_ft_dadb_component(pftp_y,2,k_y)        
      .make_ft_dadb_component(pftp_z,3,k_z)

      ! Incorporate prefactor into ft_z
      do b = 0,.b.l 
      do a = 0,.a.l
         ft_z(a,b) = ft_z(a,b) * prefac
         pftp_z(a,b) = pftp_z(a,b) * prefac
      end
      end
!      prefac.destroy

      ! Gaussian function power arrays
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
      bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)

      ! Do the Fourier transform
      ft = pftp_x(ax,bx)*ft_y(ay,by)*ft_z(az,bz)     &
         + ft_x(ax,bx)*pftp_y(ay,by)*ft_z(az,bz)     &
         + ft_x(ax,bx)*ft_y(ay,by)*pftp_z(az,bz)

      ! Clean up
      ft_z.destroy; ft_y.destroy; ft_x.destroy

   end

   make_ft_component(res,comp,k_pts)
   ! Do the Fourier transform of component "comp" of the gaussian pair
   ! evaluated at the points "k_pts", without the prefactors.
      res :: MAT{CPX}(0:,0:), OUT
      comp  :: INT, IN
      k_pts :: REAL, IN

      e  :: MAT3{REAL}*
      kp :: VEC{REAL}*
      vr,vi :: REAL   
      a,b,t,k_max,t_max :: INT

      k_max = 1 
      t_max = .a.l+.b.l

      ! Make the E coefficients
      e.create([0,t_max],[0,.a.l],[0,.b.l])
      .make_e_coeff(e,comp)

      ! Define kp array containing powers k_pts(n)^t
      nullify(kp)
      if (t_max>0) then
         kp.create([1,t_max])    
         kp(1) = k_pts
         do t = 2,t_max 
            kp(t) = kp(t-1)*k_pts
         end
         do t = 2,t_max 
            if (mod(t,4)<=1) cycle
            kp(t) = -kp(t)
         end
      end

      ! Real, imaginary parts of answer: (vr,vi)
     !  vr.create(k_max)   
     !  vi.create(k_max)   

      do a = 0,.a.l
      do b = 0,.b.l

         t_max = a + b

         ! Real part
         vr = e(0,a,b)
         do t = 2,t_max,2
            vr = vr + e(t,a,b)*kp(t)
         end

         ! Imaginary part
         vi = ZERO
         do t = 1,t_max,2
            vi = vi + e(t,a,b)*kp(t)
         end

         res(a,b) = cmplx(vr,vi,kind=CPX_KIND)

      end
      end

!      vi.destroy; vr.destroy
      kp.destroy; e.destroy
   end

   make_ft_dadb_component(res,comp,k_pts)
   ! Do the Fourier transform of component "comp" of the gaussian pair
   ! evaluated at the points "k_pts", without the prefactors.
      res :: MAT{CPX}(0:,0:), OUT
      comp  :: INT, IN
      k_pts :: REAL, IN

      e  :: MAT3{REAL}*
      kp :: VEC{REAL}*
      vr,vi :: REAL   
      a,b,t,k_max,t_max :: INT

      k_max = 1 
      t_max = .a.l+.b.l+2

      ! Make the E coefficients
      e.create([0,t_max],[0,.a.l+1],[0,.b.l+1])
      .make_e_coeff_dadb(e,comp)

      ! Define kp array containing powers k_pts(n)^t
      nullify(kp)
      if (t_max>0) then
         kp.create([1,t_max])    
         kp(1) = k_pts
         do t = 2,t_max 
            kp(t) = kp(t-1)*k_pts
         end
         do t = 2,t_max 
            if (mod(t,4)<=1) cycle
            kp(t) = -kp(t)
         end
      end

      ! Real, imaginary parts of answer: (vr,vi)
     !  vr.create(k_max)   
     !  vi.create(k_max)   
      
      ! case build seems fine Lukas c u tommorrow kokot
      
      do a = 0,.a.l
      do b = 0,.b.l

         ! this part do not needs the if because it holds for all
         ! angular momentum functions
         t_max = a + b + 2

         ! Real part
         vr = e(0,a+1,b+1)*FOUR*.a.ex*.b.ex
         do t = 2,t_max,2
            vr = vr + e(t,a+1,b+1)*kp(t)*FOUR*.a.ex*.b.ex
         end
         ! Imaginary part
         vi = ZERO
         do t = 1,t_max,2
            vi = vi + e(t,a+1,b+1)*kp(t)*FOUR*.a.ex*.b.ex
         end
         
         if (b>0) then
            vr = vr - e(0,a+1,b-1)*TWO*.a.ex*b
            t_max = a + b 
            ! Real part
            do t = 2,t_max,2
               vr = vr - e(t,a+1,b-1)*kp(t)*TWO*.a.ex*b
            end
            ! Imaginary part
            do t = 1,t_max,2
               vi = vi - e(t,a+1,b-1)*kp(t)*TWO*.a.ex*b
            end
         end if
         
         if (a>0) then
            t_max = a + b 
            vr = vr - e(0,a-1,b+1)*TWO*.b.ex*a
            ! Real part
            do t = 2,t_max,2
               vr = vr - e(t,a-1,b+1)*kp(t)*TWO*.b.ex*a
            end
            ! Imaginary part
            do t = 1,t_max,2
               vi = vi - e(t,a-1,b+1)*kp(t)*TWO*.b.ex*a
            end
         end if 
         
         if (a>0 AND b>0) then
            vr = vr + e(0,a-1,b-1)*b*a
            t_max = a + b - 2
            ! Real part
            do t = 2,t_max,2
               vr = vr + e(t,a-1,b-1)*kp(t)*a*b
            end
            ! Imaginary part
            do t = 1,t_max,2
               vi = vi + e(t,a-1,b-1)*kp(t)*a*b
            end
         end if 

         res(a,b) = cmplx(vr,vi,kind=CPX_KIND)

      end
      end

!      vi.destroy; vr.destroy
      kp.destroy; e.destroy
   end

   make_e_coeff_dadb(e,comp) 
   ! Return the McMurchie-Davidson "e" coefficients for component "comp"
   ! (c) dylan jayatilaka, april 1995
   ! Checked using mathematica, may 1995
   ! 2008 bucinsky added +1 to l_a and l_b and +2 to max
      e :: MAT3{REAL}(0:,0:,0:), OUT 
      comp :: INT, IN

      t,a,b,ap,am,bp,bm,abp,ab,abm,max,l_a,l_b :: INT
      R,gamma,g1,g2,a1,b1,e000 :: REAL

      l_a = .a.l+1
      l_b = .b.l+1
      max = l_a+l_b+2

      R = .a.pos(comp) - .b.pos(comp)

      gamma = .a.ex + .b.ex
      g1 = ONE/gamma
      b1 = .b.ex*g1*R

      e000 = exp(-.a.ex*b1*R)
      e(0,0,0) = e000

      ! Return for e000
      if (max==0) return               

      g2 = HALF*g1
      a1 = .a.ex*g1*R
      if (l_a>=1) then
         e(1,1,0) =  g2*e000
         e(0,1,0) = -b1*e000
      end
      if (l_b>=1) then
         e(1,0,1) =  g2*e000
         e(0,0,1) =  a1*e000
      end

      ! Return for eXX1
      if (max==1) return               

      ! Consider case b=0
      do a = 1,l_a-1                   
         ap = a + 1
         am = a - 1
         e(ap,ap,0) =  g2*e( a,a,0)
         e( a,ap,0) =  g2*e(am,a,0) - b1*e(a,a,0)
         e( 0,ap,0) = -b1*e( 0,a,0) +    e(1,a,0)
         do t = 1,am
            e(t,ap,0) = g2*e(t-1,a,0) - b1*e(t,a,0) + (t+1)*e(t+1,a,0)
         end
      end

      ! Consider case a=0
      do b = 1,l_b-1                   
         bp = b + 1
         bm = b - 1
         e(bp,0,bp) =  g2*e( b,0,b)
         e( b,0,bp) =  g2*e(bm,0,b) + a1*e(b,0,b)
         e( 0,0,bp) =  a1*e( 0,0,b) +    e(1,0,b)
         do t = 1,bm
            e(t,0,bp) = g2*e(t-1,0,b) + a1*e(t,0,b) + (t+1)*e(t+1,0,b)
         end
      end

      ! Now do the rest, a/=0 & b/=0
      do b = 1,l_b                     
         do a = 0,l_a-1
            ab  = a + b
            ap  = a + 1
            abp = ab + 1
            abm = ab - 1
            e(abp,ap,b) =  g2*e( ab,a,b)
            e( ab,ap,b) =  g2*e(abm,a,b) - b1*e(ab,a,b)
            e(  0,ap,b) = -b1*e(  0,a,b) +    e( 1,a,b)
            do t = 1,abm
               e(t,ap,b) = g2*e(t-1,a,b) - b1*e(t,a,b) + (t+1)*e(t+1,a,b)
            end
         end
      end

   end

end
