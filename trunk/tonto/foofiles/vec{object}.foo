!---------------------------------------------------------------------------
!
! VEC{OBJECT}: generic vector operations ...
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

virtual module VEC{OBJECT}

   implicit none

contains

! =================
! Memory allocation
! =================

   create(dim) ::: leaky
   ! Create space for object
      self :: PTR
      dim :: INT, IN

      status :: INT

      nullify(self)
      allocate(self(dim),stat=status)

      ENSURE(status==0,"error in allocating memory")

      ADD_MEMORY(dim*ELEMENT_TYPE_SIZE)

      .nullify_ptr_part

      .set_defaults

   end

   create(dim) ::: leaky
   ! Create space for object. This version does not set defaults.
      self :: PTR
      dim :: INT, IN

      status :: INT

      nullify(self)
      allocate(self(dim),stat=status)

      ENSURE(status==0,"error in allocating memory")
      status = 0

      ADD_MEMORY(dim*ELEMENT_TYPE_SIZE)

      .nullify_ptr_part

   end

   create(dim) ::: leaky
   ! Create space for object. This version does not nullify ptr parts.
      self :: PTR
      dim :: INT, IN

      status :: INT

      nullify(self)
      allocate(self(dim),stat=status)

      ENSURE(status==0,"error in allocating memory")
      status = 0

      ADD_MEMORY(dim*ELEMENT_TYPE_SIZE)

      .set_defaults

   end

   create(lb,ub) ::: leaky
   ! Create the vector with lower bound "lb", upper bound "ub"
      self :: PTR
      lb,ub :: INT, IN

      status :: INT

      nullify(self)
      allocate(self(lb:ub),stat=status)

      ENSURE(status==0,"error in allocating memory")
      status = 0

      ADD_MEMORY((ub-lb+1)*ELEMENT_TYPE_SIZE)

      .nullify_ptr_part

      .set_defaults

   end

   create(lb,ub) ::: leaky
   ! Create the vector with lower bound "lb", upper bound "ub". This
   ! version does not set defaults.
      self :: PTR
      lb,ub :: INT, IN

      status :: INT

      nullify(self)
      allocate(self(lb:ub),stat=status)

      ENSURE(status==0,"error in allocating memory")
      status = 0

      ADD_MEMORY((ub-lb+1)*ELEMENT_TYPE_SIZE)

      .nullify_ptr_part

   end

   create(bounds) ::: leaky
   ! Create the vector with "bounds"
      self :: PTR
      bounds :: VEC{INT}(2), IN

      nullify(self)
      .create(bounds(1),bounds(2))

   end

   destroy ::: leaky
   ! Destroy space for object
      self :: PTR

      status :: INT

      if (.destroyed) return

      .destroy_ptr_part

      deallocate(self,stat=status)

      ENSURE(status==0,"error in deallocating memory")
      status = 0

      DELETE_MEMORY(.dim*ELEMENT_TYPE_SIZE)

   end

   destroy ::: leaky
   ! Destroy space for object. This version does not destroy ptr parts
      self :: PTR

      status :: INT

      if (.destroyed) return

      deallocate(self,stat=status)

      ENSURE(status==0,"error in deallocating memory")
      status = 0

      DELETE_MEMORY(.dim*ELEMENT_TYPE_SIZE)

   end

   nullify_ptr_part
   ! Nullify the pointer parts of self

      a :: INT

      do a = 1,.dim
         self(a).nullify_ptr_part
      end

   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self

      a :: INT

      do a = 1,.dim
         self(a).destroy_ptr_part
      end

   end

   created result (res) ::: inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
      result = associated(self)
   end

   destroyed result (res) ::: inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
      result = NOT associated(self)
   end

! ====
! Copy
! ====

   create_copy(vec) ::: leaky
   ! Create a replica copy of "vec".
      self :: PTR
      vec :: VEC{OBJECT}, IN

      nullify(self)
      .create(vec.dim)
      .copy(vec)

   end

   create_copy(vec,list) ::: leaky
   ! Create a copy of "vec" for the elements in "list".
      self :: PTR
      vec  :: VEC{OBJECT}, IN
      list :: VEC{INT}, IN

      nullify(self)
      .create(list.dim)
      .copy(vec,list)

   end

   copy(vec) ::: leaky
   ! Copy "vec".
      vec :: VEC{OBJECT}, IN

   ENSURE(.dim==vec.dim,"vec size does not match")

      a :: INT

      ! Copy element-by-element
      do a = 1,vec.dim
         self(a).copy(vec(a))
      end

   end

   copy(vec,list) ::: leaky
   ! Copy "vec" for the elements in "list".
      vec  :: VEC{OBJECT}, IN
      list :: VEC{INT}, IN

   ENSURE(.dim==list.dim,"wrong size, list")

      a,b :: INT

      ! Copy element-by-element
      do a = 1,list.dim
         b = list(a)
         self(a).copy(vec(b))
      end

   end

!  ===========
!  Set methods
!  ===========

   set_defaults
   ! Set default values

      n :: INT

      do n = 1,.dim
         self(n).set_defaults
      end

   end

   set_saved_self 
   ! Set saved_self
      self :: PTR
      saved_self => self
   end

   set(val)
   ! Generic set
      val :: TYPE
      VAL = val
   end

! =======================
! Shrinking and expansion
! =======================

   shrink(dim) ::: leaky
   ! Shrink self to dimension dim.  Contents are retained.
      self :: PTR
      dim :: INT, IN

   ENSURE(.created,"no self array")
   ENSURE(dim<=.dim,"dim too large")
   ENSURE(dim>=0,"dim must be non-negative")

      old :: VEC{OBJECT}*
      n :: INT

      if (dim==.dim) return

      ! Save self
      old => self

      ! Shrink
      nullify(self)
      self.create(dim)

      ! Copy old
      do n=1,dim
         self(n).copy(old(n))
      end

      ! Clean
      old.destroy

   end

   expand(dim) ::: leaky
   ! Expand the vector "self" to "dim". New slots are left undefined.
      self :: PTR
      dim :: INT, IN

      old :: VEC{OBJECT}*
      old_dim :: INT

      if (.destroyed) then

         .create(dim)

      else

         ENSURE(dim>=.dim, "dim not large enough")
         ENSURE(dim>=0,"dim must be non-negative")

         ! Save old
         old => self
         old_dim = old.dim

         ! Expand
         nullify(self)
         self.create(dim)

         ! Copy
         self(1:old_dim).copy(old)

         ! Clean
         old.destroy

      end

   end

   append(v) ::: leaky
   ! Expands self and appends the contents of vector "v".
      self :: PTR
      v :: VEC{OBJECT}, IN

      dim :: INT

      ! Original size
      if (.destroyed) then; dim = 0
      else;                 dim = .dim
      end

      ! Expand
      .expand(dim+v.dim)

      ! Append
      self(dim+1:).copy(v)

   end

   append(value) ::: leaky
   ! Expands self by 1, and appends the single scalar "value" onto the end.
      self :: PTR
      value :: OBJECT, IN

      dim :: INT

      ! Original size
      if (.destroyed) then; dim = 0
      else;                 dim = .dim
      end

      ! Expand by one
      .expand(dim+1)

      ! Append
      self(dim+1).copy(value)

   end

   join(v) result (res) ::: leaky
   ! Yield a vector which is the concatenation of "self" and "v"
      v :: VEC{OBJECT}
      res :: VEC{OBJECT}*

      dim, dim_v :: INT

      ! Sizes
      dim   = self.dim
      dim_v = v.dim

      ! Create joined
      res.create(dim+dim_v)

      ! Copy
      res(    1:dim      ).copy(self)
      res(dim+1:dim+dim_v).copy(v)

   end

   join(v1,v2) result (res) ::: leaky
   ! Yield a vector which is the concatenation of "self" and "v1" and "v2"
      v1,v2 :: VEC{OBJECT}
      res :: VEC{OBJECT}*

      dim, dim_v1, dim_v2 :: INT

      ! Sizes
      dim    = self.dim
      dim_v1 = v1.dim
      dim_v2 = v2.dim

      ! Create joined
      res.create(dim+dim_v1+dim_v2)

      ! Copy
      res(           1:dim              ).copy(self)
      res(dim+       1:dim+dim_v1       ).copy(v1)
      res(dim+dim_v1+1:dim+dim_v1+dim_v2).copy(v2)

   end

   prune_element(k) ::: leaky
   ! Removes the single element at position "k" from the vector.
   ! The order of the elements is unchanged.
      self :: PTR
      k :: INT, IN

      copy :: VEC{OBJECT}*

      ! In range?
      if (k<1 OR k>.dim) return

      ! Shrink
      copy.create(.dim-1)

      ! Copy
      copy(1:k-1) = self(  1:k-1)
      copy(k:   ) = self(k+1:   )

      ! Reassign self
      self.destroy
      self => copy

   end

! ================
! Sorting routines
! ================

   sort(decreasing_order) ::: pure
   ! Sort array "self" from lowest to highest, using simple insertion sort.  If
   ! "decreasing_order" is present and TRUE sort from highest to lowest instead.
      decreasing_order :: BIN, IN, optional

      i,j,n :: INT
      lowest_first :: BIN

      lowest_first = TRUE
      if (present(decreasing_order)) lowest_first = NOT decreasing_order

      ! Size
      n = .dim

      if (lowest_first) then

         do i = 1  ,n-1
         do j = i+1,n
            if (self(j) < self(i)) .swap_elements(i,j)
         end
         end

      else

         do i =  1,n-1
         do j =i+1,n
            if (self(j) > self(i)) .swap_elements(i,j)
         end
         end

      end

   end

   quick_sort(decreasing_order)
   ! Sort the vector into increasing order.If "decreasing_order" is present and
   ! TRUE, the vector is sorted from largest to smallest
      decreasing_order :: BIN, optional, IN

      decreasing :: BIN

      decreasing = FALSE
      if (present(decreasing_order)) decreasing = decreasing_order

      if (NOT decreasing) then; .quick_sort_increasing
      else;                     .quick_sort_decreasing
      end

   end

   quick_sort_increasing ::: recursive, private
   ! Sort the vector into order, smallest to largest
      smaller,larger :: VEC{OBJECT}(len=len(self(1)))*
      n,ns,ne,nl :: INT
      chosen :: OBJECT(len=len(self(1)))

      if (.dim<=1) return

      n = .dim

      chosen = self(1)
      ns = count(self<chosen)
      nl = count(self>chosen)
      ne = n - ns - nl

      smaller.create(ns)
      smaller = pack(self,self<chosen)
      smaller.quick_sort_increasing

      larger.create(nl)
      larger  = pack(self,self>chosen)
      larger.quick_sort_increasing

      self(1:ns)       = smaller
      self(ns+1:ns+ne) = chosen
      self(ns+ne+1:)   = larger

      larger.destroy
      smaller.destroy

   end

   quick_sort_decreasing ::: recursive, private
   ! Sort the vector into order, largest to smallest
      smaller,larger :: VEC{OBJECT}(len=len(self(1)))*
      n,ns,ne,nl :: INT
      chosen :: OBJECT(len=len(self(1)))

      if (.dim<=1) return

      n = .dim

      chosen = self(1)
      ns = count(self<chosen)
      nl = count(self>chosen)
      ne = n - ns - nl

      smaller.create(ns)
      smaller = pack(self,self<chosen)
      smaller.quick_sort_decreasing

      larger.create(nl)
      larger  = pack(self,self>chosen)
      larger.quick_sort_decreasing

      self(1:nl)       = larger
      self(nl+1:nl+ne) = chosen
      self(nl+ne+1:)   = smaller

      larger.destroy
      smaller.destroy

   end

   quick_sort(indices,decreasing_order)
   ! Return the "indices" which sort self from smallest to largest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
   ! If "decreasing_order" is present and TRUE, the indices are sorted from
   ! largest to smallest
      self :: IN
      indices :: VEC{INT}, INOUT
      decreasing_order :: BIN, optional, IN

   ENSURE(indices.dim==.dim,"wrong size, indices")

      decreasing :: BIN
      i :: INT

      ! Initialise indices
      i = 0
      indices = [(i,i=1,.dim)] 

      ! Decreasing order?
      decreasing = FALSE
      if (present(decreasing_order)) decreasing = decreasing_order

      ! Sort
      if (NOT decreasing) then; .quick_sort_increasing(indices)
      else;                     .quick_sort_decreasing(indices)
      end

   end

   quick_sort_increasing(indices) ::: recursive, private
   ! Return the indices which sort vector from smallest to largest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
      self :: IN
      indices :: VEC{INT}, INOUT
      list,small,equal,large,small_indices,equal_indices,large_indices :: VEC{INT}*
      n,i,ns,ne,nl :: INT
      chosen :: OBJECT(len=len(self(1)))

      if (indices.dim<=1) return

      n = indices.dim

      ! List of indices
      i = 0
      list.create(n)
      list = [(i,i=1,n)]

      ! Choose an element
      chosen = self(1)
      ns = count(self<chosen)
      nl = count(self>chosen)
      ne = n - ns - nl

      ! Indices of small/equal/large elements
      small.create(ns); small_indices.create(ns); small = pack(list,self <chosen); small_indices = indices(small)
      equal.create(ne); equal_indices.create(ne); equal = pack(list,self==chosen); equal_indices = indices(equal)
      large.create(nl); large_indices.create(nl); large = pack(list,self >chosen); large_indices = indices(large)

      ! Sort
      if (ns>1) self(small).quick_sort_increasing(small_indices)
      if (nl>1) self(large).quick_sort_increasing(large_indices)

      ! Assign ordered indices
      indices(1:ns)       = small_indices
      indices(ns+1:ns+ne) = equal_indices
      indices(ns+ne+1:)   = large_indices

      ! Clean
      large_indices.destroy; large.destroy
      equal_indices.destroy; equal.destroy
      small_indices.destroy; small.destroy
      list.destroy

   end

   quick_sort_decreasing(indices) ::: recursive, private
   ! Return the indices which sort vector from largest to smallest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
      self :: IN
      indices :: VEC{INT}, INOUT
      list,small,equal,large,small_indices,equal_indices,large_indices :: VEC{INT}*
      n,i,ns,ne,nl :: INT
      chosen :: OBJECT(len=len(self(1)))

      if (indices.dim<=1) return

      n = indices.dim

      ! List of indices
      i = 0
      list.create(n); list = [(i,i=1,n)]

      ! Choose an element
      chosen = self(1)
      ns = count(self>chosen)
      nl = count(self<chosen)
      ne = n - ns - nl

      ! Indices of small/equal/large elements
      small.create(ns); small_indices.create(ns); small = pack(list,self >chosen); small_indices = indices(small)
      equal.create(ne); equal_indices.create(ne); equal = pack(list,self==chosen); equal_indices = indices(equal)
      large.create(nl); large_indices.create(nl); large = pack(list,self <chosen); large_indices = indices(large)

      ! Sort
      if (ns>1) self(small).quick_sort_decreasing(small_indices)
      if (nl>1) self(large).quick_sort_decreasing(large_indices)

      ! Assign ordered indices
      indices(1:ns)       = small_indices
      indices(ns+1:ns+ne) = equal_indices
      indices(ns+ne+1:)   = large_indices

      ! Clean
      large_indices.destroy; large.destroy
      equal_indices.destroy; equal.destroy
      small_indices.destroy; small.destroy
      list.destroy

   end

   reverse_order ::: pure
   ! Reverse the order of the elements of self
      self :: INOUT

      n :: INT

      do n = 1,.dim/2
         .swap_elements(n,dim-n+1)
      end

   end

! =============================
! Repetition related operations
! =============================

   remove_repetitions ::: leaky
   ! Sort through the vector and remove repeated elements which come later in
   ! the list.  NOTE: the vector may shrink
      self :: PTR

   ENSURE(.created,"no vector")

      unique :: VEC{OBJECT}(len=len(self(1)))*
      i,j,n :: INT
      found :: BIN

      if (.dim==1) return

      unique.create(.dim)
      n = 1
      unique(1) = self(1)
      do i = 2,.dim
         found = FALSE
         do j = 1,n
            if (NOT self(i).same_as(unique(j))) cycle
            found = TRUE
         end
         if (found) cycle
         n = n + 1
         unique(n) = self(i)
      end
      .destroy
      .create(n)
      self = unique(1:n)
      unique.destroy
   end

   has_repetitions result (res)
   ! Return TRUE if self has at least one repeated element.
      res :: BIN

      i,j :: INT

      res = FALSE

      if (.dim<=1) return

      do i = 2,.dim
      do j = 1,i-1
         if (NOT self(i).same_as(self(j))) cycle
         res = TRUE
         return
      end
      end

   end

   no_of_unique_elements result (res) ::: pure
   ! Return the number of unique elements in the vector.
      self :: IN
      res :: INT

      n,i :: INT
      same :: BIN

      res = 1

      do n = 2,.dim
         same = FALSE
         do i = 1,n-1
            if (NOT self(n).same_as(self(i))) cycle
            same = TRUE
            exit
         end
         if (NOT same) res = res + 1
      end

   end

! =======================
! List-based I/O Routines
! =======================

   read_keywords ::: recursive, leaky
   ! Read in and process normal (non list-type) keywords from "stdin".
      self :: PTR

   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")

      word :: STR

      ! Read the opening brace
      stdin.read(word)

      ! Echo the brace if requested
      if (tonto.keyword_echo) then
        stdout.flush
        stdout.text("keyword found --> " // trim(word))
      end

      do ! Loop over keywords within brace

        ! Read a keyword
        stdin.read(word)

        ! Unexpected end of file?
        DIE_IF(stdin.reverted,"unexpected end of file while reading list keywords")

        ! Lower case word
        word.to_lower_case

        ! Is there an equals next? Then join it on
        if (NOT stdin.buffer_exhausted) then 
        if (stdin.next_item=="=") then
           stdin.skip_next_item
           word = trim(word) // "="
        end
        end

        ! Echo the keyword if requested
        if (tonto.keyword_echo) then
           stdout.flush
           stdout.text("keyword found --> " // trim(word))
        end

        ! Exit if it is a close brace
        if (word=="}") exit
        
        ! Process the keyword
        .process_keyword(word)

      end

   end

   read_list_keywords ::: recursive, leaky
   ! Read in and process list-based keywords from "stdin". List-based keywords
   ! are those that are intended to apply to each individual element of the list
   ! through a list of "keys" stored in the associated list-element type module.
   ! NOTE: this routine will create the list, if required.
      self :: PTR

   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")

      word :: STR

      ! Read the open brace
      stdin.read(word)

      ! Echo the brace if requested
      if (tonto.keyword_echo) then
        stdout.flush
        stdout.text("keyword found --> " // trim(word))
      end

      do ! Loop over input list-type keywords

        ! Read a keyword
        stdin.read(word)

        ! Unexpected end of file?
        DIE_IF(stdin.reverted,"unexpected end of file while reading list keywords")

        ! Lower case the word
        word.to_lower_case

        ! Is there an equals next? Then join it on
        if (NOT stdin.buffer_exhausted) then 
        if (stdin.next_item=="=") then 
           stdin.skip_next_item
           word = trim(word) // "="
        end
        end

        ! Echo the keyword if requested
        if (tonto.keyword_echo) then
           stdout.flush
           stdout.text("keyword found --> " // trim(word))
        end

        ! Exit if it is a close brace
        if (word=="}") exit

        ! Process the keyword
        .process_list_keyword(word)

      end

   end

   process_list_keyword(keyword) ::: leaky
   ! Process a list-type "keyword", common to all list-type objects.
      self :: PTR
      keyword :: STR, IN

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)

         ! Standard list-input keywords
         case("altered_data=    "); .read_altered_data
         case("append_data=     "); .read_append_data
         case("data=            "); .read_data
         case("do               "); .read_keywords
         case("keys=            "); .read_keys
         case("new_data=        "); .destroy
                                    .read_data
         case("process_keys     "); .process_keys
         case("process_keys_once"); .process_keys_once
         case("redirect         "); .redirect
         case("revert           "); .revert

         ! Data
         case default;              stdin.move_to_previous_item
                                    .read_data(ignore_braces=TRUE)

      end

   end

   read_data(ignore_braces) ::: leaky
   ! Process the keywords list to read data or commands. If "ignore_braces" is
   ! present then the opening and closing braces, which are normally required,
   ! are ignored.
      self :: PTR
      ignore_braces :: BIN, optional

      word :: STR
      length :: INT
      skip_braces :: BIN

      skip_braces = FALSE
      if (present(ignore_braces)) skip_braces = ignore_braces

      ! Any open braces? Read it
      if (NOT skip_braces) then
         ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")
         stdin.read(word) ! move past open brace
      end

      ! Get the vector length
      length = .data_length

      if (.created) then
         ! If created, is dimension the same
         ENSURE(length==.dim,"Mismatching new and old data lists")
      else
         ! If not created, create it
         .create(length)
      end

      ! Process keys
      .process_keys

      ! Close braces there? Read it.
      if (NOT skip_braces) then
         stdin.read(word)
         ENSURE(word=="}","expecting close bracket symbol, }")
      end

   end

   data_length result (length)
   ! Read ahead in stdin to get the "length" of the data list, i.e. the number
   ! of data items in the list. The data must begin with the first data item,
   ! *not* a "{" symbol.  The order of data items comprising the list is given
   ! by keys defined in the associated list-element type module. The data list
   ! must be terminated by a "}" symbol.
      self :: PTR
      length :: INT

   ENSURE(stdin.next_item/="}","empty data list!")

      tmp :: OBJECT*
      word :: STR
      line,item :: INT

      ! Remove warning
      if (FALSE) self = self

      ! Initialize result
      length = 0

      ! Initialize line no & item
      stdin.read(word)
      line = stdin.line_number
      item = stdin.previous_line_item

      ! Get the length
      do

         ! Move just before
         stdin.move_to_previous_item

         ! Read a scalar & increment
         tmp.create
         tmp.process_keys
         tmp.destroy
         length = length + 1

         ! EOF?
         stdin.read(word)
         word.to_lower_case
         if (word=="}") exit
         if (stdin.at_end_of_file) exit

      end

      ! Go back to start
      stdin.move_to_line(line)
      stdin.move_to_line_item(item)

   end

   read_altered_data ::: leaky
   ! Read in a sublist of the complete list, and alter the data for that
   ! sublist.  The order of the data items in the sublist is given by the "keys"
   ! defined in the associated list-element type module.
      self :: PTR
   
   ENSURE(.created,"list does not exist yet")
   ENSURE(stdin.next_item=="{","expecting open bracket symbol: {")

      word :: STR
      s :: INT

      ! Read brace {
      stdin.read(word)

      do

         ! Read index
         stdin.read(word)

         ! End of indices
         if (word=="}") exit

         ! Get index
         ENSURE(word.is_int,"expecting integer list-element index")
         s = word.to_int
         ENSURE(s<=.dim,"list-element too large")
         ENSURE(s>0,"list-element must be positive")

         ! Altered data for this index
         self(s).process_keys

      end

   end

   read_append_data ::: leaky
   ! Read in a set of data to append to an existing set.
      self :: PTR

   ENSURE(.created,"list does not exist yet")
   ENSURE(stdin.next_item=="{","expecting open bracket symbol: {")

      tmp :: VEC{OBJECT}*

      ! Read data
      nullify(tmp)
      tmp.read_data

      ! Append it
      .append(tmp)

      ! Clean
      tmp.destroy

   end

   process_keys ::: leaky
   ! Process the "keys" on each element of the list.
      self :: PTR

      s :: INT

      ! Process keys on each element
      if (.created) then
         do s = 1,.dim
            self(s).process_keys
         end
      ! Process keys once on anonymous element
      else 
         .process_keys_once
      end

   end

   process_keys_once 
   ! Process the "keys" just once on an anonymous object. This is useful if the
   ! "keys" set global variables in the list module (e.g. the default order of
   ! lists *within* the list data) as opposed to being keys pertaining to each
   ! element of the list.
      self :: PTR

      tmp :: OBJECT

      if (FALSE) self = self

      tmp.process_keys

   end

   keys_created result (res)
   ! Return TRUE if the list-element keys are created.
      self :: PTR
      res :: BIN

      tmp :: OBJECT

      if (FALSE) self = self

      res = tmp.keys_created

   end

   set_keys(the_keys)
   ! This is for setting the "keys" externally.
      self :: PTR
      the_keys :: VEC{STR}

      tmp :: OBJECT

      if (FALSE) self = self

      tmp.set_keys(the_keys)

   end

   clear_keys ::: leaky
   ! This is for destroying the "keys" externally.
      tmp :: OBJECT
      if (FALSE) self = self
      tmp.clear_keys
   end

   read_keys ::: leaky
   ! Read a new set of keys
      self :: PTR
      tmp :: OBJECT
      if (FALSE) self = self
      tmp.read_keys
   end

! ======
! Output
! ======

   dump(object_name)
   ! Dump a vector object
      self :: IN
      object_name :: STR, IN
    
      val :: STR
      i :: INT

      stdout.flush

      val = trim(object_name)//":VEC{TYPE} = {"
      stdout.text(trim(val))

      stdout.increment_margin_width(1)
      stdout.flush

      stdout.put("dimension =",width=11)
      stdout.put(.dim,width=0)
      stdout.flush

      do i = 1,.dim
         val = trim(object_name)//"("//trim(i.to_str)//")"
         self(i).dump(trim(val))
      end

      stdout.increment_margin_width(-1)
      stdout.flush

      stdout.text("}")

   end

   dmpp(object_name)
   ! Dump a vector pointer object
      self :: PTR
      object_name :: STR, IN
    
      val :: STR
      i :: INT

      stdout.flush

      if (.destroyed) then

         val = trim(object_name)//":VEC{TYPE}* = null"
         stdout.text(trim(val))

      else

         val = trim(object_name)//":VEC{TYPE}* = {"
         stdout.text(trim(val))

         stdout.increment_margin_width(1)
         stdout.flush

         stdout.put("dimension =",width=11)
         stdout.put(.dim,width=0)
         stdout.flush
         
         do i = 1,.dim
            val = trim(object_name)//"("//trim(i.to_str)//")"
            self(i).dump(trim(val))
         end

         stdout.increment_margin_width(-1)
         stdout.flush

         stdout.text("}")

      end

   end

   put
   ! Output the list information

     i :: INT

      do i = 1,.dim
         self(i).put
         stdout.flush
      end

   end

end
