!-------------------------------------------------------------------------------
!
! GAUSSIAN_DATA
!
! This module is used to store precalculated information pertaining to gaussian
! functions, including gaussian powers an gaussian indices, data for the reduced
! multiplication scheme (RMS) used in electron repulsion integral evaluation,
! data for the transfer relation, and binomial coefficients for the reverse
! transfer relation. The type is a dummy: the data is all held as module arrays.
!
! Copyright (C) Dylan Jayatilaka, 2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: $
!-------------------------------------------------------------------------------

module GAUSSIAN_DATA

   implicit none

   l_max_saved :: INT, private = -1

   ! List of cartesian powers for gaussian functions in increasing angular
   ! momentum. This defines the lexical order. 
   px :: VEC{INT}*, public  DEFAULT_NULL
   py :: VEC{INT}*, public  DEFAULT_NULL
   pz :: VEC{INT}*, public  DEFAULT_NULL
   pp :: MAT{INT}*, public  DEFAULT_NULL

   ! The normalising factors apply to gaussians with angular part different
   ! from x^l, y^l or z^l
   normalising_factors :: VEC{REAL}*, public  DEFAULT_NULL

   ! List of cartesian indices for gaussian functions in increasing angular
   ! momentum. The indices are the powers plus 1.
   nx :: VEC{INT}*, public  DEFAULT_NULL
   ny :: VEC{INT}*, public  DEFAULT_NULL
   nz :: VEC{INT}*, public  DEFAULT_NULL
   nn :: MAT{INT}*, public  DEFAULT_NULL

   ! Set TRUE if Ishida's ordering is to be used
   ! This turns of special code in SHELL1QUARTET
   Ishida_ordering :: BIN, public = FALSE

   ! These are indexing arrays used for the horizontal recursion relation.
   ! They are set using the set_gaussian_indices routine.
   first_nonzero :: VEC{INT}*, public  DEFAULT_NULL
   index_of :: MAT3{INT}*, public  DEFAULT_NULL
   index_m1 :: VEC{INT}*, public  DEFAULT_NULL
   index_p1 :: MAT{INT}*, public  DEFAULT_NULL

   ! The binomial coefficients, plus 1, for reverse HRR
   binomial_p1 :: VEC{VEC_{INT}}*, public  DEFAULT_NULL

   ! List of arrays used for the reduced multiplication scheme (RMS)
   rms_indices :: MAT{RMS_INDICES}*, public  DEFAULT_NULL

   ! List of arrays used for the reduced multiplication scheme (RMS)
 ! rms2_indices :: MAT4{RMS2_INDICES}*, public  DEFAULT_NULL
   rms2_indices :: MAT{RMS2_INDICES}*, public  DEFAULT_NULL

   ! Array of spherical harmonic coefficients
   spherical_harmonics_for :: VEC{MAT_{REAL}}*, public   DEFAULT_NULL

contains

! *****************
! Memory allocation
! *****************

   create ::: get_from(OBJECT), leaky
   ! Create an object. This version does not nullify point parts.
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object. This version does not destroy pointer parts.
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   destroy_data ::: selfless, leaky
   ! Destroy all module data and reset l_max_saved.
      spherical_harmonics_for.destroy
      rms2_indices.destroy
      rms_indices.destroy
      binomial_p1.destroy
      index_p1.destroy; index_m1.destroy
      first_nonzero.destroy
      index_of.destroy
      normalising_factors.destroy
      nn.destroy; nz.destroy; ny.destroy; nx.destroy
      pp.destroy; pz.destroy; py.destroy; px.destroy
   end

   set_defaults
   ! Set defaults
      .l_max = 0
   end

! ***********
! Set indices
! ***********

! This is the main routine: all others are private.

   set_indices(l_max) ::: selfless, leaky
   ! Set the gaussian power indices, hrr indices, and the rms indices. 
      l_max :: INT, IN

      l_tri,l2,n :: INT

      if (l_max<=l_max_saved) return

      l_max_saved = l_max
      l2 = 2*l_max
      n = GAUSSIAN_DATA::n_comp_up_to(l2)

      GAUSSIAN_DATA::destroy_data  ! <<< destroy data here

      px.create(n); py.create(n); pz.create(n); pp.create(3,n)
      nx.create(n); ny.create(n); nz.create(n); nn.create(3,n)
      normalising_factors.create(n)
      index_of.create(l2+1,l2+1,l2+1)
      first_nonzero.create(n)
      index_m1.create(n)
      index_p1.create(n,3)

      GAUSSIAN_DATA::set_gaussian_indices(l2,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1)
   ! GAUSSIAN_DATA::set_Ishida_indices(l2,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1)
      nn(1,:) = nx; nn(2,:) = ny; nn(3,:) = nz
      px = nx - 1; py = ny - 1; pz = nz - 1; pp = nn -1

  !  stdout.text("pp:")
  !  stdout.put(transpose(nn)-1)
  !  stdout.text("first_non_zero:")
  !  stdout.put(first_nonzero,"column")
  !  stdout.text("index_of:")
  !  stdout.put(index_of)
  !  stdout.text("index_m1:")
  !  stdout.put(index_m1,"column")
  !  stdout.text("index_p1:")
  !  stdout.put(index_p1)

      GAUSSIAN_DATA::set_normalising_factors(l2,normalising_factors,px,py,pz)

      binomial_p1.create(l_max+1)
      GAUSSIAN_DATA::set_binomial_p1_coefficients(l_max,binomial_p1)

      rms_indices.create(0,l_max,0,l_max)
      rms_indices.set_indices(l_max,nx,ny,nz,px,py,pz)

   ! l_tri = (l_max+1)*(l_max+2)/2
   ! rms2_indices.create(l_tri,l_tri)
   ! rms2_indices.set_indices(l_max,rms_indices,nx,ny,nz)

      ! Make spherical harmonic coefficients -- created in here
      GAUSSIAN_DATA::make_xyz_to_solid_harmonics(spherical_harmonics_for) 
!LBxxx  GAUSSIAN_DATA::make_xyz_to_solid_harmonics2(spherical_harmonics_for) 

   end


   set_gaussian_indices(l_max,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1) ::: selfless, private
   ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
   ! momentum up to "l_max". (Actually adds one to each power to avoid 0 as
   ! lower bound). Return "first_nonzero(i)", the cartesian index (between 1 and
   ! 3) of the first non-zero power for the gaussian with lexical index "i".
   ! Also return "index_m1(i)" and "index_p1(i)", the lexical indices of the
   ! gaussians with the first nonzero component decremented by one, and
   ! incrementred by one, respectively. In the latter case we must store all
   ! possible increments.  These are used to determine which gaussian are to be
   ! used in the HRR recursion relations.  
      l_max :: INT, IN
      nx,ny,nz :: VEC{INT}, OUT
      first_nonzero :: VEC{INT}, OUT
      index_of :: MAT3{INT}, OUT
      index_m1 :: VEC{INT}, OUT
      index_p1 :: MAT{INT}, OUT
   ENSURE(nx.dim==GAUSSIAN_DATA::n_comp_up_to(l_max),"wrong size, nx")
   ENSURE(ny.dim==nx.dim,"wrong size, ny")
   ENSURE(nz.dim==nx.dim,"wrong size, nz")
   ENSURE(first_nonzero.dim==nx.dim,"wrong dimension, first_nonzero")
   ENSURE(index_m1.dim==nx.dim,"wrong dimension, index_m1")
   ENSURE(index_p1.dim1==nx.dim,"wrong 1st dimension, index_p1")
   ENSURE(index_p1.dim2==3,"wrong 2nd dimension, index_p1")
   ENSURE(index_of.dim1==(l_max+1),"wrong 1st dimension, index_of")
   ENSURE(index_of.dim2==(l_max+1),"wrong 2nd dimension, index_of")
   ENSURE(index_of.dim3==(l_max+1),"wrong 3rd dimension, index_of")
      a,b,c,i,j,a1,b1,c1,f :: INT
      p,m :: VEC{INT}(3)
      i = 1
      do j = 0,l_max
       do a = j,floor((j+2)*THIRD),-1
          do b = min(j-a,a),floor((j-a+1)*HALF),-1
            c = j - a - b
            if (a==b AND b==c) then
              a1=a+1
              nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = a1
              index_of(a1,a1,a1) = i
              first_nonzero(i)   = 1
              i =i+1
            else if (a>b AND b==c) then
              a1=a+1
              b1=b+1
              nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = b1
              nx(i+1) = b1; ny(i+1) = a1; nz(i+1) = b1
              nx(i+2) = b1; ny(i+2) = b1; nz(i+2) = a1
              index_of(a1,b1,b1) = i
              index_of(b1,a1,b1) = i+1
              index_of(b1,b1,a1) = i+2
              first_nonzero(i  ) = 1
              first_nonzero(i+1) = 2
              first_nonzero(i+2) = 3
              if (b>0) then
                first_nonzero(i+1) = 1
                first_nonzero(i+2) = 1
              end
              i =i+3
            else if (a==b AND b>c) then
              a1=a+1
              c1=c+1
              nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = c1
              nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = a1
              nx(i+2) = c1; ny(i+2) = a1; nz(i+2) = a1
              index_of(a1,a1,c1) = i
              index_of(a1,c1,a1) = i+1
              index_of(c1,a1,a1) = i+2
              first_nonzero(i)   = 1
              first_nonzero(i+1) = 1
              first_nonzero(i+2) = 2
              if (c>0) then
                first_nonzero(i+2) = 1
              end
              i =i+3
            else
              a1=a+1
              b1=b+1
              c1=c+1
              nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = c1
              nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = b1
              nx(i+2) = b1; ny(i+2) = a1; nz(i+2) = c1
              nx(i+3) = c1; ny(i+3) = a1; nz(i+3) = b1
              nx(i+4) = b1; ny(i+4) = c1; nz(i+4) = a1
              nx(i+5) = c1; ny(i+5) = b1; nz(i+5) = a1
              index_of(a1,b1,c1) = i
              index_of(a1,c1,b1) = i+1
              index_of(b1,a1,c1) = i+2
              index_of(c1,a1,b1) = i+3
              index_of(b1,c1,a1) = i+4
              index_of(c1,b1,a1) = i+5
              if (a>0) then
                first_nonzero(i  ) = 1
                first_nonzero(i+1) = 1
                first_nonzero(i+2) = 2
                first_nonzero(i+3) = 2
                first_nonzero(i+4) = 3
                first_nonzero(i+5) = 3
              else
                first_nonzero(i  ) = 3
                first_nonzero(i+1) = 3
                first_nonzero(i+2) = 3
                first_nonzero(i+3) = 3
                ! i+4,i+5 must have b or c nonzero.
              end
              if (b>0) then
                first_nonzero(i+2) = 1
                first_nonzero(i+4) = 1
                first_nonzero(i+5) = 2
              end
              if (c>0) then
                first_nonzero(i+3) = 1
                first_nonzero(i+5) = 1
              end
              i =i+6
            end
         end
       end
      end
      do i = 1,nx.dim         ! Now make the index_p1, index_m1 arrays
        p = [nx(i),ny(i),nz(i)]
        m = p                ! add one, since lb=1 on index which should 0
        f = first_nonzero(i)
        m(f) = m(f) - 1
        if (any(m<1)) then; index_m1(1) = -1
        else;               index_m1(i) = index_of(m(1),m(2),m(3))
        end
        do f = 1,3
           p(f) = p(f) + 1
           if (any(p>l_max+1)) then; index_p1(i,f) = -1
           else;                     index_p1(i,f) = index_of(p(1),p(2),p(3))
           end
           p(f) = p(f) - 1
        end
      end
      first_nonzero(1) = -1   ! Fix up s function which has no non-zero
   end

! Below is Ishida's original (corrected) ordering
! To use this change make_esfs -> make_esfs_general
! in SHELL1QUARTET

   set_Ishida_indices(l_max,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1) ::: selfless, private
   ! Same as set_indices except using Ishida's ordering scheme.
   ! See Ishida (1993), JCP 98 p2176.
   ! NOTE: NOT WORKING
   ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
   ! momentum up to "l_max". (Actually adds one to each power to avoid 0 as
   ! lower bound). Return "first_nonzero(i)", the cartesian index (between 1 and
   ! 3) of the first non-zero power for the gaussian with lexical index "i".
   ! Also return "index_m1(i)" and "index_p1(i)", the lexical indices of the
   ! gaussians with the first nonzero component decremented by one, and
   ! incrementred by one, respectively. In the latter case we must store all
   ! possible increments.  These are used to determine which gaussian are to be
   ! used in the HRR recursion relations.  
      l_max :: INT, IN
      nx,ny,nz :: VEC{INT}, OUT
      first_nonzero :: VEC{INT}, OUT
      index_of :: MAT3{INT}, OUT
      index_m1 :: VEC{INT}, OUT
      index_p1 :: MAT{INT}, OUT
   ENSURE(nx.dim==GAUSSIAN_DATA::n_comp_up_to(l_max),"wrong size, nx")
   ENSURE(ny.dim==nx.dim,"wrong size, ny")
   ENSURE(nz.dim==nx.dim,"wrong size, nz")
   ENSURE(first_nonzero.dim==nx.dim,"wrong dimension, first_nonzero")
   ENSURE(index_m1.dim==nx.dim,"wrong dimension, index_m1")
   ENSURE(index_p1.dim1==nx.dim,"wrong 1st dimension, index_p1")
   ENSURE(index_p1.dim2==3,"wrong 2nd dimension, index_p1")
   ENSURE(index_of.dim1==(l_max+1),"wrong 1st dimension, index_of")
   ENSURE(index_of.dim2==(l_max+1),"wrong 2nd dimension, index_of")
   ENSURE(index_of.dim3==(l_max+1),"wrong 3rd dimension, index_of")
      i,i1,i2,L,M,N,a1,b1,c1,f :: INT
      p,q :: VEC{INT}(3)

      Ishida_ordering = TRUE
      index_of = -1
      index_p1 = -1

      ! S-type gaussian
      nx(1 ) = 1; ny(1 ) =  1; nz(1 ) =  1
      index_of( 1, 1, 1) = 1
      first_nonzero(1 )  = 1

      ! P-type gaussians and greater
      i = 2
      do L = 1,l_max

        a1 = L + 1

        i1 = i + 1
        i2 = i + 2
        nx(i ) = a1; ny(i ) =  1; nz(i ) =  1
        nx(i1) =  1; ny(i1) = a1; nz(i1) =  1
        nx(i2) =  1; ny(i2) =  1; nz(i2) = a1
        index_of(a1, 1, 1) = i
        index_of( 1,a1, 1) = i1
        index_of( 1, 1,a1) = i2
        first_nonzero(i )  = 1
        first_nonzero(i1)  = 2
        first_nonzero(i2)  = 3

        i = i + 3

        if (L<2) cycle

        do M = 1,L/2

           a1 = M + 1
           b1 = L - M + 1

           i1 = i + 1
           i2 = i + 2
           nx(i ) = a1; ny(i ) = b1; nz(i ) =  1
           nx(i1) =  1; ny(i1) = a1; nz(i1) = b1
           nx(i2) = b1; ny(i2) =  1; nz(i2) = a1
           index_of(a1,b1, 1) = i
           index_of( 1,a1,b1) = i1
           index_of(b1, 1,a1) = i2
           first_nonzero(i )  = 1   ! These are not first non-zero
           first_nonzero(i1)  = 2   ! but good enough for recurrence
           first_nonzero(i2)  = 3

           i = i + 3

           if (a1==b1) cycle

           i1 = i + 1
           i2 = i + 2
           nx(i ) = a1; ny(i ) =  1; nz(i ) = b1
           nx(i1) = b1; ny(i1) = a1; nz(i1) =  1
           nx(i2) =  1; ny(i2) = b1; nz(i2) = a1
           index_of(a1, 1,b1) = i
           index_of(b1,a1, 1) = i1
           index_of( 1,b1,a1) = i2
           first_nonzero(i )  = 1   ! These are not first non-zero
           first_nonzero(i1)  = 2   ! but good enough for recurrence
           first_nonzero(i2)  = 3

           i = i + 3

        end

        if (L<3) cycle

        do M = 2,(2*L)/3
        do N = max(1,2*M-L),M/2     ! <<< Mistake from Ishida?

           a1 = N + 1
           b1 = M - N + 1
           c1 = L - M + 1

           nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = c1
           index_of(a1,b1,c1) = i
           first_nonzero(i )  = 1  

           i = i + 1

           if (a1==b1 AND b1==c1) cycle

           i1 = i + 1
           nx(i ) = c1; ny(i ) = a1; nz(i ) = b1
           nx(i1) = b1; ny(i1) = c1; nz(i1) = a1
           index_of(c1,a1,b1) = i
           index_of(b1,c1,a1) = i1
           first_nonzero(i )  = 2  
           first_nonzero(i1)  = 3  

           i = i + 2

           if (a1==b1 OR b1==c1 OR a1==c1) cycle

           i1 = i + 1
           i2 = i + 2
           nx(i ) = a1; ny(i ) = c1; nz(i ) = b1
           nx(i1) = b1; ny(i1) = a1; nz(i1) = c1
           nx(i2) = c1; ny(i2) = b1; nz(i2) = a1
           index_of(a1,c1,b1) = i
           index_of(b1,a1,c1) = i1
           index_of(c1,b1,a1) = i2
           first_nonzero(i )  = 1  
           first_nonzero(i1)  = 2   
           first_nonzero(i2)  = 3

           i = i + 3

        end
        end
     
      end

      do i = 1,nx.dim         ! Now make the index_p1, index_m1 arrays
        p = [nx(i),ny(i),nz(i)]
        q = p                ! add one, since lb=1 on index which should 0
        f = first_nonzero(i)
        q(f) = q(f) - 1
        if (any(q<1)) then; index_m1(1) = -1
        else;               index_m1(i) = index_of(q(1),q(2),q(3))
        end
        do f = 1,3
           p(f) = p(f) + 1
           if (any(p>l_max+1)) then; index_p1(i,f) = -1
           else;                     index_p1(i,f) = index_of(p(1),p(2),p(3))
           end
           p(f) = p(f) - 1
        end
      end
      first_nonzero(1) = -1   ! Fix up s function which has no non-zero

   end

! Modified Ishida ordering: not working

!   set_Ishida_indices(l_max,nx,ny,nz,first_nonzero,index_of,index_m1,index_p1) ::: selfless, private
!   ! Same as set_indices except using Ishida's ordering scheme.
!   ! See Ishida (1993), JCP 98 p2176.
!   ! NOTE: NOT WORKING
!   ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
!   ! momentum up to "l_max". (Actually adds one to each power to avoid 0 as
!   ! lower bound). Return "first_nonzero(i)", the cartesian index (between 1 and
!   ! 3) of the first non-zero power for the gaussian with lexical index "i".
!   ! Also return "index_m1(i)" and "index_p1(i)", the lexical indices of the
!   ! gaussians with the first nonzero component decremented by one, and
!   ! incrementred by one, respectively. In the latter case we must store all
!   ! possible increments.  These are used to determine which gaussian are to be
!   ! used in the HRR recursion relations.  
!     l_max :: INT, IN
!     nx,ny,nz :: VEC{INT}, OUT
!     first_nonzero :: VEC{INT}, OUT
!     index_of :: MAT3{INT}, OUT
!     index_m1 :: VEC{INT}, OUT
!     index_p1 :: MAT{INT}, OUT
!   ENSURE(nx.dim==GAUSSIAN_DATA::n_comp_up_to(l_max),"wrong size, nx")
!   ENSURE(ny.dim==nx.dim,"wrong size, ny")
!   ENSURE(nz.dim==nx.dim,"wrong size, nz")
!   ENSURE(first_nonzero.dim==nx.dim,"wrong dimension, first_nonzero")
!   ENSURE(index_m1.dim==nx.dim,"wrong dimension, index_m1")
!   ENSURE(index_p1.dim1==nx.dim,"wrong 1st dimension, index_p1")
!   ENSURE(index_p1.dim2==3,"wrong 2nd dimension, index_p1")
!   ENSURE(index_of.dim1==(l_max+1),"wrong 1st dimension, index_of")
!   ENSURE(index_of.dim2==(l_max+1),"wrong 2nd dimension, index_of")
!   ENSURE(index_of.dim3==(l_max+1),"wrong 3rd dimension, index_of")
!     i,i1,i2,L,M,N,a1,b1,c1,f :: INT
!     p,q :: VEC{INT}(3)
!
!     index_of = -1
!     index_p1 = -1
!
!     ! S-type gaussian
!     nx(1 ) = 1; ny(1 ) =  1; nz(1 ) =  1
!     index_of( 1, 1, 1) = 1
!     first_nonzero(1 )  = 1
!
!     ! P-type gaussians and greater
!     i = 2
!     do L = 1,l_max
!
!        a1 = L + 1
!
!        i1 = i + 1
!        i2 = i + 2
!        nx(i ) = a1; ny(i ) =  1; nz(i ) =  1
!        nx(i1) =  1; ny(i1) = a1; nz(i1) =  1
!        nx(i2) =  1; ny(i2) =  1; nz(i2) = a1
!        index_of(a1, 1, 1) = i
!        index_of( 1,a1, 1) = i1
!        index_of( 1, 1,a1) = i2
!        first_nonzero(i )  = 1
!        first_nonzero(i1)  = 2
!        first_nonzero(i2)  = 3
!
!        i = i + 3
!
!        if (L<2) cycle
!
!        do M = 1,L/2
!
!           a1 = M + 1
!           b1 = L - M + 1
!
!           i1 = i + 1
!           i2 = i + 2
!           nx(i ) = b1; ny(i ) =  1; nz(i ) = a1
!           nx(i1) = a1; ny(i1) = b1; nz(i1) =  1
!           nx(i2) =  1; ny(i2) = a1; nz(i2) = b1
!           index_of(b1, 1,a1) = i 
!           index_of(a1,b1, 1) = i1
!           index_of( 1,a1,b1) = i2
!           first_nonzero(i )  = 3   ! These are not first non-zero
!           first_nonzero(i1)  = 1   ! but good enough for recurrence
!           first_nonzero(i2)  = 2
!
!           i = i + 3
!
!           if (a1==b1) cycle
!
!           i1 = i + 1
!           i2 = i + 2
!           nx(i ) = b1; ny(i ) = a1; nz(i ) =  1
!           nx(i1) =  1; ny(i1) = b1; nz(i1) = a1
!           nx(i2) = a1; ny(i2) =  1; nz(i2) = b1
!           index_of(b1,a1, 1) = i 
!           index_of( 1,b1,a1) = i1
!           index_of(a1, 1,b1) = i2
!           first_nonzero(i )  = 2   ! These are not first non-zero
!           first_nonzero(i1)  = 3   ! but good enough for recurrence
!           first_nonzero(i2)  = 1
!
!           i = i + 3
!
!        end
!
!        if (L<3) cycle
!
!        do M = 2,(2*L)/3
!        do N = max(1,2*M-L),M/2     ! <<< Mistake from Ishida?
!
!           a1 = N + 1
!           b1 = M - N + 1
!           c1 = L - M + 1
!
!           nx(i ) = c1; ny(i ) = a1; nz(i ) = b1
!           index_of(c1,a1,b1) = i
!           first_nonzero(i )  = 2  
!
!           i = i + 1
!
!           if (a1==b1 AND b1==c1) cycle
!
!           i1 = i + 1
!           nx(i ) = b1; ny(i ) = c1; nz(i ) = a1
!           nx(i1) = a1; ny(i1) = b1; nz(i1) = c1
!           index_of(b1,c1,a1) = i
!           index_of(a1,b1,c1) = i1
!           first_nonzero(i )  = 3  
!           first_nonzero(i1)  = 1  
!
!           i = i + 2
!
!           if (a1==b1 OR b1==c1 OR a1==c1) cycle
!
!           i1 = i + 1
!           i2 = i + 2
!           nx(i ) = c1; ny(i ) = b1; nz(i ) = a1
!           nx(i1) = a1; ny(i1) = c1; nz(i1) = b1
!           nx(i2) = b1; ny(i2) = a1; nz(i2) = c1
!           index_of(c1,b1,a1) = i 
!           index_of(a1,c1,b1) = i1
!           index_of(b1,a1,c1) = i2
!           first_nonzero(i )  = 3  
!           first_nonzero(i1)  = 1   
!           first_nonzero(i2)  = 2
!
!           i = i + 3
!
!        end
!        end
!     
!     end
!
!     do i = 1,nx.dim         ! Now make the index_p1, index_m1 arrays
!        p = [nx(i),ny(i),nz(i)]
!        q = p                ! add one, since lb=1 on index which should 0
!        f = first_nonzero(i)
!        q(f) = q(f) - 1
!        if (any(q<1)) then; index_m1(1) = -1
!        else;               index_m1(i) = index_of(q(1),q(2),q(3))
!        end
!        do f = 1,3
!           p(f) = p(f) + 1
!           if (any(p>l_max+1)) then; index_p1(i,f) = -1
!           else;                     index_p1(i,f) = index_of(p(1),p(2),p(3))
!           end
!           p(f) = p(f) - 1
!        end
!     end
!     first_nonzero(1) = -1   ! Fix up s function which has no non-zero
!
!   end

   set_normalising_factors(l_max,normalising_factors,px,py,pz) ::: selfless, private
   ! Make the normalising factors for cartesian gaussians
      l_max :: INT
      normalising_factors :: VEC{REAL}, OUT
      px,py,pz :: VEC{INT}, IN
   ENSURE(px.dim==GAUSSIAN_DATA::n_comp_up_to(l_max),"wrong size, px")
   ENSURE(py.dim==px.dim,"wrong size, py")
   ENSURE(pz.dim==px.dim,"wrong size, pz")
   ENSURE(normalising_factors.dim==px.dim,"wrong dimension, normalising_factors")
      val :: REAL
      l,s,f,i :: INT
      f = 0
      do l = 0,l_max
         s = f + 1
         f = f + GAUSSIAN_DATA::n_comp(l)
         do i = s,f
            val = l.double_factorial / &
                  (px(i).double_factorial   &
                  *py(i).double_factorial   &
                  *pz(i).double_factorial)
            normalising_factors(i) = sqrt(val)
         end
      end
   end

   set_binomial_coefficients(l_max,binomial) ::: selfless, leaky, private
   ! Set the binomial coefficients using Pascal's triangle
      l_max :: INT, IN
      binomial :: VEC{VEC_{INT}}*
   ENSURE(l_max>=0,"l_max must be non-negative")
      n,i :: INT
      binomial.create(0,l_max)
      binomial(0).element.create(0,0)
      binomial(0)[0] = 1
      do n = 1,l_max
        binomial(n).element.create(0,n)
        do i = 0,n
           if      (i==0) then; binomial(n)[i] = 1
           else if (i==n) then; binomial(n)[i] = 1
           else;                binomial(n)[i] = binomial(n-1)[i-1] + binomial(n-1)[i]
           end
        end
      end
   end

   set_binomial_p1_coefficients(l_max,binomial_p1) ::: selfless, leaky, private
   ! Set the binomial coefficients (plus 1) using Pascal's triangle.
   ! In this version one is added to all indices to avoid indexing from 0.
      l_max :: INT, IN
      binomial_p1 :: VEC{VEC_{INT}}
   ENSURE(l_max>=0,"l_max must be non-negative")
      n,i :: INT
      binomial_p1(1).element.create(1)
      binomial_p1(1)[1] = 1
      do n = 2,l_max+1
        binomial_p1(n).element.create(n)
        do i = 1,n
           if      (i==1) then; binomial_p1(n)[i] = 1
           else if (i==n) then; binomial_p1(n)[i] = 1
           else;                binomial_p1(n)[i] = binomial_p1(n-1)[i-1] + binomial_p1(n-1)[i]
           end
        end
      end
   end

! These define the boundaries of each angular momentum range
! They are inherited by many modules.

   n_sph(l) result (res) ::: selfless, private, always_pure
   ! No. of cartesian components in a gaussian shell of momentum "l".
      l :: INT, IN
      res :: INT
      res = 2*l+1
   end

   n_sph_up_to(l) result (res) ::: selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
      l :: INT, IN
      res :: INT
      res = (l+1)*(l+1)
   end

   n_comp(l) result (res) ::: selfless, private, always_pure
   ! No. of cartesian components in a gaussian shell of momentum "l".
      l :: INT, IN
      res :: INT
      res = (l+1)*(l+2)/2
   end

   n_comp_up_to(l) result (res) ::: selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
      l :: INT, IN
      res :: INT
      res = (l+1)*(l+2)*(l+3)/6
   end

! Make the cartesian to spherical harmonic transformation

   make_xyz_to_solid_harmonics(sph) ::: selfless, leaky
   ! Make the cartesian gaussian to *real* solid harmonic gaussian
   ! transformation matrices up to angular momentum "l_max". The particular
   ! transformation matrix for angular momentum "L" is sph(L).element(c,M)
   ! where "c" is the lexical index of the cartesian gaussian and "M" is the
   ! spherical component index, as defined in the book by Helgaker, Olsen, and
   ! Simons, p.218. NOTE: sph is created.
      sph :: VEC{MAT_{REAL}}*

   ENSURE(l_max_saved>=0,"l_max_saved must be non-negative")

      l_max,two :: INT
      L,M,i,del,nc,x,y,z,lm1,lm0,lm2 :: INT
      top,bot,fac,val,valp,valm :: REAL
      ix,iy,iz,pow :: VEC{INT}(3)

      ! Set l_max
      l_max = l_max_saved

      ! Initialising the tranformation matrices
      two = 2
      sph.create(0,l_max)
      do L = 0,l_max
         nc = n_comp(L)
         sph(L).element.create(1,nc,-L,L)
         sph(L).element = ZERO
      end

      ! Initialising S function
      sph(0).element(1,0) = ONE

      ! Recurrence for the other functions
      do L = 0,l_max-1

         del = L.delta(0)
         top = 2*L+1
         fac = sqrt((two.raised_to(del))*top/(top+1))
         nc  = n_comp(L)
         lm1 = n_comp_up_to(L-1)
         lm0 = n_comp_up_to(L)

         do i = 1,nc ! loop over cartesian gaussian in L-shell

            pow = GAUSSIAN_DATA::pp(:,lm1+i)
            ix  = pow+[1,0,0]+1; x = GAUSSIAN_DATA::index_of(ix(1),ix(2),ix(3)) - lm0 ! multipy by x
            iy  = pow+[0,1,0]+1; y = GAUSSIAN_DATA::index_of(iy(1),iy(2),iy(3)) - lm0 ! multipy by y
            iz  = pow+[0,0,1]+1; z = GAUSSIAN_DATA::index_of(iz(1),iz(2),iz(3)) - lm0 ! multipy by z

            valp = fac*        sph(L).element(i, L)
            valm = fac*(1-del)*sph(L).element(i,-L)

            sph(L+1).element(x, L+1) = sph(L+1).element(x, L+1) + valp
            sph(L+1).element(x,-L-1) = sph(L+1).element(x,-L-1) + valm
            sph(L+1).element(y, L+1) = sph(L+1).element(y, L+1) - valm
            sph(L+1).element(y,-L-1) = sph(L+1).element(y,-L-1) + valp

            do M = -L,L

               bot = (L+M+1)*(L-M+1)
               val = (top/sqrt(bot))*sph(L).element(i,M)

               sph(L+1).element(z,M) = sph(L+1).element(z,M) + val

            end

         end

         if (L<=0) cycle

         nc  = n_comp(L-1)
         lm2 = n_comp_up_to(L-2)

         do i = 1,nc ! loop over cartesian gaussians in (L-1)-shell

            pow = GAUSSIAN_DATA::pp(:,lm2+i)
            ix  = pow+[2,0,0]+1; x = GAUSSIAN_DATA::index_of(ix(1),ix(2),ix(3)) - lm0 ! multiply by x^2
            iy  = pow+[0,2,0]+1; y = GAUSSIAN_DATA::index_of(iy(1),iy(2),iy(3)) - lm0 ! multiply by y^2
            iz  = pow+[0,0,2]+1; z = GAUSSIAN_DATA::index_of(iz(1),iz(2),iz(3)) - lm0 ! multiply by y^2

            do M = -L+1,L-1

               bot = (L+M+1)*(L-M+1)
               val = sqrt((L+M)*(L-M)/bot)*sph(L-1).element(i,M)

               sph(L+1).element(x,M) = sph(L+1).element(x,M) - val
               sph(L+1).element(y,M) = sph(L+1).element(y,M) - val
               sph(L+1).element(z,M) = sph(L+1).element(z,M) - val

            end

         end

      end

   end

   make_xyz_to_solid_harmonics2(sph) ::: selfless, leaky
   ! Make the cartesian gaussian to *real* solid harmonic gaussian
   ! transformation matrices up to angular momentum "l_max". The particular
   ! transformation matrix for angular momentum "L" is sph(L).element(c,M)
   ! where "c" is the lexical index of the cartesian gaussian and "M" is the
   ! spherical component index, as defined in the book by Helgaker, Olsen, and
   ! Simons, p.218. NOTE: sph is created.
      sph :: VEC{MAT_{REAL}}*

   ENSURE(l_max_saved>=0,"l_max_saved must be non-negative")
   ENSURE(l_max_saved<4,"sorry g case and higher momentum not implemented")


      l_max,i,L,nc :: INT
      MX1 :: MAT{REAL}*

      l_max = l_max_saved

      sph.create(0,l_max)
      do L = 0,l_max
         nc = n_comp(L)
         sph(L).element.create(1,nc,1,2*L+1)
         sph(L).element = ZERO
      end

      sph(0).element(1,1) = ONE
      if(l_max>=1)then
      sph(1).element(1,1) = ONE
      sph(1).element(2,2) = ONE
      sph(1).element(3,3) = ONE
      end

      if(l_max>=2)then
      !  MX1.create(6,5) 
        sph(2).element(4,1) =  ONE ! 1.73205077648163d0 / 1.7320508075688773d0
        sph(2).element(6,2) =  ONE ! 1.73205077648163d0 / 1.7320508075688773d0
        sph(2).element(1,3) = -HALF
        sph(2).element(2,3) = -HALF
        sph(2).element(3,3) =  ONE 
        sph(2).element(5,4) =  ONE   ! 1.73205077648163d0 / 1.7320508075688773d0
        sph(2).element(1,5) =  HALF* sqrt (THREE) !0.866025388240814d0
        sph(2).element(2,5) = -HALF* sqrt (THREE) !-0.866025388240814d0
      ! sph(2).element=MX1
      ! MX1.destroy
      end

      if(l_max>=3)then
      ! MX1.create(10,7) 
          sph(3).element(4,1)  =  THREE / sqrt(EIGHT)                           ! 2.37170815467834d0 !N
          sph(3).element(2,1)  = -ONE   * sqrt(FIVE) / sqrt(EIGHT)              !-0.790569384892782d0 !N
          sph(3).element(10,2) =  ONE                                           ! 3.87298345565796d0  ! N 
          sph(3).element(9,3)  =  FOUR *HALF*sqrt(THREE)/sqrt(TEN)               ! 2.44948983192444d0 
          sph(3).element(4,3)  = -ONE *HALF*sqrt(THREE)/sqrt(TEN)                !-0.612372457981110d0 
          sph(3).element(2,3)  = -ONE *HALF*sqrt(THREE)/sqrt(TEN) * sqrt(FIVE)   !-0.612372457981110d0 !N
          sph(3).element(3,4)  =  TWO /sqrt(TWO*TEN)   * sqrt(FIVE)              ! 1.0d0
          sph(3).element(5,4)  = -THREE /sqrt(TWO*TEN)                           !-1.5d0
          sph(3).element(7,4)  = -THREE /sqrt(TWO*TEN)                           !-1.5d0
          sph(3).element(8,5)  =  FOUR *HALF*sqrt(THREE)/sqrt(TEN)               ! 2.44948983192444d0
          sph(3).element(1,5)  = -ONE *HALF*sqrt(THREE)/sqrt(TEN) * sqrt(FIVE)   !-0.612372457981110d0   
          sph(3).element(6,5)  = -ONE *HALF*sqrt(THREE)/sqrt(TEN)                !-0.612372457981110d0   
          sph(3).element(5,6)  =  HALF *sqrt(THREE)                              ! 1.93649172782898d0  !N
          sph(3).element(7,6)= -HALF *sqrt(THREE)                              !-1.93649172782898d0  !N
          sph(3).element(1,7)=  ONE   * sqrt(FIVE) / sqrt(EIGHT)              ! 0.790569384892782d0  !N
          sph(3).element(6,7)= -THREE / sqrt(EIGHT)                           !-2.37170815467834d0 !N
     !  sph(3).element=MX1
     !  MX1.destroy
!      else
!        i=4
!        Mg=> sph(i).element
!        Mg=ZERO
!        lincomb_xyz_2_sph(i,Mg)
      end 

   end
    
!   lincomb_xyz_2_sph(l,MX1) ::: selfless, private
!   ! Make the cartesian gaussian to *real* solid harmonic gaussian
!   l :: INT,IN
!   MX1 :: MAT{REAL}
!    !
!
!    MX1=ZERO
!! the coefs which were commented out seem to be somehow not working
!       if (l==2) then
!          MX1(4,1)=  ONE ! 1.73205077648163d0 / 1.7320508075688773d0
!          MX1(6,2)=  ONE ! 1.73205077648163d0 / 1.7320508075688773d0
!          MX1(1,3)= -HALF
!          MX1(2,3)= -HALF
!          MX1(3,3)=  ONE 
!          MX1(5,4)=  ONE   ! 1.73205077648163d0 / 1.7320508075688773d0
!          MX1(1,5)=  HALF* sqrt (THREE) !0.866025388240814d0
!          MX1(2,5)= -HALF* sqrt (THREE) !-0.866025388240814d0
!! f orbs  due to the existence of double factorials the extra factor of sqrt(FIVE) 
!!         has been introduced (now is ta given f shell othogonal in the S matrix for 
!       else 
!          MX1(4,1)=  THREE / sqrt(EIGHT)                           ! 2.37170815467834d0 !N
!          MX1(2,1)= -ONE   * sqrt(FIVE) / sqrt(EIGHT)              !-0.790569384892782d0 !N
!          MX1(10,2)= ONE                                           ! 3.87298345565796d0  ! N 
!          MX1(9,3)=  FOUR *HALF*sqrt(THREE)/sqrt(TEN)               ! 2.44948983192444d0 
!          MX1(4,3)= -ONE *HALF*sqrt(THREE)/sqrt(TEN)                !-0.612372457981110d0 
!          MX1(2,3)= -ONE *HALF*sqrt(THREE)/sqrt(TEN) * sqrt(FIVE)   !-0.612372457981110d0 !N
!          MX1(3,4)=  TWO /sqrt(TWO*TEN)   * sqrt(FIVE)              ! 1.0d0
!          MX1(5,4)= -THREE /sqrt(TWO*TEN)                           !-1.5d0
!          MX1(7,4)= -THREE /sqrt(TWO*TEN)                           !-1.5d0
!          MX1(8,5)=  FOUR *HALF*sqrt(THREE)/sqrt(TEN)               ! 2.44948983192444d0
!          MX1(1,5)= -ONE *HALF*sqrt(THREE)/sqrt(TEN) * sqrt(FIVE)   !-0.612372457981110d0   
!          MX1(6,5)= -ONE *HALF*sqrt(THREE)/sqrt(TEN)                !-0.612372457981110d0   
!          MX1(5,6)=  HALF *sqrt(THREE)                              ! 1.93649172782898d0  !N
!          MX1(7,6)= -HALF *sqrt(THREE)                              !-1.93649172782898d0  !N
!          MX1(1,7)=  ONE   * sqrt(FIVE) / sqrt(EIGHT)              ! 0.790569384892782d0  !N
!          MX1(6,7)= -THREE / sqrt(EIGHT)                           !-2.37170815467834d0 !N
!      end
!   end

end
