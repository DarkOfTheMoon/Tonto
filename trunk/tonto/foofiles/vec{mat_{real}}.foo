!---------------------------------------------------------------------------
!
! VEC{MAT_{REAL}}: Vector of matrices
!
! Copyright (C) Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module VEC{MAT_{REAL}}

   implicit none

contains

   create(dim) ::: leaky
   ! Create a matvec
      self :: PTR
      dim :: INT
      nullify(self)
      allocate(self(dim))
      ADD_MEMORY(dim*ELEMENT_TYPE_SIZE)
      .nullify_ptr_part
   end

   create(lb,ub) ::: leaky
   ! Create a matvec
      self :: PTR
      lb,ub :: INT
      nullify(self)
      allocate(self(lb:ub))
      ADD_MEMORY((ub-lb+1)*ELEMENT_TYPE_SIZE)
      .nullify_ptr_part
   end

   destroy ::: leaky
   ! Destroy a matvec
      self :: PTR
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEMORY(size(self)*ELEMENT_TYPE_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of a matvec
      i :: INT
      do i = .lb,.ub
         nullify(self(i).element)
      end
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of a matvec
       i :: INT
      do i = .lb,.ub
         self(i).element.destroy
      end
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(m) ::: leaky
   ! Create a copy of "m"
      self :: PTR
      m :: VEC{MAT_{REAL}}
      .create(m.lb,m.ub)
      .copy(m)
   end

   copy(m) ::: leaky
   ! Make a copy of "m"
      m :: VEC{MAT_{REAL}}
   ENSURE(.lb==m.lb,"different lower bounds")
   ENSURE(.ub==m.ub,"different upper bounds")
      i :: INT
      do i = m.lb,m.ub
         self(i).element.create_copy(m(i).element)
      end
   end

   lb result(res) ::: pure
   ! Returns the lower bound of self
      self :: IN
      res :: INT
      res = lbound(self,1)
   end

   ub result(res) ::: pure
   ! Returns the upper bound of self
      self :: IN
      res :: INT
      res = ubound(self,1)
   end

   make_xyz_to_solid_harmonics(l_max) ::: leaky
   ! Make the cartesian gaussian to *real* solid harmonic gaussian
   ! transformation matrices up to angular momentum "l_max". The particular
   ! transformation matrix for angular momentum "L" is self(L).element(c,M)
   ! where "c" is the lexical index of the cartesian gaussian and "M" is the
   ! spherical component index, as defined in the book by Helgaker, Olsen, and
   ! Simons, p.218. NOTE: self is created.
      self :: PTR
      l_max :: INT
   ENSURE(.destroyed,"self is not destroyed")
   ENSURE(l_max>=0,"l_max must be non-negative")
      two :: INT
      powers :: MAT{INT}*
      idx :: MAT3{INT}*
      L,M,i,del,n_comp,offset,x,y,z :: INT
      top,bot,fac,val,valp,valm :: REAL
      ix,iy,iz :: VEC{INT}(3)
      two = 2
      .create(0,l_max)
      do L = 0,l_max
         n_comp = L.n_comp
         self(L).element.create(1,n_comp,-L,L)
         self(L).element = ZERO
      end
      allocate(powers(3,l_max.n_comp_sum))
      allocate(idx(0:l_max,0:l_max,0:l_max))
      powers.to_gaussian_xyz_powers(l_max) ! cartesian gaussian component xyz powers
      idx.to_gaussian_xyz_indices(l_max) ! index of gaussian for a given xyz power
      self(0).element(1,0) = ONE
      do L = 0,l_max-1
         del = L.delta(0)
         top = 2*L+1
         fac = sqrt((two.raised_to(del))*top/(top+1))
         n_comp = L.n_comp
         offset = (L-1).n_comp_sum
         do i = 1,n_comp ! loop over cartesian gaussian in L-shell
            ix = powers(:,offset+i)+[1,0,0]; x = idx(ix(1),ix(2),ix(3)) ! multipy by x
            iy = powers(:,offset+i)+[0,1,0]; y = idx(iy(1),iy(2),iy(3)) ! multipy by y
            iz = powers(:,offset+i)+[0,0,1]; z = idx(iz(1),iz(2),iz(3)) ! multipy by z
            valp = fac*self(L).element(i,L)
            valm = fac*(1-del)*self(L).element(i,-L)
            self(L+1).element(x, L+1) = self(L+1).element(x, L+1) + valp
            self(L+1).element(x,-L-1) = self(L+1).element(x,-L-1) + valm
            self(L+1).element(y, L+1) = self(L+1).element(y, L+1) - valm
            self(L+1).element(y,-L-1) = self(L+1).element(y,-L-1) + valp
            do M = -L,L
               bot = (L+M+1)*(L-M+1)
               val = (top/sqrt(bot))*self(L).element(i,M)
               self(L+1).element(z,M) = self(L+1).element(z,M) + val
            end
         end
         if (L>0) then
         n_comp = (L-1).n_comp
         offset = (L-2).n_comp_sum
         do i = 1,n_comp ! loop over cartesian gaussians in (L-1)-shell
            ix = powers(:,offset+i)+[2,0,0]; x = idx(ix(1),ix(2),ix(3)) ! multiply by x^2
            iy = powers(:,offset+i)+[0,2,0]; y = idx(iy(1),iy(2),iy(3)) ! multiply by y^2
            iz = powers(:,offset+i)+[0,0,2]; z = idx(iz(1),iz(2),iz(3)) ! multiply by y^2
            do M = -L+1,L-1
               bot = (L+M+1)*(L-M+1)
               val = sqrt((L+M)*(L-M)/bot)*self(L-1).element(i,M)
               self(L+1).element(x,M) = self(L+1).element(x,M) - val
               self(L+1).element(y,M) = self(L+1).element(y,M) - val
               self(L+1).element(z,M) = self(L+1).element(z,M) - val
            end
         end
         end
      end
      deallocate(idx)
      deallocate(powers)
   end

   make_xyz_to_R_harmonics(Rc,Rs,l_max) ::: selfless, leaky
   ! Make the cartesian gaussian to scaled regular solid harmonics "Rc" and "Rs"
   ! transformation matrices up to angular momentum "l_max". The particular
   ! transformation matrix for angular momentum "L" is, e.g. Rc(L).element(c,M)
   ! where "c" is the lexical index of the cartsian gaussian and "M" is the
   ! spherical component index, as defined in the book by Helgaker, Olsen, and
   ! Simons, p. 416. NOTE: "Rc" and Rs are created.
      Rc,Rs :: VEC{MAT_{REAL}}*
      l_max :: INT
   ENSURE(l_max>=0,"l_max must be non-negative")
      powers :: MAT{INT}*
      idx :: MAT3{INT}*
      L,M,i,n_comp,offset,x,y,z :: INT
      top,bot,fac,val,valc,vals :: REAL
      ix,iy,iz :: VEC{INT}(3)
      Rc.create(0,l_max)
      Rs.create(0,l_max)
      do L = 0,l_max
         n_comp = L.n_comp
         Rc(L).element.create(1,n_comp,0,L)
         Rs(L).element.create(1,n_comp,0,L)
         Rc(L).element = ZERO
         Rs(L).element = ZERO
      end
      powers.create(3,l_max.n_comp_sum)
      powers.to_gaussian_xyz_powers(l_max) ! cartesian gaussian component xyz powers
      idx.create(0,l_max,0,l_max,0,l_max)
      idx.to_gaussian_xyz_indices(l_max)   ! index of gaussian for a given xyz power
      Rc(0).element(1,0) = ONE
      Rs(0).element(1,0) = ZERO
      do L = 0,l_max-1
         bot = 2*L + 2
         top = bot - 1
         fac = ONE/bot
         n_comp = L.n_comp
         offset = (L-1).n_comp_sum
         do i = 1,n_comp ! loop over cartesian gaussian in L-shell
            ix = powers(:,offset+i)+[1,0,0]; x = idx(ix(1),ix(2),ix(3)) ! multipy by x
            iy = powers(:,offset+i)+[0,1,0]; y = idx(iy(1),iy(2),iy(3)) ! multipy by y
            iz = powers(:,offset+i)+[0,0,1]; z = idx(iz(1),iz(2),iz(3)) ! multipy by z
            valc = fac*Rc(L).element(i,L)
            vals = fac*Rs(L).element(i,L)
            Rc(L+1).element(x, L+1) = Rc(L+1).element(x, L+1) - valc
            Rc(L+1).element(y, L+1) = Rc(L+1).element(y, L+1) + vals
            Rs(L+1).element(y, L+1) = Rs(L+1).element(y, L+1) - valc
            Rs(L+1).element(x, L+1) = Rs(L+1).element(x, L+1) - vals
            do M = 0,L
               bot = (L+M+1)*(L-M+1)
               valc = top/bot*Rc(L).element(i,M)
               vals = top/bot*Rs(L).element(i,M)
               Rc(L+1).element(z,M) = Rc(L+1).element(z,M) + valc
               Rs(L+1).element(z,M) = Rs(L+1).element(z,M) + vals
            end
         end
         if (L>0) then
         n_comp = (L-1).n_comp
         offset = (L-2).n_comp_sum
         do i = 1,n_comp ! loop over cartesian gaussians in (L-1)-shell
            ix = powers(:,offset+i)+[2,0,0]; x = idx(ix(1),ix(2),ix(3)) ! multiply by x^2
            iy = powers(:,offset+i)+[0,2,0]; y = idx(iy(1),iy(2),iy(3)) ! multiply by y^2
            iz = powers(:,offset+i)+[0,0,2]; z = idx(iz(1),iz(2),iz(3)) ! multiply by y^2
            do M = 0,L-1
               bot = (L+M+1)*(L-M+1)
               valc = Rc(L-1).element(i,M)/bot
               vals = Rs(L-1).element(i,M)/bot
               Rc(L+1).element(x,M) = Rc(L+1).element(x,M) - valc
               Rc(L+1).element(y,M) = Rc(L+1).element(y,M) - valc
               Rc(L+1).element(z,M) = Rc(L+1).element(z,M) - valc
               Rs(L+1).element(x,M) = Rs(L+1).element(x,M) - vals
               Rs(L+1).element(y,M) = Rs(L+1).element(y,M) - vals
               Rs(L+1).element(z,M) = Rs(L+1).element(z,M) - vals
            end
         end
         end
      end
      idx.destroy
      powers.destroy
   end

   make_gaussian_xyz_matrices(ptr) ::: leaky
   ! Return representation matrices for the s, p, d, f, and g (l = 0 ... 4)
   ! xyz cartesian gaussian shell components from a single p xyz representation 
   ! matrix "ptr".
   ! NOTE: nothing in self in pointer assigned, so it can be destroyed safely.
      self :: PTR
      ptr :: MAT{REAL}
   ENSURE(ptr.is_square,"ptr matrix is not square")
   ENSURE(ptr.dim2==3,"wrong 1st dimension, self")
      self.create(0,4)
      self(0).element.create(1,1)
      self(1).element.create(3,3)
      self(2).element.create(6,6)
      self(3).element.create(10,10)
      self(4).element.create(15,15)
      ! Now assign the transformation matrices
      self(0).element = ONE
      self(1).element = ptr
      self(2).element = ptr.gaussian_d_xyz_matrix
      self(3).element = ptr.gaussian_f_xyz_matrix
      self(4).element = ptr.gaussian_g_xyz_matrix
   end

end
