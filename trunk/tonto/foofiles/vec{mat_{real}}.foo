!---------------------------------------------------------------------------
!
! VEC{MAT_{REAL}}: Vector of matrices
!
! Copyright (C) Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module VEC{MAT_{REAL}}

   implicit none

contains

   create(dim) ::: leaky
   ! Create a matvec
      self :: PTR
      dim :: INT
      nullify(self)
      allocate(self(dim))
      ADD_MEMORY(dim*ELEMENT_TYPE_SIZE)
      .nullify_ptr_part
   end

   create(lb,ub) ::: leaky
   ! Create a matvec
      self :: PTR
      lb,ub :: INT
      nullify(self)
      allocate(self(lb:ub))
      ADD_MEMORY((ub-lb+1)*ELEMENT_TYPE_SIZE)
      .nullify_ptr_part
   end

   destroy ::: leaky
   ! Destroy a matvec
      self :: PTR
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEMORY(size(self)*ELEMENT_TYPE_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of a matvec
      i :: INT
      do i = .lb,.ub
         nullify(self(i).element)
      end
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of a matvec
       i :: INT
      do i = .lb,.ub
         self(i).element.destroy
      end
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(m) ::: leaky
   ! Create a copy of "m"
      self :: PTR
      m :: VEC{MAT_{REAL}}
      .create(m.lb,m.ub)
      .copy(m)
   end

   copy(m) ::: leaky
   ! Make a copy of "m"
      m :: VEC{MAT_{REAL}}
   ENSURE(.lb==m.lb,"different lower bounds")
   ENSURE(.ub==m.ub,"different upper bounds")
      i :: INT
      .nullify_ptr_part
      do i = m.lb,m.ub
         if (m(i).element.destroyed) cycle
         self(i).element.create_copy(m(i).element)
      end
   end

   lb result(res) ::: pure
   ! Returns the lower bound of self
      self :: IN
      res :: INT
      res = lbound(self,1)
   end

   ub result(res) ::: pure
   ! Returns the upper bound of self
      self :: IN
      res :: INT
      res = ubound(self,1)
   end

!   make_xyz_to_solid_harmonics(l_max) ::: leaky
!   ! Make the cartesian gaussian to *real* solid harmonic gaussian
!   ! transformation matrices up to angular momentum "l_max". The particular
!   ! transformation matrix for angular momentum "L" is self(L).element(c,M)
!   ! where "c" is the lexical index of the cartesian gaussian and "M" is the
!   ! spherical component index, as defined in the book by Helgaker, Olsen, and
!   ! Simons, p.218. NOTE: self is created.
!      self :: PTR
!      l_max :: INT
!   ENSURE(.destroyed,"self is not destroyed")
!   ENSURE(l_max>=0,"l_max must be non-negative")
!      two :: INT
!      powers :: MAT{INT}*
!      idx :: MAT3{INT}*
!      L,M,i,del,n_comp,offset,x,y,z :: INT
!      top,bot,fac,val,valp,valm :: REAL
!      ix,iy,iz :: VEC{INT}(3)
!      two = 2
!      .create(0,l_max)
!      do L = 0,l_max
!         n_comp = L.n_comp
!         self(L).element.create(1,n_comp,-L,L)
!         self(L).element = ZERO
!      end
!      allocate(powers(3,l_max.n_comp_sum))
!      allocate(idx(0:l_max,0:l_max,0:l_max))
!      powers.to_gaussian_xyz_powers(l_max) ! cartesian gaussian component xyz powers
!      idx.to_gaussian_xyz_indices(l_max) ! index of gaussian for a given xyz power
!      self(0).element(1,0) = ONE
!      do L = 0,l_max-1
!         del = L.delta(0)
!         top = 2*L+1
!         fac = sqrt((two.raised_to(del))*top/(top+1))
!         n_comp = L.n_comp
!         offset = (L-1).n_comp_sum
!         do i = 1,n_comp ! loop over cartesian gaussian in L-shell
!            ix = powers(:,offset+i)+[1,0,0]; x = idx(ix(1),ix(2),ix(3)) ! multipy by x
!            iy = powers(:,offset+i)+[0,1,0]; y = idx(iy(1),iy(2),iy(3)) ! multipy by y
!            iz = powers(:,offset+i)+[0,0,1]; z = idx(iz(1),iz(2),iz(3)) ! multipy by z
!            valp = fac*self(L).element(i,L)
!            valm = fac*(1-del)*self(L).element(i,-L)
!            self(L+1).element(x, L+1) = self(L+1).element(x, L+1) + valp
!            self(L+1).element(x,-L-1) = self(L+1).element(x,-L-1) + valm
!            self(L+1).element(y, L+1) = self(L+1).element(y, L+1) - valm
!            self(L+1).element(y,-L-1) = self(L+1).element(y,-L-1) + valp
!            do M = -L,L
!               bot = (L+M+1)*(L-M+1)
!               val = (top/sqrt(bot))*self(L).element(i,M)
!               self(L+1).element(z,M) = self(L+1).element(z,M) + val
!            end
!         end
!         if (L>0) then
!         n_comp = (L-1).n_comp
!         offset = (L-2).n_comp_sum
!         do i = 1,n_comp ! loop over cartesian gaussians in (L-1)-shell
!            ix = powers(:,offset+i)+[2,0,0]; x = idx(ix(1),ix(2),ix(3)) ! multiply by x^2
!            iy = powers(:,offset+i)+[0,2,0]; y = idx(iy(1),iy(2),iy(3)) ! multiply by y^2
!            iz = powers(:,offset+i)+[0,0,2]; z = idx(iz(1),iz(2),iz(3)) ! multiply by y^2
!            do M = -L+1,L-1
!               bot = (L+M+1)*(L-M+1)
!               val = sqrt((L+M)*(L-M)/bot)*self(L-1).element(i,M)
!               self(L+1).element(x,M) = self(L+1).element(x,M) - val
!               self(L+1).element(y,M) = self(L+1).element(y,M) - val
!               self(L+1).element(z,M) = self(L+1).element(z,M) - val
!            end
!         end
!         end
!      end
!      deallocate(idx)
!      deallocate(powers)
!   end
!
!   make_xyz_to_R_harmonics(Rc,Rs,l_max) ::: selfless, leaky
!   ! Make the cartesian gaussian to scaled regular solid harmonics "Rc" and "Rs"
!   ! transformation matrices up to angular momentum "l_max". The particular
!   ! transformation matrix for angular momentum "L" is, e.g. Rc(L).element(c,M)
!   ! where "c" is the lexical index of the cartsian gaussian and "M" is the
!   ! spherical component index, as defined in the book by Helgaker, Olsen, and
!   ! Simons, p. 416. NOTE: "Rc" and Rs are created.
!      Rc,Rs :: VEC{MAT_{REAL}}*
!      l_max :: INT
!   ENSURE(l_max>=0,"l_max must be non-negative")
!      powers :: MAT{INT}*
!      idx :: MAT3{INT}*
!      L,M,i,n_comp,offset,x,y,z :: INT
!      top,bot,fac,val,valc,vals :: REAL
!      ix,iy,iz :: VEC{INT}(3)
!      Rc.create(0,l_max)
!      Rs.create(0,l_max)
!      do L = 0,l_max
!         n_comp = L.n_comp
!         Rc(L).element.create(1,n_comp,0,L)
!         Rs(L).element.create(1,n_comp,0,L)
!         Rc(L).element = ZERO
!         Rs(L).element = ZERO
!      end
!      powers.create(3,l_max.n_comp_sum)
!      powers.to_gaussian_xyz_powers(l_max) ! cartesian gaussian component xyz powers
!      idx.create(0,l_max,0,l_max,0,l_max)
!      idx.to_gaussian_xyz_indices(l_max)   ! index of gaussian for a given xyz power
!      Rc(0).element(1,0) = ONE
!      Rs(0).element(1,0) = ZERO
!      do L = 0,l_max-1
!         bot = 2*L + 2
!         top = bot - 1
!         fac = ONE/bot
!         n_comp = L.n_comp
!         offset = (L-1).n_comp_sum
!         do i = 1,n_comp ! loop over cartesian gaussian in L-shell
!            ix = powers(:,offset+i)+[1,0,0]; x = idx(ix(1),ix(2),ix(3)) ! multipy by x
!            iy = powers(:,offset+i)+[0,1,0]; y = idx(iy(1),iy(2),iy(3)) ! multipy by y
!            iz = powers(:,offset+i)+[0,0,1]; z = idx(iz(1),iz(2),iz(3)) ! multipy by z
!            valc = fac*Rc(L).element(i,L)
!            vals = fac*Rs(L).element(i,L)
!            Rc(L+1).element(x, L+1) = Rc(L+1).element(x, L+1) - valc
!            Rc(L+1).element(y, L+1) = Rc(L+1).element(y, L+1) + vals
!            Rs(L+1).element(y, L+1) = Rs(L+1).element(y, L+1) - valc
!            Rs(L+1).element(x, L+1) = Rs(L+1).element(x, L+1) - vals
!            do M = 0,L
!               bot = (L+M+1)*(L-M+1)
!               valc = top/bot*Rc(L).element(i,M)
!               vals = top/bot*Rs(L).element(i,M)
!               Rc(L+1).element(z,M) = Rc(L+1).element(z,M) + valc
!               Rs(L+1).element(z,M) = Rs(L+1).element(z,M) + vals
!            end
!         end
!         if (L>0) then
!         n_comp = (L-1).n_comp
!         offset = (L-2).n_comp_sum
!         do i = 1,n_comp ! loop over cartesian gaussians in (L-1)-shell
!            ix = powers(:,offset+i)+[2,0,0]; x = idx(ix(1),ix(2),ix(3)) ! multiply by x^2
!            iy = powers(:,offset+i)+[0,2,0]; y = idx(iy(1),iy(2),iy(3)) ! multiply by y^2
!            iz = powers(:,offset+i)+[0,0,2]; z = idx(iz(1),iz(2),iz(3)) ! multiply by y^2
!            do M = 0,L-1
!               bot = (L+M+1)*(L-M+1)
!               valc = Rc(L-1).element(i,M)/bot
!               vals = Rs(L-1).element(i,M)/bot
!               Rc(L+1).element(x,M) = Rc(L+1).element(x,M) - valc
!               Rc(L+1).element(y,M) = Rc(L+1).element(y,M) - valc
!               Rc(L+1).element(z,M) = Rc(L+1).element(z,M) - valc
!               Rs(L+1).element(x,M) = Rs(L+1).element(x,M) - vals
!               Rs(L+1).element(y,M) = Rs(L+1).element(y,M) - vals
!               Rs(L+1).element(z,M) = Rs(L+1).element(z,M) - vals
!            end
!         end
!         end
!      end
!      idx.destroy
!      powers.destroy
!   end

   make_gaussian_xyz_matrices(ptr) ::: leaky
   ! Return representation matrices for the s, p, d, f, and g (l = 0 ... 4)
   ! xyz cartesian gaussian shell components from a single p xyz representation 
   ! matrix "ptr".
   ! NOTE: nothing in self in pointer assigned, so it can be destroyed safely.
      self :: PTR
      ptr :: MAT{REAL}
   ENSURE(ptr.is_square,"ptr matrix is not square")
   ENSURE(ptr.dim2==3,"wrong 1st dimension, self")
      self.create(0,4)
      self(0).element.create(1,1)
      self(1).element.create(3,3)
      self(2).element.create(6,6)
      self(3).element.create(10,10)
      self(4).element.create(15,15)
      ! Now assign the transformation matrices
      self(0).element = ONE
      self(1).element = ptr
      self(2).element = ptr.gaussian_d_xyz_matrix
      self(3).element = ptr.gaussian_f_xyz_matrix
      self(4).element = ptr.gaussian_g_xyz_matrix
   end

end
