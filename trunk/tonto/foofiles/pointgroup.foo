! $Id$
!-------------------------------------------------------------------------------
!
!  POINTGROUP : for deriving and manipulating pointgroup objects
!
!  Input required is the Schonflies symbol. The data generated are
!  The 3x3 rotation matrices, all the irreducible representations,
!  The character table, the irreducible representation lables,
!  the group multiplication table, and the list of inverse operators
!
!  (c) copyright 1994, 1995, 1996, 1997, Anthony  J. Russell
!  (c) 1998, Dylan Jayatilaka
!-------------------------------------------------------------------------------
module POINTGROUP

   use TYPES
   use ERROR
   use MM
   use STR
   use INT

   use VEC
   use IVEC
   use MAT
   use IMAT
   use MAT3

   use INPUT
   use OUTPUT

   use IRREP
   use IRREPVEC

   implicit none

#  include "macros"
#  include "pointgroup.int"

!  type pointgroup_type
!     CHR(4) :: symbol             ! symmetry symbol
!     CHR(4) :: ID_symbol          ! group id symbol
!     INT :: ID_number             ! group id number
!     INT :: axis_order            ! principal axis order
!     INT :: order                 ! order of the group
!     INT :: n_irrep               ! no of irreducible representations
!     INT :: n_gen                 ! No. of generators
!     BIN :: has_complex_irreps    ! true if the group has complex irreps
!     IMAT, PTR :: table           ! group multiplication table
!     MAT3, PTR :: mat             ! 3x3 representation matrices
!     MAT3, PTR :: ptr             ! 3x3 representation matrices for p functions, same as mat
!     MAT3, PTR :: dtr             ! 6x6 representation matrices for d functions
!     MAT3, PTR :: ftr             ! 10x10 representation matrices for f functions
!     IVEC, PTR :: inverse         ! Indices of inverse group elements
!     IRREPVEC, PTR :: irrep       ! List of irrrducible representations
!  end

contains    

   create
   ! Create a pointgroup object
      PTR :: self
      nullify(self)
      allocate(self)
      std_mm.add(POINTGROUP_SIZE)
      .nullify_ptr_part
   end

   create(symbol)
   ! Create a pointgroup object
      PTR :: self
      STR(*) :: symbol
      nullify(self)
      allocate(self)
      std_mm.add(POINTGROUP_SIZE)
      .nullify_ptr_part
      .set_symbol(symbol)
      .analyse
   end

   destroy 
   ! Destroy a pointgroup object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      std_mm.delete(POINTGROUP_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   nullify_ptr_part
      nullify(.table)
      nullify(.mat)
      nullify(.ptr)
      nullify(.dtr)
      nullify(.ftr)
      nullify(.inverse)
      nullify(.irrep)
   end

   destroy_ptr_part
      .table.destroy
      .mat.destroy
!      .ptr.destroy
      nullify( .ptr )
      .dtr.destroy
      .ftr.destroy
      .inverse.destroy
      .irrep.destroy
   end
   
   set_symbol(symbol)
   ! Set the pointgroup Schonflies symbol
      CHR(*) :: symbol
      .symbol = symbol
      .ID_symbol = symbol
      .ID_symbol.to_lower_case
   end

   read(in)
   ! Read the group symbol and analyse the spacegroup
      INPUT :: in
      STR :: word
      in.read(word)
      .set_symbol(word)
      .analyse
   end

   set_default
   ! Set the default pointgroup, "C1"
      .set_symbol("C1")
      .analyse
   end

   analyse [leaky]
   ! Analyse the pointgroup 
      .analyse_symbol
      .make_rep_matrices
      .make_xyz_matrices
      .make_inverse
      .make_table
      .make_irrep_matrices
      .make_irrep_labels
      .make_character_table
   end

   analyse_symbol
   ! Analyse the pointgroup symbol
      STR :: axis
      INT :: n
      BIN :: temp_bin
      select case (.ID_symbol) 
         case ("c1");      .ID_number=1;  .ID_symbol="c1 "
         case ("cs");      .ID_number=2;  .ID_symbol="cs "
         case ("ci");      .ID_number=3;  .ID_symbol="ci "
         case ("c2 ","c3 ","c4 ","c5 ","c6 ","c7 ","c8 ","c9 ","c10 ","c11 ","c12 "); .ID_number=4;  .ID_symbol="cn "
         case ("s2 ","s4 ","s6 ","s8 ","s10","s12");                                  .ID_number=5;  .ID_symbol="s2n"
         case ("c2h","c3h","c4h","c5h","c6h","c7h","c8h","c9h","c10h","c11h","c12h"); .ID_number=6;  .ID_symbol="cnh"
         case ("c2v","c3v","c4v","c5v","c6v","c7v","c8v","c9v","c10v","c11v","c12v"); .ID_number=7;  .ID_symbol="cnv"
         case ("d2 ","d3 ","d4 ","d5 ","d6 ","d7 ","d8 ","d9 ","d10 ","d11 ","d12 "); .ID_number=8;  .ID_symbol="dn "
         case ("d2h","d3h","d4h","d5h","d6h","d7h","d8h","d9h","d10h","d11h","d12h"); .ID_number=9;  .ID_symbol="dnh"
         case ("d2d","d3d","d4d","d5d","d6d","d7d","d8d","d9d","d10d","d11d","d12d"); .ID_number=10; .ID_symbol="dnd"
         case ("cinfv");   .ID_number=11; .ID_symbol="cinf"
         case ("dinfh");   .ID_number=12; .ID_symbol="dinf"
         case ("t ");      .ID_number=13; .ID_symbol="t  "
         case ("th");      .ID_number=14; .ID_symbol="th "
         case ("td");      .ID_number=15; .ID_symbol="td "
         case ("o ");      .ID_number=16; .ID_symbol="o  "
         case ("oh");      .ID_number=17; .ID_symbol="oh "
         case ("i ");      .ID_number=18; .ID_symbol="i  "
         case ("ih");      .ID_number=19; .ID_symbol="ih "
         case default;     .ID_number=20
      end
      temp_bin = any(.ID_symbol==(/"i   ","ih  ","cinf","dinf"/))
      DIE_IF(temp_bin,"Group" // trim(.symbol) // "not implemented") 
      DIE_IF(.ID_number==20,"Unknown group symbol: " // trim(.symbol)) 
      select case (.ID_number)
         case (1:3)
            .axis_order = 1 
         case (4:10)
            axis = .symbol(2:)
            n = axis.verify("123456789")-1
            axis = axis(1:n)
            .axis_order = axis.to_int
            if (.ID_number==5) .axis_order = .axis_order/2
         case (13:15)
            .axis_order = 2
         case (16:17)
            .axis_order = 4
      end
      select case (.ID_symbol)
         case ("c1 "); .order = 1
         case ("cs "); .order = 2
         case ("ci "); .order = 2
         case ("cn "); .order =   .axis_order
         case ("s2n"); .order = 2*.axis_order
         case ("cnh"); .order = 2*.axis_order
         case ("cnv"); .order = 2*.axis_order
         case ("dn "); .order = 2*.axis_order
         case ("dnh"); .order = 4*.axis_order
         case ("dnd"); .order = 4*.axis_order
         case ("t  "); .order = 12
         case ("th "); .order = 24
         case ("td "); .order = 24
         case ("o  "); .order = 24
         case ("oh "); .order = 48
      end
   end 

   make_rep_matrices [leaky]
   ! Make the 3x3 point group representation matrices 
      INT :: n
      n = .axis_order
      .mat.create(3,3,.order)
      call to_unit_mat_( .mat(:,:,1))
      select case (.ID_symbol)
         case ("c1")                ! C1 
         case ("cs")                ! Cs  = C1 x sigma-h
            .times_sigma_h(1)
         case ("ci")                ! Ci  = C1 x Ci 
            .times_ci(1)
         case ("cn")                ! Cn 
            .make_cn_matrices
         case ("s2n")               ! Sn 
            .make_cn_matrices
            .make_sn_matrices(n)
         case ("cnh")               ! Cnh = Cn x sigma-h(xy)
            .make_cn_matrices
            .times_sigma_h(n)
         case ("cnv")               ! Cnv = Cn x sigma-v(xz) 
            .make_cn_matrices
            .times_sigma_v(n)
         case ("dn")                ! Dn  = Cn  x C2(x)
            .make_cn_matrices
            .times_c2x(n)
         case ("dnh")               ! Dnh = Cn x sigma-h(xy) x C2(x)
            .make_cn_matrices
            .times_sigma_h(n)
            n = 2*n
            .times_c2x(n)
         case ("dnd")               ! Dnd = Cn x C2(x) x sigma-d 
            .make_cn_matrices
            .times_c2x(n)
            n = 2*n
            .times_sigma_d(n)
         case ("t")                 ! T 
            .make_t_matrices
         case ("th")                ! Th  = T x Ci
            .make_t_matrices
            .times_ci(12)
         case ("td")                ! Td  = T x sigma(x=y)
            .make_t_matrices
            .mat(:,1,13:24) = .mat(:,2,1:12)
            .mat(:,2,13:24) = .mat(:,1,1:12)
            .mat(:,3,13:24) = .mat(:,3,1:12)
         case ("o")                 ! O  = T x C4(z)
            .make_t_matrices
            .times_c4z(12)
         case ("oh")                ! Oh = T x C4(z) x Ci
            .make_t_matrices
            .times_c4z(12)
            .times_ci(24)
      end
   end

   times_ci(n)
   ! Direct product with inversion operator
      INT :: n
      .mat(1,:,n+1:n+n) = -.mat(1,:,1:n)
      .mat(2,:,n+1:n+n) = -.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = -.mat(3,:,1:n)
   end

   times_sigma_h(n)
   ! Direct product with sigma-h, which is the xy plane
      INT :: n
      .mat(1,:,n+1:n+n) =  .mat(1,:,1:n)
      .mat(2,:,n+1:n+n) =  .mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = -.mat(3,:,1:n)
   end

   times_sigma_v(n)
   ! Direct product with sigma-v, which is the xz plane
      INT :: n
      .mat(1,:,n+1:n+n) =  .mat(1,:,1:n)
      .mat(2,:,n+1:n+n) = -.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) =  .mat(3,:,1:n)
   end

   times_sigma_d(n)
   ! Direct product with sigma-d. Equation of sigma-d is sin(alph/4)*x-cos(alph/4)*y=0                               
      INT :: n
      DBL :: beta,cosb,sinb
      beta = PI/.axis_order 
      cosb = cos(beta) 
      sinb = sin(beta) 
      .mat(1,:,n+1:n+n) = cosb*.mat(1,:,1:n) + sinb*.mat(2,:,1:n)
      .mat(2,:,n+1:n+n) = sinb*.mat(1,:,1:n) - cosb*.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = .mat(3,:,1:n)
   end

   times_c2x(n)
   ! Direct product with C2x, for Dn groups
      INT :: n
      .mat(1,:,n+1:n+n) =  .mat(1,:,1:n)
      .mat(2,:,n+1:n+n) = -.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = -.mat(3,:,1:n)
   end

   times_c4z(n)
   ! Direct product with the C4z matrix
      INT :: n
      .mat(:,1,n+1:n+n) = -.mat(:,2,1:n)
      .mat(:,2,n+1:n+n) =  .mat(:,1,1:n)
      .mat(:,3,n+1:n+n) =  .mat(:,3,1:n)
   end

   make_cn_matrices
   ! Make the Cn rotation matrices
      DBL :: alph,alpha,cosa,sina
      INT :: n
      alph = TWO*PI/.axis_order 
      alpha = ZERO
      do n = 2, .axis_order
         alpha = alpha + alph
         cosa = cos(alpha)
         sina = sin(alpha)
         .mat(:,:,n) = reshape((/cosa,-sina, ZERO, sina, cosa, ZERO, ZERO, ZERO, ONE/), (/3,3/))
      end 
   end

   make_sn_matrices(n)
   ! Make the Sn rotation matrices
      INT :: n
      DBL :: beta,cosb,sinb
      beta = PI/.axis_order 
      cosb = cos(beta) 
      sinb = sin(beta) 
      .mat(1,:,n+1:n+n) =  cosb*.mat(1,:,1:n) + sinb*.mat(2,:,1:n)
      .mat(2,:,n+1:n+n) = -sinb*.mat(1,:,1:n) + cosb*.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = -.mat(3,:,1:n)
   end

   make_t_matrices
   ! Make the Tetrahedral group 3x3 representation matrices
      INT :: n
      n = 1
      .mat(:,:,2) = reshape((/  ONE, ZERO, ZERO, ZERO, -ONE, ZERO, ZERO, ZERO, -ONE/), (/3,3/)) ! C2x
      .mat(:,:,3) = reshape((/ -ONE, ZERO, ZERO, ZERO,  ONE, ZERO, ZERO, ZERO, -ONE/), (/3,3/)) ! C2y
      .mat(:,:,4) = reshape((/ -ONE, ZERO, ZERO, ZERO, -ONE, ZERO, ZERO, ZERO,  ONE/), (/3,3/)) ! C2z
      do n = 5, 12
         .mat(:,1,n) = .mat(:,3,n-4)
         .mat(:,2,n) = .mat(:,1,n-4)
         .mat(:,3,n) = .mat(:,2,n-4)
      end 
   end

   make_xyz_matrices [leaky]
   ! Make the representation matrices for xyz products found in
   ! gaussian shells, i.e. work out matrix R, where the shell row vector
   ! p'(r) = p(S^{-1}r) = p(r)R, and S is the symop.
      INT :: n,j
      DBL :: sqrt3,sqrt5,sqrt15
      IVEC(6)  :: d1 = (/1,2,3,1,1,2/)
      IVEC(6)  :: d2 = (/1,2,3,2,3,3/)
      IVEC(10) :: f1 = (/1,2,3,1,1,2,2,3,3,1/)
      IVEC(10) :: f2 = (/1,2,3,1,1,2,2,3,3,2/) 
      IVEC(10) :: f3 = (/1,2,3,2,3,1,3,1,2,3/) 
      sqrt3 = dsqrt(THREE)
      sqrt5 = dsqrt(FIVE)
      sqrt15= dsqrt(15.0D0)
      .ptr => .mat
      .dtr.create(6,6,.order)
      do n = 1,.order
         do j = 1,6
            .dtr(1,j,n)  = .ptr(1,d1(j),n)*.ptr(1,d2(j),n)
            .dtr(2,j,n)  = .ptr(2,d1(j),n)*.ptr(2,d2(j),n)
            .dtr(3,j,n)  = .ptr(3,d1(j),n)*.ptr(3,d2(j),n)
            .dtr(4,j,n)  = .ptr(1,d1(j),n)*.ptr(2,d2(j),n) &
                         + .ptr(2,d1(j),n)*.ptr(1,d2(j),n)
            .dtr(5,j,n)  = .ptr(1,d1(j),n)*.ptr(3,d2(j),n) &
                         + .ptr(3,d1(j),n)*.ptr(1,d2(j),n)
            .dtr(6,j,n)  = .ptr(2,d1(j),n)*.ptr(3,d2(j),n) &
                         + .ptr(3,d1(j),n)*.ptr(2,d2(j),n)
         end
         .dtr(1:6,4:6,n) = .dtr(1:6,4:6,n)*sqrt3 ! Put in correct normalization for old primitives
         .dtr(4:6,1:6,n) = .dtr(4:6,1:6,n)/sqrt3 ! Put in wrong   normalization for new primitives
      end
      .ftr.create(10,10,.order)
      do n = 1,.order
         do j = 1,10
            .ftr(1,j,n)  = .ptr(1,f1(j),n)*.ptr(1,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(2,j,n)  = .ptr(2,f1(j),n)*.ptr(2,f2(j),n)*.ptr(2,f3(j),n)
            .ftr(3,j,n)  = .ptr(3,f1(j),n)*.ptr(3,f2(j),n)*.ptr(3,f3(j),n)
            .ftr(4,j,n)  = .ptr(1,f1(j),n)*.ptr(1,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(1,f1(j),n)*.ptr(2,f2(j),n)*.ptr(1,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(1,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(5,j,n)  = .ptr(1,f1(j),n)*.ptr(1,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(1,f1(j),n)*.ptr(3,f2(j),n)*.ptr(1,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(1,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(6,j,n)  = .ptr(1,f1(j),n)*.ptr(2,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(1,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(2,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(7,j,n)  = .ptr(3,f1(j),n)*.ptr(2,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(3,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(2,f2(j),n)*.ptr(3,f3(j),n)
            .ftr(8,j,n)  = .ptr(1,f1(j),n)*.ptr(3,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(1,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(3,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(9,j,n)  = .ptr(2,f1(j),n)*.ptr(3,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(2,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(3,f2(j),n)*.ptr(2,f3(j),n)
            .ftr(10,j,n) = .ptr(1,f1(j),n)*.ptr(2,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(1,f1(j),n)*.ptr(3,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(1,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(3,f2(j),n)*.ptr(1,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(1,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(2,f2(j),n)*.ptr(1,f3(j),n)
         end
         .ftr(1:10, 4:9 ,n) = .ftr(1:10, 4:9 ,n)*sqrt5
         .ftr(1:10,10:10,n) = .ftr(1:10,10:10,n)*sqrt15
         .ftr(4:9 , 1:10,n) = .ftr(4:9 , 1:10,n)/sqrt5
         .ftr(10:10,1:10,n) = .ftr(10:10,1:10,n)/sqrt15
      end
   end

   xyz_matrix(n,l) result(res) [leaky]
   ! Return the "n"-th representation matrix for xyz product found in
   ! a gaussian shell of angular momentum "l"
      INT :: n,l
      MAT, PTR :: res
      INT :: dim
      ENSURE(l>=0,"l must be non-negative")
      ENSURE(l<4, "l must be less than 4")
      dim = (l+1)*(l+2)/2
      nullify(res)
      res.create(dim,dim)
      select case (l)
         case(0); res = .irrep(1)%mat(:,:,n)
         case(1); res = .ptr(1:3 ,1:3 ,n)
         case(2); res = .dtr(1:6 ,1:6 ,n)
         case(3); res = .ftr(1:10,1:10,n)
      end
   end

   make_inverse [leaky]
   ! Make the inverse operator list
      INT :: m,n
      DBL :: test
      .inverse.create(.order)
      do m = 1,.order
         do n = 1,.order
            test = .mat(:,:,m).trace_of_product( .mat(:,:,n)) - THREE
            if (abs(test)>0.001d0) cycle
            .inverse(m) = n
            exit
         end 
      end 
   end

   make_table [leaky]
   ! Make the group multiplication table
      INT :: l,m,n
      BIN :: same
      MAT(3,3) :: prod
      .table.create(.order,.order)
      do l = 1,.order
      do m = 1,.order
         prod.to_product(.mat(:,:,l),.mat(:,:,m))
         do n = 1,.order
            same = .mat(:,:,n).equals(prod)
            if (same) exit
         end 
         .table(l,m) = n
      end 
      end 
   end

   make_irrep_matrices [leaky]
   ! Make the Irreps for the group 
      if (.ID_number<=10) .make_C_type_irreps
      if (.ID_number>=13) .make_T_type_irreps
   end

   make_C_type_irreps [leaky]
   ! Make irrep matrices for the groups C1, Cs, Ci, Cn, Cnh, Cnv, S2n, Dn, Dnh, Dnd
      BIN :: odd_axis
      INT :: e, i, n, n_max, dim
      DBL :: theta
      MAT3(2,2, 14), target :: gen1, gen2, gen3  ! generator matrices
      MAT3, PTR :: mat
      MAT, PTR :: g1,g2,g3
      odd_axis = NOT .axis_order==2*(.axis_order/2)
      select case (.ID_symbol)
         case ("c1")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_irrep = 1 
            .irrep.create(.n_irrep)
            .irrep(1)%dimension = 1
            e = 2
            .n_gen = 1
            gen1(1,1, 1) =  ONE
         case ("cs","ci")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_irrep = 2 
            .irrep.create(.n_irrep)
            .irrep(1:2)%dimension = 1
            e = 3
            .n_gen = 1
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) = -ONE 
         case ("cn")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            if (.axis_order>2) .has_complex_irreps = TRUE
            .n_gen = 1
            gen1(1,1, 1) =  ONE
            if (odd_axis) then
               .n_irrep = (.axis_order+1)/2 
               .irrep.create(.n_irrep)
               .irrep(1)%dimension = 1
               e = 2 
            else
               .n_irrep = .axis_order/2 + 1 
               .irrep.create(.n_irrep)
               .irrep(1:2)%dimension = 1
               e = 3 
               gen1(1,1, 2) = -ONE 
            end
            .make_cn_gen(e,gen1,.axis_order)
         case ("s2n")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            if (.axis_order>=2) .has_complex_irreps = TRUE
            .n_irrep = .axis_order + 1 
            .irrep.create(.n_irrep)
            .irrep(1:2)%dimension = 1
            e = 3 
            .n_gen = 2
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            .make_cn_gen(e,gen2,2*.axis_order)
            .make_cn_gen(e,gen1,.axis_order)
         case ("cnh")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            if (.axis_order>2) .has_complex_irreps = TRUE
            .n_gen = 2
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            if (odd_axis) then
               .n_irrep = .axis_order + 1
               .irrep.create(.n_irrep)
               .irrep(1:2)%dimension = 1
               e = 3
            else
               .n_irrep = .axis_order + 2
               .irrep.create(.n_irrep)
               .irrep(1:4)%dimension = 1
               e = 5
               gen1(1,1, 3) = -ONE
               gen1(1,1, 4) = -ONE
               gen2(1,1, 3) =  ONE
               gen2(1,1, 4) = -ONE
            end
            .make_cnh_gen(e,gen1,gen2)
         case ("cnv","dn")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_gen = 2
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            if (odd_axis) then
               .n_irrep = (.axis_order + 3)/2
               .irrep.create(.n_irrep)
               .irrep(1:2)%dimension = 1
               e = 3
            else
               .n_irrep = .axis_order/2 + 3
               .irrep.create(.n_irrep)
               .irrep(1:4)%dimension = 1
               e = 5
               gen1(1,1, 3) = -ONE
               gen1(1,1, 4) = -ONE
               gen2(1,1, 3) =  ONE
               gen2(1,1, 4) = -ONE
            end
            .make_sigma_x_gen(e,gen2)
            .make_cn_gen(e,gen1,.axis_order)
         case ("dnh")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_gen = 3
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            gen2(1,1, 3) =  ONE
            gen2(1,1, 4) = -ONE
            gen3(1,1, 1) =  ONE
            gen3(1,1, 2) =  ONE
            if (odd_axis) then
               .n_irrep = .axis_order + 3
               .irrep.create(.n_irrep)
               .irrep(1:4)%dimension = 1
               e = 5
               gen3(1,1, 3) = -ONE 
               gen3(1,1, 4) = -ONE 
               gen1(1,1, 3) =  ONE ! Warning, possible error, Changed from gen3 to gen1; the first two could be gen1
               gen1(1,1, 4) =  ONE ! Warning, possible error, Changed from gen3 to gen1
            else
               .n_irrep = .axis_order + 6
               .irrep.create(.n_irrep)
               .irrep(1:8)%dimension = 1
               e = 9
               gen1(1,1, 3) = -ONE
               gen1(1,1, 4) = -ONE
               gen1(1,1, 5) =  ONE
               gen1(1,1, 6) =  ONE
               gen1(1,1, 7) = -ONE
               gen1(1,1, 8) = -ONE
               gen2(1,1, 5) =  ONE
               gen2(1,1, 6) = -ONE
               gen2(1,1, 7) =  ONE
               gen2(1,1, 8) = -ONE
               gen3(1,1, 3) =  ONE
               gen3(1,1, 4) =  ONE
               gen3(1,1, 5) = -ONE
               gen3(1,1, 6) = -ONE
               gen3(1,1, 7) = -ONE
               gen3(1,1, 8) = -ONE
            end
            do i = e,.n_irrep
               gen3(1,1, i) =  ONE
               gen3(2,2, i) = -ONE
               gen3(2,1, i) = ZERO   ! Transposed
               gen3(1,2, i) = ZERO
            end 
            .make_cnh_gen(e,gen1,gen2)
         case ("dnd")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_irrep = .axis_order + 3 
            .irrep.create(.n_irrep)
            .irrep(1:4)%dimension = 1
            e = 5 
            .n_gen = 3
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen1(1,1, 3) =  ONE 
            gen1(1,1, 4) =  ONE 
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            gen2(1,1, 3) =  ONE 
            gen2(1,1, 4) = -ONE 
            gen3(1,1, 1) =  ONE 
            gen3(1,1, 2) =  ONE 
            gen3(1,1, 3) = -ONE 
            gen3(1,1, 4) = -ONE 
            do i = e,.n_irrep
               theta = (i-e+1)*PI/.axis_order
               gen3(1,1, i) =  cos(theta)
               gen3(2,2, i) = -cos(theta)
               gen3(2,1, i) =  sin(theta) ! Transposed
               gen3(1,2, i) =  sin(theta)
            end 
            .make_sigma_x_gen(e,gen2)
            .make_cn_gen(e,gen1,.axis_order)
      end
      do i = 1, .n_irrep
         dim = .irrep(i)%dimension
         .irrep(i)%mat.create(dim,dim, .order)
         mat => .irrep(i)%mat
         g1  => gen1(1:dim,1:dim,i)
         g2  => gen2(1:dim,1:dim,i)
         g3  => gen3(1:dim,1:dim,i)
         mat(:,:,1).to_unit_mat
         n_max = .axis_order
         if (.ID_symbol=="c1") cycle
         if (.ID_symbol=="cs") n_max = 2
         if (.ID_symbol=="ci") n_max = 2
         do n = 2,n_max
            mat(:,:,n) = matmul(g1,mat(:,:,n-1))
         end 
         if (.n_gen==1) cycle
         do n = 1,n_max
            mat(:,:,n_max+n) = matmul(g2,mat(:,:,n))
         end 
         if (.n_gen==2) cycle
         n_max = 2*n_max
         do n = 1,n_max
            mat(:,:,n_max+n) = matmul(g3,mat(:,:,n))
         end 
      end 
   end

   make_cnh_gen(e,gen1,gen2)
   ! Make the Cnh generator matrices for the irreps
      INT :: e,i,m
      MAT3(2,2, 14) :: gen1, gen2
      DBL :: sign,theta
      do i = e,.n_irrep
         .irrep(i)%dimension = 2
         m = (i-e+2)/2
         theta = m*TWO*PI/.axis_order
         gen1(1,1, i) =  cos(theta)
         gen1(2,2, i) =  cos(theta)
         gen1(2,1, i) = -sin(theta) ! Transposed
         gen1(1,2, i) =  sin(theta)
      end 
      sign = ONE 
      do i = e,.n_irrep
         sign = -sign
         gen2(1,1, i) = sign
         gen2(2,2, i) = sign
         gen2(2,1, i) = ZERO ! Transposed
         gen2(1,2, i) = ZERO
      end 
   end

   make_sigma_x_gen(e,gen2)
   ! Make the sigma-x generator matrices for the irreps
      INT :: e,i
      MAT3(2,2, 14) :: gen2
      do i = e,.n_irrep
         gen2(1,1, i) =  ONE
         gen2(2,2, i) = -ONE
         gen2(2,1, i) = ZERO ! Transposed
         gen2(1,2, i) = ZERO
      end 
   end

   make_cn_gen(e,gen1,axis_order)
   ! Make the Cn generator matrices for the irreps
      INT :: e,axis_order,i
      MAT3(2,2, 14) :: gen1
      DBL :: theta
      do i = e,.n_irrep
         .irrep(i)%dimension = 2
         theta = (i-e+1)*TWO*PI/axis_order
         gen1(1,1, i) =  cos(theta)
         gen1(2,2, i) =  cos(theta)
         gen1(2,1, i) = -sin(theta) ! Transposed
         gen1(1,2, i) =  sin(theta)
      end
   end
      
   make_T_type_irreps [leaky]
   ! Make irrep matrices for the groups T, Th, Td, O, and Oh 
   ! Must have already generated the 3x3 rep matrices
      IMAT(10,5) :: irrep_dimension = reshape( &               ! Irrep dimensions for T-groups
                         (/ 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, &    ! T
                            1, 2, 3, 1, 2, 3, 0, 0, 0, 0, &    ! Th
                            1, 1, 2, 3, 3, 0, 0, 0, 0, 0, &    ! Td
                            1, 1, 2, 3, 3, 0, 0, 0, 0, 0, &    ! O
                            1, 1, 2, 3, 3, 1, 1, 2, 3, 3 /), & ! Oh
                          (/10,5/))
      IVEC(5) :: n_irrep  = (/ 3, 6, 5, 5, 10 /)               ! No of irreps
      IVEC(5) :: ab_irrep = (/ 0, 4, 2, 2, 2  /)               ! A irreps
      IVEC(5) :: ea_irrep = (/ 2, 2, 3, 3, 3  /)               ! E irreps 
      IVEC(5) :: eb_irrep = (/ 0, 5, 0, 0, 8  /)               ! E irreps
      IVEC(5) :: fa_irrep = (/ 3, 6, 5, 4, 9  /)               ! F irreps
      IVEC(5) :: fb_irrep = (/ 0, 0, 4, 5, 10 /)               ! F irreps
      INT :: i, n, id, dim
      INT :: ab,ea,eb,fa,fb
      DBL :: pt5,r32
      .has_complex_irreps = FALSE
      if (.ID_symbol=="t" ) .has_complex_irreps = TRUE
      if (.ID_symbol=="td") .has_complex_irreps = TRUE
      id = .ID_number - 12
      .n_irrep = n_irrep(id)
      .irrep.create(.n_irrep)
      .irrep%dimension = irrep_dimension(1:.n_irrep,id)
      do i = 1,.n_irrep
         dim = .irrep(i)%dimension
         .irrep(i)%mat.create(dim,dim,.order)
      end

      .irrep(1)%mat(1,1,:) = ONE
      
      pt5 = HALF
      r32 = sqrt(THREE)/TWO
      ea = ea_irrep(id)
      .irrep(ea)%mat(1,1,1:4)  =  ONE
      .irrep(ea)%mat(2,1,1:4)  = ZERO
      .irrep(ea)%mat(1,2,1:4)  = ZERO
      .irrep(ea)%mat(2,2,1:4)  =  ONE

      .irrep(ea)%mat(1,1,5:8)  = -pt5
      .irrep(ea)%mat(2,1,5:8)  = -r32
      .irrep(ea)%mat(1,2,5:8)  =  r32
      .irrep(ea)%mat(2,2,5:8)  = -pt5

      .irrep(ea)%mat(1,1,9:12) = -pt5
      .irrep(ea)%mat(2,1,9:12) =  r32
      .irrep(ea)%mat(1,2,9:12) = -r32
      .irrep(ea)%mat(2,2,9:12) = -pt5

      fa = fa_irrep(id) 
      .irrep(fa)%mat(:,:,:) = .mat(:,:,:)

      if (.ID_symbol=="t") return

      ab = ab_irrep(id)
      .irrep(ab)%mat(1,1, 1:12) =  ONE
      .irrep(ab)%mat(1,1,13:24) = -ONE
      if (.ID_symbol=="oh") then             
         .irrep(2)%mat(1,1,25:48) =  .irrep(2)%mat(1,1, 1:24) 
         .irrep(6)%mat(1,1, 1:24) =  ONE
         .irrep(6)%mat(1,1,25:48) = -ONE
         .irrep(7)%mat(1,1, 1:24) =  .irrep(2)%mat(1,1, 1:24) 
         .irrep(7)%mat(1,1,25:48) = -.irrep(2)%mat(1,1, 1:24) 
      end

      .irrep(ea)%mat(:,:,13:24)   =  .irrep(ea)%mat(:,:,1:12) 
      n = .order/2
      if (.ID_symbol=="th" OR .ID_symbol=="oh") then  
         .irrep(ea)%mat(:,:,n+1:n+n) =  .irrep(ea)%mat(:,:,1:n) 
         eb = eb_irrep(id)
         .irrep(eb)%mat(:,:,  1:  n) =  .irrep(ea)%mat(:,:,  1:  n) 
         .irrep(eb)%mat(:,:,n+1:n+n) = -.irrep(ea)%mat(:,:,n+1:n+n) 
      end

      if (.ID_symbol=="th") then              
         .irrep(3)%mat(:,:, 1:12) =  .irrep(6)%mat(:,:, 1:12) 
         .irrep(3)%mat(:,:,13:24) =  .irrep(6)%mat(:,:, 1:12) 
      else  
         fb = fb_irrep(id)
         fa = fa_irrep(id)
         .irrep(fb)%mat(:,:, 1:12) =  .irrep(fa)%mat(:,:, 1:12) 
         .irrep(fb)%mat(:,:,13:24) = -.irrep(fa)%mat(:,:,13:24) 
         if (.ID_symbol=="oh") then
            .irrep(10)%mat(:,:,25:48) = -.irrep(10)%mat(:,:, 1:24) 
            .irrep(4)%mat(:,:, 1:24)  =  .irrep(9)%mat(:,:, 1:24) 
            .irrep(5)%mat(:,:, 1:24)  =  .irrep(10)%mat(:,:, 1:24) 
            .irrep(4)%mat(:,:,25:48)  =  .irrep(9)%mat(:,:, 1:24) 
            .irrep(5)%mat(:,:,25:48)  =  .irrep(10)%mat(:,:, 1:24) 
         end
      end
   end

   make_character_table [leaky]
   ! MAke the character table
      INT :: n,i
      do i = 1, .n_irrep
         .irrep(i)%character.create(.order)
         do n = 1, .order
            .irrep(i)%character(n) = .irrep(i)%mat(:,:,n).trace
         end 
      end 
   end

   make_irrep_labels
   ! Make the names for the symmetry irreducible representations 
   ! The irrep object must already be created and dimensioned correctly.
      STR(41) :: warn_str = "can't label irreps for groups larger than"
      WARN_IF(.ID_symbol=="cn"  AND .axis_order>9, warn_str // " C9")
      WARN_IF(.ID_symbol=="s2n" AND .axis_order>8, warn_str // " S8")
      WARN_IF(.ID_symbol=="cnh" AND .axis_order>6, warn_str // " C6h")
      WARN_IF(.ID_symbol=="cnv" AND .axis_order>6, warn_str // " C6v")
      WARN_IF(.ID_symbol=="dn"  AND .axis_order>6, warn_str // " D6")
      WARN_IF(.ID_symbol=="dnh" AND .axis_order>8, warn_str // " D8h")
      WARN_IF(.ID_symbol=="dnd" AND .axis_order>6, warn_str // " D6d")
      .irrep%label = "?"
      select case (.ID_symbol)
         case ("c1"); .irrep%label = (/"A   "/)
         case ("cs"); .irrep%label = (/"A'  ", "A'' "/)
         case ("ci"); .irrep%label = (/"Ag  ", "Au  "/)
         case ("cn") 
            select case (.axis_order)
            case (1); .irrep%label = (/"A   "/)
            case (2); .irrep%label = (/"A   ", "B   "/)
            case (3); .irrep%label = (/"A   ", "E   "/)
            case (4); .irrep%label = (/"A   ", "B   ", "E   "/)
            case (5); .irrep%label = (/"A   ", "E1  ", "E2  "/)
            case (6); .irrep%label = (/"A   ", "B   ", "E1  ", "E2  "/)
            case (7); .irrep%label = (/"A   ", "E1  ", "E2  ", "E3  "/)
            case (8); .irrep%label = (/"A   ", "B   ", "E1  ", "E2  ", "E3  "/)
            case (9); .irrep%label = (/"A   ", "E1  ", "E2  ", "E3  ", "E4  "/)
            end
         case ("s2n")
            select case (.axis_order)
            case (1); .irrep%label = (/"Ag  ", "Au  "/)
            case (2); .irrep%label = (/"A   ", "B   ", "E   "/)
            case (3); .irrep%label = (/"Ag  ", "Au  ", "Eu  ", "Eg  "/)
            case (4); .irrep%label = (/"A   ", "B   ", "E1  ", "E2  ", "E3  "/) 
            end
         case ("cnh")
            select case (.axis_order)
            case (1); .irrep%label = (/"A'  ", "A'' "/)
            case (2); .irrep%label = (/"Ag  ", "Au  ", "Bu  ", "Bg  "/)
            case (3); .irrep%label = (/"A'  ", "A'' ", "E'' ", "E'  "/)
            case (4); .irrep%label = (/"Ag  ", "Au  ", "Bg  ", "Bu  ", "Eg  ", &
                                       "Eu  "/)
            case (5); .irrep%label = (/"A'  ", "A'' ", "E1''", "E1' ", "E2''", &
                                       "E2' "/)
            case (6); .irrep%label = (/"Ag  ", "Au  ", "Bu  ", "Bg  ", "E1g ", &
                                       "E1u ", "E2u ", "E2g "/)
            end
         case ("cnv")
            select case (.axis_order)
            case (1); .irrep%label = (/"A'  ", "A'' "/)
            case (2); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  "/)
            case (3); .irrep%label = (/"A1  ", "A2  ", "E   "/)
            case (4); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E   "/)
            case (5); .irrep%label = (/"A1  ", "A2  ", "E1  ", "E2  "/)
            case (6); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E1  ", &
                                       "E2  "/)
            end
         case ("dn") 
            select case (.axis_order)
            case (1); .irrep%label = (/"A1  ", "B   "/)
            case (2); .irrep%label = (/"A   ", "B1  ", "B3  ", "B2  "/)
            case (3); .irrep%label = (/"A1  ", "A2  ", "E   "/)
            case (4); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E   "/)
            case (5); .irrep%label = (/"A1  ", "A2  ", "E1  ", "E2  "/)
            case (6); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E1  ", &
                                       "E2  "/)
            end
         case ("dnh") 
            select case (.axis_order)
            case (1); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  "/)
            case (2); .irrep%label = (/"Ag  ", "Au  ", "B3u ", "B3g ", "B1g ", &
                                       "B1u ", "B2u ", "B2g "/)
            case (3); .irrep%label = (/"A1' ", "A1''", "A2' ", "A2''", "E'' ", &
                                       "E'  "/)
            case (4); .irrep%label = (/"A1g ", "A1u ", "B1g ", "B1u ", "A2g ", &
                                       "A2u ", "B2g ", "B2u ", "Eg  ", "Eu  "/)
            case (5); .irrep%label = (/"A1' ", "A1''", "A2' ", "A2''", "E1''", &
                                       "E1' ", "E2''", "E2' "/)
            case (6); .irrep%label = (/"A1g ", "A1u ", "B1u ", "B1g ", "A2g ", &
                                       "A2u ", "B2u ", "B2g ", "E1g ", "E1u ", &
                                       "E2u ", "E2g "/)
            case (8); .irrep%label = (/"A1g ", "A1u ", "A2g ", "A2u ", "B1g ", &
                                       "B1u ", "B2g ", "B2u ", "E1g ", "E1u ", &
                                       "E2u ", "E2g ", "E3g ", "E3u "/)
            case (7); DIE("No such group as d7h")
            end
         case ("dnd")
            select case (.axis_order)
            case (1); .irrep%label = (/"Ag  ", "Au  ", "Bu  ", "Bg  "/)
            case (2); .irrep%label = (/"A1  ", "B2  ", "B1  ", "A2  ", "E   "/)
            case (3); .irrep%label = (/"A1g ", "A2u ", "A1u ", "A2g ", "Eu  ", &
                                       "Eg  "/)
            case (4); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E1  ", &
                                       "E2  ", "E3  "/)
            case (5); .irrep%label = (/"A1g ", "A1u ", "A2u ", "A2g ", "E2u ", &
                                       "E1g ", "E1u ", "E2g "/)
            case (6); .irrep%label = (/"A1  ", "B2  ", "B1  ", "A2  ", "E1  ", &
                                       "E2  ", "E3  ", "E4  ", "E5  "/)
            end
         case ("t");  .irrep%label = (/"A   ", "E   ", "F   "/)
         case ("th"); .irrep%label = (/"Ag  ", "Eg  ", "Fg  ", "Au  ", "Eu  ", &
                                       "Fu  "/)
         case ("td"); .irrep%label = (/"A1  ", "A2  ", "E   ", "F1  ", "F2  "/)
         case ("o");  .irrep%label = (/"A1  ", "A2  ", "E   ", "F1  ", "F2  "/)
         case ("oh"); .irrep%label = (/"A1g ", "A2g ", "Eg  ", "F1g ", "F2g ", &
                                       "A1u ", "A2u ", "Eu  ", "F1u ", "F2u "/)
         case ("i");  .irrep%label = (/"A   ", "F1  ", "F2  ", "G   ", "H   "/)
         case ("ih"); .irrep%label = (/"Ag  ", "F1g ", "F2g ", "Gg  ", "Hg  ", &
                                       "Au  ", "F1u ", "F2u ", "Gu  ", "Hu  "/)
      end 
   end

   put(out)
   ! Display the pointgroup data to output file "out".
      OUTPUT :: out
      INT :: i,n,dim
      INT :: block,n_block,f,l
      out.flush
      out.put_text("POINTGROUP output:",flush=2)
      out.show("Symbol                  =",.symbol, int_width=TRUE)
      out.show("ID_symbol               =",.ID_symbol, int_width=TRUE)
      out.show("ID_number               =",.ID_number)
      out.show("Principal axis order    =",.axis_order)
      out.show("Order                   =",.order)
      out.show("No. of Irreps           =",.n_irrep)
      out.show("No. of Irrep generators =",.n_gen)
      out.show("Has complex irreps?     =",.has_complex_irreps)

      out.flush
      out.put_text("List of inverse group elements :",flush=2)
      out.put(.inverse)

      out.flush
      out.put_text("Group multiplication table :",flush=2)
      out.put(.table)

      out.flush
      out.put_text("Character Table :")
      n_block = (.order-1)/out%fields + 1
      do block = 1,n_block
         f = 1 + (block-1)*out%fields
         l = min(f+out%fields-1,.order)
         out.flush                          ! Banner
         out.put_dash(int_fields=1,dbl_fields=min(out%fields,.order),flush=1)
         out.tab(int_fields=1)
         do n = f,l
            out.put(n,dbl_width=TRUE)
         end
         out.flush
         out.put_dash(int_fields=1,dbl_fields=min(out%fields,.order),flush=1)
         do i = 1,.n_irrep                     ! The actual table
            out.put_text(.irrep(i)%label,int_width=TRUE)
            do n = f,l
               out.put(.irrep(i)%character(n))
            end
            out.flush
         end
         out.put_dash(int_fields=1,dbl_fields=min(out%fields,.order),flush=1)
      end

      out.flush
      out.put_text("3x3 Representation matrices :",flush=1)
      do n = 1,.order
        out.flush
        out.put_text("Matrix number " // n.to_str ,flush=1)
        out.put(.mat(:,:,n))
      end

      out.flush
      out.put_text("Irrep matrices :",flush=1)
      do i = 1,.n_irrep
        out.flush
        dim = .irrep(i)%dimension
        out.put_text("Irrep " // trim( .irrep(i)%label) // ", dimension " &
                    // trim( dim.to_str) // ":" ,flush=1)
        if (dim==1) then
           out.put(.irrep(i)%mat(1,1,:))
        else
           do n = 1,.order
              out.put_text("Matrix number " // n.to_str ,flush=1)
              out.put(.irrep(i)%mat(:,:,n))
           end
        end
      end
   end

   main
   ! Main routine to test the pointgroup object
      PTR :: self
      INPUT, PTR :: in
      OUTPUT, PTR :: out
      in.create("pointgroup.in")
      in.open
      out.create("pointgroup.out")
      out.open
      std_output=>out
      std_error.set_put_file(out)
      .create
      .read(in)
      .put(out)
      .destroy
   end

end
