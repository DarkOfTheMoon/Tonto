! $Id$
!-------------------------------------------------------------------------------
!
!  POINTGROUP : for deriving and manipulating pointgroup objects
!
!  Input required is the Schonflies symbol. The data generated are
!  The 3x3 rotation matrices, all the irreducible representations,
!  The character table, the irreducible representation lables,
!  the group multiplication table, and the list of inverse operators
!
!  (c) copyright 1994, 1995, 1996, 1997, Anthony  J. Russell
!  (c) 1998, Dylan Jayatilaka
!-------------------------------------------------------------------------------
module POINTGROUP

   use TYPES
   use SYSTEM
   use STR
   use INT
   use IVEC
   use IMAT
   use VEC
   use MAT
   use MAT3
   use TEXTFILE
   use IRREP
   use IRREPVEC

   implicit none

#  include "macros"
#  include "pointgroup.int"

!   type pointgroup_type
!
!   CHR(4) :: symbol
!   ! symmetry symbol
!
!   CHR(4) :: ID_symbol
!   ! group id symbol
!
!   INT :: ID_number
!   ! group id number
!
!   INT :: axis_order
!   ! principal axis order
!
!   INT :: order
!   ! order of the group
!
!   INT :: n_irrep
!   ! no of irreducible representations
!
!   INT :: n_gen
!   ! No. of generators
!
!   BIN :: has_complex_irreps
!   ! true if the group has complex irreps
!
!   IMAT, PTR :: table DEFAULT_NULL
!   ! group multiplication table
!
!   MAT3, PTR :: mat DEFAULT_NULL
!   ! 3x3 representation matrices
!
!   MAT3, PTR :: ptr DEFAULT_NULL
!   ! 3x3 representation matrices for p functions, same as mat
!
!   MAT3, PTR :: dtr DEFAULT_NULL
!   ! 6x6 representation matrices for d functions
!
!   MAT3, PTR :: ftr DEFAULT_NULL
!   ! 10x10 representation matrices for f functions
!
!   IVEC, PTR :: inverse DEFAULT_NULL
!   ! Indices of inverse group elements
!
!   IRREPVEC, PTR :: irrep DEFAULT_NULL
!   ! List of irrrducible representations
!
!   end

contains    

   create
   ! Create a pointgroup object
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(POINTGROUP_SIZE)
      .nullify_ptr_part
   end

   create(symbol)
   ! Create a pointgroup object
      PTR :: self
      STR(*) :: symbol
      nullify(self)
      allocate(self)
      ADD_MEM(POINTGROUP_SIZE)
      .nullify_ptr_part
      .set_symbol(symbol)
      .analyse
   end

   destroy 
   ! Destroy a pointgroup object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(POINTGROUP_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   nullify_ptr_part
      nullify(.table)
      nullify(.mat)
      nullify(.ptr)
      nullify(.dtr)
      nullify(.ftr)
      nullify(.inverse)
      nullify(.irrep)
   end

   destroy_ptr_part
      .table.destroy
      .mat.destroy
!      .ptr.destroy
      nullify( .ptr )
      .dtr.destroy
      .ftr.destroy
      .inverse.destroy
      .irrep.destroy
   end
   
   set_symbol(symbol)
   ! Set the pointgroup Schonflies symbol
      CHR(*) :: symbol
      .symbol = symbol
      .ID_symbol = symbol
      .ID_symbol.to_lower_case
   end

   read(in)
   ! Read the group symbol and analyse the spacegroup
      TEXTFILE :: in
      STR :: word
      in.read(word)
      .set_symbol(word)
      .analyse
   end

   set_default
   ! Set the default pointgroup, "C1"
      .set_symbol("C1")
      .analyse
   end

   analyse [leaky]
   ! Analyse the pointgroup 
      .analyse_symbol
      .make_rep_matrices
      .make_xyz_matrices
      .make_inverse
      .make_table
      .make_irrep_matrices
      .make_irrep_labels
      .make_character_table
   end

   analyse_symbol
   ! Analyse the pointgroup symbol
      STR :: axis
      INT :: n
      BIN :: temp_bin
      select case (.ID_symbol) 
         case ("c1");      .ID_number=1;  .ID_symbol="c1 "
         case ("cs");      .ID_number=2;  .ID_symbol="cs "
         case ("ci");      .ID_number=3;  .ID_symbol="ci "
         case ("c2 ","c3 ","c4 ","c5 ","c6 ","c7 ","c8 ","c9 ","c10 ","c11 ","c12 "); .ID_number=4;  .ID_symbol="cn "
         case ("s2 ","s4 ","s6 ","s8 ","s10","s12");                                  .ID_number=5;  .ID_symbol="s2n"
         case ("c2h","c3h","c4h","c5h","c6h","c7h","c8h","c9h","c10h","c11h","c12h"); .ID_number=6;  .ID_symbol="cnh"
         case ("c2v","c3v","c4v","c5v","c6v","c7v","c8v","c9v","c10v","c11v","c12v"); .ID_number=7;  .ID_symbol="cnv"
         case ("d2 ","d3 ","d4 ","d5 ","d6 ","d7 ","d8 ","d9 ","d10 ","d11 ","d12 "); .ID_number=8;  .ID_symbol="dn "
         case ("d2h","d3h","d4h","d5h","d6h","d7h","d8h","d9h","d10h","d11h","d12h"); .ID_number=9;  .ID_symbol="dnh"
         case ("d2d","d3d","d4d","d5d","d6d","d7d","d8d","d9d","d10d","d11d","d12d"); .ID_number=10; .ID_symbol="dnd"
         case ("cinfv");   .ID_number=11; .ID_symbol="cinf"
         case ("dinfh");   .ID_number=12; .ID_symbol="dinf"
         case ("t ");      .ID_number=13; .ID_symbol="t  "
         case ("th");      .ID_number=14; .ID_symbol="th "
         case ("td");      .ID_number=15; .ID_symbol="td "
         case ("o ");      .ID_number=16; .ID_symbol="o  "
         case ("oh");      .ID_number=17; .ID_symbol="oh "
         case ("i ");      .ID_number=18; .ID_symbol="i  "
         case ("ih");      .ID_number=19; .ID_symbol="ih "
         case default;     .ID_number=20
      end
      temp_bin = any(.ID_symbol==(/"i   ","ih  ","cinf","dinf"/))
      DIE_IF(temp_bin,"Group" // trim(.symbol) // "not implemented") 
      DIE_IF(.ID_number==20,"Unknown group symbol: " // trim(.symbol)) 
      select case (.ID_number)
         case (1:3)
            .axis_order = 1 
         case (4:10)
            axis = .symbol(2:)
            n = axis.verify("123456789")-1
            axis = axis(1:n)
            .axis_order = axis.to_int
            if (.ID_number==5) .axis_order = .axis_order/2
         case (13:15)
            .axis_order = 2
         case (16:17)
            .axis_order = 4
      end
      select case (.ID_symbol)
         case ("c1 "); .order = 1
         case ("cs "); .order = 2
         case ("ci "); .order = 2
         case ("cn "); .order =   .axis_order
         case ("s2n"); .order = 2*.axis_order
         case ("cnh"); .order = 2*.axis_order
         case ("cnv"); .order = 2*.axis_order
         case ("dn "); .order = 2*.axis_order
         case ("dnh"); .order = 4*.axis_order
         case ("dnd"); .order = 4*.axis_order
         case ("t  "); .order = 12
         case ("th "); .order = 24
         case ("td "); .order = 24
         case ("o  "); .order = 24
         case ("oh "); .order = 48
      end
   end 

   make_rep_matrices [leaky]
   ! Make the 3x3 point group representation matrices 
      INT :: n
      n = .axis_order
      .mat.create(3,3,.order)
      call to_unit_mat_( .mat(:,:,1))
      select case (.ID_symbol)
         case ("c1")                ! C1 
         case ("cs")                ! Cs  = C1 x sigma-h
            .times_sigma_h(1)
         case ("ci")                ! Ci  = C1 x Ci 
            .times_ci(1)
         case ("cn")                ! Cn 
            .make_cn_matrices
         case ("s2n")               ! Sn 
            .make_cn_matrices
            .make_sn_matrices(n)
         case ("cnh")               ! Cnh = Cn x sigma-h(xy)
            .make_cn_matrices
            .times_sigma_h(n)
         case ("cnv")               ! Cnv = Cn x sigma-v(xz) 
            .make_cn_matrices
            .times_sigma_v(n)
         case ("dn")                ! Dn  = Cn  x C2(x)
            .make_cn_matrices
            .times_c2x(n)
         case ("dnh")               ! Dnh = Cn x sigma-h(xy) x C2(x)
            .make_cn_matrices
            .times_sigma_h(n)
            n = 2*n
            .times_c2x(n)
         case ("dnd")               ! Dnd = Cn x C2(x) x sigma-d 
            .make_cn_matrices
            .times_c2x(n)
            n = 2*n
            .times_sigma_d(n)
         case ("t")                 ! T 
            .make_t_matrices
         case ("th")                ! Th  = T x Ci
            .make_t_matrices
            .times_ci(12)
         case ("td")                ! Td  = T x sigma(x=y)
            .make_t_matrices
            .mat(:,1,13:24) = .mat(:,2,1:12)
            .mat(:,2,13:24) = .mat(:,1,1:12)
            .mat(:,3,13:24) = .mat(:,3,1:12)
         case ("o")                 ! O  = T x C4(z)
            .make_t_matrices
            .times_c4z(12)
         case ("oh")                ! Oh = T x C4(z) x Ci
            .make_t_matrices
            .times_c4z(12)
            .times_ci(24)
      end
   end

   times_ci(n)
   ! Direct product with inversion operator
      INT :: n
      .mat(1,:,n+1:n+n) = -.mat(1,:,1:n)
      .mat(2,:,n+1:n+n) = -.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = -.mat(3,:,1:n)
   end

   times_sigma_h(n)
   ! Direct product with sigma-h, which is the xy plane
      INT :: n
      .mat(1,:,n+1:n+n) =  .mat(1,:,1:n)
      .mat(2,:,n+1:n+n) =  .mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = -.mat(3,:,1:n)
   end

   times_sigma_v(n)
   ! Direct product with sigma-v, which is the xz plane
      INT :: n
      .mat(1,:,n+1:n+n) =  .mat(1,:,1:n)
      .mat(2,:,n+1:n+n) = -.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) =  .mat(3,:,1:n)
   end

   times_sigma_d(n)
   ! Direct product with sigma-d. Equation of sigma-d is sin(alph/4)*x-cos(alph/4)*y=0                               
      INT :: n
      DBL :: beta,cosb,sinb
      beta = PI/.axis_order 
      cosb = cos(beta) 
      sinb = sin(beta) 
      .mat(1,:,n+1:n+n) = cosb*.mat(1,:,1:n) + sinb*.mat(2,:,1:n)
      .mat(2,:,n+1:n+n) = sinb*.mat(1,:,1:n) - cosb*.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = .mat(3,:,1:n)
   end

   times_c2x(n)
   ! Direct product with C2x, for Dn groups
      INT :: n
      .mat(1,:,n+1:n+n) =  .mat(1,:,1:n)
      .mat(2,:,n+1:n+n) = -.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = -.mat(3,:,1:n)
   end

   times_c4z(n)
   ! Direct product with the C4z matrix
      INT :: n
      .mat(:,1,n+1:n+n) = -.mat(:,2,1:n)
      .mat(:,2,n+1:n+n) =  .mat(:,1,1:n)
      .mat(:,3,n+1:n+n) =  .mat(:,3,1:n)
   end

   make_cn_matrices
   ! Make the Cn rotation matrices
      DBL :: alph,alpha,cosa,sina
      INT :: n
      alph = TWO*PI/.axis_order 
      alpha = ZERO
      do n = 2, .axis_order
         alpha = alpha + alph
         cosa = cos(alpha)
         sina = sin(alpha)
         .mat(:,:,n) = reshape((/cosa,-sina, ZERO, sina, cosa, ZERO, ZERO, ZERO, ONE/), (/3,3/))
      end 
   end

   make_sn_matrices(n)
   ! Make the Sn rotation matrices
      INT :: n
      DBL :: beta,cosb,sinb
      beta = PI/.axis_order 
      cosb = cos(beta) 
      sinb = sin(beta) 
      .mat(1,:,n+1:n+n) =  cosb*.mat(1,:,1:n) + sinb*.mat(2,:,1:n)
      .mat(2,:,n+1:n+n) = -sinb*.mat(1,:,1:n) + cosb*.mat(2,:,1:n)
      .mat(3,:,n+1:n+n) = -.mat(3,:,1:n)
   end

   make_t_matrices
   ! Make the Tetrahedral group 3x3 representation matrices
      INT :: n
      n = 1
      .mat(:,:,2) = reshape((/  ONE, ZERO, ZERO, ZERO, -ONE, ZERO, ZERO, ZERO, -ONE/), (/3,3/)) ! C2x
      .mat(:,:,3) = reshape((/ -ONE, ZERO, ZERO, ZERO,  ONE, ZERO, ZERO, ZERO, -ONE/), (/3,3/)) ! C2y
      .mat(:,:,4) = reshape((/ -ONE, ZERO, ZERO, ZERO, -ONE, ZERO, ZERO, ZERO,  ONE/), (/3,3/)) ! C2z
      do n = 5, 12
         .mat(:,1,n) = .mat(:,3,n-4)
         .mat(:,2,n) = .mat(:,1,n-4)
         .mat(:,3,n) = .mat(:,2,n-4)
      end 
   end

   make_xyz_matrices [leaky]
   ! Make the representation matrices for xyz products found in
   ! gaussian shells, i.e. work out matrix R, where the shell row vector
   ! p'(r) = p(S^{-1}r) = p(r)R, and S is the symop.
      INT :: n,j
      DBL :: sqrt3,sqrt5,sqrt15
      IVEC(6)  :: d1 = (/1,2,3,1,1,2/)
      IVEC(6)  :: d2 = (/1,2,3,2,3,3/)
      IVEC(10) :: f1 = (/1,2,3,1,1,2,2,3,3,1/)
      IVEC(10) :: f2 = (/1,2,3,1,1,2,2,3,3,2/) 
      IVEC(10) :: f3 = (/1,2,3,2,3,1,3,1,2,3/) 
      sqrt3 = sqrt(THREE)
      sqrt5 = sqrt(FIVE)
      sqrt15= sqrt3*sqrt5 ! = sqrt(15)
      .ptr => .mat
      .dtr.create(6,6,.order)
      do n = 1,.order
         do j = 1,6
            .dtr(1,j,n)  = .ptr(1,d1(j),n)*.ptr(1,d2(j),n)
            .dtr(2,j,n)  = .ptr(2,d1(j),n)*.ptr(2,d2(j),n)
            .dtr(3,j,n)  = .ptr(3,d1(j),n)*.ptr(3,d2(j),n)
            .dtr(4,j,n)  = .ptr(1,d1(j),n)*.ptr(2,d2(j),n) &
                         + .ptr(2,d1(j),n)*.ptr(1,d2(j),n)
            .dtr(5,j,n)  = .ptr(1,d1(j),n)*.ptr(3,d2(j),n) &
                         + .ptr(3,d1(j),n)*.ptr(1,d2(j),n)
            .dtr(6,j,n)  = .ptr(2,d1(j),n)*.ptr(3,d2(j),n) &
                         + .ptr(3,d1(j),n)*.ptr(2,d2(j),n)
         end
         .dtr(1:6,4:6,n) = .dtr(1:6,4:6,n)*sqrt3 ! Put in correct normalization for old primitives
         .dtr(4:6,1:6,n) = .dtr(4:6,1:6,n)/sqrt3 ! Put in wrong   normalization for new primitives
      end
      .ftr.create(10,10,.order)
      do n = 1,.order
         do j = 1,10
            .ftr(1,j,n)  = .ptr(1,f1(j),n)*.ptr(1,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(2,j,n)  = .ptr(2,f1(j),n)*.ptr(2,f2(j),n)*.ptr(2,f3(j),n)
            .ftr(3,j,n)  = .ptr(3,f1(j),n)*.ptr(3,f2(j),n)*.ptr(3,f3(j),n)
            .ftr(4,j,n)  = .ptr(1,f1(j),n)*.ptr(1,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(1,f1(j),n)*.ptr(2,f2(j),n)*.ptr(1,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(1,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(5,j,n)  = .ptr(1,f1(j),n)*.ptr(1,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(1,f1(j),n)*.ptr(3,f2(j),n)*.ptr(1,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(1,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(6,j,n)  = .ptr(1,f1(j),n)*.ptr(2,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(1,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(2,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(7,j,n)  = .ptr(3,f1(j),n)*.ptr(2,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(3,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(2,f2(j),n)*.ptr(3,f3(j),n)
            .ftr(8,j,n)  = .ptr(1,f1(j),n)*.ptr(3,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(1,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(3,f2(j),n)*.ptr(1,f3(j),n)
            .ftr(9,j,n)  = .ptr(2,f1(j),n)*.ptr(3,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(2,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(3,f2(j),n)*.ptr(2,f3(j),n)
            .ftr(10,j,n) = .ptr(1,f1(j),n)*.ptr(2,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(1,f1(j),n)*.ptr(3,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(1,f2(j),n)*.ptr(3,f3(j),n) &
                         + .ptr(2,f1(j),n)*.ptr(3,f2(j),n)*.ptr(1,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(1,f2(j),n)*.ptr(2,f3(j),n) &
                         + .ptr(3,f1(j),n)*.ptr(2,f2(j),n)*.ptr(1,f3(j),n)
         end
         .ftr(1:10, 4:9 ,n) = .ftr(1:10, 4:9 ,n)*sqrt5
         .ftr(1:10,10:10,n) = .ftr(1:10,10:10,n)*sqrt15
         .ftr(4:9 , 1:10,n) = .ftr(4:9 , 1:10,n)/sqrt5
         .ftr(10:10,1:10,n) = .ftr(10:10,1:10,n)/sqrt15
      end
   end

   xyz_matrix(n,l) result(res) [leaky]
   ! Return the "n"-th representation matrix for xyz product found in
   ! a gaussian shell of angular momentum "l"
      INT :: n,l
      MAT, PTR :: res
      INT :: dim
      ENSURE(l>=0,"l must be non-negative")
      ENSURE(l<4, "l must be less than 4")
      dim = (l+1)*(l+2)/2
      nullify(res)
      res.create(dim,dim)
      select case (l)
         case(0); res = .irrep(1)%mat(:,:,n)
         case(1); res = .ptr(1:3 ,1:3 ,n)
         case(2); res = .dtr(1:6 ,1:6 ,n)
         case(3); res = .ftr(1:10,1:10,n)
      end
   end

   make_inverse [leaky]
   ! Make the inverse operator list
      INT :: m,n
      DBL :: test
      .inverse.create(.order)
      do m = 1,.order
         do n = 1,.order
            test = .mat(:,:,m).trace_of_product( .mat(:,:,n)) - THREE
            if (abs(test)>0.001d0) cycle
            .inverse(m) = n
            exit
         end 
      end 
   end

   make_table [leaky]
   ! Make the group multiplication table
      INT :: l,m,n
      BIN :: same
      MAT(3,3) :: prod
      .table.create(.order,.order)
      do l = 1,.order
      do m = 1,.order
         prod.to_product(.mat(:,:,l),.mat(:,:,m))
         do n = 1,.order
            same = .mat(:,:,n).equals(prod)
            if (same) exit
         end 
         .table(l,m) = n
      end 
      end 
   end

   make_irrep_matrices [leaky]
   ! Make the Irreps for the group 
      if (.ID_number<=10) .make_C_type_irreps
      if (.ID_number>=13) .make_T_type_irreps
   end

   make_C_type_irreps [leaky]
   ! Make irrep matrices for the groups C1, Cs, Ci, Cn, Cnh, Cnv, S2n, Dn, Dnh, Dnd
      BIN :: odd_axis
      INT :: e, i, n, n_max, dim
      DBL :: theta
      MAT3(2,2, 14), target :: gen1, gen2, gen3  ! generator matrices
      MAT3, PTR :: mat
      MAT, PTR :: g1,g2,g3
      odd_axis = NOT .axis_order==2*(.axis_order/2)
      select case (.ID_symbol)
         case ("c1")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_irrep = 1 
            .irrep.create(.n_irrep)
            .irrep(1)%dimension = 1
            e = 2
            .n_gen = 1
            gen1(1,1, 1) =  ONE
         case ("cs","ci")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_irrep = 2 
            .irrep.create(.n_irrep)
            .irrep(1:2)%dimension = 1
            e = 3
            .n_gen = 1
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) = -ONE 
         case ("cn")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            if (.axis_order>2) .has_complex_irreps = TRUE
            .n_gen = 1
            gen1(1,1, 1) =  ONE
            if (odd_axis) then
               .n_irrep = (.axis_order+1)/2 
               .irrep.create(.n_irrep)
               .irrep(1)%dimension = 1
               e = 2 
            else
               .n_irrep = .axis_order/2 + 1 
               .irrep.create(.n_irrep)
               .irrep(1:2)%dimension = 1
               e = 3 
               gen1(1,1, 2) = -ONE 
            end
            .make_cn_gen(e,gen1,.axis_order)
         case ("s2n")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            if (.axis_order>=2) .has_complex_irreps = TRUE
            .n_irrep = .axis_order + 1 
            .irrep.create(.n_irrep)
            .irrep(1:2)%dimension = 1
            e = 3 
            .n_gen = 2
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            .make_cn_gen(e,gen2,2*.axis_order)
            .make_cn_gen(e,gen1,.axis_order)
         case ("cnh")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            if (.axis_order>2) .has_complex_irreps = TRUE
            .n_gen = 2
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            if (odd_axis) then
               .n_irrep = .axis_order + 1
               .irrep.create(.n_irrep)
               .irrep(1:2)%dimension = 1
               e = 3
            else
               .n_irrep = .axis_order + 2
               .irrep.create(.n_irrep)
               .irrep(1:4)%dimension = 1
               e = 5
               gen1(1,1, 3) = -ONE
               gen1(1,1, 4) = -ONE
               gen2(1,1, 3) =  ONE
               gen2(1,1, 4) = -ONE
            end
            .make_cnh_gen(e,gen1,gen2)
         case ("cnv","dn")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_gen = 2
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            if (odd_axis) then
               .n_irrep = (.axis_order + 3)/2
               .irrep.create(.n_irrep)
               .irrep(1:2)%dimension = 1
               e = 3
            else
               .n_irrep = .axis_order/2 + 3
               .irrep.create(.n_irrep)
               .irrep(1:4)%dimension = 1
               e = 5
               gen1(1,1, 3) = -ONE
               gen1(1,1, 4) = -ONE
               gen2(1,1, 3) =  ONE
               gen2(1,1, 4) = -ONE
            end
            .make_sigma_x_gen(e,gen2)
            .make_cn_gen(e,gen1,.axis_order)
         case ("dnh")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_gen = 3
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            gen2(1,1, 3) =  ONE
            gen2(1,1, 4) = -ONE
            gen3(1,1, 1) =  ONE
            gen3(1,1, 2) =  ONE
            if (odd_axis) then
               .n_irrep = .axis_order + 3
               .irrep.create(.n_irrep)
               .irrep(1:4)%dimension = 1
               e = 5
               gen3(1,1, 3) = -ONE 
               gen3(1,1, 4) = -ONE 
               gen1(1,1, 3) =  ONE ! Warning, possible error, Changed from gen3 to gen1; the first two could be gen1
               gen1(1,1, 4) =  ONE ! Warning, possible error, Changed from gen3 to gen1
            else
               .n_irrep = .axis_order + 6
               .irrep.create(.n_irrep)
               .irrep(1:8)%dimension = 1
               e = 9
               gen1(1,1, 3) = -ONE
               gen1(1,1, 4) = -ONE
               gen1(1,1, 5) =  ONE
               gen1(1,1, 6) =  ONE
               gen1(1,1, 7) = -ONE
               gen1(1,1, 8) = -ONE
               gen2(1,1, 5) =  ONE
               gen2(1,1, 6) = -ONE
               gen2(1,1, 7) =  ONE
               gen2(1,1, 8) = -ONE
               gen3(1,1, 3) =  ONE
               gen3(1,1, 4) =  ONE
               gen3(1,1, 5) = -ONE
               gen3(1,1, 6) = -ONE
               gen3(1,1, 7) = -ONE
               gen3(1,1, 8) = -ONE
            end
            do i = e,.n_irrep
               gen3(1,1, i) =  ONE
               gen3(2,2, i) = -ONE
               gen3(2,1, i) = ZERO   ! Transposed
               gen3(1,2, i) = ZERO
            end 
            .make_cnh_gen(e,gen1,gen2)
         case ("dnd")!<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
            .has_complex_irreps = FALSE
            .n_irrep = .axis_order + 3 
            .irrep.create(.n_irrep)
            .irrep(1:4)%dimension = 1
            e = 5 
            .n_gen = 3
            gen1(1,1, 1) =  ONE
            gen1(1,1, 2) =  ONE
            gen1(1,1, 3) =  ONE 
            gen1(1,1, 4) =  ONE 
            gen2(1,1, 1) =  ONE
            gen2(1,1, 2) = -ONE
            gen2(1,1, 3) =  ONE 
            gen2(1,1, 4) = -ONE 
            gen3(1,1, 1) =  ONE 
            gen3(1,1, 2) =  ONE 
            gen3(1,1, 3) = -ONE 
            gen3(1,1, 4) = -ONE 
            do i = e,.n_irrep
               theta = (i-e+1)*PI/.axis_order
               gen3(1,1, i) =  cos(theta)
               gen3(2,2, i) = -cos(theta)
               gen3(2,1, i) =  sin(theta) ! Transposed
               gen3(1,2, i) =  sin(theta)
            end 
            .make_sigma_x_gen(e,gen2)
            .make_cn_gen(e,gen1,.axis_order)
      end
      do i = 1, .n_irrep
         dim = .irrep(i)%dimension
         .irrep(i)%mat.create(dim,dim, .order)
         mat => .irrep(i)%mat
         g1  => gen1(1:dim,1:dim,i)
         g2  => gen2(1:dim,1:dim,i)
         g3  => gen3(1:dim,1:dim,i)
         mat(:,:,1).to_unit_mat
         n_max = .axis_order
         if (.ID_symbol=="c1") cycle
         if (.ID_symbol=="cs") n_max = 2
         if (.ID_symbol=="ci") n_max = 2
         do n = 2,n_max
            mat(:,:,n) = matmul(g1,mat(:,:,n-1))
         end 
         if (.n_gen==1) cycle
         do n = 1,n_max
            mat(:,:,n_max+n) = matmul(g2,mat(:,:,n))
         end 
         if (.n_gen==2) cycle
         n_max = 2*n_max
         do n = 1,n_max
            mat(:,:,n_max+n) = matmul(g3,mat(:,:,n))
         end 
      end 
   end

   make_cnh_gen(e,gen1,gen2)
   ! Make the Cnh generator matrices for the irreps
      INT :: e,i,m
      MAT3(2,2, 14) :: gen1, gen2
      DBL :: sign,theta
      do i = e,.n_irrep
         .irrep(i)%dimension = 2
         m = (i-e+2)/2
         theta = m*TWO*PI/.axis_order
         gen1(1,1, i) =  cos(theta)
         gen1(2,2, i) =  cos(theta)
         gen1(2,1, i) = -sin(theta) ! Transposed
         gen1(1,2, i) =  sin(theta)
      end 
      sign = ONE 
      do i = e,.n_irrep
         sign = -sign
         gen2(1,1, i) = sign
         gen2(2,2, i) = sign
         gen2(2,1, i) = ZERO ! Transposed
         gen2(1,2, i) = ZERO
      end 
   end

   make_sigma_x_gen(e,gen2)
   ! Make the sigma-x generator matrices for the irreps
      INT :: e,i
      MAT3(2,2, 14) :: gen2
      do i = e,.n_irrep
         gen2(1,1, i) =  ONE
         gen2(2,2, i) = -ONE
         gen2(2,1, i) = ZERO ! Transposed
         gen2(1,2, i) = ZERO
      end 
   end

   make_cn_gen(e,gen1,axis_order)
   ! Make the Cn generator matrices for the irreps
      INT :: e,axis_order,i
      MAT3(2,2, 14) :: gen1
      DBL :: theta
      do i = e,.n_irrep
         .irrep(i)%dimension = 2
         theta = (i-e+1)*TWO*PI/axis_order
         gen1(1,1, i) =  cos(theta)
         gen1(2,2, i) =  cos(theta)
         gen1(2,1, i) = -sin(theta) ! Transposed
         gen1(1,2, i) =  sin(theta)
      end
   end
      
   make_T_type_irreps [leaky]
   ! Make irrep matrices for the groups T, Th, Td, O, and Oh 
   ! Must have already generated the 3x3 rep matrices
      IMAT(10,5) :: irrep_dimension = reshape( &               ! Irrep dimensions for T-groups
                         (/ 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, &    ! T
                            1, 2, 3, 1, 2, 3, 0, 0, 0, 0, &    ! Th
                            1, 1, 2, 3, 3, 0, 0, 0, 0, 0, &    ! Td
                            1, 1, 2, 3, 3, 0, 0, 0, 0, 0, &    ! O
                            1, 1, 2, 3, 3, 1, 1, 2, 3, 3 /), & ! Oh
                          (/10,5/))
      IVEC(5) :: n_irrep  = (/ 3, 6, 5, 5, 10 /)               ! No of irreps
      IVEC(5) :: ab_irrep = (/ 0, 4, 2, 2, 2  /)               ! A irreps
      IVEC(5) :: ea_irrep = (/ 2, 2, 3, 3, 3  /)               ! E irreps 
      IVEC(5) :: eb_irrep = (/ 0, 5, 0, 0, 8  /)               ! E irreps
      IVEC(5) :: fa_irrep = (/ 3, 6, 5, 4, 9  /)               ! F irreps
      IVEC(5) :: fb_irrep = (/ 0, 0, 4, 5, 10 /)               ! F irreps
      INT :: i, n, id, dim
      INT :: ab,ea,eb,fa,fb
      DBL :: pt5,r32
      .has_complex_irreps = FALSE
      if (.ID_symbol=="t" ) .has_complex_irreps = TRUE
      if (.ID_symbol=="td") .has_complex_irreps = TRUE
      id = .ID_number - 12
      .n_irrep = n_irrep(id)
      .irrep.create(.n_irrep)
      .irrep%dimension = irrep_dimension(1:.n_irrep,id)
      do i = 1,.n_irrep
         dim = .irrep(i)%dimension
         .irrep(i)%mat.create(dim,dim,.order)
      end

      .irrep(1)%mat(1,1,:) = ONE
      
      pt5 = HALF
      r32 = sqrt(THREE)/TWO
      ea = ea_irrep(id)
      .irrep(ea)%mat(1,1,1:4)  =  ONE
      .irrep(ea)%mat(2,1,1:4)  = ZERO
      .irrep(ea)%mat(1,2,1:4)  = ZERO
      .irrep(ea)%mat(2,2,1:4)  =  ONE

      .irrep(ea)%mat(1,1,5:8)  = -pt5
      .irrep(ea)%mat(2,1,5:8)  = -r32
      .irrep(ea)%mat(1,2,5:8)  =  r32
      .irrep(ea)%mat(2,2,5:8)  = -pt5

      .irrep(ea)%mat(1,1,9:12) = -pt5
      .irrep(ea)%mat(2,1,9:12) =  r32
      .irrep(ea)%mat(1,2,9:12) = -r32
      .irrep(ea)%mat(2,2,9:12) = -pt5

      fa = fa_irrep(id) 
      .irrep(fa)%mat(:,:,:) = .mat(:,:,:)

      if (.ID_symbol=="t") return

      ab = ab_irrep(id)
      .irrep(ab)%mat(1,1, 1:12) =  ONE
      .irrep(ab)%mat(1,1,13:24) = -ONE
      if (.ID_symbol=="oh") then             
         .irrep(2)%mat(1,1,25:48) =  .irrep(2)%mat(1,1, 1:24) 
         .irrep(6)%mat(1,1, 1:24) =  ONE
         .irrep(6)%mat(1,1,25:48) = -ONE
         .irrep(7)%mat(1,1, 1:24) =  .irrep(2)%mat(1,1, 1:24) 
         .irrep(7)%mat(1,1,25:48) = -.irrep(2)%mat(1,1, 1:24) 
      end

      .irrep(ea)%mat(:,:,13:24)   =  .irrep(ea)%mat(:,:,1:12) 
      n = .order/2
      if (.ID_symbol=="th" OR .ID_symbol=="oh") then  
         .irrep(ea)%mat(:,:,n+1:n+n) =  .irrep(ea)%mat(:,:,1:n) 
         eb = eb_irrep(id)
         .irrep(eb)%mat(:,:,  1:  n) =  .irrep(ea)%mat(:,:,  1:  n) 
         .irrep(eb)%mat(:,:,n+1:n+n) = -.irrep(ea)%mat(:,:,n+1:n+n) 
      end

      if (.ID_symbol=="th") then              
         .irrep(3)%mat(:,:, 1:12) =  .irrep(6)%mat(:,:, 1:12) 
         .irrep(3)%mat(:,:,13:24) =  .irrep(6)%mat(:,:, 1:12) 
      else  
         fb = fb_irrep(id)
         fa = fa_irrep(id)
         .irrep(fb)%mat(:,:, 1:12) =  .irrep(fa)%mat(:,:, 1:12) 
         .irrep(fb)%mat(:,:,13:24) = -.irrep(fa)%mat(:,:,13:24) 
         if (.ID_symbol=="oh") then
            .irrep(10)%mat(:,:,25:48) = -.irrep(10)%mat(:,:, 1:24) 
            .irrep(4)%mat(:,:, 1:24)  =  .irrep(9)%mat(:,:, 1:24) 
            .irrep(5)%mat(:,:, 1:24)  =  .irrep(10)%mat(:,:, 1:24) 
            .irrep(4)%mat(:,:,25:48)  =  .irrep(9)%mat(:,:, 1:24) 
            .irrep(5)%mat(:,:,25:48)  =  .irrep(10)%mat(:,:, 1:24) 
         end
      end
   end

   make_character_table [leaky]
   ! MAke the character table
      INT :: n,i
      do i = 1, .n_irrep
         .irrep(i)%character.create(.order)
         do n = 1, .order
            .irrep(i)%character(n) = .irrep(i)%mat(:,:,n).trace
         end 
      end 
   end

   make_irrep_labels
   ! Make the names for the symmetry irreducible representations 
   ! The irrep object must already be created and dimensioned correctly.
      STR(41) :: warn_str = "can't label irreps for groups larger than"
      WARN_IF(.ID_symbol=="cn"  AND .axis_order>9, warn_str // " C9")
      WARN_IF(.ID_symbol=="s2n" AND .axis_order>8, warn_str // " S8")
      WARN_IF(.ID_symbol=="cnh" AND .axis_order>6, warn_str // " C6h")
      WARN_IF(.ID_symbol=="cnv" AND .axis_order>6, warn_str // " C6v")
      WARN_IF(.ID_symbol=="dn"  AND .axis_order>6, warn_str // " D6")
      WARN_IF(.ID_symbol=="dnh" AND .axis_order>8, warn_str // " D8h")
      WARN_IF(.ID_symbol=="dnd" AND .axis_order>6, warn_str // " D6d")
      .irrep%label = "?"
      select case (.ID_symbol)
         case ("c1"); .irrep%label = (/"A   "/)
         case ("cs"); .irrep%label = (/"A'  ", "A'' "/)
         case ("ci"); .irrep%label = (/"Ag  ", "Au  "/)
         case ("cn") 
            select case (.axis_order)
            case (1); .irrep%label = (/"A   "/)
            case (2); .irrep%label = (/"A   ", "B   "/)
            case (3); .irrep%label = (/"A   ", "E   "/)
            case (4); .irrep%label = (/"A   ", "B   ", "E   "/)
            case (5); .irrep%label = (/"A   ", "E1  ", "E2  "/)
            case (6); .irrep%label = (/"A   ", "B   ", "E1  ", "E2  "/)
            case (7); .irrep%label = (/"A   ", "E1  ", "E2  ", "E3  "/)
            case (8); .irrep%label = (/"A   ", "B   ", "E1  ", "E2  ", "E3  "/)
            case (9); .irrep%label = (/"A   ", "E1  ", "E2  ", "E3  ", "E4  "/)
            end
         case ("s2n")
            select case (.axis_order)
            case (1); .irrep%label = (/"Ag  ", "Au  "/)
            case (2); .irrep%label = (/"A   ", "B   ", "E   "/)
            case (3); .irrep%label = (/"Ag  ", "Au  ", "Eu  ", "Eg  "/)
            case (4); .irrep%label = (/"A   ", "B   ", "E1  ", "E2  ", "E3  "/) 
            end
         case ("cnh")
            select case (.axis_order)
            case (1); .irrep%label = (/"A'  ", "A'' "/)
            case (2); .irrep%label = (/"Ag  ", "Au  ", "Bu  ", "Bg  "/)
            case (3); .irrep%label = (/"A'  ", "A'' ", "E'' ", "E'  "/)
            case (4); .irrep%label = (/"Ag  ", "Au  ", "Bg  ", "Bu  ", "Eg  ", &
                                       "Eu  "/)
            case (5); .irrep%label = (/"A'  ", "A'' ", "E1''", "E1' ", "E2''", &
                                       "E2' "/)
            case (6); .irrep%label = (/"Ag  ", "Au  ", "Bu  ", "Bg  ", "E1g ", &
                                       "E1u ", "E2u ", "E2g "/)
            end
         case ("cnv")
            select case (.axis_order)
            case (1); .irrep%label = (/"A'  ", "A'' "/)
            case (2); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  "/)
            case (3); .irrep%label = (/"A1  ", "A2  ", "E   "/)
            case (4); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E   "/)
            case (5); .irrep%label = (/"A1  ", "A2  ", "E1  ", "E2  "/)
            case (6); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E1  ", &
                                       "E2  "/)
            end
         case ("dn") 
            select case (.axis_order)
            case (1); .irrep%label = (/"A1  ", "B   "/)
            case (2); .irrep%label = (/"A   ", "B1  ", "B3  ", "B2  "/)
            case (3); .irrep%label = (/"A1  ", "A2  ", "E   "/)
            case (4); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E   "/)
            case (5); .irrep%label = (/"A1  ", "A2  ", "E1  ", "E2  "/)
            case (6); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E1  ", &
                                       "E2  "/)
            end
         case ("dnh") 
            select case (.axis_order)
            case (1); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  "/)
            case (2); .irrep%label = (/"Ag  ", "Au  ", "B3u ", "B3g ", "B1g ", &
                                       "B1u ", "B2u ", "B2g "/)
            case (3); .irrep%label = (/"A1' ", "A1''", "A2' ", "A2''", "E'' ", &
                                       "E'  "/)
            case (4); .irrep%label = (/"A1g ", "A1u ", "B1g ", "B1u ", "A2g ", &
                                       "A2u ", "B2g ", "B2u ", "Eg  ", "Eu  "/)
            case (5); .irrep%label = (/"A1' ", "A1''", "A2' ", "A2''", "E1''", &
                                       "E1' ", "E2''", "E2' "/)
            case (6); .irrep%label = (/"A1g ", "A1u ", "B1u ", "B1g ", "A2g ", &
                                       "A2u ", "B2u ", "B2g ", "E1g ", "E1u ", &
                                       "E2u ", "E2g "/)
            case (8); .irrep%label = (/"A1g ", "A1u ", "A2g ", "A2u ", "B1g ", &
                                       "B1u ", "B2g ", "B2u ", "E1g ", "E1u ", &
                                       "E2u ", "E2g ", "E3g ", "E3u "/)
            case (7); DIE("No such group as d7h")
            end
         case ("dnd")
            select case (.axis_order)
            case (1); .irrep%label = (/"Ag  ", "Au  ", "Bu  ", "Bg  "/)
            case (2); .irrep%label = (/"A1  ", "B2  ", "B1  ", "A2  ", "E   "/)
            case (3); .irrep%label = (/"A1g ", "A2u ", "A1u ", "A2g ", "Eu  ", &
                                       "Eg  "/)
            case (4); .irrep%label = (/"A1  ", "A2  ", "B1  ", "B2  ", "E1  ", &
                                       "E2  ", "E3  "/)
            case (5); .irrep%label = (/"A1g ", "A1u ", "A2u ", "A2g ", "E2u ", &
                                       "E1g ", "E1u ", "E2g "/)
            case (6); .irrep%label = (/"A1  ", "B2  ", "B1  ", "A2  ", "E1  ", &
                                       "E2  ", "E3  ", "E4  ", "E5  "/)
            end
         case ("t");  .irrep%label = (/"A   ", "E   ", "F   "/)
         case ("th"); .irrep%label = (/"Ag  ", "Eg  ", "Fg  ", "Au  ", "Eu  ", &
                                       "Fu  "/)
         case ("td"); .irrep%label = (/"A1  ", "A2  ", "E   ", "F1  ", "F2  "/)
         case ("o");  .irrep%label = (/"A1  ", "A2  ", "E   ", "F1  ", "F2  "/)
         case ("oh"); .irrep%label = (/"A1g ", "A2g ", "Eg  ", "F1g ", "F2g ", &
                                       "A1u ", "A2u ", "Eu  ", "F1u ", "F2u "/)
         case ("i");  .irrep%label = (/"A   ", "F1  ", "F2  ", "G   ", "H   "/)
         case ("ih"); .irrep%label = (/"Ag  ", "F1g ", "F2g ", "Gg  ", "Hg  ", &
                                       "Au  ", "F1u ", "F2u ", "Gu  ", "Hu  "/)
      end 
   end

   put(out)
   ! Display the pointgroup data to output file "out".
      TEXTFILE :: out
      INT :: i,n,dim
      INT :: block,n_block,f,l
      out.flush
      out.put_text("POINTGROUP output:",flush=2)
      out.show("Symbol                  =",.symbol, int_width=TRUE)
      out.show("ID_symbol               =",.ID_symbol, int_width=TRUE)
      out.show("ID_number               =",.ID_number)
      out.show("Principal axis order    =",.axis_order)
      out.show("Order                   =",.order)
      out.show("No. of Irreps           =",.n_irrep)
      out.show("No. of Irrep generators =",.n_gen)
      out.show("Has complex irreps?     =",.has_complex_irreps)

      out.flush
      out.put_text("List of inverse group elements :",flush=2)
      out.put(.inverse)

      out.flush
      out.put_text("Group multiplication table :",flush=2)
      out.put(.table)

      out.flush
      out.put_text("Character Table :")
      n_block = (.order-1)/out%fields + 1
      do block = 1,n_block
         f = 1 + (block-1)*out%fields
         l = min(f+out%fields-1,.order)
         out.flush                          ! Banner
         out.put_dash(int_fields=1,dbl_fields=min(out%fields,.order),flush=1)
         out.tab(int_fields=1)
         do n = f,l
            out.put(n,dbl_width=TRUE)
         end
         out.flush
         out.put_dash(int_fields=1,dbl_fields=min(out%fields,.order),flush=1)
         do i = 1,.n_irrep                     ! The actual table
            out.put_text(.irrep(i)%label,int_width=TRUE)
            do n = f,l
               out.put(.irrep(i)%character(n))
            end
            out.flush
         end
         out.put_dash(int_fields=1,dbl_fields=min(out%fields,.order),flush=1)
      end

      out.flush
      out.put_text("3x3 Representation matrices :",flush=1)
      do n = 1,.order
        out.flush
        out.put_text("Matrix number " // n.to_str ,flush=1)
        out.put(.mat(:,:,n))
      end

      out.flush
      out.put_text("Irrep matrices :",flush=1)
      do i = 1,.n_irrep
        out.flush
        dim = .irrep(i)%dimension
        out.put_text("Irrep " // trim( .irrep(i)%label) // ", dimension " &
                    // trim( dim.to_str) // ":" ,flush=1)
        if (dim==1) then
           out.put(.irrep(i)%mat(1,1,:))
        else
           do n = 1,.order
              out.put_text("Matrix number " // n.to_str ,flush=1)
              out.put(.irrep(i)%mat(:,:,n))
           end
        end
      end
   end

   main
   ! Main routine to test the pointgroup object
      PTR :: self
      TEXTFILE, PTR :: in,out
      in.create("pointgroup_in")
      in.open_for_read
      out.create("pointgroup_out")
      out.open_for_write
      stdout => out
      tonto.set_put_file(out)
      .create
      .read(in)
      .put(out)
      .destroy
   end

end
