!---------------------------------------------------------------------------
!
!  BASISVEC: BASIS vectors
!
!  (c) dylan jayatilaka, 1998
!
! $Id$
!---------------------------------------------------------------------------
module BASISVEC

   use TYPES
   use SYSTEM
   use TEXTFILE
   use BASIS

   implicit none

#  include "macros"
#  include "basisvec.int"

contains

!  ******************
!  Allocation methods
!  ******************

   create(dim)
   ! Create space for a shell vector
      PTR :: self
      INT :: dim
      nullify(self)
      allocate(self(dim))
      ADD_MEM(dim*BASIS_SIZE)
      .nullify_ptr_part
   end

   destroy
   ! Destroy space for a string vector
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(size(self)*BASIS_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      INT :: b
      do b = 1,size(self)
         self(b).nullify_ptr_part
      end
   end

   destroy_ptr_part
   ! Destroy the pointer parts of self
      INT :: b
      do b = 1,size(self)
         self(b).destroy_ptr_part
      end
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

!  *************
!  Input methods
!  *************

   read [leaky]
   ! Read in data in the standard order from "stdin". 
   ! NOTE: Will create a BASISVEC, if required
      PTR :: self
      STRVEC, PTR :: keywords
      STR :: word
      keywords.create(BASIS_INPUT_DATA_ORDER)
      read_loop: do         ! Loop over input keywords
         stdin.read(word)
         word.to_lower_case
         select case (word)
            case("end");        exit read_loop
            case("data_order"); .read_data_order(keywords)
            case("loop");       .read_loop(keywords)
            case default;       DIE("unknown keyword, "//trim(word))
         end
      end do read_loop
      keywords.destroy
   end 

   read_data_order(keywords) [leaky]
   ! Read in a new data order list from "stdin". 
      STRVEC, PTR :: keywords
      keywords.destroy
      stdin.read_ptr(keywords)
   end

   read_loop(keywords) [leaky]
   ! Read in a list of plain-style data, according to the ordering
   ! in the list of "keywords".
      PTR :: self
      STRVEC :: keywords
      STR :: word
      INT :: length
      length = .list_length(keywords)
      if (.created) ENSURE(length==.n_basis,"list length is wrong")
      if (.destroyed) .create(length)
      .process(keywords)
      stdin.read(word)
      ENSURE(word=="end","loop must terminate with end")
   end

   process(keywords) [leaky]
   ! Read in the list information from "stdin". 
      PTR :: self
      STRVEC :: keywords
      INT :: s
      STR :: word
      do s = 1,size(self)             ! Read the list
         self(s).process(keywords)
      end
   end 

   list_length(keywords) result (res)
   ! Return the number of shells in the list, where each shell data components 
   ! is ordered according to a list of "keywords", if present. 
      STRVEC  :: keywords
      INT :: res
      INT :: line,item
      BASIS, PTR :: basis
      STR :: word
      stdin.read(word)
      ENSURE(word/="end","empty list")
      line = stdin.line_number        ! Store line of atom list
      item = stdin.previous_line_item
      res = 0
      do                              ! Read ahead for the number of atoms
         stdin.move_to_previous_item
         basis.create
         basis.process(keywords)
         basis.destroy
         res = res + 1
         stdin.read(word)
         word.to_lower_case
         if (word=="end") exit
      end
      stdin.move_to_line(line)
      stdin.move_to_line_item(item)
   end

   put
   ! Output the molecule basis set information
      INT :: b
      do b = 1,size(self)
         self(b).put
         stdout.flush
      end 
   end 

   put_table
   ! Output tables of molecule basis set information
      INT :: b
      do b = 1,size(self)
         self(b).put_table
         stdout.flush
      end 
   end 

   n_basis result (res)
   ! Return the number of basis sets
      INT :: res
      res = size(self)
   end
      
end 
