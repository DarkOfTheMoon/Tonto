! $Id$
!---------------------------------------------------------------------------
!
!  GAUSSIAN4 : Quartets of gaussian functions
!
!  (c) dylan jayatilaka, 1999
!
!---------------------------------------------------------------------------
module GAUSSIAN4

   use TYPES
   use ERROR
   use MM
   use INT
   use IVEC
   use VEC
   use IMAT
   use MAT
   use MAT3
   use MAT4
   use MAT5
   use OUTPUT
   use GAUSSIAN
   use RYS

   implicit none         

#  include "macros"
#  include "gaussian4.int"

!  type gaussian4_type
!     INT :: l_a,l_b,l_c,l_d
!     VEC(3) :: pos_a,pos_b,pos_c,pos_d
!     DBL :: ex_a,ex_b,ex_c,ex_d
!  end 

   DBL, private :: pi212  = 1.1283791670955d+0
!  DBL, private :: pi212  = TWO/sqrt(PI)

contains

   create
   ! Create 
      PTR :: self
      nullify(self)
      allocate(self)
      std_mm.add(GAUSSIAN4_SIZE)
   end

   create(Ga,Gb,Gc,Gd)
   ! Create and set to "Ga" ... "Gd"
      PTR :: self
      GAUSSIAN :: Ga,Gb,Gc,Gd
      nullify(self)
      allocate(self)
      std_mm.add(GAUSSIAN4_SIZE)
      .set(Ga,Gb,Gc,Gd)
   end

   destroy
   ! Destroy 
      PTR :: self
      if (.destroyed) return
      std_mm.delete(GAUSSIAN4_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set(Ga,Gb,Gc,Gd) 
   ! Set the gaissian pair object to "Ga" and "Gb"
      GAUSSIAN :: Ga,Gb,Gc,Gd
      .l_a   = Ga%l
      .pos_a = Ga%pos
      .ex_a  = Ga%ex
      .l_b   = Gb%l
      .pos_b = Gb%pos
      .ex_b  = Gb%ex
      .l_c   = Gc%l
      .pos_c = Gc%pos
      .ex_c  = Gc%ex
      .l_d   = Gd%l
      .pos_d = Gd%pos
      .ex_d  = Gd%ex
   end

   set(l_a,pos_a,ex_a,l_b,pos_b,ex_b,l_c,pos_c,ex_c,l_d,pos_d,ex_d) 
   ! Set a gaussian object
      INT :: l_a,l_b,l_c,l_d
      VEC(3) :: pos_a,pos_b,pos_c,pos_d
      DBL :: ex_a,ex_b,ex_c,ex_d
      .l_a   = l_a
      .pos_a = pos_a
      .ex_a  = ex_a
      .l_b   = l_b
      .pos_b = pos_b
      .ex_b  = ex_b
      .l_c   = l_c
      .pos_c = pos_c
      .ex_c  = ex_c
      .l_d   = l_d
      .pos_d = pos_d
      .ex_d  = ex_d
   end

   set(ex_a,ex_b,ex_c,ex_d) 
   ! Set the exponents of the pair
      DBL, optional :: ex_a,ex_b,ex_c,ex_d
      if (present(ex_a)) .ex_a = ex_a
      if (present(ex_b)) .ex_b = ex_b
      if (present(ex_c)) .ex_c = ex_c
      if (present(ex_d)) .ex_d = ex_d
   end

   make_ERI_ints(I)
   ! Make ERI matrix "I" using Rys decomposition of 1/r_{12}.
      MAT4 :: I
      MAT5, PTR :: Ix,Iy,Iz
      IVEC, PTR :: ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz
      RYS, PTR :: rys
      VEC(3) :: AB,CD,P,Q,PA,QC,QP
      DBL :: zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac
      INT :: l_e,l_f,n_a,n_b,n_c,n_d,n_roots
      l_e = .l_a + .l_b
      l_f = .l_c + .l_d
      n_roots = (l_e+l_f)/2 + 1
      Ix.create(n_roots,l_e+1,.l_b+1,l_f+1,.l_d+1)
      Iy.create(n_roots,l_e+1,.l_b+1,l_f+1,.l_d+1)
      Iz.create(n_roots,l_e+1,.l_b+1,l_f+1,.l_d+1)
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      n_c = (.l_c+1)*(.l_c+2)/2
      n_d = (.l_d+1)*(.l_d+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_powers(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_powers(bx,by,bz)
      cx.create(n_c); cy.create(n_c); cz.create(n_c); .l_c.make_gaussian_xyz_powers(cx,cy,cz)
      dx.create(n_d); dy.create(n_d); dz.create(n_d); .l_d.make_gaussian_xyz_powers(dx,dy,dz)
      zeta = .ex_a + .ex_b
      eta  = .ex_c + .ex_d
      zinv = 1/zeta
      einv = 1/eta
      zeinv = 1/(zeta+eta)
      rho  = zeta*eta*zeinv
      AB  = .pos_a - .pos_b
      CD  = .pos_c - .pos_d
      P   = (.ex_a*.pos_a + .ex_b*.pos_b)*zinv
      Q   = (.ex_c*.pos_c + .ex_d*.pos_d)*einv
      PA  = P - .pos_a
      QC  = Q - .pos_c
      QP  = Q - P
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)
      !!!!!!!!!!!!!!!!!!!!
      I = ZERO
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys%r,rys%w,rho,zinv,einv,PA,QC,QP)
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD)
      ! Form the integrals 
      I = sum(Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)
      !!!!!!!!!!!!!!!!!!!!
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy
      dz.destroy; dy.destroy; dx.destroy
      cz.destroy; cy.destroy; cx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-.ex_a*.ex_b*AB2*zinv -.ex_c*.ex_d*CD2*einv)
      I = fac*I
   end

   transfer_2d_ints(Ix,Iy,Iz,AB,CD) [pure]
   ! Use the transfer relation to put momenta on centres B and D and get all 
   ! the 2d integrals "Ix", "Iy" and "Iz"
      IN :: self
      MAT5, INOUT :: Ix,Iy,Iz
      VEC(3), IN :: AB,CD
      INT :: le1,lf1,a,b,c,d,a1,b1,c1,d1,la1
      if (.l_b==0 AND .l_d==0) return
      if (.l_b/=0) then
         le1 = .l_a + .l_b + 1
         do b = 1,.l_b
         do a = 1,le1 - b 
            b1 = b   + 1
            a1 = a   + 1
            Ix(:,a,b1,:,1) = Ix(:,a1,b,:,1) + AB(1)*Ix(:,a,b,:,1)
            Iy(:,a,b1,:,1) = Iy(:,a1,b,:,1) + AB(2)*Iy(:,a,b,:,1)
            Iz(:,a,b1,:,1) = Iz(:,a1,b,:,1) + AB(3)*Iz(:,a,b,:,1)
         end
         end
      end
      if (.l_d/=0) then
         la1 = .l_a + 1
         lf1 = .l_c + .l_d + 1
         do d = 1,.l_d
         do c = 1,lf1 - d
            d1 = d   + 1
            c1 = c   + 1
            Ix(:,1:la1,:,c,d1) = Ix(:,1:la1,:,c1,d) + CD(1)*Ix(:,1:la1,:,c,d)
            Iy(:,1:la1,:,c,d1) = Iy(:,1:la1,:,c1,d) + CD(2)*Iy(:,1:la1,:,c,d)
            Iz(:,1:la1,:,c,d1) = Iz(:,1:la1,:,c1,d) + CD(3)*Iz(:,1:la1,:,c,d)
         end
         end
      end
   end

   form_2d_ints(Ix,Iy,Iz,t2,wt,rho,zinv,einv,PA,QC,QP) [pure]
   ! Forms the two dimensional integrals "Ix", "Iy" and "Iz" with momenta only
   ! on centres A and C, using Rys roots "t2" and weights "wt".
   ! Other variables are intermediates, to avoid calculations: see make_ERI_ints.
     IN :: self
     MAT3, INOUT :: Ix,Iy,Iz
     VEC, IN :: t2,wt
     DBL, IN :: rho,zinv,einv
     VEC(3), IN :: PA,QC,QP
     VEC(size(t2)) :: ret,rzt,ce,cf,bb,ce1,cf1
     INT :: l_e,l_f,e,f,e1,f1,fp1,ep1,k
     l_e = .l_a + .l_b
     l_f = .l_c + .l_d
     Ix(:,1,1) = ONE
     Iy(:,1,1) = ONE
     Iz(:,1,1) = ONE
     if (l_e/=0 OR l_f/=0) then
       if (l_f>0) then
         ret = rho*t2*einv
         Ix(:,1,2) = QC(1) - ret(:) * QP(1)
         Iy(:,1,2) = QC(2) - ret(:) * QP(2)
         Iz(:,1,2) = QC(3) - ret(:) * QP(3)
         if (l_f>1) then
           cf = (ONE - ret) * HALF * einv
           do f = 2,l_f
             f1  = f - 1
             fp1 = f + 1
             cf1 = f1 * cf
             Ix(:,1,fp1) = Ix(:,1,2) * Ix(:,1,f) + cf1 * Ix(:,1,f1)
             Iy(:,1,fp1) = Iy(:,1,2) * Iy(:,1,f) + cf1 * Iy(:,1,f1)
             Iz(:,1,fp1) = Iz(:,1,2) * Iz(:,1,f) + cf1 * Iz(:,1,f1)
           end
         end
       end
       if (l_e>0) then
         rzt = rho * t2 * zinv
         Ix(:,2,1) = PA(1) + rzt(:) * QP(1)
         Iy(:,2,1) = PA(2) + rzt(:) * QP(2)
         Iz(:,2,1) = PA(3) + rzt(:) * QP(3)
         if (l_e>1) then
           ce = (ONE - rzt) * HALF * zinv
           do e = 2, l_e
             e1  = e - 1
             ep1 = e + 1
             ce1 = e1 * ce
             Ix(:,ep1,1) = Ix(:,2,1) * Ix(:,e,1) + ce1 * Ix(:,e1,1)
             Iy(:,ep1,1) = Iy(:,2,1) * Iy(:,e,1) + ce1 * Iy(:,e1,1)
             Iz(:,ep1,1) = Iz(:,2,1) * Iz(:,e,1) + ce1 * Iz(:,e1,1)
           end
         end
       end
       if (l_f>0 AND l_e>0) then
         bb = HALF*einv*rzt
         Ix(:,2,2)=Ix(:,1,2)*Ix(:,2,1)+bb
         Iy(:,2,2)=Iy(:,1,2)*Iy(:,2,1)+bb
         Iz(:,2,2)=Iz(:,1,2)*Iz(:,2,1)+bb
         if (l_f>1) then
           do f=2,l_f
             f1  = f - 1
             fp1 = f + 1
             cf1 = f1 * cf
             Ix(:,2,fp1) = Ix(:,1,2) * Ix(:,2,f) + cf1 * Ix(:,2,f1) + bb *Ix(:,1,f)
             Iy(:,2,fp1) = Iy(:,1,2) * Iy(:,2,f) + cf1 * Iy(:,2,f1) + bb *Iy(:,1,f)
             Iz(:,2,fp1) = Iz(:,1,2) * Iz(:,2,f) + cf1 * Iz(:,2,f1) + bb *Iz(:,1,f)
           end
         end
         if (l_e>1) then
           do e = 2, l_e
             e1  =e - 1
             ep1 =e + 1
             ce1 =e1 * ce
             do f=2, l_f + 1
               f1 = f - 1
               Ix(:,ep1,f) = Ix(:,2,1)*Ix(:,e,f)+ce1*Ix(:,e1,f)+f1*bb(:)*Ix(:,e,f1)
               Iy(:,ep1,f) = Iy(:,2,1)*Iy(:,e,f)+ce1*Iy(:,e1,f)+f1*bb(:)*Iy(:,e,f1)
               Iz(:,ep1,f) = Iz(:,2,1)*Iz(:,e,f)+ce1*Iz(:,e1,f)+f1*bb(:)*Iz(:,e,f1)
             end
           end
         end
       end
     end
     ! Multiply Iz by the weight
     do k = 1,size(Iz,1)
        Iz(k,:,:) = Iz(k,:,:)*wt(k)
     end
   end

   put(out)
   ! Put the object to file "out"
      OUTPUT :: out
      out.flush
      out.text("GAUSSIAN4 output:")
      out.flush
      out.show("l_a   =",.l_a,dbl_width=TRUE)
      out.show("l_b   =",.l_a,dbl_width=TRUE)
      out.show("l_c   =",.l_c,dbl_width=TRUE)
      out.show("l_d   =",.l_d,dbl_width=TRUE)
      out.show("Ra    =",.pos_a(1),.pos_a(2),.pos_a(3))
      out.show("Rb    =",.pos_b(1),.pos_b(2),.pos_b(3))
      out.show("Rc    =",.pos_c(1),.pos_c(2),.pos_c(3))
      out.show("Rd    =",.pos_d(1),.pos_d(2),.pos_d(3))
      out.show("alpha =",.ex_a)
      out.show("beta  =",.ex_b)
      out.show("gamma =",.ex_c)
      out.show("delta =",.ex_d)
   end

end
