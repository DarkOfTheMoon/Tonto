!---------------------------------------------------------------------------
!
!  GAUSSIAN4 : Quartets of gaussian functions
!
!  (c) dylan jayatilaka, 1999
!
! $Id$
!
!---------------------------------------------------------------------------
module GAUSSIAN4

   use TYPES
   use ERROR
   use MM
   use INT
   use IVEC
   use VEC
   use IMAT
   use MAT
   use MAT3
   use MAT4
   use MAT5
   use OUTPUT
   use GAUSSIAN
   use RYS

   implicit none         

#  include "macros"
#  include "gaussian4.int"

!  type gaussian4_type
!     INT :: l_a,l_b,l_c,l_d
!     VEC(3) :: pos_a,pos_b,pos_c,pos_d
!     DBL :: ex_a,ex_b,ex_c,ex_d
!  end 

   DBL, private :: pi212  = 1.1283791670955d+0
!  DBL, private :: pi212  = TWO/sqrt(PI)

contains

   create
   ! Create 
      PTR :: self
      nullify(self)
      allocate(self)
      std_mm.add(GAUSSIAN4_SIZE)
   end

   create(Ga,Gb,Gc,Gd)
   ! Create and set to "Ga" ... "Gd"
      PTR :: self
      GAUSSIAN :: Ga,Gb,Gc,Gd
      nullify(self)
      allocate(self)
      std_mm.add(GAUSSIAN4_SIZE)
      .set(Ga,Gb,Gc,Gd)
   end

   destroy
   ! Destroy 
      PTR :: self
      if (.destroyed) return
      std_mm.delete(GAUSSIAN4_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set(Ga,Gb,Gc,Gd) 
   ! Set the gaissian pair object to "Ga" and "Gb"
      GAUSSIAN :: Ga,Gb,Gc,Gd
      .l_a   = Ga%l
      .pos_a = Ga%pos
      .ex_a  = Ga%ex
      .l_b   = Gb%l
      .pos_b = Gb%pos
      .ex_b  = Gb%ex
      .l_c   = Gc%l
      .pos_c = Gc%pos
      .ex_c  = Gc%ex
      .l_d   = Gd%l
      .pos_d = Gd%pos
      .ex_d  = Gd%ex
   end

   set(l_a,pos_a,ex_a,l_b,pos_b,ex_b,l_c,pos_c,ex_c,l_d,pos_d,ex_d) 
   ! Set a gaussian object
      INT :: l_a,l_b,l_c,l_d
      VEC(3) :: pos_a,pos_b,pos_c,pos_d
      DBL :: ex_a,ex_b,ex_c,ex_d
      .l_a   = l_a
      .pos_a = pos_a
      .ex_a  = ex_a
      .l_b   = l_b
      .pos_b = pos_b
      .ex_b  = ex_b
      .l_c   = l_c
      .pos_c = pos_c
      .ex_c  = ex_c
      .l_d   = l_d
      .pos_d = pos_d
      .ex_d  = ex_d
   end

   set(ex_a,ex_b,ex_c,ex_d) 
   ! Set the exponents of the pair
      DBL, optional :: ex_a,ex_b,ex_c,ex_d
      if (present(ex_a)) .ex_a = ex_a
      if (present(ex_b)) .ex_b = ex_b
      if (present(ex_c)) .ex_c = ex_c
      if (present(ex_d)) .ex_d = ex_d
   end

   make_ERI_ints(I)
   ! Make ERI matrix "I" using Rys decomposition of 1/r_{12}.
      MAT4 :: I
      MAT5, PTR :: Ix,Iy,Iz
      IVEC, PTR :: ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz
      RYS, PTR :: rys
      VEC(3) :: AB,CD,P,Q,PA,QC,QP
      DBL :: zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac
      INT :: l_e,l_f,n_a,n_b,n_c,n_d,n_roots
      l_e = .l_a + .l_b
      l_f = .l_c + .l_d
      n_roots = (l_e+l_f+2)/2
      Ix.create(n_roots,l_e+1,.l_b+1,l_f+1,.l_d+1)
      Iy.create(n_roots,l_e+1,.l_b+1,l_f+1,.l_d+1)
      Iz.create(n_roots,l_e+1,.l_b+1,l_f+1,.l_d+1)
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      n_c = (.l_c+1)*(.l_c+2)/2
      n_d = (.l_d+1)*(.l_d+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_powers(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_powers(bx,by,bz)
      cx.create(n_c); cy.create(n_c); cz.create(n_c); .l_c.make_gaussian_xyz_powers(cx,cy,cz)
      dx.create(n_d); dy.create(n_d); dz.create(n_d); .l_d.make_gaussian_xyz_powers(dx,dy,dz)
      zeta = .ex_a + .ex_b
      eta  = .ex_c + .ex_d
      zinv = 1/zeta
      einv = 1/eta
      zeinv = 1/(zeta+eta)
      rho  = zeta*eta*zeinv
      AB  = .pos_a - .pos_b
      CD  = .pos_c - .pos_d
      P   = (.ex_a*.pos_a + .ex_b*.pos_b)*zinv
      Q   = (.ex_c*.pos_c + .ex_d*.pos_d)*einv
      PA  = P - .pos_a
      QC  = Q - .pos_c
      QP  = Q - P
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)
      !!!!!!!!!!!!!!!!!!!!
      I = ZERO
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys%r,rys%w,rho,zinv,einv,PA,QC,QP)
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD)
      ! Form the integrals 
      I = sum(Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)
      !!!!!!!!!!!!!!!!!!!!
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy
      dz.destroy; dy.destroy; dx.destroy
      cz.destroy; cy.destroy; cx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-.ex_a*.ex_b*AB2*zinv -.ex_c*.ex_d*CD2*einv)
      I = fac*I
   end

   transfer_2d_ints(Ix,Iy,Iz,AB,CD,max_a,max_b,max_c,max_d) [pure]
   ! Use the ,transfer relation to put momenta on centres B and D to get all 
   ! the 2d integrals "Ix", "Iy" and "Iz". If present, "max_i" are the maximum
   ! l-values desired for each center. You must ensure that the "Ii" arrays are
   ! big enough, in this case.
      IN :: self
      MAT5, INOUT :: Ix,Iy,Iz
      VEC(3), IN :: AB,CD
      INT, IN, optional :: max_a,max_b,max_c,max_d
      INT :: le1,lf1,l_a,l_b,l_c,l_d,a,b,c,d,a1,b1,c1,d1,la1
      l_a = .l_a; l_b = .l_b; l_c = .l_c; l_d = .l_d
      if (present(max_a)) l_a=max_a
      if (present(max_b)) l_b=max_b
      if (present(max_c)) l_c=max_c
      if (present(max_d)) l_d=max_d
      if (l_b==0 AND l_d==0) return
      if (l_b/=0) then
         le1 = l_a + l_b + 1
         do b = 1,l_b
         do a = 1,le1 - b 
            b1 = b   + 1
            a1 = a   + 1
            Ix(:,a,b1,:,1) = Ix(:,a1,b,:,1) + AB(1)*Ix(:,a,b,:,1)
            Iy(:,a,b1,:,1) = Iy(:,a1,b,:,1) + AB(2)*Iy(:,a,b,:,1)
            Iz(:,a,b1,:,1) = Iz(:,a1,b,:,1) + AB(3)*Iz(:,a,b,:,1)
         end
         end
      end
      if (l_d/=0) then
         la1 = l_a + 1
         lf1 = l_c + l_d + 1
         do d = 1,l_d
         do c = 1,lf1 - d
            d1 = d   + 1
            c1 = c   + 1
            Ix(:,1:la1,:,c,d1) = Ix(:,1:la1,:,c1,d) + CD(1)*Ix(:,1:la1,:,c,d)
            Iy(:,1:la1,:,c,d1) = Iy(:,1:la1,:,c1,d) + CD(2)*Iy(:,1:la1,:,c,d)
            Iz(:,1:la1,:,c,d1) = Iz(:,1:la1,:,c1,d) + CD(3)*Iz(:,1:la1,:,c,d)
         end
         end
      end
   end

   form_2d_ints(Ix,Iy,Iz,t2,wt,rho,zinv,einv,PA,QC,QP,max_e,max_f) [pure]
   ! Forms the two dimensional integrals "Ix", "Iy" and "Iz" with momenta only
   ! on centres A and C, using Rys roots "t2" and weights "wt".
   ! Other variables are intermediates, to avoid calculations: see make_ERI_ints.
   ! If present, "max_e" and "max_f" are used for the maximum angular momenta
   ! of centers (a+b) and (c+d) respectively -- for derivative integrals.
     IN :: self
     MAT3, INOUT :: Ix,Iy,Iz
     VEC, IN :: t2,wt
     DBL, IN :: rho,zinv,einv
     VEC(3), IN :: PA,QC,QP
     INT, IN, optional :: max_e,max_f
     VEC(size(t2)) :: ret,rzt,ce,cf,bb,ce1,cf1
     INT :: l_e,l_f,e,f,e1,f1,fp1,ep1,k
     l_e = .l_a + .l_b
     l_f = .l_c + .l_d
     if (present(max_e)) l_e = max_e
     if (present(max_f)) l_f = max_f
     Ix(:,1,1) = ONE
     Iy(:,1,1) = ONE
     Iz(:,1,1) = ONE
     if (l_e/=0 OR l_f/=0) then
       if (l_f>0) then
         ret = rho*t2*einv
         Ix(:,1,2) = QC(1) - ret(:) * QP(1)
         Iy(:,1,2) = QC(2) - ret(:) * QP(2)
         Iz(:,1,2) = QC(3) - ret(:) * QP(3)
         if (l_f>1) then
           cf = (ONE - ret) * HALF * einv
           do f = 2,l_f
             f1  = f - 1
             fp1 = f + 1
             cf1 = f1 * cf
             Ix(:,1,fp1) = Ix(:,1,2) * Ix(:,1,f) + cf1 * Ix(:,1,f1)
             Iy(:,1,fp1) = Iy(:,1,2) * Iy(:,1,f) + cf1 * Iy(:,1,f1)
             Iz(:,1,fp1) = Iz(:,1,2) * Iz(:,1,f) + cf1 * Iz(:,1,f1)
           end
         end
       end
       if (l_e>0) then
         rzt = rho * t2 * zinv
         Ix(:,2,1) = PA(1) + rzt(:) * QP(1)
         Iy(:,2,1) = PA(2) + rzt(:) * QP(2)
         Iz(:,2,1) = PA(3) + rzt(:) * QP(3)
         if (l_e>1) then
           ce = (ONE - rzt) * HALF * zinv
           do e = 2, l_e
             e1  = e - 1
             ep1 = e + 1
             ce1 = e1 * ce
             Ix(:,ep1,1) = Ix(:,2,1) * Ix(:,e,1) + ce1 * Ix(:,e1,1)
             Iy(:,ep1,1) = Iy(:,2,1) * Iy(:,e,1) + ce1 * Iy(:,e1,1)
             Iz(:,ep1,1) = Iz(:,2,1) * Iz(:,e,1) + ce1 * Iz(:,e1,1)
           end
         end
       end
       if (l_f>0 AND l_e>0) then
         bb = HALF*einv*rzt
         Ix(:,2,2)=Ix(:,1,2)*Ix(:,2,1)+bb
         Iy(:,2,2)=Iy(:,1,2)*Iy(:,2,1)+bb
         Iz(:,2,2)=Iz(:,1,2)*Iz(:,2,1)+bb
         if (l_f>1) then
           do f=2,l_f
             f1  = f - 1
             fp1 = f + 1
             cf1 = f1 * cf
             Ix(:,2,fp1) = Ix(:,1,2) * Ix(:,2,f) + cf1 * Ix(:,2,f1) + bb *Ix(:,1,f)
             Iy(:,2,fp1) = Iy(:,1,2) * Iy(:,2,f) + cf1 * Iy(:,2,f1) + bb *Iy(:,1,f)
             Iz(:,2,fp1) = Iz(:,1,2) * Iz(:,2,f) + cf1 * Iz(:,2,f1) + bb *Iz(:,1,f)
           end
         end
         if (l_e>1) then
           do e = 2, l_e
             e1  =e - 1
             ep1 =e + 1
             ce1 =e1 * ce
             do f=2, l_f + 1
               f1 = f - 1
               Ix(:,ep1,f) = Ix(:,2,1)*Ix(:,e,f)+ce1*Ix(:,e1,f)+f1*bb(:)*Ix(:,e,f1)
               Iy(:,ep1,f) = Iy(:,2,1)*Iy(:,e,f)+ce1*Iy(:,e1,f)+f1*bb(:)*Iy(:,e,f1)
               Iz(:,ep1,f) = Iz(:,2,1)*Iz(:,e,f)+ce1*Iz(:,e1,f)+f1*bb(:)*Iz(:,e,f1)
             end
           end
         end
       end
     end
     ! Multiply Iz by the weight
     do k = 1,size(Iz,1)
        Iz(k,:,:) = Iz(k,:,:)*wt(k)
     end
   end

   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
   ! Make the same-spin orbit integrals "Sx" "Sy" "Sz"  and the 
   ! other spin orbit integrals  "Ox" "Oy" "Oz" using Rys method.
   ! Reference: Bearpark et al., Mol. Phys. 80, p. 479 (1993)
      MAT4 :: Sx,Sy,Sz,Ox,Oy,Oz
      MAT5, PTR :: Ix,Iy,Iz,LLx,LLy,LLz,RRx,RRy,RRz
      IVEC, PTR :: ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz
      RYS, PTR :: rys
      VEC(3) :: AB,CD,P,Q,PA,QC,QP
      DBL :: zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac
      INT :: l_e,l_f,l_a,l_b,l_c,l_d,n_a,n_b,n_c,n_d,n_roots,f,d
      l_a = .l_a + 1; l_b = .l_b + 1; l_c = .l_c + 1; l_d = .l_d + 1
      l_e = .l_a + .l_b + 1; l_f = .l_c + .l_d + 1 ! One higherfor differentiating
      n_roots = (l_e+l_f+2)/2
      Ix.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)   ! Basic intermediate integrals
      Iy.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)
      Iz.create(n_roots,l_e+1,l_b+1,l_f+1,l_d+1)
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      n_c = (.l_c+1)*(.l_c+2)/2
      n_d = (.l_d+1)*(.l_d+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_powers(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_powers(bx,by,bz)
      cx.create(n_c); cy.create(n_c); cz.create(n_c); .l_c.make_gaussian_xyz_powers(cx,cy,cz)
      dx.create(n_d); dy.create(n_d); dz.create(n_d); .l_d.make_gaussian_xyz_powers(dx,dy,dz)
      zeta = .ex_a + .ex_b
      eta  = .ex_c + .ex_d
      zinv = 1/zeta
      einv = 1/eta
      zeinv = 1/(zeta+eta)
      rho  = zeta*eta*zeinv
      AB  = .pos_a - .pos_b
      CD  = .pos_c - .pos_d
      P   = (.ex_a*.pos_a + .ex_b*.pos_b)*zinv
      Q   = (.ex_c*.pos_c + .ex_d*.pos_d)*einv
      PA  = P - .pos_a
      QC  = Q - .pos_c
      QP  = Q - P
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Ix = ZERO; Iy = ZERO; Iz = ZERO
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys%r,rys%w,rho,zinv,einv,PA,QC,QP,l_e,l_f)
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD,l_a,l_b,l_c,l_d) ! one unit higher for differentiating
      LLx.create(n_roots,l_a,l_b,l_c,l_d) ! Derivative integrals
      LLy.create(n_roots,l_a,l_b,l_c,l_d)
      LLz.create(n_roots,l_a,l_b,l_c,l_d)
      RRx.create(n_roots,l_a,l_b,l_c,l_d)
      RRy.create(n_roots,l_a,l_b,l_c,l_d)
      RRz.create(n_roots,l_a,l_b,l_c,l_d)
      .differentiate(Ix,"a",LLx); .differentiate(Iy,"a",LLy); .differentiate(Iz,"a",LLz)
      .differentiate(Ix,"b",RRx); .differentiate(Iy,"b",RRy); .differentiate(Iz,"b",RRz)
      ! Form the same-spin orbit integrals 
      Sx = sum(Ix(:,ax,bx,cx,dx)*(LLy(:,ay,by,cy,dy)*RRz(:,az,bz,cz,dz)-RRy(:,ay,by,cy,dy)*LLz(:,az,bz,cz,dz)),dim=1)
      Sy = sum(Iy(:,ay,by,cy,dy)*(LLz(:,az,bz,cz,dz)*RRx(:,ax,bx,cx,dx)-RRz(:,az,bz,cz,dz)*LLx(:,ax,bx,cx,dx)),dim=1)
      Sz = sum(Iz(:,az,bz,cz,dz)*(LLx(:,ax,bx,cx,dx)*RRy(:,ay,by,cy,dy)-RRx(:,ax,bx,cx,dx)*LLy(:,ay,by,cy,dy)),dim=1)
      .differentiate(Ix,"c",LLx); .differentiate(Iy,"c",LLy); .differentiate(Iz,"c",LLz)
      .differentiate(Ix,"d",RRx); .differentiate(Iy,"d",RRy); .differentiate(Iz,"d",RRz) 
      ! Form the other spin orbit integrals 
      Ox = sum(Ix(:,ax,bx,cx,dx)*(LLy(:,ay,by,cy,dy)*RRz(:,az,bz,cz,dz)-RRy(:,ay,by,cy,dy)*LLz(:,az,bz,cz,dz)),dim=1)
      Oy = sum(Iy(:,ay,by,cy,dy)*(LLz(:,az,bz,cz,dz)*RRx(:,ax,bx,cx,dx)-RRz(:,az,bz,cz,dz)*LLx(:,ax,bx,cx,dx)),dim=1)
      Oz = sum(Iz(:,az,bz,cz,dz)*(LLx(:,ax,bx,cx,dx)*RRy(:,ay,by,cy,dy)-RRx(:,ax,bx,cx,dx)*LLy(:,ay,by,cy,dy)),dim=1)
      RRz.destroy; RRy.destroy; RRx.destroy
      LLz.destroy; LLy.destroy; LLx.destroy
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy
      dz.destroy; dy.destroy; dx.destroy
      cz.destroy; cy.destroy; cx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-.ex_a*.ex_b*AB2*zinv -.ex_c*.ex_d*CD2*einv)
      Sx = fac*Sx; Sy = fac*Sy; Sz = fac*Sz
      Ox = fac*Ox; Oy = fac*Oy; Oz = fac*Oz
   end

   differentiate(I,index,ID) 
   ! Differentiate a gaussian-integral matrix "I" with respect to the
   ! *nuclear* coordinate on basis function "index", which can be 
   ! "a" "b" "c" or "d" depending on which center is differntiated. 
   ! Place the result in "ID".
      MAT5 :: I,ID
      STR(*) :: index
      INT :: i_a,i_b,i_c,i_d,d_a,d_b,d_c,d_d,a,b,c,d
      DBL :: a2,b2,c2,d2
      i_a = ubound(I,2);  i_b = ubound(I,3);  i_c = ubound(I,4);  i_d = ubound(I,5)
      d_a = ubound(ID,2); d_b = ubound(ID,3); d_c = ubound(ID,4); d_d = ubound(ID,5)
      ID = ZERO
      select case (index)
         case("a")
            ENSURE(i_a>1,  "I array too small to differentiate")
            ENSURE(i_a>d_a,"I and ID arrays are incompatible")
            a2 = TWO*.ex_a
            ID(:,1,:,:,:) = a2*I(:,2  ,1:d_b,1:d_c,1:d_d) 
            do a = 2,d_a
            ID(:,a,:,:,:) = a2*I(:,a+1,1:d_b,1:d_c,1:d_d) - (a-1)*I(:,a-1,1:d_b,1:d_c,1:d_d) 
            end
         case("b")
            ENSURE(i_b>1,  "I array too small to differentiate")
            ENSURE(i_b>d_b,"I and ID arrays are incompatible")
            b2 = TWO*.ex_b
            ID(:,:,1,:,:) = b2*I(:,1:d_a,2  ,1:d_c,1:d_d) 
            do b = 2,d_b
            ID(:,:,b,:,:) = b2*I(:,1:d_a,b+1,1:d_c,1:d_d) - (b-1)*I(:,1:d_a,b-1,1:d_c,1:d_d)
            end
         case("c")
            ENSURE(i_c>1,  "I array too small to differentiate")
            ENSURE(i_c>d_c,"I and ID arrays are incompatible")
            c2 = TWO*.ex_c
            ID(:,:,:,1,:) = c2*I(:,1:d_a,1:d_b,2  ,1:d_d) 
            do c = 2,d_c
            ID(:,:,:,c,:) = c2*I(:,1:d_a,1:d_b,c+1,1:d_d) - (c-1)*I(:,1:d_a,1:d_b,c-1,1:d_d)
            end
         case("d")
            ENSURE(i_d>1,  "I array too small to differentiate")
            ENSURE(i_d>d_d,"I and ID arrays are incompatible")
            d2 = TWO*.ex_d
            ID(:,:,:,:,1) = d2*I(:,1:d_a,1:d_b,1:d_c,2  ) 
            do d = 2,d_d
            ID(:,:,:,:,d) = d2*I(:,1:d_a,1:d_b,1:d_c,d+1) - (d-1)*I(:,1:d_a,1:d_b,1:d_c,d-1)
            end
      end
   end

   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
   ! Make the spin spin magnetic dipole-dipole integrals "Dij" using Rys method.
   ! Reference: None. But see Bearpark et al., Mol. Phys. 80, p. 479 (1993) for inspiration.
      MAT4 :: Dxx,Dyy,Dzz,Dxy,Dxz,Dyz
      MAT5, PTR :: Ix,Iy,Iz,Lx,Ly,Lz,Rx,Ry,Rz,LL,LR,RR
      IVEC, PTR :: ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz
      RYS, PTR :: rys
      VEC(3) :: AB,CD,P,Q,PA,QC,QP
      DBL :: zeta,zinv,eta,einv,zeinv,rho,xx,AB2,CD2,fac
      INT :: l_e,l_f,l_a,l_b,l_c,l_d,n_a,n_b,n_c,n_d,n_roots,f,d
      l_a = .l_a + 1; l_b = .l_b + 1
      l_c = .l_c + 1; l_d = .l_d + 1
      l_e = .l_a + .l_b + 2; l_f = .l_c + .l_d    ! Two higher for differentiating A, B.
      n_roots = (l_e+l_f+2)/2
      Ix.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)  ! Basic intermediate integrals
      Iy.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)
      Iz.create(n_roots,l_e+1,l_b+2,l_f+1,l_d+1)
      n_a = (.l_a+1)*(.l_a+2)/2
      n_b = (.l_b+1)*(.l_b+2)/2
      n_c = (.l_c+1)*(.l_c+2)/2
      n_d = (.l_d+1)*(.l_d+2)/2
      ax.create(n_a); ay.create(n_a); az.create(n_a); .l_a.make_gaussian_xyz_powers(ax,ay,az)
      bx.create(n_b); by.create(n_b); bz.create(n_b); .l_b.make_gaussian_xyz_powers(bx,by,bz)
      cx.create(n_c); cy.create(n_c); cz.create(n_c); .l_c.make_gaussian_xyz_powers(cx,cy,cz)
      dx.create(n_d); dy.create(n_d); dz.create(n_d); .l_d.make_gaussian_xyz_powers(dx,dy,dz)
      zeta = .ex_a + .ex_b
      eta  = .ex_c + .ex_d
      zinv = 1/zeta
      einv = 1/eta
      zeinv = 1/(zeta+eta)
      rho  = zeta*eta*zeinv
      AB  = .pos_a - .pos_b
      CD  = .pos_c - .pos_d
      P   = (.ex_a*.pos_a + .ex_b*.pos_b)*zinv
      Q   = (.ex_c*.pos_c + .ex_d*.pos_d)*einv
      PA  = P - .pos_a
      QC  = Q - .pos_c
      QP  = Q - P
      xx = rho*(QP(1)*QP(1)+QP(2)*QP(2)+QP(3)*QP(3))
      rys.create(n_roots)
      rys.get_weights(xx)
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Ix = ZERO; Iy = ZERO; Iz = ZERO
      .form_2d_ints(Ix(:,:,1,:,1),Iy(:,:,1,:,1),Iz(:,:,1,:,1),rys%r,rys%w,rho,zinv,einv,PA,QC,QP,l_e,l_f)
      .transfer_2d_ints(Ix,Iy,Iz,AB,CD,l_a+1,l_b+1) ! two units higher on A, B for differentiating
      Lx.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Ly.create(n_roots,l_a+1,l_b+1,l_c,l_d) 
      Lz.create(n_roots,l_a+1,l_b+1,l_c,l_d) 
      Rx.create(n_roots,l_a+1,l_b+1,l_c,l_d)
      Ry.create(n_roots,l_a+1,l_b+1,l_c,l_d) 
      Rz.create(n_roots,l_a+1,l_b+1,l_c,l_d) 
      LL.create(n_roots,l_a  ,l_b  ,l_c,l_d) 
      LR.create(n_roots,l_a  ,l_b  ,l_c,l_d) 
      RR.create(n_roots,l_a  ,l_b  ,l_c,l_d) 
      .differentiate(Ix,"a",Lx); .differentiate(Ix,"b",Rx) 
      .differentiate(Iy,"a",Ly); .differentiate(Iy,"b",Ry) 
      .differentiate(Iz,"a",Lz); .differentiate(Iz,"b",Rz) 
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      .differentiate(Lx,"a",LL); .differentiate(Rx,"b",RR)
      .differentiate(Lx,"b",LR); LR = TWO*LR
      Dxx = sum(LL(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     LR(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     RR(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)
      .differentiate(Ly,"a",LL); .differentiate(Ry,"b",RR)
      .differentiate(Ly,"b",LR); LR = TWO*LR
      Dyy = sum(Ix(:,ax,bx,cx,dx)*LL(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*LR(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*RR(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)
      .differentiate(Lz,"a",LL); .differentiate(Rz,"b",RR)
      .differentiate(Lz,"b",LR); LR = TWO*LR
      Dzz = sum(Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*LL(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*LR(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Iz(:,ay,by,cy,dy)*RR(:,az,bz,cz,dz),dim=1)
      RR.destroy; LR.destroy; LL.destroy
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Dxy = sum(Lx(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Lx(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Rx(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz) &
          +     Rx(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Iz(:,az,bz,cz,dz),dim=1)
      Dxz = sum(Lx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
          +     Lx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz) &
          +     Rx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
          +     Rx(:,ax,bx,cx,dx)*Iy(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz),dim=1)
      Dyz = sum(Ix(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Ly(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Lz(:,az,bz,cz,dz) &
          +     Ix(:,ax,bx,cx,dx)*Ry(:,ay,by,cy,dy)*Rz(:,az,bz,cz,dz),dim=1)
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      Rz.destroy; Ry.destroy; Rx.destroy
      Lz.destroy; Ly.destroy; Lx.destroy
      rys.destroy
      Iz.destroy; Iy.destroy; Ix.destroy
      dz.destroy; dy.destroy; dx.destroy
      cz.destroy; cy.destroy; cx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      AB2 = AB(1)*AB(1)+AB(2)*AB(2)+AB(3)*AB(3)
      CD2 = CD(1)*CD(1)+CD(2)*CD(2)+CD(3)*CD(3)
      fac = TWOPI5ON2*sqrt(zeinv)*zinv*einv*exp(-.ex_a*.ex_b*AB2*zinv -.ex_c*.ex_d*CD2*einv)
      Dxx = fac*Dxx; Dyy = fac*Dyy; Dzz = fac*Dzz
      Dxy = fac*Dxy; Dxz = fac*Dxz; Dyz = fac*Dyz
   end

   put(out)
   ! Put the object to file "out"
      OUTPUT :: out
      out.flush
      out.text("GAUSSIAN4 output:")
      out.flush
      out.show("l_a   =",.l_a,dbl_width=TRUE)
      out.show("l_b   =",.l_a,dbl_width=TRUE)
      out.show("l_c   =",.l_c,dbl_width=TRUE)
      out.show("l_d   =",.l_d,dbl_width=TRUE)
      out.show("Ra    =",.pos_a(1),.pos_a(2),.pos_a(3))
      out.show("Rb    =",.pos_b(1),.pos_b(2),.pos_b(3))
      out.show("Rc    =",.pos_c(1),.pos_c(2),.pos_c(3))
      out.show("Rd    =",.pos_d(1),.pos_d(2),.pos_d(3))
      out.show("alpha =",.ex_a)
      out.show("beta  =",.ex_b)
      out.show("gamma =",.ex_c)
      out.show("delta =",.ex_d)
   end

end
