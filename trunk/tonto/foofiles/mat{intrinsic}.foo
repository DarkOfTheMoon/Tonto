!-------------------------------------------------------------------------------
!
! MAT{INTRISIC}: Generic matrix operations ...
!
! Copyright (C) Dylan Jayatilaka, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

virtual module MAT{INTRINSIC}

   implicit none

   interface diagonal_set_to
      set_from_diagonal
   end

   interface diagonal_set_to
      set_diagonal_to
   end

   interface diagonal_plus
      increment_diagonal_by
   end

   interface diagonal_times
      scale_diagonal_by
   end

   interface diagonal_max 
      max_diagonal_element 
   end

   interface diagonal_max_abs
      max_abs_diagonal_element 
   end

contains

! *****************
! Memory allocation
! *****************

   create(dim1,dim2) ::: leaky
   ! Create a matrix with the given dimensions
      self :: PTR
      dim1,dim2 :: INT, IN
      status :: INT
      nullify(self)
      allocate(self(dim1,dim2),STAT=status)
      DIE_IF(status/=0,"error in allocating memory")
      ADD_MEMORY(dim1*dim2*ELEMENT_TYPE_SIZE)
   end

   create(bounds) ::: leaky
   ! Create a matrix with the specified "bounds" for each dimension
      self :: PTR
      bounds :: VEC{INT}(2), IN
      .create(bounds(1),bounds(2))
   end

   create(lb1,ub1,lb2,ub2) ::: leaky
   ! Create a matrix with the given dimensions
      self :: PTR
      lb1,ub1,lb2,ub2 :: INT, IN
      status :: INT
      nullify(self)
      allocate(self(lb1:ub1,lb2:ub2),STAT=status)
      DIE_IF(status/=0,"error in allocating memory")
      ADD_MEMORY((ub1-lb1+1)*(ub2-lb2+1)*ELEMENT_TYPE_SIZE)
   end

   create(bounds1,bounds2) ::: leaky
   ! Create a matrix with the specified bounds for each dimension
      self :: PTR
      bounds1,bounds2 :: VEC{INT}, IN
      .create(bounds1(1),bounds1(2),bounds2(1),bounds2(2))
   end

   create(bounds) ::: leaky
   ! Create a matrix with the given bounds for all dimensions
      self :: PTR
      bounds :: MAT{INT}(2,2), IN
      .create(bounds(1,1),bounds(1,2),bounds(2,1),bounds(2,2))
   end

   create_copy(matrix) ::: leaky
   ! Create a replica copy of matrix
      self :: PTR
      matrix :: MAT{INTRINSIC}, IN
      .create(lbound(matrix,1),ubound(matrix,1), &
              lbound(matrix,2),ubound(matrix,2)  )
      self = matrix
   end

   destroy ::: leaky
   ! Destroy the object
      self :: PTR
      if (.destroyed) return
      DELETE_MEMORY(.dim*ELEMENT_TYPE_SIZE)
      deallocate(self)
   end

   created result (res) ::: inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
      result = associated(self)
   end

   destroyed result (res) ::: inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
      result = NOT associated(self)
   end

! ****************************
! Size-of and shape operations 
! ****************************

   size result (res) ::: inlined_by_foo
   ! Return the size of the array
      res :: INT
      res = .size
   end

   dim1 result (res) ::: inlined_by_foo
   ! Return the size of the 1st dimension
      res :: INT
      res = .dim1
   end

   dim2 result (res) ::: inlined_by_foo
   ! Return the size of the 2nd dimension
      res :: INT
      res = .dim2
   end

   shape result (res)
   ! Return the shape of "self"
      res :: VEC{INT}(2)
      res = [.dim1,.dim2]
   end

   is_same_shape_as(a) result (res) ::: pure
   ! Returns TRUE if the matrix "a" has the same shape as "self"
      self :: IN
      a :: A_TYPE, IN
      res :: BIN
      res = .dim1==a.dim1 AND .dim2==a.dim2
   end

   is_transposed_shape_of(a) result (res) ::: pure
   ! Returns TRUE if the matrix "a" is the transposed shape of self
      self :: IN
      a :: A_TYPE, IN
      res :: BIN
      res = .dim1==a.dim2 AND .dim2==a.dim1
   end

   is_square result (res) ::: pure
   ! Returns TRUE if the matrix is square
      self :: IN
      res :: BIN
      res = .dim1==.dim2
   end

! ***********************
! Shrinking and expansion
! ***********************

   shrink(dim1,dim2) ::: leaky
   ! Shrinks self to dimension dim1xdim2.  Contents are retained.
     self :: PTR
     dim1,dim2 :: INT, IN
   ENSURE(.created, "matrix not allocated")
   ENSURE(dim1<=.dim1, "1st dimension given is too large.")
   ENSURE(dim2<=.dim2, "2nd dimension given is too large.")
     old :: MAT{INTRINSIC}*
     if (dim1==.dim1 AND dim2==.dim2) return
     old => self
     nullify(self)
     self.create(dim1,dim2)
     self=old(1:dim1,1:dim2)
     old.destroy
   end

   shrink_columns(dim2) ::: leaky
   ! Shrinks columns of self to dimension dim2. Contents are retained.
     self :: PTR
     dim2 :: INT, IN
   ENSURE(.created,"matrix not allocated")
   ENSURE(dim2<=.dim2, "2nd dimension given is too large.")
     old :: MAT{INTRINSIC}*
     dim1 :: INT
     if (dim2==.dim2) return
     dim1 = .dim1
     old => self
     nullify(self)
     self.create(dim1,dim2)
     self=old(1:dim1,1:dim2)
     old.destroy
   end

   expand(dim1,dim2) ::: leaky
   ! Expands self to dimension dim1xdim2.  Contents are retained.
     self :: PTR
     dim1,dim2 :: INT, IN
     old :: MAT{INTRINSIC}*
     old_size1,old_size2 :: INT
     if (.destroyed) then
       .create(0,0)
     else
     ENSURE(dim1>=.dim1, "1st dimension given is too small")
     ENSURE(dim2>=.dim2, "2nd dimension given is too small")
     end
     old => self
     old_size1 = old.dim1
     old_size2 = old.dim2
     nullify(self)
     self.create(dim1,dim2)
     self(1:old_size1,1:old_size2)=old
     old.destroy
   end

   expand_columns(dim2) ::: leaky
   ! Expands the columns self to dim2.  Contents are retained.
     self :: PTR
     dim2 :: INT, IN
   ENSURE( .created, "matrix not allocated")
   ENSURE(dim2>=.dim2, "2nd dimension given is too small")
     dim1,old_dim2 :: INT
     old :: MAT{INTRINSIC}*
     dim1 = .dim1
     old => self
     old_dim2 = old.dim2
     nullify(self)
     self.create(dim1,dim2)
     self(:,1:old_dim2) = old
     old.destroy
   end

   append_columns(cols) ::: leaky
   ! Append the columns "cols" onto the end of self.
     self :: PTR
     cols :: MAT{INTRINSIC}
     old_dim2,new_dim2 :: INT
     if (.destroyed) then
        .create_copy(cols)
     else
        ENSURE(.dim1==cols.dim1, "1st dimension wrong, cols")
        old_dim2 = .dim2
        new_dim2 = .dim2 + cols.dim2
        .expand_columns(new_dim2)
        self(:,old_dim2+1:new_dim2) = cols
     end
   end

   append_column(col) ::: leaky
   ! Append the column "col" onto the end of self.
     self :: PTR
     col :: VEC{INTRINSIC}
     old_dim2,new_dim2 :: INT
     if (.destroyed) then
        .create(col.dim,1)
        self(:,1) = col
     else
        ENSURE(.dim1==col.dim, "2nd dimension given is too small")
        old_dim2 = .dim2
        new_dim2 = .dim2 + 1
        .expand_columns(new_dim2)
        self(:,new_dim2) = col
     end
   end

   prune_column(col) ::: leaky
   ! Prune the column "col".
     self :: PTR
     col :: INT, IN
   ENSURE(.created,"self is not created")
   ENSURE(1 <= col AND col<=.dim2, "col is out of range")
     dim2 :: INT
     dim2 = .dim2 -1
     self(:,col:dim2) =  self(:,col+1:)
     self.shrink_columns(dim2)
   end

! ********************
! Comparison functions
! ********************

   equals(b) result (res)
   ! Check if the matrix is the same as "b".
      self :: IN
      b :: MAT{INTRINSIC}, IN
      res :: BIN
      res = .same_as(b)
   end

   same_as(b,eps,diff) result (res)
   ! Check if the matrix is the same as "b", within "eps", and return the
   ! actual difference in "diff"
      self :: IN
      b :: MAT{INTRINSIC}, IN
      eps :: REAL, IN, optional
      diff :: REAL, OUT, optional
      res :: BIN
   ENSURE(.is_same_shape_as(b),"incompatible dimensions")
      tmp :: VEC{INTRINSIC}*
      del,tolerance :: REAL
      tolerance = REAL_EPSILON
      if (present(eps)) tolerance = eps
      tmp.create(.size)
      tmp = reshape((self-b),[.size])
      del = sqrt(dot_product(tmp,tmp))
      tmp.destroy
      res = FALSE
      if (del<tolerance) res = TRUE
      if (present(diff)) diff = del
   end

! ****************
! Range operations
! ****************

   all_in_range(range) result (res)
   ! Return TRUE if all values of self are within the specified "range".
      range :: VEC{INTRINSIC}(2)
      res :: BIN
      res = all(range(1) <= self AND self <= range(2))
   end

   in_range(range) result (res)
   ! Return element ij as TRUE if self(i,j) is within the specified "range".
      range :: VEC{INTRINSIC}(2)
      res :: MAT{BIN}(.dim1,.dim2)
      res = (range(1) <= self AND self <= range(2))
   end

   range result (res)
   ! Return the range (smallest and largest value) of self.
      res :: VEC{INTRINSIC}(2)
      res(1) = minval(self)
      res(2) = maxval(self)
   end

! *****************
! Inquiry functions
! *****************

   is_diagonal result (res)
   ! Returns TRUE if the matrix "self" is a diagonal matrix
      self :: IN
      res :: BIN
   ENSURE(.is_square,"Non-square matrix")
      dim,i,j :: INT
      dim = .dim1
      res = TRUE
      do i = 1,dim
      do j = 1,dim
         if (i==j) cycle
         if (self(i,j).is_zero) cycle
         res = FALSE
         return
      end
      end
   end

   has_unit_diagonal result (res)
   ! Returns TRUE if the matrix "self" has 1's as diagonal elements
      self :: IN
      res :: BIN
   ENSURE(.is_square,"Non-square matrix")
      i :: INT
      res = TRUE
      do i = 1,.dim1
         if (self(i,i).is_one) cycle
         res = FALSE
         return
      end
   end

   has_unit_diagonal(eps) result (res)
   ! Returns TRUE if the matrix "self" has 1's as diagonal elements to within
   ! tolerance "eps" (if present).
      self :: IN
      eps :: REAL, IN, optional
      res :: BIN
   ENSURE(.is_square,"Non-square matrix")
      i :: INT
      res = TRUE
      do i = 1,.dim1
         if (self(i,i).is_one(eps)) cycle
         res = FALSE
         return
      end
   end

   has_minus_unit_diagonal result (res)
   ! Returns TRUE if the matrix "self" has -1's as diagonal elements
      self :: IN
      res :: BIN
   ENSURE(.is_square,"Non-square matrix")
      i :: INT
      res = TRUE
      do i = 1,.dim1
         if (self(i,i).is_minus_one) cycle
         res = FALSE
         return
      end
   end

   is_unit_matrix result (res)
   ! Returns TRUE if the matrix "self" is the unit matrix
      self :: IN
      res :: BIN
   ENSURE(.is_square,"Non-square matrix")
      res = .has_unit_diagonal AND .is_diagonal
   end

   is_inversion_matrix result (res)
   ! Returns TRUE if the matrix "self" is an inversion matrix
   ! i.e. minus the unit matrix
      self :: IN
      res :: BIN
   ENSURE(.is_square,"Non-square matrix")
      res = .has_minus_unit_diagonal AND .is_diagonal
   end

   is_symmetric result (res)
   ! Returns TRUE if the matrix "self" is a symmetric matrix
      self :: IN
      res :: BIN
   ENSURE(.is_square,"Non-square matrix")
      dim,i,j :: INT
      dim = .dim1
      res = TRUE
      do i = 1,dim
      do j = 1,i-1
         if (self(i,j).equals(self(j,i))) cycle
         res = FALSE
         return
      end
      end
      ! res = .is_square AND .same_as(transpose(self),tol)
   end

   is_antisymmetric result (res)
   ! Returns TRUE if the matrix "self" is an antisymmetric matrix
      self :: IN
      res :: BIN
   ENSURE(.is_square,"Non-square matrix")
      dim,i,j :: INT
      dim = .dim1
      res = TRUE
      do i = 1,dim
      do j = 1,i-1
         if (self(i,j).equals(-self(j,i))) cycle
         res = FALSE
         return
      end
      end
      ! res = .is_square AND .same_as(-transpose(self),tol)
   end

   is_zero(eps) result (res) ::: pure
   ! Return TRUE is "self" is the zero matrix, i.e. every element is zero.
   ! If present, "eps" is used to decide when a small number is zero.
      self :: IN
      eps :: REAL, optional, IN
      res :: BIN
      i,j :: INT
      res = TRUE
      do i = 1,.dim1
      do j = 1,.dim2
         if (self(i,j).is_zero(eps)) cycle
         res = FALSE
         exit
      end
      end
   end

! *****************
! Column operations 
! *****************

   has_column(c,col) result (res)
   ! Returns TRUE if the matrix "self" has a column "c".  If present, the
   ! matching column index "col" is also returned.
      self :: IN
      c :: VEC{INTRINSIC}, IN
      col :: INT, optional
      res :: BIN
   ENSURE(c.dim==.dim1,"incompatible column size")
      n :: INT
      if (present(col)) col = 0
      res = FALSE
      do n = 1,.dim2
         res = self(:,n).same_as(c)
         if (NOT res) cycle
         if (present(col)) col = n
         exit
      end
   end

   has_column(c,eps,col) result (res)
   ! Returns TRUE if the matrix "self" has a column "c", with "eps" tolerance.
   ! If present, the matching column index "col" is also returned.
      self :: IN
      c :: VEC{INTRINSIC}, IN
      eps :: REAL, optional
      col :: INT, optional
      res :: BIN
   ENSURE(c.dim==.dim1,"incompatible column size")
      n :: INT
      if (present(col)) col = 0
      res = FALSE
      do n = 1,.dim2
         res = self(:,n).same_as(c,eps)
         if (res) then
            if (present(col)) col = n
            exit
         end
      end
   end

   column_index(c) result (res)
   ! The matching column index is returned, if the column matches "col".
      self :: IN
      c :: VEC{INTRINSIC}, IN
      res :: INT
   ENSURE(c.dim==.dim1,"incompatible column size")
      n :: INT
      res = 0
      do n = 1,.dim2
         if (self(:,n).same_as(c)) then
            res = n
            exit
         end
      end
   end

   column_index(c,eps) result (res)
   ! The matching column index is returned, if the column matches "col" to
   ! tolerance "eps", if it is present.
      self :: IN
      c :: VEC{INTRINSIC}, IN
      res :: INT
      eps :: REAL, optional
   ENSURE(c.dim==.dim1,"incompatible column size")
      n :: INT
      res = 0
      do n = 1,.dim2
         if (self(:,n).same_as(c,eps)) then
            res = n
            exit
         end
      end
   end

   compare_columns_with(m,col)
   ! Compare the columns of "self" with "m". The elements of array "col" are set
   ! TRUE if the corresponding column appears in "m"
      self :: IN
      m :: MAT{INTRINSIC}, IN
      col :: VEC{INT}, OUT
   ENSURE(m.dim1==.dim1,"incompatible column size")
   ENSURE(col.dim==.dim2,"wrong size for col")
      n,i :: INT
      col = 0
      do n = 1,.dim2
         do i = 1,m.dim2
            if (NOT self(:,n).same_as(m(:,i))) cycle
            col(n) = i
            exit
         end
      end
   end

   unique_columns(col)
   ! Compare the later columns of "self" with earlier columns to see if they are
   ! unique. The elements of array "col" are set TRUE if the corresponding
   ! column is unique.
      self :: IN
      col :: VEC{BIN}, OUT
   ENSURE(.dim2>0,"must have at least one column")
   ENSURE(col.dim==.dim2,"wrong size for col")
      n,i :: INT
      col = TRUE
      do n = 2,.dim2
         do i = 1,n-1
            if (NOT self(:,n).same_as(self(:,i))) cycle
            col(n) = FALSE
            exit
         end
      end
   end

   unique_columns(col) ::: leaky
   ! Compare the later columns of "self" with earlier columns to see if they are
   ! unique. The elements of array "col" are set to the indices of the unique
   ! columns.
      self :: IN
      col :: VEC{INT}*
   ENSURE(.dim2>0,"must have at least one column")
   ENSURE(col.dim==.dim2,"wrong size for col")
      n,i :: INT
      is_unique :: VEC{BIN}*
      is_unique.create(.dim2)
      .unique_columns(is_unique)
      col.create(count(is_unique)) ! this is leaky
      i = 1
      col(1) = 1
      do n = 2,.dim2
         if (NOT is_unique(n)) cycle
         i = i + 1
         col(i) = n
      end 
      is_unique.destroy
   end

   no_of_unique_columns result (res)
   ! Compare the later columns of "self" with earlier columns to see if they are
   ! unique. Return the number of unique columns.
      self :: IN
      res :: INT
   ENSURE(.dim2>0,"must have at least one column")
      n,i :: INT
      res = .dim2
      do n = 2,.dim2
         do i = 1,n-1
            if (NOT self(:,n).same_as(self(:,i))) cycle
            res = res - 1
            exit
         end
      end
   end

   swap_columns(col1,col2)
   ! Swap columns "col1" and "col2" of self
      col1,col2 :: INT, IN
   ENSURE(col1<=.dim2 AND col2<=.dim2,"columns exceed dimesions")
      a1,a2,i :: INT
      val :: INTRINSIC
      a1 = .dim1
      a2 = .dim2
      do i = 1,a1
         val = self(i,col1)
         self(i,col1) = self(i,col2)
         self(i,col2) = val
      end
   end

   swap_columns(list)
   ! Sequentially swap all columns in a column "list",
   ! self(:,i)      = self(:,list(i))
   ! self(:,col(i)) = self(:,i)
      list :: VEC{INT}, IN
   ENSURE(maxval(list)<=.dim2,"list value exceed column dimension")
      l :: INT
      do l = 1,list.dim
         .swap_columns(l,list(l))
      end
   end

   column_norms result (res)
   ! Return the norms of every column
      res :: VEC{REAL}(.dim2)
      i :: INT
      do i = 1,.dim2
         res(i) = self(:,i).norm
      end
   end

   get_column_norms(res)
   ! Return the norms of every column
      res :: VEC{REAL}
   ENSURE(res.dim==.dim2,"wrong size, res array")
      i :: INT
      do i = 1,.dim2
         res(i) = self(:,i).norm
      end
   end

   get_column_dot_products(res)
   ! Return the dot products of every column with itself.
   ! Good for testing distances without using a sqrt.
      res :: VEC{REAL}
   ENSURE(res.dim==.dim2,"wrong size, res array")
      i :: INT
      do i = 1,.dim2
         res(i) = dot_product(self(:,i),self(:,i))
      end
   end

   index_of_minimum_column_norm(offset) result (res)
   ! Return the column index of the column with the *minimum* norm. If present,
   ! "offset" is subtracted from every column beforehand, and then added back
   ! afterwards. This is useful for finding the index of the column with minimum
   ! distance to "offset", for a list of points held in "self".
      offset :: VEC{INTRINSIC}(.dim1), optional
      res :: INT
      i :: INT
      val,tmp :: REAL
      if (present(offset)) &
         self = self - spread(offset,dim=2,ncopies=self.dim2)
      res = 1
      val = self(:,1).norm
      do i = 2,.dim2
         tmp = self(:,i).norm
         if (tmp>=val) cycle
         val = tmp
         res = i
      end
      if (present(offset)) &
         self = self + spread(offset,dim=2,ncopies=self.dim2)
   end

   max_abs_column_difference result (res)
   ! Return the maximum of the absolute difference between all the column vector
   ! pairs of the matrix.
      res :: VEC{REAL}(.dim1)
      diff :: VEC{REAL}(.dim1)
      col_i,col_j :: VEC{INTRINSIC}(.dim1)
      i,j,dim :: INT
      dim = .dim2
      diff = ZERO
      do i = 1,.dim2
         col_i = self(:,i)
         do j = 1,i-1
            col_j = self(:,j)
            diff = max( real(abs(col_i-col_j),kind=REAL_KIND) , diff)
         end
      end
      res = diff
   end

   mean_column_vector result (res)
   ! Return the mean of the column vectors.
      res :: VEC{INTRINSIC}(.dim1)
      res = .sum_column_vectors/.dim2
   end

   sum_column_vectors result (res)
   ! Sum the column vectors (i.e. rows) in "self".
      res :: VEC{INTRINSIC}(.dim1)
      i :: INT
      do i = 1,.dim1
         res(i) = sum(self(i,:))
      end
   end

   reverse_column_order
   ! Reverse the order of the columns of self.
      tmp :: VEC{INTRINSIC}*
      n,n_col :: INT
      n_col = .dim2
      tmp.create(.dim1)
      do n=1,n_col/2
        tmp = self(:,n_col-n+1)
        self(:,n_col-n+1) = self(:,n)
        self(:,n) = tmp
      end
      tmp.destroy
   end

! **************
! Row operations
! **************

   unique_rows(row)
   ! Compare the later rows of "self" with earlier rows to see if they are
   ! unique. The elements of array "row" are set TRUE if the corresponding
   ! row is unique.
      self :: IN
      row :: VEC{BIN}, OUT
   ENSURE(.dim1>0,"must have at least one row")
   ENSURE(row.dim==.dim1,"wrong size for row")
      n,i :: INT
      row = TRUE
      do n = 2,.dim1
         do i = 1,n-1
            if (NOT self(n,:).same_as(self(i,:))) cycle
            row(n) = FALSE
            exit
         end
      end
   end

   unique_rows(row) ::: leaky
   ! Compare the later rows of "self" with earlier rows to see if they are
   ! unique. The elements of array "row" are set to the indices of the unique
   ! rows.
      self :: IN
      row :: VEC{INT}*
   ENSURE(.dim1>0,"must have at least one row")
   ENSURE(row.dim==.dim1,"wrong size for row")
      n,i :: INT
      is_unique :: VEC{BIN}*
      is_unique.create(.dim1)
      .unique_rows(is_unique)
      row.create(count(is_unique)) ! this is leaky
      i = 1
      row(1) = 1
      do n = 2,.dim1
         if (NOT is_unique(n)) cycle
         i = i + 1
         row(i) = n
      end 
      is_unique.destroy
   end

   no_of_unique_rows result (res)
   ! Compare the later row of "self" with earlier rows to see if they are
   ! unique. Return the number of unique rows.
      self :: IN
      res :: INT
   ENSURE(.dim1>0,"must have at least one row")
      n,i :: INT
      res = .dim1
      do n = 2,.dim1
         do i = 1,n-1
            if (NOT self(n,:).same_as(self(i,:))) cycle
            res = res - 1
            exit
         end
      end
   end

   swap_rows(row1,row2)
   ! Swap columns "row1" and "row2" of self
      row1,row2 :: INT, IN
   ENSURE(row1<=.dim1 AND row2<=.dim1,"columns exceed dimesions")
      i :: INT
      val :: INTRINSIC
      do i = 1,.dim2
         val = self(row1,i)
         self(row1,i) = self(row2,i)
         self(row2,i) = val
      end
   end

   swap_rows(list)
   ! Sequentially swap all rows in a row "list",
   ! self(i,:)       = self(list(i),:)
   ! self(list(i),:) = self(i,:)
      list :: VEC{INT}, IN
   ENSURE(maxval(list)<=.dim1,"list value exceed row dimension")
      l :: INT
      do l = 1,list.dim
         .swap_rows(l,list(l))
      end
   end

   row_norms result (res)
   ! Return the norms of every row
      res :: VEC{REAL}(.dim1)
      i :: INT
      do i = 1,.dim1
         res(i) = self(i,:).norm
      end
   end

   sum_row_vectors result (res)
   ! Sum the row vectors (i.e. columns) in "self".
      res :: VEC{INTRINSIC}(.dim2)
      j :: INT
      do j = 1,.dim2
         res(j) = sum(self(:,j))
      end
   end

! ******************************************
! Matrix algebra and vector space operations
! ******************************************

   determinant result (res)
   ! Return the determinant a 3x3 matrix
      self :: IN
      res :: INTRINSIC
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1<4,"only works for up to size 3 matrices")
      select case (.dim1)
          case (1)
             res = self(1,1)
          case (2)
             res = self(1,1)*self(2,2) - self(2,1)*self(1,2)
          case (3)
             res = self(1,3)*(self(2,1)*self(3,2) - self(3,1)*self(2,2)) &
                 + self(2,3)*(self(3,1)*self(1,2) - self(1,1)*self(3,2)) &
                 + self(3,3)*(self(1,1)*self(2,2) - self(2,1)*self(1,2))
          case default
             DIE("determinant not implemented for dimension greater than 3")
      end
   end

   cofactor result (res) ::: leaky
   ! Return the cofactor of a 3x3 matrix
      self :: IN
      res :: MAT{INTRINSIC}*
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1==3,"only works for 3x3 matrices")
      nullify(res)
      res.create(3,3)
      res(1,1) =  (self(2,2)*self(3,3) - self(2,3)*self(3,2))
      res(1,2) = -(self(2,1)*self(3,3) - self(2,3)*self(3,1))
      res(1,3) =  (self(2,1)*self(3,2) - self(2,2)*self(3,1))
      res(2,1) = -(self(1,2)*self(3,3) - self(1,3)*self(3,2))
      res(2,2) =  (self(1,1)*self(3,3) - self(1,3)*self(3,1))
      res(2,3) = -(self(1,1)*self(3,2) - self(1,2)*self(3,1))
      res(3,1) =  (self(1,2)*self(2,3) - self(1,3)*self(2,2))
      res(3,2) = -(self(1,1)*self(2,3) - self(1,3)*self(2,1))
      res(3,3) =  (self(1,1)*self(2,2) - self(1,2)*self(2,1))
   end

   dot(l,r) result (res)
   ! Multiply the matrix self by vector "l" on the left and vector "r" on the
   ! right ie:  res = l^dagger self r. Useful for non-unit metric dot_products.
     self :: IN
     l,r :: LR_TYPE, IN
     res :: RES_TYPE
   ENSURE(.dim1==l.dim,"wrong size, r")
   ENSURE(.dim2==r.dim,"wrong size, r")
     w :: VEC{RES_TYPE}*
     w.create(l.dim)
     w.to_product_of(self,r)
     res = dot_product(l,w)
     w.destroy
   end

   rotate(v)
   ! Rotate vector "v" by self
     v :: VEC{INTRINSIC}, INOUT
   ENSURE(.is_square,"incompatible arrays sizes")
   ENSURE(.dim2==v.dim, "incompatible arrays sizes")
     dim1,dim2,i,j :: INT
     w :: VEC{INTRINSIC}*
     val :: REAL
     dim1 = .dim1
     dim2 = .dim2
     w.create(dim2)
     do i = 1,dim1
       val = ZERO
       do j = 1,dim2
         val = val + self(i,j) * v(j)
       end
       w(i) = val
     end
     v = w
     w.destroy
   end

   to_unit_matrix
   ! Set "self" to the unit matrix
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      self = ZERO
      do i = 1,.dim1
         self(i,i) = ONE
      end
   end

   zero_small_values(eps) ::: pure
   ! Zero elements of the matrix which are less than "eps" in magnitude
      self :: INOUT
      eps :: REAL, IN
      where (abs(self)<eps)
        self = ZERO
      end
   end

   set_to(a)
   ! Set self to "a"
      a :: A_TYPE, IN
   ENSURE(.is_same_shape_as(a),"incompatible shape")
      self = a
   end

   set_to_transpose_of(a)
   ! Self becomes the transpose of "a"
     self :: OUT
     a :: A_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.is_transposed_shape_of(a),"incompatible shapes")
     i,j,dim :: INT
     dim = .dim1
     ! do it element by element, otherwise the intrinsic routine can run out
     ! of stack space
     do i=1,dim
       do j=1,dim
         self(i,j) = a(j,i)
       end
     end
   end

   to_transpose
   ! Self becomes its own transpose.
     self :: INOUT
   ENSURE(.is_square,"non-square matrix")
     i,j,dim :: INT
     tmp :: INTRINSIC
     dim = .dim1
     ! do it element by element, otherwise the intrinsic routine can run out
     ! of stack space
     do i=1,dim
       do j=1,i
         tmp       = self(i,j)
         self(i,j) = self(j,i)
         self(j,i) = tmp
       end
     end
   end

   plus(a)
   ! Add to self the matrix "a"
      a :: A_TYPE, IN
   ENSURE(.is_same_shape_as(a),"incompatible shape")
      self = self + a
   end

   minus(a)
   ! Subtract from self the matrix "a"
      a :: A_TYPE, IN
   ENSURE(.is_same_shape_as(a),"incompatible shape")
      self = self - a
   end

   to_scaled(a,fac)
   ! Set "self" to matrix "at" scaled by "fac"
      a :: A_TYPE, IN
      fac :: FAC_TYPE, IN
   ENSURE(.is_same_shape_as(a),"different shapes")
      self = fac * a
   end

   plus_scaled(a,fac)
   ! Add to "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: A_TYPE, IN
      fac :: FAC_TYPE, IN
   ENSURE(.is_same_shape_as(a),"different shapes")
      self = self + fac * a
   end

   minus_scaled(a,fac)
   ! Subtract from "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: A_TYPE, IN
      fac :: FAC_TYPE, IN
   ENSURE(.is_same_shape_as(a),"different shapes")
      self = self - fac * a
   end

   to_product_of(a,b,transpose_a,transpose_b)
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
     self :: OUT
     a,b :: AB_TYPE, IN
     transpose_a, transpose_b :: BIN, optional, IN
     trans_a,trans_b :: BIN
     i,j,opt :: INT
     trans_a = FALSE;       trans_b = FALSE
     if (present(transpose_a)) trans_a = transpose_a
     if (present(transpose_b)) trans_b = transpose_b
     opt = 0
     if (trans_a) opt = opt + 1
     if (trans_b) opt = opt + 2
     select case (opt)
       case (0) ! .to_product_an_bn
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim2==b.dim1,"incompatible arrays")
         do j = 1,.dim2
         do i = 1,.dim1
            self(i,j) = sum(a(i,:)*b(:,j))
         end
         end
       case (1) ! .to_product_at_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do j = 1,.dim2
         do i = 1,.dim1
            self(i,j) = sum(a(:,i)*b(:,j))
         end
         end
       case (2) ! .to_product_an_bt
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do j = 1,.dim2
         do i = 1,.dim1
            self(i,j) = sum(a(i,:)*b(j,:))
         end
         end
       case (3) ! .to_product_at_bt
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do j = 1,.dim2
         do i = 1,.dim1
            self(i,j) = sum(a(:,i)*b(j,:))
         end
         end
     end
   end

   to_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b)
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   ! Likewise for the dagger operations.
     self :: OUT
     a,b :: MAT{CPX}, IN
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   ENSURE(NOT (present(dagger_a) AND present(transpose_a)),"can't transpose and dagger a")
   ENSURE(NOT (present(dagger_b) AND present(transpose_b)),"can't transpose and dagger b")
     dagg_a, dagg_b, trans_a, trans_b :: BIN
     i,j,opt :: INT
     trans_a = FALSE; trans_b = FALSE
     dagg_a  = FALSE; dagg_b  = FALSE
     if (present(dagger_a)) dagg_a = dagger_a
     if (present(dagger_b)) dagg_b = dagger_b
     if (present(transpose_a)) trans_a = transpose_a
     if (present(transpose_b)) trans_b = transpose_b
     opt = 0
     if (dagg_a)  opt = opt + 1
     if (trans_a) opt = opt + 2
     if (dagg_b)  opt = opt + 3
     if (trans_b) opt = opt + 6
     select case (opt)
       case (0) ! .to_product_an_bn
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim2==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = sum( a(i,:) * b(:,j) )
           end
         end
       case (1) ! .to_product_ad_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = sum( conjg(a(:,i)) * b(:,j) )
           end
         end
       case (2) ! .to_product_at_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = sum( a(:,i) * b(:,j) )
           end
         end
       case (3) ! .to_product_an_bd
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = sum( a(i,:) * conjg(b(j,:)) )
           end
         end
       case (4) ! .to_product_ad_bd
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = conjg( sum(a(:,i) * b(j,:)) )
           end
         end
       case (5) ! .to_product_at_bd
         ENSURE( .dim1==a.dim2,"incompatible shapes")
         ENSURE( .dim2==b.dim1,"incompatible shapes")
         ENSURE(a.dim1==b.dim2,"incompatible shapes")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = sum( a(:,i) * conjg(b(j,:)) )
           end
         end
       case (6) ! .to_product_an_bt
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = sum( a(i,:) * b(j,:) )
           end
         end
       case (7) ! .to_product_ad_bt
         ENSURE( .dim1==a.dim2,"incompatible shapes")
         ENSURE( .dim2==b.dim1,"incompatible shapes")
         ENSURE(a.dim1==b.dim2,"incompatible shapes")
         do i = 1,.dim1
         do j = 1,.dim2
            self(i,j) = sum( conjg(a(:,i)) * b(j,:) )
         end
         end
       case (8) ! .to_product_at_bt
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = sum( a(:,i) * b(j,:) )
           end
         end
       case default;
         DIE("Unknown case option: "//opt.to_str.trim)
     end
   end

   to_product_of(a,b,dagger_a,transpose_b)
   ! Set "self" to the product of complex matrix "a" and real matrix "b".  If
   ! present, "dagger_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{CPX}, IN
      b :: MAT{REAL}, IN
      dagger_a, transpose_b :: BIN, optional
      dagg_a,trans_b :: BIN
      opt,i,j :: INT
      dagg_a = FALSE;           trans_b = FALSE
      if (present(dagger_a))    dagg_a  = dagger_a
      if (present(transpose_b)) trans_b = transpose_b
      opt = 0
      if (dagg_a)  opt = opt + 1
      if (trans_b) opt = opt + 2
      select case (opt)
        case(0) ! .to_product_an_bn
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim2==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = sum( a(i,:) * b(:,j) )
          end
          end
        case(1) ! .to_product_ad_bn
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim1==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = sum( conjg(a(:,i)) * b(:,j) )
          end
          end
        case(2) ! .to_product_an_bt
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim2==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = sum( a(i,:) * b(j,:) )
          end
          end
        case(3) ! .to_product_ad_bt
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim1==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = sum( conjg(a(:,i)) * b(j,:) )
          end
          end
      end
   end

   to_product_of(a,b,transpose_a,dagger_b)
   ! Set "self" to the product of real matrix "a" and complex matrix "b".  If
   ! present, "transpose_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{REAL}, IN
      b :: MAT{CPX}, IN
      transpose_a, dagger_b :: BIN, optional
      trans_a,dagg_b :: BIN
      opt,i,j,k :: INT
      trans_a = FALSE;          dagg_b  = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      if (present(dagger_b))    dagg_b  = dagger_b
      opt = 0
      if (trans_a) opt = opt + 1
      if (dagg_b)  opt = opt + 2
      select case (opt)
        case(0) ! .to_product_an_bn
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim2==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = sum( a(i,:) * b(:,j) )
          end
          end
        case(1) ! .to_product_at_bn
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim1==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = sum( a(:,i) * b(:,j) )
          end
          end
        case(2) ! .to_product_an_bd
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim2==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = sum( a(i,:) * conjg(b(j,:)) )
          end
          end
        case(3) ! .to_product_at_bd
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim1==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = sum( a(:,i) * conjg(b(j,:)) )
          end
          end
      end
   end

   plus_product_of(a,b,transpose_a,transpose_b)
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
     self :: INOUT
     a,b :: AB_TYPE, IN
     transpose_a, transpose_b :: BIN, optional, IN
     trans_a,trans_b :: BIN
     i,j,opt :: INT
     trans_a = FALSE;       trans_b = FALSE
     if (present(transpose_a)) trans_a = transpose_a
     if (present(transpose_b)) trans_b = transpose_b
     opt = 0
     if (trans_a) opt = opt + 1
     if (trans_b) opt = opt + 2
     select case (opt)
       case (0) ! .to_product_an_bn
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim2==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum(a(i,:)*b(:,j))
           end
         end
       case (1) ! .to_product_at_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum(a(:,i)*b(:,j))
           end
         end
       case (2) ! .to_product_an_bt
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum(a(i,:)*b(j,:))
           end
         end
       case (3) ! .to_product_at_bt
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum(a(:,i)*b(j,:))
           end
         end
     end
   end

   plus_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b)
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   ! Likewise for the dagger operations.
     self :: INOUT
     a,b :: MAT{CPX}, IN
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   ENSURE(NOT (present(dagger_a) AND present(transpose_a)),"can't transpose and dagger a")
   ENSURE(NOT (present(dagger_b) AND present(transpose_b)),"can't transpose and dagger b")
     dagg_a, dagg_b, trans_a, trans_b :: BIN
     i,j,opt :: INT
     trans_a = FALSE; trans_b = FALSE
     dagg_a  = FALSE; dagg_b  = FALSE
     if (present(dagger_a)) dagg_a = dagger_a
     if (present(dagger_b)) dagg_b = dagger_b
     if (present(transpose_a)) trans_a = transpose_a
     if (present(transpose_b)) trans_b = transpose_b
     opt = 0
     if (dagg_a)  opt = opt + 1
     if (trans_a) opt = opt + 2
     if (dagg_b)  opt = opt + 3
     if (trans_b) opt = opt + 6
     select case (opt)
       case (0) ! .to_product_an_bn
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim2==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum( a(i,:) * b(:,j) )
           end
         end
       case (1) ! .to_product_ad_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum( conjg(a(:,i)) * b(:,j) )
           end
         end
       case (2) ! .to_product_at_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum( a(:,i) * b(:,j) )
           end
         end
       case (3) ! .to_product_an_bd
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum( a(i,:) * conjg(b(j,:)) )
           end
         end
       case (4) ! .to_product_ad_bd
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + conjg( sum(a(:,i) * b(j,:)) )
           end
         end
       case (5) ! .to_product_at_bd
         ENSURE( .dim1==a.dim2,"incompatible shapes")
         ENSURE( .dim2==b.dim1,"incompatible shapes")
         ENSURE(a.dim1==b.dim2,"incompatible shapes")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum( a(:,i) * conjg(b(j,:)) )
           end
         end
       case (6) ! .to_product_an_bt
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum( a(i,:) * b(j,:) )
           end
         end
       case (7) ! .to_product_ad_bt
         ENSURE( .dim1==a.dim2,"incompatible shapes")
         ENSURE( .dim2==b.dim1,"incompatible shapes")
         ENSURE(a.dim1==b.dim2,"incompatible shapes")
         do i = 1,.dim1
         do j = 1,.dim2
            self(i,j) = self(i,j) + sum( conjg(a(:,i)) * b(j,:) )
         end
         end
       case (8) ! .to_product_at_bt
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + sum( a(:,i) * b(j,:) )
           end
         end
       case default;
         DIE("Unknown case option: "//opt.to_str.trim)
     end
   end

   plus_product_of(a,b,dagger_a,transpose_b)
   ! Add to "self" the product of complex matrix "a" and real matrix "b".  If
   ! present, "dagger_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      dagger_a, transpose_b :: BIN, optional
      dagg_a,trans_b :: BIN
      opt,i,j :: INT
      dagg_a = FALSE;           trans_b = FALSE
      if (present(dagger_a))    dagg_a  = dagger_a
      if (present(transpose_b)) trans_b = transpose_b
      opt = 0
      if (dagg_a)  opt = opt + 1
      if (trans_b) opt = opt + 2
      select case (opt)
        case(0) ! .to_product_an_bn
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim2==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + sum( a(i,:) * b(:,j) )
          end
          end
        case(1) ! .to_product_ad_bn
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim1==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + sum( conjg(a(:,i)) * b(:,j) )
          end
          end
        case(2) ! .to_product_an_bt
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim2==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + sum( a(i,:) * b(j,:) )
          end
          end
        case(3) ! .to_product_ad_bt
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim1==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + sum( conjg(a(:,i)) * b(j,:) )
          end
          end
      end
   end

   plus_product_of(a,b,transpose_a,dagger_b)
   ! Add to "self" the product of real matrix "a" and complex matrix "b".  If
   ! present, "transpose_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      transpose_a, dagger_b :: BIN, optional
      trans_a,dagg_b :: BIN
      opt,i,j :: INT
      trans_a = FALSE;          dagg_b  = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      if (present(dagger_b))    dagg_b  = dagger_b
      opt = 0
      if (trans_a) opt = opt + 1
      if (dagg_b)  opt = opt + 2
      select case (opt)
        case(0) ! .to_product_an_bn
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim2==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + sum( a(i,:) * b(:,j) )
          end
          end
        case(1) ! .to_product_at_bn
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim1==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + sum( a(:,i) * b(:,j) )
          end
          end
        case(2) ! .to_product_an_bd
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim2==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + sum( a(i,:) * conjg(b(j,:)) )
          end
          end
        case(3) ! .to_product_at_bd
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim1==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + sum( a(:,i) * conjg(b(j,:)) )
          end
          end
      end
   end

   to_scaled_product_of(a,b,fac,transpose_a,transpose_b)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
     self :: OUT
     a,b :: AB_TYPE, IN
     fac :: FAC_TYPE
     transpose_a, transpose_b :: BIN, optional, IN
     trans_a,trans_b :: BIN
     i,j,opt :: INT
     trans_a = FALSE;       trans_b = FALSE
     if (present(transpose_a)) trans_a = transpose_a
     if (present(transpose_b)) trans_b = transpose_b
     opt = 0
     if (trans_a) opt = opt + 1
     if (trans_b) opt = opt + 2
     select case (opt)
       case (0) ! .to_product_an_bn
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim2==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac*sum(a(i,:)*b(:,j))
           end
         end
       case (1) ! .to_product_at_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac*sum(a(:,i)*b(:,j))
           end
         end
       case (2) ! .to_product_an_bt
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac*sum(a(i,:)*b(j,:))
           end
         end
       case (3) ! .to_product_at_bt
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac*sum(a(:,i)*b(j,:))
           end
         end
     end
   end

   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
     self :: OUT
     a,b :: MAT{CPX}, IN
     fac :: FAC_TYPE
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   ENSURE(NOT (present(dagger_a) AND present(transpose_a)),"can't transpose and dagger a")
   ENSURE(NOT (present(dagger_b) AND present(transpose_b)),"can't transpose and dagger b")
     dagg_a, dagg_b, trans_a, trans_b :: BIN
     i,j,opt :: INT
     trans_a = FALSE; trans_b = FALSE
     dagg_a  = FALSE; dagg_b  = FALSE
     if (present(dagger_a)) dagg_a = dagger_a
     if (present(dagger_b)) dagg_b = dagger_b
     if (present(transpose_a)) trans_a = transpose_a
     if (present(transpose_b)) trans_b = transpose_b
     opt = 0
     if (dagg_a)  opt = opt + 1
     if (trans_a) opt = opt + 2
     if (dagg_b)  opt = opt + 3
     if (trans_b) opt = opt + 6
     select case (opt)
       case (0) ! .to_product_an_bn
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim2==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * sum( a(i,:) * b(:,j) )
           end
         end
       case (1) ! .to_product_ad_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * sum( conjg(a(:,i)) * b(:,j) )
           end
         end
       case (2) ! .to_product_at_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * sum( a(:,i) * b(:,j) )
           end
         end
       case (3) ! .to_product_an_bd
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * sum( a(i,:) * conjg(b(j,:)) )
           end
         end
       case (4) ! .to_product_ad_bd
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * conjg( sum(a(:,i) * b(j,:)) )
           end
         end
       case (5) ! .to_product_at_bd
         ENSURE( .dim1==a.dim2,"incompatible shapes")
         ENSURE( .dim2==b.dim1,"incompatible shapes")
         ENSURE(a.dim1==b.dim2,"incompatible shapes")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * sum( a(:,i) * conjg(b(j,:)) )
           end
         end
       case (6) ! .to_product_an_bt
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * sum( a(i,:) * b(j,:) )
           end
         end
       case (7) ! .to_product_ad_bt
         ENSURE( .dim1==a.dim2,"incompatible shapes")
         ENSURE( .dim2==b.dim1,"incompatible shapes")
         ENSURE(a.dim1==b.dim2,"incompatible shapes")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * sum( conjg(a(:,i)) * b(j,:) )
           end
         end
       case (8) ! .to_product_at_bt
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = fac * sum( a(:,i) * b(j,:) )
           end
         end
       case default;
         DIE("Unknown case option: "//opt.to_str.trim)
     end
   end

   to_scaled_product_of(a,b,fac,dagger_a,transpose_b)
   ! Set "self" to the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      fac :: FAC_TYPE
      dagger_a, transpose_b :: BIN, optional
      dagg_a,trans_b :: BIN
      opt,i,j :: INT
      dagg_a = FALSE;           trans_b = FALSE
      if (present(dagger_a))    dagg_a  = dagger_a
      if (present(transpose_b)) trans_b = transpose_b
      opt = 0
      if (dagg_a)  opt = opt + 1
      if (trans_b) opt = opt + 2
      select case (opt)
        case(0) ! .to_product_an_bn
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim2==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = fac * sum( a(i,:) * b(:,j) )
          end
          end
        case(1) ! .to_product_ad_bn
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim1==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = fac * sum( conjg(a(:,i)) * b(:,j) )
          end
          end
        case(2) ! .to_product_an_bt
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim2==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = fac * sum( a(i,:) * b(j,:) )
          end
          end
        case(3) ! .to_product_ad_bt
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim1==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = fac * sum( conjg(a(:,i)) * b(j,:) )
          end
          end
      end
   end

   to_scaled_product_of(a,b,fac,transpose_a,dagger_b)
   ! Set "self" to the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      fac :: FAC_TYPE
      transpose_a, dagger_b :: BIN, optional
      trans_a,dagg_b :: BIN
      opt,i,j :: INT
      trans_a = FALSE;          dagg_b  = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      if (present(dagger_b))    dagg_b  = dagger_b
      opt = 0
      if (trans_a) opt = opt + 1
      if (dagg_b)  opt = opt + 2
      select case (opt)
        case(0) ! .to_product_an_bn
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim2==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = fac * sum( a(i,:) * b(:,j) )
          end
          end
        case(1) ! .to_product_at_bn
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim1==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = fac * sum( a(:,i) * b(:,j) )
          end
          end
        case(2) ! .to_product_an_bd
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim2==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = fac * sum( a(i,:) * conjg(b(j,:)) )
          end
          end
        case(3) ! .to_product_at_bd
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim1==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = fac * sum( a(:,i) * conjg(b(j,:)) )
          end
          end
      end
   end

   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! neeb to be transposed.
     self :: INOUT
     a,b :: AB_TYPE, IN
     fac :: FAC_TYPE
     transpose_a, transpose_b :: BIN, optional, IN
     trans_a,trans_b :: BIN
     opt,i,j :: INT
     trans_a = FALSE;       trans_b = FALSE
     if (present(transpose_a)) trans_a = transpose_a
     if (present(transpose_b)) trans_b = transpose_b
     opt = 0
     if (trans_a) opt = opt + 1
     if (trans_b) opt = opt + 2
     select case (opt)
       case (0) ! .to_product_an_bn
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim2==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac*sum(a(i,:)*b(:,j))
           end
         end
       case (1) ! .to_product_at_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac*sum(a(:,i)*b(:,j))
           end
         end
       case (2) ! .to_product_an_bt
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac*sum(a(i,:)*b(j,:))
           end
         end
       case (3) ! .to_product_at_bt
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac*sum(a(:,i)*b(j,:))
           end
         end
     end
   end

   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
     self :: INOUT
     a,b :: MAT{CPX}, IN
     fac :: FAC_TYPE
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   ENSURE(NOT (present(dagger_a) AND present(transpose_a)),"can't transpose and dagger a")
   ENSURE(NOT (present(dagger_b) AND present(transpose_b)),"can't transpose and dagger b")
     dagg_a, dagg_b, trans_a, trans_b :: BIN
     i,j,opt :: INT
     trans_a = FALSE; trans_b = FALSE
     dagg_a  = FALSE; dagg_b  = FALSE
     if (present(dagger_a)) dagg_a = dagger_a
     if (present(dagger_b)) dagg_b = dagger_b
     if (present(transpose_a)) trans_a = transpose_a
     if (present(transpose_b)) trans_b = transpose_b
     opt = 0
     if (dagg_a)  opt = opt + 1
     if (trans_a) opt = opt + 2
     if (dagg_b)  opt = opt + 3
     if (trans_b) opt = opt + 6
     select case (opt)
       case (0) ! .to_product_an_bn
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim2==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac * sum( a(i,:) * b(:,j) )
           end
         end
       case (1) ! .to_product_ad_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac * sum( conjg(a(:,i)) * b(:,j) )
           end
         end
       case (2) ! .to_product_at_bn
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim2,"incompatible arrays")
         ENSURE(a.dim1==b.dim1,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac * sum( a(:,i) * b(:,j) )
           end
         end
       case (3) ! .to_product_an_bd
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac * sum( a(i,:) * conjg(b(j,:)) )
           end
         end
       case (4) ! .to_product_ad_bd
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac * conjg( sum(a(:,i) * b(j,:)) )
           end
         end
       case (5) ! .to_product_at_bd
         ENSURE( .dim1==a.dim2,"incompatible shapes")
         ENSURE( .dim2==b.dim1,"incompatible shapes")
         ENSURE(a.dim1==b.dim2,"incompatible shapes")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac * sum( a(:,i) * conjg(b(j,:)) )
           end
         end
       case (6) ! .to_product_an_bt
         ENSURE( .dim1==a.dim1,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim2==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac * sum( a(i,:) * b(j,:) )
           end
         end
       case (7) ! .to_product_ad_bt
         ENSURE( .dim1==a.dim2,"incompatible shapes")
         ENSURE( .dim2==b.dim1,"incompatible shapes")
         ENSURE(a.dim1==b.dim2,"incompatible shapes")
         do i = 1,.dim1
         do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( conjg(a(:,i)) * b(j,:) )
         end
         end
       case (8) ! .to_product_at_bt
         ENSURE( .dim1==a.dim2,"incompatible arrays")
         ENSURE( .dim2==b.dim1,"incompatible arrays")
         ENSURE(a.dim1==b.dim2,"incompatible arrays")
         do i = 1,.dim1
           do j = 1,.dim2
             self(i,j) = self(i,j) + fac * sum( a(:,i) * b(j,:) )
           end
         end
       case default;
         DIE("Unknown case option: "//opt.to_str.trim)
     end
   end

   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b)
   ! Add to "self" the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      fac :: FAC_TYPE
      dagger_a, transpose_b :: BIN, optional
      dagg_a,trans_b :: BIN
      opt,i,j :: INT
      dagg_a = FALSE;           trans_b = FALSE
      if (present(dagger_a))    dagg_a  = dagger_a
      if (present(transpose_b)) trans_b = transpose_b
      opt = 0
      if (dagg_a)  opt = opt + 1
      if (trans_b) opt = opt + 2
      select case (opt)
        case(0) ! .to_product_an_bn
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim2==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( a(i,:) * b(:,j) )
          end
          end
        case(1) ! .to_product_ad_bn
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim1==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( conjg(a(:,i)) * b(:,j) )
          end
          end
        case(2) ! .to_product_an_bt
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim2==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( a(i,:) * b(j,:) )
          end
          end
        case(3) ! .to_product_ad_bt
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim1==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( conjg(a(:,i)) * b(j,:) )
          end
          end
      end
   end

   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b)
   ! Add to "self" the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      fac :: FAC_TYPE
      transpose_a, dagger_b :: BIN, optional
      trans_a,dagg_b :: BIN
      opt,i,j :: INT
      trans_a = FALSE;          dagg_b  = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      if (present(dagger_b))    dagg_b  = dagger_b
      opt = 0
      if (trans_a) opt = opt + 1
      if (dagg_b)  opt = opt + 2
      select case (opt)
        case(0) ! .to_product_an_bn
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim2==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( a(i,:) * b(:,j) )
          end
          end
        case(1) ! .to_product_at_bn
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim2,"incompatible shapes")
          ENSURE(a.dim1==b.dim1,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( a(:,i) * b(:,j) )
          end
          end
        case(2) ! .to_product_an_bd
          ENSURE( .dim1==a.dim1,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim2==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( a(i,:) * conjg(b(j,:)) )
          end
          end
        case(3) ! .to_product_at_bd
          ENSURE( .dim1==a.dim2,"incompatible shapes")
          ENSURE( .dim2==b.dim1,"incompatible shapes")
          ENSURE(a.dim1==b.dim2,"incompatible shapes")
          do i = 1,.dim1
          do j = 1,.dim2
            self(i,j) = self(i,j) + fac * sum( a(:,i) * conjg(b(j,:)) )
          end
          end
      end
   end

   plus_outer_product_of(a,fac)
   ! Add to "self" the outer product of "a" with itself, with an
   ! optional scale factor "fac".
      self :: INOUT
      a :: VEC{A_TYPE}
      fac :: FAC_TYPE, optional

   ENSURE(.is_square,"self is not square")
   ENSURE(a.dim==.dim1,"incomptabile a")

      i,j :: INT

      if (NOT present(fac)) then
          do i = 1,.dim1
          do j = 1,.dim1
            self(i,j) = self(i,j) + a(i)*a(j)
          end
          end
      else
          do i = 1,.dim1
          do j = 1,.dim1
            self(i,j) = self(i,j) + fac*a(i)*a(j)
          end
          end
      end

   end

   to_product_with_diagonal(a,diag,transpose_a)
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, ""transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      self :: INOUT
      a :: A_TYPE, IN
      diag :: DIAG_TYPE, IN
      transpose_a :: BIN, optional, IN
   ENSURE(.is_same_shape_as(a),"incompatible dimensions")
      trans_a :: BIN
      opt,j :: INT
      trans_a = FALSE; 
      if (present(transpose_a)) trans_a = transpose_a
      opt = 0
      if (trans_a) opt = 1
      select case (opt)
         case (0)
            ENSURE(a.dim2==diag.dim,"incompatible dimensions")
            do j = 1,.dim2
               self(:,j) = a(:,j)*diag(j)
             end
         case (1)
            ENSURE(a.dim1==diag.dim,"incompatible dimensions")
            do j = 1,.dim2
               self(:,j) = a(j,:)*diag(j)
            end
      end
   end

   to_product_with_diagonal(a,diag,dagger_a,transpose_a)
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, "dagger_a" or "transpose_a" can be set to TRUE
   ! if "a" needs to be daggered or transposed.
      self :: OUT
      a :: MAT{CPX}, IN
      diag :: DIAG_TYPE, IN
      dagger_a, transpose_a :: BIN, optional, IN
   ENSURE(.is_same_shape_as(a),"incompatible dimensions")
      dagg_a, trans_a :: BIN
      opt,j :: INT
      dagg_a  = FALSE
      trans_a = FALSE 
      if (present(dagger_a)) dagg_a = dagger_a
      if (present(transpose_a)) trans_a = transpose_a
      opt = 0
      if (dagg_a)  opt = 1
      if (trans_a) opt = 2
      select case (opt)
         case (0) ! an
            ENSURE(a.dim2==diag.dim,"incompatible dimensions")
            do j = 1,.dim2
               self(:,j) = a(:,j)*diag(j)
            end
         case (1) ! ad
            ENSURE(a.dim1==diag.dim,"incompatible dimensions")
            do j = 1,.dim2
              self(:,j) = conjg(a(j,:))*diag(j)
            end
         case (2) ! at
            ENSURE(a.dim1==diag.dim,"incompatible dimensions")
            do j = 1,.dim2
               self(:,j) = a(j,:)*diag(j)
            end
      end
   end

   to_product_with_diagonal(dg,a,transpose_a)
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      self :: OUT
      dg :: DG_TYPE, IN
      a :: A_TYPE, IN
      transpose_a :: BIN, optional, IN
   ENSURE(.is_same_shape_as(a),"incompatible dimensions")
      trans_a :: BIN
      opt,i :: INT
      trans_a = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      opt = 0
      if (trans_a) opt = 1
      select case (opt)
         case (0) ! an
            ENSURE(a.dim1==dg.dim,"incompatible dimensions")
            do i = 1,.dim1
               self(i,:) = dg(i)*a(i,:)
            end
         case (1) ! at
            ENSURE(a.dim2==dg.dim,"incompatible dimensions")
            do i = 1,.dim1
               self(i,:) = dg(i)*a(:,i)
            end
      end
   end

   to_product_with_diagonal(dg,a,dagger_a,transpose_a)
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "dagger_a" or "transpose_a" can be set to
   ! TRUE if "a" needs to be daggered or transposed.
      self :: OUT
      dg :: DG_TYPE, IN
      a :: MAT{CPX}, IN
      dagger_a, transpose_a :: BIN, optional, IN
   ENSURE(.is_same_shape_as(a),"incompatible dimensions")
      dagg_a, trans_a :: BIN
      opt,i :: INT
      dagg_a  = FALSE
      trans_a = FALSE
      if (present(dagger_a)) dagg_a = dagger_a
      if (present(transpose_a)) trans_a = transpose_a
      opt = 0
      if (dagg_a)  opt = 1
      if (trans_a) opt = 2
      select case (opt)
         case (0) ! an
            ENSURE(a.dim1==dg.dim,"incompatible dimensions")
            do i = 1,.dim1
               self(i,:) = dg(i)*a(i,:)
            end
         case (1) ! ad
            ENSURE(a.dim2==dg.dim,"incompatible dimensions")
            do i = 1,.dim1
               self(i,:) = dg(i)*conjg(a(:,i))
            end
         case (2) ! at
            ENSURE(a.dim2==dg.dim,"incompatible dimensions")
            do i = 1,.dim1
               self(i,:) = dg(i)*a(:,i)
            end
      end
   end

! ****************
! Trace operations
! ****************

   trace result (res)
   ! Return the trace of self
      self :: IN
      res :: INTRINSIC
   ENSURE(.dim1==.dim2,"non-square matrix")
      dim,i :: INT
      dim = .dim1
      res = ZERO
      do i = 1,dim
         res = res + self(i,i)
      end
   end

   trace_product_with(a) result (res)
   ! Return the trace of the product of "self" with matrix "a".
      self :: IN
      a :: A_TYPE, IN
      res :: INTRINSIC
   ENSURE(.is_transposed_shape_of(a),"incompatible dimensions")
      i :: INT
      res = ZERO
      do i = 1,.dim1
         res = res + sum( self(i,:)*a(:,i) )
      end
   end

   trace_product_with(a,transpose_a) result (res)
   ! Return the trace of the product of "self" with matrix "a",
   ! and if "transpose_a" is present and TRUE, then transpose "a".
      self :: IN
      a :: A_TYPE, IN
      transpose_a :: BIN, IN
      res :: INTRINSIC
      i :: INT
      if (transpose_a) then
         res = ZERO
         do i = 1,.dim1
            res = res + sum( self(i,:)*a(i,:) )
         end
      else 
         res = ZERO
         do i = 1,.dim1
            res = res + sum( self(i,:)*a(:,i) )
         end
      end
   end

   trace_product_with(a,b,c) result (res)
   ! Return the trace of the product of "self" with matrices "a", "b" and "c".
      a,b,c :: MAT{INTRINSIC}
      res :: INTRINSIC
      W1,W2 :: MAT{INTRINSIC}*
      W2.create(a.dim1,c.dim2)
      W1.create(b.dim1,c.dim2)
      W1.to_product_of(b,c)
      W2.to_product_of(a,W1)
      W1.destroy
      W1.create( .dim1,c.dim2)
      W1.to_product_of(self,W2)
      res = W1.trace
      W1.destroy
      W2.destroy
   end

   trace_product_with(a,b,c,d,e) result (res)
   ! Return the trace of the product of "self" with matrices "a", "b" ... "e".
      a,b,c,d,e :: MAT{INTRINSIC}
      res :: INTRINSIC
      W1,W2 :: MAT{INTRINSIC}*
      W1.create(d.dim1,e.dim2)
      W1.to_product_of(d,e)     ! d*e
      W2.create(c.dim1,e.dim2)
      W2.to_product_of(c,W1)    ! c*d*e
      W1.destroy; W1 => W2
      W2.create(b.dim1,e.dim2)
      W2.to_product_of(b,W1)    ! b*c*d*e
      W1.destroy; W1 => W2
      W2.create(a.dim1,e.dim2)
      W2.to_product_of(a,W1)    ! a*b*c*d*e
      W1.destroy; W1 => W2
      W2.create( .dim1,e.dim2)
      W2.to_product_of(self,W1) ! self*a*b*c*d*e
      res = W2.trace
      W2.destroy
      W1.destroy
   end

! ************************
! Change of basis routines
! ************************

   change_basis_using(V)
   ! Change the basis of "self" using vectors "V"; self = V^dagger self V
      V :: V_TYPE, IN
   ENSURE( .is_square,"Non-square matrix")
   ENSURE(V.is_square,"Non-square matrix")
   ENSURE(.dim2==V.dim1,"wrong shapes")
      W :: MAT{INTRINSIC}*
      W.create(.dim1,V.dim2)
      W.to_product_of(self,V)
      .to_product_of(V,W,TRANSPOSE_A=TRUE)
      W.destroy
   end

   change_basis_using(V)
   ! Change the basis of "self" using diagonal matrix "V" (stored as a vector).
   ! self = V self V
      V :: V_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1==V.dim,"incompatible sizes")
      W :: MAT{INTRINSIC}*
      W.create(V.dim,V.dim)
      W.to_product_with_diagonal(self,V)
      .to_product_with_diagonal(V,W)
      W.destroy
   end

   change_basis_using(L,R)
   ! Change the basis of "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L^dagger self R
      L,R :: LR_TYPE, IN
   ENSURE(.dim2==R.dim1,"incompatible sizes")
   ENSURE(.dim1==L.dim1,"incompatible sizes")
   ENSURE(.dim2==R.dim2,"incompatible sizes")
   ENSURE(.dim1==L.dim2,"incompatible sizes")
      W :: MAT{INTRINSIC}*
      W.create(.dim1,R.dim2)
      W.to_product_of(self,R)
      .to_product_of(L,W,TRANSPOSE_A=TRUE)
      W.destroy
   end

   change_basis_using(L,R)
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
      L,R :: LR_TYPE, IN
   ENSURE(.dim1==L.dim AND .dim2==R.dim,"incompatible sizes")
      W :: MAT{INTRINSIC}*
      W.create(L.dim,R.dim)
      W.to_product_with_diagonal(self,R)
      .to_product_with_diagonal(L,W)
      W.destroy
   end

   change_basis_to(new,V)
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new".  new = V^dagger self V
      new :: MAT{INTRINSIC}
      V :: V_TYPE, IN
   ENSURE(   .is_square,"Non-square matrix")
   ENSURE(new.is_square,"Non-square matrix")
   ENSURE(V.dim1==   .dim2,"wrong shapes")
   ENSURE(V.dim2==new.dim2,"wrong shapes")
      W :: MAT{INTRINSIC}*
      W.create(.dim1,V.dim2)
      W.to_product_of(self,V)
      new.to_product_of(V,W,TRANSPOSE_A=TRUE)
      W.destroy
   end

   change_basis_to(new,V)
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new" i.e. new = V^dagger self V. This version uses only intrinsic
   ! procedures to avoid circular dependencies.
      new :: NEW_TYPE
      V :: V_TYPE, IN
   ENSURE(   .is_square,"Non-square matrix")
   ENSURE(new.dim1==new.dim2,"Non-square matrix")
   ENSURE(V.dim1==   .dim2,"wrong shapes")
   ENSURE(V.dim2==new.dim2,"wrong shapes")
      W :: NEW_TYPE*
      status :: INT
      allocate(W(.dim1,V.dim2),STAT=status)
      DIE_IF(status/=0,"error in allocating memory")
      W = matmul(self,V)
      new = matmul(CONJG(transpose(V)),W)
      deallocate(W)
   end

   change_basis_to(new,L,R)
   ! Change the basis of "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L^dagger self R
      new :: MAT{INTRINSIC}
      L,R :: LR_TYPE, IN
   ENSURE(.dim2==R.dim1,"incompatible sizes")
   ENSURE(.dim1==L.dim1,"incompatible sizes")
   ENSURE(new.dim2==R.dim2,"incompatible sizes")
   ENSURE(new.dim1==L.dim2,"incompatible sizes")
      W :: MAT{INTRINSIC}*
      W.create(.dim1,R.dim2)
      W.to_product_of(self,R)
      new.to_product_of(L,W,TRANSPOSE_A=TRUE)
      W.destroy
   end

   back_transform_using(V)
   ! Back transform "self" using vectors "V", and place the result in "self".
   ! self = V self V^dagger
      V :: V_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.is_same_shape_as(V),"incompatible shape")
      W :: MAT{INTRINSIC}*
      W.create(V.dim1,.dim2)
      W.to_product_of(V,self)
      .to_product_of(W,V,TRANSPOSE_B=TRUE)
      W.destroy
   end

   back_transform_to(new,V)
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! new = V self V^dagger
      new :: MAT{INTRINSIC}
      V :: V_TYPE, IN
   ENSURE(   .is_square,"non-square matrix")
   ENSURE(new.is_square,"non-square matrix")
   ENSURE(V.dim2==.dim1,"incompatible sizes")
   ENSURE(V.dim1==new.dim1,"incompatible sizes")
      W :: MAT{INTRINSIC}*
      W.create(V.dim1,.dim2)
      W.to_product_of(V,self)
      new.to_product_of(W,V,TRANSPOSE_B=TRUE)
      W.destroy
   end

   back_transform_to(new,V)
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! i.e. new = V self V^dagger. This version uses only intrinsic calls to avpid
   ! circular dependencies.
      new :: NEW_TYPE
      V :: V_TYPE, IN
   ENSURE(   .is_square,"non-square matrix")
   ENSURE(new.dim1==new.dim2,"Non-square matrix")
   ENSURE(V.dim2==.dim1,"incompatible sizes")
   ENSURE(V.dim1==new.dim1,"incompatible sizes")
      W :: NEW_TYPE*
      status :: INT
      allocate(W(V.dim1,.dim2),STAT=status)
      DIE_IF(status/=0,"error in allocating memory")
      W = matmul(V,self)
      new = matmul(W,CONJG(transpose(V)))
      deallocate(W)
   end

   back_transform_to(new,L,R)
   ! Back transform "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L self R^dagger
      new :: MAT{INTRINSIC}
      L,R :: LR_TYPE, IN
   ENSURE(.dim2==R.dim2,"incompatible sizes")
   ENSURE(.dim1==L.dim2,"incompatible sizes")
   ENSURE(new.dim2==R.dim1,"incompatible sizes")
   ENSURE(new.dim1==L.dim1,"incompatible sizes")
      W :: MAT{INTRINSIC}*
      W.create(.dim1,R.dim1)
      W.to_product_of(self,R,TRANSPOSE_B=TRUE)
      new.to_product_of(L,W)
      W.destroy
   end

   similarity_transform(V)
   ! Do a similarity transform of "self" using vectors "V": self = V self V^-1
      V :: V_TYPE, IN
   ENSURE( .is_square,"Non-square matrix")
   ENSURE(V.is_square,"Non-square matrix")
   ENSURE(.dim1==V.dim1,"wrong shapes")
      V1,W :: MAT{INTRINSIC}*
      n :: INT
      n = .dim1
      V1.create(n,n)
      V1.to_inverse_of(V)
      W.create(n,n)
      W.to_product_of(self,V1)
      .to_product_of(V,W)
      W.destroy
      V1.destroy
   end

! **************************
! Operations on the diagonal
! **************************

   set_from_diagonal(d)
   ! Converts the diagonal vector "d" to matrix "self".
      d :: D_TYPE
   ENSURE(.is_square,"non-square matrix")
   ENSURE(d.dim==.dim1,"incompatibale diagonal length")
      i :: INT
      self = ZERO
      do i = 1,d.dim
         self(i,i) = d(i)
      end
   end

   set_diagonal_to(d)
   ! Set the diagonal of "self" to th diagonal vector "d"
      d :: D_TYPE
   ENSURE(.is_square,"non-square matrix")
   ENSURE(d.dim==.dim1,"incompatibale diagonal length")
      i :: INT
      do i = 1,d.dim
         self(i,i) = d(i)
      end
   end

   set_diagonal_to(val)
   ! Set the diagonal of "self" to "val"
      val :: VAL_TYPE
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = val
      end
   end

   put_diagonal_to(d)
   ! Get the diagonal elements of "self" in vector "d"
      d :: VEC{INTRINSIC}
   ENSURE(d.dim==min(.dim1,.dim2),"diag vector is incompatible")
      i :: INT
      do i = 1,d.dim
         d(i) = self(i,i)
      end
   end

   increment_diagonal_by(val)
   ! Add "val" to the diagonal of "self"
      val :: VAL_TYPE
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = self(i,i) + val
      end
   end

   increment_diagonal_by(d)
   ! Add "d" to the diagonal of "self"
      d :: VEC{INTRINSIC}
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = self(i,i) + d(i)
      end
   end

   scale_diagonal_by(fac)
   ! Weight the diagonal elements of "self" by "fac"
      fac :: FAC_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = fac*self(i,i)
      end
   end

   zero_diagonal
   ! Zero the diagonal elements of "self"
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = ZERO
      end
   end

   zero_off_diagonal
   ! Zero the off diagonal elements of "self"
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
      do j = 1,.dim1
         if (i==j) cycle
         self(i,j) = ZERO
      end
      end
   end

   max_diagonal_element result (res)
   ! Get the maximum element on the diagonal of the matrix
      res :: INTRINSIC
   ENSURE(min(.dim1,.dim2)>0,"cannot have zero sized dimensions")
      dim,i :: INT
      dim = min(.dim1,.dim2)
      res = self(1,1)
      do i = 2,dim
         res = max(self(i,i),res)
      end
   end

   max_abs_diagonal_element result (res)
   ! Get the maximum absolute value of the diagonal elements of the self matrix
      res :: REAL
   ENSURE(min(.dim1,.dim2)>0,"cannot have zero sized dimensions")
      dim,i :: INT
      dim = min(.dim1,.dim2)
      res = abs(self(1,1))
      do i = 2,dim
         res = max( real(abs(self(i,i)),kind=REAL_KIND) , res)
      end
   end

   diagonal_set_to(d)
   ! Set the diagonal of "self" to th diagonal vector "d"
      d :: D_TYPE
   ENSURE(.is_square,"non-square matrix")
   ENSURE(d.dim==.dim1,"incompatibale diagonal length")
      i :: INT
      do i = 1,d.dim
         self(i,i) = d(i)
      end
   end

   diagonal_set_to(val)
   ! Set the diagonal of "self" to "val"
      val :: VAL_TYPE
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = val
      end
   end

   diagonal_set_to(d)
   ! Get the diagonal elements of "self" in vector "d"
      d :: VEC{INTRINSIC}
   ENSURE(d.dim==min(.dim1,.dim2),"diag vector is incompatible")
      i :: INT
      do i = 1,d.dim
         d(i) = self(i,i)
      end
   end

   diagonal_plus(val)
   ! Add "val" to the diagonal of "self"
      val :: VAL_TYPE
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = self(i,i) + val
      end
   end

   diagonal_plus(d)
   ! Add "d" to the diagonal of "self"
      d :: VEC{INTRINSIC}
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = self(i,i) + d(i)
      end
   end

   diagonal_times(fac)
   ! Weight the diagonal elements of "self" by "fac"
      fac :: FAC_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
      i :: INT
      do i = 1,.dim1
         self(i,i) = fac*self(i,i)
      end
   end

   diagonal_max result (res)
   ! Get the maximum element on the diagonal of the matrix
      res :: INTRINSIC
   ENSURE(min(.dim1,.dim2)>0,"cannot have zero sized dimensions")
      dim,i :: INT
      dim = min(.dim1,.dim2)
      res = self(1,1)
      do i = 2,dim
         res = max(self(i,i),res)
      end
   end

   diagonal_max_abs result (res)
   ! Get the maximum absolute value of the diagonal elements of the self matrix
      res :: REAL
   ENSURE(min(.dim1,.dim2)>0,"cannot have zero sized dimensions")
      dim,i :: INT
      dim = min(.dim1,.dim2)
      res = abs(self(1,1))
      do i = 2,dim
         res = max( real(abs(self(i,i)),kind=REAL_KIND) , res)
      end
   end

! ************************
! Symmetrising and folding
! ************************

   symmetrize
   ! Set self to half of itself plus half its transpose, i.e.
   ! self = 1/2 (self + self^T)
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      val :: INTRINSIC
      do i = 1,.dim1
         do j = 1,i-1
            val = HALF*(self(i,j)+self(j,i))
            self(i,j) = val
            self(j,i) = val
         end
      end
   end

   antisymmetrize
   ! Set self to half of itself minus half its transpose, i.e.
   ! self = 1/2 (self - self^T)
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      val :: INTRINSIC
      do i = 1,.dim1
         do j = 1,i
            val = HALF*(self(i,j)-self(j,i))
            self(i,j) =  val
            self(j,i) = -val
         end
      end
   end

   symmetric_fold
   ! Add the upper triangle of "self" into the lower triangle
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(i,j) = self(i,j) + self(j,i)
         end
      end
   end

   antisymmetric_fold
   ! Subtract the upper triangle of "self" into the lower triangle
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j= 1,i-1
            self(i,j) = self(i,j) - self(j,i)
         end
      end
   end

   symmetric_reflect
   ! Make the upper triangle of "self" the same as the lower triangle
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = self(i,j)
         end
      end
   end

   antisymmetric_reflect
   ! Make the upper triangle of "self" the negative of the lower triangle and
   ! make the diagonal zero.
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = -self(i,j)
         end
      end
      do i = 1,.dim1
         self(i,i) = ZERO
      end
   end

   symmetric_fold_to_triangle(tr)
   ! Add the upper triangle of "self" into the lower triangle and return
   ! the lower triangle "tr" as a vector across rows.
      tr :: VEC{INTRINSIC}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(tr.dim>=.tri_size,"triangle array too small")
      i,j,ij :: INT
      ij = 0
      do i = 1,.dim1
         do j = 1,i
            ij = ij+1
            if (i==j) then
               tr(ij) = self(i,j)
            else
               tr(ij) = self(i,j)+self(j,i)
            end
         end
      end
   end

! **************************************
! Compression and uncompression routines
! **************************************

   compress_to_triangle(tr)
   ! Converts the lower triangle of matrix self to the triangle "tr".
   ! using row order.
      tr :: VEC{INTRINSIC}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(tr.dim>=.tri_size,"triangle array too small")
      i,j,ij :: INT
      ij = 0
      do i = 1,.dim1
         do j = 1,i
            ij = ij + 1
            tr(ij) = self(i,j)
         end
      end
   end

   uncompress_from_triangle(tr)
   ! Converts the triangle "tr" into the symmetric matrix "self".
      tr :: VEC{INTRINSIC}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(tr.dim>=.tri_size,"triangle array too small")
      tmp :: INTRINSIC
      dim,i,j,ij :: INT
      dim = .dim1
      ij = 0
      do i = 1,dim
         do j = 1,i
            ij = ij + 1
            tmp = tr(ij)
            self(j,i) = tmp
            self(i,j) = tmp
         end
      end
   end

   uncompress_anti_triangle(tr)
   ! Converts the triangle "tr" into the antisymmetric matrix "self".
      tr :: VEC{INTRINSIC}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(tr.dim>=.tri_size,"triangle array too small")
      tmp :: INTRINSIC
      dim,i,j,ij :: INT
      dim = .dim1
      ij = 0
      do i = 1,dim
         do j = 1,i
            ij = ij + 1
            tmp = tr(ij)
            self(j,i) = -tmp
            self(i,j) =  tmp
         end
            self(i,i) =  ZERO
      end
   end

   tri_size result (ltr)
   ! Returns the size of the lower triangle needed to store self.
      ltr :: INT
   ENSURE(.is_square,"non-square matrix")
      dim :: INT
      dim = .dim1
      ltr = dim*(dim+1)/2
   end

! *****************
! Orthogonalisation
! *****************

   is_linearly_dependent(S,tol,col) result (res)
   ! Return TRUE if the columns are linearly dependent with respect to "S".
   ! If present, "tol" is the tolerance used to establish linear dependency.
   ! If present, "col" is the column number where the dependence was first
   ! noticed when Schmidt orthogonalising is used, starting from column 1.
     self :: target
     S :: MAT{REAL}, IN
     tol :: REAL, optional, IN
     col :: INT, optional, OUT
     res :: BIN
   ENSURE(S.is_square,"S must be square matrix")
   ENSURE(S.dim1==.dim1,"incompatible metric S")
   ENSURE(NOT S.is_zero,"S is zero matrix")
   ENSURE(NOT .is_zero,"self is zero matrix")
     cols :: MAT{INTRINSIC}*
     old,new :: VEC{INTRINSIC}*
     fac :: INTRINSIC
     n,o :: INT
     test,norm,norm0 :: REAL
     test = MAT_LINEAR_DEPENDENCE_TOL
     if (present(tol)) test = tol
     res = FALSE
     cols.create_copy(self)
     do n = 1,.dim2
        new => cols(:,n)
        norm0 = S.dot(new,new)
        ENSURE(norm0>=ZERO,"length of column "//trim(n.to_str)//"is negative")
        norm0 = sqrt(S.dot(new,new))
        do o = 1,n-1
           old => cols(:,o)
           fac = S.dot(old,new)
           new = new - fac*old
        end
        norm = S.dot(new,new)
        ENSURE(norm>=ZERO,"length of column "//trim(n.to_str)//"is negative")
        norm = sqrt(norm)
        if ((norm/norm0)<test) then
           res = TRUE
           if (present(col)) col = n
           return
        end
        norm = ONE/norm
        new = new*norm
     end
     cols.destroy
   end

   schmidt_orthonormalise(S,scale)
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric. If "scale" is present, it is set to the product of the
   ! normalisation factors used to normalise each column after the Schmidt
   ! procedure. 
     self :: target
     S :: MAT{REAL}, IN
     scale :: REAL, optional
   ENSURE(S.is_square,"S must be square matrix")
   ENSURE(S.dim1==.dim1,"incompatible metric S")
   ENSURE(NOT S.is_zero,"S is zero matrix")
   ENSURE(NOT .is_zero,"self is zero matrix")
     old,new :: VEC{INTRINSIC}*
     fac :: INTRINSIC
     n,o :: INT
     norm :: REAL
     ! T :: VEC{REAL}*
     ! dim,j,k :: INT
     ! proj :: REAL
     if (present(scale)) scale = ONE
     do n = 1,.dim2
        new => self(:,n)
        do o = 1,n-1
           old => self(:,o)
           fac = S.dot(old,new)
           new = new - fac*old
        end
        norm = S.dot(new,new)
        ENSURE(norm>MAT_LINEAR_DEPENDENCE_TOL,"linear dependence in vector "//n.to_str)
        norm = ONE/sqrt(norm)
        new = new*norm
        if (present(scale)) scale = scale*norm
     end
     ! This is old code which is not so clean, kept cos it may be more efficient
!    dim = .dim1
!    T.create(dim)
!    do n=1,dim
!      do j=1,dim
!        T(j) = dot_product(self(:j,n),S(:j,j))
!        T(1:j-1) = T(1:j-1) + self(j,n) * S(:j-1,j)
!      end
!      do k=1,n-1
!        proj = - dot_product(self(:,k),T)
!        self(:,n) = self(:,n) + proj * self(:,k)
!      end
!      do j=1,dim
!        T(j) = dot_product(self(:j,n), S(:j,j))
!        T(:j-1) = T(:j-1) + self(j,n) * S(:j-1,j)
!      end
!      norm = dot_product(T,self(:,n))
!      ENSURE(norm>TOL(10),"linear dependence in vector " // n.to_str)
!      self(:,n) = self(:,n) / sqrt(norm)
!    end
!    T.destroy
   end

   schmidt_orthonormalise(S,from,to)
   ! Schmidt orthonormalise the *column* vectors in "self" using "S" as the
   ! metric. Only the columns starting from index "from" are orthonormalised,
   ! and further, those columns are only orthonormalised to first columns, up to
   ! the column with index "to".
     self :: target
     S :: MAT{REAL}, IN
     from,to :: INT
   ENSURE(S.is_square,"S must be square matrix")
   ENSURE(S.dim1==.dim1,"incompatible metric S")
   ENSURE(NOT S.is_zero,"S is zero matrix")
   ENSURE(NOT .is_zero,"self is zero matrix")
   ENSURE(from>to,"from must be greater than to")
   ENSURE(from<=.dim2,"from to large")
     old,new :: VEC{INTRINSIC}*
     fac :: INTRINSIC
     n,o :: INT
     norm :: REAL
     do n = from,.dim2
        new => self(:,n)
        do o = 1,to
           old => self(:,o)
           fac = S.dot(old,new)
           new = new - fac*old
        end
        norm = S.dot(new,new)
        ENSURE(norm>MAT_LINEAR_DEPENDENCE_TOL,"linear dependence in vector "//n.to_str)
        norm = ONE/sqrt(norm)
        new = new*norm
     end
   end

   reverse_schmidt_orthonormalise(S)
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric.
     self :: target
     S :: MAT{REAL}
   ENSURE(S.is_square,"S must be square matrix")
   ENSURE(S.dim1==.dim1,"incompatible metric S")
   ENSURE(NOT S.is_zero,"S is zero matrix")
   ENSURE(NOT .is_zero, "self is zero matrix")
     new,old :: VEC{INTRINSIC}*
     fac :: INTRINSIC
     n,o :: INT
     norm :: REAL
     do n = .dim2,1,-1
        new => self(:,n)
        do o = .dim2,n+1,-1
           old => self(:,o)
           fac = S.dot(old,new)
           new = new - fac*old
        end
        norm = S.dot(new,new)
        ENSURE(norm>MAT_LINEAR_DEPENDENCE_TOL,"linear dependence in vector "//n.to_str)
        new = new/sqrt(norm)
     end
   end

   schmidt_orthonormalise
   ! Schmidt orthonormalise the column vectors in "self".
     self :: target
   ENSURE(.dim1>=.dim2,"more vectors than dimension of vector space")
     new,old :: VEC{INTRINSIC}*
     fac :: INTRINSIC
     norm :: REAL
     n,k :: INT
     do n = 1,.dim2
        new => self(:,n)
        do k = 1,n-1
           old => self(:,k)
           fac = dot_product(old,new)
           new = new - fac*old
        end
        norm = dot_product(new,new)
        ENSURE(norm>TOL(10),"linear dependence in vector " // n.to_str)
        new = new/sqrt(norm)
     end
   end

   reverse_schmidt_orthogonalise
   ! Schmidt orthonormalise the column vectors in "self" using unit metric.
      self :: target
   ENSURE(.dim1>=.dim2,"more vectors than dimension of vector space")
      new,old :: VEC{INTRINSIC}*
      fac :: INTRINSIC
      norm :: REAL
      n,k :: INT
      do n = .dim2,1,-1
         new => self(:,n)
         do k = n-1,1,-1
            old => self(:,k)
            fac = dot_product(old,new)
            new = new - fac*old
         end
         norm = dot_product(new,new)
         ENSURE(norm>TOL(10),"linear dependence in vector " // n.to_str)
         new = new/sqrt(norm)
      end
   end

   symmetrically_orthonormalise(S)
   ! Symmetrically orthonormalise the column vectors in "self" using "S" as the
   ! metric.
     S :: MAT{REAL}, IN
   ENSURE(S.is_square,"S must be square matrix")
   ENSURE(S.dim1==.dim1,"incompatible metric S")
   ENSURE(NOT .is_zero,"self is zero matrix")
   ENSURE(NOT S.is_zero,"S is zero matrix")
     SS,SI :: MAT{INTRINSIC}*
     SI.create(.dim2,.dim2)
     SS.create(.dim2,.dim2)
     ! S.change_basis_to(SS,self)
     MAT{REAL}:change_basis_to(S,SS,self)
     SI.to_inverse_sqrt_of(SS)
     SS.destroy
     SS.create(.dim1,.dim2)
     SS.to_product_of(self,SI)
     self = SS
     SS.destroy
     SI.destroy
   end

   make_diagonally_dominant(permutation)
   ! Rearrange the order of the columns of self so that the largest magnitude
   ! elements in each column occur along the diagonal. If "permutation" is
   ! present, it is the array which achieves this ordering, i.e. at the end of
   ! the routine, what is done is: self = self(:,permutation).
      permutation :: VEC{INT}, optional
   ENSURE(.is_square,"not square")
      perm :: VEC{INT}*
      mask :: MAT{BIN}*
      i,n  :: INT
      loc :: VEC{INT}(2)
      if (present(permutation)) then
      ENSURE(permutation.dim==.dim2,"wrong size, perm")
      end
      n = .dim2
      perm.create(n)
      mask.create(n,n)
      mask = TRUE
      do i = 1,n
        loc = maxloc(abs(self),mask=mask)
        perm(loc(1))   = loc(2)
        mask(:,loc(2)) = FALSE ! eliminate this column next time
        mask(loc(1),:) = FALSE ! eliminate this row also
      ! write(*,*) " loc  =",loc
      ! write(*,*) " mask =",mask
      end
      self = self(:,perm)
      if (present(permutation)) permutation = perm
      mask.destroy
      perm.destroy
   end

   schmidt_orthonormalise(S,scale)
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric. If "scale" is present, it is set to the product of the
   ! normalisation factors used to normalise each column after the Schmidt
   ! procedure.
     self :: target
     S :: MAT{REAL}, IN
     scale :: REAL, optional
   ENSURE(S.is_square,"S must be square matrix")
   ENSURE(S.dim1==.dim1,"incompatible metric S")
   ENSURE(NOT S.is_zero,"S is zero matrix")
   ENSURE(NOT .is_zero,"self is zero matrix")
     old,new :: VEC{INTRINSIC}*
     fac :: INTRINSIC
     n,o :: INT
     norm :: REAL
     ! T :: VEC{REAL}*
     ! dim,j,k :: INT
     ! proj :: REAL
     if (present(scale)) scale = ONE
     do n = 1,.dim2
        new => self(:,n)
        do o = 1,n-1
           old => self(:,o)
           fac = S.dot(old,new)
           new = new - fac*old
        end
        norm = S.dot(new,new)
        ENSURE(norm>MAT_LINEAR_DEPENDENCE_TOL,"linear dependence in vector "//n.to_str)
        norm = ONE/sqrt(norm)
        new = new*norm
        if (present(scale)) scale = scale*norm
     end
     ! This is old code which is not so clean, kept cos it may be more efficient
!    dim = .dim1
!    T.create(dim)
!    do n=1,dim
!      do j=1,dim
!        T(j) = dot_product(self(:j,n),S(:j,j))
!        T(1:j-1) = T(1:j-1) + self(j,n) * S(:j-1,j)
!      end
!      do k=1,n-1
!        proj = - dot_product(self(:,k),T)
!        self(:,n) = self(:,n) + proj * self(:,k)
!      end
!      do j=1,dim
!        T(j) = dot_product(self(:j,n), S(:j,j))
!        T(:j-1) = T(:j-1) + self(j,n) * S(:j-1,j)
!      end
!      norm = dot_product(T,self(:,n))
!      ENSURE(norm>TOL(10),"linear dependence in vector " // n.to_str)
!      self(:,n) = self(:,n) / sqrt(norm)
!    end
!    T.destroy
   end

! **********************************************************
! Matrix functions: square roots, inverses, and exponentials
! **********************************************************

   to_sqrt_of(R)
   ! self = sqrt(R), cannot have R=self
      R :: MAT{INTRINSIC}
   ENSURE(.is_square,"not square")
      evec :: MAT{INTRINSIC}* DEFAULT_NULL
      eval :: VEC{REAL}* DEFAULT_NULL
      veci,vecj :: VEC{INTRINSIC}* DEFAULT_NULL
      d,i,j :: INT
      temp :: REAL
      d = R.dim1
      eval.create(d)
      evec.create(d,d)
      R.solve_eigenproblem(eval,evec)
      do i = 1,d
         temp = eval(i)
         if (temp <= ZERO) then
           WARN("non-positive eigenvalue, " // trim(temp.to_str("e15.8")))
         end
         eval(i) = sqrt(abs(temp))
      end
      do i = 1,d
        veci => evec(i,:)
        do j = 1,d
          vecj => evec(j,:)
          self(i,j) = sum(veci*eval*vecj)
        end
      end
      evec.destroy
      eval.destroy
   end

   to_inverse_sqrt_of(R)
   ! self = sqrt(R)^(-1), cannot have R=self
      R :: MAT{INTRINSIC}
   ENSURE(.is_square,"not square")
      evec :: MAT{INTRINSIC}* DEFAULT_NULL
      eval :: VEC{REAL}* DEFAULT_NULL
      veci,vecj :: VEC{INTRINSIC}* DEFAULT_NULL
      d,i,j :: INT
      val :: STR
      temp :: REAL
      d = R.dim1
      eval.create(d)
      evec.create(d,d)
      R.solve_eigenproblem(eval,evec)
      do i = 1,d
         temp = eval(i)
         val = temp.to_str("e15.8")
         WARN_IF(temp<=ZERO,"non-positive eigenvalue, "// trim(val))
         eval(i) = ONE/sqrt(abs(temp))
      end
      do i = 1,d
        veci => evec(i,:)
        do j = 1,d
          vecj => evec(j,:)
          self(i,j) = sum(veci*eval*vecj)
        end
      end
      evec.destroy
      eval.destroy
   end

   to_power_series_inverse_of(S,tol,max_it)
   ! Set self to the power series inverse square root of "S".
   ! If "tol" is present, make sure that the maximum deviation from the exact
   ! answer is less than "tol" times the smallest element of "S". If "max_it"
   ! is present, use this as the maximum number of terms in the power series,
   ! before termination with an error.
      S :: MAT{INTRINSIC}
      tol :: REAL, optional
      max_it :: INT, optional
   ENSURE(S.is_square,"S not square")
   ENSURE(.is_same_shape_as(S),"wrong shape")
      d :: VEC{INTRINSIC}*
      W,X :: MAT{INTRINSIC}*
      perm :: VEC{INT}*
      max_iter,n,k :: INT
      eps :: REAL
      eps = TOL(6)
      if (present(tol)) eps = tol
      max_iter = 100
      if (present(max_it)) max_iter = max_it
      n = S.dim1
      perm.create(n)
      d.create(n)
      W.create(n,n)
      X.create(n,n)
      W = S
      W.make_diagonally_dominant(perm)
      W.put_diagonal_to(d)
      d = ONE/d
      X.to_product_with_diagonal(d,W)
      self.to_unit_matrix
      X = X - self
      W = X
      self = self - W
      k = 1
      do
         k = k + 1
         W = matmul(X,W)
         if (k.is_odd) then; self = self - W
         else;               self = self + W
         end
         if (maxval(abs(W)) < eps) exit
         ENSURE(k<=max_iter,"power series too long")
       ! write(*,*) "k = ",k
       ! write(*,*) "W = ",W
       ! write(*,*) "s = ",self
      end
      X.to_product_with_diagonal(self,d)
      self = X
      self(perm,:) = self
      X.destroy
      W.destroy
      d.destroy
      perm.destroy
   end

   to_power_series_inv_sqrt_of(S,tol,prefactor,max_it)
   ! Set self to the inverse square root of "S", a matrix which is required to
   ! have a unit diagonal. The method uses a binomial power series expansion.
   ! If "tol" is present, make sure that the maximum deviation from the exact
   ! answer is less than "tol" times the smallest element of "S". If "max_it"
   ! is present, use this as the maximum number of terms in the power series,
   ! before termination with an error.
      S :: MAT{INTRINSIC}
      tol,prefactor :: REAL, optional
      max_it :: INT, optional
   ENSURE(S.has_unit_diagonal,"must have unit diagonal")
   ENSURE(S.is_square,"S not square")
   ENSURE(.is_same_shape_as(S),"wrong shape")
      W,X :: MAT{INTRINSIC}*
      max_iter,n,k :: INT
      eps,fac,prefac :: REAL
      eps = TOL(6)
      if (present(tol)) eps = tol
      max_iter = 100
      if (present(max_it)) max_iter = max_it
      prefac = ONE
      if (present(prefactor)) prefac = prefactor
      n = S.dim1
      self.to_unit_matrix
      S = prefac*S
      S = S - self
      X.create(n,n)
      W.create(n,n)
      fac = -HALF
      X = fac*S
      W = X
      self = self + X
      k = 1
      do
         k   = k + 1
         fac = fac - ONE
         X.to_scaled_product_of(S,W,(fac/k))
         W = X
         self = self + X
         if (maxval(abs(X)) < eps) exit
         write(*,*) "max = ",maxval(abs(X))
         ENSURE(k<=max_iter,"power series too long")
      end
      prefac = sqrt(prefac)
      self = prefac*self
      prefac = ONE/(prefac*prefac)
      W.to_unit_matrix
      S = prefac*(S + W)
      W.destroy
      X.destroy
   end

   to_exponential_of(X,tol)
   ! Exponentiate the matrix "X" using a power series expansion, self = exp(X),
      X :: MAT{INTRINSIC}
      tol :: REAL, optional
      X.exponentiate_to(self,tol)
   end

   exponentiate_to(U,tol)
   ! Exponentiate the matrix self using a power series expansion, U = exp(self),
   ! so that the maximum deviation from the exact answer is less than "tol"
   ! if present. 
      U :: MAT{INTRINSIC}, OUT
      tol :: REAL, IN, optional
   ENSURE(U.is_square,"U not square")
   ENSURE(.is_same_shape_as(U),"wrong shape")
      W,V :: MAT{INTRINSIC}*
      n,k :: INT
      eps,fac,error :: REAL

      eps = TOL(9)
      if (present(tol)) eps = tol

      n = U.dim1

      U.to_unit_matrix
      W.create(n,n)
      V.create(n,n)

      W = self
      U = U + W

      k = 1
      do
         k   = k+1
         fac = ONE/k
         V.to_scaled_product_of(self,W,fac)
         W   = V
         U   = U + W
         error = maxval(abs(W))
       ! write(*,*) "error=",error
         if ( error < eps ) exit
      end
      V.destroy
      W.destroy
   end

   antisymmetric_exponential_to(U,eval,evec)
   ! Make unitary matrix U = exp(self) where "self" must be antisymmetric.
   ! Uses the formula:  exp A = V (cos P) V^t + V (sin P)/P V^t A
   !                        P = sqrt diag(eig(A^t A))
   ! (c) dylan jayatilaka, university of western australia, 1993
   ! WARNING: Untested in TONTO and looks wrong.
      U :: MAT{INTRINSIC}
      evec :: MAT{INTRINSIC}*, optional
      eval :: VEC{REAL}*, optional
   ENSURE(.is_square,"self is a non-square matrix")
   ENSURE(.is_same_shape_as(U),"incompatible shapes")
      W :: MAT{INTRINSIC}*
      dim1,dim2,dim,k :: INT
      e,e2,cs,sn :: REAL
      v_k :: MAT{INTRINSIC}*
      dim = .dim1
      if (NOT present(eval)) then
         eval.create(dim)
      else
         dim2 = eval.dim
         ENSURE(dim2>=dim,"eval too small")
      end
      if (NOT present(evec)) then
         evec.create(dim,dim)
      else
         dim1 = evec.dim1
         dim2 = evec.dim2
         ENSURE(dim1==dim AND dim2==dim,"evec incompatible")
      end
      W.create(dim,dim)
      U = matmul(self,self)   ! U = -self^t*self = self^2, makes U hermitian
      U.solve_eigenproblem(eval,evec) ! diagonalise U ...

      U = ZERO
      do k = 1,dim            ! do the exponential ... loop over eigenvalues ...
         e2 = eval(k)
         if (e2<0)  then
            e = sqrt(-e2); cs = cos(e);  sn = sin(e)/e;
         end
         if (e2>0)  then
            e = sqrt(e2) ; cs = cosh(e); sn = sinh(e)/e
         end
         if (e2==0) then
            cs = ONE    ; sn = ONE
         end
         v_k => evec(1:dim,k:k)
         W.to_product_of(v_k,v_k,transpose_b=TRUE) ! V V^\dag part
         U.plus_scaled_product_of(W,self,sn)       ! sin part
         U.plus_scaled(W,cs)                       ! cos part
      end
      if (NOT present(eval)) eval.destroy
      if (NOT present(evec)) evec.destroy
   end

!  ***********************
!  Spin-orbital operations
!  ***********************

!  Block returning routines

   alpha_alpha result (res)
   ! return the alpha-alpha sector of the matrix
      self :: target
      res :: MAT{INTRINSIC}*
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      res => self(1:n,1:n)
   end

   beta_alpha result (res)
   ! return the beta-alpha sector of the matrix
      self :: target
      res :: MAT{INTRINSIC}*
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      res => self(n+1:2*n,1:n)
   end

   alpha_beta result (res)
   ! return the alpha-beta sector of the matrix
      self :: target
      res :: MAT{INTRINSIC}*
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      res => self(1:n,n+1:2*n)
   end

   beta_beta result (res)
   ! return the beta-beta sector of the matrix
      self :: target
      res :: MAT{INTRINSIC}*
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      res => self(n+1:2*n,n+1:2*n)
   end

!  Set_to routines

   alpha_alpha_set_to(X)
   ! Set the alpha-alpha sector of the matrix to "X"
      X :: X_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(1:n,1:n) = X
   end

   alpha_alpha_set_to(X,factor)
   ! Set the alpha-alpha sector of the matrix to "X"
      X :: X_TYPE, IN
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(1:n,1:n) = factor*X
   end

   beta_alpha_set_to(X)
   ! Set the beta-alpha sector of the matrix to "X"
      X :: X_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(n+1:2*n,1:n) = X
   end

   beta_alpha_set_to(X,factor)
   ! Set the beta-alpha sector of the matrix to "X"
      X :: X_TYPE, IN
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(n+1:2*n,1:n) = factor*X
   end

   alpha_beta_set_to(X)
   ! Set the alpha-beta sector of the matrix to "X"
      X :: X_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(1:n,n+1:2*n) = X
   end

   alpha_beta_set_to(X,factor)
   ! Set the alpha-beta sector of the matrix to "X"
      X :: X_TYPE, IN
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(1:n,n+1:2*n) = factor*X
   end

   beta_beta_set_to(X)
   ! Set the beta-beta sector of the matrix to "X"
      X :: X_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(n+1:2*n,n+1:2*n) = X
   end

   beta_beta_set_to(X,factor)
   ! Set the beta-beta sector of the matrix to "X"
      X :: X_TYPE, IN
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(n+1:2*n,n+1:2*n) = factor*X
   end

!  Put_to routines

   alpha_alpha_put_to(X)
   ! Put the alpha-alpha sector of the matrix to "X"
      X :: X_TYPE, OUT
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      X = self(1:n,1:n)
   end

   alpha_alpha_put_to(X,factor)
   ! Put the alpha-alpha sector of the matrix to "X"
      X :: X_TYPE, OUT
      factor :: FACTOR_TYPE
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      X = factor*self(1:n,1:n)
   end

   beta_alpha_put_to(X)
   ! Put the beta-alpha sector of the matrix to "X"
      X :: X_TYPE, OUT
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      X = self(n+1:2*n,1:n)
   end

   beta_alpha_put_to(X,factor)
   ! Put the beta-alpha sector of the matrix to "X"
      X :: X_TYPE, OUT
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      X = factor*self(n+1:2*n,1:n)
   end

   alpha_beta_put_to(X)
   ! Put the alpha-beta sector of the matrix to "X"
      X :: X_TYPE, OUT
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      X = self(1:n,n+1:2*n)
   end

   alpha_beta_put_to(X,factor)
   ! Put the alpha-beta sector of the matrix to "X"
      X :: X_TYPE, OUT
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      X = factor*self(1:n,n+1:2*n)
   end

   beta_beta_put_to(X)
   ! Put the beta-beta sector of the matrix to "X"
      X :: X_TYPE, OUT
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      X = self(n+1:2*n,n+1:2*n)
   end

   beta_beta_put_to(X,factor)
   ! Put the beta-beta sector of the matrix to "X"
      X :: X_TYPE, OUT
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      X = factor*self(n+1:2*n,n+1:2*n)
   end

!  plus routines

   alpha_alpha_plus(X)
   ! Add "X" to the alpha-alpha sector of the matrix
      X :: X_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(1:n,1:n) = self(1:n,1:n) + X
   end

   alpha_alpha_plus(X,factor)
   ! Add "X" to the alpha-alpha sector of the matrix
      X :: X_TYPE, IN
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(1:n,1:n) = self(1:n,1:n) + factor*X
   end

   beta_alpha_plus(X)
   ! Add "X" to the beta-alpha sector of the matrix
      X :: X_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(n+1:2*n,1:n) = self(n+1:2*n,1:n) + X
   end

   beta_alpha_plus(X,factor)
   ! Add "X" to the beta-alpha sector of the matrix
      X :: X_TYPE, IN
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(n+1:2*n,1:n) = self(n+1:2*n,1:n) + factor*X
   end

   alpha_beta_plus(X)
   ! Add "X" to the alpha-beta sector of the matrix
      X :: X_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(1:n,n+1:2*n) = self(1:n,n+1:2*n) + X
   end

   alpha_beta_plus(X,factor)
   ! Add "X" to the alpha-beta sector of the matrix
      X :: X_TYPE, IN
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(1:n,n+1:2*n) = self(1:n,n+1:2*n) + factor*X
   end

   beta_beta_plus(X)
   ! Add "X" to the beta-beta sector of the matrix
      X :: X_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(n+1:2*n,n+1:2*n) = self(n+1:2*n,n+1:2*n) + X
   end

   beta_beta_plus(X,factor)
   ! Add "X" to the beta-beta sector of the matrix
      X :: X_TYPE, IN
      factor :: FACTOR_TYPE, IN
   ENSURE(.is_square,"non-square matrix")
   ENSURE(.dim1.is_even,"not even-dimensioned")
      n :: INT
      n = .dim1/2
      self(n+1:2*n,n+1:2*n) = self(n+1:2*n,n+1:2*n) + factor*X
   end

end

