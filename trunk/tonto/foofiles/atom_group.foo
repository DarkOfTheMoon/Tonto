!---------------------------------------------------------------------
!
! ATOM_GROUP:
!
! For storing the lists of integers which make up separate atom groups
! within a list of atoms.
!
! Copyright (C) Dylan Jayatilaka, June 2011
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: atom_group.foo $
!
!---------------------------------------------------------------------

module ATOM_GROUP

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts
      nullify(.atom_index)
      nullify(.atom)
      nullify(.mol)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts
      .atom_index.destroy
      nullify(.atom) ! do not destroy
      ! .mol.destroy ! destroy manually
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(atom_group) ::: leaky
   ! Set self to be "group".
      atom_group :: ATOM_GROUP, IN
      self = atom_group
      .nullify_ptr_part
      if (atom_group.atom_index.created) .atom_index.create_copy(atom_group.atom_index)
   end

   set_defaults
   ! Set up defaults
      .name   = " "
      .n_atoms = 0
      .charge = 0
      .n_MOs  = 0
   end

   set_one_group
   ! Set up one group comprising all the atoms
   DIE_IF(.atom.destroyed,"atom list not created")
      i :: INT
      .atom_index.destroy
      .atom_index.create(.atom.dim)
      .atom_index = [ (i, i=1,.atom.dim) ]
   end

   set_atom(atom)
   ! Set the .atom list to which .atom_index refers to
      atom :: VEC{ATOM}*
   ENSURE(atom.created,"atom list not created")
      .atom => atom
   end

   set_mol(mol)
   ! Set the molecule associated with .atom_index
      mol :: MOLECULE*
   ENSURE(mol.created,"mol not created")
      .mol => mol
   end

   set_name(name)
   ! Set the name of this stom group to be "name"
      name :: STR
      .name = name
   end

!  ************
!  Read methods
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                      ")  ! exit read_loop
         case ("charge=                "); .read_charge
         case ("atom_indices=          "); .read_atom_indices
         case ("n_mos=                 "); .read_n_MOs
         case ("name=                  "); .read_name
         ! These are only for making custom tables for the list type
         case ("---For custom tables---");
         case ("flush                  "); stdout.flush
         case ("put_charge             "); stdout.put(.charge)
         case ("put_chemical_symbols   "); .put_chemical_symbols
         case ("put_atom_indices       "); .put_atom_indices
         case ("put_n_atoms            "); stdout.put(.n_atoms)
         case ("put_n_mos              "); stdout.put(.n_MOs)
         case ("put_name               "); stdout.put(.name)
         case default;       UNKNOWN(word)
      end

   end

   read_atom_indices ::: leaky
   ! Read the atom atom_indices in the group
      stdin.read_ptr(.atom_index)
      .n_atoms = .atom_index.dim
   end

   read_charge ::: leaky
   ! Read the charges on the group
      stdin.read(.charge)
   end

   read_n_MOs ::: leaky
   ! Read the number of MOs to use to make the density matrix on 
   ! each group
      stdin.read(.n_MOs)
   end

   read_name ::: leaky
   ! Read the name for the groups
      stdin.read(.name)
   end

   finalise(atom) ::: leaky
   ! Do all the sanity checks and default settings
      atom :: VEC{ATOM}*

      DIE_IF(atom.destroyed,"no atom list")
      DIE_IF(atom.dim==0,"no atoms")

      ! Set the atom information
      .set_atom(atom)

      ! Ensure .atom_index is defined and OK
      DIE_IF(.atom_index.destroyed,"no atom_index in the group")
      DIE_IF(.atom_index.dim>.atom.dim,"more atom_index than # of atoms!")
      DIE_IF(.atom_index.has_repetitions,"there are repeated atom_index!")
      DIE_IF(any(.atom_index<=0),"non-positive atom atom_index!")
      DIE_IF(any(.atom_index>.atom.dim),"index too large")

   end

! ********************
! Key related routines
! ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   ENSURE(keys.created,"no keys")
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")

      word :: STR
      width,k :: INT

      width = .table_width

      if (width > 0) then

         stdout.dash(width=width)

         do k = 1,keys.dim

            word = keys(k)

            word.to_lower_case
            select case (word)
               case ("put_charge      "); stdout.put("Charge",int_width=TRUE)
               case ("put_n_atoms     "); stdout.put("n_atoms",int_width=TRUE)
               case ("put_n_mos       "); stdout.put("n_MO",int_width=TRUE)
               case ("put_name        "); stdout.put("Name")
               case ("put_atom_indices"); stdout.put("Atom #s")
               case ("flush           "); stdout.flush; exit
            end

            if (k==keys.dim) then
               stdout.flush ! In case they didn't write one.
               DIE("no flush keyword - you may later overrun the output buffer")
            end

         end

         stdout.dash(width=width)

      end

   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
      res :: INT

   ENSURE(keys.created,"no keys")

      word :: STR
      int_dash,real_dash,width,k :: INT

      int_dash  = 0
      real_dash = 0
      width = 0

      do k = 1,size(keys)

         word = keys(k)

         word.to_lower_case
         select case (word)
            case ("}               "); ! exit surrounding loop
            case ("put_charge      "); int_dash  = int_dash + 1
            case ("put_n_atoms     "); int_dash  = int_dash + 1
            case ("put_n_mos       "); int_dash  = int_dash + 1
            case ("put_name        "); real_dash = real_dash + 1
            case ("put_atom_indices"); width     = width + stdout.real_width
            case ("flush           "); exit
            case default
         end

      end

      res = int_dash*stdout.int_width &
          + real_dash*stdout.real_width &
          + width

   end

!  ***********
!  Put methods
!  ***********

   put_chemical_symbols
   ! Output the chemical symbol information
   ENSURE(.atom_index.created,"no atom atom_index")
   ENSURE(.atom.created,"no atoms")
      i :: INT
      do i = 1,.n_atoms
         stdout.put(.atom(.atom_index(i)).chemical_symbol,width=3)
      end
   end

   put_atom_indices
   ! Output info array
   ENSURE(.atom_index.created,"no atom atom_index")
      i,pos,wid,len :: INT
      pos = stdout.buffer.item_end
      wid = stdout.real_width
      len = stdout.real_width
      do i = 1,.atom_index.dim
         stdout.put(.atom_index(i),width=3)
         len = len + 3
         if (len>wid) then
         stdout.flush
         stdout.tab(width=pos)
         end
      end
   end

end
