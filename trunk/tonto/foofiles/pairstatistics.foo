!-------------------------------------------------------------------------------
!
! PAIRSTATISTICS: 
!
! Routines for assesing statistical behaviour between a pair  of data sets.
!
! $Id$
!
! (c) dylan jayatilaka, university of western australia (2000)
!-------------------------------------------------------------------------------
module PAIRSTATISTICS

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use VEC
   use TEXTFILE

   implicit none

#  include "macros"
#  include "pairstatistics.int"

!   type pairstatistics_type
!
!   VEC, PTR :: X_data DEFAULT_NULL
!   ! A list of the data set X
!
!   VEC, PTR :: Y_data DEFAULT_NULL
!   ! A list of the data set Y
!
!   VEC, PTR :: sigma_Y DEFAULT_NULL
!   ! A list of the standard deviations in the data set Y
!
!   INT :: n_data
!   ! The number of data (i.e. the dimension of X_data, Y_data)
!
!   DBL :: chi2
!   ! Chi^2 agreement statistic with respect to Y
!
!   DBL :: goodness_of_fit
!   ! Goodness of fit parameter with respect to Y
!
!   DBL :: r_factor
!   ! R factor agreement statistic w.r.t. Y
!
!   DBL :: weighted_r_factor
!   ! Weighted R factor agreement statistic w.r.t. Y
!
!   DBL :: scaled_chi2
!   ! Chi^2 agreement statistic with respect to Y after overall scaling
!
!   DBL :: scaled_goodness_of_fit
!   ! Goodness of fit parameter with respect to Y after overall scaling
!
!   DBL :: scaled_r_factor
!   ! R factor agreement statistic w.r.t. Y after overall scaling
!
!   DBL :: scaled_weighted_r_factor
!   ! Weighted R factor agreement statistic w.r.t. Y after overall scaling
!
!   INT :: n_param
!   ! No of fitting parameters used
!
!   DBL :: scale_factor
!   ! Scale factor used to minimise chi^2
!
!   end

contains

!  **************************
!  Create and destroy methods
!  **************************

   create(X_data,Y_data,sigma_Y)
   ! Create the pairstatistics object fiven the data sets X and Y, and the
   ! error "sigma_Y" in the Y data set.
      PTR :: self
      VEC, PTR :: X_data,Y_data,sigma_Y
      allocate(self)
      ADD_MEM(PAIRSTATISTICS_SIZE)
      .set_default
      .set_data(X_data,Y_data,sigma_Y) 
   end

   destroy
   ! Destroy the object
      PTR :: self
      if (.destroyed) return
      .nullify_ptr_part ! because data are PTR assigned
      DELETE_MEM(PAIRSTATISTICS_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object
      nullify(.X_data)
      nullify(.Y_data)
   end

   destroy_ptr_part
   ! Erase all pointer information
      .X_data.destroy
      .Y_data.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_default [leaky]
   ! Set up a default crystal object
      .X_data  => null()
      .Y_data  => null()
      .sigma_Y => null()
      .chi2 = ZERO
      .r_factor = ZERO
      .weighted_r_factor = ZERO
      .goodness_of_fit = ZERO
      .n_param = 0
      .scale_factor = ONE
   end

   set_data(X_data,Y_data,sigma_Y) 
   ! Set up a default crystal object
      VEC, PTR :: X_data,Y_data,sigma_Y
      ENSURE(X_data.created, "no X data set!")
      ENSURE(Y_data.created, "no Y data set!")
      ENSURE(sigma_Y.created,"no Y data errors!")
      ENSURE(size(Y_data )==size(X_data),"incompatible data")
      ENSURE(size(sigma_Y)==size(X_data),"incompatible data")
      .X_data  => X_data
      .Y_data  => Y_data
      .sigma_Y => sigma_Y
      .n_data = size(.X_data)
      .make_agreement_statistics
   end

   make_agreement_statistics
   ! Make the agreement statistics
      DBL :: top1,top2,bot1,bot2
      VEC, PTR :: X
      top1 = sum( abs(.X_data - .Y_data) )
      bot1 = sum( abs(.Y_data) )
      top2 = sum( ((.X_data - .Y_data) /.sigma_Y)**2 )
      bot2 = sum( (.Y_data/.sigma_Y)**2 )
      .r_factor          = top1/bot1
      .weighted_r_factor = sqrt(top2/bot2)
      .chi2              = top2/max(.n_data,1)
      .goodness_of_fit   = sqrt(.chi2)
      !
      .make_scale_factor
      !
      X.create(.n_data)
      X = .scale_factor*.X_data
      top1 = sum( abs(X - .Y_data) )
      bot1 = sum( abs(.Y_data) )
      top2 = sum( ((X - .Y_data) /.sigma_Y)**2 )
      bot2 = sum( (.Y_data/.sigma_Y)**2 )
      .scaled_r_factor          = top1/bot1
      .scaled_weighted_r_factor = sqrt(top2/bot2)
      .scaled_chi2              = top2/max(.n_data-.n_param,1)
      .scaled_goodness_of_fit   = sqrt(.chi2)
      X.destroy
   end

   make_scale_factor
   ! Make the agreement statistics
      DBL :: top3,bot3
      top3 = ZERO
      top3 = sum(abs(.X_data(:)*.Y_data(:))/(.sigma_Y(:)*.sigma_Y(:)))
      bot3 = sum(   (.X_data(:)*.X_data(:))/(.sigma_Y(:)*.sigma_Y(:)))
      .scale_factor = top3/bot3
   end

   make_qq_plot_grid(grid)
   ! Make the grid for the Q-Q plot, which is a plot of the deviations X-Y
   ! versus the expected deviations, assuming that the expected devaitions 
   ! are normally distributed. grid(1,:) contains the expected deviation d0j, 
   ! grid(2,:) contains actual deviation dj.
      MAT :: grid
      VEC, PTR :: d,Fc
      DBL :: temp
      INT :: n,j
      ENSURE(size(grid,1)==2, "grid wrong size")
      ENSURE(size(grid,2)==n, "grid wrong size")
      d.create(n)                      ! quantile
      d(:)  = (.Y_data(:) - .X_data(:))/.sigma_Y(:)
      d.sort                           ! sort array from lowest to highest.
      grid(2,:) = d
      d.destroy
      do j=1,n                           ! expected quantile, d0j
        temp = real(2*n-2*j+1)/real(2*n) ! cumulative probability
        grid(1,n-j+1) = temp.z_from_p
      end
   end

   put(output)
   ! Output the goodness of fit statistics to file "out"
      TEXTFILE, optional, target :: output
      TEXTFILE, PTR :: out
      if (present(output)) then; out => output
      else;                      out => stdout
      end
      out.flush
      out.text("Goodness of fit parameters based on Structure Factors:",flush=2)
      out.show("R factor                    =", .r_factor)
      out.show("Weighted R factor           =", .weighted_r_factor)
      out.show("chi**2                      =", .chi2)
      out.show("Goodness of fit             =", .goodness_of_fit)
      out.show("Scale factor                =", .scale_factor)
      RETURN_IF(.scale_factor.equals(ONE))
      out.show("Scaled R factor             =", .scaled_r_factor)
      out.show("Scaled weighted R factor    =", .scaled_weighted_r_factor)
      out.show("Scaled chi**2               =", .scaled_chi2)
      out.show("Scaled goodness of fit      =", .scaled_goodness_of_fit)
   end

end
