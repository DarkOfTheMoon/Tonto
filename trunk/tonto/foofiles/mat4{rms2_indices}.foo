!-------------------------------------------------------------------------------
!
! MAT4{RMS2_INDICES}
!
! This object is used to store precalculated information pertaining to the
! reduced multiplication scheme (RMS) used in electron repulsion integral 
! evaluation.
!
! Copyright (C) Dylan Jayatilaka, 2000
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module MAT4{RMS2_INDICES}

   use MAT_RMS_INDICES

   implicit none

   l_max_saved :: INT, private = -1

   ! List of arrays used for the RMS scheme
   rms2_indices :: MAT4{RMS2_INDICES}*, public  DEFAULT_NULL

contains

! *****************
! Memory allocation
! *****************

   create(dim1,dim2,dim3,dim4) ::: get_from(MAT4{OBJECT}), leaky
   ! Create the object. This version does not set defaults.
   end

   create(lb1,ub1,lb2,ub2,lb3,ub3,lb4,ub4) ::: get_from(MAT4{OBJECT}), leaky
   ! Create the object with the desired bounds. This version does not set
   ! defaults.
   end

   destroy ::: get_from(MAT4{OBJECT}), leaky
   ! Destroy the object
   end

   created result(res) ::: get_from(MAT4{OBJECT}), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result(res) ::: get_from(MAT4{OBJECT}), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   nullify_ptr_part ::: get_from(MAT4{OBJECT})
   ! Nullify the pointer parts of self
   end

   destroy_ptr_part ::: get_from(MAT4{OBJECT}), leaky
   ! Destroy the pointer parts of self
   end

! ****************************
! Size-of and shape operations 
! ****************************

   size result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo
   ! Return the size of the array
   end

   dim1 result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo
   ! Return the size of the 1st dimension
   end

   dim2 result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo
   ! Return the size of the 2nd dimension
   end

   dim3 result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo
   ! Return the size of the 3rd dimension
   end

   dim4 result (res) ::: get_from(MAT4{OBJECT}), inlined_by_foo
   ! Return the size of the 4th dimension
   end

! ***********
! Set indices
! ***********

   set_indices(l_max) ::: leaky
   ! Set the rms indices. 
     self :: PTR
     l_max :: INT, IN
 !   nx,ny,nz :: VEC{INT}, IN
 ! ENSURE(nx.dim==n_comp_up_to(2*l_max),"wrong size, nx")
 ! ENSURE(ny.dim==ex.dim,"wrong size, ny")
 ! ENSURE(nz.dim==ex.dim,"wrong size, nz")
     ab_lmax,ab_lmin,fe,le :: INT
     cd_lmax,cd_lmin,ff,lf :: INT
     if (l_max<=l_max_saved) return
     l_max_saved = l_max
     rms2_indices.destroy
     rms2_indices.create(0,l_max,0,l_max,0,l_max,0,l_max)
     do ab_lmax = 0,l_max   ! Maximum l for a shell
     do ab_lmin = 0,ab_lmax ! l for the b shell
        fe = n_comp_up_to(ab_lmax-1)+1
        le = n_comp_up_to(ab_lmin+ab_lmax)
        do cd_lmax = 0,l_max   ! Maximum l for c shell
        do cd_lmin = 0,cd_lmax ! l for the d shell
           ff = n_comp_up_to(cd_lmax-1)+1
           lf = n_comp_up_to(cd_lmin+cd_lmax)
           rms2_indices(ab_lmax,ab_lmin,cd_lmax,cd_lmin).set_indices( &
              rms_indices(ab_lmax,ab_lmin),  & 
              rms_indices(cd_lmax,cd_lmin),  &
              nx(fe:le),ny(fe:le),nz(fe:le), &
              nx(ff:lf),ny(ff:lf),nz(ff:lf), &
              ab_lmax,ab_lmin,cd_lmax,cd_lmin )
        end
        end
     end
     end
   end

   n_comp_up_to(l) result(res) ::: selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
     l :: INT, IN
     res :: INT
     res = (l+1)*(l+2)*(l+3)/6
   end

end
