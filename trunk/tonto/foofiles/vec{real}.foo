!---------------------------------------------------------------------------
!
!  VEC{REAL}: Vector operations ...
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module VEC{REAL}

   implicit none

contains

! *****************
! Memory allocation
! *****************

   create(dim) ::: get_from(VEC{INTRINSIC}), leaky
   ! Create space for object
      self :: PTR
      dim :: INT, IN
   end

   create(lb,ub) ::: get_from(VEC{INTRINSIC}), leaky
   ! Create the vector with lower bound "lb", upper bound "ub"
      self :: PTR
      lb,ub :: INT, IN
   end

   create(bounds) ::: get_from(VEC{INTRINSIC}), leaky
   ! Create the vector with "bounds"
      self :: PTR
      bounds :: VEC{INT}(2), IN
   end

   destroy ::: get_from(VEC{INTRINSIC}), leaky
   ! Destroy space for object
      self :: PTR
   end

   create_copy(v) ::: get_from(VEC{INTRINSIC}), leaky
   ! Create a copy of vector "v".
      self :: PTR
      v :: VEC{REAL}, IN
   end

   copy(v) ::: get_from(VEC{INTRINSIC})
   ! Copy vector "v".
      v :: VEC{REAL}, IN
   end

   created result(res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

! ******************
! Size-of operations
! ******************

   size result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Return the size of the array
      res :: INT
   end

   dim result (res) ::: get_from(VEC{INTRINSIC}), inlined_by_foo
   ! Return the size of the 1st dimension
      res :: INT
   end

! ***********************
! Shrinking and expansion
! ***********************

   shrink(dim) ::: get_from(VEC{INTRINSIC}), leaky
   ! Shrink self to dimension dim.  Contents are retained.
     self :: PTR
     dim :: INT, IN
   end

   expand(dim) ::: get_from(VEC{INTRINSIC}), leaky
   ! Expand self to dimension dim. New slots are left undefined.
     self :: PTR
     dim :: INT, IN
   end

   append(v) ::: get_from(VEC{INTRINSIC}), leaky
   ! Expands self and appends the contents of vector "v".
     self :: PTR
     v :: VEC{REAL}, IN
   end

   append(value) ::: get_from(VEC{INTRINSIC}), leaky
   ! Expands self by 1, and appends the single scalar "value" onto the end.
     self :: PTR
     value :: REAL, IN
   end

   prepend(v) ::: get_from(VEC{INTRINSIC}), leaky
   ! Prepend the vector "v" to "self". "self" is expanded.
     self :: PTR
     v :: VEC{REAL}, IN
   end

   prepend(value) ::: get_from(VEC{INTRINSIC}), leaky
   ! Prepend an single "value" to "self". "self" is expanded.
     self :: PTR
     value :: REAL, IN
   end

   join(v) result (res) ::: get_from(VEC{INTRINSIC}), leaky
   ! Yield a vector which is the concatenation of "self" and "v"
     v :: VEC{REAL}, IN
     res :: VEC{REAL}*
   end

   join(v1,v2) result (res) ::: get_from(VEC{INTRINSIC}), leaky
   ! Yield a vector which is the concatenation of "self" and "v1" and "v2"
     v1,v2 :: VEC{REAL}, IN
     res :: VEC{REAL}*
   end

! ********************
! Comparison functions
! ********************

   equals(v,eps) result(res) ::: get_from(VEC{INTRINSIC})
   ! Return true if "self" is the same as "v", within range "eps" if supplied
      self :: IN
      v :: VEC{REAL}, IN
      eps :: REAL, optional, IN
      res :: BIN
   end

   same_as(v,eps) result(res) ::: get_from(VEC{INTRINSIC})
   ! Return true if "self" is the same as "v", within range "eps" if supplied
      self :: IN
      v :: VEC{REAL}, IN
      eps :: REAL, optional, IN
      res :: BIN
   end

   are_all_equal(eps) result(res) ::: get_from(VEC{INTRINSIC})
   ! Return TRUE if "self" contains all the same elements, to within precision
   ! "eps", if supplied.
      self :: IN
      eps :: REAL, optional, IN
      res :: BIN
   end

   is_zero(eps) result(res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return true if the vector is zero (within "eps", if supplied)
      self :: IN
      eps :: REAL, IN, optional
      res :: BIN
   end

   is_z_axis(eps) result(res)
   ! Return true if the vector is set to the z-axis
      eps :: REAL, IN, optional
      res :: BIN
   ENSURE(.dim==3,"must supply a 3 dimensional vector!")
      res = self(1).equals(ZERO,eps)
      res = self(2).equals(ZERO,eps) AND res
      res = self(3).equals(ONE,eps)  AND res
   end

! *****************************
! Repetition related operations
! *****************************

   remove_repetitions ::: get_from(VEC{OBJECT}), leaky
   ! Sort through the vector and remove repeated elements which come later in
   ! the list.  NOTE: the vector may shrink
      self :: PTR
   end

   has_repetitions result (res) ::: get_from(VEC{OBJECT})
   ! Return TRUE if self has at least one repeated element.
      res :: BIN
   end

   no_of_unique_elements result (res) ::: get_from(VEC{OBJECT}), pure
   ! Return the number of unique elements in the vector.
      self :: IN
      res :: INT
   end

! ****************
! Sorting routines
! ****************

   sort(decreasing_order) ::: get_from(VEC{OBJECT}), pure
   ! Sort array "self" from lowest to highest, using simple insertion sort.  If
   ! "decreasing_order" is present and TRUE sort from highest to lowest instead.
     self :: INOUT
     decreasing_order :: BIN, IN, optional
   end

   quick_sort(decreasing_order) ::: get_from(VEC{OBJECT})
   ! Sort the vector into increasing order.If "decreasing_order" is present and
   ! TRUE, the vector is sorted from largest to smallest
      self :: IN
      decreasing_order :: BIN, optional, IN
   end

   quick_sort_increasing ::: get_from(VEC{OBJECT}), recursive, private
   ! Sort the vector into order, smallest to largest
   end

   quick_sort_decreasing ::: get_from(VEC{OBJECT}), recursive, private
   ! Sort the vector into order, largest to smallest
   end

   quick_sort(indices,decreasing_order) ::: get_from(VEC{OBJECT})
   ! Return the "indices" which sort self from smallest to largest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
   ! If "decreasing_order" is present and TRUE, the indices are sorted from
   ! largest to smallest
      self :: IN
      indices :: VEC{INT}, INOUT
      decreasing_order :: BIN, optional, IN
   end

   quick_sort_increasing(indices) ::: get_from(VEC{OBJECT}), recursive, private
   ! Return the indices which sort vector from smallest to largest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
      self :: IN
      indices :: VEC{INT}, INOUT
   end

   quick_sort_decreasing(indices) ::: get_from(VEC{OBJECT}), recursive, private
   ! Return the indices which sort vector from largest to smallest, i.e. on
   ! return "self(indices)" is sorted. NOTE: self is *not* sorted.
      self :: IN
      indices :: VEC{INT}, INOUT
   end

   reverse_order ::: get_from(VEC{INTRINSIC}), pure
   ! Reverse the order of the elements of self
     self :: INOUT
   end

   swap_elements(e1,e2) ::: get_from(VEC{INTRINSIC}), pure
   ! Swap elements "e1" and "e2" in "self".
      self :: INOUT
      e1,e2 :: INT, IN
   end

! ********************
! Numerical operations
! ********************

   set_to(v) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure
   ! Set the vector to "v". See also the "copy" routine.
      self :: INOUT
      v :: VEC{REAL}, IN
   end

   plus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure
   ! Add vector "v" to "self"
      self :: INOUT
      mask :: VEC{BIN}, IN, optional
      v :: VEC{REAL}, IN
   end

   minus(v,mask) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}), pure
   ! Subtract vector "v" from "self"
      self :: INOUT
      v :: VEC{REAL}, IN
      mask :: VEC{BIN}, IN, optional
   end

   to_scaled_vec(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL), pure
   ! Set the vector to "v" scaled by "fac"
      self :: INOUT
      v :: VEC{REAL}, IN
      fac :: REAL, IN
   end

   plus_scaled_vec(v,fac) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL), pure
   ! Add a vector "v" scaled by "fac" to "self"
      self :: INOUT
      v :: VEC{REAL}, IN
      fac :: REAL, IN
   end

   dot(v) result (res) ::: get_from(VEC{INTRINSIC}, V_TYPE=>VEC{REAL}, RES_TYPE=>REAL), pure
   ! Return the dot product with "v"
      self :: IN
      v :: VEC{REAL}, IN
      res :: REAL
   end

   cross(v) result(res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the cross product of "self" and "v".
      self :: IN
      v :: VEC{REAL}, IN
      res :: VEC{REAL}(3)
   end

   to_cross_product_of(u,v) ::: get_from(VEC{INTRINSIC}), pure
   ! Set the vector to the cross product of "u" and "v".
      self :: INOUT
      u,v :: VEC{REAL}, IN
   end

   to_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})
   ! Set "self" to the product of the matrix "a" and vector "v". If present,
   ! "transpose_a" can be set to TRUE if the matrix needs to be transposed.
      a :: MAT{REAL}, IN
      v :: VEC{REAL}, IN
      transpose_a :: BIN, optional
   end

   plus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})
   ! Add to "self" the product of the matrix "a" and vector "v". If present,
   ! "transpose_a" can be set to TRUE if the marix needs to be transposed.
      a :: MAT{REAL}, IN
      v :: VEC{REAL}, IN
      transpose_a :: BIN, optional
   end

   minus_product_of(a,v,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL})
   ! Subtract from "self" the product of the matrix "a" and vector "v". If
   ! present, "transpose_a" can be set to TRUE if the marix needs to be
   ! transposed.
      a :: MAT{REAL}, IN
      v :: VEC{REAL}, IN
      transpose_a :: BIN, optional
   end

   to_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL)
   ! Set "self" to the product of the matrix "a" and vector "v" scaled by "fac".
   ! If present, "transpose_a" can be set to TRUE if the matrix needs to be
   ! transposed.
      a :: MAT{REAL}, IN
      v :: VEC{REAL}, IN
      fac :: REAL
      transpose_a :: BIN, optional
   end

   plus_scaled_product_of(a,v,fac,transpose_a) ::: get_from(VEC{INTRINSIC}, A_TYPE=>MAT{REAL}, V_TYPE=>VEC{REAL}, FAC_TYPE=>REAL)
   ! Add to self "self" the product of the matrix "a" and vector "v" scaled by
   ! "fac".  If present, "transpose_a" can be set to TRUE if the matrix needs to
   ! be transposed.
      a :: MAT{REAL}, IN
      v :: VEC{REAL}, IN
      fac :: REAL
      transpose_a :: BIN, optional
   end

   rotate_by(a) ::: get_from(VEC{INTRINSIC})
   ! Rotate self by matrix "a", treating self as a column vector
     self :: INOUT
     a :: MAT{REAL}, IN
   end

   translate_by(v) ::: get_from(VEC{INTRINSIC})
   ! Translate self by vector "v".
     self :: INOUT
     v :: VEC{REAL}, IN
   end

   seitz_multiply(seitz)
   ! Self is operated on by the seitz matrix.  Self must be in fractional
   !  coordinates.
     self :: INOUT
     seitz :: MAT{REAL}, IN
   ENSURE(size(seitz,1)==4,"seitz matrix must be 4x4")
   ENSURE(size(seitz,2)==4,"seitz matrix must be 4x4")
   ENSURE(.dim==3,"vector not of dimension 3")
     .rotate_by(seitz(1:3,1:3))
     .translate_by(seitz(4,1:3))
   end

   outer_product_with(v) result(res) ::: get_from(VEC{INTRINSIC})
   ! Returns the outer product of "self" with vector "v".
     self :: IN
     v :: VEC{REAL}, IN
     res :: MAT{REAL}(.dim,v.dim)
   end

   norm result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the norm of the vector
      self :: IN
      res :: REAL
   end

   normalise ::: get_from(VEC{INTRINSIC})
   ! Normalise the vector
      self :: INOUT
   end

   distance_to(a) result(res) ::: get_from(VEC{INTRINSIC})
   ! Return the distance to "a" if supplied
      a :: VEC{REAL}, IN
      res :: REAL
   end

   mean result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the mean of the vector
     self :: IN
     res :: REAL
   end

   variance result (res) ::: pure
   ! Return the variance of the vector from its mean
     self :: IN
     res :: REAL
     mean :: REAL
     mean = .mean
     res = (sum(self*self))/size(self)-mean*mean
   end

   standard_deviation result (res) ::: pure
   ! Return the standard deviation of the vector from its mean
     self :: IN
     res :: REAL
     variance :: REAL
     variance = .variance
     if (variance/=ZERO) res = sqrt(variance)
   end

   arcsinh result(res)
   ! Return the arcsinh of self, where self is a vector of any real numbers.
      self :: IN
      res :: VEC{REAL}(size(self))
      res = log(self + sqrt(ONE+self*self))
   end

!   integrate(a,b,accuracy) result(res) ::: recursive, functional
!   ! Integrate the vector valued scalar function "self" between the limits
!   ! "a" and "b" using adaptive trapezoidal rule with Simpsons approximation.
!   ! If present, "accuracy" is the required accuracy of the integral.
!      interface
!         self(x) result(res)
!             x :: REAL
!            res :: VEC{REAL}*
!         end
!      end
!      a,b :: REAL
!      accuracy :: REAL, optional
!      res :: VEC{REAL}*
!       n :: INT
!      same :: BIN
!      tol,h,m :: REAL
!      fa,fb,fm,one_trap,two_trap,left,right :: VEC{REAL},PTR
!      tol = TOL(6)
!      if (present(accuracy)) tol = accuracy
!      h  = b-a
!      m  = (a+b)/TWO
!      fa => self(a)
!      fb => self(b)
!      fm => self(m)
!      n = size(fa)
!      one_trap.create(n)
!      two_trap.create(n)
!      one_trap = h*(fa+fb)/TWO
!      two_trap = h*(fa+TWO*fm+fb)/FOUR
!      fm.destroy
!      fb.destroy
!      fa.destroy
!      res.create(n)
!      res = abs(one_trap-two_trap)
!      same = maxval(res) < THREE*tol
!      if (same) then
!         res = (FOUR*two_trap - one_trap)/THREE
!         two_trap.destroy
!         one_trap.destroy
!      else
!         two_trap.destroy
!         one_trap.destroy
!         left  => .integrate(a,m,tol/TWO)
!         right => .integrate(m,b,tol/TWO)
!         res = left + right
!         right.destroy
!         left.destroy
!      end
!   end

! ******************
! Min/max operations
! ******************

   chop_large_values(val) ::: get_from(VEC{INTRINSIC}), pure
   ! Set all values in the self whose absolute value is larger than "val" to
   ! "val" times the sign of the original value.
      self :: INOUT
      val :: REAL, IN
   end

   zero_small_values(eps) ::: get_from(VEC{INTRINSIC}), pure
   ! Zero elements of the vector which are less than "tol" in magnitude
      self :: INOUT
      eps :: REAL, optional, IN
   end

   largest_value result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the maximum absolute value in the vector
      self :: IN
      res :: REAL
   end

   smallest_value result (res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return minimum absolute value in the vector
      self :: IN
      res :: REAL
   end

   no_of_elements_larger_than(tol) result(res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the number of elements larger than "tol".
      self :: IN
      tol :: REAL, IN
      res :: INT
   end

! ****************
! Range operations
! ****************

   all_in_range(range) result(res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return TRUE if all values of self are within the specified "range".
      self :: IN
      range :: VEC{REAL}(2), IN
      res :: BIN
   end

   in_range(range) result(res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return element i as TRUE if self(i) is within the specified "range".
      self :: IN
      range :: VEC{REAL}(2), IN
      res :: VEC{BIN}(.dim)
   end

   range result(res) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the range (smallest and largest value) of self.
      self :: IN
      res :: VEC{REAL}(2)
   end

! **************************
! Index returning operations
! **************************

   index_of_maximum result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the index of the maximum in the vector
      self :: IN
      ind :: INT
   end

   index_of_minimum result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the index of the minimum in the vector
      self :: IN
      ind :: INT
   end

   index_of_largest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the index "ind" of the largest absolute value in the vector
      self :: IN
      ind :: INT
   end

   index_of_smallest_value result (ind) ::: get_from(VEC{INTRINSIC}), pure
   ! Return the index "ind" of the smallest value in the vector
      self :: IN
      ind :: INT
   end

   index_of_first_nonzero_value(eps) result(res) ::: pure
   ! Returns the index of the first nonzero component of self.
     self :: IN
     eps :: REAL, IN, optional
     res :: INT
     i :: INT
     res=0
     do i=1,size(self)
       if (NOT self(i).is_zero(eps)) then
         res=i
         exit
       end
     end
   end

   index_of_first_zero_value result(res)
   ! Returns the index of the first zero component of self.
     self :: IN
     res :: INT
     i :: INT
     res=0
     do i=1,size(self)
       if (self(i).is_zero) then
         res=i
         exit
       end
     end
   end

   index_of_value(val,eps) result(pos) ::: pure
   ! Returns the first index in "self" which has the value "val", or 0 if "val"
   ! is not present in the array. If present, "eps" is used to test equality
   ! with "val".
     self :: IN
     val :: REAL, IN
     eps :: REAL, optional, IN
     pos :: INT
     i :: INT
     pos = 0
     do i = 1,.dim
        if (self(i).same_as(val,eps)) then
           pos = i
           exit
        end
     end
   end

! *************************
! Find and match operations
! *************************

   find_opposite_pairs(pair,min,max)
   ! "pair(i)" returns the location of the element which has the opposite
   ! value to self(i) *and* is also negative, i.e. self(pair(i)) = -self(i) < 0.
   ! If no such match can be found, pair(i) is set to 0.
   ! unless self(i) is greater than max, in which case pair(i) is set to -1.
      pair :: VEC{INT}
      min,max :: REAL
      i,j :: INT
      pair = 0
      do i = 1,size(self)
         if      (abs(self(i))<min) then; pair(i) =  0
         else if (abs(self(i))>max) then
             if (self(i)<0)  pair(i) = -1
             if (self(i)>0)  pair(i) = -2
         else
            do j = 1,i-1
               if (any(pair==j)) cycle
               if (abs(self(j)+self(i))<min) then
                  if (self(i)>0) then; pair(i)=j
                  else;                pair(i)=0
                  end
               end
            end
         end
      end
   end

   find_pairs(pair,match_function,tol)
   ! Given a vector "self" find pairs of values self(i) and self(pair(i))
   ! where: match_function(self(i),self(pair(i))) = 0. If no such pair can be
   ! found, then pair(i) is set to 0. If more than one match is found then the
   ! first match from the start of the list is the one that is paired.
      pair :: VEC{INT}
      interface
   match_function(arg1,arg2) result (res)
      arg1,arg2,res :: REAL
         end
      end
      tol :: REAL, optional
      i,j,dim :: INT
      val :: REAL
      dim = size(self)
      pair = 0
      do i = 1,dim
      do j = 1,dim
         val = match_function(self(i),self(j))
         if (val.is_zero(tol) AND self(i)>self(j) AND NOT any(pair==j)) then
            pair(i) = j
            pair(j) = i
            exit
         end
      end
      end
   end

! *********************
! Conversion operations
! *********************

   convert_to(units)
   ! Convert the number "self" in atomic units or generic units to a
   ! new number in "units".
      self :: INOUT
      units :: STR, IN
   ENSURE(units.is_known_unit,"unknown units, " // units)
      factor :: REAL
      factor = units.conversion_factor
      self = self * factor
   end

   convert_from(units)
   ! Convert the number "self" from "units" system to a new number
   ! in atomic units or generic units.  Returns "err" whether it was successful.
      self :: INOUT
      units :: STR, IN
   ENSURE(units.is_known_unit,"unknown units, " // units)
      factor :: REAL
      factor = ONE/(units.conversion_factor)
      self = self * factor
   end

   to_str(format,separator) result(string)
   ! Change self to a "string" using default format.
     format :: STR, optional
     separator :: STR, optional
     string :: STR
     str1,str2 :: STR
     n :: INT
     string = " "
     do n = 1,size(self)
       str1 = self(n).to_str(format)
       ENSURE(len_trim(string) + len_trim(str1) < len(string), "string too long")
       if (present(separator)) then; str2 = trim(string) // separator // trim(str1)
       else;                         str2 = trim(string) //    " "    // trim(str1)
       end
       string = str2
     end
   end

! ***********************
! Spin-orbital operations
! ***********************

   alpha result(res) ::: get_from(VEC{INTRINSIC})
   ! return the alpha sector of the vector
      self :: target
      res :: VEC{REAL}*
   end

   beta result(res) ::: get_from(VEC{INTRINSIC})
   ! return the beta sector of the vector
      self :: target
      res :: VEC{REAL}*
   end

   alpha_set_to(X) ::: get_from(VEC{INTRINSIC})
   ! Set the alpha sector of the vector
      X :: VEC{REAL}
   end

   beta_set_to(X) ::: get_from(VEC{INTRINSIC})
   ! Set the beta sector of the vector
      X :: VEC{REAL}
   end

! *********************
! Root finding routines
! *********************

   bracket_root(z,direction,x1,x2,factor,val,max_it) ::: routinal
   ! Given a vector function self(z), an initial point "z" and a "direction",
   ! and initial distances "x1" and "x2" along "direction" from "z", bracket
   ! a root of self along "direction" by expansion. If "factor" is present it is
   ! used as the (linear) interval expansion factor. If "val" is present the
   ! values "x1" and "x2" will bracket the value x where self(x) = val.
   ! If "max_it" is present then it is the number of times the interval is
   ! expanded.
      interface
   self(z) result(res)
       z :: VEC{REAL}
      res :: REAL
         end
      end
      z,direction :: VEC{REAL}
      x1,x2  :: REAL
      factor,val :: REAL, optional
      max_it :: INT, optional
   ENSURE(x1/=x2,"non-zero range (x1,x2) required")
      j :: INT
      f1,f2 :: REAL
      fac :: REAL = 1.6d0
      iso :: REAL = 0.0d0
      maxit :: INT = 500
      if (present(factor)) fac = factor
      if (present(val))    iso = val
      if (present(max_it)) maxit = max_it
      if (x1>x2) x1.swap_with(x2)
      f1 = self(z + x1*direction) - iso
      f2 = self(z + x2*direction) - iso
      do j = 1,maxit
         if (f1*f2<ZERO) return
         if (abs(f1)<abs(f2)) then
            x1 = x1 + fac*(x1-x2)
            f1 = self(z + x1*direction) - iso
         else
            x2 = x2 + fac*(x2-x1)
            f2 = self(z + x2*direction) - iso
         end
      end
      DIE("Exceeded maximum number of iterations")
   end

   find_root_brent(z,direction,x1,x2,tol,root,val,max_it) ::: routinal
   ! Given a vector function self(x), an initial point "z", a "direction", and
   ! initial values "x1" and "x2" along this "direction" which bracket a root
   ! of self, return the "root" of self along "direction" to a precision "tol"
   ! using Brent's method. The point "z" is reset to be the vector point
   ! corresponding to this root. If "val" present, then root is set so that
   ! self(root) = val, i.e.  root is set top be an iso-value of self. If
   ! "max_it" is present it is set to the maximum number of iterations.
      interface
   self(z) result(res)
       z :: VEC{REAL}
      res :: REAL
         end
      end
      z,direction :: VEC{REAL}
      x1,x2,tol :: REAL
      root,val :: REAL, optional
      max_it :: INT, optional
      iter :: INT
      a,b,c,d,e,fa,fb,fc,p,q,r,s,tol1,xm :: REAL
      maxit :: INT = 100
      iso   :: REAL = ZERO
      eps   :: REAL = TOL(8)
      if (present(max_it)) maxit = max_it
      if (present(val))    iso = val
      a  = x1
      b  = x2
      fa = self(z + a*direction) - iso
      fb = self(z + b*direction) - iso
      ENSURE((fa>0 AND fb<0) OR (fa<0 AND fb>0),"root is not bracketed")
      c = b
      fc = fb
      do iter = 1,maxit
         if ((fb>0 AND fc>0) OR (fb<0 AND fc<0)) then
            c = a    ! Rename a,b,c and adjust bounding interval d
            fc = fa
            d = b - a
            e = d
         end
         if (abs(fc)<abs(fb)) then
            a  = b ; b  = c ; c  = a
            fa = fb; fb = fc; fc = fa
         end
         ! Test convergence
         tol1 = TWO*eps*abs(b)+HALF*tol
         xm = HALF*(c-b)
         if (abs(xm)<=tol1 OR fb==ZERO) then
            if (present(root)) root = b
            z = z + b*direction
            return
         end
         if (abs(e)>=tol1 AND abs(fa)>abs(fb)) then
            s = fb/fa ! Attempt inverse quadratic interpolation
            if (a==c) then
               p = TWO*xm*s
               q = ONE - s
            else
               q = fa/fc
               r = fb/fc
               p = s*(TWO*xm*q*(q-r)-(b-a)*(r-ONE))
               q = (q-ONE)*(r-ONE)*(s-ONE)
            end
            if (p>ZERO) q = -q
            p = abs(p)
            if (TWO*p<min(THREE*xm*q-abs(tol1*q),abs(e*q))) then
               e = d  ! Accept interpolation
               d = p/q
            else
               d = xm ! Interpolation failed, use bisection
               e = d
            end
         else
            d = xm    ! Bounds decreasing too slowly, use bisection
            e = d
         end
         a = b; fa = fb
         if (abs(d)> tol1) then; b = b + d
         else;                   b = b+sign(tol1,xm)
         end
         fb = self(z + b*direction) - iso
      end
      DIE("maximum iterations exceeded")
   end

   find_isopoint(z,direction,isovalue,tol,x1,x2) ::: routinal
   ! Given an initial point "z" and a "direction" to search along, return the
   ! isopoint "z" where the function "self" has value "isovalue", i.e. where
   ! self(p) = isovalue. "tol" is the accuracy to which "z" is determined.
   ! If present, "x1" and "x2" are an initial interval along "direction" from
   ! "p" where the isopoint is suspected to lie.
      z,direction :: VEC{REAL}
      interface
   self(z) result (res)
      z :: VEC{REAL}
      res :: REAL
         end
      end
      isovalue,tol :: REAL
      x1,x2 :: REAL, optional
      y1,y2 :: REAL
      y1 = ZERO; if (present(x1)) y1 = x1
      y2 = ONE;  if (present(x2)) y2 = x2
      .bracket_root(z,direction,y1,y2,val=isovalue)
      .find_root_brent(z,direction,y1,y2,tol,val=isovalue)
   end

! *********************
! Minimisation routines
! *********************

   minimise(new_direction,gradient,old_val,old_gradient,hessian)
   ! Move the vector "self" to a position closer to the minimum, based on the
   ! gradient.  Uses the BFGS scheme.  Doesn't check for convergence, just does
   ! one iteration.
     new_direction :: VEC{REAL}, OUT
     gradient :: VEC{REAL}, IN
     old_val, old_gradient :: VEC{REAL}, INOUT
     hessian :: MAT{REAL}, INOUT
   ENSURE(.dim==new_direction.dim, "vector size mismatch")
   ENSURE(.dim==gradient.dim, "vector size mismatch")
   ENSURE(.dim==old_val.dim, "vector size mismatch")
   ENSURE(.dim==old_gradient.dim, "vector size mismatch")
   ENSURE(.dim==hessian.dim1, "incorrect dimension for hessian matrix")
   ENSURE(.dim==hessian.dim2, "incorrect dimension for hessian matrix")
     dx,dg,hdg,u :: VEC{REAL}*
     dxdg,dghdg,dghdg_inv :: REAL
     dim :: INT
     dim = .dim
     dx.create(dim); dg.create(dim); hdg.create(dim); u.create(dim)
     dg = gradient - old_gradient
     dx = self - old_val
     hdg.to_product_of(hessian,dg)
     dxdg = ONE / dot_product(dx,dg)
     dghdg = dot_product(dg,hdg)
     dghdg_inv = ONE / dghdg
     u  = dxdg * dx - dghdg_inv * hdg
     hessian = hessian &
             + dxdg * dx.outer_product_with(dx) &
             - dghdg_inv * hdg.outer_product_with(hdg) &
             + dghdg * u.outer_product_with(u)
     dx.to_product_of(hessian,gradient)
     old_val = self
     old_gradient = gradient
     new_direction = - dx
     dx.destroy; dg.destroy; hdg.destroy; u.destroy
   end

   minimise_BFGS(dself,p,fret,tol,gtol,step,max_it) ::: routinal, public
   ! Use the Broyden-Fletcher-Goldfarb-Shanno method to minimise a vector
   ! function self(p) with derivative function dself(p) starting from
   ! an initial point "p", returning the minimum point in "p", to a
   ! tolerance "gtol" in the gradient. If "step" is present it determines
   ! the size of the initial step in the line minimisation along the
   ! gradient direction. If "max_it" is present, set that to be the
   ! maximum iterations
      interface
   self(p) result(res)
       p :: VEC{REAL}
      res :: REAL
         end
      end
      interface
   dself(p) result(res)
       p :: VEC{REAL}
      res :: VEC{REAL}(size(p))
         end
      end
      p :: VEC{REAL}
      fret,tol,gtol :: REAL, IN
      step :: REAL, optional
      max_it :: INT, optional, IN
      n,iter,i,itmax :: INT
      fac,fad,fae,fp,sumdg,sumxi,eps, stp,this_stp :: REAL
      g,dg,hdg,pnew,xi :: VEC{REAL}*
      hessian :: MAT{REAL}, PTR
      fail :: BIN
      eps = tol/FOUR
      stp = ONE
      if (present(step)) stp = step
      itmax = 200
      if (present(max_it)) itmax = max_it
      n = size(p)
      g.create(n)
      dg.create(n)
      hdg.create(n)
      pnew.create(n)
      xi.create(n)
      allocate(hessian(n,n))
      fp = self(p)
      g = dself(p)
      hessian = ZERO
      do i = 1,n
         hessian(i,i) = ONE
      end
      xi = -g
      iter = 0
      fail = FALSE
      do
         iter = iter + 1
         pnew = p
         xi = (stp/xi.norm) * xi ! This is new
         .line_minimise_from(pnew,xi,fret,tol,fp,this_stp)
         stp = stp*sqrt(abs(this_stp))
         fp = fret
         xi = pnew - p
         p = pnew
         if (xi.largest_value<tol) exit
         dg = g
         g = dself(p)
         if (g.largest_value<gtol) exit
         dg = g - dg
         hdg.to_product_of(hessian,dg)
         fac = sum(dg*xi)
         fae = sum(dg*hdg)
         sumdg = sum(dg*dg)
         sumxi = sum(xi*xi)
         if (fac**2>eps*sumdg*sumxi) then
            fac = ONE/fac
            fad = ONE/fae
            dg = fac*xi - fad*hdg
            hessian = hessian + fac * xi.outer_product_with(xi)   &
                              - fad * hdg.outer_product_with(hdg) &
                              + fae * dg.outer_product_with(dg)
            xi.minus_product_of(hessian,g)
         end
         if (i > itmax) fail = TRUE
      end
      DIE_IF(fail,"exceeded allowed iterations")
      deallocate(hessian)
      xi.destroy
      pnew.destroy
      hdg.destroy
      dg.destroy
      g.destroy
   end

   minimise_FRPR(dself,p,fret,tol,ftol,algorithm,step) ::: routinal
   ! Use the Fletcher-Reeves-Polak-Ribiere method to minimise a vector
   ! function self(p) with derivative function dself(p) starting from
   ! an initial point "p", returning the minimum point in "p", to a
   ! tolerance "tol" and the minimum function value in "fret" to a
   ! tolerance "ftol". "algorithm" (if present) can be set to
   ! "Polak-Ribiere" (default) or "Fletcher-Reeves".
      interface
   self(p) result(res)
      p :: VEC{REAL}
      res :: REAL
         end
      end
      interface
   dself(p) result(res)
      p :: VEC{REAL}
      res :: VEC{REAL}(size(p))
         end
      end
      p :: VEC{REAL}
      fret,tol,ftol :: REAL
      step :: REAL, optional
      algorithm :: STR, optional
      itmax :: INT = 200
      n,iter :: INT
!      eps :: REAL = TOL(10)
      stp,this_stp,dgg,fp,gam,gg,dtol :: REAL
      g,h,xi :: VEC{REAL}*
      alg :: STR
      fail :: BIN
      alg = "Polak-Ribiere"
      if (present(algorithm)) alg = algorithm
      stp = ONE
      if (present(step)) stp = step
      n = size(p)
      g.create(n)
      h.create(n)
      xi.create(n)
      fp = self(p)
      fret = fp
      xi = dself(p)
      g = -xi
      h = g
      xi = h
      iter = 0
      fail = FALSE
      do
         iter = iter + 1
         dtol = xi.largest_value
         if (dtol<tol) exit
         xi = (stp/xi.norm) * xi ! This is new
         .line_minimise_from(p,xi,fret,tol,fp,this_stp)
         stp = stp*sqrt(abs(this_stp))
       ! if (TWO*abs(fret-fp)<=ftol*(abs(fret)+abs(fp)+eps)) exit
         if (abs(fret-fp)<=ftol AND dtol<tol) exit
         fail = iter>=itmax
         if (fail) exit
       ! fp = self(p)
         fp = fret
         xi = dself(p)
         gg = ZERO
         dgg = ZERO
         gg = sum(g*g)
         select case (alg)
            case("Polak-Ribiere  "); dgg = sum((xi+g)*xi)
            case("Fletcher-Reeves"); dgg = sum(xi*xi)
            case default;        UNKNOWN(alg)
         end
         if (gg==ZERO) exit
         gam = dgg/gg
         g = -xi
         h = g + gam*h
         xi = h
      end
      DIE_IF(fail,"exceeded allowed iterations")
      xi.destroy
      h.destroy
      g.destroy
   end

   minimise_powell(p,directions,fret,tol,ftol) ::: routinal
   ! Use Powell's method to minimise a vector function self(p) starting from
   ! an initial point "p" along the initial (columns of) "directions", returning
   ! the minimum point in "p", the minimum function value in "fret" to a
   ! tolerance "ftol", and "tol" in the vector coordinates "p".
      interface
   self(p) result(res)
       p :: VEC{REAL}
      res :: REAL
         end
      end
      p :: VEC{REAL}
      directions :: MAT{REAL}
      fret,tol,ftol :: REAL
   ENSURE(size(p)==size(directions,1),"incompatible initial data")
   ENSURE(size(p)==size(directions,2),"incompatible initial data")
      itmax :: INT = 200
      n,iter,i,ibig :: INT
      del,fp,fptt,t :: REAL
      pt,ptt,xit :: VEC{REAL}*
      fail :: BIN
      n = size(p)
      pt.create(n)
      ptt.create(n)
      xit.create(n)
      fret = self(p)
      pt = p                                    ! Save initial point
      iter = 0
      fail = FALSE
      do                                        ! Iteration loop
         iter = iter + 1
         fp = fret
         ibig = 0
         del = 0
         do i = 1,n                             ! Loop over all directions in set
            xit = directions(:,i)               ! Get direction
            fptt = fret
            .line_minimise_from(p,xit,fret,tol) ! Minimize along direction
            if (abs(fptt-fret)>del) then        ! Save if largest decrease so far
               del = abs(fptt-fret)
               ibig = i
            end
         end
         if (TWO*abs(fp-fret)<=ftol*(abs(fp)+abs(fret))) exit
         fail = iter>=itmax
         if (fail) exit
         ptt = TWO*p - pt                       ! Construct extrapolated point and the
         xit = p - pt                           ! average direction moved; save old
         pt = p                                 ! starting point
         fptt = self(ptt)
         if (fptt>=fp) cycle
         t = TWO*(fp-TWO*fret+fptt)*(fp-fret-del)**2-del*(fp-fptt)**2
         if (t>=0) cycle
         .line_minimise_from(p,xit,fret,tol)    ! Move to minimum of the new direction
         directions(:,ibig) = directions(:,n)
         directions(:,n) = xit
      end
      DIE_IF(fail,"exceeded allowed iterations")
      xit.destroy
      ptt.destroy
      pt.destroy
   end

   line_minimise_from(p,direction,fret,tol,f0,del) ::: routinal
   ! Given a vector function self(x), minimise from point "p" along "direction".
   ! Return the minimum point in "p" and the minimum value "fret", with an
   ! accuracy "tol". If "f0" is present it is used as the value of the function
   ! "self" at p, f0 = self(p). If "del" is present it is set to the length
   ! along "direction" where p achieved its minimum, useful for monitoring the
   ! step size.
      interface
   self(p) result(res)
      p :: VEC{REAL}
      res :: REAL
         end
      end
      p,direction :: VEC{REAL}
      fret,tol :: REAL
      f0,del :: REAL, optional
      a,x,b,fa,fx,fb,xmin :: REAL
      a = ZERO
      x = ONE
      .bracket_minimum(p,direction,a,x,b,fa,fx,fb,f0)
      .minimise_brent(p,direction,a,x,b,xmin,fret,tol,fx)
      if (present(del)) del = xmin
   end

   bracket_minimum(p,direction,a,b,c,fa,fb,fc,fa0,fb0) ::: routinal
   ! Given a vector function self(p), an initial point "p" and a "direction",
   ! and initial distances "a" and "b" along "direction" from "p", search in
   ! the downhill direction and return new distances "a", "b" and "c" along
   ! "direction" from "p" that bracket a minimum of the function self, and
   ! return the values of the function "fa", "fb", and "fc" at these points.
   ! NOTE: "c" is not used initially.
   ! If present, "fa0" is the initial value of self at a, fa0 = self(a).
   ! If present, "fb0" is the initial value of self at b, fb0 = self(b).
      interface
   self(p) result(res)
       p :: VEC{REAL}
      res :: REAL
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,fa,fb,fc :: REAL
      fa0,fb0 :: REAL, optional
   ENSURE(size(p)==size(direction),"incompatible vectors")
      gold :: REAL = 1.618034
      glimit :: REAL = 100
      tiny :: REAL = 1.0d-20
      fu,q,r,u,ulim :: REAL
      iter :: INT
      fail :: BIN
      if (present(fa0)) then; fa = fa0
      else;                   fa = self(p + a*direction)
      end
      if (present(fb0)) then; fb = fb0
      else;                   fb = self(p + b*direction)
      end
      if (fb>fa) then
        a.swap_with(b)
        fa.swap_with(fb)
      end
      c  = b + gold*(b-a)
      fc = self(p + c*direction)
      fail = TRUE
      do iter = 1, 100
         if (fb<fc) then
           fail = FALSE
           exit                           ! bracket found
         end
         r = (b-a)*(fb-fc)                ! get u by parabolic extrapolation
         q = (b-c)*(fb-fa)
         u = b - ((b-c)*q-(b-a)*r)/(TWO*sign(max(abs(q-r),tiny),q-r))
         ulim = b + glimit*(c-b)
         if ((b-u)*(u-c)>ZERO) then       ! Parabolic u lies between b and c
            fu = self(p + u*direction)
            if (fu<fc) then               ! got a minimum between b and c
               a = b; fa = fb
               b = u; fb = fu
               fail = FALSE
               exit
            else if (fu>fb) then          ! got a minimum between a and u
               c = u; fc = fu
               fail = FALSE
               exit
            end
            u = c + gold*(c-b)            ! parabolic fit no use, so magnify
            fu = self(p + u*direction)
         else if ((c-u)*(u-ulim)>0) then ! Fit is between c and its allowed limit
            fu = self(p + u*direction)
            if (fu<fc) then
               b = c; fb = fc
               c = u; fc = fu
               u = c + gold*(c-b)
               fu = self(p + u*direction)
            end
         else if ((u-ulim)*(ulim-c)>0) then
            u = ulim
            fu = self(p + u*direction)
         else
            u = c + gold*(c-b)            ! magnify
            fu = self(p + u*direction)
         end
         a = b; fa = fb
         b = c; fb = fc
         c = u; fc = fu
      end
      WARN_IF(fail, "exceeded maximum iterations")
      if (a>c) then
         a.swap_with(c)
         fa.swap_with(fc)
      end
   end

   minimise_golden(p,direction,a,b,c,xmin,f,tol) ::: routinal
   ! Given a vector function self(p), an initial point "p" and a "direction",
   ! and initial distances "a", "b" and "c" along "direction" from "p" which
   ! bracket a minimum in function self, return the minimum point "p" and its
   ! distance "xmin" along the "direction" from "p", and also the value "f" at
   ! the minimum to a precision "tol", using the golden section search method.
      interface
   self(p) result(res)
       p :: VEC{REAL}
      res :: REAL
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,xmin,f,tol :: REAL
   ENSURE(size(p)==size(direction),"incompatible vectors")
       r :: REAL = 0.618033399
      s,f1,f2,x0,x1,x2,x3 :: REAL
      s = ONE - r
      x0 = a
      x3 = c
      if (abs(c-b)>abs(b-a)) then
         x1 = b; x2 = b + s*(c-b)
      else
         x2 = b; x1 = b - s*(b-a)
      end
      f1 = self(p + x1*direction)
      f2 = self(p + x2*direction)
      do
         if (abs(x3-x0)<=tol*(abs(x1)+abs(x2))) exit
         if (f2<f1) then
            x0 = x1
            x1 = x2
            x2 = r*x1 + s*x3
            f1 = f2
            f2 = self(p + x2*direction)
         else
            x3 = x2
            x2 = x1
            x1 = r*x2 + s*x0
            f2 = f1
            f1 = self(p + x1*direction)
         end
      end
      if (f1<f2) then; f = f1; xmin = x1; p = p + x1*direction
      else;            f = f2; xmin = x2; p = p + x2*direction
      end
   end

   minimise_brent(p,direction,a,b,c,xmin,f,tol,fb_in) ::: routinal
   ! Given a vector function self(x), an initial point "p", a "direction", and
   ! initial distances "a", "b" and "c" along "direction" from "p" which
   ! bracket a minimum in function self, return the minimum point "p" and its
   ! distance "xmin" along the "direction" from "p", and also the value "f" at
   ! the minimum to a precision "tol", using Brent's search method.
      interface
   self(p) result(res)
       p :: VEC{REAL}
      res :: REAL
         end
      end
      p,direction :: VEC{REAL}
      a,b,c,xmin,f,tol :: REAL
      fb_in :: REAL, IN, optional
   ENSURE(size(p)==size(direction),"incompatible vectors")
      itmax :: INT = 100
      cgold :: REAL = 0.3819660d0
      zeps :: REAL = TOL(10)
      d,e,etemp,fu,fv,fw,fx,pp,qq,r,tol1,tol2,u,v,w,x,xm :: REAL
      iter,iters :: INT
      fail :: BIN
      if (a>c) a.swap_with(c)
      v = b
      w = b
      x = b
      if (present(fb_in)) then
        fx = fb_in
      else
        fx = self(p + x*direction)
      end
      fv = fx
      fw = fx
      e = ZERO
      fail = TRUE
      b = c
      iters=0
      do iter = 1,itmax
         xm = HALF*(a+b)
         tol1 = tol*abs(x) + zeps
         tol2 = TWO*tol1
         if (abs(x-xm)<(tol2-HALF*(b-a))) then
            fail = FALSE
            exit
         end
         if (abs(e)>tol1) then
            r = (x-w)*(fx-fv)
            qq = (x-v)*(fx-fw)
            pp = (x-v)*qq - (x-w)*r
            qq = TWO*(qq-r)
            if (qq>ZERO) pp = -pp
            qq = abs(qq)
            etemp = e
            e = d
            if (abs(pp)>=abs(HALF*qq*etemp) OR pp<=qq*(a-x) OR pp>=qq*(b-x)) then
              if (x>=xm) then; e = a-x
              else;            e = b-x
              end
              d = cgold*e
            else
              d = pp/qq
              u = x + d
              if ((u-a)<tol2 OR (b-u)<tol2) d = sign(tol1,xm-x)
            end
         else
           if (x>=xm) then; e = a-x
           else;            e = b-x
           end
           d = cgold*e
         end
         if (abs(d)>=tol1) then; u = x + d
         else;                   u = x + sign(tol1,d)
         end
         fu = self(p + u*direction)
         if (fu<=fx) then
            if (u>=x) then; a = x
            else;           b = x
            end
            v = w; fv = fw
            w = x; fw = fx
            x = u; fx = fu
         else
            if (u<x) then; a = u
            else;          b = u
            end
            if (fu<=fw OR w==x) then
               v = w; fv = fw
               w = u; fw = fu
            else if (fu<=fv OR v==x OR v==w) then
               v = u; fv = fu
            end
         end
         iters=iters+1
      end
      DIE_IF(fail,"maximum iterations exceeded")
      f = fx
      xmin = x
      p = p + x*direction
   end

! **********
! Misc stuff
! **********

   normalising_factors(l) ::: pure
   ! Return the normalising factors for cartesian gaussian basis functions used
   ! in quantum chemical calculations.
     l :: INT, IN
     self :: OUT
   ENSURE(l>=1,"l must be positive")
   ENSURE(.dim==(l+1)*(l+2)/2,"wrong size, self")
     xyz_momenta :: MAT{INT}, allocatable
     fac :: REAL
     i,ncomp :: INT
     if (l<2) then
       self = ONE
     else if (l==2) then
       self(1)=ONE
       self(2)=ONE
       self(3)=ONE
       self(4)=sqrt(THREE)
       self(5)=sqrt(THREE)
       self(6)=sqrt(THREE)
     else
       ncomp=l.n_comp
       allocate(xyz_momenta(3,ncomp))
       l.make_gaussian_xyz_powers(xyz_momenta)
       do i=1,ncomp
         fac = l.double_factorial / &
               (xyz_momenta(1,i).double_factorial   &
               *xyz_momenta(2,i).double_factorial   &
               *xyz_momenta(3,i).double_factorial)
         self(i)=sqrt(fac)
       end
       deallocate(xyz_momenta)
     end
   end

   make_R_harmonics(Rc,Rs,point,l_max) ::: selfless, leaky
   ! Make the scaled regular solid harmonics "Rc" and "Rs" evaluated at a single
   ! "point" in space, up to angular momentum "l_max". The particular solid
   ! harmonic for quantum numbers "L" and "M" is, e.g. Rc(L).element(M) for the
   ! given "point". See the book by Helgaker, Olsen, and Simons, p. 416. 
   ! NOTE: "Rc" and "Rs" are created.
   ! NOTE: this routine is here because VEC{REAL} cannot use VEC{VEC_{REAL}}
      Rc,Rs :: VEC{VEC_{REAL}}*
      point :: VEC{REAL}(3)
      l_max :: INT
   ENSURE(l_max>=0,"l_max must be non-negative")
      L,M,sn :: INT
      top,bot,fac, r2,x,y,z :: REAL
      allocate(Rc(0:l_max))
      allocate(Rs(0:l_max))
      do L = 0,l_max
         allocate(Rc(L)[-L:L])
         allocate(Rs(L)[-L:L])
      end
      Rc(0)[0] = ONE
      Rs(0)[0] = ZERO
      x = point(1); y = point(2); z = point(3)
      r2 = x*x + y*y + z*z
      do L = 0,l_max-1
         bot = 2*L + 2
         top = bot - 1
         fac = ONE/bot
         Rc(L+1)[L+1] = -fac*(x*Rc(L)[L] - y*Rs(L)[L])
         Rs(L+1)[L+1] = -fac*(y*Rc(L)[L] + x*Rs(L)[L])
         Rc(L+1)[L  ] = z*Rc(L)[L]
         Rs(L+1)[L  ] = z*Rs(L)[L]
         do M = 0,L-1
            bot = ONE/((L+M+1)*(L-M+1))
            fac = top*bot
            Rc(L+1)[M] = fac*z*Rc(L)[M] - bot*r2*Rc(L-1)[M]
            Rs(L+1)[M] = fac*z*Rs(L)[M] - bot*r2*Rs(L-1)[M]
         end
         sn = 1
         do M = 1,L+1
            sn = -sn ! this is (-1)**M
            Rc(L+1)[-M] =  sn * Rc(L+1)[M]
            Rs(L+1)[-M] = -sn * Rs(L+1)[M]
         end
      end
   end

   make_R_harmonics(Rc,Rs,points,l_max) ::: selfless, leaky
   ! Make the scaled regular solid harmonics "Rc" and "Rs" evaluated at a set of
   ! "points" in space, up to angular momentum "l_max". The particular solid
   ! harmonic for quantum numbers "L" and "M" evaluated at point "points(i,:)
   ! is, e.g.  Rc(L).element(M).element(i). See the book by Helgaker, Olsen, and
   ! Simons, p. 416. 
   ! NOTE: "Rc" and Rs are created.
   ! NOTE: this routine is here since VEC{REAL} cannot use VEC{VEC_{VEC_{REAL}}}
      Rc,Rs :: VEC{VEC_{VEC_{REAL}}}*
      points :: MAT{REAL}, target
      l_max :: INT
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")
      r2,x,y,z :: VEC{REAL}*
      L,M,sn :: INT
      top,bot,fac :: REAL
      allocate(Rc(0:l_max))
      allocate(Rs(0:l_max))
      do L = 0,l_max
         allocate(Rc(L)[-L:L])
         allocate(Rs(L)[-L:L])
         do M = -L,L
            allocate(Rc(L)[M][points.dim1])
            allocate(Rs(L)[M][points.dim1])
         end
      end
      Rc(0)[0][:] = ONE
      Rs(0)[0][:] = ZERO
      r2.create(points.dim)
      x => points(:,1); y => points(:,2); z => points(:,3)
      r2 = x*x + y*y + z*z
      do L = 0,l_max-1
         bot = 2*L + 2
         top = bot - 1
         fac = ONE/bot
         Rc(L+1)[L+1][:] = -fac*(x*Rc(L)[L][:] - y*Rs(L)[L][:])
         Rs(L+1)[L+1][:] = -fac*(y*Rc(L)[L][:] + x*Rs(L)[L][:])
         Rc(L+1)[L  ][:] = z*Rc(L)[L][:] 
         Rs(L+1)[L  ][:] = z*Rs(L)[L][:] 
         do M = 0,L-1
            bot = ONE/((L+M+1)*(L-M+1))
            fac = top*bot
            Rc(L+1)[M][:] = fac*z*Rc(L)[M][:] - bot*r2*Rc(L-1)[M][:]
            Rs(L+1)[M][:] = fac*z*Rs(L)[M][:] - bot*r2*Rs(L-1)[M][:]
         end
         sn = 1
         do M = 1,L+1
            sn = -sn ! this is (-1)**M
            Rc(L+1)[-M][:] =  sn * Rc(L+1)[M][:]
            Rs(L+1)[-M][:] = -sn * Rs(L+1)[M][:]
         end
      end
      r2.destroy
   end

   make_R_multipoles(qc,qs,charges,points,l_max) ::: selfless, leaky
   ! Make the scaled regular solid harmonic multipole moments "qc" and "qs" for
   ! a given set of "charges" located at a set of "points", up to a maximum
   ! angular momentum "l_max".  Reference: the book by Helgaker, Olsen, and
   ! Simons, p. 414. NOTE: "qc" and "qs" are created.
      qc,qs :: VEC{REAL}*
      charges :: VEC{REAL}, target
      points :: MAT{REAL}, target
      l_max :: INT
   ENSURE(charges.dim==points.dim1,"inconsistent charges and points arrays")
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")
      Rc,Rs :: VEC{VEC_{VEC_{REAL}}}*
      L,M,n,lm :: INT
      n = l_max.n_comp
      qc.create(n)
      qs.create(n)
      VEC{REAL}:make_R_harmonics(Rc,Rs,points,l_max)
      lm = 0
      do L = 0,l_max
         do M = 0,L
            lm = lm + 1
            qc(lm) = sum(charges * Rc(L)[M][:])
            qs(lm) = sum(charges * Rs(L)[M][:])
         end
      end
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Rs(L)[M].element)
            deallocate(Rc(L)[M].element)
         end
         deallocate(Rs(L).element)
         deallocate(Rc(L).element)
      end
      deallocate(Rs)
      deallocate(Rc)
   end

   make_R_mu_harmonics(Rm,points,l_max) ::: selfless, leaky
   ! Make scaled regular mu-type solid harmonics "Rm" evaluated at set of
   ! "points" in space, up to angular momentum "l_max". The particular solid
   ! harmonic is, e.g. Rm(L).element(M).element(i) where "L" and "M" are the
   ! angular quantum numbers and "i" is the point number. See the book by
   ! Helgaker, Olsen, and Simons, p. 412 and p. 416. NOTE: "Rm" are created.
      Rm :: VEC{VEC_{VEC_{REAL}}}*
      points :: MAT{REAL}, IN
      l_max :: INT, IN
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")
      L,M :: INT
      Rc,Rs :: VEC{VEC_{VEC_{REAL}}}*
      allocate(Rm(0:l_max))
      do L = 0,l_max
         allocate(Rm(L)[-L:L])
         do M = -L,L
            allocate(Rm(L)[M][points.dim1])
         end
      end
      VEC{REAL}:make_R_harmonics(Rc,Rs,points,l_max) 
      do L = 0,l_max
         do M = 0,L
            Rm(L)[M][:] = Rc(L)[M][:]
         end
         do M = -L,-1
            Rm(L)[M][:] = Rs(L)[M][:]
         end
      end
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Rs(L)[M].element)
            deallocate(Rc(L)[M].element)
         end
         deallocate(Rs(L).element)
         deallocate(Rc(L).element)
      end
      deallocate(Rs)
      deallocate(Rc)
   end

   make_R_mu_multipoles(q,charges,points,l_max) ::: selfless
   ! Make the scaled regular mu-type solid harmonic multipole moments "q" for a
   ! given set of "charges" located at a set of "points", up to a maximum
   ! angular momentum "l_max".  Reference: the book by Helgaker, Olsen, and
   ! Simons, p. 414. 
      q :: VEC{REAL}, OUT
      charges :: VEC{REAL}, IN
      points :: MAT{REAL}, IN
      l_max :: INT
   ENSURE(q.dim==(l_max+1)*(l_max+1),"wrong size for q")
   ENSURE(charges.dim==points.dim1,"inconsistent charges and points arrays")
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")
      Rm :: VEC{VEC_{VEC_{REAL}}}*
      L,M,lm :: INT
      VEC{REAL}:make_R_mu_harmonics(Rm,points,l_max)
      lm = 0
      do L = 0,l_max
         do M = -L,L ! note the canonoical order here
            lm = lm + 1
            q(lm) = sum(charges * Rm(L)[M][:])
         end
      end
  ! write(*,*) "Rm(1)( 1)=",Rm(1)[1][:]
  ! write(*,*) "Rm(1)(-1)=",Rm(1)[-1][:]
  ! write(*,*) "Rm(1)( 0)=",Rm(1)[0][:]
  ! write(*,*) "q(1)( 1)=",sum(charges*Rm(1)[1][:])
  ! write(*,*) "q(1)(-1)=",sum(charges*Rm(1)[-1][:])
  ! write(*,*) "q(1)( 0)=",sum(charges*Rm(1)[0][:])
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Rm(L)[M].element)
         end
         deallocate(Rm(L).element)
      end
      deallocate(Rm)
   end

   add_R_mu_multipoles(q,charges,points,l_max) ::: selfless
   ! Add the scaled regular mu-type solid harmonic multipole moments "q" for a
   ! given set of "charges" located at a set of "points", up to a maximum
   ! angular momentum "l_max".  Reference: the book by Helgaker, Olsen, and
   ! Simons, p. 414. 
      q :: VEC{REAL}, OUT
      charges :: VEC{REAL}, IN
      points :: MAT{REAL}, IN
      l_max :: INT
   ENSURE(q.dim==(l_max+1)*(l_max+1),"wrong size for q")
   ENSURE(charges.dim==points.dim1,"inconsistent charges and points arrays")
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")
      Rm :: VEC{VEC_{VEC_{REAL}}}*
      L,M,lm :: INT
      VEC{REAL}:make_R_mu_harmonics(Rm,points,l_max)
      lm = 0
      do L = 0,l_max
         do M = -L,L ! note the canonoical order here
            lm = lm + 1
            q(lm) = q(lm) + sum(charges * Rm(L)[M][:])
         end
      end
  ! write(*,*) "Rm(1)( 1)=",Rm(1)[1][:]
  ! write(*,*) "Rm(1)(-1)=",Rm(1)[-1][:]
  ! write(*,*) "Rm(1)( 0)=",Rm(1)[0][:]
  ! write(*,*) "q(1)( 1)=",sum(charges*Rm(1)[1][:])
  ! write(*,*) "q(1)(-1)=",sum(charges*Rm(1)[-1][:])
  ! write(*,*) "q(1)( 0)=",sum(charges*Rm(1)[0][:])
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Rm(L)[M].element)
         end
         deallocate(Rm(L).element)
      end
      deallocate(Rm)
   end

   make_I_harmonics(Ic,Is,point,l_max) ::: selfless, leaky
   ! Make the scaled irregular solid harmonics "Ic" and "Is" evaluated at a
   ! single "point" in space, up to angular momentum "l_max". The particular
   ! solid harmonic for quantum numbers "L" and "M" is, e.g. Ic(L).element(M)
   ! for the given "point". See the book by Helgaker, Olsen, and Simons, p. 416.
   ! NOTE: "Ic" and "Is" are created.
   ! NOTE: this routine is here since VEC{REAL} cannot use VEC{VEC_{REAL}}
      Ic,Is :: VEC{VEC_{REAL}}*
      point :: VEC{REAL}(3)
      l_max :: INT
   ENSURE(l_max>=0,"l_max must be non-negative")
      L,M,sn :: INT
      top,fac, r2,x,y,z :: REAL
      allocate(Ic(0:l_max))
      allocate(Is(0:l_max))
      do L = 0,l_max
         allocate(Ic(L)[-L:L])
         allocate(Is(L)[-L:L])
      end
      x = point(1); y = point(2); z = point(3)
      r2 = ONE/(x*x + y*y + z*z)
      Ic(0)[0] = sqrt(r2)
      Is(0)[0] = ZERO
      do L = 0,l_max-1
         fac = 2*L + 1
         Ic(L+1)[L+1] = -fac*r2*(x*Ic(L)[L] - y*Is(L)[L])
         Is(L+1)[L+1] = -fac*r2*(y*Ic(L)[L] + x*Is(L)[L])
         Ic(L+1)[L  ] =  fac*z*r2*Ic(L)[L]
         Is(L+1)[L  ] =  fac*z*r2*Is(L)[L]
         do M = 0,L-1
            top = L*L - M*M
            Ic(L+1)[M] = r2*(fac*z*Ic(L)[M] - top*Ic(L-1)[M])
            Is(L+1)[M] = r2*(fac*z*Is(L)[M] - top*Is(L-1)[M])
         end
         sn = 1
         do M = 1,L+1
            sn = -sn ! this is (-1)**M
            Ic(L+1)[-M] =  sn * Ic(L+1)[M]
            Is(L+1)[-M] = -sn * Is(L+1)[M]
         end
      end
   end

   make_I_harmonics(Ic,Is,points,l_max) ::: selfless, leaky
   ! Make the scaled irregular solid harmonics "Ic" and "Is" evaluated at set of
   ! "points" in space, up to maximum angular momentum "l_max".  The particular
   ! solid harmonic for quantum numbers "L" and "M" evaluated at point
   ! "points(i,:)" is, e.g. "Ic(L).element(M).element(i)".  See the book by
   ! Helgaker, Olsen, and Simons, p. 416. 
   ! NOTE: "Ic" and "Is" are created.
   ! NOTE: this routine is here since VEC{REAL} cannot use VEC{VEC_{VEC_{REAL}}}
      Ic,Is :: VEC{VEC_{VEC_{REAL}}}*
      points :: MAT{REAL}, target
      l_max :: INT
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")
      r2,x,y,z :: VEC{REAL}*
      L,M,sn :: INT
      top,fac :: REAL
      allocate(Ic(0:l_max))
      allocate(Is(0:l_max))
      do L = 0,l_max
         allocate(Ic(L)[-L:L])
         allocate(Is(L)[-L:L])
         do M = -L,L
            allocate(Ic(L)[M][points.dim1])
            allocate(Is(L)[M][points.dim1])
         end
      end
      r2.create(points.dim)
      x => points(:,1); y => points(:,2); z => points(:,3)
      r2 = ONE/(x*x + y*y + z*z)
      Ic(0)[0][:] = sqrt(r2)
      Is(0)[0][:] = ZERO
      do L = 0,l_max-1
         fac = 2*L + 1
         Ic(L+1)[L+1][:] = -fac*r2*(x*Ic(L)[L][:] - y*Is(L)[L][:])
         Is(L+1)[L+1][:] = -fac*r2*(y*Ic(L)[L][:] + x*Is(L)[L][:])
         Ic(L+1)[L  ][:] =  fac*z*r2*Ic(L)[L][:] 
         Is(L+1)[L  ][:] =  fac*z*r2*Is(L)[L][:] 
         do M = 0,L-1
            top = L*L - M*M
            Ic(L+1)[M][:] = r2*(fac*z*Ic(L)[M][:] - top*Ic(L-1)[M][:])
            Is(L+1)[M][:] = r2*(fac*z*Is(L)[M][:] - top*Is(L-1)[M][:])
         end
         sn = 1
         do M = 1,L+1
            sn = -sn ! this is (-1)**M
            Ic(L+1)[-M][:] =  sn * Ic(L+1)[M][:]
            Is(L+1)[-M][:] = -sn * Is(L+1)[M][:]
         end
      end
      r2.destroy
   end

   make_I_mu_harmonics(Im,points,l_max) ::: selfless, leaky
   ! Make scaled irregular mu-type solid harmonics "Im" evaluated at set of
   ! "points" in space, up to angular momentum "l_max". The particular solid
   ! harmonic is, e.g. Im(L).element(M).element(i) where "L" and "M" are the
   ! angular quantum numbers and "i" is the point number. See the book by
   ! Helgaker, Olsen, and Simons, p. 412 and p. 416. NOTE: "Rm" are created.
      Im :: VEC{VEC_{VEC_{REAL}}}*
      points :: MAT{REAL}, target
      l_max :: INT
   ENSURE(points.dim2==3,"wrong 2nd dimension, points arrays")
   ENSURE(l_max>=0,"l_max must be non-negative")
      L,M :: INT
      Ic,Is :: VEC{VEC_{VEC_{REAL}}}*
      allocate(Im(0:l_max))
      do L = 0,l_max
         allocate(Im(L)[-L:L])
         do M = -L,L
            allocate(Im(L)[M][points.dim1])
         end
      end
      VEC{REAL}:make_I_harmonics(Ic,Is,points,l_max) 
      do L = 0,l_max
         do M = 0,L
            Im(L)[M][:] = Ic(L)[M][:]
         end
         do M = -L,-1
            Im(L)[M][:] = Is(L)[M][:]
         end
      end
      do L = l_max,0,-1
         do M = L,-L,-1
            deallocate(Is(L)[M].element)
            deallocate(Ic(L)[M].element)
         end
         deallocate(Is(L).element)
         deallocate(Ic(L).element)
      end
      deallocate(Is)
      deallocate(Ic)
   end

   to_multipole_T_interaction_vec(R,j_max)
   ! Make the multipole translation vector T(1,jk)(R) evaluated at position "R"
   ! where the maximum value of j is "j_max" and only the monopole term is
   ! calculated for the first indsex of the T matrix. This is used for
   ! evaluating the potential at the position "R" where a charge is located.
   ! See the book by Helgaker, Olsen, and Simons, equation (9.13.75), p. 415.
   ! NOTE: self is created.
      self :: PTR
      R :: VEC{REAL}(3)
      j_max :: INT
   ENSURE(j_max>=0,"j_max must be non-negative")
   ENSURE(.dim==(j_max+1)*(j_max+1),"self has wrong length")
      Ic,Is :: VEC{VEC_{REAL}}*
      Ic_lj,Is_lj :: VEC{REAL}*
      j,k,jk,sj,sk, L :: INT
      fac,fk :: REAL
      VEC{REAL}:make_I_harmonics(Ic,Is,R,j_max)
      jk = 0
      do j = 0,j_max
         sj = -1
         if (j.is_even) sj = 1
         sk = -sj
         ! First do k<0
         do k = -j,-1
            jk = jk + 1
            sk = -sk           ! initially,  (-1)**j
            fk = ONE
            if (k==0) fk = HALF
            Ic_lj => Ic(j).element
            Is_lj => Is(j).element
            fac = sj*fk
            self(jk) = fac*( Is_lj(k) - sk*Is_lj(-k)) ! T^cs
         end
         ! No do k>=0
         do k = 0,j
            jk = jk + 1
            sk = -sk           ! initially,  (-1)**j
            fk = ONE
            if (k==0) fk = HALF
            Ic_lj => Ic(j).element
            Is_lj => Is(j).element
            fac = sj*fk
            self(jk) = fac*( Ic_lj(k) + sk*Ic_lj(-k)) ! T^cc
         end
      end
      ! Must deallocate Ic, Is
      do L = j_max,0,-1
         deallocate(Is(L).element)
         deallocate(Ic(L).element)
      end
      deallocate(Is)
      deallocate(Ic)
   end

end
