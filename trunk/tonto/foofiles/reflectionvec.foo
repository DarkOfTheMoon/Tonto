!---------------------------------------------------------------------------
!
!  REFLECTIONVEC: a vector of crystal reflection data
!
!  (c) daniel grimwood, 2000
!
! $Id$
!---------------------------------------------------------------------------
module REFLECTIONVEC

  use TYPES
  use SYSTEM
  use DBL
  use STR
  use VEC
  use IMAT
  use STRVEC
  use TEXTFILE
  use ARCHIVE
  use REFLECTION

  implicit none

# include "macros"
# include "reflectionvec.int"

contains

!*******************************************************************************
!                           Create and Destroy Routines
!*******************************************************************************

  create(dim)
  ! Create space for a reflection vector
    PTR :: self
    INT, IN :: dim
    INT :: n
    nullify(self)
    allocate(self(dim))
    ADD_MEM(dim*REFLECTION_SIZE)
    do n=1,dim
      self(n).set_default
    end
  end

  create_copy(vec)
  ! Create space for a reflection vector and copy "vec" to it.
    REFLECTIONVEC, IN :: vec
    PTR :: self
    INT :: dim,n
    dim = size(vec)
    .create(dim)
    do n=1,dim
      self(n) = vec(n)
    end
  end

  destroy
  ! Destroy space for a reflection vector
    PTR :: self
    INT :: dim
    dim = size(self)
    RETURN_IF(.destroyed)
    DELETE_MEM(size(self)*REFLECTION_SIZE)
    deallocate(self)
  end

!*******************************************************************************
!                           Data changing routines
!*******************************************************************************

  set_indices(h,k,l)
  ! Set the reflection data from the vector.
    target :: self
    REFLECTION* :: ref
    IVEC, IN :: h,k,l
    INT :: n
    do n=1,.n_refl
      ref => self(n)
      ref.h       = h(n)
      ref.k       = k(n)
      ref.l       = l(n)
    end
  end

  set_F_calc(F_calc)
  ! Set the reflection data from the vector.
    target :: self
    CVEC, IN :: F_calc
    INT :: n
    do n=1,.n_refl
      self(n).F_calc = F_calc(n)
    end
  end

  set_F_pred(F_pred)
  ! Set the reflection data from the vector.
    target :: self
    VEC, IN :: F_pred
    INT :: n
    do n=1,.n_refl
      self(n).F_pred = F_pred(n)
    end
  end

  set_F_exp(F_exp)
  ! Set the reflection data from the vector.
    target :: self
    VEC, IN :: F_exp
    INT :: n
    do n=1,.n_refl
      self(n).F_exp = F_exp(n)
    end
  end

  set_F_sigma(F_sigma)
  ! Set the reflection data from the vector.
    target :: self
    VEC, IN :: F_sigma
    INT :: n
    do n=1,.n_refl
      self(n).F_sigma = F_sigma(n)
    end
  end

  set_I_pred(I_pred)
  ! Set the reflection data from the vector.
    target :: self
    VEC, IN :: I_pred
    INT :: n
    do n=1,.n_refl
      self(n).I_pred = I_pred(n)
    end
  end

  set_I_exp(I_exp)
  ! Set the reflection data from the vector.
    target :: self
    VEC, IN :: I_exp
    INT :: n
    do n=1,.n_refl
      self(n).I_exp = I_exp(n)
    end
  end

  set_I_sigma(I_sigma)
  ! Set the reflection data from the vector.
    target :: self
    VEC, IN :: I_sigma
    INT :: n
    do n=1,.n_refl
      self(n).I_sigma = I_sigma(n)
    end
  end

  set(ref)
  ! Set the reflection data from.
    target :: self
    REFLECTIONVEC, target :: ref
    REFLECTION* :: ref1,self1
    INT :: n
    do n=1,.n_refl
      self1 => self(n)
      ref1  => ref(n)
      self1.h       = ref1.h
      self1.k       = ref1.k
      self1.l       = ref1.l
      self1.F_exp   = ref1.F_exp
      self1.F_pred  = ref1.F_pred
      self1.F_calc  = ref1.F_calc
      self1.F_sigma = ref1.F_sigma
      self1.I_exp   = ref1.I_exp
      self1.I_pred  = ref1.I_pred
      self1.I_sigma = ref1.I_sigma
    end
  end

  scale_F_pred(fac)
  ! Scale the predicted structure factors
    INOUT :: self
    DBL, IN :: fac
    INT :: n
    do n=1,size(self)
      self(n).F_pred = self(n).F_pred * fac
    end
  end

  scale_F_calc(fac)
  ! Scale the calculated structure factors
    INOUT :: self
    DBL, IN :: fac
    INT :: n
    do n=1,size(self)
      self(n).F_calc = self(n).F_calc * fac
    end
  end

  scale_F_exp(fac)
  ! Scale the experimental structure factors
    INOUT :: self
    DBL, IN :: fac
    INT :: n
    do n=1,size(self)
      self(n).F_exp = self(n).F_exp * fac
    end
  end

  scale_F_sigma(fac)
  ! Scale the structure factor errors
    INOUT :: self
    DBL, IN :: fac
    INT :: n
    do n=1,size(self)
      self(n).F_sigma = self(n).F_sigma * fac
    end
  end

!*******************************************************************************
!                             Enquiry Routines
!*******************************************************************************

  created result(res)
  ! Returns true if self has been created
    PTR :: self
    BIN :: res
    res = associated(self)
  end

  destroyed result(res)
  ! Returns true if self has *not* been created
    PTR :: self
    BIN :: res
    res = NOT associated(self)
  end

  n_refl result (res) [pure]
  ! The number of reflections
    IN :: self
    INT :: res
    res = size(self)
  end

  have_F_calc result (res) [pure]
  ! Whether we have any calculated structure factors
    IN :: self
    BIN :: res
    INT :: n
    res = FALSE
    do n=1,size(self)
      if (abs(self(n).F_calc) > TOL(10)) then
        res = TRUE
        exit
      end
    end
  end

  have_F_pred result (res) [pure]
  ! Whether we have any predicted structure factors
    IN :: self
    BIN :: res
    INT :: n
    res = FALSE
    do n=1,size(self)
      if (abs(self(n).F_pred) > TOL(10)) then
        res = TRUE
        exit
      end
    end
  end

  have_F_exp result (res) [pure]
  ! Whether we have any experimental structure factors
    IN :: self
    BIN :: res
    INT :: n
    res = FALSE
    do n=1,size(self)
      if (abs(self(n).F_exp) > TOL(10)) then
        res = TRUE
        exit
      end
    end
  end

  have_F_sigma result (res) [pure]
  ! Whether we have any errors in the structure factors
    IN :: self
    BIN :: res
    INT :: n
    res = FALSE
    do n=1,size(self)
      if (abs(self(n).F_sigma) > TOL(10)) then
        res = TRUE
        exit
      end
    end
  end

  have_I_pred result (res) [pure]
  ! Whether we have any predicted intensities
    IN :: self
    BIN :: res
    INT :: n
    res = FALSE
    do n=1,size(self)
      if (abs(self(n).I_pred) > TOL(10)) then
        res = TRUE
        exit
      end
    end
  end

  have_I_exp result (res) [pure]
  ! Whether we have any experimental intensities
    IN :: self
    BIN :: res
    INT :: n
    res = FALSE
    do n=1,size(self)
      if (abs(self(n).I_exp) > TOL(10)) then
        res = TRUE
        exit
      end
    end
  end

  have_I_sigma result (res) [pure]
  ! Whether we have any errors in the intensities
    IN :: self
    BIN :: res
    INT :: n
    res = FALSE
    do n=1,size(self)
      if (abs(self(n).I_sigma) > TOL(10)) then
        res = TRUE
        exit
      end
    end
  end

  have_indices result (res) [pure]
  ! Whether we have the Miller indices
    IN :: self
    BIN :: res
    INT :: n
    res = FALSE
    do n=1,size(self)
      if (self(n).h /= 0 OR self(n).k /= 0 OR self(n).l /= 0) then
        res = TRUE
        exit
      end
    end
  end

  indices(n) result (res) [pure]
  ! Return the miller indices of reflection n.
    IN :: self
    INT, IN :: n
    IVEC(3) :: res
    res = (/ self(n).h, self(n).k, self(n).l /)
  end

!*******************************************************************************
!                              Statistical Routines
!*******************************************************************************

  F_chi2 result (res) [pure]
  ! chi2 for the structure factors
    IN :: self
    DBL :: res,z
    INT :: n
    res = ZERO
    do n=1,size(self)
      z = self(n).F_z
      res = res + z*z
    end
    res = res / max(.n_refl - 1,1)
  end

  I_chi2 result (res) [pure]
  ! chi2 for the intensities
    IN :: self
    DBL :: res,z
    INT :: n
    res = ZERO
    do n=1,size(self)
      z = self(n).I_z
      res = res + z*z
    end
    res = res / max(.n_refl - 1,1)
  end

  F_goodness_of_fit result (res) [pure]
  ! goodness_of_fit for the structure factors
    IN :: self
    DBL :: res
    res = sqrt(.F_chi2)
  end

  I_goodness_of_fit result (res) [pure]
  ! goodness_of_fit for the intensities
    IN :: self
    DBL :: res
    res = sqrt(.I_chi2)
  end

  F_r_factor result (res) [pure]
  ! r factor for the structure factors
    IN :: self
    DBL :: res,top,bot
    INT :: n
    top = ZERO
    bot = ZERO
    do n=1,size(self)
      top = top + abs(self(n).F_pred - self(n).F_exp)
      bot = bot + abs(self(n).F_exp)
    end
    res = top / bot
  end

  I_r_factor result (res) [pure]
  ! r factor for the intensities
    IN :: self
    DBL :: res,top,bot
    INT :: n
    top = ZERO
    bot = ZERO
    do n=1,size(self)
      top = top + abs(self(n).I_pred - self(n).I_exp)
      bot = bot + abs(self(n).I_exp)
    end
    res = top / bot
  end

  F_weighted_r_factor result (res) [pure]
  ! weighted r factor for the structure factors
    IN :: self
    DBL :: res,top,bot,z,b
    INT :: n
    top = ZERO
    bot = ZERO
    do n=1,size(self)
      z = self(n).F_z
      b = self(n).F_exp / self(n).F_sigma
      top = top + z*z
      bot = bot + b*b
    end
    res = top / bot
  end

  I_weighted_r_factor result (res) [pure]
  ! weighted r factor for the intensities
    IN :: self
    DBL :: res,top,bot,z,b
    INT :: n
    top = ZERO
    bot = ZERO
    do n=1,size(self)
      z = self(n).I_z
      b = self(n).I_exp / self(n).I_sigma
      top = top + z*z
      bot = bot + b*b
    end
    res = top / bot
  end

  F_calc result (res) [pure]
  ! return the calculated structure factors
    IN :: self
    CVEC(size(self)) :: res
    INT :: n
    do n=1,size(self)
      res(n) = self(n).F_calc
    end
  end

  F_pred result (res) [pure]
  ! return the predicted structure factors
    IN :: self
    VEC(size(self)) :: res
    INT :: n
    do n=1,size(self)
      res(n) = self(n).F_pred
    end
  end

  F_exp result (res) [pure]
  ! return the experimental structure factors
    IN :: self
    VEC(size(self)) :: res
    INT :: n
    do n=1,size(self)
      res(n) = self(n).F_exp
    end
  end

  I_pred result (res) [pure]
  ! return the predicted intensities
    IN :: self
    VEC(size(self)) :: res
    INT :: n
    do n=1,size(self)
      res(n) = self(n).I_pred
    end
  end

  F_sigma result (res) [pure]
  ! return the errors in the experimental structure factors
    IN :: self
    VEC(size(self)) :: res
    INT :: n
    do n=1,size(self)
      res(n) = self(n).F_sigma
    end
  end

!*******************************************************************************
!                                Read Routines
!*******************************************************************************

  read [leaky]
  ! Read in data in the standard order from "stdin". 
  ! NOTE: Will create a REFLECTIONVEC, if required
    PTR :: self
    STRVEC* :: keywords
    STR :: word
    stdin.read(word)
    ENSURE(word=="{","expecting open bracket symbol, {")
    stdin.read(word)
    ENSURE(word/="}","empty data list!")
    stdin.move_to_previous_item
    nullify(keywords)
    keywords.create(REFLECTION_INPUT_DATA_ORDER)
    read_loop: do                 ! Loop over input keywords
      stdin.read(word)
      word.to_lower_case
      select case (word)
        case("}");                exit read_loop
        case("data_order=")
          keywords.destroy
          stdin.read_ptr(keywords)
        case("data=")
          stdin.read(word)
          ENSURE(word=="{","expecting open bracket symbol, {")
          .read_data(keywords)
          stdin.read(word)
          ENSURE(word=="}","expecting close bracket symbol, }")
        case default
          stdin.move_to_previous_item
          .read_data(keywords)
      end
    end do read_loop
    keywords.destroy
  end 

  read_data(keywords) [leaky]
    PTR :: self
    STRVEC, IN :: keywords
    INT :: length
    length = .data_length(keywords) 
    if (.created) then
      DIE_IF(length/=size(self),"list length is wrong")
    end
    if (.destroyed) .create(length)
    .process_input(keywords)               ! Read in the reflections
  end

  data_length(keywords) result (length) [leaky]
  ! Read ahead to get the "length", the number of data items in the vector
  ! The list data begins with the first data item, not a "{" symbol.
  ! The list data must be terminated by a "}" symbol.
    PTR :: self
    INT :: length
    STRVEC, IN :: keywords
    REFLECTION* :: reflection
    STR :: word
    INT :: line,item
    stdin.read(word)
    ENSURE(word/="}","empty data list!")
    length = 0                             ! Read ahead to get the number
    line = stdin.line_number               ! of reflections
    item = stdin.previous_line_item
    do
      stdin.move_to_previous_item
      reflection.create
      reflection.process_input(keywords)
      reflection.destroy
      length = length + 1
      stdin.read(word)
      word.to_lower_case
      if (word=="}") exit
    end
    stdin.move_to_line(line)
    stdin.move_to_line_item(item)
  end

  process_input(keywords) [leaky]
  ! Read in the list information from "stdin". 
    INOUT :: self
    STRVEC, IN :: keywords
    INT :: s
    do s = 1,size(self)
      self(s).process_input(keywords)
    end
  end 

!*******************************************************************************
!                                  Output routines
!*******************************************************************************

  put(keywords,output)
  ! Output the reflection data in the order specified by keywords.
  ! Optional "output" textfile can be used instead of stdout.
    TEXTFILE, target, optional :: output
    TEXTFILE* :: out
    STRVEC, IN :: keywords
    INT :: k,n,n_refl,n_k,int_dash,dbl_dash

    if (present(output)) then; out => output
    else;                      out => stdout
    end

    n_refl = size(self)
    n_k = size(keywords)

    out.flush
    out.text("Reflection data")
    out.flush
    out.show("Number of reflections is ",n_refl)
    out.flush

    int_dash = 0                             ! Get the width of the banner.
    dbl_dash = 0
    do k=1,n_k
      select case (keywords(k))
        case("h");          int_dash = int_dash + 1
        case("k");          int_dash = int_dash + 1
        case("l");          int_dash = int_dash + 1
        case("indices");    int_dash = int_dash + 3
        case("F_exp");      dbl_dash = dbl_dash + 1
        case("F_calc");     dbl_dash = dbl_dash + 2
        case("F_pred");     dbl_dash = dbl_dash + 1
        case("F_sigma");    dbl_dash = dbl_dash + 1
        case("I_exp");      dbl_dash = dbl_dash + 1
        case("I_pred");     dbl_dash = dbl_dash + 1
        case("I_sigma");    dbl_dash = dbl_dash + 1
      end
    end

    out.dash(dbl_fields=dbl_dash,int_fields=int_dash)   ! Put the banner.
    do k=1,n_k                   
      select case (keywords(k))
        case("h");          out.put("h",int_width=TRUE)
        case("k");          out.put("l",int_width=TRUE)
        case("l");          out.put("k",int_width=TRUE)
        case("indices");    out.put("h",int_width=TRUE)
                            out.put("k",int_width=TRUE)
                            out.put("l",int_width=TRUE)
        case("F_exp");      out.put("F_exp")
        case("F_calc");     out.put("Re(F_calc)")
                            out.put("Im(F_calc)")
        case("F_pred");     out.put("F_pred")
        case("F_sigma");    out.put("F_sigma")
        case("I_exp");      out.put("I_exp")
        case("I_pred");     out.put("I_pred")
        case("I_sigma");    out.put("I_sigma")
      end
    end
    out.flush
    out.dash(dbl_fields=dbl_dash,int_fields=int_dash)

    do n = 1,n_refl                                     ! Put the data.
      do k=1,n_k
        select case (keywords(k))
          case("h");          out.put(self(n).h)
          case("k");          out.put(self(n).l)
          case("l");          out.put(self(n).k)
          case("indices");    out.put(self(n).h)
                              out.put(self(n).k)
                              out.put(self(n).l)
          case("F_exp");      out.put(self(n).F_exp)
          case("F_calc");     out.put(self(n).F_calc)
          case("F_pred");     out.put(self(n).F_pred)
          case("F_sigma");    out.put(self(n).F_sigma)
          case("I_exp");      out.put(self(n).I_exp)
          case("I_pred");     out.put(self(n).I_pred)
          case("I_sigma");    out.put(self(n).I_sigma)
        end
      end
      out.flush
    end
    out.dash(dbl_fields=dbl_dash,int_fields=int_dash)
    out.flush
  end

  put_reflection_data(output)
  ! Output the reflection data to file "output"
    TEXTFILE, target, optional :: output

    if (.have_F_pred) then
      if (.have_F_exp) then
        .put_structure_factor_data(output)
      else
        .put_F_pred_data(output)
      end
    else
      if (.have_F_exp) .put_F_exp_data(output)
    end

    if (.have_I_pred) then
      if (.have_I_exp) then
        .put_intensity_data(output)
      else
        .put_I_pred_data(output)
      end
    else
      if (.have_I_exp) .put_I_exp_data(output)
    end
  end

  put_structure_factor_data(output)
  ! Output the structure factor data to file "output"
    TEXTFILE, target, optional :: output
    STRVEC(5) :: keywords
    .put_F_stats(output)
    keywords(1) = "indices"
    keywords(2) = "F_calc"
    keywords(3) = "F_pred"
    keywords(4) = "F_exp"
    keywords(5) = "F_sigma"
    .put(keywords,output)
  end
 
  put_F_pred_data(output)
  ! Output only the predicted structure factor data to file "output"
    TEXTFILE, target, optional :: output
    STRVEC(3) :: keywords
    keywords(1) = "indices"
    keywords(2) = "F_calc"
    keywords(3) = "F_pred"
    .put(keywords,output)
  end
 
  put_F_exp_data(output)
  ! Output only the experimental structure factor data to file "output"
    TEXTFILE, target, optional :: output
    STRVEC(3) :: keywords
    keywords(1) = "indices"
    keywords(2) = "F_exp"
    keywords(3) = "F_sigma"
    .put(keywords,output)
  end
 
  put_intensity_data(output)
  ! Output the structure factor data to file "output"
    TEXTFILE, target, optional :: output
    STRVEC(4) :: keywords
    .put_I_stats(output)
    keywords(1) = "indices"
    keywords(2) = "I_pred"
    keywords(3) = "I_exp"
    keywords(4) = "I_sigma"
    .put(keywords,output)
  end
 
  put_I_pred_data(output)
  ! Output only the predicted structure factor data to file "output"
    TEXTFILE, target, optional :: output
    STRVEC(3) :: keywords
    keywords(1) = "indices"
    keywords(2) = "I_calc"
    keywords(3) = "I_pred"
    .put(keywords,output)
  end
 
  put_I_exp_data(output)
  ! Output only the experimental intensity data to file "output"
    TEXTFILE, target, optional :: output
    STRVEC(3) :: keywords
    keywords(1) = "indices"
    keywords(3) = "I_exp"
    keywords(2) = "I_sigma"
    .put(keywords,output)
  end

  put_F_stats(output)
  ! Output the structure factor goodness of fit statistics to file "output" or
  ! stdout.
    TEXTFILE, optional, target :: output
    TEXTFILE* :: out
    DBL :: chi2
    if (present(output)) then; out => output
    else;                      out => stdout
    end
    chi2 = .F_chi2
    out.flush
    out.text("Goodness of fit parameters based on Structure Factors:",flush=2)
    out.show("R factor                    =", .F_r_factor)
    out.show("Weighted R factor           =", .F_weighted_r_factor)
    out.show("chi**2                      =", chi2)
    out.show("Goodness of fit             =", sqrt(chi2))
  end
 
  put_I_stats(output)
  ! Output the intensity goodness of fit statistics to file "output" or stdout.
    TEXTFILE, optional, target :: output
    TEXTFILE* :: out
    DBL :: chi2
    if (present(output)) then; out => output
    else;                      out => stdout
    end
    chi2 = .I_chi2
    out.flush
    out.text("Goodness of fit parameters based on Intensities:",flush=2)
    out.show("R factor                    =", .I_r_factor)
    out.show("Weighted R factor           =", .I_weighted_r_factor)
    out.show("chi**2                      =", chi2)
    out.show("Goodness of fit             =", sqrt(chi2))
  end

!*******************************************************************************
!                                    QQ plots
!*******************************************************************************

  put_F_qq_plot(name)
  ! Output a qq plot to the text file.
  ! It is a plot of the experimental quantile vs expected quantile.
    STR, optional :: name
    ARCHIVE :: archive
    MAT* :: grid
    grid.create(.n_refl,2)
    .make_F_qq_plot_grid(grid)
    archive.set(root_name=name,name="qq_plot",format="ascii")
    archive.write(grid,order="by_row")
    archive.close
    grid.destroy
  end
 
  put_labelled_F_qq_plot(name)
  ! Output a qq plot to the text file.
  ! It is a plot of the experimental quantile vs expected quantile.
    STR, optional :: name
    TEXTFILE* :: textfile
    MAT* :: grid
    IMAT* :: hkl
    INT :: n
    hkl.create(.n_refl,3)
    do n=1,.n_refl
      hkl(n,:) = .indices(n)
    end
    grid.create(.n_refl,2)
    .make_F_qq_plot_grid(grid,hkl)
    textfile.create(trim(name) // ":qq_plot_labelled")
    textfile.open_for_write
    textfile.set_labels(FALSE)
    do n=1,.n_refl
      textfile.put(grid(n,1))
      textfile.put(grid(n,2))
      textfile.put(hkl(n,1))
      textfile.put(hkl(n,2))
      textfile.put(hkl(n,3))
      textfile.flush
    end
    textfile.close
    textfile.destroy
    grid.destroy
    hkl.destroy
  end

  make_F_qq_plot_grid(grid,hkl)
  ! Make the grid for the Q-Q plot, which is a plot of the deviations X-Y
  ! versus the expected deviations, assuming that the expected devaitions
  ! are normally distributed. grid(1,:) contains the expected deviation d0j,
  ! grid(2,:) contains actual deviation dj.
    target :: self
    MAT, target :: grid
    VEC* :: d,e
    REFLECTION* :: ref
    IMAT, optional :: hkl
    DBL :: p
    INT :: n_refl,i,j
    n_refl = size(self)
    ENSURE(size(grid,1)==n_refl, "grid wrong size")
    ENSURE(size(grid,2)==2,      "grid wrong size")

    e => grid(:,1) ! theoretical z's
    d => grid(:,2) ! calculated z's

    do i=1,n_refl
      ref => self(i)
      d(i)  = ref.F_z * sign(ONE,real(ref.F_calc))
    end

   ! sort array from lowest z to highest
    if (present(hkl)) then
      ENSURE(size(hkl,1)==n_refl, "size of index array incorrect")
      ENSURE(size(hkl,2)==3,      "size of index array incorrect")
      do i=1,n_refl-1
        do j=i+1,n_refl
          if (d(j) < d(i)) then
            d.swap_elements(i,j)
            hkl.swap_columns(i,j)
          end
        end
      end
    else
      d.sort
    end

    do j=1,n_refl                    ! expected quantile, d0j
      p = (TWO*(n_refl-j)+ONE)/(TWO*n_refl) ! cumulative probability
      e(n_refl-j+1) = p.z_from_p
    end

  end

end
