!-------------------------------------------------------------------------------
!
! LEAST_SQUARES: For performing an iteration of least squares
!
! Copyright (C) Dylan Jayatilaka 2013
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module LEAST_SQUARES

   implicit none

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========
!  Allocation
!  ==========

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the diffraction data object

      nullify(.X)
      nullify(.X0)
      nullify(.dX)
      nullify(.Y)
      nullify(.Y0)
      nullify(.dY)
      nullify(.inv_sigma)
      nullify(.X_labels)
      nullify(.dYdX)

      nullify(.near_0_eigenvalues)
      nullify(.near_0_eigenvectors)

      nullify(.esd)
      nullify(.covariance_matrix)
      nullify(.correlation_matrix)

      nullify(.table)

   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information

      .X.destroy
      .X0.destroy
      .dX.destroy
      .Y.destroy
      .Y0.destroy
      .dY.destroy
      .inv_sigma.destroy
      .X_labels.destroy
      .dYdX.destroy

      .near_0_eigenvalues.destroy
      .near_0_eigenvectors.destroy

      .esd.destroy
      .covariance_matrix.destroy
      .correlation_matrix.destroy

      .table.destroy

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(object) ::: leaky
   ! Copy the object
      object :: LEAST_SQUARES, IN

      self = object

      .nullify_ptr_part

      if (object.X.created)                    .X.create_copy(object.X)
      if (object.X0.created)                   .X0.create_copy(object.X0)
      if (object.dX.created)                   .dX.create_copy(object.dX)
      if (object.Y.created)                    .Y.create_copy(object.Y)
      if (object.Y0.created)                   .Y0.create_copy(object.Y0)
      if (object.dY.created)                   .dY.create_copy(object.dY)
      if (object.inv_sigma.created)            .inv_sigma.create_copy(object.inv_sigma)
      if (object.X_labels.created)             .X_labels.create_copy(object.X_labels)
      if (object.dYdX.created)                 .dYdX.create_copy(object.dYdX)

      if (object.near_0_eigenvalues.created)   .near_0_eigenvalues.create_copy(object.near_0_eigenvalues)
      if (object.near_0_eigenvectors.created)  .near_0_eigenvectors.create_copy(object.near_0_eigenvectors)

      if (object.esd.created)                  .esd.create_copy(object.esd)
      if (object.covariance_matrix.created)    .covariance_matrix.create_copy(object.covariance_matrix)
      if (object.correlation_matrix.created)   .correlation_matrix.create_copy(object.correlation_matrix)

      if (object.table.created)                .table.create_copy(object.table)
   
   end


!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky
   ! Set default values

      .n_parameters                = 0
      .n_data                      = 0
                                  
      ! Penalty
      .chi2                        = ZERO
      .chi20                       = ZERO
                                  
      ! Iterations                
      .iterations                  = 0
      .max_iterations              = LEAST_SQUARES_MAX_ITER
      .min_iterations              = LEAST_SQUARES_MIN_ITER  
                                  
      ! Convergence               
      .converged                   = FALSE
      .chi2_increased              = FALSE
      .too_many_iterations         = FALSE
                                  
      ! Shifts                    
      .max_shift                   = ZERO
      .max_shift_tol               = LEAST_SQUARES_MAX_SHIFT_TOL
      .max_shift_on_esd            = ZERO
      .max_shift_on_esd_tol        = LEAST_SQUARES_MAX_SHIFT_ON_ESD_TOL
      .max_shift_on_esd_ind        = 0
      .max_shift_on_esd_par        = " "

      ! Singularities
      .n_0                         = 0
      .tol_0                       = LEAST_SQUARES_TOL_0
      .n_near_0                    = 0
      .tol_near_0                  = LEAST_SQUARES_TOL_NEAR_0

      ! Output control
      .show_fit_output             = FALSE
      .display_near_0_eigenvectors = FALSE
      .display_correlation_matrix  = FALSE
      .min_correlation             = LEAST_SQUARES_MIN_CORRELATION

      ! Table (leaky)
      .set_default_table

   end

   set_default_table ::: leaky
   ! Create the default LS output table

      ! Create the table (leaky)
      .table.create(8)

      ! Table headings
      .table(1).set_heading("Fit")
      .table(1).set_subhead("Iter")
      .table(2).set_heading("chi2")
      .table(3).set_heading("R")
      .table(4).set_heading("R_w")
      .table(5).set_heading("Max.")
      .table(5).set_subhead("Shift")
      .table(5).set_sb3head("/esd")
      .table(6).set_heading("Max.")
      .table(6).set_subhead("Shift")
      .table(6).set_sb3head("param")
      .table(7).set_heading("No. of")
      .table(7).set_subhead("params")
      .table(8).set_heading("No. of")
      .table(8).set_subhead("eig's")
      .table(8).set_sb3head("near 0")

      ! Table widths (needs to be here because of label width)
      .table(1).set_width_from(LEAST_SQUARES_MAX_ITER) ! Iter
      .table(2).set_width_from(TEN**3)                 ! chi2
      .table(3).set_width_from(ONE)                    ! R
      .table(4).set_width_from(ONE)                    ! Rw
      .table(5).set_width_from(TEN*TEN)                ! Max shift/esd
   !  .table(6).set_width_from(labels)                 ! Max shift par
      .table(7).set_width(3)                           ! n_param
      .table(8).set_width(3)                           ! n_near_0

   end

   set_n_parameters(n) ::: leaky
   ! Set the number of parameters ".n_parameters" to "n"
   ! NOTE: this must be called to ensure all arrays are created
      n :: INT, IN

   ENSURE(n>0,"must be +ve")

      .n_parameters = n

      ! Allocate 
      .X.create(n)
      .X0.create(n)
      .dX.create(n)
      .X_labels.create(n)

      .esd.create(n)
      .covariance_matrix.create(n,n)
      .correlation_matrix.create(n,n)

      ! Table size
      .table(7).set_width(log10(n)+1)  ! n_param
      .table(8).set_width(log10(n)+1)  ! n_near_0

   end

   set_n_data(n) ::: leaky
   ! Set the number of data points ".n_data" to "n"
   ! NOTE: .n_parameters must have been set already
   ! NOTE: this must be called to ensure all arrays are created
      n :: INT, IN

   ENSURE(n>0,"must be +ve")

      .n_data = n

      ! Allocate the arrays
      .dYdX.create(n,.n_parameters)
      .Y.create(n)
      .Y0.create(n)
      .dY.create(n)

   end

   set_chi2(val) 
   ! Set the ".chi2" to "val" and save old value in "chi20"
      val :: REAL, IN

   ENSURE(chi2>0,"must be +ve")

      .chi20 = .chi2
      .chi2  = val

   end

   set(X,Y,Y0,sigma,dYdX)
   ! Initialise least squares
   X,Y,Y0,sigma   :: VEC{REAL}, IN
   dYdX :: MAT{REAL}
   .set_n_parameters(X.dim)
   .set_n_data(Y.dim)
   .set_X(X)
   .set_Ys(Y,Y0)
   .set_inv_sigma(sigma)
   .set_dYdX(dYdX)
   end

   set_X(v) 
   ! Set the parameter vector ".X" to "v"
      v :: VEC{REAL}, IN

   ENSURE(.n_parameters>0,"n_parameters has not been set")
   ENSURE( v.dim==.n_parameters,"wrong size, v")

      .X = v

   end

   set_dX(v) 
   ! Set the parameter shifts ".dX" to "v", save ".X" in ".X0", and
   ! update parameter vector ".X".
      chi2 :: REAL, IN

   ENSURE(.n_parameters>0,"n_parameters has not been set")
   ENSURE( v.dim ==.n_parameters,"wrong size, v")

      .dX = v
      .X0 = .X
      .X  = .X + v

   end

   set_Y(v) 
   ! Set the parameter vector ".Y" to "v"
      v :: VEC{REAL}, IN

   ENSURE(.n_parameters>0,"n_parameters has not been set")
   ENSURE( v.dim==.n_parameters,"wrong size, v")

      .Y = v

   end

   set_Ys(v,v0) 
   ! Set the parameter vector ".X" to "v"
      v,v0 :: VEC{REAL}, IN

   ENSURE(.n_parameters>0,"n_parameters has not been set")
   ENSURE( v.dim==.n_parameters,"wrong size, v")

      .Y0 = v0
      .Y = v
      .dY = .Y-.Y0

   end

   set_X_labels(v) 
   ! Set the parameter labels ".X_labels" to "v"
      v :: VEC{STR}, IN

   ENSURE(.n_parameters>0,"n_parameters has not been set")
   ENSURE( v.dim==.n_parameters,"wrong size, v")

      .X = v

   end

   set_dYdX(mx) 
   ! Set the derivatives ".dYdX" to "m"
      m :: MAT{REAL}, IN

   ENSURE(.n_parameters>0,"n_parameters has not been set")
   ENSURE(.n_data>0,"n_data has not been set")
   ENSURE(m.dim1==.n_parameters,"wrong dim1, m")
   ENSURE(m.dim2==.n_data,      "wrong dim2, m")

      .dYdX = m

   end

   set_inv_sigma(sigma) 
   ! Set the parameter vector ".Y" to "v"
      sigma :: VEC{REAL}, IN

   ENSURE(.n_parameters>0,"n_parameters has not been set")
   ENSURE( sigma.dim==.n_parameters,"wrong size, sigma")

      .Y = ONE/sigma

   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      self :: PTR
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)

         case ("}                             ")  ! exit read_loop

         case ("debug_off                     "); .read_debug_off
         case ("debug_on                      "); .read_debug_on
         case ("display_correlation_matrix=   "); .read_display_corr_matrix
         case ("display_near_0_eigenvectors=  "); .read_display_near_0_evecs

         case ("max_iterations=               "); .read_max_iterations
         case ("max_shift_on_esd_tol=         "); .read_max_shift_on_esd_tol
         case ("max_shift_tol=                "); .read_max_shift_tol
         case ("min_iterations=               "); .read_min_iterations
         case ("min_correlation=              "); .read_min_correlation

         case ("put                           "); .put
         case ("put_debug_list                "); .put_debug_list

         case ("redirect                      "); .redirect
         case ("revert                        "); .revert

         case ("show_fit_output=              "); .read_show_fit_output

         case ("tolerance_0=                  "); .read_tol_0
         case ("tolerance_near_0=             "); .read_tol_near_0

         case default;                       UNKNOWN(word)

      end

   end

! Reading

   read_display_corr_matrix
   ! Read whether to display the correlation matrix.
      stdin.read(.display_correlation_matrix)
   end

   read_display_near_0_evecs
   ! Read whether to display the near 0 eigenvectros of the correlation matrix.
      stdin.read(.display_near_0_eigenvectors)
   end

   read_max_iterations
   ! Read the maximum number of iterations
      stdin.read(.max_iterations)
      ENSURE(.max_iterations>-1,"max_iterations must be non-negative")
      ENSURE(.max_iterations>.min_iterations,"max_iterations must be greater than min_iterations")
   end

   read_max_shift_tol
   ! Read the maximum allowed shift in a parameter
      stdin.read(.max_shift_tol)
      ENSURE(.max_shift_tol>ZERO,"must be +ve!")
   end

   read_max_shift_on_esd_tol
   ! Read the maximum allowed shift-on-esd ratio, for a parameter
      stdin.read(.max_shift_on_esd_tol)
      ENSURE(.max_shift_on_esd_tol>ZERO,"must be +ve!")
   end

   read_min_iterations
   ! Read the minimum number of iterations
      stdin.read(.min_iterations)
      ENSURE(.min_iterations>-1,"min_iterations must be non-negative")
      ENSURE(.max_iterations>.min_iterations,"min_iterations must be smaller than max_iterations")
   end

   read_min_correlation
   ! Read the minimum correlation between parameters before reporting
      stdin.read(.min_correlation)
      ENSURE(.min_correlation.is_in_range([ZERO,ONE]),,"must be in range [0,1]")
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

   read_show_fit_output ::: private
   ! Read wether to show the rejected reflections
      stdin.read(.show_fit_output)
   end

   read_tol_0
   ! Read the tolerance for deciding on zero eigenvalues in solving
   ! the normal equations.
      stdin.read(.tol_0)
      ENSURE(.tol_0>ZERO,"tol_0 must be positive")
      ENSURE(.tol_0<.tol_near_0,"tol_0 must be smaller than tol_near_0")
   end

   read_tol_near_0
   ! Read the tolerance for deciding on *near* zero eigenvalues in
   ! solving the normal equations.
      stdin.read(.tol_near_0)
      ENSURE(.tol_near_0>ZERO,"tol_near_0 must be positive")
      ENSURE(.tol_0<.tol_near_0,"tol_near_0 must be bigger than tol_0")
   end


!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, X?=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end



   the_chi2 result (res) ::: pure
   ! Return the chi2 between the predicted and observed structure
   ! factors. The sum of squares is divided by max(.dim-1,1)
      self :: IN
      res :: REAL
      z :: REAL
      n :: INT

      res = ZERO

      do n = 1,.n_data
         z = (.Y(n) - .Y0(n))*.inv_sigma(n)
         res = res + z*z
      end

      res = res / max(.n_data-.n_parameters-.n_near_0)

   end

   goodness_of_fit result (res) ::: pure
   ! Return the goodness-of-fit between the predicted and observed
   ! structure factors
      self :: IN
      res :: REAL
      res = sqrt(.chi2)
   end

   r_factor result (res) ::: pure
   ! Return the r factor between the predicted and observed structure
   ! factors
      self :: IN
      res :: REAL
      top,bot :: REAL
      n :: INT

      top = ZERO
      bot = ZERO

      do n=1,size(self)
         top = top + abs(.Y(n) - .Y0(n))
         bot = bot + abs(.Y0(n))
      end

      res = top / bot

   end


   weighted_r_factor result (res) ::: pure
   ! Return the weighted r factor for the structure factors
      self :: IN
      res :: REAL
      top,bot,z,b :: REAL
      n :: INT

      top = ZERO
      bot = ZERO

      do n = 1,.dim

         z = .Y(n)*(.Y(n)-.Y0(n))*.inv_sigma(n)
         b = .Y0(n)*.inv_sigma(n)

         top = top + z*z
         bot = bot + b*b

      end

      res = sqrt(top/bot)

   end


!  ===============================
!  Least-squares: Normal equations
!  ===============================

   solve_normal_equations(dYdX) ::: leaky
   ! Get the ".dX" in some parameter vector by solving the normal
   ! equations, given "dYdX", the derivatives of Y w.r.t. X. 
      dYdX :: MAT{REAL}, IN

   ENSURE(dYdX.dim1==.reflections.n_refl, "wrong size, dYdX")
   ENSURE(dYdX.dim2==.dX.dim, "incompatible .dX and dYdX")

      A :: MAT{REAL}*
      rhs,inv_sigma2,delta :: VEC{REAL}*
      n_p,i,j :: INT
      fac :: REAL
 
      ! Next iteration
      .iteration = .iteration + 1

      ! Save and increment parameters
      .set_dX

      ! Constants
      n_p    = .n_parameters
 
      ! Arrays
      A.create(n_p,n_p)
      rhs.create(n_p)
      inv_sigma2.create(n_p)

      ! Make the normal matrix
      inv_sigma2.create(n_p)
      inv_sigma2 = .inv_sigma*.inv_sigma
      do i = 1,n_p
      do j = 1,n_p
         A(i,j) = VEC{REAL}:sum(inv_sigma2*.dYdX(:,i)*.dYdX(:,j))
      end
      end
      inv_sigma2.destroy

      ! Make the rhs
      delta.create(.n_data)
      delta = (.Y-.Y0)*.inv_sigma
      do i = 1,n_p
         rhs(i) = VEC{REAL}:sum(delta*.dYdX(:,i))
      end
      delta.destroy

      if (.debugging("solve_normal_equations")) then 
      stdout.text("A:")
      stdout.put(A)
      stdout.text("rhs:")
      stdout.put(rhs)
      end

      ! Solve for the shifts .dX (leaky)
      A.solve_ill_linear_equations(rhs,.dX,.tol_0,.n_0,.tol_near_0,.n_near_0 &
                                  ,.near_0_eigenvalues,.near_0_eigenvectors &
                                  ,.covariance_matrix,.correlation_matrix)

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts:")
      stdout.put(.dX)
      stdout.show("Normal equations check =",maxval(abs(matmul(A,.dX)-rhs)))
      stdout.show("Smallest eigenvalue    =",minval(abs(.near_0_eigenvalues)))
      stdout.show("tol_0                  =",.tol_0)
      stdout.show("n_0                    =",.n_0)
      stdout.show("tol_near_0             =",.tol_near_0)
      stdout.show("n_near_0               =",.n_near_0)
      stdout.text("Near_0 eigenvalues:")
      stdout.put(.near_0_eigenvalues,by_column=TRUE)
      end

      ! Get the maximum shift
      .max_shift = maxval(abs(.dX))

      ! Set the full covariance matrix
      .chi2_0 = .chi2
      .chi2 = .the_chi2
      .covariance_matrix = .chi2*.covariance_matrix

      ! Set variances
      .covariance_matrix.put_diagonal_to(.esd)

      ! Set ESD's
      .esd = sqrt(.esd)

      ! Set the fit errors e.g. max(.dX/esd)
      ! Parameter ordering is unique fragment atom order.
      
      .update_shift_info

      rhs.destroy
      A.destroy

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts before renormalisation:")
      stdout.put(.dX)
      end

      ! Renormalise shift if too big
      if (.max_shift>.tol_max_shift) then
         fac = .tol_max_shift/.max_shift
         .dX = fac * .dX
      end

      if (.debugging("solve_normal_equations")) then 
      stdout.text("shifts after renormalisation:")
      stdout.put(.dX)
      end

   end

   update_shift_info
   ! Set the esd's for the current fit. 
   ! WARNING: The order of the parameters is not always the same
   ! between calls of this routine. You *must* call this if the
   ! covariance matrix has been transformed from a unique-fragment
   ! atom ordering to asymmetric-unit ordering.

      indmax,p :: INT
      val,valmax :: REAL

      ! Get the location of the maximum shift on esd
      indmax = 0
      valmax = ZERO
      do p = 1,.esd.dim

         val = .esd(p)

         ! Ignore symmetry zero's
         if (abs(val)<TOL(8)) cycle

         ! Shift on esd
         val = abs(.dX(p)/val)

         ! Set shift on esd if larger ...
         if (val<=valmax) cycle
         valmax = val
         indmax = p

      end

      ! Assign maximum index
      DIE_IF(indmax==0,"no maximum index found!")
      .max_shift_on_esd_ind = indmax
      .max_shift_on_esd     = valmax

      ! Debug
      if (.debugging("update_fit_errors")) then 
         stdout.show("max_shift_on_esd_ind  =",indmax)
         stdout.show("max_shift_on_esd      =",valmax)
      end

   end

!  Fit/refinement iteration control
 
   fit_finished result (res)
   ! Return whether the LS has finished
      res :: BIN

      ! Converged?
      .converged = .max_shift_on_esd<.tol_max_shift_on_esd &
               AND .iteration>=.min_iterations

      ! chi2 inceased?
      .chi2_increased = .chi2>.chi20 AND .iteration>.min_iterations

      ! Roll back the parameters is chi2 increases
      ! WARNING: covariances are not rolled back ...
    ! if (.chi2_increased) then
    !    .X_fit    = .X_fit0
    !    .chi2_fit = .chi2_fit0
    ! end

      ! Too many fit iterations?
      .too_many_iterations = .iteration>.max_iterations

      ! Set finished
      res = .converged OR .chi2_increased OR .too_many_iterations

   end

!  Fit/refinement output

   put_table_headings
   ! Put the fit table header
      .table.put_headings
   end

   put_table_body
   ! Print the current iterations results

      ! Set table body (leaky)
      .table(1).create_values([.iteration])
      .table(2).create_values([.chi2])
      .table(3).create_values([.r_factor])
      .table(4).create_values([.weighted_r_factor])
      .table(5).create_values([.max_shift_on_esd])
      .table(6).create_values([.max_shift_on_esd_par])
      .table(7).create_values([.n_parameters])
      .table(8).create_values([.n_near_0])

      ! Put out the body
      .table.put_body

      ! Clear thje columns for next time (UNleaky!)
      .table.clear_columns

   end


   put_results
   ! Put the fit-iteration footer and fit results

      ! Table footer
      .table.put_footer

      ! Results
      stdout.flush
      stdout.text("=====================")
      stdout.text("Least-squares results")
      stdout.text("=====================")
      stdout.flush

      ! Print how it finished
      if      (.converged)            then; stdout.text("Least-squares converged.")
      else if (.chi2_increased        then; stdout.text("Warning: fit stopped: chi2 has increased.")
                                            stdout.text("Warning: fit results are unreliable.")
      else if (.too_many_iterations)  then; stdout.text("Warning: fit stopped: too many iterations.")
      end

      ! Put final fitting statistics
      stdout.show("# of fit parameters, N_p    =", .n_parameters)
      stdout.show("chi^2(N_p)                  =",.chi2)
      stdout.show("Goodness of fit (N_p)       =", sqrt(.chi2))

   end

   put_near_0_eigenvectors
   ! Put the near zero (linearly dependent) parameter eigenvectors

      if (.near_0_eigenvectors.created) then
      if (.near_0_eigenvectors.dim>0) then

         stdout.flush
         stdout.text("Near 0 eigenvalues of the normal matrix:")
         stdout.put(.near_0_eigenvalues)
         stdout.flush
         stdout.text("Near 0 eigenvectors of the normal matrix:")
         stdout.put(.near_0_eigenvectors)

      end
      end

   end


!  ==============
!  Output methods
!  ==============


end
