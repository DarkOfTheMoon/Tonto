! $Id$
!-------------------------------------------------------------------------------
!
! OPMAT: Operator matrices. 
!
! Provide a basis set (matrix) representation of a one-electron quantum 
! mechanical operator. Can cope with polymorphic types of basis representations, 
! including restricted, unrestricted, and general basis orbital matrices.
! Also, complex types for all these matrices.
!
! Basically, its a polymorphic matrix type.
!
! (c) dylan jayatilaka 1998
!
!-------------------------------------------------------------------------------
module OPMAT

   use TYPES
   use ERROR
   use MM
   use STR

   use VEC
   use MAT
   use CMAT

   implicit none         

#  include "macros"
#  include "opmat.int"

!  type opmat_type
!     INT       :: n_bf                   ! AO basis set size
!     MAT, PTR  :: restricted             ! Restricted spinorbital representation
!     MAT, PTR  :: alpha                  ! Alpha part of a DODS representation
!     MAT, PTR  :: beta                   ! Beta  part of a DODS representation
!     MAT, PTR  :: general                ! General mixed alpha-beta matrix representation
!     CMAT, PTR :: restricted_complex     ! Complex restricted representation
!     CMAT, PTR :: alpha_complex          ! Complex alpha part of a DODS representation
!     CMAT, PTR :: beta_complex           ! Complex beta  part of a DODS representation
!     CMAT, PTR :: general_complex        ! Complex general mixed alpha-beta matrix representation
!     VEC, PTR  :: triangle               ! Space saving : lower traingle
!     CVEC, PTR :: square                 ! Space saving : lower traingle for real part, upper for imaginary
!  end 

contains

   create(n_bf,kind)
   ! Create an opmat object, in a basis set with "n_bf" spatial orbitals
      PTR :: self
      INT, IN :: n_bf
      STR(*), optional :: kind
      nullify(self)
      allocate(self)
      std_mm.add(OPMAT_SIZE)
      .nullify_ptr_part
      .n_bf = n_bf
      if (present(kind)) .create(kind)
   end

   destroy 
   ! Destroy an opmat object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      std_mm.delete(OPMAT_SIZE)
      deallocate(self)
   end

   create(kind)
   ! Create the appropriate spinorbital kind the opmat
      STR(*) :: kind
      INT :: n_bf
      n_bf = .n_bf
      select case (kind)
         case ("restricted");           .restricted.create(n_bf,n_bf)
         case ("unrestricted");         .alpha.create(n_bf,n_bf)
                                        .beta.create(n_bf,n_bf)
         case ("alpha");                .alpha.create(n_bf,n_bf)
         case ("beta");                 .beta.create(n_bf,n_bf)
         case ("general");              .general.create(2*n_bf,2*n_bf)
         case ("restricted_complex");   .restricted_complex.create(n_bf,n_bf)
         case ("unrestricted_complex"); .alpha_complex.create(n_bf,n_bf)
                                        .beta_complex.create(n_bf,n_bf)
         case ("alpha_complex");        .alpha_complex.create(n_bf,n_bf)
         case ("beta_complex");         .beta_complex.create(n_bf,n_bf)
         case ("general_complex");      .general_complex.create(2*n_bf,2*n_bf)
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   destroy(kind)
   ! Destroy the appropriate spinorbital kind of the opmat
      STR(*) :: kind
      select case (kind)
         case ("restricted");           .restricted.destroy
         case ("unrestricted");         .alpha.destroy; .beta.destroy
         case ("alpha");                .alpha.destroy
         case ("beta");                 .beta.destroy
         case ("general");              .general.destroy
         case ("restricted_complex");   .restricted_complex.destroy
         case ("unrestricted_complex"); .alpha_complex.destroy; .beta_complex.destroy
         case ("alpha_complex");        .alpha_complex.destroy
         case ("beta_complex");         .beta_complex.destroy
         case ("general_complex");      .general_complex.destroy
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the opmat object
      nullify(.restricted)
      nullify(.alpha)
      nullify(.beta)
      nullify(.general)
      nullify(.restricted_complex)
      nullify(.alpha_complex)
      nullify(.beta_complex)
      nullify(.general_complex)
      nullify(.triangle)
      nullify(.square)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of the opmat object
      .restricted.destroy
      .alpha.destroy
      .beta.destroy
      .general.destroy
      .restricted_complex.destroy
      .alpha_complex.destroy
      .beta_complex.destroy
      .general_complex.destroy
      .triangle.destroy
      .square.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   any_created result(res)
   ! Returns true if any component of self has been created
      BIN :: res
      BIN, dimension(6) :: c
      c(1) = .restricted.created
      c(2) = .alpha.created
      c(3) = .general.created
      c(4) = .restricted_complex.created
      c(5) = .alpha_complex.created
      c(6) = .general_complex.created
      res = any(c)
   end

   all_destroyed result(res)
   ! Returns true if all components of self have been destroyed
      BIN :: res
      BIN, dimension(6) :: d
      d(1) = .restricted.destroyed
      d(2) = .alpha.destroyed
      d(3) = .general.destroyed
      d(4) = .restricted_complex.destroyed
      d(5) = .alpha_complex.destroyed
      d(6) = .general_complex.destroyed
      res = all(d)
   end

   created(kind) result(res)
   ! Returns true if subkind "kind" of self has been created
      PTR :: self
      STR(*) :: kind
      BIN :: res
      if (NOT associated(self)) then;      res = FALSE; return
      else
         select case (kind)
            case ("restricted");           res = self%restricted.created
            case ("unrestricted");         res = self%alpha.created
            case ("general");              res = self%general.created
            case ("restricted_complex");   res = self%restricted_complex.created
            case ("unrestricted_complex"); res = self%alpha_complex.created
            case ("general_complex");      res = self%general_complex.created
            case default; DIE("unknown spinorbital kind, " // kind.trim)
         end
      end
   end

   destroyed(kind) result(res)
   ! Returns true if subkind "kind" of self has *not* been created
      PTR :: self
      STR(*) :: kind
      BIN :: res
      if (NOT associated(self)) then;      res = TRUE; return
      else
         select case (kind)
            case ("restricted");           res = self%restricted.destroyed
            case ("unrestricted");         res = self%alpha.destroyed
            case ("general");              res = self%general.destroyed
            case ("restricted_complex");   res = self%restricted_complex.destroyed
            case ("unrestricted_complex"); res = self%alpha_complex.destroyed
            case ("general_complex");      res = self%general_complex.destroyed
            case default; DIE("unknown spinorbital kind, " // kind.trim)
         end
      end
   end

   set(n_bf)
   ! Set with "n_bf" spatial orbitals
      INT :: n_bf
      .n_bf = n_bf
   end

   set_to(m) [leaky]
   ! Set self to m
      OPMAT :: m
      .set(m%n_bf)
      if ( m.all_destroyed) return
      if ( m%restricted.created) then
         .destroy("restricted"); .create("restricted")
         self%restricted = m%restricted
      end
      if ( m%alpha.created) then
         .destroy("alpha"); .create("alpha")
          self%alpha = m%alpha
      end
      if ( m%beta.created) then
         .destroy("beta"); .create("beta")
         self%beta = m%beta
      end
      if ( m%general.created) then
         .destroy("general"); .create("general")
         self%general = m%general
      end
      if ( m%restricted_complex.created) then
         .destroy("restricted_complex"); .create("restricted_complex")
         self%restricted_complex = m%restricted_complex
      end
      if ( m%alpha_complex.created) then
         .destroy("alpha_complex"); .create("alpha_complex")
         self%alpha_complex = m%alpha_complex
      end
      if ( m%beta_complex.created) then
         .destroy("beta_complex"); .create("beta_complex")
         self%beta_complex = m%beta_complex
      end
      if ( m%general_complex.created) then
         .destroy("general_complex"); .create("general_complex")
         self%general_complex = m%general_complex
      end
   end

   spinorbital_kind result(res)
   ! Return the kind of spinorbitals used in the representation
   ! The simplest spinorbital kind in use is the one returned.
      STR :: res
      if      ( .restricted.created )         then; res = "restricted"
      else if ( .alpha.created )              then; res = "unrestricted"
      else if ( .general.created )            then; res = "general"
      else if ( .restricted_complex.created ) then; res = "restricted_complex"
      else if ( .alpha_complex.created )      then; res = "unrestricted_complex"
      else if ( .general_complex.created )    then; res = "general_complex"
      else; DIE("no object created")
      end
   end

   number_kind result(res)
   ! Return the kind of numbers used in the representation
      STR :: res
      if      ( .restricted.created )         then; res = "real"
      else if ( .alpha.created )              then; res = "real"
      else if ( .general.created )            then; res = "real"
      else if ( .restricted_complex.created ) then; res = "complex"
      else if ( .alpha_complex.created )      then; res = "complex"
      else if ( .general_complex.created )    then; res = "complex"
      else; DIE("no object created")
      end
   end

   guess_scf_kind result(res)
   ! Guess the kind of SCF to be used from the spinorbitals used in the representation
      STR :: res
      if      ( .restricted.created )         then; res = "rhf"
      else if ( .alpha.created )              then; res = "uhf"
      else if ( .general.created )            then; res = "ghf"
      else if ( .restricted_complex.created ) then; res = "rchf"
      else if ( .alpha_complex.created )      then; res = "uchf"
      else if ( .general_complex.created )    then; res = "gchf"
      else; DIE("no object created")
      end
   end

   zero
   ! Set self to zero
      STR :: kind
      kind = .spinorbital_kind
      select case(kind)
         case("restricted");           .restricted = ZERO
         case("unrestricted");         .alpha = ZERO; .beta = ZERO
         case("alpha");                .alpha = ZERO
         case("beta");                 .beta = ZERO
         case("general");              .general = ZERO
         case("restricted_complex");   .restricted = ZERO
         case("unrestricted_complex"); .alpha_complex = ZERO; .beta_complex = ZERO
         case("alpha_complex");        .alpha_complex = ZERO
         case("beta_complex");         .beta_complex = ZERO
         case("general_complex");      .general_complex = ZERO
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   convert(newkind,factor) [leaky]
   ! Convert self to a new basis kind "newkind"
      STR(*) :: newkind
      DBL, optional :: factor
      DBL :: fac
      STR :: oldkind
      fac = ONE
      if (present(factor)) fac = factor
      oldkind = .spinorbital_kind
      if (newkind==oldkind) return
      .create(newkind)
      select case (oldkind)
         case("restricted")
            select case (newkind)
               case("unrestricted")
                  .alpha = fac*.restricted
                  .beta  = fac*.restricted
               case("general")
                  .general = ZERO
                  .general.set_alpha_alpha(fac*.restricted)
                  .general.set_beta_beta(fac*.restricted)
               case("restricted_complex")
                  .restricted_complex = .restricted
               case("unrestricted_complex")
                  .alpha_complex = fac*.restricted
                  .beta_complex  = fac*.restricted
               case("general_complex")
                  .general_complex = ZERO
                  .general_complex.set_alpha_alpha(fac*.restricted)
                  .general_complex.set_beta_beta(fac*.restricted)
            end
         case("unrestricted")
            select case (newkind)
               case("restricted")
                  .restricted = fac*.alpha
               case("general")
                  .general = ZERO
                  .general.set_alpha_alpha(.alpha)
                  .general.set_beta_beta(.beta)
               case("unrestricted_complex")
                  .alpha_complex = .alpha
                  .beta_complex  = .beta
               case("general_complex")
                  .general_complex = ZERO
                  .general_complex.set_alpha_alpha(.alpha)
                  .general_complex.set_beta_beta(.beta)
               case default
                  DIE("cant convert kind " // oldkind // " to kind " // newkind)
            end
         case("general")
            select case (newkind)
               case("unrestricted")
                  .alpha = .general.alpha_alpha
                  .beta  = .general.beta_beta
               case("general_complex")
                  .general_complex = .general
               case default
                  DIE("cant convert kind " // oldkind // " to kind " // newkind)
            end
         case default; DIE("cant convert old kind " // oldkind)
      end
      .destroy(oldkind)
   end

   l_compress(kind) result(res)
   ! Return the length of the compressed object
      INT :: res
      STR(*), optional :: kind
      STR :: k
      if (present(kind)) then; k = kind
      else;                    k = .spinorbital_kind
      end
      select case (k)
         case("restricted");           res = HALF*.n_bf*(.n_bf+1)
         case("unrestricted");         res = .n_bf*(.n_bf+1)
         case("general");              res = .n_bf*(2*.n_bf+1)
         case("restricted_complex");   res = .n_bf*.n_bf
         case("unrestricted_complex"); res = 2*.n_bf*.n_bf
         case("general_complex");      res = 4*.n_bf*.n_bf
      end
   end

   compress(kind) [leaky]
   ! Compress the opmat into a triangle or square vector to save space
      STR(*), optional :: kind
      STR :: k
      k = .spinorbital_kind
      if (present(kind)) k = kind
      select case (k)
         case("restricted")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .restricted.to_tri(.triangle)
            .restricted.destroy
         case("unrestricted")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .alpha.to_tri( .triangle.alpha)
            .beta.to_tri( .triangle.beta)
            .alpha.destroy
            .beta.destroy
         case("general")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .general.to_tri(.triangle)
         case("restricted_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .restricted_complex.to_square(.square)
            .restricted_complex.destroy
         case("unrestricted_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .alpha_complex.to_square( .square.alpha)
            .beta_complex.to_square( .square.beta)
            .alpha_complex.destroy
            .beta_complex.destroy
         case("general_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .general_complex.to_square( .square)
            .general_complex.destroy
      end
   end

   uncompress [leaky]
   ! Uncompress the opmat
      INT :: l_compress
      if (.triangle.created) l_compress = size(.triangle)
      if (.square.created)   l_compress = size(.square)
      if (l_compress==.l_compress("restricted")) then
            .destroy("restricted")
            .create("restricted")
            .restricted.from_tri(.triangle)
            .triangle.destroy
      else if (l_compress==.l_compress("unrestricted")) then
            .destroy("unrestricted")
            .create("unrestricted")
            .alpha.from_tri( .triangle.alpha)
            .beta.from_tri( .triangle.beta)
            .triangle.destroy
      else if (l_compress==.l_compress("general")) then
            .destroy("general")
            .create("general")
            .general.from_tri(.triangle)
            .triangle.destroy
      else if (l_compress==.l_compress("restricted_complex")) then
            .destroy("restricted_complex")
            .create("restricted_complex")
            .restricted_complex.from_square(.square)
            .square.destroy
      else if (l_compress==.l_compress("unrestricted_complex")) then
            .destroy("unrestricted_complex")
            .create("unrestricted_complex")
            .alpha_complex.from_square( .square.alpha)
            .beta_complex.from_square( .square.beta)
            .square.destroy
      else if (l_compress==.l_compress("general_complex")) then
            .destroy("general_complex")
            .create("general_complex")
            .general_complex.from_square(.square)
            .square.destroy
      end
   end

   schmidt_orthonormalise(mat)
   ! Schmidt Orthonormalise self.  (For molecular orbitals).
      MAT, IN :: mat
      STR :: kind
      kind = .spinorbital_kind
      select case(kind)
         case("restricted")
                  .restricted.schmidt_orthonormalise(mat)
         case("unrestricted")
                  .alpha.schmidt_orthonormalise(mat)
                  .beta.schmidt_orthonormalise(mat)
         case("alpha")
                  .alpha.schmidt_orthonormalise(mat)
         case("beta")
                  .beta.schmidt_orthonormalise(mat)
         case("general")
                  .general.schmidt_orthonormalise(mat)
         case("restricted_complex")
                  .restricted.schmidt_orthonormalise(mat)
         case("unrestricted_complex")
                  .alpha_complex.schmidt_orthonormalise(mat)
                  .beta_complex.schmidt_orthonormalise(mat)
         case("alpha_complex")
                  .alpha_complex.schmidt_orthonormalise(mat)
         case("beta_complex")
                  .beta_complex.schmidt_orthonormalise(mat)
         case("general_complex")
                  .general_complex.schmidt_orthonormalise(mat)
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

end 
