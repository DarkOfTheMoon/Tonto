!-------------------------------------------------------------------------------
!
! OPMAT: Operator matrices.
!
! Provide a basis set (matrix) representation of a one-electron quantum
! mechanical operator. Can cope with polymorphic types of basis representations,
! including restricted, unrestricted, and general basis orbital matrices.
! Also, complex types for all these matrices.
!
! Basically, its a polymorphic matrix type.
!
! (c) dylan jayatilaka 1998
!
! $Id$
!-------------------------------------------------------------------------------
module OPMAT

   use TYPES
   use SYSTEM
   use STR
   use VEC
   use MAT
   use CMAT

   implicit none

#  include "macros"
#  include "opmat.int"

!  type opmat_type
!     INT   :: n_bf                   ! AO basis set size
!     MAT*  :: restricted             ! Restricted spinorbital representation
!     MAT*  :: alpha                  ! Alpha part of a DODS representation
!     MAT*  :: beta                   ! Beta  part of a DODS representation
!     MAT*  :: general                ! General mixed alpha-beta matrix representation
!     CMAT* :: restricted_complex     ! Complex restricted representation
!     CMAT* :: alpha_complex          ! Complex alpha part of a DODS representation
!     CMAT* :: beta_complex           ! Complex beta  part of a DODS representation
!     CMAT* :: general_complex        ! Complex general mixed alpha-beta matrix representation
!     VEC*  :: triangle               ! Space saving : lower traingle
!     CVEC* :: square                 ! Space saving : lower traingle for real part, upper for imaginary
!  end

contains

   create(n_bf)
   ! Create an opmat object, in a basis set with "n_bf" spatial orbitals
      PTR :: self
      INT, IN, optional :: n_bf
      nullify(self)
      allocate(self)
      ADD_MEM(OPMAT_SIZE)
      .nullify_ptr_part
      .n_bf = 0
      if (present(n_bf)) .n_bf = n_bf
   end

   create(n_bf,kind)
   ! Create an opmat object, in a basis set with "n_bf" spatial orbitals
      PTR :: self
      INT, IN :: n_bf
      STR(*) :: kind
      .create(n_bf)
      .create(kind)
   end

   create_copy(m)
   ! Create an opmat object
      PTR :: self
      OPMAT, IN :: m
      .create(m.n_bf)
      .set_to(m)
   end

   destroy
   ! Destroy an opmat object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(OPMAT_SIZE)
      deallocate(self)
   end

   create(kind)
   ! Create the appropriate spinorbital kind the opmat
      STR(*), IN :: kind
      INT :: n_bf
      n_bf = .n_bf
      ENSURE(n_bf > 0, "bad number of basis functions.")
      select case (kind)
         case ("restricted");           .restricted.create(n_bf,n_bf)
         case ("unrestricted");         .alpha.create(n_bf,n_bf)
                                        .beta.create(n_bf,n_bf)
         case ("alpha");                .alpha.create(n_bf,n_bf)
         case ("beta");                 .beta.create(n_bf,n_bf)
         case ("general");              .general.create(2*n_bf,2*n_bf)
         case ("restricted_complex");   .restricted_complex.create(n_bf,n_bf)
         case ("unrestricted_complex"); .alpha_complex.create(n_bf,n_bf)
                                        .beta_complex.create(n_bf,n_bf)
         case ("alpha_complex");        .alpha_complex.create(n_bf,n_bf)
         case ("beta_complex");         .beta_complex.create(n_bf,n_bf)
         case ("general_complex");      .general_complex.create(2*n_bf,2*n_bf)
         case default; DIE("unknown spinorbital kind, " // trim(kind))
      end
   end

   destroy(kind)
   ! Destroy the appropriate spinorbital kind of the opmat
      STR(*) :: kind
      select case (kind)
         case ("restricted");           .restricted.destroy
         case ("unrestricted");         .alpha.destroy; .beta.destroy
         case ("alpha");                .alpha.destroy
         case ("beta");                 .beta.destroy
         case ("general");              .general.destroy
         case ("restricted_complex");   .restricted_complex.destroy
         case ("unrestricted_complex"); .alpha_complex.destroy
                                        .beta_complex.destroy
         case ("alpha_complex");        .alpha_complex.destroy
         case ("beta_complex");         .beta_complex.destroy
         case ("general_complex");      .general_complex.destroy
         case ("all");                  .destroy_ptr_part
         case default; DIE("unknown spinorbital kind, " // trim(kind))
      end
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the opmat object
      nullify(.restricted)
      nullify(.alpha)
      nullify(.beta)
      nullify(.general)
      nullify(.restricted_complex)
      nullify(.alpha_complex)
      nullify(.beta_complex)
      nullify(.general_complex)
      nullify(.triangle)
      nullify(.square)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of the opmat object
      .restricted.destroy
      .alpha.destroy
      .beta.destroy
      .general.destroy
      .restricted_complex.destroy
      .alpha_complex.destroy
      .beta_complex.destroy
      .general_complex.destroy
      .triangle.destroy
      .square.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   any_created result(res)
   ! Returns true if any component of self has been created
      BIN :: res
      BIN, dimension(6) :: c
      c(1) = .restricted.created
      c(2) = .alpha.created
      c(3) = .general.created
      c(4) = .restricted_complex.created
      c(5) = .alpha_complex.created
      c(6) = .general_complex.created
      res = any(c)
   end

   all_destroyed result(res)
   ! Returns true if all components of self have been destroyed
      BIN :: res
      BIN, dimension(6) :: d
      d(1) = .restricted.destroyed
      d(2) = .alpha.destroyed
      d(3) = .general.destroyed
      d(4) = .restricted_complex.destroyed
      d(5) = .alpha_complex.destroyed
      d(6) = .general_complex.destroyed
      res = all(d)
   end

   created(kind) result(res)
   ! Returns true if subkind "kind" of self has been created
      PTR :: self
      STR(*) :: kind
      BIN :: res
      if (NOT associated(self)) then
                                           res = FALSE; RETURN
      else
         select case (kind)
            case ("restricted");           res = .restricted.created
            case ("unrestricted");         res = .alpha.created
            case ("general");              res = .general.created
            case ("restricted_complex");   res = .restricted_complex.created
            case ("unrestricted_complex"); res = .alpha_complex.created
            case ("general_complex");      res = .general_complex.created
            case default; DIE("unknown spinorbital kind, " // trim(kind))
         end
      end
   end

  destroyed(kind) result(res)
  ! Returns true if subkind "kind" of self has *not* been created
!    PTR :: self
    STR(*) :: kind
    BIN :: res
!    if (NOT associated(self)) then
!                                       res = TRUE; RETURN
!    else
      select case (kind)
        case ("restricted");           res = .restricted.destroyed
        case ("unrestricted");         res = .alpha.destroyed
        case ("general");              res = .general.destroyed
        case ("restricted_complex");   res = .restricted_complex.destroyed
        case ("unrestricted_complex"); res = .alpha_complex.destroyed
        case ("general_complex");      res = .general_complex.destroyed
        case default; DIE("unknown spinorbital kind, " // trim(kind))
      end
!    end
  end

   set(n_bf)
   ! Set with "n_bf" spatial orbitals
      INT, IN :: n_bf
      .n_bf = n_bf
   end

   set_to(m) [leaky]
   ! Set self to "m".
     OPMAT, IN :: m
     INT :: old_n_bf
     old_n_bf = .n_bf
     .set( m.n_bf)
     if ( m.restricted.created) then
        if (NOT old_n_bf == .n_bf)    .destroy("restricted")
        if (.restricted.destroyed) .create("restricted")
        .restricted = m.restricted
     end
     if ( m.alpha.created) then
        if (NOT old_n_bf == .n_bf)    .destroy("alpha")
        if (.alpha.destroyed) .create("alpha")
        .alpha = m.alpha
     end
     if ( m.beta.created) then
        if (NOT old_n_bf == .n_bf)    .destroy("beta")
        if (.beta.destroyed) .create("beta")
        .beta = m.beta
     end
     if ( m.general.created) then
        if (NOT old_n_bf == .n_bf)    .destroy("general")
        if (.general.destroyed) .create("general")
        .general = m.general
     end
     if ( m.restricted_complex.created) then
        if (NOT old_n_bf == .n_bf)    .destroy("restricted_complex")
        if (.destroyed("restricted_complex")) .create("restricted_complex")
        .restricted_complex = m.restricted_complex
     end
     if ( m.alpha_complex.created) then
        if (NOT old_n_bf == .n_bf)    .destroy("alpha_complex")
        if (.destroyed("alpha_complex")) .create("alpha_complex")
        .alpha_complex = m.alpha_complex
     end
     if ( m.beta_complex.created) then
        if (NOT old_n_bf == .n_bf)    .destroy("beta_complex")
        if (.destroyed("beta_complex")) .create("beta_complex")
        .beta_complex = m.beta_complex
     end
     if ( m.general_complex.created) then
        if (NOT old_n_bf == .n_bf)    .destroy("general_complex")
        if (.destroyed("general_complex")) .create("general_complex")
        .general_complex = m.general_complex
     end
   end

   spinorbital_kind result(res)
   ! Return the kind of spinorbitals used in the representation
   ! The simplest spinorbital kind in use is the one returned.
      STR :: res
      if      ( .restricted.created )         then; res = "restricted"
      else if ( .alpha.created )              then; res = "unrestricted"
      else if ( .general.created )            then; res = "general"
      else if ( .restricted_complex.created ) then; res = "restricted_complex"
      else if ( .alpha_complex.created )      then; res = "unrestricted_complex"
      else if ( .general_complex.created )    then; res = "general_complex"
      else; DIE("no object created")
      end
   end

   number_kind result(res)
   ! Return the kind of numbers used in the representation
      STR :: res
      if      ( .restricted.created )         then; res = "real"
      else if ( .alpha.created )              then; res = "real"
      else if ( .general.created )            then; res = "real"
      else if ( .restricted_complex.created ) then; res = "complex"
      else if ( .alpha_complex.created )      then; res = "complex"
      else if ( .general_complex.created )    then; res = "complex"
      else; DIE("no object created")
      end
   end

   guess_scf_kind result(res)
   ! Guess the kind of SCF to be used from the spinorbitals used in the
   ! representation.
      STR :: res
      if      ( .restricted.created )         then; res = "rhf"
      else if ( .alpha.created )              then; res = "uhf"
      else if ( .general.created )            then; res = "ghf"
      else if ( .restricted_complex.created ) then; res = "rchf"
      else if ( .alpha_complex.created )      then; res = "uchf"
      else if ( .general_complex.created )    then; res = "gchf"
      else; DIE("no object created")
      end
   end

   zero
   ! Set self to zero
      STR :: kind
      kind = .spinorbital_kind
      select case(kind)
         case("restricted");           .restricted = ZERO
         case("unrestricted");         .alpha = ZERO; .beta = ZERO
         case("alpha");                .alpha = ZERO
         case("beta");                 .beta = ZERO
         case("general");              .general = ZERO
         case("restricted_complex");   .restricted = ZERO
         case("unrestricted_complex"); .alpha_complex = ZERO
                                       .beta_complex = ZERO
         case("alpha_complex");        .alpha_complex = ZERO
         case("beta_complex");         .beta_complex = ZERO
         case("general_complex");      .general_complex = ZERO
         case default; DIE("unknown spinorbital kind, " // trim(kind))
      end
   end

   convert_to(newkind,factor) [leaky]
   ! Convert self to a new basis kind "newkind".  To convert MO's please use
   ! the next routine.
      STR(*) :: newkind
      DBL, optional :: factor
      DBL :: fac
      STR :: oldkind
      fac = ONE
      if (present(factor)) fac = factor
      oldkind = .spinorbital_kind
      if (newkind==oldkind) return
      .create(newkind)
      select case (oldkind)
         case("restricted")
            select case (newkind)
               case("unrestricted")
                  .alpha = fac*.restricted
                  .beta  = fac*.restricted
               case("general")
                  .general = ZERO
                  .general.alpha_alpha_set_to(.restricted,factor=fac)
                  .general.beta_beta_set_to(.restricted,factor=fac)
               case("restricted_complex")
                  .restricted_complex = .restricted
               case("unrestricted_complex")
                  .alpha_complex = fac*.restricted
                  .beta_complex  = fac*.restricted
               case("general_complex")
                  .general_complex = ZERO
                  .general_complex.alpha_alpha_set_to(.restricted,factor=fac)
                  .general_complex.beta_beta_set_to(.restricted,factor=fac)
               case default
                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))
            end
         case("unrestricted")
            select case (newkind)
               case("restricted")
                  .restricted = fac*.alpha
               case("general")
                  .general = ZERO
                  .general.alpha_alpha_set_to(.alpha)
                  .general.beta_beta_set_to(.beta)
               case("unrestricted_complex")
                  .alpha_complex = .alpha
                  .beta_complex  = .beta
               case("general_complex")
                  .general_complex = ZERO
                  .general_complex.alpha_alpha_set_to(.alpha)
                  .general_complex.beta_beta_set_to(.beta)
               case default
                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))
            end
         case("general")
            select case (newkind)
               case("unrestricted")
                  .alpha = .general.alpha_alpha
                  .beta  = .general.beta_beta
               case("general_complex")
                  .general_complex = .general
               case default
                  DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))
            end
         case default; DIE("cant convert old kind "//trim(oldkind))
      end
      .destroy(oldkind)
   end

  convert_to(newkind,na,nb,quantization_axis) [leaky]
  ! Convert self (which is regarded to be a set of MO's) to a
  ! new basis kind "newkind"
    STR(*) :: newkind
    INT :: na,nb
    VEC(3), optional :: quantization_axis
    BIN :: quantize
    STR :: oldkind
    INT :: d,ne
    DBL :: lam,tmp,ar,br,bi
    d = .n_bf
    ne = na + nb
    oldkind = .spinorbital_kind
    if (newkind==oldkind) return
    .create(newkind)
    select case (oldkind)
      case("restricted")
        select case (newkind)
          case("unrestricted")
            .alpha = .restricted
            .beta  = .restricted
          case("general")
            .general = ZERO
            .general(  1:d,     1:2*nb-1:2) = .restricted(:,   1:nb)
            .general(d+1: ,     2:2*nb  :2) = .restricted(:,   1:nb)
            .general(  1:d,2*nb+1:ne      ) = .restricted(:,nb+1:na)
            .general(d+1: ,  ne+1:2*na    ) = .restricted(:,nb+1:na)
            .general(1:d  ,2*na+1:2*d -1:2) = .restricted(:,na+1: d)
            .general(d+1: ,2*na+2:2*d   :2) = .restricted(:,na+1: d)
          case("restricted_complex")
            .restricted_complex = .restricted
          case("unrestricted_complex")
            .alpha_complex = .restricted
            .beta_complex  = .restricted
          case("general_complex")
            .general_complex = ZERO
            .general_complex(  1:d,     1:2*nb-1:2) = .restricted(:,   1:nb)
            .general_complex(d+1: ,     2:2*nb  :2) = .restricted(:,   1:nb)
            .general_complex(  1:d,2*nb+1:ne      ) = .restricted(:,nb+1:na)
            .general_complex(d+1: ,  ne+1:2*na    ) = .restricted(:,nb+1:na)
            .general_complex(  1:d,2*na+1:2*d -1:2) = .restricted(:,na+1: d)
            .general_complex(d+1: ,2*na+2:2*d   :2) = .restricted(:,na+1: d)
          case default
            DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))
        end
      case("unrestricted")
        select case (newkind)
          case("restricted","alpha")
            .restricted = .alpha ! Loss of information here
            WARN("Conversion from unrestricted to restricted ignores beta orbitals")
          case("beta")
            .restricted = .beta  ! Loss of information here
            WARN("Conversion from unrestricted to restricted ignores alpha orbitals")
          case("general")
            .general = ZERO
            .general(  1:d,     1:2*nb-1:2) = .alpha(:,   1:nb)
            .general(d+1: ,     2:2*nb  :2) = .beta (:,   1:nb)
            .general(  1:d,2*nb+1:ne      ) = .alpha(:,nb+1:na)
            .general(d+1: ,  ne+1:2*na    ) = .beta (:,nb+1:na)
            .general(  1:d,2*na+1:2*d -1:2) = .alpha(:,na+1: d)
            .general(d+1: ,2*na+2:2*d   :2) = .beta (:,na+1: d)
          case("unrestricted_complex")
            .alpha_complex = .alpha
            .beta_complex  = .beta
          case("general_complex")
            .general_complex = ZERO
            quantize = FALSE
            if (present(quantization_axis)) &
              quantize = NOT quantization_axis.equals((/ZERO,ZERO,ONE/))
            if (quantize) then
              lam = quantization_axis.norm
              tmp = abs(quantization_axis(3)+lam) ! always positive anyway
              if (tmp.equals(ZERO)) then
                 ar = ZERO
                 br = ONE
                 bi = ZERO
              else
                 ar = sqrt(tmp/(TWO*lam))
                 br = ONE/sqrt(TWO*lam*tmp)
                 bi = br
                 br = br*quantization_axis(1)
                 bi = bi*quantization_axis(2)
              end
              .general_complex(d+1: ,     1:  na) = cmplx(br,bi)*.alpha(:,   1:na)
              .general_complex(  1:d,     1:  na) =           ar*.alpha(:,   1:na)
              .general_complex(d+1: ,  ne+1:nb+d) = cmplx(br,bi)*.alpha(:,na+1: d)
              .general_complex(  1:d,  ne+1:nb+d) =           ar*.alpha(:,na+1: d)
              br = -br
              .general_complex(  1:d,  na+1:ne  ) = cmplx(br,bi)*.beta (:,   1:nb)
              .general_complex(d+1: ,  na+1:ne  ) =           ar*.beta (:,   1:nb)
              .general_complex(  1:d,nb+d+1:    ) = cmplx(br,bi)*.beta (:,nb+1: d)
              .general_complex(d+1: ,nb+d+1:    ) =           ar*.beta (:,nb+1: d)
            else
              .general_complex(  1:d,     1:na  ) = .alpha(:,   1:na)
              .general_complex(d+1: ,  na+1:ne  ) = .beta (:,   1:nb)
              .general_complex(  1:d,  ne+1:nb+d) = .alpha(:,na+1:  )
              .general_complex(d+1: ,nb+d+1:    ) = .beta (:,nb+1:  )
            end
          case default
            DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))
        end
      case("general")
        select case (newkind)
          case("unrestricted")
            .general.alpha_alpha_put_to(.alpha)
            .general.beta_beta_put_to(.beta)
            WARN("Conversion from general to unrestricted not recommended!")
          case("general_complex")
            .general_complex = .general
          case default
            DIE("cant convert kind "//trim(oldkind)//" to kind "//trim(newkind))
        end
      case default; DIE("cant convert old kind "//trim(oldkind))
    end
    .destroy(oldkind)
  end

   l_compress(kind) result(res)
   ! Return the length of the compressed object
      INT :: res
      STR(*), optional :: kind
      STR :: k
      if (present(kind)) then; k = kind
      else;                    k = .spinorbital_kind
      end
      select case (k)
         case("restricted");           res = HALF*.n_bf*(.n_bf+1)
         case("unrestricted");         res = .n_bf*(.n_bf+1)
         case("general");              res = .n_bf*(2*.n_bf+1)
         case("restricted_complex");   res = .n_bf*.n_bf
         case("unrestricted_complex"); res = 2*.n_bf*.n_bf
         case("general_complex");      res = 4*.n_bf*.n_bf
      end
   end

   compress(kind) [leaky]
   ! Compress the opmat into a triangle or square vector to save space
      STR(*), optional :: kind
      STR :: k
      k = .spinorbital_kind
      if (present(kind)) k = kind
      select case (k)
         case("restricted")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .restricted.to_tri(.triangle)
            .restricted.destroy
         case("unrestricted")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .alpha.to_tri( .triangle.alpha)
            .beta.to_tri( .triangle.beta)
            .alpha.destroy
            .beta.destroy
         case("general")
            .triangle.destroy
            .triangle.create(.l_compress(k))
            .general.to_tri(.triangle)
         case("restricted_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .restricted_complex.to_square(.square)
            .restricted_complex.destroy
         case("unrestricted_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .alpha_complex.to_square( .square.alpha)
            .beta_complex.to_square( .square.beta)
            .alpha_complex.destroy
            .beta_complex.destroy
         case("general_complex")
            .square.destroy
            .square.create(.l_compress(k))
            .general_complex.to_square( .square)
            .general_complex.destroy
      end
   end

   uncompress [leaky]
   ! Uncompress the opmat
      INT :: l_compress
      if (.triangle.created) l_compress = size(.triangle)
      if (.square.created)   l_compress = size(.square)
      if (l_compress==.l_compress("restricted")) then
            .destroy("restricted")
            .create("restricted")
            .restricted.from_tri(.triangle)
            .triangle.destroy
      else if (l_compress==.l_compress("unrestricted")) then
            .destroy("unrestricted")
            .create("unrestricted")
            .alpha.from_tri( .triangle.alpha)
            .beta.from_tri( .triangle.beta)
            .triangle.destroy
      else if (l_compress==.l_compress("general")) then
            .destroy("general")
            .create("general")
            .general.from_tri(.triangle)
            .triangle.destroy
      else if (l_compress==.l_compress("restricted_complex")) then
            .destroy("restricted_complex")
            .create("restricted_complex")
            .restricted_complex.from_square(.square)
            .square.destroy
      else if (l_compress==.l_compress("unrestricted_complex")) then
            .destroy("unrestricted_complex")
            .create("unrestricted_complex")
            .alpha_complex.from_square( .square.alpha)
            .beta_complex.from_square( .square.beta)
            .square.destroy
      else if (l_compress==.l_compress("general_complex")) then
            .destroy("general_complex")
            .create("general_complex")
            .general_complex.from_square(.square)
            .square.destroy
      end
   end

   schmidt_orthonormalise(mat)
   ! Schmidt Orthonormalise self.  (For molecular orbitals).
      MAT, IN :: mat
      STR :: kind
      INT :: n
      MAT* :: S
      kind = .spinorbital_kind
      select case(kind)
         case("restricted")
                  .restricted.schmidt_orthonormalise(mat)
         case("unrestricted")
                  .alpha.schmidt_orthonormalise(mat)
                  .beta.schmidt_orthonormalise(mat)
         case("alpha")
                  .alpha.schmidt_orthonormalise(mat)
         case("beta")
                  .beta.schmidt_orthonormalise(mat)
         case("general")
                  n = size(mat,1)*2
                  S.create(n,n)
                  S = ZERO
                  S.alpha_alpha_set_to(mat)
                  S.beta_beta_set_to(mat)
                  .general.schmidt_orthonormalise(S)
                  S.destroy
         case("restricted_complex")
                  .restricted.schmidt_orthonormalise(mat)
         case("unrestricted_complex")
                  .alpha_complex.schmidt_orthonormalise(mat)
                  .beta_complex.schmidt_orthonormalise(mat)
         case("alpha_complex")
                  .alpha_complex.schmidt_orthonormalise(mat)
         case("beta_complex")
                  .beta_complex.schmidt_orthonormalise(mat)
         case("general_complex")
                  n = size(mat,1)*2
                  S.create(n,n)
                  S = ZERO
                  S.alpha_alpha_set_to(mat)
                  S.beta_beta_set_to(mat)
                  .general_complex.schmidt_orthonormalise(S)
                  S.destroy
         case default; DIE("unknown spinorbital kind, " // trim(kind))
      end
   end

  plus(mat)
  ! Add mat to self.
    OPMAT, IN :: mat
    STR :: kind,kind2
    kind = .spinorbital_kind
    kind2 = mat.spinorbital_kind
    ENSURE(kind==kind2,"incompatible kinds of matrices")
    select case(kind)
      case("restricted")
        .restricted.plus(mat.restricted)
      case("unrestricted")
        .alpha.plus(mat.alpha)
        .beta.plus(mat.beta)
      case("alpha")
        .alpha.plus(mat.alpha)
      case("beta")
        .beta.plus(mat.beta)
      case("general")
        .general.plus(mat.general)
      case("restricted_complex")
        .restricted.plus(mat.restricted)
      case("unrestricted_complex")
        .alpha_complex.plus(mat.alpha_complex)
        .beta_complex.plus(mat.beta_complex)
      case("alpha_complex")
        .alpha_complex.plus(mat.alpha_complex)
      case("beta_complex")
        .beta_complex.plus(mat.beta_complex)
      case("general_complex")
        .general_complex.plus(mat.general_complex)
      case default; DIE("unknown spinorbital kind, " // trim(kind))
    end
  end

  minus(mat)
  ! Subtract mat from self.
    OPMAT, IN :: mat
    STR :: kind,kind2
    kind = .spinorbital_kind
    kind2 = mat.spinorbital_kind
    ENSURE(kind==kind2,"incompatible kinds of matrices")
    select case(kind)
      case("restricted")
        .restricted.minus(mat.restricted)
      case("unrestricted")
        .alpha.minus(mat.alpha)
        .beta.minus(mat.beta)
      case("alpha")
        .alpha.minus(mat.alpha)
      case("beta")
        .beta.minus(mat.beta)
      case("general")
        .general.minus(mat.general)
      case("restricted_complex")
        .restricted.minus(mat.restricted)
      case("unrestricted_complex")
        .alpha_complex.minus(mat.alpha_complex)
        .beta_complex.minus(mat.beta_complex)
      case("alpha_complex")
        .alpha_complex.minus(mat.alpha_complex)
      case("beta_complex")
        .beta_complex.minus(mat.beta_complex)
      case("general_complex")
        .general_complex.minus(mat.general_complex)
      case default; DIE("unknown spinorbital kind, " // trim(kind))
    end
  end

end
