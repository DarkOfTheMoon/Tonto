!-------------------------------------------------------------------------------
!
! BECKE_GRID 
! 
! This module provides a grid and weights for 3D numerical quadrature, where the
! 3D integrand is comprised of peaks which are centered at points in space which
! are known beforehand (they may be the positions of the atoms in a molecule,
! for example, and the integrand may be the density). 
!
! These grids were first designed by Axel Becke. See the references: 
!     A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
!     O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
!     M. Mura and P. Knowles, J. Chem. Phys. 104 (1996) p 9848.
!
! The 3-D grid is a direct-product combination of a radial grid and a spherical
! grid. The radial grids are standard one-dimensional types (Chebyshev,
! Euler-Maclaurin, etc) while the spherical grids are Lebedev-Laikov grids with
! octahedral symmetry designed to integrate exactly spherical harmonics up to
! angular momentum L=53 or higher. A minimum L=11 is recommended. The number of
! radial points for each atom is defined by reference to the number of points
! for Hydrogen, according to Becke's rule of thumb (5 points more for each
! atomic n-shell).
!
! The grid is essentially composed of a superposition of spherical grids, which
! have been "translated", "scaled", and "partitioned" to take into account
! that the grids are overlapping and interpenetrating.
!
! This version is essentially completely rewritten compared to Steve Wolff's
! original version. Some code remains from the original elliptic partitioning.
!
! Copyright (C) S. K. Wolff, 1999
! Copyright (C) D. Jayatilaka, 2005
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!-------------------------------------------------------------------------------

module BECKE_GRID

   implicit none

!   type BECKE_GRID
!
!   kind :: STR  DEFAULT(BECKE_GRID_KIND)
!   ! The exact type of Becke grid to use
!
!   atom_Z :: VEC{INT}*  DEFAULT_NULL
!   ! List of atomic numbers for the atoms which are to be integrated
!
!   atom_pos :: MAT{REAL}*  DEFAULT_NULL
!   ! List of atomic positions for the atoms which are to be integrated
!
!   atom_zeta :: VEC{REAL}*  DEFAULT_NULL
!   ! List of scaling factors used in the transformation to the radial
!   ! integration interval.
!
!   n_radial_points ::  INT DEFAULT(0)
!   ! No. of radial points desired for the Hydrogen atom. The number of points
!   ! used for other atoms is normally 5 more for every extra shell, according
!   ! to Becke's original rule of thumb.
!
!   n_extra_points_per_shell ::  INT DEFAULT(5)
!   ! The number of extra points to use per n-shell over and above the default
!   ! number .n_radial_points for the Hydrogen atom.
!
!   l_angular_grid ::  INT DEFAULT(0)
!   ! Angular momentum which is to be integrated exactly by the angular grid.
!
!   l_H_angular_grid ::  INT DEFAULT(0)
!   ! Angular momentum which is to be integrated exactly by the angular grid
!   ! for the Hydrogen/Helium atoms only. Used only if .reduce_H_angular_grid is
!   ! set TRUE. For non-H and non-He atoms .l_angular_grid is always used.
!
!   reduce_core_angular_grid :: BIN  DEFAULT(TRUE)
!   ! If set TRUE the order of the angular grid near the core of the atom is
!   ! reduced to make smaller meshes. So far the scheme of Treutler and Ahlrichs
!   ! is used.
!
!   reduce_H_angular_grid :: BIN  DEFAULT(TRUE)
!   ! If set TRUE the order of the angular grid for Hydrogen and Helium are
!   ! reduced to .l_H_angular_grid.
!
!   scale_atomic_grids :: BIN  DEFAULT(TRUE)
!   ! If set TRUE, the atomic grids are scaled according to the authors
!   ! recommended scaling factors. This does *not* mean that the partition
!   ! function is also scaled to account for varying atomic sizes.
!
!   partition_power :: REAL  DEFAULT(BECKE_GRID_PARTITION_POWER)
!   ! Used in smoothing the partition boundary
!
!   partition_scaling_scheme :: BIN  DEFAULT("treutler_ahlrichs")
!   ! This chooses the precise method to scale the sizes of the atoms in
!   ! Becke-like partition function schemes based on elliptic coordiantes. 
!   ! The scaling is based on the Bragg-Slater radii (except for H, where
!   ! twice the radii is used). Treutler and Ahlrichs recommended using the
!   ! square root of the ration of Bragg Slater radii.
!
!   finalized :: BIN  DEFAULT(FALSE)
!   ! Set to true if the DFTGRID has been "set" using set_grid_data
!
!   radial_grid :: VEC{QUADRATURE}*  DEFAULT_NULL
!   ! The radial quadrature points, one for every row of the periodic table.
!
!   lebedev_grid :: LEBEDEV*  DEFAULT_NULL
!   ! The angular quadrature points. We use a Lebedev grid.
!
!   lebedev_H_grid :: LEBEDEV*  DEFAULT_NULL
!   ! The angular quadrature points for the Hydrogen atom.
!
!   lebedev_L5_grid :: LEBEDEV*  DEFAULT_NULL
!   ! Angular quadrature points for L=5, used close to the atom.
!
!   lebedev_L11_grid :: LEBEDEV*  DEFAULT_NULL
!   ! Angular quadrature points for L=11, used close to the atom.
!
!   n_unscaled_points :: INT DEFAULT(0)
!   ! No. of quadrature points in the reference atom.
!
!   unscaled_point :: MAT{REAL}*, private  DEFAULT_NULL
!   ! The unscaled spherical quadrature grid points centered at the origin, 
!   ! for a reference atom.
!
!   unscaled_weight :: VEC{REAL}*, private  DEFAULT_NULL
!   ! The unscaled spherical quadrature grid weights for a reference atom.
!
!   n_points :: INT DEFAULT(0)
!   ! No. of points in quadrature grid for the whole molecule.
!
!   point :: MAT{REAL}*  DEFAULT_NULL
!   ! The complete list of grid points appropriate for the specified atoms
!
!   weight :: VEC{REAL}*  DEFAULT_NULL
!   ! The complete list of grid weights appropriate for the specified atoms
!
!   end

   ! These are the Bragg slater radii.
   ! WARNING: These are in Angstroms.
   bragg_slater_radius :: VEC{REAL}(89), private 
   data bragg_slater_radius/ &
      0.35d0,0.35d0,                                           & ! 1s
      1.45d0,1.05d0,0.85d0,0.70d0,0.65d0,0.60d0,0.50d0,0.45d0, & ! 2s+2p
      1.80d0,1.50d0,1.25d0,1.10d0,1.00d0,1.00d0,1.00d0,1.00d0, & ! 3s+3p
      2.20d0,1.80d0,                                           & ! 4s
      1.60d0,1.40d0,1.35d0,1.40d0,1.40d0,                      & ! 3d: 1st transition
      1.40d0,1.35d0,1.35d0,1.35d0,1.35d0,                      &
                    1.30d0,1.25d0,1.15d0,1.15d0,1.15d0,1.15d0, & ! 4p
      1.30d0,1.30d0,                                           & ! 5s
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      & ! 4d: 2nd transition
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0, & ! 5p
      1.30d0,1.30d0,                                           & ! 6s
      1.30d0,                                                  & ! Lanthanum
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,        & ! 4f: 1st Lanthanide
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,        &
             1.30d0,1.30d0,1.30d0,1.30d0,                      & ! 5d: 3rd transition
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0, & ! 6p
      1.30d0,1.30d0,                                           & ! 7s
      1.30d0                                                   / ! Ac

   ! Treutler and Ahlrichs recommended zeta values
   ! WARNING: I think these are in Angstroms.
   TA_zeta :: VEC{REAL}(89), private 
   data TA_zeta/ &
      0.80d0,0.90d0,                                           & ! 1s
      1.80d0,1.40d0,1.30d0,1.10d0,0.90d0,0.90d0,0.90d0,0.90d0, & ! 2s+2p
      1.40d0,1.30d0,1.30d0,1.20d0,1.10d0,1.00d0,1.00d0,1.00d0, & ! 3s+3p
      1.50d0,1.40d0,                                           & ! 4s
      1.30d0,1.20d0,1.20d0,1.20d0,1.20d0,                      & ! 3d: 1st transition
      1.20d0,1.20d0,1.10d0,1.10d0,1.10d0,                      &
                    1.10d0,1.00d0,0.90d0,0.90d0,0.90d0,0.90d0, & ! 4p: values after here are guessed
      1.50d0,1.40d0,                                           & ! 5s
      1.30d0,1.20d0,1.20d0,1.20d0,1.20d0,                      & ! 4d: 2nd transition
      1.20d0,1.20d0,1.10d0,1.10d0,1.10d0,                      &
                    1.10d0,1.00d0,0.90d0,0.90d0,0.90d0,0.90d0, & ! 5p
      1.50d0,1.40d0,                                           & ! 6s
      1.30d0,                                                  & ! Lanthanum
      1.00d0,1.00d0,1.00d0,1.00d0,1.00d0,1.00d0,1.00d0,        & ! 4f: 1st Lanthanide
      1.00d0,1.00d0,1.00d0,1.00d0,1.00d0,1.00d0,1.00d0,        &
             1.00d0,1.00d0,1.00d0,1.00d0,                      & ! 5d: 3rd transition
      1.00d0,1.00d0,1.00d0,1.00d0,1.00d0,                      &
                    1.00d0,1.00d0,1.00d0,1.00d0,1.00d0,1.00d0, & ! 6p
      1.50d0,1.40d0,                                           & ! 7s
      1.30d0                                                   / ! Ac

   ! Mura and Knowles recommended alpha values
   ! These are in atomic units
   MK_zeta :: VEC{REAL}(89), private 
   data MK_zeta/ &
      5.00d0,5.00d0,                                           & ! 1s
      7.00d0,7.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0, & ! 2s+2p
      7.00d0,7.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0, & ! 3s+3p
      7.00d0,7.00d0,                                           & ! 4s
      5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,                      & ! 3d: 1st transition
      5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,                      &
                    5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0, & ! 4p: values after here are guessed
      7.00d0,7.00d0,                                           & ! 5s
      5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,                      & ! 4d: 2nd transition
      5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,                      &
                    5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0, & ! 5p
      7.00d0,7.00d0,                                           & ! 6s
      5.00d0,                                                  & ! Lanthanum
      5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,        & ! 4f: 1st Lanthanide
      5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,        &
             5.00d0,5.00d0,5.00d0,5.00d0,                      & ! 5d: 3rd transition
      5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,                      &
                    5.00d0,5.00d0,5.00d0,5.00d0,5.00d0,5.00d0, & ! 6p
      7.00d0,7.00d0,                                           & ! 7s
      5.00d0                                                   / ! Ac

   ! The period of the atom. Needed because the number of radial points
   ! depends on the atom's period number.
   period :: VEC{INT}(89), private 
   data period/ &
           1,     1,                                           & ! 1s
           2,     2,     2,     2,     2,     2,     2,     2, & ! 2s+2p
           3,     3,     3,     3,     3,     3,     3,     3, & ! 3s+3p
           4,     4,                                           & ! 4s
           4,     4,     4,     4,     4,                      & ! 3d: 1st transition
           4,     4,     4,     4,     4,                      &
                         4,     4,     4,     4,     4,     4, & ! 4p
           5,     5,                                           & ! 5s
           5,     5,     5,     5,     5,                      & ! 4d: 2nd transition
           5,     5,     5,     5,     5,                      &
                         5,     5,     5,     5,     5,     5, & ! 5p
           6,     6,                                           & ! 6s
           6,                                                  & ! Lanthanum
           6,     6,     6,     6,     6,     6,     6,        & ! 4f: 6st Lanthanide
           6,     6,     6,     6,     6,     6,     6,        &
                  6,     6,     6,     6,                      & ! 5d: 3rd transition
           6,     6,     6,     6,     6,                      &
                         6,     6,     6,     6,     6,     6, & ! 6p
           7,     7,                                           & ! 7s
           7                                                   / ! Ac

contains


!  **************************
!  Create and destroy methods
!  **************************

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts
   ! .atom.destroy ! Never destroy this, just nullify
     .atom_Z.destroy
     .atom_pos.destroy
     .atom_zeta.destroy
     .atom_lowest_exponents.destroy
     .atom_min_distance.destroy
     .unique_atom.destroy
     .unique_atom_for.destroy
     .radial_grid.destroy
     .lebedev_grid.destroy
     .lebedev_H_grid.destroy
     .lebedev_L5_grid.destroy
     .lebedev_L11_grid.destroy
     .unscaled_point.destroy
     .unscaled_weight.destroy
     .n_points_for_row.destroy
     .atom_points.destroy
     .atom_weights.destroy
     .atom_grid0.destroy
     .atom_grid1.destroy
     .weight_is_0.destroy
   end

   nullify_ptr_part ::: leaky
   ! Nullify the pointer 
     nullify(.atom)
     nullify(.atom_Z)
     nullify(.atom_pos)
     nullify(.atom_zeta)
     nullify(.atom_lowest_exponents)
     nullify(.atom_min_distance)
     nullify(.unique_atom)
     nullify(.unique_atom_for)
     nullify(.radial_grid)
     nullify(.lebedev_grid)
     nullify(.lebedev_H_grid)
     nullify(.lebedev_L5_grid)
     nullify(.lebedev_L11_grid)
     nullify(.unscaled_point)
     nullify(.unscaled_weight)
     nullify(.n_points_for_row)
     nullify(.atom_points)
     nullify(.atom_weights)
     nullify(.atom_grid0)
     nullify(.atom_grid1)
     nullify(.weight_is_0)
   end

   destroy_grid_part ::: leaky
   ! Destroy all the quadrature grid pointer parts
     .radial_grid.destroy
     .lebedev_grid.destroy
     .lebedev_H_grid.destroy
     .lebedev_L5_grid.destroy
     .lebedev_L11_grid.destroy
     .unscaled_point.destroy
     .unscaled_weight.destroy
     .n_points_for_row.destroy
     .atom_points.destroy
     .atom_weights.destroy
     .atom_grid0.destroy
     .atom_grid1.destroy
     .weight_is_0.destroy
   end

   destroy_unscaled_grid ::: leaky
   ! Destroy the quadrature grid pointer parts
     .unscaled_weight.destroy
     .unscaled_point.destroy
   end

   destroy_atom_info ::: leaky
   ! Destroy atoms and positions
   ! .atom.destroy ! Never destroy this, just nullify
     .atom_pos.destroy
     .atom_Z.destroy
     .atom_lowest_exponents.destroy
     .atom_min_distance.destroy
     .unique_atom.destroy
     .unique_atom_for.destroy
     .atom_points.destroy
     .atom_weights.destroy
     .atom_grid0.destroy
     .atom_grid1.destroy
     .weight_is_0.destroy
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(b) ::: leaky
   ! Copy a becke_grid "b"
      b :: BECKE_GRID
      self = b
      if (b.atom_Z.created) .atom_Z.create_copy(b.atom_Z)
      if (b.atom_pos.created) .atom_pos.create_copy(b.atom_pos)
      if (b.atom_zeta.created) .atom_zeta.create_copy(b.atom_zeta)
      if (b.atom_lowest_exponents.created) .atom_lowest_exponents.create_copy(b.atom_lowest_exponents)
      if (b.atom_min_distance.created) .atom_min_distance.create_copy(b.atom_min_distance)
      if (b.unique_atom.created) .unique_atom.create_copy(b.unique_atom)
      if (b.unique_atom_for.created) .unique_atom_for.create_copy(b.unique_atom_for)
      if (b.radial_grid.created) .radial_grid.create_copy(b.radial_grid)
      if (b.lebedev_grid.created) .lebedev_grid.create_copy(b.lebedev_grid)
      if (b.lebedev_H_grid.created) .lebedev_H_grid.create_copy(b.lebedev_H_grid)
      if (b.lebedev_L5_grid.created) .lebedev_L5_grid.create_copy(b.lebedev_L5_grid)
      if (b.lebedev_L11_grid.created) .lebedev_L11_grid.create_copy(b.lebedev_L11_grid)
      if (b.unscaled_point.created) .unscaled_point.create_copy(b.unscaled_point)
      if (b.unscaled_weight.created) .unscaled_weight.create_copy(b.unscaled_weight)
      if (b.n_points_for_row.created) .n_points_for_row.create_copy(b.n_points_for_row)
      if (b.atom_points.created) .atom_points.create_copy(b.atom_points)
      if (b.atom_weights.created) .atom_weights.create_copy(b.atom_weights)
      if (b.atom_grid0.created) .atom_grid0.create_copy(b.atom_grid0)
      if (b.atom_grid1.created) .atom_grid1.create_copy(b.atom_grid1)
      if (b.weight_is_0.created) .weight_is_0.create_copy(b.weight_is_0)
   end

   set_defaults ::: leaky
   ! Set up a default dftgrid object
      .set_kind(BECKE_GRID_KIND) ! leaky, because of .set_zeta
      .set_accuracy(BECKE_GRID_ACCURACY)
      .basis_function_cutoff = BECKE_GRID_BASIS_FUNCTION_CUTOFF
      .partition_cutoff = BECKE_GRID_PARTITION_CUTOFF
      .n_extra_points_per_shell = BECKE_GRID_EXTRA_POINTS_PER_SHELL
      .reduce_core_angular_grid = BECKE_GRID_REDUCE_CORE_ANGULAR_GRID
      .reduce_H_angular_grid = BECKE_GRID_REDUCE_H_ANGULAR_GRID
      .scale_atomic_grids = BECKE_GRID_SCALE_ATOMIC_GRIDS
      .partition_power = BECKE_GRID_PARTITION_POWER
      .partition_scheme = BECKE_GRID_PARTITION_SCHEME
      .partition_scaling_scheme = BECKE_GRID_PARTITION_SCALING_SCHEME
      .finalized = FALSE
      .n_unscaled_points = 0
      .n_points = 0
   end

!  ************
!  Set routines
!  ************

   set_kind(kind) ::: leaky
   ! Set the kind of interpolation to use.
      kind :: STR
      .kind = kind
      .kind.to_lower_case
      select case (.kind)
         case ("becke                    ")                
         case ("treutler_ahlrichs        ")                
         case ("mura_knowles             ")                
         case default; UNKNOWN(.kind)
      end
      .set_zeta ! leaky here
   end

   set_partition_scheme(scheme)
   ! THis option describes how the masking function to be used to partition the
   ! density-like function into separate "atomic" regions.
      scheme :: STR
      .partition_scheme = scheme
      .partition_scheme.to_lower_case
      select case (.partition_scheme)
         case ("becke             ")
         case ("delley            ")
            WARN("setting partition scaling scheme to `none'")
            .set_partition_scaling_scheme("none")
         case ("stratmann_scuseria")
            WARN("setting partition scaling scheme to `none'")
            .set_partition_scaling_scheme("none")
         case default; UNKNOWN(.partition_scheme)
      end
   end

   set_partition_scaling_scheme(scheme)
   ! This chooses the precise method to scale the sizes of the "atoms" generated
   ! by the atomic partition function scheme.
      scheme :: STR
      .partition_scaling_scheme = scheme
      .partition_scaling_scheme.to_lower_case
      select case (.partition_scaling_scheme)
         case ("none             ")
         case ("becke            ")
         case ("treutler_ahlrichs")
         case default; UNKNOWN(.partition_scaling_scheme)
      end
   end

   set_zeta ::: leaky, private
   ! Set the atom_zeta scaling parameters. We store them in case they need to be
   ! manually changed ...
   ENSURE(.kind/=" ","no kind specified")
      i :: INT
      fac :: REAL
      .atom_zeta.destroy
      .atom_zeta.create(89)
      if (.scale_atomic_grids) then
         select case (.kind)
            case ("becke                    ")                
               .atom_zeta.create_copy(bragg_slater_radius) 
               fac = HALF*BOHR_PER_ANGSTROM
               .atom_zeta = fac*.atom_zeta
               ! H and He are the Bragg radius
               .atom_zeta(1) = TWO*.atom_zeta(1)
               .atom_zeta(2) = TWO*.atom_zeta(2)
            case ("treutler_ahlrichs        ")                
               .atom_zeta.create_copy(TA_zeta)
               fac = BOHR_PER_ANGSTROM
               .atom_zeta = fac*.atom_zeta
            case ("mura_knowles             ")                
               .atom_zeta.create_copy(MK_zeta)
            case default
               UNKNOWN(.kind)
         end
      else
         .atom_zeta = ONE
      end
   end

   set_zeta(i,zeta) ::: leaky
   ! Set the zeta value for element "i" to be "zeta".
   ! NOTE: This is ain atomic units
      i :: INT
      zeta :: REAL
   ENSURE(.atom_zeta.created,"no atom_zeta array, set atom positions first")
   ENSURE(i.is_in_range([1,89]),"i is not in the allowed range")
      .atom_zeta(i) = zeta
   end

   set_accuracy(acc)
   ! Set the accuracy. NOTE: the actual integration accuracy is affected not
   ! only by this keyword, but also by the switches .reduce_core_angular_grid
   ! and .reduce_H_angular_grid. It will also depend on .n_extra_points_per_shell.
      acc :: STR
      .accuracy = acc
      .accuracy.to_lower_case
      select case (acc)
         case ("very_low")             ! These are Treutler-Ahlrichs settings
            .set_l_H_angular_grid(11)
            .set_l_angular_grid(17)
            .set_n_radial_points(20)
         case ("low");
            .set_l_H_angular_grid(17)
            .set_l_angular_grid(23)
            .set_n_radial_points(25)
         case ("medium")
            .set_l_H_angular_grid(23)
            .set_l_angular_grid(29)
            .set_n_radial_points(30)
         case ("high")
            .set_l_H_angular_grid(29)
            .set_l_angular_grid(35)
            .set_n_radial_points(35)
         case ("very_high")
            .set_l_H_angular_grid(35)
            .set_l_angular_grid(47)
            .set_n_radial_points(45)
         case ("extreme")             ! These are better than the Mura-Knowles settings
            .set_l_H_angular_grid(47)
            .set_l_angular_grid(59)
            .set_n_radial_points(55)
         case ("best")
            .set_l_H_angular_grid(59)
            .set_l_angular_grid(71)
            .set_n_radial_points(65)
         case default
            UNKNOWN(acc)
      end
   end

   set_atoms_and_positions(atom_Z,atom_pos,use_unique) ::: leaky
   ! Set the atom atomic numbers "atom_Z" and their corresponding positions
   ! "atom_pos". The atoms define the peaks and extent of the 3D integrand.
   ! If "use_unique" is present and TRUE, then the list of atom positions is
   ! checked to see if they are all different; if they are not all different,
   ! only the unique set of positions is used. NOTE: "use_unique" should really
   ! always be set TRUE, but we don't do it to save calculation in cases when
   ! the atoms are known to be distinct.
      atom_Z :: VEC{INT}
      atom_pos :: MAT{REAL}
      use_unique :: BIN, optional
   ENSURE(.kind/=" ","must set kind of quadrature first")
   ENSURE(atom_Z.dim==atom_pos.dim1,"inconsistent atom_Z and atom_pos arrays")
   ENSURE(atom_pos.dim2==3,"wrong atom_pos arrays")
   ENSURE(atom_pos.no_of_unique_rows==atom_pos.dim1,"there are non unique atom positions!")
      unique :: VEC{INT}*
      make_unique :: BIN
      make_unique = FALSE
      if (present(use_unique)) make_unique = use_unique
      ! Get rid of last lot
      .destroy_atom_info
      if (make_unique) then ! Set the unique atom positions: this is safe
         .atom_pos.unique_rows(unique)
         .atom_Z.create_copy(atom_Z(unique))
         .atom_pos.create_copy(atom_pos(unique,:))
         unique.destroy
      else                  ! Don't worry about being unique: this is not safe
         .atom_Z.create_copy(atom_Z)
         .atom_pos.create_copy(atom_pos)
      end
   end

   set_atom_info(atom_Z,atom_pos,atom_lowest_exponents,atom) ::: leaky
   ! Set the atom atomic numbers "atom_Z" and their corresponding positions
   ! "atom_pos". Also set the "atom_lowest_exponents" used to estimate when grid
   ! points too far away from an atom become insignificant (in the case when we
   ! are making matrix elements of the atom basis functions). Optionally, a list
   ! of atoms "atom" may be set, which is used to precalculate basis function
   ! grid for gaussian DFT calculations.
      atom_Z :: VEC{INT}, IN
      atom_pos :: MAT{REAL}, IN
      atom_lowest_exponents :: VEC{REAL}, optional, IN
      atom :: VEC{ATOM}*, optional
   ENSURE(.kind/=" ","must set kind of quadrature first")
   ENSURE(atom_Z.dim==atom_pos.dim1,"inconsistent atom_Z and atom_pos arrays")
   ENSURE(atom_lowest_exponents.dim==atom_pos.dim1,"inconsistent atom_lowest_exponents and atom_pos arrays")
   ENSURE(atom_pos.dim2==3,"wrong atom_pos arrays")
   ENSURE(atom_pos.no_of_unique_rows==atom_pos.dim1,"there are non unique atom positions!")
      .destroy_atom_info
      .atom_Z.create_copy(atom_Z)
      .atom_pos.create_copy(atom_pos)
      if (present(atom_lowest_exponents)) .atom_lowest_exponents.create_copy(atom_lowest_exponents)
      if (present(atom)) .atom => atom
   end

!   set_atom_row ::: private
!   ! Set the atom_zeta scaling parameters.
!   ENSURE(.atom_Z.created,"no atom_Z array")
!      i :: INT
!      do i = 1,.atom_Z.dim
!         .atom_row(i) = .period_for_atom(i)
!      end
!   end

!   period_for_atom(i) result(p) ::: private
!   ! Return the period (i.e. row of the periodic table) for the atom "i".
!   ! This is used to determine the number of radial points.
!      i :: INT, optional
!      p :: INT
!      Z,noble,n :: INT
!      Z = .atom_Z(i)
!      p = 1
!      noble = 0
!      do
!         n = (p+2)/2
!         noble = noble + 2*n**2
!         if (Z <= noble) exit
!         p = p + 1
!      end
!   end

   set_basis_function_cutoff(cutoff)
   ! Set .basis_function_cutoff, the value below which function values are
   ! assumed to be zero, so as to eliminate *atom* grid points.
      cutoff :: REAL
   ENSURE(cutoff>=ZERO,"cutoff must be non-negative")
   WARN_IF(cutoff>TOL(4),"cutoff may be too large")
      .basis_function_cutoff = cutoff
   end

   set_partition_cutoff(cutoff)
   ! Set .partition_cutoff, the value below which the partition function values
   ! are assumed to be zero, so as to eliminate (full) grid points *after*
   ! partitioning.
      cutoff :: REAL
   ENSURE(cutoff>=ZERO,"cutoff must be non-negative")
   WARN_IF(cutoff>TOL(15),"cutoff may be too large")
      .partition_cutoff = cutoff
   end

   set_n_radial_points(n)
   ! Set the number of radial points wanted for the Hydrogen atom.
   ! The number of points used for other atoms is more: 5 more points are used
   ! for every atomic shell that the atom has more than Hydrogen.
      n :: INT
   ENSURE(n>1,"n must be greater than one")
      .n_radial_points = n
   end

   set_n_extra_points_per_shell(n)
   ! Set the number of extra radial points to use per n-shell over and above the
   ! default number .n_radial_points wanted for the Hydrogen atom. Normally this
   ! is set to 5 according to Becke's rule of thumb. You might want to set it to
   ! zero to get uniform grids for all the atoms.
      n :: INT
   ENSURE(n>=0,"n must be non-negative")
      .n_extra_points_per_shell = n
   end

   set_l_angular_grid(l)
   ! Set the angular quantum number "l" which is to be integrated exactly by the
   ! angular grid.
      l :: INT
   WARN_IF(l<11,"l recommended greater than 11")
      .l_angular_grid = l
   end

   set_l_H_angular_grid(l)
   ! Set the angular quantum number "l" which is to be integrated exactly by the
   ! angular grid for the Hydrogen and Helium atoms only.
      l :: INT
   WARN_IF(l<11,"l recommended greater than 11")
      .l_H_angular_grid = l
   end

   set_reduce_H_angular_grid(reduce)
   ! If set TRUE the order of the angular grid for Hydrogen and Helium are
   ! reduced to .l_H_angular_grid.
      reduce :: BIN
      .reduce_H_angular_grid = reduce
   end

   set_reduce_core_angular_grid(reduce)
   ! If set TRUE the order of the angular grid near the core of the atom is
   ! reduced to make smaller meshes. So far the scheme of Treutler and Ahlrichs
   ! is used.
      reduce :: BIN
      .reduce_core_angular_grid = reduce
   end

   set_scale_atomic_grids(scale) ::: leaky
   ! If set TRUE, the atomic grids are scaled according to the authors
   ! recommended scaling factors. This does *not* mean that the partition
   ! function is also scaled to account for varying atomic sizes.
      scale :: BIN
      .scale_atomic_grids = scale
      .set_zeta
   end

!  *************
!  Input methods
!  *************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR
      word :: STR
      word = keyword
      word.to_lower_case
      .finalized = FALSE
      select case (word)
         case ("}                         ")  ! exit case
         case ("accuracy=                 "); .read_accuracy
         case ("basis_function_cutoff=    "); .read_basis_function_cutoff
         case ("kind=                     "); .read_kind
         case ("l_angular_grid=           "); .read_l_angular_grid
         case ("l_h_angular_grid=         "); .read_l_H_angular_grid
         case ("n_extra_points_per_shell= "); .read_n_extra_points_per_shell
         case ("n_radial_points=          "); .read_n_radial_points
         case ("reduce_core_angular_grid= "); .read_reduce_core_angular_grid
         case ("reduce_h_angular_grid=    "); .read_reduce_H_angular_grid
         case ("scale_atomic_grids=       "); .read_scale_atomic_grids
         case ("partition_cutoff=         "); .read_partition_cutoff
         case ("partition_scheme=         "); .read_partition_scheme
         case ("partition_scaling_scheme= "); .read_partition_scaling_scheme
         case ("put                       "); .put
         case ("put_atom_info             "); .put_atom_info
         case ("put_radial_angular_grids  "); .put_radial_angular_grids
         case ("put_unique_atom_grids     "); .put_unique_atom_grids
         case ("set_grid_data             "); .set_grid_data
         case ("set_defaults              "); .set_defaults
         case default;                    UNKNOWN(word)
      end
   end

   read_accuracy
   ! Read the accuracy of the numerical integration
      word :: STR
      stdin.read(word)
      .set_accuracy(word)
   end

   read_kind ::: leaky
   ! Read the .kind of quadrature desired
      word :: STR
      stdin.read(word)
      word.to_lower_case
      .set_kind(word)
   end

   read_partition_scheme
   ! Set the partition method to use. Normally it is "becke".
      s :: STR
      stdin.read(s)
      .set_partition_scheme(s)
   end

   read_partition_scaling_scheme
   ! Set the partition scaling method to use. Normally "treutler_ahlrichs".
      s :: STR
      stdin.read(s)
      .set_partition_scaling_scheme(s)
   end

   read_l_angular_grid
   ! Read .l_angular_grid, the angular momentum used for the angular grid
      l :: INT
      stdin.read(l)
      .set_l_angular_grid(l)
   end

   read_l_H_angular_grid
   ! Read .l_H_angular_grid, the angular momentum used for the angular grid for
   ! the Hydrogen atom.
      l :: INT
      stdin.read(l)
      .set_l_H_angular_grid(l)
   end

   read_n_extra_points_per_shell
   ! Read .n_extra_points_per_shell, 
      n :: INT
      stdin.read(n)
      .set_n_extra_points_per_shell(n)
   end

   read_n_radial_points
   ! Read .n_radial_points, required to defined the radial quadrature
      n :: INT
      stdin.read(n)
      .set_n_radial_points(n)
   end

   read_reduce_core_angular_grid
   ! Read whether to reduce the angular momentum of the angular grid near the
   ! core of an atom
      l :: BIN
      stdin.read(l)
      .set_reduce_core_angular_grid(l)
   end

   read_reduce_H_angular_grid
   ! Read whether to reduce the angular momentum of the angular grid near the
   ! core of a *hydrogen* atom
      l :: BIN
      stdin.read(l)
      .set_reduce_H_angular_grid(l)
   end

   read_scale_atomic_grids
   ! Read whether to scale the sizes of the atomic grids to account for
   ! different atomic sizes. NOTE: this does not also scale the partitioning
   ! scheme, for this set the .partition_scaling_scheme.
      l :: BIN
      stdin.read(l)
      .set_scale_atomic_grids(l)
   end

   read_basis_function_cutoff
   ! Read .basis_function_cutoff, the value below which function values are
   ! assumed to be zero, so as to eliminate *atom* grid points.
      cutoff :: REAL
      stdin.read(cutoff)
      .set_basis_function_cutoff(cutoff)
   end

   read_partition_cutoff
   ! Read .partition_cutoff, the value below which the partition function values
   ! are assumed to be zero, so as to eliminate (full) grid points *after*
   ! partitioning.
      cutoff :: REAL
      stdin.read(cutoff)
      .set_partition_cutoff(cutoff)
   end

!  *********************************************************************
!  Radial, angular grid precomputation + unique atom grid precomputation
!  *********************************************************************

!  This is the main finalization ...

   set_grid_data ::: leaky
   ! Set all the radial and angular grid data required to construct the product
   ! grids for any atom in the periodic table. Then define the unique atomic
   ! grids for the current set of atoms.
      .destroy_grid_part
      .set_radial_grids       ! Radial and angular grids come first
      .set_angular_grids
      .set_n_points_for_row   ! Point counting routines next, for dimensioning
      .set_unique_atoms       ! Lists of unique atoms
      .set_atom_min_distance
      .set_atom_grids         ! Finally, make the unique atomic grids
      if (.atom.created) .set_atom_density_grids
      .finalized = TRUE
   end

!  The following are private helper routines

   set_radial_grids ::: private, leaky
   ! Set all possible .radial_grid's that could be needed. Since a different
   ! number of radial points is used for atoms in different rows of the periodic
   ! table, this required a loop over the rows of the periodic table.
   ENSURE(.kind/=" ","no grid kind set")
      p :: INT
      .radial_grid.create(7)
      do p = 1,7
         .set_radial_grid(.radial_grid(p),p)
      end
   end

   set_radial_grid(radial,p) ::: private, leaky
   ! Set the "radial" grid data for an atom on period "p" of the periodic table.
   ! The standard radial grid points are modified using the mappings
   ! recommended by the authors. The jacoboian of the transformation is included
   ! back into the weight. The zeta scale factor is *not* included at this stage,
   ! only at the final stage when the full grid is generated for the entire atom
   ! list.
      radial :: QUADRATURE
      p  :: INT
   ENSURE(.kind/=" ","no grid kind set")
      nr :: INT
      nr = .no_of_radial_points(p)
      select case (.kind)
         case ("becke            "); .set_B_radial_grid(radial,nr)
         case ("treutler_ahlrichs"); .set_TA_radial_grid(radial,nr)
         case ("mura_knowles     "); .set_MK_radial_grid(radial,nr)
         case default;                UNKNOWN(.kind)
      end
   end

   set_B_radial_grid(radial_grid,nr) ::: private, leaky
   ! Set the Becke "radial_grid" to have "nr" points. The standard grid points
   ! are modified using the recommended mappings. The jacoboian of the mapping
   ! is included back into the weight. The zeta scale factor is *not* included
   ! at this stage, only at the final stage when the full grid is generated for
   ! the entire atom list.
      radial_grid :: QUADRATURE
      nr :: INT
      i  :: INT
      r,w,rr,ww,rp1,rm1 :: REAL
      radial_grid.set_n_points(nr)
      radial_grid.set_kind("gauss_chebyshev_2nd")
    ! radial_grid.set_kind("gauss_chebyshev_1st")
      radial_grid.set_quadrature_points ! leaky here
      ! Apply the Becke mapping r = (1+x)/(1-x), for x in [-1,1]
      do i = 1,radial_grid.n_points
         r = radial_grid.point(i)
         w = radial_grid.weight(i)
         rp1 = ONE + r
         rm1 = ONE - r
         rr = rp1/rm1
         ww = TWO*w/(rm1*rm1)
         radial_grid.point(i) = rr
         radial_grid.weight(i) = ww
       ! r = cos(pf*(i-HALF))
       ! !a = cos(PI*(2*i-1)/(TWO*num))
       ! x = (ONE + r)/(ONE - r)
       ! pt(i) = x
       ! wt(i) = x*w*(rp1 + r*rm1)/sqrt(ONE - r*r)
      end
   end

   set_TA_radial_grid(radial_grid,nr) ::: private, leaky
   ! Set the Treutler-Ahlrichs "radial_grid" to have "nr" points. The standard
   ! grid points are modified using the recommended mappings. The jacobian of
   ! the mapping is included back into the weight. The zeta scale factor is
   ! *not* included at this stage, only at the final stage when the full grid is
   ! generated for the entire atom list.
      radial_grid :: QUADRATURE
      nr :: INT
      i :: INT
      r,w,rr,ww,rp1,rm1,ra1,ra,ln2,a,a1,tmp :: REAL
      radial_grid.set_n_points(nr)
      radial_grid.set_kind("gauss_chebyshev_2nd")
      radial_grid.set_quadrature_points ! leaky here
      ! Apply the Treutler-Ahlrichs mapping 
      ! r = (ln 2)^-1 (1+x)^0.6 ln(2/(1-x)), for x in [-1,1]
      ln2 = ONE/log(TWO)
      a  = 0.6d0
      a1 = a - ONE
      do i = 1,radial_grid.n_points
         r = radial_grid.point(i)
         w = radial_grid.weight(i)
         rp1 = ONE + r
         rm1 = ONE - r
         ra1 = rp1**a1
         ra  = ra1*rp1
         tmp = ONE - ln2*log(rm1)
         rr = ra*tmp
         ww = ra1*(a*tmp+ln2*rp1/rm1)*w
         radial_grid.point(i) = rr
         radial_grid.weight(i) = ww
      end
      radial_grid.point.reverse_order
      radial_grid.weight.reverse_order
   end

   set_MK_radial_grid(radial_grid,nr) ::: private, leaky
   ! Set the Mura-Knowles "radial_grid" to have "nr" points. The standard grid
   ! points are modified using the recommended mappings. The jacoboian of the
   ! mapping is included back into the weight. The zeta scale factor is *not*
   ! included at this stage, only at the final stage when the full grid is
   ! generated for the entire atom list.
      radial_grid :: QUADRATURE
      nr :: INT
      i,m,m1 :: INT
      r,w,rr,ww,rm1,rm,tmp :: REAL
      radial_grid.set_n_points(nr)
    ! radial_grid.set_kind("open_rectangle") ! eliminate end points
    ! radial_grid.set_kind("open_extended_simpson") ! seems not to work
      radial_grid.set_kind("open_extended_trapezoid") ! eliminate end points
    ! radial_grid.set_kind("gauss_legendre") 
      radial_grid.set_quadrature_points ! leaky here
      ! Apply the Mura-Knowles log 3 mapping
      ! r = -ln (1-x^3), for x in [0,1]
      m  = 3
      m1 = m - 1
      do i = 1,radial_grid.n_points
         r = radial_grid.point(i)
         w = radial_grid.weight(i)
         rm1 = r**m1
         rm  = r*rm1
         tmp = ONE - rm
         rr = -log(tmp)
         ww = (ONE/tmp)*m*rm1*w
         radial_grid.point(i) = rr
         radial_grid.weight(i) = ww
      end
   end

   set_angular_grids ::: private, leaky
   ! Set all possible angular grid's that might be needed. At the moment only
   ! spherical Lebedev grids are available, but they are probably the best
   ! anyway ...
   WARN_IF(.l_angular_grid<11,"l recommended greater than 11")
   WARN_IF(.l_H_angular_grid<11,"l_H recommended greater than 11")
      .lebedev_grid.create           ! Default grid
      .lebedev_grid.set_l(.l_angular_grid)
      .lebedev_H_grid.create         ! Needed for H atoms
      .lebedev_H_grid.set_l(.l_H_angular_grid)
      .lebedev_L5_grid.create        ! Needed for reduced grids near atom core
      .lebedev_L5_grid.set_l(5)
      .lebedev_L11_grid.create
      .lebedev_L11_grid.set_l(11)
   end

   set_n_points_for_row ::: private, leaky
   ! Set the number of points per row of the periodic table.
      r :: INT
      .n_points_for_row.destroy
      .n_points_for_row.create(7)
      do r = 1,7 ! Set no. of points for each row
         .n_points_for_row(r) = .no_of_points_for_row(r)
      end
   end

   set_unique_atoms ::: leaky, private
   ! Make the list of unique_atoms, and a map array to the unique list of atoms.
      n,k,Z,i :: INT
      .unique_atom.create(.atom_Z.dim)
      .unique_atom_for.create(.atom_Z.dim)
      .unique_atom_for(1) = 1
      .unique_atom(1) = 1
      k = 1
      do n = 2,.atom_Z.dim
         Z = .atom_Z(n)
         i = .atom_Z(1:n).index_of_value(Z)
         .unique_atom_for(n) = i
         if (i/=n) cycle
         k = k + 1
         .unique_atom(k) = n
      end
      .n_unique_atoms = k
      .unique_atom.shrink(k)
   end

   set_atom_min_distance ::: leaky, private
   ! Make the minimum distances between atoms.
   ENSURE(.atom_pos.created,"no atom_Z array")
      n_atom,i,j,k :: INT
      px,py,pz,dx,dy,dz,dmin,d :: REAL
      if (.atom_pos.dim1==1) return
      n_atom = .atom_pos.dim1
      .atom_min_distance.create(n_atom)
      do i = 2,n_atom
         px = .atom_pos(i,1)
         py = .atom_pos(i,2)
         pz = .atom_pos(i,3)
         dmin = huge(ONE)
         do j = 1,i-1
            dx = px - .atom_pos(j,1)
            dy = py - .atom_pos(j,2)
            dz = pz - .atom_pos(j,3)
            if (d>=dmin) cycle
            dmin = d
            k = j
         end
         .atom_min_distance(i) = d
         .atom_min_distance(k) = d
      end
   end

   set_atom_grids ::: leaky, private
   ! Make all the atom integration grids.
   ! A slim grid makes use of atom_lowest_exponents and prunes the radial grid,
   ! as well as pruning points which have zero or low weight factors.
   ENSURE(.atom_Z.created,"no atom_Z array")
   ENSURE(.unique_atom.created,"no unique_atom array")
      u,p,p_max,a,np :: INT
      s,s3 :: REAL
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      .atom_weights.destroy
      .atom_points.destroy
      .atom_points.create(.n_unique_atoms)
      .atom_weights.create(.n_unique_atoms)
      p_max = period(maxval(.atom_Z))
      do p = 1,p_max                     ! Loop over atoms with periodic table row=p
         if (all(period(.atom_Z)/=p)) cycle
         .set_unscaled_grid(p)           ! Set unscaled reference grid for row=p
         do u = 1,.n_unique_atoms        ! for each *unique* atom
            a = .unique_atom(u)
            if (period(.atom_Z(a))/=p) cycle
            np = .no_of_points_for_atom(a)
            .atom_points(u).element.create(np,3)
            .atom_weights(u).element.create(np)
            pt => .atom_points(u).element
            wt => .atom_weights(u).element
            pt = .unscaled_point(1:np,:)
            wt = .unscaled_weight(1:np)
            if (.scale_atomic_grids) then
               s  = .atom_zeta(.atom_Z(a))
               s3 = s*s*s
               pt = s*pt
               wt = s3*wt
            end
         end
         .destroy_unscaled_grid
      end
   end

   set_atom_density_grids ::: leaky, private
   ! Make all the atom basis function grids. This will use up a large slab of
   ! memory, but hopefully not too much, since it only depends on the number of
   ! different atoms in the molecule.
   ENSURE(.atom.created,"no atom_Z array")
   ENSURE(.unique_atom.created,"no unique_atom array")
   ENSURE(.atom_points.created,"no atom_points array")
      u,a,np,nb :: INT
      g0,pt :: MAT{REAL}*
      g1 :: MAT3{REAL}*
      pos :: VEC{REAL}(3)
      .atom_grid0.destroy
      .atom_grid1.destroy
      .atom_grid0.create(.n_unique_atoms)
      .atom_grid1.create(.n_unique_atoms)
      do u = 1,.n_unique_atoms        ! for each *unique* atom
         a = .unique_atom(u)
       ! np = .no_of_points_for_atom(a)
         np = .atom_points(u).element.dim1
         nb = .atom(a).n_bf
         .atom_grid0(u).element.create(np,nb)
         .atom_grid1(u).element.create(np,nb,3)
         g0 => .atom_grid0(u).element
         g1 => .atom_grid1(u).element
         pt => .atom_points(u).element
         pos = .atom(a).pos           ! Reset atom to origin temporarily
         .atom(a).pos = ZERO
         .atom(a).make_nabla_bf_grid(g1,g0,pt)
         .atom(a).pos = pos
      end
   end

   set_unscaled_grid(p) ::: leaky, private
   ! Set the *unscaled* spherical quadrature grid points and weights for an atom
   ! on period "p" of the periodic table. The unscaled grid is a direct product
   ! of the ".radial_grid(p)" and the ".lebedev" angular grids. This routine may
   ! use the Treutler-Ahlrichs scheme to reduce the order of the angular grids
   ! for radial points near the nucleus.
      p :: INT, IN
   ENSURE(.radial_grid.created,"no radial_grid")
   ENSURE(.lebedev_grid.created,"no lebedev_grid")
   ENSURE(.n_points_for_row.created,"no n_points_for_row")
      i,j,k, np,nr,n3,n2 :: INT
      pi4,r,w,pi4r2w :: REAL
      lebedev_grid :: LEBEDEV*
      radial_grid :: QUADRATURE*
      np = .n_points_for_row(p)
      .n_unscaled_points = np
      .destroy_unscaled_grid
      .unscaled_point.create(np,3)
      .unscaled_weight.create(np)
      radial_grid => .radial_grid(p)
      nr = radial_grid.n_points
      n3 = nr/3
      n2 = nr/2
      pi4 = FOUR*PI ! Include the factor 4*pi*r^2 in the weights.
      k = 0
      do i = 1,nr                       ! <-- Loop on radial grid
         r = radial_grid.point(i)
         w = radial_grid.weight(i)
         pi4r2w = pi4*r*r*w
         ! Set default lebedev grid
         lebedev_grid => .lebedev_grid
         ! Reset lebedev grid for H atoms
         if (.reduce_H_angular_grid AND p==1) lebedev_grid => .lebedev_H_grid
         ! Reset lebedev grids for points near the core
         if (.reduce_core_angular_grid) then
            if      (i <= n3) then;           lebedev_grid => .lebedev_L5_grid
            else if (n3<i AND i<=n2) then;    lebedev_grid => .lebedev_L11_grid
            end
         end
         do j = 1,lebedev_grid.n_points ! <-- Loop on angular grid
            k = k + 1
            .unscaled_point(k,:) = r*lebedev_grid.point(j,:)
            .unscaled_weight(k)  = pi4r2w*lebedev_grid.weight(j)
         end
      end
   end

!  ************************************************
!  Unscaled reference atom grid generation routines
!  ************************************************

   set_unscaled_points(p) ::: private, leaky
   ! Set only the *unscaled* spherical quadrature grid points for an atom
   ! on period "p" of the periodic table. The unscaled grid is a direct product
   ! of the ".radial_grid(p)" and the ".lebedev" angular grids. This routine may
   ! use the Treutler-Ahlrichs scheme to reduce the order of the angular grids
   ! for radial points near the nucleus.
      p :: INT, IN
   ENSURE(.radial_grid.created,"no radial_grid")
   ENSURE(.lebedev_grid.created,"no lebedev_grid")
      i,j,k, np,nr,n3,n2 :: INT
      r :: REAL
      lebedev_grid :: LEBEDEV*
      radial_grid :: QUADRATURE*
      np = .no_of_points_for_row(p)
      .n_unscaled_points = np
      .destroy_unscaled_grid
      .unscaled_point.create(np,3)
      radial_grid => .radial_grid(p)
      nr = radial_grid.n_points
      n3 = nr/3
      n2 = nr/2
      k = 0
      do i = 1,nr                       ! <-- Loop on radial grid
         r = radial_grid.point(i)
         ! Set default lebedev grid
         lebedev_grid => .lebedev_grid
         ! Reset lebedev grid for H atoms
         if (.reduce_H_angular_grid AND p==1) lebedev_grid => .lebedev_H_grid
         ! Reset lebedev grids for points near the core
         if (.reduce_core_angular_grid) then
            if      (i <= n3) then;           lebedev_grid => .lebedev_L5_grid
            else if (n3<i AND i<=n2) then;    lebedev_grid => .lebedev_L11_grid
            end
         end
         do j = 1,lebedev_grid.n_points ! <-- Loop on angular grid
            k = k + 1
            .unscaled_point(k,:) = r*lebedev_grid.point(j,:)
         end
      end
   end

   set_unscaled_weights(p) ::: private, leaky
   ! Set only the *unscaled* spherical quadrature grid weights for an atom
   ! on period "p" of the periodic table. The unscaled grid is a direct product
   ! of the ".radial_grid(p)" and the ".lebedev" angular grids. This routine may
   ! use the Treutler-Ahlrichs scheme to reduce the order of the angular grids
   ! for radial points near the nucleus.
      p :: INT, IN
   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
   ENSURE(.radial_grid.created,"no radial_grid")
   ENSURE(.lebedev_grid.created,"no lebedev_grid")
      i,j,k, np,nr,n3,n2 :: INT
      pi4,r,w,pi4r2w :: REAL
      lebedev_grid :: LEBEDEV*
      radial_grid :: QUADRATURE*
      np = .no_of_points_for_row(p)
      .n_unscaled_points = np
      .destroy_unscaled_grid
      .unscaled_weight.create(np)
      radial_grid => .radial_grid(p)
      nr = radial_grid.n_points
      n3 = nr/3
      n2 = nr/2
      pi4 = FOUR*PI ! Include the factor 4*pi*r^2 in the weights.
      k = 0
      do i = 1,nr                       ! <-- Loop on radial grid
         r = radial_grid.point(i)
         w = radial_grid.weight(i)
         pi4r2w = pi4*r*r*w
         ! Set default lebedev grid
         lebedev_grid => .lebedev_grid
         ! Reset lebedev grid for H atoms
         if (.reduce_H_angular_grid AND p==1) lebedev_grid => .lebedev_H_grid
         ! Reset lebedev grids for points near the core
         if (.reduce_core_angular_grid) then
            if      (i <= n3) then;           lebedev_grid => .lebedev_L5_grid
            else if (n3<i AND i<=n2) then;    lebedev_grid => .lebedev_L11_grid
            end
         end
         do j = 1,lebedev_grid.n_points ! <-- Loop on angular grid
            k = k + 1
            .unscaled_weight(k)  = pi4r2w*lebedev_grid.weight(j)
         end
      end
   end

   no_of_radial_points(p) result (res) 
   ! Return the number of radial points in the grid for an atom in period "p" of
   ! the periodic table.
      p   :: INT, IN
      res :: INT
      res = .n_radial_points + .n_extra_points_per_shell*(p-1)
   end

   no_of_points_for_row(p) result (res) ::: private
   ! Return the number of points in the (radial x spherical) grid, assuming that
   ! the atom is in period "p", and assuming the Treutler-Ahlrichs scheme to
   ! reduce the order of the angular mesh near the nucleus. WARNING: this
   ! routine must be compatible with .set_unscaled_grid. NOTE: This routine does
   ! not eliminate points far from the origin due to basis function atom
   ! exponents; this returns the maximum number of points for an atom in period
   ! "p" of the periodic table.
      p   :: INT, IN
      res :: INT
   ENSURE(p>=0 AND p<=7,"p out of range")
   ENSURE(.radial_grid.created,"no radial_grid")
   ENSURE(.lebedev_grid.created,"no lebedev_grid")
      lebedev_grid :: LEBEDEV*
      nr,i,n3,n2 :: INT
      nr = .radial_grid(p).n_points
      n3 = nr/3
      n2 = nr/2
      res = 0
      do i = 1,nr
         ! Set default lebedev grid
         lebedev_grid => .lebedev_grid
         ! Reset lebedev grid for H atoms
         if (.reduce_H_angular_grid AND p==1) lebedev_grid => .lebedev_H_grid
         ! Reset lebedev grids for points near the core
         if (.reduce_core_angular_grid) then
            if      (i <= n3) then;           lebedev_grid => .lebedev_L5_grid
            else if (n3<i AND i<=n2) then;    lebedev_grid => .lebedev_L11_grid
            end
         end
         DIE_IF(lebedev_grid.destroyed,"no lebedev_grid")
         res = res + lebedev_grid.n_points
      end
   end

   no_of_points_for_atom(a) result (res)
   ! Calculate the total number of points for atom "a" assuming that the array
   ! .atom_lowest_exponents has been defined. These exponents are used to define
   ! a corresponding gaussian; when that gaussian has value below
   ! .basis_function_cutoff, the contribution of the radial point is assumed to
   ! be zero. NOTE: this routine assumes the grid points are to be used for
   ! integrating products of basis functions on *all* atoms in the list (usually
   ! this will be at most two atoms).  NOTE: this routine assumes the radial
   ! grid points are ordered smallest to largest. NOTE: this routine depends on
   ! the atom scale factor, as well as the type of radial grid.
      a :: INT, IN
      res :: INT
   ENSURE(.radial_grid.created,"no radial_grid")
   ENSURE(.lebedev_grid.created,"no lebedev_grid")
   ENSURE(.atom_Z.created,"no atom_Z array")
   ENSURE(.atom_lowest_exponents.created,"no atom_lowest_exponents array")
   ENSURE(.atom_zeta.created,"no atom_zeta scale factors")
      lebedev_grid :: LEBEDEV*
      radial_grid :: QUADRATURE*
      p,nr,n3,n2,i :: INT
      alpha,r_max,s,r,cutoff :: REAL
      alpha = ONE/.atom_lowest_exponents(a)
      cutoff = .basis_function_cutoff
      if (cutoff<=ZERO) then; r_max = huge(ONE)
      else;    r_max = sqrt(-alpha*log(cutoff)) ! <<< .basis_function_cutoff defines r_max !!!
      end
      p  = period(.atom_Z(a))
      radial_grid => .radial_grid(p)
      nr = .radial_grid(p).n_points
      n3 = nr/3
      n2 = nr/2
      res = 0
      do i = 1,nr
         s = .atom_zeta(.atom_Z(a))
         r = s*radial_grid.point(i)
         if (r>r_max) exit     ! <<< This eliminates the later points in the list
         ! Set default lebedev grid
         lebedev_grid => .lebedev_grid
         ! Reset lebedev grid for H atoms
         if (.reduce_H_angular_grid AND p==1) lebedev_grid => .lebedev_H_grid
         ! Reset lebedev grids for points near the core
         if (.reduce_core_angular_grid) then
            if      (i <= n3) then;           lebedev_grid => .lebedev_L5_grid
            else if (n3<i AND i<=n2) then;    lebedev_grid => .lebedev_L11_grid
            end
         end
         DIE_IF(lebedev_grid.destroyed,"no lebedev_grid")
         res = res + lebedev_grid.n_points
      end
   end

   no_of_points result (res)
   ! Calculate the total number of points over all atoms stored in the becke
   ! grid. This number of points does *not* take into account grid compression
   ! but it *does* take into account each atom's lowest exponent. We can't know
   ! the number of compressed points before the weights are made!
      res :: INT
   ENSURE(.finalized,"not finalized; use set_grid_data")
   ENSURE(.unique_atom_for.created,"no unique_atom_for array")
   ENSURE(.atom_Z.created,"no atom_Z array")
   ENSURE(.atom_weights.created,"no atom_weights array")
      a,u :: INT
      res = 0    
      do a = 1,.atom_Z.dim       
         u = .unique_atom_for(a)
         res = res + .atom_weights(u).element.dim
      end
   end

   no_of_points(atoms) result (res)
   ! Return the number of points in the DFT integration grid required to
   ! integrate those atoms whose indices appear in "atoms". This number of
   ! points does *not* take into account grid compression, but it *does* take
   ! into account the atoms lowest exponent.
      res :: INT
      atoms :: VEC{INT}, IN
   ENSURE(.finalized,"not finalized; use set_grid_data")
   ENSURE(.unique_atom_for.created,"no unique_atom_for array")
   ENSURE(.atom_weights.created,"no atom_weights array")
      a,u :: INT
      res = 0    
      do a = 1,atoms.dim    
         u = .unique_atom_for(atoms(a))
         res = res + .atom_weights(u).element.dim
      end
   end

   no_of_fat_points result (res)
   ! Calculate the total number of points in the total grid over all atoms (i.e.
   ! not just the number of points in the reference atom grid).
      res :: INT
   ENSURE(.finalized,"not finalized; use set_grid_data")
   ENSURE(.atom_Z.created,"no atom_Z array")
      a :: INT
      res = 0    
      do a = 1,.atom_Z.dim       
         res = res + .no_of_points_for_row(period(.atom_Z(a)))
      end
   end

!  *****************************
!  Full grid generation routines
!  *****************************

   make_grid(pt,wt)
   ! Make the DFT integration grid points "pt" for a given list of "atoms".
   ! The precalculated atom grids must have been made by calling .set_grid_data
      pt :: MAT{REAL}, OUT
      wt :: VEC{REAL}, OUT
   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
   ENSURE(.atom_points.created,"no atom_Z array")
   ENSURE(pt.dim1==wt.dim,"incompatible pt and wt arrays")
   ENSURE(pt.dim2==3,"wrong size, pt array")
      a,u,f,l :: INT
      l = 0
      do a = 1,.atom_Z.dim     
         u = .unique_atom_for(a)
         f = l + 1
         l = l + .atom_weights(u).element.dim
         pt(f:l,:) = .atom_points(u).element
         wt(f:l)   = .atom_weights(u).element
         .displace(pt(f:l,:),a)
         .partition(wt(f:l),pt(f:l,:),a)
      end
   end

   make_grid(pt,wt,atoms,compress,weight_is_0) ::: leaky
   ! Make the DFT integration grid ("pt","wt") for a given list of "atoms".
   ! The precalculated atom grids must have been made by calling .set_grid_data
   ! If you don't want a compressed grid set "compress" to FALSE.  If you need
   ! the .weight_is_0 array (to save work when making basis function grids) then
   ! set "weight_is_0" to TRUE.
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      atoms :: VEC{INT}, IN
      compress,weight_is_0 :: BIN, optional
   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
   ENSURE(.atom_points.created,"no atom_Z array")
   ENSURE(.weight_is_0.destroyed,"the weight_is_0 array exists!")
      n_pt,a,u,f,l,i,k :: INT
      keep,kompress :: BIN
      pt0 :: MAT{REAL}*
      wt0 :: VEC{REAL}*
      kompress = TRUE
      keep = FALSE
      if (present(compress))    kompress = compress
      if (present(weight_is_0)) keep = weight_is_0
      if (atoms.dim==1)         kompress = FALSE
      n_pt = .no_of_points(atoms)
      pt.create(n_pt,3)                    ! leaky
      wt.create(n_pt)
      if (NOT kompress) then               ! <<< No compression
         l = 0
         do a = 1,atoms.dim     
            u = .unique_atom_for(atoms(a))
            f = l + 1
            l = l + .atom_weights(u).element.dim
            pt(f:l,:) = .atom_points(u).element
            wt(f:l)   = .atom_weights(u).element
            .displace(pt(f:l,:),atoms(a))
            if (atoms.dim==1) cycle
            .partition(wt(f:l),pt(f:l,:),a,atoms)
         end
 ! stdout.show("n_pt =",n_pt)
 ! .weight_is_0.create(n_pt)
 ! .weight_is_0 = FALSE
 ! stdout.text("w0:")
 ! stdout.put(.weight_is_0,"column")
 ! .weight_is_0.destroy
 ! stdout.text("pt:")
 ! stdout.put(pt)
 ! stdout.text("wt:")
 ! stdout.put(wt,"column")
      else                                 ! <<< Compress and partition ...
         .weight_is_0.create(n_pt)         ! leaky here
         l = 0
         do a = 1,atoms.dim     
            u = .unique_atom_for(atoms(a))
            f = l + 1
            l = l + .atom_weights(u).element.dim
            pt(f:l,:) = .atom_points(u).element
            wt(f:l)   = .atom_weights(u).element
            .displace(pt(f:l,:),atoms(a))
            .partition(wt(f:l),pt(f:l,:),a,atoms,.weight_is_0(f:l))
         end
         n_pt = count(NOT .weight_is_0)    ! How many non-zero weights?
 ! stdout.show("n_pt =",n_pt)
 ! stdout.show("n_mx =",wt.dim)
 ! stdout.text("w0:")
 ! stdout.put(.weight_is_0,"column")
 ! stdout.text("pt:")
 ! stdout.put(pt)
 ! stdout.text("wt:")
 ! stdout.put(wt,"column")
         if (n_pt==wt.dim) then            ! If none we don't need it
            .weight_is_0.destroy
         else
            pt0.create(n_pt,3)             ! leaky
            wt0.create(n_pt)
            k = 0
            do i = 1,wt.dim                ! Compress the grid here
               if (.weight_is_0(i)) cycle
               k = k + 1
               pt0(k,:) = pt(i,:)
               wt0(k)   = wt(i)
            end
            if (NOT keep) .weight_is_0.destroy ! Leaky
            wt.destroy; wt => wt0
            pt.destroy; pt => pt0
         end
      end
   end

   make_points(pt,atoms)
   ! Make the DFT integration grid points "pt" for a given list of "atoms".
   ! The precalculated atom grids must have been made by calling .set_grid_data
      pt :: MAT{REAL}, OUT
      atoms :: VEC{INT}, IN
   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
   ENSURE(.atom_points.created,"no atom_Z array")
   ENSURE(pt.dim2==3,"wrong size, pt array")
      a,u,f,l :: INT
      l = 0
      do a = 1,atoms.dim     
         u = .unique_atom_for(atoms(a))
         f = l + 1
         l = l + .atom_points(u).element.dim1
         pt(f:l,:) = .atom_points(u).element
         .displace(pt(f:l,:),atoms(a))
      end
   end

   make_weights(wt,pt,atoms) ::: leaky
   ! Make the DFT integration grid weights "wt" for a given set of grid points
   ! "pt" and for the given list of "atoms".  The precalculated atom grids must
   ! have been made by calling .set_grid_data
      wt :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}, IN
   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
   ENSURE(.atom_points.created,"no atom_Z array")
   ENSURE(pt.dim1==wt.dim,"incompatible pt and wt arrays")
   ENSURE(pt.dim2==3,"wrong size, pt array")
   ENSURE(.weight_is_0.destroyed,"the weight_is_o array exists!")
      a,u,f,l :: INT
      .weight_is_0.create(wt.dim)
      l = 0
      do a = 1,atoms.dim     
         u = .unique_atom_for(atoms(a))
         f = l + 1
         l = l + .atom_weights(u).element.dim
         wt(f:l) = .atom_weights(u).element
         if (atoms.dim==1) cycle
         .partition(wt(f:l),pt(f:l,:),a,atoms,.weight_is_0(f:l))
      end
      stdout.show("No of weight       =",.weight_is_0.dim)
      stdout.show("No of zero weights =",count(.weight_is_0))
   end

!  ***************************************
!  Basis function grid generation routines
!  ***************************************

   make_bf_grids(a0,a1,b0,b1,pt,atoms) ::: leaky
   ! Make the basis function grid and basis unction gradient grid, "a0", "a1"
   ! and "b0", "b1" respectively, on the set of points "pt", for a pair of
   ! "atoms" (a,b) in the complete atom list. NOTE: remember *not* to destroy
   ! "b0" and "b1" sometimes. NOTE: .weight_is_0 is destroyed at the end of
   ! this routine, since I assume that this expensive routine is called only
   ! once for a particular pair of atoms.
      a0,b0 :: MAT{REAL}*
      a1,b1 :: MAT3{REAL}*
      pt :: MAT{REAL}
      atoms :: VEC{INT}, IN
   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
   ENSURE(.atom_grid0.created,"no atom_grid0 array")
   ENSURE(.atom_grid1.created,"no atom_grid1 array")
   ENSURE(atoms.dim==2,"only valid for two atoms")
   ENSURE(a0.destroyed,"a0 exists!")
   ENSURE(a1.destroyed,"a1 exists!")
   ENSURE(b0.destroyed,"b0 exists!")
   ENSURE(b1.destroyed,"b1 exists!")
      n_pt,a,b,ua,ub,na,nb,n,fa,fb,i,k,ma,m :: INT
      a = atoms(1)
      b = atoms(2)
      if (a==b) then
         ua = .unique_atom_for(a) 
         a0.create_copy(.atom_grid0(ua).element)          ! Leaky
         a1.create_copy(.atom_grid1(ua).element)
         ENSURE(b0.destroyed,"b0 is not destroyed!")
         ENSURE(b1.destroyed,"b1 is not destroyed!")
         b0 => a0 
         b1 => a1
      else
         ua = .unique_atom_for(a) 
         ub = .unique_atom_for(b) 
         na = .atom_grid0(ua).element.dim1
         nb = .atom_grid0(ub).element.dim1
         fa = .atom_grid0(ua).element.dim2
         fb = .atom_grid0(ub).element.dim2
         n  = na + nb
         if (.weight_is_0.destroyed) then                 ! WARNING: be careful here
            a0.create(n,fa); a1.create(n,fa,3)            ! Leaky
            b0.create(n,fb); b1.create(n,fb,3)
            a0(   1:na,:)   = .atom_grid0(ua).element     ! a's basis functions on a's points
            a1(   1:na,:,:) = .atom_grid1(ua).element
            b0(na+1: n,:)   = .atom_grid0(ub).element     ! b's basis functions on b's points
            b1(na+1: n,:,:) = .atom_grid1(ub).element
            .atom(a).make_nabla_bf_grid(a1(na+1: n,:,:),a0(na+1: n,:),pt(na+1: n,:)) ! a's basis functions on b's point
            .atom(b).make_nabla_bf_grid(b1(   1:na,:,:),b0(   1:na,:),pt(   1:na,:)) ! b's basis functions on a's points
 ! stdout.show("na =",na)
 ! stdout.show("nb =",nb)
 ! stdout.show("n  =",n )
 ! stdout.text("a0:")
 ! stdout.put(a0)
         else
            m = count(NOT .weight_is_0)
            ENSURE(pt.dim1==m,"wrong size for pt array")
            a0.create(m,fa); a1.create(m,fa,3)            ! Leaky
            b0.create(m,fb); b1.create(m,fb,3)
            k = 0
            do i = 1,na
               if (.weight_is_0(i)) cycle
               k = k + 1
               a0(k,:)   = .atom_grid0(ua).element(i,:)   ! a's basis functions on a's points
               a1(k,:,:) = .atom_grid1(ua).element(i,:,:)
            end
            ma = k
            do i = 1,nb
               if (.weight_is_0(na+i)) cycle
               k = k + 1
               b0(k,:)   = .atom_grid0(ub).element(i,:)   ! b's basis functions on b's points
               b1(k,:,:) = .atom_grid1(ub).element(i,:,:)
            end
            .atom(a).make_nabla_bf_grid(a1(ma+1: m,:,:),a0(ma+1: m,:),pt(ma+1: m,:)) ! a's basis functions on b's point
            .atom(b).make_nabla_bf_grid(b1(   1:ma,:,:),b0(   1:ma,:),pt(   1:ma,:)) ! b's basis functions on a's points
 ! stdout.show("na =",na)
 ! stdout.show("nb =",nb)
 ! stdout.show("n  =",n )
 ! stdout.show("ma =",ma)
 ! stdout.show("m  =",m )
 ! stdout.text("a0:")
 ! stdout.put(a0)
            .weight_is_0.destroy                          ! <<< Destroy .weight_is_0
         end
      end
   end


!  *****************************
!  Slim grid generation routines
!  *****************************

!   make_slim_grid(pt,wt)
!   ! Make an entire *slim* integration grid, ("pt","wt") from the given list of atoms.
!   ! A slim grid makes use of atom_lowest_exponents and prunes the radial grid,
!   ! as well as pruning points which have zero or low weight factors.
!      pt :: MAT{REAL}, OUT
!      wt :: VEC{REAL}, OUT
!   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
!   ENSURE(.radial_grid.created,"no radial_grid")
!   ENSURE(.lebedev_grid.created,"no lebedev_grid")
!   ENSURE(.n_points_for_row.created,"n_points_for_row array missing")
!   ENSURE(.atom_Z.created,"no atom_Z array")
!   ENSURE(pt.dim1==wt.dim,"incompatible pt and wt arrays")
!   ENSURE(pt.dim2==3,"wrong size, pt array")
!   ENSURE(.atom_lowest_exponents.created,"no atom_lowest_exponents array")
!      n,p,p_max,a,f,l :: INT
!      na :: VEC{INT}*
!      na.create(.atom_Z.dim+1)
!      na(1) = 0                          ! Create an array telling where the points 
!      do a = 1,.atom_Z.dim               ! for each atom begins
!         na(a+1) = na(a) + .no_of_points_for_atom(a)
!      end
!      n = na(.atom_Z.dim+1)
!      .n_points = n                      ! Check the dimensions are correct
!      ENSURE(pt.dim1==n,"wrong size, pt")
!      ENSURE(wt.dim ==n,"wrong size, wt")
!      p_max = period(maxval(.atom_Z))
!      do p = 1,p_max                     ! Loop over atoms with periodic table row=p
!         if (all(period(.atom_Z)/=p)) cycle
!         .set_unscaled_grid(p)           ! Set unscaled reference grid for row=p
!         do a = 1,.atom_Z.dim            ! Do the atoms "a" for this row
!            if (period(.atom_Z(a))/=p) cycle
!            f = na(a) + 1                ! Not all the unscaled grid points are used
!            l = na(a+1)
!            .set_slim_and_scale(pt(f:l,:),wt(f:l),a)
!            .displace(pt(f:l,:),a)
!            .partition(wt(f:l),pt(f:l,:),a)
!         end
!         .destroy_unscaled_grid
!      end
!      na.destroy
!   end
!
!   make_slim_points(pt)
!   ! Make *only* the integration grid points "pt" from the given list of atoms.
!      pt :: MAT{REAL}, OUT
!   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
!   ENSURE(.radial_grid.created,"no radial_grid")
!   ENSURE(.lebedev_grid.created,"no lebedev_grid")
!   ENSURE(.n_points_for_row.created,"no n_points_for_row array")
!   ENSURE(.atom_Z.created,"no atom_Z array")
!   ENSURE(pt.dim2==3,"wrong size, pt array")
!   ENSURE(.atom_lowest_exponents.created,"no atom_lowest_exponents array")
!      n,p,p_max,a,f,l :: INT
!      na :: VEC{INT}*
!      na.create(.atom_Z.dim+1)
!      na(1) = 0                          ! Create an array telling where the points 
!      do a = 1,.atom_Z.dim               ! for each atom begins
!         na(a+1) = na(a) + .no_of_points_for_atom(a)
!      end
!      n = na(.atom_Z.dim+1)
!      .n_points = n                      ! Check the dimensions are correct
!      ENSURE(pt.dim1==n,"wrong size, pt")
!      p_max = period(maxval(.atom_Z))
!      do p = 1,p_max                     ! Loop over atoms with periodic table row=p
!         if (all(period(.atom_Z)/=p)) cycle
!         .set_unscaled_points(p)         ! Set unscaled reference grid for row=p
!         do a = 1,.atom_Z.dim            ! Do the atoms "a" for this row
!            if (period(.atom_Z(a))/=p) cycle
!            f = na(a) + 1
!            l = na(a+1)
!            .set_slim_and_scale(pt(f:l,:),a) ! Scale only points, and displace
!            .displace(pt(f:l,:),a)
!         end
!         .destroy_unscaled_grid
!      end
!      na.destroy
!   end
!
!   make_slim_weights(wt,pt)
!   ! Make *only* the integration grid weights "wt" for the given list of atoms.
!   ! The grid points "pt" must have been previously calculated using
!   ! .make_points and are required as input.
!      wt :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
!   ENSURE(.radial_grid.created,"no radial_grid")
!   ENSURE(.lebedev_grid.created,"no lebedev_grid")
!   ENSURE(.n_points_for_row.created,"no n_points_for_row array")
!   ENSURE(.atom_Z.created,"no atom_Z array")
!   ENSURE(pt.dim2==3,"wrong size, pt array")
!      n,p,p_max,a,f,l :: INT
!      na :: VEC{INT}*
!      na.create(.atom_Z.dim+1)
!      na(1) = 0                          ! Create an array telling where the points 
!      do a = 1,.atom_Z.dim               ! for each atom begins
!         na(a+1) = na(a) + .no_of_points_for_atom(a)
!      end
!      n = na(.atom_Z.dim+1)
!      .n_points = n                      ! Check the dimensions are correct
!      ENSURE(pt.dim1==n,"wrong size, pt")
!      ENSURE(wt.dim ==n,"wrong size, wt")
!      p_max = period(maxval(.atom_Z))
!      do p = 1,p_max                     ! Loop over atoms with periodic table row=p
!         if (all(period(.atom_Z)/=p)) cycle
!         .set_unscaled_weights(p)         ! Set unscaled reference grid for row=p
!         do a = 1,.atom_Z.dim            ! Do the atoms "a" for this row
!            if (period(.atom_Z(a))/=p) cycle
!            f = na(a) + 1
!            l = na(a+1)
!            .set_slim_and_scale(wt(f:l),a) ! Scale only weights, and partition
!            .partition(wt(f:l),pt(f:l,:),a)
!         end
!         .destroy_unscaled_grid
!      end
!      na.destroy
!   end
!
!   set_slim_and_scale(pt,wt,a) ::: private
!   ! Set a smaller portion of the unscaled quadrature grid ("pt","wt") and then
!   ! scale it by the zeta scale factor for atom "a", ".atom_zeta(a)".
!      pt :: MAT{REAL}
!      wt :: VEC{REAL}
!      a :: INT, IN
!   ENSURE(.finalized,"call the set_grid_data routine")
!   ENSURE(.unscaled_point.created,"no reference unscaled points")
!   ENSURE(.unscaled_weight.created,"no reference unscaled weights")
!   ENSURE(pt.dim1<=.n_unscaled_points,"pt incorrectly dimensioned")
!   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
!   ENSURE(wt.dim<=.n_unscaled_points, "wt incorrectly dimensioned")
!   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
!   ENSURE(.atom_Z.created,"no atom list")
!   ENSURE(.atom_zeta.created,"no atom scales")
!   ENSURE(a.is_in_range([1,.atom_Z.dim]),"atom index out of range")
!      s,s3 :: REAL
!      n :: INT
!      n = wt.dim
!      pt = .unscaled_point(1:n,:)
!      wt = .unscaled_weight(1:n)
!      ! Rescale the extend of the reference grid
!      if (NOT .scale_atomic_grids) return
!      s  = .atom_zeta(.atom_Z(a))
!      pt = s*pt
!      s3 = s*s*s
!      wt = s3*wt
!   end
!
!   set_slim_and_scale(pt,a) ::: private
!   ! Set a smaller portion of the unscaled quadrature grid ("pt","wt") and then
!   ! scale it by the zeta scale factor for atom "a", ".atom_zeta(a)".
!   ! This version scales only the points.
!      pt :: MAT{REAL}
!      a :: INT, IN
!   ENSURE(.finalized,"call the set_grid_data routine")
!   ENSURE(.unscaled_point.created,"no reference unscaled points")
!   ENSURE(pt.dim1<=.n_unscaled_points,"pt incorrectly dimensioned")
!   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
!   ENSURE(.atom_Z.created,"no atom list")
!   ENSURE(.atom_zeta.created,"no atom scales")
!   ENSURE(a.is_in_range([1,.atom_Z.dim]),"atom index out of range")
!      s :: REAL
!      n :: INT
!      n = pt.dim1
!      pt = .unscaled_point(1:n,:)
!      ! Rescale the extend of the reference grid
!      if (NOT .scale_atomic_grids) return
!      s  = .atom_zeta(.atom_Z(a))
!      pt = s*pt
!   end
!
!   set_slim_and_scale(wt,a) ::: private
!   ! Set a smaller portion of the unscaled quadrature grid ("pt","wt") and then
!   ! scale it by the zeta scale factor for atom "a", ".atom_zeta(a)".
!   ! This version scales only the weights.
!      wt :: VEC{REAL}
!      a :: INT, IN
!   ENSURE(.finalized,"call the set_grid_data routine")
!   ENSURE(.unscaled_weight.created,"no reference unscaled weights")
!   ENSURE(wt.dim<=.n_unscaled_points, "wt incorrectly dimensioned")
!   ENSURE(.atom_Z.created,"no atom list")
!   ENSURE(.atom_zeta.created,"no atom scales")
!   ENSURE(a.is_in_range([1,.atom_Z.dim]),"atom index out of range")
!      s,s3 :: REAL
!      n :: INT
!      n = wt.dim
!      wt = .unscaled_weight(1:n)
!      ! Rescale the extend of the reference grid
!      if (NOT .scale_atomic_grids) return
!      s  = .atom_zeta(.atom_Z(a))
!      s3 = s*s*s
!      wt = s3*wt
!   end

!  ********************************
!  Regular grid generation routines
!  ********************************

!   make_fat_grid(pt,wt)
!   ! Make an entire integration grid, ("pt","wt") from the given list of atoms.
!      pt :: MAT{REAL}, OUT
!      wt :: VEC{REAL}, OUT
!   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
!   ENSURE(.radial_grid.created,"no radial_grid")
!   ENSURE(.lebedev_grid.created,"no lebedev_grid")
!   ENSURE(.n_points_for_row.created,"n_points_for_row array missing")
!   ENSURE(.atom_Z.created,"no atom_Z array")
!   ENSURE(pt.dim1==wt.dim,"incompatible pt and wt arrays")
!   ENSURE(pt.dim2==3,"wrong size, pt array")
!      n,p,p_max,a,f,l :: INT
!      na :: VEC{INT}*
!      na.create(.atom_Z.dim+1)
!      na(1) = 0                          ! Create an array telling where the points 
!      do a = 1,.atom_Z.dim               ! for each atom begins
!         na(a+1) = na(a) + .n_points_for_row(period(.atom_Z(a)))
!      end
!      n = na(.atom_Z.dim+1)
!      .n_points = n                      ! Check the dimensions are correct
!      ENSURE(pt.dim1==n,"wrong size, pt")
!      ENSURE(wt.dim ==n,"wrong size, wt")
!      p_max = period(maxval(.atom_Z))
!      do p = 1,p_max                     ! Loop over atoms with periodic table row=p
!         if (all(period(.atom_Z)/=p)) cycle
!         .set_unscaled_grid(p)           ! Set unscaled reference grid for row=p
!         do a = 1,.atom_Z.dim            ! Do the atoms "a" for this row
!            if (period(.atom_Z(a))/=p) cycle
!            f = na(a) + 1
!            l = na(a) + .n_unscaled_points
!            .set_fat_and_scale(pt(f:l,:),wt(f:l),a)
!            .displace(pt(f:l,:),a)
!            .partition(wt(f:l),pt(f:l,:),a)
!         end
!         .destroy_unscaled_grid
!      end
!      na.destroy
!   end
!
!   make_fat_points(pt)
!   ! Make *only* the integration grid points "pt" from the given list of atoms.
!      pt :: MAT{REAL}, OUT
!   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
!   ENSURE(.radial_grid.created,"no radial_grid")
!   ENSURE(.lebedev_grid.created,"no lebedev_grid")
!   ENSURE(.n_points_for_row.created,"no n_points_for_row array")
!   ENSURE(.atom_Z.created,"no atom_Z array")
!   ENSURE(pt.dim2==3,"wrong size, pt array")
!      n,p,p_max,a,f,l :: INT
!      na :: VEC{INT}*
!      na.create(.atom_Z.dim+1)
!      na(1) = 0                          ! Create an array telling where the points 
!      do a = 1,.atom_Z.dim               ! for each atom begins
!         na(a+1) = na(a) + .n_points_for_row(period(.atom_Z(a)))
!      end
!      n = na(.atom_Z.dim+1)
!      .n_points = n                      ! Check the dimensions are correct
!      ENSURE(pt.dim1==n,"wrong size, pt")
!      p_max = period(maxval(.atom_Z))
!      do p = 1,p_max                     ! Loop over atoms with periodic table row=p
!         if (all(period(.atom_Z)/=p)) cycle
!         .set_unscaled_points(p)         ! Set unscaled reference grid for row=p
!         do a = 1,.atom_Z.dim            ! Do the atoms "a" for this row
!            if (period(.atom_Z(a))/=p) cycle
!            f = na(a) + 1
!            l = na(a) + .n_unscaled_points
!            .set_fat_and_scale(pt(f:l,:),a)  ! Scale only points, and displace
!            .displace(pt(f:l,:),a)
!         end
!         .destroy_unscaled_grid
!      end
!      na.destroy
!   end
!
!   make_fat_weights(wt,pt)
!   ! Make *only* the integration grid weights "wt" for the given list of atoms.
!   ! The grid points "pt" must have been previously calculated using
!   ! .make_points and are required as input.
!      wt :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!   ENSURE(.finalized,"radial and angular grids are unmade; use set_grid_data")
!   ENSURE(.radial_grid.created,"no radial_grid")
!   ENSURE(.lebedev_grid.created,"no lebedev_grid")
!   ENSURE(.n_points_for_row.created,"no n_points_for_row array")
!   ENSURE(.atom_Z.created,"no atom_Z array")
!   ENSURE(pt.dim2==3,"wrong size, pt array")
!      n,p,p_max,a,f,l :: INT
!      na :: VEC{INT}*
!      na.create(.atom_Z.dim+1)
!      na(1) = 0                          ! Create an array telling where the points 
!      do a = 1,.atom_Z.dim               ! for each atom begins
!         na(a+1) = na(a) + .n_points_for_row(period(.atom_Z(a)))
!      end
!      n = na(.atom_Z.dim+1)
!      .n_points = n                      ! Check the dimensions are correct
!      ENSURE(pt.dim1==n,"wrong size, pt")
!      ENSURE(wt.dim ==n,"wrong size, wt")
!      p_max = period(maxval(.atom_Z))
!      do p = 1,p_max                     ! Loop over atoms with periodic table row=p
!         if (all(period(.atom_Z)/=p)) cycle
!         .set_unscaled_weights(p)        ! Set unscaled reference grid for row=p
!         do a = 1,.atom_Z.dim            ! Do the atoms "a" for this row
!            if (period(.atom_Z(a))/=p) cycle
!            f = na(a) + 1
!            l = na(a) + .n_unscaled_points
!            .set_fat_and_scale(wt(f:l),a)    ! Scale only weights, and partition
!            .partition(wt(f:l),pt(f:l,:),a)
!         end
!         .destroy_unscaled_grid
!      end
!      na.destroy
!   end
!
!   set_fat_and_scale(pt,wt,a) ::: private
!   ! Scales the unscaled atom quadrature grid ("pt","wt") by the zeta scale
!   ! factor for atom "a", ".atom_zeta(a)". Schematically:
!   !           ("pt","wt") <-- (scale*"pt", scale^3*"wt"). 
!   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
!   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
!      pt :: MAT{REAL}
!      wt :: VEC{REAL}
!      a :: INT, IN
!   ENSURE(.finalized,"call the set_grid_data routine")
!   ENSURE(.unscaled_point.created,"no reference unscaled points")
!   ENSURE(.unscaled_weight.created,"no reference unscaled weights")
!   ENSURE(pt.dim1==.n_unscaled_points,"pt incorrectly dimensioned")
!   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
!   ENSURE(wt.dim==.n_unscaled_points, "wt incorrectly dimensioned")
!   ENSURE(.atom_Z.created,"no atom list")
!   ENSURE(.atom_zeta.created,"no atom scales")
!   ENSURE(a.is_in_range([1,.atom_Z.dim]),"atom index out of range")
!      s,s3 :: REAL
!      pt = .unscaled_point
!      wt = .unscaled_weight
!      ! Rescale the extend of the reference grid
!      if (NOT .scale_atomic_grids) return
!      s  = .atom_zeta(.atom_Z(a))
!      pt = s*pt
!      s3 = s*s*s
!      wt = s3*wt
!   end
!
!   set_fat_and_scale(pt,a) ::: private
!   ! Scales the unscaled atom quadrature grid ("pt","wt") by the zeta scale
!   ! factor for atom "a", ".atom_zeta(a)". Schematically:
!   !           ("pt","wt") <-- (scale*"pt", scale^3*"wt"). 
!   ! This version scales only the points.
!   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
!   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
!      pt :: MAT{REAL}
!      a :: INT, IN
!   ENSURE(.finalized,"call the set_grid_data routine")
!   ENSURE(.unscaled_point.created,"no reference unscaled points")
!   ENSURE(pt.dim1==.n_unscaled_points,"pt incorrectly dimensioned")
!   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
!   ENSURE(.atom_Z.created,"no atom list")
!   ENSURE(.atom_zeta.created,"no atom scales")
!   ENSURE(a.is_in_range([1,.atom_Z.dim]),"atom index out of range")
!      s :: REAL
!      pt = .unscaled_point
!      ! Rescale the extend of the reference grid
!      if (NOT .scale_atomic_grids) return
!      s  = .atom_zeta(.atom_Z(a))
!      pt = s*pt
!   end
!
!   set_fat_and_scale(wt,a) ::: private
!   ! Scales the unscaled atom quadrature grid ("pt","wt") by the zeta scale
!   ! factor for atom "a", ".atom_zeta(a)". Schematically:
!   !           ("pt","wt") <-- (scale*"pt", scale^3*"wt"). 
!   ! This version scales only the weights.
!   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
!   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
!      wt :: VEC{REAL}
!      a :: INT, IN
!   ENSURE(.finalized,"call the set_grid_data routine")
!   ENSURE(.unscaled_weight.created,"no reference unscaled weights")
!   ENSURE(wt.dim==.n_unscaled_points, "wt incorrectly dimensioned")
!   ENSURE(.atom_Z.created,"no atom list")
!   ENSURE(.atom_zeta.created,"no atom scales")
!   ENSURE(a.is_in_range([1,.atom_Z.dim]),"atom index out of range")
!      s,s3 :: REAL
!      wt = .unscaled_weight
!      ! Rescale the extend of the reference grid
!      if (NOT .scale_atomic_grids) return
!      s  = .atom_zeta(.atom_Z(a))
!      s3 = s*s*s
!      wt = s3*wt
!   end

   displace(pt,a) ::: private
   ! Displace the atomic grid from the origin to the position of atom "a".
   ! Schematically:
   !           ("pt","wt") <-- ("pt" + ".atom_pos(a,:)", "wt"). 
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
      pt :: MAT{REAL}
      a :: INT
      n :: INT
      do n = 1,pt.dim1
          pt(n,:) = pt(n,:) + .atom_pos(a,:)
      end
   end

   displace(pt,pos) ::: private
   ! Displace the atomic grid from the origin to "pos". Schematically:
   !           ("pt","wt") <-- ("pt" + "pos", "wt"). 
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
      pt :: MAT{REAL}
      pos :: VEC{REAL}(3)
      n :: INT
      do n = 1,pt.dim1
          pt(n,:) = pt(n,:) + pos
      end
   end

!  Partition function

   partition(wt,pt,a) ::: private
   ! Partition the grid ("pt","wt") for the atom "a" whose position is in
   ! "pos(a,:)" so that the weights work with all the other atomic positions
   ! given in "pos" using Becke's or Delley's partition function. Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! You can choose if you want the atom sizes to be taken account in
   ! the construction of the partiton.
   ! NOTE : all the positions in "pos" must be distinct!!!!!!
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
   !             Perez-Jorda and Yang 1995, CPL 241 p.469
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
      select case (.partition_scheme)
         case ("becke            ")
            select case (.partition_scaling_scheme)
               case ("none             "); .partition_B_no_adj(wt,pt,a)
               case ("becke            "); .partition_B_B_adj(wt,pt,a)
               case ("treutler_ahlrichs"); .partition_B_TA_adj(wt,pt,a)
               case default; UNKNOWN(.partition_scaling_scheme)
            end
         case ("delley           ")
            select case (.partition_scaling_scheme)
               case ("none             "); .partition_D(wt,pt,a)
               case default; UNKNOWN(.partition_scaling_scheme)
            end
         case ("stratmann_scuseria")
            select case (.partition_scaling_scheme)
               case ("none             "); .partition_SS(wt,pt,a)
               case default; UNKNOWN(.partition_scaling_scheme)
            end
         case default; UNKNOWN(.partition_scheme)
      end
   end

   partition_D(wt,pt,a) ::: private
   ! Using a modified Delley partition function (as described by Perez-Jorda and
   ! Yang 1995, CPL 241 p.469), partition the grid ("pt","wt") for the
   ! atom "a" so that the weights work with all the other atomic positions given
   ! in ".atom_pos". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! In this version no atomic size adjustments is made.
   ! NOTE : all the positions in "pos" must be distinct!!!!!!
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n,n_pts,n_centers,i :: INT
      dni,eni,s :: REAL
      rni,posi :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      n_centers = .atom_pos.dim1        ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"
      partition.create(n_pts,n_centers) ! Create partition array
      do i = 1,n_centers
          posi = .atom_pos(i,:)
          do n = 1,n_pts
              rni = pt(n,:) - posi
              dni = TWO*sqrt(dot_product(rni,rni))
              eni = min(ONE/dni,7.0d2)  ! Limit the exponential below
              s = exp(-dni)*(exp(eni)-ONE-eni)
              partition(n,i) = s
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      do n = 1,n_pts
          s = partition(n,a)/sum(partition(n,:))
          wt(n) = wt(n)*s
      end
      partition.destroy
   end

   partition_B_no_adj(wt,pt,a) ::: private
   ! Using Becke's partition function, partition the grid ("pt","wt") for the
   ! atom "a" so that the weights work with all the other atomic positions given
   ! in ".atom_pos". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! In this version no atomic size adjustments is made.
   ! NOTE : all the positions in "pos" must be distinct!!!!!!
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n,n_pts,n_centers,i,j,m :: INT
      rij,rni,rnj :: VEC{REAL}(3)
      dij,dni,dnj,uij,h,s :: REAL
      posi,posj :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      n_centers = .atom_pos.dim1        ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"
      partition.create(n_pts,n_centers) ! Create partition array
      partition = ONE
      do i = 1,n_centers
          posi = .atom_pos(i,:)
          do j = 1,n_centers
              if (i==j) cycle
              posj = .atom_pos(j,:)
              rij = posi-posj
              dij = sqrt(dot_product(rij,rij))
              do n = 1,n_pts
                  rni = pt(n,:) - posi
                  rnj = pt(n,:) - posj
                  dni = sqrt(dot_product(rni,rni))
                  dnj = sqrt(dot_product(rnj,rnj))
                  uij = (dni - dnj)/dij
                  h = uij
                  do m = 1,.partition_power
                      h = 1.5d0*h - HALF*h*h*h
                  end
                  s = HALF*(ONE - h)
                  ! ===========================================
                  partition(n,i) = partition(n,i)*s
              end
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      do n = 1,n_pts
          s = partition(n,a)/sum(partition(n,:))
          wt(n) = wt(n)*s
      end
      partition.destroy
   end

   partition_B_B_adj(wt,pt,a) ::: private
   ! Using Becke's partition function, partition the grid ("pt","wt") for the
   ! atom "a" so that the weights work with all the other atomic positions given
   ! in ".atom_pos". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! This version uses Becke's scheme for atomic size adjusments.
   ! NOTE : all the positions in "pos" must be distinct!!!!!!
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n,n_pts,n_centers,i,j,m,Z :: INT
      rij,rni,rnj :: VEC{REAL}(3)
      dij,dni,dnj,uij,vij,bsri,bsrj,chi,wij,aij,h,s :: REAL
      posi,posj :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      n_centers = .atom_pos.dim1        ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"
      partition.create(n_pts,n_centers) ! Create partition array
      partition = ONE
      do i = 1,n_centers
          bsri = bragg_slater_radius(.atom_Z(i))
          posi = .atom_pos(i,:)
          do j = 1,n_centers
              if (i==j) cycle
              bsrj = bragg_slater_radius(.atom_Z(j))
              chi = bsri/bsrj           ! Becke size adjustment
              wij = (chi - ONE)/(chi + ONE)
              aij = wij/(wij*wij - ONE)
              posj = .atom_pos(j,:)
              rij = posi-posj
              dij = sqrt(dot_product(rij,rij))
              do n = 1,n_pts
                  rni = pt(n,:) - posi
                  rnj = pt(n,:) - posj
                  dni = sqrt(dot_product(rni,rni))
                  dnj = sqrt(dot_product(rnj,rnj))
                  uij = (dni - dnj)/dij
                  vij = uij + aij*(ONE - uij*uij)
                  h = vij
                  do m = 1,.partition_power
                      h = 1.5d0*h - HALF*h*h*h
                  end
                  s = HALF*(ONE - h)
                  ! ===========================================
                  partition(n,i) = partition(n,i)*s
              end
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      do n = 1,n_pts
          s = partition(n,a)/sum(partition(n,:))
          wt(n) = wt(n)*s
      end
      partition.destroy
   end

   partition_B_TA_adj(wt,pt,a) ::: private
   ! Using Becke's partition function, partition the grid ("pt","wt") for the
   ! atom "a" so that the weights work with all the other atomic positions given
   ! in ".atom_pos". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! This version uses Treutler and Ahlrichs scheme for atomic size adjusments.
   ! NOTE : all the positions in "pos" must be distinct!!!!!!
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n,n_pts,n_centers,i,j,m,Z :: INT
      rij,rni,rnj :: VEC{REAL}(3)
      dij,dni,dnj,uij,vij,bsri,bsrj,chi,wij,aij,h,s :: REAL
      posi,posj :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      n_centers = .atom_pos.dim1        ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"
      partition.create(n_pts,n_centers) ! Create partition array
      partition = ONE
      do i = 1,n_centers
          bsri = bragg_slater_radius(.atom_Z(i))
          posi = .atom_pos(i,:)
          do j = 1,n_centers
              if (i==j) cycle
              bsrj = bragg_slater_radius(.atom_Z(j))
              chi = sqrt(bsri/bsrj)     ! Treutler-Ahlrcihs size adjustment
              wij = (chi - ONE)/(chi + ONE)
              aij = wij/(wij*wij - ONE)
              posj = .atom_pos(j,:)
              rij = posi-posj
              dij = sqrt(dot_product(rij,rij))
              do n = 1,n_pts
                  rni = pt(n,:) - posi
                  rnj = pt(n,:) - posj
                  dni = sqrt(dot_product(rni,rni))
                  dnj = sqrt(dot_product(rnj,rnj))
                  uij = (dni - dnj)/dij
                  vij = uij + aij*(ONE - uij*uij)
                  h = vij
                  do m = 1,.partition_power
                      h = 1.5d0*h - HALF*h*h*h
                  end
                  s = HALF*(ONE - h)
                  ! ===========================================
                  partition(n,i) = partition(n,i)*s
              end
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      do n = 1,n_pts
          s = partition(n,a)/sum(partition(n,:))
          wt(n) = wt(n)*s
      end
      partition.destroy
   end

   partition_SS(wt,pt,a) ::: private
   ! Using Stratmann and Scuseria's partition function, partition the atomic
   ! grid ("pt","wt") for the atom "a" in the list of "atoms" so that the
   ! weights work with all the other atomic positions given in ".atom_pos". 
   ! Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! In this version no atomic size adjustments is made.
   ! References: R.E. Stratmann, G E. Scuseria and M.E. Frisch, 1996 CPL 257 p. 213
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      i :: INT
      weight_is_0 :: VEC{BIN}*
      weight_is_0.create(wt.dim)
      .partition_SS(wt,pt,a,[(i,i=1,.atom_Z.dim)],weight_is_0)
      weight_is_0.destroy
   end

!  Partition function

   partition(wt,pt,a,atoms,weight_is_0) ::: private
   ! Partition the atomic grid ("pt","wt") for the atom "a" in the list of
   ! "atoms" so that the weights work with all the other atomic positions
   ! given in ".atom_pos(atoms,:)". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! You can choose if you want the atom sizes to be taken account in
   ! the construction of the partiton.
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
   !             Perez-Jorda and Yang 1995, CPL 241 p.469
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
      atoms :: VEC{INT}, IN
      weight_is_0 :: VEC{BIN}, optional, OUT
      select case (.partition_scheme)
         case ("becke            ")
            select case (.partition_scaling_scheme)
               case ("none             "); .partition_B_no_adj(wt,pt,a,atoms,weight_is_0)
               case ("becke            "); .partition_B_B_adj(wt,pt,a,atoms,weight_is_0)
               case ("treutler_ahlrichs"); .partition_B_TA_adj(wt,pt,a,atoms,weight_is_0)
               case default; UNKNOWN(.partition_scaling_scheme)
            end
         case ("delley           ")
            select case (.partition_scaling_scheme)
               case ("none             "); .partition_D(wt,pt,a,atoms,weight_is_0)
               case default; UNKNOWN(.partition_scaling_scheme)
            end
         case ("stratmann_scuseria")
            select case (.partition_scaling_scheme)
               case ("none             "); .partition_SS(wt,pt,a,atoms,weight_is_0)
               case default; UNKNOWN(.partition_scaling_scheme)
            end
         case default; UNKNOWN(.partition_scheme)
      end
   end

   partition_D(wt,pt,a,atoms,weight_is_0) ::: private
   ! Using a modified Delley partition function (as described by Perez-Jorda and
   ! Yang 1995, CPL 241 p.469), partition the grid ("pt","wt") for the
   ! atom "a" so that the weights work with all the other atomic positions given
   ! in ".atom_pos". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! In this version no atomic size adjustments is made.
   ! NOTE : all the positions in "pos" must be distinct!!!!!!
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
      atoms :: VEC{INT}, IN
      weight_is_0 :: VEC{BIN}, optional, OUT
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n,n_pts,n_centers,i :: INT
      dni,eni,s :: REAL
      rni,posi :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      n_centers = atoms.dim             ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"
      partition.create(n_pts,n_centers) ! Create partition array
      do i = 1,n_centers
          posi = .atom_pos(atoms(i),:)
          do n = 1,n_pts
              rni = pt(n,:) - posi
              dni = TWO*sqrt(dot_product(rni,rni))
              eni = min(ONE/dni,7.0d2)  ! Limit the exponential below
              s = exp(-dni)*(exp(eni)-ONE-eni)
              partition(n,i) = s
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      .partition_wt(wt,partition,a,weight_is_0)
      partition.destroy
   end

   partition_B_no_adj(wt,pt,a,atoms,weight_is_0) ::: private
   ! Using Becke's partition function, partition the atomic grid ("pt","wt") for
   ! the atom "a" in the list of "atoms" so that the weights work with all the
   ! other atomic positions given in ".atom_pos(atoms,:)". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! In this version no atomic size adjustments is made.
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
      atoms :: VEC{INT}, IN
      weight_is_0 :: VEC{BIN}, optional, OUT
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n,n_pts,n_centers,i,j,m :: INT
      rij,rni,rnj :: VEC{REAL}(3)
      dij,dni,dnj,uij,h,s :: REAL
      posi,posj :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      n_centers = atoms.dim             ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"
      partition.create(n_pts,n_centers) ! Create partition array
      partition = ONE
      do i = 1,n_centers
          posi = .atom_pos(atoms(i),:)
          do j = 1,n_centers
              if (i==j) cycle
              posj = .atom_pos(atoms(j),:)
              rij = posi-posj
              dij = sqrt(dot_product(rij,rij))
              do n = 1,n_pts
                  rni = pt(n,:) - posi
                  rnj = pt(n,:) - posj
                  dni = sqrt(dot_product(rni,rni))
                  dnj = sqrt(dot_product(rnj,rnj))
                  uij = (dni - dnj)/dij
                  h = uij
                  do m = 1,.partition_power
                      h = 1.5d0*h - HALF*h*h*h
                  end
                  s = HALF*(ONE - h)
                  ! ===========================================
                  partition(n,i) = partition(n,i)*s
              end
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      .partition_wt(wt,partition,a,weight_is_0)
      partition.destroy
   end

   partition_B_B_adj(wt,pt,a,atoms,weight_is_0) ::: private
   ! Using Becke's partition function, partition the atomic grid ("pt","wt") for
   ! the atom "a" in the list of "atoms" so that the weights work with all the
   ! other atomic positions given in ".atom_pos(atoms,:)". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! This version uses Becke's scheme for atomic size adjusments.
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
      atoms :: VEC{INT}, IN
      weight_is_0 :: VEC{BIN}, optional, OUT
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n,n_pts,n_centers,i,j,ai,aj,m,Z :: INT
      rij,rni,rnj :: VEC{REAL}(3)
      dij,dni,dnj,uij,vij,bsri,bsrj,chi,wij,aij,h,s :: REAL
      posi,posj :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      n_centers = atoms.dim             ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"
      partition.create(n_pts,n_centers) ! Create partition array
      partition = ONE
      do i = 1,n_centers
          ai = atoms(i)
          bsri = bragg_slater_radius(.atom_Z(ai))
          posi = .atom_pos(atoms(ai),:)
          do j = 1,n_centers
              if (i==j) cycle
              aj = atoms(j)
              bsrj = bragg_slater_radius(.atom_Z(aj))
              chi = bsri/bsrj           ! Becke size adjustment
              wij = (chi - ONE)/(chi + ONE)
              aij = wij/(wij*wij - ONE)
              posj = .atom_pos(aj,:)
              rij = posi-posj
              dij = sqrt(dot_product(rij,rij))
              do n = 1,n_pts
                  rni = pt(n,:) - posi
                  rnj = pt(n,:) - posj
                  dni = sqrt(dot_product(rni,rni))
                  dnj = sqrt(dot_product(rnj,rnj))
                  uij = (dni - dnj)/dij
                  vij = uij + aij*(ONE - uij*uij)
                  h = vij
                  do m = 1,.partition_power
                      h = 1.5d0*h - HALF*h*h*h
                  end
                  s = HALF*(ONE - h)
                  ! ===========================================
                  partition(n,i) = partition(n,i)*s
              end
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      .partition_wt(wt,partition,a,weight_is_0)
      partition.destroy
   end

   partition_B_TA_adj(wt,pt,a,atoms,weight_is_0) ::: private
   ! Using Becke's partition function, partition the atomic grid ("pt","wt") for
   ! the atom "a" in the list of "atoms" so that the weights work with all the
   ! other atomic positions given in ".atom_pos(atoms,:)". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! This version uses Treutler and Ahlrichs scheme for atomic size adjusments.
   ! References: A. D. Becke, J. Chem. Phys. 88 (1988) 2547.
   !             O. Treutler and R. Ahlrichs, J. Chem. Phys. 102 (1995) 346.
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
      atoms :: VEC{INT}, IN
      weight_is_0 :: VEC{BIN}, optional, OUT
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n,n_pts,n_centers,i,j,ai,aj,m,Z :: INT
      rij,rni,rnj :: VEC{REAL}(3)
      dij,dni,dnj,uij,vij,bsri,bsrj,chi,wij,aij,h,s :: REAL
      posi,posj :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      n_centers = atoms.dim             ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"
      partition.create(n_pts,n_centers) ! Create partition array
      partition = ONE
      do i = 1,n_centers
          ai = atoms(i)
          bsri = bragg_slater_radius(.atom_Z(ai))
          posi = .atom_pos(ai,:)
          do j = 1,n_centers
              if (i==j) cycle
              aj = atoms(j)
              bsrj = bragg_slater_radius(.atom_Z(aj))
              chi = sqrt(bsri/bsrj)     ! Treutler-Ahlrcihs size adjustment
              wij = (chi - ONE)/(chi + ONE)
              aij = wij/(wij*wij - ONE)
              posj = .atom_pos(aj,:)
              rij = posi-posj
              dij = sqrt(dot_product(rij,rij))
              do n = 1,n_pts
                  rni = pt(n,:) - posi
                  rnj = pt(n,:) - posj
                  dni = sqrt(dot_product(rni,rni))
                  dnj = sqrt(dot_product(rnj,rnj))
                  uij = (dni - dnj)/dij
                  vij = uij + aij*(ONE - uij*uij)
                  h = vij
                  do m = 1,.partition_power
                      h = 1.5d0*h - HALF*h*h*h
                  end
                  s = HALF*(ONE - h)
                  ! ===========================================
                  partition(n,i) = partition(n,i)*s
              end
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      .partition_wt(wt,partition,a,weight_is_0)
      partition.destroy
   end

   partition_SS(wt,pt,a,atoms,weight_is_zero) ::: private
   ! Using Stratmann and Scuseria's partition function, partition the atomic
   ! grid ("pt","wt") for the atom "a" in the list of "atoms" so that the
   ! weights work with all the other atomic positions given in
   ! ".atom_pos(atoms,:)". Schematically:
   !         ("pt","wt") <-- ("pt", partition*"wt"). 
   ! In this version no atomic size adjustments is made.
   ! References: R.E. Stratmann, G E. Scuseria and M.E. Frisch, 1996 CPL 257 p. 213
      wt :: VEC{REAL}
      pt :: MAT{REAL}, IN
      a :: INT, IN
      atoms :: VEC{INT}, IN
      weight_is_zero :: VEC{BIN}, target, optional, OUT
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
   ENSURE(.atom_pos.created,"no atom list")
   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
      n_centers,n_pts,i,j,k,n,m,ai,aj :: INT
      rij,rni,rnj :: VEC{REAL}(3)
      r_min,dij,dni,dnj,uij,uij1,uij2,uij3,uij5,uij7,h,s, aa,c5,c21,c35 :: REAL
      posi,posj :: VEC{REAL}(3)
      partition :: MAT{REAL}*
      weight_is_0,weight_is_1 :: VEC{BIN}*
      list :: VEC{INT}*

      if (present(weight_is_zero)) then; weight_is_0 => weight_is_zero
      else;                              weight_is_0.create(wt.dim)
      end

      aa = .stratmann_scuseria_A
      c5  = FIVE
      c21 = SEVEN*THREE
      c35 = SEVEN*FIVE
      n_centers = atoms.dim             ! Number of integration (atom) centres
      n_pts = wt.dim                    ! Number of points for this atom "a"

      weight_is_1.create(n_pts)         ! Tells where weights are 1 or zero
      weight_is_1 = FALSE

          i = a
          ai = atoms(i)
          posi = .atom_pos(ai,:)
          r_min = .atom_min_distance(ai)
          do n = 1,n_pts                ! Predetermine which weights are one
              rni = pt(n,:) - posi
              dni = sqrt(dot_product(rni,rni))
              if (dni>HALF*(ONE-aa)*r_min) cycle
              weight_is_1(n) = TRUE
          end

      k = 0                             ! Make the list of non-unit weights
      list.create(count(NOT weight_is_1))
      do n = 1,n_pts 
          if (weight_is_1(n)) cycle
          k = k + 1
          list(k) = n
      end

      partition.create(n_pts,n_centers) 
      partition = ONE
      weight_is_0 = FALSE

          i = a                         ! Do atom "a" partition & set weight_is_0
          ai = atoms(i)
          posi = .atom_pos(ai,:)
          r_min = .atom_min_distance(ai)
          do j = 1,n_centers
              if (i==j) cycle
              posj = .atom_pos(atoms(j),:)
              rij = posi-posj
              dij = sqrt(dot_product(rij,rij))
              do m = 1,list.dim         ! Loop over non-unit weight points
                  n = list(m)
                  rni = pt(n,:) - posi
                  rnj = pt(n,:) - posj
                  dni = sqrt(dot_product(rni,rni))
                  dnj = sqrt(dot_product(rnj,rnj))
                  uij = (dni - dnj)/dij
                  if      (uij> aa) then
                     partition(n,i) = ZERO
                     weight_is_0(n) = TRUE
                     wt(n) = ZERO       ! <<< This is rigorously zero ...
                  else if (uij>-aa) then
                     uij1 = uij/aa
                     uij2 = uij1*uij1
                     uij3 = uij2*uij1
                     uij5 = uij3*uij2
                     uij7 = uij5*uij2
                     h = SIXTEENTH*(c35*uij1-c35*uij3+c21*uij5-c5*uij7)
                     s = HALF*(ONE - h)
                     partition(n,i) = partition(n,i)*s
                  end
              end
          end

      k = 0                             ! Make the list of non-unit & non-zero weights
      list.destroy
      list.create(count(NOT (weight_is_1 OR weight_is_0)))
      do n = 1,n_pts 
          if (weight_is_1(n) OR weight_is_0(n)) cycle
          k = k + 1
          list(k) = n
      end
      weight_is_1.destroy

      do i = 1,n_centers                ! Now partition those non-unit weights
          if (i==a) cycle               ! Do atoms /= a ... for normalisation
          ai = atoms(i)
          posi = .atom_pos(ai,:)
          r_min = .atom_min_distance(ai)
          do j = 1,n_centers
              if (i==j) cycle
              posj = .atom_pos(atoms(j),:)
              rij = posi-posj
              dij = sqrt(dot_product(rij,rij))
              do m = 1,list.dim         ! Loop over non-unit non-zero weight points
                  n = list(m)          
                  rni = pt(n,:) - posi
                  rnj = pt(n,:) - posj
                  dni = sqrt(dot_product(rni,rni))
                  dnj = sqrt(dot_product(rnj,rnj))
                  uij = (dni - dnj)/dij
                  if      (uij> aa) then
                     partition(n,i) = ZERO
                  else if (uij>-aa) then
                     uij1 = uij/aa
                     uij2 = uij1*uij1
                     uij3 = uij2*uij1
                     uij5 = uij3*uij2
                     uij7 = uij5*uij2
                     h = SIXTEENTH*(c35*uij1-c35*uij3+c21*uij5-c5*uij7)
                     s = HALF*(ONE - h)
                     partition(n,i) = partition(n,i)*s
                  end
              end
          end
      end
      ! Normalize the partitioning function and modify the grid weights
      do m = 1,list.dim
          n = list(m)
          s = partition(n,a)/sum(partition(n,:))
          wt(n) = wt(n)*s
          if (s<=.partition_cutoff) weight_is_0(n) = TRUE
      end
      partition.destroy
      list.destroy
      if (NOT present(weight_is_zero)) weight_is_0.destroy
   end

!   partition_SS(wt,pt,a,atoms,weight_is_0) ::: private
!   ! Using Stratmann and Scuseria's partition function, partition the atomic
!   ! grid ("pt","wt") for the atom "a" in the list of "atoms" so that the
!   ! weights work with all the other atomic positions given in
!   ! ".atom_pos(atoms,:)". Schematically:
!   !         ("pt","wt") <-- ("pt", partition*"wt"). 
!   ! In this version no atomic size adjustments is made.
!   ! References: R.E. Stratmann, G E. Scuseria and M.E. Frisch, 1996 CPL 257 p. 213
!      wt :: VEC{REAL}
!      pt :: MAT{REAL}, IN
!      a :: INT, IN
!      atoms :: VEC{INT}, IN
!      weight_is_0 :: VEC{BIN}, optional, OUT
!   ENSURE(.finalized,"call the set_grid_data routine")
!   ENSURE(pt.dim2==3,"pt incorrectly dimensioned")
!   ENSURE(pt.dim1==wt.dim, "pt and wt incompatible")
!   ENSURE(.atom_pos.created,"no atom list")
!   ENSURE(a.is_in_range([1,.atom_pos.dim1]),"`a' argument out of range")
!      n_centers,n_pts,i,j,k,n,m,ai,aj :: INT
!      rij,rni,rnj :: VEC{REAL}(3)
!      r_min,dij,dni,dnj,uij,uij1,uij2,uij3,uij5,uij7,h,s, aa,c5,c21,c35 :: REAL
!      posi,posj :: VEC{REAL}(3)
!      partition :: MAT{REAL}*
!      weight_is_1 :: VEC{BIN}*
!      list :: VEC{INT}*
!      aa = .stratmann_scuseria_A
!      c5  = FIVE
!      c21 = SEVEN*THREE
!      c35 = SEVEN*FIVE
!      n_centers = atoms.dim             ! Number of integration (atom) centres
!      n_pts = wt.dim                    ! Number of points for this atom "a"
!    ! weight_is_1.create(n_pts)         ! Tells where weights are 1 or zero
!    ! weight_is_1 = FALSE
!    ! do i = 1,n_centers
!    !     ai = atoms(i)
!    !     posi = .atom_pos(ai,:)
!    !     r_min = .atom_min_distance(ai)
!    !     do n = 1,n_pts                ! Predetermine which weights are not one
!    !         rni = pt(n,:) - posi
!    !         dni = sqrt(dot_product(rni,rni))
!    !         if (dni>HALF*(ONE-aa)*r_min) cycle
!    !         weight_is_1(n) = TRUE
!    !     end
!    ! end
!    ! k = 0                             ! Make the list of non-unit weights
!    ! list.create(count(NOT weight_is_1))
!    ! do n = 1,n_pts 
!    !     if (weight_is_1(n)) cycle
!    !     k = k + 1
!    !     list(k) = n
!    ! end
!    ! weight_is_1.destroy
!      partition.create(n_pts,n_centers) 
!      partition = ONE
!      do i = 1,n_centers                ! Now partition those non-unit weights
!          ai = atoms(i)
!          posi = .atom_pos(ai,:)
!          r_min = .atom_min_distance(ai)
!          do j = 1,n_centers
!              if (i==j) cycle
!              posj = .atom_pos(atoms(j),:)
!              rij = posi-posj
!              dij = sqrt(dot_product(rij,rij))
!            ! do m = 1,list.dim         ! Loop over non-unit weight points
!            !     n = list(m)
!              do n = 1,n_pts
!                  rni = pt(n,:) - posi
!                  rnj = pt(n,:) - posj
!                  dni = sqrt(dot_product(rni,rni))
!                  dnj = sqrt(dot_product(rnj,rnj))
!                  uij = (dni - dnj)/dij
!                  if      (uij> aa) then
!                     partition(n,i) = ZERO
!                  else if (uij>-aa) then
!                     uij1 = uij/aa
!                     uij2 = uij1*uij1
!                     uij3 = uij2*uij1
!                     uij5 = uij3*uij2
!                     uij7 = uij5*uij2
!                     h = SIXTEENTH*(c35*uij1-c35*uij3+c21*uij5-c5*uij7)
!                     s = HALF*(ONE - h)
!                     partition(n,i) = partition(n,i)*s
!                  end
!              end
!          end
!      end
!      ! Normalize the partitioning function and modify the grid weights
!    ! do m = 1,list.dim
!    !     n = list(m)
!    !     if (weight_is_0(n)) then
!    !        wt(n) = ZERO
!    !     else
!    !        s = partition(n,a)/sum(partition(n,:))
!    !        wt(n) = wt(n)*s
!    !        if (s<=.partition_cutoff) weight_is_0(n) = TRUE
!    !     end
!    ! end
!      .partition_wt(wt,partition,a,weight_is_0)
!      partition.destroy
!      list.destroy
!   end

   partition_wt(wt,partition,a,weight_is_0) ::: private
   ! Partition the weights "wt" using the unnormalised "partition" for atom "a".
   ! If present the zero weights are recorded in "weight_is_0".
      wt :: VEC{REAL}
      partition :: MAT{REAL}, IN
      a :: INT, IN
      weight_is_0 :: VEC{BIN}, optional, OUT
      n :: INT
      s :: REAL
      if (present(weight_is_0)) then
          weight_is_0 = FALSE
          do n = 1,wt.dim
              s = partition(n,a)/sum(partition(n,:))
              wt(n) = wt(n)*s
              if (s>.partition_cutoff) cycle
              weight_is_0(n) = TRUE
          end
      else
          do n = 1,wt.dim
              s = partition(n,a)/sum(partition(n,:))
              wt(n) = wt(n)*s
          end
      end
   end

!  ******************************
!  Numerical integration routines
!  ******************************

   integrate_function(f,Z,pos,ans)
   ! Integrate the function "f" which is sharply peaked at positions "pos" in 3D
   ! space, where the peaks resemble those in the electron density of atoms with
   ! charge "Z". The integrand is returned as "ans".
      self :: PTR
      interface
         f(f_grid,pts)
            f_grid :: VEC{REAL}, OUT
            pts :: MAT{REAL}, IN
         end
      end
      pos :: MAT{REAL}
      Z   :: VEC{INT}
      ans :: REAL
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(pos.dim1==Z.dim,"pos and Z are incompatible")
   ENSURE(pos.dim2==3,"wrong size, pos")
      n_pt :: INT
      pt :: MAT{REAL}*
      wt,f_grid :: VEC{REAL}*
    ! .set_atoms_and_positions(Z,pos)
      n_pt = .no_of_points
      f_grid.create(n_pt)
      pt.create(n_pt,3); wt.create(n_pt)
      .make_grid(pt,wt) ! <<<<<<<<<<<
      ! Do the integration
      call f(f_grid,pt)
      ans = sum(f_grid*wt)
      wt.destroy; pt.destroy; f_grid.destroy
   end

   make_matrix_elements_of(V,g,ans)
   ! Integrate the matrix elements of a multiplicative operator "V"
   ! between all components of two gaussian functions given by the
   ! gaussian-pair "g". The result of the integration is matrix "ans".
   ! Operator "V" is represented by a function which returns a "v_grid"
   ! on a set of "pts".
      self :: PTR
      interface
         V(v_grid,pts)
            v_grid :: VEC{REAL}
            pts :: MAT{REAL}
         end
      end
      g :: GAUSSIAN2
      ans :: MAT{REAL}
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(ans.dim1==g.a.n_comp,"wrong size, ans")
   ENSURE(ans.dim2==g.b.n_comp,"wrong size, ans")
      n_pt,n,a,b :: INT
      pt,pos,a_grid,b_grid :: MAT{REAL}*
      wt,v_grid :: VEC{REAL}*
      Z :: VEC{INT}*
      if (g.a.pos.equals(g.b.pos)) then
         Z.create(1); Z = 1
         pos.create(1,3)
         pos(1,:) = g.a.pos
      else
         Z.create(2); Z = 1
         pos.create(2,3)
         pos(1,:) = g.a.pos
         pos(2,:) = g.b.pos
      end
      .reduce_core_angular_grid = FALSE ! Gives better results for ME's
      .scale_atomic_grids = TRUE        ! This is essential for Mura-Knowles
    ! .partition_scaling_scheme = "none"
    ! .set_atoms_and_positions(Z,pos)
      n_pt = .no_of_points
      v_grid.create(n_pt)
      a_grid.create(n_pt,g.a.n_comp)
      b_grid.create(n_pt,g.b.n_comp)
      pt.create(n_pt,3); wt.create(n_pt)
      .make_grid(pt,wt) ! <<<<<<<<<<<
      ! Do the integration
      ans = ZERO
         call V(v_grid,pt)
         v_grid = wt*v_grid
         g.a.make_grid(a_grid,pt)
         g.b.make_grid(b_grid,pt)
         do a = 1,g.a.n_comp
         do b = 1,g.b.n_comp
            wt = a_grid(:,a)*b_grid(:,b)
            ans(a,b) = ans(a,b) + sum(wt*v_grid)
         end
         end
      wt.destroy; pt.destroy
      b_grid.destroy; a_grid.destroy; v_grid.destroy
      pos.destroy; Z.destroy
   end

   make_matrix_elements_of(V,g,c,ans)
   ! Integrate the matrix elements of a multiplicative operator "V"
   ! between all components of two gaussian functions given by the
   ! gaussian-pair "g". The result of the integration is matrix "ans".
   ! Operator "V" is represented by a function which returns a "v_grid"
   ! on a set of "pts".
      self :: PTR
      interface
         V(v_grid,pts)
            v_grid :: VEC{REAL}
            pts :: MAT{REAL}
         end
      end
      g :: GAUSSIAN2
      c :: VEC{REAL}(3)
      ans :: MAT{REAL}
   ENSURE(.finalized,"call the set_grid_data routine")
   ENSURE(ans.dim1==g.a.n_comp,"wrong size, ans")
   ENSURE(ans.dim2==g.b.n_comp,"wrong size, ans")
      n_pt,n,a,b :: INT
      pt,pos,a_grid,b_grid :: MAT{REAL}*
      wt,v_grid :: VEC{REAL}*
      Z :: VEC{INT}*
      if (g.a.pos.equals(g.b.pos)) then
         Z.create(2); Z = 1
         pos.create(2,3)
         pos(1,:) = g.a.pos
         pos(2,:) = c
      else
         Z.create(3); Z = 1
         pos.create(3,3)
         pos(1,:) = g.a.pos
         pos(2,:) = g.b.pos
         pos(3,:) = c
      end
    ! .reduce_core_angular_grid = FALSE
    ! .scale_atomic_grids = FALSE
    ! .partition_scaling_scheme = "none"
    ! .set_atom_info(Z,pos)
      n_pt = .no_of_points
      v_grid.create(n_pt)
      a_grid.create(n_pt,g.a.n_comp)
      b_grid.create(n_pt,g.b.n_comp)
      pt.create(n_pt,3); wt.create(n_pt)
      .make_grid(pt,wt) ! <<<<<<<<<<<
      ! Do the integration
      ans = ZERO
         call V(v_grid,pt)
         v_grid = wt*v_grid
         g.a.make_grid(a_grid,pt)
         g.b.make_grid(b_grid,pt)
         do a = 1,g.a.n_comp
         do b = 1,g.b.n_comp
            wt = a_grid(:,a)*b_grid(:,b)
            ans(a,b) = ans(a,b) + sum(wt*v_grid)
         end
         end
      wt.destroy; pt.destroy
      b_grid.destroy; a_grid.destroy; v_grid.destroy
      pos.destroy; Z.destroy
   end

!  **************
!  Output methods
!  **************

   put(out)
   ! Put out to file "out"
      out :: TEXTFILE, target, optional
      output :: TEXTFILE*
      if (present(out)) then; output => out
      else;                   output => stdout
      end
      output.flush
      output.text("BECKE_GRID information:")
      output.flush
      output.show("Kind of grid              =",.kind)
      output.show("Accuracy                  =",.accuracy)
      output.show("Basis function cutoff     =",.basis_function_cutoff)
      output.show("Partition cutoff          =",.partition_cutoff)
      output.show("Partition scheme          =",.partition_scheme)
      output.show("Partition scaling scheme  =",.partition_scaling_scheme)
      output.show("Becke partition_power     =",.partition_power)
      output.show("Scale atomic grids?       =",.scale_atomic_grids)
      output.show("# of points (row=1)       =",.no_of_points_for_row(1))
      output.show("# of points (row=2)       =",.no_of_points_for_row(2))
      output.show("# of points (row=3)       =",.no_of_points_for_row(3))
      output.flush
      output.text("Radial grid:")
      output.flush
      output.show("n_radial_points (for H)   =",.n_radial_points)
      output.show("n_extra_points_per_shell  =",.n_extra_points_per_shell)
      output.flush
      output.text("Angular grid:")
      output.flush
      output.show("l_angular_grid            =",.l_angular_grid)
      output.show("l_H_angular_grid          =",.l_H_angular_grid)
      output.show("reduce_core_angular_grid? =",.reduce_core_angular_grid)
      output.show("reduce_H_angular_grid?    =",.reduce_H_angular_grid)
   end

   put_atom_info(out)
   ! Put out the atom info to file "out"
      out :: TEXTFILE, target, optional
   ENSURE(.finalized,"not finalized")
   ENSURE(.atom_Z.created,"no atom list")
   ENSURE(.atom_pos.created,"no atom list")
      output :: TEXTFILE*
      i,Z,u,np :: INT
      has_exponents :: BIN
      fields :: INT
      if (present(out)) then; output => out
      else;                   output => stdout
      end
      has_exponents = FALSE
      fields = 4
      if (.atom_lowest_exponents.created) then
         has_exponents = TRUE
         fields = 5
      end
      output.flush
      output.show("Total n_points            =",.no_of_points)
      output.flush
      output.text("Atom center information:")
      output.flush
      output.dash(int_fields=fields,real_fields=fields)
      output.put("Atom #",int_width=TRUE)
      output.put("Z",int_width=TRUE)
      output.put("Row",int_width=TRUE)
      output.put("x")
      output.put("y")
      output.put("z")
      output.put("Scale factor")
      if (has_exponents) output.put_str("Min exponent")
      output.put("n_pts",int_width=TRUE)
      output.put("n_max",int_width=TRUE)
      output.flush
      output.dash(int_fields=fields,real_fields=fields)
      do i = 1,.atom_Z.dim
         output.put_int(i)
         Z = .atom_Z(i)
         output.put(Z)
         output.put(period(Z))
         output.put(.atom_pos(i,1))
         output.put(.atom_pos(i,2))
         output.put(.atom_pos(i,3))
         output.put(.atom_zeta(Z))
         if (has_exponents) then
            u = .unique_atom_for(i)
            np = .atom_weights(u).element.dim
            output.put(.atom_lowest_exponents(i))
            output.put(np)
         end
         output.put(.n_points_for_row(period(Z)))
         output.flush
      end
      output.dash(int_fields=fields,real_fields=fields)
   end

   put_radial_angular_grids(out)
   ! Put out the radial and angular grid info to file "out"
      out :: TEXTFILE, target, optional
   ENSURE(.finalized,"not finalized")
   ENSURE(.radial_grid.created,"no radial_grid")
   ENSURE(.lebedev_grid.created,"no lebedev_grid")
      output :: TEXTFILE*
      i,p :: INT
      if (present(out)) then; output => out
      else;                   output => stdout
      end
      do p = 1,1
      output.flush
      output.show("Radial grid, period = ",p)
      output.flush
      output.dash(int_fields=1,real_fields=2)
      output.put("pt #",int_width=TRUE)
      output.put("pt")
      output.put("wt")
      output.flush
      output.dash(int_fields=1,real_fields=2)
      do i = 1,.radial_grid(p).n_points
         output.put(i)
         output.put(.radial_grid(p).point(i))
         output.put(.radial_grid(p).weight(i))
         output.flush
      end
      end
      output.flush
      output.text("Angular grid:")
      output.flush
      output.dash(int_fields=1,real_fields=4)
      output.put("pt #",int_width=TRUE)
      output.put("x")
      output.put("y")
      output.put("z")
      output.put("wt")
      output.flush
      output.dash(int_fields=1,real_fields=4)
      do i = 1,.lebedev_grid.n_points
         output.put(i)
         output.put(.lebedev_grid.point(i,1))
         output.put(.lebedev_grid.point(i,2))
         output.put(.lebedev_grid.point(i,3))
         output.put(.lebedev_grid.weight(i))
         output.flush
      end
      output.dash(int_fields=1,real_fields=4)
   end

   put_unique_atom_grids(out)
   ! Put out the unique atom grid info to file "out"
      out :: TEXTFILE, target, optional
   ENSURE(.finalized,"not finalized")
   ENSURE(.unique_atom.created,"no .unique_atom")
   ENSURE(.atom_points.created,"no .atom_points")
   ENSURE(.atom_weights.created,"no .atom_weights")
      output :: TEXTFILE*
      u,a,p,np :: INT
      if (present(out)) then; output => out
      else;                   output => stdout
      end
      output.flush
      output.text("Atom grids:")
      output.flush
      output.show("No of atom grids          =",.n_unique_atoms)
      output.flush
      do u = 1,.n_unique_atoms
         a = .unique_atom(u)
         np = .atom_weights(u).element.dim
         p = period(.atom_Z(a))
         output.flush
         output.show("Unique atom number        =",u)
         output.show("Atom number               =",a)
         output.show("Atomic number             =",.atom_Z(a))
         output.show("No of points              =",np)
         output.show("Max no of points for row  =",.n_points_for_row(p))
         output.flush
         output.text("Grid points:")
         output.put(.atom_points(u).element)
         output.flush
         output.text("Grid weights:")
         output.put(.atom_weights(u).element,"column")
      end
   end

end
