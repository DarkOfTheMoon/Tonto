!-------------------------------------------------------------------------------
!
! TYPES : used to deposit all derived types used in TONTO.
!
! A separate module is required so that two modules can use each others types in
! even if they can't use each others routines by with a "use" statement. In the
! C++ language every one of TONTO's objects are "friendly" with each other.
!
! (c) dylan jayatilaka, univeristy of western australia, 1998
!
! $Id$
!
!-------------------------------------------------------------------------------
module TYPES

   implicit none

#  include "macros"


   type system_type
 
   INT :: error_status
   ! Set non-zero on errors
 
   INT :: error_unit
   ! Unit number for error messages
 
   INT :: mem_used
   ! Memory used so far
 
   INT :: mem_blocks
   ! No of blocks allocated so far
 
   INT :: mem_max_used
   ! Maximum memory used so far
 
   INT :: mem_max_blocks
   ! Maximum memory blocks allocated
 
   INT :: mem_limit
   ! Soft memory limit
 
   BIN :: mem_exceeded
   ! True if memory soft limit exceeded
 
   STR :: mem_units
   ! Memory usage units
 
   INT :: stack_level
   ! The current call-stack level
 
   INT :: stack_max_level
   ! Maximum call-stack level
 
   INT :: stack_check_level
   ! Enable memory checking for all routines at this level or higher in the
   ! call-stack
 
   IVEC* :: used_stack
   ! Stores the amount of memory used at each call-level
 
   STRVEC* :: call_stack
   ! Stores the name of each subroutine at each call-level for tracebacks

   BIN :: show_call_stack
   ! Whether to show the complete call stack as the program runs.
   ! Be warned, this produces copious output.
 
   STR :: io_file_name
   ! Last file used
 
   STR :: io_file_action
   ! The action (read or write) assciated with the io_file
 
   INT :: io_file_record
   ! Record number of last file
 
   BSTR :: io_file_buffer
   ! The buffer string associated with the io_file
 
   INT :: io_file_pos
   ! The position of the cursor in the buffer string
 
   end


   type dblfmt_type

   INT :: fields
   ! No of fields (i.e. columns) to use for outputting     

   INT :: width
   ! Width of each field

   INT :: precision
   ! No. of decimal places to use for output

   STR :: dbl_style
   ! Fortran style character for the dbl variable

   end 


   type buffer_type

   INT :: pos
   ! The position of the last character of the last item processed in
   ! buffer_str

   INT :: item
   ! The item number of the last item processed in buffer_str

   INT :: n_items
   ! The total number of items in the buffer_str

   BIN :: analysed
   ! True, if the buffer_str has been analysed

   STR :: comment_chars
   ! The comment character symbols (concatenated) to be used in the
   ! buffer_str

   BSTR :: buffer_str
   ! The actual buffer string

   end 


   type unitnumber_type

   INT :: unit
   ! The unit number

   end


   type file_type

   STR :: name
   ! The name of the file

   INT :: unit
   ! The unit number

   INT :: record
   ! The current record of the output

   INT :: io_status
   ! Set non-zero if there is an error condition

   STR :: action
   ! The type of action performed on this file

   STR :: file_status
   ! File status

   BIN :: buffered
   ! Whether to use buffering if the file is for numbers

   INT :: int_buffer_pos
   ! The integer buffer position marker

   IVEC* :: int_buffer
   ! The integer buffer which is flushed to the file when full

   INT :: dbl_buffer_pos
   ! The dbl buffer position marker

   VEC* :: dbl_buffer
   ! The dbl buffer which is flushed to the file when full

   INT :: cdbl_buffer_pos
   ! The cdbl buffer position marker

   CVEC* :: cdbl_buffer
   ! The cdbl buffer which is flushed to the file when full

   end 


   type input_type

   STR :: name
   ! The name of the file

   INT :: unit
   ! The unit number

   INT :: record
   ! The current record of the output

   INT :: io_status
   ! Set non-zero if there is an error condition
 
   STR :: default_units
   ! Each DBL number is assumed to have "default_units", and are converted
   ! into generic (internal) units, usually A.U.

   BUFFER :: buffer
   ! The input file buffer which holds one line of input

   end 


   type output_type

   STR :: name
   ! The name of the file

   INT :: unit
   ! The unit number

   INT :: record
   ! The current record of the output

   INT :: io_status
   ! Set non-zero if there is an error condition

   INT :: fields
   ! No of fields (i.e. columns) to use for outputting the variable 

   INT :: int_width
   ! Width of an integer field

   INT :: dbl_width
   ! Width of a dbl field

   INT :: dbl_precision
   ! No. of decimal places to use for outputing a dbl variable

   STR :: dbl_style
   ! Fortran style character for a dbl variable

   INT :: margin
   ! Margin width 

   BIN :: labels
   ! Whether to use column and row labels on vectors and matrices

   BUFFER :: buffer
   ! The output buffer which holds one line of output to be flushed

   end 


   type textfile_type

   STR :: name
   ! The name of the file

   STR :: action
   ! The action status of the file, "read" or "write"

   INT :: unit
   ! The unit number

   INT :: record
   ! The current record of the output

   INT :: io_status DEFAULT(0)
   ! Set non-zero if there is an error condition

   BIN :: ignore_end_of_file DEFAULT(FALSE)
   ! Set to TRUE if the end of file is not to be regarded as an error.

   INT :: fields DEFAULT(TEXTFILE_NO_OF_FIELDS)
   ! No of fields (i.e. columns) to use for outputting the variable

   INT :: int_width DEFAULT(TEXTFILE_INT_WIDTH)
   ! Width of an integer field

   INT :: dbl_width DEFAULT(TEXTFILE_DBL_WIDTH)
   ! Width of a dbl field

   INT :: dbl_precision DEFAULT(TEXTFILE_PRECISION)
   ! No. of decimal places to use for outputing a dbl variable

   STR :: dbl_style DEFAULT(TEXTFILE_DBL_STYLE)
   ! Fortran style character for a dbl variable

   INT :: margin DEFAULT(TEXTFILE_MARGIN_WIDTH)
   ! Margin width

   BIN :: labels DEFAULT(TEXTFILE_USE_LABELS)
   ! Whether to use column and row labels on vectors and matrices

   STR :: default_units DEFAULT(" ")
   ! Each DBL number is assumed to have "default_units", and are converted
   ! into generic (internal) units, usually A.U.

   BUFFER :: buffer
   ! The output buffer which holds one line of output to be flushed

   STRVEC* :: internal
   ! Used to keep a record of of the entire file, internally

   TEXTFILE* :: saved
   ! Used to keep a record of a previous file, say for input redirect

   end


   type archive_type

   STR :: root_name
   ! Archive root name (usually, the name of the job)

   STR :: name
   ! Archive name (usually, the name of the entity in the archive)

   STR :: kind
   ! Archive basis kind for opmat objects, or a qualifier for name

   STR :: format
   ! Archive format (blank for binary)

   FILE * :: file
   ! Binary file part

   TEXTFILE* :: textfile
   ! Text file part

   end 


   type rys_type

   INT :: n
   ! No. of rys roots

   VEC* :: w
   ! The Rys weights

   VEC* :: r
   ! The Rys roots

   end


   type ivec__type

   IVEC* :: vec
   ! Encapsulated ivec type

   end


   type vec__type

   VEC* :: vec
   ! Encapsulated vec type

   end


   type mat__type

   MAT* :: mat
   ! Encapsulated mat type

   end


   type mat3__type

   MAT3* :: mat3
   ! Encapsulated mat3 type

   end


   type mat4__type

   MAT4* :: mat4
   ! Encapsulated mat4 type

   end


   type opvec_type

   INT :: n_bf
   ! No of spatial basis functions (i.e. AO's)

   VEC* :: restricted
   ! Restricted spinorbital representation

   VEC* :: alpha
   ! Alpha part of a DODS representation

   VEC* :: beta
   ! Beta  part of a DODS representation

   VEC* :: general
   ! General mixed alpha-beta matrix representation

   end


   type opmat_type

   INT :: n_bf
   ! No of real spatial basis functions (i.e. AO's)

   MAT* :: restricted
   ! Restricted spinorbital representation

   MAT* :: alpha
   ! Alpha part of a DODS representation

   MAT* :: beta
   ! Beta  part of a DODS representation

   MAT* :: general
   ! General mixed alpha-beta matrix representation

   CMAT* :: restricted_complex
   ! Complex restricted representation

   CMAT* :: alpha_complex
   ! Complex alpha part of a DODS representation

   CMAT* :: beta_complex
   ! Complex beta  part of a DODS representation

   CMAT* :: general_complex
   ! Complex general mixed alpha-beta matrix representation

   VEC* :: triangle
   ! Space saving for symmetric matrices: lower triangle only

   VEC* :: square
   ! Space saving for hermitian matrices: lower triangle is real part, upper is imaginary

   end

   type reflection_type

   INT :: h
   ! Miller h index for the reflection

   INT :: k
   ! Miller k index for the reflection

   INT :: l
   ! Miller l index for the reflection

   DBL :: F_exp
   ! Experimental structure factor

   DBL :: F_sigma
   ! Experimental error in the structure factor

   CDBL :: F_calc
   ! Calculated complex structure factor without including corrections

   DBL :: F_pred
   ! Calculated structure factor including scale and extinction corrections

   DBL :: I_exp
   ! Experimental intensity

   DBL :: I_sigma
   ! Experimental error in the intensity

   DBL :: I_pred
   ! Calculated intensity including scale and extinction corrections

   end

   type vecdiis_type

   INT :: keep
   ! No. of parameter vectors to keep for use in extrapolation

   INT :: start
   ! The iteration at which DIIS extrapolation should start

   INT :: n_vec
   ! The number of parameter vectors currently available for extrapolation

   INT :: new
   ! The integer identifier for the new (current) parameter vector

   DBL :: error_length
   ! The length of the DIIS error vector

   ARCHIVE :: archive
   ! Archive used to store the DIIS parameter and error vectors

   VEC* :: coeff
   ! The DIIS coefficients which combine/extrapolate the stored parameter vectors

   end


   type gaussian_type

   INT :: l
   ! l quantum number for the gaussian

   DBL :: ex
   ! Exponent for the gaussian

   VEC(3) :: pos
   ! Position of the gaussian
   end 


   type gaussian2_type

   INT :: l_a
   ! l quantum number for gaussian "a" of the gaussian pair

   INT :: l_b
   ! l quantum number for gaussian "b" of the gaussian pair

   DBL :: ex_a
   ! Exponent for gaussian "a" of the gaussian pair

   DBL :: ex_b
   ! Exponent for gaussian "b" of the gaussian pair

   VEC(3) :: pos_a
   ! Position for gaussian "a" of the gaussian pair

   VEC(3) :: pos_b
   ! Position for gaussian "b" of the gaussian pair
   end 


   type gaussian4_type

   INT :: l_a
   ! l quantum number for gaussian "a" of the gaussian quartet

   INT :: l_b
   ! l quantum number for gaussian "b" of the gaussian quartet

   INT :: l_c
   ! l quantum number for gaussian "c" of the gaussian quartet

   INT :: l_d
   ! l quantum number for gaussian "d" of the gaussian quartet

   DBL :: ex_a
   ! Exponent for gaussian "a" of the quartet

   DBL :: ex_b
   ! Exponent for gaussian "b" of the quartet

   DBL :: ex_c
   ! Exponent for gaussian "c" of the quartet

   DBL :: ex_d
   ! Exponent for gaussian "d" of the quartet

   VEC(3) :: pos_a
   ! Position for gaussian "a" of the quartet

   VEC(3) :: pos_b
   ! Position for gaussian "b" of the quartet

   VEC(3) :: pos_c
   ! Position for gaussian "c" of the quartet

   VEC(3) :: pos_d
   ! Position for gaussian "d" of the quartet

   end 


   type shell_type

   INT :: l
   ! l quantum number for the gaussian shell

   INT :: n_comp
   ! No. of components for the gaussian shell

   INT :: n_cc
   ! No. of contractions for the gaussian shell

   VEC* :: ex
   ! Exponent vector

   VEC* :: cc
   ! Contraction coefficient vector
   end 


   type shell1_type

   INT :: l
   ! l quantum number of the shell

   INT :: n_comp
   ! No. of components for the shell

   INT :: n_cc
   ! No. of contraction coefficients for the shell

   VEC(3) :: pos
   ! Position of the shell

   VEC* :: ex
   ! Exponent vector

   VEC* :: cc
   ! Contraction coefficient vector

   end 


   type shell2_type

   SHELL1 :: a
   ! Shell "a" of the pair        

   SHELL1 :: b
   ! Shell "b" of the pair

   end


   type shell4_type

   SHELL1 :: a
   ! Shell "a" of the quartet

   SHELL1 :: b
   ! Shell "b" of the quartet

   SHELL1 :: c
   ! Shell "c" of the quartet

   SHELL1 :: d
   ! Shell "d" of the quartet

   MAT, PTR :: norm_kappa_ab
   ! For the ERIs

   MAT3, PTR :: PA
   ! For the ERIs

   MAT3, PTR :: P
   ! For the ERIs

   end


   type shellpair_type

   SHELL1 :: a
   ! Shell "a" of the pair

   SHELL1 :: b
   ! Shell "b" of the pair

   INT :: n_gaussian_pairs
   ! The number of gaussian pair products in the shell pair

   INT :: l_max
   ! Maximum of the angular momenta on each shell

   INT :: l_min
   ! Minimum of the angular momenta on each shell

   INT :: l_sum
   ! Sum of the angular momenta on each shell

   VEC* :: exponent_sum
   ! The sum of all gaussian pair exponents as a flattened array
   ! with shell "a" exponents incrementing most rapidly

   VEC* :: exponent_inv
   ! The inverse of the sum of the gaussian pair exponents, as a 
   ! flattened array

   VEC* :: cc_prefactor
   ! The contraction coefficient product with an exponential part
   ! for each gaussian pair as a flattened array with shell "a" 
   ! gaussian components incrementing most rapidly. Useful for integral 
   ! evaluation.

   MAT* :: pair_center
   ! The center of each gaussian product pair, the second dimension being 
   ! the pair index where shell "a" components increment most rapidly

   MAT* :: center_diff
   ! The difference between the high momenta center and the center of the 
   ! gaussian product pair, the second dimension being the pair index
   ! where shell "a" gaussian components increments most rapidly

   end


   type shellquartet_type

   SHELLPAIR* :: ab
   ! Pair "ab" of the quartet

   SHELLPAIR* :: cd
   ! Pair "cd" of the quartet

   end


   type basis_type

   STR :: label
   ! Unique label for the basis set

   INT :: n_shell
   ! No. of shells in the basis, equal to size(shell)

   INT :: n_bf
   ! No. of basis functions for the shell

   INT :: n_prim
   ! No. of primitives for the shell

   SHELLVEC* :: shell
   ! The list of gaussian shells in the basis set

   end 


   type atom_type

   STR :: label
   ! The label for the atom (not necessarily unique)

   INT :: atomic_number
   ! The atomic number

   STR :: axis_system DEFAULT("cartesian")
   ! Specifies the coordinate axis system

   VEC(3) :: pos
   ! Atom position

   MAT(3,3) :: thermal_tensor DEFAULT(ZERO)
   ! The thermal tensor for the atom

   STR :: thermal_axis_system DEFAULT("cartesian")
   ! Specifies the thermal tensor coordinate system

   BASIS* :: basis
   ! The basis for the atom

   OPMAT* :: natural_orbitals
   ! The natural orbitals for the atom

   OPVEC* :: occupation
   ! The occupation numbers for the atom

   DBL :: energy
   ! The energy of the isolated atom

   end 

   type plotgrid_type

   STR :: kind
   ! The type of plot calculation wanted

   INT :: orbital
   ! The orbital to plot (if any)

   DBL :: maximum_cell_distance
   ! The maximum cell distance for a crystal-section plot

   INT :: n_x
   ! The number of points on the x-axis

   INT :: n_y
   ! The number of points on the y-axis

   INT :: n_z
   ! The number of points on the z-axis

   INT :: n_pt
   ! The total no. of points in the plot

   INT :: centre_atom
   ! Use this atom as the centre of the plot

   INT :: x_atom_1, x_atom_2
   ! These atoms define the x-axis of the plot

   INT :: y_atom_1, y_atom_2
   ! These atoms define the y-axis of the plot (made orthogonal to the x-axis)

   DBL :: del
   ! The distance between axis points in the plot

   VEC(3) :: centre
   ! Centre of the plot

   VEC(3) :: origin
   ! Bottom left point of the plot

   VEC(3) :: x_axis
   ! x-axis of the plot

   VEC(3) :: y_axis
   ! y-axis of the plot

   VEC(3) :: z_axis
   ! z-axis of the plot

   VEC(3) :: width
   ! Thw widths (in AU) of each axis of the plot

   VEC(3) :: offset
   ! The centre of the plot is offset by this amount

   BIN :: calc_x_width
   ! True if the x_width, i.e. width(1), is to be calculated from the size of
   ! the inputted x_axis vector

   BIN :: calc_y_width
   ! True if the y_width, i.e. width(2), is to be calculated from the size of
   ! the inputted x_axis vector
 
   BIN :: z_axis_defined
   ! Flag set true if the user has defined the z_axis in the input
 
   end 


   type dftgrid_type

   STR :: spherical_grid_kind
   ! Identifier for the kind of spherical grid

   STR :: radial_grid_kind
   ! Type of radial grid

   INT :: spherical_grid_order
   ! Order of the spherical grid

   INT :: radial_grid_order
   ! Order of the radial grid

   INT :: n_spherical_pts
   ! No of spherical grid points

   INT :: n_radial_pts
   ! No of radial grid points

   INT :: n_atom_pts
   ! No of atom grid points

   DBL :: becke_m_partition_power
   ! Used in smoothing the partition boundary

   DBL :: gauss_chebyshev_alpha
   ! Gauss-Chebychev radial grid parameters

   DBL :: gauss_chebyshev_m 
   ! ?

   DBL :: euler_maclaurin_alpha
   ! Euler-Maclaurin radial grid parameters

   DBL :: euler_maclaurin_m 
   !

   ARCHIVE :: archive
   ! Archive to store the generated grids

   end


   type irrep_type

   CHR(4) :: label
   ! Irrep label

   INT :: dimension
   ! Irrep dimension

   VEC* :: character
   ! Characters for the irrep

   MAT3* :: mat
   ! Representation matrices for the irrep

   end


   type pointgroup_type

   CHR(4) :: symbol
   ! symmetry symbol

   CHR(4) :: ID_symbol
   ! group id symbol

   INT :: ID_number
   ! group id number

   INT :: axis_order
   ! principal axis order

   INT :: order
   ! order of the group

   INT :: n_irrep
   ! no of irreducible representations

   INT :: n_gen
   ! No. of generators

   BIN :: has_complex_irreps
   ! true if the group has complex irreps

   IMAT* :: table
   ! group multiplication table

   MAT3* :: mat
   ! 3x3 representation matrices

   MAT3* :: ptr
   ! 3x3 representation matrices for p functions, same as mat

   MAT3* :: dtr
   ! 6x6 representation matrices for d functions

   MAT3* :: ftr
   ! 10x10 representation matrices for f functions

   IVEC* :: inverse
   ! Indices of inverse group elements

   IRREPVEC* :: irrep
   ! List of irrrducible representations

   end


   type spacegroup_type

   STR :: IT_symbol
   ! International Table (Hermann-Maguin) symmetry symbol

   INT :: IT_group_number
   ! International tables group number

   STR :: Hall_symbol
   ! Hall notation symbol

   CHR :: lattice_symbol
   ! Lattice symmetry symbol

   STR :: lattice_type
   ! Lattice type

   BIN :: centrosymmetric
   ! True if center of symmetry present

   INT :: order(3)
   ! Order of each crystal axis

   INT :: setting_index(3)
   ! Indicates axes of rotation corresponding to x, y, or z...

   BIN :: has_bar(3)
   ! True if bar for this axis

   BIN :: has_subscript(3)
   ! True if subscript present for this axis

   CHR :: setting_symbol(3)
   ! Superscript rotation axis symbols axis

   CHR :: subscript(3,3)
   ! Subscript translations symbols for each axis

   INT :: lattice_symbol_index
   ! Lattice symbol index number

   INT :: nL
   ! No. of translational lattice generators

   INT :: nR
   ! No. of rotation generators

   INT :: nG
   ! No. of generators

   INT :: n_seitz
   ! No. of Seitz matrices

   MAT3* :: seitz
   ! Seitz matrices (the transpose, as defined in Hall's paper)

   INT :: n_unique
   ! No. of equivalent positions unrelated by traslation or inversion

   IVEC* :: unique_symop
   ! Index of unique symops not related by translation or inversion

   IVEC* :: map_to_unique
   ! Maps symop to a unique symop. Negative indicates inversion

   end


   type crystal_type

   STR :: kind
   ! Kind of diffraction experiment used.

   SPACEGROUP :: spacegroup
   ! The crystal spacegroup

   VEC(3) :: unit_cell_angle
   ! cell angles  (in radians)

   VEC(3) :: unit_cell_length
   ! cell lengths (in bohr)

   DBL :: unit_cell_volume
   ! cell volumes (bohr^3)

   MAT(3,3) :: direct_cell_matrix
   ! direct cell matrix (bohr)

   MAT(3,3) :: direct_U_cell_matrix
   ! Converts thermal tensors from crystal to cartesian systems.

   MAT(3,3) :: inverse_cell_matrix
   ! inverse direct cell matrix (bohr^{-1})

   MAT(3,3) :: reciprocal_cell_matrix
   ! reciprocal cell matrix (bohr^{-1}).

   MAT(3,3) :: reciprocal_U_cell_matrix
   ! Converts thermal tensors from cartesian to crystal systems.

   INT :: n_fragment_atoms
   ! No of atoms in the inputted cell fragment

   MAT* :: fragment_geometry
   ! The geometry for molecular cell fragment under consideration

   INT :: n_unit_cell_atoms
   ! Total no. of unit cell atoms

   MAT* :: unit_cell_geometry
   ! The full unit cell geometry

   INT :: n_unique_unit_cell_atoms
   ! No of unique unit cell atoms

   IVEC* :: unique_atom
   ! Contains the actual unique (asymmetric) unit cell atoms.

   IVEC* :: unique_atom_for
   ! If "a" is the index of an atom position in fragment_geometry,
   ! fragment_geometry(:,a), then unique_atom_for(a) is the index of the unique
   ! (asymmetric) unit cell atom which generates that position.

   IVEC* :: unique_atom_symop_for
   ! If "a" is the index of an atom position in fragment_geometry,
   ! fragment_geometry(:,a), then unique_atom_symop_for(a) is the index of the
   ! symmetry operation which maps unique_atom_for(a) onto that position.

   IVEC* :: fragment_atom_for
   ! If "u" is the index of an atom position in unit_cell_geometry,
   ! unit_cell_geometry(:,u), then fragment_atom_for(a) is the index of the
   ! fragment_atom which generates that position.

   INT :: n_reduced_symops
   ! No. of symops needed to make the unit_cell_geometry from fragment_geometry

   IVEC* :: reduced_symop
   ! Indices of the reduced symops in the spacegroup seitz list

   INT :: n_inverted_symops
   ! Number of symmetry operations related by inversion

   IVEC* :: inverted_symop
   ! Indices of the unique symops related by inversion

   IVEC* :: translated_symop
   ! Indices of the unique symops related by translation

   INT :: n_unique_symops
   ! Number of unique symmetry operations not related by inversion or
   ! translation.
   ! This is used to save work in structure factor calculations.

   IVEC* :: unique_symop
   ! Indices of the unique symops not related by inversion or translation

   VEC* :: repetition_factor
   ! The partition factors for cell_geometry

   DBL :: Z
   ! The crystallographic Z factor for the molecular cell fragment in the
   ! unitcell

   REFLECTIONVEC* :: reflections
   ! The structure factor information

   DBL :: scale_factor
   ! Scale factor to apply to the predicted structure factors

   DBL :: exp_scale_factor
   ! Fixed scale factor to apply to the experimental structure factors

   BIN :: optimise_scale
   ! True if an overall scaler factor is to be optimised, for use in calculating
   ! F_pred

   BIN :: synthesize_sigma_I
   ! True if artificial sigma(I) errors are to be gereated from poisson
   ! statistics and used in calculating agreement statistics

   BIN :: optimise_extinction
   ! True if extinction is to be optimised.

   BIN :: correct_dispersion
   ! True if dispersion is to be corrected

   DBL :: extinction_factor
   ! Secondary extinction factor

   DBL :: wavelength
   ! Experiment wavelength

   STR :: thermal_smearing_model
   ! Thermal smearing model for ft integrals

   STR :: partition_model
   ! Model for partitioning fragments of the molecule

   INT :: n_param
   ! No of fitting parameters used

   end

   type scfdata_type

   STR :: kind
   ! The kind of SCF calculation to perform

   STR :: initial_density
   ! The kind of density matrix to start the SCF calc

   STR :: initial_mos
   ! The kind of initial MO's to start the SCF calc

   DBL :: nuclear_energy
   ! Nuclear repulsion energy for the associated molecule

   DBL :: kinetic_energy
   ! The kinetic energy for the associated molecule

   DBL :: energy
   ! The SCF energy for the associated molecule

   DBL :: old_energy
   ! The SCF energy from the previous SCF cycle

   DBL :: difference
   ! The change in the SCF energy between cycles

   DBL :: convergence
   ! A number which measures the convergnece of the SCF

   DBL :: diis_convergence
   ! A limit below which the DIIS is deemed converged

   INT :: iteration
   ! The interation count for the SCF procedure

   INT :: lambda_iteration
   ! Lambda iteration count for the x-ray SCF procedure

   INT :: min_iterations
   ! The minimum number of SCF iterations to perform

   INT :: max_iterations
   ! The maximum number of SCF iterations to perform

   DBL :: lambda
   ! The initial lambda value to use in an x-ray SCF procedure

   DBL :: lambda_max
   ! The maximum lambda value to use in an x-ray SCF procedure

   DBL :: lambda_step
   ! The value to step the lambda value between lambda cycles in an x-ray SCF
   ! calc.

   DBL :: fit_value
   ! The value of E + lambda * chi2 in an x-ray SCF calc.

   DBL :: old_fit_value
   ! The value of E + lambda * chi2 of the previous iteration in an x-ray SCF
   ! calc.

   DBL :: F_chi2
   ! Chi^2 agreement statistic for an x-ray SCF calc

   DBL :: F_gof
   ! Goodness-of-fit agreement statistic for x-ray SCF calc

   DBL :: F_r_factor
   ! R-factor agreement statistic for x-ray SCF calc

   DBL :: F_weighted_r_factor
   ! The weighted r-factor agreement statistic

   BIN :: test  
   ! Test flag. Set True if some test procedure is to be executed

   BIN :: direct
   ! True if using direct SCF

   BIN :: using_diis
   ! True if using DIIS

   BIN :: using_damping
   ! True if using damping

   BIN :: using_level_shift
   ! True if using level shifting

   BIN :: using_camp_king
   ! True if using Camp-King converger

   VECDIIS :: diis
   ! For (fock matrix) diis extrapolation

   DBL :: diis_error
   ! The DIIS error

   DBL :: old_diis_error
   ! The DIIS error of the previous iteration

   INT :: damp_finish
   ! Iteration when density matrix damping is turned off

   DBL :: damp_factor
   ! The damping factor to use

   INT :: level_shift_finish
   ! Iteration when level shifting is turned off

   DBL :: level_shift
   ! Value to level shift the virtual orbitals

   BIN :: output
   ! True if output is wanted

   BIN :: nddo
   ! Neglect of diatomic differential overlap

   BIN :: nudo
   ! Neglect of unconnected differential overlap

   BIN :: using_bl_term
   ! Switch on/off the B.L term (complex SCF reqd.)

   BIN :: using_bs_term
   ! Switch on/off the B.S term

   BIN :: using_bs_t_term
   ! Switch on/off the (B.S) T_e term

   BIN :: using_aa_term
   ! Switch on/off the A.A diamagnetic term 

   BIN :: using_1e_sl_term
   ! Switch on/off the 1 electron S.L term 

   BIN :: using_1e_srxa_term
   ! Switch on/off the 1 electron diamagnetic term 

   BIN :: using_1e_zora_term
   ! Switch on/off the 1 electron ZORA terms

   DBL :: sl_1e_factor
   ! Factor to apply to the 1-electron S.L terms

   BIN :: using_2e_sl_term
   ! Switch on/off the 2 electron S.L terms

   DBL :: sl_2e_factor
   ! Factor to apply to the 2-electron S.L terms

   DBL :: eri_limit
   ! Cutoff for the two electron integrals

   BIN :: using_variable_cutoff
   ! Using a sliding ERI cutoff for the two electron integrals

   VEC(3) :: quantization_axis DEFAULT(ZERO)
   ! Quantization axis for GCHF, if using initial MO's as a guess

   end


   type time_type

  IVEC(5) :: started
   ! Contains real start time, in Julian day,h,m,s,ms

  IVEC(5) :: stopped
   ! Contains real stop time, in Julian day,h,m,s,ms

  DBL :: start_cpu
   ! Contains CPU start time, in seconds

  DBL :: stop_cpu
   ! Contains CPU stop  time, in seconds

   end


   type mol_type

   STR :: name
   ! Name of molecule

   INT :: charge
   ! Electric charge of the molecule

   INT :: mult
   ! Spin multiplicity of the molecule

   VEC(3) :: E_field
   ! Applied electric field in atomic units

   VEC(3) :: B_field
   ! Applied magnetic field in atomic units

   VEC(3) :: gauge_origin
   ! Global gauge origin for magnetic field

   ATOMVEC* :: atom
   ! List of atoms in molecule

   BASISVEC* :: basis
   ! List of basis sets used

   PLOTGRID* :: grid
   ! Rectangular grid data, for plots

   DFTGRID* :: dftgrid
   ! DFT integration grid data

   CRYSTAL* :: crystal
   ! Crystal data for the enclosing crystal

   POINTGROUP* :: pointgroup
   ! Pointgroup symmetry of the molecule

   INT :: n_e
   ! No of electrons

   INT :: n_a
   ! No of alpha electrons

   INT :: n_b
   ! No of beta electrons

   INT :: n_atom
   ! No of atoms

   INT :: n_atom_kind
   ! No of atoms of a different kind

   INT :: n_basis
   ! No of basis sets

   INT :: n_shell
   ! Total number of shells in the molecular basis set

   INT :: n_shell_pairs
   ! Total number of shell pairs in the molecular basis set

   INT :: n_bf
   ! Total number of basis functions in the molecular basis set

   INT :: n_prim
   ! Total number of primitives in the molecular basis set

   IVEC* :: atom_for_shell
   ! Atom index for molecular shell index array

   IVEC* :: atom_shell_for_shell
   ! Atom shell index for molecular shell index array

   IVEC* :: first_shell_for_atom
   ! First molecule shell index for an atom

   IVEC* :: first_basis_fn_for_shell
   ! First basis function for a given shell

   IVEC* :: last_basis_fn_for_shell
   ! Last basis function for a given shell

   IVEC* :: atom_kind
   ! The unique kind of each atom in .atom

   IVEC* :: unique_atom
   ! List of the unique atoms (of different kind)

   IVEC* :: first_basis_fn_for_atom
   ! For the atom basis function limits

   IVEC* :: last_basis_fn_for_atom
   ! For the atom basis function limits

   SCFDATA* :: scfdata
   ! SCF data object

   OPVEC* :: orbital_energies
   ! The orbital energies

   OPMAT* :: molecular_orbitals
   ! The (real) molecular orbitals

   OPMAT* :: density_matrix
   ! The real density matrix

   OPMAT* :: natural_orbitals
   ! The natural orbitals

   OPVEC* :: occupation
   ! The associated occupation numbers

   OPMAT* :: fock_matrix
   ! The real fock matrix

   IVECVEC* :: atom_group
   ! A list of atom group indices, for group property decomposition

   MAT4VEC* :: ab_ab_ERI
   ! The two electron integrals of the form ab|ab

   BIN :: optimise_thermals
   ! Whether to optimise the thermal parameters

   end 

end
