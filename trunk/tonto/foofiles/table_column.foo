!---------------------------------------------------------------------
!
! TABLE_COLUMN:
!
! For setting up table columns ready to print
!
! Copyright (C) Dylan Jayatilaka, June 2011
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: table_column.foo $
!
!---------------------------------------------------------------------

module TABLE_COLUMN

   implicit none

contains

!  ***************
!  Create routines
!  ***************

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts
      nullify(.b_value)
      nullify(.i_value)
      nullify(.r_value)
      nullify(.s_value)
      nullify(.iv_value)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts
     .nullify_ptr_part
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(column) ::: leaky
   ! Set self to be "group".
      column :: TABLE_COLUMN, IN
      self = column
   end

   set_defaults
   ! Set up defaults
      .heading        = " "
      .subheading     = " "
      .sb3heading     = " "
      .width          = TABLE_COLUMN_WIDTH
      .width_set      = FALSE
      .item_width     = TABLE_COLUMN_WIDTH
      .item_width_set = FALSE
      .real_precision = TABLE_COLUMN_REAL_PRECISION
      .spacing        = TABLE_COLUMN_SPACING
      .item_spacing   = TABLE_COLUMN_SPACING
      .spacer         = TABLE_COLUMN_SPACER 
      .center         = TABLE_COLUMN_CENTER
      .left_justify   = TABLE_COLUMN_LEFT_JUSTIFY
   end

   clear_column
   ! Remove the column data
      .nullify_ptr_part
   end

!  ************
!  Set routines
!  ************

   set_heading(val)
   ! Set the heading
      val :: STR
      .heading = val
      .set_width_from(.heading)
   end

   set_subheading(val)
   ! Set the subheading
      val :: STR
      .subheading = val
      .set_width_from(.subheading)
   end

   set_subhead(val)
   ! Set the subheading
      val :: STR
      .set_subheading(val)
   end

   set_sb3head(val)
   ! Set the sub3 heading
      val :: STR
      .sb3heading = val
      .set_width_from(.sb3heading)
   end

   set_real_precision(val)
   ! Set the real precision
      val :: INT
   ENSURE(val>0,"real_precision must be positive")
   ENSURE(val<.width,"real_precision must be less than column width")
      .real_precision = val
   end

   set_spacing(val)
   ! Set the free space within each column width
      val :: INT

   ENSURE(val>=0,"spacing must be non-negative")
   DIE_IF(.width_set,"set spacing before width or heading")

      .spacing = val

   end

   set_item_spacing(val)
   ! Set the free space between items in a list-item column
      val :: INT

   ENSURE(val>=0,"spacing must be non-negative")
   DIE_IF(.width_set,"set spacing before width or heading")

      .item_spacing = val

   end

   set_spacer(val)
   ! Set the space character between each column
      val :: STR
      .spacer = val
   end

   set_center(val)
   ! Set whether to center a STR column
      val :: BIN
      .center = val
   end

   set_left_justify(val)
   ! Set whether to left-justify a column
      val :: BIN
      .left_justify = val
   end

   set_left(val)
   ! Set whether to left-justify a column
      val :: BIN
      .left_justify = val
   end

   set_width(val)
   ! Set the column width to be the maximum of what it was and "val"
   ! If headings are set, take into account those widths too.
      val :: INT

      if (.width_set) then; .width = max(.width,val)
      else;                 .width = val
      end

      .width_set = TRUE

   end

   set_item_width(val)
   ! Set the list item width
      val :: INT

      if (.item_width_set) then; .item_width = max(.item_width,val)
      else;                      .item_width = val
      end

      .item_width_set = TRUE

   end

! *************************************
! Set column width from width of values
! *************************************

! Non-real intrinsics

   set_width_from(v) ::: template
   ! Set width from the width of value(s) "v"
      v :: TYPE
      .set_width(v.str_length(.spacing))
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>BIN)
   ! Set width from the width of value(s) "v"
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>INT)
   ! Set width from the width of value(s) "v"
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>STR)
   ! Set width from the width of value(s) "v"
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{BIN})
   ! Set width from the width of value(s) "v"
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{INT})
   ! Set width from the width of value(s) "v"
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{STR})
   ! Set width from the width of value(s) "v"
   end

! Reals ...

   set_width_from(v) ::: template
   ! Set width from the int part of the REAL value(s) "v".
      v :: TYPE
      .set_width(v.str_length_with_precision(.real_precision,.spacing))
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>REAL)
   ! Set width from the int part of the REAL value(s) "v".
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{REAL})
   ! Set width from the int part of the REAL value(s) "v".
   end

   set_width_from(v) ::: get_from(TABLE_COLUMN, TYPE=>MAT{REAL})
   ! Set width from the int part of the REAL value(s) "v".
   end

! List of lists

   set_width_from(v)
   ! Set width from the width of value(s) "v"
      v :: VEC{VEC_{INT}}
      .set_width(v.list_str_length(.item_spacing)+.spacing)
      .set_item_width(v.item_str_length(.item_spacing))
   end

! *****************
! Set column values
! *****************

   set_values(v) ::: template
   ! Set the column values "v"
      v :: TYPE, target

   DIE_IF(.values_set,"column has already been set!")

      .VALUE => v
      .set_width_from(v)

   end

   set_values(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{BIN}, VALUE=>b_value)
   ! Set the column values "v"
   end

   set_values(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{INT}, VALUE=>i_value)
   ! Set the column values "v"
   end

   set_values(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{VEC_{INT}}, VALUE=>iv_value)
   ! Set the column values "v"
   end

   set_values(v)
   ! Set the column values "v"
      v :: VEC{STR}(len=STR_SIZE,:), target

   DIE_IF(.values_set,"column has already been set!")

      .s_value => v
      .set_width_from(v)

   end

   set_values(v) ::: get_from(TABLE_COLUMN, TYPE=>VEC{REAL}, VALUE=>r_value)
   ! Set the column values "v"
   end

!   set_values(v,dp) ! TYPE=>r_value
!   ! Set the REAL column values "v"
!      v :: VEC{REAL}, target
!      dp :: INT, optional
!
!   DIE_IF(.values_set,"column has already been set!")
!
!      .r_value => v
!      if (present(dp)) .set_real_precision(dp)
!      .set_width_from(v)
!
!   end

!  ****************
!  Inquiry routines
!  ****************

   values_set result (res) ::: pure
   ! Return true if any column has been set
      self :: IN
      res :: BIN
      res = .b_value.created &
         OR .i_value.created &
         OR .r_value.created &
         OR .s_value.created &
         OR .iv_value.created
   end

   n_rows result (res) ::: pure
   ! Returns the number of rowa
      self :: IN
      res :: INT

   ENSURE(.values_set,"column not set")

      if      (.b_value.created)  then; res = .b_value.dim
      else if (.i_value.created)  then; res = .i_value.dim
      else if (.r_value.created)  then; res = .r_value.dim
      else if (.s_value.created)  then; res = .s_value.dim
      else if (.iv_value.created) then; res = .iv_value.dim
      end

   end

!  ************
!  Put routines
!  ************

   put_heading
   ! Put the column heading out
      if (.spacer/=" ") stdout.put(trim(.spacer))
      stdout.put(.heading,center=.center,left=.left_justify,width=.width)
   end

   put_subheading
   ! Put the column subheading out
      if (.spacer/=" ") stdout.put(trim(.spacer))
      stdout.put(.subheading,center=.center,left=.left_justify,width=.width)
   end

   put_sb3heading
   ! Put the column subheading out
      if (.spacer/=" ") stdout.put(trim(.spacer))
      stdout.put(.sb3heading,center=.center,left=.left_justify,width=.width)
   end

   put_value(i)
   ! Put out the value "i"
      i :: INT

   ENSURE(.values_set,"column not set")

      w,p :: INT
      l,c :: BIN
      j :: INT

      ! Widths & centering
      w = .width
      p = .real_precision
      l = .left_justify
      c = .center

      ! Put the space
      if (.spacer/=" ") stdout.put(trim(.spacer))

      ! Write out the item
      if (.b_value.created) then

         stdout.put(.b_value(i),left=l,center=c,width=w)

      else if (.i_value.created) then

         stdout.put(.i_value(i),left=l,center=c,width=w)

      else if (.r_value.created) then

         stdout.put(.r_value(i),left=l,center=c,width=w,precision=p)

      else if (.s_value.created) then

         stdout.put(.s_value(i),left=l,center=c,width=w)

      else if (.iv_value.created) then

         stdout.put(" ",width=.spacing)
         do j = 1,.iv_value(i).element.dim
         stdout.put(.iv_value(i)[j],left=l,center=c,width=.item_width)
         end

      end

   end

end
