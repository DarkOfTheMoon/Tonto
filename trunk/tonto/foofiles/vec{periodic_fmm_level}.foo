!
! Copyright (C) Daniel Grimwood, 2003
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!*******************************************************************************

module VEC{PERIODIC_FMM_LEVEL}

  implicit none

contains

!*******************************************************************************
! Memory allocation
!*******************************************************************************

   create(lb,ub,mol) ::: leaky
   ! Create the vector with lower bound "lb", upper bound "ub"
      self :: PTR
      lb,ub :: INT, IN
      mol :: MOLECULE, IN, optional
      nullify(self)
      allocate(self(lb:ub))
      ADD_MEMORY((ub-lb+1)*ELEMENT_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults(mol)
   end

   destroy ::: get_from(VEC{OBJECT}), leaky
   ! Destroy space for object
   end

   nullify_ptr_part ::: get_from(VEC{OBJECT})
   ! Nullify the pointer parts of self
   end

   destroy_ptr_part ::: get_from(VEC{OBJECT})
   ! Destroy the pointer parts of self
   end

   set_defaults(mol)
   ! Set default values.
      mol :: MOLECULE, IN, optional
   ENSURE(.dim>1,"must have at least two levels")
      i :: INT
      do i = 1,.dim
         self(i).set_defaults(mol)
      end
   end

!*******************************************************************************
! Misc
!*******************************************************************************

   set_first_level(n_div)
   ! Set the variables that go into the first level.
     n_div :: INT, IN
     self(1).set_number_of_divisions(n_div)
   end
 
   set_l_max
   ! Set l_max and other basic information for all levels. This assumes that the
   ! first level is zero and that level zero is properly initialised.
      self :: PTR
   ENSURE(.created,"no fmm levels")
   ENSURE(lbound(self,1)==0,"must have level zero as lower bound")
   ENSURE(ubound(self,1)>=1,"must have at least two levels")
      i :: INT
      do i = 1,ubound(self,1)
         self(i).set_level(self(i-1))
      end
   end

   make_positions_and_charges(charges,positions)
   ! Make a list of point charges that accurately represents the total charge of
   ! the initial level (i.e. unit cell) from a given set of fragment "charges"
   ! and fragment "positions".  Includes contributions from electrons and nuclei.
   ! NOTE: this sets level 0 and level 1 ONLY.
      self :: PTR
      charges :: VEC{REAL}
      positions :: MAT{REAL}
   ENSURE(.created,"no fmm levels")
   ENSURE(lbound(self,1)==0,"must have level zero as lower bound")
   ENSURE(ubound(self,1)>1,"must have at least two levels")
      self(0).make_positions_and_charges(charges,positions)
      ! Copy to level 1 and level 2
      self(1).charges   => self(0).charges
      self(1).positions => self(0).positions
      self(2).charges   => self(0).charges ! needed to generate multipoles
      self(2).positions => self(0).positions
   end

   make_initial_subbox_multipoles(l_max) ::: leaky
   ! Assign the initial subbox multipoles up to order "l_max" from a given set
   ! of ".charges" and ".positions". NOTE: this should be applied to level two
   ! in the first instance (level 1 is the buffer zone).
      self :: PTR
      l_max :: INT
   ENSURE(.created,"no fmm levels")
   ENSURE(lbound(self,1)==0,"must have level zero as lower bound")
   ENSURE(ubound(self,1)>=1,"must have at least two levels")
      self(2).make_initial_subbox_multipoles(l_max)
   end
 
   make_all_subbox_multipoles
   ! Make the multipole expansion for each level. This assumed the multipoles at
   ! level 2 are created.
      self :: PTR
   ENSURE(.created,"no fmm levels")
   ENSURE(lbound(self,1)==0,"must have level zero as lower bound")
   ENSURE(ubound(self,1)>=1,"must have at least two levels")
   ENSURE(self(2).subbox_multipoles.created,"no starting multipoles at level 2")
   ENSURE(self(2).subbox_multipoles(1,1,1).element.created,"no starting multipoles at level 2")
      i :: INT
      do i = 3,ubound(self,1)
         self(i).make_subbox_multipoles(self(i-1))
      end
   end
 
   make_potential(values,points,adjust_surface_dipoles) 
   ! Make the the "values" of the potential at "points" in the unit cell, coming
   ! from the set of subbox multipoles at this level. If present TRUE,
   ! "adjust_surface_dipoles" causes most of the dipoles on the surface of this
   ! level to be reversed, to simulate the neutralisation of the surface charge,
   ! in order to get a potential close to the Ewald potential.
      self :: PTR
      values :: VEC{REAL}
      points :: MAT{REAL}
      adjust_surface_dipoles :: BIN, optional
   ENSURE(.created,"no fmm levels")
   ENSURE(lbound(self,1)==0,"must have level zero as lower bound")
   ENSURE(ubound(self,1)>=1,"must have at least two levels")
      i :: INT
      values = ZERO
    ! do i = 0,ubound(self,1)
         stdout.set_real_style("e")
      do i = 0,2
         self(i).add_potential_to(values,points)
         stdout.text("potential so far:")
         stdout.show("level =",i)
         stdout.put(values,"column")
      end
   end
 
   set_all_levels
   ! Make the information for each level.
      self :: PTR
   ENSURE(lbound(self,1)==0,"must have level zero as lower bound")
   ENSURE(ubound(self,1)>=1,"must have at least two levels")
   ENSURE(self(0).level_number>=0, "starting level must not be negative")
     i :: INT
     do i = 1,ubound(self,1)
        self(i).set_level(self(i-1))
     end
   end
 
   check_levels_match
   ! Check whether the levels are all related.
     ENSURE(.dim>1,"must have at least two levels")
     i :: INT
     div_match,centre_match :: BIN
     div_match = TRUE
     centre_match = TRUE
     do i = 1,.dim
       if (any(self(1).divisions/=self(i).divisions)) div_match = FALSE
       if (NOT self(1).box_centre.same_as(self(i).box_centre)) centre_match = FALSE
       if (NOT div_match OR NOT centre_match) exit
     end
     ENSURE(div_match,"number of divisions not consistent")
     ENSURE(centre_match,"box centres not consistent")
   end

   put
   ! Output the list information
      self :: PTR
      i :: INT
      do i = lbound(self,1),ubound(self,1)
         self(i).put
      end
   end

end
