!
! Copyright (C) Daniel Grimwood, 2003
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!*******************************************************************************

module VEC{PERIODIC_FMM_LEVEL}

  implicit none

contains

!*******************************************************************************
! Memory allocation
!*******************************************************************************

   create(lb,ub,mol) ::: leaky
   ! Create the vector with lower bound "lb", upper bound "ub"
      self :: PTR
      lb,ub :: INT, IN
      mol :: MOLECULE, IN, optional
      nullify(self)
      allocate(self(lb:ub))
      ADD_MEMORY((ub-lb+1)*ELEMENT_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults(mol)
   end

   destroy ::: get_from(VEC{OBJECT}), leaky
   ! Destroy space for object
   end

   nullify_ptr_part ::: get_from(VEC{OBJECT})
   ! Nullify the pointer parts of self
   end

   destroy_ptr_part ::: get_from(VEC{OBJECT})
   ! Destroy the pointer parts of self
   end

   set_defaults(mol)
   ! Set default values.
      mol :: MOLECULE, IN, optional
   ENSURE(.dim>1,"must have at least two levels")
      i :: INT
      do i = 1,.dim
         self(i).set_defaults(mol)
      end
   end

!*******************************************************************************
! Misc
!*******************************************************************************

   set_first_level(n_div)
   ! Set the variables that go into the first level.
     n_div :: INT, IN
     self(1).set_number_of_divisions(n_div)
   end
 
   set_all_levels
   ! Make the information for each level.
      self :: PTR
   ENSURE(lbound(self,1)==0,"must have level zero as lower bound")
   ENSURE(ubound(self,1)>=1,"must have at least two levels")
   ENSURE(self(0).level_number>=0, "starting level must not be negative")
     i :: INT
     do i = 1,ubound(self,1)
        self(i).set_level(self(i-1))
     end
   end
 
   make_all_subbox_multipoles
   ! Make the multipole expansion for each level.
      self :: PTR
   ENSURE(lbound(self,1)==0,"must have level zero as lower bound")
   ENSURE(ubound(self,1)>=1,"must have at least two levels")
   ENSURE(self(0).level_number>=0, "starting level must not be negative")
     i :: INT
     do i = 1,ubound(self,1)
        self(i).make_subbox_multipoles(self(i-1))
        self(i).put
     end
   end
 
   check_levels_match
   ! Check whether the levels are all related.
     ENSURE(.dim>1,"must have at least two levels")
     i :: INT
     div_match,centre_match :: BIN
     div_match = TRUE
     centre_match = TRUE
     do i = 1,.dim
       if (any(self(1).divisions/=self(i).divisions)) div_match = FALSE
       if (NOT self(1).box_centre.same_as(self(i).box_centre)) centre_match = FALSE
       if (NOT div_match OR NOT centre_match) exit
     end
     ENSURE(div_match,"number of divisions not consistent")
     ENSURE(centre_match,"box centres not consistent")
   end

   put
   ! Output the list information
      self :: PTR
      i :: INT
      do i = lbound(self,1),ubound(self,1)
         self(i).put
      end
   end

end
