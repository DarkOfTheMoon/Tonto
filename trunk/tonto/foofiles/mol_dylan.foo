!-------------------------------------------------------------------------------
!
! MOL_dylan: dylan's test routines
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_DYLAN

   use TYPES
   use SYSTEM
   use TIME
   use STR
   use INT
   use DBL

   use STRVEC
   use BINVEC
   use IVEC
   use IVECVEC
   use IMAT
   use IMAT3
   use IMAT4
   use VEC
   use VECVEC
   use MAT
   use MAT3
   use MAT4
   use MAT5
   use MATVEC
   use MAT3VEC

   use CVEC
   use CMAT
   use CMAT3
   use CMAT4
   use CMAT5
   use OPVEC
   use OPMAT

   use UNITNUMBER
   use TEXTFILE
   use ARCHIVE

   use VECDIIS

   use RYS
   use GAUSSIAN
   use GAUSSIAN2
   use GAUSSIAN4
   use SHELL
   use SHELL1
   use SHELL2
   use SHELL4
   use SHELLVEC

   use BASISVEC

   use ATOM
   use ATOMVEC

   use IRREP
   use IRREPVEC
   use SPACEGROUP

   use CRYSTAL

   use PLOTGRID
   use DFTGRID

   use SCFDATA
   use MOL

   implicit none

#  include "macros"
#  include "mol_dylan.int"

contains

  make_pcc_b_field
     INT :: n_pt,i,j,n, k
     DBL :: aa,bb,cc
     MAT, PTR :: pt
     CMAT3, PTR :: dma
     DBL :: re,im
     n_pt = 59*75
   ! n_pt = 25
     pt.create(n_pt,3)
     aa=7.4/sqrt(2.0)
   ! aa=0.4/sqrt(2.0)
     bb=0.2/sqrt(2.0)
     n = 0
     do i=1,75
        cc=5.4
   !    cc=0.6
        do j=1,59
           n = n+1
           cc = cc - 0.2
           pt(n,1)= aa
           pt(n,2)=-aa
           pt(n,3)= cc
        end
        aa = aa-bb
     end
     dma.create(160,160,4)
     open(unit=99,file='opdens.c',form='formatted',status='old')
     do i=1,160
     do j=1,160
        do k=1,4
           read(99,*) re,im
           dma(i,j,k) = cmplx(re,im)
        enddo
     enddo
     enddo
     close(99)
     .density_matrix.destroy("general_complex")
     .density_matrix.create(160,"general_complex")
     .density_matrix.general_complex.alpha_alpha_set_to(dma(:,:,1))
     .density_matrix.general_complex.alpha_beta_set_to(dma(:,:,2))
     .density_matrix.general_complex.beta_alpha_set_to(dma(:,:,3))
     .density_matrix.general_complex.beta_beta_set_to(dma(:,:,4))
     dma.destroy
     .make_b_field_grid(pt)
     pt.destroy
  end                                                                               

   make_b_field_grid(pt)
   ! Make the total b_field "b" on ".grid"
      MAT :: pt
      ARCHIVE :: archive
      MAT, PTR :: b,w
      BIN :: complex
      INT :: n_pt
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      complex = .density_matrix.spinorbital_kind == "general_complex"
      ENSURE(complex, "no general complex density matrix")
      .make_spin_b_field_grid(pt)
      .make_current_b_field_grid(pt)
      n_pt = size(pt,1)
      b.create(n_pt,3)
      w.create(n_pt,3)
      archive.set(.name,"spin_b_field_density_grid")
      archive.read(b)
      b = 0
      archive.set(.name,"current_b_field_density_grid")
      archive.read(w)
      b = b + w
      w.destroy
      archive.set(.name,"b_field_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1)
      archive.set(.name,"b_fie7d_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
      archive.set(.name,"b_field_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
      b.destroy
   end

   make_spin_b_field_grid(pt)
   ! Make the b_field due to the spin density on ".grid"
      MAT :: pt
      ARCHIVE :: archive
      MAT, PTR :: b
      BIN :: complex
      INT :: n_pt
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      complex = .density_matrix.spinorbital_kind == "general_complex"
      ENSURE(complex, "no general complex density matrix")
      n_pt = size(pt,1)
      b.create(n_pt,3)
      .make_spin_b_field_grid(b,.density_matrix.general_complex,pt)
      archive.set(.name,"spin_b_field_density_grid")
      archive.write(b)
      archive.set(.name,"spin_b_field_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1)
      archive.set(.name,"spin_b_field_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
      archive.set(.name,"spin_b_field_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
      b.destroy
   end

   make_spin_b_field_grid(bb,dens,pt)
   ! Make the b_field "bb" due to the spin density on ".grid" using complex general 
   ! AO density matrix "dens"
      MAT :: bb,pt
      CMAT, target :: dens
      CMAT, PTR :: Daa,Dba,Dbb
      MAT, PTR :: Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz
      INT :: q,a,b,fa,fb,la,lb,k, n_pt
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      bb = ZERO
      do q = 1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
        Daa => dens(fb:lb,fa:la) ! alpha-alpha block
        fb = fb + .n_bf
        lb = lb + .n_bf
        Dba => dens(fb:lb,fa:la) ! beta-alpha block
        fa = fa + .n_bf
        la = la + .n_bf
        Dbb => dens(fb:lb,fa:la) ! beta-beta block
        fac = ONE; if (a==b) fac=HALF
        Mxx.create(shell.a.n_comp,shell.b.n_comp)
        Mxy.create(shell.a.n_comp,shell.b.n_comp)
        Mxz.create(shell.a.n_comp,shell.b.n_comp)
        Myx.create(shell.a.n_comp,shell.b.n_comp)
        Myy.create(shell.a.n_comp,shell.b.n_comp)
        Myz.create(shell.a.n_comp,shell.b.n_comp)
        Mzx.create(shell.a.n_comp,shell.b.n_comp)
        Mzy.create(shell.a.n_comp,shell.b.n_comp)
        Mzz.create(shell.a.n_comp,shell.b.n_comp)
        do k = 1,n_pt
          shell.make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,pt(k,:))
          bb(k,1) = bb(k,1) + Mxx.trace_of_product( real(Dba))
          bb(k,1) = bb(k,1) + Mxy.trace_of_product(aimag(Dba))
          bb(k,1) = bb(k,1) + fac*Mxz.trace_of_product(real(Daa))
          bb(k,1) = bb(k,1) - fac*Mxz.trace_of_product(real(Dbb))
          bb(k,2) = bb(k,2) + Myx.trace_of_product( real(Dba))
          bb(k,2) = bb(k,2) - Myy.trace_of_product(aimag(Dba))
          bb(k,2) = bb(k,2) + fac*Myz.trace_of_product(real(Daa))
          bb(k,2) = bb(k,2) - fac*Myz.trace_of_product(real(Dbb))
          bb(k,3) = bb(k,3) + Mzx.trace_of_product( real(Dba))
          bb(k,3) = bb(k,3) + Mzy.trace_of_product(aimag(Dba))
          bb(k,3) = bb(k,3) + fac*Mzz.trace_of_product(real(Daa))
          bb(k,3) = bb(k,3) - fac*Mzz.trace_of_product(real(Dbb))
        end
        Mzz.destroy; Mzy.destroy; Mzx.destroy
        Myz.destroy; Myy.destroy; Myx.destroy
        Mxz.destroy; Mxy.destroy; Mxx.destroy
        shell.destroy_ptr_part
      end
      bb.zero_small_values(TOL(10))
      fac = -G_FACTOR*HALF
      bb = fac*bb
   end

   make_current_b_field_grid(pt)
   ! Make the b_field due to the current density on ".grid"
      MAT :: pt
      ARCHIVE :: archive
      MAT, PTR :: b
      BIN :: complex
      INT :: n_pt
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      .make_ao_density_matrix
      complex = .density_matrix.spinorbital_kind.includes("complex")
      ENSURE(complex, "no complex density matrix")
      n_pt = size(pt,1)
      b.create(n_pt,3)
      .make_current_b_field_grid(b,.density_matrix.restricted_complex,pt)
      archive.set(.name,"current_b_field_density_grid")
      archive.write(b)
      archive.set(.name,"current_b_field_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1)
      archive.set(.name,"current_b_field_norm_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
      archive.set(.name,"current_b_field_density_grid,normalized,gnuplot",format="ascii")
      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
      b.destroy
   end

   make_current_b_field_grid(bb,dens,pt)
   ! Make the b_field "bb" due to the paramagnetic current density on ".grid" using 
   ! a complex AO density matrix "dens"
      MAT :: bb,pt
      CMAT, target :: dens
      CMAT, PTR :: Dba
      MAT, PTR :: Jx,Jy,Jz
      INT :: q,a,b,fa,fb,la,lb,k, n_pt
      DBL :: fac
      SHELL2 :: shell
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_pt = size(pt,1)
      bb = ZERO
      do q = 1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la) 
        fac = ONE; if (a==b) fac=HALF
        Jx.create(shell.a.n_comp,shell.b.n_comp)
        Jy.create(shell.a.n_comp,shell.b.n_comp)
        Jz.create(shell.a.n_comp,shell.b.n_comp)
        do k = 1,n_pt
          shell.make_magnetic_jp_ints(Jx,Jy,Jz,pt(k,:))
          bb(k,1) = bb(k,1) + Jx.trace_of_product(aimag(Dba))
          bb(k,2) = bb(k,2) + Jy.trace_of_product(aimag(Dba))
          bb(k,3) = bb(k,3) + Jz.trace_of_product(aimag(Dba))
        end
        Jz.destroy; Jy.destroy; Jx.destroy
        shell.destroy_ptr_part
      end
   !  bb.zero_small_values(TOL(10))
      bb = -HALF*bb
   end

  make_pcc_structure_factors
     MAT, PTR :: S
     MAT, PTR :: mo,Smo
     TEXTFILE, PTR :: in
     MAT, PTR :: k_pts
     CMAT3, PTR :: ftnew,ft
     CMAT, PTR :: W
     CMAT4, PTR :: ftnew_nabla,ft_nabla
     SHELL2, PTR :: shell
     INT :: n_refl,q,i,j
     INT :: fa,la,fb,lb,a,b
     DBL :: fac
     mo.create(160,4)
     in.create("mo35")
     in.open_for_read
     in.read(mo,order="by_column")
     stdout.text("mo")
     stdout.put(mo)

     S.create(160,160)
     .get_overlap_matrix(S)

     Smo.create(4,4)
     Smo.create(4,4)
     S.change_basis(Smo,mo)
     stdout.text("Smo")
     stdout.put(Smo)

     n_refl = .crystal%n_refl

     k_pts.create(n_refl,3)
     .crystal.make_k_pts(k_pts)

     shell.create
     ftnew.create(4,4,1)
     ftnew = ZERO
     do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft.create(n_refl,shell%a%n_comp,shell%b%n_comp)
         shell.make_ft(ft,k_pts)
         fac = ONE
         if (a==b) fac = HALF
         do i = 1,n_refl
            ftnew(:,:,i) = ftnew(:,:,i) + &
               fac*matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) + &
               fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) )
         end
         ft.destroy
         shell.destroy_ptr_part
     end

     do i = 1,n_refl
        stdout.put(ftnew(:,:,i))
     end
     ftnew.destroy

     ftnew_nabla.create(4,4,3,1)
     ftnew_nabla = ZERO
     do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_nabla.create(n_refl,shell%a%n_comp,shell%b%n_comp,3)
         shell.make_ft_nabla(ft_nabla,k_pts)
         fac = ONE
         if (a==b) fac = HALF
         do i = 1,n_refl
         do j = 1,3
            ftnew_nabla(:,:,j,i) = ftnew_nabla(:,:,j,i) + &
               fac*matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) - &
               fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) )
         end
         end
         ft_nabla.destroy
         shell.destroy_ptr_part
     end

     do i = 1,n_refl
     do j = 1,3
         stdout.show("component =",j)
         stdout.put(ftnew_nabla(:,:,j,i))
     end
     end
     ftnew_nabla.destroy
     shell.destroy
  end

  make_pcc_L_matrices
     MAT, PTR :: S
     MAT, PTR :: mo,Smo
     MAT, PTR :: Lx,Ly,Lz
     MAT, PTR :: Lxmo,Lymo,Lzmo
     TEXTFILE, PTR :: in
     mo.create(160,4)
     in.create("mo35")
     in.open_for_read
     in.read(mo,order="by_column")
     stdout.text("mo")
     stdout.put(mo)

     S.create(160,160)
     .get_overlap_matrix(S)

     Smo.create(4,4)
     Smo.create(4,4)
     S.change_basis(Smo,mo)
     stdout.text("Smo")
     stdout.put(Smo)

     Lx.create(.n_bf,.n_bf); Lx = ZERO
     Ly.create(.n_bf,.n_bf); Ly = ZERO
     Lz.create(.n_bf,.n_bf); Lz = ZERO
     .make_L_matrices(Lx,Ly,Lz)

   ! std_output.text("Lx")
   ! std_output.put(Lx)
   ! std_output.text("Ly")
   ! std_output.put(Ly)
   ! std_output.text("Lz")
   ! std_output.put(Lz)

     Lxmo.create(4,4)
     Lymo.create(4,4)
     Lzmo.create(4,4)
     Lx.change_basis(Lxmo,mo)
     Ly.change_basis(Lymo,mo)
     Lz.change_basis(Lzmo,mo)

     stdout.text("Lxmo")
     stdout.put(Lxmo)
     stdout.text("Lymo")
     stdout.put(Lymo)
     stdout.text("Lzmo")
     stdout.put(Lzmo)
     S.destroy
     Smo.destroy
     Lxmo.destroy; Lymo.destroy; Lzmo.destroy
     Lx.destroy; Ly.destroy; Lz.destroy
  end


  test_spin_orbit_B_matrices
     MAT, PTR :: Lx,Ly,Lz
     DBL :: fac
     fac = (TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)/G_FACTOR
     Lx.create(.n_bf,.n_bf)
     Ly.create(.n_bf,.n_bf)
     Lz.create(.n_bf,.n_bf)
     .make_spin_orbit_B_matrices(Lx,Ly,Lz)
     stdout.text("x")
     stdout.put( Lx)
     stdout.text("y")
     stdout.put( Ly)
     stdout.text("z")
     stdout.put( Lz)
     .make_SOB_matrices(Lx,Ly,Lz)
     stdout.text("x")
     stdout.put( Lx)
     stdout.text("y")
     stdout.put( Ly)
     stdout.text("z")
     stdout.put( Lz)
     Lx.destroy; Ly.destroy; Lz.destroy
  end

  make_SOB_matrices(SOBx,SOBy,SOBz)
  ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy" and "SOBz"
     MAT :: SOBx,SOBy,SOBz
     MAT, PTR :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,Qx,Qy,Qz,Qss
     INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
     DBL :: fac,Z
     SHELL2 :: shell
     ARCHIVE :: archive
     BIN :: debug
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
     SOBx = ZERO; SOBy = ZERO; SOBz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell%a%n_comp; n_b = shell%b%n_comp
        Qss.create(n_a,n_b)
        Qx.create(n_a,n_b);  Qy.create(n_a,n_b);  Qz.create(n_a,n_b)
        Qxx.create(n_a,n_b); Qxy.create(n_a,n_b); Qxz.create(n_a,n_b)
        Qyx.create(n_a,n_b); Qyy.create(n_a,n_b); Qyz.create(n_a,n_b)
        Qzx.create(n_a,n_b); Qzy.create(n_a,n_b); Qzz.create(n_a,n_b)
        do c = 1,.n_atom
           Z = .atom(c)%atomic_number
           shell.make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, .atom(c)%pos, .gauge_origin)
           Qss = Qxx + Qyy + Qzz
           Qx = Qss*.B_field(1) - Qxx*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
           Qy = Qss*.B_field(2) - Qyx*.B_field(1) - Qyy*.B_field(2) - Qyz*.B_field(3)
           Qz = Qss*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2) - Qzz*.B_field(3)
           SOBx(fa:la,fb:lb) = SOBx(fa:la,fb:lb) - Z*Qx
           SOBy(fa:la,fb:lb) = SOBy(fa:la,fb:lb) - Z*Qy
           SOBz(fa:la,fb:lb) = SOBz(fa:la,fb:lb) - Z*Qz
        end
        shell.destroy_ptr_part
        Qzz.destroy; Qzy.destroy; Qzx.destroy
        Qyz.destroy; Qyy.destroy; Qyx.destroy
        Qxz.destroy; Qxy.destroy; Qxx.destroy
        Qz.destroy;  Qy.destroy;  Qx.destroy;  Qss.destroy
     end
     SOBx.make_symmetric
     SOBy.make_symmetric
     SOBz.make_symmetric
   ! archive.set(.name,"SOB_x_matrix"); archive.write(SOBx)
   ! archive.set(.name,"SOB_y_matrix"); archive.write(SOBy)
   ! archive.set(.name,"SOB_z_matrix"); archive.write(SOBz)
  end

  make_pcc_densities
  ! Calculate pcc's densities for the paper
     MAT, PTR :: mo
     VEC, PTR :: mo35,mo48,mo49,mo50
     VEC, PTR :: p35,p48,p49,p50
     MAT, PTR :: g35,g48,g49,g50
     MAT, PTR :: j,s
     TEXTFILE, PTR :: in
     INT :: n_pt,k
     DBL :: mu,nu,rt3,fac
     ARCHIVE :: archive

     mo35.create(160)
     mo48.create(160)
     mo49.create(160)
     mo50.create(160)
     in.create("mo35")
     in.open_for_read
     in.read(mo35)
     in.read(mo48)
     in.read(mo49)
     in.read(mo50)

     n_pt = .grid%n_pt
     p35.create(n_pt); g35.create(n_pt,3)
     p48.create(n_pt); g48.create(n_pt,3)
     p49.create(n_pt); g49.create(n_pt,3)
     p50.create(n_pt); g50.create(n_pt,3)
     .make_orbital_grid(p35,mo35)
     .make_orbital_grid(p48,mo48)
     .make_orbital_grid(p49,mo49)
     .make_orbital_grid(p50,mo50)
     .make_nabla_orbital_grid(g35,mo35)
     .make_nabla_orbital_grid(g48,mo48)
     .make_nabla_orbital_grid(g49,mo49)
     .make_nabla_orbital_grid(g50,mo50)

     j.create(n_pt,3)
     s.create(n_pt,3)
     nu = 0.15578d0
     mu = 0.19107d0
     rt3 = ONE/sqrt(THREE)
     fac = ONE/(ONE+mu*mu+nu*nu)
     do k = 1,3
        j(:,k) =      nu*(p35(:)*g48(:,k) - p48(:)*g35(:,k)) &
               + HALF*mu*(p50(:)*g49(:,k) - p49(:)*g50(:,k))
     end
     j = fac*j

     s(:,1) = -rt3*mu * (p35(:)*p49(:) - nu*p48(:)*p50(:))
     s(:,2) = -rt3*mu * (p35(:)*p50(:) - nu*p48(:)*p49(:))
     s(:,3) = (ONE+mu*mu/THREE) * p48(:)*p48(:) &
            + (ONE+nu*nu+mu*mu/SIX) * (p49(:)*p49(:)+p50(:)*p50(:)) &
            + (nu*nu+mu*mu/THREE) * p35(:)*p35(:)
     s(:,3) = HALF*s(:,3)

     archive.set(.name,"current_density")
     archive.write(j)
     archive.set(.name,"current_density,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z)
     archive.set(.name,"current_norm_density,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
     archive.set(.name,"current_density,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)

     archive.set(.name,"spin_density")
     archive.write(s)
     archive.set(.name,"spin_density,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z)
     archive.set(.name,"spin_norm_density,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
     archive.set(.name,"spin_density,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)

     s.destroy
     j.destroy
     g50.destroy; p50.destroy
     g49.destroy; p49.destroy
     g48.destroy; p48.destroy
     g35.destroy; p35.destroy
     in.close
     in.destroy
     mo50.destroy
     mo49.destroy
     mo48.destroy
     mo35.destroy
  end

  make_weak_force_energy_shift
  ! Make the expectation value of the parity-violating energy shift.
  ! Requires some archived molecular orbitals, general_complex kind.
  ! Reference: R. Zanasi and P. Lazzeretti, CPL 286, 240 (1998)
      MAT, PTR  :: pt
      CVEC, PTR :: Pa,Pb
      CMAT, PTR :: Na,Nb
      VEC, PTR  :: PV,NN
      INT :: n, x,y,z
      DBL :: Gamma
      CDBL :: I
      ARCHIVE :: archive
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      .molecular_orbitals.destroy_ptr_part
      archive.set(.name,"molecular_orbitals")
      archive.read(.molecular_orbitals, kind="general_complex")
      Gamma = 5.73416d-17
      PV.create(.n_atom)
      pt.create(.n_atom,3)
      .atom.get_coordinates(pt)
      Pa.create(.n_atom);   Pb.create(.n_atom)
      Na.create(.n_atom,3); Nb.create(.n_atom,3)
      I = (ZERO,ONE)
      stdout.set_dbl_style("d")
      x = 1; y = 2; z = 3
      PV = ZERO
      do n = 1,.n_e
         .make_orbital_grid(Pa,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
         .make_orbital_grid(Pb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
         .make_nabla_orbital_grid(Na,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
         .make_nabla_orbital_grid(Nb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
         PV(:) = PV(:) &
               + I*conjg(Nb(:,x))*Pa(:) + I*conjg(Na(:,x))*Pb(:) &
               - I*conjg(Pb(:))*Na(:,x) - I*conjg(Pa(:))*Nb(:,x) &
               +   conjg(Nb(:,y))*Pa(:) -   conjg(Na(:,y))*Pb(:) &
               +   conjg(Pb(:))*Na(:,y) -   conjg(Pa(:))*Nb(:,y) &
               + I*conjg(Na(:,z))*Pa(:) - I*conjg(Nb(:,z))*Pb(:) &
               - I*conjg(Pa(:))*Na(:,z) + I*conjg(Pb(:))*Nb(:,z)
      end
      PV = -HALF*Gamma*PV
      Nb.destroy; Na.destroy
      Pb.destroy; Pa.destroy
      pt.destroy
      NN.create(.n_atom)
      .atom.get_mean_neutron_numbers(NN)
      PV = PV*NN

      stdout.set_dbl_style("d")
      stdout.flush
      stdout.text("Contributions (by nucleus) to the parity-violating weak force energy shift term:")
      stdout.flush
      stdout.put(PV, format="column")
      stdout.flush
      stdout.show("Total contribution =", sum(PV) )
      stdout.flush
      stdout.text("Neutron numbers:")
      stdout.flush
      stdout.put(NN, format="column")
      stdout.set_dbl_style("f")
      NN.destroy
      PV.destroy
      .molecular_orbitals.destroy_ptr_part
  end

  put_g_tensor_information
  ! Put the g-tensor shift information to the output.
  ! Reference: Jayatilaka, JCP 108, 7587 (1998)
     MAT, PTR :: S, Lx,Ly,Lz, Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, T
     CMAT, PTR :: HH,P
     DBL :: Sx,Sy,Sz,SS_net, Mx,My,Mz,MM_net
     DBL :: Qx,Qy,Qz,QQ_net, Tx,Ty,Tz,TT_net
     DBL :: Sx_ppm,Sy_ppm,Sz_ppm, Mx_ppm,My_ppm,Mz_ppm
     DBL :: Qx_ppm,Qy_ppm,Qz_ppm, Tx_ppm,Ty_ppm,Tz_ppm
     DBL :: fac, fx,fy,fz, total
     VEC(3) :: quantization_axis
     CDBL :: I
     INT :: m
     BIN :: int_width
     ARCHIVE :: archive
     .density_matrix.destroy_ptr_part
     archive.set(.name,"density_matrix")
     archive.read(.density_matrix, kind="general_complex")
     P => .density_matrix%general_complex
     HH.create(2*.n_bf,2*.n_bf)
     I = (ZERO,ONE)
     quantization_axis = .scfdata.quantization_axis
     ! Spin contribution
     S.create(.n_bf,.n_bf)
     .get_overlap_matrix(S)
     fac = G_FACTOR/FOUR
     HH = ZERO
     HH.beta_alpha_plus(S,factor=fac)
     HH.alpha_beta_plus(S,factor=fac)
     Sx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(S,factor=fac*I)
     HH.alpha_beta_plus(S,factor=-fac*I)
     Sy = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(S,factor=fac)
     HH.beta_beta_plus(S,factor=-fac)
     Sz = HH.trace_of_product(P)
     S.destroy
     m = .n_a - .n_b
     fx = m*fac*quantization_axis(1)
     fy = m*fac*quantization_axis(2)
     fz = m*fac*quantization_axis(3)
     Sx_ppm = (Sx-fx)*4000000/m
     Sy_ppm = (Sy-fy)*4000000/m
     Sz_ppm = (Sz-fz)*4000000/m
     SS_net = Sx_ppm*quantization_axis(1) + Sy_ppm*quantization_axis(2) + Sz_ppm*quantization_axis(3)
     ! L contribution
     Lx.create(.n_bf,.n_bf)
     Ly.create(.n_bf,.n_bf)
     Lz.create(.n_bf,.n_bf)
     .get_L_matrices(Lx,Ly,Lz)
     fac = HALF
     HH = ZERO
     HH.alpha_alpha_plus(Lx,factor=-fac*I)  ! -I factor for the nabla part
     HH.beta_beta_plus(Lx,factor=-fac*I)
     Mx = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Ly,factor=-fac*I)
     HH.beta_beta_plus(Ly,factor=-fac*I)
     My = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Lz,factor=-fac*I)
     HH.beta_beta_plus(Lz,factor=-fac*I)
     Mz = HH.trace_of_product(P)
     Lz.destroy; Ly.destroy; Lx.destroy
     Mx_ppm = Mx*4000000/m
     My_ppm = My*4000000/m
     Mz_ppm = Mz*4000000/m
     MM_net = Mx_ppm*quantization_axis(1) + My_ppm*quantization_axis(2) + Mz_ppm*quantization_axis(3)
     ! 1 electron LS gauge contribution
     Qxx.create(.n_bf,.n_bf); Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf)
     Qyx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
     Qzx.create(.n_bf,.n_bf); Qzy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
     .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     fac = G_FACTOR/(TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
     HH = ZERO
     HH.beta_alpha_plus(Qyy,factor=fac)
     HH.beta_alpha_plus(Qzz,factor=fac)
     HH.beta_alpha_plus(Qyx,factor=-I*fac)
     HH.alpha_alpha_plus(Qzx,factor=-fac)
     HH.beta_beta_plus(Qzx,factor=+fac)
     HH.make_hermitian
     Qx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(Qxx,factor=I*fac)
     HH.beta_alpha_plus(Qzz,factor=I*fac)
     HH.beta_alpha_plus(Qxy,factor=-fac)
     HH.alpha_alpha_plus(Qzy,factor=-fac)
     HH.beta_beta_plus(Qzy,factor=+fac)
     HH.make_hermitian
     Qy = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Qxx,factor=fac)
     HH.alpha_alpha_plus(Qyy,factor=fac)
     HH.beta_beta_plus(Qxx,factor=-fac)
     HH.beta_beta_plus(Qyy,factor=-fac)
     HH.beta_alpha_plus(Qxz,factor=-fac)
     HH.beta_alpha_plus(Qyz,factor=-I*fac)
     HH.make_hermitian
     Qz = HH.trace_of_product(P)
     Qzz.destroy; Qzy.destroy; Qzx.destroy
     Qyz.destroy; Qyy.destroy; Qyx.destroy
     Qxz.destroy; Qxy.destroy; Qxx.destroy
     Qx_ppm = Qx*4000000/m
     Qy_ppm = Qy*4000000/m
     Qz_ppm = Qz*4000000/m
     QQ_net = Qx_ppm*quantization_axis(1) + Qy_ppm*quantization_axis(2) + Qz_ppm*quantization_axis(3)
     ! Relativistic kinetic energy contribution
     T.create(.n_bf,.n_bf)
     .get_kinetic_matrix(T)
     fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
     HH = ZERO
     HH.beta_alpha_plus(T,factor=fac)
     HH.alpha_beta_plus(T,factor=fac)
     Tx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(T,factor=I*fac)
     HH.alpha_beta_plus(T,factor=-I*fac)
     Ty = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(T,factor=fac)
     HH.beta_beta_plus(T,factor=-fac)
     Tz = HH.trace_of_product(P)
     T.destroy
     HH.destroy
     .density_matrix.destroy_ptr_part
     Tx_ppm = Tx*4000000/m
     Ty_ppm = Ty*4000000/m
     Tz_ppm = Tz*4000000/m
     TT_net = Tx_ppm*quantization_axis(1) + Ty_ppm*quantization_axis(2) + Tz_ppm*quantization_axis(3)

     stdout.set_dbl_style("d")
     int_width = TRUE
     stdout.flush
     stdout.text("Contribution to g-tensor shift:")
     stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.put("Term",int_width); stdout.put("<value>");
     stdout.put("shift/ppm"); stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.text("Spin term:")
     stdout.put("S_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sx)
     stdout.set_dbl_style("f"); stdout.put(Sx_ppm); stdout.flush
     stdout.put("S_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sy)
     stdout.set_dbl_style("f"); stdout.put(Sy_ppm); stdout.flush
     stdout.put("S_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sz);
     stdout.set_dbl_style("f"); stdout.put(Sz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(SS_net); stdout.flush
     stdout.text("Angular momentum term:")
     stdout.put("L_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Mx);
     stdout.set_dbl_style("f"); stdout.put(Mx_ppm); stdout.flush
     stdout.put("L_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(My);
     stdout.set_dbl_style("f"); stdout.put(My_ppm); stdout.flush
     stdout.put("L_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Mz);
     stdout.set_dbl_style("f"); stdout.put(Mz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(MM_net); stdout.flush
     stdout.text("1-electron L:S gauge term:")
     stdout.put("Q_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qx);
     stdout.set_dbl_style("f"); stdout.put(Qx_ppm); stdout.flush
     stdout.put("Q_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qy);
     stdout.set_dbl_style("f"); stdout.put(Qy_ppm); stdout.flush
     stdout.put("Q_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qz);
     stdout.set_dbl_style("f"); stdout.put(Qz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(QQ_net); stdout.flush
     stdout.text("Relativistic B:S kinetic term:")
     stdout.put("T_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Tx)
     stdout.set_dbl_style("f"); stdout.put(Tx_ppm); stdout.flush
     stdout.put("T_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Ty);
     stdout.set_dbl_style("f"); stdout.put(Ty_ppm); stdout.flush
     stdout.put("T_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Tz);
     stdout.set_dbl_style("f"); stdout.put(Tz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(TT_net); stdout.flush
     total = SS_net + MM_net + QQ_net + TT_net
     stdout.flush
     stdout.put("Total:",int_width); stdout.tab(dbl_fields=1); stdout.put(total)
     stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.set_dbl_style("f")
  end

   integrate_property(make_property_grid) result (res)
   ! Integrate a scalar molecular property, which is represented by a subroutine
   ! "make_property_grid" which returns "values" of the property in a vector,
   ! given "mol" as the molecule, and "pts" as a set of points. The result of
   ! the integration is "res".
      interface
         make_property_grid(mol,values,pts)
            use TYPES
            MOL :: mol
            VEC :: values
            MAT :: pts
         end
      end
      DBL :: res
      ENSURE( .dftgrid.created,"no DFT grid information!")
!      res = .dftgrid.integrate_molecular_property(make_property_grid,self)
      res = ZERO
   end

!  integrate_rho_numerically
!  ! Integrate the density numerically
!     DBL :: res
!     res = .integrate_property(make_density_grid_1)
!     stdout.show("numerically integrated charge =",res)
!  end

   put_atom_kind_map
   ! Check the atom kind map routine
      DBL :: res
      IVEC, PTR :: atom_kind,unique_atom
      INT :: n_atom,n_kind
      n_atom = .n_atom
      atom_kind.create(n_atom)
      .atom.make_atom_kind_list(atom_kind,n_kind)
      stdout.text("atom kind")
      stdout.put(atom_kind,"column")
      unique_atom.create(n_kind)
      .atom.make_unique_atom_list(unique_atom)
      stdout.text("unique atom list")
      stdout.put(unique_atom,"column")
      unique_atom.destroy
      atom_kind.destroy
   end

  test_eigen
     INT :: n,i
     DBL :: dot
     MAT, PTR :: m
     VEC, PTR :: eval
     MAT, PTR :: L,R,w
     stdin.read(n)
     m.create(n,n)
     stdin.read(m)
     eval.create(n)
     L.create(n,n)
     R.create(n,n)
     m.solve_general_eigenproblem(eval,L,R)
     stdout.show("n =",n)
     stdout.text("eval:")
     stdout.put(eval,"column")
     stdout.text("Left eigenvectors:")
     stdout.put(L)
     stdout.text("right eigenvectors:")
     stdout.put(R)
     w.create(n,n)
     w.to_product(L,R,transpose_a=TRUE)
     stdout.text("(left)^T x (right) eigenvectors:")
     stdout.put(w)
     w.destroy
     R.destroy
     L.destroy
     eval.destroy
     m.destroy
  end

! *************************************************************
! Determinant Variation Perturbation Theory (DVPT) SCF routines
! *************************************************************

  DVPT_scf [recursive] [leaky]
  ! Do a restricted determinant variation perturbation theory SCF calculation. The following
  ! are produced as results: .molecular_orbitals, .orbital_energies, .density_matrix  
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    .make_DVPT_initial_mos
    .make_DVPT_density_matrices
    .make_DVPT_fock_matrices
    .scfdata.set(nuclear_energy=.nuclear_energy)
    .scfdata.reset(energy=.DVPT_scf_energy, kinetic_energy=ZERO)

  ! stdout.text("D:")
  ! stdout.put(.density_matrix.restricted)
  ! stdout.text("F:")
  ! stdout.put(.fock_matrix.restricted)
  ! .scfdata.kind="rhf"
  ! .scfdata.reset(energy=.scf_energy, kinetic_energy=ZERO)
  ! .scfdata.kind="rdvpt"

    .scfdata.put_banner
    ! Begin iterations
    do
    ! .extrapolate_scf
      .update_DVPT_orbitals
      .schmidt_orthonormalise(.molecular_orbitals)
      .make_DVPT_density_matrices
      .make_DVPT_fock_matrices
      .save_DVPT_results
      .scfdata.update(energy=.DVPT_scf_energy, kinetic_energy=ZERO)
      .scfdata.put_results
      if (.scfdata.scf_done) exit
    end
    .scfdata.cleanup_diis
    .fock_matrix.destroy("restricted")
  end

  update_DVPT_orbitals
  ! Solve for the new DVPT orbitals and energies. An initial set of orbitals
  ! and a Fock matrix must already exist in memory. The new molecular orbitals 
  ! "MO*U" are found from the old MOs solving : (MO^T F MO)U = MO^T S MO U E 
  ! where U is a general matrix (since F is not symmetric).
    VEC, PTR :: MO_energies
    MAT, PTR :: MO,F
    MAT, PTR :: G,U,left
    INT :: i
    MO_energies => .orbital_energies.restricted
    MO => .molecular_orbitals.restricted
    F  => .fock_matrix.restricted
    G.create(.n_bf,.n_bf)
    U.create(.n_bf,.n_bf)
    left.create(.n_bf,.n_bf)
    G = F
    G.change_basis(MO)
    ! Level shifting
    if ( .scfdata.apply_level_shifting) then
      do i = .n_a + 1, .n_bf
        G(i,i) = .scfdata.level_shift + G(i,i)
      end
    end
    G.solve_general_eigenproblem(MO_energies,left,U)
    G.to_product(MO,U)
    MO = G
    left.destroy
    U.destroy
    G.destroy
  end

  save_DVPT_results
  ! Save the DVPT results in various archives
    ARCHIVE :: archive
    INT :: m
    .save_scf_results
    m = .DVPT_order
    archive.set(.name,"DVPT_mo_"// m.to_str.trim)
    archive.write(.molecular_orbitals.restricted)
  end

  make_DVPT_initial_mos [leaky]
  ! Make the DVPT initial orbitals. Currently this is just the same
  ! as the usual initial guess, but the MO's are written to disk.
     INT :: m
     MAT, PTR :: MO
     ARCHIVE :: m_archive
     m = .DVPT_order
     m_archive.set(.name,"DVPT_mo_"// m.to_str.trim)
     .scfdata.kind = "rhf"
     .get_initial_guess
     .scfdata.kind = "rdvpt"
     MO => .molecular_orbitals.restricted
     m_archive.write(MO)
  end

  DVPT_order result (X)
  ! Determine the DVPT order by looking for the highest number "X" for
  ! which a DVPT_mo_X archive file exists.
     INT :: X
     ARCHIVE :: archive
     INT :: order = 999
     if (order/=999) then
        X = order
     else
        X = 0
        do
           archive.set(.name,"DVPT_mo_"// X.to_str.trim)
           if (archive.does_not_exist) exit
           X = X + 1
        end
        order = X
     end
  end

  make_DVPT_density_matrices
  ! Make all the DVPT density matrices up to the required order
  ! NOTE: the indice order is opposite to the paper.
     INT :: m,j
     m = .DVPT_order
     do j = 0,m
        .make_DVPT_density_matrix(m,j)
     end
     .make_DVPT_eff_density_matrix
  !  .scfdata.kind = "rhf"
  !  .make_scf_density_matrix
  !  .scfdata.kind = "rdvpt"
  end

  make_DVPT_eff_density_matrix
  ! Make the effective DVPT fock matrix
     INT :: m,i,j
     DBL :: fac,sum,det
     MAT, PTR :: DD,D
     ARCHIVE :: d_archive
     .density_matrix.restricted.destroy
     DD.create(.n_bf,.n_bf); DD = ZERO
     D.create(.n_bf,.n_bf)
     m   = .DVPT_order
     do i = 0,m
     do j = 0,i
        fac = TWO
        if (i==j) fac = ONE
        .get_DVPT_density_matrix(D,det,i,j)
        sum = sum + fac*det
        D = fac*D
        DD.plus(D)
     end
     end
     DD = DD/sum
     d_archive.set(.name,"DVPT_density_matrix")
     d_archive.write(DD)
     .density_matrix.restricted => DD
     D.destroy
  end

  get_DVPT_density_matrix(D,determinant,left,right)
  ! Get the determinant variation perturbation theory transition density matrix 
  ! for a left determinant orbitals "left" and  a right determinant orbitals "right". 
  ! Make the density if the archive does not exist.
     MAT :: D
     DBL :: determinant
     INT :: left,right
     ARCHIVE :: d_archive
     STR :: label
     label = left.to_str.trim // right.to_str.trim
     d_archive.set(.name,"DVPT_density_"// label)
     if (d_archive.does_not_exist) .make_DVPT_density_matrix(left,right)
     d_archive.read(D)
     d_archive.set(.name,"DVPT_determinant_"// left.to_str.trim // right.to_str.trim)
     d_archive.read(determinant)
  end

  make_DVPT_density_matrix(left,right)
  ! Make the determinant variation perturbation theory transition density matrix 
  ! for a left determinant orbitals "left" and  a right determinant orbitals "right". 
  ! The density and determinant are stored as archives on disk.
     INT :: left,right
     MAT, PTR :: D,L,R
     ARCHIVE :: l_archive,r_archive,d_archive
     DBL :: determinant
     D.create(.n_bf,.n_bf)
     l_archive.set(.name,"DVPT_mo_"// left.to_str.trim)
     r_archive.set(.name,"DVPT_mo_"// right.to_str.trim)
     ENSURE(l_archive.exists, "no DVPT mo archive, no. ="// left.to_str.trim)
     ENSURE(r_archive.exists, "no DVPT mo archive, no. ="// right.to_str.trim)
     L.create(.n_bf,.n_bf)
     R.create(.n_bf,.n_bf)
     l_archive.read(L)
     r_archive.read(R)
     ! Make density matrix using occupied orbitals only
     .make_DVPT_density_matrix(D,determinant,L(:,:.n_a),R(:,:.n_a))

     !       stdout.show("det =",determinant)
     !       stdout.text("MO:")
     !       stdout.put(L(:,.n_a))
     !       stdout.text("D:")
     !       stdout.put(TWO*D)

     R.destroy
     L.destroy
     d_archive.set(.name,"DVPT_density_"// left.to_str.trim // right.to_str.trim)
     d_archive.write(D)
     d_archive.set(.name,"DVPT_determinant_"// left.to_str.trim // right.to_str.trim)
     d_archive.write(determinant)
     D.destroy
  end

  make_DVPT_density_matrix(D,determinant,left,right)
  ! Make the determinant variation perturbation theory transition density matrix "D" for a
  ! left determinant of occupied orbitals "left" and a right determinant of occupied 
  ! orbitals "right". Also return the "determinant" of the orbital ovarlap matrix.
     MAT :: D
     MAT :: left,right
     DBL :: determinant
     MAT, PTR :: S,O,C
     INT :: dim
     ENSURE(size(D,1)==size(D,2),"D is not square")
     ENSURE(size(D,1)==.n_bf,"D has wrong size")
     ENSURE(size(left,1) ==.n_bf,"left has wrong size")
     ENSURE(size(right,1)==.n_bf,"right has wrong size")
     ENSURE(size(left,2)==size(right,2),"left and and right are incompatible")
     dim = size(left,2)
     S.create(dim,dim)
     O.create(.n_bf,.n_bf)
     .get_overlap_matrix(O)
     O.change_basis(S,left,right)
     O.destroy
     C.create(dim,dim)
     .make_cofactor(C,determinant,S)
     C.back_transform(D,right,left)
     C.destroy
     S.destroy
  end

  make_cofactor(C,determinant,S)
  ! Make the cofactor matrix "C" and "determinant" for the matrix "S".
  ! Note: this constructs the alpha-alpha part of the cofactor, but the
  ! determinant is that for the full overlap matrix
     MAT :: C,S
     DBL :: determinant
     VEC, PTR :: eval,n
     MAT, PTR :: left,right,W
     INT :: dim,i
     DBL :: dot
     ENSURE(size(C,1)==size(C,2),"C is not square")
     ENSURE(size(S,1)==size(S,2),"incorrect size for array S")
     ENSURE(size(S,1)==size(C,1),"array C and array S incompatible")
     dim = size(C,1)
     left.create(dim,dim)
     right.create(dim,dim)
     eval.create(dim)
     ! Get the eigenvalues and determinant of S
     S.solve_general_eigenproblem(eval,left,right)
     determinant = product(eval)
     determinant = determinant*determinant ! include beta part
     ! Make the cofactor
     n.create(dim)
     n = determinant/eval
     W.create(dim,dim)
     W.to_product_with_diagonal(n,left,transpose_a=TRUE)
     C = matmul(right,W)
 
   ! stdout.text("*********make_cofactor**************")
   ! stdout.text("S:")
   ! stdout.put(S)
   ! stdout.text("n:")
   ! stdout.put(n,format="column")
   ! stdout.text("L:")
   ! stdout.put(left)
   ! stdout.text("R:")
   ! stdout.put(right)
   ! W = matmul(right,transpose(left))
   ! stdout.text("R L^T:")
   ! stdout.put(W)
   ! W = matmul(transpose(left),right)
   ! stdout.text("L^T R:")
   ! stdout.put(W)
   ! stdout.text("C:")
   ! stdout.put(C)
   ! stdout.text("************************************")

     W.destroy
     n.destroy
     eval.destroy
     right.destroy
     left.destroy
  end

  make_DVPT_fock_matrices [leaky]
  ! Make the DVPT fock matrices up to the required order,
  ! including the effective fock matrix
     INT :: m,j
     m = .DVPT_order
     do j = 0,m
        .make_DVPT_fock_matrix(m,j)
     end
     .make_DVPT_eff_fock_matrix
  !  .scfdata.kind = "rhf"
  !  .make_fock_matrix
  !  .scfdata.kind = "rdvpt"
  end

  make_DVPT_eff_fock_matrix [leaky]
  ! Make the effective DVPT fock matrix
     INT :: m,j
     DBL :: E_m,E_mj,sum,det
     MAT, PTR :: FF,F,W,D
     ARCHIVE :: f_archive
     .fock_matrix.restricted.destroy
     FF.create(.n_bf,.n_bf); FF = ZERO
     F.create(.n_bf,.n_bf)
     W.create(.n_bf,.n_bf)
     D.create(.n_bf,.n_bf)
     m   = .DVPT_order
     E_m = .DVPT_electronic_energy
     sum = ZERO
     do j = 0,m
        .get_DVPT_fock_matrix(F,m,j)
        .get_DVPT_density_matrix(D,det,m,j)
        sum = sum + det
        det = 1/(TWO*det)
        FF.plus(F)
        .add_core_hamiltonian(FF)
        E_mj = E_m + det*F.trace_of_product(D)
        .get_overlap_matrix(F)
        W.to_product(D,F) 
        D.to_product(F,W) 
        FF = FF - E_mj*D
     end
     FF = FF/sum
     f_archive.set(.name,"DVPT_effective_fock_"// m.to_str.trim)
     f_archive.write(FF)
     .fock_matrix.restricted => FF
     D.destroy
     W.destroy
     F.destroy
  end

  get_DVPT_fock_matrix(F,left,right)
  ! Get the determinant variation perturbation theory transition Fock matrix 
  ! for a left determinant orbitals "left" and  a right determinant orbitals "right". 
     MAT :: F
     INT :: left,right
     ARCHIVE :: f_archive
     STR :: label
     label = left.to_str.trim // right.to_str.trim
     f_archive.set(.name,"DVPT_fock_"// label)
     if (f_archive.does_not_exist) .make_DVPT_fock_matrix(left,right)
     f_archive.read(F)
  end

  make_DVPT_fock_matrix(left,right)
  ! Make the determinant variation perturbation theory transition fock matrix 
  ! for a left determinant orbitals "left" and  a right determinant orbitals "right". 
  ! The Fock matrix is stored as an archive on disk.
     INT :: left,right
     MAT, PTR :: F
     ARCHIVE :: f_archive
     STR :: label
     F.create(.n_bf,.n_bf)
     .make_DVPT_fock_matrix(F,left,right)
     label = left.to_str.trim // right.to_str.trim
     f_archive.set(.name,"DVPT_fock_"// label)
     f_archive.write(F)
     F.destroy
  end

  make_DVPT_fock_matrix(F,left,right)
  ! Make the determinant variation perturbation theory transition fock matrix for
  ! a left determinant of orbitals "left" and a right determinant of orbitals
  ! "right". If present, "D" is used as the density matrix.
     MAT :: F
     INT :: left,right
     MAT, PTR :: P
     DBL :: determinant,fac
     P.create(.n_bf,.n_bf)
     .get_DVPT_density_matrix(P,determinant,left,right)
  !  .make_r_asymmetric_fock(P,F,direct=FALSE,core=FALSE,r12=TRUE) 
     .make_r_fock(P,F,direct=FALSE,core=FALSE,r12=TRUE) 
     fac = TWO/determinant
     F = fac*F
     P.destroy
  end

  make_r_fock(P,F,direct,core,r12) [leaky]
  ! Make a new restricted Fock matrix "F" from the density matrix "P".
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    MAT :: P,F
    MAT, PTR :: J,K
    BIN :: do_direct,add_core,add_r12

    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       K.create(.n_bf,.n_bf)
       if (do_direct) then; .make_r_JK_direct(J,K,P)
       else;                .make_r_JK_disk(J,K,P)
       end
       F = J - HALF*K 
       K.destroy
       J.destroy
    else
       F = ZERO
    end
    if (add_core) .add_core_hamiltonian(F)
  end

  make_r_asymmetric_fock(P,F,direct,core,r12) [leaky]
  ! Make a new restricted Fock matrix "F" from an asymmetric density matrix "P".
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    MAT :: P,F
    MAT, PTR :: J,K
    BIN :: do_direct,add_core,add_r12
    ENSURE(size(F,1)==.n_bf, "Fock matrix dimensions wrong")
    ENSURE(size(P,1)==.n_bf, "Density matrix dimensions wrong")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       K.create(.n_bf,.n_bf)
       if (do_direct) then; .make_r_asymmetric_JK_direct(J,K,P)
       else;                .make_r_asymmetric_JK_disk(J,K,P)
       end
       F = J - HALF*K 
       K.destroy
       J.destroy
    else
       F = ZERO
    end
    if (add_core) then
      .add_core_hamiltonian(F)
    end
  end

  make_r_asymmetric_JK_direct(J,K,P)
  ! Make the real coulomb matrices "J" and exchange matrix "K"  from an
  ! asymmetric density matrix "P" directly from the integrals. 
    MAT :: J,K,P
    MAT4, PTR   :: I
    SHELL4, PTR :: shell4
    VEC, PTR :: I_max
    INT :: ac,ab,cd,aa,cc
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: cutoff,I_abcd,factor
    BIN :: skip
    J = ZERO
    K = ZERO
    cutoff = .scfdata.eri_cutoff
    shell4.create
    I_max.create(.n_shell_pairs)
    .make_max_abab_integrals(I_max)
    do ab = 1,.n_shell_pairs
      .get_shell_pair(ab,a,b)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      do cd = 1,ab
        .get_shell_pair(cd,c,d)
        fc = .first_basis_fn_for_shell(c)
        fd = .first_basis_fn_for_shell(d)
        lc = .last_basis_fn_for_shell(c)
        ld = .last_basis_fn_for_shell(d)
        .get_shell_quartet(shell4,a,b,c,d)
        skip = .schwarz_inequality_test(cutoff,ab,cd,fa,la,fb,lb,fc,lc,fd,ld,P,I_max)
        if (skip) then
           shell4.destroy_ptr_part
           cycle
        end
        I.create(fa,la,fb,lb,fc,lc,fd,ld)
        shell4.get_ERI(I)
        factor = ONE                                ! Evaluate the integrals
        if (a==b)          factor = HALF            ! Coincidence factors   
        if (c==d)          factor = HALF * factor
        if (a==c AND b==d) factor = HALF * factor
        do d = fd,ld
        do c = fc,lc
        do b = fb,lb
        do a = fa,la
           I_abcd = factor * I(a,b,c,d)
           J(a,b) = J(a,b) + I_abcd*(P(d,c)+P(c,d)) ! These are symmetric
           J(c,d) = J(c,d) + I_abcd*(P(b,a)+P(a,b))
           K(a,d) = K(a,d) + I_abcd*P(b,c)          ! These are asymmetric
           K(a,c) = K(a,c) + I_abcd*P(b,d) 
           K(b,c) = K(b,c) + I_abcd*P(a,d)
           K(b,d) = K(b,d) + I_abcd*P(a,c)
           K(d,a) = K(d,a) + I_abcd*P(c,b)
           K(c,a) = K(c,a) + I_abcd*P(d,b)
           K(c,b) = K(c,b) + I_abcd*P(d,a)
           K(d,b) = K(d,b) + I_abcd*P(c,a)
        end
        end
        end
        end
        I.destroy
        shell4.destroy_ptr_part
      end
    end
    I_max.destroy
    shell4.destroy
    .weight_diagonal_blocks(J,TWO)
    J.make_symmetric
  end

  make_r_asymmetric_JK_disk(J,K,P)
  ! Make the real coulomb matrices "J" and exchange matrix "K"  from an
  ! asymmetric density matrix "P" using disk integrals. 
    MAT :: J,K,P
    ARCHIVE, PTR :: eri_archive,ind_archive
    MAT4, PTR   :: I
    INT :: q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J = ZERO
    K = ZERO
    n_quartets = .n_shell_quartets
    do
       ind_archive.file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       eri_archive.file.read(I)
       do d = fd,ld
       do c = fc,lc
       do b = fb,lb
       do a = fa,la
          I_abcd = I(a,b,c,d)
          J(a,b) = J(a,b) + I_abcd*(P(d,c)+P(c,d)) ! These are symmetric
          J(c,d) = J(c,d) + I_abcd*(P(b,a)+P(a,b))
          K(a,d) = K(a,d) + I_abcd*P(b,c)          ! These are asymmetric
          K(a,c) = K(a,c) + I_abcd*P(b,d) 
          K(b,c) = K(b,c) + I_abcd*P(a,d)
          K(b,d) = K(b,d) + I_abcd*P(a,c)
          K(d,a) = K(d,a) + I_abcd*P(c,b)
          K(c,a) = K(c,a) + I_abcd*P(d,b)
          K(c,b) = K(c,b) + I_abcd*P(d,a)
          K(d,b) = K(d,b) + I_abcd*P(c,a)
       end
       end
       end
       end
       I.destroy
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    J.make_symmetric
  end
 
   get_shell_pair_indices_from(index,a,b)
   ! Return the actual shell indicies "a" and "b" which map to "index"
     INT, IN :: index
     INT, OUT :: a,b
     a  = (1+sqrt(8.0d0*index-7.0d0))/2
     b  = index - a*(a-1)/2
   end

  DVPT_scf_energy result (res)
  ! Evaluates the determinant variation perturbation theory SCF energy 
  ! (including the nuclear repulsion contribution)
    DBL :: res
    res = .DVPT_electronic_energy + .nuclear_energy
  end

  DVPT_electronic_energy result (res)
  ! Evaluates the SCF electronic energy 
    DBL :: res
    STR :: kind
    MAT, PTR :: F,D
    INT :: m,i,j
    DBL :: fac,det,sum
    m = .DVPT_order
    kind = .scfdata.kind
    select case (kind)
       case ("rdvpt","restricted_dvpt")
          F.create(.n_bf,.n_bf)
          D.create(.n_bf,.n_bf)
          res = ZERO
          sum = ZERO
          do i = 0,m
          do j = 0,i
             fac = TWO
             if (i==j) fac = ONE
             .get_DVPT_density_matrix(D,det,i,j)
             .get_DVPT_fock_matrix(F,i,j)
             .add_core_hamiltonian(F)

          !  stdout.show("i   =",i)
          !  stdout.show("j   =",j)
          !  stdout.show("det =",det)
          !  stdout.text("D:")
          !  stdout.put(TWO*D)
          !  stdout.text("F:")
          !  stdout.put(F)

             .add_core_hamiltonian(F)
             res = res + fac*F.trace_of_product(D)
             sum = sum + fac*det
          end
          end
          res = res/sum
          D.destroy
          F.destroy
       case default; DIE("not yet implemented, " // .scfdata.kind)
    end
  end

end
