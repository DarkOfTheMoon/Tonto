!-------------------------------------------------------------------------------
!
! MOL_dylan: dylan's test routines
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_DYLAN

   USE types 
   USE error 
   USE mm 
   USE time 
   USE str 
   USE int 
   USE dbl 
!  USE buffer 

   USE strvec 
   USE binvec 
   USE ivec 
   USE ivecvec 
   USE imat 
   USE imat3 
   USE imat4
   USE vec 
   USE vecvec 
   USE mat 
   USE mat3 
   USE mat4 
   USE mat5 
   USE matvec 
   USE mat3vec

   USE cvec 
   USE cmat 
   USE cmat3 
   USE cmat4 
   USE cmat5
   USE opvec 
   USE opmat

   USE unitnumber 
   USE input 
   USE output 
!  USE file 
   USE archive

   USE vecdiis

   USE rys 
   USE gaussian 
   USE gaussian2 
   USE gaussian4
   USE shell 
   USE shell1
   USE shell2
   USE shell4
   USE shellvec

!  USE basis
   USE basisvec  

   USE atom
   USE atomvec

   USE irrep
   USE irrepvec
!  USE pointgroup
   USE spacegroup 

   USE unitcell
   USE xtal

   USE plotgrid
   USE dftgrid
!  USE scfdata 

   USE mol_common
   USE mol_integrals
   USE mol_xtal
   USE mol_io
   USE mol_scf
   USE mol_plot

   implicit none         

#  include "macros"
#  include "mol_dylan.int"

contains

  make_pcc_structure_factors
     MAT, PTR :: S
     MAT, PTR :: mo,Smo
     INPUT, PTR :: in
     MAT, PTR :: k_pts
     CMAT3, PTR :: ftnew,ft
     CMAT, PTR :: W 
     CMAT4, PTR :: ftnew_nabla,ft_nabla
     SHELL2, PTR :: shell
     INT :: n_refl,q,i,j
     INT :: fa,la,fb,lb,a,b
     DBL :: fac
     mo.create(160,4)
     in.create("mo35")
     in.open
     in.read(mo,order="by_column")
     std_output.text("mo")
     std_output.put(mo)

     S.create(160,160)
     .get_overlap_matrix(S)

     Smo.create(4,4)
     Smo.create(4,4)
     S.change_basis(Smo,mo)
     std_output.text("Smo")
     std_output.put(Smo)
     
     n_refl = .xtal%n_refl

     k_pts.create(n_refl,3)
     .xtal.make_k_pts(k_pts)

     shell.create
     ftnew.create(4,4,1)
     ftnew = ZERO
     do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft.create(n_refl,shell%a%n_comp,shell%b%n_comp)
         shell.make_ft(ft,k_pts)
         fac = ONE
         if (a==b) fac = HALF
         do i = 1,n_refl
            ftnew(:,:,i) = ftnew(:,:,i) + &
               fac*matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) + &
               fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) )
         end
         ft.destroy
         shell.destroy_ptr_part
     end

     do i = 1,n_refl
         .out.put(ftnew(:,:,i))
     end
     ftnew.destroy

     ftnew_nabla.create(4,4,3,1)
     ftnew_nabla = ZERO
     do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_nabla.create(n_refl,shell%a%n_comp,shell%b%n_comp,3)
         shell.make_ft_nabla(ft_nabla,k_pts)
         fac = ONE
         if (a==b) fac = HALF
         do i = 1,n_refl
         do j = 1,3
            ftnew_nabla(:,:,j,i) = ftnew_nabla(:,:,j,i) + &
               fac*matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) - &
               fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) )
         end
         end
         ft_nabla.destroy
         shell.destroy_ptr_part
     end

     do i = 1,n_refl
     do j = 1,3
         .out.show("component =",j)
         .out.put(ftnew_nabla(:,:,j,i))
     end
     end
     ftnew_nabla.destroy
     shell.destroy
  end

  make_pcc_L_matrices
     MAT, PTR :: S
     MAT, PTR :: mo,Smo
     MAT, PTR :: Lx,Ly,Lz
     MAT, PTR :: Lxmo,Lymo,Lzmo
     INPUT, PTR :: in
     mo.create(160,4)
     in.create("mo35")
     in.open
     in.read(mo,order="by_column")
     std_output.text("mo")
     std_output.put(mo)

     S.create(160,160)
     .get_overlap_matrix(S)

     Smo.create(4,4)
     Smo.create(4,4)
     S.change_basis(Smo,mo)
     std_output.text("Smo")
     std_output.put(Smo)
     
     Lx.create(.n_bf,.n_bf); Lx = ZERO
     Ly.create(.n_bf,.n_bf); Ly = ZERO
     Lz.create(.n_bf,.n_bf); Lz = ZERO
     .make_L_matrices(Lx,Ly,Lz) 

   ! std_output.text("Lx")
   ! std_output.put(Lx)
   ! std_output.text("Ly")
   ! std_output.put(Ly)
   ! std_output.text("Lz")
   ! std_output.put(Lz)

     Lxmo.create(4,4)
     Lymo.create(4,4)
     Lzmo.create(4,4)
     Lx.change_basis(Lxmo,mo)
     Ly.change_basis(Lymo,mo)
     Lz.change_basis(Lzmo,mo)

     std_output.text("Lxmo")
     std_output.put(Lxmo)
     std_output.text("Lymo")
     std_output.put(Lymo)
     std_output.text("Lzmo")
     std_output.put(Lzmo)
     S.destroy 
     Smo.destroy 
     Lxmo.destroy; Lymo.destroy; Lzmo.destroy
     Lx.destroy; Ly.destroy; Lz.destroy
  end


  test_spin_orbit_B_matrices
     MAT, PTR :: Lx,Ly,Lz
     DBL :: fac
     fac = (TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)/G_FACTOR
     Lx.create(.n_bf,.n_bf)
     Ly.create(.n_bf,.n_bf)
     Lz.create(.n_bf,.n_bf)
     .make_spin_orbit_B_matrices(Lx,Ly,Lz) 
     .out.text("x")
     .out.put( Lx)
     .out.text("y")
     .out.put( Ly)
     .out.text("z")
     .out.put( Lz)
     .make_SOB_matrices(Lx,Ly,Lz) 
     .out.text("x")
     .out.put( Lx)
     .out.text("y")
     .out.put( Ly)
     .out.text("z")
     .out.put( Lz)
     Lx.destroy; Ly.destroy; Lz.destroy
  end

  make_SOB_matrices(SOBx,SOBy,SOBz)
  ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy" and "SOBz"
     MAT :: SOBx,SOBy,SOBz
     MAT, PTR :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,Qx,Qy,Qz,Qss
     INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
     DBL :: fac,Z
     SHELL2 :: shell
     ARCHIVE :: archive
     BIN :: debug
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.basis_resolved, "no basis set")
     fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
     SOBx = ZERO; SOBy = ZERO; SOBz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell%a%n_comp; n_b = shell%b%n_comp
        Qss.create(n_a,n_b)
        Qx.create(n_a,n_b);  Qy.create(n_a,n_b);  Qz.create(n_a,n_b)
        Qxx.create(n_a,n_b); Qxy.create(n_a,n_b); Qxz.create(n_a,n_b)
        Qyx.create(n_a,n_b); Qyy.create(n_a,n_b); Qyz.create(n_a,n_b)
        Qzx.create(n_a,n_b); Qzy.create(n_a,n_b); Qzz.create(n_a,n_b)
        do c = 1,.n_atom
           Z = .atom(c)%atomic_number
           shell.make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, .atom(c)%pos, .gauge_origin)
           Qss = Qxx + Qyy + Qzz
           Qx = Qss*.B_field(1) - Qxx*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
           Qy = Qss*.B_field(2) - Qyx*.B_field(1) - Qyy*.B_field(2) - Qyz*.B_field(3)
           Qz = Qss*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2) - Qzz*.B_field(3)
           SOBx(fa:la,fb:lb) = SOBx(fa:la,fb:lb) - Z*Qx
           SOBy(fa:la,fb:lb) = SOBy(fa:la,fb:lb) - Z*Qy
           SOBz(fa:la,fb:lb) = SOBz(fa:la,fb:lb) - Z*Qz
        end
        shell.destroy_ptr_part
        Qzz.destroy; Qzy.destroy; Qzx.destroy
        Qyz.destroy; Qyy.destroy; Qyx.destroy
        Qxz.destroy; Qxy.destroy; Qxx.destroy
        Qz.destroy;  Qy.destroy;  Qx.destroy;  Qss.destroy
     end
     SOBx.make_symmetric
     SOBy.make_symmetric
     SOBz.make_symmetric
   ! archive.set(.name,"SOB_x_matrix"); archive.write(SOBx)
   ! archive.set(.name,"SOB_y_matrix"); archive.write(SOBy)
   ! archive.set(.name,"SOB_z_matrix"); archive.write(SOBz)
  end

  make_pcc_densities
  ! Calculate pcc's densities for the paper
     MAT, PTR :: mo
     VEC, PTR :: mo35,mo48,mo49,mo50
     VEC, PTR :: p35,p48,p49,p50
     MAT, PTR :: g35,g48,g49,g50
     MAT, PTR :: j,s
     INPUT, PTR :: in
     INT :: n_pt,k
     DBL :: mu,nu,rt3,fac
     ARCHIVE :: archive
     !
     mo35.create(160)
     mo48.create(160)
     mo49.create(160)
     mo50.create(160)
     in.create("mo35")
     in.open
     in.read(mo35)
     in.read(mo48)
     in.read(mo49)
     in.read(mo50)
     !
     n_pt = .grid%n_pt 
     p35.create(n_pt); g35.create(n_pt,3)
     p48.create(n_pt); g48.create(n_pt,3)
     p49.create(n_pt); g49.create(n_pt,3)
     p50.create(n_pt); g50.create(n_pt,3)
     .make_orbital_grid(p35,mo35)
     .make_orbital_grid(p48,mo48)
     .make_orbital_grid(p49,mo49)
     .make_orbital_grid(p50,mo50)
     .make_nabla_orbital_grid(g35,mo35)
     .make_nabla_orbital_grid(g48,mo48)
     .make_nabla_orbital_grid(g49,mo49)
     .make_nabla_orbital_grid(g50,mo50)
     !
     j.create(n_pt,3)
     s.create(n_pt,3)
     nu = 0.15578d0
     mu = 0.19107d0
     rt3 = ONE/sqrt(THREE)
     fac = ONE/(ONE+mu*mu+nu*nu)
     do k = 1,3
        j(:,k) =      nu*(p35(:)*g48(:,k) - p48(:)*g35(:,k)) &
               + HALF*mu*(p50(:)*g49(:,k) - p49(:)*g50(:,k))
     end
     j = fac*j
     !
     s(:,1) = -rt3*mu * (p35(:)*p49(:) - nu*p48(:)*p50(:))
     s(:,2) = -rt3*mu * (p35(:)*p50(:) - nu*p48(:)*p49(:))
     s(:,3) = (ONE+mu*mu/THREE) * p48(:)*p48(:) &
            + (ONE+nu*nu+mu*mu/SIX) * (p49(:)*p49(:)+p50(:)*p50(:)) &
            + (nu*nu+mu*mu/THREE) * p35(:)*p35(:)
     s(:,3) = HALF*s(:,3)
     !
     archive.set(.name,"current_density")
     archive.write(j)
     archive.set(.name,"current_density,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z)
     archive.set(.name,"current_norm_density,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
     archive.set(.name,"current_density,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
     !
     archive.set(.name,"spin_density")
     archive.write(s)
     archive.set(.name,"spin_density,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z)
     archive.set(.name,"spin_norm_density,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
     archive.set(.name,"spin_density,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
     !
     s.destroy
     j.destroy
     g50.destroy; p50.destroy
     g49.destroy; p49.destroy
     g48.destroy; p48.destroy
     g35.destroy; p35.destroy
     in.close
     in.destroy
     mo50.destroy
     mo49.destroy
     mo48.destroy
     mo35.destroy
  end

  make_weak_force_energy_shift
  ! Make the expectation value of the parity-violating energy shift.
  ! Requires some archived molecular orbitals, general_complex kind.
  ! Reference: R. Zanasi and P. Lazzeretti, CPL 286, 240 (1998)
      MAT, PTR  :: pt
      CVEC, PTR :: Pa,Pb
      CMAT, PTR :: Na,Nb
      VEC, PTR  :: PV,NN
      INT :: n, x,y,z
      DBL :: Gamma
      CDBL :: I
      ARCHIVE :: archive
      ENSURE( .atom.basis_resolved, "no basis set")
      .molecular_orbitals.destroy_ptr_part
      archive.set(.name,"molecular_orbitals")
      archive.read(.molecular_orbitals, kind="general_complex")
      Gamma = 5.73416d-17
      PV.create(.n_atom)
      pt.create(.n_atom,3)
      .atom.get_coordinates(pt)
      Pa.create(.n_atom);   Pb.create(.n_atom)
      Na.create(.n_atom,3); Nb.create(.n_atom,3)
      I = (ZERO,ONE)
      .out.set_dbl_style("d")
      x = 1; y = 2; z = 3
      PV = ZERO
      do n = 1,.n_e
         .make_orbital_grid(Pa,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
         .make_orbital_grid(Pb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
         .make_nabla_orbital_grid(Na,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt) 
         .make_nabla_orbital_grid(Nb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt) 
         PV(:) = PV(:) &
               + I*conjg(Nb(:,x))*Pa(:) + I*conjg(Na(:,x))*Pb(:) &
               - I*conjg(Pb(:))*Na(:,x) - I*conjg(Pa(:))*Nb(:,x) &
               +   conjg(Nb(:,y))*Pa(:) -   conjg(Na(:,y))*Pb(:) &
               +   conjg(Pb(:))*Na(:,y) -   conjg(Pa(:))*Nb(:,y) &
               + I*conjg(Na(:,z))*Pa(:) - I*conjg(Nb(:,z))*Pb(:) &
               - I*conjg(Pa(:))*Na(:,z) + I*conjg(Pb(:))*Nb(:,z) 
      end
      PV = -HALF*Gamma*PV
      Nb.destroy; Na.destroy
      Pb.destroy; Pa.destroy
      pt.destroy
      NN.create(.n_atom)
      .atom.get_mean_neutron_numbers(NN)
      PV = PV*NN
      !
      .out.set_dbl_style("d")
      .out.flush
      .out.text("Contributions (by nucleus) to the parity-violating weak force energy shift term:")
      .out.flush
      .out.put(PV, format="column")
      .out.flush
      .out.show("Total contribution =", sum(PV) )
      .out.flush
      .out.text("Neutron numbers:")
      .out.flush
      .out.put(NN, format="column")
      .out.set_dbl_style("f")
      NN.destroy
      PV.destroy
      .molecular_orbitals.destroy_ptr_part
  end

  put_g_tensor_information
  ! Put the g-tensor shift information to the output.
  ! Reference: Jayatilaka, JCP 108, 7587 (1998)
     MAT, PTR :: S, Lx,Ly,Lz, Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, T
     CMAT, PTR :: HH,P
     DBL :: Sx,Sy,Sz,SS_net, Mx,My,Mz,MM_net
     DBL :: Qx,Qy,Qz,QQ_net, Tx,Ty,Tz,TT_net
     DBL :: Sx_ppm,Sy_ppm,Sz_ppm, Mx_ppm,My_ppm,Mz_ppm
     DBL :: Qx_ppm,Qy_ppm,Qz_ppm, Tx_ppm,Ty_ppm,Tz_ppm
     DBL :: fac, fx,fy,fz, total
     CDBL :: I
     INT :: m
     BIN :: int_width
     ARCHIVE :: archive
     .density_matrix.destroy_ptr_part
     archive.set(.name,"density_matrix")
     archive.read(.density_matrix, kind="general_complex")
     P => .density_matrix%general_complex
     HH.create(2*.n_bf,2*.n_bf) 
     I = (ZERO,ONE)
     ! Spin contribution
     S.create(.n_bf,.n_bf)
     .get_overlap_matrix(S)
     fac = G_FACTOR/FOUR
     HH = ZERO
     HH.beta_alpha_plus(S,factor=fac)
     HH.alpha_beta_plus(S,factor=fac)
     Sx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(S,factor=fac*I)
     HH.alpha_beta_plus(S,factor=-fac*I)
     Sy = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(S,factor=fac)
     HH.beta_beta_plus(S,factor=-fac)
     Sz = HH.trace_of_product(P)
     S.destroy
     m = .n_a - .n_b
     fx = m*fac*.quantization_axis(1)
     fy = m*fac*.quantization_axis(2)
     fz = m*fac*.quantization_axis(3)
     Sx_ppm = (Sx-fx)*4000000/m
     Sy_ppm = (Sy-fy)*4000000/m
     Sz_ppm = (Sz-fz)*4000000/m
     SS_net = Sx_ppm*.quantization_axis(1) + Sy_ppm*.quantization_axis(2) + Sz_ppm*.quantization_axis(3) 
     ! L contribution
     Lx.create(.n_bf,.n_bf)
     Ly.create(.n_bf,.n_bf)
     Lz.create(.n_bf,.n_bf)
     .get_L_matrices(Lx,Ly,Lz) 
     fac = HALF
     HH = ZERO
     HH.alpha_alpha_plus(Lx,factor=fac*I)
     HH.beta_beta_plus(Lx,factor=fac*I)
     Mx = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Ly,factor=fac*I)
     HH.beta_beta_plus(Ly,factor=fac*I)
     My = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Lz,factor=fac*I)
     HH.beta_beta_plus(Lz,factor=fac*I)
     Mz = HH.trace_of_product(P)
     Lz.destroy; Ly.destroy; Lx.destroy
     Mx_ppm = Mx*4000000/m
     My_ppm = My*4000000/m
     Mz_ppm = Mz*4000000/m
     MM_net = Mx_ppm*.quantization_axis(1) + My_ppm*.quantization_axis(2) + Mz_ppm*.quantization_axis(3) 
     ! 1 electron LS gauge contribution
     Qxx.create(.n_bf,.n_bf); Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf)
     Qyx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
     Qzx.create(.n_bf,.n_bf); Qzy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
     .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
     HH = ZERO
     HH.beta_alpha_plus(Qyy,factor=fac)
     HH.beta_alpha_plus(Qzz,factor=fac)
     HH.beta_alpha_plus(Qyx,factor=-I*fac)
     HH.alpha_alpha_plus(Qzx,factor=-fac)
     HH.beta_beta_plus(Qzx,factor=+fac)
     HH.make_hermitian
     Qx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(Qxx,factor=I*fac)
     HH.beta_alpha_plus(Qzz,factor=I*fac)
     HH.beta_alpha_plus(Qxy,factor=-fac)
     HH.alpha_alpha_plus(Qzy,factor=-fac)
     HH.beta_beta_plus(Qzy,factor=+fac)
     HH.make_hermitian
     Qy = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Qxx,factor=fac)
     HH.alpha_alpha_plus(Qyy,factor=fac)
     HH.beta_beta_plus(Qxx,factor=-fac)
     HH.beta_beta_plus(Qyy,factor=-fac)
     HH.beta_alpha_plus(Qxz,factor=-fac)
     HH.beta_alpha_plus(Qyz,factor=-I*fac)
     HH.make_hermitian
     Qz = HH.trace_of_product(P)
     Qzz.destroy; Qzy.destroy; Qzx.destroy
     Qyz.destroy; Qyy.destroy; Qyx.destroy
     Qxz.destroy; Qxy.destroy; Qxx.destroy
     Qx_ppm = Qx*4000000/m
     Qy_ppm = Qy*4000000/m
     Qz_ppm = Qz*4000000/m
     QQ_net = Qx_ppm*.quantization_axis(1) + Qy_ppm*.quantization_axis(2) + Qz_ppm*.quantization_axis(3) 
     ! Relativistic kinetic energy contribution
     T.create(.n_bf,.n_bf)
     .get_kinetic_matrix(T) 
     fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU**2)
     HH = ZERO
     HH.beta_alpha_plus(T,factor=fac)
     HH.alpha_beta_plus(T,factor=fac)
     Tx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(T,factor=I*fac)
     HH.alpha_beta_plus(T,factor=-I*fac)
     Ty = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(T,factor=fac)
     HH.beta_beta_plus(T,factor=-fac)
     Tz = HH.trace_of_product(P)
     T.destroy
     HH.destroy
     .density_matrix.destroy_ptr_part
     Tx_ppm = Tx*4000000/m
     Ty_ppm = Ty*4000000/m
     Tz_ppm = Tz*4000000/m
     TT_net = Tx_ppm*.quantization_axis(1) + Ty_ppm*.quantization_axis(2) + Tz_ppm*.quantization_axis(3) 
     !
     .out.set_dbl_style("d")
     .out.flush
     .out.text("Contribution to g-tensor shift:")
     .out.flush
     .out.dash(int_fields=1,dbl_fields=2)
     .out.tab(int_fields=1); .out.put("<value>"); .out.put("shift/ppm"); .out.flush
     .out.dash(int_fields=1,dbl_fields=2)
     .out.text("Spin term:")
     .out.put("S_x",int_width)
     .out.set_dbl_style("d"); .out.put(Sx)
     .out.set_dbl_style("f"); .out.put(Sx_ppm); .out.flush
     .out.put("S_y",int_width)
     .out.set_dbl_style("d"); .out.put(Sy)
     .out.set_dbl_style("f"); .out.put(Sy_ppm); .out.flush
     .out.put("S_z",int_width)
     .out.set_dbl_style("d"); .out.put(Sz);
     .out.set_dbl_style("f"); .out.put(Sz_ppm); .out.flush
     .out.put("Net",int_width); .out.tab(dbl_fields=1); .out.put(SS_net); .out.flush
     .out.text("Angular momentum term:")
     .out.put("L_x",int_width)
     .out.set_dbl_style("d"); .out.put(Mx);
     .out.set_dbl_style("f"); .out.put(Mx_ppm); .out.flush
     .out.put("L_y",int_width)
     .out.set_dbl_style("d"); .out.put(My);
     .out.set_dbl_style("f"); .out.put(My_ppm); .out.flush
     .out.put("L_z",int_width)
     .out.set_dbl_style("d"); .out.put(Mz);
     .out.set_dbl_style("f"); .out.put(Mz_ppm); .out.flush
     .out.put("Net",int_width); .out.tab(dbl_fields=1); .out.put(MM_net); .out.flush
     .out.text("1-electron L:S gauge term:")
     .out.put("Q_x",int_width)
     .out.set_dbl_style("d"); .out.put(Qx);
     .out.set_dbl_style("f"); .out.put(Qx_ppm); .out.flush
     .out.put("Q_y",int_width)
     .out.set_dbl_style("d"); .out.put(Qy);
     .out.set_dbl_style("f"); .out.put(Qy_ppm); .out.flush
     .out.put("Q_z",int_width)
     .out.set_dbl_style("d"); .out.put(Qz);
     .out.set_dbl_style("f"); .out.put(Qz_ppm); .out.flush
     .out.put("Net",int_width); .out.tab(dbl_fields=1); .out.put(QQ_net); .out.flush
     .out.text("Relativistic B:S kinetic term:")
     .out.put("T_x",int_width)
     .out.set_dbl_style("d"); .out.put(Tx)
     .out.set_dbl_style("f"); .out.put(Tx_ppm); .out.flush
     .out.put("T_y",int_width)
     .out.set_dbl_style("d"); .out.put(Ty);
     .out.set_dbl_style("f"); .out.put(Ty_ppm); .out.flush
     .out.put("T_z",int_width) 
     .out.set_dbl_style("d"); .out.put(Tz);
     .out.set_dbl_style("f"); .out.put(Tz_ppm); .out.flush
     .out.put("Net",int_width); .out.tab(dbl_fields=1); .out.put(TT_net); .out.flush
     total = SS_net + MM_net + QQ_net + TT_net
     .out.flush
     .out.put("Total:",int_width); .out.tab(dbl_fields=1); .out.put(total)
     .out.flush
     .out.dash(int_fields=1,dbl_fields=2)
     .out.set_dbl_style("f")
  end

   integrate_property(make_property_grid) result (res)
   ! Integrate a scalar molecular property, which is represented by a subroutine 
   ! "make_property_grid" which returns "values" of the property in a vector,
   ! given "mol" as the molecule, and "pts" as a set of points. The result of 
   ! the integration is "res".
      interface
         make_property_grid(mol,values,pts)
            use TYPES
            MOL :: mol
            VEC :: values
            MAT :: pts
         end
      end
      DBL :: res
      ENSURE( .dftgrid.created,"no DFT grid information!")
      res = .dftgrid.integrate_molecular_property(make_property_grid,self)
   end

   integrate_rho_numerically
   ! Integrate the density numerically
      DBL :: res
      res = .integrate_property( make_density_grid_1)
      .out.show("numerically integrated charge =",res)
   end

!  nuclear_potential(values,pts)
!  ! Calculate the nuclear potential "values" of a given set of "pts".
!  ! This is usefule for numerical integration of nuclear attraction integrals.
!     VEC :: values
!     MAT :: pts
!     INT :: n_pts,n,i
!     DBL :: Z_n,r_ni
!     VEC(3) :: pos
!     n_pts = size(pts,1)
!     values = ZERO
!     do n = 1,.n_atom
!        Z_n = .atom(n)%atomic_number
!        pos = .atom(n)%pos
!        do i = 1,n_pts
!           r_ni = pos.distance_to(pts(i,:))
!           values(i) = values(i) - Z_n/r_ni
!        end
!     end
!  end

! make_na_matrix
! ! Calculate the nuclear attraction matrix "Z" numerically
!   MAT, PTR :: Z
!   MAT, PTR :: ZZ
!   INT :: q,fa,la,fb,lb
!   SHELL2 :: shell
!   ENSURE( .atom.created,  "no atom list")
!   ENSURE( .atom.basis_resolved, "no basis set")
!   Z.create(.n_bf,.n_bf)
!   Z = ZERO
!   do q = 1,.n_shell_pairs
!      .get_shell_pair(q,shell,fa,la,fb,lb)
!      ZZ.create(shell%a%n_comp,shell%b%n_comp)
!      .dftgrid.make_matrix_elements_of(nuclear_potential,self,shell,ZZ)
!      Z(fa:la,fb:lb) = Z(fa:la,fb:lb) + ZZ
!      ZZ.destroy
!      shell.destroy_ptr_part
!   end
!   Z.make_symmetric
!   .out.text("Z numerical")
!   .out.put(Z)
!   Z = ZERO
!   .out.text("Z analytical")
!   .get_nuclear_matrix(Z)
!   .out.put(Z)
!   Z.destroy
! end

!  ZORA_potential(values,pts)
!  ! Calculate the one electron ZORA potential "values" of a given set of "pts".
!  ! This is useful for numerical integration.
!     VEC :: values
!     MAT :: pts
!     DBL :: c2
!     .nuclear_potential(values,pts)
!     c2 = ONE/(SPEED_OF_LIGHT_AU**2)
!     values = ONE/(TWO - c2*values)
!  end

! make_ZORA_SO_matrix
! ! Calculate the ZORA spin orbit matrix numerically. This includes
! ! the relativitically modified kinetic energy integrals.
!   CMAT, PTR :: HH
!   MAT, PTR  :: W
!   MAT4, PTR :: ZORA ,SO
!   INT :: q,fa,la,fb,lb, k,l,a,b, x,y,z
!   DBL  :: fac
!   CDBL :: I
!   SHELL2 :: shell
!   ENSURE( .atom.created,  "no atom list")
!   ENSURE( .atom.basis_resolved, "no basis set")
!   HH.create(2*.n_bf,2*.n_bf)
!   ZORA.create(.n_bf,.n_bf,3,3)
!   ! Make the lower half of the ZORA spin orbit integrals
!   ZORA = ZERO
!   do q = 1,.n_shell_pairs
!      .get_shell_pair(q,shell,fa,la,fb,lb)
!      SO.create(shell%a%n_comp,shell%b%n_comp,3,3)
!      .dftgrid.make_SO_matrix_elements_of(ZORA_potential,self,shell,SO)
!      ZORA(fa:la,fb:lb,:,:) = ZORA(fa:la,fb:lb,:,:) + SO
!      SO.destroy
!      shell.destroy_ptr_part
!   end
!   ! Make the upper half of the ZORA spin orbit integrals
!   do k = 1,3
!   do l = 1,k
!   do a = 1,.n_bf
!   do b = 1,a-1
!      ZORA(b,a,l,k) = ZORA(a,b,k,l)
!   end
!   end
!   end
!   end
!   ! Assemble the ZORA contribution to the 1 electron hamiltonian
!   W.create(.n_bf,.n_bf)
!   x = 1; y = 2; z = 3
!   W = ZORA(:,:,x,x) + ZORA(:,:,y,y) + ZORA(:,:,z,z)
!   ! Scalar kinetic energy contribution
!   HH = ZERO
! ! HH.alpha_alpha_plus(W)
! ! HH.beta_beta_plus(W)
!   ! Spin-dependent spin-orbit contribution
!   I = (ZERO,ONE)
!   fac = -G_FACTOR/TWO  ! minus factor from two momenta
!   W = ZORA(:,:,y,z) - ZORA(:,:,z,y)
!   HH.beta_alpha_plus(W,factor=-I*fac)
!   W = ZORA(:,:,z,x) - ZORA(:,:,x,z)
!   HH.beta_alpha_plus(W,factor=fac)
!   W = ZORA(:,:,x,y) - ZORA(:,:,y,x)
!   HH.alpha_alpha_plus(W,factor=-I*fac)
!   HH.beta_beta_plus(W,factor=I*fac)
!   HH.make_hermitian
!         .out.set_dbl_width(15)
!         .out.set_dbl_precision(8)
!         .out.set_fields(7)
!         .out.text("ZORA, real")
!         .out.put(real(HH))
!         .out.text("ZORA, imag")
!         .out.put(aimag(HH))
!         stop
!   W.destroy
!   ZORA.destroy
!   HH.destroy
! end

   put_atom_kind_map
   ! Check the atom kind map routine   
      DBL :: res
      IVEC, PTR :: atom_kind,unique_atom
      INT :: n_atom,n_kind
      n_atom = .n_atom
      atom_kind.create(n_atom)
      .atom.make_atom_kind_list(atom_kind,n_kind)
      .out.text("atom kind")
      .out.put(atom_kind,"column")
      unique_atom.create(n_kind)
      .atom.make_unique_atom_list(unique_atom)
      .out.text("unique atom list")
      .out.put(unique_atom,"column")
      unique_atom.destroy
      atom_kind.destroy
   end

end 
