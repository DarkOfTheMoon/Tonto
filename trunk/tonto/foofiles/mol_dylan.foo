!-------------------------------------------------------------------------------
!
! MOL_dylan: dylan's test routines
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_DYLAN

   use TYPES
   use SYSTEM

   use STR
   use VEC
   use MAT
   use MAT3
   use MAT4
   use CVEC
   use CMAT
   use OPVEC
   use OPMAT

   use TEXTFILE
   use ARCHIVE

   use SHELL4, ONLY:destroy_ab_,destroy_cd_,get_ERI_
   use SHELL2, ONLY:make_nuclear_attraction_ints_
   use DFTGRID, ONLY:make_matrix_elements_of_
   use ATOMVEC
   use MOL

   implicit none

#  include "macros"
#  include "mol_dylan.int"

contains

  read_atom_groups
  ! Read in the .atom_group array
     INT :: n,i,length,line,item
     IVEC*   :: atoms
     IVEC(2) :: range
     STR :: word
     ENSURE(.atom.created,"no atom list")
     ENSURE(stdin.next_str=="{","Expecting open bracket symbol: {")
     line = stdin.line_number
     item = stdin.next_line_item
     n = 0
     do                             ! Loop over keywords
        nullify(atoms)
        stdin.read(word)
        word.to_lower_case
        select case (word)
           case("}");               exit 
           case("atom_group=");     stdin.read_ivec_ptr(atoms); n = n+1
           case("atom_range=");     stdin.read_ivec(range);     n = n+1
           case default;  DIE("unknown directive " // '"' // word.trim // '"')
        end
        if (atoms.created) atoms.destroy
     end
     !
     stdin.move_to_line(line)
     stdin.move_to_line_item(item)
     .atom_group.create(n)
     n = 0
     do                             ! Loop over keywords
        stdin.read(word)
        word.to_lower_case
        select case (word)
           case("}");               exit 
           case("atom_group=")
              n = n+1
              stdin.read_ivec_ptr(.atom_group(n).vec)
              ENSURE(all(.atom_group(n).vec>0),       "non-positive atom indices!")
              ENSURE(all(.atom_group(n).vec<=.n_atom),"Some stom indices too large!")
           case("atom_range=")
              n = n+1
              stdin.read_ivec(range)
              length = range(2) - range(1) + 1
              ENSURE(length>=1,"non-positive atom group range!")
              .atom_group(n).vec.create(length)
              .atom_group(n).vec = [ (i, i=range(1),range(2)) ]
        end
     end 
     .put_atom_groups
  end

  put_atom_groups
  ! Out out the .atom_group info array
     INT :: n,i
     ENSURE(.atom_group.created,"no atom group information")
     stdout.save
     stdout.set_int_width(3)
     stdout.set_fields(25)
     stdout.set_labels(FALSE)
     stdout.text(" ")
     stdout.text("Atom group information")
     stdout.text(" ")
     stdout.show("n_groups =",size(.atom_group))
     do n = 1,size(.atom_group)
        stdout.put_text("group "//n.to_str.trim//"  =")
        do i = 1,size(.atom_group(n).vec)
           stdout.put(.atom_group(n).vec(i))
        end
        stdout.flush
     end
     stdout.unsave
  end

  put_energy_decomposition
  ! Put out the energy decomposition specified in the .atom_group array
     MAT* :: T,Z,C,K,P,E_T,E_Z,E_C,E_K
     INT :: n_group,i,j,ia,ib,a,b, fa,la,fb,lb
     DBL :: fac
     STR :: unit
     ARCHIVE :: archive
     ENSURE(.atom_group.created,"no atom group information")
     archive.set(.name,"density_matrix,restricted")
     ENSURE(archive.exists,"no density matrix")
     P.create(.n_bf,.n_bf)
     archive.read(P)
     .density_matrix.create("restricted")
     .density_matrix.restricted = P
     T.create(.n_bf,.n_bf); .get_kinetic_matrix(T)
     Z.create(.n_bf,.n_bf); .get_nuclear_matrix(Z)
     C.create(.n_bf,.n_bf)
     K.create(.n_bf,.n_bf); .make_r_JK_direct(C,K,P)
     .make_r_fock(direct=TRUE,core=FALSE,r12=TRUE) 
     n_group = size(.atom_group)
     E_T.create(n_group,n_group); E_T = ZERO
     E_Z.create(n_group,n_group); E_Z = ZERO
     E_C.create(n_group,n_group); E_C = ZERO
     E_K.create(n_group,n_group); E_K = ZERO
     do i = 1,n_group
     do j = 1,n_group
     do ia = 1,size(.atom_group(i).vec)
     do ib = 1,size(.atom_group(j).vec)
        a = .atom_group(i).vec(ia)
        b = .atom_group(j).vec(ib)
        fa = .first_basis_fn_for_atom(a)
        la = .last_basis_fn_for_atom(a)
        fb = .first_basis_fn_for_atom(b)
        lb = .last_basis_fn_for_atom(b)
        fac = ONE
      ! if (i/=j) fac = TWO
        E_T(i,j) = E_T(i,j) + fac*T(fa:la,fb:lb).trace_product_with(P(fb:lb,fa:la))
        E_Z(i,j) = E_Z(i,j) + fac*Z(fa:la,fb:lb).trace_product_with(P(fb:lb,fa:la))
        E_C(i,j) = E_C(i,j) + fac*C(fa:la,fb:lb).trace_product_with(P(fb:lb,fa:la))
        E_K(i,j) = E_K(i,j) - fac*K(fa:la,fb:lb).trace_product_with(P(fb:lb,fa:la))
     end
     end
     end
     end
     E_C = HALF*E_C
     E_K = HALF*HALF*E_K
     stdout.text(" ")
     stdout.text("F:")
     stdout.put(.fock_matrix.restricted)
     stdout.text(" ")
     stdout.text("C-K/2:")
     stdout.put(C-HALF*K)
     stdout.text(" ")
     stdout.text("Energy decomposition in AU ...")
     stdout.text(" ")
     stdout.text("Kinetic interaction terms")
     stdout.put(E_T)
     stdout.text(" ")
     stdout.text("Nuclear attraction interaction terms")
     stdout.put(E_Z)
     stdout.text(" ")
     stdout.text("Coulomb repulsion interaction terms")
     stdout.put(E_C)
     stdout.text(" ")
     stdout.text("Exchange interaction terms")
     stdout.put(E_K)
     stdout.text(" ")
     fac = sum(E_T+E_Z+E_C+E_K)
     stdout.show("SCF electronic energy =",fac)
     stdout.show("SCF energy            =",fac+.nuclear_energy)
     stdout.show("Kinetic energy        =",sum(E_T))
     !
     unit = "kcal/mol"
     fac = unit.conversion_factor
     E_T = fac*E_T
     E_Z = fac*E_Z
     E_C = fac*E_C
     E_K = fac*E_K
     stdout.text(" ")
     stdout.text("Energy decomposition in kcal/mol ...")
     stdout.text(" ")
     stdout.text("Kinetic interaction terms")
     stdout.put(E_T)
     stdout.text(" ")
     stdout.text("Nuclear attraction interaction terms")
     stdout.put(E_Z)
     stdout.text(" ")
     stdout.text("Coulomb repulsion interaction terms")
     stdout.put(E_C)
     stdout.text(" ")
     stdout.text("Exchange interaction terms")
     stdout.put(E_K)
     stdout.text(" ")
     E_K.destroy
     E_C.destroy
     E_Z.destroy
     E_T.destroy
     K.destroy
     C.destroy
     Z.destroy
     T.destroy
  end

  put_energy_partition
  ! Put out the energy decomposition specified in the .atom_group array
  ! This routine calculates quadricentric contributions which are
  ! comparable to the Fischer-Kollmar decomposition.
     MAT*  :: T,Z,ZZ,C,K,P,W,E_T,E_Z, EE
     MAT3* :: E_ZZ
     MAT4* :: E_C,E_K
     INT :: n_group,x,y,i,j
     DBL :: fac
     STR :: unit
     ARCHIVE :: archive
     DBL :: kinetic_energy,nuclear_attraction,nuclear_repulsion
     DBL :: coulomb_repulsion,net_coulomb,bicentric_exchange
     DBL :: exchange_attraction,total_interaction
     ENSURE(.atom_group.created,"no atom group information")
     archive.set(.name,"density_matrix,restricted")
     ENSURE(archive.exists,"no density matrix")
     P.create(.n_bf,.n_bf)
     archive.read(P)
     W.create(.n_bf,.n_bf)
     T.create(.n_bf,.n_bf); .get_kinetic_matrix(T)
     Z.create(.n_bf,.n_bf); .get_nuclear_matrix(Z)
     n_group = size(.atom_group)
     E_T.create(n_group,n_group); E_T = ZERO
     E_Z.create(n_group,n_group); E_Z = ZERO
     E_C.create(n_group,n_group,n_group,n_group); E_C = ZERO
     E_K.create(n_group,n_group,n_group,n_group); E_K = ZERO
     E_ZZ.create(n_group,n_group,n_group); E_ZZ = ZERO
     ZZ.create(.n_bf,.n_bf)
        do i = 1,n_group
        do j = 1,i
           W = ZERO
           .atom_group_AO_subspace_set(W,P,i,j)
           if (i/=j) &
           .atom_group_AO_subspace_set(W,P,j,i)
           E_T(i,j) = T.trace_product_with(W)
           E_Z(i,j) = Z.trace_product_with(W)
           do x = 1,n_group
              .make_nuclear_matrix(ZZ,.atom_group(x).vec)
              E_ZZ(i,j,x) = ZZ.trace_product_with(W)
           end
        end
        end
     ZZ.destroy
     C.create(.n_bf,.n_bf)
     K.create(.n_bf,.n_bf)
     do x = 1,n_group
     do y = 1,x
        .make_r_JK_group(C,K,P,x,y)
        do i = 1,n_group
        do j = 1,i
           W = ZERO
           .atom_group_AO_subspace_set(W,P,i,j)
           if (i/=j) &
           .atom_group_AO_subspace_set(W,P,j,i)
           E_C(i,j,x,y) =  C.trace_product_with(W)
           E_K(i,j,x,y) = -K.trace_product_with(W)
        end
        end
     end
     end
     K.destroy
     C.destroy
     E_C = HALF*E_C
     E_K = HALF*HALF*E_K
     EE.create(n_group,n_group)
     !
     stdout.text(" ")
     fac = sum(E_T+E_Z) + sum(E_C+E_K)
     stdout.show("SCF electronic energy =",fac)
     stdout.show("SCF energy            =",fac+.nuclear_energy)
     stdout.show("Kinetic energy        =",sum(E_T))
!    stdout.text(" ")
!    stdout.text("Energy decomposition in AU ...")
!    stdout.text(" ")
!    stdout.text("Kinetic interaction terms")
!    stdout.put(E_T)
!    stdout.text(" ")
!    stdout.text("Nuclear attraction interaction terms")
!    stdout.put(E_Z)
!    stdout.text(" ")
!    stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
!    stdout.put(E_ZZ(:,:,1))
!    stdout.text(" ")
!    stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
!    stdout.put(E_ZZ(:,:,2))
!    EE(1,1) = .atom(.atom_group(1).vec).nuclear_energy
!    EE(2,2) = .atom(.atom_group(2).vec).nuclear_energy
!    EE(2,1) = .atom.nuclear_energy - EE(1,1) - EE(2,2)
!    EE(1,2) = ZERO
!    stdout.text(" ")
!    stdout.text("Nuclear nuclear repulsion")
!    stdout.put(EE)
!    EE(1,1) = E_C(1,1,1,1)
!    EE(2,1) = E_C(2,2,1,1)
!    EE(1,2) = E_C(1,1,2,2)
!    EE(2,2) = E_C(2,2,2,2)
!    stdout.text(" ")
!    stdout.text("Diagonal Coulomb repulsion interaction terms")
!    stdout.put(EE)
!    EE(1,1) = E_C(1,2,1,1)
!    EE(2,1) = E_C(2,1,1,1)
!    EE(1,2) = E_C(1,2,2,2)
!    EE(2,2) = E_C(2,1,2,2)
!    stdout.text(" ")
!    stdout.text("Semi diagonal Coulomb repulsion interaction terms")
!    stdout.put(EE)
!    EE(1,1) = E_C(1,2,1,2)
!    EE(2,1) = E_C(2,1,1,2)
!    EE(1,2) = E_C(1,2,2,1)
!    EE(2,2) = E_C(2,1,2,1)
!    stdout.text(" ")
!    stdout.text("Off diagonal Coulomb repulsion interaction terms")
!    stdout.put(EE)
!    stdout.text(" ")
!    stdout.text("All Coulomb repulsion interaction terms")
!    stdout.put(E_C)
!    EE(1,1) = E_K(1,1,1,1)
!    EE(2,1) = E_K(2,2,1,1)
!    EE(1,2) = E_K(1,1,2,2)
!    EE(2,2) = E_K(2,2,2,2)
!    stdout.text(" ")
!    stdout.text("Diagonal exchange interaction terms")
!    stdout.put(EE)
!    EE(1,1) = E_K(1,2,1,1)
!    EE(2,1) = E_K(2,1,1,1)
!    EE(1,2) = E_K(1,2,2,2)
!    EE(2,2) = E_K(2,1,2,2)
!    stdout.text(" ")
!    stdout.text("Semi diagonal exchange interaction terms")
!    stdout.put(EE)
!    EE(1,1) = E_K(1,2,1,2)
!    EE(2,1) = E_K(2,1,1,2)
!    EE(1,2) = E_K(1,2,2,1)
!    EE(2,2) = E_K(2,1,2,1)
!    stdout.text(" ")
!    stdout.text("Off diagonal exchange interaction terms")
!    stdout.put(EE)
!    stdout.text(" ")
!    stdout.text("All exchange interaction terms")
!    stdout.put(E_K)
     !
     unit = "kcal/mol"
     fac = unit.conversion_factor
     E_T = fac*E_T
     E_Z = fac*E_Z
     E_C = fac*E_C
     E_K = fac*E_K
     E_ZZ = fac*E_ZZ
     stdout.text(" ")
     stdout.text("Energy decomposition in kcal/mol ...")
     stdout.text(" ")
     stdout.text("Kinetic interaction terms")
     stdout.put(E_T)
     stdout.text(" ")
     stdout.text("Nuclear attraction interaction terms")
     stdout.put(E_Z)
     stdout.text(" ")
     stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
     stdout.put(E_ZZ(:,:,1))
     stdout.text(" ")
     stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
     stdout.put(E_ZZ(:,:,2))
     EE(1,1) = fac*.atom(.atom_group(1).vec).nuclear_energy
     EE(2,2) = fac*.atom(.atom_group(2).vec).nuclear_energy
     nuclear_repulsion = fac*.atom.nuclear_energy - EE(1,1) - EE(2,2)
     EE(2,1) = nuclear_repulsion
     EE(1,2) = ZERO
     stdout.text(" ")
     stdout.text("Nuclear nuclear repulsion")
     stdout.put(EE)
     EE(1,1) = E_C(1,1,1,1)
     EE(2,1) = E_C(2,2,1,1)
     EE(1,2) = E_C(1,1,2,2)
     EE(2,2) = E_C(2,2,2,2)
     stdout.text(" ")
     stdout.text("Diagonal Coulomb repulsion interaction terms")
     stdout.put(EE)
     EE(1,1) = E_C(1,2,1,1)
     EE(2,1) = E_C(2,1,1,1)
     EE(1,2) = E_C(1,2,2,2)
     EE(2,2) = E_C(2,1,2,2)
     stdout.text(" ")
     stdout.text("Semi diagonal Coulomb repulsion interaction terms")
     stdout.put(EE)
     EE(1,1) = E_C(1,2,1,2)
     EE(2,1) = E_C(2,1,1,2)
     EE(1,2) = E_C(1,2,2,1)
     EE(2,2) = E_C(2,1,2,1)
     stdout.text(" ")
     stdout.text("Off diagonal Coulomb repulsion interaction terms")
     stdout.put(EE)
     stdout.text(" ")
     stdout.text("All Coulomb repulsion interaction terms")
     stdout.put(E_C)
     EE(1,1) = E_K(1,1,1,1)
     EE(2,1) = E_K(2,2,1,1)
     EE(1,2) = E_K(1,1,2,2)
     EE(2,2) = E_K(2,2,2,2)
     stdout.text(" ")
     stdout.text("Diagonal exchange interaction terms")
     stdout.put(EE)
     EE(1,1) = E_K(1,2,1,1)
     EE(2,1) = E_K(2,1,1,1)
     EE(1,2) = E_K(1,2,2,2)
     EE(2,2) = E_K(2,1,2,2)
     stdout.text(" ")
     stdout.text("Semi diagonal exchange interaction terms")
     stdout.put(EE)
     EE(1,1) = E_K(1,2,1,2)
     EE(2,1) = E_K(2,1,1,2)
     EE(1,2) = E_K(1,2,2,1)
     EE(2,2) = E_K(2,1,2,1)
     stdout.text(" ")
     stdout.text("Off diagonal exchange interaction terms")
     stdout.put(EE)
     stdout.text(" ")
     stdout.text("All exchange interaction terms")
     stdout.put(E_K)
     kinetic_energy = E_T(2,1)
     nuclear_attraction = sum(E_Z) - E_ZZ(1,1,1) - E_ZZ(2,2,2)
     coulomb_repulsion = sum(E_C) - E_C(1,1,1,1) - E_C(2,2,2,2)
     net_coulomb = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
     bicentric_exchange = E_K(1,1,2,2) + E_K(2,2,1,1)
     exchange_attraction = sum(E_K) - E_K(1,1,1,1) - E_K(2,2,2,2)
     total_interaction = kinetic_energy + net_coulomb + exchange_attraction
     stdout.text(" ")
     stdout.text("Interaction energies for "//trim(.name)//":")
     stdout.text(" ")
     stdout.show("Kinetic energy     =",kinetic_energy)
     stdout.show("Exchange energy    =",exchange_attraction)
     stdout.show("Kinetic + Exhange  =",kinetic_energy+exchange_attraction)
     stdout.show("Bicentric Exchange =",bicentric_exchange)
     stdout.show("Net Coulomb energy =",net_coulomb)
     stdout.show("Total int. energy  =",total_interaction)
     EE.destroy
     E_ZZ.destroy
     E_K.destroy
     E_C.destroy
     E_Z.destroy
     E_T.destroy
     Z.destroy
     T.destroy
     W.destroy
     P.destroy
  end

  put_ortho_energy_partition
  ! Put out the energy decomposition specified in the .atom_group array
  ! This routine calculates quadricentric contributions which are
  ! comparable to the Fischer-Kollmar decomposition in an orthogonalised
  ! AO basis set
     MAT*  :: T,Z,ZZ,C,K,P,PP,W,E_T,E_Z, S,Sph,Smh, EE
     MAT3* :: E_ZZ
     MAT4* :: E_C,E_K
     INT :: n_group,x,y,i,j,a,b, fa,la,fb,lb
     DBL :: fac,fac_ij,fac_xy
     STR :: unit
     ARCHIVE :: archive
     DBL :: kinetic_energy,nuclear_attraction,nuclear_repulsion
     DBL :: coulomb_repulsion,net_coulomb,bicentric_exchange
     DBL :: exchange_attraction,total_interaction
     ENSURE(.atom_group.created,"no atom group information")
     archive.set(.name,"density_matrix,restricted")
     ENSURE(archive.exists,"no density matrix")
     P.create(.n_bf,.n_bf)
     PP.create(.n_bf,.n_bf)
     archive.read(P)
     W.create(.n_bf,.n_bf)
     T.create(.n_bf,.n_bf); .get_kinetic_matrix(T)
     Z.create(.n_bf,.n_bf); .get_nuclear_matrix(Z)
     S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
     Sph.create(.n_bf,.n_bf); Sph.to_sqrt(S)
     Smh.create(.n_bf,.n_bf); Smh.to_inverse_sqrt(S)
     n_group = size(.atom_group)
     E_T.create(n_group,n_group); E_T = ZERO
     E_Z.create(n_group,n_group); E_Z = ZERO
     E_C.create(n_group,n_group,n_group,n_group); E_C = ZERO
     E_K.create(n_group,n_group,n_group,n_group); E_K = ZERO
     E_ZZ.create(n_group,n_group,n_group); E_ZZ = ZERO
     ZZ.create(.n_bf,.n_bf)
     PP = P
     PP.change_basis(Sph)
        do i = 1,n_group
        do j = 1,i
           W = ZERO
           .atom_group_AO_subspace_set(W,PP,i,j)
           if (i/=j) &
           .atom_group_AO_subspace_set(W,PP,j,i)
           W.change_basis(Smh)
           E_T(i,j) = T.trace_product_with(W)
           E_Z(i,j) = Z.trace_product_with(W)
           do x = 1,n_group
              .make_nuclear_matrix(ZZ,.atom_group(x).vec)
              E_ZZ(i,j,x) = ZZ.trace_product_with(W)
           end
        end
        end
     ZZ.destroy
     C.create(.n_bf,.n_bf)
     K.create(.n_bf,.n_bf)
     do x = 1,n_group
     do y = 1,x
        W = ZERO
        .atom_group_AO_subspace_set(W,PP,x,y)
        if (x/=y) &
        .atom_group_AO_subspace_set(W,PP,y,x)
        W.change_basis(Smh)
        .make_r_JK_nosym(C,K,W)
        do i = 1,n_group
        do j = 1,i
           W = ZERO
           .atom_group_AO_subspace_set(W,PP,i,j)
           if (i/=j) &
           .atom_group_AO_subspace_set(W,PP,j,i)
           W.change_basis(Smh)
           E_C(i,j,x,y) =  C.trace_product_with(W)
           E_K(i,j,x,y) = -K.trace_product_with(W)
        end
        end
     end
     end
     K.destroy
     C.destroy
     E_C = HALF*E_C
     E_K = HALF*HALF*E_K
     EE.create(n_group,n_group)
     !
     stdout.text(" ")
     fac = sum(E_T+E_Z) + sum(E_C+E_K)
     stdout.show("SCF electronic energy =",fac)
     stdout.show("SCF energy            =",fac+.nuclear_energy)
     stdout.show("Kinetic energy        =",sum(E_T))
     !
     unit = "kcal/mol"
     fac = unit.conversion_factor
     E_T = fac*E_T
     E_Z = fac*E_Z
     E_C = fac*E_C
     E_K = fac*E_K
     E_ZZ = fac*E_ZZ
     stdout.text(" ")
     stdout.text("Energy decomposition in kcal/mol ...")
     stdout.text(" ")
     stdout.text("Kinetic interaction terms")
     stdout.put(E_T)
     stdout.text(" ")
     stdout.text("Nuclear attraction interaction terms")
     stdout.put(E_Z)
     stdout.text(" ")
     stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
     stdout.put(E_ZZ(:,:,1))
     stdout.text(" ")
     stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
     stdout.put(E_ZZ(:,:,2))
     EE(1,1) = fac*.atom(.atom_group(1).vec).nuclear_energy
     EE(2,2) = fac*.atom(.atom_group(2).vec).nuclear_energy
     nuclear_repulsion = fac*.atom.nuclear_energy - EE(1,1) - EE(2,2)
     EE(2,1) = nuclear_repulsion
     EE(1,2) = ZERO
     stdout.text(" ")
     stdout.text("Nuclear nuclear repulsion")
     stdout.put(EE)
     EE(1,1) = E_C(1,1,1,1)
     EE(2,1) = E_C(2,2,1,1)
     EE(1,2) = E_C(1,1,2,2)
     EE(2,2) = E_C(2,2,2,2)
     stdout.text(" ")
     stdout.text("Diagonal Coulomb repulsion interaction terms")
     stdout.put(EE)
     EE(1,1) = E_C(1,2,1,1)
     EE(2,1) = E_C(2,1,1,1)
     EE(1,2) = E_C(1,2,2,2)
     EE(2,2) = E_C(2,1,2,2)
     stdout.text(" ")
     stdout.text("Semi diagonal Coulomb repulsion interaction terms")
     stdout.put(EE)
     EE(1,1) = E_C(1,2,1,2)
     EE(2,1) = E_C(2,1,1,2)
     EE(1,2) = E_C(1,2,2,1)
     EE(2,2) = E_C(2,1,2,1)
     stdout.text(" ")
     stdout.text("Off diagonal Coulomb repulsion interaction terms")
     stdout.put(EE)
     stdout.text(" ")
     stdout.text("All Coulomb repulsion interaction terms")
     stdout.put(E_C)
     EE(1,1) = E_K(1,1,1,1)
     EE(2,1) = E_K(2,2,1,1)
     EE(1,2) = E_K(1,1,2,2)
     EE(2,2) = E_K(2,2,2,2)
     stdout.text(" ")
     stdout.text("Diagonal exchange interaction terms")
     stdout.put(EE)
     EE(1,1) = E_K(1,2,1,1)
     EE(2,1) = E_K(2,1,1,1)
     EE(1,2) = E_K(1,2,2,2)
     EE(2,2) = E_K(2,1,2,2)
     stdout.text(" ")
     stdout.text("Semi diagonal exchange interaction terms")
     stdout.put(EE)
     EE(1,1) = E_K(1,2,1,2)
     EE(2,1) = E_K(2,1,1,2)
     EE(1,2) = E_K(1,2,2,1)
     EE(2,2) = E_K(2,1,2,1)
     stdout.text(" ")
     stdout.text("Off diagonal exchange interaction terms")
     stdout.put(EE)
     stdout.text(" ")
     stdout.text("All exchange interaction terms")
     stdout.put(E_K)
     kinetic_energy = E_T(2,1)
     nuclear_attraction = sum(E_Z) - E_ZZ(1,1,1) - E_ZZ(2,2,2)
     coulomb_repulsion = sum(E_C) - E_C(1,1,1,1) - E_C(2,2,2,2)
     net_coulomb = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
     bicentric_exchange = E_K(1,1,2,2) + E_K(2,2,1,1)
     exchange_attraction = sum(E_K) - E_K(1,1,1,1) - E_K(2,2,2,2)
     total_interaction = kinetic_energy + net_coulomb + exchange_attraction
     stdout.text(" ")
     stdout.text("Interaction energies for "//trim(.name)//":")
     stdout.text(" ")
     stdout.show("Kinetic energy     =",kinetic_energy)
     stdout.show("Exchange energy    =",exchange_attraction)
     stdout.show("Kinetic + Exhange  =",kinetic_energy+exchange_attraction)
     stdout.show("Bicentric Exchange =",bicentric_exchange)
     stdout.show("Net Coulomb energy =",net_coulomb)
     stdout.show("Total int. energy  =",total_interaction)
     EE.destroy
     E_ZZ.destroy
     E_K.destroy
     E_C.destroy
     E_Z.destroy
     E_T.destroy
     Smh.destroy
     Sph.destroy
     S.destroy
     Z.destroy
     T.destroy
     W.destroy
     PP.destroy
     P.destroy
  end

  atom_group_AO_subspace_set(P,Q,row_group,col_group)
  ! Set P=Q only for the block whose rows correspond to basis functions
  ! on the atoms in the atom group "row_group" and whose columns are
  ! on the atoms in the atom group "col_group", as given in the
  ! .atom_group array vector.
    MAT :: P,Q
    INT :: row_group,col_group
    INT :: i_a,i_b,a,b,fa,fb,la,lb
    ENSURE(size(P,1)==.n_bf,"wrong size for P")
    ENSURE(size(P,2)==.n_bf,"wrong size for P")
    ENSURE(size(Q,1)==.n_bf,"wrong size for Q")
    ENSURE(size(Q,2)==.n_bf,"wrong size for Q")
    ENSURE(.atom_group.created,"no atom group information")
    ENSURE(row_group<=size(.atom_group),"no such row group")
    ENSURE(col_group<=size(.atom_group),"no such column group")
    ENSURE(row_group>0,"row group index must be positive")
    ENSURE(col_group>0,"column group index must be positive")
    do i_a = 1,size(.atom_group(row_group).vec)
    do i_b = 1,size(.atom_group(col_group).vec)
      a = .atom_group(row_group).vec(i_a)
      b = .atom_group(col_group).vec(i_b)
      fa = .first_basis_fn_for_atom(a)
      fb = .first_basis_fn_for_atom(b)
      la = .last_basis_fn_for_atom(a)
      lb = .last_basis_fn_for_atom(b)
      P(fa:la,fb:lb) = Q(fa:la,fb:lb)
    end
    end
  end

  make_r_JK_group(J,K,P,row_group,col_group)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the 
  ! density matrix "P" which is non-zero only for rows belonging to basis
  ! functions on atoms in group "row_group" and also columns for basis functions
  ! on atoms in the "col_group", as specified in ".atom_group".
    MAT :: J,K,P
    INT :: row_group,col_group
    MAT* :: PP
    MAT4*   :: I
    VEC* :: max_I,max_P
    SHELL4 :: shell4
    INT :: ab,cd,i_a,i_b,i_c,i_d
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,factor,cutoff
    BIN :: skip
    ENSURE(.atom_group.created,"no atom group information")
    ENSURE(row_group<=size(.atom_group),"no such row group")
    ENSURE(col_group<=size(.atom_group),"no such column group")
    ENSURE(row_group>0,"row group index must be positive")
    ENSURE(col_group>0,"column group index must be positive")
    J = ZERO
    K = ZERO
    cutoff = SCFDATA_ERI_LIMIT
    PP.create(.n_bf,.n_bf)
    PP = ZERO
    .atom_group_AO_subspace_set(PP,P,row_group,col_group)
    if (row_group/=col_group) &
    .atom_group_AO_subspace_set(PP,P,col_group,row_group)
    max_I.create(.n_shell_pairs)
    max_P.create(.n_shell_pairs)
    .make_max_abab_integrals(max_I)
    .make_max_density_elements(max_P,PP)
    do ab = 1, .n_shell_pairs
      .get_shell_pair_indices(ab,i_a,i_b)    ! a & b shell indices.
      fa = .first_basis_fn_for_shell(i_a)
      fb = .first_basis_fn_for_shell(i_b)
      la = .last_basis_fn_for_shell(i_a)
      lb = .last_basis_fn_for_shell(i_b)
      .set_shell_quartet_ab(shell4,i_a,i_b)
      do cd = 1,ab
        .get_shell_pair_indices(cd,i_c,i_d)  ! c & d shell indices.
        fc = .first_basis_fn_for_shell(i_c)
        fd = .first_basis_fn_for_shell(i_d)
        lc = .last_basis_fn_for_shell(i_c)
        ld = .last_basis_fn_for_shell(i_d)
                                       ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
        skip = .schwarz_inequality_test(cutoff,ab,cd,i_a,i_b,i_c,i_d,max_P,max_I)
        if (skip) cycle
                                             ! calculate ab|cd
        .set_shell_quartet_cd(shell4,i_c,i_d)
        factor = ONE                         ! Evaluate the integrals'
        if (i_a==i_b) factor = HALF          ! coincidence factors
        if (i_c==i_d) factor = HALF * factor
        if (i_a==i_c AND i_b==i_d) factor = HALF * factor
        I.create(fa,la,fb,lb,fc,lc,fd,ld)
        shell4.get_ERI(I)
          do d = fd,ld
          do c = fc,lc
          do b = fb,lb
          do a = fa,la
           I_abcd = factor * I(a,b,c,d)
           J(a,b) = J(a,b) + I_abcd*PP(d,c) ! These are symmetric
           J(a,b) = J(a,b) + I_abcd*PP(c,d) 
           J(b,a) = J(b,a) + I_abcd*PP(d,c) 
           J(b,a) = J(b,a) + I_abcd*PP(c,d) 
           J(c,d) = J(c,d) + I_abcd*PP(b,a)
           J(c,d) = J(c,d) + I_abcd*PP(a,b)
           J(d,c) = J(d,c) + I_abcd*PP(b,a)
           J(d,c) = J(d,c) + I_abcd*PP(a,b)
           K(a,d) = K(a,d) + I_abcd*PP(b,c) ! These are asymmetric
           K(a,c) = K(a,c) + I_abcd*PP(b,d) 
           K(b,c) = K(b,c) + I_abcd*PP(a,d)
           K(b,d) = K(b,d) + I_abcd*PP(a,c)
           K(d,a) = K(d,a) + I_abcd*PP(c,b)
           K(c,a) = K(c,a) + I_abcd*PP(d,b)
           K(c,b) = K(c,b) + I_abcd*PP(d,a)
           K(d,b) = K(d,b) + I_abcd*PP(c,a)
          end
          end
          end
          end
        I.destroy
        shell4.destroy_cd
      end
      shell4.destroy_ab
    end
    max_P.destroy
    max_I.destroy
    PP.destroy
  end

  make_r_JK_nosym(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the 
  ! density matrix "P" which has no permutational symmetry.
    MAT :: J,K,P
    MAT4*   :: I
    VEC* :: max_I,max_P
    SHELL4 :: shell4
    INT :: ab,cd,i_a,i_b,i_c,i_d
    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
    DBL :: I_abcd,factor,P_dc,P_db,P_cb,cutoff
    DBL :: Jcd,Kbc,Kbd
    BIN :: skip
    J = ZERO
    K = ZERO
    cutoff = SCFDATA_ERI_LIMIT
    max_I.create(.n_shell_pairs)
    max_P.create(.n_shell_pairs)
    .make_max_abab_integrals(max_I)
    .make_max_density_elements(max_P,P)
    do ab = 1, .n_shell_pairs
      .get_shell_pair_indices(ab,i_a,i_b)    ! a & b shell indices.
      fa = .first_basis_fn_for_shell(i_a)
      fb = .first_basis_fn_for_shell(i_b)
      la = .last_basis_fn_for_shell(i_a)
      lb = .last_basis_fn_for_shell(i_b)
      .set_shell_quartet_ab(shell4,i_a,i_b)
      do cd = 1,ab
        .get_shell_pair_indices(cd,i_c,i_d)  ! c & d shell indices.
        fc = .first_basis_fn_for_shell(i_c)
        fd = .first_basis_fn_for_shell(i_d)
        lc = .last_basis_fn_for_shell(i_c)
        ld = .last_basis_fn_for_shell(i_d)
                                       ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
        skip = .schwarz_inequality_test(cutoff,ab,cd,i_a,i_b,i_c,i_d,max_P,max_I)
        if (skip) cycle
                                             ! calculate ab|cd
        .set_shell_quartet_cd(shell4,i_c,i_d)
        factor = ONE                         ! Evaluate the integrals'
        if (i_a==i_b) factor = HALF          ! coincidence factors
        if (i_c==i_d) factor = HALF * factor
        if (i_a==i_c AND i_b==i_d) factor = HALF * factor
        I.create(fa,la,fb,lb,fc,lc,fd,ld)
        shell4.get_ERI(I)
          do d = fd,ld
          do c = fc,lc
          do b = fb,lb
          do a = fa,la
           I_abcd = factor * I(a,b,c,d)
           J(a,b) = J(a,b) + I_abcd*P(d,c) ! These are symmetric
           J(a,b) = J(a,b) + I_abcd*P(c,d) 
           J(b,a) = J(b,a) + I_abcd*P(d,c) 
           J(b,a) = J(b,a) + I_abcd*P(c,d) 
           J(c,d) = J(c,d) + I_abcd*P(b,a)
           J(c,d) = J(c,d) + I_abcd*P(a,b)
           J(d,c) = J(d,c) + I_abcd*P(b,a)
           J(d,c) = J(d,c) + I_abcd*P(a,b)
           K(a,d) = K(a,d) + I_abcd*P(b,c) ! These are asymmetric
           K(a,c) = K(a,c) + I_abcd*P(b,d) 
           K(b,c) = K(b,c) + I_abcd*P(a,d)
           K(b,d) = K(b,d) + I_abcd*P(a,c)
           K(d,a) = K(d,a) + I_abcd*P(c,b)
           K(c,a) = K(c,a) + I_abcd*P(d,b)
           K(c,b) = K(c,b) + I_abcd*P(d,a)
           K(d,b) = K(d,b) + I_abcd*P(c,a)
          end
          end
          end
          end
        I.destroy
        shell4.destroy_cd
      end
      shell4.destroy_ab
    end
    max_P.destroy
    max_I.destroy
  end

  put_sylvian_csizmadia_tensors
  ! Put out the Sylvian-Csizmadia polarisability tensors.
  ! This routine will read the value of the Unsold denominator.
     MAT* :: Dx,Dy,Dz, P
     MAT* :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
     MAT* :: Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz
     INT :: x,y,z
     DBL :: delta,fac
     MAT(3,3) :: alpha
     MAT3(3,3,3) :: beta
     ENSURE(.density_matrix.created,"no density matrix")
     ENSURE( .atom.created, "no atom info")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     stdout.flush
     stdout.text("Sylvian-Csizmadia polarisability tensors")
     stdout.flush
     stdin.read(delta)
     stdout.show("Unsold denominator/a.u. =",delta)
     Dx.create(.n_bf,.n_bf); Dy.create(.n_bf,.n_bf); Dz.create(.n_bf,.n_bf)
     Qxx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
     Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
     Oxxx.create(.n_bf,.n_bf); Oyyy.create(.n_bf,.n_bf); Ozzz.create(.n_bf,.n_bf)
     Oxxy.create(.n_bf,.n_bf); Oxxz.create(.n_bf,.n_bf)
     Oyyx.create(.n_bf,.n_bf); Oyyz.create(.n_bf,.n_bf)
     Ozzx.create(.n_bf,.n_bf); Ozzy.create(.n_bf,.n_bf)
     Oxyz.create(.n_bf,.n_bf)
     .get_dipole_matrices(Dx,Dy,Dz)
     .get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
     .get_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
     .make_ao_density_matrix
     x = 1; y = 2; z = 3
     P => .density_matrix.restricted
     alpha(x,x) = P.trace_product_with(Qxx) - P.trace_product_with(Dx,P,Dx)
     alpha(y,y) = P.trace_product_with(Qyy) - P.trace_product_with(Dy,P,Dy)
     alpha(z,z) = P.trace_product_with(Qzz) - P.trace_product_with(Dz,P,Dz)
     alpha(y,x) = P.trace_product_with(Qxy) - P.trace_product_with(Dy,P,Dx)
     alpha(z,x) = P.trace_product_with(Qxz) - P.trace_product_with(Dz,P,Dx)
     alpha(z,y) = P.trace_product_with(Qyz) - P.trace_product_with(Dz,P,Dy)
     alpha.make_symmetric
     fac = FOUR/delta
     alpha = fac*alpha
     stdout.flush
     stdout.text("First polarisability:")
     stdout.flush
     stdout.put(alpha)
     beta(x,x,x) = P.trace_product_with(Oxxx) - THREE*P.trace_product_with(Dx,P,Qxx) &
                 + P.trace_product_with(Dx,P,Dx,P,Dx)
     beta(y,y,y) = P.trace_product_with(Oyyy) - THREE*P.trace_product_with(Dy,P,Qyy) &
                 + P.trace_product_with(Dy,P,Dy,P,Dy)
     beta(z,z,z) = P.trace_product_with(Ozzz) - THREE*P.trace_product_with(Dz,P,Qzz) &
                 + P.trace_product_with(Dz,P,Dz,P,Dz)
     beta(y,x,x) = P.trace_product_with(Oxxy) - TWO*P.trace_product_with(Dx,P,Qxy) &
                 - P.trace_product_with(Dy,P,Qxx) + P.trace_product_with(Dy,P,Dx,P,Dx)
     beta(z,x,x) = P.trace_product_with(Oxxz) - TWO*P.trace_product_with(Dx,P,Qxz) &
                 - P.trace_product_with(Dz,P,Qxx) + P.trace_product_with(Dz,P,Dx,P,Dx)
     beta(y,y,x) = P.trace_product_with(Oyyx) - TWO*P.trace_product_with(Dy,P,Qxy) &
                 - P.trace_product_with(Dx,P,Qyy) + P.trace_product_with(Dy,P,Dy,P,Dx)
     beta(z,y,x) = P.trace_product_with(Oxyz) - P.trace_product_with(Dz,P,Qxy) &
                 - P.trace_product_with(Dy,P,Qxz) - P.trace_product_with(Dx,P,Qyz) &
                 + P.trace_product_with(Dz,P,Dy,P,Dx)
     beta(z,z,x) = P.trace_product_with(Ozzx) - TWO*P.trace_product_with(Dz,P,Qxz) &
                 - P.trace_product_with(Dx,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dx)
     beta(z,y,y) = P.trace_product_with(Oyyz) - TWO*P.trace_product_with(Dy,P,Qyz) &
                 - P.trace_product_with(Dz,P,Qyy) + P.trace_product_with(Dz,P,Dy,P,Dy)
     beta(z,z,y) = P.trace_product_with(Ozzy) - TWO*P.trace_product_with(Dz,P,Qyz) &
                 - P.trace_product_with(Dy,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dy)
     beta.make_symmetric
     fac = 12.0d0/delta
     beta = fac*beta
     stdout.flush
     stdout.text("Second polarisability:")
     stdout.flush
     stdout.put(beta)
     Oxyz.destroy
     Ozzy.destroy; Ozzx.destroy
     Oyyz.destroy; Oyyx.destroy
     Oxxz.destroy; Oxxy.destroy
     Ozzz.destroy; Oyyy.destroy; Oxxx.destroy
     Qyz.destroy; Qxz.destroy; Qxy.destroy
     Qzz.destroy; Qyy.destroy; Qxx.destroy
     Dz.destroy; Dy.destroy; Dx.destroy
  end

  make_weak_force_energy_shift
  ! Make the expectation value of the parity-violating energy shift.
  ! Requires some archived molecular orbitals, general_complex kind.
  ! Reference: R. Zanasi and P. Lazzeretti, CPL 286, 240 (1998)
      MAT*  :: pt
      CVEC* :: Pa,Pb
      CMAT* :: Na,Nb
      VEC*  :: PV,NN
      INT :: n, x,y,z
      DBL :: Gamma
      CDBL :: I
      ARCHIVE :: archive
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      .molecular_orbitals.destroy_ptr_part
      archive.set(.name,"molecular_orbitals")
      archive.read(.molecular_orbitals, kind="general_complex")
      Gamma = 5.73416d-17
      PV.create(.n_atom)
      pt.create(.n_atom,3)
      .atom.get_coordinates(pt)
      Pa.create(.n_atom);   Pb.create(.n_atom)
      Na.create(.n_atom,3); Nb.create(.n_atom,3)
      I = (ZERO,ONE)
      stdout.set_dbl_style("d")
      x = 1; y = 2; z = 3
      PV = ZERO
      do n = 1,.n_e
         .make_orbital_grid(Pa,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
         .make_orbital_grid(Pb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
         .make_nabla_orbital_grid(Na,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
         .make_nabla_orbital_grid(Nb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
         PV(:) = PV(:) &
               + I*conjg(Nb(:,x))*Pa(:) + I*conjg(Na(:,x))*Pb(:) &
               - I*conjg(Pb(:))*Na(:,x) - I*conjg(Pa(:))*Nb(:,x) &
               +   conjg(Nb(:,y))*Pa(:) -   conjg(Na(:,y))*Pb(:) &
               +   conjg(Pb(:))*Na(:,y) -   conjg(Pa(:))*Nb(:,y) &
               + I*conjg(Na(:,z))*Pa(:) - I*conjg(Nb(:,z))*Pb(:) &
               - I*conjg(Pa(:))*Na(:,z) + I*conjg(Pb(:))*Nb(:,z)
      end
      PV = -HALF*Gamma*PV
      Nb.destroy; Na.destroy
      Pb.destroy; Pa.destroy
      pt.destroy
      NN.create(.n_atom)
      .atom.get_mean_neutron_numbers(NN)
      PV = PV*NN

      stdout.set_dbl_style("d")
      stdout.flush
      stdout.text("Contributions (by nucleus) to the parity-violating weak force energy shift term:")
      stdout.flush
      stdout.put(PV, format="column")
      stdout.flush
      stdout.show("Total contribution =", sum(PV) )
      stdout.flush
      stdout.text("Neutron numbers:")
      stdout.flush
      stdout.put(NN, format="column")
      stdout.set_dbl_style("f")
      NN.destroy
      PV.destroy
      .molecular_orbitals.destroy_ptr_part
  end

  put_g_tensor_information
  ! Put the g-tensor shift information to the output.
  ! Reference: Jayatilaka, JCP 108, 7587 (1998)
     MAT* :: S, Lx,Ly,Lz, Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, T
     CMAT* :: HH,P
     DBL :: Sx,Sy,Sz,SS_net, Mx,My,Mz,MM_net
     DBL :: Qx,Qy,Qz,QQ_net, Tx,Ty,Tz,TT_net
     DBL :: Sx_ppm,Sy_ppm,Sz_ppm, Mx_ppm,My_ppm,Mz_ppm
     DBL :: Qx_ppm,Qy_ppm,Qz_ppm, Tx_ppm,Ty_ppm,Tz_ppm
     DBL :: fac, fx,fy,fz, total
     VEC(3) :: quantization_axis
     CDBL :: I
     INT :: m
     BIN :: int_width
     ARCHIVE :: archive
     .density_matrix.destroy_ptr_part
     archive.set(.name,"density_matrix")
     archive.read(.density_matrix, kind="general_complex")
     P => .density_matrix%general_complex
     HH.create(2*.n_bf,2*.n_bf)
     I = (ZERO,ONE)
     quantization_axis = .scfdata.quantization_axis
     ! Spin contribution
     S.create(.n_bf,.n_bf)
     .get_overlap_matrix(S)
     fac = G_FACTOR/FOUR
     HH = ZERO
     HH.beta_alpha_plus(S,factor=fac)
     HH.alpha_beta_plus(S,factor=fac)
     Sx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(S,factor=fac*I)
     HH.alpha_beta_plus(S,factor=-fac*I)
     Sy = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(S,factor=fac)
     HH.beta_beta_plus(S,factor=-fac)
     Sz = HH.trace_of_product(P)
     S.destroy
     m = .n_a - .n_b
     fx = m*fac*quantization_axis(1)
     fy = m*fac*quantization_axis(2)
     fz = m*fac*quantization_axis(3)
     Sx_ppm = (Sx-fx)*4000000/m
     Sy_ppm = (Sy-fy)*4000000/m
     Sz_ppm = (Sz-fz)*4000000/m
     SS_net = Sx_ppm*quantization_axis(1) + Sy_ppm*quantization_axis(2) + Sz_ppm*quantization_axis(3)
     ! L contribution
     Lx.create(.n_bf,.n_bf)
     Ly.create(.n_bf,.n_bf)
     Lz.create(.n_bf,.n_bf)
     .get_L_matrices(Lx,Ly,Lz)
     fac = HALF
     HH = ZERO
     HH.alpha_alpha_plus(Lx,factor=-fac*I)  ! -I factor for the nabla part
     HH.beta_beta_plus(Lx,factor=-fac*I)
     Mx = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Ly,factor=-fac*I)
     HH.beta_beta_plus(Ly,factor=-fac*I)
     My = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Lz,factor=-fac*I)
     HH.beta_beta_plus(Lz,factor=-fac*I)
     Mz = HH.trace_of_product(P)
     Lz.destroy; Ly.destroy; Lx.destroy
     Mx_ppm = Mx*4000000/m
     My_ppm = My*4000000/m
     Mz_ppm = Mz*4000000/m
     MM_net = Mx_ppm*quantization_axis(1) + My_ppm*quantization_axis(2) + Mz_ppm*quantization_axis(3)
     ! 1 electron LS gauge contribution
     Qxx.create(.n_bf,.n_bf); Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf)
     Qyx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
     Qzx.create(.n_bf,.n_bf); Qzy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
     .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     fac = G_FACTOR/(TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
     HH = ZERO
     HH.beta_alpha_plus(Qyy,factor=fac)
     HH.beta_alpha_plus(Qzz,factor=fac)
     HH.beta_alpha_plus(Qyx,factor=-I*fac)
     HH.alpha_alpha_plus(Qzx,factor=-fac)
     HH.beta_beta_plus(Qzx,factor=+fac)
     HH.make_hermitian
     Qx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(Qxx,factor=I*fac)
     HH.beta_alpha_plus(Qzz,factor=I*fac)
     HH.beta_alpha_plus(Qxy,factor=-fac)
     HH.alpha_alpha_plus(Qzy,factor=-fac)
     HH.beta_beta_plus(Qzy,factor=+fac)
     HH.make_hermitian
     Qy = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Qxx,factor=fac)
     HH.alpha_alpha_plus(Qyy,factor=fac)
     HH.beta_beta_plus(Qxx,factor=-fac)
     HH.beta_beta_plus(Qyy,factor=-fac)
     HH.beta_alpha_plus(Qxz,factor=-fac)
     HH.beta_alpha_plus(Qyz,factor=-I*fac)
     HH.make_hermitian
     Qz = HH.trace_of_product(P)
     Qzz.destroy; Qzy.destroy; Qzx.destroy
     Qyz.destroy; Qyy.destroy; Qyx.destroy
     Qxz.destroy; Qxy.destroy; Qxx.destroy
     Qx_ppm = Qx*4000000/m
     Qy_ppm = Qy*4000000/m
     Qz_ppm = Qz*4000000/m
     QQ_net = Qx_ppm*quantization_axis(1) + Qy_ppm*quantization_axis(2) + Qz_ppm*quantization_axis(3)
     ! Relativistic kinetic energy contribution
     T.create(.n_bf,.n_bf)
     .get_kinetic_matrix(T)
     fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
     HH = ZERO
     HH.beta_alpha_plus(T,factor=fac)
     HH.alpha_beta_plus(T,factor=fac)
     Tx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(T,factor=I*fac)
     HH.alpha_beta_plus(T,factor=-I*fac)
     Ty = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(T,factor=fac)
     HH.beta_beta_plus(T,factor=-fac)
     Tz = HH.trace_of_product(P)
     T.destroy
     HH.destroy
     .density_matrix.destroy_ptr_part
     Tx_ppm = Tx*4000000/m
     Ty_ppm = Ty*4000000/m
     Tz_ppm = Tz*4000000/m
     TT_net = Tx_ppm*quantization_axis(1) + Ty_ppm*quantization_axis(2) + Tz_ppm*quantization_axis(3)

     stdout.set_dbl_style("d")
     int_width = TRUE
     stdout.flush
     stdout.text("Contribution to g-tensor shift:")
     stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.put("Term",int_width); stdout.put("<value>");
     stdout.put("shift/ppm"); stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.text("Spin term:")
     stdout.put("S_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sx)
     stdout.set_dbl_style("f"); stdout.put(Sx_ppm); stdout.flush
     stdout.put("S_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sy)
     stdout.set_dbl_style("f"); stdout.put(Sy_ppm); stdout.flush
     stdout.put("S_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sz);
     stdout.set_dbl_style("f"); stdout.put(Sz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(SS_net); stdout.flush
     stdout.text("Angular momentum term:")
     stdout.put("L_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Mx);
     stdout.set_dbl_style("f"); stdout.put(Mx_ppm); stdout.flush
     stdout.put("L_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(My);
     stdout.set_dbl_style("f"); stdout.put(My_ppm); stdout.flush
     stdout.put("L_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Mz);
     stdout.set_dbl_style("f"); stdout.put(Mz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(MM_net); stdout.flush
     stdout.text("1-electron L:S gauge term:")
     stdout.put("Q_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qx);
     stdout.set_dbl_style("f"); stdout.put(Qx_ppm); stdout.flush
     stdout.put("Q_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qy);
     stdout.set_dbl_style("f"); stdout.put(Qy_ppm); stdout.flush
     stdout.put("Q_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qz);
     stdout.set_dbl_style("f"); stdout.put(Qz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(QQ_net); stdout.flush
     stdout.text("Relativistic B:S kinetic term:")
     stdout.put("T_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Tx)
     stdout.set_dbl_style("f"); stdout.put(Tx_ppm); stdout.flush
     stdout.put("T_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Ty);
     stdout.set_dbl_style("f"); stdout.put(Ty_ppm); stdout.flush
     stdout.put("T_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Tz);
     stdout.set_dbl_style("f"); stdout.put(Tz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(TT_net); stdout.flush
     total = SS_net + MM_net + QQ_net + TT_net
     stdout.flush
     stdout.put("Total:",int_width); stdout.tab(dbl_fields=1); stdout.put(total)
     stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.set_dbl_style("f")
  end

!  make_pcc_b_field
!     INT :: n_pt,i,j,n, k
!     DBL :: aa,bb,cc
!     MAT* :: pt
!     CMAT3* :: dma
!     DBL :: re,im
!     n_pt = 59*75
!   ! n_pt = 25
!     pt.create(n_pt,3)
!     aa=7.4/sqrt(2.0)
!   ! aa=0.4/sqrt(2.0)
!     bb=0.2/sqrt(2.0)
!     n = 0
!     do i=1,75
!        cc=5.4
!   !    cc=0.6
!        do j=1,59
!           n = n+1
!           cc = cc - 0.2
!           pt(n,1)= aa
!           pt(n,2)=-aa
!           pt(n,3)= cc
!        end
!        aa = aa-bb
!     end
!     dma.create(160,160,4)
!     open(unit=99,file='opdens.c',form='formatted',status='old')
!     do i=1,160
!     do j=1,160
!        do k=1,4
!           read(99,*) re,im
!           dma(i,j,k) = cmplx(re,im)
!        enddo
!     enddo
!     enddo
!     close(99)
!     .density_matrix.destroy("general_complex")
!     .density_matrix.create(160,"general_complex")
!     .density_matrix.general_complex.alpha_alpha_set_to(dma(:,:,1))
!     .density_matrix.general_complex.alpha_beta_set_to(dma(:,:,2))
!     .density_matrix.general_complex.beta_alpha_set_to(dma(:,:,3))
!     .density_matrix.general_complex.beta_beta_set_to(dma(:,:,4))
!     dma.destroy
!     .make_b_field_grid(pt)
!     pt.destroy
!  end                                                                               
!
!   make_b_field_grid(pt)
!   ! Make the total b_field "b" on ".grid"
!      MAT :: pt
!      ARCHIVE :: archive
!      MAT* :: b,w
!      BIN :: complex
!      INT :: n_pt
!      ENSURE( .atom.bases_are_all_resolved, "no basis set")
!      ENSURE( .density_matrix.created, "no density matrix")
!      complex = .density_matrix.spinorbital_kind == "general_complex"
!      ENSURE(complex, "no general complex density matrix")
!      .make_spin_b_field_grid(pt)
!      .make_current_b_field_grid(pt)
!      n_pt = size(pt,1)
!      b.create(n_pt,3)
!      w.create(n_pt,3)
!      archive.set(.name,"spin_b_field_density_grid")
!      archive.read(b)
!      b = 0
!      archive.set(.name,"current_b_field_density_grid")
!      archive.read(w)
!      b = b + w
!      w.destroy
!      archive.set(.name,"b_field_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1)
!      archive.set(.name,"b_fie7d_norm_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
!      archive.set(.name,"b_field_density_grid,normalized,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
!      b.destroy
!   end
!
!   make_spin_b_field_grid(pt)
!   ! Make the b_field due to the spin density on ".grid"
!      MAT :: pt
!      ARCHIVE :: archive
!      MAT* :: b
!      BIN :: complex
!      INT :: n_pt
!      ENSURE( .atom.bases_are_all_resolved, "no basis set")
!      ENSURE( .density_matrix.created, "no density matrix")
!      complex = .density_matrix.spinorbital_kind == "general_complex"
!      ENSURE(complex, "no general complex density matrix")
!      n_pt = size(pt,1)
!      b.create(n_pt,3)
!      .make_spin_b_field_grid(b,.density_matrix.general_complex,pt)
!      archive.set(.name,"spin_b_field_density_grid")
!      archive.write(b)
!      archive.set(.name,"spin_b_field_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1)
!      archive.set(.name,"spin_b_field_norm_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
!      archive.set(.name,"spin_b_field_density_grid,normalized,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
!      b.destroy
!   end
!
!   make_spin_b_field_grid(bb,dens,pt)
!   ! Make the b_field "bb" due to the spin density on ".grid" using complex general 
!   ! AO density matrix "dens"
!      MAT :: bb,pt
!      CMAT, target :: dens
!      CMAT* :: Daa,Dba,Dbb
!      MAT* :: Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz
!      INT :: q,a,b,fa,fb,la,lb,k, n_pt
!      DBL :: fac
!      SHELL2 :: shell
!      ENSURE( .atom.created,  "no atom list")
!      ENSURE( .atom.bases_are_all_resolved, "no basis set")
!      n_pt = size(pt,1)
!      bb = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
!        Daa => dens(fb:lb,fa:la) ! alpha-alpha block
!        fb = fb + .n_bf
!        lb = lb + .n_bf
!        Dba => dens(fb:lb,fa:la) ! beta-alpha block
!        fa = fa + .n_bf
!        la = la + .n_bf
!        Dbb => dens(fb:lb,fa:la) ! beta-beta block
!        fac = ONE; if (a==b) fac=HALF
!        Mxx.create(shell.a.n_comp,shell.b.n_comp)
!        Mxy.create(shell.a.n_comp,shell.b.n_comp)
!        Mxz.create(shell.a.n_comp,shell.b.n_comp)
!        Myx.create(shell.a.n_comp,shell.b.n_comp)
!        Myy.create(shell.a.n_comp,shell.b.n_comp)
!        Myz.create(shell.a.n_comp,shell.b.n_comp)
!        Mzx.create(shell.a.n_comp,shell.b.n_comp)
!        Mzy.create(shell.a.n_comp,shell.b.n_comp)
!        Mzz.create(shell.a.n_comp,shell.b.n_comp)
!        do k = 1,n_pt
!          shell.make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,pt(k,:))
!          bb(k,1) = bb(k,1) + Mxx.trace_of_product( real(Dba))
!          bb(k,1) = bb(k,1) + Mxy.trace_of_product(aimag(Dba))
!          bb(k,1) = bb(k,1) + fac*Mxz.trace_of_product(real(Daa))
!          bb(k,1) = bb(k,1) - fac*Mxz.trace_of_product(real(Dbb))
!          bb(k,2) = bb(k,2) + Myx.trace_of_product( real(Dba))
!          bb(k,2) = bb(k,2) - Myy.trace_of_product(aimag(Dba))
!          bb(k,2) = bb(k,2) + fac*Myz.trace_of_product(real(Daa))
!          bb(k,2) = bb(k,2) - fac*Myz.trace_of_product(real(Dbb))
!          bb(k,3) = bb(k,3) + Mzx.trace_of_product( real(Dba))
!          bb(k,3) = bb(k,3) + Mzy.trace_of_product(aimag(Dba))
!          bb(k,3) = bb(k,3) + fac*Mzz.trace_of_product(real(Daa))
!          bb(k,3) = bb(k,3) - fac*Mzz.trace_of_product(real(Dbb))
!        end
!        Mzz.destroy; Mzy.destroy; Mzx.destroy
!        Myz.destroy; Myy.destroy; Myx.destroy
!        Mxz.destroy; Mxy.destroy; Mxx.destroy
!        shell.destroy_ptr_part
!      end
!      bb.zero_small_values(TOL(10))
!      fac = -G_FACTOR*HALF
!      bb = fac*bb
!   end
!
!   make_current_b_field_grid(pt)
!   ! Make the b_field due to the current density on ".grid"
!      MAT :: pt
!      ARCHIVE :: archive
!      MAT* :: b
!      BIN :: complex
!      INT :: n_pt
!      ENSURE( .atom.bases_are_all_resolved, "no basis set")
!      ENSURE( .density_matrix.created, "no density matrix")
!      .make_ao_density_matrix
!      complex = .density_matrix.spinorbital_kind.includes("complex")
!      ENSURE(complex, "no complex density matrix")
!      n_pt = size(pt,1)
!      b.create(n_pt,3)
!      .make_current_b_field_grid(b,.density_matrix.restricted_complex,pt)
!      archive.set(.name,"current_b_field_density_grid")
!      archive.write(b)
!      archive.set(.name,"current_b_field_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1)
!      archive.set(.name,"current_b_field_norm_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
!      archive.set(.name,"current_b_field_density_grid,normalized,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
!      b.destroy
!   end
!
!   make_current_b_field_grid(bb,dens,pt)
!   ! Make the b_field "bb" due to the paramagnetic current density on ".grid" using 
!   ! a complex AO density matrix "dens"
!      MAT :: bb,pt
!      CMAT, target :: dens
!      CMAT* :: Dba
!      MAT* :: Jx,Jy,Jz
!      INT :: q,a,b,fa,fb,la,lb,k, n_pt
!      DBL :: fac
!      SHELL2 :: shell
!      ENSURE( .atom.created,  "no atom list")
!      ENSURE( .atom.bases_are_all_resolved, "no basis set")
!      n_pt = size(pt,1)
!      bb = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
!        Dba => dens(fb:lb,fa:la) 
!        fac = ONE; if (a==b) fac=HALF
!        Jx.create(shell.a.n_comp,shell.b.n_comp)
!        Jy.create(shell.a.n_comp,shell.b.n_comp)
!        Jz.create(shell.a.n_comp,shell.b.n_comp)
!        do k = 1,n_pt
!          shell.make_magnetic_jp_ints(Jx,Jy,Jz,pt(k,:))
!          bb(k,1) = bb(k,1) + Jx.trace_of_product(aimag(Dba))
!          bb(k,2) = bb(k,2) + Jy.trace_of_product(aimag(Dba))
!          bb(k,3) = bb(k,3) + Jz.trace_of_product(aimag(Dba))
!        end
!        Jz.destroy; Jy.destroy; Jx.destroy
!        shell.destroy_ptr_part
!      end
!   !  bb.zero_small_values(TOL(10))
!      bb = -HALF*bb
!   end
!
!  make_pcc_structure_factors
!     MAT* :: S
!     MAT* :: mo,Smo
!     TEXTFILE* :: in
!     MAT* :: k_pts
!     CMAT3* :: ftnew,ft
!     CMAT* :: W
!     CMAT4* :: ftnew_nabla,ft_nabla
!     SHELL2* :: shell
!     INT :: n_refl,q,i,j
!     INT :: fa,la,fb,lb,a,b
!     DBL :: fac
!     mo.create(160,4)
!     in.create("mo35")
!     in.open_for_read
!     in.read(mo,order="by_column")
!     stdout.text("mo")
!     stdout.put(mo)
!
!     S.create(160,160)
!     .get_overlap_matrix(S)
!
!     Smo.create(4,4)
!     Smo.create(4,4)
!     S.change_basis(Smo,mo)
!     stdout.text("Smo")
!     stdout.put(Smo)
!
!     n_refl = .crystal%n_refl
!
!     k_pts.create(n_refl,3)
!     .crystal.make_k_pts(k_pts)
!
!     shell.create
!     ftnew.create(4,4,1)
!     ftnew = ZERO
!     do q = 1,.n_shell_pairs
!         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
!         ft.create(n_refl,shell%a%n_comp,shell%b%n_comp)
!         shell.make_ft(ft,k_pts)
!         fac = ONE
!         if (a==b) fac = HALF
!         do i = 1,n_refl
!            ftnew(:,:,i) = ftnew(:,:,i) + &
!               fac*matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) + &
!               fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) )
!         end
!         ft.destroy
!         shell.destroy_ptr_part
!     end
!
!     do i = 1,n_refl
!        stdout.put(ftnew(:,:,i))
!     end
!     ftnew.destroy
!
!     ftnew_nabla.create(4,4,3,1)
!     ftnew_nabla = ZERO
!     do q = 1,.n_shell_pairs
!         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
!         ft_nabla.create(n_refl,shell%a%n_comp,shell%b%n_comp,3)
!         shell.make_ft_nabla(ft_nabla,k_pts)
!         fac = ONE
!         if (a==b) fac = HALF
!         do i = 1,n_refl
!         do j = 1,3
!            ftnew_nabla(:,:,j,i) = ftnew_nabla(:,:,j,i) + &
!               fac*matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) - &
!               fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) )
!         end
!         end
!         ft_nabla.destroy
!         shell.destroy_ptr_part
!     end
!
!     do i = 1,n_refl
!     do j = 1,3
!         stdout.show("component =",j)
!         stdout.put(ftnew_nabla(:,:,j,i))
!     end
!     end
!     ftnew_nabla.destroy
!     shell.destroy
!  end
!
!  make_pcc_L_matrices
!     MAT* :: S
!     MAT* :: mo,Smo
!     MAT* :: Lx,Ly,Lz
!     MAT* :: Lxmo,Lymo,Lzmo
!     TEXTFILE* :: in
!     mo.create(160,4)
!     in.create("mo35")
!     in.open_for_read
!     in.read(mo,order="by_column")
!     stdout.text("mo")
!     stdout.put(mo)
!
!     S.create(160,160)
!     .get_overlap_matrix(S)
!
!     Smo.create(4,4)
!     Smo.create(4,4)
!     S.change_basis(Smo,mo)
!     stdout.text("Smo")
!     stdout.put(Smo)
!
!     Lx.create(.n_bf,.n_bf); Lx = ZERO
!     Ly.create(.n_bf,.n_bf); Ly = ZERO
!     Lz.create(.n_bf,.n_bf); Lz = ZERO
!     .make_L_matrices(Lx,Ly,Lz)
!
!   ! std_output.text("Lx")
!   ! std_output.put(Lx)
!   ! std_output.text("Ly")
!   ! std_output.put(Ly)
!   ! std_output.text("Lz")
!   ! std_output.put(Lz)
!
!     Lxmo.create(4,4)
!     Lymo.create(4,4)
!     Lzmo.create(4,4)
!     Lx.change_basis(Lxmo,mo)
!     Ly.change_basis(Lymo,mo)
!     Lz.change_basis(Lzmo,mo)
!
!     stdout.text("Lxmo")
!     stdout.put(Lxmo)
!     stdout.text("Lymo")
!     stdout.put(Lymo)
!     stdout.text("Lzmo")
!     stdout.put(Lzmo)
!     S.destroy
!     Smo.destroy
!     Lxmo.destroy; Lymo.destroy; Lzmo.destroy
!     Lx.destroy; Ly.destroy; Lz.destroy
!  end
!
!
!  test_ZORA_SO_matrices
!     MAT* :: SOx,SOy,SOz
!     MAT* :: ZOx,ZOy,ZOz, T
!     T.create(.n_bf,.n_bf)
!     SOx.create(.n_bf,.n_bf); SOy.create(.n_bf,.n_bf); SOz.create(.n_bf,.n_bf)
!     ZOx.create(.n_bf,.n_bf); ZOy.create(.n_bf,.n_bf); ZOz.create(.n_bf,.n_bf)
!     .get_nuclear_matrix(SOz)
!     .make_ENA_matrix(ZOz)
!     stdout.text("NA"); stdout.put(SOz)
!     stdout.text("numerical NA"); stdout.put(ZOz)
!     .get_spin_orbit_matrices(SOx,SOy,SOz)
!     .get_1e_ZORA_matrices(T,ZOx,ZOy,ZOz)
!     stdout.text("SOx"); stdout.put(SOx)
!     stdout.text("ZOx"); stdout.put(ZOx)
!     stdout.text("SOy"); stdout.put(SOy)
!     stdout.text("ZOy"); stdout.put(ZOy)
!     stdout.text("SOz"); stdout.put(SOz)
!     stdout.text("ZOz"); stdout.put(ZOz)
!     SOx.destroy; SOy.destroy; SOz.destroy
!     ZOx.destroy; ZOy.destroy; ZOz.destroy
!     T.destroy
!  end
!
!  test_dftgrid
!     MAT* :: Z,NZ,DZ
!     Z.create(.n_bf,.n_bf)
!     NZ.create(.n_bf,.n_bf)
!     DZ.create(.n_bf,.n_bf)
!     .make_nuclear_matrix(DZ,output=TRUE)
!     .make_nuclear_ints(Z)
!     .get_ENA_matrix(NZ)
!     stdout.text("DZ"); stdout.put(DZ)
!     stdout.text("Z"); stdout.put(Z)
!     stdout.text("NZ"); stdout.put(NZ)
!     .test_num
!     Z.destroy; NZ.destroy; DZ.destroy
!  end
!
!  make_nuclear_ints(Z,output)
!  ! Calculate the nuclear attraction matrix "Z"
!  ! if output is present and FALSE then do not make output archive
!    MAT :: Z
!    BIN, OPTIONAL :: output
!    BIN :: do_output
!    ATOM* :: atom
!    MAT* :: Z_c
!    INT :: q,c,fa,la,fb,lb
!    SHELL2 :: shell
!    ARCHIVE :: archive
!    ENSURE( .atom.created,  "no atom list")
!    ENSURE( .atom.bases_are_all_resolved, "no basis set")
!    do_output=TRUE
!    if (present(output)) do_output=output
!    Z = ZERO
!      do q=1,.n_shell_pairs
!        .get_shell_pair(shell,q,fa,la,fb,lb)
!        Z_c.create(shell.a.n_comp,shell.b.n_comp)
!        do c=1,.n_atom
!          atom=>.atom(c)
!        ! shell.get_nuc(Z_c, atom.mass,atom.pos)
!          shell.make_nuclear_attraction_ints(Z_c, atom.pos)
!          Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
!        end
!        Z_c.destroy
!        shell.destroy_ptr_part
!      end
!    Z.make_symmetric
!    if (do_output) then
!      archive.set(.name,"nuc_matrix")
!      archive.write(Z)
!    end
!  end
!
!  test_num
!    MAT* :: ZZ
!    INT :: q,fa,la,fb,lb
!    SHELL2 :: shell
!    ENSURE( .atom.created,  "no atom list")
!    ENSURE( .dftgrid.created, "need to specify dftgrid for ZORA")
!    ENSURE( .atom.bases_are_all_resolved, "no basis set")
!       q = 529
!       .get_shell_pair(shell,q,fa,la,fb,lb)
!       write(*,*) "fa=",fa,"la=",la,"fb=",fb,"lb=",lb
!       ZZ.create(shell.a.n_comp,shell.b.n_comp)
!       .dftgrid.make_matrix_elements_of(nuc_pot,self,shell,ZZ)
!       stdout.text("ZZ")
!       stdout.put(ZZ)
!       ZZ.destroy
!       shell.destroy_ptr_part
!  end
!
!   nuc_pot(values,pts)
!   ! Calculate the nuclear potential "values" of a given set of "pts".
!   ! This is usefule for numerical integration of nuclear attraction integrals.
!      VEC :: values
!      MAT :: pts
!      INT :: n_pts,n,i
!      DBL :: Z_n,r_ni
!      VEC(3) :: pos
!      n_pts = size(pts,1)
!      values = ZERO
!      do n = 1,.n_atom
!         Z_n = .atom(n).atomic_number
!         pos = .atom(n).pos
!         do i = 1,n_pts
!            r_ni = pos.distance_to(pts(i,:))
!            values(i) = values(i) + Z_n/r_ni
!         end
!      end
!   end
!
!  get_ENA_matrix(Z)
!  ! Set "Z" to the numerically calculated electron nuclear attraction matrix.
!  ! If archives exist, read them; otherwise make them.
!     MAT :: Z
!     ARCHIVE :: archive
!     archive.set(.name,"ENA_matrix")
!     if (archive.exists) then
!        archive.read(Z)
!     else
!        .make_ENA_matrix(Z)
!     end
!  end
!
!  test_spin_orbit_B_matrices
!     MAT* :: Lx,Ly,Lz
!     DBL :: fac
!     fac = (TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)/G_FACTOR
!     Lx.create(.n_bf,.n_bf)
!     Ly.create(.n_bf,.n_bf)
!     Lz.create(.n_bf,.n_bf)
!     .make_spin_orbit_B_matrices(Lx,Ly,Lz)
!     stdout.text("x")
!     stdout.put( Lx)
!     stdout.text("y")
!     stdout.put( Ly)
!     stdout.text("z")
!     stdout.put( Lz)
!     .make_SOB_matrices(Lx,Ly,Lz)
!     stdout.text("x")
!     stdout.put( Lx)
!     stdout.text("y")
!     stdout.put( Ly)
!     stdout.text("z")
!     stdout.put( Lz)
!     Lx.destroy; Ly.destroy; Lz.destroy
!  end
!
!  make_SOB_matrices(SOBx,SOBy,SOBz)
!  ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy" and "SOBz"
!     MAT :: SOBx,SOBy,SOBz
!     MAT* :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,Qx,Qy,Qz,Qss
!     INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
!     DBL :: fac,Z
!     SHELL2 :: shell
!     ARCHIVE :: archive
!     BIN :: debug
!     INT :: n_a,n_b
!     ENSURE( .atom.created,  "no atom list")
!     ENSURE( .atom.bases_are_all_resolved, "no basis set")
!     fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
!     SOBx = ZERO; SOBy = ZERO; SOBz = ZERO
!     do q=1,.n_shell_pairs
!        .get_shell_pair(q,shell,fa,la,fb,lb)
!        n_a = shell%a%n_comp; n_b = shell%b%n_comp
!        Qss.create(n_a,n_b)
!        Qx.create(n_a,n_b);  Qy.create(n_a,n_b);  Qz.create(n_a,n_b)
!        Qxx.create(n_a,n_b); Qxy.create(n_a,n_b); Qxz.create(n_a,n_b)
!        Qyx.create(n_a,n_b); Qyy.create(n_a,n_b); Qyz.create(n_a,n_b)
!        Qzx.create(n_a,n_b); Qzy.create(n_a,n_b); Qzz.create(n_a,n_b)
!        do c = 1,.n_atom
!           Z = .atom(c)%atomic_number
!           shell.make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, .atom(c)%pos, .gauge_origin)
!           Qss = Qxx + Qyy + Qzz
!           Qx = Qss*.B_field(1) - Qxx*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
!           Qy = Qss*.B_field(2) - Qyx*.B_field(1) - Qyy*.B_field(2) - Qyz*.B_field(3)
!           Qz = Qss*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2) - Qzz*.B_field(3)
!           SOBx(fa:la,fb:lb) = SOBx(fa:la,fb:lb) - Z*Qx
!           SOBy(fa:la,fb:lb) = SOBy(fa:la,fb:lb) - Z*Qy
!           SOBz(fa:la,fb:lb) = SOBz(fa:la,fb:lb) - Z*Qz
!        end
!        shell.destroy_ptr_part
!        Qzz.destroy; Qzy.destroy; Qzx.destroy
!        Qyz.destroy; Qyy.destroy; Qyx.destroy
!        Qxz.destroy; Qxy.destroy; Qxx.destroy
!        Qz.destroy;  Qy.destroy;  Qx.destroy;  Qss.destroy
!     end
!     SOBx.make_symmetric
!     SOBy.make_symmetric
!     SOBz.make_symmetric
!   ! archive.set(.name,"SOB_x_matrix"); archive.write(SOBx)
!   ! archive.set(.name,"SOB_y_matrix"); archive.write(SOBy)
!   ! archive.set(.name,"SOB_z_matrix"); archive.write(SOBz)
!  end
!
!  make_pcc_densities
!  ! Calculate pcc's densities for the paper
!     MAT* :: mo
!     VEC* :: mo35,mo48,mo49,mo50
!     VEC* :: p35,p48,p49,p50
!     MAT* :: g35,g48,g49,g50
!     MAT* :: j,s
!     TEXTFILE* :: in
!     INT :: n_pt,k
!     DBL :: mu,nu,rt3,fac
!     ARCHIVE :: archive
!
!     mo35.create(160)
!     mo48.create(160)
!     mo49.create(160)
!     mo50.create(160)
!     in.create("mo35")
!     in.open_for_read
!     in.read(mo35)
!     in.read(mo48)
!     in.read(mo49)
!     in.read(mo50)
!
!     n_pt = .grid%n_pt
!     p35.create(n_pt); g35.create(n_pt,3)
!     p48.create(n_pt); g48.create(n_pt,3)
!     p49.create(n_pt); g49.create(n_pt,3)
!     p50.create(n_pt); g50.create(n_pt,3)
!     .make_orbital_grid(p35,mo35)
!     .make_orbital_grid(p48,mo48)
!     .make_orbital_grid(p49,mo49)
!     .make_orbital_grid(p50,mo50)
!     .make_nabla_orbital_grid(g35,mo35)
!     .make_nabla_orbital_grid(g48,mo48)
!     .make_nabla_orbital_grid(g49,mo49)
!     .make_nabla_orbital_grid(g50,mo50)
!
!     j.create(n_pt,3)
!     s.create(n_pt,3)
!     nu = 0.15578d0
!     mu = 0.19107d0
!     rt3 = ONE/sqrt(THREE)
!     fac = ONE/(ONE+mu*mu+nu*nu)
!     do k = 1,3
!        j(:,k) =      nu*(p35(:)*g48(:,k) - p48(:)*g35(:,k)) &
!               + HALF*mu*(p50(:)*g49(:,k) - p49(:)*g50(:,k))
!     end
!     j = fac*j
!
!     s(:,1) = -rt3*mu * (p35(:)*p49(:) - nu*p48(:)*p50(:))
!     s(:,2) = -rt3*mu * (p35(:)*p50(:) - nu*p48(:)*p49(:))
!     s(:,3) = (ONE+mu*mu/THREE) * p48(:)*p48(:) &
!            + (ONE+nu*nu+mu*mu/SIX) * (p49(:)*p49(:)+p50(:)*p50(:)) &
!            + (nu*nu+mu*mu/THREE) * p35(:)*p35(:)
!     s(:,3) = HALF*s(:,3)
!
!     archive.set(.name,"current_density")
!     archive.write(j)
!     archive.set(.name,"current_density,gnuplot",format="ascii")
!     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z)
!     archive.set(.name,"current_norm_density,gnuplot",format="ascii")
!     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
!     archive.set(.name,"current_density,normalized,gnuplot",format="ascii")
!     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
!
!     archive.set(.name,"spin_density")
!     archive.write(s)
!     archive.set(.name,"spin_density,gnuplot",format="ascii")
!     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z)
!     archive.set(.name,"spin_norm_density,gnuplot",format="ascii")
!     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
!     archive.set(.name,"spin_density,normalized,gnuplot",format="ascii")
!     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)
!
!     s.destroy
!     j.destroy
!     g50.destroy; p50.destroy
!     g49.destroy; p49.destroy
!     g48.destroy; p48.destroy
!     g35.destroy; p35.destroy
!     in.close
!     in.destroy
!     mo50.destroy
!     mo49.destroy
!     mo48.destroy
!     mo35.destroy
!  end
!
!   integrate_property(make_property_grid) result (res)
!   ! Integrate a scalar molecular property, which is represented by a subroutine
!   ! "make_property_grid" which returns "values" of the property in a vector,
!   ! given "mol" as the molecule, and "pts" as a set of points. The result of
!   ! the integration is "res".
!      interface
!         make_property_grid(mol,values,pts)
!            use TYPES
!            MOL :: mol
!            VEC :: values
!            MAT :: pts
!         end
!      end
!      DBL :: res
!      ENSURE( .dftgrid.created,"no DFT grid information!")
!!      res = .dftgrid.integrate_molecular_property(make_property_grid,self)
!      res = ZERO
!   end
!
!   integrate_rho_numerically
!   ! Integrate the density numerically
!      DBL :: res
!      res = .integrate_property(make_density_grid_1)
!      stdout.show("numerically integrated charge =",res)
!   end
!
!   put_atom_kind_map
!   ! Check the atom kind map routine
!      DBL :: res
!      IVEC* :: atom_kind,unique_atom
!      INT :: n_atom,n_kind
!      n_atom = .n_atom
!      atom_kind.create(n_atom)
!      .atom.make_atom_kind_list(atom_kind,n_kind)
!      stdout.text("atom kind")
!      stdout.put(atom_kind,"column")
!      unique_atom.create(n_kind)
!      .atom.make_unique_atom_list(unique_atom)
!      stdout.text("unique atom list")
!      stdout.put(unique_atom,"column")
!      unique_atom.destroy
!      atom_kind.destroy
!   end
!
!  test_eigen
!     INT :: n,i
!     DBL :: dot
!     MAT* :: m
!     VEC* :: eval
!     MAT* :: L,R,w
!     stdin.read(n)
!     m.create(n,n)
!     stdin.read(m)
!     eval.create(n)
!     L.create(n,n)
!     R.create(n,n)
!     m.solve_general_eigenproblem(eval,L,R)
!     stdout.show("n =",n)
!     stdout.text("eval:")
!     stdout.put(eval,"column")
!     stdout.text("Left eigenvectors:")
!     stdout.put(L)
!     stdout.text("right eigenvectors:")
!     stdout.put(R)
!     w.create(n,n)
!     w.to_product(L,R,transpose_a=TRUE)
!     stdout.text("(left)^T x (right) eigenvectors:")
!     stdout.put(w)
!     w.destroy
!     R.destroy
!     L.destroy
!     eval.destroy
!     m.destroy
!  end

! *************************************************************
! Determinant Variation Perturbation Theory (DVPT) SCF routines
! *************************************************************

!  DVPT_scf [recursive] [leaky]
!  ! Do a restricted determinant variation perturbation theory SCF calculation. The following
!  ! are produced as results: .molecular_orbitals, .orbital_energies, .density_matrix  
!    ENSURE( .atom.created,  "no atom list")
!    ENSURE( .atom.bases_are_all_resolved, "no basis set")
!    .make_DVPT_initial_mos
!    .make_DVPT_density_matrices
!    .make_DVPT_fock_matrices
!    .scfdata.set(nuclear_energy=.nuclear_energy)
!    .scfdata.reset(energy=.DVPT_scf_energy, kinetic_energy=ZERO)
!
!  ! stdout.text("D:")
!  ! stdout.put(.density_matrix.restricted)
!  ! stdout.text("F:")
!  ! stdout.put(.fock_matrix.restricted)
!  ! .scfdata.kind="rhf"
!  ! .scfdata.reset(energy=.scf_energy, kinetic_energy=ZERO)
!  ! .scfdata.kind="rdvpt"
!
!    .scfdata.put_banner
!    ! Begin iterations
!    do
!    ! .extrapolate_scf
!      .update_DVPT_orbitals
!      .schmidt_orthonormalise(.molecular_orbitals)
!      .make_DVPT_density_matrices
!      .make_DVPT_fock_matrices
!      .save_DVPT_results
!      .scfdata.update(energy=.DVPT_scf_energy, kinetic_energy=ZERO)
!      .scfdata.put_results
!      if (.scfdata.scf_done) exit
!    end
!    .scfdata.cleanup_diis
!    .fock_matrix.destroy("restricted")
!  end
!
!  update_DVPT_orbitals
!  ! Solve for the new DVPT orbitals and energies. An initial set of orbitals
!  ! and a Fock matrix must already exist in memory. The new molecular orbitals 
!  ! "MO*U" are found from the old MOs solving : (MO^T F MO)U = MO^T S MO U E 
!  ! where U is a general matrix (since F is not symmetric).
!    VEC* :: MO_energies
!    MAT* :: MO,F
!    MAT* :: G,U,left
!    INT :: i
!    MO_energies => .orbital_energies.restricted
!    MO => .molecular_orbitals.restricted
!    F  => .fock_matrix.restricted
!    G.create(.n_bf,.n_bf)
!    U.create(.n_bf,.n_bf)
!    left.create(.n_bf,.n_bf)
!    G = F
!    G.change_basis(MO)
!    ! Level shifting
!    if ( .scfdata.apply_level_shifting) then
!      do i = .n_a + 1, .n_bf
!        G(i,i) = .scfdata.level_shift + G(i,i)
!      end
!    end
!    G.solve_general_eigenproblem(MO_energies,left,U)
!    G.to_product(MO,U)
!    MO = G
!    left.destroy
!    U.destroy
!    G.destroy
!  end
!
!  save_DVPT_results
!  ! Save the DVPT results in various archives
!    ARCHIVE :: archive
!    INT :: m
!    .save_scf_results
!    m = .DVPT_order
!    archive.set(.name,"DVPT_mo_"// m.to_str.trim)
!    archive.write(.molecular_orbitals.restricted)
!  end
!
!  make_DVPT_initial_mos [leaky]
!  ! Make the DVPT initial orbitals. Currently this is just the same
!  ! as the usual initial guess, but the MO's are written to disk.
!     INT :: m
!     MAT* :: MO
!     ARCHIVE :: m_archive
!     m = .DVPT_order
!     m_archive.set(.name,"DVPT_mo_"// m.to_str.trim)
!     .scfdata.kind = "rhf"
!     .get_initial_guess
!     .scfdata.kind = "rdvpt"
!     MO => .molecular_orbitals.restricted
!     m_archive.write(MO)
!  end
!
!  DVPT_order result (X)
!  ! Determine the DVPT order by looking for the highest number "X" for
!  ! which a DVPT_mo_X archive file exists.
!     INT :: X
!     ARCHIVE :: archive
!     INT :: order = 999
!     if (order/=999) then
!        X = order
!     else
!        X = 0
!        do
!           archive.set(.name,"DVPT_mo_"// X.to_str.trim)
!           if (archive.does_not_exist) exit
!           X = X + 1
!        end
!        order = X
!     end
!  end
!
!  make_DVPT_density_matrices
!  ! Make all the DVPT density matrices up to the required order
!  ! NOTE: the indice order is opposite to the paper.
!     INT :: m,j
!     m = .DVPT_order
!     do j = 0,m
!        .make_DVPT_density_matrix(m,j)
!     end
!     .make_DVPT_eff_density_matrix
!  !  .scfdata.kind = "rhf"
!  !  .make_scf_density_matrix
!  !  .scfdata.kind = "rdvpt"
!  end
!
!  make_DVPT_eff_density_matrix
!  ! Make the effective DVPT fock matrix
!     INT :: m,i,j
!     DBL :: fac,sum,det
!     MAT* :: DD,D
!     ARCHIVE :: d_archive
!     .density_matrix.restricted.destroy
!     DD.create(.n_bf,.n_bf); DD = ZERO
!     D.create(.n_bf,.n_bf)
!     m   = .DVPT_order
!     do i = 0,m
!     do j = 0,i
!        fac = TWO
!        if (i==j) fac = ONE
!        .get_DVPT_density_matrix(D,det,i,j)
!        sum = sum + fac*det
!        D = fac*D
!        DD.plus(D)
!     end
!     end
!     DD = DD/sum
!     d_archive.set(.name,"DVPT_density_matrix")
!     d_archive.write(DD)
!     .density_matrix.restricted => DD
!     D.destroy
!  end
!
!  get_DVPT_density_matrix(D,determinant,left,right)
!  ! Get the determinant variation perturbation theory transition density matrix 
!  ! for a left determinant orbitals "left" and  a right determinant orbitals "right". 
!  ! Make the density if the archive does not exist.
!     MAT :: D
!     DBL :: determinant
!     INT :: left,right
!     ARCHIVE :: d_archive
!     STR :: label
!     label = left.to_str.trim // right.to_str.trim
!     d_archive.set(.name,"DVPT_density_"// label)
!     if (d_archive.does_not_exist) .make_DVPT_density_matrix(left,right)
!     d_archive.read(D)
!     d_archive.set(.name,"DVPT_determinant_"// left.to_str.trim // right.to_str.trim)
!     d_archive.read(determinant)
!  end
!
!  make_DVPT_density_matrix(left,right)
!  ! Make the determinant variation perturbation theory transition density matrix 
!  ! for a left determinant orbitals "left" and  a right determinant orbitals "right". 
!  ! The density and determinant are stored as archives on disk.
!     INT :: left,right
!     MAT* :: D,L,R
!     ARCHIVE :: l_archive,r_archive,d_archive
!     DBL :: determinant
!     D.create(.n_bf,.n_bf)
!     l_archive.set(.name,"DVPT_mo_"// left.to_str.trim)
!     r_archive.set(.name,"DVPT_mo_"// right.to_str.trim)
!     ENSURE(l_archive.exists, "no DVPT mo archive, no. ="// left.to_str.trim)
!     ENSURE(r_archive.exists, "no DVPT mo archive, no. ="// right.to_str.trim)
!     L.create(.n_bf,.n_bf)
!     R.create(.n_bf,.n_bf)
!     l_archive.read(L)
!     r_archive.read(R)
!     ! Make density matrix using occupied orbitals only
!     .make_DVPT_density_matrix(D,determinant,L(:,:.n_a),R(:,:.n_a))
!
!     !       stdout.show("det =",determinant)
!     !       stdout.text("MO:")
!     !       stdout.put(L(:,.n_a))
!     !       stdout.text("D:")
!     !       stdout.put(TWO*D)
!
!     R.destroy
!     L.destroy
!     d_archive.set(.name,"DVPT_density_"// left.to_str.trim // right.to_str.trim)
!     d_archive.write(D)
!     d_archive.set(.name,"DVPT_determinant_"// left.to_str.trim // right.to_str.trim)
!     d_archive.write(determinant)
!     D.destroy
!  end
!
!  make_DVPT_density_matrix(D,determinant,left,right)
!  ! Make the determinant variation perturbation theory transition density matrix "D" for a
!  ! left determinant of occupied orbitals "left" and a right determinant of occupied 
!  ! orbitals "right". Also return the "determinant" of the orbital ovarlap matrix.
!     MAT :: D
!     MAT :: left,right
!     DBL :: determinant
!     MAT* :: S,O,C
!     INT :: dim
!     ENSURE(size(D,1)==size(D,2),"D is not square")
!     ENSURE(size(D,1)==.n_bf,"D has wrong size")
!     ENSURE(size(left,1) ==.n_bf,"left has wrong size")
!     ENSURE(size(right,1)==.n_bf,"right has wrong size")
!     ENSURE(size(left,2)==size(right,2),"left and and right are incompatible")
!     dim = size(left,2)
!     S.create(dim,dim)
!     O.create(.n_bf,.n_bf)
!     .get_overlap_matrix(O)
!     O.change_basis(S,left,right)
!     O.destroy
!     C.create(dim,dim)
!     .make_cofactor(C,determinant,S)
!     C.back_transform(D,right,left)
!     C.destroy
!     S.destroy
!  end
!
!  make_cofactor(C,determinant,S)
!  ! Make the cofactor matrix "C" and "determinant" for the matrix "S".
!  ! Note: this constructs the alpha-alpha part of the cofactor, but the
!  ! determinant is that for the full overlap matrix
!     MAT :: C,S
!     DBL :: determinant
!     VEC* :: eval,n
!     MAT* :: left,right,W
!     INT :: dim,i
!     DBL :: dot
!     ENSURE(size(C,1)==size(C,2),"C is not square")
!     ENSURE(size(S,1)==size(S,2),"incorrect size for array S")
!     ENSURE(size(S,1)==size(C,1),"array C and array S incompatible")
!     dim = size(C,1)
!     left.create(dim,dim)
!     right.create(dim,dim)
!     eval.create(dim)
!     ! Get the eigenvalues and determinant of S
!     S.solve_general_eigenproblem(eval,left,right)
!     determinant = product(eval)
!     determinant = determinant*determinant ! include beta part
!     ! Make the cofactor
!     n.create(dim)
!     n = determinant/eval
!     W.create(dim,dim)
!     W.to_product_with_diagonal(n,left,transpose_a=TRUE)
!     C = matmul(right,W)
! 
!   ! stdout.text("*********make_cofactor**************")
!   ! stdout.text("S:")
!   ! stdout.put(S)
!   ! stdout.text("n:")
!   ! stdout.put(n,format="column")
!   ! stdout.text("L:")
!   ! stdout.put(left)
!   ! stdout.text("R:")
!   ! stdout.put(right)
!   ! W = matmul(right,transpose(left))
!   ! stdout.text("R L^T:")
!   ! stdout.put(W)
!   ! W = matmul(transpose(left),right)
!   ! stdout.text("L^T R:")
!   ! stdout.put(W)
!   ! stdout.text("C:")
!   ! stdout.put(C)
!   ! stdout.text("************************************")
!
!     W.destroy
!     n.destroy
!     eval.destroy
!     right.destroy
!     left.destroy
!  end
!
!  make_DVPT_fock_matrices [leaky]
!  ! Make the DVPT fock matrices up to the required order,
!  ! including the effective fock matrix
!     INT :: m,j
!     m = .DVPT_order
!     do j = 0,m
!        .make_DVPT_fock_matrix(m,j)
!     end
!     .make_DVPT_eff_fock_matrix
!  !  .scfdata.kind = "rhf"
!  !  .make_fock_matrix
!  !  .scfdata.kind = "rdvpt"
!  end
!
!  make_DVPT_eff_fock_matrix [leaky]
!  ! Make the effective DVPT fock matrix
!     INT :: m,j
!     DBL :: E_m,E_mj,sum,det
!     MAT* :: FF,F,W,D
!     ARCHIVE :: f_archive
!     .fock_matrix.restricted.destroy
!     FF.create(.n_bf,.n_bf); FF = ZERO
!     F.create(.n_bf,.n_bf)
!     W.create(.n_bf,.n_bf)
!     D.create(.n_bf,.n_bf)
!     m   = .DVPT_order
!     E_m = .DVPT_electronic_energy
!     sum = ZERO
!     do j = 0,m
!        .get_DVPT_fock_matrix(F,m,j)
!        .get_DVPT_density_matrix(D,det,m,j)
!        sum = sum + det
!        det = 1/(TWO*det)
!        FF.plus(F)
!        .add_core_hamiltonian(FF)
!        E_mj = E_m + det*F.trace_of_product(D)
!        .get_overlap_matrix(F)
!        W.to_product(D,F) 
!        D.to_product(F,W) 
!        FF = FF - E_mj*D
!     end
!     FF = FF/sum
!     f_archive.set(.name,"DVPT_effective_fock_"// m.to_str.trim)
!     f_archive.write(FF)
!     .fock_matrix.restricted => FF
!     D.destroy
!     W.destroy
!     F.destroy
!  end
!
!  get_DVPT_fock_matrix(F,left,right)
!  ! Get the determinant variation perturbation theory transition Fock matrix 
!  ! for a left determinant orbitals "left" and  a right determinant orbitals "right". 
!     MAT :: F
!     INT :: left,right
!     ARCHIVE :: f_archive
!     STR :: label
!     label = left.to_str.trim // right.to_str.trim
!     f_archive.set(.name,"DVPT_fock_"// label)
!     if (f_archive.does_not_exist) .make_DVPT_fock_matrix(left,right)
!     f_archive.read(F)
!  end
!
!  make_DVPT_fock_matrix(left,right)
!  ! Make the determinant variation perturbation theory transition fock matrix 
!  ! for a left determinant orbitals "left" and  a right determinant orbitals "right". 
!  ! The Fock matrix is stored as an archive on disk.
!     INT :: left,right
!     MAT* :: F
!     ARCHIVE :: f_archive
!     STR :: label
!     F.create(.n_bf,.n_bf)
!     .make_DVPT_fock_matrix(F,left,right)
!     label = left.to_str.trim // right.to_str.trim
!     f_archive.set(.name,"DVPT_fock_"// label)
!     f_archive.write(F)
!     F.destroy
!  end
!
!  make_DVPT_fock_matrix(F,left,right)
!  ! Make the determinant variation perturbation theory transition fock matrix for
!  ! a left determinant of orbitals "left" and a right determinant of orbitals
!  ! "right". If present, "D" is used as the density matrix.
!     MAT :: F
!     INT :: left,right
!     MAT* :: P
!     DBL :: determinant,fac
!     P.create(.n_bf,.n_bf)
!     .get_DVPT_density_matrix(P,determinant,left,right)
!  !  .make_r_asymmetric_fock(P,F,direct=FALSE,core=FALSE,r12=TRUE) 
!     .make_r_fock(P,F,direct=FALSE,core=FALSE,r12=TRUE) 
!     fac = TWO/determinant
!     F = fac*F
!     P.destroy
!  end
!
!  make_r_fock(P,F,direct,core,r12) [leaky]
!  ! Make a new restricted Fock matrix "F" from the density matrix "P".
!  ! If present and TRUE , "direct" means calculate integrals on the fly
!  ! If present and FALSE, "core" removes the core matrix contribution
!  ! If present and FALSE, "r12"  removes the two electron contribution
!    BIN, optional :: direct,core,r12
!    MAT :: P,F
!    MAT* :: J,K
!    BIN :: do_direct,add_core,add_r12
!
!    do_direct= FALSE
!    add_core = TRUE
!    add_r12  = TRUE
!    if (present(direct)) do_direct = direct
!    if (present(core))   add_core = core
!    if (present(r12))    add_r12  = r12
!    if (add_r12) then
!       J.create(.n_bf,.n_bf)
!       K.create(.n_bf,.n_bf)
!       if (do_direct) then; .make_r_JK_direct(J,K,P)
!       else;                .make_r_JK_disk(J,K,P)
!       end
!       F = J - HALF*K 
!       K.destroy
!       J.destroy
!    else
!       F = ZERO
!    end
!    if (add_core) .add_core_hamiltonian(F)
!  end
!
!  make_r_asymmetric_fock(P,F,direct,core,r12) [leaky]
!  ! Make a new restricted Fock matrix "F" from an asymmetric density matrix "P".
!  ! If present and TRUE , "direct" means calculate integrals on the fly
!  ! If present and FALSE, "core" removes the core matrix contribution
!  ! If present and FALSE, "r12"  removes the two electron contribution
!    BIN, optional :: direct,core,r12
!    MAT :: P,F
!    MAT* :: J,K
!    BIN :: do_direct,add_core,add_r12
!    ENSURE(size(F,1)==.n_bf, "Fock matrix dimensions wrong")
!    ENSURE(size(P,1)==.n_bf, "Density matrix dimensions wrong")
!    do_direct= FALSE
!    add_core = TRUE
!    add_r12  = TRUE
!    if (present(direct)) do_direct = direct
!    if (present(core))   add_core = core
!    if (present(r12))    add_r12  = r12
!    if (add_r12) then
!       J.create(.n_bf,.n_bf)
!       K.create(.n_bf,.n_bf)
!       if (do_direct) then; .make_r_asymmetric_JK_direct(J,K,P)
!       else;                .make_r_asymmetric_JK_disk(J,K,P)
!       end
!       F = J - HALF*K 
!       K.destroy
!       J.destroy
!    else
!       F = ZERO
!    end
!    if (add_core) then
!      .add_core_hamiltonian(F)
!    end
!  end
!
!  make_r_asymmetric_JK_direct(J,K,P)
!  ! Make the real coulomb matrices "J" and exchange matrix "K"  from an
!  ! asymmetric density matrix "P" directly from the integrals. 
!    MAT :: J,K,P
!    MAT4*   :: I
!    SHELL4* :: shell4
!    VEC* :: I_max
!    INT :: ac,ab,cd,aa,cc
!    INT :: a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
!    DBL :: cutoff,I_abcd,factor
!    BIN :: skip
!    J = ZERO
!    K = ZERO
!    cutoff = .scfdata.eri_cutoff
!    shell4.create
!    I_max.create(.n_shell_pairs)
!    .make_max_abab_integrals(I_max)
!    do ab = 1,.n_shell_pairs
!      .get_shell_pair(ab,a,b)
!      fa = .first_basis_fn_for_shell(a)
!      fb = .first_basis_fn_for_shell(b)
!      la = .last_basis_fn_for_shell(a)
!      lb = .last_basis_fn_for_shell(b)
!      do cd = 1,ab
!        .get_shell_pair(cd,c,d)
!        fc = .first_basis_fn_for_shell(c)
!        fd = .first_basis_fn_for_shell(d)
!        lc = .last_basis_fn_for_shell(c)
!        ld = .last_basis_fn_for_shell(d)
!        .get_shell_quartet(shell4,a,b,c,d)
!        skip = .schwarz_inequality_test(cutoff,ab,cd,fa,la,fb,lb,fc,lc,fd,ld,P,I_max)
!        if (skip) then
!           shell4.destroy_ptr_part
!           cycle
!        end
!        I.create(fa,la,fb,lb,fc,lc,fd,ld)
!        shell4.get_ERI(I)
!        factor = ONE                                ! Evaluate the integrals
!        if (a==b)          factor = HALF            ! Coincidence factors   
!        if (c==d)          factor = HALF * factor
!        if (a==c AND b==d) factor = HALF * factor
!        do d = fd,ld
!        do c = fc,lc
!        do b = fb,lb
!        do a = fa,la
!           I_abcd = factor * I(a,b,c,d)
!           J(a,b) = J(a,b) + I_abcd*(P(d,c)+P(c,d)) ! These are symmetric
!           J(c,d) = J(c,d) + I_abcd*(P(b,a)+P(a,b))
!           K(a,d) = K(a,d) + I_abcd*P(b,c)          ! These are asymmetric
!           K(a,c) = K(a,c) + I_abcd*P(b,d) 
!           K(b,c) = K(b,c) + I_abcd*P(a,d)
!           K(b,d) = K(b,d) + I_abcd*P(a,c)
!           K(d,a) = K(d,a) + I_abcd*P(c,b)
!           K(c,a) = K(c,a) + I_abcd*P(d,b)
!           K(c,b) = K(c,b) + I_abcd*P(d,a)
!           K(d,b) = K(d,b) + I_abcd*P(c,a)
!        end
!        end
!        end
!        end
!        I.destroy
!        shell4.destroy_ptr_part
!      end
!    end
!    I_max.destroy
!    shell4.destroy
!    .weight_diagonal_blocks(J,TWO)
!    J.make_symmetric
!  end
!
!  make_r_asymmetric_JK_disk(J,K,P)
!  ! Make the real coulomb matrices "J" and exchange matrix "K"  from an
!  ! asymmetric density matrix "P" using disk integrals. 
!    MAT :: J,K,P
!    ARCHIVE* :: eri_archive,ind_archive
!    MAT4*   :: I
!    INT :: q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld
!    DBL :: I_abcd
!    eri_archive.create(.name,"eri_integrals")
!    ind_archive.create(.name,"eri_index")
!    ENSURE( .atom.created,  "no atom list")
!    ENSURE( .atom.bases_are_all_resolved, "no basis set")
!    ENSURE( eri_archive.exists, "no integral file")
!    ENSURE( ind_archive.exists, "no integral index file")
!    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
!    ind_archive.open(for="read-only",buffered=TRUE,type="int")
!    J = ZERO
!    K = ZERO
!    n_quartets = .n_shell_quartets
!    do
!       ind_archive.file.read(q)
!       if (q > n_quartets) exit
!       .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
!       I.create(fa,la,fb,lb,fc,lc,fd,ld)
!       eri_archive.file.read(I)
!       do d = fd,ld
!       do c = fc,lc
!       do b = fb,lb
!       do a = fa,la
!          I_abcd = I(a,b,c,d)
!          J(a,b) = J(a,b) + I_abcd*(P(d,c)+P(c,d)) ! These are symmetric
!          J(c,d) = J(c,d) + I_abcd*(P(b,a)+P(a,b))
!          K(a,d) = K(a,d) + I_abcd*P(b,c)          ! These are asymmetric
!          K(a,c) = K(a,c) + I_abcd*P(b,d) 
!          K(b,c) = K(b,c) + I_abcd*P(a,d)
!          K(b,d) = K(b,d) + I_abcd*P(a,c)
!          K(d,a) = K(d,a) + I_abcd*P(c,b)
!          K(c,a) = K(c,a) + I_abcd*P(d,b)
!          K(c,b) = K(c,b) + I_abcd*P(d,a)
!          K(d,b) = K(d,b) + I_abcd*P(c,a)
!       end
!       end
!       end
!       end
!       I.destroy
!    end
!    ind_archive.destroy
!    eri_archive.destroy
!    .weight_diagonal_blocks(J,TWO)
!    J.make_symmetric
!  end
! 
!   get_shell_pair_indices_from(index,a,b)
!   ! Return the actual shell indicies "a" and "b" which map to "index"
!     INT, IN :: index
!     INT, OUT :: a,b
!     a  = (1+sqrt(8.0d0*index-7.0d0))/2
!     b  = index - a*(a-1)/2
!   end
!
!  DVPT_scf_energy result (res)
!  ! Evaluates the determinant variation perturbation theory SCF energy 
!  ! (including the nuclear repulsion contribution)
!    DBL :: res
!    res = .DVPT_electronic_energy + .nuclear_energy
!  end
!
!  DVPT_electronic_energy result (res)
!  ! Evaluates the SCF electronic energy 
!    DBL :: res
!    STR :: kind
!    MAT* :: F,D
!    INT :: m,i,j
!    DBL :: fac,det,sum
!    m = .DVPT_order
!    kind = .scfdata.kind
!    select case (kind)
!       case ("rdvpt","restricted_dvpt")
!          F.create(.n_bf,.n_bf)
!          D.create(.n_bf,.n_bf)
!          res = ZERO
!          sum = ZERO
!          do i = 0,m
!          do j = 0,i
!             fac = TWO
!             if (i==j) fac = ONE
!             .get_DVPT_density_matrix(D,det,i,j)
!             .get_DVPT_fock_matrix(F,i,j)
!             .add_core_hamiltonian(F)
!
!          !  stdout.show("i   =",i)
!          !  stdout.show("j   =",j)
!          !  stdout.show("det =",det)
!          !  stdout.text("D:")
!          !  stdout.put(TWO*D)
!          !  stdout.text("F:")
!          !  stdout.put(F)
!
!             .add_core_hamiltonian(F)
!             res = res + fac*F.trace_of_product(D)
!             sum = sum + fac*det
!          end
!          end
!          res = res/sum
!          D.destroy
!          F.destroy
!       case default; DIE("not yet implemented, " // .scfdata.kind)
!    end
!  end

end
