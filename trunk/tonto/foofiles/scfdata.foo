!---------------------------------------------------------------------------
!
!  SCFDATA: Store SCF data and deal with iteration control ......
!
!  (c) Daniel Grimwood, 1998
!
! $Id$
!---------------------------------------------------------------------------
module SCFDATA

   use TYPES
   use SYSTEM
   use STR
   use DBL
   use TEXTFILE
   use VECDIIS

   implicit none

#  include "macros"
#  include "scfdata.int"

!   type scfdata_type
!
!   STR :: kind
!   ! The kind of SCF calculation to perform
!
!   STR :: initial_density
!   ! The kind of density matrix to start the SCF calc
!
!   STR :: initial_mos
!   ! The kind of initial MO's to start the SCF calc
!
!   DBL :: nuclear_energy
!   ! Nuclear repulsion energy for the associated molecule
!
!   DBL :: kinetic_energy
!   ! The kinetic energy for the associated molecule
!
!   DBL :: energy
!   ! The SCF energy for the associated molecule
!
!   DBL :: old_energy
!   ! The SCF energy from the previous SCF cycle
!
!   DBL :: difference
!   ! The change in the SCF energy between cycles
!
!   DBL :: convergence
!   ! A number which measures the convergnece of the SCF
!
!   INT :: iteration
!   ! The interation count for the SCF procedure
!
!   INT :: lambda_iteration
!   ! Lambda iteration count for the x-ray SCF procedure
!
!   INT :: min_iterations
!   ! The minimum number of SCF iterations to perform
!
!   INT :: max_iterations
!   ! The maximum number of SCF iterations to perform
!
!   DBL :: lambda
!   ! The initial lambda value to use in an x-ray SCF procedure
!
!   DBL :: lambda_max
!   ! The maximum lambda value to use in an x-ray SCF procedure
!
!   DBL :: lambda_step
!   ! The value to step the lambda value between lambda cycles in an x-ray SCF calc
!
!   DBL :: chi2
!   ! Chi^2 agreement statistic for an x-ray SCF calc
!
!   DBL :: old_chi2
!   ! Chi^2 agreement statistic for the previous x-ray SCF cycle
!
!   DBL :: gof
!   ! Goodness-of-fit agreement statistic for x-ray SCF calc
!
!   DBL :: r_factor
!   ! R-factor agreement statistic for x-ray SCF calc
!
!   DBL :: weighted_r_factor
!   ! The weighted r-factor agreement statistic
!
!   BIN :: direct
!   ! True if udsing direct SCF
!
!   BIN :: using_diis
!   ! True if using DIIS
!
!   BIN :: using_damping
!   ! True if using damping
!
!   BIN :: using_level_shift
!   ! True if using level shifting
!
!   VECDIIS :: diis
!   ! For (fock matrix) diis extrapolation
!
!   INT :: damp_finish
!   ! Iteration when density matrix damping is turned off
!
!   DBL :: damp_factor
!   ! The damping factor to use
!
!   DBL :: level_shift
!   ! Value to level shift the virtual orbitals
!
!   BIN :: output
!   ! True if output is wanted
!
!   BIN :: nddo
!   ! Neglect of diatomic differential overlap
!
!   BIN :: nudo
!   ! Neglect of unconnected differential overlap
!
!   BIN :: using_bl_term
!   ! Switch on/off the B.L term (complex SCF reqd.)
!
!   BIN :: using_bs_term
!   ! Switch on/off the B.S term
!
!   BIN :: using_bs_t_term
!   ! Switch on/off the (B.S) T_e term
!
!   BIN :: using_aa_term
!   ! Switch on/off the A.A diamagnetic term
!
!   BIN :: using_1e_sl_term
!   ! Switch on/off the 1 electron S.L term
!
!   BIN :: using_1e_srxa_term
!   ! Switch on/off the 1 electron diamagnetic term
!
!   BIN :: using_1e_zora_term
!   ! Switch on/off the 1 electron ZORA terms
!
!   DBL :: sl_1e_factor
!   ! Factor to apply to the 1-electron S.L terms
!
!   BIN :: using_2e_sl_term
!   ! Switch on/off the 2 electron S.L terms
!
!   DBL :: sl_2e_factor
!   ! Factor to apply to the 2-electron S.L terms
!
!   DBL :: eri_limit
!   ! Cutoff for the two electron integrals
!
!   end

contains

!  *******************
!  Allocation routines
!  *******************

  create
  ! Create space for an SCF type
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SCFDATA_SIZE)
    .nullify_ptr_part
    .set_default
  end

  destroy
  ! Destroy space for an SCF type
    PTR :: self
    if (.destroyed) return
    .destroy_ptr_part
    DELETE_MEM(SCFDATA_SIZE)
    deallocate(self)
  end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      .diis.nullify_ptr_part
   end

   destroy_ptr_part
   ! Destroy the pointer parts of self
      .diis.destroy_ptr_part
   end

   delete_diis_archives
   ! Delete the DIIS archives on disk
     if (.using_diis) .diis.delete_archives
   end

   cleanup_diis
   ! Delete the DIIS archives on disk, and restore the DIIS object so it can be
   ! reused.  Does not go back to the default DIIS parameters.
     if (.using_diis) .diis.cleanup
   end

!  ************
!  Set routines
!  ************
 
  set_default
  ! Set default SCF data 
    .kind               = " "       ! Purposely set blank so diis comes later
    .initial_density    = "core"
    .initial_mos        = "--not used--"
    .energy             = ZERO
    .nuclear_energy     = ZERO
    .kinetic_energy     = ZERO
    .old_energy         = ZERO
    .difference         = ZERO
    .convergence        = 0.000001d0
    .iteration          = 0
    .min_iterations     = 0
    .max_iterations     = 100
    .damp_finish        = DIIS_START
    .damp_factor        = 0.5d0
    .direct             = FALSE
    .lambda             = 0
    .lambda_max         = 0
    .lambda_step        = 1
    .lambda_iteration   = 0
    .chi2               = ZERO
    .gof                = ZERO
    .r_factor           = ZERO
    .weighted_r_factor  = ZERO
    .direct             = FALSE
    .using_diis         = TRUE
    .using_damping      = TRUE
    .using_level_shift  = TRUE
    .output             = TRUE
    .nddo               = FALSE
    .nudo               = FALSE
    .using_bl_term      = TRUE
    .using_bs_term      = TRUE
    .using_bs_t_term    = TRUE
    .using_aa_term      = TRUE
    .using_1e_sl_term   = TRUE
    .using_1e_srxa_term = TRUE
    .using_2e_sl_term   = TRUE
    .using_1e_zora_term = FALSE
    .sl_1e_factor       = ONE
    .sl_2e_factor       = ONE
    .level_shift        = 0.3d0
    .diis.set_default
    .eri_limit          = ERI_CUTOFF
  end
 
  set(nuclear_energy,energy,kinetic_energy,chi2,gof,r_factor,weighted_r_factor)
  ! Set various parts of the scfdata type.
    DBL, IN, optional :: nuclear_energy,energy,kinetic_energy
    DBL, IN, optional :: chi2,gof,r_factor,weighted_r_factor
    if (present(nuclear_energy))    .nuclear_energy = nuclear_energy
    if (present(energy))            .update_energy(energy)
    if (present(kinetic_energy))    .kinetic_energy = kinetic_energy 
    if (present(chi2))              .update_chi2(chi2)
    if (present(gof))               .gof = gof
    if (present(r_factor))          .r_factor = r_factor
    if (present(weighted_r_factor)) .weighted_r_factor = weighted_r_factor
  end

  reset(energy,kinetic_energy,chi2,gof,r_factor,weighted_r_factor)
  ! Reset SCF energy and iteration data , but don't change 
  ! nuclear_energy, convergence, direct, or max_it options
     DBL, IN, optional :: energy,kinetic_energy
     DBL, IN, optional :: chi2,gof,r_factor,weighted_r_factor
    .energy             = ZERO
    .kinetic_energy     = ZERO
    .old_energy         = ZERO
    .difference         = ZERO
    .iteration          = 0
    .chi2               = ZERO
    .gof                = ZERO
    .r_factor           = ZERO
    .weighted_r_factor  = ZERO
    .set(energy=energy,kinetic_energy=kinetic_energy)
    .set(chi2=chi2,gof=gof,r_factor=r_factor,weighted_r_factor=weighted_r_factor)
  end

  update_lambda
  ! Increments lambda by lambda_step
    .lambda = .lambda + .lambda_step
    .lambda_iteration = .lambda_iteration + 1
    .iteration      = 0
  end

  update(energy,kinetic_energy,chi2,gof,r_factor,weighted_r_factor)
  ! Update the SCF energy and/or chi2 and increment iteration.
    DBL, IN, optional :: energy,kinetic_energy
    DBL, IN, optional :: chi2,gof,r_factor,weighted_r_factor
    .set(energy=energy,kinetic_energy=kinetic_energy)
    .set(chi2=chi2,gof=gof,r_factor=r_factor,weighted_r_factor=weighted_r_factor)
    .iteration = .iteration+1
  end

  update_energy(energy)
  ! Update the current SCF energy and increment iteration.
    DBL, IN :: energy
    .old_energy = .energy
    .energy = energy 
    .difference = .energy - .old_energy
  end

  update_chi2(chi2)
  ! Update the current chi2.
    DBL, IN :: chi2
    .old_chi2 = .chi2
    .chi2 = chi2
  end

  set_initial_energy(energy)
  ! Set the current SCF energy
    DBL, IN :: energy
    .old_energy = .energy
    .energy = energy
    .difference = .energy - .old_energy
  end

  spinorbital_kind(scf_kind) result(res)
  ! Return the kind of spinorbitals used in a particular "scf_kind"
  ! (i.e. for the fock_matrix and density_matrix, but not neccesarily the mo's)
    STR(*), optional :: scf_kind
    STR :: res
    STR :: kind
    kind = .kind
    if (present(scf_kind)) kind = scf_kind 
    select case (kind)
      case("rhf","restricted_hartree_fock");      res = "restricted"
      case("rohf", &
           "restricted_open_shell_hartree_fock"); res = "unrestricted"
      case("uhf","unrestricted_hartree_fock");    res = "unrestricted"
      case("ghf","general_hartree_fock");         res = "general"
      case("rchf","crhf", &
           "restricted_complex_hartree_fock", &
           "complex_restricted_hartree_fock");    res = "restricted_complex"
      case("uchf","cuhf", &
           "unrestricted_complex_hartree_fock", &
           "complex_unrestricted_hartree_fock");  res = "unrestricted_complex"
      case("gchf","cghf", &
           "general_complex_hartree_fock", &
           "complex_general_hartree_fock");       res = "general_complex"
      case("xray_rhf", &
           "xray_restricted_hartree_fock");       res = "restricted"
      case("rdvpt","restricted_dvpt");            res = "restricted"
      case default; DIE("unknown scf kind")
    end
  end

  molecular_orbital_kind(scf_kind) result(res)
  ! Return the kind of spinorbitals used for the molecular orbitals in a
  ! particular "scf_kind"
    STR(*), optional :: scf_kind
    STR :: res
    STR :: kind
     kind = .kind
    if (present(scf_kind)) kind = scf_kind 
    select case (kind)
      case("rhf","restricted_hartree_fock");      res = "restricted"
      case("rohf", &
           "restricted_open_shell_hartree_fock"); res = "restricted"
      case("uhf","unrestricted_hartree_fock");    res = "unrestricted"
      case("ghf","general_hartree_fock");         res = "general"
      case("rchf","crhf", &
           "restricted_complex_hartree_fock", &
           "complex_restricted_hartree_fock");    res = "restricted_complex"
      case("uchf","cuhf", &
           "unrestricted_complex_hartree_fock", &
           "complex_unrestricted_hartree_fock");  res = "unrestricted_complex"
      case("gchf","cghf", &
           "general_complex_hartree_fock", &
           "complex_general_hartree_fock");       res = "general_complex"
      case("xray_rhf", &
           "xray_restricted_hartree_fock");       res = "restricted"
      case("rdvpt","restricted_dvpt");            res = "restricted"
      case default; DIE("unknown scf kind")
    end
  end

   orbital_energy_kind(scf_kind) result(res)
   ! Return the kind of vectors used for the orbital energies in a
   ! particular "scf_kind"
      STR(*), optional :: scf_kind
      STR :: res
      res = .orbital_energies_kind(scf_kind)
   end

   orbital_energies_kind(scf_kind) result(res)
   ! Return the kind of vectors used for the orbital energies in a
   ! particular "scf_kind"
      STR(*), optional :: scf_kind
      STR :: res
      STR :: kind
      kind = .kind
      if (present(scf_kind)) kind = scf_kind 
      select case (kind)
         case("rhf","restricted_hartree_fock");             res = "restricted"
         case("rohf","restricted_open_shell_hartree_fock"); res = "restricted"
         case("uhf","unrestricted_hartree_fock");           res = "unrestricted"
         case("ghf","general_hartree_fock");                res = "general"
         case("rchf","crhf", &
              "restricted_complex_hartree_fock", &
              "complex_restricted_hartree_fock");           res = "restricted"
         case("uchf","cuhf", &
              "unrestricted_complex_hartree_fock", &
              "complex_unrestricted_hartree_fock");         res = "unrestricted"
         case("gchf","cghf", &
              "general_complex_hartree_fock", &
              "complex_general_hartree_fock");              res = "general"
         case("xray_rhf","xray_restricted_hartree_fock");   res = "restricted"
         case("rdvpt","restricted_dvpt");                   res = "restricted"
         case default; DIE("unknown scf kind")
      end
   end

   number_kind result(res)
   ! Return the kind of numbers used for a particular "kind"
      STR :: res
      select case (.kind)
         case("rhf","rohf","uhf","ghf");                   res = "real"
         case("rchf","uchf","gchf");                       res = "complex"
         case("restricted_hartree_fock");                  res = "real"
         case("restricted_open_shell_hartree_fock");       res = "real"
         case("unrestricted_hartree_fock");                res = "real"
         case("general_hartree_fock");                     res = "real"
         case("restricted_complex_hartree_fock");          res = "complex"
         case("unrestricted_complex_hartree_fock");        res = "complex"
         case("general_complex_hartree_fock");             res = "complex"
         case("xray_rhf","xray_restricted_hartree_fock");  res = "real"
         case("rdvpt","restricted_dvpt");                  res = "real"
         case default; DIE("unknown scf kind")
      end
   end

!  **************
!  Input routines
!  **************

   read(input)
      TEXTFILE, target, optional :: input
      TEXTFILE, PTR :: in
      STR :: word
      if (present(input)) then
        in => input
      else
        in => stdin
      end
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("end");             exit read_loop
            case("kind");            in.read(.kind) 
            case("scf_kind");        in.read(.kind)
            case("scf_type");        in.read(.kind)
            case("guess");           in.read(.initial_density)
            case("initial_guess");   in.read(.initial_density)
            case("initial_density"); in.read(.initial_density)
            case("initial_mos");     in.read(.initial_mos)
            case("min_it");          in.read(.min_iterations)
            case("min_iterations");  in.read(.min_iterations)
            case("max_it");          in.read(.max_iterations)
            case("max_iterations");  in.read(.max_iterations)
            case("convergence");     in.read(.convergence)
            case("direct");          in.read(.direct)
            case("diis");            in.read(.using_diis)
            case("use_diis");        in.read(.using_diis)
            case("diis_keep");       .diis.set_keep( in.next_int)
            case("diis_start");      .diis.set_start( in.next_int)
            case("use_damping");     in.read(.using_damping)
            case("damp_finish");     in.read(.damp_finish)
            case("damp_factor");     in.read(.damp_factor)
            case("initial_lambda");  in.read(.lambda)
            case("lambda_max");      in.read(.lambda_max)
            case("lambda_step");     in.read(.lambda_step)
            case("use_level_shift");       in.read(.using_level_shift)
            case("use_level_shifting");    in.read(.using_level_shift)
            case("level_shift");           in.read(.level_shift)
            case("output");                in.read(.output)
            case("nddo");                  in.read(.nddo)
            case("nudo");                  in.read(.nudo)
            case("use_b."//"l_term");      in.read(.using_bl_term)
            case("use_b."//"s_term");      in.read(.using_bs_term)
            case("use_b."//"s_t_term");    in.read(.using_bs_t_term)
            case("use_a."//"a_term");      in.read(.using_aa_term)
            case("use_1e_s."//"l_term");   in.read(.using_1e_sl_term)
            case("use_1e_s."//"rxa_term"); in.read(.using_1e_srxa_term)
            case("use_2e_s."//"l_term");   in.read(.using_2e_sl_term)
            case("use_1e_zora_term");      in.read(.using_1e_zora_term)
            case("1e_s."//"l_factor");     in.read(.sl_1e_factor)
            case("s."//"l_1e_factor");     in.read(.sl_1e_factor)
            case("2e_s."//"l_factor");     in.read(.sl_2e_factor)
            case("s."//"l_2e_factor");     in.read(.sl_2e_factor)
            case("eri_cutoff");            in.read(.eri_limit)
            case default;            DIE("unknown keyword, " // word.trim)
         end 
      end do read_loop
      ENSURE(.kind/="","no scf kind specified")
      ENSURE(.max_iterations>=.min_iterations,"max_it must be greater than min_it!")
      if (.initial_mos/="--not used--") .initial_density = "--using MO's--"
      if (.using_1e_zora_term) .using_1e_sl_term = FALSE
      if (.using_1e_sl_term)   .using_1e_zora_term = FALSE
   end

!  *****
!  Tests
!  *****

   scf_done result(res)
   ! Return TRUE if the scf procedure is done
      BIN :: res
      res = (.converged OR .exceeded_max_it) AND .exceeded_min_it
   end

   converged result(res)
   ! Return TRUE if the SCFDATA appears to be converged
      BIN :: res
      res = (abs(.difference) < .convergence) &
            AND (abs(.diis_error) < sqrt(.convergence)) &
            AND (.iteration > 1)
   end

   diis_error result(res)
   ! Return a numerical measure of the diis error
      DBL :: res
      if (.diis_used) then; res = .diis%error_length
      else;                 res = ZERO
      end
   end

   exceeded_max_it result(res)
   ! Return TRUE if the SCFDATA has exceeded the maximum iterations
      BIN :: res
      res = .iteration >= .max_iterations
   end

   exceeded_min_it result(res)
   ! Return TRUE if the SCFDATA has exceeded the minimum iterations
      BIN :: res
      res = .iteration >= .min_iterations
   end

   exceeded_lambda_max result(res)
   ! Return TRUE if the SCFDATA has exceeded the maximum lambda
      BIN :: res
      res = .lambda > 1.000001d0 * .lambda_max   ! 1.00001 because they are real
   end

   eri_cutoff result(res)
     DBL :: res
     res = .eri_limit
     select case (.iteration)
       case (0);  res = res * TOL(5)
       case (1);  res = res * TOL(4)
       case (2);  res = res * TOL(3)
       case (3);  res = res * TOL(2)
       case (4);  res = res * TOL(1)
     end
   end

!  **********************
!  DIIS tests. Be careful
!  **********************

   diis_used result(res)
   ! Return TRUE if DIIS extrapolation has *really* been used this iteration
   ! (The first time doesn't really count)
      BIN :: res
      if (NOT .using_diis) then; res = FALSE
      else;                      res = (.iteration >  .diis%start)
      end
   end

   diis_not_used result(res)
   ! Return TRUE if DIIS extrapolation has NOT really been used this iteration
   ! (The first time doesn't really count)
      BIN :: res
      res = NOT .diis_used
   end

   apply_diis result(res)
   ! Return TRUE if DIIS extrapolation must be, or has been applied this
   ! iteration
      BIN :: res
      if (NOT .using_diis) then; res = FALSE
      else;                      res = (.iteration >= .diis%start)
      end
   end

   skip_diis result(res)
   ! Return TRUE if DIIS extrapolation must NOT be applied this iteration
      BIN :: res
      res = NOT .apply_diis
   end

   apply_damping result(res)
   ! Return TRUE if density matrix damping is to be applied this iteration
      BIN :: res
      res = .using_damping AND .iteration <= .damp_finish
   end

   apply_level_shifting result(res)
   ! Return TRUE if level shifting must be applied this iteration
      BIN :: res
      res = .level_shift.is_not_zero &
            AND .using_level_shift &
            AND .diis_not_used
   end

  fitting result(res)
  ! Return true if we are fitting the wavefunction.
    BIN :: res
    select case (.kind)
      case("xray_rhf","xray_restricted_hartree_fock");   res = TRUE
      case default;                                      res = FALSE
    end
  end

!  ***************
!  Output routines
!  ***************

  put_summary
  ! Prints out a summary of what is stored in the scfdata object.
    stdout.show("SCF kind                 = ", .kind)
    stdout.show("Initial density          = ", .initial_density)
    stdout.show("Initial MO's             = ", .initial_mos)
    stdout.show("Nuclear Energy           = ", .nuclear_energy)
    stdout.show("SCF Energy               = ", .energy)
    stdout.show("Kinetic Energy           = ", .kinetic_energy)
    stdout.show("Convergence              = ", .convergence)
    stdout.show("Minimum iterations       = ", .min_iterations,dbl_width=TRUE)
    stdout.show("Maximum iterations       = ", .max_iterations,dbl_width=TRUE)
    stdout.show("Direct                   = ", .direct,dbl_width=TRUE)
    if (.nddo) &
    stdout.show("NDDO                     = ", .nddo,dbl_width=TRUE)
    if (.using_level_shift) then
    stdout.show("Level shift              = ", .level_shift)
    else
    stdout.show("Using level shift        = ", .using_level_shift,dbl_width=TRUE)
    end
    if (.using_damping) then
    stdout.show("Damping factor           = ", .damp_factor)
    stdout.show("Damping quits at         = ", .damp_finish,dbl_width=TRUE)
    else
    stdout.show("Using density damping    = ", .using_damping,dbl_width=TRUE)
    end
    if (.using_diis) then;                  .diis.put(stdout)
    else
    stdout.show("Using DIIS               = ", .using_diis,dbl_width=TRUE)
    end
    if (.spinorbital_kind=="general_complex") then
      stdout.show("Using B:L term           = ", .using_bl_term)
      stdout.show("Using B:S term           = ", .using_bs_term)
      stdout.show("Using B:S T term         = ", .using_bs_t_term)
      stdout.show("Using A:A term           = ", .using_aa_term)
      stdout.show("Using 1e S:L term        = ", .using_1e_sl_term)
      stdout.show("Using 1e S:(rxA) term    = ", .using_1e_srxa_term)
      stdout.show("Using 2e S:L term        = ", .using_2e_sl_term)
      stdout.show("Factor for 1e S:L term   = ", .sl_1e_factor)
      stdout.show("Factor for 2e S:L term   = ", .sl_2e_factor)
    end
    if (.fitting) then
      stdout.show("lambda fitting parameter =", .lambda)
      stdout.show("lambda max               =", .lambda_max)
      stdout.show("lambda step              =", .lambda_step)
      .put_crystal
    end
    stdout.flush
  end

  put_banner
  ! Prints out the nuclear energy and initial guess energy.
    if (NOT .output) return
    stdout.flush
    stdout.text("***************")
    stdout.text("SCF calculation")
    stdout.text("***************")
    stdout.flush
    .put_summary
  end

  put_table_head
  ! Prints out the table head for an SCF calculation
    INT :: fields
    if (NOT .output) return
    fields = 2
    if (.fitting)     fields = fields + 2
    if (.using_diis)  fields = fields + 1
    stdout.dash(dbl_fields=fields,int_fields=1)
    stdout.put("Iter",int_width=TRUE)
    if (.fitting) then
      stdout.put("lambda")
      stdout.put("chi2")
    end
    stdout.put("Energy")
    stdout.put("Difference")
    if (.using_diis) stdout.put("DIIS Error")
    stdout.flush
    stdout.dash(dbl_fields=fields,int_fields=1)
  end

  put_results
  ! Print out the results for the current iteration
  ! This routine must be compatible with put_banner.
    INT :: fields
    if (NOT .output) return
    if (.iteration == 1 AND .lambda_iteration < 1) .put_table_head
    stdout.put(.iteration)
    fields = 2
    if (.fitting) then
      fields = fields + 2
      stdout.put(.lambda)
      stdout.put(.chi2)
    end
    stdout.put(.energy)
    stdout.put(.difference)
    if (.using_diis) then
      fields = fields + 1
      if (.diis_used) then
        stdout.put(.diis_error)
      else
        stdout.put("-")
      end
    end
    stdout.flush
    if (.scf_done) then
       stdout.dash(dbl_fields=fields,int_fields=1)
       if (.converged) then; stdout.text("* * * SCF has converged * * *",flush=1)
       else;                 stdout.text("* * * SCF has not converged * * *",flush=1)
       end
       stdout.dash(dbl_fields=fields,int_fields=1)
       .put_energy
       .put_kinetic_energy
       if (.fitting) .put_crystal
       stdout.dash(dbl_fields=fields,int_fields=1)
    end
  end

  put_energy
  ! Prints out the SCF energy.
    stdout.show("SCF Energy               = ", .energy)
  end

  put_kinetic_energy
  ! Prints out the kinetic energy.
    stdout.show("Kinetic Energy           = ", .kinetic_energy)
  end

  put_crystal
  ! Prints out the crystal structure factor statistics.
    stdout.show("Chi^2                    = ", .chi2)
    stdout.show("Goodness of fit          = ", .gof)
    stdout.show("R factor                 = ", .r_factor)
    stdout.show("Weighted R factor        = ", .weighted_r_factor)
  end

end 
