! $Id$
!---------------------------------------------------------------------------
!
!  CVECDIIS:  DIIS Extrapolation technique for complex vectors
!
!  (c) dylan jayatilaka, 1997
!
!---------------------------------------------------------------------------
module CVECDIIS

   use TYPES
   use ERROR
   use MM
   use INT
   use STR
   use CVEC
   use CMAT
   use OUTPUT
   use ARCHIVE

   implicit none         

#include "macros"
#include "cvecdiis.int"

!  type cvecdiis_type
!     INT :: keep
!     INT :: start
!     INT :: n_vec
!     INT :: new
!     DBL :: error_length
!     ARCHIVE :: archive
!     CMAT*  :: diis
!     CVEC*  :: coeff
!  end
   
contains

   create(root_name,name,kind,format,keep,start)
   ! Create the DIIS object with dimension "dim", but no archive name
      PTR :: self
      STR, optional :: root_name,name
      STR, optional :: kind,format
      INT, IN, optional :: keep,start
      allocate(self)
      std_mm.add(CVECDIIS_SIZE)
      .nullify_ptr_part
      .set_default
      .archive.set_names(root_name,name,kind,format)
      .set(keep,start)
   end

   destroy
   ! Destroy the DIIS object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      std_mm.delete(CVECDIIS_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      nullify(.diis)
      nullify(.coeff)
      .archive.nullify_ptr_part
   end

   destroy_ptr_part
   ! Destroy the pointer parts of self
      .diis.destroy
      .coeff.destroy
      .archive.destroy_ptr_part
   end

   set_default
   ! Set up the default settings
      .keep  = DIIS_KEEP
      .start = DIIS_START
      .n_vec = 0
      .new = 0
      .error_length = ZERO
      .archive.set_default
      .destroy_ptr_part ! ensure ptr parts are nullified first !
   end

   set(keep,start)
   ! Set the number of DIIS objects to keep
      INT, IN, optional :: keep,start
      if (present(keep))  .set_keep(keep)
      if (present(start)) .set_start(start)
   end

   set_keep(keep)
   ! Set the number of DIIS objects to keep
      INT, IN :: keep
      .keep = keep
   end

   set_start(start)
   ! Set the number of DIIS objects to keep
      INT, IN :: start
      .start = start
   end

   set_archive_root_name(root_name)
   ! Set the DIIS archive to have root name "root_name".
      STR(*) :: root_name
      .archive.set_root_name(root_name)
   end

   set_archive_name(name)
   ! Set the DIIS archive name. 
      STR(*) :: name
      .archive.set_name(name)
   end

   set_archive_format(format)
   ! Set the DIIS archive format. 
      STR(*) :: format
      .archive.set_format(format)
   end

   worst_item result(res)
   ! Return the index of the item with the worst error in the DIIS archive
      INT :: res
      CVEC* :: diag
      diag.create(.dimension)             
      .diis.get_diagonal(diag)            ! the error vector lengths^2
      res = diag.index_of_largest_value   ! Worst item has the largest error
      diag.destroy
   end
 
   next_replacement result(res)
   ! Return the index of the next item in the DIIS expansion 
   ! which is to be replaced/saved 
      INT :: res
      if (.n_vec<=.keep) then
         res = .n_vec
      else
         res = .worst_item
      end
   end

   save_pair(par,err,item)
   ! Save/replace the current vectors on an archive with item number "item",
   ! or item number ".new" if "item" is not present.
      CVEC :: par,err
      INT, optional :: item
      INT :: i
      STR :: old_name 
      i = .new
      if (present(item)) i = item
      old_name = .archive%name
      .archive.set_name( old_name.trim // ",p" // i.to_str.trim)
      .archive.write(par)
      .archive.set_name( old_name.trim // ",e" // i.to_str.trim)
      .archive.write(err)
      .archive.set_name(old_name)
   end

   get_error_item(i,err)
   ! Get the error item "i" in vector "err"
      INT :: i
      CVEC :: err
      STR :: old_name 
      old_name = .archive%name
      .archive.set_name( old_name.trim // ",e" // i.to_str.trim)
      .archive.read(err)
      .archive.set_name(old_name)
   end

   get_parameter_item(i,par)
   ! Get the error item "i" in vector "err"
      INT :: i
      CVEC :: par
      STR :: old_name 
      old_name = .archive%name
      .archive.set_name( old_name.trim // ",p" // i.to_str.trim)
      .archive.read(par)
      .archive.set_name(old_name)
   end

   copy_old_diis_matrix
   ! Copy the old DIIS matrix to the new, if it is smaller
      INT :: dim
      CMAT* :: old_diis
      dim = .dimension
      if (.n_vec==1) then
         .diis.create(dim,dim); .diis = ZERO 
      else if (.n_vec<=.keep) then
         old_diis => .diis
         nullify(.diis)
         .diis.create(dim,dim); .diis = ZERO 
         .diis(: .n_vec, : .n_vec) = old_diis
         old_diis.destroy
      end
   end

   make_diis_matrix(err,old_vec)
   ! Make the current diis matrix using "err" as the current error vector
   ! for item ".new"
      CVEC :: err,old_vec
      INT :: dim,old
      .copy_old_diis_matrix
      dim = .dimension
      do old = 1,dim-1                         ! Calculate the DIIS matrix
         .get_error_item(old,old_vec)
         .diis(max(.new,old),min(.new,old)) = dot_product(err,old_vec)
         .diis(dim,old) = ONE
      end
      .diis(dim,dim) = ZERO
      .diis.hermitian_reflect
      .error_length = sqrt(.diis(.new,.new))
   end

   update(par,old_vec)
   ! Update the parameter vector "par", using "old_vec" as space 
      CVEC :: par,old_vec
      INT :: old,dim
      dim = .dimension
      par = ZERO                            
      do old = 1,dim-1                         ! Form revised parameter vector
         .get_parameter_item(old,old_vec)
         par = par + .coeff(old)*old_vec
      end
   end

   dimension result(res)
   ! Return the dimension of the DIIS matrix
      INT :: res
      res = min(.n_vec,.keep)+1  
   end
   
   extrapolate(par,err)
   ! DIIS extrapolation of "par", using "err" as the error vector.
      CVEC :: par,err
      INT :: dim
      CVEC* :: rhs
      STR :: blank = ""
      ENSURE( .archive.file_name/=blank,"no archive name specified")
      .n_vec = .n_vec+1
      .new = .next_replacement
      .save_pair(par,err,item=.new)
      .make_diis_matrix(err,par)             ! Calculate the new diis matrix
      .diis( .new, .new)=.diis( .new, .new)*1.02d0   ! Weight the last vector a bit more
      .get_parameter_item(.new,par)
      if (.n_vec==1) return
      if (associated( .coeff)) .coeff.destroy
      dim = .dimension
      .coeff.create(dim); .coeff = ZERO              ! the diis coefficients
      rhs.create(dim); rhs = ZERO; rhs(dim) = ONE
      .diis.solve_linear_equations(rhs,.coeff)       ! Solve diis equations; diis c = b = (0 0 *** 1)
      rhs.destroy
      .update(par,err)
      .get_error_item(.new,err)
   end

  put(out)
  ! Prints out the DIIS data to file "out"
    OUTPUT :: out
    out.flush
    out.put_text("DIIS data ",flush=1)
    out.show("Archive root name  =", .archive%root_name)
    out.show("No to keep         =", .keep)
    out.show("Start iteration    =", .start)
    out.flush
  end

end
