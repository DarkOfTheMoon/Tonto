!-------------------------------------------------------------------------------
!
! MOL: these routines required by several modules in mol.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_COMMON

   use TYPES
   use SYSTEM
   use STR
   use INT
   use IVEC
   use VEC
   use MAT
   use CMAT
   use OPVEC
   use OPMAT
   use FILE
   use TEXTFILE
   use ARCHIVE
   use SHELL
   use SHELL1
   use SHELL2
   use SHELL4
   use BASIS
   use BASISVEC
   use ATOM
   use ATOMVEC
   use POINTGROUP
   use CRYSTAL
   use PLOTGRID
   use DFTGRID
   use SCFDATA

   implicit none         

#  include "macros"
#  include "mol_common.int"

contains

!  **************************
!  Create and destroy methods
!  **************************

   create 
   ! Create a molecule object
      PTR :: self
      allocate(self)
      .nullify_ptr_part
      .set_defaults
      ADD_MEM(MOL_SIZE)
   end

   destroy 
   ! Destroy a molecule object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      deallocate(self)
      DELETE_MEM(MOL_SIZE)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the molecule
      nullify(.in)
      nullify(.out)
      nullify(.crystal)
      nullify(.pointgroup)
      nullify(.atom)
      nullify(.basis)
      nullify(.grid)
      nullify(.dftgrid)
      nullify(.atom_for_shell)
      nullify(.atom_shell_for_shell)
      nullify(.first_shell_for_atom)
      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.first_basis_fn_for_atom)
      nullify(.last_basis_fn_for_atom)
      nullify(.atom_kind)
      nullify(.unique_atom)
      nullify(.scfdata)
      nullify(.orbital_energies)
      nullify(.molecular_orbitals)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation)
      nullify(.fock_matrix)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of a molecule object
      .in.destroy
      .out.destroy
      .crystal.destroy
      .pointgroup.destroy
      if (.atom.created) .atom.nullify_basis_part ! nullify this !
      .atom.destroy
      .basis.destroy
      .grid.destroy
      .dftgrid.destroy
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .atom_kind.destroy
      .unique_atom.destroy
      .scfdata.destroy
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation.destroy
      .fock_matrix.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has not been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_defaults [leaky]
   ! Set up a default molecule
      .E_field = ZERO
      .B_field = ZERO
      .gauge_origin = ZERO
      .quantization_axis = (/ ZERO, ZERO, ONE /)
      .charge = 0
      .mult = 1
      .optimise_thermals = FALSE
      if ( .atom.created) then
        .mult = .atom.default_multiplicity
        .set_atom_info
      end
   end

   set_atom_info [leaky]
   ! Set the associated atom information
      .n_atom = .no_of_atoms
      .n_e = .no_of_electrons
      .n_a = .no_of_alpha_electrons
      .n_b = .no_of_beta_electrons
      .atom_kind.create(.n_atom)
      .atom.make_atom_kind_list(.atom_kind,.n_atom_kind)
      .unique_atom.create(.n_atom_kind)
      .atom.make_unique_atom_list(.unique_atom)
   end

   resolve_basis_labels [leaky]
   ! Match the basis set labels for every atom with the actual atomic basis set.
   ! Also perform any initialization procedures to finalise all data objects
      if ( .basis.destroyed) return
      if ( .atom.destroyed) return
      if ( .atom.bases_are_not_all_labeled) return
      .atom.resolve_basis_labels(.basis)
      .n_basis = .no_of_basis_sets
      .set_basis_info
    ! .delete_scf_integrals
   end

   resolve_axis_system 
   ! Change the axis system to crystal coordinates, if required.
      if ( .crystal.destroyed) return
      if ( .atom.destroyed) return
      .atom.resolve_axis_system(.crystal)
   end

   set_basis_info [leaky]
   ! Set the associated basis set information
      .n_basis = .no_of_basis_sets
      .n_bf = .no_of_basis_functions
      .n_prim = .no_of_primitives
      .n_shell = .no_of_shells
      .n_shell_pairs = .no_of_shell_pairs
      .molecular_orbitals.create( .n_bf)
      .orbital_energies.create( .n_bf)
      .density_matrix.create( .n_bf)
      .natural_orbitals.create( .n_bf)
      .occupation.create( .n_bf)
      .fock_matrix.create( .n_bf)
      .make_shell_info
   end

   delete_scf_integrals
   ! Delete all integral files. This is required whenever the geometry is
   ! changed.
      ARCHIVE :: archive
      archive.set(.name,"overlap_matrix"); archive.delete
      archive.set(.name,"kinetic_matrix"); archive.delete
      archive.set(.name,"nuclear_matrix"); archive.delete
      archive.set(.name,"core_matrix");    archive.delete
      archive.set(.name,"fock_matrix");    archive.delete
      archive.set(.name,"eri_integrals");  archive.delete
      archive.set(.name,"eri_index");      archive.delete
      archive.set(.name,"ft_ints");        archive.delete
   end

   assign_natural_orbitals
   ! Assign the natural orbitals to be the molecular_orbitals 
      STR :: kind
      .natural_orbitals => .molecular_orbitals
      kind = .natural_orbitals.spinorbital_kind
      .occupation.create(kind)
      .occupation.zero
      select case ( .molecular_orbitals.spinorbital_kind)
         case ("restricted")
            .occupation%restricted(1:.n_a) = TWO
         case ("unrestricted")
            .occupation%alpha(1:.n_a) = ONE
            .occupation%beta(1:.n_b) = ONE
         case ("general")
            .occupation%general(1:.n_e) = ONE
         case ("restricted_complex")
            .occupation%restricted(1:.n_a) = TWO
         case ("unrestricted_complex")
            .occupation%alpha(1:.n_a) = ONE
            .occupation%beta(1:.n_b) = ONE
         case ("general_complex")
            .occupation%general(1:.n_e) = ONE
      end
   end

!  ***************************
!  ATOMVEC information methods
!  ***************************
 
   nuclear_energy result(res)
   ! Return the nuclear repulsion energy
      DBL :: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.nuclear_energy
   end

   chemical_formula result(res)
   ! Return the chemical formula for the molecule, as a string, in alphabetical 
   ! order of elements
      STR :: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.chemical_formula
   end

   centre_of_mass result(centre)
   ! Return the centre of mass
      VEC(3) :: centre
      ENSURE( .atom.created,"atom list required")
      centre = .atom.centre_of_mass
   end
 
   move_origin_to_centre_of_mass
   ! Move the origin to the centre of mass
      VEC(3) :: com
      INT :: a
      ENSURE( .atom.created,"atom list required")
      com = .atom.centre_of_mass
      do a = 1,.n_atom
         .atom(a)%pos = .atom(a)%pos - com
      end
   end

   molecular_weight result(res)
   ! Return the molceular weight
      DBL:: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.molecular_weight
   end

   reduced_mass result(res)
   ! Return the reduced mass
      DBL:: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.reduced_mass
   end

   centre_of_atoms result(centre)
   ! Return the centroid of the atom positions
      VEC(3) :: centre
      ENSURE( .atom.created,"atom list required")
      centre = .atom.centre_of_atoms
   end

   atom_index_from_pos(pos) result(res)
   ! Return the index of atom from its position "pos"
      VEC(3) :: pos
      INT :: res
      ENSURE( .atom.created,"atom list required")
      res = .atom.atom_index_from_pos(pos)
   end

   get_geometry(g)
   ! Return the geometry "g" in a matrix
      MAT :: g
      ENSURE( .atom.created,"no atom list")
      .atom.get_geometry(g)
   end

   get_crystal_geometry(g)
   ! Return the crystal (fractional coordinate) geometry "g" in a matrix
      MAT :: g
      INT :: n
      .get_geometry(g)
      if (size(g,1)==3) then
         do n = 1,.n_atom
            .crystal.inverse_cell_matrix.rotate(g(:,n))
         end
      else if (size(g,2)==3) then
         do n = 1,.n_atom
            .crystal.inverse_cell_matrix.rotate(g(n,:))
         end
      end
   end

!  ********************************
!  ATOMVEC shell extraction methods
!  ********************************

   get_shell(index,shell) [leaky]
   ! Get basis set shell "index" in "sh" 
      INT, IN :: index
      SHELL, OUT :: shell
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy( .atom(aa)%basis%shell(sa) )
   end

   get_shell1(index,shell) [leaky]
   ! Update the shell1 "shell".
      INT, IN :: index
      SHELL1, OUT :: shell
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(shell=.atom(aa)%basis%shell(sa),pos=.atom(aa)%pos)
   end

   get_shell1(index,shell,fa,la) [leaky]
   ! Update the shell1 "shell".
      INT, IN :: index
      SHELL1, OUT :: shell
      INT, OUT :: fa,la
      INT :: aa,sa
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      shell.copy(shell=.atom(aa)%basis%shell(sa),pos=.atom(aa)%pos)
   end

   get_shell_pair(index,shell,a,b) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b
      INT :: aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                  .atom(aa)%pos, .atom(bb)%pos )
   end

   get_shell_pair(index,a,b,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      INT, OUT :: a,b,fa,la,fb,lb
      .get_shell_pair(index,a,b)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: fa,la,fb,lb
      INT :: a,b,aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                  .atom(aa)%pos, .atom(bb)%pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,a,b,fa,la,fb,lb) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL2, OUT :: shell
      INT, OUT :: a,b,fa,la,fb,lb
      INT :: aa,sa,bb,sb
      .get_shell_pair(index,a,b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      shell.copy( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                  .atom(aa)%pos, .atom(bb)%pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair(index,shell,a,b,fa,la,fb,lb,atom_a,atom_b) [leaky]
   ! Get the SHELL2 object "sh" correponding to the pair index "index"
   ! Also return the actual shell indicies "a" and "b" which map to "index"
   ! Plus the atoms the shells are located on, "atom_a" and "atom_b".
     INT, IN :: index
     SHELL2, OUT :: shell
     INT, OUT :: a,b,fa,la,fb,lb,atom_a,atom_b
     INT :: sa,sb
     .get_shell_pair(index,a,b)
     atom_a = .atom_for_shell(a)
     atom_b = .atom_for_shell(b)
     sa = .atom_shell_for_shell(a)
     sb = .atom_shell_for_shell(b)
     shell.copy( .atom(atom_a)%basis%shell(sa), .atom(atom_b)%basis%shell(sb), &
                 .atom(atom_a)%pos, .atom(atom_b)%pos )
     fa = .first_basis_fn_for_shell(a)
     fb = .first_basis_fn_for_shell(b)
     la = .last_basis_fn_for_shell(a)
     lb = .last_basis_fn_for_shell(b)
   end
 
   get_shell_pair(index,a,b)
   ! Return the actual shell indicies "a" and "b" which map to "index"
     INT, IN :: index
     INT, OUT :: a,b
     a  = (1+sqrt(8.0d0*index-7.0d0))/2
     b  = index - a*(a-1)/2
   end

   get_shell_quartet(index,a,b,c,d)
   ! Get the indexes a,b,c,d of the quartet from the "index".
   ! Note that "index" will die at 361 shells for integer(4).
     INT, IN :: index
     INT, OUT :: a,b,c,d
     INT :: ab,cd
     ab = (1+sqrt(8.0d0*index-7.0d0))/2
     cd = index - ab*(ab-1)/2
     a  = (1+sqrt(8.0d0*ab-7.0d0))/2
     b  = ab - a*(a-1)/2
     c  = (1+sqrt(8.0d0*cd-7.0d0))/2
     d  = cd - c*(c-1)/2
   end

   get_shell_quartet(shell,a,b,c,d) [leaky]
   ! Get the SHELL4 object "sh" correponding to the indicies "a", "b", "c" and
   ! "d".
      SHELL4, OUT :: shell
      INT, IN :: a,b,c,d
      INT :: aa,sa,bb,sb,cc,sc,dd,sd
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                  .atom(cc)%basis%shell(sc), .atom(dd)%basis%shell(sd), &
                  .atom(aa)%pos, .atom(bb)%pos, .atom(cc)%pos, .atom(dd)%pos )
   end

   get_shell_quartet(index,shell,a,b,c,d) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d
      .get_shell_quartet(index,a,b,c,d)
      .get_shell_quartet(shell,a,b,c,d)
   end

   get_shell_quartet(index,shell,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld
      .get_shell_quartet(index,a,b,c,d)
      .get_shell_quartet(shell,a,b,c,d)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet(index,fa,la,fb,lb,fc,lc,fd,ld) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      INT, IN :: index
      INT, OUT :: fa,la,fb,lb,fc,lc,fd,ld
      INT :: a,b,c,d
      .get_shell_quartet(index,a,b,c,d)
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet(index,shell,a,b,c,d,atom_a,atom_b,atom_c,atom_d) [leaky]
   ! Get the SHELL4 object "sh" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Plus the atoms which the shells are on.
      INT, IN :: index
      SHELL4, OUT :: shell
      INT, OUT :: a,b,c,d,atom_a,atom_b,atom_c,atom_d
      .get_shell_quartet(index,a,b,c,d)
      .get_shell_quartet(shell,a,b,c,d)
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)
   end

   set_shell_quartet_ab(shell,a,b) [leaky]
   ! Set the a and b parts of the SHELL4 object.
     SHELL4, INOUT :: shell
     INT, IN :: a,b
     INT :: aa,sa,bb,sb
     aa = .atom_for_shell(a)
     sa = .atom_shell_for_shell(a)
     bb = .atom_for_shell(b)
     sb = .atom_shell_for_shell(b)
     shell.copy_ab( .atom(aa)%basis%shell(sa), .atom(bb)%basis%shell(sb), &
                 .atom(aa)%pos, .atom(bb)%pos)
   end

   set_shell_quartet_cd(shell,c,d) [leaky]
   ! Set the c and d parts of the SHELL4 object.
     SHELL4, INOUT :: shell
     INT, IN :: c,d
     INT :: cc,sc,dd,sd
     cc = .atom_for_shell(c)
     sc = .atom_shell_for_shell(c)
     dd = .atom_for_shell(d)
     sd = .atom_shell_for_shell(d)
     shell.copy_cd( .atom(cc)%basis%shell(sc), .atom(dd)%basis%shell(sd), &
                 .atom(cc)%pos, .atom(dd)%pos)
   end

   make_contraction_matrix(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      MAT, OUT :: cc_mat
      INT :: a, bf_count, prim_count
      STR :: error_string
      error_string = "contraction matrix has incorrect shape"
      ENSURE(size(cc_mat,1)== .n_prim,error_string)
      ENSURE(size(cc_mat,2)== .n_bf,error_string)
      bf_count = 1
      prim_count = 1
      cc_mat.zero
      do a = 1, .n_atom
         cc_mat( prim_count : prim_count + .atom(a)%basis%n_prim - 1, bf_count : bf_count + .atom(a)%basis%n_bf - 1) &
                  = .atom(a)%basis.contraction_matrix
         prim_count = prim_count + .atom(a)%basis%n_prim
         bf_count = bf_count + .atom(a)%basis%n_bf
      end
   end
   

!  **********************
!  Make shell information
!  **********************

   make_shell_info [leaky]
   ! Define a vector of atom numbers corresponding to the molecule 
   ! basis set shell numbers; also define a vector of atom shell numbers 
   ! corresponding to the molecule basis set shell number
     .atom_for_shell       => .atom.atom_for_shell
     .atom_shell_for_shell => .atom.atom_shell_for_shell
     .first_shell_for_atom => .atom.first_shell_for_atom
     .atom.get_shell_limits(.first_basis_fn_for_shell, .last_basis_fn_for_shell)
     .atom.make_atom_basis_fn_limits(.first_basis_fn_for_atom,.last_basis_fn_for_atom)
   end

!  **********************
!  Density matrix methods
!  **********************

   make_scf_density_matrix(damp,scf_kind) [leaky]
   ! Make the density matrix from the molecular orbitals. If "damp" is present
   ! use it to damp the updated density matrix.
      BIN, optional :: damp
      STR(*), optional :: scf_kind
      BIN :: damping
      OPMAT, PTR :: D_old
      MAT, PTR :: MO,D,MOa,MOb,Da,Db
      CMAT, PTR :: CMO,CD,CMOa,CMOb,CDa,CDb
      ARCHIVE :: archive
      STR :: kind
      DBL :: mix
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .molecular_orbitals.created, "no molecular orbitals")
      if ( .scfdata.destroyed) then;                 damping = FALSE
      else if ( .density_matrix.all_destroyed) then; damping = FALSE
      else
         damping = .scfdata.apply_damping
         if (present(damp)) damping = damp
      end
      D_old.create(.n_bf)
      if (damping) D_old.set_to(.density_matrix)
      if ( .scfdata.destroyed) then; kind = .molecular_orbitals.spinorbital_kind
      else;                          kind = .scfdata.spinorbital_kind
      end
      .density_matrix.destroy(kind)
      .density_matrix.create(kind)
      archive.set(.name,"density_matrix",kind)
      if (present(scf_kind)) then;        kind = scf_kind
      else if ( .scfdata.destroyed) then; kind = .molecular_orbitals.guess_scf_kind
      else;                               kind = .scfdata%kind
      end
      select case (kind)
          case ("rhf","restricted_hartree_fock", &
                "xray_rhf","xray_constrained_restricted_hartree_fock", &
                "xray_fit","xray_constrained")
            DIE_IF(.mult/=1,"this is not a singlet state")
            MO => .molecular_orbitals%restricted(:,1:.n_a)
            D  => .density_matrix%restricted
            D.to_product(MO,MO,transpose_b=TRUE)
            D = TWO*D
         case ("rohf","restricted_open_shell_hartree_fock")
            MOa => .molecular_orbitals%restricted(:,1:.n_a)
            MOb => .molecular_orbitals%restricted(:,1:.n_b)
            Da => .density_matrix%alpha
            Db => .density_matrix%beta
            Da.to_product(MOa,MOa,transpose_b=TRUE)
            Db.to_product(MOb,MOb,transpose_b=TRUE)
         case ("uhf","unrestricted_hartree_fock")
            MOa => .molecular_orbitals%alpha(:,1:.n_a)
            MOb => .molecular_orbitals%beta(:,1:.n_b)
            Da => .density_matrix%alpha
            Db => .density_matrix%beta
            Da.to_product(MOa,MOa,transpose_b=TRUE)
            Db.to_product(MOb,MOb,transpose_b=TRUE)
         case ("ghf","general_hartree_fock")
            DIE_IF(.mult/=1,"this is not a singlet state")
            MO => .molecular_orbitals%general(:,1:.n_e)
            D =>  .density_matrix%general
            D.to_product(MO,MO,transpose_b=TRUE)
         case ("rchf","restricted_complex_hartree_fock")
            CMO => .molecular_orbitals%restricted_complex(:,1:.n_a)
            CD  => .density_matrix%restricted_complex
            CD.to_product(CMO,CMO,dagger_b=TRUE)
            CD = TWO*CD
         case ("uchf","unrestricted_complex_hartree_fock")
            CMOa => .molecular_orbitals%alpha_complex(:,1:.n_a)
            CMOb => .molecular_orbitals%beta_complex(:,1:.n_b)
            CDa => .density_matrix%alpha_complex
            CDb => .density_matrix%beta_complex
            CDa.to_product(CMOa,CMOa,dagger_b=TRUE)
            CDb.to_product(CMOb,CMOb,dagger_b=TRUE)
         case ("gchf","general_complex_hartree_fock")
            CMO => .molecular_orbitals%general_complex(:,1:.n_e)
            CD =>  .density_matrix%general_complex
            CD.to_product(CMO,CMO,dagger_b=TRUE)
      end
      if (damping) then
         mix = .scfdata%damp_factor
         select case (kind)
            case ("rhf","restricted_hartree_fock", &
                  "xray_rhf","xray_constrained_restricted_hartree_fock")
               D = (1-mix)*D + mix*D_old%restricted
            case ("rohf","restricted_open_shell_hartree_fock")
               Da = (1-mix)*Da + mix*D_old%alpha
               Db = (1-mix)*Db + mix*D_old%beta
            case ("uhf","unrestricted_hartree_fock")
               Da = (1-mix)*Da + mix*D_old%alpha
               Db = (1-mix)*Db + mix*D_old%beta
            case ("ghf","general_hartree_fock")
               D = (1-mix)*D + mix*D_old%general
            case ("rchf","restricted_complex_hartree_fock")
               CD = (1-mix)*CD + mix*D_old%restricted_complex
            case ("uchf","unrestricted_complex_hartree_fock")
               CDa = (1-mix)*CDa + mix*D_old%alpha_complex
               CDb = (1-mix)*CDb + mix*D_old%beta_complex
            case ("gchf","general_complex_hartree_fock")
               CD = (1-mix)*CD + mix*D_old%general_complex
        end
      end
      D_old.destroy
      archive.write(.density_matrix)
   end

   make_ao_density_matrix [leaky]
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix.
   ! The result is placed in the "restricted" part of the density matrix
      STR :: kind
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if ( kind=="restricted") return
      if ( kind=="restricted_complex") return
      if ( kind.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (kind)
         case ("unrestricted")
            .density_matrix%restricted = .density_matrix%alpha + .density_matrix%beta
         case ("general")
            .density_matrix%restricted = .density_matrix%general.alpha_alpha &
                                       + .density_matrix%general.beta_beta 
         case ("unrestricted_complex")
            .density_matrix%restricted_complex = .density_matrix%alpha_complex &
                                               + .density_matrix%beta_complex
         case ("general_complex")
            .density_matrix%restricted_complex = .density_matrix%general_complex.alpha_alpha &
                                               + .density_matrix%general_complex.beta_beta 
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   make_ao_sz_density_matrix
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix.
   ! The result is placed in the "restricted" part of the density matrix
      STR :: kind
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      kind = .density_matrix.spinorbital_kind
      if ( kind=="restricted") return
      if ( kind.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (kind)
         case ("unrestricted")
            .density_matrix%restricted = .density_matrix%alpha - .density_matrix%beta
         case ("general")
            .density_matrix%restricted = .density_matrix%general.alpha_alpha &
                                       - .density_matrix%general.beta_beta 
         case ("unrestricted_complex")
            .density_matrix%restricted_complex = .density_matrix%alpha_complex &
                                               - .density_matrix%beta_complex
         case ("general_complex")
            .density_matrix%restricted_complex = .density_matrix%general_complex.alpha_alpha &
                                               - .density_matrix%general_complex.beta_beta 
         case default; DIE("unknown spinorbital kind, " // kind.trim)
      end
   end

   make_scf_density_matrix(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals. 
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      INT :: n
      INT, optional :: nb
      MAT, PTR :: MO,D,MOa,MOb,Da,Db
      CMAT, PTR :: CMO,CD,CMOa,CMOb,CDa,CDb
      STR :: kind
      ARCHIVE :: archive
      INT :: m
      BIN :: uhf
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .molecular_orbitals.created, "no molecular orbitals")
      uhf = .scfdata%kind.includes("unrestricted")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")
      m = n
      if (present(nb)) m = nb
      kind = .scfdata.spinorbital_kind
      .density_matrix.destroy(kind)
      .density_matrix.create(kind)
      archive.set(.name,"density_matrix",kind)
      kind = .scfdata%kind
      select case (kind)
         case ("rhf","restricted_hartree_fock", &
               "xray_rhf","xray_constrained_restricted_hartree_fock", &
               "xray_fit","xray_constrained")
            DIE_IF(.mult/=1,"this is not a singlet state")
            D  => .density_matrix%restricted
            if (n>0 AND n<=.n_a) then
               MO => .molecular_orbitals%restricted(:,n:n)
               D.to_product(MO,MO,transpose_b=TRUE)
               D = TWO*D
            else
               D = ZERO
            end 
         case ("rohf","restricted_open_shell_hartree_fock")
            Da => .density_matrix%alpha
            Db => .density_matrix%beta
            if (n>0 AND n<=.n_b) then
               MOa => .molecular_orbitals%restricted(:,n:n)
               MOb => .molecular_orbitals%restricted(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
               Db.to_product(MOb,MOb,transpose_b=TRUE)
            else if (n>nb AND n<=.n_a) then
               MOa => .molecular_orbitals%restricted(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
               Db = ZERO
            else
               Da = ZERO
               Db = ZERO
            end
         case ("uhf","unrestricted_hartree_fock")
            Da => .density_matrix%alpha
            Db => .density_matrix%beta
            if (n>0 AND n<=.n_a) then
               MOa => .molecular_orbitals%alpha(:,n:n)
               Da.to_product(MOa,MOa,transpose_b=TRUE)
            else
               Da = ZERO
            end
            if (m>0 AND m<=.n_b) then
               MOb => .molecular_orbitals%beta(:,m:m)
               Db.to_product(MOb,MOb,transpose_b=TRUE)
            else
               Db = ZERO
            end
         case ("ghf","general_hartree_fock")
            DIE_IF(.mult/=1,"this is not a singlet state")
            D =>  .density_matrix%general
            if (n>0 AND n<=.n_e) then
               MO => .molecular_orbitals%general(:,n:n)
               D.to_product(MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end 
         case ("rchf","restricted_complex_hartree_fock")
            CD  => .density_matrix%restricted_complex
            if (n>0 AND n<=.n_a) then
               CMO => .molecular_orbitals%restricted_complex(:,n:n)
               CD.to_product(CMO,CMO,dagger_b=TRUE)
               CD = TWO*CD
            else
               CD = ZERO
            end 
         case ("uchf","unrestricted_complex_hartree_fock")
            CDa => .density_matrix%alpha_complex
            CDb => .density_matrix%beta_complex
            if (n>0 AND n<=.n_a) then
               CMOa => .molecular_orbitals%alpha_complex(:,n:n)
               CDa.to_product(CMOa,CMOa,dagger_b=TRUE)
            else 
               CDa = ZERO
            end
            if (m>0 AND m<=.n_b) then
               CMOb => .molecular_orbitals%beta_complex(:,m:m)
               CDb.to_product(CMOb,CMOb,dagger_b=TRUE)
            else 
               CDb = ZERO
            end
         case ("gchf","general_complex_hartree_fock")
            CD =>  .density_matrix%general_complex
            if (n>0 AND n<=.n_e) then
               CMO => .molecular_orbitals%general_complex(:,n:n)
               CD.to_product(CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end 
      end
      archive.write(.density_matrix)
   end


!****************************
!* Overlap Matrix formation *
!****************************


  get_overlap_matrix(S)
  ! Set "S" to the overlap matrix. 
  ! If the archive file exists, read it; otherwise make it.
     MAT :: S
     ARCHIVE :: archive
     archive.set(.name,"overlap_matrix")
     if ( archive.exists) then; archive.read(S)
     else;                      .make_overlap_matrix(S)
     end
  end
 
  make_overlap_matrix(S)
  ! Calculate the overlap matrix "S"
    MAT, target :: S
    INT :: q,fa,la,fb,lb,a,b,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    S = ZERO
  ! if (.scfdata%NDDO) then
  !   do q=1,.n_shell_pairs
  !     .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
  !     if (atom_a==atom_b) then; shell.make_overlap(S(fa:la,fb:lb))
  !     else;                     S(fa:la,fb:lb) = ZERO
  !     end
  !     shell.destroy_ptr_part
  !   end
  ! else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        shell.make_overlap(S(fa:la,fb:lb))
        shell.destroy_ptr_part
      end
  ! end
    S.make_symmetric
    archive.set(.name,"overlap_matrix")
    archive.write(S)
  end

!  ***************
!  Inquiry methods
!  ***************

   no_of_electrons result(res) 
   ! Work out and return the number of electrons in the molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      res = 0
      do a = 1,.no_of_atoms
         res = res + .atom(a)%atomic_number
      end
      res = res - .charge
   end

   no_of_alpha_electrons result(res) 
   ! Work out and return the number of alpha electrons in the molecule
      INT :: res
      res = (.no_of_electrons+.mult-1)/2
   end

   no_of_beta_electrons result(res) 
   ! Work out and return the number of beta electrons in the molecule
      INT :: res
      res = (.no_of_electrons-.mult+1)/2
   end

   no_of_atoms result(res) 
   ! Return the number of atoms in the molecule
      INT :: res
      ENSURE( .atom.created,  "no atom list")
      res = size(.atom)
   end

   no_of_basis_sets result(res) 
   ! Return the number of distinct atomic basis sets for the molecule
      INT :: res
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      res = size(.basis)
   end

   no_of_shells result(res) 
   ! Work out and return the number of gaussian shells in the basis set for the
   ! molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      res = 0
      do a = 1,.n_atom
         res = res + .atom(a)%basis%n_shell
      end
   end

   no_of_shell_pairs result(res) 
   ! Return the number of shell pairs in the basis set for the molecule
      INT :: res
      INT :: n_shell
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      n_shell = .no_of_shells
      res = n_shell*(n_shell+1)/2
   end

   n_shell_quartets result (res)
   ! Return the number of shell quartets in the basis set for the molecule
      INT :: res
      INT :: n_shell_pair
      ! "res" will die at 22 shells for integer(2).
      ! "res" will die at 361 shells for integer(4).
      ! "res" will die at 92681 shells for integer(8).
      n_shell_pair = .no_of_shell_pairs
      DIE_IF(n_shell_pair > (huge(n_shell_pair))**(1/2),"too many shells")
      res = n_shell_pair*(n_shell_pair+1)/2
   end

   no_of_basis_functions result (res)
   ! Work out and return the number of basis functions in the basis set for the
   ! molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      res = 0
      do a = 1,.n_atom
         res = res + .atom(a)%basis%n_bf
      end
   end

   no_of_primitives result (res)
   ! Work out and return the number of primitives in the basis set for the
   ! molecule
      INT :: res
      INT :: a
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      res = 0
      do a= 1,.n_atom
         res = res + .atom(a)%basis%n_prim
      end
   end

   no_of_occupied_NOs(kind,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      STR, optional :: kind
      DBL, optional :: tol
      INT :: res
      STR :: itemkind
      DBL :: eps
      INT :: n,n_bf
      ENSURE( .atom.created,  "no atom list")
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .occupation.created, "no occupation numbers")
      itemkind = .occupation.spinorbital_kind
      if (present(kind)) itemkind=kind
      eps = TOL(7)
      if (present(tol)) eps = tol 
      select case (itemkind)
         case ("restricted")
            n_bf = .occupation%n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation%restricted(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("unrestricted")
            n_bf = .occupation%n_bf
            res = 2*n_bf
            do n = 1,n_bf
               if (.occupation%alpha(n)<eps) then
                  res = n-1
                  exit
               end
            end
            do n = 1,n_bf
               if (.occupation%beta(n)<eps) then
                  res = res + n-1
                  exit
               end
            end
         case ("general")
            n_bf = 2*.occupation%n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation%general(n)<eps) then
                  res = n-1
                  exit
               end
            end
      end
   end

   maximum_basis_set_l_value result (res)
   ! Returns the maximum basis set l value
      INT :: res
      INT :: i,j,l
      res = 0 
      do i = 1,size(.basis)
         do j = 1,size(.basis(i)%shell)
            l = .basis(i)%shell(j)%l
            res = max(l,res)
         end
      end
   end

!  ****************
!  Natural orbitals
!  ****************

   make_natural_orbitals [leaky]
   ! Make the natural orbitals from the density matrix
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      ENSURE( .density_matrix.created, "no density matrix")
      select case ( .density_matrix.spinorbital_kind)
         case ("restricted");         .make_restricted_NOs
         case ("unrestricted");       .make_unrestricted_NOs
!        case ("general");            .make_general_NOs
         case ("restricted_complex"); .make_restricted_complex_NOs
         case ("general_complex");    .make_general_complex_NOs
      end
   end

   make_restricted_NOs [leaky]
   ! Make the restricted natural orbitals from the density matrix
      ENSURE( .density_matrix%restricted.created, "no density matrix")
      .natural_orbitals.destroy("restricted")
      .natural_orbitals.create("restricted")
      .occupation.destroy("restricted")
      .occupation.create("restricted")
      .make_r_NOs(.natural_orbitals%restricted,.occupation%restricted,.density_matrix%restricted)
   end

   make_unrestricted_NOs [leaky]
   ! Make the unrestricted natural orbitals from the density matrix
      ENSURE( .density_matrix%alpha.created, "no density matrix")
      ENSURE( .density_matrix%beta.created, "no density matrix")
      .natural_orbitals.destroy("unrestricted")
      .natural_orbitals.create("unrestricted")
      .occupation.destroy("unrestricted")
      .occupation.create("unrestricted")
      .make_r_NOs(.natural_orbitals%alpha,.occupation%alpha,.density_matrix%alpha)
      .make_r_NOs(.natural_orbitals%beta, .occupation%beta, .density_matrix%beta)
   end

   make_r_NOs(NO,occupation,P)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      MAT :: NO,P
      VEC :: occupation
      MAT, PTR :: V,X,S
      V.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      V.to_sqrt(S)
      S.destroy
      X.create(.n_bf,.n_bf)
      X = P
      X.change_basis(V)
      X.solve_eigenproblem(occupation,V)
      S.create( .n_bf, .n_bf); .get_overlap_matrix(S)
      X.to_inverse_sqrt(S)
      S.destroy
      NO.to_product(X,V)
      X.destroy
      V.destroy
      occupation = occupation(.n_bf:1:-1)
      occupation.zero_small_values(TOL(10))
      NO = NO(:,.n_bf:1:-1)
   end

  make_restricted_complex_NOs [leaky]
  ! Make the restricted complex natural orbitals from the density matrix
    CMAT, PTR :: V,X
    MAT, PTR  :: S,O
    CMAT, PTR :: D
    D => .density_matrix%restricted_complex
    ENSURE( D.created, "no density matrix")
    .natural_orbitals.destroy("restricted_complex")
    .natural_orbitals.create("restricted_complex")
    .occupation.destroy("restricted")
    .occupation.create("restricted")
    V.create(.n_bf,.n_bf)
    X.create(.n_bf,.n_bf)
    O.create(.n_bf,.n_bf)
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    O.to_sqrt(S)
    S.destroy
    V = O
    X = D
    X.change_basis(V)
    X.solve_eigenproblem(.occupation%restricted,V)
    S.create( .n_bf, .n_bf); .get_overlap_matrix(S)
    O.to_inverse_sqrt(S)
    S.destroy
    X = O
    O.destroy
    .natural_orbitals%restricted_complex.to_product(X,V)
    X.destroy
    V.destroy
    .occupation%restricted = .occupation%restricted(.n_bf:1:-1)
    .occupation%restricted.zero_small_values(TOL(10))
    .natural_orbitals%restricted_complex = .natural_orbitals%restricted_complex(:,.n_bf:1:-1)
  end

   make_general_complex_NOs [leaky]
   ! Make the general natural orbitals and occupations from the complex density matrix
      MAT, PTR :: S,R
      CMAT, PTR :: V,X
      BIN :: dens_created
      dens_created = .density_matrix%general_complex.created
      ENSURE(dens_created,"no density matrix")
      .natural_orbitals.destroy("general_complex")
      .natural_orbitals.create("general_complex")
      .occupation.destroy("general")
      .occupation.create("general")
      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      R.to_sqrt(S)
      S.destroy
      V.alpha_alpha_set_to(R)
      V.beta_beta_set_to(R)
      R.destroy
      X.create(2*.n_bf,2*.n_bf)
      X = .density_matrix%general_complex
      X.change_basis(V)
      X.solve_eigenproblem(.occupation%general,V)
      R.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      R.to_inverse_sqrt(S)
      S.destroy
      X.alpha_alpha_set_to(R)
      X.beta_beta_set_to(R)
      R.destroy
      .natural_orbitals%general_complex.to_product(X,V)
      .occupation%general = .occupation%general(2*.n_bf:1:-1)
      .occupation%general.zero_small_values(TOL(10))
      .natural_orbitals%general = .natural_orbitals%general(:,2*.n_bf:1:-1)
      X.destroy
      V.destroy
   end

!  ***************************
!  Population Analysis Methods
!  ***************************
   
   make_mulliken_matrix
   ! sets the mulliken population matrix and the outputs it.
      MAT, PTR :: mulliken_matrix, S
      VEC, PTR :: diagonals
      S.create( .n_bf, .n_bf)
      mulliken_matrix.create( .n_bf, .n_bf)
      diagonals.create( .n_bf)
      .get_overlap_matrix(S)
      mulliken_matrix = matmul( .density_matrix%restricted, S)
      mulliken_matrix.get_diagonal( diagonals)
      .put_mulliken_populations( mulliken_matrix, diagonals)
      S.destroy
      mulliken_matrix.destroy
      diagonals.destroy
   end
   
   put_mulliken_populations( mulliken_matrix, diagonals)
   ! outputs the mulliken populations to mol.out
      MAT :: mulliken_matrix      
      VEC :: diagonals
      DBL :: sum
      INT :: o_count, a, b, c
      .out.flush
      .out.text( "Mulliken population analysis: ")
      .out.dash(int_fields=2,dbl_fields=1)
      .out.put( "Atom", int_width = TRUE)
      .out.put( "Type", int_width = TRUE)
      .out.put( "Population")
      .out.flush
      .out.dash(int_fields=2,dbl_fields=1)
      o_count = 1
      do a = 1, .n_atom
         do b = 1, .atom.n_shell_for_atom(a)
            do c = 1, .atom(a)%basis%shell(b)%n_comp
               .out.put( .atom(a)%label, int_width = TRUE)
               .out.put( .atom(a)%basis%shell(b).l_chr, int_width = TRUE)
               .out.put( diagonals(c + o_count - 1))
               .out.flush
            end
            o_count = o_count + .atom(a)%basis%shell(b)%n_comp
         end
      end
      .out.flush
      .out.text( "Trace of the matrix: ")
      .out.put( mulliken_matrix.trace )
      .out.flush
      .out.text( "Atomic Populations: ")
      .out.dash(int_fields=1, dbl_fields=1)
      .out.put( "Atom", int_width = TRUE)
      .out.put( "Population")
      .out.flush
      .out.dash(int_fields=1, dbl_fields=1)
      o_count = 1
      do a = 1, .n_atom
         .out.put( .atom(a)%label, int_width = TRUE)
         sum = 0
         do b = 1, .atom.n_shell_for_atom(a)
            sum = sum + diagonals(b - 1 + o_count)
         end
         .out.put( sum)
         .out.flush
         o_count = o_count + .atom.n_bf_for_atom(a)
      end
   end

  get_kinetic_matrix(T)
  ! Set "T" to the kinetic matrix
  ! If the archive file exists, read it; otherwise make it.
     MAT :: T
     ARCHIVE :: archive
     archive.set(.name,"kinetic_matrix")
     if ( archive.exists) then; archive.read(T)
     else;                      .make_kinetic_matrix(T)
     end
  end

  make_kinetic_matrix(T)
  ! Calculate the kinetic energy matrix "T"
    MAT :: T
    INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    if (.scfdata%nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then; shell.get_kei(T(fa:la,fb:lb))
        else;                     T(fa:la,fb:lb) = ZERO
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        shell.get_kei(T(fa:la,fb:lb))
        shell.destroy_ptr_part
      end
    end
    T.make_symmetric
    archive.set(.name,"kinetic_matrix")
    archive.write(T)
  end

  get_kinetic_overlap(T,S)
  ! Set "S" to the overlap matrix and "T" to the kinetic matrix
  ! If both archives exists, read them; otherwise make them both!
     MAT :: T,S
     ARCHIVE :: T_archive,S_archive
     S_archive.set(.name,"overlap_matrix")
     T_archive.set(.name,"kinetic_matrix")
     if ((S_archive.exists) AND (T_archive.exists)) then
        S_archive.read(S)
        T_archive.read(T)
     else
        .make_kinetic_overlap(T,S)
     end
  end

  make_kinetic_overlap(T,S)
  ! Calculate the kinetic energy matrix "T" and overlap integral matrix "S"
    MAT :: T,S
    INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    if (.scfdata%nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
        shell.get_kei( T(fa:la,fb:lb), S(fa:la,fb:lb))
        if (atom_a/=atom_b) T(fa:la,fb:lb) = ZERO
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        shell.get_kei( T(fa:la,fb:lb), S(fa:la,fb:lb))
        shell.destroy_ptr_part
      end
    end
    S.make_symmetric
    T.make_symmetric
    archive.set(.name,"kinetic_matrix")
    archive.write(T)
    archive.set(.name,"overlap_matrix")
    archive.write(S)
  end

  get_nuclear_matrix(Z)
  ! Set "Z" to the nuclear attraction matrix.
  ! If the archive file exists, read it; otherwise make it.
     MAT :: Z
     ARCHIVE :: archive
     archive.set(.name,"nuclear_matrix")
     if ( archive.exists) then; archive.read(Z)
     else;                      .make_nuclear_matrix(Z)
     end
  end

  make_nuclear_matrix(Z)
  ! Calculate the nuclear attraction matrix "Z"
    MAT :: Z
    ATOM, PTR :: atom
    MAT, PTR :: Z_c
    INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    Z = ZERO
    if (.scfdata%nddo) then
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,a,b,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then
          Z_c.create(shell%a%n_comp,shell%b%n_comp)
          do c=1,.n_atom
            atom=>.atom(c)
            shell.get_nuc(Z_c, atom.mass,atom%pos)
          ! shell.make_nuclear_attraction_ints(Z_c, atom%pos)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom%atomic_number * Z_c
          end
          Z_c.destroy
        end
        shell.destroy_ptr_part
      end
    else
      do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        Z_c.create(shell%a%n_comp,shell%b%n_comp)
        do c=1,.n_atom
          atom=>.atom(c)
        ! shell.get_nuc(Z_c, atom.mass,atom%pos)
          shell.make_nuclear_attraction_ints(Z_c, atom%pos)
          Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom%atomic_number * Z_c
        end
        Z_c.destroy
        shell.destroy_ptr_part
      end
    end
    Z.make_symmetric
    archive.set(.name,"nuclear_matrix")
    archive.write(Z)
  end

  get_core_matrix(H)
  ! Get the core hamiltonian matrix. If already in memory, do nothing. Else if
  ! the archive file exists, read it. Otherwise make it.
     MAT :: H
     ARCHIVE :: archive
     archive.set(.name,"core_matrix")
     if ( archive.exists) then; archive.read(H)
     else;                     .make_core_matrix(H)
     end
  end

  make_core_matrix(H)
  ! Get the core hamiltonian matrix "H".
     MAT :: H
     MAT, PTR :: Z
     ARCHIVE :: archive
     .get_kinetic_matrix(H)
     Z.create( .n_bf, .n_bf)
     .get_nuclear_matrix(Z)
     H = H + Z
     Z.destroy
     archive.set(.name,"core_matrix")
     archive.write(H)
  end

  get_dipole_matrices(Dx,Dy,Dz)
  ! Set "Di" to the dipole moment integral matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Dx,Dy,Dz
     ARCHIVE :: x_archive,y_archive,z_archive
     x_archive.set(.name,"dipole_x_matrix")
     y_archive.set(.name,"dipole_y_matrix")
     z_archive.set(.name,"dipole_z_matrix")
     if (x_archive.exists) then
        x_archive.read(Dx); y_archive.read(Dy); z_archive.read(Dz)
     else
        .make_dipole_matrices(Dx,Dy,Dz)
     end
  end

  make_dipole_matrices(Dx,Dy,Dz)
  ! Make "Di", the dipole moment integral matrices.
     MAT :: Dx,Dy,Dz
     MAT, PTR :: DDx,DDy,DDz
     INT :: q,c,a,b,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     Dx = ZERO; Dy = ZERO; Dz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell%a%n_comp; n_b = shell%b%n_comp
        DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
        shell.make_dipole_ints(DDx,DDy,DDz, .gauge_origin)
        Dx(fa:la,fb:lb) = Dx(fa:la,fb:lb) + DDx
        Dy(fa:la,fb:lb) = Dy(fa:la,fb:lb) + DDy
        Dz(fa:la,fb:lb) = Dz(fa:la,fb:lb) + DDz
        shell.destroy_ptr_part
        DDz.destroy; DDy.destroy; DDx.destroy
     end
     Dx.make_symmetric; Dy.make_symmetric; Dz.make_symmetric
     archive.set(.name,"dipole_x_matrix"); archive.write(Dx)
     archive.set(.name,"dipole_y_matrix"); archive.write(Dy)
     archive.set(.name,"dipole_z_matrix"); archive.write(Dz)
  end

  get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
  ! Set "Qij" to the quadrupole moment integral matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
     ARCHIVE :: xx_archive,yy_archive,zz_archive
     ARCHIVE :: xy_archive,xz_archive,yz_archive
     xx_archive.set(.name,"quadrupole_xx_matrix")
     yy_archive.set(.name,"quadrupole_yy_matrix")
     zz_archive.set(.name,"quadrupole_zz_matrix")
     xy_archive.set(.name,"quadrupole_xy_matrix")
     xz_archive.set(.name,"quadrupole_xz_matrix")
     yz_archive.set(.name,"quadrupole_yz_matrix")
     if (xx_archive.exists) then
        xx_archive.read(Qxx); yy_archive.read(Qyy); zz_archive.read(Qzz)
        xy_archive.read(Qxy); xz_archive.read(Qxz); yz_archive.read(Qyz)
     else
        .make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
     end
  end

  make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
  ! Make "Qij", the quadrupole moment integral matrices.
     MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
     MAT, PTR :: QQxx,QQyy,QQzz,QQxy,QQxz,QQyz
     INT :: q,c,a,b,fa,la,fb,lb
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
     Qxy = ZERO; Qxz = ZERO; Qyz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell%a%n_comp; n_b = shell%b%n_comp
        QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
        QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)
        shell.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz, .gauge_origin)
        Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) + QQxx
        Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) + QQyy
        Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) + QQzz
        Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) + QQxy
        Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) + QQxz
        Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) + QQyz
        shell.destroy_ptr_part
        QQyz.destroy; QQxz.destroy; QQxy.destroy
        QQzz.destroy; QQyy.destroy; QQxx.destroy
     end
     Qxx.make_symmetric; Qyy.make_symmetric; Qzz.make_symmetric
     Qxy.make_symmetric; Qxz.make_symmetric; Qyz.make_symmetric
     archive.set(.name,"quadrupole_xx_matrix"); archive.write(Qxx)
     archive.set(.name,"quadrupole_yy_matrix"); archive.write(Qyy)
     archive.set(.name,"quadrupole_zz_matrix"); archive.write(Qzz)
     archive.set(.name,"quadrupole_xy_matrix"); archive.write(Qxy)
     archive.set(.name,"quadrupole_xz_matrix"); archive.write(Qxz)
     archive.set(.name,"quadrupole_yz_matrix"); archive.write(Qyz)
  end

  get_spin_orbit_matrices(SOx,SOy,SOz)
  ! Set "SOx", "SOy", and "SOz" to the one electron spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: SOx,SOy,SOz
     ARCHIVE :: SOx_archive,SOy_archive,SOz_archive
     SOx_archive.set(.name,"SOx_matrix")
     SOy_archive.set(.name,"SOy_matrix")
     SOz_archive.set(.name,"SOz_matrix")
     if (SOx_archive.exists AND SOy_archive.exists AND SOz_archive.exists) then
        SOx_archive.read(SOx)
        SOy_archive.read(SOy)
        SOz_archive.read(SOz)
     else
        .make_spin_orbit_matrices(SOx,SOy,SOz)
     end
  end

  make_spin_orbit_matrices(SOx,SOy,SOz)
  ! Calculate the spin orbit matrices "SOx" "SOy" and "SOz"
     MAT :: SOx,SOy,SOz
     MAT, PTR :: SOx_c,SOy_c,SOz_c
     INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
     DBL :: Z
     SHELL2 :: shell
     ARCHIVE :: archive
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     SOx = ZERO; SOy = ZERO; SOz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        SOx_c.create(shell%a%n_comp,shell%b%n_comp)
        SOy_c.create(shell%a%n_comp,shell%b%n_comp)
        SOz_c.create(shell%a%n_comp,shell%b%n_comp)
        do c = 1,.n_atom
           Z = .atom(c)%atomic_number
           shell.make_spin_orbit_ints(SOx_c,SOy_c,SOz_c, .atom(c)%pos,FALSE)
           SOx(fa:la,fb:lb) = SOx(fa:la,fb:lb) + Z*SOx_c
           SOy(fa:la,fb:lb) = SOy(fa:la,fb:lb) + Z*SOy_c
           SOz(fa:la,fb:lb) = SOz(fa:la,fb:lb) + Z*SOz_c
        end
        shell.destroy_ptr_part
        SOz_c.destroy; SOy_c.destroy; SOx_c.destroy
     end
     SOx.make_antisymmetric
     SOy.make_antisymmetric
     SOz.make_antisymmetric
     archive.set(.name,"SOx_matrix"); archive.write(SOx)
     archive.set(.name,"SOy_matrix"); archive.write(SOy)
     archive.set(.name,"SOz_matrix"); archive.write(SOz)
  end

  get_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
  ! Set "SOBi" to the gauge modified (B field) one electron spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: SOBx,SOBy,SOBz
     ARCHIVE :: x_archive,y_archive,z_archive
     x_archive.set(.name,"SOBx_matrix")
     y_archive.set(.name,"SOBy_matrix")
     z_archive.set(.name,"SOBz_matrix")
     if (x_archive.exists) then
        x_archive.read(SOBx); y_archive.read(SOBy); z_archive.read(SOBz)
     else
        .make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
     end
  end

  make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
  ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy"
  ! and "SOBz"
     MAT :: SOBx,SOBy,SOBz
     MAT, PTR :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     ARCHIVE :: archive
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     Qxx.create(.n_bf,.n_bf); Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf)
     Qyx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
     Qzx.create(.n_bf,.n_bf); Qzy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
     .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     SOBx = (Qyy + Qzz)*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
     SOBy = (Qxx + Qzz)*.B_field(2) - Qyx*.B_field(1) - Qyz*.B_field(3)
     SOBz = (Qxx + Qyy)*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2)
     Qzz.destroy; Qzy.destroy; Qzx.destroy
     Qyz.destroy; Qyy.destroy; Qyx.destroy
     Qxz.destroy; Qxy.destroy; Qxx.destroy
     SOBx.make_symmetric
     SOBy.make_symmetric
     SOBz.make_symmetric
     archive.set(.name,"SOBx_matrix"); archive.write(SOBx)
     archive.set(.name,"SOBy_matrix"); archive.write(SOBy)
     archive.set(.name,"SOBz_matrix"); archive.write(SOBz)
  end

  get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
  ! Set "Qij" the gauge modified (B field) spin orbit quadrupole matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     ARCHIVE :: xx_archive,xy_archive,xz_archive
     ARCHIVE :: yx_archive,yy_archive,yz_archive
     ARCHIVE :: zx_archive,zy_archive,zz_archive
     xx_archive.set(.name,"SO_Qxx_matrix")
     xy_archive.set(.name,"SO_Qxy_matrix")
     xz_archive.set(.name,"SO_Qxz_matrix")
     yx_archive.set(.name,"SO_Qyx_matrix")
     yy_archive.set(.name,"SO_Qyy_matrix")
     yz_archive.set(.name,"SO_Qyz_matrix")
     zx_archive.set(.name,"SO_Qzx_matrix")
     zy_archive.set(.name,"SO_Qzy_matrix")
     zz_archive.set(.name,"SO_Qzz_matrix")
     if ( xx_archive.exists ) then
        xx_archive.read(Qxx); xy_archive.read(Qxy); xz_archive.read(Qxz)
        yx_archive.read(Qyx); yy_archive.read(Qyy); yz_archive.read(Qyz)
        zx_archive.read(Qzx); zy_archive.read(Qzy); zz_archive.read(Qzz)
     else
        .make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     end
  end

  make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
  ! Calculate the gauge modified (B field) spin orbit quadrupole matrices "Qij".
     MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
     MAT, PTR :: xx,xy,xz,yx,yy,yz,zx,zy,zz
     INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
     DBL :: Z
     SHELL2 :: shell
     ARCHIVE :: archive
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     Qxx = ZERO; Qxy = ZERO; Qxz = ZERO
     Qyx = ZERO; Qyy = ZERO; Qyz = ZERO
     Qzx = ZERO; Qzy = ZERO; Qzz = ZERO
     do q = 1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell%a%n_comp; n_b = shell%b%n_comp
        xx.create(n_a,n_b); xy.create(n_a,n_b); xz.create(n_a,n_b)
        yx.create(n_a,n_b); yy.create(n_a,n_b); yz.create(n_a,n_b)
        zx.create(n_a,n_b); zy.create(n_a,n_b); zz.create(n_a,n_b)
        do c = 1,.n_atom
           Z = .atom(c)%atomic_number
           shell.make_spin_orbit_B_ints(xx,xy,xz,yx,yy,yz,zx,zy,zz,.atom(c)%pos, .gauge_origin)
           ! minus due to r-c, not c-r in the electric field part
           ! this comment should go in gaussian2?
           Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) - Z*xx
           Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) - Z*xy
           Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) - Z*xz
           Qyx(fa:la,fb:lb) = Qyx(fa:la,fb:lb) - Z*yx
           Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) - Z*yy
           Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) - Z*yz
           Qzx(fa:la,fb:lb) = Qzx(fa:la,fb:lb) - Z*zx
           Qzy(fa:la,fb:lb) = Qzy(fa:la,fb:lb) - Z*zy
           Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) - Z*zz
        end
        shell.destroy_ptr_part
        zz.destroy; zy.destroy; zx.destroy
        yz.destroy; yy.destroy; yx.destroy
        xz.destroy; xy.destroy; xx.destroy
     end
     Qxx.make_symmetric; Qxy.make_symmetric; Qxz.make_symmetric
     Qyx.make_symmetric; Qyy.make_symmetric; Qyz.make_symmetric
     Qzx.make_symmetric; Qzy.make_symmetric; Qzz.make_symmetric
     archive.set(.name,"SO_Qxx_matrix"); archive.write(Qxx)
     archive.set(.name,"SO_Qxy_matrix"); archive.write(Qxy)
     archive.set(.name,"SO_Qxz_matrix"); archive.write(Qxz)
     archive.set(.name,"SO_Qyx_matrix"); archive.write(Qyx)
     archive.set(.name,"SO_Qyy_matrix"); archive.write(Qyy)
     archive.set(.name,"SO_Qyz_matrix"); archive.write(Qyz)
     archive.set(.name,"SO_Qzx_matrix"); archive.write(Qzx)
     archive.set(.name,"SO_Qzy_matrix"); archive.write(Qzy)
     archive.set(.name,"SO_Qzz_matrix"); archive.write(Qzz)
  end

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
   ! This is usefule for numerical integration of nuclear attraction integrals.
      VEC :: values
      MAT :: pts
      INT :: n_pts,n,i
      DBL :: Z_n,r_ni
      VEC(3) :: pos
      n_pts = size(pts,1)
      values = ZERO
      do n = 1,.n_atom
         Z_n = .atom(n)%atomic_number
         pos = .atom(n)%pos
         do i = 1,n_pts
            r_ni = pos.distance_to(pts(i,:))
            values(i) = values(i) - Z_n/r_ni
         end
      end
   end

   ZORA_potential(values,pts)
   ! Calculate the one electron ZORA potential "values" of a given set of "pts".
   ! This is useful for numerical integration.
      VEC :: values
      MAT :: pts
      .nuclear_potential(values,pts)
      values = ONE/(TWO - values/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU))
   end

  get_1e_ZORA_matrices(T,SOx,SOy,SOz)
  ! Set "SOx", "SOy", and "SOz" to the one electron ZORA spin orbit matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: T,SOx,SOy,SOz
     ARCHIVE :: T_archive,SOx_archive,SOy_archive,SOz_archive
     T_archive.set(.name,"ZORA_kinetic_matrix")
     SOx_archive.set(.name,"ZORA_SOx_matrix")
     SOy_archive.set(.name,"ZORA_SOy_matrix")
     SOz_archive.set(.name,"ZORA_SOz_matrix")
     if (exists_(SOx_archive) AND exists_(SOy_archive) AND exists_(SOz_archive)) then
        T_archive.read(T)
        SOx_archive.read(SOx)
        SOy_archive.read(SOy)
        SOz_archive.read(SOz)
     else
        .make_1e_ZORA_matrices(T,SOx,SOy,SOz)
     end
  end

  make_1e_ZORA_matrices(T,Zx,Zy,Zz)
  ! Calculate the one-electron ZORA spin orbit matrices numerically.
  ! This includes the relativitically modified kinetic energy integrals.
    MAT  :: T, Zx,Zy,Zz
    MAT4, PTR :: ZORA ,SO
    INT :: q,fa,la,fb,lb, k,l,a,b, x,y,z
    SHELL2 :: shell
    ARCHIVE :: archive
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .dftgrid.created, "need to specify dftgrid for ZORA")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    ZORA.create(.n_bf,.n_bf,3,3)
    ! Make the lower half of the ZORA spin orbit integrals
    ZORA = ZERO
    do q = 1,.n_shell_pairs
       .get_shell_pair(q,shell,fa,la,fb,lb)
       SO.create(shell%a%n_comp,shell%b%n_comp,3,3)
!       .dftgrid.make_SO_matrix_elements_of(ZORA_potential,self,shell,SO)
       ZORA(fa:la,fb:lb,:,:) = ZORA(fa:la,fb:lb,:,:) + SO
       SO.destroy
       shell.destroy_ptr_part
    end
    ! Make the upper half of the ZORA spin orbit integrals
    do k = 1,3
    do l = 1,k
    do a = 1,.n_bf
    do b = 1,a-1
       ZORA(b,a,l,k) = ZORA(a,b,k,l)
    end
    end
    end
    end
    ! Assemble the ZORA contribution to the 1 electron hamiltonian
    ! Scalar kinetic energy contribution
    x = 1; y = 2; z = 3
    T = ZORA(:,:,x,x) + ZORA(:,:,y,y) + ZORA(:,:,z,z)
    ! Spin-dependent spin-orbit contribution
    Zx = ZORA(:,:,y,z) - ZORA(:,:,z,y)
    Zy = ZORA(:,:,z,x) - ZORA(:,:,x,z)
    Zz = ZORA(:,:,x,y) - ZORA(:,:,y,x)
    ! HH.beta_alpha_plus(W,factor=-I*fac)
    ! HH.beta_alpha_plus(W,factor=fac)
    ! HH.alpha_alpha_plus(W,factor=-I*fac)
    ! HH.beta_beta_plus(W,factor=I*fac)
    ZORA.destroy
     archive.set(.name,"ZORA_kinetic_matrix"); archive.write(T)
     archive.set(.name,"ZORA_SOx_matrix");     archive.write(Zx)
     archive.set(.name,"ZORA_SOy_matrix");     archive.write(Zy)
     archive.set(.name,"ZORA_SOz_matrix");     archive.write(Zz)
  end

  get_L_matrices(Lx,Ly,Lz)
  ! Set "Lx", "Ly", and "Lz" to the angular momentum matrices.
  ! If archives exist, read them; otherwise make them.
     MAT :: Lx,Ly,Lz
     ARCHIVE :: Lx_archive,Ly_archive,Lz_archive
     Lx_archive.set(.name,"Lx_matrix")
     Ly_archive.set(.name,"Ly_matrix")
     Lz_archive.set(.name,"Lz_matrix")
     if (exists_(Lx_archive) AND exists_(Ly_archive) AND exists_(Lz_archive)) then
        Lx_archive.read(Lx)
        Ly_archive.read(Ly)
        Lz_archive.read(Lz)
     else
        .make_L_matrices(Lx,Ly,Lz)
     end
  end

  make_L_matrices(Lx,Ly,Lz)
  ! Make the angular momentum matrices  "Lx", "Ly", and "Lz".
     MAT :: Lx,Ly,Lz
     INT :: q,a,b,fa,la,fb,lb,atom_a,atom_b
     SHELL2 :: shell
     ARCHIVE :: archive
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        shell.make_L_ints(Lx(fa:la,fb:lb),Ly(fa:la,fb:lb),Lz(fa:la,fb:lb), .gauge_origin)
        shell.destroy_ptr_part
     end
     Lx.make_antisymmetric
     Ly.make_antisymmetric
     Lz.make_antisymmetric
     archive.set(.name,"Lx_matrix"); archive.write(Lx)
     archive.set(.name,"Ly_matrix"); archive.write(Ly)
     archive.set(.name,"Lz_matrix"); archive.write(Lz)
  end

  get_eri_integrals
  ! Get the electron repulsion integrals on disk. If the integral
  ! file is already there, do nothing.
    ARCHIVE :: eri_archive,ind_archive
    eri_archive.set(.name,"eri_integrals")
    ind_archive.set(.name,"eri_index")
    if (eri_archive.does_not_exist OR does_not_exist_(ind_archive)) then
       eri_archive.open(for="write-only",buffered=TRUE,type="dbl")
       ind_archive.open(for="write-only",buffered=TRUE,type="int")
       .make_eri_integrals(eri_archive,ind_archive)
       ind_archive.close
       eri_archive.close
    end
  end

  make_eri_integrals(eri_archive,eri_index)
  ! Calculate the electron repulsion integrals (ERI's) over all basis functions
  ! Outputs to archive "eri_archive".  Note that index coincidence factors are
  ! included.
    ARCHIVE :: eri_archive,eri_index
    SHELL4 :: shell4     ! a shell quartet
    MAT4, PTR   :: ERI        ! a block of ERI's for shell4
    INT :: q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d
    DBL :: factor
    STR :: cutoff
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    cutoff.from_dbl(SHELL4_ERI_CUTOFF)
    skipped = 0
    if (.scfdata%output) then
      .out.text("Skipping electron repulsion integrals less than " // cutoff.trim // ".")
    end
    do q = 1, .n_shell_quartets
      if (.scfdata%nddo) then
        .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
        if (atom_a==atom_b AND atom_c==atom_d) then
          shell4.destroy_ptr_part
          .get_shell_quartet(q,shell4,a,b,c,d)
        else
          skipped = skipped + 1
          shell4.destroy_ptr_part
          cycle
        end
      else
        .get_shell_quartet(q,shell4,a,b,c,d)
      end
      if (shell4.skip_ERI) then
        skipped = skipped + 1
        shell4.destroy_ptr_part
        cycle
      end
      ERI.create(shell4%a%n_comp,shell4%b%n_comp,shell4%c%n_comp,shell4%d%n_comp)
      shell4.get_eri(ERI)
      factor = ONE
      if (a==b) factor = HALF                    ! Coincidence factors
      if (c==d) factor = HALF * factor
      if (a==c AND b==d) factor = HALF * factor
      ERI = factor * ERI
      eri_archive.file.write(ERI)
      eri_index.file.write(q)
      ERI.destroy
      shell4.destroy_ptr_part
    end
    if (.scfdata%output) then
      .out.put_text("Skipped " // trim( skipped.to_str ) //  " out of " // &
          trim( .n_shell_quartets.to_str ) // " blocks.",flush=1)
    end
    eri_index.file.write( .n_shell_quartets + 1 )
  end

  get_spin_orbit_integrals
  ! Get the spin orbit integrals on disk. If the integral files are
  ! file is already there, do nothing.
    ARCHIVE :: SOx_archive,SOy_archive,SOz_archive,ind_archive
    SOx_archive.set(.name,"SOx_integrals")
    SOy_archive.set(.name,"SOy_integrals")
    SOz_archive.set(.name,"SOz_integrals")
    ind_archive.set(.name,"SO_indices")
    if (SOx_archive.does_not_exist) then
       SOx_archive.open(for="write-only",buffered=TRUE,type="dbl")
       SOy_archive.open(for="write-only",buffered=TRUE,type="dbl")
       SOz_archive.open(for="write-only",buffered=TRUE,type="dbl")
       ind_archive.open(for="write-only",buffered=TRUE,type="int")
       .make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
       SOx_archive.close
       SOy_archive.close
       SOz_archive.close
       ind_archive.close
    end
  end

  make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
  ! Calculate the spin orbit integrals. Outputs the spin same-orbit integrals
  ! to for each component i to "SOi_archive". The shell quartet index for
  ! these integrals are put in "ind_archive". Note that index coincidence
  ! factors are included.
    ARCHIVE :: SOx_archive,SOy_archive,SOz_archive,ind_archive
    SHELL4 :: shell4                  ! a shell quartet
    MAT4, PTR   :: Sx,Sy,Sz,Ox,Oy,Oz  ! a blocks of spin orbit ints. for shell4
    INT :: q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d,na,nb,nc,nd
    DBL :: factor
    STR :: cutoff
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.bases_are_all_resolved, "no basis set")
    cutoff.from_dbl(SHELL4_ERI_CUTOFF)
    skipped = 0
    if (.scfdata%output) then
      .out.text("Skipping electron repulsion integrals less than " // cutoff.trim // ".")
    end
    do q = 1, .n_shell_quartets
      if (.scfdata%nddo) then
        .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
        if (atom_a==atom_b AND atom_c==atom_d) then
          .get_shell_quartet(q,shell4,a,b,c,d)
        else
          skipped = skipped + 1
          cycle
        end
      else
        .get_shell_quartet(q,shell4,a,b,c,d)
      end
      if (shell4.skip_ERI) then
        skipped = skipped + 1
        shell4.destroy_ptr_part
        cycle
      end
      na = shell4%a%n_comp; nb = shell4%b%n_comp
      nc = shell4%c%n_comp; nd = shell4%d%n_comp
      Sx.create(na,nb,nc,nd); Sy.create(na,nb,nc,nd); Sz.create(na,nb,nc,nd)
      Ox.create(na,nb,nc,nd); Oy.create(na,nb,nc,nd); Oz.create(na,nb,nc,nd)
      shell4.make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
      factor = ONE
      if (a==b) factor = HALF                    ! Coincidence factors
      if (c==d) factor = HALF * factor
      if (a==c AND b==d) factor = HALF * factor
      Sx = factor*Sx; Sy = factor*Sy; Sz = factor*Sz
      Ox = factor*Ox; Oy = factor*Oy; Oz = factor*Oz
      SOx_archive.file.write(Sx); SOx_archive.file.write(Ox)
      SOy_archive.file.write(Sy); SOy_archive.file.write(Oy)
      SOz_archive.file.write(Sz); SOz_archive.file.write(Oz)
      ind_archive.file.write(q)
      Oz.destroy; Oy.destroy; Ox.destroy
      Sz.destroy; Sy.destroy; Sx.destroy
      shell4.destroy_ptr_part
    end
    if (.scfdata%output) then
      .out.put_text("Skipped " // trim( skipped.to_str ) //  " out of " // &
          trim( .n_shell_quartets.to_str ) // " blocks.",flush=1)
    end
    ind_archive.file.write( .n_shell_quartets + 1 )
  end

end 
