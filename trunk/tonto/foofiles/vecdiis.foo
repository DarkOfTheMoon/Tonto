!---------------------------------------------------------------------------
!
!  VECDIIS:  DIIS Extrapolation technique for vectors
!
!  (c) dylan jayatilaka, 1997
!
! $Id$
!---------------------------------------------------------------------------
module VECDIIS

   use TYPES
   use SYSTEM
   use STR
   use INT
   use VEC
   use MAT
   use TEXTFILE
   use ARCHIVE

   implicit none         

#include "macros"
#include "vecdiis.int"

!   type vecdiis_type
!
!   INT :: keep
!   ! No. of parameter vectors to keep for use in extrapolation
!
!   INT :: start
!   ! The iteration at which DIIS extrapolation should start
!
!   INT :: n_vec
!   ! The number of parameter vectors currently available for extrapolation
!
!   INT :: new
!   ! The integer identifier for the new (current) parameter vector
!
!   DBL :: error_length
!   ! The length of the DIIS error vector
!
!   ARCHIVE :: archive
!   ! Archive used to store the DIIS parameter and error vectors
!
!   MAT, PTR :: mat DEFAULT_NULL
!   ! The DIIS matrix
!
!   VEC, PTR :: coeff DEFAULT_NULL
!   ! The DIIS coefficients which combine/extrapolate the stored parameter vectors
!
!   end

contains

   create(root_name,name,kind,format,keep,start)
   ! Create the DIIS object with dimension "dim", but no archive name
      PTR :: self
      STR, optional :: root_name,name
      STR, optional :: kind,format
      INT, IN, optional :: keep,start
      nullify(self)
      allocate(self)
      ADD_MEM(VECDIIS_SIZE)
      .nullify_ptr_part
      .set_default
      .archive.set_names(root_name,name,kind,format)
      .set(keep,start)
   end

   destroy
   ! Destroy the DIIS object
      PTR :: self
      if (.destroyed) return
      .delete_archives
      .destroy_ptr_part
      DELETE_MEM(VECDIIS_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      nullify(.mat)
      nullify(.coeff)
      .archive.nullify_ptr_part
   end

   destroy_ptr_part
   ! Destroy the pointer parts of self
      .mat.destroy
      .coeff.destroy
      .archive.destroy_ptr_part
   end

   delete_archives
   ! Delete the archive files on disk.
     INT :: i
     STR :: name
     name = .archive.name
     .archive.set_name( name.trim // ",mat" )
     if (.archive.exists)  .archive.delete
     do i=1, .n_vec
       .archive.set_name( name.trim // ",p" // i.to_str.trim)
       if (.archive.exists)  .archive.delete
       .archive.set_name( name.trim // ",e" // i.to_str.trim)
       if (.archive.exists)  .archive.delete
     end
     .archive.set_name( name.trim )
     .new=0
     .n_vec = 0
     .error_length = ZERO
   end

   cleanup
   ! Cleanup the DIIS files and matrices, but don't resort back to default parameters.
      .delete_archives
      .destroy_ptr_part
   end

   set_default
   ! Set up the default settings
      .keep  = DIIS_KEEP
      .start = DIIS_START
      .n_vec = 0
      .new = 0
      .error_length = ZERO
      .archive.set_default
      .destroy_ptr_part ! ensure ptr parts are nullified first !
   end

   set(keep,start)
   ! Set the number of DIIS objects to keep
      INT, IN, optional :: keep,start
      if (present(keep))  .set_keep(keep)
      if (present(start)) .set_start(start)
   end

   set_keep(keep)
   ! Set the number of DIIS objects to keep
      INT, IN :: keep
      .keep = keep
   end

   set_start(start)
   ! Set the number of DIIS objects to keep
      INT, IN :: start
      .start = start
   end

   set_archive_root_name(root_name)
   ! Set the DIIS archive to have root name "root_name".
      STR(*) :: root_name
      .archive.set_root_name(root_name)
   end

   set_archive_name(name)
   ! Set the DIIS archive name. 
      STR(*) :: name
      .archive.set_name(name)
   end

   set_archive_format(format)
   ! Set the DIIS archive format. 
      STR(*) :: format
      .archive.set_format(format)
   end

   worst_item result(res)
   ! Return the index of the item with the worst error in the DIIS archive
      INT :: res
      MAT, PTR :: mat
      VEC, PTR :: diag
      INT :: dim
      dim = .dimension
      diag.create(dim)             
      mat.create(dim,dim)
      .get_old_diis_matrix(mat) 
      mat.get_diagonal(diag)             ! the error vector lengths^2
      res = diag.index_of_largest_value   ! Worst item has the largest error
      mat.destroy
      diag.destroy
   end
 
   next_replacement result(res)
   ! Return the index of the next item in the DIIS expansion 
   ! which is to be replaced/saved 
      INT :: res
      if (.n_vec<=.keep) then
         res = .n_vec
      else
         res = .worst_item
      end
   end

   save_pair(par,err,item)
   ! Save/replace the current vectors on an archive with item number "item",
   ! or item number ".new" if "item" is not present.
      VEC :: par,err
      INT, optional :: item
      INT :: i
      STR :: old_name 
      i = .new
      if (present(item)) i = item
      old_name = .archive.name
      .archive.set_name( old_name.trim // ",p" // i.to_str.trim)
      .archive.write(par)
      .archive.set_name( old_name.trim // ",e" // i.to_str.trim)
      .archive.write(err)
      .archive.set_name(old_name)
   end

   get_error_item(i,err)
   ! Get the error item "i" in vector "err"
      INT :: i
      VEC :: err
      STR :: old_name 
      old_name = .archive.name
      .archive.set_name( old_name.trim // ",e" // i.to_str.trim)
      .archive.read(err)
      .archive.set_name(old_name)
   end

   get_parameter_item(i,par)
   ! Get the error item "i" in vector "err"
      INT :: i
      VEC :: par
      STR :: old_name 
      old_name = .archive.name
      .archive.set_name( old_name.trim // ",p" // i.to_str.trim)
      .archive.read(par)
      .archive.set_name(old_name)
   end

   save_diis_mat(mat)
   ! Save the DIIS matrix to disk
      MAT :: mat
      STR :: old_name 
      old_name = .archive.name
      .archive.set_name( old_name.trim // ",mat" )
      .archive.write(mat)
      .archive.set_name(old_name)
   end

   get_diis_mat(mat)
   ! Get the DIIS matrix from disk
      MAT :: mat
      STR :: old_name 
      old_name = .archive.name
      .archive.set_name( old_name.trim // ",mat" )
      .archive.read(mat)
      .archive.set_name(old_name)
   end

   get_old_diis_matrix(mat) 
   ! Get the old DIIS matrix to "mat", if it is smaller
      MAT :: mat
      MAT, PTR :: old_mat
      if (.n_vec==1) then
         mat = ZERO 
      else if (.n_vec<=.keep) then
         old_mat.create(.n_vec,.n_vec)
         .get_diis_mat(old_mat)
         mat = ZERO 
         mat(: .n_vec, : .n_vec) = old_mat
         old_mat.destroy
      else
        .get_diis_mat(mat)
      end
   end

   make_diis_matrix(mat,err,old_err)
   ! Make the current diis matrix "mat" using "err" as the current error vector
   ! for item ".new". "old_err" is used to hold the old error vectors.
      MAT :: mat
      VEC :: err,old_err
      INT :: dim,old
      .get_old_diis_matrix(mat)
      dim = .dimension
      do old = 1,dim-1                         ! Calculate the DIIS matrix
         .get_error_item(old,old_err)
         mat(max(.new,old),min(.new,old)) = dot_product(err,old_err)
         mat(dim,old) = ONE
      end
      mat(dim,dim) = ZERO
      mat.symmetric_reflect
      .save_diis_mat(mat)
      .error_length = sqrt(mat(.new,.new))
   end

   update(par,old_par)
   ! Update the parameter vector "par", using "old_par" as space 
      VEC :: par,old_par
      INT :: old,dim
      dim = .dimension
      par = ZERO                            
      do old = 1,dim-1                         ! Form revised parameter vector
         .get_parameter_item(old,old_par)
         par = par + .coeff(old)*old_par
      end
   end

   dimension result(res)
   ! Return the dimension of the DIIS matrix
      INT :: res
      res = min(.n_vec,.keep)+1  
   end
   
   extrapolate(par,err) 
   ! DIIS extrapolation of "par", using "err" as the error vector.
      VEC :: par,err
      INT :: dim,i,j
      VEC, PTR :: rhs
      MAT, PTR :: mat
      STR :: name
      name = .archive.file_name
      ENSURE(name/="","no archive name specified")
      .n_vec = .n_vec+1
      dim    = .dimension
      .new   = .next_replacement
      .save_pair(par,err,item=.new)
      .mat.create(dim,dim)
      .make_diis_matrix(.mat,err,par)                ! Calculate the new diis matrix
      .mat( .new, .new)=.mat( .new, .new)*1.02d0     ! Weight the last vector a bit more
      .get_parameter_item(.new,par)
      if (.n_vec>1) then
         .coeff.create(dim); .coeff = ZERO           ! the diis coefficients
         rhs.create(dim); rhs = ZERO; rhs(dim) = ONE
         mat.create(dim,dim)
         do i = 1,dim-1
            do j = 1,dim-1
              mat(i,j) = .mat(i,j)/.mat(i,i)
            end
            mat(dim,i) = ONE
            mat(i,dim) = TOL(8)/.mat(i,i)
            mat(dim,dim) = ZERO
         end
         mat.solve_linear_equations(rhs,.coeff)      ! Solve diis equations; diis c = b = (0 0 *** 1)
         mat.destroy
         rhs.destroy
         .update(par,err)
         .get_error_item(.new,err)                   ! Put back old error item
         .coeff.destroy
      end
      .mat.destroy
   end

  put(out)
  ! Prints out the DIIS data to file "out"
    TEXTFILE :: out
    out.flush
    out.text("DIIS data ")
    out.show("Archive root name        = ", .archive.root_name)
    out.show("No to keep               = ", .keep)
    out.show("Start iteration          = ", .start)
    out.flush
  end

end
