!-------------------------------------------------------------------------------
!
! GEMINAL_MF_SPECTRUM
!
! Copyright (C) Patrick Cassam-Chenai 2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: geminal_mf_spectrum.foo,v 1.15 2004/03/24 04:55:46 cassam Exp $
!
!-------------------------------------------------------------------------------

module GEMINAL_MF_SCHEME

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!*******************************************************************************
!                             Create and Destroy Routines
!*******************************************************************************

   create(name,nuc,n_geminals,n_step,n_bf,use_brillouin,use_orthogonality,print_hamiltonian,convergence) ::: leaky
   ! Create the contraction-truncation scheme 
      self :: PTR
      name :: STR
      use_orthogonality :: STR
      nuc :: REAL
      n_geminals,n_step,n_bf :: INT
      convergence :: REAL
      use_brillouin,print_hamiltonian :: BIN
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults(n_geminals,n_step,n_bf,name,nuc,use_brillouin,use_orthogonality,print_hamiltonian,convergence)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      nullify(.do_triplet_energies)
      nullify(.truncation_scheme)
   end

   destroy_ptr_part  ::: leaky
   ! Destroy the pointer parts of self
      .do_triplet_energies.destroy
      .truncation_scheme.destroy
   end

   create_copy(b) ::: leaky
   ! Create a copy of "b".
     b :: GEMINAL_MF_SCHEME, IN
     n_step :: INT
     self :: PTR
     n_step=size(b.truncation_scheme)
     .create(b.spectrum.name,b.spectrum.nuclear_energy,b.spectrum.n_geminals,n_step   &   
            ,b.spectrum.n_bf,b.use_brillouin,b.use_orthogonality,b.print_hamiltonian,b.convergence_threshold)
     .copy(b)
   end

   copy(b) ::: leaky
   ! Copy a basis "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
      b :: GEMINAL_MF_SCHEME, IN
      self = b
      if (b.truncation_scheme.created) .truncation_scheme.create_copy(b.truncation_scheme)
      if (b.do_triplet_energies.created) .do_triplet_energies.create_copy(b.do_triplet_energies)
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   set_defaults(n_geminals,n_steps,n_bf,name,nuclear_energy,use_brillouin,use_orthogonality,print_hamiltonian,convergence) ::: leaky
   ! Create a default object.
     n_geminals,n_steps,n_bf :: INT
     name :: STR
     use_orthogonality :: STR
     nuclear_energy :: REAL
     use_brillouin,print_hamiltonian :: BIN, optional
     convergence :: REAL, optional
     i,i_step,n_step :: INT
     .use_orthogonality = use_orthogonality
     .use_brillouin = TRUE
     .print_hamiltonian = FALSE
     .convergence_threshold = REAL_EPSILON
     n_step=n_steps-1
     if (present(use_brillouin)) .use_brillouin = use_brillouin
     if (present(print_hamiltonian)) .print_hamiltonian = print_hamiltonian
     if (present(convergence) AND convergence>.convergence_threshold) .convergence_threshold=convergence
     .spectrum.create(name,nuclear_energy,n_geminals,1,n_bf)
     .ld_tol_scheme.create(1,n_step)
     .ig_tol_scheme.create(1,n_step)
     .tolerance_scheme.create(0,n_step)
     .truncation_scheme.create(0,n_step)
     .do_triplet_energies.create(0,n_step)
!steps from 0 to nsteps - 1
     stdin.read(.tolerance_scheme(0))
     if(.tolerance_scheme(0)<=ZERO) .tolerance_scheme(0)=12
     stdin.read(.do_triplet_energies(0))
     stdin.read(.truncation_scheme(0))
     do i_step=1,n_step
       stdin.read(.ld_tol_scheme(i_step))
       if(.ld_tol_scheme(i_step)<=ZERO) .ld_tol_scheme(i_step)=LINEAR_DEPENDENCE_TOL
       stdin.read(.ig_tol_scheme(i_step))
       if(.ig_tol_scheme(i_step)<=ZERO) .ig_tol_scheme(i_step)=INTERNAL_GEMINAL_TOL
       stdin.read(.tolerance_scheme(i_step))
       if(.tolerance_scheme(i_step)<=ZERO) .tolerance_scheme(i_step)=12
       stdin.read(.do_triplet_energies(i_step))
       stdin.read(.truncation_scheme(i_step))
     end
   end

!  ************
!  I/O Routines
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
       case ("do_gmf_auto             "); .do_gmf_auto
       case ("restart_gmf_auto        "); .restart_gmf_auto
     ! case ("do_gmf                  "); .do_gmf
     ! case ("restart_gmf             "); .restart_gmf
     ! case ("do_spectrum             "); .do_spectrum
     ! case ("do_restart              "); .do_restart
       case ("junk=                   "); .read_junk
       case ("put                     "); .put
       case ("units=                  "); .read_units
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT)
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT)
   ! Read in a junk string, useful for ignoring a field
   end

   get_old_tolerance(old_tolerance)
   ! get old tolerances from an archive file
     old_tolerance :: VEC{INT}
     old_tolerance_archive :: ARCHIVE
     name :: STR
     
     name="old_tolerance"
     old_tolerance_archive.set(.spectrum.name,name)
     old_tolerance_archive.read(old_tolerance)
     stdout.put(old_tolerance)
   end

   get_gs_energies(gs_energies)
   ! get ground state energies from an archive file
     gs_energies :: VEC{REAL}
     gs_energies_archive :: ARCHIVE
     name :: STR
     
     name="gs_energies"
     gs_energies_archive.set(.spectrum.name,name)
     gs_energies_archive.read(gs_energies)
   end

!  ********************
!  Key related routines
!  ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")
     word :: STR
     width,k :: INT
     width = .table_width
     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case default; DIE("unknown option")
         end
         if (k==size(keys)) then
           stdout.flush ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
     res :: INT
   ENSURE(keys.created,"no keys")
     int_dash,real_dash,k :: INT
     word :: STR
     int_dash = 0
     real_dash = 0
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}                "); ! exit surrounding loop
         case ("put_configuration"); real_dash = real_dash + 1
         case ("put_label        "); int_dash = int_dash + 1
         case ("put_n_shells     "); int_dash = int_dash + 1
         case ("put_n_bf         "); int_dash = int_dash + 1
         case ("put_n_prim       "); int_dash = int_dash + 1
         case ("flush            "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  ***************
!  Inquiry methods
!  ***************

   same_as(b) result(res) 
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      self :: IN
      b :: GEMINAL_MF_SCHEME, IN
      res :: BIN
      res = FALSE
   end

!  **************
!  Output methods
!  **************

   put
   ! Print out the object
      n_step :: INT
      i_step :: INT

      stdout.text("GEMINAL_MF_SCHEME:")
      stdout.text(" ")
      stdout.show("molecule      =",.spectrum.name)
      stdout.show("n_geminals    =",.spectrum.n_geminals)
      stdout.show("n_bf          =",.spectrum.n_bf)
      stdout.show("nuclear_energy=",.spectrum.nuclear_energy)
      stdout.show("use_brillouin =",.use_brillouin)
      stdout.show("use_orthogonality =",.use_orthogonality)
      stdout.show("print_hamiltonian =",.print_hamiltonian)
      stdout.show("convergence   =",.convergence_threshold,precision=12)
      stdout.text(" ")

      n_step=size(.truncation_scheme)

!steps from 1 to nsteps - 1
      if(.print_hamiltonian) then
        stdout.show("step :",0)
        stdout.text(" ")
        stdout.show("Cutoff tolerance =",TOL(.tolerance_scheme(0)),precision=12)
        stdout.show("do_triplet_energies=",.do_triplet_energies(0))
        stdout.show("truncation =",.truncation_scheme(0),precision=12)
        stdout.text(" ")
        do i_step=1,n_step-1
          stdout.show("step :",i_step)
          stdout.text(" ")
          stdout.show("Linear dependence tolerance =",.ld_tol_scheme(i_step),precision=12)
          stdout.show("Internal geminal tolerance =",.ig_tol_scheme(i_step),precision=12)
          stdout.show("Cutoff tolerance =",TOL(.tolerance_scheme(i_step)),precision=12)
          stdout.show("do_triplet_energies=",.do_triplet_energies(i_step))
          stdout.show("truncation =",.truncation_scheme(i_step),precision=12)
          stdout.text(" ")
        end
      end
   end

   put_gs_energies(gs_energies)
   ! put ground state energies to an archive file
     gs_energies :: VEC{REAL}
     gs_energies_archive :: ARCHIVE
     name :: STR
     
     name="gs_energies"
     gs_energies_archive.set(.spectrum.name,name)
     gs_energies_archive.write(gs_energies)
   end

   put_old_tolerance(old_tolerance)
   ! put old tolerance to an archive file
     old_tolerance :: VEC{INT}
     old_tolerance_archive :: ARCHIVE
     name :: STR
     
     name="old_tolerance"
     old_tolerance_archive.set(.spectrum.name,name)
     old_tolerance_archive.write(old_tolerance)
   end

!  ***************
!  EMFCI methods
!  ***************

   do_gmf_auto ::: leaky !because of the set_defaults
   ! implement the contraction-truncation scheme
   ! designed for a singlet ground state
   ! take advantage of the possible truncation of the geminal basis
     ham :: MAT{REAL}*
     gs_energies :: VEC{REAL}*
     old_tolerance :: VEC{INT}*
     group_order :: VEC{INT}*
     lowest_energy :: REAL
   !  highest_energy :: REAL
     old_energy :: REAL
     i,j,i_step,i_geminals :: INT
     n_nonzero,max_bas :: INT
     n_step,n_geminals,n_bf :: INT
     i_loop,loop_count :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     set :: BIN
     save_step :: BIN
     n_geminals=.spectrum.n_geminals
     n_bf=.spectrum.n_bf
     max_bas=.spectrum.n_bas
     n_step=size(.truncation_scheme)-1
     gs_energies.create(n_geminals)
     old_tolerance.create(n_geminals)
! step 0
     timer.start_timing
     stdout.text(" ")
     stdout.show("step number: ",0)
     stdout.text(" ")
     old_tolerance=.tolerance_scheme(0)
     .put_old_tolerance(old_tolerance)
     .spectrum.tol=TOL(.tolerance_scheme(0))
!kutzelnigg!     .spectrum.make_singlet_extremals
!kutzelnigg     .spectrum.set_singlet_extremals
!kutzelnigg     .spectrum.put
!kutzelnigg      ham.create(1,1)
!kutzelnigg      ham = .spectrum.overlap
!kutzelnigg      old_energy = ham(1,1) !.spectrum.n_bas may be smaller than
!kutzelnigg      ham(1,1) = .spectrum.hamiltonian(1,1) !.spectrum.n_bas may be smaller than
!kutzelnigg     stdout.show("kutzelnigg energy: ", ham(1,1))
!kutzelnigg     stdout.show("kutzelnigg overlap: ", old_energy)
!kutzelnigg     stdout.show("kutzelnigg normalized energy: ", ham(1,1)/old_energy)
!kutzelnigg     stop
!tmp_rassolov
    !tmp_rassolov   !.spectrum.set_singlet_handmade
     ! ! .spectrum.set_rassolov_defaults
!tmp_rassolov
     .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0))
     gs_energies(1)=.spectrum.contraction_energies(1)
     do i=2,n_geminals
       .spectrum.set_defaults(i_geminals=i)
      ! .spectrum.set_singlet_extremals
       .spectrum.set_singlet_defaults
  !tmp_rassolov   !  .spectrum.set_singlet_handmade
      ! .spectrum.set_rassolov_defaults
      ! .spectrum.set_singlet_random
      ! .spectrum.set_singlet_agp
       .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0))
       gs_energies(i)=.spectrum.contraction_energies(1)
     end
     timer.stop_timing
     stdout.show("time taken for step 0 in s:",timer.elapsed_time)
     stdout.text(" ")
     .put_gs_energies(gs_energies)  
     group_order.create(n_geminals)
     gs_energies.quick_sort(group_order)
!out     stdout.text("group_order:")
!out     stdout.put(group_order)
!out     stop
     i_loop=1 !index for group_order
     i_geminals=group_order(i_loop)
!tmp-rassolov     do i=1,n_geminals
!tmp-rassolov       if(i/=i_geminals) then
!tmp-rassolov         .spectrum.set_defaults(i_geminals=i)
!tmp-rassolov!         .spectrum.set_singlet_extremals
!tmp-rassolov         .spectrum.set_singlet_defaults
!tmp-rassolov         .spectrum.put_wfs
!tmp-rassolov         .spectrum.put_ground_state
!tmp-rassolov       end
!tmp-rassolov     end
     loop_count=2 !nb of step after step 0 or after a change of tolerance 
     i_loop=2
! step 1 to n_steps -1
     do i_step=1,n_step
       timer.start_timing
       stdout.text(" ")
       stdout.show("step number: ",i_step)
       stdout.text(" ")
       .spectrum.ld_tol=.ld_tol_scheme(i_step)
       stdout.show("Linear dependence tolerance",.ld_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.ig_tol=.ig_tol_scheme(i_step)
       stdout.show("Internal geminal tolerance",.ig_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.tol=TOL(.tolerance_scheme(i_step))
       stdout.show("Cutoff tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
       stdout.text(" ")
       do i=1,n_geminals
         .spectrum.set_defaults(i_geminals=i)
         .spectrum.get_ground_state
       end
       .spectrum.set_to_zero_special_ket 
       set=FALSE
       DIE_IF(maxval(old_tolerance)>.tolerance_scheme(i_step),"Cutoff tolerance has decreased")
       do i=0,n_geminals-1
         if(i_loop+i > n_geminals) then
           j=group_order(mod(i_loop+i,n_geminals))
         else
           j=group_order(i_loop+i)
         end  
         if(old_tolerance(j)<.tolerance_scheme(i_step))then
           stdout.text(" ")
           stdout.show("tolerance has increased for group",j) 
           stdout.text(" ")
           .spectrum.set_defaults(i_geminals=j)
           i_geminals=j
           set=TRUE
           if(i_loop+i > n_geminals) then
             i_loop=mod(i_loop+i,n_geminals)
           else
             i_loop=i_loop+i
           end  
           exit
         end
       end
       if(NOT set) then
         j=group_order(i_loop)
         .spectrum.set_defaults(i_geminals=j)
         i_geminals=j
       end
       old_energy=gs_energies(i_geminals)
  !     highest_energy=maxval(gs_energies)
       lowest_energy=minval(gs_energies)
       .spectrum.gs_permutation
       .remove_singlet_dependencies
       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
       .spectrum.set_to_zero_special_ket !maybe not needed but safer
       ham.create(n_nonzero,n_nonzero)
       ham = .spectrum.hamiltonian !.spectrum.n_bas may be smaller than
                                  ! .spectrum.contraction_energies.dim but
                                  ! should work
       eigenvec.create(n_nonzero,n_nonzero)
       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec) 
       ham.destroy
       if(.print_hamiltonian) then
         stdout.text(" ")
         stdout.text("singlet eigenvectors") 
         stdout.text(" ")
         stdout.put(eigenvec) 
         stdout.text(" ")
       end
       .spectrum.contraction_energies(1:n_nonzero)= &
          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
       .spectrum.get_max_bas !now .spectrum.n_bas is the size of the truncated
                             ! set of possibly quasilinearly dependent basis
                             ! functions
       do j=n_nonzero+1,.spectrum.n_bas
         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
       end
       stdout.text(" ")
       stdout.show("i_geminals    =",i_geminals)
       stdout.text(" ")
       stdout.show("first eigenvalue is ",.spectrum.contraction_energies(1),precision=12)
       stdout.text(" ")
       stdout.text(" ")
       stdout.text("singlet eigenvalues") 
       stdout.text(" ")
       stdout.put(.spectrum.contraction_energies) 
       stdout.text(" ")
!begin testing convergence
       if(set)then
         stdout.text(" ")
         stdout.text("the tolerance having changed, the job continue ...") 
         stdout.text(" ")
         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
         .put_old_tolerance(old_tolerance)
         loop_count=1
         save_step=TRUE
       else  
         if(.spectrum.contraction_energies(1)+.convergence_threshold<lowest_energy) then
           stdout.text(" ")
           stdout.text("Energy difference not within tolerance, the job continue ...") 
           stdout.text(" ")
           loop_count=1
           save_step=TRUE
         else
           if(.spectrum.contraction_energies(1)<old_energy) then
             stdout.show("The energy has improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=TRUE
           else
             stdout.show("The energy has not improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=FALSE
           end
           if(loop_count==n_geminals) then
          !   if(save_step)then
          !     .save_gmf_step(i_step,i_geminals)
          !     if(.do_triplet_energies(i_step)) then
          !       .do_triplet_spectrum
          !     end
          !   end
             stdout.text(" ")
             stdout.text("all electron groups have been considered")
             stdout.text(" ")
             stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
             stdout.text(" ")
             if(.convergence_threshold<.spectrum.tol) then
               stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
               stdout.text(" ")
             end
             stdout.text(std_time.elapsed_time_message(" "))
             stdout.text(std_time.elapsed_cpu_time_message(" "))
             stop
           else
             timer.stop_timing
             stdout.show("time taken for this step in s:",timer.elapsed_time)
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("Energy difference within tolerance, however ...") 
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("not all electron groups have been considered, the job continue ...") 
             stdout.text(" ")
             loop_count=loop_count+1
             save_step=FALSE
           end
         end
       end
!end testing convergence
       if(save_step)then
      !   .save_gmf_step(i_step,i_geminals)
         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
         .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
         .spectrum.put_ground_state_geminals
         eigenvec.destroy 
         if(.truncation_scheme(i_step)/=ZERO) then
           stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
           stdout.text(" ")
           .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
             .spectrum.contraction_energies < .truncation_scheme(i_step))
         end
         stdout.show("number of states saved at this step",.spectrum.n_bas)
         stdout.text(" ")
         timer.stop_timing
         stdout.show("time taken for this step in s:",timer.elapsed_time)
         stdout.text(" ")
         .spectrum.put_wfs
         .spectrum.put_ground_state
         .put_gs_energies(gs_energies)
         if(.do_triplet_energies(i_step)) then
           .do_triplet_spectrum
         end
       end
       if(i_loop == n_geminals) then
         i_loop=1
       else
         i_loop=i_loop+1
       end  
     end
     gs_energies.destroy
     old_tolerance.destroy
     group_order.destroy
   end

   restart_gmf_auto
   ! restart the contraction-truncation scheme
   ! designed for a singlet ground state
   ! does take advantage of the possible truncation of the geminal basis
     ham :: MAT{REAL}*
     gs_energies :: VEC{REAL}*
     old_tolerance :: VEC{INT}*
     group_order :: VEC{INT}*
     lowest_energy :: REAL
     old_energy :: REAL
     i,j,i_step,i_geminals :: INT
     n_nonzero,max_bas :: INT
     n_step,n_geminals,n_bf :: INT
     i_loop,loop_count :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     set :: BIN
     save_step :: BIN
     n_geminals=.spectrum.n_geminals
     n_bf=.spectrum.n_bf
     max_bas=.spectrum.n_bas
     n_step=size(.truncation_scheme)-1
     gs_energies.create(n_geminals)
     .get_gs_energies(gs_energies)
     group_order.create(n_geminals)
     gs_energies.quick_sort(group_order,decreasing_order=TRUE)
!out     stdout.text("group_order:")
!out     stdout.put(group_order)
!out     stop
     loop_count=1 !nb of step after step 0 or after a change of tolerance 
     i_loop=1 !index for group_order
     old_tolerance.create(n_geminals)
     .get_old_tolerance(old_tolerance)
     stdout.text(" ")
     stdout.text("WARNING, this is a restart job")
     stdout.text(" the step numbering and the group order have been re-initialised ")
     stdout.text(" the energy improvement message may be wrong for the first steps")
     stdout.text(" if less than n_geminals steps were performed in the original run ")
     stdout.text(" ")
! step 1 to n_steps -1
     do i_step=1,n_step
       timer.start_timing
       stdout.text(" ")
       stdout.show("step number: ",i_step)
       stdout.text(" ")
       .spectrum.ld_tol=.ld_tol_scheme(i_step)
       stdout.show("Linear dependence tolerance",.ld_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.ig_tol=.ig_tol_scheme(i_step)
       stdout.show("Internal geminal tolerance",.ig_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.tol=TOL(.tolerance_scheme(i_step))
       stdout.show("tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
       stdout.text(" ")
       do i=1,n_geminals
         .spectrum.set_defaults(i_geminals=i)
         .spectrum.get_ground_state
       end
       .spectrum.set_to_zero_special_ket !really needed here
       set=FALSE
       DIE_IF(maxval(old_tolerance)>.tolerance_scheme(i_step),"Cutoff tolerance has decreased")
       do i=0,n_geminals-1
         if(i_loop+i > n_geminals) then
           j=group_order(mod(i_loop+i,n_geminals))
         else
           j=group_order(i_loop+i)
         end  
         if(old_tolerance(j)<.tolerance_scheme(i_step))then
           stdout.text(" ")
           stdout.show("tolerance has increased for group",j) 
           stdout.text(" ")
           .spectrum.set_defaults(i_geminals=j)
           i_geminals=j
           set=TRUE
           if(i_loop+i > n_geminals) then
             i_loop=mod(i_loop+i,n_geminals)
           else
             i_loop=i_loop+i
           end  
           exit
         end
       end
       if(NOT set) then
         j=group_order(i_loop)
         .spectrum.set_defaults(i_geminals=j)
         i_geminals=j
       end
       old_energy=gs_energies(i_geminals)
       lowest_energy=minval(gs_energies)
       .spectrum.gs_permutation
       if(.do_triplet_energies(i_step)) then
         .do_triplet_spectrum
       end
       .remove_singlet_dependencies
       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
       .spectrum.set_to_zero_special_ket !really needed here
       ham.create(n_nonzero,n_nonzero)
       ham = .spectrum.hamiltonian !.spectrum.n_bas may be smaller than
                                  ! .spectrum.contraction_energies.dim but
                                  ! ! should work
       eigenvec.create(n_nonzero,n_nonzero)
       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec)
       ham.destroy
       if(.print_hamiltonian) then
         stdout.text(" ")
         stdout.text("singlet eigenvectors")
         stdout.text(" ")
         stdout.put(eigenvec)
         stdout.text(" ")
       end
       .spectrum.contraction_energies(1:n_nonzero)= &
          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
       .spectrum.get_max_bas !now .spectrum.n_bas is the size of the truncated
                             ! set of possibly quasilinearly dependent basis
                             ! functions

       do j=n_nonzero+1,.spectrum.n_bas
         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
       end
       stdout.text(" ")
       stdout.show("i_geminals    =",.spectrum.i_geminals)
       stdout.text(" ")
       stdout.show("first eigenvalue is:",.spectrum.contraction_energies(1),precision=12)
       stdout.text(" ")
       stdout.text(" ")
       stdout.text("singlet eigenvalues") 
       stdout.text(" ")
       stdout.put(.spectrum.contraction_energies) 
       stdout.text(" ")
!begin testing convergence
       if(set)then
         stdout.text(" ")
         stdout.text("the tolerance having changed, the job continue ...") 
         stdout.text(" ")
         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
         .put_old_tolerance(old_tolerance)
         loop_count=1
         save_step=TRUE
       else  
         if(.spectrum.contraction_energies(1)+.convergence_threshold<lowest_energy) then
           stdout.text(" ")
           stdout.text("Energy difference not within tolerance, the job continue ...") 
           stdout.text(" ")
           loop_count=1
           save_step=TRUE
         else
           if(.spectrum.contraction_energies(1)<old_energy) then
             stdout.show("The energy has improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=TRUE
           else
             stdout.show("The energy has not improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=FALSE
           end
           if(loop_count==n_geminals) then
          !   if(save_step)then
          !     .save_gmf_step(i_step,i_geminals)
          !     if(.do_triplet_energies(i_step)) then
          !       .do_triplet_spectrum
          !     end
          !   end
             stdout.text(" ")
             stdout.text("all electron groups have been considered")
             stdout.text(" ")
             stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
             stdout.text(" ")
             if(.convergence_threshold<.spectrum.tol) then
               stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
               stdout.text(" ")
             end
             stdout.text(std_time.elapsed_time_message(" "))
             stdout.text(std_time.elapsed_cpu_time_message(" "))
             stop
           else
             timer.stop_timing
             stdout.show("time taken for this step in s:",timer.elapsed_time)
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("Energy difference within tolerance, however ...") 
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("not all electron groups have been considered, the job continue ...") 
             stdout.text(" ")
             loop_count=loop_count+1
             save_step=FALSE
           end
         end
       end
!end testing convergence
       if(save_step)then
      !   .save_gmf_step(i_step,i_geminals)
         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
         .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
         .spectrum.put_ground_state_geminals
         eigenvec.destroy 
         if(.truncation_scheme(i_step)/=ZERO) then
           stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
           stdout.text(" ")
           .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
             .spectrum.contraction_energies < .truncation_scheme(i_step))
         end
         stdout.show("number of states saved at this step",.spectrum.n_bas)
         stdout.text(" ")
         timer.stop_timing
         stdout.show("time taken for this step in s:",timer.elapsed_time)
         stdout.text(" ")
         .spectrum.put_wfs
         .spectrum.put_ground_state
         .put_gs_energies(gs_energies)
       end
       if(i_loop == n_geminals) then
         i_loop=1
       else
         i_loop=i_loop+1
       end  
     end
     gs_energies.destroy
     old_tolerance.destroy
     group_order.destroy
   end

!     save_gmf_step(i_step,i_geminals) 
!     ! save a geminal mean field step for next iteration and/or restart
!       i_step,i_geminals :: INT
!       gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!       .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
!       .spectrum.put_ground_state_geminals
!       eigenvec.destroy 
!       if(.truncation_scheme(i_step)/=ZERO) then
!         stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
!         stdout.text(" ")
!         .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
!           .spectrum.contraction_energies < .truncation_scheme(i_step))
!       end
!       stdout.show("number of states saved at this step",.spectrum.n_bas)
!       stdout.text(" ")
!       timer.stop
!       stdout.show("time taken for this step in s:",timer.elapsed_time)
!       stdout.text(" ")
!       .spectrum.put_wfs
!       .spectrum.put_ground_state
!       .put_gs_energies(gs_energies)
!     end

!pcc
!pcc   do_gmf ::: leaky !because of the set_defaults
!pcc   ! implement the contraction-truncation scheme
!pcc   ! designed for a singlet ground state
!pcc   ! take advantage of the possible truncation of the geminal basis
!pcc     ham :: MAT{REAL}*
!pcc     gs_energies :: VEC{REAL}*
!pcc     old_tolerance :: VEC{INT}*
!pcc     old_energy,best_step_0 :: REAL
!pcc     i,j,i_step,i_geminals :: INT
!pcc     n_nonzero,max_bas :: INT
!pcc     n_step,n_geminals,n_bf :: INT
!pcc     eigenvec :: MAT{REAL}*
!pcc     !new_wfs :: VEC{MAT_{REAL}}*
!pcc     timer :: TIME
!pcc     set :: BIN
!pcc     n_geminals=.spectrum.n_geminals
!pcc     n_bf=.spectrum.n_bf
!pcc     max_bas=.spectrum.n_bas
!pcc     n_step=size(.truncation_scheme)-1
!pcc     gs_energies.create(n_geminals)
!pcc     old_tolerance.create(n_geminals)
!pcc! step 0
!pcc     timer.start_timing
!pcc     stdout.text(" ")
!pcc     stdout.show("step number: ",0)
!pcc     stdout.text(" ")
!pcc! i_geminals=1
!pcc     old_tolerance=.tolerance_scheme(0)
!pcc     .put_old_tolerance(old_tolerance)
!pcc     .spectrum.tol=TOL(.tolerance_scheme(0))
!pcc   !  .spectrum.set_singlet_agp !test
!pcc!for carmela     .spectrum.set_singlet_handmade !test
!pcc   !  .spectrum.set_singlet_random !test
!pcc!for carmela     .spectrum.put
!pcc!for carmela      ham.create(1,1)
!pcc!for carmela      ham = .spectrum.overlap
!pcc!for carmela      best_step_0 = ham(1,1) !.spectrum.n_bas may be smaller than
!pcc!for carmela      ham(1,1) = .spectrum.hamiltonian(1,1) !.spectrum.n_bas may be smaller than
!pcc!for carmela     stdout.show("carmela energy: ", ham(1,1))
!pcc!for carmela     stdout.show("carmela overlap: ", best_step_0)
!pcc!for carmela     stdout.show("carmela normalized energy: ", ham(1,1)/best_step_0)
!pcc!for carmela     stop
!pcc     .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0))
!pcc     gs_energies(1)=.spectrum.contraction_energies(1)
!pcc     do i=2,n_geminals
!pcc       .spectrum.set_defaults(i_geminals=i)
!pcc       .spectrum.set_singlet_defaults
!pcc      ! .spectrum.set_singlet_random
!pcc      ! .spectrum.set_singlet_agp
!pcc       .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0))
!pcc       gs_energies(i)=.spectrum.contraction_energies(1)
!pcc     end
!pcc     timer.stop_timing
!pcc     stdout.show("time taken for step 0 in s:",timer.elapsed_time)
!pcc     stdout.text(" ")
!pcc     .put_gs_energies(gs_energies)  
!pcc     i = minloc(gs_energies,1)
!pcc     best_step_0=gs_energies(i)
!pcc! step 1 to n_steps -1
!pcc     do i_step=1,n_step
!pcc       timer.start_timing
!pcc       stdout.text(" ")
!pcc       stdout.show("step number: ",i_step)
!pcc       stdout.text(" ")
!pcc       .spectrum.tol=TOL(.tolerance_scheme(i_step))
!pcc       stdout.show("tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
!pcc       stdout.text(" ")
!pcc       do i=1,n_geminals
!pcc         .spectrum.set_defaults(i_geminals=i)
!pcc         .spectrum.get_ground_state
!pcc       end
!pcc       .spectrum.set_to_zero_special_ket !maybe not needed but safer
!pcc     !  .get_old_tolerance(old_tolerance)
!pcc       set=FALSE
!pcc       do i=1,n_geminals
!pcc         DIE_IF(old_tolerance(i)>.tolerance_scheme(i_step),"tolerance has decreased")
!pcc         if(old_tolerance(i)<.tolerance_scheme(i_step))then
!pcc           stdout.text(" ")
!pcc           stdout.show("tolerance has increased for group",i) 
!pcc           stdout.text(" ")
!pcc           .spectrum.set_defaults(i_geminals=i)
!pcc           i_geminals=i
!pcc           set=TRUE
!pcc           exit
!pcc         end
!pcc       end
!pcc       if(NOT set) then
!pcc         i = minloc(gs_energies,1)
!pcc         old_energy=gs_energies(i)
!pcc         i = maxloc(gs_energies,1)
!pcc         .spectrum.set_defaults(i_geminals=i)
!pcc         i_geminals=i
!pcc       end
!pcc       .spectrum.gs_permutation
!pcc       .remove_singlet_dependencies
!pcc       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
!pcc       .spectrum.set_to_zero_special_ket !maybe not needed but safer
!pcc       ham.create(n_nonzero,n_nonzero)
!pcc       ham = .spectrum.hamiltonian !.spectrum.n_bas may be smaller than
!pcc                                  ! .spectrum.contraction_energies.dim but
!pcc                                  ! should work
!pcc       eigenvec.create(n_nonzero,n_nonzero)
!pcc       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec) 
!pcc       ham.destroy
!pcc       if(.print_hamiltonian) then
!pcc         stdout.text(" ")
!pcc         stdout.text("singlet eigenvectors") 
!pcc         stdout.text(" ")
!pcc         stdout.put(eigenvec) 
!pcc         stdout.text(" ")
!pcc       end
!pcc       .spectrum.contraction_energies(1:n_nonzero)= &
!pcc          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
!pcc       .spectrum.get_max_bas !now .spectrum.n_bas is the size of the truncated
!pcc                             ! set of possibly quasilinearly dependent basis
!pcc                             ! functions
!pcc       do j=n_nonzero+1,.spectrum.n_bas
!pcc         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
!pcc       end
!pcc       stdout.text(" ")
!pcc       stdout.show("i_geminals    =",i_geminals)
!pcc       stdout.text(" ")
!pcc       stdout.show("first eigenvalue is ",.spectrum.contraction_energies(1),precision=12)
!pcc       stdout.text(" ")
!pcc       stdout.text(" ")
!pcc       stdout.text("singlet eigenvalues") 
!pcc       stdout.text(" ")
!pcc       stdout.put(.spectrum.contraction_energies) 
!pcc       stdout.text(" ")
!pcc!begin testing convergence
!pcc       if(set)then
!pcc         stdout.text(" ")
!pcc         stdout.text("the tolerance having changed, the job continue ...") 
!pcc         stdout.text(" ")
!pcc         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
!pcc         .put_old_tolerance(old_tolerance)
!pcc         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc       else  
!pcc         if(.spectrum.contraction_energies(1)+.convergence_threshold<old_energy) then
!pcc           gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc         else
!pcc           if(NOT gs_energies(i_geminals)<best_step_0) then
!pcc             stdout.text("WARNING, convergence could be a step 0 effect.")
!pcc             stdout.text(" ")
!pcc           end
!pcc           if(.spectrum.contraction_energies(1)<gs_energies(i_geminals)) then
!pcc             stdout.show("The energy has improved for contraction",i_geminals)
!pcc             stdout.text(" ")
!pcc             gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc           else
!pcc             stdout.show("The energy has not even improved for contraction",i_geminals)
!pcc             stdout.text(" ")
!pcc             timer.stop_timing
!pcc             stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc             stdout.text(std_time.elapsed_time_message(" "))
!pcc             stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc             stop
!pcc           end
!pcc           i=maxloc(gs_energies,1)
!pcc           if(i==i_geminals) then
!pcc             stdout.show("largest energy is still for geminal",i_geminals)
!pcc             stdout.text(" ")
!pcc             timer.stop_timing
!pcc             stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc             stdout.text(std_time.elapsed_time_message(" "))
!pcc             stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc             stop
!pcc           else
!pcc             if(gs_energies(i)-.spectrum.contraction_energies(1)<.convergence_threshold) then
!pcc               stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
!pcc               stdout.text(" ")
!pcc               if(.convergence_threshold<.spectrum.tol) then
!pcc                 stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
!pcc                 stdout.text(" ")
!pcc               end
!pcc               timer.stop_timing
!pcc               stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc               stdout.text(std_time.elapsed_time_message(" "))
!pcc               stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc               stop
!pcc             else
!pcc               stdout.show("now the largest energy is for contraction",i)
!pcc               stdout.text(" ")
!pcc             end
!pcc           end
!pcc         end
!pcc       end
!pcc!end testing convergence
!pcc       .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
!pcc       .spectrum.put_ground_state_geminals
!pcc       eigenvec.destroy 
!pcc       if(.truncation_scheme(i_step)/=ZERO) then
!pcc         stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
!pcc         stdout.text(" ")
!pcc         .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
!pcc           .spectrum.contraction_energies < .truncation_scheme(i_step))
!pcc       end
!pcc       stdout.show("number of states saved at this step",.spectrum.n_bas)
!pcc       stdout.text(" ")
!pcc       timer.stop_timing
!pcc       stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc       stdout.text(" ")
!pcc       .spectrum.put_wfs
!pcc       .spectrum.put_ground_state
!pcc       .put_gs_energies(gs_energies)
!pcc       if(.do_triplet_energies(i_step)) then
!pcc         .do_triplet_spectrum
!pcc       end
!pcc     end
!pcc     gs_energies.destroy
!pcc     old_tolerance.destroy
!pcc   end
!pcc
!pcc   restart_gmf
!pcc   ! restart the contraction-truncation scheme
!pcc   ! designed for a singlet ground state
!pcc   ! does take advantage of the possible truncation of the geminal basis
!pcc     ham :: MAT{REAL}*
!pcc     gs_energies :: VEC{REAL}*
!pcc     old_tolerance :: VEC{INT}*
!pcc     old_energy :: REAL
!pcc     i,j,i_step,i_geminals :: INT
!pcc     n_nonzero,max_bas :: INT
!pcc     n_step,n_geminals,n_bf :: INT
!pcc     eigenvec :: MAT{REAL}*
!pcc     !new_wfs :: VEC{MAT_{REAL}}*
!pcc     timer :: TIME
!pcc     set :: BIN
!pcc     n_geminals=.spectrum.n_geminals
!pcc     n_bf=.spectrum.n_bf
!pcc     max_bas=.spectrum.n_bas
!pcc     n_step=size(.truncation_scheme)-1
!pcc     gs_energies.create(n_geminals)
!pcc     old_tolerance.create(n_geminals)
!pcc     .get_gs_energies(gs_energies)
!pcc     .get_old_tolerance(old_tolerance)
!pcc     stdout.text(" ")
!pcc     stdout.text("WARNING, this is a restart job")
!pcc     stdout.text(" the step numbering has been re-initialised ")
!pcc     stdout.text(" Ensure that the number of steps done in the previous jobs ")
!pcc     stdout.text(" was at least equal to the number of geminals + 1 ")
!pcc     stdout.text(" (or more if the tolerance was not constant), ")
!pcc     stdout.text(" because step 0 effects are not tested for in this routine ")
!pcc     stdout.text(" ")
!pcc! step 1 to n_steps -1
!pcc     do i_step=1,n_step
!pcc       timer.start_timing
!pcc       stdout.text(" ")
!pcc       stdout.show("step number: ",i_step)
!pcc       stdout.text(" ")
!pcc       .spectrum.tol=TOL(.tolerance_scheme(i_step))
!pcc       stdout.show("tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
!pcc       stdout.text(" ")
!pcc       do i=1,n_geminals
!pcc         .spectrum.set_defaults(i_geminals=i)
!pcc         .spectrum.get_ground_state
!pcc       end
!pcc       .spectrum.set_to_zero_special_ket !really needed here
!pcc       set=FALSE
!pcc       do i=1,n_geminals
!pcc         DIE_IF(old_tolerance(i)>.tolerance_scheme(i_step),"tolerance has decreased")
!pcc         if(old_tolerance(i)<.tolerance_scheme(i_step))then
!pcc           stdout.text(" ")
!pcc           stdout.show("tolerance has increased for group",i)
!pcc           stdout.text(" ")
!pcc           .spectrum.set_defaults(i_geminals=i)
!pcc           i_geminals=i
!pcc           set=TRUE
!pcc           exit
!pcc         end
!pcc       end
!pcc       if(NOT set) then
!pcc         i = minloc(gs_energies,1)
!pcc         old_energy=gs_energies(i)
!pcc         i = maxloc(gs_energies,1)
!pcc         .spectrum.set_defaults(i_geminals=i)
!pcc         i_geminals=i
!pcc       end
!pcc       .spectrum.gs_permutation
!pcc       if(.do_triplet_energies(i_step)) then
!pcc         .do_triplet_spectrum
!pcc       end
!pcc       .remove_singlet_dependencies
!pcc       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
!pcc       .spectrum.set_to_zero_special_ket !really needed here
!pcc       ham.create(n_nonzero,n_nonzero)
!pcc       ham = .spectrum.hamiltonian !.spectrum.n_bas may be smaller than
!pcc                                  ! .spectrum.contraction_energies.dim but
!pcc                                  ! ! should work
!pcc       eigenvec.create(n_nonzero,n_nonzero)
!pcc       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec)
!pcc       ham.destroy
!pcc       if(.print_hamiltonian) then
!pcc         stdout.text(" ")
!pcc         stdout.text("singlet eigenvectors")
!pcc         stdout.text(" ")
!pcc         stdout.put(eigenvec)
!pcc         stdout.text(" ")
!pcc       end
!pcc       .spectrum.contraction_energies(1:n_nonzero)= &
!pcc          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
!pcc       .spectrum.get_max_bas !now .spectrum.n_bas is the size of the truncated
!pcc                             ! set of possibly quasilinearly dependent basis
!pcc                             ! functions
!pcc
!pcc       do j=n_nonzero+1,.spectrum.n_bas
!pcc         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
!pcc       end
!pcc       stdout.text(" ")
!pcc       stdout.show("i_geminals    =",.spectrum.i_geminals)
!pcc       stdout.text(" ")
!pcc       stdout.show("first eigenvalue is:",.spectrum.contraction_energies(1),precision=12)
!pcc       stdout.text(" ")
!pcc       stdout.text(" ")
!pcc       stdout.text("singlet eigenvalues") 
!pcc       stdout.text(" ")
!pcc       stdout.put(.spectrum.contraction_energies) 
!pcc       stdout.text(" ")
!pcc!begin testing convergence
!pcc       if(set)then
!pcc         stdout.text(" ")
!pcc         stdout.text("the tolerance having changed, the job continue ...")
!pcc         stdout.text(" ")
!pcc         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
!pcc         .put_old_tolerance(old_tolerance)
!pcc         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc       else
!pcc         if(.spectrum.contraction_energies(1)+.convergence_threshold<old_energy) then
!pcc           gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc         else
!pcc           if(.spectrum.contraction_energies(1)<gs_energies(i_geminals)) then
!pcc             stdout.show("The energy has improved for contraction",i_geminals)
!pcc             stdout.text(" ")
!pcc             gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc           else
!pcc             stdout.show("The energy has not even improved for contraction",i_geminals)
!pcc             stdout.text(" ")
!pcc             timer.stop_timing
!pcc             stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc             stdout.text(std_time.elapsed_time_message(" "))
!pcc             stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc             stop
!pcc           end
!pcc           i=maxloc(gs_energies,1)
!pcc           if(i==i_geminals) then
!pcc             stdout.show("largest energy is still for geminal",i_geminals)
!pcc             stdout.text(" ")
!pcc             timer.stop_timing
!pcc             stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc             stdout.text(std_time.elapsed_time_message(" "))
!pcc             stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc             stop
!pcc           else
!pcc             if(gs_energies(i)-.spectrum.contraction_energies(1)<.convergence_threshold) then
!pcc               stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
!pcc               stdout.text(" ")
!pcc               if(.convergence_threshold<.spectrum.tol) then
!pcc                 stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
!pcc                 stdout.text(" ")
!pcc               end
!pcc               timer.stop_timing
!pcc               stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc               stdout.text(std_time.elapsed_time_message(" "))
!pcc               stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc               stop
!pcc             else
!pcc               stdout.show("now the largest energy is for contraction",i)
!pcc               stdout.text(" ")
!pcc             end
!pcc           end
!pcc         end
!pcc       end
!pcc!end testing convergence
!pcc       .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
!pcc       .spectrum.put_ground_state_geminals
!pcc       eigenvec.destroy 
!pcc       if(.truncation_scheme(i_step)/=ZERO) then
!pcc         stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
!pcc         stdout.text(" ")
!pcc         .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
!pcc           .spectrum.contraction_energies < .truncation_scheme(i_step))
!pcc       end
!pcc       stdout.show("number of states saved at this step",.spectrum.n_bas)
!pcc       stdout.text(" ")
!pcc       timer.stop_timing
!pcc       stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc       stdout.text(" ")
!pcc       .spectrum.put_wfs
!pcc       .spectrum.put_ground_state
!pcc       .put_gs_energies(gs_energies)
!pcc     end
!pcc     gs_energies.destroy
!pcc     old_tolerance.destroy
!pcc   end
!pcc
!pcc   do_spectrum ::: leaky !because of the set_defaults
!pcc   ! implement the contraction-truncation scheme
!pcc   ! designed for a singlet ground state
!pcc   ! does not take advantage of the possible truncation of the geminal basis
!pcc     ham :: MAT{REAL}*
!pcc     gs_energies :: VEC{REAL}*
!pcc     old_tolerance :: VEC{INT}*
!pcc     old_energy,best_step_0 :: REAL
!pcc     i,j,i_step,i_geminals :: INT
!pcc     n_nonzero,max_bas :: INT
!pcc     n_step,n_geminals,n_bf :: INT
!pcc     eigenvec :: MAT{REAL}*
!pcc     !new_wfs :: VEC{MAT_{REAL}}*
!pcc     orthovec :: MAT{REAL}*
!pcc     timer :: TIME
!pcc     set :: BIN
!pcc     n_geminals=.spectrum.n_geminals
!pcc     n_bf=.spectrum.n_bf
!pcc!for_gio
!pcc!for_gio     .spectrum.set_defaults(i_geminals=3) !test
!pcc!for_gio     .spectrum.set_singlet_mono !test
!pcc!for_gio 
!pcc!for_gio     max_bas=.spectrum.n_bas
!pcc!for_gio!begin test 
!pcc!for_gio     ham.create(2,2) !test
!pcc!for_gio     .spectrum.hamiltonian_matrix_gio(ham) !test
!pcc!for_gio       eigenvec.create(2,2)
!pcc!for_gio       eigenvalues.create(2)
!pcc!for_gio       ham.solve_eigenproblem(eigenvalues,eigenvec) 
!pcc!for_gio   !    ham = .spectrum.hamiltonian !test
!pcc!for_gio         stdout.text(" ")
!pcc!for_gio        ! stdout.text("The Hamiltonian for mono excited singlet is ")
!pcc!for_gio         stdout.text("The eigenvalues are  ")
!pcc!for_gio         stdout.text(" ")
!pcc!for_gio        ! stdout.put(ham)
!pcc!for_gio         stdout.put(eigenvalues)
!pcc!for_gio         stdout.text(" ")
!pcc!for_gio   stop
!pcc!for_gio!end test 
!pcc!for_gio
!pcc     max_bas=.spectrum.n_bas
!pcc     n_step=size(.truncation_scheme)-1
!pcc     gs_energies.create(n_geminals)
!pcc     old_tolerance.create(n_geminals)
!pcc! step 0
!pcc     timer.start_timing
!pcc     stdout.text(" ")
!pcc     stdout.show("step number: ",0)
!pcc     stdout.text(" ")
!pcc! i_geminals=1
!pcc     old_tolerance=.tolerance_scheme(0)
!pcc     .put_old_tolerance(old_tolerance)
!pcc     .spectrum.tol=TOL(.tolerance_scheme(0))
!pcc     .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0))
!pcc     gs_energies(1)=.spectrum.contraction_energies(1)
!pcc     do i=2,n_geminals
!pcc       .spectrum.set_defaults(i_geminals=i)
!pcc       .spectrum.set_singlet_defaults
!pcc      ! .spectrum.set_singlet_random
!pcc     !  .spectrum.set_singlet_agp
!pcc       .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0))
!pcc       gs_energies(i)=.spectrum.contraction_energies(1)
!pcc     end
!pcc     timer.stop_timing
!pcc     stdout.show("time taken for step 0 in s:",timer.elapsed_time)
!pcc     stdout.text(" ")
!pcc     i = minloc(gs_energies,1)
!pcc     best_step_0=gs_energies(i)
!pcc! step 1 to n_steps -1
!pcc     do i_step=1,n_step
!pcc       timer.start_timing
!pcc       stdout.text(" ")
!pcc       stdout.show("step number: ",i_step)
!pcc       stdout.text(" ")
!pcc       .spectrum.tol=TOL(.tolerance_scheme(i_step))
!pcc       stdout.show("tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
!pcc       stdout.text(" ")
!pcc       do i=1,n_geminals
!pcc         .spectrum.set_defaults(i_geminals=i)
!pcc         .spectrum.get_ground_state
!pcc       end
!pcc       .spectrum.set_to_zero_special_ket !maybe not needed but safer
!pcc     !  .get_old_tolerance(old_tolerance)
!pcc       set=FALSE
!pcc       do i=1,n_geminals
!pcc         DIE_IF(old_tolerance(i)>.tolerance_scheme(i_step),"tolerance has decreased")
!pcc         if(old_tolerance(i)<.tolerance_scheme(i_step))then
!pcc           stdout.text(" ")
!pcc           stdout.show("tolerance has increased for group",i) 
!pcc           stdout.text(" ")
!pcc           .spectrum.set_defaults(i_geminals=i)
!pcc           i_geminals=i
!pcc           set=TRUE
!pcc           exit
!pcc         end
!pcc       end
!pcc       if(NOT set) then
!pcc         i = minloc(gs_energies,1)
!pcc         old_energy=gs_energies(i)
!pcc         i = maxloc(gs_energies,1)
!pcc         .spectrum.set_defaults(i_geminals=i)
!pcc         i_geminals=i
!pcc       end
!pcc       .spectrum.gs_permutation
!pcc       .remove_singlet_default_dependencies
!pcc       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
!pcc       .spectrum.set_to_zero_special_ket !maybe not needed but safer
!pcc       .spectrum.set_singlet_wfs !now .spectrum.n_bas is again max_bas
!pcc       ham.create(max_bas,max_bas)
!pcc       ham = .spectrum.hamiltonian
!pcc       .spectrum.get_wfs     !now .spectrum.n_bas is the size of the truncated
!pcc                             ! set of possibly quasilinearly dependent basis
!pcc                             ! functions 
!pcc       orthovec.create(n_nonzero,max_bas)
!pcc       .spectrum.contraction_wfs(1:n_nonzero).flatten(orthovec)
!pcc       ham.back_transform_using(orthovec)
!pcc       if(.print_hamiltonian) then
!pcc         stdout.text(" ")
!pcc         stdout.text("The singlet  Hamiltonian is ")
!pcc         stdout.text(" ")
!pcc         stdout.put(ham(1:n_nonzero,1:n_nonzero))
!pcc         stdout.text(" ")
!pcc       end
!pcc       orthovec.destroy
!pcc       eigenvec.create(n_nonzero,n_nonzero)
!pcc       ham.shrink(n_nonzero,n_nonzero)
!pcc       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec) 
!pcc       ham.destroy
!pcc       if(.print_hamiltonian) then
!pcc         stdout.text(" ")
!pcc         stdout.text("singlet eigenvectors") 
!pcc         stdout.text(" ")
!pcc         stdout.put(eigenvec) 
!pcc         stdout.text(" ")
!pcc       end
!pcc       .spectrum.contraction_energies(1:n_nonzero)= &
!pcc          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
!pcc       do j=n_nonzero+1,.spectrum.n_bas
!pcc         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
!pcc       end
!pcc       stdout.text(" ")
!pcc       stdout.show("i_geminals    =",i_geminals)
!pcc       stdout.text(" ")
!pcc       stdout.show("first eigenvalue is ",.spectrum.contraction_energies(1),precision=12)
!pcc       stdout.text(" ")
!pcc       stdout.text(" ")
!pcc       stdout.text("singlet eigenvalues") 
!pcc       stdout.text(" ")
!pcc       stdout.put(.spectrum.contraction_energies) 
!pcc       stdout.text(" ")
!pcc!begin testing convergence
!pcc       if(set)then
!pcc         stdout.text(" ")
!pcc         stdout.text("the tolerance having changed, the job continue ...") 
!pcc         stdout.text(" ")
!pcc         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
!pcc         .put_old_tolerance(old_tolerance)
!pcc         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc       else  
!pcc         if(.spectrum.contraction_energies(1)+.convergence_threshold<old_energy) then
!pcc           gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc         else
!pcc           if(NOT gs_energies(i_geminals)<best_step_0) then
!pcc             stdout.text("WARNING, convergence could be a step 0 effect.")
!pcc             stdout.text(" ")
!pcc           end
!pcc           if(.spectrum.contraction_energies(1)<gs_energies(i_geminals)) then
!pcc             stdout.show("The energy has improved for contraction",i_geminals)
!pcc             stdout.text(" ")
!pcc             gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc           else
!pcc             stdout.show("The energy has not even improved for contraction",i_geminals)
!pcc             stdout.text(" ")
!pcc             timer.stop_timing
!pcc             stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc             stdout.text(std_time.elapsed_time_message(" "))
!pcc             stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc             stop
!pcc           end
!pcc           i=maxloc(gs_energies,1)
!pcc           if(i==i_geminals) then
!pcc             stdout.show("largest energy is still for geminal",i_geminals)
!pcc             stdout.text(" ")
!pcc             timer.stop_timing
!pcc             stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc             stdout.text(std_time.elapsed_time_message(" "))
!pcc             stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc             stop
!pcc           else
!pcc             if(gs_energies(i)-.spectrum.contraction_energies(1)<.convergence_threshold) then
!pcc               stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
!pcc               stdout.text(" ")
!pcc               if(.convergence_threshold<.spectrum.tol) then
!pcc                 stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
!pcc                 stdout.text(" ")
!pcc               end
!pcc               timer.stop_timing
!pcc               stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc               stdout.text(std_time.elapsed_time_message(" "))
!pcc               stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc               stop
!pcc             else
!pcc               stdout.show("now the largest energy is for contraction",i)
!pcc               stdout.text(" ")
!pcc             end
!pcc           end
!pcc         end
!pcc       end
!pcc!end testing convergence
!pcc       .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
!pcc  !     new_wfs.create(n_nonzero)
!pcc  !     do j=1,n_nonzero
!pcc  !       new_wfs(j).element.create(n_bf,n_bf)
!pcc  !     end
!pcc  !     new_wfs.to_product_of(eigenvec,.spectrum.contraction_wfs(1:n_nonzero),TRUE)
!pcc       eigenvec.destroy 
!pcc  !     do j=1,n_nonzero
!pcc  !       .spectrum.contraction_wfs(j).element=new_wfs(j).element
!pcc  !     end
!pcc  !     new_wfs.destroy 
!pcc       if(.truncation_scheme(i_step)/=ZERO) then
!pcc         stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
!pcc         stdout.text(" ")
!pcc         .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
!pcc           .spectrum.contraction_energies < .truncation_scheme(i_step))
!pcc       end
!pcc       stdout.show("number of states saved at this step",.spectrum.n_bas)
!pcc       stdout.text(" ")
!pcc       timer.stop_timing
!pcc       stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc       stdout.text(" ")
!pcc       .spectrum.put_wfs
!pcc       .spectrum.put_ground_state
!pcc       .put_gs_energies(gs_energies)
!pcc       if(.do_triplet_energies(i_step)) then
!pcc         .do_triplet_spectrum
!pcc       end
!pcc     end
!pcc     gs_energies.destroy
!pcc     old_tolerance.destroy
!pcc   end
!pcc
!pcc   do_restart 
!pcc   ! restart the contraction-truncation scheme
!pcc   ! designed for a singlet ground state
!pcc   ! does not take advantage of the possible truncation of the geminal basis
!pcc     ham :: MAT{REAL}*
!pcc     gs_energies :: VEC{REAL}*
!pcc     old_tolerance :: VEC{INT}*
!pcc     old_energy :: REAL
!pcc     i,j,i_step,i_geminals :: INT
!pcc     n_nonzero,max_bas :: INT
!pcc     n_step,n_geminals,n_bf :: INT
!pcc     eigenvec :: MAT{REAL}*
!pcc     !new_wfs :: VEC{MAT_{REAL}}*
!pcc     orthovec :: MAT{REAL}*
!pcc     timer :: TIME
!pcc     set :: BIN
!pcc     n_geminals=.spectrum.n_geminals
!pcc     n_bf=.spectrum.n_bf
!pcc     max_bas=.spectrum.n_bas
!pcc     n_step=size(.truncation_scheme)-1
!pcc     gs_energies.create(n_geminals)
!pcc     old_tolerance.create(n_geminals)
!pcc     .get_gs_energies(gs_energies)
!pcc     .get_old_tolerance(old_tolerance)
!pcc     stdout.text(" ")
!pcc     stdout.text("WARNING, this is a restart job")
!pcc     stdout.text(" the step numbering has been re-initialised ")
!pcc     stdout.text(" Ensure that the number of steps done in the previous jobs ")
!pcc     stdout.text(" was at least equal to the number of geminals + 1 ")
!pcc     stdout.text(" (or more if the tolerance was not constant), ")
!pcc     stdout.text(" because step 0 effects are not tested for in this routine ")
!pcc     stdout.text(" ")
!pcc! step 1 to n_steps -1
!pcc     do i_step=1,n_step
!pcc       timer.start_timing
!pcc       stdout.text(" ")
!pcc       stdout.show("step number: ",i_step)
!pcc       stdout.text(" ")
!pcc       .spectrum.tol=TOL(.tolerance_scheme(i_step))
!pcc       stdout.show("tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
!pcc       stdout.text(" ")
!pcc       do i=1,n_geminals
!pcc         .spectrum.set_defaults(i_geminals=i)
!pcc         .spectrum.get_ground_state
!pcc       end
!pcc       .spectrum.set_to_zero_special_ket !really needed here
!pcc       set=FALSE
!pcc       do i=1,n_geminals
!pcc         DIE_IF(old_tolerance(i)>.tolerance_scheme(i_step),"tolerance has decreased")
!pcc         if(old_tolerance(i)<.tolerance_scheme(i_step))then
!pcc           stdout.text(" ")
!pcc           stdout.show("tolerance has increased for group",i)
!pcc           stdout.text(" ")
!pcc           .spectrum.set_defaults(i_geminals=i)
!pcc           i_geminals=i
!pcc           set=TRUE
!pcc           exit
!pcc         end
!pcc       end
!pcc       if(NOT set) then
!pcc         i = minloc(gs_energies,1)
!pcc         old_energy=gs_energies(i)
!pcc         i = maxloc(gs_energies,1)
!pcc         .spectrum.set_defaults(i_geminals=i)
!pcc         i_geminals=i
!pcc       end
!pcc       .spectrum.gs_permutation
!pcc       if(.do_triplet_energies(i_step)) then
!pcc         .do_triplet_spectrum
!pcc       end
!pcc       .remove_singlet_default_dependencies
!pcc       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
!pcc       .spectrum.set_to_zero_special_ket !really needed here
!pcc       .spectrum.set_singlet_wfs !now .spectrum.n_bas is again max_bas
!pcc       ham.create(max_bas,max_bas)
!pcc       ham = .spectrum.hamiltonian
!pcc       .spectrum.get_wfs     !now .spectrum.n_bas is the size of the truncated
!pcc                             ! set of possibly quasilinearly dependent basis
!pcc                             ! functions
!pcc       orthovec.create(n_nonzero,max_bas)
!pcc       .spectrum.contraction_wfs(1:n_nonzero).flatten(orthovec)
!pcc       ham.back_transform_using(orthovec)
!pcc       if(.print_hamiltonian) then
!pcc         stdout.text(" ")
!pcc         stdout.text("The singlet  Hamiltonian is ")
!pcc         stdout.text(" ")
!pcc         stdout.put(ham(1:n_nonzero,1:n_nonzero))
!pcc         stdout.text(" ")
!pcc       end
!pcc       orthovec.destroy
!pcc       eigenvec.create(n_nonzero,n_nonzero)
!pcc       ham.shrink(n_nonzero,n_nonzero)
!pcc       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec) 
!pcc       ham.destroy
!pcc       if(.print_hamiltonian) then
!pcc         stdout.text(" ")
!pcc         stdout.text("singlet eigenvectors") 
!pcc         stdout.text(" ")
!pcc         stdout.put(eigenvec) 
!pcc         stdout.text(" ")
!pcc       end
!pcc       .spectrum.contraction_energies(1:n_nonzero)= &
!pcc          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
!pcc       do j=n_nonzero+1,.spectrum.n_bas
!pcc         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
!pcc       end
!pcc       stdout.text(" ")
!pcc       stdout.show("i_geminals    =",.spectrum.i_geminals)
!pcc       stdout.text(" ")
!pcc       stdout.show("first eigenvalue is:",.spectrum.contraction_energies(1),precision=12)
!pcc       stdout.text(" ")
!pcc       stdout.text(" ")
!pcc       stdout.text("singlet eigenvalues") 
!pcc       stdout.text(" ")
!pcc       stdout.put(.spectrum.contraction_energies) 
!pcc       stdout.text(" ")
!pcc!begin testing convergence
!pcc       if(set)then
!pcc         stdout.text(" ")
!pcc         stdout.text("the tolerance having changed, the job continue ...")
!pcc         stdout.text(" ")
!pcc         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
!pcc         .put_old_tolerance(old_tolerance)
!pcc         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc       else
!pcc         if(.spectrum.contraction_energies(1)+.convergence_threshold<old_energy) then
!pcc           gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc         else
!pcc           if(.spectrum.contraction_energies(1)<gs_energies(i_geminals)) then
!pcc             stdout.show("The energy has improved for contraction",i_geminals)
!pcc             stdout.text(" ")
!pcc             gs_energies(i_geminals)=.spectrum.contraction_energies(1)
!pcc           else
!pcc             stdout.show("The energy has not even improved for contraction",i_geminals)
!pcc             stdout.text(" ")
!pcc             timer.stop_timing
!pcc             stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc             stdout.text(std_time.elapsed_time_message(" "))
!pcc             stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc             stop
!pcc           end
!pcc           i=maxloc(gs_energies,1)
!pcc           if(i==i_geminals) then
!pcc             stdout.show("largest energy is still for geminal",i_geminals)
!pcc             stdout.text(" ")
!pcc             timer.stop_timing
!pcc             stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc             stdout.text(std_time.elapsed_time_message(" "))
!pcc             stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc             stop
!pcc           else
!pcc             if(gs_energies(i)-.spectrum.contraction_energies(1)<.convergence_threshold) then
!pcc               stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
!pcc               stdout.text(" ")
!pcc               if(.convergence_threshold<.spectrum.tol) then
!pcc                 stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
!pcc                 stdout.text(" ")
!pcc               end
!pcc               timer.stop_timing
!pcc               stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc               stdout.text(std_time.elapsed_time_message(" "))
!pcc               stdout.text(std_time.elapsed_cpu_time_message(" "))
!pcc               stop
!pcc             else
!pcc               stdout.show("now the largest energy is for contraction",i)
!pcc               stdout.text(" ")
!pcc             end
!pcc           end
!pcc         end
!pcc       end
!pcc!end testing convergence
!pcc       .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
!pcc   !    new_wfs.create(n_nonzero)
!pcc   !    do j=1,n_nonzero
!pcc   !      new_wfs(j).element.create(n_bf,n_bf)
!pcc   !    end
!pcc   !    new_wfs.to_product_of(eigenvec,.spectrum.contraction_wfs(1:n_nonzero),TRUE)
!pcc       eigenvec.destroy 
!pcc   !    do j=1,n_nonzero
!pcc   !      .spectrum.contraction_wfs(j).element=new_wfs(j).element
!pcc   !    end
!pcc   !    new_wfs.destroy 
!pcc       if(.truncation_scheme(i_step)/=ZERO) then
!pcc         stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
!pcc         stdout.text(" ")
!pcc         .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
!pcc           .spectrum.contraction_energies < .truncation_scheme(i_step))
!pcc       end
!pcc       stdout.show("number of states saved at this step",.spectrum.n_bas)
!pcc       stdout.text(" ")
!pcc       timer.stop_timing
!pcc       stdout.show("time taken for this step in s:",timer.elapsed_time)
!pcc       stdout.text(" ")
!pcc       .spectrum.put_wfs
!pcc       .spectrum.put_ground_state
!pcc       .put_gs_energies(gs_energies)
!pcc     end
!pcc     gs_energies.destroy
!pcc     old_tolerance.destroy
!pcc   end
!pcc
   do_triplet_spectrum ::: leaky !because of the set_defaults
   ! do the triplet spectrum after a geminal mean field singlet step
     ham :: MAT{REAL}*
     i_geminals :: INT
     n_geminals,max_bas :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     timer.start_timing
     n_geminals=.spectrum.n_geminals
     i_geminals=.spectrum.i_geminals
     stdout.text(" ")
     stdout.text("Triplet spectrum for this step")
     stdout.text(" ")
!     .spectrum.set_triplet_wfs !now .spectrum.n_bas is again max_bas
     .remove_triplet_default_dependencies
     max_bas=.spectrum.n_bas
     ham.create(max_bas,max_bas)
     ham = .spectrum.hamiltonian
     if(.print_hamiltonian) then
       stdout.text("The triplet hamiltonian matrix is ")
       stdout.text(" ")
       stdout.put(ham)
       stdout.text(" ")
     end
     eigenvec.create(max_bas,max_bas)
     ham.solve_eigenproblem(.spectrum.contraction_energies,eigenvec) 
     ham.destroy
     if(.print_hamiltonian) then
       stdout.text("triplet eigenvectors") 
       stdout.text(" ")
       stdout.put(eigenvec) 
       stdout.text(" ")
     end
     .spectrum.contraction_energies= .spectrum.contraction_energies+.spectrum.nuclear_energy
     stdout.show("i_geminals    =",i_geminals)
     stdout.text(" ")
     stdout.text(" ")
     stdout.text("triplet eigenvalues") 
     stdout.text(" ")
     stdout.put(.spectrum.contraction_energies) 
     stdout.text(" ")
     timer.stop_timing
     stdout.show("time taken for triplet spectrum in s:",timer.elapsed_time)
     stdout.text(" ")
   end

   remove_singlet_dependencies ::: leaky
   ! remove linear dependencies in the contraction basis set
     .spectrum.remove_dependencies(.use_orthogonality,.print_hamiltonian)
   end

!pcc   remove_singlet_default_dependencies ::: leaky
!pcc   ! remove linear dependencies in the contraction basis set
!pcc     .spectrum.remove_dependencies_fast(.use_orthogonality,.print_hamiltonian)
!pcc   end
!pcc

   remove_triplet_default_dependencies ::: leaky
   ! remove linear dependencies in the contraction basis set
     .spectrum.remove_triplet_dependencies(.print_hamiltonian)
   end

end
