!-------------------------------------------------------------------------------
!
! GEMINAL_MF_SCHEME
!
! Copyright (C) Patrick Cassam-Chenai 2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: geminal_mf_spectrum.foo,v 1.15 2004/03/24 04:55:46 cassam Exp $
!
!-------------------------------------------------------------------------------

module GEMINAL_MF_SCHEME

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!*******************************************************************************
!                             Create and Destroy Routines
!*******************************************************************************

   create(name,nuc,n_geminals,n_step,n_bf,use_brillouin,orthogonality_type,print_hamiltonian,convergence) ::: leaky
   ! Create the contraction-truncation scheme 
      self :: PTR
      name :: STR
      orthogonality_type :: STR
      nuc :: REAL
      n_geminals,n_step,n_bf :: INT
      convergence :: REAL
      use_brillouin,print_hamiltonian :: BIN
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults(n_geminals,n_step,n_bf,name,nuc,use_brillouin,orthogonality_type,print_hamiltonian,convergence)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      nullify(.do_triplet_energies)
      nullify(.truncation_scheme)
   end

   destroy_ptr_part  ::: leaky
   ! Destroy the pointer parts of self
      .do_triplet_energies.destroy
      .truncation_scheme.destroy
   end

   create_copy(b) ::: leaky
   ! Create a copy of "b".
     b :: GEMINAL_MF_SCHEME, IN
     n_step :: INT
     self :: PTR
     n_step=size(b.truncation_scheme)
     .create(b.spectrum.name,b.spectrum.nuclear_energy,b.spectrum.n_geminals,n_step   &   
            ,b.spectrum.n_bf,b.use_brillouin,b.orthogonality_type,b.print_hamiltonian,b.convergence_threshold)
     .copy(b)
   end

   copy(b) ::: leaky
   ! Copy a basis "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
      b :: GEMINAL_MF_SCHEME, IN
      self = b
      if (b.truncation_scheme.created) .truncation_scheme.create_copy(b.truncation_scheme)
      if (b.do_triplet_energies.created) .do_triplet_energies.create_copy(b.do_triplet_energies)
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   set_defaults(n_geminals,n_steps,n_bf,name,nuclear_energy,use_brillouin,orthogonality_type,print_hamiltonian,convergence) ::: leaky
   ! Create a default object.
     n_geminals,n_steps,n_bf :: INT
     name :: STR
     orthogonality_type :: STR
     nuclear_energy :: REAL
     use_brillouin,print_hamiltonian :: BIN, optional
     convergence :: REAL, optional
     i_step,n_step :: INT
     .orthogonality_type = orthogonality_type
     .use_brillouin = TRUE
     .print_hamiltonian = FALSE
     .convergence_threshold = REAL_EPSILON
     n_step=n_steps-1
     if (present(use_brillouin)) .use_brillouin = use_brillouin
     if (present(print_hamiltonian)) .print_hamiltonian = print_hamiltonian
     if (present(convergence) AND convergence>.convergence_threshold) .convergence_threshold=convergence
     .spectrum.create(name,nuclear_energy,n_geminals,1,n_bf)
     .ld_tol_scheme.create(1,n_step)
     .ig_tol_scheme.create(1,n_step)
     .tolerance_scheme.create(0,n_step)
     .truncation_scheme.create(0,n_step)
     .do_triplet_energies.create(0,n_step)
!steps from 0 to nsteps - 1
     stdin.read(.tolerance_scheme(0))
     if(.tolerance_scheme(0)<=ZERO) .tolerance_scheme(0)=12
     stdin.read(.do_triplet_energies(0))
     stdin.read(.truncation_scheme(0))
     do i_step=1,n_step
       stdin.read(.ld_tol_scheme(i_step))
       if(.ld_tol_scheme(i_step)<=ZERO) .ld_tol_scheme(i_step)=LINEAR_DEPENDENCE_TOL
       stdin.read(.ig_tol_scheme(i_step))
       if(.ig_tol_scheme(i_step)<=ZERO) .ig_tol_scheme(i_step)=INTERNAL_GEMINAL_TOL
       stdin.read(.tolerance_scheme(i_step))
       if(.tolerance_scheme(i_step)<=ZERO) .tolerance_scheme(i_step)=12
       stdin.read(.do_triplet_energies(i_step))
       stdin.read(.truncation_scheme(i_step))
     end
   end

!  ************
!  I/O Routines
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
       case ("do_gmf_auto             "); .do_gmf_auto
       case ("restart_gmf_auto        "); .restart_gmf_auto
     ! case ("do_gmf                  "); .do_gmf
     ! case ("restart_gmf             "); .restart_gmf
     ! case ("do_spectrum             "); .do_spectrum
     ! case ("do_restart              "); .do_restart
       case ("junk=                   "); .read_junk
       case ("orthogonality_type=     "); .read_orthogonality_type
       case ("put                     "); .put
       case ("units=                  "); .read_units
       case ("use_brillouin=          "); .read_use_brillouin
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_orthogonality_type
   ! Read  ?
      stdin.read(.orthogonality_type)
      .orthogonality_type.to_lower_case
      select case (.orthogonality_type)
         case ("no_orthogonality    ")
         case ("one_orthogonality   ")
            DIE("one_orthogonality not yet implemented")
         case ("sp_two_orthogonality")
         case ("sf_two_orthogonality")
         case default
            DIE("unknown orthogonality option: "//trim(.orthogonality_type))
      end 
   end

   read_use_brillouin
   ! Read  ?
      stdin.read(.use_brillouin)
   end

   read_units ::: get_from(OBJECT)
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT)
   ! Read in a junk string, useful for ignoring a field
   end

   get_old_tolerance(old_tolerance)
   ! get old cutoff thresholds from an archive file
     old_tolerance :: VEC{INT}
     old_tolerance_archive :: ARCHIVE
     name :: STR
     
     name="old_tolerance"
     old_tolerance_archive.set(.spectrum.name,name)
     old_tolerance_archive.read(old_tolerance)
     stdout.put(old_tolerance)
   end

   get_gs_energies(gs_energies)
   ! get ground state energies from an archive file
     gs_energies :: VEC{REAL}
     gs_energies_archive :: ARCHIVE
     name :: STR
     
     name="gs_energies"
     gs_energies_archive.set(.spectrum.name,name)
     gs_energies_archive.read(gs_energies)
   end

!  ********************
!  Key related routines
!  ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")
     word :: STR
     width,k :: INT
     width = .table_width
     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case default; DIE("unknown option")
         end
         if (k==size(keys)) then
           stdout.flush ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
     res :: INT
   ENSURE(keys.created,"no keys")
     int_dash,real_dash,k :: INT
     word :: STR
     int_dash = 0
     real_dash = 0
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}                "); ! exit surrounding loop
         case ("put_configuration"); real_dash = real_dash + 1
         case ("put_label        "); int_dash = int_dash + 1
         case ("put_n_shells     "); int_dash = int_dash + 1
         case ("put_n_bf         "); int_dash = int_dash + 1
         case ("put_n_prim       "); int_dash = int_dash + 1
         case ("flush            "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  ***************
!  Inquiry methods
!  ***************

   same_as(b) result(res) 
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      self :: IN
      b :: GEMINAL_MF_SCHEME, IN
      res :: BIN
      res = FALSE
   end

!  **************
!  Output methods
!  **************

   put
   ! Print out the object
      n_step :: INT
      i_step :: INT

      stdout.text("GEMINAL_MF_SCHEME:")
      stdout.text(" ")
      stdout.show("molecule      =",.spectrum.name)
      stdout.show("n_geminals    =",.spectrum.n_geminals)
      stdout.show("n_bf          =",.spectrum.n_bf)
      stdout.show("nuclear_energy=",.spectrum.nuclear_energy)
      stdout.show("use_brillouin =",.use_brillouin)
      stdout.show("orthogonality_type =",.orthogonality_type)
      stdout.show("print_hamiltonian =",.print_hamiltonian)
      stdout.show("convergence   =",.convergence_threshold,precision=12)
      stdout.text(" ")

      n_step=size(.truncation_scheme)

!steps from 1 to nsteps - 1
      if(.print_hamiltonian) then
        stdout.show("step :",0)
        stdout.text(" ")
        stdout.show("Cutoff tolerance =",TOL(.tolerance_scheme(0)),precision=12)
        stdout.show("do_triplet_energies=",.do_triplet_energies(0))
        stdout.show("truncation =",.truncation_scheme(0),precision=12)
        stdout.text(" ")
        do i_step=1,n_step-1
          stdout.show("step :",i_step)
          stdout.text(" ")
          stdout.show("Linear dependence tolerance =",.ld_tol_scheme(i_step),precision=12)
          stdout.show("Internal geminal tolerance =",.ig_tol_scheme(i_step),precision=12)
          stdout.show("Cutoff tolerance =",TOL(.tolerance_scheme(i_step)),precision=12)
          stdout.show("do_triplet_energies=",.do_triplet_energies(i_step))
          stdout.show("truncation =",.truncation_scheme(i_step),precision=12)
          stdout.text(" ")
        end
      end
   end

   put_gs_energies(gs_energies)
   ! put ground state energies to an archive file
     gs_energies :: VEC{REAL}
     gs_energies_archive :: ARCHIVE
     name :: STR
     
     name="gs_energies"
     gs_energies_archive.set(.spectrum.name,name)
     gs_energies_archive.write(gs_energies)
   end

   put_old_tolerance(old_tolerance)
   ! put old cutoff thresholds to an archive file
     old_tolerance :: VEC{INT}
     old_tolerance_archive :: ARCHIVE
     name :: STR
     
     name="old_tolerance"
     old_tolerance_archive.set(.spectrum.name,name)
     old_tolerance_archive.write(old_tolerance)
   end

!  ***************
!  EMFCI methods
!  ***************

   do_gmf_auto ::: leaky !because of the set_defaults
   ! implement the contraction-truncation scheme
   ! designed for a singlet ground state
   ! take advantage of the possible truncation of the geminal basis
     ham :: MAT{REAL}*
     gs_energies :: VEC{REAL}*
     old_tolerance :: VEC{INT}*
     group_order :: VEC{INT}*
     lowest_energy :: REAL
   !  highest_energy :: REAL
     old_energy :: REAL
     i,j,i_step,i_geminals :: INT
     n_nonzero,max_bas :: INT
     n_step,n_geminals,n_bf :: INT
     i_loop,loop_count :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     set :: BIN
     save_step :: BIN
     n_geminals=.spectrum.n_geminals
     n_bf=.spectrum.n_bf
     max_bas=.spectrum.n_bas
     n_step=size(.truncation_scheme)-1
     gs_energies.create(n_geminals)
     old_tolerance.create(n_geminals)
! step 0
     timer.start_timing
     stdout.text(" ")
     stdout.show("step number: ",0)
     stdout.text(" ")
     old_tolerance=.tolerance_scheme(0)
     .put_old_tolerance(old_tolerance)
     .spectrum.tol=TOL(.tolerance_scheme(0))
!tmp_rassolov
    !tmp_rassolov   !.spectrum.set_singlet_handmade
     ! ! .spectrum.set_rassolov_defaults
!tmp_rassolov
     .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0))
     gs_energies(1)=.spectrum.contraction_energies(1)
     do i=2,n_geminals
       .spectrum.set_defaults(i_geminals=i)
       .spectrum.set_singlet_defaults
  !tmp_rassolov   !  .spectrum.set_singlet_handmade
      ! .spectrum.set_singlet_random
      ! .spectrum.set_singlet_agp
       .spectrum.do_step_0(.use_brillouin,.print_hamiltonian,.truncation_scheme(0))
       gs_energies(i)=.spectrum.contraction_energies(1)
     end
     timer.stop_timing
     stdout.show("time taken for step 0 in s:",timer.elapsed_time)
     stdout.text(" ")
     .put_gs_energies(gs_energies)  
     group_order.create(n_geminals)
     gs_energies.quick_sort(group_order)
!out     stdout.text("group_order:")
!out     stdout.put(group_order)
!out     stop
     i_loop=1 !index for group_order
     i_geminals=group_order(i_loop)
     loop_count=2 !nb of step after step 0 or after a change of tolerance 
     i_loop=2
! step 1 to n_steps -1
     do i_step=1,n_step
       timer.start_timing
       stdout.text(" ")
       stdout.show("step number: ",i_step)
       stdout.text(" ")
       .spectrum.ld_tol=.ld_tol_scheme(i_step)
       stdout.show("Linear dependence tolerance",.ld_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.ig_tol=.ig_tol_scheme(i_step)
       stdout.show("Internal geminal tolerance",.ig_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.tol=TOL(.tolerance_scheme(i_step))
       stdout.show("Cutoff tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
       stdout.text(" ")
       do i=1,n_geminals
         .spectrum.set_defaults(i_geminals=i)
         .spectrum.get_ground_state
       end
       .spectrum.set_to_zero_special_ket 
       set=FALSE
       DIE_IF(maxval(old_tolerance)>.tolerance_scheme(i_step),"Cutoff tolerance has decreased")
       do i=0,n_geminals-1
         if(i_loop+i > n_geminals) then
           j=group_order(mod(i_loop+i,n_geminals))
         else
           j=group_order(i_loop+i)
         end  
         if(old_tolerance(j)<.tolerance_scheme(i_step))then
           stdout.text(" ")
           stdout.show("tolerance has increased for group",j) 
           stdout.text(" ")
           .spectrum.set_defaults(i_geminals=j)
           i_geminals=j
           set=TRUE
           if(i_loop+i > n_geminals) then
             i_loop=mod(i_loop+i,n_geminals)
           else
             i_loop=i_loop+i
           end  
           exit
         end
       end
       if(NOT set) then
         j=group_order(i_loop)
         .spectrum.set_defaults(i_geminals=j)
         i_geminals=j
       end
       old_energy=gs_energies(i_geminals)
  !     highest_energy=maxval(gs_energies)
       lowest_energy=minval(gs_energies)
       .spectrum.gs_permutation
       .remove_singlet_dependencies
       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
       .spectrum.set_to_zero_special_ket !maybe not needed but safer
       ham.create(n_nonzero,n_nonzero)
       ham = .spectrum.hamiltonian !.spectrum.n_bas may be smaller than
                                  ! .spectrum.contraction_energies.dim but
                                  ! should work
       eigenvec.create(n_nonzero,n_nonzero)
       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec) 
       ham.destroy
       if(.print_hamiltonian) then
         stdout.text(" ")
         stdout.text("singlet eigenvectors") 
         stdout.text(" ")
         stdout.put(eigenvec) 
         stdout.text(" ")
       end
       .spectrum.contraction_energies(1:n_nonzero)= &
          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
       .spectrum.get_max_bas !now .spectrum.n_bas is the size of the truncated
                             ! set of possibly quasilinearly dependent basis
                             ! functions
       do j=n_nonzero+1,.spectrum.n_bas
         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
       end
       stdout.text(" ")
       stdout.show("i_geminals    =",i_geminals)
       stdout.text(" ")
       stdout.show("first eigenvalue is ",.spectrum.contraction_energies(1),precision=12)
       stdout.text(" ")
       stdout.text(" ")
       stdout.text("singlet eigenvalues") 
       stdout.text(" ")
       stdout.put(.spectrum.contraction_energies) 
       stdout.text(" ")
!begin testing convergence
       if(set)then
         stdout.text(" ")
         stdout.text("the tolerance having changed, the job continue ...") 
         stdout.text(" ")
         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
         .put_old_tolerance(old_tolerance)
         loop_count=1
         save_step=TRUE
       else  
         if(.spectrum.contraction_energies(1)+.convergence_threshold<lowest_energy) then
           stdout.text(" ")
           stdout.text("Energy difference not within tolerance, the job continue ...") 
           stdout.text(" ")
           loop_count=1
           save_step=TRUE
         else
           if(.spectrum.contraction_energies(1)<old_energy) then
             stdout.show("The energy has improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=TRUE
           else
             stdout.show("The energy has not improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=FALSE
           end
           if(loop_count==n_geminals) then
             stdout.text(" ")
             stdout.text("all electron groups have been considered")
             stdout.text(" ")
             stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
             stdout.text(" ")
             if(.convergence_threshold<.spectrum.tol) then
               stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
               stdout.text(" ")
             end
             stdout.text(std_time.elapsed_time_message(" "))
             stdout.text(std_time.elapsed_cpu_time_message(" "))
             stop
           else
             timer.stop_timing
             stdout.show("time taken for this step in s:",timer.elapsed_time)
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("Energy difference within tolerance, however ...") 
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("not all electron groups have been considered, the job continue ...") 
             stdout.text(" ")
             loop_count=loop_count+1
             save_step=FALSE
           end
         end
       end
!end testing convergence
       if(save_step)then
         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
         .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
         .spectrum.put_ground_state_geminals
         eigenvec.destroy 
         if(.truncation_scheme(i_step)/=ZERO) then
           stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
           stdout.text(" ")
           .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
             .spectrum.contraction_energies < .truncation_scheme(i_step))
         end
         stdout.show("number of states saved at this step",.spectrum.n_bas)
         stdout.text(" ")
         timer.stop_timing
         stdout.show("time taken for this step in s:",timer.elapsed_time)
         stdout.text(" ")
         .spectrum.put_wfs
         .spectrum.put_ground_state
         .put_gs_energies(gs_energies)
         if(.do_triplet_energies(i_step)) then
           .do_triplet_spectrum
         end
       end
       if(i_loop == n_geminals) then
         i_loop=1
       else
         i_loop=i_loop+1
       end  
     end
     gs_energies.destroy
     old_tolerance.destroy
     group_order.destroy
   end

   restart_gmf_auto
   ! restart the contraction-truncation scheme
   ! designed for a singlet ground state
   ! does take advantage of the possible truncation of the geminal basis
     ham :: MAT{REAL}*
     gs_energies :: VEC{REAL}*
     old_tolerance :: VEC{INT}*
     group_order :: VEC{INT}*
     lowest_energy :: REAL
     old_energy :: REAL
     i,j,i_step,i_geminals :: INT
     n_nonzero,max_bas :: INT
     n_step,n_geminals,n_bf :: INT
     i_loop,loop_count :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     set :: BIN
     save_step :: BIN
     n_geminals=.spectrum.n_geminals
     n_bf=.spectrum.n_bf
     max_bas=.spectrum.n_bas
     n_step=size(.truncation_scheme)-1
     gs_energies.create(n_geminals)
     .get_gs_energies(gs_energies)
     group_order.create(n_geminals)
     gs_energies.quick_sort(group_order,decreasing_order=TRUE)
!out     stdout.text("group_order:")
!out     stdout.put(group_order)
!out     stop
     loop_count=1 !nb of step after step 0 or after a change of tolerance 
     i_loop=1 !index for group_order
     old_tolerance.create(n_geminals)
     .get_old_tolerance(old_tolerance)
     stdout.text(" ")
     stdout.text("WARNING, this is a restart job")
     stdout.text(" the step numbering and the group order have been re-initialised ")
     stdout.text(" the energy improvement message may be wrong for the first steps")
     stdout.text(" if less than n_geminals steps were performed in the original run ")
     stdout.text(" ")
! step 1 to n_steps -1
     do i_step=1,n_step
       timer.start_timing
       stdout.text(" ")
       stdout.show("step number: ",i_step)
       stdout.text(" ")
       .spectrum.ld_tol=.ld_tol_scheme(i_step)
       stdout.show("Linear dependence tolerance",.ld_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.ig_tol=.ig_tol_scheme(i_step)
       stdout.show("Internal geminal tolerance",.ig_tol_scheme(i_step),precision=12)
       stdout.text(" ")
       .spectrum.tol=TOL(.tolerance_scheme(i_step))
       stdout.show("tolerance: (n in 10^-n) ",.tolerance_scheme(i_step))
       stdout.text(" ")
       do i=1,n_geminals
         .spectrum.set_defaults(i_geminals=i)
         .spectrum.get_ground_state
       end
       .spectrum.set_to_zero_special_ket !really needed here
       set=FALSE
       DIE_IF(maxval(old_tolerance)>.tolerance_scheme(i_step),"Cutoff tolerance has decreased")
       do i=0,n_geminals-1
         if(i_loop+i > n_geminals) then
           j=group_order(mod(i_loop+i,n_geminals))
         else
           j=group_order(i_loop+i)
         end  
         if(old_tolerance(j)<.tolerance_scheme(i_step))then
           stdout.text(" ")
           stdout.show("tolerance has increased for group",j) 
           stdout.text(" ")
           .spectrum.set_defaults(i_geminals=j)
           i_geminals=j
           set=TRUE
           if(i_loop+i > n_geminals) then
             i_loop=mod(i_loop+i,n_geminals)
           else
             i_loop=i_loop+i
           end  
           exit
         end
       end
       if(NOT set) then
         j=group_order(i_loop)
         .spectrum.set_defaults(i_geminals=j)
         i_geminals=j
       end
       old_energy=gs_energies(i_geminals)
       lowest_energy=minval(gs_energies)
       .spectrum.gs_permutation
       if(.do_triplet_energies(i_step)) then
         .do_triplet_spectrum
       end
       .remove_singlet_dependencies
       n_nonzero=.spectrum.n_bas !number of quasilinearly independent basis functions
       .spectrum.set_to_zero_special_ket !really needed here
       ham.create(n_nonzero,n_nonzero)
       ham = .spectrum.hamiltonian !.spectrum.n_bas may be smaller than
                                  ! .spectrum.contraction_energies.dim but
                                  ! ! should work
       eigenvec.create(n_nonzero,n_nonzero)
       ham.solve_eigenproblem(.spectrum.contraction_energies(1:n_nonzero),eigenvec)
       ham.destroy
       if(.print_hamiltonian) then
         stdout.text(" ")
         stdout.text("singlet eigenvectors")
         stdout.text(" ")
         stdout.put(eigenvec)
         stdout.text(" ")
       end
       .spectrum.contraction_energies(1:n_nonzero)= &
          .spectrum.contraction_energies(1:n_nonzero)+.spectrum.nuclear_energy
       .spectrum.get_max_bas !now .spectrum.n_bas is the size of the truncated
                             ! set of possibly quasilinearly dependent basis
                             ! functions

       do j=n_nonzero+1,.spectrum.n_bas
         .spectrum.contraction_energies(j)=.spectrum.nuclear_energy
       end
       stdout.text(" ")
       stdout.show("i_geminals    =",.spectrum.i_geminals)
       stdout.text(" ")
       stdout.show("first eigenvalue is:",.spectrum.contraction_energies(1),precision=12)
       stdout.text(" ")
       stdout.text(" ")
       stdout.text("singlet eigenvalues") 
       stdout.text(" ")
       stdout.put(.spectrum.contraction_energies) 
       stdout.text(" ")
!begin testing convergence
       if(set)then
         stdout.text(" ")
         stdout.text("the tolerance having changed, the job continue ...") 
         stdout.text(" ")
         old_tolerance(i_geminals)=.tolerance_scheme(i_step)
         .put_old_tolerance(old_tolerance)
         loop_count=1
         save_step=TRUE
       else  
         if(.spectrum.contraction_energies(1)+.convergence_threshold<lowest_energy) then
           stdout.text(" ")
           stdout.text("Energy difference not within tolerance, the job continue ...") 
           stdout.text(" ")
           loop_count=1
           save_step=TRUE
         else
           if(.spectrum.contraction_energies(1)<old_energy) then
             stdout.show("The energy has improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=TRUE
           else
             stdout.show("The energy has not improved for contraction",i_geminals)
             stdout.text(" ")
          !   save_step=FALSE
           end
           if(loop_count==n_geminals) then
             stdout.text(" ")
             stdout.text("all electron groups have been considered")
             stdout.text(" ")
             stdout.show("Energy seems converged to within",.convergence_threshold,precision=12)
             stdout.text(" ")
             if(.convergence_threshold<.spectrum.tol) then
               stdout.show("WARNING, tolerance was only",.spectrum.tol,precision=12)
               stdout.text(" ")
             end
             stdout.text(std_time.elapsed_time_message(" "))
             stdout.text(std_time.elapsed_cpu_time_message(" "))
             stop
           else
             timer.stop_timing
             stdout.show("time taken for this step in s:",timer.elapsed_time)
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("Energy difference within tolerance, however ...") 
             stdout.text(" ")
             stdout.text(" ")
             stdout.text("not all electron groups have been considered, the job continue ...") 
             stdout.text(" ")
             loop_count=loop_count+1
             save_step=FALSE
           end
         end
       end
!end testing convergence
       if(save_step)then
      !   .save_gmf_step(i_step,i_geminals)
         gs_energies(i_geminals)=.spectrum.contraction_energies(1)
         .spectrum.contraction_wfs(1:n_nonzero).change_basis_using(eigenvec,TRUE)
         .spectrum.put_ground_state_geminals
         eigenvec.destroy 
         if(.truncation_scheme(i_step)/=ZERO) then
           stdout.show("truncation threshold for this step",.truncation_scheme(i_step))
           stdout.text(" ")
           .spectrum.n_bas=maxloc(.spectrum.contraction_energies,1,mask= &
             .spectrum.contraction_energies < .truncation_scheme(i_step))
         end
         stdout.show("number of states saved at this step",.spectrum.n_bas)
         stdout.text(" ")
         timer.stop_timing
         stdout.show("time taken for this step in s:",timer.elapsed_time)
         stdout.text(" ")
         .spectrum.put_wfs
         .spectrum.put_ground_state
         .put_gs_energies(gs_energies)
       end
       if(i_loop == n_geminals) then
         i_loop=1
       else
         i_loop=i_loop+1
       end  
     end
     gs_energies.destroy
     old_tolerance.destroy
     group_order.destroy
   end

   do_triplet_spectrum ::: leaky !because of the set_defaults
   ! do the triplet spectrum after a geminal mean field singlet step
     ham :: MAT{REAL}*
     i_geminals :: INT
     n_geminals,max_bas :: INT
     eigenvec :: MAT{REAL}*
     timer :: TIME
     timer.start_timing
     n_geminals=.spectrum.n_geminals
     i_geminals=.spectrum.i_geminals
     stdout.text(" ")
     stdout.text("Triplet spectrum for this step")
     stdout.text(" ")
!     .spectrum.set_active_triplet_defaults !now .spectrum.n_bas is again max_bas
     .remove_triplet_dependencies
     max_bas=.spectrum.n_bas
     ham.create(max_bas,max_bas)
     ham = .spectrum.hamiltonian
     if(.print_hamiltonian) then
       stdout.text("The triplet hamiltonian matrix is ")
       stdout.text(" ")
       stdout.put(ham)
       stdout.text(" ")
     end
     eigenvec.create(max_bas,max_bas)
     ham.solve_eigenproblem(.spectrum.contraction_energies,eigenvec) 
     ham.destroy
     if(.print_hamiltonian) then
       stdout.text("triplet eigenvectors") 
       stdout.text(" ")
       stdout.put(eigenvec) 
       stdout.text(" ")
     end
     .spectrum.contraction_energies= .spectrum.contraction_energies+.spectrum.nuclear_energy
     stdout.show("i_geminals    =",i_geminals)
     stdout.text(" ")
     stdout.text(" ")
     stdout.text("triplet eigenvalues") 
     stdout.text(" ")
     stdout.put(.spectrum.contraction_energies) 
     stdout.text(" ")
     timer.stop_timing
     stdout.show("time taken for triplet spectrum in s:",timer.elapsed_time)
     stdout.text(" ")
   end

   remove_singlet_dependencies ::: leaky
   ! remove linear dependencies in the contraction basis set
     .spectrum.remove_dependencies(.orthogonality_type,.print_hamiltonian)
   end

   remove_triplet_dependencies ::: leaky
   ! remove linear dependencies in the contraction basis set
     .spectrum.remove_triplet_dependencies(.print_hamiltonian)
   end

end
