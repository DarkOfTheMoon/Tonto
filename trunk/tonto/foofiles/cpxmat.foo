! $Id$
!---------------------------------------------------------------------------
!
!  CMAT :: complex matrix operations ...
!
!  (c) dylan jayatilaka, 1996
!
!---------------------------------------------------------------------------
module CMAT

   use TYPES
   use ERROR
   use MM
   use VEC
   use IVEC
   use CVEC

   implicit none         

#include "macros"
#include "cmat.int"

   DBL, private :: tol5 = 1.0d-5
!   DBL, private :: tol10 = 1.0d-10
   
contains

   create(dim1,dim2)
   ! Create a complex matrix with the given dimensions
      PTR :: self
      INT :: dim1,dim2
      nullify(self)
      allocate(self(dim1,dim2))
      std_mm.add(dim1*dim2*CDBL_SIZE)
   end

   create(lb1,ub1,lb2,ub2)
   ! Create a complex matrix with the given dimensions
      PTR :: self
      INT :: lb1,ub1,lb2,ub2
      nullify(self)
      allocate(self(lb1:ub1,lb2:ub2))
      std_mm.add((ub1-lb1+1)*(ub2-lb2+1)*CDBL_SIZE)
   end

   destroy
   ! Destroy a complex matrix 
      PTR :: self
      if (.destroyed) return
      std_mm.delete(size(self)*CDBL_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   to_product(mat_a,mat_b,dagger_a,dagger_b)
   ! Set "self" to the matrix product of "mat_a" and "mat_b". If present,
   ! "dagger_a" and "dagger_b" can be set to TRUE if "mat_a" and "mat_b"
   ! needs to be daggerred.
      CMAT :: mat_a, mat_b
      BIN, optional :: dagger_a, dagger_b
      INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,dim2,i,j,k
      BIN :: dagg_a,dagg_b

      dagg_a = FALSE;       dagg_b = FALSE
      if (present(dagger_a)) dagg_a = dagger_a
      if (present(dagger_b)) dagg_b = dagger_b

      dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
      dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
      dim1   = size(self,1);            dim2 = size(self,2)

      if (dagg_a) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        if (dagg_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              self(i,j) = conjg(mat_a(1,i)) * conjg(mat_b(j,1))
              do k=2,dim_a1
                self(i,j) = self(i,j) + conjg(mat_a(k,i)) * conjg(mat_b(j,k))
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              self(i,j) = conjg(mat_a(1,i)) * mat_b(1,j)
              do k=2,dim_a1
                self(i,j) = self(i,j) + conjg(mat_a(k,i)) * mat_b(k,j)
              end
            end
          end
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        if (dagg_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              self(i,j) = mat_a(i,1) * conjg(mat_b(j,1))
              do k=2,dim_a2
                self(i,j) = self(i,j) + mat_a(i,k) * conjg(mat_b(j,k))
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              self(i,j) = mat_a(i,1) * mat_b(1,j)
              do k=2,dim_a2
                self(i,j) = self(i,j) + mat_a(i,k) * mat_b(k,j)
              end
            end
          end
        end
      end
   end

   to_scaled_product(fac,mat_a,mat_b,dagger_a,dagger_b)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "dagger_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! need to be daggerred.
      CMAT :: mat_a, mat_b
      DBL :: fac
      BIN, optional :: dagger_a, dagger_b
      INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,dim2,i,j,k
      BIN :: dagg_a,dagg_b

      dagg_a = FALSE;       dagg_b = FALSE
      if (present(dagger_a)) dagg_a = dagger_a
      if (present(dagger_b)) dagg_b = dagger_b

      dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
      dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
      dim1   = size(self,1);            dim2 = size(self,2)

      if (dagg_a) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        if (dagg_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              self(i,j) = fac * conjg(mat_a(1,i)) * conjg(mat_b(j,1))
              do k=2,dim_a1
                self(i,j) = self(i,j) + fac * conjg(mat_a(k,i)) * conjg(mat_b(j,k))
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              self(i,j) = fac * conjg(mat_a(1,i)) * mat_b(1,j)
              do k=2,dim_a1
                self(i,j) = self(i,j) + fac * conjg(mat_a(k,i)) * mat_b(k,j)
              end
            end
          end
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        if (dagg_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              self(i,j) = fac * mat_a(i,1) * conjg(mat_b(j,1))
              do k=2,dim_a2
                self(i,j) = self(i,j) + fac * mat_a(i,k) * conjg(mat_b(j,k))
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              self(i,j) = fac * mat_a(i,1) * mat_b(1,j)
              do k=2,dim_a2
                self(i,j) = self(i,j) + fac * mat_a(i,k) * mat_b(k,j)
              end
            end
          end
        end
      end
   end

   plus_product(mat_a,mat_b,dagger_a,dagger_b)
   ! Add to "self" the matrix product of "a" and "b". If present, "dagger_a"
   ! and "dagger_b" can be set to TRUE if "a" and "b" neeb to be daggerd.
      CMAT :: mat_a, mat_b
      BIN, optional :: dagger_a, dagger_b
      INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,dim2,i,j,k
      BIN :: dagg_a,dagg_b

      dagg_a = FALSE;       dagg_b = FALSE
      if (present(dagger_a)) dagg_a = dagger_a
      if (present(dagger_b)) dagg_b = dagger_b

      dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
      dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
      dim1   = size(self,1);            dim2 = size(self,2)

      if (dagg_a) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        if (dagg_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + conjg(mat_a(k,i)) * conjg(mat_b(j,k))
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + conjg(mat_a(k,i)) * mat_b(k,j)
              end
            end
          end
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        if (dagg_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + mat_a(i,k) * conjg(mat_b(j,k))
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + mat_a(i,k) * mat_b(k,j)
              end
            end
          end
        end
      end
   end

   plus_scaled_product(fac,mat_a,mat_b,dagger_a,dagger_b)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "dagger_a" and "dagger_b" can be set to TRUE if "a" and "b" need
   ! to be daggerd.
      CMAT :: mat_a, mat_b
      DBL :: fac
      BIN, optional :: dagger_a, dagger_b
      INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,dim2,i,j,k
      BIN :: dagg_a,dagg_b

      dagg_a = FALSE;       dagg_b = FALSE
      if (present(dagger_a)) dagg_a = dagger_a
      if (present(dagger_b)) dagg_b = dagger_b

      dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
      dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
      dim1   = size(self,1);            dim2 = size(self,2)

      if (dagg_a) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        if (dagg_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + fac * conjg(mat_a(k,i)) * conjg(mat_b(j,k))
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + fac * conjg(mat_a(k,i)) * mat_b(k,j)
              end
            end
          end
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        if (dagg_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + fac * mat_a(i,k) * conjg(mat_b(j,k))
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + fac * mat_a(i,k) * mat_b(k,j)
              end
            end
          end
        end
      end
   end

   plus_product(a,b,transpose_a,dagger_b)
   ! Add to self the product of "a" and "b"
      MAT :: a
      CMAT :: b
      BIN, optional :: transpose_a, dagger_b
      BIN :: ta,tb
      ta = FALSE; tb = FALSE
      if (present(transpose_a)) ta = transpose_a
      if (present(dagger_b)) tb = dagger_b
      if (ta AND tb) then
         self = self + matmul(transpose(a),conjg(transpose(b)))
      else if (ta) then
         self = self + matmul(transpose(a),b)
      else if (tb) then
         self = self + matmul(a,conjg(transpose(b)))
      else
         self = self + matmul(a,b)
      end
   end
      
   plus_product(a,b,dagger_a,transpose_b)
   ! Add to self the product of "a" and "b"
      CMAT :: a
      MAT :: b
      BIN, optional :: dagger_a, transpose_b
      BIN :: ta,tb
      ta = FALSE; tb = FALSE
      if (present(dagger_a)) ta = dagger_a
      if (present(transpose_b)) tb = transpose_b
      if (ta AND tb) then
         self = self + matmul(conjg(transpose(a)),transpose(b))
      else if (ta) then
         self = self + matmul(conjg(transpose(a)),b)
      else if (tb) then
         self = self + matmul(a,transpose(b))
      else
         self = self + matmul(a,b)
      end
   end

   to_product_with_diagonal(a,diag,dagger_a)
   ! set self to the product of "a" and with diagonal "diag"
      CMAT :: a
      VEC :: diag
      BIN, optional :: dagger_a
      INT :: a1,a2,s1,s2,d1,i,j
      s1 = size(self,1); s2 = size(self,2)
      a1 = size(a,1);    a2 = size(a,2)
      d1 = size(diag)
      DIE_IF(s1/=a1 OR s2/=a2,"incompatible dimensions")
      if (present(dagger_a)) then
         DIE_IF(a1/=d1,"incompatible dimensions")
         do i = 1,s1
         do j = 1,s2
            self(i,j) = conjg(a(j,i))*diag(j)
         end
         end
      else
         DIE_IF(a2/=d1,"incompatible dimensions")
         do i = 1,s1
         do j = 1,s2
            self(i,j) = a(i,j)*diag(j)
         end
         end
      end
   end

   to_product_with_diagonal(dg,a,dagger_a)
   ! set self to the product of diagonal "dg" with "a"
      CMAT :: a
      VEC :: dg
      BIN, optional :: dagger_a
      INT :: a1,a2,s1,s2,d1,i,j
      s1 = size(self,1); s2 = size(self,2)
      a1 = size(a,1);    a2 = size(a,2)
      d1 = size(dg)
      DIE_IF(s1/=a1 OR s2/=a2,"incompatible dimensions")
      if (present(dagger_a)) then
         DIE_IF(a2/=d1,"incompatible dimensions")
         do i = 1,s1
         do j = 1,s2
            self(i,j) = dg(i)*conjg(a(j,i))
         end
         end
      else
         DIE_IF(a1/=d1,"incompatible dimensions")
         do i = 1,s1
         do j = 1,s2
            self(i,j) = dg(i)*a(i,j)
         end
         end
      end
   end

   trace result (res)
   ! Return the trace of "self"
      CDBL :: res
      INT :: dim,dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      dim = dim1
      res = ZERO
      do i = 1,dim
         res = res + self(i,i)
      end
   end
      
   solve_eigenproblem(eigenvalues,eigenvectors)
   ! Solve the hermitian eigenvalue problem for self
      VEC :: eigenvalues
      CMAT :: eigenvectors
      CVEC, PTR :: W
      VEC, PTR :: RW
      INT :: dim,dim1,dim2,fail
      dim1 = size(self,1)
      dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      dim = dim1
      dim2 = size(eigenvalues)
      DIE_IF(dim2<dim,"supplied eigenvalue array too small")
      dim2 = size(eigenvectors)
      DIE_IF(dim2<dim*dim,"supplied eigenvector matrix too small")
      W.create(dim*dim)
      RW.create(3*dim)
      eigenvectors.set_to(self)
      fail = 0
      call zheev("V","L",dim,eigenvectors,dim,eigenvalues,W,dim*dim,RW,fail)
      RW.destroy
      W.destroy
   end
      
   solve_linear_equations(rhs,solution)
   ! Solve the linear equations self*x = rhs, and put the answer x in "solution"
      CVEC :: rhs, solution
      CMAT, PTR :: LU
      IVEC, PTR :: pivot
      INT :: dim,dim1,dim2,dimr,dims
      INT :: err,nrhs
      dim1 = size(self,1)
      dim2 = size(self,2)
      dimr = size(rhs,1)
      dims = size(solution,1)
      nrhs = 1
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dimr==dim1,"rhs incompatible with coefficient matrix")
      ENSURE(dims==dim1,"solution incompatible with coefficient matrix")
      dim = dim1
      LU.create(dim,dim)
      LU.set_to(self)
      pivot.create(dim)
      call dgesv(dim,nrhs,LU,dim,pivot,solution,dim,err)
      DIE_IF(err>0,"no solution, singular matrix")
      DIE_IF(err<0,"illegal input")
      LU.destroy
      pivot.destroy
   end
      
   solve_linear_equations(rhs,solution)
   ! Solve the linear equations self*x = rhs, and put the answer x in "solution"
      CMAT :: rhs, solution
      CMAT, PTR :: LU
      IVEC, PTR :: pivot
      INT :: dim,dim1,dim2,dimr1,dimr2,dims1,dims2
      INT :: err,nrhs
      dim1  = size(self,1)
      dim2  = size(self,2)
      dimr1 = size(rhs,1)
      dimr2 = size(rhs,2)
      dims1 = size(solution,1)
      dims2 = size(solution,2)
      nrhs  = dimr2
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dimr1==dim1,"rhs incompatible with coefficient matrix")
      ENSURE(dims1==dim1,"solution incompatible with coefficient matrix")
      ENSURE(dimr2==dims2,"solution and rhs are incompatible")
      ENSURE(nrhs>0,"no rhs vectors")
      dim = dim1
      LU.create(dim,dim)
      LU.set_to(self)
      pivot.create(dim)
      call dgesv(dim,nrhs,LU,dim,pivot,solution,dim,err)
      DIE_IF(err>0,"no solution, singular matrix")
      DIE_IF(err<0,"illegal input")
      LU.destroy
      pivot.destroy
   end
      
   trace_of_product(b) result (res)
   ! Return the trace of the product of self with "b"
      CMAT :: b 
      CDBL :: res
      INT :: a1,a2,b1,b2,i,j
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      DIE_IF(a2/=b1 AND a1/=b2,"incompatible dimensions")
      res = ZERO 
      do i = 1,a1
      do j = 1,a2
         res = res + self(i,j)*b(j,i)
      end
      end
   end

   trace_of_product(b) result (res)
   ! Return the trace of the product of self with "b"
      MAT :: b 
      CDBL :: res
      INT :: a1,a2,b1,b2,i,j
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      DIE_IF(a2/=b1 AND a1/=b2,"incompatible dimensions")
      res = ZERO 
      do i = 1,a1
      do j = 1,a2
         res = res + self(i,j)*b(j,i)
      end
      end
   end

   equals(b) result(res)
   ! Check if the matrix is the same as "b".
      IN :: self
      CMAT, IN :: b
      BIN :: res
      res = .same_as(b)
   end

   same_as(b, tol,diff) result(res)
   ! Return TRUE if self is the same as "b:", within tolerance "tol", if provided,
   ! or 10^-5 if not.
      CMAT :: b 
      DBL, optional :: tol,diff
      BIN :: res
      INT :: a1,a2,b1,b2,i,j
      DBL :: tolerance
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      DIE_IF(a2/=b1 AND a1/=b2,"incompatible dimensions")
      if (present(tol))     tolerance = tol
      if (NOT present(tol)) tolerance = tol5
      diff = ZERO 
      do i = 1,a1
      do j = 1,a2
         diff = diff + abs(self(j,i)-b(j,i))**2
      end
      end
      diff = sqrt(diff)
      res = FALSE
      if (diff<tolerance) res=TRUE
   end

   swap_columns(col1,col2)
   ! Swap columns "col1" and "col2" of self
      INT :: col1,col2
      INT :: a1,a2,i
      CDBL :: val
      a1 = size(self,1)
      a2 = size(self,2)
      DIE_IF(col1>a2 OR col2>a2,"columns exceed dimesions")
      do i = 1,a1
         val = self(i,col1)
         self(i,col1) = self(i,col2)
         self(i,col2) = val
      end
   end

   set_to(b)
   ! Set self to "b"
      CMAT :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      DIE_IF(b1/=a1,"error in limits")
      DIE_IF(b2/=a2,"error in limits")
      self = b
   end

   plus(b)
   ! Add to self the matrix "b"
      CMAT :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      DIE_IF(b1/=a1,"error in limits")
      DIE_IF(b2/=a2,"error in limits")
      self = self+b
   end

   minus(b)
   ! Subtract from self the matrix "b"
      CMAT :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      DIE_IF(b1/=a1,"error in limits")
      DIE_IF(b2/=a2,"error in limits")
      self = self-b
   end

   to_scaled_mat(fac,b)
   ! Set self to the scaled matrix "b"
      CMAT :: b
      CDBL :: fac
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      DIE_IF(b1/=a1,"error in limits")
      DIE_IF(b2/=a2,"error in limits")
      self = fac*b
   end

   plus_scaled_mat(fac,b)
   ! Add to self the scaled matrix "b"
      CMAT :: b
      CDBL :: fac
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      DIE_IF(b1/=a1,"error in limits")
      DIE_IF(b2/=a2,"error in limits")
      self = self+fac*b
   end

   zero
   ! Set self to sero
      self = ZERO
   end

   change_basis(V) 
   ! Change the basis of self using matrix V, i.e. self = V^T self V
      CMAT :: V
      CMAT, PTR :: W
      INT :: o1,o2,v1,v2
      o1 = size(self,1); o2 = size(self,2)
      v1 = size(V,1)   ; v2 = size(V,2)
      DIE_IF(o1/=o2,"non-square matrix")
      DIE_IF(o2/=v1,"incompatible sizes")
      DIE_IF(v1/=v2,"new basis not square")
      W.create(o1,v2)
      W.to_product(self,V)
      self.to_product(V,W,dagger_a=TRUE)
      W.destroy
   end

   change_basis(L,R) 
   ! Change the basis of self using diagonals L and R, i.e. self = L^T self R
      VEC :: L,R
      CMAT, PTR :: W
      INT :: s1,s2,l1,r1
      s1 = size(self,1); s2 = size(self,2)
      l1 = size(L)
      r1 = size(R)
      DIE_IF(s1/=l1,"incompatible sizes")
      DIE_IF(s2/=r1,"incompatible sizes")
      W.create(l1,r1)
      W.to_product_with_diagonal(self,R)
      self.to_product_with_diagonal(L,W)
      W.destroy
   end

   change_basis(new,V)
   ! Set new = V^T self V
      CMAT :: new,V
      CMAT, PTR :: W
      INT :: o1,o2,n1,n2,dim
      o1 = size(self,1); o2 = size(self,2)
      n1 = size(new,1);  n2 = size(new,2)
      DIE_IF(o1/=o2,"non-square matrix")
      DIE_IF(n1/=n2,"non-square matrix")
      DIE_IF(o1/=n1,"incompatible sizes")
      dim = o1
      W.create(dim,dim)
      W.to_product(self,V)
      new.to_product(V,W)
      W.destroy
   end

   back_transform(new,V)
      CMAT :: new,V
      CMAT, PTR :: W
      INT :: o1,o2,n1,n2,dim
      o1 = size(self,1); o2 = size(self,2)
      n1 = size(new,1);  n2 = size(new,2)
      DIE_IF(o1/=o2,"non-square matrix")
      DIE_IF(n1/=n2,"non-square matrix")
      DIE_IF(o1/=n1,"incompatible sizes")
      dim = o1
      W.create(dim,dim)
      W.to_product(V,self)
      new.to_product(W,V)
      W.destroy
   end

   to_square(sq)
   ! Converts the matrix self to the square sq. The lower half
   ! is the real part and the upper half is the imaginary
      IN :: self
      VEC :: sq
      INT :: dim1,dim2,i,j,ij,lsq
      dim1 = size(self,1)
      dim2 = size(self,2)
      lsq = dim1*dim1
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(size(sq)>=lsq,"square array too small")
      ij = 0
      do i = 1,dim1
         forall (j = 1:i)
            sq(ij+j) = real(self(i,j),kind=DBL_KIND)
         end
         ij = ij+i
      end
      do i = 1,dim1
         forall (j = 1:i-1)
            sq(ij+j) = aimag(self(i,j))
         end
         ij = ij+i
      end
   end

   from_square(sq)
   ! Converts the the square sq to the matrix. The lower half
   ! is the real part and the upper half is the imaginary
      VEC :: sq
      INT :: dim1,dim2,i,j,ij,lsq,ltr
      CDBL :: z
      dim1 = size(self,1)
      dim2 = size(self,2)
      lsq = dim1*dim1
      ltr = dim1*(dim1+1)/2
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(size(sq)>=lsq,"square array too small")
      ij = 0
      do i = 1,dim1
         do j = 1,i
            z = cmplx(sq(ij+j),sq(ltr+ij+j),kind=DBL_KIND)
            self(i,j) = z
            self(j,i) = conjg(z)
         end
         ij = ij+i
      end
   end
      
   to_unit_mat
   ! Set self to the unit matrix
      INT :: dim1,dim2,dim,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      dim = dim1
      self = (0.0,0.0)
      do i = 1,dim
         self(i,i) = (1.0,0.0)
      end
   end
      
   weight_diagonal(fac)
   ! Weight the diagonals of self by "fac"
      CDBL :: fac
      INT :: dim1,dim2,dim,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      dim = dim1
      do i = 1,dim
         self(i,i) = fac*self(i,i)
      end
   end
      
   get_diagonal(diag)
   ! Return the diagonals of self in "diag"
      CVEC :: diag
      INT :: dim1,dim2,dim,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      dim  = size(diag)
      DIE_IF(dim/=min(dim1,dim2),"size of diagonal vector is incompatible")
      do i = 1,dim
         diag(i) = self(i,i)
      end
   end

   hermitian_fold
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j=1:i-1)
            self(i,j) = self(i,j)+conjg(self(j,i))
         end
         self(i,i) = real(self(i,i),kind=DBL_KIND)
      end
   end
      
   antihermitian_fold
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j=1:i-1)
            self(i,j) = self(i,j)-conjg(self(j,i))
         end
         self(i,i) = ZERO
      end
   end
      
   make_hermitian
   ! Make the upper half of self hermitian with respect to the lower half
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j = 1:i-1)
            self(j,i) = conjg(self(i,j))
         end
      end
      forall (i = 1:dim1)
         self(i,i) = real(self(i,i),kind=DBL_KIND)
      end
   end
      
   hermitian_reflect
   ! Make the upper half of self hermitian with respect to the lower half
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j = 1:i-1)
            self(j,i) = conjg(self(i,j))
         end
      end
      forall (i = 1:dim1)
         self(i,i) = real(self(i,i),kind=DBL_KIND)
      end
   end
      
   make_antihermitian
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j = 1:i-1)
            self(j,i) = -conjg(self(i,j))
         end
      end
      forall (i = 1:dim1)
         self(i,i) = ZERO
      end
   end
      
   antihermitian_reflect
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j = 1:i-1)
            self(j,i) = -conjg(self(i,j))
         end
      end
      forall (i = 1:dim1)
         self(i,i) = ZERO
      end
   end

   alpha_alpha result(res)
   ! return the alpha-alpha sector of the matrix
      TARGET :: self
      CMAT, PTR :: res
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(1:n,1:n)
   end

   beta_alpha result(res)
   ! return the beta-alpha sector of the matrix
      TARGET :: self
      CMAT, PTR :: res
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(n+1:2*n,1:n)
   end

   alpha_beta result(res)
   ! return the alpha-beta sector of the matrix
      TARGET :: self
      CMAT, PTR :: res
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(1:n,n+1:2*n)
   end

   beta_beta result(res)
   ! return the beta-beta sector of the matrix
      TARGET :: self
      CMAT, PTR :: res
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(n+1:2*n,n+1:2*n)
   end

   set_alpha_alpha(X)
   ! Set the alpha-alpha sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,1:n) = X
   end

   set_beta_alpha(X)
   ! Set the beta-alpha sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,1:n) = X
   end

   set_alpha_beta(X)
   ! Set the alpha-beta sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,n+1:2*n) = X
   end

   set_beta_beta(X)
   ! Set the beta-beta sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,n+1:2*n) = X
   end

   set_alpha_alpha(X)
   ! Set the alpha-alpha sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,1:n) = X
   end

   set_beta_alpha(X)
   ! Set the beta-alpha sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,1:n) = X
   end

   set_alpha_beta(X)
   ! Set the alpha-beta sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,n+1:2*n) = X
   end

   set_beta_beta(X)
   ! Set the beta-beta sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,n+1:2*n) = X
   end

   plus_alpha_alpha(X)
   ! Add the alpha-alpha sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,1:n) = self(1:n,1:n) + X
   end

   plus_beta_alpha(X)
   ! Add the beta-alpha sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,1:n) = self(n+1:2*n,1:n) + X
   end

   plus_alpha_beta(X)
   ! Add the alpha-beta sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,n+1:2*n) = self(1:n,n+1:2*n) + X
   end

   plus_beta_beta(X)
   ! Add the beta-beta sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,n+1:2*n) = self(n+1:2*n,n+1:2*n) + X
   end

   plus_alpha_alpha(X)
   ! Add the alpha-alpha sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,1:n) = self(1:n,1:n) + X
   end

   plus_beta_alpha(X)
   ! Add the beta-alpha sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,1:n) = self(n+1:2*n,1:n) + X
   end

   plus_alpha_beta(X)
   ! Add the alpha-beta sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,n+1:2*n) = self(1:n,n+1:2*n) + X
   end

   plus_beta_beta(X)
   ! Add the beta-beta sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,n+1:2*n) = self(n+1:2*n,n+1:2*n) + X
   end

   minus_alpha_alpha(X)
   ! Subtract the alpha-alpha sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,1:n) = self(1:n,1:n) + X
   end

   minus_beta_alpha(X)
   ! Subtract the beta-alpha sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,1:n) = self(n+1:2*n,1:n) + X
   end

   minus_alpha_beta(X)
   ! Subtract the alpha-beta sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,n+1:2*n) = self(1:n,n+1:2*n) + X
   end

   minus_beta_beta(X)
   ! Subtract the beta-beta sector of the matrix
      CMAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,n+1:2*n) = self(n+1:2*n,n+1:2*n) + X
   end

   minus_alpha_alpha(X)
   ! Subtract the alpha-alpha sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,1:n) = self(1:n,1:n) + X
   end

   minus_beta_alpha(X)
   ! Subtract the beta-alpha sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,1:n) = self(n+1:2*n,1:n) + X
   end

   minus_alpha_beta(X)
   ! Subtract the alpha-beta sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(1:n,n+1:2*n) = self(1:n,n+1:2*n) + X
   end

   minus_beta_beta(X)
   ! Subtract the beta-beta sector of the matrix
      MAT :: X
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      DIE_IF(n1/=n2,"self is a non-square matrix")
      DIE_IF(n/=2*(n/2),"self is not even-dimensioned")
      n = n/2
      self(n+1:2*n,n+1:2*n) = self(n+1:2*n,n+1:2*n) + X
   end

  schmidt_orthonormalise(S)
  ! Schmidt ortyhonormalise the column vectors in "self" using "S" as the
  ! metric.
    MAT :: S
    INT :: dim,dimS,n,k,j
    DBL :: proj,norm
    VEC, PTR :: T
    dim = size(self,1)
    dimS = size(S,1)
    ENSURE(dim==size(self,2),"non-square matrix")
    ENSURE(dimS==size(S,2),"non-square matrix")
    ENSURE(dim==dimS,"matrices not same size")

    T.create(dim)
    do n=1,dim
      do j=1,dim
        T(j) = dot_product(self(:j,n),S(:j,j))
        T(1:j-1) = T(1:j-1) + self(j,n) * S(:j-1,j)
      end
      do k=1,n-1
        proj = - dot_product(self(:,k),T)
        self(:,n) = self(:,n) + proj * self(:,k)
      end
      do j=1,dim
        T(j) = dot_product(self(:j,n), S(:j,j))
        T(:j-1) = T(:j-1) + self(j,n) * S(:j-1,j)
      end
      norm = dot_product(T,self(:,n))
      self(:,n) = self(:,n) / sqrt(norm)
    end
    T.destroy
  end

end
