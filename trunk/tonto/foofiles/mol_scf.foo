!-------------------------------------------------------------------------------
!
! MOL: scf routines.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_SCF

   use TYPES
   use SYSTEM

   use BUFFER
   use STR
   use INT
   use DBL
   use VEC
   use IVEC
   use MAT
   use MAT3
   use MAT4
   use CMAT
   use CMAT3
   use OPVEC
   use OPMAT

   use INPUT
   use OUTPUT
   use ARCHIVE

   use FILE
   use SHELL2
   use SHELL4
   use ATOM

   use ATOMVEC
   use VECVEC
   use IVECVEC
   use MATVEC
   use SCFDATA
   use VECDIIS
   use POINTGROUP
   use XTAL

   use MOL_COMMON
   use MOL_XTAL
   use MOL_IO
   use MOL_INTEGRALS

   implicit none         

#  include "macros"
#  include "mol_scf.int"

contains

!**********
! SCF setup
!**********

   set_scf_defaults [leaky]
   ! Set up scf defaults for molecule
      .scfdata.destroy
      .scfdata.create
      if (.mult==1) .scfdata%kind = "rhf"
      if (.mult/=1) .scfdata%kind = "uhf"
      .scfdata%using_diis = TRUE
      .scfdata%direct = FALSE
      .scfdata%diis.set_archive_root_name(.name) 
      .scfdata%diis.set_archive_name("fock_matrix,DIIS")
   end

   make_molecule_from_atom(n,mol) [leaky]
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
      INT :: n
      MOL :: mol
      ENSURE(n<=.n_atom,"atom number n too big")
      mol%atom.create(1)
      mol%atom = .atom(n) ! WARNING: dont destroy ptr parts of mol%atom !
      mol%atom(1)%pos = (/ZERO,ZERO,ZERO/)
      mol.set_defaults
      mol%name  =  .name.trim // "_" // (.atom(n)%label).trim
      mol%basis => .basis ! WARNING: dont destroy basis of mol !
      mol.set_basis_info
      mol.set_scf_defaults
   end

!************
! SCF routine
!************

  scf    [recursive] [leaky]
  ! Do an SCF calculation. The following :
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! are produced as results.
    select case (.scfdata%kind)
      case ("xray_rhf","xray_constrained_restricted_hartree_fock")
        .constrained_scf_rhf
      case default;
        .hf_scf
    end
  end

  hf_scf [recursive] [leaky]
  ! Do a Hartree-Fock SCF calculation. The following :
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! are produced as results.
    MAT, PTR :: S
    STR :: kind
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    .get_initial_guess
    .make_fock_matrix
    .scfdata.set(nuclear_energy=.nuclear_energy, put_file=.out)
    .scfdata.reset(energy=.scf_energy, kinetic_energy=.kinetic_energy)
    .scfdata.put_banner
    kind = .scfdata.spinorbital_kind
    do
      .extrapolate_scf
      .update_molecular_orbitals
      if (kind == "restricted") then
        S.create( .n_bf, .n_bf)
        .get_overlap_matrix(S)
        .molecular_orbitals%restricted.schmidt_orthonormalise(S)
        S.destroy
      end
      .make_scf_density_matrix
      .save_scf_results
      .make_fock_matrix
      .scfdata.update( energy=.scf_energy, kinetic_energy=.kinetic_energy )
      .scfdata.put_results
      if (.scfdata.scf_done) exit
    end
    .scfdata.cleanup_diis
    .fock_matrix.destroy(kind)
  end

  update_molecular_orbitals
  ! Solve for the molecular orbitals.  Requires a set of old molecular orbitals.
  ! The new molecular orbitals "cU" are found from the old MOs "c" by solving :
  ! (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    STR :: kind
    BIN :: mos_exist
    VEC, PTR :: e
    CMAT, PTR :: MOc,Fc
    kind = .scfdata%kind
    mos_exist = .molecular_orbitals.created
    ENSURE(mos_exist, "need old MOs for initial guess")
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "rohf","restricted_open_shell_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock", &
             "xray_fit","xray_constrained")
          .update_r_MO(.orbital_energies%restricted,.molecular_orbitals%restricted,.fock_matrix%restricted)
       case ("uhf","unrestricted_hartree_fock")
          .update_r_MO(.orbital_energies%alpha,.molecular_orbitals%alpha, .fock_matrix%alpha)
          .update_r_MO(.orbital_energies%beta ,.molecular_orbitals%beta , .fock_matrix%beta )
       case ("gchf","cghf","general_complex_hartree_fock","complex_general_hartree_fock")
          e   => .orbital_energies%general
          MOc => .molecular_orbitals%general_complex
          Fc  => .fock_matrix%general_complex
          .update_gc_MO(e,MOc,Fc)
    end
  end

  update_r_MO(MO_energies,MO,F)
  ! Solve for the new molecular orbital energies "MO_energies" and the new 
  ! molecular orbitals "MO", given an initial old set (in "MO") and a fock matrix "F".
  ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by solving :
  ! (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    VEC :: MO_energies
    MAT :: MO,F
    MAT, PTR :: G,U
    INT :: i

    G.create(.n_bf,.n_bf)
    U.create(.n_bf,.n_bf)
    G = F
    G.change_basis(MO)

    ! Level shifting
    if ( .scfdata.apply_level_shifting) then
      do i = .n_a + 1, .n_bf
        G(i,i) = .scfdata%level_shift + G(i,i)
      end
    end

    G.solve_eigenproblem(MO_energies,U)
    G.to_product(MO,U)
    MO = G
    U.destroy
    G.destroy
  end

  update_gc_MO(MO_energies,MO,F)
  ! Solve for the new molecular orbital energies "MO_energies" and the new 
  ! molecular orbitals "MO", given an initial old set (in "MO") and a fock matrix "F".
  ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by solving :
  ! (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    VEC :: MO_energies
    CMAT :: MO,F
    CMAT, PTR :: G,U
    INT :: i
    G.create(2*.n_bf,2*.n_bf)
    U.create(2*.n_bf,2*.n_bf)
    G = F
    G.change_basis(MO)
      !  .out.text("F in MO basis, real")
      !  .out.put( real(G))
      !  .out.text("F in MO basis, imag")
      !  .out.put( aimag(G))
    ! Level shifting
    if ( .scfdata.apply_level_shifting) then
      do i = .n_e + 1, 2*.n_bf
        G(i,i) = .scfdata%level_shift + G(i,i)
      end
    end
    G.solve_eigenproblem(MO_energies,U)
      !  .out.text("MO energies")
      !  .out.put( MO_energies, format="column")
    G.to_product(MO,U)
    MO = G
    U.destroy
    G.destroy
  end

  kinetic_energy result (res)
  ! Evaluates the SCF kinetic energy as a trace of ".density_matrix" with the
  ! ".kinetic matrix". 
    DBL :: res
    STR :: kind
    MAT, PTR :: H
    CMAT, PTR :: HH
    kind = .scfdata%kind
    ENSURE( .density_matrix.any_created, "no density matrix")
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock", &
             "xray_fit","xray_constrained")
          H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
          res = - .density_matrix%restricted.trace_of_product(H)
          H.destroy
       case ("uhf","unrestricted_hartree_fock","rohf","restricted_open_shell_hartree_fock")
          H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
          res = - .density_matrix%alpha.trace_of_product(H)
          res = - .density_matrix%beta.trace_of_product(H) + res
          H.destroy
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          HH.create(2*.n_bf,2*.n_bf); HH=ZERO
          H.create(.n_bf,.n_bf)
          .get_kinetic_matrix(H)
          HH.alpha_alpha_set_to(H)
          HH.beta_beta_set_to(H)
          H.destroy
          res = - .density_matrix%general_complex.trace_of_product(HH)
          HH.destroy
       case default; DIE("don't know what to do with " // .scfdata%kind)
    end
  end

  scf_energy result (res)
  ! Evaluates the total SCF energy (including nuclear) as a trace of 
  ! ".density_matrix" with the ".fock matrix". 
    DBL :: res
    res = .scf_electronic_energy(.density_matrix) + .nuclear_energy
  end

  scf_energy(P) result (res)
  ! Evaluates the total SCF energy (including nuclear) as a trace of 
  ! "P" with the ".fock matrix". 
    OPMAT, target :: P
    DBL :: res
    res = .scf_electronic_energy(P) + .nuclear_energy
  end

  scf_electronic_energy(P,core) result (res)
  ! Evaluates the SCF electronic energy as a trace of "D" with the ".fock matrix". 
  ! If "core" is present and FALSE, the core contribution is not added
    OPMAT, target :: P
    BIN, optional :: core
    BIN :: add_core
    DBL :: res
    STR :: kind
    MAT, PTR :: F
    CMAT, PTR :: FF
    kind = .scfdata%kind
    ENSURE( .fock_matrix.any_created,    "no fock matrix")
    ENSURE( .density_matrix.any_created, "no density matrix")
    add_core = TRUE
    if (present(core)) add_core = core
    select case (kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock")
          F.create(.n_bf,.n_bf)
          F = .fock_matrix%restricted
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P%restricted.trace_of_product(F)
          F.destroy
       case ("uhf","unrestricted_hartree_fock","rohf","restricted_open_shell_hartree_fock")
          F.create(.n_bf,.n_bf);
          F = .fock_matrix%alpha
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P%alpha.trace_of_product(F)
          F = .fock_matrix%beta
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P%beta.trace_of_product(F) + res
          F.destroy
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          FF.create(2*.n_bf,2*.n_bf);
          FF = .fock_matrix%general_complex
          if (add_core) .add_core_hamiltonian(FF)
          res = HALF * P%general_complex.trace_of_product(FF)
          FF.destroy
       case default; DIE("not yet implemented, " // .scfdata%kind)
    end
  end

  get_scf_results [leaky]
  ! Get the SCF results in from archives. Do not get the density matrix, because
  ! it can/should be generated from the orbitals, depending on the kind of SCF.
    ARCHIVE :: archive
    STR :: k
    k = .scfdata.molecular_orbital_kind
    archive.set(.name,"molecular_orbitals",kind=k)
    archive.read(.molecular_orbitals,kind=k)
    k = .scfdata.orbital_energies_kind
    archive.set(.name,"orbital_energies",kind=k)
    archive.read(.orbital_energies,kind=k)
  end

  save_scf_results
  ! Save the SCF results in various archives
    ARCHIVE :: archive
    archive.set(.name,"density_matrix")
    archive.write(.density_matrix)
    archive.set(.name,"molecular_orbitals")
    archive.write(.molecular_orbitals)
    archive.set(.name,"orbital_energies")
    archive.write(.orbital_energies)
  end

  destroy_scf_results [leaky]
  ! Destroy the SCF results
    .density_matrix.destroy
    .density_matrix.create(.n_bf)
    .molecular_orbitals.destroy
    .molecular_orbitals.create(.n_bf)
    .orbital_energies.destroy
    .orbital_energies.create(.n_bf)
  end

  delete_integrals
  ! Delete all integral files. This is required whenever the geometry is changed.
     ARCHIVE :: archive
     archive.set(.name,"overlap_matrix")
     archive.delete
     archive.set(.name,"kinetic_matrix")
     archive.delete
     archive.set(.name,"nuclear_matrix")
     archive.delete
     archive.set(.name,"core_matrix")
     archive.delete
     archive.set(.name,"fock_matrix")
     archive.delete
     archive.set(.name,"eri_integrals")
     archive.delete
     archive.set(.name,"eri_index")
     archive.delete
     archive.set(.name,"ft_ints")
     archive.delete
  end

  delete_matrices
  ! Delete any matrices stored on disk.
     ARCHIVE :: archive
     archive.set(.name,"density_matrix")
     archive.delete_all
     archive.set(.name,"molecular_orbitals")
     archive.delete_all
     archive.set(.name,"orbital_energies")
     archive.delete_all
  end

!*******************************
! Initial orbital guess routines
!*******************************

  get_initial_guess [leaky]
  ! Get the initial guess for the ".density_matrix" and ".molecular_orbitals"
  ! If .initial_mos is set, it overides .initial_density.
     STR :: initial_density,initial_mos
     ARCHIVE :: archive
     initial_mos     = .scfdata%initial_mos
     initial_density = .scfdata%initial_density
     if (initial_mos/="--not used--") then
        .make_MO_guess(initial_mos) 
     else
        select case (initial_density)
           case ("core"); .make_core_guess
           case ("fock"); .make_fock_guess
           case ("atom"); .make_atom_guess
           case("restricted","unrestricted","general", &
                "restricted_complex","unrestricted_complex","general_complex", &
                "complex_restricted","complex_unrestricted","complex_general")
              .make_density_guess(initial_density)
           case default
              DIE("unknown initial guess density, "// initial_density.trim)
        end
     end
  end

  make_MO_guess(initial_mos) [leaky]
  ! Read old .molecular_orbitals of type "initial_mos" and use it to
  ! make initial .density_matrix to start the scf calculation.
  ! Convert the .molecular_orbitals, if neccesary.
     STR :: initial_mos
     ARCHIVE :: archive
     archive.set(.name,"molecular_orbitals",kind=initial_mos)
     archive.read(.molecular_orbitals)
     .molecular_orbitals.convert_to( .scfdata.molecular_orbital_kind,.n_bf,.n_a,.n_b)
     .make_scf_density_matrix
     .orbital_energies.create(kind=.scfdata.orbital_energies_kind)
  end

  make_density_guess(initial_density) [leaky]
  ! Read an old .density_matrix of type "initial_guess" and use it to
  ! make initial .molecular_orbitals to start an scf calculation.
  ! Convert the .density_matrix, if neccesary.
     STR :: initial_density
     ARCHIVE :: archive
     archive.set(.name,"density_matrix")
     archive.read(.density_matrix,kind=initial_density)
     .density_matrix.convert_to(newkind = .scfdata.spinorbital_kind)
     .make_fock_matrix  ! Make a fock matrix
     .make_fock_guess   ! Get a reasonable set of starting MO's
  end

  make_core_guess [leaky]
  ! Do a core scf for the ".density_matrix", ".molecular_orbitals" and ".orbital_energies"
    STR :: kind
    .destroy_scf_results
    .orbital_energies.destroy("restricted")
    .orbital_energies.create("restricted")
    .molecular_orbitals.destroy("restricted")
    .molecular_orbitals.create("restricted")
    .make_r_core_guess(.orbital_energies%restricted,.molecular_orbitals%restricted)
    kind = .scfdata.orbital_energies_kind
    .orbital_energies.convert_to(kind)
    kind = .scfdata.molecular_orbital_kind
    .molecular_orbitals.convert_to(kind,factor=HALF)
    .make_scf_density_matrix
    .make_fock_matrix  ! Make a fock matrix
    .make_fock_guess   ! Get a reasonable set of starting MO's
!    select case (kind)
!       case ("rhf","restricted_hartree_fock","rohf","restricted_open_shell_hartree_fock", &
!             "xray_rhf","xray_constrained_restricted_hartree_fock", &
!             "xray_fit","xray_constrained")
!          .orbital_energies.destroy("restricted")
!          .orbital_energies.create("restricted")
!          .molecular_orbitals.destroy("restricted")
!          .molecular_orbitals.create("restricted")
!          .get_r_core_guess(.orbital_energies%restricted,.molecular_orbitals%restricted)
!       case ("uhf","unrestricted_hartree_fock")
!          .orbital_energies.destroy("unrestricted")
!          .orbital_energies.create("unrestricted")
!          .molecular_orbitals.destroy("unrestricted")
!          .molecular_orbitals.create("unrestricted")
!          .get_r_core_guess(.orbital_energies%alpha,.molecular_orbitals%alpha)
!          .orbital_energies%beta   = .orbital_energies%alpha
!          .molecular_orbitals%beta = .molecular_orbitals%alpha
!       case ("gchf","cghf","general_complex_hartree_fock","complex_general_hartree_fock")
!          .orbital_energies.destroy("restricted")
!          .orbital_energies.create("restricted")
!          .molecular_orbitals.destroy("restricted")
!          .molecular_orbitals.create("restricted")
!          .get_r_core_guess(.orbital_energies%restricted,.molecular_orbitals%restricted)
!          .orbital_energies.destroy("general")
!          .orbital_energies.create("general")
!          eg  => .orbital_energies%general
!          er  => .orbital_energies%restricted
!          eg(1:2*.n_b-1:2)  = er(1:.n_b)
!          eg(2:2*.n_b  :2)  = er(1:.n_b)
!          eg(2*.n_b+1:.n_e) = er(.n_b+1:.n_a)
!          eg(.n_e+1:2*.n_a)        = er(.n_b+1:.n_a)
!          eg(2*.n_a+1:2*.n_bf-1:2) = er(.n_a+1:.n_bf)
!          eg(2*.n_a+2:2*.n_bf  :2) = er(.n_a+1:.n_bf)
!          .orbital_energies.destroy("restricted")
!          .molecular_orbitals.destroy("general_complex")
!          .molecular_orbitals.create("general_complex")
!          MOg => .molecular_orbitals%general_complex
!          MOr => .molecular_orbitals%restricted
!          MOg = ZERO
!          MOg(1:.n_bf ,1:2*.n_b-1:2)  = MOr(:,1:.n_b)
!          MOg(.n_bf+1:,2:2*.n_b  :2)  = MOr(:,1:.n_b)
!          MOg(1:.n_bf ,2*.n_b+1:.n_e) = MOr(:,.n_b+1:.n_a)
!          MOg(.n_bf+1:,.n_e+1:2*.n_a) = MOr(:,.n_b+1:.n_a)
!          MOg(1:.n_bf ,2*.n_a+1:2*.n_bf-1:2) = MOr(:,.n_a+1:.n_bf)
!          MOg(.n_bf+1:,2*.n_a+2:2*.n_bf  :2) = MOr(:,.n_a+1:.n_bf)
!          .molecular_orbitals.destroy("restricted")
!       case default; DIE("don't know what to do for " // kind)
!    end
!    .make_scf_density_matrix
!    .save_scf_results
  end

  make_r_core_guess(MO_energies,MO)
  ! Do a real core scf for the molecular orbital energies  "MO_energies" 
  ! and the molecular_orbitals "MO"
    VEC :: MO_energies
    MAT :: MO
    MAT, PTR :: S,R,H
    !  H~ = S^-1/2 H S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    R.create(.n_bf,.n_bf); R.to_inverse_sqrt(S)
    H.create(.n_bf,.n_bf); .get_core_matrix(H)
    S.to_product(R,H)
    H.to_product(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H.to_product(R,MO)
    MO = H
    H.destroy
    R.destroy
    S.destroy
  end

  make_atom_guess [leaky]
  ! Make a ".density matrix" and fock matrix from the sum of atomic densities
     .get_atom_density
     .make_fock_matrix  ! Make a fock matrix
     .make_fock_guess   ! Get a reasonable set of starting MO's
  end

  get_atom_density [leaky]
  ! Reads ".density_matrix" from the archive, otherwise makes it and
  ! writes to the archive.
    ARCHIVE :: archive
    archive.set(.name,"atom_density_matrix", kind="restricted")
    if ( archive.exists) then
       archive.read(.density_matrix)
       .density_matrix.convert_to( .scfdata.spinorbital_kind,factor=HALF)
    else
       .make_atom_density
    end
  end

  make_atom_density [leaky]
  ! Make a ".density matrix" from the sum of atomic densities
    INT :: k,n_k,l,kl,a,b
    MOL, PTR :: mol
    IVEC, PTR :: first,last
    IVECVEC, PTR :: atom_kind
    ARCHIVE :: archive
    ENSURE( .scfdata.created, "no scf data present.")
    .density_matrix.destroy("restricted")
    .density_matrix.create("restricted")
    .density_matrix%restricted = ZERO
    .atom.make_atom_basis_fn_limits(first,last)
    .atom.make_atom_kind_list(atom_kind)
    n_k = size(atom_kind)
    do k = 1,n_k ! Do an SCF for every different kind of atom
      mol.create
      l = atom_kind(k)%vec(1)
      .make_molecule_from_atom(l,mol)
      if (mol.no_of_electrons >= 1) then
        mol%scfdata%convergence = 0.0001
        mol%scfdata%output = FALSE
        mol.scf
        mol.make_ao_density_matrix
        mol%pointgroup.create("oh")
        mol.symmetrise(mol%density_matrix)
        do l = 1,size(atom_kind(k)%vec) ! Copy this atom density 
          kl = atom_kind(k)%vec(l)
          a = first(kl); b = last(kl)
         .density_matrix%restricted(a:b,a:b) = &
         .density_matrix%restricted(a:b,a:b) &
         + mol%density_matrix%restricted
        end
      end
      mol%atom.nullify_ptr_part ! do not destroy these
      nullify(mol%basis)        ! do not destroy this
      mol.delete_integrals
      mol.delete_matrices
      mol.destroy
    end
    archive.set(.name,"atom_density_matrix", kind="restricted")
    archive.write(.density_matrix, kind="restricted")
    .density_matrix.convert_to( .scfdata.spinorbital_kind,factor=HALF)
    atom_kind.destroy
    last.destroy
    first.destroy
  end

  make_fock_guess [leaky]
  ! Make the .density_matrix, .molecular_orbitals, and .orbital_energies
  ! from an initial .fock_matrix; destroy .fock_matrix afterwards
    STR :: kind
    VEC, PTR :: e
    MAT, PTR :: MO,F
    CMAT, PTR :: MOc,Fc
    kind = .scfdata.spinorbital_kind
    ENSURE( .fock_matrix.created(kind),"need an initial fock matrix")
    .destroy_scf_results
    kind = .scfdata%kind
    select case (kind)
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock", &
             "xray_fit","xray_constrained")
          .orbital_energies.destroy("restricted")
          .orbital_energies.create("restricted")
          .molecular_orbitals.destroy("restricted")
          .molecular_orbitals.create("restricted")
          e  => .orbital_energies%restricted
          MO => .molecular_orbitals%restricted
          F  => .fock_matrix%restricted
          .make_r_fock_guess(e,MO,F)
       case ("uhf","unrestricted_hartree_fock")
          .orbital_energies.destroy("unrestricted")
          .orbital_energies.create("unrestricted")
          .molecular_orbitals.destroy("unrestricted")
          .molecular_orbitals.create("unrestricted")
          e  => .orbital_energies%alpha
          MO => .molecular_orbitals%alpha
          F  => .fock_matrix%alpha
          .make_r_fock_guess(e,MO,F)
          e  => .orbital_energies%beta
          MO => .molecular_orbitals%beta
          F  => .fock_matrix%beta
          .make_r_fock_guess(e,MO,F)
       case ("cghf","gchf","general_complex_hartree_fock","complex_general_hartree_fock")
          .orbital_energies.destroy("general")
          .orbital_energies.create("general")
          .molecular_orbitals.destroy("general_complex")
          .molecular_orbitals.create("general_complex")
          e   => .orbital_energies%general
          MOc => .molecular_orbitals%general_complex
          Fc  => .fock_matrix%general_complex
          .make_gc_fock_guess(e,MOc,Fc)
       case default; DIE("unknown spinorbital kind, " // kind.trim)
    end
    kind = .scfdata.spinorbital_kind
    .fock_matrix.destroy(kind)
    .make_scf_density_matrix
    .save_scf_results
  end

  make_r_fock_guess(MO_energies,MO,fock_matrix) 
  ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
  ! a given real restricted "fock_matrix".
    VEC :: MO_energies
    MAT :: MO, fock_matrix
    STR :: kind
    MAT, PTR :: S,R,H
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    R.create(.n_bf,.n_bf); R.to_inverse_sqrt(S)
    H.create(.n_bf,.n_bf); H = fock_matrix
    S.to_product(R,H)
    H.to_product(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H.to_product(R,MO)
    MO = H
    H.destroy
    R.destroy
    S.destroy
  end

  make_gc_fock_guess(MO_energies,MO,fock_matrix) 
  ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
  ! a given complex general "fock_matrix".
    VEC :: MO_energies
    CMAT :: MO, fock_matrix
    STR :: kind
    MAT, PTR :: S,R
    CMAT, PTR :: H,W
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf)
    R.create(.n_bf,.n_bf)
    .get_overlap_matrix(R)
    S.to_inverse_sqrt(R)
    R.destroy
    R.create(2*.n_bf,2*.n_bf); R=ZERO
    R.alpha_alpha_set_to(S)
    R.beta_beta_set_to(S)
    S.destroy
    H.create(2*.n_bf,2*.n_bf); H = fock_matrix
    W.create(2*.n_bf,2*.n_bf)
    W = matmul(R,H)
    H = matmul(W,R)
    W.destroy
    H.solve_eigenproblem(MO_energies,MO)
    H = matmul(R,MO)
    MO = H
    H.destroy
    R.destroy
  end
 
! ******************
! DIIS extrapolation 
! ******************

   extrapolate_scf 
   ! Extrapolate the scf objects
      STR :: kind
      OPMAT, PTR :: error
      CMAT, PTR :: err,F,P
      if ( .scfdata.skip_diis) return
      kind = .scfdata%kind
      select case (kind)
         case ("rhf","restricted_hartree_fock", &
               "xray_rhf","xray_constrained_restricted_hartree_fock", &
               "xray_fit","xray_constrained")
            error.create(.n_bf,"restricted")
            .make_r_diis_error(error%restricted,.fock_matrix%restricted,.density_matrix%restricted)
            error.compress
            .fock_matrix.compress
            .scfdata%diis.extrapolate(.fock_matrix%triangle,error%triangle)
            .fock_matrix.uncompress
            error.destroy
         case ("rohf","restricted_open_shell_hartree_fock")
            error.create(.n_bf,"restricted")
            .make_r_diis_error(error%restricted,.fock_matrix%restricted,.density_matrix%alpha)
            error.compress
            .fock_matrix.compress("restricted")
            .scfdata%diis.extrapolate(.fock_matrix%triangle,error%triangle)
            .fock_matrix.uncompress
            error.destroy
         case ("uhf","unrestricted_hartree_fock")
            error.create(.n_bf,"unrestricted")
            .make_r_diis_error(error%alpha,.fock_matrix%alpha,.density_matrix%alpha)
            .make_r_diis_error(error%beta, .fock_matrix%beta, .density_matrix%beta)
            error.compress
            .fock_matrix.compress
            .scfdata%diis.extrapolate(.fock_matrix%triangle,error%triangle)
            .fock_matrix.uncompress
            error.destroy
         case ("gchf","cghf","complex_general_hartree_fock","general_complex_hartree_fock")
    ! .out.text("1")
            error.create(.n_bf,"general_complex")
    ! .out.text("2")
            err => error%general_complex
            F   => .fock_matrix%general_complex
            P   => .density_matrix%general_complex
    ! .out.text("3")
            .make_gc_diis_error(err,F,P)
    ! .out.text("4")
            error.compress
    ! .out.text("5")
            .fock_matrix.compress
    ! .out.text("6")
            .scfdata%diis.extrapolate(.fock_matrix%square,error%square)
    ! .out.text("7")
            .fock_matrix.uncompress
    ! .out.text("8")
            error.destroy
      end
   end

   make_r_diis_error(error,F,P)
   ! Make the real DIIS error matrix, error = FPS - SPF
      MAT :: error,F,P
      MAT, PTR :: S,W
      W.create(.n_bf, .n_bf)
      S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
      W.to_product(P,S)
      S.destroy
      error.to_product(F,W)
      W.destroy
      error.antisymmetric_fold
      error.make_antisymmetric
   end

   make_gc_diis_error(error,F,P)
   ! Make the complex general DIIS error matrix, error = FPS - SPF
      CMAT :: error,F,P
      MAT, PTR :: R
      CMAT, PTR :: S,W
      W.create(2*.n_bf, 2*.n_bf)
      S.create(2*.n_bf,2*.n_bf); S=ZERO
      R.create(.n_bf,.n_bf)
      .get_overlap_matrix(R)
      S.alpha_alpha_set_to(R)
      S.beta_beta_set_to(R)
      R.destroy
      W.to_product(P,S)
      S.destroy
      error.to_product(F,W)
      W.destroy
      error.antihermitian_fold
      error.make_antihermitian
   end
 
! *******************
! Pairwise SCF energy
! *******************

   put_scf_energy_in_mo_pairs
   ! Analyse the SCF energy into MO pairs
      OPMAT, PTR :: Di
      VEC, PTR :: core_energy
      MAT, PTR :: pair_energy
      INT :: i,j
      DBL :: energy,fac
      BIN :: direct
      core_energy.create(.n_a)
      pair_energy.create(.n_a,.n_a)
      core_energy = ZERO
      pair_energy = ZERO
      Di.create(.n_bf)
      direct = .scfdata%direct
      .scfdata%direct = TRUE 
      do i = 1,.n_a
         .make_scf_density_matrix(i) 
         Di.set_to(.density_matrix)
         .make_fock_matrix(core=TRUE,r12=FALSE)
         core_energy(i) = .scf_electronic_energy(Di,core=TRUE)
         do j = 1,i
            .make_scf_density_matrix(j)
            .make_fock_matrix(core=FALSE,r12=TRUE)
            fac = TWO
            if (i==j) fac = ONE
            pair_energy(i,j) = fac*.scf_electronic_energy(Di,core=FALSE)
         end
      end  
      Di.destroy
      .scfdata%direct = direct
      .out.flush
      .out.text("SCF MO pair energy decomposition:",flush=1)
      energy = sum(core_energy)+sum(transfer(pair_energy,(/ONE/)))+.nuclear_energy
      .out.show("SCF energy =",energy)
      .out.text("Core energies:",flush=1)
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("MO_i",int_width=TRUE)
      .out.put("Core energy")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      do i = 1,.n_a
         .out.put(i)
         .out.put(core_energy(i),flush=1)
      end 
      .out.dash(int_fields=1,dbl_fields=1)
      .out.flush
      .out.text("Orbital pair energies:",flush=1)
      .out.dash(int_fields=2,dbl_fields=1)
      .out.put("MO_i",int_width=TRUE)
      .out.put("MO_j",int_width=TRUE)
      .out.put("Pair energy",flush=1)
      .out.dash(int_fields=2,dbl_fields=1)
      do i = 1,.n_a
      do j = 1,i
         .out.put(i)
         .out.put(j)
         .out.put(pair_energy(i,j),flush=1)
      end 
      end 
      .out.dash(int_fields=2,dbl_fields=1)
      .out.flush
  end

!*********************
! Fock matrix routines
!*********************

  get_fock_matrix [leaky]
  ! Get the Fock matrix. If already in memory, do nothing. Else if 
  ! the archive file exists, read it. Otherwise make it.
     ARCHIVE :: archive
     STR :: kind
     kind = .scfdata.spinorbital_kind
     archive.set(.name,"fock_matrix",kind)
     if ( archive.exists) then; archive.read(.fock_matrix)
     else;                      .make_fock_matrix
     end
  end

  make_fock_matrix(core,r12) [leaky]
  ! If core is present and FALSE, the core hamiltonian is not added
  ! If r12  is present and FALSE, the r12 part is not computed
    BIN, optional :: core,r12
    BIN :: direct
    STR :: scf_kind 
    scf_kind = .scfdata%kind 
    direct = .scfdata%direct 
    if (NOT direct) .get_eri_integrals
    select case (scf_kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock")
                                                            .make_r_fock(direct,core,r12)
       case("rohf","restricted_open_shell_hartree_fock");   .make_ro_fock(direct,core,r12)
       case("uhf","unrestricted_hartree_fock");             .make_u_fock(direct,core,r12)
       case("gchf","cghf", &
            "general_complex_hartree_fock","complex_general_hartree_fock")
                                                            .make_gc_fock(direct,core,r12) 
                                                            .make_gc_so_fock 
       case default; DIE("unknown scf kind, "// scf_kind.trim)
    end
  end

  add_core_hamiltonian(F)
  ! Add the core hamiltonain to "F"
     MAT :: F
     MAT, PTR :: H
     H.create( .n_bf, .n_bf)
     .get_core_matrix(H)
     F = F + H
     H.destroy
  end

  add_core_hamiltonian(F)
  ! Add the core hamiltonain to a general complex "F"
     CMAT :: F
     CMAT,PTR :: HH
     MAT, PTR :: H, S, T, xx,yy,zz,xy,xz,yz, Lx,Ly,Lz, yx,zx,zy
     MAT(3,3) :: BB
     INT :: k,l
     DBL :: fac
     CDBL :: I
     HH.create( 2*.n_bf, 2*.n_bf); HH = ZERO
     H.create( .n_bf, .n_bf)
     .get_core_matrix(H)
     HH.alpha_alpha_plus(H)
     HH.beta_beta_plus(H)
     H.destroy
     I = (ZERO,ONE)
     if ( .scfdata%using_1e_sl_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_spin_orbit_matrices(Lx,Ly,Lz) 
           fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
           fac = fac * .scfdata%sl_1e_factor
           HH.beta_alpha_plus(Lx,factor=-fac*I)
           HH.beta_alpha_plus(Ly,factor=fac)
           HH.alpha_alpha_plus(Lz,factor=-fac*I)
           HH.beta_beta_plus(Lz,factor=fac*I)
           Lz.destroy; Ly.destroy; Lx.destroy
     else if ( .scfdata%using_1e_zora_term) then
           T.create(.n_bf,.n_bf)
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_1e_ZORA_matrices(T,Lx,Ly,Lz) 
           HH.alpha_alpha_plus(T)
           HH.beta_beta_plus(T)
           .get_kinetic_matrix(T) ! remove normal kinetic energy
           HH.alpha_alpha_plus(T,factor=-ONE)
           HH.beta_beta_plus(T,factor=-ONE)
           fac = -G_FACTOR/TWO  ! minus factor to be consistent with above
           fac = fac * .scfdata%sl_1e_factor
           HH.beta_alpha_plus(Lx,factor=-fac*I)
           HH.beta_alpha_plus(Ly,factor=fac)
           HH.alpha_alpha_plus(Lz,factor=-fac*I)
           HH.beta_beta_plus(Lz,factor=fac*I)
           T.destroy
           Lz.destroy; Ly.destroy; Lx.destroy
     end
     if ( .B_field.is_not_zero) then
        if ( .scfdata%using_bs_term) then
           S.create(.n_bf,.n_bf)
           .get_overlap_matrix(S) 
           fac = G_FACTOR/FOUR
           HH.alpha_alpha_plus(S,factor=fac*.B_field(3))
           HH.beta_beta_plus(S,factor=-fac*.B_field(3))
           HH.beta_alpha_plus(S,factor=fac*.B_field(1))
           HH.beta_alpha_plus(S,factor=fac*.B_field(2)*I)
           S.destroy
        end
        if ( .scfdata%using_bs_t_term) then
           T.create(.n_bf,.n_bf)
           .get_kinetic_matrix(T) 
           fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU**2)
           HH.alpha_alpha_plus(T,factor=fac*.B_field(3))
           HH.beta_beta_plus(T,factor=-fac*.B_field(3))
           HH.beta_alpha_plus(T,factor=fac*.B_field(1))
           HH.beta_alpha_plus(T,factor=fac*.B_field(2)*I)
           T.destroy
        end
        if ( .scfdata%using_bl_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_L_matrices(Lx,Ly,Lz) 
           Lx = Lx*.B_field(1) + Ly*.B_field(2) + Lz*.B_field(3)
           fac = HALF
           HH.alpha_alpha_plus(Lx,factor=fac*I)
           HH.beta_beta_plus(Lx,factor=fac*I)
           Lz.destroy; Ly.destroy; Lx.destroy
        end
        if ( .scfdata%using_aa_term) then
           xx.create(.n_bf,.n_bf); yy.create(.n_bf,.n_bf); zz.create(.n_bf,.n_bf)
           xy.create(.n_bf,.n_bf); xz.create(.n_bf,.n_bf); yz.create(.n_bf,.n_bf)
           .get_quadrupole_matrices(xx,yy,zz,xy,xz,yz) 
           fac = ONE/EIGHT
           do k = 1,3
              BB(k,k) = fac*(sum(.B_field*.B_field) - .B_field(k)*.B_field(k))
           end
           do k = 1,3
           do l = k+1,3
              BB(k,l) = -TWO*fac*.B_field(k)*.B_field(l)
           end
           end
           xx =      BB(1,1)*xx; xx = xx + BB(2,2)*yy; xx = xx + BB(3,3)*zz
           xx = xx + BB(1,2)*xy; xx = xx + BB(1,3)*xz; xx = xx + BB(2,3)*yz
           HH.alpha_alpha_plus(xx)
           HH.beta_beta_plus(xx)
           yz.destroy; xz.destroy; xy.destroy
           zz.destroy; yy.destroy; xx.destroy
        end
        if ( .scfdata%using_1e_srxa_term) then
           Lx.create(.n_bf,.n_bf)
           Ly.create(.n_bf,.n_bf)
           Lz.create(.n_bf,.n_bf)
           .get_spin_orbit_B_matrices(Lx,Ly,Lz) 
           fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
           HH.beta_alpha_plus(Lx,factor=fac)
           HH.beta_alpha_plus(Ly,factor=fac*I)
           HH.alpha_alpha_plus(Lz,factor=fac)
           HH.beta_beta_plus(Lz,factor=-fac)
           Lz.destroy; Ly.destroy; Lx.destroy
        end
     end
     HH.make_hermitian
     F = HH + F
        ! .out.set_dbl_width(15)
        ! .out.set_dbl_precision(8)
        ! .out.set_fields(7)
        ! .out.text("h, real")
        ! .out.put(real(HH))
        ! .out.text("h, imag")
        ! .out.put(aimag(HH))
        ! stop
     HH.destroy
  end

  make_r_fock(direct,core,r12) [leaky]
  ! Make a new restricted Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    MAT, PTR :: J,K,P,F
    BIN :: do_direct,add_core,add_r12
    ENSURE( .density_matrix%restricted.created, "no density matrix")
    .fock_matrix.destroy("restricted")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    F.create(.n_bf,.n_bf)
    F = ZERO
    if (add_r12) then
       P => .density_matrix%restricted
       J.create( .n_bf, .n_bf)
       K.create( .n_bf, .n_bf)
       if (do_direct) then; .make_r_JK_direct(J,K,P)
       else;                .make_r_JK_disk(J,K,P)
       end
       F = J - HALF*K 
       K.destroy
       J.destroy
    end
    if (add_core) .add_core_hamiltonian(F)
    .fock_matrix%restricted => F
  end

  make_u_fock(direct,core,r12) [leaky]
  ! Make a new unrestricted Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    MAT, PTR :: J,Ka,Kb,P,Pa,Pb,Fa,Fb
    BIN :: do_direct,add_core,add_r12
    ENSURE( .density_matrix%alpha.created, "no density matrix")
    ENSURE( .density_matrix%beta.created, "no density matrix")
    .fock_matrix.destroy("unrestricted")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    Fa.create(.n_bf,.n_bf)
    Fb.create(.n_bf,.n_bf)
    Fa = ZERO
    Fb = ZERO
    if (add_r12) then
       Pa => .density_matrix%alpha
       Pb => .density_matrix%beta
       J.create(.n_bf,.n_bf)
       Ka.create(.n_bf,.n_bf)
       Kb.create(.n_bf,.n_bf)
       P.create(.n_bf,.n_bf)
       P  = Pa + Pb
       if (do_direct) then; .make_u_JK_direct(J,Ka,Kb,P,Pa,Pb)
       else;                .make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
       end
       P.destroy
       Fa = J - Ka 
       Fb = J - Kb 
       Kb.destroy
       Ka.destroy
       J.destroy
    end
    if (add_core) .add_core_hamiltonian(Fa)
    if (add_core) .add_core_hamiltonian(Fb)
    .fock_matrix%alpha => Fa
    .fock_matrix%beta  => Fb
  end

  make_ro_fock(direct,core,r12) [leaky]
  ! Make a new restricted open shell Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    MAT, PTR :: F,Fa,Fb,S,W
    ENSURE( .molecular_orbitals%restricted.created, "no orbitals")
    .make_u_fock(direct,core,r12)
    .fock_matrix.destroy("restricted")
    .fock_matrix.create("restricted")
    F => .fock_matrix%restricted
    Fa.create(.n_bf,.n_bf); Fa = .fock_matrix%alpha
    Fb.create(.n_bf,.n_bf); Fb = .fock_matrix%beta
    Fa.change_basis(.molecular_orbitals%restricted)
    Fb.change_basis(.molecular_orbitals%restricted)
    F = HALF*(Fa+Fb)
    F(.n_b+1:.n_a,     1:.n_b) = Fb(.n_b+1:.n_a,     1:.n_b)
    F(     1:.n_b,.n_b+1:.n_a) = Fb(     1:.n_b,.n_b+1:.n_a)
    F(.n_a+1:    ,.n_b+1:.n_a) = Fa(.n_a+1:    ,.n_b+1:.n_a)
    F(.n_b+1:.n_a,.n_a+1:    ) = Fa(.n_b+1:.n_a,.n_a+1:    )
    S => Fb; .get_overlap_matrix(S)
    W => Fa; W.to_product(.molecular_orbitals%restricted,S,transpose_a=TRUE)
    F.change_basis(W) ! change to AO basis
    Fb.destroy
    Fa.destroy
  end

  make_gc_fock(direct,core,r12) [leaky]
  ! Make a new complex general Fock matrix.
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    CMAT, PTR :: Ka,Kb,Kba,Pa,Pb,Pba,F
    MAT, PTR :: J, P
    BIN :: do_direct,add_core,add_r12
    .fock_matrix.destroy("general_complex")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core)) add_core = core
    if (present(r12))  add_r12  = r12
    F.create(2*.n_bf,2*.n_bf)
    F = ZERO
    if (add_r12) then
       J.create(.n_bf,.n_bf)
       Ka.create(.n_bf,.n_bf)
       Kb.create(.n_bf,.n_bf)
       Kba.create(.n_bf,.n_bf)
       Pa.create(.n_bf,.n_bf);  .density_matrix%general_complex.alpha_alpha_put_to(Pa)
       Pb.create(.n_bf,.n_bf);  .density_matrix%general_complex.beta_beta_put_to(Pb)
       Pba.create(.n_bf,.n_bf); .density_matrix%general_complex.beta_alpha_put_to(Pba)
       P.create(.n_bf,.n_bf)
       P  = Pa + Pb
       if (do_direct) then; .make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
       else;                .make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
       end
       P.destroy
       Pba.destroy
       Pb.destroy
       Pa.destroy
       Ka = J - Ka; F.alpha_alpha_set_to(Ka)
       Kb = J - Kb; F.beta_beta_set_to(Kb)
       Kba = -Kba;  F.beta_alpha_set_to(Kba)
       Kba.destroy
       Kb.destroy
       Ka.destroy
       J.destroy
    end
    if (add_core) .add_core_hamiltonian(F)
    F.make_hermitian
    .fock_matrix%general_complex => F
        ! .out.text("F, real:")
        ! .out.put( real(F) )
        ! .out.text("F, imag:")
        ! .out.put( aimag(F) )
  end

  make_gc_so_fock [leaky]
  ! Make the general complex two electron spin orbit contribution to the Fock matrix. 
    CMAT5, PTR :: JS,KS,JO,KO
    CMAT4, PTR :: P
    CMAT, PTR  :: F,Faa,Fbb,Fba
    ARCHIVE    :: SOx_archive,SOy_archive,SOz_archive,ind_archive
    CDBL :: I
    DBL :: fac
    INT :: a,b,x,y,z
    if (.scfdata%using_2e_sl_term) then
      .get_spin_orbit_integrals
      Faa.create(.n_bf,.n_bf)
      Fbb.create(.n_bf,.n_bf)
      Fba.create(.n_bf,.n_bf)
      JS.create(.n_bf,.n_bf,2,2,3); KS.create(.n_bf,.n_bf,2,2,3)
      JO.create(.n_bf,.n_bf,2,2,3); KO.create(.n_bf,.n_bf,2,2,3)
      P.create(.n_bf,.n_bf,2,2)
      .density_matrix%general_complex.alpha_alpha_put_to(P(:,:,1,1))
      .density_matrix%general_complex.beta_alpha_put_to(P(:,:,2,1))
      .density_matrix%general_complex.alpha_beta_put_to(P(:,:,1,2))
      .density_matrix%general_complex.beta_beta_put_to(P(:,:,2,2))
      SOx_archive.set(.name,"SOx_integrals")
      SOy_archive.set(.name,"SOy_integrals")
      SOz_archive.set(.name,"SOz_integrals")
      ind_archive.set(.name,"SO_indices")
      .make_gc_so_JK_disk(JS(:,:,:,:,1),KS(:,:,:,:,1),JO(:,:,:,:,1),KO(:,:,:,:,1),P,SOx_archive,ind_archive)
      .make_gc_so_JK_disk(JS(:,:,:,:,2),KS(:,:,:,:,2),JO(:,:,:,:,2),KO(:,:,:,:,2),P,SOy_archive,ind_archive)
      .make_gc_so_JK_disk(JS(:,:,:,:,3),KS(:,:,:,:,3),JO(:,:,:,:,3),KO(:,:,:,:,3),P,SOz_archive,ind_archive)
      P.destroy
      I = (ZERO,ONE)
      a = 1; b = 2; x = 1; y = 2; z = 3
      Faa =  THREE*JO(:,:,a,a,z) +       JO(:,:,b,b,z) + THREE*JS(:,:,a,a,z) -   JS(:,:,b,b,z) &
          +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
          +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
          -    TWO*KO(:,:,b,a,x) -       KO(:,:,a,b,x) -   TWO*KS(:,:,a,b,x) -   KS(:,:,b,a,x) &
          +  I*TWO*KO(:,:,b,a,y) -     I*KO(:,:,a,b,y) - I*TWO*KS(:,:,a,b,y) + I*KS(:,:,b,a,y) &
          -  THREE*KO(:,:,a,a,z) - THREE*KS(:,:,a,a,z)
      Fbb = -THREE*JO(:,:,b,b,z) -       JO(:,:,a,a,z) - THREE*JS(:,:,b,b,z) +   JS(:,:,a,a,z) &
          +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
          +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
          -    TWO*KO(:,:,a,b,x) -       KO(:,:,b,a,x) -   TWO*KS(:,:,b,a,x) -   KS(:,:,a,b,x) &
          -  I*TWO*KO(:,:,a,b,y) + I*KO(:,:,b,a,y)     + I*TWO*KS(:,:,b,a,y) - I*KS(:,:,a,b,y) &
          +  THREE*KO(:,:,b,b,z) + THREE*KS(:,:,b,b,z)
      Fba =    TWO*JO(:,:,a,a,x) +   TWO*JO(:,:,b,b,x) +       JS(:,:,a,a,x) +   JS(:,:,b,b,x) &
          +  I*TWO*JO(:,:,a,a,y) + I*TWO*JO(:,:,b,b,y) +     I*JS(:,:,a,a,y) + I*JS(:,:,b,b,y) &
          -    TWO*KO(:,:,a,a,x) -       KO(:,:,b,b,x) -   TWO*KS(:,:,b,b,x) -   KS(:,:,a,a,x) &
          -  I*TWO*KO(:,:,a,a,y) -     I*KO(:,:,b,b,y) - I*TWO*KS(:,:,b,b,y) - I*KS(:,:,a,a,y) &
          +        KO(:,:,b,a,z) -       KS(:,:,b,a,z)
      KO.destroy; JO.destroy; KS.destroy; JS.destroy
      F => .fock_matrix%general_complex
      fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
      fac = fac * .scfdata%sl_2e_factor
      F.alpha_alpha_plus(Faa,factor=I*fac)
      F.beta_beta_plus(Fbb,factor=I*fac)
      F.beta_alpha_plus(Fba,factor=I*fac)
      Fbb = conjg(transpose(Fba))
      F.alpha_beta_plus(Fbb,factor=-I*fac)
      Fba.destroy; Fbb.destroy; Faa.destroy
          ! .out.set_dbl_width(15)
          ! .out.set_dbl_precision(8)
          ! .out.set_fields(7)
          ! .out.text("F, real:")
          ! .out.put( real(F) )
          ! .out.text("F, imag:")
          ! .out.put( aimag(F) )
          ! stop
    end
  end

  make_gc_so_JK_disk(JS,KS,JO,KO,P,SO_archive,ind_archive)
  ! Make the general complex spin orbit cLassical and Exchange matrices.
    CMAT4 :: JS,KS,JO,KO,P
    ARCHIVE :: SO_archive,ind_archive
    MAT4, PTR   :: S,O
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,n_quartets, m,n
    DBL :: S_abcd,O_abcd
    CDBL :: I
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( SO_archive.exists,  "no spin orbit integral file!")
    ENSURE( ind_archive.exists, "no spin orbit integral index file")
    SO_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    JS = ZERO; KS = ZERO; JO = ZERO; KO = ZERO
    I = (ZERO,ONE)
    n_quartets = .n_shell_quartets
    do
       ind_archive%file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
       S.create(fa,la,fb,lb,fc,lc,fd,ld)
       O.create(fa,la,fb,lb,fc,lc,fd,ld)
       SO_archive%file.read(S)
       SO_archive%file.read(O)
       do a = fa,la
       do b = fb,lb
       do c = fc,lc
       do d = fd,ld
          S_abcd = S(a,b,c,d)
          O_abcd = O(a,b,c,d)
          do m = 1,2
          do n = 1,2
             !
             JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(d,c, m,n)
             JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(c,d, m,n)
             JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(d,c, m,n)
             JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(c,d, m,n)
             JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(b,a, m,n)
             JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(a,b, m,n)
             JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(b,a, m,n)
             JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(a,b, m,n)
             !
             JO(a,b, m,n) = JO(a,b, m,n) + O_abcd*P(d,c, m,n)
             JO(a,b, m,n) = JO(a,b, m,n) - O_abcd*P(c,d, m,n)
             JO(b,a, m,n) = JO(b,a, m,n) + O_abcd*P(d,c, m,n)
             JO(b,a, m,n) = JO(b,a, m,n) - O_abcd*P(c,d, m,n)
             JO(c,d, m,n) = JO(c,d, m,n) + S_abcd*P(b,a, m,n)
             JO(c,d, m,n) = JO(c,d, m,n) - S_abcd*P(a,b, m,n)
             JO(d,c, m,n) = JO(d,c, m,n) + S_abcd*P(b,a, m,n)
             JO(d,c, m,n) = JO(d,c, m,n) - S_abcd*P(a,b, m,n)
             !
             KS(a,d, m,n) = KS(a,d, m,n) + S_abcd*P(b,c, m,n)
             KS(a,c, m,n) = KS(a,c, m,n) + S_abcd*P(b,d, m,n)
             KS(b,d, m,n) = KS(b,d, m,n) - S_abcd*P(a,c, m,n)
             KS(b,c, m,n) = KS(b,c, m,n) - S_abcd*P(a,d, m,n)
             KS(c,b, m,n) = KS(c,b, m,n) + O_abcd*P(d,a, m,n)
             KS(c,a, m,n) = KS(c,a, m,n) + O_abcd*P(d,b, m,n)
             KS(d,b, m,n) = KS(d,b, m,n) - O_abcd*P(c,a, m,n)
             KS(d,a, m,n) = KS(d,a, m,n) - O_abcd*P(c,b, m,n)
             !
             KO(a,d, m,n) = KO(a,d, m,n) + O_abcd*P(b,c, m,n)
             KO(a,c, m,n) = KO(a,c, m,n) - O_abcd*P(b,d, m,n)
             KO(b,d, m,n) = KO(b,d, m,n) + O_abcd*P(a,c, m,n)
             KO(b,c, m,n) = KO(b,c, m,n) - O_abcd*P(a,d, m,n)
             KO(c,b, m,n) = KO(c,b, m,n) + S_abcd*P(d,a, m,n)
             KO(c,a, m,n) = KO(c,a, m,n) - S_abcd*P(d,b, m,n)
             KO(d,b, m,n) = KO(d,b, m,n) + S_abcd*P(c,a, m,n)
             KO(d,a, m,n) = KO(d,a, m,n) - S_abcd*P(c,b, m,n)
          end
          end
       end
       end
       end
       end
       O.destroy; S.destroy
    end
    SO_archive.close
    ind_archive.close
  end

!**********************
! J & K matrix routines
!**********************

  make_r_JK_direct(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a 
  ! symmetric density matrix "P" directly. 
    MAT :: J,K,P
    MAT4, PTR   :: I
    SHELL4 :: shell4
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,atom_a,atom_b,atom_c,atom_d
    DBL :: I_abcd,factor
    J = ZERO
    K = ZERO
    do q = 1,.n_shell_quartets
       if (.scfdata%nddo) then
         .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (atom_a==atom_b AND atom_c==atom_d) then
           .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
         else
           cycle
         end
       else
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       end
       if (shell4.skip_ERI) then
         shell4.destroy_ptr_part
         cycle
       end
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       shell4.get_ERI(I)
       factor = ONE                         ! Evaluate the integrals
       if (a==b) factor = HALF              ! Coincidence factors   
       if (c==d) factor = HALF * factor
       if (a==c AND b==d) factor = HALF * factor
       I = factor * I
       do a = fa,la
       do b = fb,lb
       do c = fc,lc
       do d = fd,ld
          I_abcd = I(a,b,c,d)
          J(a,b) = J(a,b) + I_abcd*P(d,c)
          J(c,d) = J(c,d) + I_abcd*P(b,a)
          K(a,c) = K(a,c) + I_abcd*P(d,b)
          K(a,d) = K(a,d) + I_abcd*P(c,b)
          K(b,c) = K(b,c) + I_abcd*P(d,a)
          K(b,d) = K(b,d) + I_abcd*P(c,a)
       end
       end
       end
       end
       I.destroy
       shell4.destroy_ptr_part
    end
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(K)
    J.make_symmetric
    K.make_symmetric
    J = TWO*J 
  end

  make_r_JK_disk(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a 
  ! symmetric density matrix "P" from disk integral archive "eri_integrals"
    MAT :: J,K,P
    ARCHIVE :: eri_archive,ind_archive
    MAT4, PTR :: I             ! a block of ERI's for shell4
    INT :: q,a,b,c,d
    INT :: fa,la,fb,lb,fc,lc,fd,ld,n_quartets
    DBL :: I_abcd
    eri_archive.set(.name,"eri_integrals")
    ind_archive.set(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J = ZERO
    K = ZERO
    n_quartets = .n_shell_quartets
    q = 0
    do
      ind_archive%file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive%file.read(I)
      do d = fd,ld
      do c = fc,lc
      do b = fb,lb
      do a = fa,la
         I_abcd = I(a,b,c,d)
         J(a,b) = J(a,b) + I_abcd*P(d,c)
         J(c,d) = J(c,d) + I_abcd*P(b,a)
         K(a,c) = K(a,c) + I_abcd*P(d,b)
         K(a,d) = K(a,d) + I_abcd*P(c,b)
         K(b,c) = K(b,c) + I_abcd*P(d,a)
         K(b,d) = K(b,d) + I_abcd*P(c,a)
      end
      end
      end
      end
      I.destroy
    end
    ind_archive.close
    eri_archive.close
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(K)
    J.make_symmetric
    K.make_symmetric
    J = TWO*J
  end

  make_u_JK_direct(J,Ka,Kb,P,Pa,Pb)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT :: J,Ka,Kb,P,Pa,Pb
    MAT4, PTR   :: I
    SHELL4 :: shell4
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,atom_a,atom_b,atom_c,atom_d
    DBL :: I_abcd,factor
    J  = ZERO
    Ka = ZERO
    Kb = ZERO
    do q = 1,.n_shell_quartets
       if (.scfdata%nddo) then
         .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (atom_a==atom_b AND atom_c==atom_d) then
           .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
         else
           cycle
         end
       else
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       end
       if (shell4.skip_ERI) then
         shell4.destroy_ptr_part
         cycle
       end
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       shell4.get_ERI(I)
       factor = ONE                          ! Evaluate the integrals
       if (a==b) factor = HALF               ! Coincidence factors   
       if (c==d) factor = HALF * factor
       if (a==c AND b==d) factor = HALF * factor
       I = factor * I
       do d = fd,ld
       do c = fc,lc
       do b = fb,lb
       do a = fa,la
          I_abcd = I(a,b,c,d)
          J(a,b)  = J(a,b)  + I_abcd*P(d,c)
          J(c,d)  = J(c,d)  + I_abcd*P(b,a)
          Ka(a,c) = Ka(a,c) + I_abcd*Pa(d,b)
          Ka(a,d) = Ka(a,d) + I_abcd*Pa(c,b)
          Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
          Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
          Kb(a,c) = Kb(a,c) + I_abcd*Pb(d,b)
          Kb(a,d) = Kb(a,d) + I_abcd*Pb(c,b)
          Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
          Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
       end
       end
       end
       end
       I.destroy
       shell4.destroy_ptr_part
    end
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(Ka)
    .blockwise_symmetric_fold(Kb)
    J.make_symmetric
    Ka.make_symmetric
    Kb.make_symmetric
    J = TWO*J 
  end

  make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT :: J,Ka,Kb,P,Pa,Pb
    ARCHIVE, PTR :: eri_archive,ind_archive
    MAT4, PTR   :: I
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,n_quartets
    DBL :: I_abcd
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J  = ZERO
    Ka = ZERO
    Kb = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive%file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive%file.read(I)
      do d = fd,ld
      do c = fc,lc
      do b = fb,lb
      do a = fa,la
         I_abcd = I(a,b,c,d)
         J(a,b)  = J(a,b)  + I_abcd*P(d,c)
         J(c,d)  = J(c,d)  + I_abcd*P(b,a)
         Ka(a,c) = Ka(a,c) + I_abcd*Pa(d,b)
         Ka(a,d) = Ka(a,d) + I_abcd*Pa(c,b)
         Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
         Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
         Kb(a,c) = Kb(a,c) + I_abcd*Pb(d,b)
         Kb(a,d) = Kb(a,d) + I_abcd*Pb(c,b)
         Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
         Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
      end
      end
      end
      end
      I.destroy
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(Ka)
    .blockwise_symmetric_fold(Kb)
    J.make_symmetric
    Ka.make_symmetric
    Kb.make_symmetric
    J = TWO*J 
  end

  make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
  ! Make the general complex matrices "J" and exchange matrices 
  ! "Ka", "Kb" and "Kba" from a density matrices "P", "Pa", "Pb" and "Pba"
  ! directly from the integrals.
    MAT :: J,P
    CMAT :: Ka,Kb,Kba,Pa,Pb,Pba
    MAT4, PTR   :: I
    SHELL4, PTR :: shell4
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,atom_a,atom_b,atom_c,atom_d
    DBL :: I_abcd,factor
    J   = ZERO
    Ka  = ZERO
    Kb  = ZERO
    Kba = ZERO
    shell4.create
    do q = 1,.n_shell_quartets
       if (.scfdata%nddo) then
         .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (atom_a==atom_b AND atom_c==atom_d) then
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
         else; cycle
         end
       else
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       end
       if (shell4.skip_ERI) cycle
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       shell4.get_ERI(I)
       factor = ONE                          ! Evaluate the integrals
       if (a==b) factor = HALF               ! Coincidence factors   
       if (c==d) factor = HALF * factor
       if (a==c AND b==d) factor = HALF * factor
       I = factor * I
       do d = fd,ld
       do c = fc,lc
       do b = fb,lb
       do a = fa,la
          I_abcd = I(a,b,c,d)
          J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
          J(c,d)   = J(c,d)   + I_abcd*P(b,a)
          Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric but must be folded
          Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  
          Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
          Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
          Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric but must be folded
          Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  
          Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
          Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
          Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
          Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d) 
          Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
          Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
          Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
          Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
          Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
          Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
       end
       end
       end
       end
       I.destroy
    end
    shell4.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_hermitian_fold(Ka)
    .blockwise_hermitian_fold(Kb)
    J.make_symmetric
    Ka.make_hermitian
    Kb.make_hermitian
    J = TWO*J 
  end

  make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT :: J,P
    CMAT :: Ka,Kb,Kba,Pa,Pb,Pba
    ARCHIVE, PTR :: eri_archive,ind_archive
    MAT4, PTR   :: I
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,n_quartets
    DBL :: I_abcd
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J   = ZERO
    Ka  = ZERO
    Kb  = ZERO
    Kba = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive%file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive%file.read(I)
      do d = fd,ld
      do c = fc,lc
      do b = fb,lb
      do a = fa,la
          I_abcd = I(a,b,c,d)
          J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
          J(c,d)   = J(c,d)   + I_abcd*P(b,a)
          Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric but must be folded
          Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  
          Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
          Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
          Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric but must be folded
          Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  
          Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
          Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
          Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
          Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d) 
          Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
          Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
          Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
          Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
          Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
          Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
      end
      end
      end
      end
      I.destroy
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_hermitian_fold(Ka)
    .blockwise_hermitian_fold(Kb)
    J.make_symmetric
    Ka.make_hermitian
    Kb.make_hermitian
    J = TWO*J 
  end
 
  weight_diagonal_blocks(X,fac) [pure]
  ! Weight the diagonal blocks of matrix "X" by "fac"
     IN :: self
     MAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac*X(f:l,f:l)
     end
  end
 
  weight_diagonal_blocks(X,fac) [pure]
  ! Weight the diagonal blocks of matrix "X" by "fac"
     IN :: self
     CMAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac*X(f:l,f:l)
     end
  end

  set_diagonal_blocks(X,fac) [pure]
  ! Set the diagonal blocks of matrix "X" to "fac"
     IN :: self
     MAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac
     end
  end

  blockwise_symmetric_fold(X)
  ! Symmetrically fold the matrix "X" blockwise
     MAT :: X
     INT :: a,fa,la,b,fb,lb
     do a = 1,.n_shell
     do b = 1,a
        fa = .first_basis_fn_for_shell(a)
        la = .last_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        lb = .last_basis_fn_for_shell(b)
        X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(X(fb:lb,fa:la))
     end
     end
  end

  blockwise_hermitian_fold(X)
  ! Hermitian fold the matrix "X" blockwise
     CMAT :: X
     INT :: a,fa,la,b,fb,lb
     do a = 1,.n_shell
     do b = 1,a
        fa = .first_basis_fn_for_shell(a)
        la = .last_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        lb = .last_basis_fn_for_shell(b)
        X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(conjg(X(fb:lb,fa:la)))
     end
     end
  end


! ******************
! Constraint methods
! ******************

  constrained_scf_rhf [leaky]
  ! Do a restricted Hartree-Fock calculation. The following objects 
  ! are destroyed and made new:
  !   .overlap_matrix, .core_matrix, .fock_matrix, 
  ! The following objects are produced as results:
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! The following objects are deleted from memory after execution:
  !   .overlap_matrix, .core_matrix, .fock_matrix
    MAT, PTR :: MO,temp,S
    MAT, PTR :: constraint,first_fock
    ARCHIVE :: archive
    STR :: kind
    DBL :: max_diff, mean_diff, diff, total
    INT :: i,j

    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    DIE_IF( .mult/=1,"this is not a singlet state")
    kind = .scfdata.spinorbital_kind

    .get_initial_guess
    .make_fock_matrix

    .get_ft_ints
    .make_structure_factors
    .xtal.update_scaled_gof_parameters

    .scfdata.set(nuclear_energy=.nuclear_energy, put_file=.out)
    .scfdata.reset(energy=.scf_energy, kinetic_energy=.kinetic_energy, &
                   chi2=.xtal%chi2, gof=.xtal%gof, r_factor=.xtal%r_factor, &
                   weighted_r_factor=.xtal%weighted_r_factor)
    .scfdata.update(energy=.scf_energy, kinetic_energy=.kinetic_energy, &
                    chi2=.xtal%chi2, chi2_in_F2=.xtal%chi2_in_F2, &
                    gof=.xtal%gof, r_factor=.xtal%r_factor, &
                    weighted_r_factor=.xtal%weighted_r_factor)
    .scfdata.put_banner

    if (kind == "restricted") then
      if ( .molecular_orbitals.destroyed(kind) ) .make_fock_guess
      MO => .molecular_orbitals%restricted
    else
      DIE("can only do restricted calculations.")
    end

    do
      .scfdata%diis.cleanup

      do
        temp.create( .n_bf, .n_bf)
        S.create( .n_bf, .n_bf)
        .get_overlap_matrix(S)
        temp.to_product(MO,S,transpose_a=TRUE)
        S.destroy

        constraint.create( .n_bf, .n_bf)
        .make_constraint(constraint, .scfdata%lambda / (.scfdata%lambda + 1) )
        constraint.change_basis(MO)          ! Zero out the occ-occ and vir-vir
        constraint(:.n_a, :.n_a) = ZERO      ! blocks of the constraint matrix
        constraint(.n_a+1:, .n_a+1:) = ZERO  ! to improve convergence.

        .fock_matrix%restricted.change_basis(MO)
        .fock_matrix%restricted(.n_a+1:,:.n_a).to_product( ONE/(.scfdata%lambda+1) )
        .fock_matrix%restricted(:.n_a,.n_a+1:).to_product( ONE/(.scfdata%lambda+1) )
        .fock_matrix%restricted = .fock_matrix%restricted + constraint
        .fock_matrix%restricted.change_basis(temp) ! Back to AO basis.
        constraint.destroy
        temp.destroy

        .extrapolate_scf
        .update_molecular_orbitals
        S.create( .n_bf, .n_bf)
        .molecular_orbitals.schmidt_orthonormalise(S)
        S.destroy
        .make_scf_density_matrix
        .save_scf_results
        .make_fock_matrix                      ! To get new Hartree-Fock energy.

        if (.optimise_thermals) then
          .fit_thermal_parameters
        else
          .make_structure_factors
          .xtal.update_scaled_gof_parameters
        end

        .scfdata.update(energy=.scf_energy, kinetic_energy=.kinetic_energy, &
                        chi2=.xtal%chi2, chi2_in_F2=.xtal%chi2_in_F2, &
                        gof=.xtal%gof, r_factor=.xtal%r_factor, &
                        weighted_r_factor=.xtal%weighted_r_factor)
        .scfdata.put_results
        if (.scfdata.scf_done) exit
      end
      .scfdata.update_lambda

      ! You can comment this section out if you want.  It is self contained.
      if (.scfdata%lambda_iteration == 1) then
        archive.set(.name,"first_fock",kind=kind)
        archive.write(.fock_matrix%restricted)
      else
        first_fock.create( .n_bf, .n_bf)
        archive.set(.name,"first_fock",kind=kind)
        archive.read(first_fock)
        mean_diff = ZERO; max_diff = ZERO; total = ZERO
        do i = 1, .n_bf
          do j = 1, .n_bf
            diff = abs(first_fock(i,j) - .fock_matrix%restricted(i,j))
            mean_diff = mean_diff + diff
            total = total + abs(first_fock(i,j))
            if (diff > max_diff) max_diff = max_diff + diff
          end
        end
        first_fock.destroy
        mean_diff = mean_diff / (.n_bf * .n_bf)
        .out.text("Fock matrix statistics, AO basis.")
        .out.show("Magnitude first Fock matrix   = ",total)
        .out.show("Mean deviation in Fock matrix = ",mean_diff)
        .out.show("Mean deviation as a fraction  = ",mean_diff/total)
        .out.show("Max deviation in Fock matrix  = ",max_diff)
        .out.show("Max deviation as a fraction   = ",max_diff/total)
        .out.dash(dbl_fields=5,int_fields=1)
        .out.flush
      end

      if (.optimise_thermals) .put_thermal_tensors
      if (.scfdata.exceeded_lambda_max) exit
    end

    .xtal.scale_Fc
    .xtal.put_reflection_data(.out)
    .scfdata%diis.delete_archives
  end

  make_constraint(constraint,lambda)
    MAT :: constraint
    DBL, IN :: lambda
    ARCHIVE :: archive
    CMAT3, PTR :: ft_ints
    VEC, PTR :: Fc,Fexp,sig,fac_times_alpha,alpha
    DBL :: sn,fac
    INT :: q,a,b,fa,la,fb,lb,n,i,j,n_refl

    Fc => .xtal%F_calc
    Fexp => .xtal%F_exp
    sig => .xtal%sigma
    n_refl = .xtal%n_refl
    fac = TWO*lambda/n_refl

    fac_times_alpha.create(n_refl)

    alpha.create(n_refl)
    alpha = .xtal.extinction_correction
    do n=1,n_refl
      sn = abs(Fc(n))/Fc(n)
      fac_times_alpha(n)=fac*alpha(n)*(alpha(n)*Fc(n)-sn*Fexp(n))/(sig(n)*sig(n))
    end
    alpha.destroy

    archive.set(.name,"ft_ints")
    archive.open(for="read-only",buffered=TRUE,type="cdbl")
    constraint=ZERO
    do q=1, .n_shell_pairs
      .get_shell_pair(q,a,b,fa,la,fb,lb)
      ft_ints.create((/1,n_refl/),(/fa,la/),(/fb,lb/))
      archive%file.read(ft_ints)
      do i = fa,la
        do j = fb,min(lb,i)
          constraint(i,j) = constraint(i,j) + sum( fac_times_alpha(:) * ft_ints(:,i,j) )
        end
      end
      ft_ints.destroy
    end
    constraint.make_symmetric

    archive.close
    fac_times_alpha.destroy
  end

end 
