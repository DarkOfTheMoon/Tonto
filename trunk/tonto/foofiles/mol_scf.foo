! $Id$
!-------------------------------------------------------------------------------
!
! MOL: scf routines.
!
!-------------------------------------------------------------------------------
module MOL_SCF

   use TYPES
   use ERROR
   use MM

   use BUFFER
   use STR
   use INT
   use DBL
   use VEC
   use IVEC
   use MAT
   use MAT3
   use MAT4
   use CMAT
   use CMAT3
   use OPVEC
   use OPMAT

   use INPUT
   use OUTPUT
   use ARCHIVE

   use FILE
   use SHELL2
   use SHELL4
   use ATOM

   use ATOMVEC
   use VECVEC
   use IVECVEC
   use MATVEC
   use SCFDATA
   use VECDIIS
   use POINTGROUP
   use XTAL
   use TIME

   use MOL_COMMON
   use MOL_XTAL
   use MOL_IO
   use MOL_INTEGRALS

   implicit none         

#  include "macros"
#  include "mol_scf.int"

contains

   set_scf_defaults [leaky]
   ! Set up scf defaults for molecule
      .scfdata.destroy
      .scfdata.create
      if (.mult==1) .scfdata%kind = "rhf"
      if (.mult/=1) .scfdata%kind = "uhf"
      .scfdata%using_diis = TRUE
      .scfdata%direct = FALSE
      .scfdata%diis.set_archive_root_name(.name) 
      .scfdata%diis.set_archive_name("fock_matrix,DIIS")
   end

   make_molecule_from_atom(n,mol) [leaky]
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
      INT :: n
      MOL :: mol
      ENSURE(n<=.n_atom,"atom number n too big")
      mol%atom.create(1)
      mol%atom = .atom(n) ! WARNING: dont destroy ptr parts of mol%atom !
      mol%atom(1)%pos = (/ZERO,ZERO,ZERO/)
      mol.set_defaults
      mol%name  =  .name.trim // "_" // (.atom(n)%label).trim
      mol%basis => .basis ! WARNING: dont destroy basis of mol !
      mol.set_basis_info
      mol.set_scf_defaults
   end

!*********************
! Fock matrix routines
!*********************

  get_fock_matrix [leaky]
  ! Get the Fock matrix. If already in memory, do nothing. Else if 
  ! the archive file exists, read it. Otherwise make it.
     ARCHIVE :: archive
     STR :: kind
     kind = .scfdata.spinorbital_kind
     archive.set(.name,"fock_matrix",kind)
     if ( archive.exists) then; archive.read(.fock_matrix)
     else;                      .make_fock_matrix
     end
  end

  make_fock_matrix(core,r12) [leaky]
  ! If core is present and FALSE, the core hamiltonian is not added
  ! If r12  is present and FALSE, the r12 part is not computed
    BIN, optional :: core,r12
    BIN :: direct
    STR :: scf_kind 
    scf_kind = .scfdata%kind 
    direct = .scfdata%direct 
    if (NOT direct) .get_eri_integrals
    select case (scf_kind)
       case ("rhf","restricted_hartree_fock", &
             "xray_rhf","xray_constrained_restricted_hartree_fock")
                                                            .make_r_fock(direct,core,r12)
       case("rohf","restricted_open_shell_hartree_fock");   .make_ro_fock(direct,core,r12)
       case("uhf","unrestricted_hartree_fock");             .make_u_fock(direct,core,r12)
       case("gchf","cghf", &
            "general_complex_hartree_fock","complex_general_hartree_fock")
                                                            .make_gc_fock(direct,core,r12) 
       case default; DIE("unknown scf kind, "// scf_kind.trim)
    end
  end

  add_core_hamiltonian(F)
  ! Add the core hamiltonain to "F"
     MAT :: F
     MAT, PTR :: H
     H.create( .n_bf, .n_bf)
     .get_core_matrix(H)
     F = H + F
     H.destroy
  end

  add_core_hamiltonian(F)
  ! Add the core hamiltonain to "F"
     CMAT :: F
     MAT, PTR :: H
     H.create( .n_bf, .n_bf)
     .get_core_matrix(H)
     F = H + F
     H.destroy
  end

  make_r_fock(direct,core,r12) [leaky]
  ! Make a new restricted Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    MAT, PTR :: J,K,P,F
    BIN :: do_direct,add_core,add_r12
    ENSURE( .density_matrix%restricted.created, "no density matrix")
    .fock_matrix.destroy("restricted")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    F.create(.n_bf,.n_bf)
    F = ZERO
    if (add_r12) then
       P => .density_matrix%restricted
       J.create( .n_bf, .n_bf)
       K.create( .n_bf, .n_bf)
       if (do_direct) then; .make_r_JK_direct(J,K,P)
       else;                .make_r_JK_disk(J,K,P)
       end
       F = J - HALF*K 
       K.destroy
       J.destroy
    end
    if (add_core) .add_core_hamiltonian(F)
    .fock_matrix%restricted => F
  end

  make_u_fock(direct,core,r12) [leaky]
  ! Make a new unrestricted Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    MAT, PTR :: J,Ka,Kb,P,Pa,Pb,Fa,Fb
    BIN :: do_direct,add_core,add_r12
    ENSURE( .density_matrix%alpha.created, "no density matrix")
    ENSURE( .density_matrix%beta.created, "no density matrix")
    .fock_matrix.destroy("unrestricted")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core))   add_core = core
    if (present(r12))    add_r12  = r12
    Fa.create(.n_bf,.n_bf)
    Fb.create(.n_bf,.n_bf)
    Fa = ZERO
    Fb = ZERO
    if (add_r12) then
       Pa => .density_matrix%alpha
       Pb => .density_matrix%beta
       J.create(.n_bf,.n_bf)
       Ka.create(.n_bf,.n_bf)
       Kb.create(.n_bf,.n_bf)
       P.create(.n_bf,.n_bf)
       P  = Pa + Pb
       if (do_direct) then; .make_u_JK_direct(J,Ka,Kb,P,Pa,Pb)
       else;                .make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
       end
       P.destroy
       Fa = J - Ka 
       Fb = J - Kb 
       Kb.destroy
       Ka.destroy
       J.destroy
    end
    if (add_core) .add_core_hamiltonian(Fa)
    if (add_core) .add_core_hamiltonian(Fb)
    .fock_matrix%alpha => Fa
    .fock_matrix%beta  => Fb
  end

  make_ro_fock(direct,core,r12) [leaky]
  ! Make a new restricted open shell Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    MAT, PTR :: F,Fa,Fb,S,W
    ENSURE( .molecular_orbitals%restricted.created, "no orbitals")
    .make_u_fock(direct,core,r12)
    .fock_matrix.destroy("restricted")
    .fock_matrix.create("restricted")
    F => .fock_matrix%restricted
    Fa.create(.n_bf,.n_bf); Fa = .fock_matrix%alpha
    Fb.create(.n_bf,.n_bf); Fb = .fock_matrix%beta
    Fa.change_basis(.molecular_orbitals%restricted)
    Fb.change_basis(.molecular_orbitals%restricted)
    F = HALF*(Fa+Fb)
    F(.n_b+1:.n_a,     1:.n_b) = Fb(.n_b+1:.n_a,     1:.n_b)
    F(     1:.n_b,.n_b+1:.n_a) = Fb(     1:.n_b,.n_b+1:.n_a)
    F(.n_a+1:    ,.n_b+1:.n_a) = Fa(.n_a+1:    ,.n_b+1:.n_a)
    F(.n_b+1:.n_a,.n_a+1:    ) = Fa(.n_b+1:.n_a,.n_a+1:    )
    S => Fb; .get_overlap_matrix(S)
    W => Fa; W.to_product(.molecular_orbitals%restricted,S,transpose_a=TRUE)
    F.change_basis(W) ! change to AO basis
    Fb.destroy
    Fa.destroy
  end

  make_gc_fock(direct,core,r12) [leaky]
  ! Make a new complex general Fock matrix. 
  ! If present and TRUE , "direct" means calculate integrals on the fly
  ! If present and FALSE, "core" removes the core matrix contribution
  ! If present and FALSE, "r12"  removes the two electron contribution
    BIN, optional :: direct,core,r12
    CMAT, PTR :: Ka,Kb,Kba,P,Pa,Pb,Pba,F
    MAT, PTR :: J
    BIN :: do_direct,add_core,add_r12
    .fock_matrix.destroy("general_complex")
    do_direct= FALSE
    add_core = TRUE
    add_r12  = TRUE
    if (present(direct)) do_direct = direct
    if (present(core)) add_core = core
    if (present(r12))  add_r12  = r12
    F.create(2*.n_bf,2*.n_bf)
    F = ZERO
    if (add_r12) then
       Pa  => .density_matrix%general_complex.alpha_alpha
       Pb  => .density_matrix%general_complex.beta_beta
       Pba => .density_matrix%general_complex.beta_alpha
       J.create(.n_bf,.n_bf)
       Ka.create(.n_bf,.n_bf)
       Kb.create(.n_bf,.n_bf)
       Kba.create(.n_bf,.n_bf)
       P.create(.n_bf,.n_bf)
       P  = Pa + Pb
       if (do_direct) then; .make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
       else;                .make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
       end
       P.destroy
       F.set_alpha_alpha(J)
       F.set_beta_beta(J)
       F.minus_alpha_alpha(Ka)
       F.minus_beta_beta(Kb)
       F.minus_beta_alpha(Kba)
       Kba.destroy
       Kb.destroy
       Ka.destroy
       J.destroy
    end
    if (add_core) then
       .add_core_hamiltonian( F.alpha_alpha)
       .add_core_hamiltonian( F.beta_beta)
    end
    F.make_hermitian
    .fock_matrix%general_complex => F
  end

!**********************
! J & K matrix routines
!**********************

  make_r_JK_direct(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a 
  ! symmetric density matrix "P" directly. 
    MAT :: J,K,P
    MAT4, PTR   :: I
    SHELL4, PTR :: shell4
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,atom_a,atom_b,atom_c,atom_d
    DBL :: I_abcd,factor
    J = ZERO
    K = ZERO
    shell4.create
    do q = 1,.n_shell_quartets
       if (.scfdata%NDDO) then
         .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (atom_a==atom_b OR atom_c==atom_d) cycle
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       else
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       end
       if (shell4.skip_ERI) cycle
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       shell4.get_ERI(I)
       factor = ONE                         ! Evaluate the integrals
       if (a==b) factor = HALF              ! Coincidence factors   
       if (c==d) factor = HALF * factor
       if (a==c AND b==d) factor = HALF * factor
       I = factor * I
       do a = fa,la
       do b = fb,lb
       do c = fc,lc
       do d = fd,ld
          I_abcd = I(a,b,c,d)
          J(a,b) = J(a,b) + I_abcd*P(d,c)
          J(c,d) = J(c,d) + I_abcd*P(b,a)
          K(a,c) = K(a,c) + I_abcd*P(d,b)
          K(a,d) = K(a,d) + I_abcd*P(c,b)
          K(b,c) = K(b,c) + I_abcd*P(d,a)
          K(b,d) = K(b,d) + I_abcd*P(c,a)
       end
       end
       end
       end
       I.destroy
    end
    shell4.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(K)
    J.make_symmetric
    K.make_symmetric
    J = TWO*J 
  end

  make_r_JK_disk(J,K,P)
  ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a 
  ! symmetric density matrix "P" from disk integral archive "eri_integrals"
    MAT :: J,K,P
    ARCHIVE :: eri_archive,ind_archive
    MAT4, PTR :: I             ! a block of ERI's for shell4
    INT :: q,a,b,c,d
    INT :: fa,la,fb,lb,fc,lc,fd,ld,n_quartets
    DBL :: I_abcd
    eri_archive.set(.name,"eri_integrals")
    ind_archive.set(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J = ZERO
    K = ZERO
    n_quartets = .n_shell_quartets
    q = 0
    do
      ind_archive%file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive%file.read(I)
      do a = fa,la
      do b = fb,lb
      do c = fc,lc
      do d = fd,ld
         I_abcd = I(a,b,c,d)
         J(a,b) = J(a,b) + I_abcd*P(d,c)
         J(c,d) = J(c,d) + I_abcd*P(b,a)
         K(a,c) = K(a,c) + I_abcd*P(d,b)
         K(a,d) = K(a,d) + I_abcd*P(c,b)
         K(b,c) = K(b,c) + I_abcd*P(d,a)
         K(b,d) = K(b,d) + I_abcd*P(c,a)
      end
      end
      end
      end
      I.destroy
    end
    ind_archive.close
    eri_archive.close
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(K)
    J.make_symmetric
    K.make_symmetric
    J = TWO*J
  end

  make_u_JK_direct(J,Ka,Kb,P,Pa,Pb)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb" matrix from a 
  ! symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT :: J,Ka,Kb,P,Pa,Pb
    MAT4, PTR   :: I
    SHELL4, PTR :: shell4
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,atom_a,atom_b,atom_c,atom_d
    DBL :: I_abcd,factor
    J  = ZERO
    Ka = ZERO
    Kb = ZERO
    shell4.create
    do q = 1,.n_shell_quartets
       if (.scfdata%NDDO) then
         .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (atom_a==atom_b OR atom_c==atom_d) cycle
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       else
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       end
       if (shell4.skip_ERI) cycle
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       shell4.get_ERI(I)
       factor = ONE                          ! Evaluate the integrals
       if (a==b) factor = HALF               ! Coincidence factors   
       if (c==d) factor = HALF * factor
       if (a==c AND b==d) factor = HALF * factor
       I = factor * I
       do a = fa,la
       do b = fb,lb
       do c = fc,lc
       do d = fd,ld
          I_abcd = I(a,b,c,d)
          J(a,b)  = J(a,b)  + I_abcd*P(d,c)
          J(c,d)  = J(c,d)  + I_abcd*P(b,a)
          Ka(a,c) = Ka(a,c) + I_abcd*Pa(d,b)
          Ka(a,d) = Ka(a,d) + I_abcd*Pa(c,b)
          Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
          Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
          Kb(a,c) = Kb(a,c) + I_abcd*Pb(d,b)
          Kb(a,d) = Kb(a,d) + I_abcd*Pb(c,b)
          Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
          Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
       end
       end
       end
       end
       I.destroy
    end
    shell4.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(Ka)
    .blockwise_symmetric_fold(Kb)
    J.make_symmetric
    Ka.make_symmetric
    Kb.make_symmetric
    J = TWO*J 
  end

  make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT :: J,Ka,Kb,P,Pa,Pb
    ARCHIVE, PTR :: eri_archive,ind_archive
    MAT4, PTR   :: I
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,n_quartets
    DBL :: I_abcd
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J  = ZERO
    Ka = ZERO
    Kb = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive%file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive%file.read(I)
      do a = fa,la
      do b = fb,lb
      do c = fc,lc
      do d = fd,ld
         I_abcd = I(a,b,c,d)
         J(a,b)  = J(a,b)  + I_abcd*P(d,c)
         J(c,d)  = J(c,d)  + I_abcd*P(b,a)
         Ka(a,c) = Ka(a,c) + I_abcd*Pa(d,b)
         Ka(a,d) = Ka(a,d) + I_abcd*Pa(c,b)
         Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
         Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
         Kb(a,c) = Kb(a,c) + I_abcd*Pb(d,b)
         Kb(a,d) = Kb(a,d) + I_abcd*Pb(c,b)
         Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
         Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
      end
      end
      end
      end
      I.destroy
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_symmetric_fold(Ka)
    .blockwise_symmetric_fold(Kb)
    J.make_symmetric
    Ka.make_symmetric
    Kb.make_symmetric
    J = TWO*J 
  end

  make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
  ! Make the general complex matrices "J" and exchange matrices 
  ! "Ka", "Kb" and "Kba" from a density matrices "P", "Pa", "Pb" and "Pba"
  ! directly from the integrals.
    MAT :: J
    CMAT :: Ka,Kb,Kba,P,Pa,Pb,Pba
    MAT4, PTR   :: I
    SHELL4, PTR :: shell4
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,atom_a,atom_b,atom_c,atom_d
    DBL :: I_abcd,factor
    J   = ZERO
    Ka  = ZERO
    Kb  = ZERO
    Kba = ZERO
    shell4.create
    do q = 1,.n_shell_quartets
       if (.scfdata%NDDO) then
         .get_shell_quartet(q,shell4,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (atom_a==atom_b OR atom_c==atom_d) cycle
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       else
         .get_shell_quartet(q,shell4,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld)
       end
       if (shell4.skip_ERI) cycle
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       shell4.get_ERI(I)
       factor = ONE                          ! Evaluate the integrals
       if (a==b) factor = HALF               ! Coincidence factors   
       if (c==d) factor = HALF * factor
       if (a==c AND b==d) factor = HALF * factor
       I = factor * I
       do a = fa,la
       do b = fb,lb
       do c = fc,lc
       do d = fd,ld
          I_abcd = I(a,b,c,d)
          J(a,b)   = J(a,b)   + I_abcd*P(d,c)
          J(c,d)   = J(c,d)   + I_abcd*P(b,a)
          Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(d,b)
          Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(c,b)
          Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(d,a)
          Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(c,a)
          Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(d,b)
          Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(c,b)
          Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(d,a)
          Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(c,a)
          Kba(a,c) = Kba(a,c) + I_abcd*Pba(d,b)
          Kba(a,d) = Kba(a,d) + I_abcd*Pba(c,b)
          Kba(b,c) = Kba(b,c) + I_abcd*Pba(d,a)
          Kba(b,d) = Kba(b,d) + I_abcd*Pba(c,a)
          Kba(c,a) = Kba(c,a) + I_abcd*Pba(b,d)
          Kba(d,a) = Kba(d,a) + I_abcd*Pba(b,c)
          Kba(c,b) = Kba(c,b) + I_abcd*Pba(a,d)
          Kba(d,b) = Kba(d,b) + I_abcd*Pba(a,c)
       end
       end
       end
       end
       I.destroy
    end
    shell4.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_hermitian_fold(Ka)
    .blockwise_hermitian_fold(Kb)
    J.make_symmetric
    Ka.make_hermitian
    Kb.make_hermitian
    J = TWO*J 
  end

  make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
  ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
  ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly. 
    MAT :: J
    CMAT :: Ka,Kb,Kba,P,Pa,Pb,Pba
    ARCHIVE, PTR :: eri_archive,ind_archive
    MAT4, PTR   :: I
    INT :: q, a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,n_quartets
    DBL :: I_abcd
    eri_archive.create(.name,"eri_integrals")
    ind_archive.create(.name,"eri_index")
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    ENSURE( eri_archive.exists, "no integral file")
    ENSURE( ind_archive.exists, "no integral index file")
    eri_archive.open(for="read-only",buffered=TRUE,type="dbl")
    ind_archive.open(for="read-only",buffered=TRUE,type="int")
    J   = ZERO
    Ka  = ZERO
    Kb  = ZERO
    Kba = ZERO
    n_quartets = .n_shell_quartets
    do
      ind_archive%file.read(q)
      if (q > n_quartets) exit
      .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
      I.create(fa,la,fb,lb,fc,lc,fd,ld)
      eri_archive%file.read(I)
      do a = fa,la
      do b = fb,lb
      do c = fc,lc
      do d = fd,ld
          I_abcd = I(a,b,c,d)
          J(a,b)   = J(a,b)   + I_abcd*P(d,c)
          J(c,d)   = J(c,d)   + I_abcd*P(b,a)
          Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(d,b)
          Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(c,b)
          Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(d,a)
          Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(c,a)
          Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(d,b)
          Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(c,b)
          Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(d,a)
          Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(c,a)
          Kba(a,c) = Kba(a,c) + I_abcd*Pba(d,b)
          Kba(a,d) = Kba(a,d) + I_abcd*Pba(c,b)
          Kba(b,c) = Kba(b,c) + I_abcd*Pba(d,a)
          Kba(b,d) = Kba(b,d) + I_abcd*Pba(c,a)
          Kba(c,a) = Kba(c,a) + I_abcd*Pba(b,d)
          Kba(d,a) = Kba(d,a) + I_abcd*Pba(b,c)
          Kba(c,b) = Kba(c,b) + I_abcd*Pba(a,d)
          Kba(d,b) = Kba(d,b) + I_abcd*Pba(a,c)
      end
      end
      end
      end
      I.destroy
    end
    ind_archive.destroy
    eri_archive.destroy
    .weight_diagonal_blocks(J,TWO)
    .blockwise_hermitian_fold(Ka)
    .blockwise_hermitian_fold(Kb)
    J.make_symmetric
    Ka.make_hermitian
    Kb.make_hermitian
    J = TWO*J 
  end
 
  weight_diagonal_blocks(X,fac) [pure]
  ! Weight the diagonal blocks of matrix "X" by "fac"
     IN :: self
     MAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac*X(f:l,f:l)
     end
  end

  set_diagonal_blocks(X,fac) [pure]
  ! Set the diagonal blocks of matrix "X" to "fac"
     IN :: self
     MAT, INOUT :: X
     DBL, IN :: fac
     INT :: n,f,l
     do n = 1,.n_shell
        f = .first_basis_fn_for_shell(n)
        l = .last_basis_fn_for_shell(n)
        X(f:l,f:l) = fac
     end
  end

  blockwise_symmetric_fold(X)
  ! Symmetrically fold the matrix "X" blockwise
     MAT :: X
     INT :: a,fa,la,b,fb,lb
     do a = 1,.n_shell
     do b = 1,a
        fa = .first_basis_fn_for_shell(a)
        la = .last_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        lb = .last_basis_fn_for_shell(b)
        X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(X(fb:lb,fa:la))
     end
     end
  end

  blockwise_hermitian_fold(X)
  ! Hermitian fold the matrix "X" blockwise
     CMAT :: X
     INT :: a,fa,la,b,fb,lb
     do a = 1,.n_shell
     do b = 1,a
        fa = .first_basis_fn_for_shell(a)
        la = .last_basis_fn_for_shell(a)
        fb = .first_basis_fn_for_shell(b)
        lb = .last_basis_fn_for_shell(b)
        X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(conjg(X(fb:lb,fa:la)))
     end
     end
  end

!************
! SCF routine
!************

  scf [leaky]
  ! Do an SCF calculation. The following :
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! are produced as results.
    select case (.scfdata%kind)
      case ("xray_rhf","xray_constrained_restricted_hartree_fock")
        .constrained_scf_rhf
      case default;
        .hf_scf
    end
  end

  hf_scf [leaky]
  ! Do a Hartree-Fock SCF calculation. The following :
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! are produced as results.
    MAT, PTR :: S
    STR :: kind
    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    .get_initial_guess
    .make_fock_matrix

    .scfdata.set(nuclear_energy=.nuclear_energy, put_file=.out)
    .scfdata.reset(energy=.scf_energy, kinetic_energy=.kinetic_energy)

    kind = .scfdata.spinorbital_kind
    if ( .molecular_orbitals.destroyed(kind) ) .make_fock_guess
    S.create( .n_bf, .n_bf)
    .get_overlap_matrix(S)
    do
      .extrapolate_scf
      .update_molecular_orbitals
      .molecular_orbitals.schmidt_orthonormalise(S)
      .make_scf_density_matrix
      .save_scf_results
      .make_fock_matrix
      .scfdata.update( energy=.scf_energy, kinetic_energy=.kinetic_energy )
      .scfdata.put_results
      if (.scfdata.scf_done) exit
    end
    .scfdata.cleanup_diis
    S.destroy
    .fock_matrix.destroy(kind)
  end

  update_molecular_orbitals
  ! Solve for the molecular orbitals.  Requires a set of old molecular orbitals.
  ! The new molecular orbitals "cU" are found from the old MOs "c" by solving :
  ! (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    STR :: kind
    VEC, PTR :: e
    CMAT, PTR :: MOc,Fc
    kind = .scfdata.spinorbital_kind
    ENSURE( .molecular_orbitals.created(kind), "need old MOs")
    select case (kind)
      case ("restricted")
        .update_r_MO(.orbital_energies%restricted,.molecular_orbitals%restricted,.fock_matrix%restricted)
      case ("unrestricted")
        .update_r_MO(.orbital_energies%alpha,.molecular_orbitals%alpha, .fock_matrix%alpha)
        .update_r_MO(.orbital_energies%beta ,.molecular_orbitals%beta , .fock_matrix%beta )
      case ("general_complex")
        e   => .orbital_energies%general
        MOc => .molecular_orbitals%general_complex
        Fc  => .fock_matrix%general_complex
        .update_gc_MO(e,MOc,Fc)
      case default; DIE("don't know what to do with " // trim(kind))
    end
  end

  update_r_MO(MO_energies,MO,F)
  ! Solve for the new molecular orbital energies "MO_energies" and the new 
  ! molecular orbitals "MO", given an initial old set (in "MO") and a fock matrix "F".
  ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by solving :
  ! (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    VEC :: MO_energies
    MAT :: MO,F
    MAT, PTR :: G,U
    INT :: i

    G.create(.n_bf,.n_bf)
    U.create(.n_bf,.n_bf)
    G = F
    G.change_basis(MO)

    ! Level shifting
    if (NOT (.scfdata%using_diis AND .scfdata%iteration >= .scfdata%diis%start)) then
      do i = .n_a + 1, .n_bf
        G(i,i) = .scfdata%level_shift + G(i,i)
      end
    end

    G.solve_eigenproblem(MO_energies,U)
    G.to_product(MO,U)
    MO = G
    U.destroy
    G.destroy
  end

  update_gc_MO(MO_energies,MO,F)
  ! Solve for the new molecular orbital energies "MO_energies" and the new 
  ! molecular orbitals "MO", given an initial old set (in "MO") and a fock matrix "F".
  ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by solving :
  ! (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
    VEC :: MO_energies
    CMAT :: MO,F
    CMAT, PTR :: G,U
    INT :: i
    G.create(2*.n_bf,2*.n_bf)
    U.create(2*.n_bf,2*.n_bf)
    G = F
    G.change_basis(MO)
    ! Level shifting
    if (NOT (.scfdata%using_diis AND .scfdata%iteration >= .scfdata%diis%start)) then
      do i = .n_e + 1, 2*.n_bf
        G(i,i) = .scfdata%level_shift + G(i,i)
      end
    end
    G.solve_eigenproblem(MO_energies,U)
    G.to_product(MO,U)
    MO = G
    U.destroy
    G.destroy
  end

  kinetic_energy result (res)
  ! Evaluates the SCF kinetic energy as a trace of ".density_matrix" with the
  ! ".kinetic matrix". 
    DBL :: res
    STR :: kind
    MAT, PTR :: H
    CMAT, PTR :: HH
    kind = .scfdata.spinorbital_kind
    ENSURE( .density_matrix.created(kind), "no density matrix")
    select case (kind)
       case ("restricted")
          H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
          res = - .density_matrix%restricted.trace_of_product(H)
          H.destroy
       case ("unrestricted")
          H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
          res = - .density_matrix%alpha.trace_of_product(H)
          res = - .density_matrix%beta.trace_of_product(H) + res
          H.destroy
       case ("general_complex")
          HH.create(2*.n_bf,2*.n_bf); HH=ZERO
          H.create(.n_bf,.n_bf)
          .get_kinetic_matrix(H)
          HH.set_alpha_alpha(H)
          HH.set_beta_beta(H)
          H.destroy
          res = - .density_matrix%general_complex.trace_of_product(HH)
          HH.destroy
       case default; DIE("don't know what to do with " // trim(kind))
    end
  end

  scf_energy result (res)
  ! Evaluates the SCF electronic energy as a trace of ".density_matrix" with the
  ! ".fock matrix". 
    DBL :: res
    MAT, PTR :: H
    CMAT, PTR :: HH
    STR :: kind
    kind = .scfdata.spinorbital_kind
    ENSURE( .fock_matrix.created(kind),    "no fock matrix")
    ENSURE( .density_matrix.created(kind), "no density matrix")
    select case (kind)
       case ("restricted")
          H.create(.n_bf,.n_bf); .get_core_matrix(H)
          H = H + .fock_matrix%restricted
          res = HALF * .density_matrix%restricted.trace_of_product(H)
          H.destroy
       case ("unrestricted")
          H.create(.n_bf,.n_bf)
          .get_core_matrix(H)
          H = H + .fock_matrix%alpha
          res = HALF * .density_matrix%alpha.trace_of_product(H)
          .get_core_matrix(H)
          H = H + .fock_matrix%beta
          res = HALF * .density_matrix%beta.trace_of_product(H) + res
          H.destroy
       case ("general_complex")
          HH.create(2*.n_bf,2*.n_bf); HH=ZERO
          H.create(.n_bf,.n_bf)
          .get_core_matrix(H)
          HH.set_alpha_alpha(H)
          HH.set_beta_beta(H)
          H.destroy
          HH = HH + .fock_matrix%general_complex
          res = HALF * .density_matrix%general_complex.trace_of_product(HH)
          HH.destroy
       case default; DIE("don't know what to do with " // trim(kind))
    end
    res = res + .nuclear_energy
  end

  scf_electronic_energy(P,core) result (res)
  ! Evaluates the SCF electronic energy as a trace of "D" with the ".fock matrix". 
  ! If "core" is present and FALSE, the core contribution is not added
    OPMAT, target :: P
    BIN, optional :: core
    BIN :: add_core
    DBL :: res
    MAT, PTR :: F
    CMAT, PTR :: FF
    STR :: kind
    kind = .scfdata.spinorbital_kind
    ENSURE( .fock_matrix.created(kind),    "no fock matrix")
    ENSURE( .density_matrix.created(kind), "no density matrix")
    add_core = TRUE
    if (present(core)) add_core = core
    select case (kind)
       case ("restricted")
          F.create(.n_bf,.n_bf)
          F = .fock_matrix%restricted
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P%restricted.trace_of_product(F)
          F.destroy
       case ("unrestricted")
          F.create(.n_bf,.n_bf);
          F = .fock_matrix%alpha
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P%alpha.trace_of_product(F)
          F = .fock_matrix%beta
          if (add_core) .add_core_hamiltonian(F)
          res = HALF * P%beta.trace_of_product(F) + res
          F.destroy
       case ("general_complex")
          FF.create(2*.n_bf,2*.n_bf);
          FF = .fock_matrix%general_complex
          if (add_core) then
             .add_core_hamiltonian( FF.alpha_alpha)
             .add_core_hamiltonian( FF.beta_beta)
          end
          res = HALF * P%general_complex.trace_of_product(FF)
          FF.destroy
       case default; DIE("don't know what to do with " // trim(kind))
    end
  end

  get_scf_results(kind) [leaky]
  ! Get the SCF results in from archives. Do not get the density matrix, because
  ! it can/should be generated from the orbitals depending on the kind of SCF.
    STR(*), optional :: kind
    ARCHIVE :: archive
    STR :: k
    k = .scfdata.spinorbital_kind
    if (present(kind)) k = kind
    archive.set(.name,"molecular_orbitals",kind=k)
    archive.read(.molecular_orbitals,kind=k)
    archive.set(.name,"orbital_energies",kind=k)
    archive.read(.orbital_energies,kind=k)
  end

  save_scf_results
  ! Save the SCF results in various archives
    ARCHIVE :: archive
    archive.set(.name,"density_matrix")
    archive.write(.density_matrix)
    archive.set(.name,"molecular_orbitals")
    archive.write(.molecular_orbitals)
    archive.set(.name,"orbital_energies")
    archive.write(.orbital_energies)
  end

  destroy_scf_results [leaky]
  ! Destroy the SCF results
    .density_matrix.destroy
    .density_matrix.create(.n_bf)
    .molecular_orbitals.destroy
    .molecular_orbitals.create(.n_bf)
    .orbital_energies.destroy
    .orbital_energies.create(.n_bf)
  end

  delete_integrals
  ! Delete all integral files. This is required whenever the geometry is changed.
     ARCHIVE :: archive
     archive.set(.name,"overlap_matrix")
     archive.delete
     archive.set(.name,"kinetic_matrix")
     archive.delete
     archive.set(.name,"nuclear_matrix")
     archive.delete
     archive.set(.name,"core_matrix")
     archive.delete
     archive.set(.name,"fock_matrix")
     archive.delete
     archive.set(.name,"eri_integrals")
     archive.delete
     archive.set(.name,"eri_index")
     archive.delete
     archive.set(.name,"ft_ints")
     archive.delete
  end

  delete_matrices
  ! Delete any matrices stored on disk.
     ARCHIVE :: archive
     archive.set(.name,"density_matrix")
     archive.delete_all
     archive.set(.name,"molecular_orbitals")
     archive.delete_all
     archive.set(.name,"orbital_energies")
     archive.delete_all
  end

  convert_scf_results(kind) [leaky]
  ! Convert the SCF results to a new basis kind
    STR :: kind
    .molecular_orbitals.convert(kind)
    .orbital_energies.convert(kind)
    .make_scf_density_matrix
  end

!*******************************
! Initial orbital guess routines
!*******************************

  get_initial_guess [leaky]
  ! Get the initial guess for the ".density_matrix"
     STR :: initial_guess
     initial_guess = .scfdata%initial_guess
     select case (initial_guess)
        case ("core")
           .make_core_guess
        case ("fock")
           .make_fock_guess
        case ("atom")
           .get_atom_density
        case("restricted","unrestricted","general", &
             "restricted_complex","unrestricted_complex","general_complex", &
             "complex_restricted","complex_unrestricted","complex_general")
           .get_scf_results(initial_guess)
           .convert_scf_results( .scfdata.spinorbital_kind)
           .make_scf_density_matrix
           .save_scf_results
        case default; DIE("unknown initial guess, "// initial_guess.trim)
     end
  end

  make_core_guess [leaky]
  ! Do a core scf for the ".density_matrix", ".molecular_orbitals" and ".orbital_energies"
    STR :: kind
    VEC, PTR  :: eg,er
    MAT, PTR  :: MOr
    CMAT, PTR :: MOg
    .destroy_scf_results
    kind = .scfdata.spinorbital_kind
    select case (kind)
       case ("restricted")
          .orbital_energies.destroy("restricted")
          .orbital_energies.create("restricted")
          .molecular_orbitals.destroy("restricted")
          .molecular_orbitals.create("restricted")
          .get_r_core_guess(.orbital_energies%restricted,.molecular_orbitals%restricted)
       case ("unrestricted")
          .orbital_energies.destroy("unrestricted")
          .orbital_energies.create("unrestricted")
          .molecular_orbitals.destroy("unrestricted")
          .molecular_orbitals.create("unrestricted")
          .get_r_core_guess(.orbital_energies%alpha,.molecular_orbitals%alpha)
          .orbital_energies%beta   = .orbital_energies%alpha
          .molecular_orbitals%beta = .molecular_orbitals%alpha
       case ("general_complex")
          .orbital_energies.destroy("restricted")
          .orbital_energies.create("restricted")
          .molecular_orbitals.destroy("restricted")
          .molecular_orbitals.create("restricted")
          .get_r_core_guess(.orbital_energies%restricted,.molecular_orbitals%restricted)
          .orbital_energies.destroy("general")
          .orbital_energies.create("general")
          eg  => .orbital_energies%general
          er  => .orbital_energies%restricted
          eg(1:2*.n_b-1:2)  = er(1:.n_b)
          eg(2:2*.n_b  :2)  = er(1:.n_b)
          eg(2*.n_b+1:.n_e) = er(.n_b+1:.n_a)
          eg(.n_e+1:2*.n_a)        = er(.n_b+1:.n_a)
          eg(2*.n_a+1:2*.n_bf-1:2) = er(.n_a+1:.n_bf)
          eg(2*.n_a+2:2*.n_bf  :2) = er(.n_a+1:.n_bf)
          .orbital_energies.destroy("restricted")
          .molecular_orbitals.destroy("general_complex")
          .molecular_orbitals.create("general_complex")
          MOg => .molecular_orbitals%general_complex
          MOr => .molecular_orbitals%restricted
          MOg(:,1:2*.n_b-1:2)  = MOr(:,1:.n_b)
          MOg(:,2:2*.n_b  :2)  = MOr(:,1:.n_b)
          MOg(:,2*.n_b+1:.n_e) = MOr(:,.n_b+1:.n_a)
          MOg(:,.n_e+1:2*.n_a) = MOr(:,.n_b+1:.n_a)
          MOg(:,2*.n_a+1:2*.n_bf-1:2) = MOr(:,.n_a+1:.n_bf)
          MOg(:,2*.n_a+2:2*.n_bf  :2) = MOr(:,.n_a+1:.n_bf)
          .molecular_orbitals.destroy("restricted")
       case default; DIE("don't know what to do for " // trim(kind))
    end
    .make_scf_density_matrix
    .save_scf_results
  end

  get_r_core_guess(MO_energies,MO)
  ! Do a real core scf for the molecular orbital energies  "MO_energies" 
  ! and the molecular_orbitals "MO"
    VEC :: MO_energies
    MAT :: MO
    MAT, PTR :: S,R,H
    !  H~ = S^-1/2 H S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    R.create(.n_bf,.n_bf); R.to_inverse_sqrt(S)
    H.create(.n_bf,.n_bf); .get_core_matrix(H)
    S.to_product(R,H)
    H.to_product(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H.to_product(R,MO)
    MO = H
    H.destroy
    R.destroy
    S.destroy
  end

  get_atom_density [leaky]
  ! Reads ".density_matrix" from the archive, otherwise makes it and
  ! writes to the archive.
    ARCHIVE :: archive
    archive.set(.name,"atom_density_matrix", &
             kind = "restricted")
    if ( archive.exists) then;  archive.read(.density_matrix)
    else;  .make_atom_density
    end
  end

  make_atom_density [leaky]
  ! Make a ".density matrix" from the sum of atomic densities
    INT :: k,n_k,l,kl,a,b
    MOL, PTR :: mol
    IVEC, PTR :: first,last
    IVECVEC, PTR :: atom_kind
    ARCHIVE :: archive
    ENSURE( .scfdata.created, "no scf data present.")
    .density_matrix.destroy("restricted")
    .density_matrix.create("restricted")
    .density_matrix%restricted = ZERO
    .atom.make_atom_basis_fn_limits(first,last)
    .atom.make_atom_kind_list(atom_kind)
    n_k = size(atom_kind)
    do k = 1,n_k ! Do an SCF for every different kind of atom
      mol.create
      l = atom_kind(k)%vec(1)
      .make_molecule_from_atom(l,mol)
      if (mol.no_of_electrons >= 1) then
        mol%scfdata%convergence = 0.000001
        mol%scfdata%output = FALSE
        mol.scf
        mol.make_ao_density_matrix
        mol%pointgroup.create("oh")
        mol.symmetrise(mol%density_matrix)
        do l = 1,size(atom_kind(k)%vec) ! Copy this atom density 
          kl = atom_kind(k)%vec(l)
          a = first(kl); b = last(kl)
         .density_matrix%restricted(a:b,a:b) = &
         .density_matrix%restricted(a:b,a:b) &
         + mol%density_matrix%restricted
        end
      end
      mol%atom.nullify_ptr_part ! do not destroy these
      nullify(mol%basis)        ! do not destroy this
      mol.delete_integrals
      mol.delete_matrices
      mol.destroy
    end
    .density_matrix.convert( .scfdata.spinorbital_kind,factor=HALF)
    atom_kind.destroy
    last.destroy
    first.destroy
    archive.set(.name,"atom_density_matrix", kind = "restricted")
    archive.write(.density_matrix)
  end

  make_atom_guess [leaky]
  ! Make a ".density matrix" and fock matrix from the sum of atomic densities
    .get_atom_density
    .make_fock_matrix  ! Make a fock matrix
    .make_fock_guess   ! Get a reasonable set of starting MO's
  end

  make_fock_guess [leaky]
  ! Make the .density_matrix, .molecular_orbitals, and .orbital_energies
  ! from an initial .fock_matrix; destroy .fock_matrix afterwards
    STR :: kind
    VEC, PTR :: e
    MAT, PTR :: S,MO,F
    CMAT, PTR :: MOc,Fc
    kind = .scfdata.spinorbital_kind
    ENSURE( .fock_matrix.created(kind),"need an initial fock matrix")
    .destroy_scf_results
    select case (kind)
       case ("restricted")
          .orbital_energies.destroy("restricted")
          .orbital_energies.create("restricted")
          .molecular_orbitals.destroy("restricted")
          .molecular_orbitals.create("restricted")
          e  => .orbital_energies%restricted
          MO => .molecular_orbitals%restricted
          F  => .fock_matrix%restricted
          .make_r_fock_guess(e,MO,F)
       case ("unrestricted")
          .orbital_energies.destroy("unrestricted")
          .orbital_energies.create("unrestricted")
          .molecular_orbitals.destroy("unrestricted")
          .molecular_orbitals.create("unrestricted")
          e  => .orbital_energies%alpha
          MO => .molecular_orbitals%alpha
          F  => .fock_matrix%alpha
          .make_r_fock_guess(e,MO,F)
          e  => .orbital_energies%beta
          MO => .molecular_orbitals%beta
          F  => .fock_matrix%beta
          .make_r_fock_guess(e,MO,F)
       case ("general_complex")
          .orbital_energies.destroy("general")
          .orbital_energies.create("general")
          .molecular_orbitals.destroy("general_complex")
          .molecular_orbitals.create("general_complex")
          e   => .orbital_energies%general
          MOc => .molecular_orbitals%general_complex
          Fc  => .fock_matrix%general_complex
          .make_gc_fock_guess(e,MOc,Fc)
       case default; DIE("unknown spinorbital kind, " // kind.trim)
    end
!    kind = .scfdata.spinorbital_kind
!    .fock_matrix.destroy(kind)
    .make_scf_density_matrix
    .save_scf_results
  end

  make_r_fock_guess(MO_energies,MO,fock_matrix) 
  ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
  ! a given real restricted "fock_matrix".
    VEC :: MO_energies
    MAT :: MO, fock_matrix
    MAT, PTR :: S,R,H
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
    R.create(.n_bf,.n_bf); R.to_inverse_sqrt(S)
    H.create(.n_bf,.n_bf); H = fock_matrix
    S.to_product(R,H)
    H.to_product(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H.to_product(R,MO)
    MO = H
    H.destroy
    R.destroy
    S.destroy
  end

  make_gc_fock_guess(MO_energies,MO,fock_matrix) 
  ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
  ! a given complex general "fock_matrix".
    VEC :: MO_energies
    CMAT :: MO, fock_matrix
    MAT, PTR :: S,R
    CMAT, PTR :: H
    !  F~ = S^-1/2 F S^-1/2
    !  c  = S^-1/2 c~
    S.create(.n_bf,.n_bf)
    R.create(.n_bf,.n_bf)
    .get_overlap_matrix(R)
    S.to_inverse_sqrt(R)
    R.destroy
    R.create(2*.n_bf,2*.n_bf); R=ZERO
    R.set_alpha_alpha(S)
    R.set_beta_beta(S)
    S.destroy
    S.create(2*.n_bf,2*.n_bf)
    H.create(2*.n_bf,2*.n_bf); H = fock_matrix
    S = matmul(R,H)
    H = matmul(S,R)
    H.solve_eigenproblem(MO_energies,MO)
    H = matmul(R,MO)
    MO = H
    H.destroy
    S.destroy
    R.destroy
  end
 
! ******************
! DIIS extrapolation 
! ******************

   extrapolate_scf 
   ! Extrapolate the scf objects
      STR :: kind
      OPMAT, PTR :: error
      CMAT, PTR :: err,F,P
      BIN :: skip
      skip = .scfdata.no_diis_extrapolation
      if (skip) return
      kind = .scfdata%kind
      if (.scfdata%using_diis) then
         select case (kind)
            case ("rhf","restricted_hartree_fock", &
                  "xray_rhf","xray_constrained_restricted_hartree_fock", &
                  "xray_fit","xray_constrained")
               error.create(.n_bf,"restricted")
               .make_r_diis_error(error%restricted,.fock_matrix%restricted,.density_matrix%restricted)
               error.compress
               .fock_matrix.compress
               .scfdata%diis.extrapolate(.fock_matrix%triangle,error%triangle)
               .fock_matrix.uncompress
               error.destroy
            case ("rohf","restricted_open_shell_hartree_fock")
               error.create(.n_bf,"restricted")
               .make_r_diis_error(error%restricted,.fock_matrix%restricted,.density_matrix%alpha)
               error.compress
               .fock_matrix.compress("restricted")
               .scfdata%diis.extrapolate(.fock_matrix%triangle,error%triangle)
               .fock_matrix.uncompress
               error.destroy
            case ("uhf","unrestricted_hartree_fock")
               error.create(.n_bf,"unrestricted")
               .make_r_diis_error(error%alpha,.fock_matrix%alpha,.density_matrix%alpha)
               .make_r_diis_error(error%beta, .fock_matrix%beta, .density_matrix%beta)
               error.compress
               .fock_matrix.compress
               .scfdata%diis.extrapolate(.fock_matrix%triangle,error%triangle)
               .fock_matrix.uncompress
               error.destroy
            case ("gchf","cghf","complex_general_hartree_fock","general_complex_hartree_fock")
               error.create(.n_bf,"general_complex")
               err => error%general_complex
               F   => .fock_matrix%general_complex
               P   => .density_matrix%general_complex
               .make_gc_diis_error(err,F,P)
               error.compress
               .fock_matrix.compress
               .scfdata%diis.extrapolate(.fock_matrix%square,error%square)
               .fock_matrix.uncompress
               error.destroy
         end
      end
   end

   make_r_diis_error(error,F,P)
   ! Make the real DIIS error matrix, error = FPS - SPF
      MAT :: error,F,P
      MAT, PTR :: S,W
      W.create(.n_bf, .n_bf)
      S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
      W.to_product(P,S)
      S.destroy
      error.to_product(F,W)
      W.destroy
      error.antisymmetric_fold
      error.make_antisymmetric
   end

   make_gc_diis_error(error,F,P)
   ! Make the complex general DIIS error matrix, error = FPS - SPF
      CMAT :: error,F,P
      MAT, PTR :: R
      CMAT, PTR :: S,W
      W.create(2*.n_bf, 2*.n_bf)
      S.create(2*.n_bf,2*.n_bf); S=ZERO
      R.create(.n_bf,.n_bf)
      .get_overlap_matrix(R)
      S.set_alpha_alpha(R)
      S.set_beta_beta(R)
      R.destroy
      W.to_product(P,S)
      S.destroy
      error.to_product(F,W)
      W.destroy
      error.antihermitian_fold
      error.make_antihermitian
   end
 
! *******************
! Pairwise SCF energy
! *******************

   put_scf_energy_in_mo_pairs
   ! Analyse the SCF energy into MO pairs
      OPMAT, PTR :: Di
      VEC, PTR :: core_energy
      MAT, PTR :: pair_energy
      INT :: i,j
      DBL :: energy,fac
      BIN :: direct
      core_energy.create(.n_a)
      pair_energy.create(.n_a,.n_a)
      core_energy = ZERO
      pair_energy = ZERO
      Di.create(.n_bf)
      direct = .scfdata%direct
      .scfdata%direct = TRUE 
      do i = 1,.n_a
         .make_scf_density_matrix(i) 
         Di.set_to(.density_matrix)
         .make_fock_matrix(core=TRUE,r12=FALSE)
         core_energy(i) = .scf_electronic_energy(Di,core=TRUE)
         do j = 1,i
            .make_scf_density_matrix(j)
            .make_fock_matrix(core=FALSE,r12=TRUE)
            fac = TWO
            if (i==j) fac = ONE
            pair_energy(i,j) = fac*.scf_electronic_energy(Di,core=FALSE)
         end
      end  
      Di.destroy
      .scfdata%direct = direct
      .out.flush
      .out.text("SCF MO pair energy decomposition:",flush=1)
      energy = sum(core_energy)+sum(transfer(pair_energy,(/ONE/)))+.nuclear_energy
      .out.show("SCF energy =",energy)
      .out.text("Core energies:",flush=1)
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      .out.put("MO_i",int_width=TRUE)
      .out.put("Core energy")
      .out.flush
      .out.dash(int_fields=1,dbl_fields=1)
      do i = 1,.n_a
         .out.put(i)
         .out.put(core_energy(i),flush=1)
      end 
      .out.dash(int_fields=1,dbl_fields=1)
      .out.flush
      .out.text("Orbital pair energies:",flush=1)
      .out.dash(int_fields=2,dbl_fields=1)
      .out.put("MO_i",int_width=TRUE)
      .out.put("MO_j",int_width=TRUE)
      .out.put("Pair energy",flush=1)
      .out.dash(int_fields=2,dbl_fields=1)
      do i = 1,.n_a
      do j = 1,i
         .out.put(i)
         .out.put(j)
         .out.put(pair_energy(i,j),flush=1)
      end 
      end 
      .out.dash(int_fields=2,dbl_fields=1)
      .out.flush
  end


! ******************
! Constraint methods
! ******************

  constrained_scf_rhf [leaky]
  ! Do a restricted Hartree-Fock calculation. The following objects 
  ! are destroyed and made new:
  !   .overlap_matrix, .core_matrix, .fock_matrix, 
  ! The following objects are produced as results:
  !   .molecular_orbitals, .orbital_energies, .density_matrix  
  ! The following objects are deleted from memory after execution:
  !   .overlap_matrix, .core_matrix, .fock_matrix
    MAT, PTR :: MO,temp,S
    MAT, PTR :: constraint
    STR :: kind

    ENSURE( .atom.created,  "no atom list")
    ENSURE( .atom.basis_resolved, "no basis set")
    DIE_IF( .mult/=1,"this is not a singlet state")
    .get_initial_guess
    .make_fock_matrix

    .scfdata.set(nuclear_energy=.nuclear_energy, put_file=.out)
    .scfdata.reset(energy=.scf_energy, kinetic_energy=.kinetic_energy, &
                   chi2=.xtal%chi2, gof=.xtal%gof, r_factor=.xtal%r_factor, &
                   weighted_r_factor=.xtal%weighted_r_factor)

    constraint.create( .n_bf, .n_bf)
    temp.create( .n_bf, .n_bf)
    S.create( .n_bf, .n_bf)
    .get_overlap_matrix(S)
    kind = .scfdata.spinorbital_kind
    if (kind == "restricted") then
      if ( .molecular_orbitals.destroyed(kind) ) .make_fock_guess
      MO => .molecular_orbitals%restricted
    else
      DIE("can only do restricted calculations.")
    end

    .get_ft_ints
    .make_structure_factors
    .xtal.update_scaled_gof_parameters

    do
      .scfdata%diis.cleanup

      do
        temp.to_product(MO,S,transpose_a=TRUE)

        .make_constraint(constraint, .scfdata%lambda / (.scfdata%lambda + 1) )
        constraint.change_basis(MO)          ! Zero out the occ-occ and vir-vir
        constraint(:.n_a, :.n_a) = ZERO      ! blocks of the constraint matrix
        constraint(.n_a+1:, .n_a+1:) = ZERO  ! to improve convergence.

        .fock_matrix%restricted.change_basis(MO)
        .fock_matrix%restricted(.n_a+1:,:.n_a).to_product( ONE/(.scfdata%lambda+1) )
        .fock_matrix%restricted(:.n_a,.n_a+1:).to_product( ONE/(.scfdata%lambda+1) )

        .fock_matrix%restricted = .fock_matrix%restricted + constraint
        .fock_matrix%restricted.change_basis(temp) ! Back to AO basis.

        .extrapolate_scf
        .update_molecular_orbitals
        .molecular_orbitals.schmidt_orthonormalise(S)
        .make_scf_density_matrix
        .save_scf_results
        .make_fock_matrix                      ! To get new Hartree-Fock energy.

        if (.optimise_thermals) then
          .fit_thermal_parameters
        else
          .make_structure_factors
          .xtal.update_scaled_gof_parameters
        end

        .scfdata.update(energy=.scf_energy, kinetic_energy=.kinetic_energy, &
                   chi2=.xtal%chi2, gof=.xtal%gof, r_factor=.xtal%r_factor, &
                   weighted_r_factor=.xtal%weighted_r_factor)
        .scfdata.put_results
        if (.scfdata.scf_done) exit
      end
      if (.scfdata.exceeded_lambda_max) exit
      .scfdata.update_lambda
      if (.optimise_thermals) .put_thermal_tensors
    end

    .xtal.scale_Fc
    .xtal.put_reflection_data(.out)

    .scfdata%diis.delete_archives
    S.destroy
    temp.destroy
    constraint.destroy
  end

  make_constraint(constraint,lambda)
    MAT :: constraint
    DBL, IN :: lambda
    ARCHIVE :: archive
    CMAT3, PTR :: ft_ints
    VEC, PTR :: Fc,Fexp,sig,fac_times_alpha,alpha
    DBL :: sn,fac
    INT :: q,a,b,fa,la,fb,lb,n,i,j,n_refl

    Fc => .xtal%F_calc
    Fexp => .xtal%F_exp
    sig => .xtal%sigma
    n_refl = .xtal%n_refl
    fac = TWO*lambda/n_refl

    fac_times_alpha.create(n_refl)

    alpha.create(n_refl)
    alpha = .xtal.extinction_correction
    do n=1,n_refl
      sn = abs(Fc(n))/Fc(n)
      fac_times_alpha(n)=fac*alpha(n)*(alpha(n)*Fc(n)-sn*Fexp(n))/(sig(n)*sig(n))
    end
    alpha.destroy

    archive.set(.name,"ft_ints")
    archive.open(for="read-only",buffered=TRUE,type="cdbl")
    constraint=ZERO
    do q=1, .n_shell_pairs
      .get_shell_pair(q,a,b,fa,la,fb,lb)
      ft_ints.create((/1,n_refl/),(/fa,la/),(/fb,lb/))
      archive%file.read(ft_ints)
      do i = fa,la
        do j = fb,min(lb,i)
          constraint(i,j) = constraint(i,j) + sum( fac_times_alpha(:) * ft_ints(:,i,j) )
        end
      end
      ft_ints.destroy
    end
    constraint.make_symmetric

    archive.close
    fac_times_alpha.destroy
  end

end 
