!---------------------------------------------------------------------------
!
!  MAT3{REAL}: 3 dimensional matrices
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module MAT3{REAL}

   implicit none

contains

   create(dim1,dim2,dim3) ::: get_from(MAT3{INTRINSIC}), leaky
   ! Create the object with the desired bounds
   end

   create(dim) ::: get_from(MAT3{INTRINSIC}), leaky
   ! Create the object with the desired dimensions "dim"
   end

   create(lb1,ub1,lb2,ub2,lb3,ub3) ::: get_from(MAT3{INTRINSIC}), leaky
   ! Create the object with the desired bounds
   end

   create(bounds1,bounds2,bounds3) ::: get_from(MAT3{INTRINSIC}), leaky
   ! Create the object with the desired bounds
   end

   create(bounds) ::: get_from(MAT3{INTRINSIC}), leaky
   ! Create the object with the desired bounds
   end

   create_copy(c) ::: get_from(MAT3{INTRINSIC}), leaky
   ! Create a copy of matrix "c"
   end

   destroy ::: get_from(MAT3{INTRINSIC}), leaky
   ! Destroy the object
   end

   created result(res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result(res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   size result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo
   ! Return the size of the array
   end

   dim1 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo
   ! Return the size of the 1st dimension
   end

   dim2 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo
   ! Return the size of the 2nd dimension
   end

   dim3 result (res) ::: get_from(MAT3{INTRINSIC}), inlined_by_foo
   ! Return the size of the 2nd dimension
   end

   shape result (res) ::: get_from(MAT3{INTRINSIC})
   ! Return the size of the 2nd dimension
   end

   is_same_shape_as(b) result(res)  ::: get_from(MAT3{INTRINSIC})
   ! Returns TRUE if the matrix "b" has the same shape as self
   end

   set_to(b) ::: get_from(MAT3{INTRINSIC})
   ! Set "self" to "b"
   end

   set_to(b) ::: get_from(MAT3{INTRINSIC})
   ! Set "self" to vector "b" in standard order
   end

   make_symmetric
   ! Make the upper pyramid of "self" the same as the lower pyramid
   ENSURE(.dim1==.dim2,"non-cube tensor")
   ENSURE(.dim1==.dim3,"non-cube tensor")
      dim, i,j,k :: INT
      val :: REAL
      dim = size(self,1)
      do i = 1,dim
      do j = 1,i
      do k = 1,j
         val = self(i,j,k)
         self(i,k,j) = val
         self(j,i,k) = val
         self(j,k,i) = val
         self(k,i,j) = val
         self(k,j,i) = val
      end
      end
      end
   end

   transpose_12
   ! Makes the matrix formed by the 1st and 2nd columns symmetrical.
   ENSURE(.dim1==.dim2,"non-square matrix")
     k :: INT
     do k = 1,.dim3
       self(:,:,k) = transpose(self(:,:,k))
     end
   end

   symmetric_reflect_12
   ! Makes the matrix formed by the 1st and 2nd columns symmetrical.
   ENSURE(.dim1==.dim2,"non-square matrix")
     dim1,dim2,i,j :: INT
     dim1 = size(self,1)
     dim2 = size(self,2)
     do i = 1,dim1
     do j = 1,i-1
       self(j,i,:) = self(i,j,:)
     end
     end
   end

   symmetric_reflect_23
   ! Makes the matrix formed by the 2nd and 3rd columns symmetrical.
     dim,i,j :: INT
     .check_square_23
     dim = size(self,2)
     do i = 1,dim
     do j = 1,i-1
       self(:,j,i) = self(:,i,j)
     end
     end
   end

   to_tri_23(tr)
   ! Converts the matrix self to the lower triangle tr.
   ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
     self :: IN
     tr :: VEC{REAL}
   ENSURE(size(tr)>=.tri_size_23,"tr array too small")
     dim1,dim2,h,i,j,ij :: INT
     dim1 = size(self,1)
     dim2 = size(self,2)
     .check_square_23
     ij = 0
     do h = 1,dim1
       do i = 1,dim2
         do j = 1,i
           ij = ij+1
           tr(ij) = self(h,j,i)
         end
       end
     end
   end

   from_tri_23(tr)
   ! Converts the matrix self to the lower triangle tr.
   ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
     tr :: VEC{REAL}, IN
   ENSURE(size(tr)>=.tri_size_23,"tr array too small")
     dim1,dim2,h,i,j,ij :: INT
     dim1 = size(self,1)
     dim2 = size(self,2)
     .check_square_23
     ij = 0
     do h = 1,dim1
       do i = 1,dim2
         do j = 1,i
           ij = ij+1
           self(h,j,i) = tr(ij)
           self(h,i,j) = tr(ij)
         end
       end
     end
   end

   tri_size_23 result (ltr)
   ! Returns the size of the lower triangle needed to store the matrix self.
   ! Assumes the matrix formed by columns 2 and 3 is the symmetric one.
     self :: IN
     ltr :: INT
     dim1,dim2 :: INT
     dim1 = size(self,1)
     dim2 = size(self,2)
     .check_square_23
     ltr = dim1*dim2*(dim2+1)/2
   end

   check_square_23
   ! Checks to see that the matrix formed by the 2nd and 3rd columns is square.
     dim2,dim3 :: INT
     dim2 = size(self,2)
     dim3 = size(self,3)
     ENSURE(dim2==dim3,"non-square 2nd and 3rd dimensions")
   end

!   gaussian_xyz_matrices result (res) ::: leaky
!   ! Return representation matrices for the s, p, d, f, and g (l = 0 ... 4)
!   ! xyz cartesian gaussian shell components from a list of the p xyz
!   ! representation matrices.
!   ! NOTE: nothing in self in pointer assigned, so it can be destroyed safely.
!      res :: VEC{MAT3_{REAL}}*
!   ENSURE(.dim1==3,"wrong 1st dimension, self")
!   ENSURE(.dim2==3,"wrong 1st dimension, self")
!   ENSURE(.dim3>0,"no p-type representation matrices")
!      allocate(res(0:4))
!      res(0).element.create(1,1,.dim3)
!      res(1).element.create(3,3,.dim3)
!      ! Now assign the transformation matrices
!      res(0).element = ONE
!      res(1).element = self
!      res(2).element => .gaussian_d_xyz_matrices
!      res(3).element => .gaussian_f_xyz_matrices
!      res(4).element => .gaussian_g_xyz_matrices
!   end

   gaussian_d_xyz_matrices result (dtr) ::: leaky
   ! Return the representation matrices for d xyz products found in
   ! gaussian shells from the p xyz matrices.
      dtr :: MAT3{REAL}*
   ENSURE(.dim1==3,"wrong 1st dimension, self")
   ENSURE(.dim2==3,"wrong 2nd dimension, self")
   ENSURE(.dim3>0,"no p type matrices")
      n,order :: INT
      order = .dim3
      dtr.create(6,6,order)
      do n = 1,order
         dtr(:,:,n) = self(:,:,n).gaussian_d_xyz_matrix
      end
   end

   gaussian_f_xyz_matrices result (ftr) ::: leaky
   ! Return the representation matrices for f xyz products found in
   ! gaussian shells from the p xyz matrices
      ftr :: MAT3{REAL}*
   ENSURE(.dim1==3,"wrong 1st dimension, self")
   ENSURE(.dim2==3,"wrong 2nd dimension, self")
   ENSURE(.dim3>0,"no p type matrices")
      n,order :: INT
      order = .dim3
      ftr.create(10,10,order)
      do n = 1,order
         ftr(:,:,n) = self(:,:,n).gaussian_f_xyz_matrix
      end
   end

   gaussian_g_xyz_matrices result (gtr) ::: leaky
   ! Return the representation matrices for g xyz products found in
   ! gaussian shells from the p xyz matrices
      gtr :: MAT3{REAL}*
   ENSURE(.dim1==3,"wrong 1st dimension, self")
   ENSURE(.dim2==3,"wrong 2nd dimension, self")
   ENSURE(.dim3>0,"no p type matrices")
      n,order :: INT
      order = .dim3
      gtr.create(15,15,order)
      do n = 1,order
         gtr(:,:,n) = self(:,:,n).gaussian_g_xyz_matrix
      end
   end

   similarity_transform_12(V)
   ! Do a similarity tranform on the first two indices of self, i.e.
   ! self(:,:,i) -> V self(:,:,i) V^-1
      V :: MAT{REAL}
   ENSURE(.dim1==.dim2, "1st two dimensions of self unequal")
   ENSURE(.dim1==V.dim1,"incompatible transform matrix, V")
   ENSURE(V.is_square,  "transform matrix not square")
   ENSURE(.dim3>0,"no p type matrices")
      n :: INT
      do n = 1,.dim3
         self(:,:,n).similarity_transform(V)
      end
   end

end
