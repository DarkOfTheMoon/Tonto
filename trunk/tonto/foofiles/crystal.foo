!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module CRYSTAL

   implicit none

   saved_self :: CRYSTAL*

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  ==========================
!  Create and destroy methods
!  ==========================

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: leaky
   ! Destroy an object
      self :: PTR

      if (.destroyed) return

    ! .nullify_basis_part

      .destroy_ptr_part

      DELETE_MEMORY(SELF_TYPE_SIZE)

      deallocate(self)

   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object

      .spacegroup.nullify_ptr_part

      nullify(.fragment_atom)
      nullify(.fragment_geometry)

      nullify(.asymmetric_unit_geometry)
      nullify(.asymmetric_unit_atom)

      nullify(.unit_cell_geometry)
      nullify(.unique_unit_cell_atom)
      nullify(.unique_uc_atom_offset)
      nullify(.is_asym_unit_cell_atom)
      nullify(.asym_atom_for_unit_cell_atom)
      nullify(.asym_symop_for_unit_cell_atom)
      nullify(.frag_parent_for_cell_atom)

      nullify(.frag_atom_for_unit_cell_atom)
      nullify(.unit_cell_atom_for_frag_atom)
      nullify(.unit_cell_shft_for_frag_atom)
      nullify(.frag_atom_for_asym_atom)
      nullify(.asym_atom_for_frag_atom)

      nullify(.unique_frag_atom)
      nullify(.unique_atom_for_frag_atom)
      nullify(.unique_symop_for_frag_atom)
      nullify(.asym_symop_for_frag_atom)
      nullify(.asym_shift_for_frag_atom)

      nullify(.repetition_factor)
      nullify(.asym_atom_rep_factor)
      nullify(.asym_atom_stabilizer)

      nullify(.unit_cell_connection)
      nullify(.uc_vdw_connection)
      nullify(.unit_cell_mol_for_atom)

      nullify(.stabilizer_symop)
      nullify(.str)
      nullify(.ptr)
      nullify(.dtr)
      nullify(.ftr)
      nullify(.gtr)

      nullify(.data)
      nullify(.xray_data)
      nullify(.pnd_data)
      nullify(.xray_r_free_data)
      nullify(.pnd_r_free_data)
      nullify(.core_reflection)

   end

!   nullify_basis_part 
!   ! Nullify the atom bases parts ... before the .bases they point 
!   ! to are destroyed.
!
!      if (.fragment_atom.created)        .fragment_atom.nullify_bases
!      if (.asymmetric_unit_atom.created) .asymmetric_unit_atom.nullify_bases
!
!   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information

      .spacegroup.destroy_ptr_part
      .destroy_fragment_data
      .destroy_asymmetric_unit
      .destroy_data

   end

   destroy_data ::: leaky
   ! Erase all data pointer information

    nullify(.data)
    .xray_data.destroy
    .pnd_data.destroy
    .xray_r_free_data.destroy
    .pnd_r_free_data.destroy
    .core_reflection.destroy

   end

   destroy_fragment_data ::: leaky
   ! Destroy the geometry and symmetry data for the fragment and unit cell.
   ! NOTE: Don't destroy asymmetric unit atom info

      if (.destroy_fragment_atom) then; .fragment_atom.destroy
      else;                             nullify(.fragment_atom)
      end
      .fragment_geometry.destroy

      ! Never destroy .asymmetric_unit_geometry
      ! Never destroy .asymmetric_unit_atom

      .unit_cell_geometry.destroy
      .unique_unit_cell_atom.destroy
      .unique_uc_atom_offset.destroy
      .is_asym_unit_cell_atom.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .asym_symop_for_unit_cell_atom.destroy
      .frag_parent_for_cell_atom.destroy

      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .unit_cell_shft_for_frag_atom.destroy
      .frag_atom_for_asym_atom.destroy
      .asym_atom_for_frag_atom.destroy

      .unique_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .unique_symop_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_shift_for_frag_atom.destroy

      if (NOT .use_manual_repetition_factors) .repetition_factor.destroy
      .asym_atom_rep_factor.destroy
      .asym_atom_stabilizer.destroy

      .unit_cell_connection.destroy
      .uc_vdw_connection.destroy
      .unit_cell_mol_for_atom.destroy

      .stabilizer_symop.destroy
      .str.destroy
      .ptr.destroy
      .dtr.destroy
      .ftr.destroy
      .gtr.destroy

      .fragment_info_made = FALSE

   end

   destroy_asymmetric_unit ::: leaky
   ! Destroy the asymmetric unit geometry. Normally this will be set
   ! by reading a CIF file. If not, it will be set from a given
   ! fragment atom list, in the "make_fragment_data" routine. Once
   ! set, it is never destroyed unless explicitly requested by a call
   ! or a keyword.
      .asymmetric_unit_geometry.destroy ! This is nothing to do with a fragment !
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_source = "?"
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(crystal) ::: leaky
   ! Set self to be crystal.
      crystal :: CRYSTAL, IN

      self = crystal

      .nullify_ptr_part

      .spacegroup.copy(crystal.spacegroup)
      .unit_cell.copy(crystal.unit_cell)

      if (crystal.fragment_atom.created) then
         if (.destroy_fragment_atom) then;               .fragment_atom.create_copy(crystal.fragment_atom)
         else;                                           .fragment_atom => crystal.fragment_atom
         end
      end
      if (crystal.fragment_geometry.created)             .fragment_geometry.create_copy(crystal.fragment_geometry)

      if (crystal.asymmetric_unit_geometry.created)      .asymmetric_unit_geometry.create_copy(crystal.asymmetric_unit_geometry)
      if (crystal.asymmetric_unit_atom.created)          .asymmetric_unit_atom.create_copy(crystal.asymmetric_unit_atom)

      if (crystal.unit_cell_geometry.created)            .unit_cell_geometry.create_copy(crystal.unit_cell_geometry)
      if (crystal.unique_unit_cell_atom.created)         .unique_unit_cell_atom.create_copy(crystal.unique_unit_cell_atom)
      if (crystal.unique_uc_atom_offset.created)         .unique_uc_atom_offset.create_copy(crystal.unique_uc_atom_offset)
      if (crystal.is_asym_unit_cell_atom.created)        .is_asym_unit_cell_atom.create_copy(crystal.is_asym_unit_cell_atom)
      if (crystal.asym_atom_for_unit_cell_atom.created)  .asym_atom_for_unit_cell_atom.create_copy(crystal.asym_atom_for_unit_cell_atom)
      if (crystal.asym_symop_for_unit_cell_atom.created) .asym_symop_for_unit_cell_atom.create_copy(crystal.asym_symop_for_unit_cell_atom)
      if (crystal.frag_parent_for_cell_atom.created)     .frag_parent_for_cell_atom.create_copy(crystal.frag_parent_for_cell_atom)

      if (crystal.frag_atom_for_unit_cell_atom.created)  .frag_atom_for_unit_cell_atom.create_copy(crystal.frag_atom_for_unit_cell_atom)
      if (crystal.unit_cell_atom_for_frag_atom.created)  .unit_cell_atom_for_frag_atom.create_copy(crystal.unit_cell_atom_for_frag_atom)
      if (crystal.unit_cell_shft_for_frag_atom.created)  .unit_cell_shft_for_frag_atom.create_copy(crystal.unit_cell_shft_for_frag_atom)
      if (crystal.frag_atom_for_asym_atom.created)       .frag_atom_for_asym_atom.create_copy(crystal.frag_atom_for_asym_atom)
      if (crystal.asym_atom_for_frag_atom.created)       .asym_atom_for_frag_atom.create_copy(crystal.asym_atom_for_frag_atom)

      if (crystal.unique_frag_atom.created)              .unique_frag_atom.create_copy(crystal.unique_frag_atom)
      if (crystal.unique_atom_for_frag_atom.created)     .unique_atom_for_frag_atom.create_copy(crystal.unique_atom_for_frag_atom)
      if (crystal.unique_symop_for_frag_atom.created)    .unique_symop_for_frag_atom.create_copy(crystal.unique_symop_for_frag_atom)
      if (crystal.asym_symop_for_frag_atom.created)      .asym_symop_for_frag_atom.create_copy(crystal.asym_symop_for_frag_atom)
      if (crystal.asym_shift_for_frag_atom.created)      .asym_shift_for_frag_atom.create_copy(crystal.asym_shift_for_frag_atom)

      if (crystal.repetition_factor.created)             .repetition_factor.create_copy(crystal.repetition_factor)
      if (crystal.asym_atom_rep_factor.created)          .asym_atom_rep_factor.create_copy(crystal.asym_atom_rep_factor)
      if (crystal.asym_atom_stabilizer.created)          .asym_atom_stabilizer.create_copy(crystal.asym_atom_stabilizer)

      if (crystal.unit_cell_connection.created)          .unit_cell_connection.create_copy(crystal.unit_cell_connection)
      if (crystal.uc_vdw_connection.created)             .uc_vdw_connection.create_copy(crystal.uc_vdw_connection)
      if (crystal.unit_cell_mol_for_atom.created)        .unit_cell_mol_for_atom.create_copy(crystal.unit_cell_mol_for_atom)

      if (crystal.stabilizer_symop.created)              .stabilizer_symop.create_copy(crystal.stabilizer_symop)
      if (crystal.str.created)                           .str.create_copy(crystal.str)
      if (crystal.ptr.created)                           .ptr.create_copy(crystal.ptr)
      if (crystal.dtr.created)                           .dtr.create_copy(crystal.dtr)
      if (crystal.ftr.created)                           .ftr.create_copy(crystal.ftr)
      if (crystal.gtr.created)                           .gtr.create_copy(crystal.gtr)

      if (crystal.xray_data.created)                     .xray_data.create_copy(crystal.xray_data)
      if (crystal.pnd_data.created)                      .pnd_data.create_copy(crystal.pnd_data)

      if (crystal.core_reflection.created)               .core_reflection.create_copy(crystal.core_reflection)

   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky
   ! Set up a default crystal object

      .CIF_chemical_formula          = "?"

      .n_fragment_atoms              = 0
      .destroy_fragment_atom         = FALSE

      .asymmetric_unit_source        = "?"
      .n_asymmetric_unit_atoms       = 0
      .prune_asymmetric_unit         = TRUE
      .n_unit_cell_atoms             = 0

      .fragment_info_made            = FALSE

      .n_unique_frag_atoms           = 0
      .Z                             = ZERO
      .use_manual_repetition_factors = FALSE
      .n_unit_cell_mols              = 0
      .n_stabilizer_symops           = 0

      .data_kind                     = "?"
      .r_free_percentage             = 0
      .stl_limit                     = 1.20d0
      .finalize                      = TRUE

      ! Subtype defaults
      .spacegroup.set_defaults
      .unit_cell.set_defaults

      ! Set xray_data defualts
      if (.xray_data.created) then; .xray_data.set_defaults
      else;                         nullify(.xray_data)
      end

      ! Set pnd_data defualts
      if (.pnd_data.created) then;  .pnd_data.set_defaults
      else;                         nullify(.pnd_data)
      end

   end

   update ::: leaky
   ! Update the crystal information after setting values.

      if (.xray_data.created) then

        .xray_data.update(.unit_cell,.spacegroup)

        if (.r_free_percentage>0 AND .xray_data.reflections.created) then
           .xray_r_free_data.destroy
           .xray_r_free_data.create_copy(.xray_data)
           .xray_r_free_data.reflections.destroy
           .set_r_free_reflections(.xray_data.reflections,.xray_r_free_data.reflections)
        end

      end

      if (.pnd_data.created) then

        .pnd_data.update(.unit_cell,.spacegroup)

        if (.r_free_percentage>0 AND .pnd_data.reflections.created) then
           .pnd_r_free_data.destroy
           .pnd_r_free_data.create_copy(.xray_data)
           .pnd_r_free_data.reflections.destroy
           .set_r_free_reflections(.pnd_data.reflections,.pnd_r_free_data.reflections)
        end

      end

   end

   set_r_free_reflections(data,free_data) ::: leaky
   ! Set the R free reflection data. "data" is destroyed and created
   ! again without those reflections in "free_data".
      data,free_data :: VEC{REFLECTION}*

   ENSURE(data.created,"no diffraction data")
   ENSURE(free_data.destroyed,"r_free_data exists")

      keep_data :: VEC{REFLECTION}*
      harvest :: VEC{REAL}* 
      free,keep :: VEC{INT}* 
      percentage :: REAL
      i,n :: INT

      if (.r_free_percentage<=0) return
      if (data.destroyed) return

      ! Set the percentage of reflections to reject
      percentage = .r_free_percentage/100.0d0

      ! Harvest random numbers
      n = data.dim
      harvest.create(n)
      call random_number(harvest)

      ! Reflections for r_free have p<percentage
      ! Otherwise, they are kept and used for fitting
      nullify(free)
      nullify(keep)
      do i = 1,n
         if (harvest(i)<percentage) then; free.append(i)
         else;                            keep.append(i)
         end
      end
      harvest.destroy

      stdout.show("No. of reflections kept for R free =",free.dim)
      stdout.flush

      ! Set free_data
      free_data.create(free.dim)
      free_data = data(free)
      free.destroy

      ! Reset data to the kept data
      keep_data.create(keep.dim)
      keep_data = data(keep)
      keep.destroy
      data.destroy
      data => keep_data

   end

   assign_xray 
   ! Assign data to the xray_data
   ENSURE(.xray_data.created, "No X-ray reflection data")
      nullify(.data)
      .data => .xray_data
   end

   assign_xray_r_free
   ! Assign data to the xray_r_free_data
   ENSURE(.xray_r_free_data.created, "No X-ray R-free reflection data")
      nullify(.data)
      .data => .xray_r_free_data
   end

   assign_pnd 
   ! Assign data to the pnd_data
   ENSURE(.pnd_data.created, "No PND reflection data")
      nullify(.data)
      .data => .pnd_data
   end

   assign_pnd_r_free
   ! Assign data to the pnd_r_free_data
   ENSURE(.pnd_r_free_data.created, "No PND R-free PND reflection data")
      nullify(.data)
      .data => .pnd_r_free_data
   end

!  ============
!  Read methods
!  ============

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                             ")  ! exit read_loop
         case ("asymmetric_unit_geometry=     "); .read_asymmetric_unit_geometry
         case ("debug_on                      "); .read_debug_on
         case ("debug_off                     "); .read_debug_off
         case ("destroy                       "); .destroy_ptr_part; .set_defaults
         case ("destroy_asymmetric_unit       "); .destroy_asymmetric_unit
         case ("destroy_spacegroup            "); .spacegroup.destroy_ptr_part
         case ("expand_unique_reflections     "); .expand_unique_reflections
         case ("finalize=                     "); .read_finalize
         case ("junk=                         "); .read_junk
         case ("kind=                         "); .read_kind
         case ("merge_equivalents             "); .merge_equivalents
         case ("merge_ordered_equivalents     "); .merge_ordered_equivalents
         case ("pnd_data=                     "); .read_pnd_data
         case ("prune_asymmetric_unit=        "); .read_prune_asymmetric_unit
         case ("put                           "); .put
         case ("put_bond_info_with_errors     "); .put_bond_info_with_errors
         case ("put_bond_info_with_errors_to  "); .put_bond_info_with_errors_to
         case ("r_free_percentage=            "); .read_r_free_percentage
         case ("read_cif                      "); .read_CIF
         case ("redirect                      "); .redirect
         case ("repetition_factors=           "); .read_repetition_factors
         case ("revert                        "); .revert
         case ("spacegroup=                   "); .read_spacegroup
         case ("set_hkl_up_to_stl_limit       "); .set_hkl_up_to_stl_limit
         case ("stl_limit=                    "); .read_stl_limit
         case ("unit_cell=                    "); .read_unit_cell
         case ("units=                        "); .read_units
         case ("use_manual_repetition_factors="); .read_use_manual_rep_factors
         case ("xray_data=                    "); .read_xray_data
         case default;                       UNKNOWN(word)
      end

   end

   read_units ::: get_from(OBJECT), private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.data_kind)
      .data_kind.to_lower_case
      select case (.data_kind)
         case("x-ray")
         case("pnd  ")
         case default; UNKNOWN(.data_kind)
      end
   end

   read_finalize
   ! Read whether to finalize the object.
      stdin.read(.finalize)
   end

   read_r_free_percentage
   ! Read the R free percentage
      stdin.read(.r_free_percentage)
      DIE_IF(.r_free_percentage<0,  "percentage must be non-negative")
      DIE_IF(.r_free_percentage>100,"percentage must be less than 100")
   end

   read_spacegroup ::: leaky
   ! Read the spacegroup
      .spacegroup.read_keywords
      .spacegroup.analyse
   end

   read_unit_cell 
   ! Read the unit cell information
      .unit_cell.read_keywords
      .unit_cell.make_info
   end

   read_xray_data ::: leaky
   ! Read in the xray diffraction data

      WARN_IF(.xray_data.created,"xray diffraction data already defined!")

      if (.xray_data.destroyed) .xray_data.create
      .xray_data.data_kind = "x-ray"

      .xray_data.read_keywords

      .xray_data.update
      .assign_xray

      ! Prune
      if (.xray_data.reflections.created) then
      if (.xray_data.reflections.have_F_exp) then
         .data.prune_negative_F_exp
      end
      end

   end

   read_pnd_data ::: leaky
   ! Read in the pnd diffraction data

      WARN_IF(.pnd_data.created,"pnd diffraction data already defined!")

      if (.pnd_data.destroyed) .pnd_data.create

      .pnd_data.data_kind = "pnd"

      .pnd_data.read_keywords

      .pnd_data.update
      .assign_pnd

   end

   read_use_manual_rep_factors ::: leaky, private
   ! Read whether to use manually entered repetition factors.
   ! If set set FALSE, the repetition factors will be destroyed.
      stdin.read(.use_manual_repetition_factors)
      if (.use_manual_repetition_factors) return
      .repetition_factor.destroy
   end

   read_repetition_factors ::: leaky, private
   ! Read in the crystal fragment repetition factors. Useful to get structure
   ! factor contributions from a small portion of the fragment.
      .repetition_factor.destroy
      stdin.read_ptr(.repetition_factor)
      .use_manual_repetition_factors = TRUE
   end

   read_prune_asymmetric_unit ::: private
   ! Read whether to prune the asymmetric unit or not. Sometimes the asymmetric
   ! unit may not be asymmetric i.e. it may have symmetry-equivalent atoms
   ! repeated. This could be because of an input or CIF file error, or it could
   ! be genuinely correct because the repeated atom corresponds to a disordered
   ! position. For Hirshfeld surface plots, which can cope with disorder, you
   ! probably do not want to prune the asymmetric atom list, but for crystal
   ! calculations you must do so.
      stdin.read(.prune_asymmetric_unit)
   end

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File object, with
   ! the "name" taken from stdin.

      name :: STR
      found :: BIN
      cif :: CIF*

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif,skip_atoms) ::: leaky
   ! Read information from a Crystallographic Information File object, "cif".
   ! If "skip_atoms" is present and TRUE, the atom coordinates are not processed.
      cif :: CIF
      skip_atoms :: BIN, optional
      skip,found :: BIN
      itemvec :: VEC{STR}*

      skip = FALSE
      if (present(skip_atoms)) skip = skip_atoms

      .set_defaults

      ! Read the chemical formula if it is there
      nullify(itemvec)
      cif.read_item("_chemical_formula_sum",.CIF_chemical_formula,itemvec,found)
      if (NOT found) .CIF_chemical_formula = "?"
      DIE_IF(itemvec.created,"multi line chemical formula")

      ! Read the spacegroup 
      .spacegroup.read_CIF(cif)

      ! Read the unit cell
      .unit_cell.read_CIF(cif)

      ! Read the atom list (if requested)
      if (NOT skip) then
         .fragment_atom.read_CIF(cif)
      end

      ! Update
      .update

      ! Eventually, this will be used
      .asymmetric_unit_source = "from-cif"

   end

   read_asymmetric_unit_geometry
   ! Read in the asymmetric unit geometry in crystal coordinates.
   ! The coordinates are read in as a single vector ordered as x,y,z
   ! incrementing fastest, for the first to the last atom.
      geometry :: VEC{REAL}*

   WARN_IF(.asymmetric_unit_geometry.created,"asymmetric_unit_geometry exists!")

      stdin.read_ptr(geometry)
      ENSURE(modulo(geometry.dim,3)==0,"number of coordinates must be divisible by 3")

      .n_asymmetric_unit_atoms = geometry.dim/3
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,.n_asymmetric_unit_atoms)
      .asymmetric_unit_geometry = reshape(geometry,[3,.n_asymmetric_unit_atoms])
      geometry.destroy

      .asymmetric_unit_source = "manual-input"

   end

!   set_asymmetric_unit_geometry(geometry) ::: leaky
!   ! Set the asymmetric unit geometry from a CARTESIAN "geometry".
!   ! This is useful if the atomic coordinates have been processed from
!   ! a CIF elsewhere, e.g. in the VEC{ATOM} module.
!      geometry :: MAT{REAL}
!
!   ENSURE(geometry.dim1==3,"wrong 1st dimensions, geometry")
!
!      .destroy_asymmetric_unit
!
!      .n_asymmetric_unit_atoms = geometry.dim2
!      .asymmetric_unit_geometry.create(3,geometry.dim2)
!      .asymmetric_unit_geometry = matmul(.unit_cell.inverse_matrix,geometry)
!
!   end

!   set_asymmetric_unit_geometry(atom) ::: leaky
!   ! Set the asymmetric unit geometry from a list of the asymmetric
!   ! units "atoms". NOTE: coordinates must be cartesian.
!      atom :: VEC{ATOM}
!
!   ENSURE(.unit_cell.info_made,"no unit cell info")
!
!      n,a :: INT
!
!      .destroy_asymmetric_unit
!
!      n = atom.dim
!      .n_asymmetric_unit_atoms = n
!      .asymmetric_unit_geometry.create(3,n)
!
!      ! Assign the positions; convert to crystal axis system
!      do a = 1,n
!         .asymmetric_unit_geometry(:,a) = matmul(.unit_cell.inverse_matrix,atom(a).position)
!      end
!
!   end

   read_stl_limit
   ! Read in the stl limit for generating (h k l)
      stdin.read(.stl_limit)
      ENSURE(.stl_limit>ZERO,"must be +ve!")
   end

!  ===============
!  General methods
!  ===============

   make_k_pts(k_pt)
   ! Convert the .reflection.hkl indices to reciprocal lattice vectors
   ! Dimension of "k_pt" is [.n_refl,3]
      k_pt :: MAT{REAL}, OUT

   ENSURE(.data.created,"no data")

      n :: INT
      hkl :: VEC{INT}(3)
      rcm :: MAT{REAL}(3,3)

      rcm = TWO*PI*.unit_cell.reciprocal_matrix

      do n = 1,.data.reflections.n_refl

         hkl = .data.reflections.indices(n)

         k_pt(n,1) = dot_product(rcm(1,:),hkl(:))
         k_pt(n,2) = dot_product(rcm(2,:),hkl(:))
         k_pt(n,3) = dot_product(rcm(3,:),hkl(:))

      end

   end

   n_unique_SF_k_pts result (res) ::: pure
   ! The number of unique k-points for an SF calculation
      self :: IN
      res :: INT

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      res = .spacegroup.n_unique_SF_symops * .data.reflections.dim

   end

   make_unique_SF_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! for structure factor calculations.
      self :: IN
      k :: MAT{REAL}, OUT, target

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.spacegroup.unique_SF_symop.created,"no unique_SF_symop array!")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")
   ENSURE(k.dim1==.n_unique_SF_k_pts,"k: wrong dim1")
   ENSURE(k.dim2==3,"k: wrong dim2")

      B,rcm,symop :: MAT{REAL}(3,3)
      k1,k2,k3 :: VEC{REAL}*
      h1,h2,h3, n_refl,n,p,u :: INT

      ! No. of reflection
      n_refl = .data.reflections.dim

      ! Reciprocal cell matrix
      rcm = TWO*PI*.unit_cell.reciprocal_matrix

      ! Symmetry-generated k points
      k1 => k(:,1)
      k2 => k(:,2)
      k3 => k(:,3)

      do u = 1,.spacegroup.n_unique_SF_symops

         symop = .spacegroup.unique_SF_symop_mat(u)

         B.to_product_of(rcm,symop,transpose_b=TRUE)

         p = (u-1)*n_refl

         do n = 1,n_refl

            p = p + 1

            h1 = .data.reflections(n).h
            h2 = .data.reflections(n).k
            h3 = .data.reflections(n).l

            k1(p) = B(1,1)*h1 + B(1,2)*h2 + B(1,3)*h3
            k2(p) = B(2,1)*h1 + B(2,2)*h2 + B(2,3)*h3
            k3(p) = B(3,1)*h1 + B(3,2)*h2 + B(3,3)*h3

         end

      end
   
   end

   set_hkl_up_to_stl_limit ::: leaky
   ! Set a h,k,l half-sphere ... useful for structure factor
   ! calculations without having to set reflections individually.

   ENSURE(.unit_cell.info_made,"no unit cell information")
   ENSURE(.data_exists,"no data")
   ENSURE(.data.reflections.destroyed,"no reflections")

      hkl,h_max :: VEC{INT}(3)
      k :: VEC{REAL}(3)
      i,h, h1,h2,h3 :: INT
      ref :: REFLECTION
      stl :: REAL

      ! Loop over axes
      do i = 1,3

         ! Max along direction "i"
         hkl = [0,0,0]
         h   = 0

         do 

            h = h + 1
            hkl(i) = h
            k.to_product_of(.unit_cell.reciprocal_matrix,REALIFY(hkl))
            stl = HALF*k.norm

            if (stl>.stl_limit) exit

         end

         ! Set the max
         h_max(i) = h - 1

      end

      ! Add the list of reflections
      ref.set_defaults
      REFLECTION:set_wavelength(.wavelength) ! Not selfless
      .data.reflections.create(0)

      do h1 = -h_max(1),h_max(1)
      do h2 = -h_max(2),h_max(2)
      do h3 = 0        ,h_max(3)

         ! Set hkl
         hkl = [h1,h2,h3]
         k.to_product_of(.unit_cell.reciprocal_matrix,REALIFY(hkl))
         stl = HALF*k.norm
         if (stl>.stl_limit) cycle

         ! Append
         ref.set_hkl(hkl)
         .data.reflections.append(ref)

      end
      end
      end

   end

!  =========================================
!  Fragment data, unique operators, Z number
!  =========================================

   make_fragment_data(atom,assign_atom,warnings) ::: leaky
   ! This routine sets the ".fragment_atom" from the "atom" list.
   ! If "assign_atom" is TRUE, ".fragment_atom" is pointed to "atom".
   !
   ! The fragment is a finite portion/model of the crystal, perhaps
   ! one molecule or a cluster of atoms. 
   ! 
   ! In addition a slew of information arrays about the fragment and
   ! crystal are made e.g. like the asymmetric unit atoms, the unit
   ! cell atoms; mapping arrays between these atoms; the stablizer
   ! symops ! for the fragment atoms; and the unit-cell connection
   ! table.
   !
   ! This is a suped-up set_defaults routine.
   !
   ! DETAILS:
   !
   ! A. The .asymmetric_unit_geometry is defined from the symmetry
   !    unique "atoms", if it is not already defined. If it is already
   !    defined the fragment atoms must be symmetry related to these
   !    asymmetric unit atom positions. The asymmetric unit is crucial
   ! B. The .asymmetric_unit_geometry is never destroyed unless
   !    explicitly requested.
   ! 1. The .unit_cell_geometry is made from the asymmetric unit. 
   !    Mapping arrays which relate the unit cell atoms to the
   !    asymmetric unit atoms are made, 
   ! 2. Other mapping arrays are made which relate the fragment atoms
   !    to the unique asymmetric unit atoms, including sometimes the
   !    symops needed to generate them.
   ! 3. The .repetition factors needed for structure factor calcs on
   !    the fragment are made. The Z number is made.
   !    unchanged (the stabilizer) is made
   ! 4. The unit cell connection table is made.
   ! 5. The set of symmetry operations which leave the fragment
   !    unchanged (the stabilizer) is made
      atom :: VEC{ATOM}*
      assign_atom :: BIN, optional
      warnings    :: BIN, optional

   ENSURE(atom.created,"no atom array")

      assign :: BIN

      assign = FALSE
      if (present(assign_atom)) assign = assign_atom

      if (NOT .spacegroup.analysed) return

      ! Store the fragment atom list
      if (assign) then; .fragment_atom => atom ! atom must be destroyable
      else;             .fragment_atom.create_copy(atom)
      end

      if (.debugging("make_fragment_data")) then
         stdout.text(">>make_fragment_data")
         stdout.text("fragment_atom (before):")
         .fragment_atom.put_coordinates_and_ADPs
         stdout.text("fragment_atom.pADP_vector (before):")
         .fragment_atom.put_pADPs
      end

      ! Get fragment geometry from the atom list
      .fragment_geometry.destroy
      .fragment_geometry => .fragment_atom.coordinates_ptr(skip_dummies=TRUE)
      .n_fragment_atoms  = .fragment_geometry.dim2
      .unit_cell.change_into_fractional(.fragment_geometry)

      ! Make .asymmetric_unit_geometry, unit_celli_geometry, as well
      ! as .asymmetric_unit_atom list, from fragment geometry ... 
      ! Only if they don't already exist
      if (.asymmetric_unit_geometry.destroyed) then
         .make_asymmetric_unit(.prune_asymmetric_unit,warnings)
         if (.asymmetric_unit_source=="?") &
             .asymmetric_unit_source = "from-fragment"
      end

      ! Sanity check
      DIE_IF(.asymmetric_unit_atom.destroyed,"no asymmetric_unit_atom list!")

    ! if (.debugging("make_fragment_data")) then
    !    stdout.text("fragment atoms:")
    !    .fragment_atom.dump("fragment_atom::")
    !    stdout.text("asymmetric unit atoms:")
    !    .asymmetric_unit_atom.dump("asymmetric_unit_atom::")
    ! end

      ! Relate fragment atoms to unit cell
      .make_frag_atom_for_cell_atom

      ! Make unique fragment atoms
      .make_unique_frag_atoms

      ! Make the unit cell connection table
      .make_unit_cell_connections
      .make_uc_vdw_connections

      ! Z factors and zep. factors for SF calculations
      .make_repetition_factors     
      .make_asym_atom_rep_factors     
      .Z = .z_factor

      ! Symops which leave fragment_geometry unchanged
      .make_stabilizer_symops 
      .make_stabilizer_xyz_matrices 

      .fragment_info_made = TRUE

   end

   make_fragment_data(fragment_geometry,cartesian) ::: leaky
   ! Makes an atom list from "fragment_geometry" to which
   ! .fragment_atoms gets set. The .asymmetric_unit_atoms (which must
   ! be in cartesian system) and .unit_cell_geometry have to be
   ! defined. Set "cartesian" to TRUE if the "fragment_geometry" is in
   ! cartesians, default is fractional coordinates.
      fragment_geometry :: MAT{REAL}, IN
      cartesian :: BIN, optional

   ENSURE(.unit_cell_geometry.created,           "no .unit_cell_geometry") 
   ENSURE(.asymmetric_unit_atom.created,         "no .asymmetric_unit_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.created, "no .asym_atom_for_unit_cell_atom")

      atom  :: VEC{ATOM}*
      list  :: VEC{INT}*
      pf,pu :: VEC{REAL}(3)
      fg :: MAT{REAL}*
      n_frag_atoms,f,u,a :: INT
      tol :: REAL
      cart,found :: BIN

      cart = FALSE
      if (present(cartesian)) cart = cartesian

      ! Transform fragment geometry to fractional
      fg.create_copy(fragment_geometry)
      if (cart) .unit_cell.change_into_fractional(fg)

      ! Create the list of atom indices -- leaky!!
      n_frag_atoms = fg.dim2
      list.create(n_frag_atoms)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = TOL(3)    

      ! Find and create fragment atoms
      do f = 1,n_frag_atoms

         ! Shift fragment atom to unit cell
         pf = fg(:,f)
         .put_to_unit_cell(pf)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            ! Is u the same as f?
            pu = .unit_cell_geometry(:,u)
            found = pu.same_as(pf,tol) 

            if (NOT found) cycle

            ! Set asymmetric atom index for atom f 
            a = .asym_atom_for_unit_cell_atom(u)
            list(f) = a

            exit 

         end

         DIE_IF(NOT found,"fragment atom "//trim(f.to_str)//" was not found in the unit cell")

      end

      ! Make the atom list, cartesian coordinates
      .unit_cell.change_from_fractional(fg)
      atom.create_copy(.asymmetric_unit_atom,list)
      atom.set_positions_to(fg)

      if (.debugging("make_fragment_data")) then
          stdout.put("make_fragment_data:")
          stdout.text("list:")
          stdout.put(list,by_column=TRUE)
          stdout.text("atom:")
          atom.dump("atom:VEC{ATOM}*")
      end

      ! Make the fragment data; make it destroyable
      .make_fragment_data(atom,assign_atom=TRUE,warnings=FALSE)
      .destroy_fragment_atom = TRUE

      ! Clean
      list.destroy
      fg.destroy

   end

   make_asymmetric_unit(prune_asymmetric_unit,warnings) ::: leaky, private
   ! Get the all the atom positions in the unit cell. Also make the
   ! symops associated with each unit cell atom when it is made from
   ! the asymmetric unit atoms. If "prune_asymmetric_unit" is present
   ! and true, any non-asymmetric unit atoms are eliminated from the
   ! asymmetric unit. This should always be done.
      prune_asymmetric_unit,warnings :: BIN, optional

   ENSURE(.fragment_atom.created,"no .fragment_atom") 
   ENSURE(.fragment_geometry.created,"no .fragment_geometry") 
   ENSURE(.asymmetric_unit_geometry.destroyed,"asymmetric unit exists") 

      pa :: VEC{REAL}(3)
      offset :: VEC{INT}(3)
      asymmetric_unit_geometry :: MAT{REAL}*
      n,a,b,s,col, i :: INT
      prune,warn,new,unique,frac,redundant,mess :: BIN
      pruned :: MAP{INT,INT}*
      list,cols :: VEC{INT}*
      tol :: REAL

      ! Set default options
      prune = TRUE
      warn = TRUE
      if (present(prune_asymmetric_unit)) prune = prune_asymmetric_unit
      if (present(warnings)) warn = warnings

      ! Clean up from before
      .unit_cell_geometry.destroy
      .unique_unit_cell_atom.destroy
      .unique_uc_atom_offset.destroy
      .is_asym_unit_cell_atom.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .asym_symop_for_unit_cell_atom.destroy

      ! List of indices of the asymmetric unit atoms to be made
      list.create(.n_fragment_atoms)
      list = [(a, a=1,.n_fragment_atoms)]

      ! Initialise .asymmetric_unit as the whole fragment
      .asymmetric_unit_geometry.create_copy(.fragment_geometry)
      .n_asymmetric_unit_atoms = .n_fragment_atoms

      ! Copy asymmetric unit, but put it to the unit cell
      asymmetric_unit_geometry.create_copy(.asymmetric_unit_geometry)
      .put_to_unit_cell(asymmetric_unit_geometry)

      ! Append new atoms "n" to unit cell
      .unit_cell_geometry.create(3,0)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = TOL(2)/maxval(.unit_cell.length) 
      tol = TOL(3)

      ! Fractional atom occupancies?
      frac = .fragment_atom.has_disorder
      WARN_IF(frac,"This structure has fractional occupancies and is disordered.")

      ! Initial loop counters
      pruned.create(0)
      redundant = FALSE
      n = 0 ! unit cell atom counter
      a = 0 ! asymmetric unit atom counter

      ! Loop: atoms "a" in
      ! the asymmetric unit
      do 

         ! Next asymmetric unit atom
         a = a + 1

         ! Loop over symops
         do s = 1,.spacegroup.n_seitz

            ! Get asymmetric unit atom cell-offset
            pa = .asymmetric_unit_geometry(:,a)
            .transform_position(pa,1,to_unit_cell=TRUE,unit_cell_shift=offset)

            ! Transform asym unit atom with symop "s"
            pa = asymmetric_unit_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)

            ! Prune symmetry redundant atoms?
            if (prune) then

               do ! remove *all* redundant atoms

                  ! Is symmetry-generated atom "pa" already in the asymmetric unit?
                  unique = NOT asymmetric_unit_geometry(:,a+1:).has_column(pa,col,tol)
                  if (unique) exit

                  ! Actual atom index to prune
                  b = col + a

                  ! If already there, are the atoms at the two sites distinct?
                  unique = .fragment_atom.are_distinct(list(a),list(b))
                  if (unique) exit

                  ! Store pruned pair
                  pruned.append_pair(list(a),list(b))

                  ! This is a symmetry-redundant structure
                  redundant = TRUE
                  frac = NOT .fragment_atom(list(b)).site_occupancy.equals(ONE)

                  ! Prune the atom
                  .n_asymmetric_unit_atoms = .n_asymmetric_unit_atoms - 1
                  .asymmetric_unit_geometry.prune_column(b)
                  asymmetric_unit_geometry.prune_column(b)
                  list.prune_element(b)

               end

            end

            ! Is symmetry-generated position "pa" new in the unit cell?
            nullify(cols)
            new = NOT .unit_cell_geometry.has_columns(pa,cols,tol)

            ! If it is there, is it a distinctly different atom?
            if (cols.dim>0) then
               do i = 1,cols.dim
                  b = .asym_atom_for_unit_cell_atom(cols(i))
                  new = .fragment_atom.are_distinct(list(a),list(b))
                  if (new) cycle
                  cols.destroy
                  exit
               end
            end

            if (NOT new) cycle

            ! New unit cell atom here ...
            n = n + 1 
            .unit_cell_geometry.append_column(pa)
            .asym_atom_for_unit_cell_atom.append(a)
            .asym_symop_for_unit_cell_atom.append(s)

            ! If s=1 it must be an asymmetric unit atom
            if (s==1) then
               .unique_unit_cell_atom.append(n)
               .unique_uc_atom_offset.append(offset)
               .is_asym_unit_cell_atom.append(TRUE)
            else
               .is_asym_unit_cell_atom.append(FALSE)
            end

         end

         ! Finished?
         if (a==.n_asymmetric_unit_atoms) exit

      end

      .n_unit_cell_atoms = n

      ! Sanity check and print out
      mess = warn AND redundant AND prune
      WARN_IF(mess,"Symmetry-redundant atoms were pruned.")

      ! Die if pruned a symmetry-redundant fractional atom.
      if (mess AND frac) then

         WARN("Symmetry-redundant pruned atom had a fractional occupancy!")

         stdout.flush
         stdout.text("Fragment atom list:")
         .fragment_atom.put_coordinates

         stdout.flush
         stdout.text("Parent and pruned fragment atoms:")
         stdout.flush
         do i = 1,pruned.n_keys
            stdout.put(pruned.keys(i))
            stdout.put(pruned.values(i))
            stdout.flush
         end
         DIE("Symmetry-redundant pruned atom had a fractional occupancy!")

      end

      ! Die if no unit cell
      DIE_IF(NOT .unit_cell_geometry.created,"The unit_cell_geometry was not created!")

      ! >> Make the asymmetric unit atoms <<
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_atom.create_copy(.fragment_atom,list)

      ! Clean
      asymmetric_unit_geometry.destroy
      list.destroy
      pruned.destroy

   end

   make_frag_atom_for_cell_atom ::: leaky, private
   ! Arrays which relate the fragment atoms to the unit cell atoms.

   ENSURE(.fragment_atom.created,                "no .fragment_atom") 
   ENSURE(.fragment_geometry.created,            "no .fragment_geometry") 
   ENSURE(.unit_cell_geometry.created,           "no .unit_cell_geometry") 
   ENSURE(.asymmetric_unit_atom.created,         "no .asymmetric_unit_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.created, "no .asym_atom_for_unit_cell_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.created,"no .asym_symop_for_unit_cell_atom")
   ENSURE(.spacegroup.analysed,                  "no spacegroup info") 

      sh :: VEC{INT}(3)
      pu,pa,pf :: VEC{REAL}(3)
      u,f,a,s :: INT
      found,ident :: BIN
      tol :: REAL

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)    

      ! Create the arrays we want
      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .unit_cell_shft_for_frag_atom.destroy
      .frag_atom_for_asym_atom.destroy
      .asym_atom_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_shift_for_frag_atom.destroy

      .frag_atom_for_unit_cell_atom.create(.n_unit_cell_atoms)
      .unit_cell_atom_for_frag_atom.create(.n_fragment_atoms)
      .unit_cell_shft_for_frag_atom.create(3,.n_fragment_atoms)
      .frag_atom_for_asym_atom.create(.n_asymmetric_unit_atoms)
      .asym_atom_for_frag_atom.create(.n_fragment_atoms)
      .asym_symop_for_frag_atom.create(.n_fragment_atoms)
      .asym_shift_for_frag_atom.create(3,.n_fragment_atoms)

      ! Initialise
      .frag_atom_for_unit_cell_atom = 0
      .unit_cell_atom_for_frag_atom = 0
      .unit_cell_shft_for_frag_atom = 0
      .frag_atom_for_asym_atom = 0
      .asym_atom_for_frag_atom = 0

      ! Loop over fragment atoms
      do f = 1,.n_fragment_atoms

         ! Shift fragment atom to unit cell
         pf = .fragment_geometry(:,f)
         .put_to_unit_cell(pf,shift=sh)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            ! Asymmetric atom a for unit cell atom u
            a = .asym_atom_for_unit_cell_atom(u)

            ! Unit cell position
            pu = .unit_cell_geometry(:,u)

            if (.debugging("make_frag_atom_for_cell_atom")) then
               stdout.show("f                         =",f)
               stdout.show("u                         =",u)
               stdout.show("a                         =",a)
               stdout.show("fragment position  pf     =",pf)
               stdout.show("cell atom position pu     =",pu)
            end

            ! Is unit cell atom u the fragment atom f?
            found = pu.same_as(pf,tol) 
            ident = .fragment_atom(f).is_xtal_identical_kind_to(.asymmetric_unit_atom(a))

            if (.debugging("make_frag_atom_for_cell_atom")) then
               stdout.show("same pos?                 =",found)
               stdout.show("xtal identical            =",ident)
               if (found) &
               stdout.text("SAME POS")
               stdout.text("===========================")
               stdout.text("===========================")
            end

            found = found AND ident

            ! Cycle if not the same
            if (NOT found) cycle

            ! Relate unit cell atom and fragment atom
            ! These are identical by translation.
            .frag_atom_for_unit_cell_atom(u) = f
            .unit_cell_atom_for_frag_atom(f) = u
            .unit_cell_shft_for_frag_atom(:,f) = sh

            ! Relate asym unit atom and fragent atom
            ! Maybe >1 frag atom  matching the asym atom
            .asym_atom_for_frag_atom(f) = a
            if (.frag_atom_for_asym_atom(a)==0) &
                .frag_atom_for_asym_atom(a) = f

            ! Asym symop which can generate this frag atom
            s = .asym_symop_for_unit_cell_atom(u)
            .asym_symop_for_frag_atom(f) = s
   
            ! Get shift for asym atom -> frag atom
            pa = .asymmetric_unit_geometry(:,a)
            pf = .fragment_geometry(:,f)
            .transform_position(pa,s,ignore_glide=TRUE)
            .asym_shift_for_frag_atom(:,f) = pf - pa

            exit 

         end

         if (NOT found) then
            DIE("fragment atom "//f.to_str.trim//" was not found in the unit cell")
         end

      end

      ! Relate unit cell atom to parent frag atom
      ! These are identical by a crystal symop.
      .frag_parent_for_cell_atom.destroy
      .frag_parent_for_cell_atom.create(.n_unit_cell_atoms)
      do u = 1,.n_unit_cell_atoms
         a = .asym_atom_for_unit_cell_atom(u)
         f = .frag_atom_for_asym_atom(a)
         .frag_parent_for_cell_atom(u) = f
      end

   end

   make_unique_frag_atoms ::: leaky, private
   ! Make the unique fragment atoms (these are those corresponding to
   ! the asymmetric unit atoms) and also make symops which relate the
   ! non-unique to the unique.
   ENSURE(.asym_atom_for_frag_atom.created, "no .asym_atom_for_frag_atom") 
   ENSURE(.unit_cell_atom_for_frag_atom.created, "no .unit_cell_atom_for_frag_atom") 
   ENSURE(.asym_symop_for_unit_cell_atom.created,"no .asym_symop_for_unit_cell_atom") 

      f,a,m,u,s,t :: INT
      unique :: BIN

      ! Create the arrays we want
      .unique_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .unique_symop_for_frag_atom.destroy

      .unique_atom_for_frag_atom.create(.n_fragment_atoms)
      .unique_symop_for_frag_atom.create(.n_fragment_atoms)

      .n_unique_frag_atoms = 0

      ! Loop over the fragment atoms
      do f = 1,.n_fragment_atoms

         ! Asym atom for this fragment atom
         a = .asym_atom_for_frag_atom(f)

         ! Asym symop which can generate this frag atom
         u = .unit_cell_atom_for_frag_atom(f)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Does this asym atom "a" occur before? 
         ! If not, its unique.
         m = .asym_atom_for_frag_atom(1:f-1).index_of_value(a)
         unique = m==0
         if (unique) then
            .n_unique_frag_atoms = .n_unique_frag_atoms + 1
            .unique_atom_for_frag_atom(f) = f
            .unique_symop_for_frag_atom(f) = 1 ! identity
            .unique_frag_atom.append(f)
         else
            .unique_atom_for_frag_atom(f) = m
            u = .unit_cell_atom_for_frag_atom(m)
            t = .asym_symop_for_unit_cell_atom(u)
            t = .spacegroup.inverse_of_symops(t)   ! inverse of symop(t) maps m -> a
            t = .spacegroup.product_of_symops(s,t) ! s maps a -> f (except for trans)
            .unique_symop_for_frag_atom(f) = t
         end

      end

   end

   make_unit_cell_connections ::: leaky
   ! From the .asymmetric_unit_atom list make the .unit_cell_connection
   ! table and the .unit_cell_mol_for_atom list which has the list of
   ! distinct molecules in the unit cell i.e. those groups of unit
   ! cell atoms which are connected to each other (ignoring/accounting
   ! for translational symmetry). NOTE: only connections to
   ! next-neighboring unit cells are considered regardless of the size
   ! of covalent radii.

   ENSURE(.unit_cell_geometry.created,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.created,"no frag_parent_for_cell_atom")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")

      new :: VEC{VEC_{INT}}*
      unit_cell_mol_for_atom,unique :: VEC{INT}*
      geom0,geom1 :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos_i,pos_j,offset :: VEC{REAL}(3)
      i,j,par_i,par_j, h1,h2,h3, mi,mj :: INT
      atom_i,atom_j :: ATOM

      ! Create the arrays we want
      .unit_cell_connection.destroy
      .unit_cell_mol_for_atom.destroy

      .unit_cell_connection.create(.n_unit_cell_atoms,0)
      .unit_cell_mol_for_atom.create(.n_unit_cell_atoms)

      ! Set worst case scenario: all atoms on different molecules
      unit_cell_mol_for_atom.create(.n_unit_cell_atoms)
      do i = 1,.n_unit_cell_atoms         
        unit_cell_mol_for_atom(i) = i
      end

      ! Define a new connected atom: its index and 3-element shift
      new.create(1)
      new(1).element.create(4)           

      ! Get unit cell cartesian geometry
      rcm = .unit_cell.direct_matrix
      geom0.create(3,.n_unit_cell_atoms)  
      geom0 = matmul(rcm,.unit_cell_geometry)

      ! First make connections in the unit cell
      ! and the distinct mols
      h1 = 0                             
      h2 = 0                             
      h3 = 0

        ! Loop over the (0,0,0) unit cell atoms i
        do i = 1,.n_unit_cell_atoms      

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i) 
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i) 

           ! Loop over the (0,0,0) unit cell atoms j
           do j = i+1,.n_unit_cell_atoms 

              ! Gross test for closeness
              pos_j = geom0(:,j)        
              if (abs(pos_j(1)-pos_i(1))>SEVEN) cycle
              if (abs(pos_j(2)-pos_i(2))>SEVEN) cycle
              if (abs(pos_j(3)-pos_i(3))>SEVEN) cycle 

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j) 
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              new(1)[:] = [h1,h2,h3,j]; .unit_cell_connection(i).element.append(new)
              new(1)[4] = i;            .unit_cell_connection(j).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)

              ! Replace all previous by the lowest mol
              if (mj<mi) then        
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end

      ! <<< Now make connections to neighbouring cells
      geom1.create(3,.n_unit_cell_atoms) 
      do h1 = -1,1                       
      do h2 = -1,1
      do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms     

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i) 
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i) ! Atom i belongs to mol "mi"

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms   

              ! Gross test for closeness
              pos_j = geom1(:,j)        
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle 

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j) 
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              new(1)[:] = [h1,h2,h3,j]
              .unit_cell_connection(i).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)
              if (mj<mi) then        ! replace all previous by the lowest mol
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end

      end
      end
      end

      ! Clean
      geom1.destroy; geom0.destroy
      new.destroy

      ! Now make the .unit_cell_mol_for_atom list consecutive
      .unit_cell_mol_for_atom = unit_cell_mol_for_atom
      unique => unit_cell_mol_for_atom.unique_elements
      unique.sort
      .n_unit_cell_mols = unique.dim
      do mi = 1,.n_unit_cell_mols
        mj = unique(mi)
        if (mj==mi) cycle
        where (unit_cell_mol_for_atom==mj) .unit_cell_mol_for_atom = mi
      end
      unique.destroy
      unit_cell_mol_for_atom.destroy

   end

   make_uc_vdw_connections ::: leaky
   ! From the .asymmetric_unit_atom list make the .uc_vdw_connection
   ! table. Essentially aame as above with different bond criteria.

   ENSURE(.unit_cell_geometry.created,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.created,"no frag_parent_for_cell_atom")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")
   ENSURE(.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom list")

      vdw :: VEC{VEC_{INT}}*
      geom0,geom1 :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos_i,pos_j,offset :: VEC{REAL}(3)
      i,j,par_i,par_j, h1,h2,h3 :: INT
      atom_i,atom_j :: ATOM

      ! Create the arrays we want
      .uc_vdw_connection.destroy
      .uc_vdw_connection.create(.n_unit_cell_atoms,0)

      ! Define a new connected atom: its index and 3-element shift
      vdw.create(1)
      vdw(1).element.create(4)           

      ! Get unit cell cartesian geometry
      rcm = .unit_cell.direct_matrix
      geom0.create(3,.n_unit_cell_atoms)  
      geom0 = matmul(rcm,.unit_cell_geometry)

      ! First make connections in the unit cell
      ! and the distinct mols
      h1 = 0                             
      h2 = 0                             
      h3 = 0

        ! Loop over the (0,0,0) unit cell atoms i
        do i = 1,.n_unit_cell_atoms      

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i) 
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Loop over the (0,0,0) unit cell atoms j
           do j = i+1,.n_unit_cell_atoms 

              ! Gross test for closeness
              pos_j = geom0(:,j)        
              if (abs(pos_j(1)-pos_i(1))>SEVEN) cycle
              if (abs(pos_j(2)-pos_i(2))>SEVEN) cycle
              if (abs(pos_j(3)-pos_i(3))>SEVEN) cycle 

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j) 
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              if (.unit_cell_mol_for_atom(i)==.unit_cell_mol_for_atom(j)) cycle
              if (NOT atom_i.is_vdw_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              vdw(1)[:] = [h1,h2,h3,j]; .uc_vdw_connection(i).element.append(vdw)
              vdw(1)[4] = i;            .uc_vdw_connection(j).element.append(vdw)

           end
        end

      ! <<< Now make connections to neighbouring cells
      geom1.create(3,.n_unit_cell_atoms) 
      do h1 = -1,1                       
      do h2 = -1,1
      do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms     

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i) 
           atom_i.set_atomic_number(.asymmetric_unit_atom(par_i).atomic_number)
           atom_i.set_position(pos_i)

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms   

              ! Gross test for closeness
              pos_j = geom1(:,j)        
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle 

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j) 
              atom_j.set_atomic_number(.asymmetric_unit_atom(par_j).atomic_number)
              atom_j.set_position(pos_j)

              ! Cycle if not bonded ...
              if (.unit_cell_mol_for_atom(i)==.unit_cell_mol_for_atom(j)) cycle
              if (NOT atom_i.is_vdw_bonded_to(atom_j)) cycle

              vdw(1)[:] = [h1,h2,h3,j]
              .uc_vdw_connection(i).element.append(vdw)

           end
        end

      end
      end
      end

      ! Clean
      geom1.destroy; geom0.destroy
      vdw.destroy

   end

   z_factor result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined
   ! as the ratio of the number of electrons in the unit cell on the
   ! number of electrons in the fragment. 
      res :: REAL

   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom")
   ENSURE(.fragment_atom.created,       "no fragment_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.created,"no asym_atom_for_unit_cell_atom")

      ue,fe :: REAL

      ! Get # of electrons in unit cell
      ue = .asymmetric_unit_atom(.asym_atom_for_unit_cell_atom).no_of_electrons

      ! Get # of electrons in fragment
      fe = .fragment_atom.no_of_electrons

      ! Z factor is the ratio
      res = ue/fe

   end

!  ==================
!  Repetition factors
!  ==================

   make_repetition_factors ::: leaky, private
   ! The number of times a fragment atom with index "a" is mapped into
   ! itself under the symmetry group is the ".repetition_factor(a)".
   ! It is used to correct structure factors for fragment geometries
   ! which are "oversampled" relative to the asymmetric cell geometry.

   ENSURE(.fragment_geometry.created, "no fragment_geometry!")

      pa,pb :: VEC{REAL}(3)
      a,b,n,n_same :: INT
      same :: BIN
      tol :: REAL

      if (.use_manual_repetition_factors) then
         ENSURE(.repetition_factor.created,"no repetiton_factors entered!")
      else
         tol = TOL(2)/maxval(.unit_cell.length)
         tol = TOL(3)                        ! <--- getting this number wrong can stuff things
         .repetition_factor.destroy
         .repetition_factor.create(.n_fragment_atoms)
         do a = 1,.n_fragment_atoms
            pa = .fragment_geometry(:,a)
            .put_to_unit_cell(pa)
            n_same = 0
            do b = 1,.n_fragment_atoms
            do n = 1,.spacegroup.n_seitz
               pb = .fragment_geometry(:,b)
               .transform_position(pb,n,to_unit_cell=TRUE)
               same = pa.same_as(pb,tol)
               if (same) n_same = n_same + 1
            end
            end
            .repetition_factor(a) = n_same
         end
      end
   end

   make_asym_atom_rep_factors ::: leaky, private
   ! The number of times an asymmetric cell atom with index "a" is
   ! mapped into itself under the symmetry group is the
   ! ".asym_atom_rep_factor(a)". Also record the stabilizing
   ! operations in ".asym_atom_stabilizer(a)[:]". These are used in
   ! atomic-type structure factor calculations based on the asymmetric
   ! cell geometry.

   ENSURE(.fragment_geometry.created, "no fragment_geometry!")

      pa,pn :: VEC{REAL}(3)
      a,n,n_same :: INT
      same :: BIN
      tol :: REAL

      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      .asym_atom_rep_factor.destroy
      .asym_atom_stabilizer.destroy
      .asym_atom_rep_factor.create(.n_asymmetric_unit_atoms)
      .asym_atom_stabilizer.create(.n_asymmetric_unit_atoms)
      do a = 1,.n_asymmetric_unit_atoms
         pa = .asymmetric_unit_geometry(:,a)
         .put_to_unit_cell(pa)
         n_same = 0
         do n = 1,.spacegroup.n_seitz
            pn = pa
            .transform_position(pn,n,to_unit_cell=TRUE)
            same = pa.same_as(pn,tol)
            if (NOT same) cycle
            n_same = n_same + 1
            .asym_atom_stabilizer(a).element.append(n)
         end
         .asym_atom_rep_factor(a) = n_same
      end
   end

!  =============================
!  Reset hydrogen atom positions
!  =============================

   reset_H_bond_lengths_in(atom,H_bond_length,reset) 
   ! Resets the coordinates of the single-bonded H "atoms" so that
   ! their bond lengths have those in the "H_bond_length" array.
   ! Negative values mean no changes. If present "reset" is set
   ! TRUE if at least on the H atom positions was reset. 
   ! *Multiple bonded H atom (from unit cell conn. table) *ignored*
   ! WARNING: this routine destroys all the fragment data.
      self :: PTR
      atom :: VEC{ATOM}*
      H_bond_length :: VEC{REAL}*
      reset :: BIN, optional

   ENSURE(H_bond_length.created,"no H_bond_length array")

      lb,ub,ua,fh,fa,uh,Za,n :: INT
      hh,ph,pa,sh,ch,ca,dd,d :: VEC{REAL}(3)
      rcm,inv :: MAT{REAL}(3,3)
      done :: BIN

      if (all(H_bond_length<ZERO)) return

      ! Destroy all the fragment and asymmetric unit data
      .destroy_fragment_data
      .destroy_asymmetric_unit

      ! Make unit cell connection table
      .make_fragment_data(atom,assign_atom=FALSE)

      ! Elements whose bond lengths to change
      lb = lbound(H_bond_length,1)
      ub = ubound(H_bond_length,1)

      ! Cell matrices
      rcm = .unit_cell.direct_matrix
      inv = .unit_cell.inverse_matrix

      done = FALSE

      ! Loop fragment atom positions
      do fh = 1,.n_fragment_atoms

         ! If fragment atom is not H atom, cycle ...
         if (atom(fh).atomic_number/=1) cycle

         ! The H atom  must have only one bond
         uh = .unit_cell_atom_for_frag_atom(fh) 
         if (.unit_cell_connection(uh).element.dim>1) then
            n = .unit_cell_connection(uh).element.dim
            WARN("Hydrogen # "//fh.to_str.trim//" is bonded to "//n.to_str.trim//" atoms")
            cycle
         end

         ! Which frag atom is the H connected to?
         ua = .unit_cell_connection(uh)[1][4]
         fa = .frag_atom_for_unit_cell_atom(ua) 
         if (fa==0) cycle

         ! If it isn't one of those to be reset, cycle
         Za = atom(fa).atomic_number
         if (Za<lb OR Za>ub) cycle
         if (H_bond_length(Za)<ZERO) cycle

         done = TRUE

         ! Get the H atom pos relative to A
         hh = .fragment_geometry(:,fh)
         pa = .fragment_geometry(:,fa)
         dd = hh - pa
         d  = mod(dd,[ONE,ONE,ONE])
         where (d> HALF) d = d - ONE
         where (d<-HALF) d = d + ONE
         ph = pa + d
         sh = ph - hh

         ! Get new cartesian H atom position
         ch = matmul(rcm,ph)
         ca = matmul(rcm,pa)
         dd = ch - ca
         dd.normalise
         ch = ca + H_bond_length(Za)*dd

         ! Put H atom back
         ph = matmul(inv,ch) - sh
         ch = matmul(rcm,ph)

         ! Reset the H atom position
         atom(fh).set_position(ch)

      end

      if (present(reset)) reset = done 

      ! Clean up
      .destroy_fragment_data

   end

!  ================
!  Position changes
!  ================

   transform_geometry(g,op,translate,ignore_glide,to_unit_cell)
   ! Transform the positions "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (1,1,1) unit cell.
      g :: MAT{REAL}
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
   ENSURE(g.dim1==3,"incorrect size for array g")
      n :: INT
      do n = 1,g.dim2
         .transform_position(g(:,n),op,translate,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,translate,ignore_glide,to_unit_cell,unit_cell_shift) 
   ! Transform the position "p" in fractional coordinates with the Seitz
   ! operator with index "op". If present, "translate" will be added to the
   ! transformed position. If present and TRUE, "ignore_glide" will not add the
   ! glide vector part of the Seitz operator.  If present and TRUE,
   ! "to_unit_cell" will translate the fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell, and "unit_cell_shift" is set to the translation
   ! vector required to do this.
      p :: VEC{REAL}(3)
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
      unit_cell_shift :: VEC{INT}(3), optional
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialized")
   ENSURE(op>0,"operator index out of bounds")
   ENSURE(op<=.spacegroup.n_seitz,"operator index out of bounds")
      ignore,to_cell :: BIN
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p)
      else
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p) + .spacegroup.seitz(1:3,4,op)
      end
      if (present(translate)) p = p + translate
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p,unit_cell_shift)
   end

   put_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      g :: MAT{REAL}
   ENSURE(g.dim1==3 OR g.dim2==3, "incorrect shape for array g")
      n :: INT
      if (g.dim1==3) then
         do n = 1,g.dim2
            .put_to_unit_cell(g(:,n))
         end
      else
         do n = 1,g.dim1
            .put_to_unit_cell(g(n,:))
         end
      end
   end

   put_to_unit_cell(p,shift)
   ! Transform the position "p" in fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell. If present, "shift" is set to the translation
   ! vector needed to effect the change to the unit cell.
      p :: VEC{REAL}(3)
      shift :: VEC{INT}(3), optional

   ENSURE(size(p)==3, "p must be length 3")

      new :: VEC{REAL}(3)
      tol,pi :: REAL
      i :: INT

      tol = TOL(1)/maxval(.unit_cell.length)
      tol = TOL(3)

      do i = 1,3
         pi = REALIFY(nint(p(i)))
         if (abs(p(i)-pi)<tol) p(i) = pi
      end

      new = p - floor(p)

      if (present(shift)) shift = nint(new - p)

      p = new

   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      g :: MAT{REAL}

   ENSURE(size(g,1)==3, "incorrect size for array g")

      n,n_atom :: INT
      center :: VEC{INT}(3)

      if (FALSE) self = self

      n_atom = g.dim2
      center = CRYSTAL::unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - center
      end

   end

   unit_cell_offset(g) result (res) ::: selfless, private
   ! Which hkl indices match the center of the fragment geometry "g" when
   ! expressed in crystal coordinates.  Usually we expect that it is 0,0,0 but
   ! not always.
      g :: MAT{REAL}
      res :: VEC{INT}(3)
   ENSURE(g.dim1==3, "incorrect size for array g")
      res = int(sum(g,dim=2)/g.dim2)
   end

!  ===============
!  Fragment widths
!  ===============

   fragment_width result (res)
   ! Return the width "res" of the fragment in each of the 3 axis directions.
      res :: VEC{REAL}(3)
   ENSURE(.fragment_geometry.created,"no fragment geometry")
      res = .fragment_geometry.max_abs_column_difference
   end

   cartesian_fragment_width result (res)
   ! Return the cartesian width "res" of the fragment in each of the three axis
   ! directions.
      res :: VEC{REAL}(3)
      res = .fragment_width
      .unit_cell.change_from_fractional(res)
   end

!  ==============
!  Seitz matrices
!  ==============

   make_xyz_seitz_matrices(res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S_cartesian  =  D  S^_crystal  D^-1
   ! NOTE: I think they are not transposed any more ...
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end

   end

   xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. 
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end

   end

   transposed_xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. 
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.reciprocal_matrix, &
                      matmul(transpose(.spacegroup.seitz(1:3,1:3,i)), &
                             transpose(.unit_cell.direct_matrix)))
      end

   end

!  ===========
!  Stabilizers
!  ===========

   make_stabilizer_symops ::: leaky, private
   ! Make a list of the indices of the Seitz matrices, ".stabilizer_symop", which
   ! will generate the same geometries to that in ".fragment_geometry" when
   ! both the original and transformed geometries are converted to unit cell
   ! coordinates.  ".n_stabilizer_symops" is set to the number of these 
   ! symmetry operations.
      g1,gi :: MAT{REAL}*
      i,n :: INT
      identical :: BIN

      .stabilizer_symop.destroy
      .stabilizer_symop.create(.spacegroup.n_seitz)

      g1.create(3,.n_fragment_atoms)
      gi.create(3,.n_fragment_atoms)
      g1 = .fragment_geometry

      n = 1
      .stabilizer_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         gi = .fragment_geometry
         .transform_geometry(gi,i)
         identical  = .is_same_geometry(gi,g1)
         if (NOT identical) cycle
         n = n + 1
         .stabilizer_symop(n) = i
      end
      gi.destroy
      g1.destroy

      .n_stabilizer_symops = n
      .stabilizer_symop.shrink(n)

   end

   is_same_geometry(geom_i,geom_j) result (res) ::: private
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      geom_i,geom_j :: MAT{REAL}
      res :: BIN
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialized")
   ENSURE(geom_i.dim1==3,"incorrect size for array geom_i")
   ENSURE(geom_j.dim1==3,"incorrect size for array geom_j")
   ENSURE(geom_i.dim2==geom_j.dim2,"incompatible sizes for geom_i, geom_j")
      i,j,n_atom :: INT
      skip :: VEC{BIN}*
      same :: BIN
      tol :: REAL
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      n_atom = geom_i.dim2
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j),tol)
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   xyz_stabilizer_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis which stabilize the fragment geometry. 
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
   ENSURE(.stabilizer_symop.created,"no stabilizer symop matrices")
      i,s :: INT
      res.create(3,3,.n_stabilizer_symops)
      do i = 1,.n_stabilizer_symops
         s = .stabilizer_symop(i)
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,s),.unit_cell.inverse_matrix))
      end
   end

   make_stabilizer_xyz_matrices ::: leaky, private
   ! Make the representation matrices for xyz products found in
   ! gaussian shells, i.e. work out matrix R, where the shell row vector
   ! p'(r) = p(S^{-1}r) = p(r)R, and S is a stabilizer symop.
   ! WARNING: this routine is tied to an explicit ordering of the cartesian
   ! gaussian basis functions in a shell.
      str :: MAT3{REAL}*

      .str.destroy
      .ptr.destroy
      .dtr.destroy
      .ftr.destroy
      .gtr.destroy

      str.create(1,1,.n_stabilizer_symops)
      str = ONE
      .str => str                          ! 1  x 1
      .ptr => .xyz_stabilizer_matrices     ! 3  x 1
      .dtr => .ptr.gaussian_d_xyz_matrices ! 6  x 6
      .ftr => .ptr.gaussian_f_xyz_matrices ! 10 x 10
      .gtr => .ptr.gaussian_g_xyz_matrices ! 15 x 15

   end

   xyz_stabilizer_matrix(n,l) result (res)
   ! Return the "n"-th stabilizer representation matrix for xyz
   ! product found in a gaussian shell of angular momentum "l"
      n,l :: INT
      res :: MAT{REAL}*
   ENSURE(l>=0,"l must be non-negative")
   ENSURE(l<5, "l must be less than 5 (no h functions or higher)")
      select case (l)
         case(0); res => .str(:,:,n)
         case(1); res => .ptr(:,:,n)
         case(2); res => .dtr(:,:,n)
         case(3); res => .ftr(:,:,n)
         case(4); res => .gtr(:,:,n)
         case default; DIE("not implemented beyond l=4")
      end
   end

!  ===========================================
!  No. of unique reflections, pruning, merging
!  ===========================================

   make_list_of_equivalents(list,n_unique,show) ::: leaky, private
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
      self :: IN
      list :: VEC{VEC_{INT}}*
      n_unique :: INT, OUT
      show :: BIN, IN, optional

   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")

      i,j,g,n_refl :: INT
      p,q,r :: VEC{INT}(3)
      same,disp :: BIN

      disp = FALSE
      if (present(show)) disp = show

      n_refl = .data.reflections.n_refl
      list.create(n_refl)
      list(1).element.append(1)

      n_unique = 1
      do i = 2,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 
        same = FALSE
        main: do g = 1,.spacegroup.n_seitz
           do j = 1,i-1
              q(1) = .data.reflections(j).h 
              q(2) = .data.reflections(j).k 
              q(3) = .data.reflections(j).l 
              r = int(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
              same = p.same_as(r) OR p.same_as(-r)
              if (NOT same) cycle
              exit main
           end
        end do main
        if (same) then
           list(j).element.append(i)
           list(i).element.append(j)
           if (disp) then
           stdout.text("reflections "//trim(i.to_str)//" and "//trim(j.to_str)//" are the same")
           end
        else
           n_unique = n_unique + 1
           list(i).element.append(i)
        end
      end
   end

   merge_equivalents ::: leaky
   ! This routine will merge this list of equivalents into a single reflections
   ! with a particular sigma value associated with it. WARNING: it assumes that
   ! there are a sufficient number of equivalents so that the sigma value can be
   ! calculated by the standard formula for the standard deviation.

   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")

      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n,i :: INT

      n_refl = .data.reflections.n_refl

      .make_list_of_equivalents(list,n_unique)

      reflections.create(n_unique)
      n = 0
      do i = 1,n_refl
        if (list(i)[1]<i) cycle
        n = n + 1
        reflections(n) = .data.reflections(i)
        reflections(n).F_exp   = .data.reflections(list(i)[:]).F_exp.mean
        reflections(n).F_sigma = .data.reflections(list(i)[:]).F_exp.standard_deviation
      end
      .data.reflections.destroy
      .data.reflections => reflections

      ! Clean up
      list.destroy

   end

   make_list_of_equivalents_ord(list,n_unique,show) ::: leaky, private
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
      self :: IN
      list :: VEC{VEC_{INT}}*
      n_unique :: INT, OUT
      show :: BIN, IN, optional
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
      i,j,g,n_refl :: INT
      p,q,r :: VEC{INT}(3)
      same,disp :: BIN
      disp = FALSE
      if (present(show)) disp = show
      n_refl = .data.reflections.n_refl
      list.create(n_refl)
      list(1).element.append(1)
      n_unique = 1
      do i = 2,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 
        same = FALSE
        j = i-1
        main: do g = 1,.spacegroup.n_seitz
           q(1) = .data.reflections(j).h 
           q(2) = .data.reflections(j).k 
           q(3) = .data.reflections(j).l 
           r = int(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
           same = p.same_as(r) OR p.same_as(-r)
           if (NOT same) cycle
           exit main
        end do main
        if (same) then
           list(j).element.append(i)
           list(i).element.append(j)
           if (disp) then
           stdout.text("reflections "//trim(i.to_str)//" and "//trim(j.to_str)//" are the same")
           end
        else
           n_unique = n_unique + 1
           list(i).element.append(i)
        end
      end
   end

   merge_ordered_equivalents ::: leaky
   ! This routine will merge apartially ordered list of equivalents into a
   ! single reflections with a particular sigma value associated with it.
   ! WARNING: it assumes that there are a sufficient number of equivalents so
   ! that the sigma value can be calculated by the standard formula for the
   ! standard deviation.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n,i :: INT
      n_refl = .data.reflections.n_refl
      .make_list_of_equivalents_ord(list,n_unique)
      reflections.create(n_unique)
      n = 0
      do i = 1,n_refl
        if (list(i)[1]<i) cycle
        n = n + 1
        reflections(n) = .data.reflections(i)
        reflections(n).F_exp   = .data.reflections(list(i)[:]).F_exp.mean
        reflections(n).F_sigma = .data.reflections(list(i)[:]).F_exp.standard_deviation
      end
      .data.reflections.destroy
      .data.reflections => reflections
      list.destroy
   end

   expand_unique_reflections ::: leaky
   ! This routine will expand a unique list of reflections into a
   ! complete redundant list of reflections.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n_max,n,i,j,g :: INT
      p,q,r :: VEC{INT}(3)
      same :: BIN

      ! Store the number of reflections
      n_refl = .data.reflections.n_refl

      ! Make the list of equivalents, to detect any repetitions
      .make_list_of_equivalents(list,n_unique,show=TRUE)
      DIE_IF(n_unique/=n_refl,"the list of reflections is not unique")
      list.destroy

      ! Create the maximum possible list of total reflections
      n_max = n_refl*.spacegroup.n_seitz
      reflections.create(n_refl*.spacegroup.n_seitz)

      ! Loop over remaining reflections
      n = 0
      do i = 1,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 

        ! Apply symmetry to this relflection
        do g = 1,.spacegroup.n_seitz
           r = int(matmul(.spacegroup.seitz(1:3,1:3,g),p),kind=INT_KIND)

           ! Is it the same as another in the list? 
           same = FALSE
           do j = 1,n-1
              q(1) = reflections(j).h 
              q(2) = reflections(j).k 
              q(3) = reflections(j).l 
              same = q.same_as(r)
              if (same) exit
           end
           if (NOT same) then
              n = n + 1
              DIE_IF(n>n_max,"more than expected number of reflections")
              reflections(n) = .data.reflections(i)
              reflections(n).h = r(1)
              reflections(n).k = r(2)
              reflections(n).l = r(3)
           end
        end
      end
      reflections.shrink(n)
      .data.reflections.destroy
      .data.reflections => reflections
   end

!  =====================================
!  Service methods used by other modules
!  =====================================

   sum_unique_sf(sf,unique_sf)
   ! Form the structure factors "sf" from the sum of the list of
   ! unique structure factors, "unique_sf".
      sf :: VEC{CPX}
      unique_sf :: VEC{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf(sf,unique_sf,.data.reflections)

   end

   sum_unique_sf_ints(sf_ints,unique_sf_ints)
   ! Form the structure factor integrals "sf_ints" from a sum of the list
   ! of unique structure factors integrals  "unique_sf_ints".
      sf_ints :: MAT3{CPX}
      unique_sf_ints :: MAT3{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_ints(sf_ints,unique_sf_ints,.data.reflections)
   end

   sum_unique_sf_derivs(sf,unique_sf)
   ! Form the structure factor derivatives "sf" from a sum of the list
   ! of unique structure factor derivatives "unique_sf".
      sf :: MAT{CPX}, OUT
      unique_sf :: MAT{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_derivs(sf,unique_sf,.data.reflections)
   end

   sum_unique_sf_derivs_t(sf,unique_sf)
   ! Form the structure factor derivatives "sf" from a sum of the list
   ! of unique structure factor derivatives "unique_sf".
      sf :: MAT{CPX}, OUT
      unique_sf :: MAT{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_derivs_t(sf,unique_sf,.data.reflections)
   end

   sum_unique_sf_pts(X,k_pts,pts,tf,Fr,Fc)
   ! Form "X", the sum of the FT phase factor e^(i k.r) times the
   ! symmetry phases (which arise from copying the molecule
   ! around the unit cell) for a series of "k_pts" and space "pts",
   ! multiplied by a given k-space factor "(Fr,Fc)". The result "X" is
   ! of length of the number of space points
      X :: VEC{REAL}, OUT
      k_pts,pts :: MAT{REAL}, IN
      tf :: VEC{REAL}, IN
      Fr,Fc :: VEC{REAL}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_pts(X,k_pts,pts,tf,Fr,Fc,.data.reflections)

   end

   sum_unique_sf_pts(X,k_pts,pts,tf,Fr,Fc)
   ! Form "X", the sum of the FT phase factor e^(i k.r) times the
   ! symmetry phases (which arise from copying the molecule
   ! around the unit cell) for a series of "k_pts" and space "pts",
   ! multiplied by a given k-space factor "(Fr,Fc)". The result "X" is
   ! of length of the number of space points
      X :: VEC{REAL}, OUT
      k_pts,pts :: MAT{REAL}, IN
      tf :: VEC{CPX}, IN
      Fr,Fc :: VEC{REAL}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_pts(X,k_pts,pts,tf,Fr,Fc,.data.reflections)

   end

! Don't delete code below just yet ...

!   make_phased_matrix_for_symop(u,phase,mask) ::: private
!   ! Return the sum of the "phase" shifts times the seitz matrices for all
!   ! symops which are equivalent to the "u"-th unique symmetry operation,
!   ! .spacegroup.unique_SF_symop(u), as determined by the "mask" array, when
!   ! mask(u)==.spacegroup.unique_SF_symop(u).
!     u :: INT, IN
!     phase :: MAT3{CPX}, OUT
!     mask :: VEC{INT}, IN
!
!   ENSURE(.spacegroup.analysed,"no spacegroup")
!   ENSURE(u<=.spacegroup.n_unique_SF_symops,"symop index out of range")
!   ENSURE(phase.dim1==.data.reflections.n_refl,"wrong size, dim=1, phase array")
!   ENSURE(phase.dim2==3,"wrong size, dim=2, phase array")
!   ENSURE(phase.dim3==3,"wrong size, dim=3, phase array")
!
!     pi2,tx,ty,tz,dot :: REAL
!     s,n,n_refl,h,k,l :: INT
!     seitz :: MAT{REAL}(4,4)
!     refl :: VEC{REFLECTION}*
!
!     refl => .data.reflections
!     n_refl = refl.dim
!     pi2 = TWO*PI
!
!     phase = ZERO
!     do s = 1,.spacegroup.n_seitz
!
!       ! Sum only those which match unique symop u
!       if (mask(s)/=.spacegroup.unique_SF_symop(u)) cycle
!
!       ! Get the symop translation vector
!       seitz = .spacegroup.seitz(:,:,s)
!       tx = pi2*seitz(1,4)
!       ty = pi2*seitz(2,4)
!       tz = pi2*seitz(3,4)
!
!       ! Sum the phase here
!       ! This seems a kludge because we don't know the magnetic symmetry
!       if (seitz(3,3)>0) then                  ! M points along +z always
!         do n = 1,n_refl
!           h = refl(n).h
!           k = refl(n).k
!           l = refl(n).l
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       else                                    ! M points in -z direction
!         seitz(3,:3) = -seitz(3,:3)            ! Invert
!         do n = 1,n_refl
!           h = refl(n).h
!           k = refl(n).k
!           l = refl(n).l
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       end
!
!     end
!
!   end
!
!   sum_PND_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phased_matrix_for_symop(u,phase,.spacegroup.translated_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              unique_ft_ints(uf+n,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phased_matrix_for_symop(u,phase,.spacegroup.inverted_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!        end
!
!     end
!     phase.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S=sigma/2 operator, and g_e x mu_B = 1.
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_PND_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a_3 integrals "ft_ints", required for the
!   ! PND magnetic structure factors, from a sum of "unique_ft_ints".
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT3{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phased_matrix_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*unique_ft_ints(uf+n,:,:,1) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*unique_ft_ints(uf+n,:,:,2) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*unique_ft_ints(uf+n,:,:,3)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phased_matrix_for_symop(u,phase,mask=.spacegroup.translated_symop) ! .inverted_symop here ??????????????
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*conjg(unique_ft_ints(uf+n,:,:,1)) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*conjg(unique_ft_ints(uf+n,:,:,2)) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*conjg(unique_ft_ints(uf+n,:,:,3))
!       end
!     end
!     phase.destroy
!
!     ! The factor of 2 to convert to Bohr magnetons cancels the factor
!     ! of 1/2 for the Bohr magneton.
!     do n = 1,n_refl
!       ft_ints(n,:,:) = ft_ints(n,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_ft_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.n_refl,n_comp_a,n_comp_b,3,3].
!     ft_ints :: MAT5{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT{CPX}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:)
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     do n = 1,n_refl
!        ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
!   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!     B :: VEC{REAL}(3)
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT3{CPX}*
!     u,uf,n,n_refl :: INT
!     ci :: CPX
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     ci = (ZERO,ONE)
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
!   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!      ft_ints :: MAT4{CPX}
!      unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!      phase :: VEC{CPX}*
!      q :: MAT{REAL}*
!      ints :: MAT3{CPX}*
!      u,uf,n,n_refl :: INT
!
!      n_refl = .data.reflections.n_refl
!      phase.create(n_refl)
!      q.create(n_refl,3)
!      ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!      .make_k_pts(q)
!
!      ft_ints = ZERO
!      do u = 1,.spacegroup.n_unique_SF_symops
!
!         uf = n_refl*(u-1)
!
!         ! Add up translated symop contribution
!         .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!         do n = 1,n_refl
!            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!         ! Add up inverted symop contribution, if any
!         if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!         .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!         do n = 1,n_refl
!            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!      end
!      ints.destroy
!
!      ! The factor of 2 to convert to Bohr magnetons cancels the factor
!      ! of 1/2 for the Bohr magneton
!      ! Extra minus sign introduced, but not sure why ...
!      ! Reversed minus sign introduced ...
!      do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!      end
!      q.destroy
!      phase.destroy
!
!   end
!
!   sum_ft_j_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform j integrals "ft_ints", required for the PND
!   ! magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     u,uf, n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
!        end
!
!     end
!     phase.destroy
!
!   end

!  ===============
!  Electric fields
!  ===============

!   make_Lorentz_fields(F,sphere_sum)
!   ! Make the Lorentz electric fields at the unit cell atom sites.
!   ! Warning: the asymmetric_unit_atom's should be generated from the
!   ! fragment where charges and dipoles have been done.
!      F :: MAT{REAL}, OUT
!      sphere_sum :: BIN, optional
!
!      symop :: MAT3{REAL}*
!      pos,L0,L1 :: MAT{REAL}* 
!      charge,dipole :: VEC{REAL}*
!      mol :: VEC{INT}*
!      fac :: REAL
!      n_atom,dim, u,a,s, fu,lu :: INT
!
!      ! No. of atoms in unit cell
!      n_atom = .n_unit_cell_atoms    
!      dim    = 3*n_atom
!
!      ! Make the Lorentz factor tensors L0, L1
!      L0.create(dim,n_atom)      ! charge L0 tensor
!      L1.create(dim,dim)         ! dipole L1 tensor
!      pos.create(3,n_atom)
!      pos = matmul(.unit_cell.direct_matrix,.unit_cell_geometry)
!      mol => .unit_cell_mol_for_atom 
!      .unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)
!      fac = FOUR*PI/.unit_cell.volume
!      L0 = fac*L0
!      L1 = fac*L1
!
!
!      ! Cartesian symops
!      symop => .xyz_seitz_matrices
!
!      ! Unit cell charges and dipoles
!      charge.create(n_atom)
!      dipole.create(dim)
!
!      ! Get unit cell charges and dipoles
!      lu = 0
!      do u = 1,n_atom
!         a = .asym_atom_for_unit_cell_atom(u)
!         s = .asym_symop_for_unit_cell_atom(u)
!         charge(u) = .asymmetric_unit_atom(a).charge 
!         fu = lu + 1
!         lu = lu + 3
!         dipole(fu:lu) = matmul(symop(:,:,s),.asymmetric_unit_atom(a).dipole)
!      end
!      
!      ! Assign electric fields
!      lu = 0
!      do a = 1,.n_fragment_atoms
!         u  = .unit_cell_atom_for_frag_atom(a)
!         lu = 3*(u-1)
!         fu = lu + 1
!         lu = lu + 3
!       ! F(:,a) = matmul(L0(fu:lu,:),charge) + matmul(L1(fu:lu,:),dipole)
!         F(:,a) = matmul(L1(fu:lu,:),dipole)
!       ! F(:,a) = matmul(L0(fu:lu,:),charge)
!      end
!
!      .put_debug(charge,"make_Lorentz_fields: charge")
!      .put_debug(dipole,"make_Lorentz_fields: dipole")
!      .put_debug(transpose(pos),"make_Lorentz_fields: pos")
!      .put_debug(mol,"make_Lorentz_fields: mol")
!      .put_debug(transpose(F),"make_Lorentz_fields: F")
!      .put_debug(L0,"make_Lorentz_fields: L0")
!      .put_debug(L1,"make_Lorentz_fields: L1")
!      .put_debug(matmul(L0,charge),"make_Lorentz_fields: L0 x charge")
!      .put_debug(matmul(L1,dipole),"make_Lorentz_fields: L1 x dipole")
!      .put_debug(.asym_symop_for_unit_cell_atom,"make_Lorentz_fields: asym_symop_for_unit_cell_atom")
!      .put_debug(.unit_cell_atom_for_frag_atom,"make_Lorentz_fields: unit_cell_atom_for_frag_atom")
!
!      ! Clean up
!      dipole.destroy; charge.destroy
!      symop.destroy
!      pos.destroy
!      L1.destroy; L0.destroy 
!
!   end

!  ===================
!  Tests for existence
!  ===================

   reflection_data_exists result (res)
   ! Return TRUE if reflection data exists
      res :: BIN
      res = associated(.data.reflections)
   end

   data_exists result (res)
   ! Return TRUE if the diffraction data information exists
      res :: BIN
      res = associated(.data)
   end

   asymmetric_unit_exists result (res)
   ! Return TRUE if the asymmetric unit geometry information exists
      res :: BIN
      res = associated(.asymmetric_unit_geometry)
   end

   unit_cell_geometry_exists result (res)
   ! Return TRUE if the unit_cell_geometry information exists
      res :: BIN
      res = associated(.unit_cell_geometry)
   end

   fragment_data_exists result (res)
   ! Return TRUE if a fragment information exists
      res :: BIN
      res = associated(.fragment_geometry)
   end

!  =============================
!  Wrappered reflection routines
!  =============================

   n_refl result (res)
   ! The number of reflections
      res :: INT
   ENSURE(.data_exists, "no diffraction data")
      res = .data.n_refl
   end

   F_exp result (res)
   ! The experimental structure factors
      res :: VEC{REAL}(.data.reflections.dim)
   ENSURE(.data_exists, "no diffraction data")
      res = .data.F_exp
   end

   F_sigma result (res)
   ! The structure factor errors
      res :: VEC{REAL}(.data.reflections.dim)
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_sigma
   end

   F_calc result (res)
   ! The calculated structure factors
      res :: VEC{CPX}(.data.reflections.dim)
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_calc
   end

   F_chi2 result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"diffraction data not created")
      res = .data.F_chi2
   end

   F_goodness_of_fit result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_goodness_of_fit
   end

   F_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_r_factor
   end

   F_weighted_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_weighted_r_factor
   end

   F_val_r_factor result (res) 
   ! Valence r factor. The set of "core_reflections" must be supplied.
      self :: IN
      res :: REAL

   ENSURE(.xray_data.created,"no xray data")
   ENSURE(.xray_data.reflection_data_exists,"no xray reflection data")
   ENSURE(.core_reflection.created,"no core electron reflection data")

      res = .xray_data.reflections.F_val_r_factor(.core_reflection)

   end

   set_F_calc(F_calc)
   ! Set the calculated structure factors
      F_calc :: VEC{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.set_F_calc(F_calc)
   end

   make_F_predicted
   ! Make the predicted magnitude of structure factors, including possibly
   ! an overall scale factor and extinction correction
   ENSURE(.data_exists,"no diffraction data")
      .data.make_F_predicted
   end

   extinction_correction result (res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors.
      res :: VEC{REAL}(.data.reflections.dim)
      res = .data.extinction_correction
   end

   n_param result (res)
   ! Returns number of independent parameters in model 
      self :: IN
      res :: INT
   ENSURE(.data_exists,"diffraction data not created")
      res = .data.n_param
   end

   partition_model result (res)
   ! Model for partitioning fragments of the molecule
      self :: IN
      res :: STR
      if (.data_exists) then; res = .data.partition_model
      else;                   res = " "
      end  
   end

   thermal_smearing_model result (res)
   ! Thermal smearing model for ft integrals.  
      self :: IN
      res :: STR
      if (.data_exists) then; res = .data.thermal_smearing_model
      else;                   res = " "
      end
   end

   correct_dispersion result (res)
   ! True if dispersion is to be corrected
      self :: IN
      res :: BIN
   ENSURE(.data_exists,"no diffraction data")
      res = .data.correct_dispersion
   end

   wavelength result (res)
   ! Experimental wavelength
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"no diffraction data")
      res = .data.wavelength
   end

   optimise_extinction result (res)
   ! True if extinction is to be optimised
      self :: IN
      res :: BIN
   ENSURE(.data_exists,"no diffraction data")
      res = .data.optimise_extinction
   end

   optimise_scale result (res)
   ! True if an overall scale factor is to be optimised, for use in calculating
   ! F_pred
      self :: IN
      res :: BIN
   ENSURE(.data_exists,"no diffraction data")
      res = .data.optimise_scale
   end

   xyz_asymmetric_unit_geometry result (res)
   ! Return the asymmetric unit geometry in cartesian coordinates.
      res :: MAT{REAL}(3,.n_asymmetric_unit_atoms)
   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit")
      res = matmul(.unit_cell.direct_matrix,.asymmetric_unit_geometry)
   end

   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.
   ENSURE(.data_exists,"no diffraction data")
      .data.simulate_new_F_exp
   end

!  ============================
!  Structure refinement methods
!  ============================

   fit_rigid_atoms(sf_n) ::: leaky
   ! Fit the Hirshfeld atoms to the calculated structure factors.
   ! "sf_n" are the static (no-thermal motion) *aspherical* *atomic*
   ! structure factors for the *unique* fragment atoms. 
   !
   ! NOTE: this routine does only one cycle of fitting with the
   !       current density matrix i.e. this is a "rigid atom fit".
   !
   ! NOTE: It's tricky exactly which atom's pADPs are used to do the
   !       refinement:
   !
   ! * Structure factors are calculated only for *unique* fragment
   !   atoms since the QM wavefunction refers to the fragment_atoms.
   !   cf. the description of "sf_n" above.
   !
   ! * However, asymmetric unit atoms are used to "store" the updating
   !   geometry; thus unique fragment atom pADPs and shifts are
   !   calculated (and derivatives with respect to these unique
   !   fragment atom positions and ADPs) but these parameters and
   !   shifts are later transformed back into asymmetric unit.

      sf_n :: MAT{CPX}, INOUT
 
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,       "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.n_asymmetric_unit_atoms, "sf_n: wrong dim2")
   ENSURE(.data_exists,                        "no data")
   ENSURE(.fragment_info_made,                 "no fragment info")

      fac :: REAL
      v :: VEC{REAL}*
      dF :: MAT{REAL}*

      ! Create refinement arrays & initialize (leaky)
      ! - asymmetric atom and fragment atom pADPs are set.
      .initialize_fit_data

      ! Place asym atom position/ADPs in vector .data.X_fit
      ! - asymmetric_unit_atom keeps the pADPs
      ! - unique frag atoms are *refined* cf. sf_n
      .asymmetric_unit_atom.put_pADP_vector_to(.data.X_fit)

      ! If refining, store a copy of the pADPs in .data.X_ref
      if (.data.refine_structure) .data.X_ref = .data.X_fit

      if (.debugging("fit_rigid_atoms")) then
         stdout.text("X_fit:")
         fac = STR:conversion_factor("angstrom")
         v.create(.data.X_fit.dim)
         .asymmetric_unit_atom.put_pADP_vector_to(v,fac)
         stdout.put(v,by_column=TRUE)
         v.destroy
      end

      ! Banner, options/switches, initial parameters,
      ! start banner, and iteration table header.
      .put_fit_header_info

      ! Begin rigid-atom fit loop
      do

         ! Set asym atom positions/ADPs from param vector
       ! .asymmetric_unit_atom.set_pADP_vector_to(.data.X_fit)
 
         ! Get unique *fragment* atom shifts in .data.dX ...
         .get_parameter_shifts(sf_n) ! .data

         ! Change/store unique frag atom -> asym atom shifts
         ! Change/store the covariance matrix too.
         .set_asym_from_ufrag_shifts ! .data.dX now for asym atoms
         .set_asym_from_ufrag_cov_mx 

         ! Stop symmetry breaking 
         ! NOTE: we should apply this to the gradient *not* 
         ! the shift to make sure the shift maintains symmetry
         .stabilize_asym_atom_shifts

         ! Store old asym-atom parameter vector. 
         ! Add shift dA to get new .data.X_fit 
         .update_fit_parameters
         .asymmetric_unit_atom.set_pADP_vector_to(.data.X_fit)

         ! Set the fit errors e.g. max(dX/esd)
         ! Copy them to the asymmetric unit atoms.
         .update_fit_errors
         .asymmetric_unit_atom.set_pADP_errors_to(.data.esd)

         ! Set ALL fragment_atom positions/ADPs from asym atoms HERE
         ! >>>fragment_atom must be the same as molecule.atom
         dF.create(3,.n_fragment_atoms)
         .set_frag_from_asym_pADPs(dF)

         ! Update "sf_n", the unique (rigid) frag atom SF's.
         ! Use the frag atom position shifts "dF".
         .shift_update_sf_n(sf_n,dF) 
         dF.destroy

         ! Put the iteration results
         .put_fit_iteration_results
 
         ! Finished?
         if (.fit_finished) exit
 
      end

      ! Table footer and final results
      .put_fit_footer_info

      ! Set the fragment covariances from cov matrix
      .set_fragment_errors

      ! Print out bond length, angle, torsion tables with errors
      .put_bond_info_with_errors

      ! Finally: remake .asymmetric_unit_atom/unit_cell geometry from
      ! .fragment_atom, which *must* be assigned since it must point 
      ! to molecule.atom
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_source = "tonto-rigid-atom-fit"
      .make_fragment_data(.fragment_atom,assign_atom=TRUE,warnings=FALSE)

      ! Put fit analysis statistics
      if (NOT .data.refine_structure) .put_fitting_plots

      ! Debug
      if (.debugging("fit_rigid_atoms")) .put_unit_cell_geometry

   end

!  Refinement initialization

   initialize_fit_data ::: leaky
   ! Initialise a rigid-atom fit

   ENSURE(.data_exists,"no diffraction data")
   ENSURE(.fragment_info_made,"no fragment info")

      X :: VEC{REAL}*
      labels, refine_U3,refine_U4 :: VEC{STR}*
      atom_a,atom_f :: ATOM*
      f,a, n_p,n_f :: INT
      fac :: REAL

      ! Create space for asymmetric unit atom pADPs (leaky)
      refine_U3 => .data.refine_3rd_order_for_atom
      refine_U4 => .data.refine_4th_order_for_atom
      .asymmetric_unit_atom.reset_pADPs_and_errors(refine_U3,refine_U4)

      if (.debugging("initialize_fit_data")) then
         n_p = .asymmetric_unit_atom.no_of_pADPs
         fac = STR:conversion_factor("angstrom")
         X.create(n_p)
         stdout.text(">>initialize_fit_data:")
         stdout.text("asymmetric_unit_atom.pADP_vector (before):")
         .asymmetric_unit_atom.put_pADP_vector_to(X,fac)
         stdout.put(X,by_column=TRUE)
         X.destroy
         stdout.text("fragment_atom (before):")
         .fragment_atom.put_coordinates
      end

      ! Create space for the fragment_atom pADPs (leaky)
      do f = 1,.n_fragment_atoms
         a = .asym_atom_for_frag_atom(f)
         atom_a => .asymmetric_unit_atom(a)
         atom_f =>        .fragment_atom(f)
         n_p = atom_a.no_of_pADPs
         atom_f.reset_pADPs_and_errors(n_p)
      end

      ! Set fragment_atom pADPs from asymmetric unit atom pADPs
      .set_frag_from_asym_pADPs

      ! Get labels (leaky)
      labels => .asymmetric_unit_atom.tag_pADP_labels

      ! Set the no. of parameters
      n_p = .asymmetric_unit_atom.no_of_pADPs
      n_f = .fragment_atom.no_of_pADPs

      ! Create refinement arrays & initialize (leaky)
      .data.initialize_fit_data(n_p,n_f,labels)

      ! Clean
      labels.destroy

   end

   initialize_refinement_data ::: leaky
   ! Initialise a full refinement

   ENSURE(.data_exists,"no diffraction data")

      labels, refine_U3,refine_U4 :: VEC{STR}*
      n_p :: INT

      ! Get labels
      labels => .asymmetric_unit_atom.tag_pADP_labels

      ! Create space for parameters (leaky)
      refine_U3 => .data.refine_3rd_order_for_atom
      refine_U4 => .data.refine_4th_order_for_atom
      .asymmetric_unit_atom.reset_pADPs_and_errors(refine_U3,refine_U4)

      ! Set the no. of parameters
      n_p = .asymmetric_unit_atom.no_of_pADPs

      ! Create refinement arrays & initialize (leaky)
      .data.initialize_refinement_data(n_p,labels)

      ! Clean
      labels.destroy

   end

!  Refinement: shifts and SF update

   get_parameter_shifts(sf_n) ::: leaky, private
   ! Get the *asym* atom shifts ".data.dX" by solving the
   ! normal equations, using:
   ! * "sf_n", the unique *fragment* atom structure factors
   !   for the symmetry related k points
   ! * ".data.X_ref", the *asym* atom parameters 
   !   (positions and ADP's) 
   ! "sf_n" is updated by the shift amount at the end. 

      sf_n :: MAT{CPX}, INOUT

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,        "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim, "sf_n: wrong dim2")
   ENSURE(.data.created,                        "no data")
   ENSURE(.fragment_info_made,                  "no fragment info")

      dFa  :: MAT{REAL}*
      sf_d,dFc :: MAT{CPX}*
      sf_e,Fc :: VEC{CPX}*
      n_refl,n_k,n_p :: INT

      ! Constants
      n_refl = .n_refl
      n_k    = .n_unique_SF_k_pts
      n_p    = .asymmetric_unit_atom.no_of_pADPs

      ! Symmetry generated structure factors
      sf_d.create(n_k,n_p) ! Symmetry generated SF derivatives
      sf_e.create(n_k)     ! Symmetry generated SF's

      ! Make the symmetry-generated structure factors 
      ! and their  derivatives
      .make_unique_sf_derivs(sf_e,sf_d,sf_n)

    ! if (.debugging("get_parameter_shifts")) then
    !    stdout.text("sf_e:")
    !    stdout.put(sf_e)
    ! end

      ! Sum the symmetry-generated SF's to get
      ! the actual structure factors Fc
      Fc.create(n_refl) 
      .sum_unique_sf(Fc,sf_e)
      sf_e.destroy

      ! Set the calculated SF's
      .set_F_calc(Fc)

      if (.debugging("get_parameter_shifts")) then
         stdout.text("Fc:")
         stdout.put(Fc)
      end
      Fc.destroy

      ! Make chi2 in F (and I?)
      .make_F_predicted

      ! Sum the symmetry-generated SF's to get 
      ! the derivative structure factors dFc
      dFc.create(n_refl,n_p)  
      .sum_unique_sf_derivs_t(dFc,sf_d)
      sf_d.destroy

      ! Get the derivative absolute SF's, 
      ! ... unique fragment atoms only
      dFa.create(n_refl,n_p)
      .d_F_abs_dX(dFa,dFc)
      dFc.destroy

      ! Get the unique atom shifts, dX (leaky)
      .solve_normal_equations(dFa)
      dFa.destroy

      if (.debugging("get_parameter_shifts")) then
         stdout.text("get_parameter_shifts, .data.dX, after:")
         stdout.put(.data.dX)
      end
 
   end

   shift_update_sf_n(sf_n,dF) ::: private
   ! Update the unique *fragment* atom structure factors "sf_n" with
   ! the frag atom positional shifts (after stabilization) in "dF"
      sf_n :: MAT{CPX}, target, INOUT
      dF   :: MAT{REAL}, IN

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,       "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.n_asymmetric_unit_atoms, "sf_n: wrong dim2")
   ENSURE(dF.dim1==3,                          "dF: wrong dim1")
   ENSURE(dF.dim2==.n_fragment_atoms,          "dF: wrong dim2")

      d1,d2,d3, k1,k2,k3, kr  :: REAL
      n_k, u,f, k :: INT
      k1v,k2v,k3v :: VEC{REAL}*
      sf_u :: VEC{CPX}*
      k_pt :: MAT{REAL}*

      ! Get the k points
      n_k = .n_unique_SF_k_pts
      k_pt.create(n_k,3)      
      .make_unique_SF_k_pts(k_pt)

      ! Components of k
      k1v => k_pt(:,1)
      k2v => k_pt(:,2)
      k3v => k_pt(:,3)

      ! Loop over unique *frag* atoms
      do u = 1,.n_unique_frag_atoms

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)

         ! Get the shift
         d1 = dF(1,f)
         d2 = dF(2,f)
         d3 = dF(3,f)

         ! Structure factors, unique atom "u"
         sf_u => sf_n(:,u)

         ! Update sf_u
         do k = 1,n_k

            k1 = k1v(k)
            k2 = k2v(k)
            k3 = k3v(k)

            kr = k1*d1 + k2*d2 + k3*d3

            sf_u(k) = sf_u(k) * cmplx(cos(kr),sin(kr),kind=CPX_KIND)

         end

      end

      ! Clean
      k_pt.destroy

   end

   set_fragment_errors  ::: private
   ! Set *all* the errors in the .fragment_atom positions/ADPs
   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.created,"no data")
   ENSURE(.data.fragment_covariance_matrix.created,"no data.fragment_covariance_matrix")

      esd :: VEC{REAL}*

      ! Get the fragment covariances
      .set_frag_from_asym_cov_mx

      ! Get just the positional covariance matrix
      esd.create(.data.fragment_covariance_matrix.dim1)
      .data.fragment_covariance_matrix.put_diagonal_to(esd)
      esd = sqrt(esd)

      ! Set the errors
      .fragment_atom.set_pADP_errors_to(esd)

      ! Clean
      esd.destroy

   end

!  Refinement: unique frag <-> asym frag parameters

   set_frag_from_asym_pADPs(dF)  ::: private
   ! Set *all* .fragment_atom pADPs from the .asymmetric_unit_atom pADPs.
   ! If "dF" present, the shift in teach frag atom position is returned.
      dF :: MAT{REAL}, optional

   ENSURE(.fragment_info_made,"no fragment info")

      f,a,s :: INT
      f_atom,a_atom :: ATOM* 
      seitz :: MAT3{REAL}*
      CM :: MAT{REAL}(3,3)
      shift :: VEC{REAL}(3)

      ! Debug
      if (.debugging("set_frag_from_asym_pADPs")) then
         .asymmetric_unit_atom.put_coordinates
         stdout.text("asymmetric_unit_atom.pADP_vector (before):")
         .asymmetric_unit_atom.put_pADPs
         stdout.text("fragment_atom (before):")
         .fragment_atom.put_coordinates
         stdout.text("fragment_atom.pADP_vector (before):")
         .fragment_atom.put_pADPs
      end

      ! Symmetry operators & cell matrix
      seitz => .xyz_seitz_matrices

      ! Cell matrix
      CM = .unit_cell.direct_matrix

      ! Loop on *all* fragment atom's
      ! Set the .fragment_atom positions/ADP's 
      ! from the .asymmetric_unit_atom's
      do f = 1,.n_fragment_atoms

         ! Links between the atom indices & symop s
         a  = .asym_atom_for_frag_atom(f)
         s  = .asym_symop_for_frag_atom(f)

         ! Atoms (fragment, asymmetric)
         f_atom =>        .fragment_atom(f)
         a_atom => .asymmetric_unit_atom(a)

         ! Store original position
         if (present(dF)) dF(:,f) = -f_atom.position

         ! Set frag atom pADPs
         f_atom.set_pADP_vector_to(a_atom.pADP_vector)

         ! Now transform frag atom pADPs with symop
         f_atom.transform_pADP_vector_with(seitz(:,:,s))

         ! Add any fragment shift to (cartesian)  position
         shift.to_product_of(CM,.asym_shift_for_frag_atom(:,f))
         shift = f_atom.position + shift
         f_atom.set_position(shift)

         ! Store shift
         if (present(dF)) dF(:,f) = dF(:,f) + f_atom.position

      end

      ! Clean
      seitz.destroy

      ! Debug
      if (.debugging("set_frag_from_asym_pADPs")) then
         if (present(dF)) then
         stdout.text("dF:")
         stdout.put(dF)
         end
         stdout.text("asymmetric_unit_atom (after):")
         .asymmetric_unit_atom.put_coordinates
         stdout.text("asymmetric_unit_atom.pADP_vector (after):")
         .asymmetric_unit_atom.put_pADPs
         stdout.text("fragment_atom (after):")
         .fragment_atom.put_coordinates
         stdout.text("fragment_atom.pADP_vectorm (after):")
         .fragment_atom.put_pADPs
      end

   end

   set_asym_from_ufrag_shifts ::: private
   ! From "dX", the unique .fragment_atom shifts in positions and
   ! ADP's, return the *asymmetric* atom shifts in positions and
   ! ADP's; place the shifts in the same "dX" parameter vector.

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom")
   ENSURE(.data.created,"no data")
   ENSURE(.data.dX.created,"no data.dX")

      u,f,a,s, n, ub,uf,ul, ab,af,al :: INT
      dA,Apar,Xpar :: VEC{REAL}*
      seitz :: MAT3{REAL}*
      a_atom :: ATOM*
      X_atom :: ATOM

      ! Debug
      if (.debugging("set_asym_from_ufrag_shifts")) then 
      stdout.text("set_asym_from_ufrag_shifts, .data.dX, before:")
      stdout.put(.data.dX)
      end
      
      ! Get symops
      seitz => .transposed_xyz_seitz_matrices

      ! Asym atom shift vector
      dA.create(.data.dX.dim)

      ! Base for ufrag atoms
      ub = 0

      ! Loop over unique frag atoms
      ! Order of asym atoms is the same.
      do u = 1,.n_unique_frag_atoms

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)
         a = .asym_atom_for_frag_atom(f)
         s = .asym_symop_for_frag_atom(f)

         ! Fragment atom, asym atom
         a_atom => .asymmetric_unit_atom(a)

         ! No of pADPs & a-base
         n  = a_atom.no_of_pADPs
         ab = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a)

         ! Block limits
         af = ab + 1
         al = ab + n
         uf = ub + 1
         ul = ub + n

         ! pADP blocks
         Apar =>       dA(af:al)
         Xpar => .data.dX(uf:ul)

         ! Put ufrag shifts at position f1 in "X_atom" (leaky)
         X_atom.pADP_vector.create(n)
         X_atom.set_pADP_vector_to(Xpar)

         ! Change ufrag atom shifts -> asym atom shifts
         X_atom.transform_pADP_vector_with(seitz(:,:,s))

         ! Store asym shifts in position a0 for asym atom "a"
         X_atom.put_pADP_vector_to(Apar)

         ! Clean
         X_atom.destroy_ptr_part

         ! Increment u-base
         ub = ub + n

      end

      ! Replace .dX
      .data.dX = dA

      ! Clean
      dA.destroy
      seitz.destroy

      ! Debug
      if (.debugging("set_asym_from_ufrag_shifts")) then 
      stdout.text("set_asym_from_ufrag_shifts, .data.dX, after:")
      stdout.put(.data.dX)
      end

   end

   stabilize_asym_atom_shifts ::: private
   ! Stabilize ".dX", parameter vector for asymmetric atom *shifts* 
   ! in positions and ADP's, removing any symmetry breaking.

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.created,"no data")
   ENSURE(.data.dX.created,"no data.dX")

      a, n,ab,af,al, n_stab,s,t :: INT
      stabilizer :: VEC{INT}*
      Xpar :: VEC{REAL}*
      seitz :: MAT3{REAL}*
      X_atom,Y_atom :: ATOM
      a_atom :: ATOM*

      ! Debug
      if (.debugging("stabilize_asym_atom_shifts")) then 
      stdout.text("stabilize_asym_atom_shifts, .data.dX, before:")
      stdout.put(.data.dX)
      end
      
      ! Get symops
      seitz => .xyz_seitz_matrices

      ! Base for asym atoms
      ab = 0

      ! Symmetrize the asym atom positions/ADP's
      ! We can use the asym atom stabilizers for the ufrag
      do a = 1,.n_asymmetric_unit_atoms

         ! List of stabilizer symops
         stabilizer => .asym_atom_stabilizer(a).element

         ! Any stabilizers?
         n_stab = stabilizer.dim
         if (n_stab<=1) cycle

         ! Fragment atom, asym atom
         a_atom => .asymmetric_unit_atom(a)

         ! Block limits
         n  = a_atom.no_of_pADPs
         af = ab + 1
         al = ab + n
         
         ! Asym atom a's pADPs
         Xpar => .data.dX(af:al)

         ! Set pADPs (leaky)
         X_atom.pADP_vector.create(n)
         Y_atom.pADP_vector.create(n)
         X_atom.set_pADP_vector_to(Xpar)
         Y_atom.set_pADP_vector_to(Xpar)

         ! Apply symops and accumulate
         do s = 2,n_stab
            t = stabilizer(s)
            X_atom.transform_pADP_vector_with(seitz(:,:,t))
            Y_atom.pADP_vector = Y_atom.pADP_vector + X_atom.pADP_vector
         end

         ! Stabilize
         Y_atom.pADP_vector = (ONE/REALIFY(n_stab)) * Y_atom.pADP_vector

         ! Put back shifts
         Y_atom.put_pADP_vector_to(Xpar)

         ! Clean
         Y_atom.destroy_ptr_part
         X_atom.destroy_ptr_part

         ! Increment a-base
         ab = ab + n

      end

      ! Clean
      seitz.destroy

      ! Debug
      if (.debugging("stabilize_asym_atom_shifts")) then 
      stdout.text("stabilize_asym_atom_shifts, .data.dX, after:")
      stdout.put(.data.dX)
      end

   end

   update_fit_errors ::: private
   ! Set the fit errors e.g. maximum shift on esd and the positional
   ! and ADP errors for the asym unit. 

   ENSURE(.data.created,"no data")

      ! Reset the esd's and maximum shifts on esd
      .data.update_fit_errors

      ! Set asym atom par label value corresponding to the max shift/esd
      .data.max_shift_on_esd_par = .asymmetric_unit_atom.tag_pADP_label(.data.max_shift_on_esd_ind)

   end

   update_refinement_errors
   ! Update the refinement errors e.g. maximum shift on esd and the
   ! positional and ADP errors for the asym unit.

   ENSURE(.data.created,"no data")

      ! Set the refinement errors
      .data.update_refinement_errors

      ! Set asym atom max refinement shift on easd par value
      .data.max_refshift_on_esd_par = .asymmetric_unit_atom.tag_pADP_label(.data.max_refshift_on_esd_ind)

   end

!  Refinement: transform covariance matrix

   set_asym_from_ufrag_cov_mx ::: private
   ! Set the asymmetric atom covariance matrix from the unique
   ! fragment atom covariance_matrix (produced from refinement)
   ! Note: .covariance_matrix is over-written.
   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom")
   ENSURE(.data.created,"no data")
   ENSURE(.data.covariance_matrix.created,"no covariance matrix")

      u1,f1,a1,s1,n1, u1b,u1f,u1l, a1b,a1f,a1l :: INT
      u2,f2,a2,s2,n2, u2b,u2f,u2l, a2b,a2f,a2l :: INT
      dim  :: INT
      diag :: VEC{REAL}*
      T1,T2, asyma_covariance_matrix,acov,ucov :: MAT{REAL}*
      seitz :: MAT3{REAL}*

      ! *Inverse* symops (see below)
      seitz => .transposed_xyz_seitz_matrices

      ! Create asym atom frag covariance matrix
      dim = .data.covariance_matrix.dim1
      asyma_covariance_matrix.create(dim,dim)
      asyma_covariance_matrix = ZERO

      ! Transform the unique .fragment_atom to the asym unit covariances
      u1b = 0
      do u1 = 1,.n_unique_frag_atoms

         ! s1 maps: asym atom a1 -> frag atom f1, but use transpose
         f1 = .unique_frag_atom(u1)
         a1 = .asym_atom_for_frag_atom(f1)
         s1 = .asym_symop_for_frag_atom(f1) 

         ! Block limits
         n1  = .asymmetric_unit_atom(a1).no_of_pADPs
         a1b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a1)
         a1f = a1b +  1
         a1l = a1b + n1
         u1f = u1b +  1
         u1l = u1b + n1

         ! Transformation matrix
         T1.create(n1,n1)
         GAUSSIAN_DATA:symmetric_tensor_product_mx(T1,seitz(:,:,s1)) 

         u2b = 0
         do u2 = 1,.n_unique_frag_atoms

            ! s2 maps: asym atom a2 -> frag atom f2, but use transpose
            f2 = .unique_frag_atom(u2)
            a2 = .asym_atom_for_frag_atom(f2)
            s2 = .asym_symop_for_frag_atom(f2) 
   
            ! Block limits
            n2  = .asymmetric_unit_atom(a2).no_of_pADPs
            a2b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a2)
            a2f = a2b +  1
            a2l = a2b + n2
            u2f = u2b +  1
            u2l = u2b + n2
   
            ! Transformation matrix
            T2.create(n2,n2)
            GAUSSIAN_DATA:symmetric_tensor_product_mx(T2,seitz(:,:,s2)) 
            
            ! Transform covariances: ufrag -> asym atom
            acov => asyma_covariance_matrix(a1f:a1l,a2f:a2l)
            ucov => .data.covariance_matrix(u1f:u1l,u2f:u2l)
            ucov.back_transform_to(acov,T1,T2)

            ! Increment
            u2b = u2b + n2

         end

         ! Increment
         u1b = u1b + n1

      end

      ! Debugging
      if (.debugging("set_asym_from_ufrag_cov_mx")) then

         stdout.text("acov:")
         stdout.put(acov)

         stdout.text("ucov:")
         stdout.put(ucov)

         diag.create(acov.dim1)
         acov.put_diagonal_to(diag)
         diag = sign(sqrt(abs(diag)),diag)
         stdout.text("acov esds:")
         stdout.put(diag)

         ucov.put_diagonal_to(diag)
         diag = sign(sqrt(abs(diag)),diag)
         stdout.text("ucov esds:")
         stdout.put(diag)

         diag.destroy

      end

      ! Overwrite ufrag-atom cov mx with asym-atom cov mx
      .data.covariance_matrix = asyma_covariance_matrix

      ! Clean
      asyma_covariance_matrix.destroy
      seitz.destroy

   end

   set_frag_from_asym_cov_mx ::: private
   ! Set the total frag atom covariance matrix from the asym atom
   ! covariance matrix. Seems correct 12/9/11
   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.created,"no data")

      f1,a1,s1,n1, f1b,f1f,f1l, a1b,a1f,a1l :: INT
      f2,a2,s2,n2, f2b,f2f,f2l, a2b,a2f,a2l :: INT
      T1,T2, acov,fcov :: MAT{REAL}*
      seitz :: MAT3{REAL}*

      ! Symops
      seitz => .xyz_seitz_matrices

      ! Copy the asymmetric atom covariances to *all* .fragment_atom ADPs
      f1b = 0
      do f1 = 1,.n_fragment_atoms

         ! s1 maps: asym atom a1 -> frag atom f1
         a1 = .asym_atom_for_frag_atom(f1)
         s1 = .asym_symop_for_frag_atom(f1)                     

         ! Block limits
         n1  = .asymmetric_unit_atom(a1).no_of_pADPs
         a1b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a1)
         a1f = a1b +  1
         a1l = a1b + n1
         f1f = f1b +  1
         f1l = f1b + n1

         ! Transformation matrix
         T1.create(n1,n1)
         GAUSSIAN_DATA:symmetric_tensor_product_mx(T1,seitz(:,:,s1)) 

         f2b = 0
         do f2 = 1,.n_fragment_atoms

            ! s2 maps: asym atom a2 -> frag atom f2
            a2 = .asym_atom_for_frag_atom(f2)
            s2 = .asym_symop_for_frag_atom(f2)

            ! Block limits
            n2  = .asymmetric_unit_atom(a2).no_of_pADPs
            a2b = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a2)  
            a2f = a2b +  1
            a2l = a2b + n2
            f2f = f2b +  1
            f2l = f2b + n2

            ! Transformation matrix
            T2.create(n2,n2)
            GAUSSIAN_DATA:symmetric_tensor_product_mx(T2,seitz(:,:,s2)) 

            ! Transform ...
            fcov => .data.fragment_covariance_matrix(f1f:f1l,f2f:f2l)
            acov =>          .data.covariance_matrix(a1f:a1l,a2f:a2l)
            acov.back_transform_to(fcov,T1,T2)

            ! Clean, increment
            T2.destroy
            f2b = f2b + n2 

         end

         ! Clean, increment
         T1.destroy
         f1b = f1b + n1

      end

      ! Clean
      seitz.destroy

      ! Debugging
      if (.debugging("set_frag_from_asym_cov_max")) then
         stdout.text("acov:")
         stdout.put(acov)
         stdout.text("fcov:")
         stdout.put(fcov)
      end

   end

!  Refinement: finished?

   update_fit_parameters
   ! Update i.e. increment the fit parameters

   ENSURE(.data_exists,"no diffraction data")

      .data.update_fit_parameters

   end

   update_refinement_parameters
   ! Update the refinement parameters

   ENSURE(.data_exists,"no diffraction data")

      .data.update_refinement_parameters

   end
 
   fit_finished result (res)
   ! Return whether the (rigid) fit has finished
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.fit_finished

      ! Rewind coordinates and ADPs if chi2 increases. 
      ! WARNING: errors and cox mx are not rewound.
    ! if (.data.chi2_increased) then
    !    .asymmetric_unit_atom.set_pADP_vector_to(.data.X_fit)
    !    .set_frag_from_asym_pADPs
    ! end

   end
 
   refinement_finished result (res)
   ! Return whether the refinement has finished
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.refinement_finished

   end

!  SF derivatives & normal equations

   make_unique_sf_derivs(sf_e,sf_d,sf_n)
   ! Make "sf_e" and "sf_d", the symmetry-related thermally-smeared
   ! structure factors and their derivatives, from "sf_n" the *unique*
   ! .fragment_atom structure factors and the ".fragment_atom.ADP_tensor".

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, INOUT

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created,                         "no data")

      ! Refine positions and ADPs
      if (.data.refine_positions_and_ADPs) then  

         if (.data.refine_H_ADPs) then               ! ... and refine H ADP's
   
            if (.data.refine_H_U_iso)          then; .make_unique_sfd_pos_Y_Hiso_Y(sf_e,sf_d,sf_n)
            else
             ! if (.data.refine_anharmonicity) then; .make_unique_sfd_pos_Y_ADPx_Y_test(sf_e,sf_d,sf_n)
               if (.data.refine_anharmonicity) then; .make_unique_sfd_pos_Y_ADP4_Y(sf_e,sf_d,sf_n)
               else;                                 .make_unique_sfd_pos_Y_ADP__Y(sf_e,sf_d,sf_n)
               end
            end
   
         else                                        ! ... and don't refine H ADP's

                                                     .make_unique_sfd_pos_Y_HADP_N(sf_e,sf_d,sf_n)
         end

      ! Refine positions only, not ADPs
      else if (.data.refine_positions_only) then 

                                                     .make_unique_sfd_pos_Y_ADP__N(sf_e,sf_d,sf_n) 

      ! Refine ADP's only, not positions
      else if (.data.refine_ADPs_only) then      

         if (.data.refine_H_ADPs) then               ! ... and refine H ADP's
   
            if (.data.refine_H_U_iso) then;          .make_unique_sfd_pos_N_Hiso_Y(sf_e,sf_d,sf_n)
            else;                                    .make_unique_sfd_pos_N_ADP__Y(sf_e,sf_d,sf_n)
            end

         else                                        ! ... and don't refine H ADP's
   
                                                     .make_unique_sfd_pos_N_HADP_N(sf_e,sf_d,sf_n)
         end

      ! wtf?
      else

         DIE("you aren't refining anything!")

      end 

   end


!   make_unique_sfd_pos_Y_ADPx_Y_test(sf_e,sf_d,sf_n) ::: private
!   ! Make the unique structure factors and their derivatives "sf_e"
!   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
!   ! set of atom parameters in .fragment_atom.
!   ! NOTE: this version does *all* parameters, positions and ADPs
!   !       *including* up to 4th order anharmonicity.
!   ! NOTE: the order of the derivatives follows the lexical order 
!   !       defined in GAUSSIAN_DATA
!      sf_e :: VEC{CPX}, OUT
!      sf_d :: MAT{CPX}, OUT
!      sf_n :: MAT{CPX}, target, IN
!
!   ENSURE(.data.created, "no reflection data")
!   ENSURE(.xray_data.created, "no x-ray reflection data")
!   DIE_IF(NOT .data.refine_anharmonicity, "must be refining anharmonicity")
!   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
!   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
!   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
!   ENSURE(sf_n.dim2==.n_unique_frag_atoms,       "sf_n, wrong dim2")
!
!      f_atom :: ATOM*
!      adp3 :: MAT3{REAL}(3,3,3)
!      adp4 :: MAT4{REAL}(3,3,3,3)
!      kv   :: VEC{REAL}(3)
!      v3   :: VEC{REAL}(10)
!      v4   :: VEC{REAL}(15)
!      sf_u :: VEC{CPX}*
!      k_pt,kU :: MAT{REAL}*
!      u1v,u2v,u3v, k1v,k2v,k3v :: VEC{REAL}*
!      u1,u2,u3, k1,k2,k3, tf, c3,c4 :: REAL
!      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
!      n_k,f,u,k,base :: INT
!      II,sf,sfh,sf2,sf4,sf6,sf24 :: CPX
!
!      ! Constants
!      II  = IMAGIFY(ONE)
!      n_k = .n_unique_SF_k_pts
!
!      ! Symmetry generated k points
!      k_pt.create(n_k,3)
!      .make_unique_SF_k_pts(k_pt)
!      k1v => k_pt(:,1)
!      k2v => k_pt(:,2)
!      k3v => k_pt(:,3)
!
!      ! K times thermal tensors
!      kU.create(n_k,3)        
!
!      ! Initialize
!      sf_e = ZERO
!      sf_d = ZERO
!
!      ! Base index for unique frag atom
!      base = 0
!
!      ! Make the structure factors and derivatives
!      parallel do u = 1,.n_unique_frag_atoms
!
!         ! Fragment atom
!         f = .unique_frag_atom(u)
!         f_atom => .fragment_atom(f)
!
!         ! k.U
!         kU.to_product_of(k_pt,f_atom.ADP_tensor)
!         u1v => kU(:,1)
!         u2v => kU(:,2)
!         u3v => kU(:,3)
!
!         ! Structure factor, iunique frag atom "u"
!         sf_u => sf_n(:,u)
!
!         ! ADP4's
!         if (f_atom.has_only_ADP4s_and_errors) then
!
!            ! Reorder from lower pyramid -> lexical
!            GAUSSIAN_DATA:lexical_3_to_lower_pyramid(f_atom.pADP_vector(10:19),v3)
!            GAUSSIAN_DATA:lexical_4_to_lower_pyramid(f_atom.pADP_vector(20:34),v4)
!
!            ! Uncompress lower pyramid -> tensor
!            adp3.uncompress_from_pyramid(v3)
!            adp4.uncompress_from_pyramid(v4)
!
!            do k = 1,n_k
!   
!               ! Scattering vector
!               k1 = k1v(k)
!               k2 = k2v(k)
!               k3 = k3v(k)
!
!               k1_k1 = k1*k1
!               k2_k2 = k2*k2
!               k3_k3 = k3*k3
!               k1_k2 = k1*k2
!               k1_k3 = k1*k3
!               k2_k3 = k2*k3
!   
!               ! Temperature factor (TF)
!               u1 = u1v(k)
!               u2 = u2v(k)
!               u3 = u3v(k)
!               tf = -HALF*(u1*k1+u2*k2+u3*k3)
!               tf = exp(tf)
!
!               ! Third and fourth order corrections
!               c3 = adp3.contract_with(kv)*SIXTH
!               c4 = adp4.contract_with(kv)*SIXTH*QUARTER
!   
!               ! Structure factor x (1 + anharm ...) x TF
!               sfh = sf_u(k) * tf 
!               sf  = sfh * (ONE+II*c3+c4)
!               sf2 = sf  * HALF
!   
!               ! SF contribution (with anhramonic!)
!               sf_e(k) = sf_e(k) + sf
!   
!               ! Pos derivatives
!               sf_d(k,base+ 1) =  II*k1*sf
!               sf_d(k,base+ 2) =  II*k2*sf
!               sf_d(k,base+ 3) =  II*k3*sf
!
!               ! U2 derivatives
!               sf_d(k,base+ 4) = -k1_k1*sf2
!               sf_d(k,base+ 5) = -k2_k2*sf2
!               sf_d(k,base+ 6) = -k3_k3*sf2
!               sf_d(k,base+ 7) = -k1_k2*sf 
!               sf_d(k,base+ 8) = -k1_k3*sf 
!               sf_d(k,base+ 9) = -k2_k3*sf 
!   
!               ! Structure factor x TF (without anharmonic!)
!               sf   = sfh
!
!               ! Multiples of sf
!               sf2  = sf * HALF
!               sf4  = sf * QUARTER
!               sf6  = sf * SIXTH
!               sf24 = sf * SIXTH*QUARTER
!
!               ! U3 derivatives
!               sf_d(k,base+10) = II*k1_k1*k1*sf6
!               sf_d(k,base+11) = II*k2_k2*k2*sf6
!               sf_d(k,base+12) = II*k3_k3*k3*sf6
!               sf_d(k,base+13) = II*k1_k1*k2*sf2
!               sf_d(k,base+14) = II*k1_k1*k3*sf2
!               sf_d(k,base+15) = II*k2_k2*k1*sf2
!               sf_d(k,base+16) = II*k2_k2*k3*sf2
!               sf_d(k,base+17) = II*k3_k3*k1*sf2
!               sf_d(k,base+18) = II*k3_k3*k2*sf2
!               sf_d(k,base+19) = II*k1*k2*k3*sf 
!
!               ! U4 derivatives
!               sf_d(k,base+20) = k1_k1*k1_k1*sf24
!               sf_d(k,base+21) = k2_k2*k2_k2*sf24
!               sf_d(k,base+22) = k3_k3*k3_k3*sf24
!               sf_d(k,base+23) = k1_k1*k1_k2*sf6
!               sf_d(k,base+24) = k1_k1*k1_k3*sf6
!               sf_d(k,base+25) = k2_k2*k1_k2*sf6
!               sf_d(k,base+26) = k2_k2*k2_k3*sf6
!               sf_d(k,base+27) = k3_k3*k1_k3*sf6
!               sf_d(k,base+28) = k3_k3*k2_k3*sf6
!               sf_d(k,base+29) = k1_k1*k2_k2*sf4
!               sf_d(k,base+30) = k1_k1*k3_k3*sf4
!               sf_d(k,base+31) = k2_k2*k3_k3*sf4
!               sf_d(k,base+32) = k1_k1*k2_k3*sf2
!               sf_d(k,base+33) = k2_k2*k1_k3*sf2
!               sf_d(k,base+34) = k3_k3*k1_k2*sf2
!
!            end
!
!         ! ADP3's
!         else if (f_atom.has_only_ADP3s_and_errors) then
!
!            DIE("sorry ...")
!
!         else ! no anharmonicity
!
!            DIE("sorry ...")
!
!         end
!
!
!         ! Analytical result
!         stdout.text("Here is the AD result for atom "//trim(u.to_str))
!         stdout.put(sf_d(:,base+10:base+34))
!
!         ! Do the finite derivatives and stop after u=1
!         sf_d(:,base+10:base+34) = ZERO
!         .make_unique_sfd_pos_Y_ADPx_Y_fd(sf_d(:,base+10:base+34),sf_e,u,sf_n)
!
!      end
!
!      ! Clean
!      kU.destroy
!      k_pt.destroy
!   
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(sf_e)
!         PARALLEL_SUM(sf_d)
!      end
!
!   end
!
!   make_unique_sfd_pos_Y_ADPx_Y_fd(sf_d,sf_e,u,sf_n) ::: private
!   ! Make "sf_d" by finite derivatives
!
!      sf_d :: MAT{CPX}
!      sf_e :: VEC{CPX}
!      u :: INT
!      sf_n :: MAT{CPX}, target
!
!   ENSURE(.data.created, "no reflection data")
!   ENSURE(.xray_data.created, "no x-ray reflection data")
!   DIE_IF(NOT .data.refine_anharmonicity, "must be refining anharmonicity")
!   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
!   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
!   ENSURE(sf_d.dim2==25,"sf_d, wrong dim2")
!
!      f,p,s :: INT
!      f_atom :: ATOM*
!      step,fac :: REAL
!
!      step = TOL(6)
!      fac  = ONE/(TWO*step)
!
!      sf_d = ZERO
!
!      ! Loop over anharmonic parameters
!      do p = 10,34
!      do s = -1,1,2
!
!         ! Atom for which derivatives are wanted
!         f = .unique_frag_atom(u)
!         f_atom => .fragment_atom(f)
!
!         ! Displace pADP "p"
!         f_atom.pADP_vector(p) = f_atom.pADP_vector(p) + s*step
!
!         ! Get displaced sf_e
!         .make_unique_sfd_pos_Y_ADPx_Y_disp(sf_e,u,sf_n)
!
!         ! Finite difference formula
!         sf_d(:,p-9) = sf_d(:,p-9) + s*fac*sf_e(:)
!
!         ! Undo displacement on "p"
!         f_atom.pADP_vector(p) = f_atom.pADP_vector(p) - s*step
!
!      end
!      end
!
!      stdout.text("Here is the FD result for atom "//trim(u.to_str))
!      stdout.put(sf_d)
!      stop
!
!   end
!
!   make_unique_sfd_pos_Y_ADPx_Y_disp(sf_e,u,sf_n) ::: private
!   ! Make the unique structure factors and their derivatives "sf_e"
!   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
!   ! set of atom parameters in .fragment_atom.
!   ! NOTE: this version does *all* parameters, positions and ADPs
!   !       *including* up to 4th order anharmonicity.
!   ! NOTE: the order of the derivatives follows the lexical order 
!   !       defined in GAUSSIAN_DATA
!      sf_e :: VEC{CPX}
!      sf_n :: MAT{CPX}, target
!      u :: INT
!
!   ENSURE(.data.created, "no reflection data")
!   ENSURE(.xray_data.created, "no x-ray reflection data")
!   DIE_IF(NOT .data.refine_anharmonicity, "must be refining anharmonicity")
!   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
!
!      f_atom :: ATOM*
!      adp2 :: MAT{REAL}(3,3)
!      adp3 :: MAT3{REAL}(3,3,3)
!      adp4 :: MAT4{REAL}(3,3,3,3)
!      kv   :: VEC{REAL}(3)
!      v2   :: VEC{REAL}(6)
!      v3   :: VEC{REAL}(10)
!      v4   :: VEC{REAL}(15)
!      sf_u :: VEC{CPX}*
!      k_pt :: MAT{REAL}*
!      k1v,k2v,k3v :: VEC{REAL}*
!      k1,k2,k3, tf, c2,c3,c4 :: REAL
!      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
!      n_k,f, k,base :: INT
!      II,sf,sfh,sf2,sf4,sf6,sf24 :: CPX
!
!      ! Constants
!      II  = IMAGIFY(ONE)
!      n_k = .n_unique_SF_k_pts
!
!      ! Symmetry generated k points
!      k_pt.create(n_k,3)
!      .make_unique_SF_k_pts(k_pt)
!      k1v => k_pt(:,1)
!      k2v => k_pt(:,2)
!      k3v => k_pt(:,3)
!
!      ! Initialize
!      sf_e = ZERO
!
!      ! Base index for unique frag atom
!      base = 0
!
!      ! Fragment atom
!      f = .unique_frag_atom(u)
!      f_atom => .fragment_atom(f)
!
!      ! Structure factor, iunique frag atom "u"
!      sf_u => sf_n(:,u)
!
!      ! ADP4's
!      if (f_atom.has_only_ADP4s_and_errors) then
!
!         ! Reorder from lower pyramid -> lexical
!         GAUSSIAN_DATA:lexical_2_to_lower_pyramid(f_atom.pADP_vector( 4: 9),v2)
!         GAUSSIAN_DATA:lexical_3_to_lower_pyramid(f_atom.pADP_vector(10:19),v3)
!         GAUSSIAN_DATA:lexical_4_to_lower_pyramid(f_atom.pADP_vector(20:34),v4)
!
!         ! Uncompress lower pyramid -> tensor
!         adp2.uncompress_from_pyramid(v2)
!         adp3.uncompress_from_pyramid(v3)
!         adp4.uncompress_from_pyramid(v4)
!
!         do k = 1,n_k
!
!            ! Scattering vector
!            k1 = k1v(k)
!            k2 = k2v(k)
!            k3 = k3v(k)
!            kv = [k1,k2,k3]
!
!            k1_k1 = k1*k1
!            k2_k2 = k2*k2
!            k3_k3 = k3*k3
!            k1_k2 = k1*k2
!            k1_k3 = k1*k3
!            k2_k3 = k2*k3
!
!            ! Third and fourth order corrections
!            c2 = adp2.contract_with(kv)*HALF
!            c3 = adp3.contract_with(kv)*SIXTH
!            c4 = adp4.contract_with(kv)*SIXTH*QUARTER
!
!            ! Structure factor x (1 + anharm ...) x TF
!            sfh = sf_u(k) * exp(-c2)
!            sf  = sfh * (ONE+II*c3+c4)
!            sf2 = sf  * HALF
!
!            ! SF contribution (with anhramonic!)
!            sf_e(k) = sf_e(k) + sf
!
!         end
!
!      ! ADP3's
!      else if (f_atom.has_only_ADP3s_and_errors) then
!
!         DIE("sorry ...")
!
!      else ! no anharmonicity
!
!         DIE("sorry ...")
!
!      end
!
!      ! Clean
!      k_pt.destroy
!   
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(sf_e)
!      end
!
!   end
!
!   make_unique_sfd_pos_Y_ADPx_Y_disp_old(sf_e,u,sf_n) ::: private
!   ! Make the unique structure factors and their derivatives "sf_e"
!   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
!   ! set of atom parameters in .fragment_atom.
!   ! NOTE: this version does *all* parameters, positions and ADPs
!   !       *including* up to 4th order anharmonicity.
!   ! NOTE: the order of the derivatives follows the lexical order 
!   !       defined in GAUSSIAN_DATA
!      sf_e :: VEC{CPX}
!      sf_n :: MAT{CPX}, target
!      u :: INT
!
!   ENSURE(.data.created, "no reflection data")
!   ENSURE(.xray_data.created, "no x-ray reflection data")
!   DIE_IF(NOT .data.refine_anharmonicity, "must be refining anharmonicity")
!   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
!
!      f_atom :: ATOM*
!      adp3 :: MAT3{REAL}(3,3,3)
!      adp4 :: MAT4{REAL}(3,3,3,3)
!      v3   :: VEC{REAL}(10)
!      v4   :: VEC{REAL}(15)
!      sf_u :: VEC{CPX}*
!      k_pt,kU :: MAT{REAL}*
!      u1v,u2v,u3v, k1v,k2v,k3v :: VEC{REAL}*
!      u1,u2,u3, k1,k2,k3, tf, c3,c4 :: REAL
!      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
!      n_k,f, k,base :: INT
!      II,sf,sfh,sf2,sf4,sf6,sf24 :: CPX
!
!      ! Constants
!      II  = IMAGIFY(ONE)
!      n_k = .n_unique_SF_k_pts
!
!      ! Symmetry generated k points
!      k_pt.create(n_k,3)
!      .make_unique_SF_k_pts(k_pt)
!      k1v => k_pt(:,1)
!      k2v => k_pt(:,2)
!      k3v => k_pt(:,3)
!
!      ! K times thermal tensors
!      kU.create(n_k,3)        
!
!      ! Initialize
!      sf_e = ZERO
!
!      ! Base index for unique frag atom
!      base = 0
!
!      ! Fragment atom
!      f = .unique_frag_atom(u)
!      f_atom => .fragment_atom(f)
!
!      ! k.U
!      kU.to_product_of(k_pt,f_atom.ADP_tensor)
!      u1v => kU(:,1)
!      u2v => kU(:,2)
!      u3v => kU(:,3)
!
!      ! Structure factor, iunique frag atom "u"
!      sf_u => sf_n(:,u)
!
!      ! ADP4's
!      if (f_atom.has_only_ADP4s_and_errors) then
!
!         ! Reorder from lower pyramid -> lexical
!         GAUSSIAN_DATA:lexical_3_to_lower_pyramid(f_atom.pADP_vector(10:19),v3)
!         GAUSSIAN_DATA:lexical_4_to_lower_pyramid(f_atom.pADP_vector(20:34),v4)
!
!         ! Uncompress lower pyramid -> tensor
!         adp3.uncompress_from_pyramid(v3)
!         adp4.uncompress_from_pyramid(v4)
!
!         do k = 1,n_k
!
!            ! Scattering vector
!            k1 = k1v(k)
!            k2 = k2v(k)
!            k3 = k3v(k)
!
!            k1_k1 = k1*k1
!            k2_k2 = k2*k2
!            k3_k3 = k3*k3
!            k1_k2 = k1*k2
!            k1_k3 = k1*k3
!            k2_k3 = k2*k3
!
!            ! Temperature factor (TF)
!            u1 = u1v(k)
!            u2 = u2v(k)
!            u3 = u3v(k)
!            tf = -HALF*(u1*k1+u2*k2+u3*k3)
!            tf = exp(tf)
!
!            ! Third and fourth order corrections
!            c3 = adp3.contract_with([k1,k2,k3])*SIXTH
!            c4 = adp4.contract_with([k1,k2,k3])*SIXTH*QUARTER
!
!            ! Structure factor x (1 + anharm ...) x TF
!            sfh = sf_u(k) * tf 
!            sf  = sfh * (ONE+II*c3+c4)
!            sf2 = sf  * HALF
!
!            ! SF contribution (with anhramonic!)
!            sf_e(k) = sf_e(k) + sf
!
!         end
!
!      ! ADP3's
!      else if (f_atom.has_only_ADP3s_and_errors) then
!
!         DIE("sorry ...")
!
!      else ! no anharmonicity
!
!         DIE("sorry ...")
!
!      end
!
!      ! Clean
!      kU.destroy
!      k_pt.destroy
!   
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(sf_e)
!      end
!
!   end


   make_unique_sfd_pos_Y_ADP4_Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does *all* parameters, positions and ADPs
   !       *including* up to 4th order anharmonicity.
   ! NOTE: the order of the derivatives follows the lexical order 
   !       defined in GAUSSIAN_DATA

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")
   DIE_IF(NOT .data.refine_anharmonicity, "must be refining anharmonicity")
   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,  "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,  "sf_d, wrong dim1")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,  "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.n_unique_frag_atoms,"sf_n, wrong dim2")

      kv   :: VEC{REAL}(3)
      adp2 :: MAT{REAL}(3,3)
      adp3 :: MAT3{REAL}(3,3,3)
      adp4 :: MAT4{REAL}(3,3,3,3)
      sf_u :: VEC{CPX}*
      k_pt :: MAT{REAL}*
      k1v,k2v,k3v :: VEC{REAL}*
      k1,k2,k3, c2,c3,c4 :: REAL
      k1_k1,k2_k2,k3_k3,k1_k2,k1_k3,k2_k3 :: REAL
      n_k,f,u,k,base :: INT
      II,sfh,sf1,sf2,sf4,sf6,sf24 :: CPX
      f_atom :: ATOM*

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)

      ! k vector components
      k1v => k_pt(:,1)
      k2v => k_pt(:,2)
      k3v => k_pt(:,3)

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         ! Fragment atom
         f = .unique_frag_atom(u)
         f_atom => .fragment_atom(f)

         ! Base index for unique frag atom
         base = .fragment_atom(.unique_frag_atom).no_of_pADPs_up_to_atom(u)

         ! Structure factor, iunique frag atom "u"
         sf_u => sf_n(:,u)

         ! ADP4's
         if (f_atom.has_only_ADP4s_and_errors) then

            ! Get ADP tensors
            f_atom.put_ADP2_to(adp2)
            f_atom.put_ADP3_to(adp3)
            f_atom.put_ADP4_to(adp4)

            DIE_IF(NOT adp2.equals(f_atom.ADP_tensor),"ADP2 not equal to ADP_tensor")

            do k = 1,n_k
   
               ! Scattering vector
               k1 = k1v(k)
               k2 = k2v(k)
               k3 = k3v(k)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
               c4 = adp4.contract_with(kv)*SIXTH*QUARTER
   
               ! Static structure factor x TF
               ! i.e. dynamic structure factor, 
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               sf1 = sfh * (ONE - II*c3 + c4)
               sf2 = sf1 * HALF
   
               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1
   
               ! Pos derivatives
               sf_d(k,base+ 1) =  II*k1*sf1
               sf_d(k,base+ 2) =  II*k2*sf1
               sf_d(k,base+ 3) =  II*k3*sf1

               ! U2 derivatives
               sf_d(k,base+ 4) = -k1_k1*sf2
               sf_d(k,base+ 5) = -k2_k2*sf2
               sf_d(k,base+ 6) = -k3_k3*sf2
               sf_d(k,base+ 7) = -k1_k2*sf1
               sf_d(k,base+ 8) = -k1_k3*sf1
               sf_d(k,base+ 9) = -k2_k3*sf1
   
               ! Structure factor (harmonic)
               sf1  = sfh

               ! Multiples of *harmonic* sf 
               sf2  = sf1 * HALF
               sf4  = sf1 * QUARTER
               sf6  = sf1 * SIXTH
               sf24 = sf1 * SIXTH*QUARTER

               ! U3 derivatives 
               sf_d(k,base+10) = -II*k1_k1*k1*sf6
               sf_d(k,base+11) = -II*k2_k2*k2*sf6
               sf_d(k,base+12) = -II*k3_k3*k3*sf6
               sf_d(k,base+13) = -II*k1_k1*k2*sf2
               sf_d(k,base+14) = -II*k1_k1*k3*sf2
               sf_d(k,base+15) = -II*k2_k2*k1*sf2
               sf_d(k,base+16) = -II*k2_k2*k3*sf2
               sf_d(k,base+17) = -II*k3_k3*k1*sf2
               sf_d(k,base+18) = -II*k3_k3*k2*sf2
               sf_d(k,base+19) = -II*k1*k2*k3*sf1

               ! U4 derivatives
               sf_d(k,base+20) = k1_k1*k1_k1*sf24
               sf_d(k,base+21) = k2_k2*k2_k2*sf24
               sf_d(k,base+22) = k3_k3*k3_k3*sf24
               sf_d(k,base+23) = k1_k1*k1_k2*sf6
               sf_d(k,base+24) = k1_k1*k1_k3*sf6
               sf_d(k,base+25) = k2_k2*k1_k2*sf6
               sf_d(k,base+26) = k2_k2*k2_k3*sf6
               sf_d(k,base+27) = k3_k3*k1_k3*sf6
               sf_d(k,base+28) = k3_k3*k2_k3*sf6
               sf_d(k,base+29) = k1_k1*k2_k2*sf4
               sf_d(k,base+30) = k1_k1*k3_k3*sf4
               sf_d(k,base+31) = k2_k2*k3_k3*sf4
               sf_d(k,base+32) = k1_k1*k2_k3*sf2
               sf_d(k,base+33) = k2_k2*k1_k3*sf2
               sf_d(k,base+34) = k3_k3*k1_k2*sf2

            end

         ! ADP3's
         else if (f_atom.has_only_ADP3s_and_errors) then

            ! Get ADP tensors
            f_atom.put_ADP2_to(adp2)
            f_atom.put_ADP3_to(adp3)
            
            DIE_IF(NOT adp2.equals(f_atom.ADP_tensor),"ADP2 not equal to ADP_tensor")

            do k = 1,n_k
   
               ! Scattering vector
               k1 = k1v(k)
               k2 = k2v(k)
               k3 = k3v(k)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF
               c3 = adp3.contract_with(kv)*SIXTH
   
               ! Static structure factor x TF
               ! i.e. dynamic structure factor, 
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples of *anharmonic* structure factor
               ! -- 3rd order only.
               sf1 = sfh * (ONE - II*c3)
               sf2 = sf1 * HALF
   
               ! SF contribution (anharmonic!)
               sf_e(k) = sf_e(k) + sf1
   
               ! Pos derivatives
               sf_d(k,base+ 1) =  II*k1*sf1
               sf_d(k,base+ 2) =  II*k2*sf1
               sf_d(k,base+ 3) =  II*k3*sf1

               ! U2 derivatives
               sf_d(k,base+ 4) = -k1_k1*sf2
               sf_d(k,base+ 5) = -k2_k2*sf2
               sf_d(k,base+ 6) = -k3_k3*sf2
               sf_d(k,base+ 7) = -k1_k2*sf1
               sf_d(k,base+ 8) = -k1_k3*sf1
               sf_d(k,base+ 9) = -k2_k3*sf1
   
               ! Structure factor (harmonic!)
               sf1  = sfh

               ! Multiples of *harmonic* sf
               sf2  = sf1 * HALF
               sf6  = sf1 * SIXTH

               ! U3 derivatives
               sf_d(k,base+10) = -II*k1_k1*k1*sf6
               sf_d(k,base+11) = -II*k2_k2*k2*sf6
               sf_d(k,base+12) = -II*k3_k3*k3*sf6
               sf_d(k,base+13) = -II*k1_k1*k2*sf2
               sf_d(k,base+14) = -II*k1_k1*k3*sf2
               sf_d(k,base+15) = -II*k2_k2*k1*sf2
               sf_d(k,base+16) = -II*k2_k2*k3*sf2
               sf_d(k,base+17) = -II*k3_k3*k1*sf2
               sf_d(k,base+18) = -II*k3_k3*k2*sf2
               sf_d(k,base+19) = -II*k1*k2*k3*sf1

            end

         else ! NO anharmonicity

            ! Get ADP tensor
            f_atom.put_ADP2_to(adp2)
            
            DIE_IF(NOT adp2.equals(f_atom.ADP_tensor),"ADP2 not equal to ADP_tensor")

            do k = 1,n_k
   
               ! Scattering vector
               k1 = k1v(k)
               k2 = k2v(k)
               k3 = k3v(k)
               kv = [k1,k2,k3]

               ! Component products
               k1_k1 = k1*k1
               k2_k2 = k2*k2
               k3_k3 = k3*k3
               k1_k2 = k1*k2
               k1_k3 = k1*k3
               k2_k3 = k2*k3

               ! U tensor contracted with k vector
               c2 = adp2.contract_with(kv)*HALF

             ! stdout.show("c2    =",c2)
   
               ! Static structure factor x TF
               ! i.e. dynamic structure factor, 
               ! in the harmonic approximation
               sfh = sf_u(k) * exp(-c2)

               ! Multiples *harmonic* structure factor
               sf1 = sfh 
               sf2 = sf1 * HALF
   
               ! SF contribution (harmonic)
               sf_e(k) = sf_e(k) + sf1
   
               ! Pos derivatives
               sf_d(k,base+ 1) =  II*k1*sf1
               sf_d(k,base+ 2) =  II*k2*sf1
               sf_d(k,base+ 3) =  II*k3*sf1

               ! U2 derivatives
               sf_d(k,base+ 4) = -k1_k1*sf2
               sf_d(k,base+ 5) = -k2_k2*sf2
               sf_d(k,base+ 6) = -k3_k3*sf2
               sf_d(k,base+ 7) = -k1_k2*sf1
               sf_d(k,base+ 8) = -k1_k3*sf1
               sf_d(k,base+ 9) = -k2_k3*sf1
   
            end

         end

      end

      ! Clean
      k_pt.destroy
   
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end


   make_unique_sfd_pos_Y_ADP__Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does *all* parameters, positions and ADPs

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      II,sf,sf2 :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)

         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         do k = 1,n_k

            k1k = k1(k)
            k2k = k2(k)
            k3k = k3(k)

            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

            sf  = sf_u(k) * tf
            sf2 = HALF*sf

            sf_e(k) = sf_e(k) + sf

            sf_d(k,base+1) =   II*k1k*sf
            sf_d(k,base+2) =   II*k2k*sf
            sf_d(k,base+3) =   II*k3k*sf
            sf_d(k,base+4) = -k1k*k1k*sf2
            sf_d(k,base+5) = -k2k*k2k*sf2
            sf_d(k,base+6) = -k3k*k3k*sf2
            sf_d(k,base+7) = -k1k*k2k*sf 
            sf_d(k,base+8) = -k1k*k3k*sf 
            sf_d(k,base+9) = -k2k*k3k*sf 

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy
   
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_Y_ADP__N(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does positions *only*

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")
   DIE_IF(.data.refine_anharmonicity, "don't refine anharmonicity without ADP's")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      II,sf :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)

         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         do k = 1,n_k

            k1k = k1(k)
            k2k = k2(k)
            k3k = k3(k)

            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

            sf  = sf_u(k) * tf

            sf_e(k) = sf_e(k) + sf

            sf_d(k,base+1) =   II*k1k*sf
            sf_d(k,base+2) =   II*k2k*sf
            sf_d(k,base+3) =   II*k3k*sf

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy
   
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_N_ADP__Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does ADPs *only*

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")
   DIE_IF(.data.refine_anharmonicity, "don't refine anharmonicity without positions")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      sf,sf2 :: CPX

      ! Constants
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)

         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         do k = 1,n_k

            k1k = k1(k)
            k2k = k2(k)
            k3k = k3(k)

            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

            sf  = sf_u(k) * tf
            sf2 = HALF*sf

            sf_e(k) = sf_e(k) + sf

            sf_d(k,base+4) = -k1k*k1k*sf2
            sf_d(k,base+5) = -k2k*k2k*sf2
            sf_d(k,base+6) = -k3k*k3k*sf2
            sf_d(k,base+7) = -k1k*k2k*sf 
            sf_d(k,base+8) = -k1k*k3k*sf 
            sf_d(k,base+9) = -k2k*k3k*sf 

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy
   
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_Y_Hiso_Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does H_U_iso=TRUE derivatives.

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")
   DIE_IF(.data.refine_anharmonicity, "don't refine anharmonicity without H ADP's")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      II,sf,sf2 :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)
         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         if (.fragment_atom(f).atomic_number>1) then

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf = sf_u(k) * tf
               sf2 = HALF*sf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+1) =   II*k1k*sf
               sf_d(k,base+2) =   II*k2k*sf
               sf_d(k,base+3) =   II*k3k*sf
               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 

            end

         else

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf  = sf_u(k) * tf
               sf2 = -HALF * sf * (k1k*k1k+k2k*k2k+k3k*k3k) * THIRD

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+1) = II*k1k*sf
               sf_d(k,base+2) = II*k2k*sf
               sf_d(k,base+3) = II*k3k*sf
               sf_d(k,base+4) = sf2
               sf_d(k,base+5) = sf2
               sf_d(k,base+6) = sf2
               sf_d(k,base+7) = ZERO
               sf_d(k,base+8) = ZERO
               sf_d(k,base+9) = ZERO

            end

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_N_Hiso_Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version *no* positions and does H_U_iso=TRUE derivatives.

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")
   DIE_IF(.data.refine_anharmonicity, "don't refine anharmonicity without positions")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      sf,sf2 :: CPX

      ! Constants
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)
         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         if (.fragment_atom(f).atomic_number>1) then

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf = sf_u(k) * tf
               sf2 = HALF*sf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 

            end

         else

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf  = sf_u(k) * tf
               sf2 = -HALF*sf * (k1k*k1k+k2k*k2k+k3k*k3k) * THIRD

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+4) = sf2
               sf_d(k,base+5) = sf2
               sf_d(k,base+6) = sf2

            end

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_Y_HADP_N(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does *not* do H ADPs

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")
   DIE_IF(.data.refine_anharmonicity, "don't refine anharmonicity without H ADP's")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      II,sf,sf2 :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)
         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         ! If not hydrogen atom
         if (.fragment_atom(f).atomic_number>1) then

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf = sf_u(k) * tf
               sf2 = HALF*sf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+1) =   II*k1k*sf
               sf_d(k,base+2) =   II*k2k*sf
               sf_d(k,base+3) =   II*k3k*sf
               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 

            end

         else ! this is hydrogen atom

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf  = sf_u(k) * tf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+1) = II*k1k*sf
               sf_d(k,base+2) = II*k2k*sf
               sf_d(k,base+3) = II*k3k*sf

            end

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_N_HADP_N(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does *not* do positions *nor* H ADPs
   !       i.e. it only does heavy atom ADPs

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")
   ENSURE(.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   DIE_IF(.data.refine_anharmonicity, "don't refine anharmonicity without positions and H ADP's")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      sf,sf2 :: CPX

      ! Constants
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)
         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         ! If not hydrogen atom
         if (.fragment_atom(f).atomic_number>1) then

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf = sf_u(k) * tf
               sf2 = HALF*sf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 

            end

         else ! this is hydrogen atom

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf  = sf_u(k) * tf

               sf_e(k) = sf_e(k) + sf

            end

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   d_chi2_dX(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters.  NOTE: this routine assumes that the .scale_factor
   ! and .extinction_factor are fixed.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.d_chi2_dX(res,dFdX)
   end

   d_chi2_dX_plus_se(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters. Two extra derivatives are included, w.r.t. the
   ! extinction parameter and the scale factor.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.d_chi2_dX_plus_se(res,dFdX)
   end

   d_F_abs_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors  w.r.t. the X
   ! parameters. 
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.d_F_abs_dX(res,dFdX)
   end

   solve_normal_equations(dFdX) ::: leaky
   ! Get the ".dX" in the parameters by solving the normal
   ! equations, given "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters. 
      dFdX :: MAT{REAL}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.solve_normal_equations(dFdX)
   end

!   set_parameter_errors
!   ! Set the parameter errors
!   ENSURE(.data_exists,"no diffraction data")
!
!      .data.set_parameter_errors
!
!   end

!  =================
!  Refinement output
!  =================

   put_fit_header_info
   ! Put out the fit header
   ENSURE(.data_exists,"no diffraction data")

      ! Turn off printing if refining ...
      if (.data.refine_structure AND NOT .data.show_fit_output) return

      ! Print header
      DIFFRACTION_DATA:put_fit_header

      ! Put the fit control switches
      .data.put_refinement_switches

      ! Put the initial parameters
      stdout.flush(2)
      stdout.text("Initial parameter values:")
      .put_fit_parameters(correlation_matrix=FALSE)

      ! Put the fit table header
      .data.put_fit_table_headings

   end

   put_refinement_header_info
   ! Put out the fit header
   ENSURE(.data_exists,"no diffraction data")

      ! Print header
      DIFFRACTION_DATA:put_refinement_header

      ! Put the refinement control switches
      .data.put_refinement_switches

      ! Put the initial parameters
      stdout.flush
      stdout.text("Initial asymmetric unit parameter values:")
      .put_fit_parameters(correlation_matrix=FALSE)

      ! Put the refinement header info
      .data.put_refinement_table_headings

   end

   put_fit_parameters(correlation_matrix)
   ! Write refinement results
      correlation_matrix :: BIN, optional

   ENSURE(.data_exists,"no diffraction data")
   ENSURE(.asymmetric_unit_atom.created,"no .asymmetric_unit_atom's")

      do_corr_mx :: BIN

      ! Put positions and ADPs
      .asymmetric_unit_atom.put_coordinates_and_ADPs(no_header=TRUE)

      ! Whether to print the parameter corelation matrix
      do_corr_mx = .data.display_correlation_matrix
      if (present(correlation_matrix)) do_corr_mx = correlation_matrix

      ! Put correlation matrix
      if (do_corr_mx) .put_correlation_matrix

      ! Put zero eigenvalue information
      if (.data.display_near_0_eigenvectors) .data.put_near_0_eigenvectors

   end

   put_correlation_matrix
   ! Put the correlation matrix
   ENSURE(.data_exists,"no diffraction data")
   ENSURE(.data.correlation_matrix.created,"no data.correlation_matrix")
   ENSURE(.asymmetric_unit_atom.created,"no .asymmetric_unit_atom's")

      val :: VEC{REAL}*
      row,col :: VEC{INT}*
      label,labr,labc :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*
      min_corr :: REAL
      n_corr :: INT

      ! How many large correlations?
      min_corr = .data.min_correlation
      n_corr   = .data.correlation_matrix.number_in_range([min_corr,0.999d0])

      ! If no large correlations, return
      if (n_corr<0) return

      ! Create
      val.create(n_corr)
      label.create(n_corr)
      row.create(n_corr)
      col.create(n_corr)

      ! Get row and column indices
      .data.correlation_matrix.get_indices_in_range([min_corr,0.9999d0],row,col,val)

      ! Construct the row labels
      labr  => .asymmetric_unit_atom.tag_pADP_labels(row)
      labc  => .asymmetric_unit_atom.tag_pADP_labels(col)
      label = labr
      label.concatenate_elementwise_with(labr)
      label.concatenate_elementwise_with("--")
      label.concatenate_elementwise_with(labc)

      ! Clean
      labc.destroy
      labr.destroy
      col.destroy
      row.destroy

      ! Make table
      table.create(2)
      table(1).set_heading("Param. Pair"); table(1).set_values(label)
      table(1).set_heading("Correlation"); table(2).set_values(val)
      table.put
      table.destroy

      ! Put the array out
      stdout.flush
      stdout.text("Largest correlations::")
      stdout.flush
      stdout.put(val,row_label=label,col_label="Correlation")

      ! Clean again
      label.destroy
      val.destroy

   end

   put_fit_iteration_results
   ! Print out the current fit iterations results
   ENSURE(.data_exists,"no diffraction data")

      ! Turn off printing if refining ...
      if (.data.refine_structure AND NOT .data.show_fit_output) return

      ! Put the table body
      .data.put_fit_table_body

   end

   put_refinement_iteration_results
   ! Print out the current refinement iterations results
   ENSURE(.data_exists,"no diffraction data")

      ! Put the table body
      .data.put_refinement_table_body

   end

   put_fit_footer_info
   ! Finalise fit, write results
   ENSURE(.data_exists,"no diffraction data")

      ! Turn off printing if refining
      if (.data.refine_structure) return

      ! Iteration footer
      .data.put_fit_results

      ! Put the initial parameters
      stdout.flush(2)
      stdout.text("Final asymmetric unit parameter values:")
      .put_fit_parameters

   end

   put_refinement_footer_info
   ! Finalise refinement, write results
   ENSURE(.data_exists,"no diffraction data")

      ! Iteration footer
      .data.put_refinement_results

      ! Put the initial parameters
      stdout.flush(2)
      stdout.text("Final asymmetric unit parameter values:")
      .put_fit_parameters

   end

   put_bond_info_with_errors
   ! Put out the bond-length, bond-angle and torsion-angle info with
   ! errors in brackets

   ENSURE(.data.created,   "no data")
   ENSURE(.data.fragment_covariance_matrix.created,"no fragment_covariance_matrix")

      f1,n1,f1b,c1b :: INT
      f2,n2,f2b,c2b :: INT
      cm :: MAT{REAL}*

      ! Turn off printing if refining
      if (.data.refine_structure) return

      ! Positional covariance matrix
      cm.create(3*.n_fragment_atoms,3*.n_fragment_atoms)

      ! Get just the positional covariance matrix (sigh)
      f1b = 0
      c1b = 0
      do f1 = 1,.n_fragment_atoms

         n1  = .fragment_atom(f1).no_of_pADPs

         f2b = 0
         c2b = 0
         do f2 = 1,.n_fragment_atoms

            n2  = .fragment_atom(f2).no_of_pADPs

            cm(c1b+1:c1b+3,c2b+1:c2b+3) = .data.fragment_covariance_matrix(f1b+1:f1b+3,f2b+1:f2b+3)

            f2b = f2b + n2
            c2b = c2b + 3

         end

         f1b = f1b + n1
         c1b = c1b + 3

      end

      ! Print out the tables with errors
      .fragment_atom.put_bond_length_table(cm)
      .fragment_atom.put_bond_angle_table(cm)
      .fragment_atom.put_torsion_angle_table(cm)

      ! Clean
      cm.destroy

   end

   put_bond_info_with_errors_to
   ! Put out the bond-length, bond-angle and torsion-angle info with
   ! errors with *no* brackets to a file, name read from stdin

   ENSURE(.data.created,   "no data")
   ENSURE(.data.fragment_covariance_matrix.created,"no fragment_covariance_matrix")

      cm :: MAT{REAL}*
      name :: STR
      save,file :: TEXTFILE*

      ! Read the name
      stdin.read(name)

      ! Create the new file
      file.create(trim(name))
      file.open_for("write")

      ! Positional covariance matrix
      cm.create(3*.n_fragment_atoms,3*.n_fragment_atoms)

      ! Get just the positional covariance matrix
      .data.fragment_covariance_matrix.put_sub_blocks_to(cm,9,3)

      ! Print out the tables with errors
      save   => TEXTFILE::stdout
      stdout => file
      .fragment_atom.put_bond_length_table(cm,parentheses=FALSE)
      .fragment_atom.put_bond_angle_table(cm,parentheses=FALSE)
      .fragment_atom.put_torsion_angle_table(cm,parentheses=FALSE)
      stdout => save

      ! Clean
      cm.destroy
      file.close; file.destroy

   end

!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT3{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

!  ====
!  Dump
!  ====

   do_dump ::: private
   ! Dump object data as text

      stdout.dump("CIF_chemical_formula",.CIF_chemical_formula)
      .spacegroup.dump("spacegroup")
      .unit_cell.dump("unit_cell")
      stdout.dump("n_fragment_atoms",.n_fragment_atoms)
      .fragment_atom.dmpp("fragment_atom")
      stdout.dump("destroy_fragment_atom",.destroy_fragment_atom)
      stdout.dmpp("fragment_geometry",.fragment_geometry)
      stdout.dump("asymmetric_unit_source",.asymmetric_unit_source)
      stdout.dump("n_asymmetric_unit_atoms",.n_asymmetric_unit_atoms)
      .asymmetric_unit_atom.dmpp("asymmetric_unit_atom")
      stdout.dmpp("asymmetric_unit_geometry",.asymmetric_unit_geometry)
      stdout.dump("prune_asymmetric_unit",.prune_asymmetric_unit)
      stdout.dump("n_unit_cell_atoms",.n_unit_cell_atoms)
      stdout.dmpp("unit_cell_geometry",.unit_cell_geometry)
      stdout.dmpp("unique_unit_cell_atom",.unique_unit_cell_atom)
    ! stdout.dmpp("unique_uc_atom_offset",.unique_uc_atom_offset)
      stdout.dmpp("is_asym_unit_cell_atom",.is_asym_unit_cell_atom)
      stdout.dump("fragment_info_made",.fragment_info_made)
      stdout.dmpp("asym_atom_for_unit_cell_atom",.asym_atom_for_unit_cell_atom)
      stdout.dmpp("asym_symop_for_unit_cell_atom",.asym_symop_for_unit_cell_atom)
      stdout.dmpp("frag_atom_for_unit_cell_atom",.frag_atom_for_unit_cell_atom)
      stdout.dmpp("unit_cell_atom_for_frag_atom",.unit_cell_atom_for_frag_atom)
      stdout.dmpp("unit_cell_shft_for_frag_atom",.unit_cell_shft_for_frag_atom)
      stdout.dmpp("frag_atom_for_asym_atom",.frag_atom_for_asym_atom)
      stdout.dmpp("asym_atom_for_frag_atom",.asym_atom_for_frag_atom)
      stdout.dmpp("frag_parent_for_cell_atom",.frag_parent_for_cell_atom)
      stdout.dump("n_unique_frag_atoms",.n_unique_frag_atoms)
      stdout.dmpp("unique_frag_atom",.unique_frag_atom)
      stdout.dmpp("unique_atom_for_frag_atom",.unique_atom_for_frag_atom)
      stdout.dmpp("unique_symop_for_frag_atom",.unique_symop_for_frag_atom)
      stdout.dmpp("asym_symop_for_frag_atom",.asym_symop_for_frag_atom)
      stdout.dmpp("asym_shift_for_frag_atom",.asym_shift_for_frag_atom)
      stdout.dump("Z",.Z)
      stdout.dump("use_manual_repetition_factors",.use_manual_repetition_factors)
      stdout.dmpp("repetition_factor",.repetition_factor)
      stdout.dmpp("asym_atom_rep_factor",.asym_atom_rep_factor)
    ! stdout.dmpp("asym_atom_stabilizer",.asym_atom_stabilizer)
    ! stdout.dmpp("unit_cell_connection",.unit_cell_connection)
    ! stdout.dmpp("uc_vdw_connection",.uc_vdw_connection)
      stdout.dmpp("unit_cell_mol_for_atom",.unit_cell_mol_for_atom)
      stdout.dump("n_unit_cell_mols",.n_unit_cell_mols)
      stdout.dump("n_stabilizer_symops",.n_stabilizer_symops)
    ! stdout.dmpp("stabilizer_symop",.stabilizer_symop)
      stdout.dmpp("str",.str)
      stdout.dmpp("ptr",.ptr)
      stdout.dmpp("dtr",.dtr)
      stdout.dmpp("ftr",.ftr)
      stdout.dmpp("gtr",.gtr)
      stdout.dump("data_kind",.data_kind)
    ! stdout.dmpp("data",.data)
    ! stdout.dmpp("xray_data",.xray_data)
    ! stdout.dmpp("pnd_data",.pnd_data)
      stdout.dump("r_free_percentage",.r_free_percentage)
    ! stdout.dmpp("xray_r_free_data",.xray_r_free_data)
    ! stdout.dmpp("pnd_r_free_data",.pnd_r_free_data)
    ! stdout.dmpp("core_reflection",.core_reflection)
      stdout.dump("stl_limit",.stl_limit)
      stdout.dump("finalize",.finalize)

   end

   dump(object_name,ptr) ::: get_from(OBJECT, TYPE=>CRYSTAL)
   ! Dump object data as text
   end

   dmpp(object_name) ::: get_from(OBJECT, TYPE=>CRYSTAL)
   ! Dump pointer object data as text
   end

!  ===========
!  Put methods
!  ===========

   put
   ! Put out the crystal data to file "out"

   DIE_IF(tonto.destroyed,"no tonto variable")

      .unit_cell.put

      .spacegroup.put

      if (.asymmetric_unit_geometry.created) .put_asymmetric_unit_geometry

      if (tonto.low_verbosity) then
      if (.fragment_geometry.created) then
         if (.fragment_geometry.dim>100) return
      end
      end

      if (.fragment_geometry.created)        .put_fragment_data
      if (.unit_cell_geometry.created)       .put_unit_cell_geometry

    ! if (.unit_cell_connection.created)     .put_uc_connection_table
    ! if (.uc_vdw_connection.created)        .put_uc_vdw_connection_table

      .put_reflection_data

   end

   put_xyz_seitz
   ! Put out the spacegroup seitz matrices.

   ENSURE(.spacegroup.n_seitz>0,"no seitz matrices")

      n :: INT
      seitz :: MAT3{REAL}*

      seitz => .xyz_seitz_matrices

      stdout.flush
      stdout.text("Cartesian (xyz) seitz matrices :")
      do n = 1,.spacegroup.n_seitz
        stdout.flush
        stdout.show("n =",n)
        stdout.put(seitz(:,:,n))
      end

      seitz.destroy

   end

   put_asymmetric_unit_geometry ::: private
   ! Put out the asymmetric unit geometry. 

   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit geometry")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric unit atoms")
   ENSURE(.asym_atom_rep_factor.created,"no asym_atom_rep_factor")
   ENSURE(.asym_atom_stabilizer.created,"no asym_atom_stabilizer")

      ID :: VEC{STR}*
      rf :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.flush
      stdout.text("===============")
      stdout.text("Asymmetric unit")
      stdout.text("===============")
      stdout.flush
      stdout.show("Asymmetric unit source       =",.asymmetric_unit_source)
      stdout.show("No. of asymmetric unit atoms =",.n_asymmetric_unit_atoms)
      stdout.flush

      ! Data
      ID => .asymmetric_unit_atom.unique_tags
      rf.create(.n_asymmetric_unit_atoms)
      rf = int(.asym_atom_rep_factor)

      ! Table
      table.create(6)
      table(1).set_heading("ID");         table(1).set_values(ID)
      table(2).set_heading("x");          table(2).set_values(.asymmetric_unit_geometry(1,:))
      table(3).set_heading("y");          table(3).set_values(.asymmetric_unit_geometry(2,:))
      table(4).set_heading("z");          table(4).set_values(.asymmetric_unit_geometry(3,:))
      table(3).set_sb3head("/frac")
      table(5).set_heading("Rep");        table(5).set_values(rf)
      table(5).set_subhead("fac")
      table(5).set_sb3head("tor")
      table(6).set_item_spacing(2)
      table(6).set_heading("Stabilizer"); table(6).set_values(.asym_atom_stabilizer)
      table(6).set_subhead("symops")
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      rf.destroy
      ID.destroy

   end

   put_asym_atom_rep_factors ::: private
   ! Put out the asymmetric unit atom repetition factors

   ENSURE(.asym_atom_rep_factor.created,"no asymmetric unit atom repetition factors")
   ENSURE(.asym_atom_stabilizer.created,"no asymmetric unit atom stabilizers")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric unit atom")

      a,n,rf,st :: INT
      symbol :: STR

      stdout.flush
      stdout.text("Crystal asymmetric unit atom repetition factors:")
      stdout.flush
      stdout.dash(int_fields=3)
      stdout.put("Asym",int_width=TRUE)
      stdout.put("Rep.",int_width=TRUE)
      stdout.put("Stab.",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Factor",int_width=TRUE)
      stdout.put("Symop",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=3)
      do a = 1,.n_asymmetric_unit_atoms
         symbol = .asymmetric_unit_atom(a).chemical_symbol
         symbol = trim(symbol) // " (" // trim(a.to_str) // ")"
         stdout.put(symbol,int_width=TRUE)
         DIE_IF(NOT .asym_atom_rep_factor(a).is_int,"asym_atom_rep_factor not int!")
         rf = int(.asym_atom_rep_factor(a))
         st = .asym_atom_stabilizer(a)[1]
         stdout.put(rf)
         stdout.put(st)
         do n = 2,.asym_atom_stabilizer(a).element.dim
            st = .asym_atom_stabilizer(a)[n]
            stdout.flush
            stdout.tab(int_fields=2)
            stdout.put(st)
         end
         stdout.flush
      end
      stdout.dash(int_fields=3)
   end

   put_unit_cell_geometry
   ! Put out the unit_cell_geometry. 

   ENSURE(.unit_cell_geometry.created,"no unit_cell_geometry")
   ENSURE(.asym_atom_for_unit_cell_atom.created, "no asym-atom_for_unit_cell_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.created,"no asym_symop_for_unit_cell_atom")
   ENSURE(.frag_atom_for_unit_cell_atom.created, "no frag_atom_for_unit_cell_atom")
   ENSURE(.frag_parent_for_cell_atom.created,    "no frag_parent_for_cell_atom")

      ID :: VEC{STR}*
      is_asym :: VEC{BIN}*
      asym_atom,asym_symp,frag_atom,frag_parn :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.flush
      stdout.text("==================")
      stdout.text("Unit cell geometry")
      stdout.text("==================")
      if (.spacegroup.n_seitz==1) then
      stdout.flush
      stdout.text(". The spacegroup is P1. The unit cell")
      stdout.text("  is the same as the asymmetric unit.")
      end
      stdout.flush
      stdout.show("No. of unit cell atoms =",.n_unit_cell_atoms)
      stdout.flush

      ! Data
      ID        => .fragment_atom(.frag_parent_for_cell_atom).unique_tags
      asym_atom => .asym_atom_for_unit_cell_atom
      asym_symp => .asym_symop_for_unit_cell_atom
      is_asym   => .is_asym_unit_cell_atom
      frag_atom => .frag_atom_for_unit_cell_atom
      frag_parn => .frag_parent_for_cell_atom

      ! Table
      table.create(9)

      table(1).set_heading("ID");        table(1).set_values(ID)

      table(3).set_heading("Coord")
      table(2).set_subhead("- x -");     table(2).set_values(.unit_cell_geometry(1,:))
      table(3).set_subhead("- y -");     table(3).set_values(.unit_cell_geometry(2,:))
      table(4).set_subhead("- z -");     table(4).set_values(.unit_cell_geometry(3,:))
      table(3).set_sb3head("/frac")

      table(5).set_heading("From");      table(5).set_values(asym_atom)
      table(5).set_subhead("asym")
      table(5).set_sb3head("atom")

      table(6).set_heading("Using");     table(6).set_values(asym_symp)
      table(6).set_subhead("symop")
      table(6).set_sb3head("    #")

      table(7).set_heading("Asym");      table(7).set_values(is_asym)
      table(7).set_subhead("atom")
      table(7).set_sb3head("   ?")

      table(8).set_heading("Made by a"); table(8).set_values(frag_atom)
      table(8).set_subhead("shift frm")
      table(8).set_sb3head("frag atom")

      table(9).set_heading("Made by a"); table(9).set_values(frag_parn)
      table(9).set_subhead("symop frm")
      table(9).set_sb3head("frag atom")

      table.put

      ! Clean
      table.clear_columns
      table.destroy
      ID.destroy

   end

   put_pdb(pdbfile)
   ! pdb file header generation
   ! Put unit cell information 
   !CRYST1   31.595   32.369   24.219  90.00  90.00  90.00 P 21 21 21    8
      pdbfile :: TEXTFILE*
      factor :: REAL
      pdbfile.save
      pdbfile.set_margin_width(0)
      pdbfile.put("CRYST1",width=6)
      pdbfile.set_real_precision(3)
      pdbfile.set_real_width(9)
      pdbfile.put(.unit_cell.length(1).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(2).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(3).to_units("angstrom"))
      pdbfile.set_real_precision(2)
      pdbfile.set_real_width(7)
      pdbfile.put(.unit_cell.angle(1).to_units("degree"))
      pdbfile.put(.unit_cell.angle(2).to_units("degree"))
      pdbfile.put(.unit_cell.angle(3).to_units("degree"))
      pdbfile.put(.spacegroup.HM_symbol,width=10)
      pdbfile.put(.Z,width=5)
      pdbfile.flush
      pdbfile.put("SCALE1",width=6)
      pdbfile.tab(width=6)
      pdbfile.set_real_precision(7)
      pdbfile.set_real_width(10)
      factor=1.0d0
      factor.convert_to("angstrom^-1")
      pdbfile.put(.unit_cell.inverse_matrix(1,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(1,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(1,3)*factor)
      pdbfile.flush
      pdbfile.put("SCALE2",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_matrix(2,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(2,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(2,3)*factor)
      pdbfile.flush
      pdbfile.put("SCALE3",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_matrix(3,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(3,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(3,3)*factor)
      pdbfile.flush
      !SCALE1     0.1053741 0.0175390 0.0172991      0.0000000
      !SCALE2     0.0000000 0.0601636 0.0076747      0.0000000
      !SCALE3     0.0000000 0.0000000 0.0321397      0.0000000
      pdbfile.unsave
   end

!   make_cif_errors_old(esd)
!   ! Make the errors "esd" for cif file output (positions and ADP's)
!   ! after a refinement i.e. this is done in crystal axis system;
!   ! positions are in bohr and ADP's are in bohr^2.
!      esd :: VEC{REAL}
!
!   ENSURE(.asymmetric_unit_atom.created,"no asymmetric unit atoms")
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.covariance_matrix.created,"no covariance_matrix")
!   ENSURE(esd.dim==9*.n_asymmetric_unit_atoms,"wrong size, esd")
!
!      n_atom, a,b,i,j,ii,jj :: INT
!      T,C :: MAT{REAL}*
!
!      ! No of asymmteric atoms
!      n_atom = .asymmetric_unit_atom.dim
!
!      ! The covariance matrix transform
!      ! Old style ...
!      T.create(9,9)
!      T = ZERO
!      T(1:3,1:3) = .unit_cell.inverse_matrix
!      T(4:9,4:9).to_tensor_change_basis_of(.unit_cell.reciprocal_U_matrix,reorder=TRUE)
!
!      ! Get standard deviations and covariances 
!      ! in crystal coordinates - only for coords/ADP2's
!      C.create(9*n_atom,9*n_atom)
!      i  = 0
!      ii = 0
!      do a = 1,n_atom
!         j  =  0
!         jj =  0
!         do b = 1,n_atom
!            .data.covariance_matrix(i+1:i+9,j+1:j+9).back_transform_to(C(ii+1:ii+9,jj+1:jj+9),T)
!            j  = j  + .asymmetric_unit_atom(b).no_of_pADPs
!            jj = jj + 9
!         end
!         i  = i  + .asymmetric_unit_atom(a).no_of_pADPs
!         ii = ii + 9
!      end
!
!      ! Get the esd's
!      C.put_diagonal_to(esd)
!
!      ! Clean
!      C.destroy
!      T.destroy
!
!   end

   make_cif_errors(esd)
   ! Make the errors "esd" for cif file output (positions and ADP's)
   ! after a refinement i.e. this is done in crystal axis system;
   ! positions are in bohr and ADP's are in bohr^2.
      esd :: VEC{REAL}

   ENSURE(.asymmetric_unit_atom.created,"no asymmetric unit atoms")
   ENSURE(.data.created,"no data")
   ENSURE(.data.covariance_matrix.created,"no covariance_matrix")

      T,C :: MAT{REAL}*
      n_pADPs :: INT
      a,n, ab,af,al :: INT

      ! No of asymmteric atoms
      n_pADPs = .asymmetric_unit_atom.no_of_pADPs
      DIE_IF(esd.dim/=n_pADPs,"wrong size, esd")

      ! Get standard deviations and covariances 
      ! ... in crystal coordinates
      C.create(n_pADPs,n_pADPs)
      C = ZERO

      ! The covariance matrix transformation matrix
      ! This is only applied to the diagonal blocks.
      T.create(34,34)
      GAUSSIAN_DATA:symmetric_tensor_product_mx(T,.unit_cell.reciprocal_U_matrix) 
      T(1:3,1:3) = .unit_cell.inverse_matrix ! Reset positional transform

      do a = 1,.n_asymmetric_unit_atoms

         ! Block limits
         n  = .asymmetric_unit_atom(a).no_of_pADPs
         ab = .asymmetric_unit_atom.no_of_pADPs_up_to_atom(a)
         af = ab +  1
         al = ab + n

         ! Transform ...
         .data.covariance_matrix(af:al,af:al).back_transform_to(C(af:al,af:al),T(1:n,1:n))

      end

      ! Get the esd's ... only diagonal (blocks) needed
      C.put_diagonal_to(esd)

      ! Clean
      C.destroy
      T.destroy

   end

   put_cif(basis,scf_type)
   ! Put out a standard cif file
      basis,scf_type :: STR

   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")

      refinement :: BIN
      n_pADPs :: INT
      Z :: REAL
      esd :: VEC{REAL}*

      ! Spacegroup information
      stdout.flush
      stdout.text("# --------------------")
      stdout.text("# Symmetry information")
      stdout.text("# --------------------")
      .spacegroup.put_cif

      ! Unit cell information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Unit cell information")
      stdout.text("# ---------------------")
      .unit_cell.put_cif

      ! Z factor
      Z = .z_factor
      stdout.text("_cell_formula_units_Z "//trim(Z.to_str("f8.2",left_justify=TRUE)))

      ! Put refinement information
      refinement = FALSE
      nullify (esd)
      if (.data.created) then
      if (.data.covariance_matrix.created) then

         ! Refinement was done
         refinement = TRUE

         ! Write the details
         stdout.flush
         stdout.text("# ------------------")
         stdout.text("# Refinement details")
         stdout.text("# ------------------")
         .data.put_cif(basis,scf_type)

         ! Standard deviations and covariances 
         ! For: coordinates and ADP2's only!
         n_pADPs = .asymmetric_unit_atom.no_of_pADPs
         esd.create(n_pADPs)
         .make_cif_errors(esd)
         esd = sqrt(esd)

      end
      end

      ! Put the coordinate information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# ---------------------")

      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell)
      if (refinement) then; .asymmetric_unit_atom.put_cif_with_errors(esd)
      else;                 .asymmetric_unit_atom.put_cif
      end
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell)

      ! Clean
      esd.destroy

      ! Put the reflection data
      if (refinement) then
         stdout.flush
         stdout.text("# -----------------------")
         stdout.text("# Refined reflection data")
         stdout.text("# -----------------------")
         .data.put_cif_reflections
      end

   end

   put_accurate_cif(basis,scf_type)
   ! Put accurate cif file
      basis,scf_type :: STR

      Z :: REAL

      if (.data.destroyed) then
         WARN("No data, no refinement? CIF file not made.")
         return
      end

      if (.data.covariance_matrix.destroyed) then
         WARN("No covariance matrix, no CIF file made")
         return
      end

      ! Spacegroup information
      stdout.flush
      stdout.text("# --------------------")
      stdout.text("# Symmetry information")
      stdout.text("# --------------------")
      .spacegroup.put_cif

      ! Unit cell information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Unit cell information")
      stdout.text("# ---------------------")
      .unit_cell.put_cif

      ! Z factor
      Z = .z_factor
      stdout.text("_cell_formula_units_Z "//trim(Z.to_str("f8.2",left_justify=TRUE)))

      ! Put refinement information
      stdout.flush
      stdout.text("# ------------------")
      stdout.text("# Refinement details")
      stdout.text("# ------------------")
      .data.put_cif(basis,scf_type)

      ! Put the coordinate information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# ---------------------")
      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell)
      .asymmetric_unit_atom.put_accurate_cif(.data.covariance_matrix)
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell)

   end

   put_molecule_cif(atom,basis,scf_type)
   ! Put cif file with given molecule "atom" list
      atom :: VEC{ATOM}
      basis,scf_type :: STR

      Z :: REAL

      ! Spacegroup information
      stdout.flush
      stdout.text("# --------------------")
      stdout.text("# Symmetry information")
      stdout.text("# --------------------")
      .spacegroup.put_cif

      ! Unit cell information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Unit cell information")
      stdout.text("# ---------------------")
      .unit_cell.put_cif

      ! Z factor
      Z = .z_factor
      stdout.text("_cell_formula_units_Z "//trim(Z.to_str("f8.2",left_justify=TRUE)))

      ! Put refinement information
      if (.data.created) then
      stdout.flush
      stdout.text("# ------------------")
      stdout.text("# Refinement details")
      stdout.text("# ------------------")
      .data.put_cif(basis,scf_type)
      end

      ! Put the coordinate information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# ---------------------")
      atom.change_axis_system_to("crystal",.unit_cell)
      atom.put_accurate_cif
      atom.change_axis_system_to("cartesian",.unit_cell)

   end

   put_NKA_cartesian
   ! Put out the NKA information in cartesian coordinates
      ENSURE(.data.created,"no diffraction data")
      ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")

      ! Cell line
      stdout.flush
      stdout.put("TCEL",width=4)
      stdout.put(.data.NKA_T_sequence_no,width=3)
      stdout.put(.data.temperature,width=6,precision=1)
      stdout.put(.unit_cell.length(1).to_units("angstrom"))
      stdout.put(.unit_cell.length(2).to_units("angstrom"))
      stdout.put(.unit_cell.length(3).to_units("angstrom"))
      stdout.put(.unit_cell.angle(1).to_units("degree"))
      stdout.put(.unit_cell.angle(2).to_units("degree"))
      stdout.put(.unit_cell.angle(3).to_units("degree"))
      stdout.flush

      ! Coordinate information
      .asymmetric_unit_atom.put_NKA_with_errors(.data.NKA_T_sequence_no)

   end

!   put_NKA_crystal
!   ! Put out the NKA information in cartesian coordinates
!      ENSURE(.data.created,"no diffraction data")
!      ENSURE(.data.covariance_matrix.created,"no covariance_matrix")
!      ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")
!
!      n_atom :: INT
!      esd :: VEC{REAL}*
!
!      ! Cell line
!      stdout.flush
!      stdout.put("TCEL",width=4)
!      stdout.put(.data.NKA_T_sequence_no,width=3)
!      stdout.put(.data.temperature,width=6,precision=1)
!      stdout.put(.unit_cell.length(1).to_units("angstrom"))
!      stdout.put(.unit_cell.length(2).to_units("angstrom"))
!      stdout.put(.unit_cell.length(3).to_units("angstrom"))
!      stdout.put(.unit_cell.angle(1).to_units("degree"))
!      stdout.put(.unit_cell.angle(2).to_units("degree"))
!      stdout.put(.unit_cell.angle(3).to_units("degree"))
!      stdout.flush
!
!      ! Change axis system to crystal
!      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell)
!
!      ! Standard deviations and covariances
!      n_atom = .asymmetric_unit_atom.dim
!      esd.create(9*n_atom)
!      .make_cif_errors(esd)
!      esd = sqrt(esd)
!
!      ! Dump the data
!      .asymmetric_unit_atom.put_NKA_with_errors(esd,.data.NKA_T_sequence_no,fractional_coords=TRUE)
!
!      ! Change axes back to cartesian
!      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell)
!
!      ! Clean up
!      esd.destroy
!
!   end

   put_excel_crystal
   ! Put out the coordinate and ADP information in Excel format
      ENSURE(.data.created,"no diffraction data")
      ENSURE(.data.covariance_matrix.created,"no covariance_matrix")
      ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")

      esd :: VEC{REAL}*
      n_pADPs :: INT

      ! Cell line
      stdout.flush
      stdout.put("TCEL",width=4)
      stdout.put(.data.NKA_T_sequence_no,width=3)
      stdout.put(.data.temperature,width=6,precision=1)
      stdout.put(.unit_cell.length(1).to_units("angstrom"))
      stdout.put(.unit_cell.length(2).to_units("angstrom"))
      stdout.put(.unit_cell.length(3).to_units("angstrom"))
      stdout.put(.unit_cell.angle(1).to_units("degree"))
      stdout.put(.unit_cell.angle(2).to_units("degree"))
      stdout.put(.unit_cell.angle(3).to_units("degree"))
      stdout.flush

      ! Get errors in crystal coordinates
      n_pADPs = .asymmetric_unit_atom.no_of_pADPs
      esd.create(n_pADPs)
      .make_cif_errors(esd)
      esd = sqrt(esd)

      ! Change axis system to crystal
      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell)

      ! Dump the data
      .asymmetric_unit_atom.put_excel_with_errors(esd,.data.temperature)

      ! Change axes back to cartesian
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell)

      ! Clean up
      esd.destroy

   end

   put_uc_connection_table
   ! Put the .unit_cell_connection table

   ENSURE(.unit_cell_connection.created,"no unit_cell_connection")
   ENSURE(.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Unit cell atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)
   
         first = TRUE
         do a = 1,.unit_cell_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle
   
            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE
   
            if (.unit_cell_connection(a).element.dim==0) then
   
               stdout.flush
   
            else
   
               do i = 1,.unit_cell_connection(a).element.dim
   
                  if (i>1) &
                  stdout.tab(int_fields=2)
   
                  b = .unit_cell_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.unit_cell_connection(a)[i][1])
                  stdout.put(.unit_cell_connection(a)[i][2])
                  stdout.put(.unit_cell_connection(a)[i][3])
                  stdout.flush
   
               end
   
            end
         end
      end

      stdout.dash(int_fields=6)

   end

   put_uc_vdw_connection_table
   ! Put the .unit_cell_connection table

   ENSURE(.uc_vdw_connection.created,"no uc_vdw_connection")
   ENSURE(.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Cell VDW atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)
   
         first = TRUE
         do a = 1,.uc_vdw_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle
   
            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE
   
            if (.uc_vdw_connection(a).element.dim==0) then
   
               stdout.flush
   
            else
   
               do i = 1,.uc_vdw_connection(a).element.dim
   
                  if (i>1) &
                  stdout.tab(int_fields=2)
   
                  b = .uc_vdw_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.uc_vdw_connection(a)[i][1])
                  stdout.put(.uc_vdw_connection(a)[i][2])
                  stdout.put(.uc_vdw_connection(a)[i][3])
                  stdout.flush
   
               end
   
            end
         end
      end

      stdout.dash(int_fields=6)

   end

!  ================================
!  Put Fragment related information
!  ================================

   put_fragment_data ::: private
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.

      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Crystal fragment")
      stdout.text("================")
      stdout.flush
      stdout.text(". Ab initio calculations are performed on the fragment")
      stdout.text("  to obtain structure factors, charges, etc.")
      stdout.flush
      stdout.text(". The fragment need not be an asymmetric unit.")
      stdout.flush
      stdout.text(". Repeated atoms are assigned a 'repetition factor' which")
      stdout.text("  is used to scale the structure factor contribution from")
      stdout.text("  that atom. You can manually reset this.")
      stdout.flush
      stdout.text(". Only the unique atoms in the fragment have their ")
      stdout.text("  positions and ADPs refined.")
      stdout.flush
      stdout.text(". The Z factor for the crystal is defined with respect to")
      stdout.text("  the no. of electrons in the fragment")

      stdout.flush
      stdout.flush
      stdout.show("No. of fragment atoms        =",.n_fragment_atoms)
      stdout.show("No. of unique fragment atoms =",.n_unique_frag_atoms)
      stdout.show("Z factor                     =",.Z)

      if (.partition_model/=" " OR .thermal_smearing_model/=" ") then
      stdout.flush
      stdout.show("Fragment partition model     =",.partition_model)
      stdout.show("Thermal smearing model       =",.thermal_smearing_model)
      end

      .put_fragment_geometry
    ! .put_stabilizer_symops 
    ! .put_inv_trans_symop_data

   end

   put_stabilizer_symops ::: private
   ! Put out the stabilizer symop data

   ENSURE(.stabilizer_symop.created,"no stabilizer_symop")

      stdout.flush
      stdout.text("Crystal stabilizer symop information:")
      stdout.flush
      stdout.show("n_stabilizer_symops =",.n_stabilizer_symops)
      stdout.flush
      stdout.put(.stabilizer_symop)

   end

   put_fragment_geometry ::: private
   ! Put out the fragment_geometry information

   ENSURE(.fragment_info_made,"no fragment info")

      ID :: VEC{STR}*
      as4f,sy4f,un4f,rf :: VEC{INT}*
      sh4f :: MAT{REAL}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.flush
      stdout.text("Fragment geometry:")
      stdout.flush

      ! Data
      as4f => .asym_atom_for_frag_atom
      sy4f => .asym_symop_for_frag_atom
      sh4f => .asym_shift_for_frag_atom
      ID   => .fragment_atom.unique_tags
      un4f => .unique_atom_for_frag_atom
      rf.create(.n_fragment_atoms)
      rf = int(.repetition_factor)

      ! Table
      table.create(11)

      table( 1).set_heading("frag");    table(1).set_values(ID)
      table( 1).set_subhead("ID")

      table( 2).set_spacing(2)
      table( 2).set_heading("Rep");     table(2).set_values(rf)
      table( 2).set_subhead("fac")
      table( 2).set_sb3head("tor")

      table( 3).set_spacing(2)
      table( 3).set_heading("Uniq");    table(3).set_values(un4f)
      table( 3).set_subhead("atom")

      table( 5).set_heading("Coord")
      table( 4).set_subhead("- x -");    table(4).set_values(.fragment_geometry(1,:))
      table( 5).set_subhead("- y -");    table(5).set_values(.fragment_geometry(2,:))
      table( 6).set_subhead("- z -");    table(6).set_values(.fragment_geometry(3,:))
      table( 5).set_sb3head("/frac")

      table( 7).set_heading("From");    table(7).set_values(as4f)
      table( 7).set_subhead("asym")
      table( 7).set_sb3head("atom")

      table( 8).set_spacing(2)
      table( 8).set_heading("Using");   table(8).set_values(sy4f)
      table( 8).set_subhead("symop")

      table( 9).set_spacing(2)
      table( 9).set_real_precision(1)
      table( 9).set_heading("     ");   table(9).set_values(sh4f(1,:))
      table( 9).set_subhead("- x -")
      table(10).set_spacing(2)
      table(10).set_real_precision(1)
      table(10).set_heading("Shift");   table(10).set_values(sh4f(2,:))
      table(10).set_subhead("- y -")
      table(11).set_spacing(2)
      table(11).set_real_precision(1)
      table(11).set_heading("     ");   table(11).set_values(sh4f(3,:))
      table(11).set_subhead("- z -")
      table(10).set_sb3head("/frac")

      table.put

      ! Clean
      table.clear_columns
      table.destroy
      rf.destroy
      ID.destroy

   end

   put_fragment_geometry_small ::: private
   ! Put out the fragment_geometry information

      ID :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.flush
      stdout.text("Fragment geometry:")
      stdout.flush

      ! Data
      ID   => .fragment_atom.unique_tags

      ! Table
      table.create(4)

      table( 1).set_heading("frag");    table(1).set_values(ID)
      table( 1).set_subhead("ID")

      table( 2).set_heading("x");       table(2).set_values(.fragment_geometry(1,:))
      table( 3).set_heading("y");       table(3).set_values(.fragment_geometry(2,:))
      table( 4).set_heading("z");       table(4).set_values(.fragment_geometry(3,:))
      table( 3).set_sb3head("/frac")

      table.put

      ! Clean
      table.clear_columns
      table.destroy
      ID.destroy

   end

!  ==================================
!  Put reflection related information
!  ==================================

   put_reflection_data
   ! Put out the reflection data to file "out".  Both Neutron and 
   ! X-ray will be put if present.

      if (.xray_data.created) then
        if (.xray_data.reflections.created) then  
        stdout.flush
        stdout.text("======================")
        stdout.text("X-ray diffraction data")
        stdout.text("======================")
        .xray_data.put_reflection_data(.core_reflection)
        stdout.flush
        end
      end  

      if (.pnd_data.created) then
        if (.pnd_data.reflections.created) then    
        stdout.flush
        stdout.text("==================================")
        stdout.text("Polarised neutron diffraction data")
        stdout.text("==================================")
        .pnd_data.put_reflection_data
        stdout.flush
        end
      end  

   end

   put_correction_data
   ! Output the correction data 
   ENSURE(.data_exists, "no diffraction data")
      .data.put_correction_data

      if (.asymmetric_unit_atom.has_any_ADP3s_and_errors) then
      stdout.flush
      stdout.show("Using ADP3's?                  =",TRUE)
      if (.asymmetric_unit_atom.has_any_ADP4s_and_errors) then
      stdout.show("Using ADP4's?                  =",TRUE)
      end
      end

   end

   put_F_statistics
   ! Output the structure factor statistics 
   ENSURE(.data_exists, "no diffraction data")

      .data.put_F_statistics

      if (.core_reflection.destroyed) return

      ! Print out the valence R factor
      stdout.show("Rval (F)                    =", .F_val_r_factor)

   end

   put_PND_sf(name)
   ! outputs the polarised neutron structure factors
      name :: STR
   ENSURE(.data_exists, "no diffraction data")
      .data.put_PND_sf(name)
   end

!  ================
!  Crystal Explorer
!  ================

   put_CX(label,formula,spacegroup)
   ! Output some information for the Crystal Explorer program.
       label,formula,spacegroup :: STR
       .unit_cell.put_CX(label,formula,spacegroup)
   end

!  ==================
!  Put plots and maps
!  ==================

   put_fitting_plots
   ! Output all the fitting plot information to "stdout.fit_analysis"
   DIE_IF(.data.destroyed,"no reflection data")

      save,file :: TEXTFILE*

      ! Fit analysis
      stdout.flush
      stdout.text("==================================")
      stdout.text("Analysis of the Hirshfeld atom fit")
      stdout.text("==================================")
      stdout.flush
      stdout.text("An analysis of the fit is deposited in 'stdout.fit_analysis'.")
      stdout.flush
      stdout.text("This large file includes:")
      stdout.text(". a binned chi2 vs. angle table")
      stdout.text(". a normal QQ plot i.e. Hamilton plot")
      stdout.text(". a normal QQ plot with each datum labelled by (hkl)")
      stdout.text(". a scatter plot of (Fexp-Fcalc)/sigma vs. sin (theta/lambda)")
      stdout.text(". a scatter plot of (Fexp-Fcalc)/sigma vs. intensity")
      stdout.flush
      stdout.text("If you used an extinction correction, you also get:")
      stdout.text(". a scatter plot of (Fcalc-Fcalc(no ext))/sigma vs. sin (theta/lambda)")
      stdout.text(". a scatter plot of (Fcalc-Fcalc(no ext))/sigma vs. Fcalc")
      stdout.flush
      stdout.text("All of the above plots are available for the reserved (free) data")
      stdout.text("if you made use of that option. Phew.")
      stdout.flush
      stdout.text("Use Excel or gnuplot to view these data. Do it.")

      ! Create the new file
      file.create("stdout.fit_analysis")
      file.open_for("write")

      ! Redirect output
      save   => TEXTFILE::stdout
      stdout => file

      ! Fit analysis (again)
      stdout.flush
      stdout.text("==================================")
      stdout.text("Analysis of the Hirshfeld atom fit")
      stdout.text("==================================")
      stdout.flush
      stdout.text("An analysis of the fit is deposited below.")
      stdout.flush
      stdout.text("This large file includes:")
      stdout.text(". a binned chi2 vs. angle table")
      stdout.text(". a normal QQ plot i.e. Hamilton plot")
      stdout.text(". a normal QQ plot with each datum labelled by (hkl)")
      stdout.text(". a scatter plot of (Fexp-Fcalc)/sigma vs. sin (theta/lambda)")
      stdout.text(". a scatter plot of (Fexp-Fcalc)/sigma vs. intensity")
      stdout.flush
      stdout.text("If you used an extinction correction, you also get:")
      stdout.text(". a scatter plot of (Fcalc-Fcalc(no ext))/sigma vs. sin (theta/lambda)")
      stdout.text(". a scatter plot of (Fcalc-Fcalc(no ext))/sigma vs. Fcalc")
      stdout.flush
      stdout.text("All of the above plots are available for the reserved (free) data")
      stdout.text("if you made use of that option. Phew.")
      stdout.flush
      stdout.text("Use Excel or gnuplot to view these data. Do it!")

      ! Data analysis
      if (.data.created) then

         stdout.flush
         stdout.text("====================================")
         stdout.text("Plots based on data used for fitting")
         stdout.text("====================================")

         .put_chi2_vs_angle_plot(.data)
         .put_qq_plot(.data)
         .put_labelled_qq_plot(.data)
         .put_fcalc_plots(.data)

      end

      ! Reserved data analysis
      if (.xray_r_free_data.created) then

         stdout.flush
         stdout.text("===================================")
         stdout.text("Plots based on free (reserved) data")
         stdout.text("===================================")

         .put_chi2_vs_angle_plot(.data)
         .put_qq_plot(.data)
         .put_labelled_qq_plot(.data)
         .put_fcalc_plots(.data)

      end

      ! Replace stdout
      stdout => save

      ! Clean
      file.close
      file.destroy

   end

   put_chi2_vs_angle_plot(data)
   ! Output a table with the chi^2 for the structure factor data set
   ! broken into sections.  Reads from stdin the number of divisions
   ! in the plot.
      data :: DIFFRACTION_DATA*
   ENSURE(data.created, "no diffraction data")
      if (FALSE) self = self
      data.put_chi2_vs_angle_plot
   end

   put_qq_plot(data)
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
      data :: DIFFRACTION_DATA*
   ENSURE(data.created, "no diffraction data")
      if (FALSE) self = self
      data.put_qq_plot
   end

   put_labelled_qq_plot(data)
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
      data :: DIFFRACTION_DATA*
   ENSURE(data.created, "no diffraction data")
      if (FALSE) self = self
      data.put_labelled_qq_plot
   end

   put_fcalc_plots(data)
   ! Output some different plots about the calculated structure factors.
      data :: DIFFRACTION_DATA*
   ENSURE(data.created, "no diffraction data")
      if (FALSE) self = self
      data.put_fcalc_plots
   end

   make_residual_error_map(map,pts)
   ! Make the crystal residual error "map" for the supplied points "pts" from
   ! the crystal structure factors
      map :: VEC{REAL}
      pts :: MAT{REAL}

   ENSURE(.data.created, "no diffraction data")
   ENSURE(.data.reflections.created, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")
   ENSURE(pts.dim2==3,  "incorrect dimension for points array")

      k :: MAT{REAL}*
      dF :: VEC{CPX}*
      k_dot_rn :: VEC{REAL}*
      fac :: REAL
      ci  :: CPX
      n_refl,n :: INT

      ! Constants
      n_refl = .data.reflections.n_refl
      ci = IMAGIFY(ONE)

      ! K points
      k.create(n_refl,3)
      .make_k_pts(k)

      ! Get phased structure factor differences 
      ! (without extinction/scale factor correction)
      dF.create(n_refl)
      dF = (.data.reflections.F_exp - .data.reflections.F_pred) &
          * .data.reflections.F_calc/abs(.data.reflections.F_calc)
      dF = dF/.extinction_correction

      ! Calculate residual map
      k_dot_rn.create(n_refl)
      do n = 1,pts.dim1
         k_dot_rn = matmul(k,pts(n,:))
         map(n) = REALIFY(sum(dF*exp(ci*k_dot_rn)))
      end
      k_dot_rn.destroy

      ! Scale
      fac = TWO/.unit_cell.volume
      map = fac*map

      ! Clean
      dF.destroy
      k.destroy

   end

end
