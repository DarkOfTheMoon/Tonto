!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! (c) dylan jayatilaka, daniel grimwood, university of western australia (1999)
!-------------------------------------------------------------------------------
module CRYSTAL

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use BUFFER
   use BINVEC
   use IVEC
   use IMAT
   use VEC
   use MAT
   use CVEC
   use CMAT
   use CMAT3
   use CMAT4
   use CMAT5
   use TEXTFILE
   use ARCHIVE
   use REFLECTION
   use REFLECTIONVEC
   use ATOM
   use ATOMVEC
   use SPACEGROUP

   implicit none

#  include "macros"
#  include "crystal.int"

!   type crystal_type
!
!   STR :: kind
!   ! Kind of diffraction experiment used.
!
!   SPACEGROUP :: spacegroup
!   ! The crystal spacegroup
!
!   VEC(3) :: unit_cell_angle
!   ! cell angles  (in radians)
!
!   VEC(3) :: unit_cell_length
!   ! cell lengths (in bohr)
!
!   DBL :: unit_cell_volume
!   ! cell volumes (bohr^3)
!
!   MAT(3,3) :: direct_cell_matrix
!   ! direct cell matrix (bohr)
!
!   MAT(3,3) :: direct_U_cell_matrix
!   ! Converts thermal tensors from crystal to cartesian systems.
!
!   MAT(3,3) :: inverse_cell_matrix
!   ! inverse direct cell matrix (bohr^{-1})
!
!   MAT(3,3) :: reciprocal_cell_matrix
!   ! reciprocal cell matrix (bohr^{-1}).
!
!   MAT(3,3) :: reciprocal_U_cell_matrix
!   ! Converts thermal tensors from cartesian to crystal systems.
!
!   INT :: n_fragment_atoms
!   ! No of atoms in the inputted cell fragment
!
!   MAT* :: fragment_geometry
!   ! The geometry for molecular cell fragment under consideration
!
!   INT :: n_unit_cell_atoms
!   ! Total no. of unit cell atoms
!
!   MAT* :: unit_cell_geometry
!   ! The full unit cell geometry
!
!   INT :: n_unique_unit_cell_atoms
!   ! No of unique unit cell atoms
!
!   IVEC* :: unique_atom
!   ! Contains the actual unique (asymmetric) unit cell atoms.
!
!   IVEC* :: unique_atom_for
!   ! If "a" is the index of an atom position in fragment_geometry,
!   ! fragment_geometry(:,a), then unique_atom_for(a) is the index of the unique
!   ! (asymmetric) unit cell atom which generates that position.
!
!   IVEC* :: unique_atom_symop_for
!   ! If "a" is the index of an atom position in fragment_geometry,
!   ! fragment_geometry(:,a), then unique_atom_symop_for(a) is the index of the
!   ! symmetry operation which maps unique_atom_for(a) onto that position.
!
!   IVEC* :: fragment_atom_for
!   ! If "u" is the index of an atom position in unit_cell_geometry,
!   ! unit_cell_geometry(:,u), then fragment_atom_for(a) is the index of the
!   ! fragment_atom which generates that position.
!
!   INT :: n_reduced_symops
!   ! No. of symops needed to make the unit_cell_geometry from fragment_geometry
!
!   IVEC* :: reduced_symop
!   ! Indices of the reduced symops in the spacegroup seitz list
!
!   INT :: n_inverted_symops
!   ! Number of symmetry operations related by inversion
!
!   IVEC* :: inverted_symop
!   ! Indices of the unique symops related by inversion
!
!   IVEC* :: translated_symop
!   ! Indices of the unique symops related by translation
!
!   INT :: n_unique_symops
!   ! Number of unique symmetry operations not related by inversion or
!   ! translation.
!   ! This is used to save work in structure factor calculations.
!
!   IVEC* :: unique_symop
!   ! Indices of the unique symops not related by inversion or translation
!
!   VEC* :: repetition_factor
!   ! The partition factors for cell_geometry
!
!   DBL :: Z
!   ! The crystallographic Z factor for the moleculat cell fragment in the
!   ! unitcell
!
!   REFLECTIONVEC* :: reflections
!   ! The structure factor information
!
!   DBL :: scale_factor
!   ! Scale factor to apply to the predicted structure factors
!
!   DBL :: exp_scale_factor
!   ! Fixed scale factor to apply to the experimental structure factors
!
!   BIN :: optimise_scale
!   ! True if an overall scaler factor is to be optimised, for use in calculating   ! F_pred
!
!   BIN :: synthesize_sigma_I
!   ! True if artificial sigma(I) errors are to be gereated from poisson
!   ! statistics and used in calculating agreement statistics
!
!   BIN :: optimise_extinction
!   ! True if extinction is to be optimised.
!
!   BIN :: correct_dispersion
!   ! True if dispersion is to be corrected
!
!   DBL :: extinction_factor
!   ! Secondary extinction factor
!
!   DBL :: wavelength
!   ! Experiment wavelength
!
!   STR :: thermal_smearing_model
!   ! Thermal smearing model for ft integrals
!
!   STR :: partition_model
!   ! Model for partitioning fragments of the molecule
!
!   INT :: n_param
!   ! No of fitting parameters used
!
!   DBL :: chi2
!   ! Chi^2 agreement statistic for F_pred with F_exp
!
!   DBL :: goodness_of_fit
!   ! Goodness of fit parameter F_pred with F_exp
!
!   DBL :: r_factor
!   ! R factor agreement statistic F_pred with F_exp
!
!   DBL :: weighted_r_factor
!   ! Weighted R factor agreement statistic F_pred with F_exp
!
!   DBL :: I_chi2
!   ! Chi^2 agreement statistic for I_pred with I_exp
!
!   DBL :: I_goodness_of_fit
!   ! Goodness of fit parameter for I_pred with I_exp
!
!   DBL :: I_r_factor
!   ! R factor agreement statistic for I_pred with I_exp
!
!   DBL :: I_weighted_r_factor
!   ! Weighted R factor agreement statistic for I_pred with I_exp
!
!   end

   CRYSTAL* :: saved_self

contains

!  **************************
!  Create and destroy methods
!  **************************

   create
   ! Create an crystal object
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(CRYSTAL_SIZE)
      .nullify_ptr_part
      .set_default
   end

   destroy
   ! Destroy an crystal object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(CRYSTAL_SIZE)
      deallocate(self)
   end

  nullify_ptr_part
  ! Nullify the pointer parts of the crystal object
    .spacegroup.nullify_ptr_part
    nullify(.reflections)
    nullify(.fragment_geometry)
    nullify(.unit_cell_geometry)
    nullify(.unique_atom)
    nullify(.unique_atom_for)
    nullify(.unique_atom_symop_for)
    nullify(.fragment_atom_for)
    nullify(.reduced_symop)
    nullify(.inverted_symop)
    nullify(.translated_symop)
    nullify(.unique_symop)
    nullify(.repetition_factor)
  end

  destroy_ptr_part
  ! Erase all pointer information
   .destroy_reflection_data
   .destroy_fragment_data
  end

  destroy_reflection_data
  ! Erase all reflection data
    if (.reflection_data_exists) then
      .scale_factor = ONE
      .exp_scale_factor = ONE
      .extinction_factor = ZERO
      .reflections.destroy
    end
  end

  destroy_fragment_data
  ! Destroy the geometry and symmetry data for the fragment and unitcell.
    .fragment_geometry.destroy
    .unit_cell_geometry.destroy
    .unique_atom.destroy
    .unique_atom_for.destroy
    .unique_atom_symop_for.destroy
    .fragment_atom_for.destroy
    .reduced_symop.destroy
    .inverted_symop.destroy
    .translated_symop.destroy
    .unique_symop.destroy
    .repetition_factor.destroy
  end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_default [leaky]
   ! Set up a default crystal object
      .spacegroup.set_default
      .unit_cell_angle = (/90.0d0,90.0d0,90.0d0/)
      .unit_cell_angle.convert_from("degree")
      .unit_cell_length = (/10.0d0,10.0d0,10.0d0/)
      .make_cell_matrices
      .destroy_reflection_data
      .synthesize_sigma_I = FALSE
      .optimise_scale = TRUE
      .optimise_extinction = TRUE
      .correct_dispersion = TRUE
      .scale_factor = ONE
      .exp_scale_factor = ONE
      .extinction_factor = ZERO
      .wavelength = 0.71069d0 * BOHR_PER_ANGSTROM
      .kind = "x-ray"
      .thermal_smearing_model = ""
      .partition_model = ""
   end

!  ********************
!  Unit cell operations
!  ********************

   make_cell_matrices
   ! Calculate the various unit cell axis matrices.
      .make_cell_volume
      .make_direct_cell_matrix
      .make_reciprocal_cell_matrix
      .make_direct_U_cell_matrix
      .make_reciprocal_U_cell_matrix
   end

   make_cell_volume
   ! Calculate the cell volume
      DBL :: a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      .unit_cell_volume = a*b*c*sqrt(ONE-ca**2-cb**2-cg**2+TWO*ca*cb*cg)
   end

   make_direct_cell_matrix
   ! Calculate the direct cell matrices, in units of BOHRS.
      DBL :: v,a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Direct cell matrix
      .direct_cell_matrix(1,1) = a
      .direct_cell_matrix(1,2) = b*cg
      .direct_cell_matrix(1,3) = c*cb
      .direct_cell_matrix(2,1) = ZERO
      .direct_cell_matrix(2,2) = v/(a*c*sb)
      .direct_cell_matrix(2,3) = ZERO
      .direct_cell_matrix(3,1) = ZERO
      .direct_cell_matrix(3,2) = b*(ca-cg*cb)/sb
      .direct_cell_matrix(3,3) = c*sb
   end

   make_reciprocal_cell_matrix
   ! Calculate the reciprocal cell matrices in units of 1/BOHRS.
      DBL :: v,a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Reciprocal cell matrix
      .reciprocal_cell_matrix(1,1) = ONE/a
      .reciprocal_cell_matrix(1,2) = ZERO
      .reciprocal_cell_matrix(1,3) = ZERO
      .reciprocal_cell_matrix(2,1) = b*c*(ca*cb-cg)/sb/v
      .reciprocal_cell_matrix(2,2) = a*c*sb/v
      .reciprocal_cell_matrix(2,3) = a*b*(cb*cg-ca)/sb/v
      .reciprocal_cell_matrix(3,1) = -cb/a/sb
      .reciprocal_cell_matrix(3,2) = ZERO
      .reciprocal_cell_matrix(3,3) = ONE/c/sb
      .inverse_cell_matrix = transpose(.reciprocal_cell_matrix)
   end

   make_direct_U_cell_matrix
   ! Return the transformation matrix which changes the thermal tensor
   ! from the crystal axis system into the cartesian axis system.
   ! See comments for reciprocal_U_tensor_matrix below.
      DBL :: len
      INT :: i
      do i = 1,3
         len = .reciprocal_cell_matrix(:,i).norm
         .direct_U_cell_matrix(i,:) = len*.direct_cell_matrix(:,i)
      end
   end

   make_reciprocal_U_cell_matrix
   ! Return the transformation matrix which changes the thermal tensor
   ! from the cartesian axis system into the crystal axis system.
   ! The thermal tensor in the crystal axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where h are the Miller indices and a^* are the reciprocal lattice
   ! constants (in bohr^{-2}). This is as used by systems like Xtal.
   ! The thermal tensor in the cartesian axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -0.5 U_{ij} k_i k_j )
   ! where k = 2\pi B h, and B is the reciprocal_cell matrix.
      DBL :: len
      INT :: i
      do i = 1,3
         len = ONE/.reciprocal_cell_matrix(:,i).norm
         .reciprocal_U_cell_matrix(:,i) = .reciprocal_cell_matrix(:,i)*len
      end
   end

   change_geometry_from_crystal(g)
   ! Change the geometry array "g" from crystal fractional coordinates into
   ! standard cartesian coordiantes
      MAT :: g
      INT :: n,n_atom
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.direct_cell_matrix)
      end
   end

   change_geometry_to_crystal(g)
   ! Change the geometry array "g" from standard cartesian coordinates into
   ! crystal fractional coordinates
      MAT :: g
      INT :: n,n_atom
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.inverse_cell_matrix)
      end
   end

!  ************
!  Read methods
!  ************

   read(input) [leaky]
   ! Read an CRYSTAL object from file "input"
      TEXTFILE, target, optional :: input
      TEXTFILE* :: in
      STR :: word
      if (present(input)) then; in => input
      else;                     in => stdin
      end
      .set_default
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("end");                         exit read_loop
            case("kind");                       .read_kind
            case("spacegroup_symbol");          .read_spacegroup_IT_symbol
            case("spacegroup_it_symbol");       .read_spacegroup_IT_symbol
            case("spacegroup_hall_symbol");     .read_spacegroup_Hall_symbol
            case("unit_cell_angles");           .read_unit_cell_angles
            case("cell_angles");                .read_unit_cell_angles
            case("unit_cell_lengths");          .read_unit_cell_lengths
            case("unit_cell_dimensions");       .read_unit_cell_lengths
            case("cell_lengths");               .read_unit_cell_lengths
            case("reflection_data");            .read_reflection_data
            case("apply_scale_factor");         .read_scale_factor
            case("make_f_predicted");           .make_F_predicted
            case("synthesize_sigma_i");         .read_synthesize_sigma_I
            case("optimise_scale");             .read_optimise_scale
            case("optimize_scale");             .read_optimise_scale
            case("optimise_scale_factor");      .read_optimise_scale
            case("optimize_scale_factor");      .read_optimise_scale
            case("optimise_extinction");        .read_optimise_extinction
            case("optimize_extinction");        .read_optimise_extinction
            case("optimise_extinction_factor"); .read_optimise_extinction
            case("optimize_extinction_factor"); .read_optimise_extinction
            case("correct_dispersion");         .read_correct_dispersion
            case("thermal_smearing_model");     .read_thermal_smearing_model
            case("partition_model");            .read_partition_model
            case("erase_spacegroup");           .spacegroup.destroy_ptr_part
            case("destroy_spacegroup");         .spacegroup.destroy_ptr_part
            case("erase_reflection_data");      .destroy_reflection_data
            case("destroy_reflection_data");    .destroy_reflection_data
            case default;    DIE("unknown option, "// trim(word))
         end
      end do read_loop
      .update
   end

  update [leaky]
  ! Update the crystal information
    .spacegroup.analyse
    .make_cell_matrices
    if (.reflections.created) then
      if (.reflections.have_F_exp) then
        .reflections.scale_F_exp(.exp_scale_factor)
      else
        .optimise_scale = FALSE
        .optimise_extinction = FALSE
      end
      if (.reflections.have_F_sigma) then
        .reflections.scale_F_sigma(.exp_scale_factor)
      else
        .optimise_scale = FALSE
        .optimise_extinction = FALSE
      end
      .exp_scale_factor = ONE
    end
  end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.kind)
      .kind.to_lower_case
   end

   read_spacegroup_IT_symbol
   ! Read the spacegroup international table symbol
      .spacegroup.read_IT_symbol(stdin)
   end

   read_spacegroup_Hall_symbol
   ! Read the spacegroup Hall symbol
      .spacegroup.read_Hall_symbol(stdin)
   end

   read_unit_cell_angles
   ! Read the unit cell angles
      stdin.read(.unit_cell_angle)
   end

   read_unit_cell_lengths
   ! Read the unit cell axis lengths
      stdin.read(.unit_cell_length)
   end

   read_reflection_data [leaky]
   ! Read in data in the standard order from "stdin".
      .reflections.read
   end

   read_scale_factor
   ! Read the structure factor multiplier
      stdin.read(.exp_scale_factor)
   end

   read_optimise_scale
   ! Read the switch whether to use and overall scale factor to minimise
   ! the chi2 statistic when calculating the structure factors.
   ! NOTE: this is not the same at the overall .scale_factor which is applied
   ! to the experimental structure factors.
      stdin.read(.optimise_scale)
   end

   read_synthesize_sigma_I
   ! Read the switch whether to artificially create sigma(I) errors when
   ! evaluating the chi2 statistics based on intensities. Refer to routine
   ! .I_sigma
      stdin.read(.synthesize_sigma_I)
   end

   read_optimise_extinction
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.optimise_extinction)
   end

   read_correct_dispersion
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      BIN :: allowed_model
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      allowed_model = .thermal_smearing_model=="none"    OR &
                      .thermal_smearing_model==""        OR &
                      .thermal_smearing_model=="coppens" OR &
                      .thermal_smearing_model=="stewart" OR &
                      .thermal_smearing_model=="tanaka"
      ENSURE(allowed_model,"unknown thermal smearing model")
   end

   read_partition_model
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
   end

  lp_factor result(res)
  ! Return the array of the Lorentz Polarization factors for all the
  ! reflections
    VEC(size(.reflections)) :: res
    INT :: n
    DBL :: c,s,two_theta
    ENSURE(.reflections.created,"no reflection data")
    do n=1, .reflections.n_refl
      two_theta = TWO*asin( .stl(n) * .wavelength )
      c = cos(two_theta)
      s = sin(two_theta)
      if (s.is_zero(TOL(8))) then
        res(n) = ZERO
        WARN("lp_factor for (000) reflection set to zero")
      else
        res(n) = (1+c*c)/(TWO*s)
      end
    end
  end

  I_pred result(res)
  ! Return the array of predicted Intensities. Only the Lorentz Polarization
  ! factor and the angular velocity factor for a single crystal are used.
  ! Fundamental constants appearing in front of this are not calculated
  ! NOTE: unlike I_exp, these may include extinction and dispersion effects.
    VEC(size(.reflections)) :: res
    INT :: n
    DBL :: c,s,two_theta,F2
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(.reflections.have_F_exp, "no calculated structure factors")
    do n=1, .reflections.n_refl
      two_theta = TWO*asin( .stl(n) * .wavelength )
      c = cos(two_theta)
      s = sin(two_theta)
      F2 = .reflections(n).F_pred
      F2 = F2*F2
      if (s.is_zero(TOL(8))) then
        res(n) = F2
      else
        res(n) = (1+c*c)/(TWO*s)*F2
      end
    end
  end

  I_exp result(res)
  ! Return the array of experimental Intensities. Only the Lorentz Polarization
  ! factor and the angular velocity factor for a single crystal are used.
  ! Fundamental constants appearing in front of this are not calculated
  ! NOTE: extinction factors, dispersion, multiple scattering corrections
  ! are not included. These are the experimental intensities with these effects
  ! removed.
    VEC(size(.reflections)) :: res
    INT :: n
    DBL :: c,s,two_theta,F2
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(.reflections.have_F_exp, "no calculated structure factors")
    do n=1, .reflections.n_refl
      two_theta = TWO*asin( .stl(n) * .wavelength )
      c = cos(two_theta)
      s = sin(two_theta)
      F2 = abs(.reflections(n).F_exp)
      F2 = F2*F2
      if (s.is_zero(TOL(8))) then
         res(n) = F2
      else
         res(n) = (1+c*c)/(TWO*s)*F2
      end
    end
  end

  I_sigma result(res)
  ! Return the array of experimental sigma's in the Intensities.
    VEC(size(.reflections)) :: res
    MAT(3,3) :: rcm
    INT :: n
    DBL :: c,s,two_theta,F2
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(.reflections.have_F_calc OR .reflections.have_F_exp, "no calculated structure factors")
    if (NOT .reflections.have_F_exp AND NOT .synthesize_sigma_I) then
      WARN("The synthesize_sigma_I flag was not set; it is now set")
      .synthesize_sigma_I = TRUE
    end
    if (.synthesize_sigma_I) then
      res = .reflections.I_pred
      res = sqrt(res/.equivalence_factors)
    else
      rcm = .reciprocal_cell_matrix
      do n=1, .reflections.n_refl
        two_theta = TWO*asin( .stl(n) * .wavelength )
        c = cos(two_theta)
        s = sin(two_theta)
        F2 = abs(.reflections(n).F_exp)
        if (s.is_zero(TOL(8))) then
          res(n) = F2
        else
          res(n) = TWO*(1+c*c)/(TWO*s)*F2
        end
      end
    end
  end

   equivalence_factors result (res)
   ! Return the equivalence factors, the number of distinct reflections
   ! which are symmetry equivalent to a particular (hkl) triple, for all
   ! the reflections.
      IVEC(size(.reflections)) :: res
      IVEC(3) :: hkl,new
      INT :: n,s,u,n_refl
      ENSURE(.reflections.created,"no reflection data")
      n_refl = .reflections.n_refl
      do n = 1,n_refl
         hkl = .reflections.indices(n)
         u = 1
         do s = 2,.spacegroup.n_seitz
            new = matmul(.spacegroup.seitz(1:3,1:3,s),hkl)
            if (hkl(1)/=new(1) OR hkl(2)/=new(2) OR hkl(3)/=new(3)) u = u + 1
         end
         res(n) = u
      end
   end

  stl(n) result (res)
  ! Return the value of sin(theta) / lambda for reflection n
    IN :: self
    INT, IN :: n
    IVEC(3) :: hkl
    DBL :: res,kx,ky,kz
    hkl = .reflections.indices(n)
    kx = dot_product(.reciprocal_cell_matrix(1,:),hkl(:))
    ky = dot_product(.reciprocal_cell_matrix(2,:),hkl(:))
    kz = dot_product(.reciprocal_cell_matrix(3,:),hkl(:))
    res = HALF*sqrt(kx*kx+ky*ky+kz*kz)
  end

  make_F_predicted [leaky]
  ! Make the predicted magnitude of the structure factors, including possibly
  ! an overall scale factor and extinction correction.
    VEC* :: F_pred
    INOUT :: self
    ENSURE(.reflections.created,"no reflection data")
    .n_param = 0
    if (.optimise_extinction OR .optimise_scale) .get_optimum_parameters
    F_pred.create(.reflections.n_refl)
    if (.kind=="pnd") then
      F_pred = .reflections.F_calc * .extinction_correction
    else
      F_pred = abs(.reflections.F_calc) * .extinction_correction
    end
    .reflections.set_F_pred(F_pred)
    F_pred.destroy
    if (.reflections.have_F_exp AND .reflections.have_F_sigma) &
                      .make_agreement_statistics
  end

  get_optimum_parameters
  ! Get the scale factors, extinction parameters, etc, which minimise the chi2.
  ! (To get the corrections cooresponding to these parameters see routine
  ! .extinction_correction)
    if (.optimise_extinction) then
      .optimise_extinction_factor
    else if (.optimise_scale) then
      .optimise_scale_factor
    end
  end

  extinction_correction result(res)
  ! Return the extinction correction  factors "res" to the calculated
  ! individual structure factors.
    VEC(size(.reflections))  :: res
    res = .extinction_correction(.scale_factor,.extinction_factor)
  end

  extinction_correction(scale_factor,extinction_factor) result(res)
  ! Return the extinction correction  factors "res" to the calculated
  ! individual structure factors. NOTE: this routine also does scaling
  ! corrections without extinction.
    DBL :: scale_factor,extinction_factor
    CDBL :: F_calc
    VEC(size(.reflections))  :: res
    VEC* :: angle_part
    INT :: n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(.reflections.have_F_calc, "no calculated structure factors")
    if (extinction_factor.is_zero(TOL(9))) then
       res(:) = scale_factor
    else
      angle_part.create(n_refl)
      angle_part = .extinction_angle_part
      do n=1, n_refl
        F_calc = .reflections(n).F_calc
        res(n) = scale_factor / sqrt(sqrt(ONE + &
            extinction_factor*F_calc*conjg(F_calc)*angle_part(n)))
      end
      angle_part.destroy
    end
  end

  extinction_angle_part result(res)
  ! Return the angular part of the extinction correction.
    VEC(size(.reflections)) :: res
    INT :: n
    DBL :: twotheta,c,s
    do n=1, .reflections.n_refl
      twotheta=TWO*asin( .stl(n) * .wavelength )
      c = cos(twotheta)
      s = sin(twotheta)
      res(n) = (1+c*c)/(1+c*s)
    end
  end

  optimise_scale_factor
  ! Determine the structure factor scale factor to scale the calculated
  ! structure factors .F_calc by in order to minimise the chi2. (But it does
  ! not do any scaling; see .extinction_correction routine for that)
    DBL :: top,bot,F_pred
    INT :: n,n_refl
    REFLECTION* :: ref
    n_refl = .reflections.n_refl
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(.reflections.have_F_calc, "no calculated structure factors")
    ENSURE(.reflections.have_F_exp, "no experimental structure factors")
    ENSURE(.reflections.have_F_sigma, "no structure factor errors")
    top = ZERO
    bot = ZERO
    do n=1,n_refl
      if (.kind=="pnd") then; F_pred = ref.F_calc
      else;                   F_pred = abs(ref.F_calc)
      end
      top = top + F_pred * ref.F_exp  / (ref.F_sigma * ref.F_sigma)
      bot = bot + F_pred * F_pred / (ref.F_sigma * ref.F_sigma)
    end
    .scale_factor = top/bot
    .n_param = 1
  end

   optimise_extinction_factor
   ! Optimize the .scale_factor and .extinction_factor parameter of Larson's
   ! method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! Reference: Larson, A. C., in <I>Crystallographic Computing</I>
   !            Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      target :: self
      VEC(2) :: p
      DBL :: chi2_min
      .optimise_scale_factor
      p(1) = .scale_factor
      p(2) = ZERO          ! This is the .extinction_factor
      saved_self => self
      call minimise_BFGS_(chi2,d_chi2,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))
      nullify(saved_self)
      .scale_factor = p(1)
      .extinction_factor = p(2)
      .n_param = 2
   end

  chi2(p) result (res) [selfless]
  ! Make the predicted magnitude of the structure factors, including possibly
  ! an overall scale factor and extinction correction. Update agreement
  ! statistcics as well, but do not update .F_pred. This routine is for use
  ! in the BFGS minimiser.
    VEC :: p
    DBL :: res,tmp,tmp1
    VEC* :: ext
    REFLECTION* :: ref
    INT :: n,n_refl
    CRYSTAL* :: self; self => saved_self
    n_refl = .reflections.n_refl
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(.reflections.have_F_calc, "no calculated structure factors")
    ENSURE(.reflections.have_F_exp, "no experimental structure factors")
    ENSURE(.reflections.have_F_sigma, "no structure factor errors")
    ENSURE(size(p)==2, "wrong size, p")
    ext.create(n_refl)
    ext = .extinction_correction(p(1),p(2))
    tmp = ZERO
    do n=1,n_refl
      ref => .reflections(n)
      tmp1 = (abs(ref.F_calc) * ext(n) - ref.F_exp) / ref.F_sigma
      tmp = tmp + tmp1 * tmp1
    end
      res = tmp / max(n_refl-.n_param,1)
    ext.destroy
  end

   d_chi2(p) result (res) [selfless]
   ! Return the derivative of the chi2 with respect to the .scale_factor in
   ! p(1), and with respect to .extinction_factor in p(2). This routine is for
   ! use in the BFGS minimiser.
      VEC :: p
      VEC(size(p)) :: res
      CRYSTAL* :: self; self => saved_self
      ENSURE(size(p)==2, "wrong size, p")
      res(1) = .d_chi2_d_scale(p)
      res(2) = .d_chi2_d_ext(p)
   end

  d_chi2_d_scale(p) result (res)
  ! Derivative of the chi^2 with respect to the scale factor
    VEC :: p
    DBL :: res,tmp,F_pred
    VEC* :: ext
    REFLECTION* :: ref
    INT :: n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(.reflections.have_F_calc, "no calculated structure factors")
    ENSURE(.reflections.have_F_exp, "no experimental structure factors")
    ENSURE(.reflections.have_F_sigma, "no structure factor errors")
    ENSURE(size(p)==2, "wrong size, p")
    ext.create(n_refl)
    ext = .extinction_correction(p(1),p(2))
    tmp = ZERO
    do n=1,n_refl
      ref => .reflections(n)
      F_pred = abs(ref.F_calc) * ext(n)
      tmp = tmp + F_pred*F_pred - ref.F_exp*F_pred / (ref.F_sigma*ref.F_sigma)
    end
    res = TWO*tmp/(p(1)*max(n_refl-.n_param,1))
    ext.destroy
  end

  d_chi2_d_ext(p) result (res)
  ! Derivative of the chi^2 with respect to the extinction parameter.
    VEC, IN :: p
    DBL :: res,tmp,extn,p1
    VEC* :: angle_bit,ext
    CVEC* :: Fc_conjgFcalc
    REFLECTION* :: ref
    INT :: n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(.reflections.have_F_calc, "no calculated structure factors")
    ENSURE(.reflections.have_F_exp, "no experimental structure factors")
    ENSURE(.reflections.have_F_sigma, "no structure factor errors")
    ENSURE(size(p)==2, "wrong size, p")
    angle_bit.create(n_refl)
    ext.create(n_refl)
    angle_bit = .extinction_angle_part
    p1 = p(1)
    ext = .extinction_correction(ONE,p(2))
    tmp = ZERO
    do n = 1,n_refl
      ref => .reflections(n)
      extn = ext(n)
      tmp = tmp + (p1 * abs(ref.F_calc) * extn - ref.F_exp) * &
          extn*extn*extn*extn*extn* ref.F_calc*ref.F_calc*ref.F_calc * &
          angle_bit(n) / (ref.F_sigma * ref.F_sigma)
    end
    res = -p1*tmp/(TWO * max(n_refl-.n_param,1))
    ext.destroy
    angle_bit.destroy
  end

  d_chi2_dU(dF) result (res)
  ! Evaluate the derivative of the chi^2 with respect to parameters U
  ! (e.g. thermal parameters) given the derivatives "dF" of where
  ! .F_calc with respect to these parameters U. NOTE: this routine
  ! assumes that the .scale_factor and .extinction_factor are fixed.
    CMAT :: dF
    VEC(size(dF,2)) :: res
    CVEC* :: Fc_conjgFcalc
    REFLECTION* :: ref
    VEC* :: ext,angle_bit
    DBL :: fac,Fc,Fc1,extn
    INT :: u,n_refl,n
    n_refl = .reflections.n_refl
    ENSURE(.reflections.created,"no reflection data")
    ENSURE(size(dF,1)==n_refl, "wrong size, dF")
    ENSURE(.reflections.have_F_calc, "no calculated structure factors")
    ENSURE(.reflections.have_F_exp, "no experimental structure factors")
    ENSURE(.reflections.have_F_sigma, "no structure factor errors")
    angle_bit.create(n_refl)
    angle_bit = .extinction_angle_part
    ext.create(n_refl)
    ext = .extinction_correction(ONE,.extinction_factor)
    Fc_conjgFcalc.create(n_refl)
    do n = 1,n_refl
      ref => .reflections(n)
      extn = ext(n)
      Fc1 = abs(ref.F_calc)
      Fc = ( (.scale_factor*extn*Fc1 - ref.F_exp) / &
         (ref.F_sigma * ref.F_sigma) ) * &
         (extn / Fc1 - HALF * extn * extn * extn * extn * extn * &
         .extinction_factor * Fc1 * angle_bit(n))
      Fc_conjgFcalc(n) = Fc * conjg(ref.F_calc)
    end
    fac = TWO*.scale_factor/max(n_refl-.n_param,1)
    do u = 1,size(dF,2)
       res(u) = fac * sum( Fc_conjgFcalc(:) * dF(:,u) )
    end
    Fc_conjgFcalc.destroy
    ext.destroy
    angle_bit.destroy
  end

  make_agreement_statistics
  ! Make the agreement statistics
    INT :: n_refl
    ENSURE(.reflections.created,"no reflection data")
    n_refl = .reflections.n_refl

    .I_chi2 = .reflections.I_chi2 * max(n_refl-1,1) / max(n_refl-.n_param,1)
    .I_goodness_of_fit = sqrt(.I_chi2)
    .I_r_factor = .reflections.I_r_factor
    .I_weighted_r_factor = .reflections.I_weighted_r_factor

    .chi2 = .reflections.F_chi2 * max(n_refl-1,1) / max(n_refl-.n_param,1)
    .goodness_of_fit = sqrt(.chi2)
    .r_factor = .reflections.F_r_factor
    .weighted_r_factor = .reflections.F_weighted_r_factor
  end

   make_k_pts(res)
   ! Convert the hkl indices to reciprocal lattice vectors
   ! Dimension of res is [.n_refl,3]
      MAT :: res
      INT :: n
      IVEC(3) :: hkl
      MAT(3,3) :: rcm
      rcm = TWO*PI*.reciprocal_cell_matrix
      do n = 1, .reflections.n_refl
         hkl = .reflections.indices(n)
         res(n,1) = dot_product(rcm(1,:),hkl(:))
         res(n,2) = dot_product(rcm(2,:),hkl(:))
         res(n,3) = dot_product(rcm(3,:),hkl(:))
      end
   end

  n_unique_k_pts result(res) [pure]
    IN :: self
    INT :: res
    res = .n_unique_symops * .reflections.n_refl
  end

   make_unique_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! in the reduced crystal spacegroup
   ! (c) Dylan Jayatilaka, UWA, feb 1996
      MAT :: k
      INT :: p,u,n,n_refl
      MAT(3,3) :: b,rcm
      IVEC(3) :: hkl
      n_refl = .reflections.n_refl
      ENSURE(.unique_symop.created,"no unique_symop array!")
      p = 0
      rcm = TWO*PI*.reciprocal_cell_matrix
      do u = 1,.n_unique_symops
         b = matmul(rcm,.unique_symop_mat(u))
         do n = 1,n_refl
            p = p + 1
            hkl = .reflections.indices(n)
            k(p,1) = dot_product(b(1,:),hkl(:))
            k(p,2) = dot_product(b(2,:),hkl(:))
            k(p,3) = dot_product(b(3,:),hkl(:))
         end
      end
   end

!  *************************************
!  Service methods used by other modules
!  *************************************

  make_phases_for_symop(u,phase,mask)
  ! Return the sum of the "phase" shifts for each (hkl) reflection from each
  ! glide vector for all symops which are equivalent to the "u"-th
  ! unique symmetry operation, .unique_symop(u), as determined by the mask
  ! array.
    INT, IN :: u
    CVEC, OUT :: phase
    IVEC, IN :: mask
    IVEC(3) :: hkl
    DBL :: pi2,tx,ty,tz
    INT :: s,n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(.unique_symop.created,"no unique_symop array!")
    ENSURE(u<=.n_unique_symops,"symop index out of range")
    ENSURE(size(phase)==n_refl,"wrong length for phase array")
    pi2 = TWO*PI
    phase = ZERO
    do s = 1,.spacegroup.n_seitz
      if (mask(s)/=.unique_symop(u)) cycle
      tx = pi2*.spacegroup.seitz(4,1,s)
      ty = pi2*.spacegroup.seitz(4,2,s)
      tz = pi2*.spacegroup.seitz(4,3,s)
      do n=1,n_refl
        hkl = .reflections.indices(n)
        phase(n) = phase(n) + exp(cmplx(ZERO,hkl(1)*tx+hkl(2)*ty+hkl(3)*tz))
      end
    end
  end

  sum_unique_sf(sf,unique_sf)
  ! Form the structure factors "sf" from the sum of the list of
  ! unique structure factors, "unique_sf".
    CVEC :: sf
    CVEC, IN :: unique_sf
    CVEC* :: phase
    INT :: u,uf,ul,n_refl
    n_refl = .reflections.n_refl
    ENSURE( size(sf)==n_refl,"incorrect size for array sf")
    phase.create(n_refl)
    sf = ZERO
    do u = 1,.n_unique_symops
       uf = n_refl*(u-1)+1
       ul = n_refl*u
       .make_phases_for_symop(u,phase,.translated_symop)
       sf(:) = sf(:) + phase(:)*unique_sf(uf:ul)
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
       .make_phases_for_symop(u,phase,.inverted_symop)
       sf(:) = sf(:) + phase(:)*conjg(unique_sf(uf:ul))
    end
    phase.destroy
  end

  sum_unique_sf_ints(sf_ints,unique_sf_ints)
  ! Form the structure factor integrals "sf_ints" from a sum of the list
  ! of unique structure factors integrals  "unique_sf_ints".
    CMAT3 :: sf_ints
    CMAT3, IN :: unique_sf_ints
    CVEC* :: phase
    INT :: u,uf,n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(size(sf_ints,1)==n_refl,"wrong size for sf_ints!")
    phase.create(n_refl)
    sf_ints = ZERO
    do u = 1,.n_unique_symops
      uf = n_refl*(u-1)
      .make_phases_for_symop(u,phase,.translated_symop)
      do n = 1,n_refl
        sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*unique_sf_ints(uf+n,:,:)
      end
      if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
      .make_phases_for_symop(u,phase,.inverted_symop)
      do n = 1,n_refl
        sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*conjg(unique_sf_ints(uf+n,:,:))
      end
    end
    phase.destroy
  end

  sum_unique_sf_deriv_U(sf,unique_sf)
  ! Form the structure factor derivatives "sf" (wrt the thermal paramaters,U)
  !  from a sum of the list of unique structure factor derivatives "unique_sf".
    CMAT :: sf
    CMAT, IN :: unique_sf
    CVEC* :: phase
    INT :: u,uf,n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(size(sf,1)==n_refl, "wrong size, matrix sf")
    ENSURE(size(unique_sf,2)==.n_unique_k_pts, "wrong size, matrix sf")
    phase.create(n_refl)
    sf = ZERO
    do u = 1,.n_unique_symops
      uf = n_refl*(u-1)
      .make_phases_for_symop(u,phase,.translated_symop)
      do n = 1,n_refl
        sf(n,:) = sf(n,:) + phase(n)*unique_sf(:,uf+n)
      end
      if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
      .make_phases_for_symop(u,phase,.inverted_symop)
      do n = 1,n_refl
        sf(n,:) = sf(n,:) + phase(n)*conjg(unique_sf(:,uf+n))
      end
    end
    phase.destroy
  end

  sum_ft_ints(ft_ints,unique_ft_ints)
  ! Form the Fourier transform integrals "ft_ints" from a sum of the list
  ! of unique integrals "unique_ft_ints".  Dimensions of ft_ints are
  ! [.n_refl,n_comp_a,n_comp_b].
    CMAT3 :: ft_ints
    CMAT3, IN :: unique_ft_ints
    CVEC* :: phase
    INT :: u,uf,n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
    phase.create(n_refl)
    ft_ints = ZERO
    do u = 1,.n_unique_symops
      uf = n_refl*(u-1)
      .make_phases_for_symop(u,phase,.translated_symop)
      do n = 1,n_refl
        ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*unique_ft_ints(uf+n,:,:)
      end
      if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
      .make_phases_for_symop(u,phase,.inverted_symop)
      do n = 1,n_refl
        ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*conjg(unique_ft_ints(uf+n,:,:))
      end
    end
    phase.destroy
  end

  make_phased_matrix_for_symop(u,phase,mask)
  ! Return the sum of the "phase" shifts times the seitz matrices for all
  ! symops which are equivalent to the "u"-th unique symmetry operation,
  ! .unique_symop(u), as determined by the "mask" array, when
  ! mask(u)==.unique_symop(u).
    INT, IN :: u
    CMAT3, OUT :: phase
    IVEC, IN :: mask
    IVEC(3) :: hkl
    VEC(3) :: t
    DBL :: pi2
    INT :: s,n,i,j,n_refl
    MAT(4,4) :: seitz
    pi2 = TWO*PI
    phase = ZERO
    n_refl = .reflections.n_refl
    ENSURE(.unique_symop.created,"no unique_symop array!")
    ENSURE(u<=.n_unique_symops,"symop index out of range")
    ENSURE(size(phase,1)==n_refl,"wrong size, dim=1, phase array")
    ENSURE(size(phase,2)==3,"wrong size, dim=2, phase array")
    ENSURE(size(phase,3)==3,"wrong size, dim=3, phase array")
    do s = 1,.spacegroup.n_seitz
      if (mask(s)/=.unique_symop(u)) cycle
      seitz = .spacegroup.seitz(:,:,s)
      t = (/ pi2*seitz(4,1), pi2*seitz(4,2), pi2*seitz(4,3) /)
      if (seitz(3,3)>0) then                  ! M points along +z always
        do n = 1,n_refl
          hkl = .reflections.indices(n)
          phase(n,:,:) = phase(n,:,:) + &
             seitz(:,:)*exp(cmplx(ZERO,dot_product(t,hkl)))
        end
      else                                    ! M points in -z direction
        seitz(3,:3) = -seitz(3,:3)           ! Invert
        do n = 1,n_refl
          hkl = .reflections.indices(n)
          phase(n,:,:) = phase(n,:,:) + &
             seitz(:,:)*exp(cmplx(ZERO,dot_product(t,hkl)))
        end
      end
    end
  end

  sum_PND_spin_ints(ft_ints,unique_ft_ints)
  ! Form the Fourier transform integrals "ft_ints", required for the spin
  ! magnetic structure factors, from a sum of the list of unique structure
  ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
  ! [.n_refl,n_comp_a,n_comp_b,3].
    CMAT4 :: ft_ints
    CMAT3, IN :: unique_ft_ints
    CMAT3* :: phase
    MAT* :: q
    INT :: u,uf,n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
    q.create(n_refl,3)
    phase.create(n_refl,3,3)
    .make_k_pts(q)
    ft_ints = ZERO
    do u = 1,.n_unique_symops
       uf = n_refl*(u-1)
       .make_phased_matrix_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
          ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
             ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
             - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
             unique_ft_ints(uf+n,:,:)
          ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
             ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
             - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
             unique_ft_ints(uf+n,:,:)
          ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
             ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
             - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
             unique_ft_ints(uf+n,:,:)
       end
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
       .make_phased_matrix_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
          ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
             ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
             - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
             conjg(unique_ft_ints(uf+n,:,:))
          ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
             ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
             - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
             conjg(unique_ft_ints(uf+n,:,:))
          ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
             ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
             - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
             conjg(unique_ft_ints(uf+n,:,:))
       end
    end
    phase.destroy
    ! The factor of two for conversion to Bohr magnetons cancels the
    ! factor of half for the S=sigma/2 operator, and g_e x mu_B = 1.
    do n = 1,n_refl
      ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
    end
    q.destroy
  end

  sum_PND_nabla_ints(ft_ints,unique_ft_ints)
  ! Form the fourier transform nabla_a_3 integrals "ft_ints", required for the
  ! PND magnetic structure factors, from a sum of "unique_ft_ints".
  ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
    CMAT3 :: ft_ints
    CMAT4, IN :: unique_ft_ints
    CMAT3* :: phase
    MAT* :: q
    INT :: u,uf,n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
    q.create(n_refl,3)
    phase.create(n_refl,3,3)
    .make_k_pts(q)
    ft_ints = ZERO
    do u = 1,.n_unique_symops
      uf = n_refl*(u-1)
      .make_phased_matrix_for_symop(u,phase,.translated_symop)
      do n = 1,n_refl
        ft_ints(n,:,:) = ft_ints(n,:,:) + &
         (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*unique_ft_ints(uf+n,:,:,1) + &
         (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*unique_ft_ints(uf+n,:,:,2) + &
         (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*unique_ft_ints(uf+n,:,:,3)
      end
      if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
      .make_phased_matrix_for_symop(u,phase,.translated_symop)
      do n = 1,n_refl
        ft_ints(n,:,:) = ft_ints(n,:,:) + &
         (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*conjg(unique_ft_ints(uf+n,:,:,1)) + &
         (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*conjg(unique_ft_ints(uf+n,:,:,2)) + &
         (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*conjg(unique_ft_ints(uf+n,:,:,3))
      end
    end
    phase.destroy
    ! The factor of 2 to convert to Bohr magnetons cancels the factor
    ! of 1/2 for the Bohr magneton.
    do n = 1,n_refl
      ft_ints(n,:,:) = ft_ints(n,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
    end
    q.destroy
  end

  sum_ft_spin_ints(ft_ints,unique_ft_ints)
  ! Form the Fourier transform integrals "ft_ints", required for the spin
  ! magnetic structure factors, from a sum of the list of unique structure
  ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
  ! [.n_refl,n_comp_a,n_comp_b,3,3].
    CMAT5 :: ft_ints
    CMAT3, IN :: unique_ft_ints
    CVEC* :: phase
    MAT* :: q
    CMAT* :: ints
    INT :: u,uf,n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
    phase.create(n_refl)
    q.create(n_refl,3)
    ints.create(size(ft_ints,2),size(ft_ints,3))
    .make_k_pts(q)
    ft_ints = ZERO
    do u = 1,.n_unique_symops
      uf = n_refl*(u-1)
      .make_phases_for_symop(u,phase,.translated_symop)
      do n = 1,n_refl
        ints = phase(n)*unique_ft_ints(uf+n,:,:)
        ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
        ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
        ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
        ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
        ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
        ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
      end
      if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
      .make_phases_for_symop(u,phase,.inverted_symop)
      do n = 1,n_refl
        ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
        ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
        ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
        ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
        ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
        ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
        ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
      end
    end
    ints.destroy
    ! The factor of two for conversion to Bohr magnetons cancels the
    ! factor of half for the S operator
    do n = 1,n_refl
       ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
    end
    q.destroy
    phase.destroy
  end

  sum_ft_r_ints(ft_ints,unique_ft_ints,B)
  ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
  ! magnetic structure factors, from a sum of the list of unique structure
  ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
  ! Note: only inversions are allowed as symmetry elements for PND simulations.
  ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
    CMAT4 :: ft_ints
    CMAT4, IN :: unique_ft_ints
    VEC(3) :: B
    CVEC* :: phase
    MAT* :: q
    CMAT3* :: ints
    INT :: u,uf,n,n_refl
    CDBL :: ci
    n_refl = .reflections.n_refl
    ENSURE( size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
    phase.create(n_refl)
    q.create(n_refl,3)
    ints.create(size(ft_ints,2),size(ft_ints,3),3)
    .make_k_pts(q)
    ft_ints = ZERO
    do u = 1,.n_unique_symops
      uf = n_refl*(u-1)
      .make_phases_for_symop(u,phase,.translated_symop)
      do n = 1,n_refl
        ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
        ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                            - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
        ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                            - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
        ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                            - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
      end
      if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
      .make_phases_for_symop(u,phase,.inverted_symop)
      do n = 1,n_refl
        ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
        ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                            - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
        ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                            - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
        ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                            - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
      end
    end
    ints.destroy
    ! The factor of two for conversion to Bohr magnetons cancels the
    ! factor of half for the S operator
    ci = (ZERO,ONE)
    do n = 1,n_refl
      ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
    end
    q.destroy
    phase.destroy
  end

   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      CVEC* :: phase
      MAT* :: q
      CMAT3* :: ints
      INT :: u,uf,n,n_refl
      n_refl = .reflections.n_refl
      ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
      phase.create(n_refl)
      q.create(n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
      end
      ints.destroy
      ! The factor of 2 to convert to Bohr magnetons cancels the factor
      ! of 1/2 for the Bohr magneton
      ! Extra minus sign introduced, but not sure why ...
      ! Reversed minus sign introduced ...
      do n = 1,n_refl
          ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

  sum_ft_j_ints(ft_ints,unique_ft_ints)
  ! Form the fourier transform j integrals "ft_ints", required for the PND
  ! magnetic striucture factors, from a sum of "unique_ft_ints".
  ! Note: only inversions are allowed as symmetry elements for PND simulations.
  ! Note: the complex conjugate nabla_b integrals are not included.
  ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
    CMAT4 :: ft_ints
    CMAT4, IN :: unique_ft_ints
    CVEC* :: phase
    INT :: u,uf, n,n_refl
    n_refl = .reflections.n_refl
    ENSURE(size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
    phase.create(n_refl)
    ft_ints = ZERO
    do u = 1,.n_unique_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
       end
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
       end
    end
    phase.destroy
  end

! ***********************************
! Operations on atomvecs in a crystal
! ***********************************

  generate_unique_symop_list(list)
  ! Returns a list of which seitz matrices generate unique molecules.
  ! Usefull when the molecule is on a special position.
    IN :: self
    BINVEC, OUT :: list
    MAT* :: pos1,pos2
    BINVEC* :: matched
    BIN :: same
    INT :: s1,s2,n,q

    ENSURE(size(list)==.spacegroup.n_seitz,"list size?")
    pos1.create(3,.n_fragment_atoms)
    pos2.create(3,.n_fragment_atoms)
    matched.create(.n_fragment_atoms)

    do s1=1,.spacegroup.n_seitz
      pos1 = .fragment_geometry
      .move_to_unit_cell(pos1)
      .transform_geometry(pos1,s1)
      .move_to_unit_cell(pos1)
      same = FALSE
      do s2=1,s1-1
        pos2 = .fragment_geometry
        .move_to_unit_cell(pos2)
        .transform_geometry(pos2,s2)
        .move_to_unit_cell(pos2)
        matched = FALSE
        do n = 1, .n_fragment_atoms
          do q = 1, .n_fragment_atoms
            same = pos2(:,n).same_as(pos1(:,q), TOL(3))
            if (same) then
              matched(q) = TRUE
              exit
            end
          end
          if (NOT same) exit   ! atom q doesn't have a match.
        end
        same = all(matched)    ! They are the same if all have a match.
        if (same) exit
      end
      list(s1) = NOT same
    end

    matched.destroy
    pos2.destroy
    pos1.destroy
  end

  create_closest_molecule_list(op_list,dist_list,position,distance_max) [leaky]
  ! Creates a list of the symmetry operations and translations of the molecules
  ! which are within max_distance of the centre of the molecule.
  ! If "position" is specified, it is used instead of the centre of the
  ! molecule.
    IMAT* :: op_list
    VEC* :: dist_list
    VEC, IN :: position
    DBL, optional :: distance_max
    MAT* :: pos1,pos2,pos3
    BINVEC* :: unique_symop_list
    VEC(3) :: centre,diff
    IVEC(3) :: offset
    INT :: n,s,h,k,l,d_h,d_k,d_l,q,maxnum
    DBL :: distance,dist,max_distance,max_cell_distance,a,b,c

    unique_symop_list.create(.spacegroup.n_seitz)
    .generate_unique_symop_list(unique_symop_list)

    max_distance = 10d0
    if (present(distance_max)) max_distance = distance_max

    a = .unit_cell_length(1)
    b = .unit_cell_length(2)
    c = .unit_cell_length(3)
    max_cell_distance = max_distance + a + b + c
    maxnum = unique_symop_list.n_true * &
                              (ceiling(max_cell_distance/min(a,b,c)))**3

    dist_list.create(maxnum)
    op_list.create(4,maxnum)

    pos1.create(3,.n_fragment_atoms)
    pos2.create(3,.n_fragment_atoms)
    pos3.create(3,.n_fragment_atoms)
    pos1 = .fragment_geometry
    .move_to_unit_cell(pos1)

    centre = position                        ! Center of the cluster
    centre.rotate_by(.inverse_cell_matrix)
    offset = floor(centre+0.001d0)           ! hkl offset of cluster
    ! We work with the 0,0,0 cell as the center of the cluster, then translate
    ! by the offset.
    centre = position - offset

    q = 0
    do s = 1, .spacegroup.n_seitz
      if (NOT unique_symop_list(s)) cycle
      pos2 = pos1
      .transform_geometry(pos2,s)

      d_h = ceiling(max_cell_distance/a)
      do h = -d_h,+d_h
        d_k = ceiling((max_cell_distance-abs(h)*a)/b)
        do k = -d_k,+d_k
          d_l = ceiling((max_cell_distance-abs(h)*a-abs(k)*b)/c)
          do l = -d_l,+d_l
            do n=1,.n_fragment_atoms
              pos3(:,n) = pos2(:,n) + (/h,k,l/)      ! Translate through lattice
            end
            .change_geometry_from_crystal(pos3)      ! Put in cartesians.
            diff = pos3(:,1) - centre
            distance = dot_product(diff,diff)
            do n=2,.n_fragment_atoms
              diff = pos3(:,n) - centre
              dist = dot_product(diff,diff)
              if (dist<distance) distance=dist
            end
            if (distance < TOL(6)) distance = ZERO
            distance = sqrt(distance)
            if (distance < max_distance) then
              q = q + 1; dist_list(q) = distance
              op_list(:,q) = (/s,h,k,l/)
            end
          end
        end
      end
    end

    do n=1,q
      op_list(2:4,n) = op_list(2:4,n) + offset       ! Translate cluster to
    end                                              ! correct cell.

    if (q==0) then ! None within required distance.
      dist_list.shrink(1);               dist_list = ZERO
      op_list.shrink(4,1);               op_list = 0
    else
      ! Truncate the lists.
      dist_list.shrink(q)
      op_list.shrink(4,q)

      ! Sort by distance.
      do k = 1, q
       do l = k, q
        if (dist_list(l) < dist_list(k)) then
          op_list.swap_columns(k,l)
          dist_list.swap_elements(k,l)
        end
       end
      end
    end

    unique_symop_list.destroy
  end

!  *****************************************
!  Reduced group, Unique operators, Z number
!  *****************************************

   make_reduced_group_data(atom) [leaky]
   ! The reduced group are those unique seitz operators which are needed to
   ! generate the complete ".unit_cell_geometry" from the atom fragment "atom".
   ! Some of these symmetry operations may only lead to geometries which are
   ! inversions of, or translations of, other operations in the reduced group.
   ! This information is also worked out here, and it can be used to save work
   ! in structure factor calculations.
      ATOMVEC :: atom
      .n_fragment_atoms = size(atom)
      .fragment_geometry.create(3,.n_fragment_atoms)
      atom.get_geometry(.fragment_geometry)
      .change_geometry_to_crystal(.fragment_geometry)
      .make_reduced_symops
      .make_inverted_symops
      .make_translated_symops
      .make_unique_symops
      .make_unique_atoms
      .make_unit_cell_geometry
      .make_repetition_factors
      .Z = .z_factor(atom)
   end

   z_factor(atom) result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined as the
   ! ratio of the number of electrons in the unit cell on the number of
   ! electrons in the fragment. Hence, we require information for each "atom" in
   ! the fragment.
      ATOMVEC :: atom
      DBL :: res,u,f
      INT :: n,a
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      ENSURE(.fragment_atom_for.created,"no reduced_symop array")
      u = ZERO
      do n = 1,.n_unit_cell_atoms
         a = .fragment_atom_for(n)
         u = u + atom(a).atomic_number
      end
      f = ZERO
      do n = 1,.n_fragment_atoms
         f = f + atom(n).atomic_number
      end
      res = u/f
   end

   make_reduced_symops [leaky]
   ! Make a list of the indices of the Seitz matrices, ".reduced_symop",
   ! which will generate distinctly different geometries from that in
   ! ".fragment_geometry". ".n_reduced_symops" is set to the number of
   ! reduced symmetry operations.
      MAT*  :: gi,gu
      INT :: i,j,u, n
      BIN :: identical
      gi.create(3,.n_fragment_atoms)
      gu.create(3,.n_fragment_atoms)
      .reduced_symop.create(.spacegroup.n_seitz)
      n = 1
      .reduced_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         do j = 1,n                            ! Loop over reduced symops
            gi = .fragment_geometry
            gu = .fragment_geometry
            u = .reduced_symop(j)
            .transform_geometry(gi,i,to_unit_cell=TRUE)
            .transform_geometry(gu,u,to_unit_cell=TRUE)
            identical  = .is_same_geometry(gi,gu)
            if (identical) exit
         end
         if (NOT identical) then
            n = n + 1
            .reduced_symop(n) = i
         end
      end
      .n_reduced_symops = n
      .reduced_symop.shrink(n)
      gu.destroy
      gi.destroy
   end

   make_inverted_symops [leaky]
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment cell_geometry" which are related by inversion.
      INT :: n,i,j
      BIN :: inverted
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      .inverted_symop.create(.spacegroup.n_seitz)
      .inverted_symop = 0
      n = 0
      do i = 2,.spacegroup.n_seitz
         do j = 1,i-1
            inverted = .spacegroup.seitz(1:3,1:3,i).equals( &
                      -.spacegroup.seitz(1:3,1:3,j) )
            if (inverted) then
               n = n + 1
               .inverted_symop(i) = j
               exit
            end
         end
      end
      .n_inverted_symops = n
   end

   make_translated_symops [leaky]
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment_cell_geometry" which are related by translation, (including
   ! translation by the zero vector), but not inversion
      INT :: i,j
      BIN :: translated
      ENSURE(.inverted_symop.created,"no inverted_symop array")
      .translated_symop.create(.spacegroup.n_seitz)
      .translated_symop = 0
      do i = 1,.spacegroup.n_seitz
         .translated_symop(i) = i
         if (.inverted_symop(i)>0) cycle
         do j = 1,i-1
            translated = .spacegroup.seitz(1:3,1:3,i).equals( &
                         .spacegroup.seitz(1:3,1:3,j) )
            if (translated) then
               .translated_symop(i) = j
               exit
            end
         end
      end
   end

   make_unique_symops [leaky]
   ! Determine which are the unique symops (independent of inversion and
   ! translation) which are a subset of the reduced symops.
      INT :: n,i
      ENSURE(.inverted_symop.created,  "no inverted_symop array")
      ENSURE(.translated_symop.created,"no translated_symop array")
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle ! Only true translations count
         n = n + 1
      end
      .n_unique_symops = n
      .unique_symop.create(n)
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle
         n = n + 1
         .unique_symop(n) = i
      end
   end

   is_same_geometry(geom_i,geom_j) result(res)
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      MAT :: geom_i,geom_j
      BIN :: res
      INT :: i,j,n_atom
      BIN :: same
      BINVEC* :: skip
      n_atom = size(geom_i,2)
      ENSURE(.spacegroup.seitz.created, "Seitz matrices not initialised")
      ENSURE(size(geom_i,1)==3, "incorrect size for array geom_i")
      ENSURE(size(geom_j,1)==3, "incorrect size for array geom_j")
      ENSURE(n_atom==size(geom_j,2), "incompatible sizes for geom_i, geom_j")
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j), TOL(3))
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   make_unique_atoms [leaky]
   ! Make the asymmetric unit atoms for the ".fragment_geometry".
      MAT* :: geometry
      VEC(3) :: pa
      INT :: u,a,s,col
      BIN :: found
      ENSURE(.fragment_geometry.created, "no fragment_geometry")
      .unique_atom_for.create(.n_fragment_atoms)
      .unique_atom_for    = 0
      .unique_atom_for(1) = 1
      .unique_atom.create(1)
      .unique_atom(1) = 1
      .unique_atom_symop_for.create(.n_fragment_atoms)
      .unique_atom_symop_for = 1
      geometry.create(3,.n_fragment_atoms)
      geometry = .fragment_geometry
      .put_to_unit_cell(geometry)
      u = 1
      do a = 2,.n_fragment_atoms
         found = FALSE
         do s = 1,.spacegroup.n_seitz
            pa = geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = geometry(:,.unique_atom).has_column(pa,TOL(3),col)
            if (.unique_atom_for(a)==0 AND found) then
               .unique_atom_for(a) = col
               .unique_atom_symop_for(a) = s
               exit
            end
         end
         if (NOT found) then
            u = u + 1
            .unique_atom_for(a) = u
            .unique_atom.expand(u)
            .unique_atom(u) = a
         end
      end
      .n_unique_unit_cell_atoms = u
      geometry.destroy
   end

   make_unit_cell_geometry [leaky]
   ! Get the all the atom positions in the unit cell, ".unit_cell_geometry",
   ! given a (possibly) partial or overcomplete set for the cell in array
   ! ".fragment_geometry".
      VEC(3) :: pa
      INT :: n,a,s
      BIN :: found
      ENSURE(.fragment_geometry.created,"no fragment_geometry")
      .fragment_atom_for.create(1)
      .fragment_atom_for(1) = 1
      .unit_cell_geometry.create(3,1)
      pa = .fragment_geometry(:,1)
      .put_to_unit_cell(pa)
      .unit_cell_geometry(:,1) = pa
      n = 1
      do a = 1,.n_fragment_atoms
         do s = 1,.spacegroup.n_seitz
            pa = .fragment_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = .unit_cell_geometry.has_column(pa,TOL(3))
            if (NOT found) then
               n = n + 1
               .fragment_atom_for.expand(n)
               .fragment_atom_for(n) = a
               .unit_cell_geometry.expand(3,n)
               .unit_cell_geometry(:,n) = pa
            end
         end
      end
      .n_unit_cell_atoms = n
   end

   make_repetition_factors [leaky]
   ! The number of times an atom with index "a" in mapped into itself under
   ! the reduced group is the ".repetition_factor(a)". It is used to correct
   ! structure factors for fragment geometries which are "oversampled" relative
   ! to the asymmetric cell geometry.
      VEC(3)  :: pa,pb
      INT :: a,b,n,n_same
      BIN :: same
      ENSURE(.reduced_symop.created, "no reduced_symops!")
      .repetition_factor.create(.n_fragment_atoms)
      do a = 1,.n_fragment_atoms
         pa = .fragment_geometry(:,a)
         .put_to_unit_cell(pa)
         n_same = 0
         do b = 1,.n_fragment_atoms
         do n = 1,.spacegroup.n_seitz
            pb = .fragment_geometry(:,b)
            .transform_position(pb,n,to_unit_cell=TRUE)
            same = pa.same_as(pb,TOL(3))
            if (same) n_same = n_same + 1
         end
         end
         .repetition_factor(a) = n_same
      end
   end

   transform_geometry(g,op,ignore_glide,to_unit_cell)
   ! Transform the geometry "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translated fractional
   ! coordinates into the (1,1,1) unit cell.
      MAT :: g
      INT :: op
      BIN, optional :: ignore_glide,to_unit_cell
      INT :: n,n_atom,n_seitz
      n_atom = size(g,2)
      n_seitz = .spacegroup.n_seitz
      ENSURE( size(g,1)==3, "incorrect size for array g")
      do n = 1,n_atom
         .transform_position(g(:,n),op,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,ignore_glide,to_unit_cell)
   ! Transform the position "p" in fractional coordinates with the
   ! Seitz operator with index "op". If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translated fractional
   ! coordinates into the (1,1,1) unit cell.
      VEC(3) :: p
      INT :: op
      BIN, optional :: ignore_glide,to_unit_cell
      BIN :: ignore,to_cell
      INT :: n_seitz
      n_seitz = .spacegroup.n_seitz
      ENSURE( op>0,        "operator index out of bounds")
      ENSURE( op<=n_seitz, "operator index out of bounds")
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(p,.spacegroup.seitz(1:3,1:3,op))
      else
        p = matmul(p,.spacegroup.seitz(1:3,1:3,op)) + .spacegroup.seitz(4,1:3,op)
      end
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p)
   end

   put_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      MAT :: g
      INT :: n,n_atom
      ENSURE( size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      do n = 1,n_atom
         .put_to_unit_cell(g(:,n))
      end
   end

   put_to_unit_cell(p)
   ! Transform the position "p" in fractional coordinates into the
   ! (1,1,1) unit cell.
      VEC(3) :: p
      ENSURE(size(p)==3, "p must be length 3")
      p(:) = mod(p(:)+TWO+0.001d0,ONE) - 0.001d0
   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      MAT :: g
      INT :: n,n_atom
      IVEC(3) :: centre
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      centre = .unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - centre
      end
   end

   unit_cell_offset(g) result(res)
   ! Which hkl indices match the centre of the fragment.
   ! Usually it's 0,0,0 but not always
      MAT :: g
      INT :: n,n_atom
      IVEC(3) :: res
      VEC(3) :: centre
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      .change_geometry_from_crystal(g)
      centre =  0.001d0
      do n = 1, n_atom
        centre = centre + g(:,n)
      end
      centre.rotate_by(.inverse_cell_matrix)
      res = floor(centre / n_atom)
      .change_geometry_to_crystal(g)
   end

   reduced_symop_mat(r) result (res)
   ! Return the "r"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      MAT(3,3) :: res
      INT :: r
      ENSURE(.reduced_symop.created,"no reduced_symops!")
      ENSURE(r<=.n_reduced_symops,"symop index out of range")
      ENSURE(r>0, "symop index out of range")
      res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

   unique_symop_mat(u) result (res)
   ! Return the "u"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      MAT(3,3) :: res
      INT :: u,r
      ENSURE(.unique_symop.created,"no unique_symops!")
      ENSURE(u<=.n_unique_symops,"symop index out of range")
      ENSURE(u>0,"symop index out of range")
      r = .unique_symop(u)
      res = .spacegroup.seitz(1:3,1:3,r)
   !  res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

!  **************
!  Output methods
!  **************

   put(atom)
   ! Put out the crystal data to stdout
      ATOMVEC, optional :: atom
     .put(stdout,atom)
   end

   put(out,atom)
   ! Put out the crystal data to file "out"
      ATOMVEC, optional :: atom
      TEXTFILE* :: out
      out.flush
      out.text("CRYSTAL information:")
      out.show("kind                        =", .kind)
      .put_unitcell_data(out)
      .spacegroup.put(out)
      if (.fragment_data_exists)   .put_fragment_data(out,atom)
      if (.reflection_data_exists) .put_reflection_data(out)
   end

   put_unitcell_data(out)
   ! Put unitcell information to file "out"
      TEXTFILE :: out
      out.flush
      out.text("Crystal unitcell information:",flush=2)
      out.show("alpha angle(rad)       = ",.unit_cell_angle(1))
      out.show("beta  angle(rad)       = ",.unit_cell_angle(2))
      out.show("gamma angle(rad)       = ",.unit_cell_angle(3))
      out.show("a cell parameter(bohr) = ",.unit_cell_length(1))
      out.show("b cell parameter(bohr) = ",.unit_cell_length(2))
      out.show("c cell parameter(bohr) = ",.unit_cell_length(3))
      out.show("cell volume(bohr^3)    = ",.unit_cell_volume)
      out.flush
      out.text("Direct cell matrix/bohr:")
      out.put(.direct_cell_matrix)
      out.flush
      out.text("Reciprocal cell matrix/(bohr^{-1}):")
      out.put(.reciprocal_cell_matrix)
      out.flush
   end

   put_fragment_data(out,atom)
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.
      TEXTFILE :: out
      ATOMVEC, optional :: atom
      out.flush
      out.text("Crystal cell-fragment data:")
      out.flush
      out.show("Fragment partition model      = ",.partition_model)
      out.show("Thermal smearing model        = ",.thermal_smearing_model)
      out.show("No. of inputted atoms         = ",.n_fragment_atoms,dbl_width=TRUE)
      out.show("No. of unit cell atoms        = ",.n_unit_cell_atoms,dbl_width=TRUE)
      out.show("No. of unique unit cell atoms = ",.n_unique_unit_cell_atoms,dbl_width=TRUE)
      out.show("Z factor                      = ",.Z)
      .put_reduced_symop_data(out)
      .put_inv_trans_symop_data(out)
      if (present(atom)) then
        .put_fragment_geometry(out,atom)
        .put_asymmetric_unit_geometry(out,atom)
        .put_unit_cell_geometry(out,atom)
        .put_repetition_factors(out,atom)
      end
   end

   put_reduced_symop_data(out)
   ! Put out the reduced symop data
      TEXTFILE :: out
      INT :: n,s
      BIN :: inverted,translated
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array!")
      out.flush
      out.text("Crystal fragment reduced group information:")
      out.flush
      out.text("NOTE: this table is NOT used any more in structure factor calculations")
      out.flush
      out.dash(int_fields=5)
      out.put("Reduced",int_width=TRUE)
      out.put("Seitz",int_width=TRUE)
      out.put("Inv.",int_width=TRUE)
      out.put("Trans.",int_width=TRUE)
      out.flush
      out.put("Symop",int_width=TRUE)
      out.put("Symop",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("Unique?",int_width=TRUE)
      out.flush
      out.dash(int_fields=5)
      do n = 1,.n_reduced_symops
         out.put(n)
         s = .reduced_symop(n)
         out.put(s)
         inverted = .inverted_symop(s)>0
         if (inverted) then;   out.put(.inverted_symop(s))
         else;                 out.tab(int_fields=1)
         end
         translated = .translated_symop(s)<n
         out.put(.translated_symop(s))
         if (inverted OR translated) then; out.put("No",int_width=TRUE)
         else;                             out.put("Yes",int_width=TRUE)
         end
         out.flush
      end
      out.dash(int_fields=5)
   end

   put_inv_trans_symop_data(out)
   ! Put out the inverted translated symop data
      TEXTFILE :: out
      INT :: n
      BIN :: inverted,translated
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal Inversion/Translation related symop information:")
      out.flush
      out.text("NOTE: this table is used in structure factor calculations")
      out.flush
      out.dash(int_fields=4)
      out.put("Seitz",int_width=TRUE)
      out.put("Inv.",int_width=TRUE)
      out.put("Trans.",int_width=TRUE)
      out.flush
      out.put("Symop",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("Unique?",int_width=TRUE)
      out.flush
      out.dash(int_fields=4)
      do n = 1,.spacegroup.n_seitz
         out.put(n)
         inverted = .inverted_symop(n)>0
         if (inverted) then;   out.put(.inverted_symop(n))
         else;                 out.tab(int_fields=1)
         end
         translated = .translated_symop(n)<n
         out.put(.translated_symop(n))
         if (inverted OR translated) then; out.put("No",int_width=TRUE)
         else;                             out.put("Yes",int_width=TRUE)
         end
         out.flush
      end
      out.dash(int_fields=4)
   end

   put_fragment_geometry(out,atom)
   ! Put out the cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      STR :: symbol
      INT :: n
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal fragment cell geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Fragment",int_width=TRUE)
      out.put("Unique",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do n = 1,.n_fragment_atoms
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.unique_atom_for(n))
         out.put(.fragment_geometry(1,n))
         out.put(.fragment_geometry(2,n))
         out.put(.fragment_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_asymmetric_unit_geometry(out,atom)
   ! Put out the asymmetric unit cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,u
      STR :: symbol
      ENSURE(.unique_atom.created,"unique_atoms?")
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      out.flush
      out.text("Crystal asymmetric unit geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Unique",int_width=TRUE)
      out.put("Fragment",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do u = 1,.n_unique_unit_cell_atoms
         out.put(u)
         n = .unique_atom(u)
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.fragment_geometry(1,n))
         out.put(.fragment_geometry(2,n))
         out.put(.fragment_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_unit_cell_geometry(out,atom)
   ! Put out the full unit cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,f
      STR :: symbol
      out.flush
      out.text("Full unit cell geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Cell ",int_width=TRUE)
      out.put("Fragment",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do n = 1,.n_unit_cell_atoms
         out.put(n)
         f = .fragment_atom_for(n)
         symbol = atom(f).chemical_symbol.trim // " (" // f.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.unit_cell_geometry(1,n))
         out.put(.unit_cell_geometry(2,n))
         out.put(.unit_cell_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_repetition_factors(out,atom)
   ! Put out the repetition factors
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,rf
      STR :: symbol
      out.flush
      out.text("Crystal fragment atom repetition factors:")
      out.flush
      out.dash(int_fields=2)
      out.put("Fragment",int_width=TRUE)
      out.put("Rep.",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Factor",int_width=TRUE)
      out.flush
      out.dash(int_fields=2)
      do n = 1,.n_fragment_atoms
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         rf = .repetition_factor(n)
         out.put(rf)
         out.flush
      end
      out.dash(int_fields=2)
   end

   put_F_calc
   ! Put the hkl Miller index triple followed by the calculated
   ! structure factor to add onto existing structure factors.
      STRVEC(2) :: keywords
      keywords(1) = "indices"
      keywords(2) = "F_calc"
      ENSURE(.reflections.created, "no reflection data")
      .reflections.put(keywords)
   end

   put_F_stats(output)
   ! Output the structure factor goodness of fit statistics to file "output" or
   ! stdout.
      TEXTFILE, optional, target :: output
      .reflections.put_F_stats(output)
      .put_correction_data(output)
   end

   put_I_stats(output)
   ! Output the intensity goodness of fit statistics to file "output" or stdout.
      TEXTFILE, optional, target :: output
      .reflections.put_I_stats(output)
      .put_correction_data(output)
   end

  put_correction_data(output)
  ! Output the correction data to file "output"
    TEXTFILE, optional, target :: output
    BIN :: dbl_width
    TEXTFILE* :: out
    if (present(output)) then; out => output
    else;                      out => stdout
    end
    dbl_width = TRUE
    out.flush
    out.show("Using scale factor          =", .optimise_scale,dbl_width)
    out.show("Using extinction            =", .optimise_extinction,dbl_width)
    out.show("Thermal smearing model      =", .thermal_smearing_model)
    out.show("Fragment partition model    =", .partition_model)
    if (.optimise_extinction) then;
    out.show("Optimize extinction         =", TRUE)
    out.show("Secondary extinction factor =", .extinction_factor)
    else
    out.show("Optimize extinction         =", FALSE)
    end
    if (.optimise_scale) then
    out.show("Optimize scale factor       =", TRUE)
    out.show("Scale factor                =", .scale_factor)
    else
    out.show("Optimize scale factor       =", FALSE)
    end
    out.show("Thermal smearing model      =", .thermal_smearing_model)
    out.show("Fragment partition model    =", .partition_model)
!    out.show("Correct dispersion?         =", .correct_dispersion)
   end

  put_reflection_data(output)
  ! Output the reflection data to file "output", or stdout
    TEXTFILE, target, optional :: output
    ENSURE(.reflections.created,"no reflections")
    .reflections.put_reflection_data(output)
  end

  put_qq_plot(name)
  ! Output a qq plot to the text file.
  ! It is a plot of the experimental quantile vs expected quantile.
    STR, optional :: name
    ENSURE(.reflections.created, "no reflection data")
    .reflections.put_F_qq_plot(name)
  end

  put_labelled_qq_plot(name)
  ! Output a qq plot to the text file.
  ! It is a plot of the experimental quantile vs expected quantile.
    STR, optional :: name
    ENSURE(.reflections.created, "no reflection data")
    .reflections.put_labelled_F_qq_plot(name)
  end

  put_chi2_vs_angle_plot
  ! Output a table with the chi^2 for the structure factor data set broken
  ! into sections.
  ! Reads from stdin the number of divisions in the plot.
    INT :: num_sections
    INT :: n,num,k,n_refl
    IVEC* :: section_for
    DBL :: stl,stl_min,stl_max,chi2,width,stl_mean,z

    stdin.read(num_sections)
    ENSURE(num_sections > 0, "number of sections to plot not positive")
    ENSURE(.reflections.created,"no structure factors")
    n_refl = .reflections.n_refl

    ! Work out the limits of the sin(theta)/lambda.
    stl_min = 1000
    stl_max = ZERO
    do n=1, n_refl
      stl = .stl(n) * BOHR_PER_ANGSTROM
      if (stl < stl_min) stl_min = stl
      if (stl > stl_max) stl_max = stl
    end
    width = (TOL(3) + stl_max - stl_min)/num_sections

    section_for.create(n_refl)
    ! Determine which section each reflection belongs to.
    do n=1, n_refl
      stl = .stl(n) * BOHR_PER_ANGSTROM
      section_for(n) = ceiling((TOL(3) + stl - stl_min) / width)
    end

    stdout.flush
    stdout.text("Chi^2 vs angle plot")
    stdout.flush
    stdout.text("sin(theta)/lambda in Angstrom^(-1)")
    stdout.show("Smallest sin(theta)/lambda  = ",stl_min)
    stdout.show("Largest sin(theta)/lambda   = ",stl_max)
    stdout.flush
    stdout.put("stl")
    stdout.put("chi^2",flush=1)
    stdout.dash(dbl_fields=2)
    do n = 1, num_sections
      chi2 = ZERO
      num = 0
      stl_mean = stl_min + (n - HALF) * width
      do k = 1, n_refl
        if (n==section_for(k)) then
          chi2 = chi2 + .reflections(k).F_z2
          num = num + 1
        end
      end
      stdout.put(stl_mean)
      if (num==0) then
        stdout.flush
        cycle
      else
        chi2 = chi2 / max(num - .n_param,1)
        stdout.put(chi2,flush=1)
      end
    end
    stdout.flush
    section_for.destroy
  end

  put_fcalc_plots
  ! Output some different plots about the calculated structure factors.
    VEC* :: ext
    REFLECTIONVEC* :: ext_refs
    IVEC(3) :: hkl
    INT :: n,n_refl
    DBL :: x,y,w

    n_refl = .reflections.n_refl

    stdout.text("The effects of angle.")
    stdout.text("Scatter plot of (Fexp-Fpred)/F_sigma vs sin(theta)/lambda")
    do n=1,n_refl
      stdout.put(.stl(n))
      stdout.put(.reflections(n).F_z)
      stdout.flush
    end
    stdout.flush

    stdout.text("The effects of intensity.")
    stdout.text("Scatter plot of (Fexp-Fpred)/F_sigma vs Fexp")
    do n=1,n_refl
      stdout.put(.reflections(n).F_exp)
      stdout.put(.reflections(n).F_z)
      stdout.flush
    end
    stdout.flush

    ext_refs.create(n_refl)
    ext.create(n_refl)
    ext = .extinction_correction
    ext_refs.set_F_exp(.reflections.F_pred)
    ext_refs.set_F_pred(.reflections.F_pred * ext)
    ext_refs.set_F_sigma(.reflections.F_sigma)
    ext.destroy

    stdout.text("The effects of extinction.")
    w = ZERO
    y = ZERO
    do n=1,n_refl
      y = y + abs(ext_refs(n).F_z)
      w = w + abs(ext_refs(n).F_r)
    end
    y = y / n_refl
    w = w / n_refl
    stdout.show("Average value of abs(Fcalc_ext-Fcalc)/F_sigma is ",y)
    stdout.show("Average value of abs(extinction correction) is ",w)
    stdout.flush

    stdout.text("The effects of extinction.")
    stdout.text("Scatter plot of (Fcalc_ext-Fcalc)/F_sigma vs Fpred")
    do n=1,n_refl
      stdout.put(ext_refs(n).F_pred)
      stdout.put(ext_refs(n).F_z)
      stdout.flush
    end
    stdout.flush

    stdout.text("The effects of extinction.")
    stdout.text("Scatter plot of (Fcalc_ext-Fcalc)/F_sigma vs sin(theta)/lambda")
    do n=1,n_refl
      stdout.put(.stl(n))
      stdout.put(ext_refs(n).F_z)
      stdout.flush
    end
    ext_refs.destroy

    stdout.flush
  end

   make_crystal_error_map(map,pts)
   ! Make the crystal error "map" for the supplied points "pts" from the crystal
   ! structure factors
     VEC :: map
     MAT :: pts
     MAT* :: k
     VEC* :: F,phase
     INT :: n_pts,n_refl,n
     DBL :: fac
     ENSURE(.reflections.created, "no structure factors")
     ENSURE(.have_F_calc, "no calculated structure factors")
     ENSURE(.have_F_exp, "no experimental structure factors")
     ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
     n_pts = size(pts,1)
     n_refl = .reflections.n_refl
     k.create(n_refl,3); .make_k_pts(k)
     F.create(n_refl)
     F = (.reflections.F_exp - .reflections.F_pred) * sign(ONE,real(.reflections.F_calc))
     phase.create(n_refl)
     do n = 1,n_pts
        phase.to_product(k,pts(n:n,:),transpose_b=TRUE)
        map(n) = sum(F*cos(phase))
     end
     fac = TWO/.unit_cell_volume
     map = fac*map
     phase.destroy
     F.destroy
     k.destroy
   end

  put_PND_sf(name)
  ! Output the magnetic structure factors
      CVEC* :: FM_s
      CVEC* :: FM_l
      STR :: name
      ARCHIVE :: archive
      INT :: n
      FM_s.create(.reflections.n_refl)
      archive.set(name,"PND_spin_sf")
      archive.read(FM_s)
      FM_l.create(.reflections.n_refl)
      archive.set(name,"PND_nabla_sf")
      archive.read(FM_l)
      stdout.text("PND magnetic structure factors:")
      stdout.flush
      stdout.dash(int_fields=3,dbl_fields=3)
      stdout.put("h", int_width=TRUE)
      stdout.put("k", int_width=TRUE)
      stdout.put("l", int_width=TRUE)
      stdout.put("FM_s")
      stdout.put("FM_l")
      stdout.put("FM")
      stdout.flush
      stdout.dash(int_fields=3,dbl_fields=3)
      do n = 1, .reflections.n_refl
         stdout.put(.reflections(n).h)
         stdout.put(.reflections(n).k)
         stdout.put(.reflections(n).l)
         stdout.put(real(FM_s(n)) )
         stdout.put(real(FM_l(n)) )
         stdout.put(real(FM_s(n)+FM_l(n)) )
         stdout.flush
      end
      stdout.dash(int_fields=3,dbl_fields=3)
      FM_l.destroy
      FM_s.destroy
  end

!  *******************
!  Tests for existence
!  *******************

   fragment_data_exists result(res)
   ! Return TRUE if a fragment information exists
      BIN :: res
      res = associated(.fragment_geometry)
   end

   no_fragment_data result(res)
   ! Return TRUE if a fragment information exists
      BIN :: res
      res = NOT associated(.fragment_geometry)
   end

   no_reflection_data result(res)
   ! Return TRUE if no reflection data exists
      BIN :: res
      res = NOT associated(.reflections)
   end

  reflection_data_exists result(res)
  ! Return TRUE if reflection data exists
    BIN :: res
    res = associated(.reflections)
  end

   have_F_exp result(res)
   ! Return TRUE if have some experimental structure factors
      BIN :: res
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_exp
   end

   have_F_calc result(res)
   ! Return TRUE if have some calculated structure factors
      BIN :: res
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_calc
   end

   have_F_pred result(res)
   ! Return TRUE if have some predicted structure factors
      BIN :: res
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_pred
   end

   have_F_sigma result(res)
   ! Return TRUE if have some structure factor errors
      BIN :: res
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_sigma
   end

!*******************************************************************************
!                     Inherited reflection routines
!*******************************************************************************

  n_refl result (res)
  ! The number of reflections
    INT :: res
    ENSURE(.reflections.created, "no reflection data")
    res = .reflections.n_refl
  end

  F_calc result (res)
  ! The calculated structure factors
    CVEC(size(.reflections)) :: res
    res = .reflections.F_calc
  end

  F_pred result (res)
  ! The predicted structure factors
    VEC(size(.reflections)) :: res
    res = .reflections.F_pred
  end

  F_sigma result (res)
  ! The structure factor errors
    VEC(size(.reflections)) :: res
    res = .reflections.F_sigma
  end

  F_exp result (res)
  ! The experimental structure factors
    VEC(size(.reflections)) :: res
    res = .reflections.F_exp
  end

  set_F_calc(F_calc)
  ! Set the calculated structure factors
    CVEC, IN :: F_calc
    ENSURE(.reflection_data_exists,"no reflection data")
    .reflections.set_F_calc(F_calc)
  end

end
