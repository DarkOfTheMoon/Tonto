!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module CRYSTAL

   implicit none

   saved_self :: CRYSTAL*

contains

!  **************************
!  Create and destroy methods
!  **************************

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object

     .spacegroup.nullify_ptr_part

     nullify(.fragment_geometry)
     nullify(.asymmetric_unit_geometry)
     nullify(.asymmetric_unit_atom)

     nullify(.unit_cell_geometry)
     nullify(.asym_atom_for_unit_cell_atom)
     nullify(.symop_for_unit_cell_atom)

     nullify(.frag_atom_for_unit_cell_atom)
     nullify(.unit_cell_atom_for_frag_atom)
     nullify(.frag_atom_for_asym_unit_atom)
     nullify(.asym_unit_atom_for_frag_atom)
     nullify(.frag_parent_for_cell_atom)

     nullify(.unique_frag_atom)
     nullify(.unique_atom_for_frag_atom)
     nullify(.asym_symop_for_frag_atom)
     nullify(.asym_shift_for_frag_atom)

     nullify(.repetition_factor)
     nullify(.asym_atom_rep_factor)
     nullify(.asym_atom_stabilizer)

     nullify(.unit_cell_connection)
     nullify(.unit_cell_mol_for_atom)

     nullify(.stabilizer_symop)
     nullify(.str)
     nullify(.ptr)
     nullify(.dtr)
     nullify(.ftr)
     nullify(.gtr)

     nullify(.data)
     nullify(.xray_data)
     nullify(.pnd_data)
     nullify(.xray_r_free_data)
     nullify(.pnd_r_free_data)

   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information
    .spacegroup.destroy_ptr_part
    .destroy_fragment_data
    .destroy_asymmetric_unit
    .destroy_data
   end

   destroy_data ::: leaky
   ! Erase all data pointer information
    nullify(.data)
    .xray_data.destroy
    .pnd_data.destroy
    .xray_r_free_data.destroy
    .pnd_r_free_data.destroy
   end

   destroy_fragment_data ::: leaky
   ! Destroy the geometry and symmetry data for the fragment and unit cell.
   ! NOTE: Don't destroy asymmetric unit atom info

     .fragment_geometry.destroy
     ! Never destroy .asymmetric_unit_geometry
     ! Never destroy .asymmetric_unit_atom

     .unit_cell_geometry.destroy
     .asym_atom_for_unit_cell_atom.destroy
     .symop_for_unit_cell_atom.destroy

     .frag_atom_for_unit_cell_atom.destroy
     .unit_cell_atom_for_frag_atom.destroy
     .frag_atom_for_asym_unit_atom.destroy
     .asym_unit_atom_for_frag_atom.destroy
     .frag_parent_for_cell_atom.destroy

     .unique_frag_atom.destroy
     .unique_atom_for_frag_atom.destroy
     .asym_symop_for_frag_atom.destroy
     .asym_shift_for_frag_atom.destroy

     if (NOT .use_manual_repetition_factors) .repetition_factor.destroy
     .asym_atom_rep_factor.destroy
     .asym_atom_stabilizer.destroy

     .unit_cell_connection.destroy
     .unit_cell_mol_for_atom.destroy

     .stabilizer_symop.destroy
     .str.destroy
     .ptr.destroy
     .dtr.destroy
     .ftr.destroy
     .gtr.destroy

     .fragment_info_made = FALSE

   end

   destroy_asymmetric_unit ::: leaky
   ! Destroy the asymmetric unit geometry. Normally this will be set by reading a CIF
   ! file. If not, it will be set from a given fragment atom list, in the
   ! "make_fragment_data" routine. Once set, it is never destroyed unless
   ! explicitly requested by a call or a keyword.
     .asymmetric_unit_geometry.destroy ! This is nothing to do with a fragment !
     .asymmetric_unit_atom.destroy
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(crystal) ::: leaky
   ! Set self to be crystal.
     crystal :: CRYSTAL, IN

     self = crystal

     .nullify_ptr_part

     .spacegroup.copy(crystal.spacegroup)
     .unit_cell.copy(crystal.unit_cell)

     if (crystal.fragment_geometry.created)        .fragment_geometry.create_copy(crystal.fragment_geometry)
     if (crystal.asymmetric_unit_geometry.created) .asymmetric_unit_geometry.create_copy(crystal.asymmetric_unit_geometry)
     if (crystal.asymmetric_unit_atom.created)     .asymmetric_unit_atom.create_copy(crystal.asymmetric_unit_atom)

     if (crystal.unit_cell_geometry.created)           .unit_cell_geometry.create_copy(crystal.unit_cell_geometry)
     if (crystal.asym_atom_for_unit_cell_atom.created) .asym_atom_for_unit_cell_atom.create_copy(crystal.asym_atom_for_unit_cell_atom)
     if (crystal.symop_for_unit_cell_atom.created)     .symop_for_unit_cell_atom.create_copy(crystal.symop_for_unit_cell_atom)

     if (crystal.frag_atom_for_unit_cell_atom.created) .frag_atom_for_unit_cell_atom.create_copy(crystal.frag_atom_for_unit_cell_atom)
     if (crystal.unit_cell_atom_for_frag_atom.created) .unit_cell_atom_for_frag_atom.create_copy(crystal.unit_cell_atom_for_frag_atom)
     if (crystal.frag_atom_for_asym_unit_atom.created) .frag_atom_for_asym_unit_atom.create_copy(crystal.frag_atom_for_asym_unit_atom)
     if (crystal.asym_unit_atom_for_frag_atom.created) .asym_unit_atom_for_frag_atom.create_copy(crystal.asym_unit_atom_for_frag_atom)
     if (crystal.frag_parent_for_cell_atom.created)    .frag_parent_for_cell_atom.create_copy(crystal.frag_parent_for_cell_atom)

     if (crystal.unique_frag_atom.created)           .unique_frag_atom.create_copy(crystal.unique_frag_atom)
     if (crystal.unique_atom_for_frag_atom.created)  .unique_atom_for_frag_atom.create_copy(crystal.unique_atom_for_frag_atom)
     if (crystal.asym_symop_for_frag_atom.created) .asym_symop_for_frag_atom.create_copy(crystal.asym_symop_for_frag_atom)
     if (crystal.asym_shift_for_frag_atom.created) .asym_shift_for_frag_atom.create_copy(crystal.asym_shift_for_frag_atom)

     if (crystal.repetition_factor.created)    .repetition_factor.create_copy(crystal.repetition_factor)
     if (crystal.asym_atom_rep_factor.created) .asym_atom_rep_factor.create_copy(crystal.asym_atom_rep_factor)
     if (crystal.asym_atom_stabilizer.created) .asym_atom_stabilizer.create_copy(crystal.asym_atom_stabilizer)

     if (crystal.unit_cell_connection.created)   .unit_cell_connection.create_copy(crystal.unit_cell_connection)
     if (crystal.unit_cell_mol_for_atom.created) .unit_cell_mol_for_atom.create_copy(crystal.unit_cell_mol_for_atom)

     if (crystal.stabilizer_symop.created)  .stabilizer_symop.create_copy(crystal.stabilizer_symop)
     if (crystal.str.created)               .str.create_copy(crystal.str)
     if (crystal.ptr.created)               .ptr.create_copy(crystal.ptr)
     if (crystal.dtr.created)               .dtr.create_copy(crystal.dtr)
     if (crystal.ftr.created)               .ftr.create_copy(crystal.ftr)
     if (crystal.gtr.created)               .gtr.create_copy(crystal.gtr)

     if (crystal.xray_data.created) .xray_data.create_copy(crystal.xray_data)
     if (crystal.pnd_data.created)  .pnd_data.create_copy(crystal.pnd_data)

   end

   set_defaults ::: leaky
   ! Set up a default crystal object

      .spacegroup.set_defaults
      .unit_cell.set_defaults

      .CIF_chemical_formula   = "?"
      .prune_asymmetric_unit  = TRUE
      .fragment_info_made     = FALSE
      .n_unit_cell_mols       = 0
      .Z                      = 0
      .finalize               = TRUE

      .data_kind              = "?"
      nullify(.data)
      if (.xray_data.created) then;    .xray_data.set_defaults
      else;                            nullify(.xray_data)
      end
      if (.pnd_data.created) then;     .pnd_data.set_defaults
      else;                            nullify(.pnd_data)
      end

      .r_free_percentage = 0

      .use_manual_repetition_factors = FALSE

   end

   update ::: leaky
   ! Update the crystal information after setting values.
     if (.xray_data.created) then
        .xray_data.update(.unit_cell,.spacegroup)
        if (.r_free_percentage>0 AND .xray_data.reflections.created) then
           .xray_r_free_data.destroy
           .xray_r_free_data.create_copy(.xray_data)
           .xray_r_free_data.reflections.destroy
           .set_r_free_reflections(.xray_data.reflections,.xray_r_free_data.reflections)
        end
     end
     if (.pnd_data.created) then
        .pnd_data.update(.unit_cell,.spacegroup)
        if (.r_free_percentage>0 AND .pnd_data.reflections.created) then
           .pnd_r_free_data.destroy
           .pnd_r_free_data.create_copy(.xray_data)
           .pnd_r_free_data.reflections.destroy
           .set_r_free_reflections(.pnd_data.reflections,.pnd_r_free_data.reflections)
        end
     end
   end

   set_r_free_reflections(data,free_data) ::: leaky
   ! Set the R free reflection data. "data" is destroyed and created
   ! again without those reflections in "free_data".
      data,free_data :: VEC{REFLECTION}*
   ENSURE(data.created,"no diffraction data")
   ENSURE(free_data.destroyed,"r_free_data exists")
      keep_data :: VEC{REFLECTION}*
      harvest :: VEC{REAL}* 
      free,keep :: VEC{INT}* 
      percentage :: REAL
      i,n :: INT
      if (.r_free_percentage<=0) return
      if (data.destroyed) return
      percentage = .r_free_percentage/100.0d0
      n = data.dim
      harvest.create(n)
      call random_number(harvest)
      nullify(free)
      nullify(keep)
      do i = 1,n
         if (harvest(i)<percentage) then; free.append(i)
         else;                            keep.append(i)
         end
      end
      harvest.destroy
      stdout.show("No. of reflections kept for R free =",free.dim)
      free_data.create(free.dim)
      free_data = data(free)
      free.destroy
      keep_data.create(keep.dim)
      keep_data = data(keep)
      keep.destroy
      data.destroy
      data => keep_data
      stdout.flush
   end

   assign_xray 
   ! Assign data to the xray_data
   ENSURE(.xray_data.created, "No X-ray reflection data")
      nullify(.data)
      .data => .xray_data
   end

   assign_xray_r_free
   ! Assign data to the xray_r_free_data
   ENSURE(.xray_r_free_data.created, "No X-ray R-free reflection data")
      nullify(.data)
      .data => .xray_r_free_data
   end

   assign_pnd 
   ! Assign data to the pnd_data
   ENSURE(.pnd_data.created, "No PND reflection data")
      nullify(.data)
      .data => .pnd_data
   end

   assign_pnd_r_free
   ! Assign data to the pnd_r_free_data
   ENSURE(.pnd_r_free_data.created, "No PND R-free PND reflection data")
      nullify(.data)
      .data => .pnd_r_free_data
   end

!  ************
!  Read methods
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
        case ("}                             ")  ! exit read_loop
        case ("asymmetric_unit_geometry=     "); .read_asymmetric_unit_geometry
        case ("destroy                       "); .destroy_ptr_part; .set_defaults
        case ("destroy_asymmetric_unit       "); .destroy_asymmetric_unit
        case ("destroy_spacegroup            "); .spacegroup.destroy_ptr_part
        case ("expand_unique_reflections     "); .expand_unique_reflections
        case ("finalize=                     "); .read_finalize
        case ("junk=                         "); CRYSTAL::read_junk
        case ("kind=                         "); .read_kind
        case ("merge_equivalents             "); .merge_equivalents
        case ("merge_ordered_equivalents     "); .merge_ordered_equivalents
        case ("pnd_data=                     "); .read_pnd_data
        case ("prune_asymmetric_unit=        "); .read_prune_asymmetric_unit
        case ("prune_bad_sigmas              "); .prune_bad_sigmas
        case ("put                           "); .put
        case ("r_free_percentage=            "); .read_r_free_percentage
        case ("read_cif                      "); .read_CIF
        case ("redirect                      "); .redirect
        case ("repetition_factors=           "); .read_repetition_factors
        case ("revert                        "); .revert
        case ("spacegroup=                   "); .read_spacegroup
        case ("unit_cell=                    "); .read_unit_cell
        case ("units=                        "); CRYSTAL::read_units
        case ("use_manual_repetition_factors="); .read_use_manual_rep_factors
        case ("xray_data=                    "); .read_xray_data
        case default;                       UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), selfless, private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.data_kind)
      .data_kind.to_lower_case
      select case (.data_kind)
         case("x-ray")
         case("pnd  ")
         case default; UNKNOWN(.data_kind)
      end
   end

   read_finalize
   ! Read whether to finalize the object.
      stdin.read(.finalize)
   end

   read_r_free_percentage
   ! Read the R free percentage
      stdin.read(.r_free_percentage)
      DIE_IF(.r_free_percentage<0,  "percentage must be non-negative")
      DIE_IF(.r_free_percentage>100,"percentage must be less than 100")
   end

   read_spacegroup ::: leaky
   ! Read the spacegroup
      .spacegroup.read_keywords
      .spacegroup.analyse
   end

   read_unit_cell 
   ! Read the unit cell information
      .unit_cell.read_keywords
      .unit_cell.make_info
   end

   read_xray_data ::: leaky
   ! Read in the xray diffraction data
      WARN_IF(.xray_data.created,"xray diffraction data already defined!")
      if (.xray_data.destroyed) .xray_data.create
      .xray_data.read_keywords
      .xray_data.update
      if (.xray_data.created) then
         .assign_xray
         if (.xray_data.reflections.created) .prune_negative_F_exp
      end
   end

   read_pnd_data ::: leaky
   ! Read in the pnd diffraction data
      WARN_IF(.pnd_data.created,"pnd diffraction data already defined!")
      if (.pnd_data.destroyed) .pnd_data.create
      .pnd_data.data_kind = "pnd"
      .pnd_data.read_keywords
      .pnd_data.update
      if (.pnd_data.created) .assign_pnd
   end

   read_use_manual_rep_factors ::: leaky, private
   ! Read whether to use manually entered repetition factors.
   ! If set set FALSE, the repetition factors will be destroyed.
     stdin.read(.use_manual_repetition_factors)
     if (.use_manual_repetition_factors) return
     .repetition_factor.destroy
   end

   read_repetition_factors ::: leaky, private
   ! Read in the crystal fragment repetition factors. Useful to get structure
   ! factor contributions from a small portion of the fragment.
     .repetition_factor.destroy
     stdin.read_ptr(.repetition_factor)
     .use_manual_repetition_factors = TRUE
   end

   read_prune_asymmetric_unit ::: private
   ! Read whether to prune the asymmetric unit or not. Sometimes the asymmetric
   ! unit may not be asymmetric i.e. it may have symmetry-equivalent atoms
   ! repeated. This could be because of an input or CIF file error, or it could
   ! be genuinely correct because the repeated atom corresponds to a disordered
   ! position. For Hirshfeld surface plots, which can cope with disorder, you
   ! probably do not want to prune the asymmetric atom list, but for crystal
   ! calculations you must do so.
      stdin.read(.prune_asymmetric_unit)
   end

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File object, with
   ! the "name" taken from stdin.
      name :: STR
      found :: BIN
      cif :: CIF*
      stdin.read(name)
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 
      .read_CIF(cif)
      cif.destroy
   end

   read_CIF(cif,skip_atoms) ::: leaky
   ! Read information from a Crystallographic Information File object, "cif".
   ! If "skip_atoms" is present and TRUE, the atom coordinates are not processed.
      cif :: CIF
      skip_atoms :: BIN, optional
      skip,found :: BIN
      itemvec :: VEC{STR}*

      skip = FALSE
      if (present(skip_atoms)) skip = skip_atoms

      .set_defaults

      ! Read the chemical formula if it is there
      nullify(itemvec)
      cif.read_item("_chemical_formula_sum",.CIF_chemical_formula,itemvec,found)
      if (NOT found) .CIF_chemical_formula = "?"
      DIE_IF(itemvec.created,"multi line chemical formula")

      ! Read the spacegroup and unit cell and atom list (if requested)
      .spacegroup.read_CIF(cif)
      .unit_cell.read_CIF(cif)
      if (NOT skip) .read_CIF_atoms(cif)

      .update

   end

   read_CIF_atoms(cif) ::: leaky, private
   ! Read atom information from a CIF file, "cif"
      cif :: CIF
      ID :: STR
      fs,fx,fy,fz :: BIN
      labels :: VEC{STR}*
      x,y,z :: VEC{REAL}*
      n :: INT
      ID = "_atom_site_type_symbol"
      cif.find_looped_item(trim(ID),fs)
      if (NOT fs) then
      ID = "_atom_site_label"
      cif.find_looped_item(trim(ID),fs)
      end
      cif.find_looped_item("_atom_site_fract_x",fx)
      cif.find_looped_item("_atom_site_fract_y",fy)
      cif.find_looped_item("_atom_site_fract_z",fz)
      ENSURE(fs AND fx AND fy AND fz,"incomplete atom information in CIF file")
      cif.read_looped_item(trim(ID),labels)
      cif.read_looped_item("_atom_site_fract_x",x)
      cif.read_looped_item("_atom_site_fract_y",y)
      cif.read_looped_item("_atom_site_fract_z",z)
      ! Assign the CIF info
      n = labels.dim
      .n_asymmetric_unit_atoms = n
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,n)
      .asymmetric_unit_geometry(1,:) = x
      .asymmetric_unit_geometry(2,:) = y
      .asymmetric_unit_geometry(3,:) = z
      z.destroy; y.destroy; x.destroy
      labels.destroy
   end

   read_asymmetric_unit_geometry
   ! Read in the asymmetric unit geometry in crystal coordinates.
   ! The coordinates are read in as a single vector ordered as x,y,z
   ! incrementing fastest, for the first to the last atom.
      geometry :: VEC{REAL}*
   WARN_IF(.asymmetric_unit_geometry.created,"asymmetric_unit_geometry exists!")
      stdin.read_ptr(geometry)
      ENSURE(modulo(geometry.dim,3)==0,"number of coordinates must be divisible by 3")
      .n_asymmetric_unit_atoms = geometry.dim/3
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,.n_asymmetric_unit_atoms)
      .asymmetric_unit_geometry = reshape(geometry,[3,.n_asymmetric_unit_atoms])
      geometry.destroy
   end

   set_asymmetric_unit_geometry(geometry) ::: leaky
   ! Set the asymmetric unit geometry from a CARTESIAN "geometry".
   ! This is useful if the atomic coordinates have been processed from
   ! a CIF elsewhere, e.g. in the VEC{ATOM} module.
      geometry :: MAT{REAL}

   ENSURE(geometry.dim1==3,"wrong 1st dimensions, geometry")

      .destroy_asymmetric_unit

      .n_asymmetric_unit_atoms = geometry.dim2
      .asymmetric_unit_geometry.create(3,geometry.dim2)
      .asymmetric_unit_geometry = matmul(.unit_cell.inverse_matrix,geometry)

   end

   set_asymmetric_unit_geometry(atom) ::: leaky
   ! Set the asymmetric unit geometry from a list of the asymmetric
   ! units "atoms". NOTE: coordinates must be cartesian.
      atom :: VEC{ATOM}

   ENSURE(.unit_cell.info_made,"no unit cell info")

      n,a :: INT

      .destroy_asymmetric_unit

      n = atom.dim
      .n_asymmetric_unit_atoms = n
      .asymmetric_unit_geometry.create(3,n)

      ! Assign the positions; convert to crystal axis system
      do a = 1,n
         .asymmetric_unit_geometry(:,a) = matmul(.unit_cell.inverse_matrix,atom(a).pos)
      end

   end

!  ***************
!  General methods
!  ***************

   make_k_pts(res)
   ! Convert the .reflection.hkl indices to reciprocal lattice vectors
   ! Dimension of res is [.n_refl,3]
      res :: MAT{REAL}
       n :: INT
      hkl :: VEC{INT}(3)
      rcm :: MAT{REAL}(3,3)
      rcm = TWO*PI*.unit_cell.reciprocal_matrix
      do n = 1, .data.reflections.n_refl
         hkl = .data.reflections.indices(n)
         res(n,1) = dot_product(rcm(1,:),hkl(:))
         res(n,2) = dot_product(rcm(2,:),hkl(:))
         res(n,3) = dot_product(rcm(3,:),hkl(:))
      end
   end

   n_unique_SF_k_pts result (res) ::: pure
   ! The number of unique k-points for an SF calculation
     self :: IN
     res :: INT
   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")
     res = .spacegroup.n_unique_SF_symops * .data.reflections.dim
   end

   make_unique_SF_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! for structure factor calculations.
   ! (c) Dylan Jayatilaka, UWA, feb 1996
      k :: MAT{REAL}

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.spacegroup.unique_SF_symop.created,"no unique_SF_symop array!")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")
   ENSURE(k.dim1==.n_unique_SF_k_pts,"wrong dim1, k")
   ENSURE(k.dim2==3,"wrong dim2, k")

      p,u,n :: INT
      b,rcm,symop :: MAT{REAL}(3,3)
      hkl :: VEC{INT}(3)

      rcm = TWO*PI*.unit_cell.reciprocal_matrix

      p = 0
      do u = 1,.spacegroup.n_unique_SF_symops

         symop = .spacegroup.unique_SF_symop_mat(u)
         symop = transpose(symop)
         b = matmul(rcm,symop)

         do n = 1,.data.reflections.dim
            p = p + 1
            hkl(1) = .data.reflections(n).h
            hkl(2) = .data.reflections(n).k
            hkl(3) = .data.reflections(n).l
            k(p,1) = dot_product(b(1,:),hkl)
            k(p,2) = dot_product(b(2,:),hkl)
            k(p,3) = dot_product(b(3,:),hkl)
         end

      end

   end

!  ****************************
!  Structure refinement methods
!  ****************************

   d_chi2_dX(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters.  NOTE: this routine assumes that the .scale_factor
   ! and .extinction_factor are fixed.
     res :: VEC{REAL}, OUT
     dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
     .data.d_chi2_dX(res,dFdX)
   end

   d_chi2_dX_plus_se(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters. Two extra derivatives are included, w.r.t. the
   ! extinction parameter and the scale factor.
     res :: VEC{REAL}, OUT
     dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
     .data.d_chi2_dX_plus_se(res,dFdX)
   end

   d_F_abs_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors  w.r.t. the X
   ! parameters. 
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.d_F_abs_dX(res,dFdX)
   end

   solve_normal_equations(shifts,dFdX)
   ! Get the "shifts" in the parameters by solving the normal
   ! equations, given "F" and "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters. "max_shift" is
   ! returned to see the maximum shift before rescaling by
   ! .max_allowed_shift_normal. "n_0" is the number of eigenvalues
   ! equal to zero (as determined by .tol_0) and "n_near_0" is the
   ! number of eigenvalues nearly equal to zero (as determined by
   ! .tol_near_0).
      shifts :: VEC{REAL}, OUT
      dFdX :: MAT{REAL}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.solve_normal_equations(shifts,dFdX)
   end

   initialise_refinement
   ! Put out the normal equations banner
   ENSURE(.data_exists,"no diffraction data")
      n_p :: INT
      n_p = 9*.asymmetric_unit_atom.dim
      .data.initialise_refinement(n_p)
      .data.put_refinement_params
      .put_refinement_results(no_correlations=TRUE)
      .data.put_iteration_header
   end

   put_iteration_results
   ! Print out the current iterations results
   ! WARNING: it increments the iteration count
   ENSURE(.data_exists,"no diffraction data")
      .data.put_iteration_results
   end

   finalise_refinement
   ! Finalise refinement, write results
   ENSURE(.data_exists,"no diffraction data")
      .data.finalise_refinement
   end

   put_refinement_results(no_correlations)
   ! Write refinement results
      no_correlations :: BIN, optional

   ENSURE(.data_exists,"no diffraction data")

      label :: VEC{STR}(9) = [" Rx"," Ry"," Rz","Uxx","Uyy","Uzz","Uxy","Uxz","Uyz"]
      delta_p :: VEC{REAL}*
      CM :: MAT{REAL}*
      atom,atom_i,atom_j :: ATOM*
      n_atom,n_p,a,ai,aj,k,i,j,ii,jj,n,e :: INT
      p,d,min_corr :: REAL
      no_correlation :: BIN

      ! Whether to print the parameter corelation matrix
      no_correlation = .data.display_correlation_matrix
      if (present(no_correlations)) no_correlation = no_correlations

      ! Constants
      n_atom = .asymmetric_unit_atom.dim
      n_p    = 9*n_atom

      ! Parameter errors
      delta_p => .data.delta_p

      ! Dump parameters and errors
      stdout.flush
      stdout.text("Positional parameters and errors (in angstrom):")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Asym",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Label",int_width=TRUE)
      stdout.put("Rx");  stdout.put("Ry");  stdout.put("Rz")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      k = -9
      do a = 1,n_atom
         stdout.put(a)
         atom => .asymmetric_unit_atom(a)
         stdout.put(atom.label,int_width=TRUE)

         k = k + 9

         .get_precision_and_error(atom.pos(1),delta_p(k+1),p,d,n,e,angstrom=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         .get_precision_and_error(atom.pos(2),delta_p(k+2),p,d,n,e,angstrom=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         .get_precision_and_error(atom.pos(3),delta_p(k+3),p,d,n,e,angstrom=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         stdout.flush

      end
      stdout.dash(int_fields=2,real_fields=3)

      stdout.flush
      stdout.text("ADPs and errors (in angstrom^2):")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      stdout.put("Asym",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Label",int_width=TRUE)
      stdout.put("Uxx"); stdout.put("Uyy"); stdout.put("Uzz")
      stdout.put("Uxy"); stdout.put("Uxz"); stdout.put("Uyz")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=6)
      k = -9
      do a = 1,n_atom
         stdout.put(a)
         atom => .asymmetric_unit_atom(a)
         stdout.put(atom.label,int_width=TRUE)

         k = k + 9

         .get_precision_and_error(atom.thermal_tensor(1,1),delta_p(k+4),p,d,n,e,angstrom2=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         .get_precision_and_error(atom.thermal_tensor(2,2),delta_p(k+5),p,d,n,e,angstrom2=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         .get_precision_and_error(atom.thermal_tensor(3,3),delta_p(k+6),p,d,n,e,angstrom2=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         .get_precision_and_error(atom.thermal_tensor(1,2),delta_p(k+7),p,d,n,e,angstrom2=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         .get_precision_and_error(atom.thermal_tensor(1,3),delta_p(k+8),p,d,n,e,angstrom2=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         .get_precision_and_error(atom.thermal_tensor(2,3),delta_p(k+9),p,d,n,e,angstrom2=TRUE)
         stdout.put(p,precision=n,width=(stdout.real_width-3))
         stdout.put("("//trim(e.to_str)//")",width=3)

         stdout.flush

      end
      stdout.dash(int_fields=2,real_fields=6)


      if (no_correlation) return

      ! Dump large correlation matrix elements
      CM => .data.correlation_matrix
      min_corr = .data.min_correlation

      stdout.flush
      stdout.text("Large correlations:")
      stdout.flush
      stdout.show("Minimum correlations to display =",min_corr)
      stdout.flush
      stdout.dash(int_fields=6,real_fields=1)
      stdout.tab(int_fields=6)
      stdout.put("Correlation")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.tab(int_fields=2)
      stdout.put("Atom",int_width=TRUE)
      stdout.tab(int_fields=2)
      stdout.put("Coefficient")
      stdout.flush
      stdout.dash(int_fields=6,real_fields=1)
      do i = 1,n_p
      do j = 1,i
         if (CM(i,j)<min_corr) cycle
         if (CM(i,j)>0.9999d0) cycle
         ai = (i-1)/9 + 1
         aj = (j-1)/9 + 1
         atom_i => .asymmetric_unit_atom(ai)
         atom_j => .asymmetric_unit_atom(aj)
         ii = modulo(i-1,9) + 1
         jj = modulo(j-1,9) + 1
         stdout.put(ai)
         stdout.put(atom_i.label,int_width=TRUE)
         stdout.put(label(ii),int_width=TRUE)
         stdout.put(aj)
         stdout.put(atom_j.label,int_width=TRUE)
         stdout.put(label(jj),int_width=TRUE)
         stdout.put(CM(i,j))
         stdout.flush
      end
      end
      stdout.dash(int_fields=6,real_fields=1)

      if (NOT .data.display_near_0_eigenvectors) return

      ! Dump zero eigenvalue information
      stdout.flush
      stdout.text("Near 0 eigenvalues of the normal matrix:")
      stdout.put(.data.near_0_eigenvalues,"column")
      stdout.flush
      stdout.text("Near 0 eigenvectors of the normal matrix:")
      stdout.put(.data.near_0_eigenvectors)

   end

   get_precision_and_error(value,error,p,d,n,e,angstrom,angstrom2) ::: private
   ! Get the precision and error for CIF style error output
      value,error :: REAL, IN
      p,d :: REAL, OUT
      n,e :: INT, OUT
      angstrom,angstrom2 :: BIN, optional

      p = value
      d = error

      if (present(angstrom)) then
      if (angstrom) then
         p = p.to_units("angstrom")
         d = d.to_units("angstrom")
      end
      end

      if (present(angstrom2)) then
      if (angstrom2) then
         p = p.to_units("angstrom^2")
         d = d.to_units("angstrom^2")
      end
      end

      if (d.equals(ZERO)) then
         n = stdout.real_precision-3
         e = nint(d*10**n)
      else
         n = min(abs(floor(log10(d))),stdout.real_precision-3)
         e = nint(d*10**n)
      end

   end
 
   refinement_finished(chi2_increased,too_many,converged) result (res)
   ! Return whether the refinement has finished
      chi2_increased,too_many,converged :: BIN, OUT, optional
      res :: BIN
   ENSURE(.data_exists,"no diffraction data")
      res = .data.refinement_finished(chi2_increased,too_many,converged)
   end

!  *************************************
!  Service methods used by other modules
!  *************************************

   sum_unique_sf(sf,unique_sf)
   ! Form the structure factors "sf" from the sum of the list of
   ! unique structure factors, "unique_sf".
     sf :: VEC{CPX}
     unique_sf :: VEC{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

     .spacegroup.sum_unique_sf(sf,unique_sf,.data.reflections)
   end

   sum_unique_sf_ints(sf_ints,unique_sf_ints)
   ! Form the structure factor integrals "sf_ints" from a sum of the list
   ! of unique structure factors integrals  "unique_sf_ints".
     sf_ints :: MAT3{CPX}
     unique_sf_ints :: MAT3{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

     .spacegroup.sum_unique_sf_ints(sf_ints,unique_sf_ints,.data.reflections)
   end

   sum_ft_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints" from a sum of the list
   ! of unique integrals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b].
     ft_ints :: MAT3{CPX}
     unique_ft_ints :: MAT3{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")
   
     .spacegroup.sum_ft_ints(ft_ints,unique_ft_ints,.data.reflections)
   end

   sum_unique_sf_derivs(sf,unique_sf)
   ! Form the structure factor derivatives "sf" from a sum of the list
   ! of unique structure factor derivatives "unique_sf".
     sf :: MAT{CPX}, OUT
     unique_sf :: MAT{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

     .spacegroup.sum_unique_sf_derivs(sf,unique_sf,.data.reflections)
   end

   sum_unique_sf_derivs_t(sf,unique_sf)
   ! Form the structure factor derivatives "sf" from a sum of the list
   ! of unique structure factor derivatives "unique_sf".
     sf :: MAT{CPX}, OUT
     unique_sf :: MAT{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

     .spacegroup.sum_unique_sf_derivs_t(sf,unique_sf,.data.reflections)
   end

! Don't delete code below just yet ...

!   make_phased_matrix_for_symop(u,phase,mask) ::: private
!   ! Return the sum of the "phase" shifts times the seitz matrices for all
!   ! symops which are equivalent to the "u"-th unique symmetry operation,
!   ! .spacegroup.unique_SF_symop(u), as determined by the "mask" array, when
!   ! mask(u)==.spacegroup.unique_SF_symop(u).
!     u :: INT, IN
!     phase :: MAT3{CPX}, OUT
!     mask :: VEC{INT}, IN
!
!   ENSURE(.spacegroup.analysed,"no spacegroup")
!   ENSURE(u<=.spacegroup.n_unique_SF_symops,"symop index out of range")
!   ENSURE(phase.dim1==.data.reflections.n_refl,"wrong size, dim=1, phase array")
!   ENSURE(phase.dim2==3,"wrong size, dim=2, phase array")
!   ENSURE(phase.dim3==3,"wrong size, dim=3, phase array")
!
!     pi2,tx,ty,tz,dot :: REAL
!     s,n,n_refl,h,k,l :: INT
!     seitz :: MAT{REAL}(4,4)
!     refl :: VEC{REFLECTION}*
!
!     refl => .data.reflections
!     n_refl = refl.dim
!     pi2 = TWO*PI
!
!     phase = ZERO
!     do s = 1,.spacegroup.n_seitz
!
!       ! Sum only those which match unique symop u
!       if (mask(s)/=.spacegroup.unique_SF_symop(u)) cycle
!
!       ! Get the symop translation vector
!       seitz = .spacegroup.seitz(:,:,s)
!       tx = pi2*seitz(1,4)
!       ty = pi2*seitz(2,4)
!       tz = pi2*seitz(3,4)
!
!       ! Sum the phase here
!       ! This seems a kludge because we don't know the magnetic symmetry
!       if (seitz(3,3)>0) then                  ! M points along +z always
!         do n = 1,n_refl
!           h = refl(n).h
!           k = refl(n).k
!           l = refl(n).l
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       else                                    ! M points in -z direction
!         seitz(3,:3) = -seitz(3,:3)            ! Invert
!         do n = 1,n_refl
!           h = refl(n).h
!           k = refl(n).k
!           l = refl(n).l
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       end
!
!     end
!
!   end
!
!   sum_PND_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phased_matrix_for_symop(u,phase,.spacegroup.translated_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              unique_ft_ints(uf+n,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phased_matrix_for_symop(u,phase,.spacegroup.inverted_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!        end
!
!     end
!     phase.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S=sigma/2 operator, and g_e x mu_B = 1.
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_PND_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a_3 integrals "ft_ints", required for the
!   ! PND magnetic structure factors, from a sum of "unique_ft_ints".
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT3{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phased_matrix_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*unique_ft_ints(uf+n,:,:,1) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*unique_ft_ints(uf+n,:,:,2) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*unique_ft_ints(uf+n,:,:,3)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phased_matrix_for_symop(u,phase,mask=.spacegroup.translated_symop) ! .inverted_symop here ??????????????
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*conjg(unique_ft_ints(uf+n,:,:,1)) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*conjg(unique_ft_ints(uf+n,:,:,2)) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*conjg(unique_ft_ints(uf+n,:,:,3))
!       end
!     end
!     phase.destroy
!
!     ! The factor of 2 to convert to Bohr magnetons cancels the factor
!     ! of 1/2 for the Bohr magneton.
!     do n = 1,n_refl
!       ft_ints(n,:,:) = ft_ints(n,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_ft_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.n_refl,n_comp_a,n_comp_b,3,3].
!     ft_ints :: MAT5{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT{CPX}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:)
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     do n = 1,n_refl
!        ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
!   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!     B :: VEC{REAL}(3)
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT3{CPX}*
!     u,uf,n,n_refl :: INT
!     ci :: CPX
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     ci = (ZERO,ONE)
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
!   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!      ft_ints :: MAT4{CPX}
!      unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!      phase :: VEC{CPX}*
!      q :: MAT{REAL}*
!      ints :: MAT3{CPX}*
!      u,uf,n,n_refl :: INT
!
!      n_refl = .data.reflections.n_refl
!      phase.create(n_refl)
!      q.create(n_refl,3)
!      ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!      .make_k_pts(q)
!
!      ft_ints = ZERO
!      do u = 1,.spacegroup.n_unique_SF_symops
!
!         uf = n_refl*(u-1)
!
!         ! Add up translated symop contribution
!         .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!         do n = 1,n_refl
!            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!         ! Add up inverted symop contribution, if any
!         if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!         .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!         do n = 1,n_refl
!            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!      end
!      ints.destroy
!
!      ! The factor of 2 to convert to Bohr magnetons cancels the factor
!      ! of 1/2 for the Bohr magneton
!      ! Extra minus sign introduced, but not sure why ...
!      ! Reversed minus sign introduced ...
!      do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!      end
!      q.destroy
!      phase.destroy
!
!   end
!
!   sum_ft_j_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform j integrals "ft_ints", required for the PND
!   ! magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     u,uf, n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
!        end
!
!     end
!     phase.destroy
!
!   end

!  *****************************************
!  Fragment data, Unique operators, Z number
!  *****************************************

   make_fragment_data(atom,warnings) ::: leaky
   ! This routine sets the ".fragment_geometry" from the "atom" list.
   ! The fragment is a portion or model of the crystal, perhaps one
   ! molecule or a cluster of atoms. Then:
   ! A. The .asymmetric_unit_geometry is defined from the symmetry
   !    unique "atoms", if it is not already defined. If it is already
   !    defined the fragment atoms must be symmetry related to these
   !    asymmetric unit atom positions. The asymmetric unit is crucial
   !    NOTE: The .asymmetric_unit_geometry is never destroyed
   ! B. The .asymmetric_unit_atom array is defined from the "atom"
   !    list if possible, This array is never destroyed unless
   !    explicitly requested.
   ! 1. The .unit_cell_geometry is made from the asymmetric unit. 
   !    Mapping arrays which relate the unit cell atoms to the
   !    asymmetric unit atoms are made, 
   ! 2. Other mapping arrays are made which relate the fragment atoms
   !    to the unique asymmetric unit atoms, including sometimes the
   !    symops needed to generate them.
   ! 3. The .repetition factors needed for structure factor calcs on
   !    the fragment are made. The Z number is made.
   !    unchanged (the stabilizer) is made
   ! 4. The unit cell connection table is made.
   ! 5. The set of symmetry operations which leave the fragment
   !    unchanged (the stabilizer) is made
      self :: PTR
      atom :: VEC{ATOM}, IN
      warnings :: BIN, optional

   ENSURE(.created,"self not created")

      if (NOT .spacegroup.analysed) return

      ! Get fragment geometry from the atom list
      .n_fragment_atoms = size(atom)
      .fragment_geometry.destroy
      .fragment_geometry.create(3,.n_fragment_atoms)
      atom.get_geometry(.fragment_geometry)
      .unit_cell.change_into_fractional(.fragment_geometry)

      ! If not there, make the asymmetric unit ...
      if (.asymmetric_unit_geometry.destroyed) then
          .asymmetric_unit_geometry.create_copy(.fragment_geometry)
          .n_asymmetric_unit_atoms = .n_fragment_atoms
      end

      ! Prune asymmetric unit and make the unit cell
      .make_unit_cell_geometry(.prune_asymmetric_unit,warnings)

      ! Relate fragment atoms to unit cell
      .make_frag_atom_for_cell_atom

      ! Make unique fragment atoms
      .make_unique_frag_atoms 

      ! Make the unit cell connection table
      .make_unit_cell_connections(atom)

      ! If not there, copy the asymmetric unit atoms (if we can)
      if (.asymmetric_unit_atom.destroyed) then
      if (all(.frag_atom_for_asym_unit_atom/=0)) then
         .asymmetric_unit_atom.create_copy(atom(.frag_atom_for_asym_unit_atom))
      end
      end

      ! Z factors and zep. factors for SF calculations
      .make_repetition_factors     
      .make_asym_atom_rep_factors     
      .Z = .z_factor

      ! Symops which leave fragment_geometry unchanged
      .make_stabilizer_symops 
      .make_stabilizer_xyz_matrices 

      .fragment_info_made = TRUE

   end

   make_fragment_data(fragment_geometry,cartesian) ::: leaky
   ! This routine sets the ".fragment_geometry" from a list a
   ! *fractional* atom positions "fragment_geometry". The asymmetric unit
   ! is not set; it should already be there. Hence no unit cell stuff
   ! is done again. Otherwise this is the same as the routine above.
      self :: PTR
      fragment_geometry :: MAT{REAL}, IN
      cartesian :: BIN, optional

   ENSURE(.created,"self not created")
   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric_unit_geometry")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atoms")

      cart :: BIN

      if (NOT .spacegroup.analysed) return

      cart = FALSE
      if (present(cartesian)) cart = cartesian

      ! Copy fragment geometry
      .n_fragment_atoms = fragment_geometry.dim2
      .fragment_geometry.destroy
      .fragment_geometry.create_copy(fragment_geometry)
      if (cart) &
      .unit_cell.change_into_fractional(.fragment_geometry)

      ! Relate fragment atoms to unit cell
      .make_frag_atom_for_cell_atom

      ! Make unique fragment atoms
      .make_unique_frag_atoms 

      ! Z factors and zep. factors for SF calculations
      .make_repetition_factors     
      .Z = .z_factor

      ! Symops which leave fragment_geometry unchanged
      .make_stabilizer_symops 
      .make_stabilizer_xyz_matrices 

      .fragment_info_made = TRUE

   end

   make_unit_cell_geometry(prune_asymmetric_unit,warnings) ::: leaky, private
   ! Get the all the atom positions in the unit cell. Also make the
   ! symops associated with each unit cell atom when it is made from
   ! the asymmetric unit atoms. If "prune_asymmetric_unit" is present
   ! and true, any non-asymmetric unit atoms are eliminated from the
   ! asymmetric unit. This should always be done.
      prune_asymmetric_unit,warnings :: BIN, optional

   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit geometry") 
   ENSURE(.n_asymmetric_unit_atoms>0,"no asymmetric unit atoms") 

      pa :: VEC{REAL}(3)
      asymmetric_unit_geometry :: MAT{REAL}*
      n,a,m,s,col :: INT
      prune,warn,found,unique,disorder :: BIN
      tol :: REAL

      ! Set default options
      prune = TRUE
      warn = TRUE
      if (present(prune_asymmetric_unit)) prune = prune_asymmetric_unit
      if (present(warnings)) warn = warnings

      ! Clean up from before
      .unit_cell_geometry.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .symop_for_unit_cell_atom.destroy

      ! Take a copy, put it to the unit cell
      asymmetric_unit_geometry.create_copy(.asymmetric_unit_geometry)
      .put_to_unit_cell(asymmetric_unit_geometry)

      ! Append new atoms "n" to unit cell
      nullify(.unit_cell_geometry)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = TOL(2)/maxval(.unit_cell.length) 
      tol = TOL(3)

      ! Initial loop counters
      disorder = FALSE
      n = 0
      a = 1

      ! Loop: atoms "a" in the asymmetric unit
      do ! a = 1,.n_asymmetric_unit_atoms

         ! Loop over symops
         do s = 1,.spacegroup.n_seitz

            ! <<< Transform asym unit with symop >>>
            pa = asymmetric_unit_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)

            ! Is the new position already in the asymmetric unit?
            unique = NOT asymmetric_unit_geometry(:,a+1:).has_column(pa,tol,col)

            ! If not new, we may have to prune ...
            if (NOT unique) then

               col = col + a
               disorder = TRUE

               if (prune) then

                  do ! Prune all repetitions

                     m = max(a,col)

                     .n_asymmetric_unit_atoms = .n_asymmetric_unit_atoms - 1
                     .asymmetric_unit_geometry.prune_column(m)
                      asymmetric_unit_geometry.prune_column(m)

                     unique = NOT asymmetric_unit_geometry(:,a+1:).has_column(pa,tol,col)
                     if (unique) exit
                     col = col + a
                  end

               end

            end ! -- NOT unique

            ! Is the new position already in the unit cell?
            found = FALSE
            if (.unit_cell_geometry.created) &
               found = .unit_cell_geometry.has_column(pa,tol)

            if (found) cycle

           ! New unit cell atom here ...
            n = n + 1 
            .unit_cell_geometry.append_column(pa)
            .asym_atom_for_unit_cell_atom.append(a)
            .symop_for_unit_cell_atom.append(s)

         end

         ! Next asymmetric unit atom
         a = a + 1
         if (a>.n_asymmetric_unit_atoms) exit

      end

      .n_unit_cell_atoms = n
      asymmetric_unit_geometry.destroy

      WARN_IF(warn AND disorder,"This structure may be disordered")
      WARN_IF(warn AND disorder AND prune,"I had to prune redundant atoms from the unit cell")
      ENSURE(.unit_cell_geometry.created,"could not make unit_cell_geometry")

   end

   make_frag_atom_for_cell_atom ::: leaky, private
   ! Arrays which relate the fragment atoms to the unit cell atoms.
   ENSURE(.fragment_geometry.created,"no .fragment_geometry") 
   ENSURE(.unit_cell_geometry.created,"no .unit_cell_geometry") 
   ENSURE(.asym_atom_for_unit_cell_atom.created,"no .asym_atom_for_unit_cell_atom")

      pu,pf :: VEC{REAL}(3)
      u,c,f,a :: INT
      found :: BIN
      tol :: REAL

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)    

      ! Create the arrays we want
      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .frag_atom_for_asym_unit_atom.destroy
      .asym_unit_atom_for_frag_atom.destroy

      .frag_atom_for_unit_cell_atom.create(.n_unit_cell_atoms)
      .unit_cell_atom_for_frag_atom.create(.n_fragment_atoms)
      .frag_atom_for_asym_unit_atom.create(.n_asymmetric_unit_atoms)
      .asym_unit_atom_for_frag_atom.create(.n_fragment_atoms)

      ! Initialise
      .frag_atom_for_unit_cell_atom = 0
      .unit_cell_atom_for_frag_atom = 0
      .frag_atom_for_asym_unit_atom = 0
      .asym_unit_atom_for_frag_atom = 0

      ! Loop over fragment atoms
      do f = 1,.n_fragment_atoms

         ! Shift fragment atom to unit cell
         pf = .fragment_geometry(:,f)
         .put_to_unit_cell(pf)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            pu = .unit_cell_geometry(:,u)
            found = pu.same_as(pf,tol)

            ! Match unit cell atom to fragment atom
            if (NOT found) cycle

            ! Relate unit cell atom and fragment atom
            ! These are identical by translation.
            .frag_atom_for_unit_cell_atom(u) = f
            .unit_cell_atom_for_frag_atom(f) = u

            ! Relate asym unit atom and fragent atom
            ! Maybe >1 frag atom  matching the asym atom
            a = .asym_atom_for_unit_cell_atom(u)
            .asym_unit_atom_for_frag_atom(f) = a
            if (.frag_atom_for_asym_unit_atom(a)==0) &
                .frag_atom_for_asym_unit_atom(a) = f


            exit 

         end

         DIE_IF(NOT found,"fragment atom "//f.to_str.trim//" was not found in the unit cell")

      end

      ! Relate unit cell atom to parent frag atom
      ! These are identical by a crystal symop.
      .frag_parent_for_cell_atom.destroy
      .frag_parent_for_cell_atom.create(.n_unit_cell_atoms)
      do u = 1,.n_unit_cell_atoms
         a = .asym_atom_for_unit_cell_atom(u)
         f = .frag_atom_for_asym_unit_atom(a)
         .frag_parent_for_cell_atom(u) = f
      end

   end

   make_unique_frag_atoms ::: leaky, private
   ! Make the unique fragment atoms (these are those corresponding to
   ! the asymmetric unit atoms) and also make symops which relate the
   ! non-unique to the unique.
   ENSURE(.asym_unit_atom_for_frag_atom.created,"no .asym_unit_atom_for_frag_atom") 
   ENSURE(.unit_cell_atom_for_frag_atom.created,"no .unit_cell_atom_for_frag_atom") 
   ENSURE(.symop_for_unit_cell_atom.created,"no .symop_for_unit_cell_atom") 

      pa,pf :: VEC{REAL}(3)
      f,a,m,u,s :: INT
      unique :: BIN
      tol :: REAL

      ! Create the arrays we want
      .unique_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_shift_for_frag_atom.destroy

      .unique_atom_for_frag_atom.create(.n_fragment_atoms)
      .asym_symop_for_frag_atom.create(.n_fragment_atoms)
      .asym_shift_for_frag_atom.create(3,.n_fragment_atoms)

      .n_unique_frag_atoms = 0

      ! Loop over the fragment atoms
      do f = 1,.n_fragment_atoms

         ! Asym atom for this fragment atom
         a = .asym_unit_atom_for_frag_atom(f)

         ! Does this asym atom "a" occur before? If not, its unique.
         m = .asym_unit_atom_for_frag_atom(1:f-1).index_of_value(a)
         unique = m==0
         if (unique) then
            .n_unique_frag_atoms = .n_unique_frag_atoms + 1
            .unique_atom_for_frag_atom(f) = f
            .unique_frag_atom.append(f)
         else
            .unique_atom_for_frag_atom(f) = m
         end

         ! Asym symop
         u = .unit_cell_atom_for_frag_atom(f)
         s = .symop_for_unit_cell_atom(u)
         .asym_symop_for_frag_atom(f) = s

         ! Get shift for asym atom -> frag atom
         pa = .asymmetric_unit_geometry(:,a)
         pf = .fragment_geometry(:,f)
         .transform_position(pa,s,ignore_glide=TRUE)
         .asym_shift_for_frag_atom(:,f) = pf - pa

      end

   end

   make_unit_cell_connections(atom) ::: leaky
   ! From the fragment "atom" list make the .unit_cell_connection
   ! table and the .unit_cell_mol_for_atom list which has the list of
   ! distinct molecules in the unit cell i.e. those groups of unit
   ! cell atoms which are connected to each other (ignoring
   ! translational symmetry).  NOTE: unconnected atoms have a nullifed
   ! connection lists NOT a zero dimenion one.
      atom :: VEC{ATOM}, IN

   ENSURE(.unit_cell_geometry.created,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.created,"no frag_parent_for_cell_atom")
   DIE_IF(any(.frag_parent_for_cell_atom==0),"fragment doesn't generate unit cell")

     new :: VEC{VEC_{INT}}*
     unit_cell_mol_for_atom,unique :: VEC{INT}*
     geom0,geom1 :: MAT{REAL}*
     rcm :: MAT{REAL}(3,3)
     pos_i,pos_j,offset :: VEC{REAL}(3)
     i,j,par_i,par_j, h1,h2,h3, mi,mj :: INT
     atom_i,atom_j :: ATOM

     ! Create the arrays we want
     .unit_cell_connection.destroy
     .unit_cell_mol_for_atom.destroy

     .unit_cell_connection.create(.n_unit_cell_atoms)
     .unit_cell_mol_for_atom.create(.n_unit_cell_atoms)

     ! Set worst case scenario: all atoms on different molecules
     unit_cell_mol_for_atom.create(.n_unit_cell_atoms)
     do i = 1,.n_unit_cell_atoms         
        unit_cell_mol_for_atom(i) = i
     end

     ! Define a new connected atom: its index and 3-element shift
     new.create(1)
     new(1).element.create(4)           

     ! Get unit cell cartesian geometry
     rcm = .unit_cell.direct_matrix
     geom0.create(3,.n_unit_cell_atoms)  
     geom0 = matmul(rcm,.unit_cell_geometry)

     ! First make connections in the unit cell
     ! and the distinct mols
     h1 = 0                             
     h2 = 0                             
     h3 = 0

        ! Loop over the (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms      

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .frag_parent_for_cell_atom(i) 
           atom_i.atomic_number = atom(par_i).atomic_number
           atom_i.pos = pos_i

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i) 

           ! Loop over the (0,0,0) unit cell atoms 
           do j = i+1,.n_unit_cell_atoms 

              ! Gross test for closeness
              pos_j = geom0(:,j)        
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle 

              ! It could be close: Set atom_j
              par_j = .frag_parent_for_cell_atom(j) 
              atom_j.atomic_number = atom(par_j).atomic_number
              atom_j.pos = pos_j

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              new(1)[:] = [h1,h2,h3,j]; .unit_cell_connection(i).element.append(new)
              new(1)[4] = i;            .unit_cell_connection(j).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)

              ! Replace all previous by the lowest mol
              if (mj<mi) then        
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end

     ! <<< Now make connections to neighbouring cells
     geom1.create(3,.n_unit_cell_atoms) 
     do h1 = -1,1                       
     do h2 = -1,1
     do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms     

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .frag_parent_for_cell_atom(i) 
           atom_i.atomic_number = atom(par_i).atomic_number
           atom_i.pos = pos_i

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i) ! Atom i belongs to mol "mi"

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms   

              ! Gross test for closeness
              pos_j = geom1(:,j)        
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle 

              ! It could be close: Set atom_j
              par_j = .frag_parent_for_cell_atom(j) 
              atom_j.atomic_number = atom(par_j).atomic_number
              atom_j.pos = pos_j

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              new(1)[:] = [h1,h2,h3,j]
              .unit_cell_connection(i).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)
              if (mj<mi) then        ! replace all previous by the lowest mol
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end
     end
     end
     end
     geom1.destroy; geom0.destroy
     new.destroy

     ! Now make the .unit_cell_mol_for_atom list consecutive
     .unit_cell_mol_for_atom = unit_cell_mol_for_atom
     unique => unit_cell_mol_for_atom.unique_elements
     unique.sort
     .n_unit_cell_mols = unique.dim
     do mi = 1,.n_unit_cell_mols
        mj = unique(mi)
        if (mj==mi) cycle
        where (unit_cell_mol_for_atom==mj) .unit_cell_mol_for_atom = mi
     end
     unique.destroy
     unit_cell_mol_for_atom.destroy

   end

   z_factor result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined
   ! as the ratio of the number of electrons in the unit cell on the
   ! number of electrons in the fragment. 
      res :: REAL

   ENSURE(.asym_atom_for_unit_cell_atom.created,"no asym_atom_for_unit_cell_atom")
   ENSURE(.asym_unit_atom_for_frag_atom.created,"no asym_unit_atom_for_frag_atom")

      ue,fe :: REAL
      n,a,f :: INT

      ! Get # of electrons in unit cell
      ue = ZERO
      do n = 1,.n_unit_cell_atoms
         a = .asym_atom_for_unit_cell_atom(n)
         ue = ue + .asymmetric_unit_atom(a).atomic_number
      end

      ! Get # of electrons in fragment
      fe = ZERO
      do f = 1,.n_fragment_atoms
         a = .asym_unit_atom_for_frag_atom(f)
         fe = fe + .asymmetric_unit_atom(a).atomic_number
      end

      ! Z factor is the ratio
      res = ue/fe

   end

!  ******************
!  Repetition factors
!  ******************

   make_repetition_factors ::: leaky, private
   ! The number of times a fragment atom with index "a" is mapped into
   ! itself under the symmetry group is the ".repetition_factor(a)".
   ! It is used to correct structure factors for fragment geometries
   ! which are "oversampled" relative to the asymmetric cell geometry.

   ENSURE(.fragment_geometry.created, "no fragment_geometry!")

      pa,pb :: VEC{REAL}(3)
      a,b,n,n_same :: INT
      same :: BIN
      tol :: REAL

      if (.use_manual_repetition_factors) then
         ENSURE(.repetition_factor.created,"no repetiton_factors entered!")
      else
         tol = TOL(2)/maxval(.unit_cell.length)
         tol = TOL(3)                        ! <--- getting this number wrong can stuff things
         .repetition_factor.destroy
         .repetition_factor.create(.n_fragment_atoms)
         do a = 1,.n_fragment_atoms
            pa = .fragment_geometry(:,a)
            .put_to_unit_cell(pa)
            n_same = 0
            do b = 1,.n_fragment_atoms
            do n = 1,.spacegroup.n_seitz
               pb = .fragment_geometry(:,b)
               .transform_position(pb,n,to_unit_cell=TRUE)
               same = pa.same_as(pb,tol)
               if (same) n_same = n_same + 1
            end
            end
            .repetition_factor(a) = n_same
         end
      end
   end

   make_asym_atom_rep_factors ::: leaky, private
   ! The number of times an asymmetric cell atom with index "a" is
   ! mapped into itself under the symmetry group is the
   ! ".asym_atom_rep_factor(a)". Also record the stabilizing
   ! operations in ".asym_atom_stabilizer(a)[:]". These are used in
   ! atomic-type structure factor calculations based on the asymmetric
   ! cell geometry.

   ENSURE(.fragment_geometry.created, "no fragment_geometry!")

      pa,pn :: VEC{REAL}(3)
      a,n,n_same :: INT
      same :: BIN
      tol :: REAL

      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      .asym_atom_rep_factor.destroy
      .asym_atom_stabilizer.destroy
      .asym_atom_rep_factor.create(.n_asymmetric_unit_atoms)
      .asym_atom_stabilizer.create(.n_asymmetric_unit_atoms)
      do a = 1,.n_asymmetric_unit_atoms
         pa = .asymmetric_unit_geometry(:,a)
         .put_to_unit_cell(pa)
         n_same = 0
         do n = 1,.spacegroup.n_seitz
            pn = pa
            .transform_position(pn,n,to_unit_cell=TRUE)
            same = pa.same_as(pn,tol)
            if (NOT same) cycle
            n_same = n_same + 1
            .asym_atom_stabilizer(a).element.append(n)
         end
         .asym_atom_rep_factor(a) = n_same
      end
   end

!  *****************************
!  Reset Hydrogen atom positions
!  *****************************

   reset_H_bond_lengths_in(atom,H_bond_length,reset) ::: leaky
   ! Resets the coordinates of the hydrogen atoms in "atoms" so that
   ! they have bond lengths given by the values in the "H_bond_length"
   ! array. Negative values mean no changes. If present "reset" is set
   ! TRUE if at least on the H atom positions was reset. 
   ! WARNING: this routine destroys all the fragment data.
      self :: PTR
      atom :: VEC{ATOM}
      H_bond_length :: VEC{REAL}*
      reset :: BIN, optional

   ENSURE(H_bond_length.created,"no H_bond_length array")

      lb,ub,ua,fh,fa,uh,ha,Za,n :: INT
      hh,ph,pa,sh,ch,ca,da,dd,d :: VEC{REAL}(3)
      rcm,inv :: MAT{REAL}(3,3)
      done :: BIN
      geom :: MAT{REAL}*

      if (all(H_bond_length<ZERO)) return

 ! stdout.text("frag geometry")
 ! stdout.put(transpose(.fragment_geometry))

      ! Destroy all the fragment data
      .destroy_fragment_data

      ! Make unit cell connection table
      .make_fragment_data(atom)

      ! Elements whose bond lengths to change
      lb = lbound(H_bond_length,1)
      ub = ubound(H_bond_length,1)

      ! Cell matrices
      rcm = .unit_cell.direct_matrix
      inv = .unit_cell.inverse_matrix

      done = FALSE

      ! Loop fragment atom positions
      do fh = 1,.n_fragment_atoms

         ! If fragment atom is not H atom, cycle ...
         if (atom(fh).atomic_number/=1) cycle

         ! The H atom  must have only one bond
         uh = .unit_cell_atom_for_frag_atom(fh) 
         if (.unit_cell_connection(uh).element.destroyed) cycle
         if (.unit_cell_connection(uh).element.dim>1) then
            n = .unit_cell_connection(uh).element.dim
            WARN("Hydrogen # "//fh.to_str.trim//" is bonded to "//n.to_str.trim//" atoms")
            cycle
         end

         ! Which frag atom is the H connected to?
         ua = .unit_cell_connection(uh)[1][4]
         fa = .frag_atom_for_unit_cell_atom(ua) 
         if (fa==0) cycle

         ! If it isn't one of those to be reset, cycle
         Za = atom(fa).atomic_number
         if (Za<lb OR Za>ub) cycle
         if (H_bond_length(Za)<ZERO) cycle

         done = TRUE

         ! Get the H atom pos relative to A
         hh = .fragment_geometry(:,fh)
         pa = .fragment_geometry(:,fa)
         dd = hh - pa
         d  = mod(dd,[ONE,ONE,ONE])
         where (d> HALF) d = d - ONE
         where (d<-HALF) d = d + ONE
         ph = pa + d
         sh = ph - hh

       ! stdout.show("Za         =",Za)
       ! stdout.show("fa         =",fa)
       ! stdout.show("fh         =",fh)
       ! stdout.show("cell shift =",d)
       ! stdout.show("H shift    =",sh)

         ! Get new cartesian H atom position
         ch = matmul(rcm,ph)
         ca = matmul(rcm,pa)
         dd = ch - ca
       ! stdout.show("old bond length =",to_units_(dd.norm,"angstrom"))
         dd.normalise
         ch = ca + H_bond_length(Za)*dd

       ! dd = ch - ca
       ! stdout.show("New bond length =",to_units_(dd.norm,"angstrom"))


         ! Put H atom back
         ph = matmul(inv,ch) - sh
         ch = matmul(rcm,ph)

       ! dd = atom(fh).pos - ch
       ! stdout.show("cart shift =",dd)
       ! stdout.show("cart norm  =",to_units_(dd.norm,"angstrom"))

         ! Reset the H atom position
         atom(fh).pos = ch

      end

 ! geom.create(3,.n_fragment_atoms)
 ! geom = atom.coordinates
 ! .unit_cell.change_into_fractional(geom)
 ! stdout.text("frag geometry")
 ! stdout.put(transpose(geom))
 ! geom.destroy

      if (present(reset)) reset = done 

      ! Clean up
      .destroy_fragment_data

   end

!  ****************
!  Position changes
!  ****************

   transform_geometry(g,op,translate,ignore_glide,to_unit_cell)
   ! Transform the positions "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (1,1,1) unit cell.
      g :: MAT{REAL}
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
   ENSURE(g.dim1==3,"incorrect size for array g")
      n :: INT
      do n = 1,g.dim2
         .transform_position(g(:,n),op,translate,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,translate,ignore_glide,to_unit_cell,unit_cell_shift) 
   ! Transform the position "p" in fractional coordinates with the Seitz
   ! operator with index "op". If present, "translate" will be added to the
   ! transformed position. If present and TRUE, "ignore_glide" will not add the
   ! glide vector part of the Seitz operator.  If present and TRUE,
   ! "to_unit_cell" will translate the fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell, and "unit_cell_shift" is set to the translation
   ! vector required to do this.
      p :: VEC{REAL}(3)
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
      unit_cell_shift :: VEC{INT}(3), optional
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
   ENSURE(op>0,"operator index out of bounds")
   ENSURE(op<=.spacegroup.n_seitz,"operator index out of bounds")
      ignore,to_cell :: BIN
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p)
      else
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p) + .spacegroup.seitz(1:3,4,op)
      end
      if (present(translate)) p = p + translate
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p,unit_cell_shift)
   end

   put_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      g :: MAT{REAL}
   ENSURE(g.dim1==3 OR g.dim2==3, "incorrect shape for array g")
      n :: INT
      if (g.dim1==3) then
         do n = 1,g.dim2
            .put_to_unit_cell(g(:,n))
         end
      else
         do n = 1,g.dim1
            .put_to_unit_cell(g(n,:))
         end
      end
   end

   put_to_unit_cell(p,shift)
   ! Transform the position "p" in fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell. If present, "shift" is set to the translation
   ! vector needed to effect the change to the unit cell.
      p :: VEC{REAL}(3)
      shift :: VEC{INT}(3), optional
   ENSURE(size(p)==3, "p must be length 3")
      new :: VEC{REAL}(3)
      tol :: REAL
      i :: INT
    ! new = mod(p - floor(p) + TWO + TOL(3),ONE) - TOL(3)
    ! ! p(:)-floor(p(:))+TWO should make it positive.
      ! I changed this from above, so that now every coordinate having an
      ! integer values will map to zero i.e. the unit cell is 0<=x_i<1, i=1,3
      ! --dylan
    ! tol = TOL(4)/maxval(.unit_cell.length)
      tol = TOL(1)/maxval(.unit_cell.length)
      tol = TOL(3)
      do i = 1,3
              if (abs(p(i))<tol)     then;  p(i) =   ZERO
         else if (abs(p(i)-ONE)<tol) then;  p(i) =    ONE
         else if (abs(p(i)+ONE)<tol) then;  p(i) =   -ONE
         else if (abs(p(i)-TWO)<tol) then;  p(i) =    TWO 
         else if (abs(p(i)+TWO)<tol) then;  p(i) =   -TWO 
         end
      !  if (abs(p(i)-THREE)<tol) p(i) =  THREE 
      !  if (abs(p(i)+THREE)<tol) p(i) = -THREE
      !  if (abs(p(i)-FOUR)<tol)  p(i) =   FOUR
      !  if (abs(p(i)+FOUR)<tol)  p(i) =  -FOUR
      end
      new = p - floor(p)
      if (present(shift)) shift = nint(new - p)
      p = new
   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      g :: MAT{REAL}
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n,n_atom :: INT
      centre :: VEC{INT}(3)
      n_atom = size(g,2)
      centre = .unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - centre
      end
   end

   unit_cell_offset(g) result (res)
   ! Which hkl indices match the centre of the fragment geometry "g" when
   ! expressed in crystal coordinates.  Usually we expect that it is 0,0,0 but
   ! not always.
      g :: MAT{REAL}
      res :: VEC{INT}(3)
   ENSURE(g.dim1==3, "incorrect size for array g")
      res = sum(g,dim=2)/g.dim2
   end

!  ***************
!  Fragment widths
!  ***************

   fragment_width result (res)
   ! Return the width "res" of the fragment in each of the 3 axis directions.
      res :: VEC{REAL}(3)
   ENSURE(.fragment_geometry.created,"no fragment geometry")
      res = .fragment_geometry.max_abs_column_difference
   end

   cartesian_fragment_width result (res)
   ! Return the cartesian width "res" of the fragment in each of the three axis
   ! directions.
      res :: VEC{REAL}(3)
      res = .fragment_width
      .unit_cell.change_from_fractional(res)
   end

!  **************
!  Seitz matrices
!  **************

   make_xyz_seitz_matrices(res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S_cartesian  =  D  S^_crystal  D^-1
   ! NOTE: I think they are not transposed any more ...
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
      i :: INT
      res.create(3,3,.spacegroup.n_seitz)
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end
   end

   xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. 
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
      i :: INT
      res.create(3,3,.spacegroup.n_seitz)
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end
   end

   transposed_xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. 
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
      i :: INT
      res.create(3,3,.spacegroup.n_seitz)
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.reciprocal_matrix, &
                      matmul(transpose(.spacegroup.seitz(1:3,1:3,i)), &
                             transpose(.unit_cell.direct_matrix)))
      end
   end

!  ***********
!  Stabilizers
!  ***********

   make_stabilizer_symops ::: leaky, private
   ! Make a list of the indices of the Seitz matrices, ".stabilizer_symop", which
   ! will generate the same geometries to that in ".fragment_geometry" when
   ! both the original and transformed geometries are converted to unit cell
   ! coordinates.  ".n_stabilizer_symops" is set to the number of these 
   ! symmetry operations.
      g1,gi :: MAT{REAL}*
      i,n :: INT
      identical :: BIN

      .stabilizer_symop.destroy
      .stabilizer_symop.create(.spacegroup.n_seitz)

      g1.create(3,.n_fragment_atoms)
      gi.create(3,.n_fragment_atoms)
      g1 = .fragment_geometry

      n = 1
      .stabilizer_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         gi = .fragment_geometry
         .transform_geometry(gi,i)
         identical  = .is_same_geometry(gi,g1)
         if (NOT identical) cycle
         n = n + 1
         .stabilizer_symop(n) = i
      end
      gi.destroy
      g1.destroy

      .n_stabilizer_symops = n
      .stabilizer_symop.shrink(n)

   end

   is_same_geometry(geom_i,geom_j) result (res) ::: private
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      geom_i,geom_j :: MAT{REAL}
      res :: BIN
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
   ENSURE(geom_i.dim1==3,"incorrect size for array geom_i")
   ENSURE(geom_j.dim1==3,"incorrect size for array geom_j")
   ENSURE(geom_i.dim2==geom_j.dim2,"incompatible sizes for geom_i, geom_j")
      i,j,n_atom :: INT
      skip :: VEC{BIN}*
      same :: BIN
      tol :: REAL
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      n_atom = geom_i.dim2
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j),tol)
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   xyz_stabilizer_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis which stabilize the fragment geometry. 
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
   ENSURE(.stabilizer_symop.created,"no stabilizer symop matrices")
      i,s :: INT
      res.create(3,3,.n_stabilizer_symops)
      do i = 1,.n_stabilizer_symops
         s = .stabilizer_symop(i)
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,s),.unit_cell.inverse_matrix))
      end
   end

   make_stabilizer_xyz_matrices ::: leaky, private
   ! Make the representation matrices for xyz products found in
   ! gaussian shells, i.e. work out matrix R, where the shell row vector
   ! p'(r) = p(S^{-1}r) = p(r)R, and S is a stabilizer symop.
   ! WARNING: this routine is tied to an explicit ordering of the cartesian
   ! gaussian basis functions in a shell.
      str :: MAT3{REAL}*

     .str.destroy
     .ptr.destroy
     .dtr.destroy
     .ftr.destroy
     .gtr.destroy

      str.create(1,1,.n_stabilizer_symops)
      str = ONE
      .str => str                          ! 1  x 1
      .ptr => .xyz_stabilizer_matrices     ! 3  x 1
      .dtr => .ptr.gaussian_d_xyz_matrices ! 6  x 6
      .ftr => .ptr.gaussian_f_xyz_matrices ! 10 x 10
      .gtr => .ptr.gaussian_g_xyz_matrices ! 15 x 15

   end

   xyz_stabilizer_matrix(n,l) result (res)
   ! Return the "n"-th stabilizer representation matrix for xyz
   ! product found in a gaussian shell of angular momentum "l"
      n,l :: INT
      res :: MAT{REAL}*
   ENSURE(l>=0,"l must be non-negative")
   ENSURE(l<5, "l must be less than 5 (no h functions or higher)")
      select case (l)
         case(0); res => .str(:,:,n)
         case(1); res => .ptr(:,:,n)
         case(2); res => .dtr(:,:,n)
         case(3); res => .ftr(:,:,n)
         case(4); res => .gtr(:,:,n)
         case default; DIE("not implemented beyond l=4")
      end
   end

!  *******************************************
!  No. of unique reflections, pruning, merging
!  *******************************************

   make_list_of_equivalents(list,n_unique,show) ::: leaky, private
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
     self :: IN
     list :: VEC{VEC_{INT}}*
     n_unique :: INT, OUT
     show :: BIN, IN, optional
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     i,j,g,n_refl :: INT
     p,q,r :: VEC{INT}(3)
     same,disp :: BIN
     disp = FALSE
     if (present(show)) disp = show
     n_refl = .data.reflections.n_refl
     list.create(n_refl)
     list(1).element.append(1)
     n_unique = 1
     do i = 2,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 
        same = FALSE
        main: do g = 1,.spacegroup.n_seitz
           do j = 1,i-1
              q(1) = .data.reflections(j).h 
              q(2) = .data.reflections(j).k 
              q(3) = .data.reflections(j).l 
              r = nint(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
              same = p.same_as(r) OR p.same_as(-r)
              if (NOT same) cycle
              exit main
           end
        end do main
        if (same) then
           list(j).element.append(i)
           list(i).element.append(j)
           if (disp) then
           stdout.text("reflections "//trim(i.to_str)//" and "//trim(j.to_str)//" are the same")
           end
        else
           n_unique = n_unique + 1
           list(i).element.append(i)
        end
     end
   end

   merge_equivalents ::: leaky
   ! This routine will merge this list of equivalents into a single reflections
   ! with a particular sigma value associated with it. WARNING: it assumes that
   ! there are a sufficient number of equivalents so that the sigma value can be
   ! calculated by the standard formula for the standard deviation.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     list :: VEC{VEC_{INT}}*
     reflections :: VEC{REFLECTION}*
     n_unique,n_refl,n,i :: INT
     n_refl = .data.reflections.n_refl
     .make_list_of_equivalents(list,n_unique)
     reflections.create(n_unique)
     n = 0
     do i = 1,n_refl
        if (list(i)[1]<i) cycle
        n = n + 1
     stdout.show("merged      = ",n)
     stdout.show("first       = ",i)
     stdout.show("equivalents =",list(i)[:])
        reflections(n) = .data.reflections(i)
        reflections(n).F_exp   = .data.reflections(list(i)[:]).F_exp.mean
        reflections(n).F_sigma = .data.reflections(list(i)[:]).F_exp.standard_deviation
     stdout.show("F_exp's      = ",.data.reflections(list(i)[:]).F_exp)
     stdout.show("new F_exp    = ",reflections(n).F_exp)
     stdout.show("new F_sigma  = ",reflections(n).F_sigma)
     end
     .data.reflections.destroy
     .data.reflections => reflections
     list.destroy
   end

   make_list_of_equivalents_ord(list,n_unique,show) ::: leaky, private
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
     self :: IN
     list :: VEC{VEC_{INT}}*
     n_unique :: INT, OUT
     show :: BIN, IN, optional
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     i,j,g,n_refl :: INT
     p,q,r :: VEC{INT}(3)
     same,disp :: BIN
     disp = FALSE
     if (present(show)) disp = show
     n_refl = .data.reflections.n_refl
     list.create(n_refl)
     list(1).element.append(1)
     n_unique = 1
     do i = 2,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 
        same = FALSE
        j = i-1
        main: do g = 1,.spacegroup.n_seitz
           q(1) = .data.reflections(j).h 
           q(2) = .data.reflections(j).k 
           q(3) = .data.reflections(j).l 
           r = nint(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
           same = p.same_as(r) OR p.same_as(-r)
           if (NOT same) cycle
           exit main
        end do main
        if (same) then
           list(j).element.append(i)
           list(i).element.append(j)
           if (disp) then
           stdout.text("reflections "//trim(i.to_str)//" and "//trim(j.to_str)//" are the same")
           end
        else
           n_unique = n_unique + 1
           list(i).element.append(i)
        end
     end
   end

   merge_ordered_equivalents ::: leaky
   ! This routine will merge apartially ordered list of equivalents into a
   ! single reflections with a particular sigma value associated with it.
   ! WARNING: it assumes that there are a sufficient number of equivalents so
   ! that the sigma value can be calculated by the standard formula for the
   ! standard deviation.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     list :: VEC{VEC_{INT}}*
     reflections :: VEC{REFLECTION}*
     n_unique,n_refl,n,i :: INT
     n_refl = .data.reflections.n_refl
     .make_list_of_equivalents_ord(list,n_unique)
     reflections.create(n_unique)
     n = 0
     do i = 1,n_refl
        if (list(i)[1]<i) cycle
        n = n + 1
     stdout.show("merged      = ",n)
     stdout.show("first       = ",i)
     stdout.show("equivalents =",list(i)[:])
        reflections(n) = .data.reflections(i)
        reflections(n).F_exp   = .data.reflections(list(i)[:]).F_exp.mean
        reflections(n).F_sigma = .data.reflections(list(i)[:]).F_exp.standard_deviation
     stdout.show("F_exp's      = ",.data.reflections(list(i)[:]).F_exp)
     stdout.show("new F_exp    = ",reflections(n).F_exp)
     stdout.show("new F_sigma  = ",reflections(n).F_sigma)
     end
     .data.reflections.destroy
     .data.reflections => reflections
     list.destroy
   end

   expand_unique_reflections ::: leaky
   ! This routine will expand a unique list of reflections into a
   ! complete redundant list of reflections.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     list :: VEC{VEC_{INT}}*
     reflections :: VEC{REFLECTION}*
     n_unique,n_refl,n_max,n,i,j,g :: INT
     p,q,r :: VEC{INT}(3)
     same :: BIN

     ! Store the number of reflections
     n_refl = .data.reflections.n_refl

     ! Make the list of equivalents, to detect any repetitions
     .make_list_of_equivalents(list,n_unique,show=TRUE)
     DIE_IF(n_unique/=n_refl,"the list of reflections is not unique")
     list.destroy

     ! Create the maximum possible list of total reflections
     n_max = n_refl*.spacegroup.n_seitz
     reflections.create(n_refl*.spacegroup.n_seitz)

     ! Loop over remaining reflections
     n = 0
     do i = 1,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 

        ! Apply symmetry to this relflection
        do g = 1,.spacegroup.n_seitz
           r = nint(matmul(.spacegroup.seitz(1:3,1:3,g),p),kind=INT_KIND)

           ! Is it the same as another in the list? 
           same = FALSE
           do j = 1,n-1
              q(1) = reflections(j).h 
              q(2) = reflections(j).k 
              q(3) = reflections(j).l 
              same = q.same_as(r)
              if (same) exit
           end
           if (NOT same) then
              n = n + 1
              DIE_IF(n>n_max,"more than expected number of reflections")
              reflections(n) = .data.reflections(i)
              reflections(n).h = r(1)
              reflections(n).k = r(2)
              reflections(n).l = r(3)
           end
        end
     end
     reflections.shrink(n)
     .data.reflections.destroy
     .data.reflections => reflections
   end

   prune_bad_sigmas ::: leaky
   ! This routine will prune away all reflections with sigmas not within a
   ! certain limit.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     low,high,val :: REAL
     i,dim :: INT
     i = 0
     loop: do 
        i = i + 1
        dim = .data.reflections.dim
        if (i>dim) exit
        low  = .data.F_sigma_min 
        high = .data.F_sigma_max
        val  = .data.reflections(i).F_sigma
        if (val>=low AND val<=high) cycle
        .data.reflections(i:dim-1) = .data.reflections(i+1:dim)
        .data.reflections.shrink(dim-1)
     end do loop
   end

   prune_negative_F_exp ::: leaky
   ! This routine will prune all negative F_exp values. (They are negative if
   ! the original F2 ws negative).
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     val :: REAL
     pruned :: BIN
     i,dim :: INT
     pruned = FALSE
     i = 0
     loop: do 
        i = i + 1
        dim = .data.reflections.dim
        if (i>dim) exit
        val  = .data.reflections(i).F_exp
        if (val>=.data.F_exp_min) cycle
        pruned = TRUE
        .data.reflections(i:dim-1) = .data.reflections(i+1:dim)
        .data.reflections.shrink(dim-1)
     end do loop
     WARN_IF(pruned,"negative structure factors have been pruned!")
   end

!  **************
!  Output methods
!  **************

   put
   ! Put out the crystal data to file "out"

      stdout.flush
      stdout.text("CRYSTAL information:")
      stdout.show("kind                        = ", .data_kind)

      .unit_cell.put
      .spacegroup.put
      .put_xyz_seitz

      if (.asymmetric_unit_geometry.created) .put_asymmetric_unit_geometry
      if (.unit_cell_geometry.created)       .put_unit_cell_geometry
      if (.unit_cell_connection.created)     .put_uc_connection_table

      if (.fragment_geometry.created)        .put_fragment_data

      .put_reflection_data

   end

   put_xyz_seitz
   ! Put out the spacegroup seitz matrices.

   ENSURE(.spacegroup.n_seitz>0,"no seitz matrices")

      n :: INT
      seitz :: MAT3{REAL}*

      seitz => .xyz_seitz_matrices

      stdout.flush
      stdout.text("Cartesian (xyz) seitz matrices :")
      do n = 1,.spacegroup.n_seitz
        stdout.flush
        stdout.show("n = ",n)
        stdout.put(seitz(:,:,n))
      end

      seitz.destroy

   end

   put_asymmetric_unit_geometry ::: private
   ! Put out the asymmetric unit geometry. 

   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit atoms")

      a :: INT
      symbol :: STR

      stdout.flush
      stdout.text("Crystal asymmetric unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do a = 1,.n_asymmetric_unit_atoms
         stdout.put(a)
         if (.asymmetric_unit_atom.created) then
            symbol = .asymmetric_unit_atom(a).chemical_symbol
            symbol = trim(symbol) // " (" // trim(a.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(a)
         end
         stdout.put(.asymmetric_unit_geometry(1,a))
         stdout.put(.asymmetric_unit_geometry(2,a))
         stdout.put(.asymmetric_unit_geometry(3,a))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_unit_cell_geometry ::: private
   ! Put out the unit_cell_geometry. If present, "atom" is assumed to be the
   ! list of fragment atoms.

   ENSURE(.unit_cell_geometry.created,"no unit_cell_geometry")
   ENSURE(.frag_parent_for_cell_atom.created,"no frag_parent_for_cell_atom")

      u,a :: INT
      symbol :: STR

      stdout.flush
      stdout.text("Crystal unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do u = 1,.n_unit_cell_atoms
         stdout.put(u)
         if (.asymmetric_unit_atom.created) then
            a = .asym_atom_for_unit_cell_atom(u)
            symbol = .asymmetric_unit_atom(a).chemical_symbol
            symbol = trim(symbol) // " (" // trim(u.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(u)
         end
         stdout.put(.unit_cell_geometry(1,u))
         stdout.put(.unit_cell_geometry(2,u))
         stdout.put(.unit_cell_geometry(3,u))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_pdb(pdbfile)
   ! pdb file header generation
   ! Put unit cell information 
   !CRYST1   31.595   32.369   24.219  90.00  90.00  90.00 P 21 21 21    8
      pdbfile :: TEXTFILE*
      factor :: REAL
      pdbfile.save
      pdbfile.set_margin(0)
      pdbfile.put("CRYST1",width=6)
      pdbfile.set_real_precision(3)
      pdbfile.set_real_width(9)
      pdbfile.put(.unit_cell.length(1).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(2).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(3).to_units("angstrom"))
      pdbfile.set_real_precision(2)
      pdbfile.set_real_width(7)
      pdbfile.put(.unit_cell.angle(1).to_units("degree"))
      pdbfile.put(.unit_cell.angle(2).to_units("degree"))
      pdbfile.put(.unit_cell.angle(3).to_units("degree"))
      pdbfile.put(.spacegroup.HM_symbol,width=10)
      pdbfile.put(nint(.Z),width=5)
      pdbfile.flush
      pdbfile.put("SCALE1",width=6)
      pdbfile.tab(width=6)
      pdbfile.set_real_precision(7)
      pdbfile.set_real_width(10)
      factor=1.0d0
      factor.convert_to("angstrom^-1")
      pdbfile.put(.unit_cell.inverse_matrix(1,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(1,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(1,3)*factor)
      pdbfile.flush
      pdbfile.put("SCALE2",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_matrix(2,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(2,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(2,3)*factor)
      pdbfile.flush
      pdbfile.put("SCALE3",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_matrix(3,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(3,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(3,3)*factor)
      pdbfile.flush
      !SCALE1     0.1053741 0.0175390 0.0172991      0.0000000
      !SCALE2     0.0000000 0.0601636 0.0076747      0.0000000
      !SCALE3     0.0000000 0.0000000 0.0321397      0.0000000
      pdbfile.unsave
   end

   put_cif(ciffile)
   ! cif file header generation
   ! Put unit cell information 
      ciffile :: TEXTFILE*
      factor :: REAL
      ciffile.save
      ciffile.flush
      ciffile.set_real_precision(4)
      ciffile.set_real_width(9)
      ciffile.set_margin(0)
      ciffile.put("data_tonto")
      ciffile.flush
      ciffile.put("_symmetry_space_group_name_H-M ")
      ciffile.put("'"//.spacegroup.HM_symbol.trim//"'")
      ciffile.flush
      ciffile.put("_symmetry_space_group_name_Hall ")
      ciffile.put("'"//.spacegroup.Hall_symbol.trim//"'")
      ciffile.flush
      ciffile.flush
      ciffile.put("_cell_length_a ")
      ciffile.put(.unit_cell.length(1).to_units("angstrom"))
      ciffile.flush
      ciffile.put("_cell_length_b ")
      ciffile.put(.unit_cell.length(2).to_units("angstrom"))
      ciffile.flush
      ciffile.put("_cell_length_c ")
      ciffile.put(.unit_cell.length(3).to_units("angstrom"))
      ciffile.flush
      ciffile.put("_cell_angle_alpha ")
      ciffile.put(.unit_cell.angle(1).to_units("degree"))
      ciffile.flush
      ciffile.put("_cell_angle_beta ")
      ciffile.put(.unit_cell.angle(2).to_units("degree"))
      ciffile.flush
      ciffile.put("_cell_angle_gamma ")
      ciffile.put(.unit_cell.angle(3).to_units("degree"))
      ciffile.flush
      ciffile.flush
      ciffile.unsave
   end


   put_uc_connection_table
   ! Put the .unit_cell_connection table

   ENSURE(.unit_cell_connection.created,"no unit_cell_connection")
   ENSURE(.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Unit cell atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols = ",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)
   
         first = TRUE
         do a = 1,.unit_cell_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle
   
            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE
   
            if (.unit_cell_connection(a).element.destroyed) then
   
               stdout.flush
   
            else
   
               do i = 1,.unit_cell_connection(a).element.dim
   
                  if (i>1) &
                  stdout.tab(int_fields=2)
   
                  b = .unit_cell_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.unit_cell_connection(a)[i][1])
                  stdout.put(.unit_cell_connection(a)[i][2])
                  stdout.put(.unit_cell_connection(a)[i][3])
                  stdout.flush
   
               end
   
            end
         end
      end

      stdout.dash(int_fields=6)

   end

!  ********************************
!  Put Fragment related information
!  ********************************

   put_fragment_data ::: private
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.

      stdout.flush
      stdout.text("Crystal fragment data:")
      stdout.flush
      stdout.show("No. of inputted atoms        = ",.n_fragment_atoms,real_width=TRUE)
      stdout.show("No. of unique fragment atoms = ",.n_unique_frag_atoms,real_width=TRUE)
      stdout.show("Z factor                     = ",.Z)
      stdout.flush
      stdout.show("Fragment partition model     = ",.partition_model)
      stdout.show("Thermal smearing model       = ",.thermal_smearing_model)

    ! .put_stabilizer_symops 
    ! .put_inv_trans_symop_data
      .put_fragment_geometry
      .put_unique_fragment_atoms
      .put_repetition_factors
      .put_asym_atom_rep_factors

   end

   put_stabilizer_symops ::: private
   ! Put out the stabilizer symop data

   ENSURE(.stabilizer_symop.created,"no stabilizer_symop")

      stdout.flush
      stdout.text("Crystal stabilizer symop information:")
      stdout.flush
      stdout.show("n_stabilizer_symops = ",.n_stabilizer_symops)
      stdout.flush
      stdout.put(.stabilizer_symop,"column")

   end

   put_fragment_geometry ::: private
   ! Put out the fragment_geometry information

   ENSURE(.fragment_geometry.created,"no fragment_geometry")
   ENSURE(.asym_unit_atom_for_frag_atom.created,"no asym_unit_atom_for_frag_atom")

      symbol :: STR
      f,a :: INT

      stdout.flush
      stdout.text("Crystal fragment geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Fragment",int_width=TRUE)
      stdout.put("Asym.",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do f = 1,.n_fragment_atoms
         a = .asym_unit_atom_for_frag_atom(f)
         if (.asymmetric_unit_atom.created) then
            symbol = .asymmetric_unit_atom(a).chemical_symbol
            symbol = trim(symbol) // " (" // trim(f.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(f)
         end
         stdout.put(a)
         stdout.put(.fragment_geometry(1,f))
         stdout.put(.fragment_geometry(2,f))
         stdout.put(.fragment_geometry(3,f))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_unique_fragment_atoms ::: private
   ! Put out the unique fragment_geometry information

   ENSURE(.fragment_geometry.created,"no fragment_geometry")
   ENSURE(.asym_unit_atom_for_frag_atom.created,"no asym_unit_atom_for_frag_atom")
   ENSURE(.unique_atom_for_frag_atom.created,"no unique_atom_for_frag_atom")
   ENSURE(.asym_symop_for_frag_atom.created,"no asym_symop_for_frag_atom")

      symbol :: STR
      f,a,u,s :: INT
      sh :: VEC{REAL}(3)

      stdout.flush
      stdout.text("Crystal unique fragment atoms:")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)
      stdout.put("Fragment",int_width=TRUE)
      stdout.put("Unique",int_width=TRUE)
      stdout.put("Asym",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("Asym")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Symop",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("Shift")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)
      do f = 1,.n_fragment_atoms
         a  = .asym_unit_atom_for_frag_atom(f)
         u  = .unique_atom_for_frag_atom(f)
         s  = .asym_symop_for_frag_atom(f)
         sh = .asym_shift_for_frag_atom(:,f)
         if (.asymmetric_unit_atom.created) then
            symbol = .asymmetric_unit_atom(a).chemical_symbol
            symbol = trim(symbol) // " (" // trim(f.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(f)
         end
         stdout.put(u)
         stdout.put(s)
         stdout.put(sh(1))
         stdout.put(sh(2))
         stdout.put(sh(3))
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=3)
   end

   put_repetition_factors ::: private
   ! Put out the repetition factors

   ENSURE(.repetition_factor.created,"no repetition factors")

      f,a,rf :: INT
      symbol :: STR

      stdout.flush
      stdout.text("Crystal fragment atom repetition factors:")
      stdout.flush
      stdout.dash(int_fields=2)
      stdout.put("Fragment",int_width=TRUE)
      stdout.put("Rep.",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Factor",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=2)
      do f = 1,.n_fragment_atoms
         if (.asymmetric_unit_atom.created) then
            a = .asym_unit_atom_for_frag_atom(f)
            symbol = .asymmetric_unit_atom(a).chemical_symbol
            symbol = trim(symbol) // " (" // trim(f.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(f)
         end
         rf = .repetition_factor(f)
         stdout.put(rf)
         stdout.flush
      end
      stdout.dash(int_fields=2)
   end

   put_asym_atom_rep_factors ::: private
   ! Put out the asymmetric unit atom repetition factors

   ENSURE(.asym_atom_rep_factor.created,"no asymmetric unit atom repetition factors")
   ENSURE(.asym_atom_stabilizer.created,"no asymmetric unit atom stabilizers")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric unit atom")

      f,a,n,rf,st :: INT
      symbol :: STR

      stdout.flush
      stdout.text("Crystal asymmetric unit atom repetition factors:")
      stdout.flush
      stdout.dash(int_fields=3)
      stdout.put("Asym",int_width=TRUE)
      stdout.put("Rep.",int_width=TRUE)
      stdout.put("Stab.",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Factor",int_width=TRUE)
      stdout.put("Symop",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=3)
      do a = 1,.n_asymmetric_unit_atoms
         symbol = .asymmetric_unit_atom(a).chemical_symbol
         symbol = trim(symbol) // " (" // trim(a.to_str) // ")"
         stdout.put(symbol,int_width=TRUE)
         rf = .asym_atom_rep_factor(a)
         st = .asym_atom_stabilizer(a)[1]
         stdout.put(rf)
         stdout.put(st)
         do n = 2,.asym_atom_stabilizer(a).element.dim
            st = .asym_atom_stabilizer(a)[n]
            stdout.flush
            stdout.tab(int_fields=2)
            stdout.put(st)
         end
         stdout.flush
      end
      stdout.dash(int_fields=3)
   end

!  **********************************
!  Put reflection related information
!  **********************************

   put_reflection_data
   ! Put out the reflection data to file "out".  Both Neutron and 
   ! X-ray will be put if present.
      stdout.flush
      if (.xray_data.created) then
        if (.xray_data.reflections.created) then  
        stdout.text("X-ray reflection data:")
        stdout.flush
        .xray_data.put_reflection_data
        stdout.flush
        end
      end  
      if (.pnd_data.created) then
        if (.pnd_data.reflections.created) then    
        stdout.text("Polarised neutron reflection data:")
        stdout.flush
        .pnd_data.put_reflection_data
        stdout.flush
        end
      end  
   end

   put_correction_data
   ! Output the correction data 
   ENSURE(.data_exists, "no diffraction data")
     .data.put_correction_data
   end

   put_F_statistics
   ! Output the structure factor statistics 
   ENSURE(.data_exists, "no diffraction data")
     .data.put_F_statistics
   end

   put_F_calc
   ! Put the hkl Miller index triple followed by the calculated
   ! structure factor to add onto existing structure factors.
   ENSURE(.data_exists, "no diffraction data")
     .data.put_F_calc
   end

   put_PND_sf(name)
   ! outputs the polarised neutron structure factors
     name :: STR
   ENSURE(.data_exists, "no diffraction data")
     .data.put_PND_sf(name)
   end

!  ****************
!  Crystal Explorer
!  ****************

   put_CX(label,formula,spacegroup)
   ! Output some information for the Crystal Explorer program.
       label,formula,spacegroup :: STR
       .unit_cell.put_CX(label,formula,spacegroup)
   end

!  ******************
!  Put plots and maps
!  ******************

   put_fitting_plots
   ! Output all the fitting plot information
     .put_chi2_vs_angle_plot
     .put_fcalc_plots
     .put_qq_plot
     .put_labelled_qq_plot
   end

   put_chi2_vs_angle_plot
   ! Output a table with the chi^2 for the structure factor data set broken
   ! into sections.
   ! Reads from stdin the number of divisions in the plot.
   ENSURE(.data_exists,"no diffraction data")
     .data.put_chi2_vs_angle_plot
   end

   put_qq_plot
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.data_exists, "no diffraction data")
     .data.put_qq_plot
   end

   put_labelled_qq_plot
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.data_exists, "no diffraction data")
     .data.put_labelled_qq_plot
   end

   put_fcalc_plots
   ! Output some different plots about the calculated structure factors.
   ENSURE(.data_exists, "no diffraction data")
     .data.put_fcalc_plots
   end

   make_residual_error_map(map,pts)
   ! Make the crystal residual error "map" for the supplied points "pts" from
   ! the crystal structure factors
     map :: VEC{REAL}
     pts :: MAT{REAL}
   ENSURE(.data.created, "no diffraction data")
   ENSURE(.data.reflections.created, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")
   ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
     k :: MAT{REAL}*
     F :: VEC{CPX}*
     k_dot_rn :: VEC{REAL}*
     fac :: REAL
     ci  :: CPX
     n_refl,n :: INT
     n_refl = .data.reflections.n_refl
     k.create(n_refl,3); .make_k_pts(k)
     F.create(n_refl)
     F = (.data.reflections.F_exp - .data.reflections.F_pred) &
       *.data.reflections.F_calc/abs(.data.reflections.F_calc)
     F = F/.extinction_correction
     ci = (ZERO,ONE)
     k_dot_rn.create(n_refl)
     do n = 1,pts.dim1
        k_dot_rn = matmul(k,pts(n,:))
        map(n) = sum(F*exp(ci*k_dot_rn))
     end
     k_dot_rn.destroy
     fac = TWO/.unit_cell.volume
     map = fac*map
     F.destroy
     k.destroy
   end

!  *******************
!  Tests for existence
!  *******************

   reflection_data_exists result (res)
   ! Return TRUE if reflection data exists
     res :: BIN
     res = associated(.data.reflections)
   end

   data_exists result (res)
   ! Return TRUE if the diffraction data information exists
     res :: BIN
     res = associated(.data)
   end

   asymmetric_unit_exists result (res)
   ! Return TRUE if the asymmetric unit geometry information exists
     res :: BIN
     res = associated(.asymmetric_unit_geometry)
   end

   unit_cell_geometry_exists result (res)
   ! Return TRUE if the unit_cell_geometry information exists
     res :: BIN
     res = associated(.unit_cell_geometry)
   end

   fragment_data_exists result (res)
   ! Return TRUE if a fragment information exists
     res :: BIN
     res = associated(.fragment_geometry)
   end

!*******************************************************************************
!                     Inherited reflection routines
!*******************************************************************************

   n_refl result (res)
   ! The number of reflections
     res :: INT
   ENSURE(.data_exists, "no diffraction data")
     res = .data.n_refl
   end

   F_exp result (res)
   ! The experimental structure factors
     res :: VEC{REAL}(.data.reflections.dim)
   ENSURE(.data_exists, "no diffraction data")
     res = .data.F_exp
   end

   F_sigma result (res)
   ! The structure factor errors
     res :: VEC{REAL}(.data.reflections.dim)
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_sigma
   end

   F_calc result (res)
   ! The calculated structure factors
     res :: VEC{CPX}(.data.reflections.dim)
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_calc
   end

   F_chi2 result (res)
   ! Returns data
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"diffraction data not created")
     res = .data.F_chi2
   end

   F_goodness_of_fit result (res)
   ! Returns data
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_goodness_of_fit
   end

   F_r_factor result (res)
   ! Returns data
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_r_factor
   end

   F_weighted_r_factor result (res)
   ! Returns data
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_weighted_r_factor
   end

   set_F_calc(F_calc)
   ! Set the calculated structure factors
     F_calc :: VEC{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
     .data.set_F_calc(F_calc)
   end

   make_F_predicted
   ! Make the predicted magnitude of structure factors, including possibly
   ! an overall scale factor and extinction correction
   ENSURE(.data_exists,"no diffraction data")
     .data.make_F_predicted
   end

   update_n_param_and_chi2
   ! Update the number of parameters and recalculate the chi2
   ENSURE(.data_exists,"no diffraction data")
     .data.update_n_param_and_chi2
   end

   extinction_correction result (res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors.
     res :: VEC{REAL}(.data.reflections.dim)
     res = .data.extinction_correction
   end

   n_param result (res)
   ! Returns number of independent parameters in model 
     self :: IN
     res :: INT
   ENSURE(.data_exists,"diffraction data not created")
     res = .data.n_param
   end

   partition_model result (res)
   ! Model for partitioning fragments of the molecule
     self :: IN
     res :: STR
     if (.data_exists) then
       res = .data.partition_model
     else 
       res = " "
     end  
   end

   thermal_smearing_model result (res)
   ! Thermal smearing model for ft integrals.  
     self :: IN
     res :: STR
     if (.data_exists) then
       res = .data.thermal_smearing_model
     else 
       res = " "
     end
   end

   correct_dispersion result (res)
   ! True if dispersion is to be corrected
     self :: IN
     res :: BIN
   ENSURE(.data_exists,"no diffraction data")
     res = .data.correct_dispersion
   end

   wavelength result (res)
   ! Experimental wavelength
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"no diffraction data")
     res = .data.wavelength
   end

   optimise_extinction result (res)
   ! True if extinction is to be optimised
     self :: IN
     res :: BIN
   ENSURE(.data_exists,"no diffraction data")
     res = .data.optimise_extinction
   end

   optimise_scale result (res)
   ! True if an overall scale factor is to be optimised, for use in calculating
   ! F_pred
     self :: IN
     res :: BIN
   ENSURE(.data_exists,"no diffraction data")
     res = .data.optimise_scale
   end

   xyz_asymmetric_unit_geometry result (res)
   ! Return the asymmetric unit geometry in cartesian coordinates.
      res :: MAT{REAL}(3,.n_asymmetric_unit_atoms)
   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit")
      res = matmul(.unit_cell.direct_matrix,.asymmetric_unit_geometry)
   end

   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.
   ENSURE(.data_exists,"no diffraction data")
     .data.simulate_new_F_exp
   end

end
