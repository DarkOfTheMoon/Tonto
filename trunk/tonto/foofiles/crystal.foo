!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module CRYSTAL

   implicit none

   saved_self :: CRYSTAL*

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  **************************
!  Create and destroy methods
!  **************************

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object

      .spacegroup.nullify_ptr_part

      nullify(.fragment_atom)
      nullify(.fragment_geometry)

      nullify(.asymmetric_unit_geometry)
      nullify(.asymmetric_unit_atom)

      nullify(.unit_cell_geometry)
      nullify(.unique_unit_cell_atom)
      nullify(.unique_uc_atom_offset)
      nullify(.is_asym_unit_cell_atom)
      nullify(.asym_atom_for_unit_cell_atom)
      nullify(.asym_symop_for_unit_cell_atom)

      nullify(.frag_atom_for_unit_cell_atom)
      nullify(.unit_cell_atom_for_frag_atom)
      nullify(.frag_atom_for_asym_atom)
      nullify(.asym_atom_for_frag_atom)
      nullify(.frag_parent_for_cell_atom)

      nullify(.unique_frag_atom)
      nullify(.unique_atom_for_frag_atom)
      nullify(.unique_symop_for_frag_atom)
      nullify(.asym_symop_for_frag_atom)
      nullify(.asym_shift_for_frag_atom)

      nullify(.repetition_factor)
      nullify(.asym_atom_rep_factor)
      nullify(.asym_atom_stabilizer)

      nullify(.unit_cell_connection)
      nullify(.uc_vdw_connection)
      nullify(.unit_cell_mol_for_atom)

      nullify(.stabilizer_symop)
      nullify(.str)
      nullify(.ptr)
      nullify(.dtr)
      nullify(.ftr)
      nullify(.gtr)

      nullify(.data)
      nullify(.xray_data)
      nullify(.pnd_data)
      nullify(.xray_r_free_data)
      nullify(.pnd_r_free_data)
      nullify(.core_reflection)

   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information
      .spacegroup.destroy_ptr_part
      .destroy_fragment_data
      .destroy_asymmetric_unit
      .destroy_data
   end

   destroy_data ::: leaky
   ! Erase all data pointer information
    nullify(.data)
    .xray_data.destroy
    .pnd_data.destroy
    .xray_r_free_data.destroy
    .pnd_r_free_data.destroy
    .core_reflection.destroy
   end

   destroy_fragment_data ::: leaky
   ! Destroy the geometry and symmetry data for the fragment and unit cell.
   ! NOTE: Don't destroy asymmetric unit atom info

      .fragment_atom.destroy
      .fragment_geometry.destroy

      ! Never destroy .asymmetric_unit_geometry
      ! Never destroy .asymmetric_unit_atom

      .unit_cell_geometry.destroy
      .unique_unit_cell_atom.destroy
      .unique_uc_atom_offset.destroy
      .is_asym_unit_cell_atom.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .asym_symop_for_unit_cell_atom.destroy

      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .frag_atom_for_asym_atom.destroy
      .asym_atom_for_frag_atom.destroy
      .frag_parent_for_cell_atom.destroy

      .unique_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .unique_symop_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_shift_for_frag_atom.destroy

      if (NOT .use_manual_repetition_factors) .repetition_factor.destroy
      .asym_atom_rep_factor.destroy
      .asym_atom_stabilizer.destroy

      .unit_cell_connection.destroy
      .uc_vdw_connection.destroy
      .unit_cell_mol_for_atom.destroy

      .stabilizer_symop.destroy
      .str.destroy
      .ptr.destroy
      .dtr.destroy
      .ftr.destroy
      .gtr.destroy

      .fragment_info_made = FALSE

   end

   destroy_asymmetric_unit ::: leaky
   ! Destroy the asymmetric unit geometry. Normally this will be set
   ! by reading a CIF file. If not, it will be set from a given
   ! fragment atom list, in the "make_fragment_data" routine. Once
   ! set, it is never destroyed unless explicitly requested by a call
   ! or a keyword.
      .asymmetric_unit_geometry.destroy ! This is nothing to do with a fragment !
      .asymmetric_unit_atom.destroy
      .asymmetric_unit_source = "?"
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(crystal) ::: leaky
   ! Set self to be crystal.
      crystal :: CRYSTAL, IN

      self = crystal

      .nullify_ptr_part

      .spacegroup.copy(crystal.spacegroup)
      .unit_cell.copy(crystal.unit_cell)

      if (crystal.fragment_geometry.created)        .fragment_geometry.create_copy(crystal.fragment_geometry)
      if (crystal.asymmetric_unit_geometry.created) .asymmetric_unit_geometry.create_copy(crystal.asymmetric_unit_geometry)
      if (crystal.asymmetric_unit_atom.created)     .asymmetric_unit_atom.create_copy(crystal.asymmetric_unit_atom)

      if (crystal.unit_cell_geometry.created)            .unit_cell_geometry.create_copy(crystal.unit_cell_geometry)
      if (crystal.unique_unit_cell_atom.created)         .unique_unit_cell_atom.create_copy(crystal.unique_unit_cell_atom)
      if (crystal.unique_uc_atom_offset.created)         .unique_uc_atom_offset.create_copy(crystal.unique_uc_atom_offset)
      if (crystal.is_asym_unit_cell_atom.created)        .is_asym_unit_cell_atom.create_copy(crystal.is_asym_unit_cell_atom)
      if (crystal.asym_atom_for_unit_cell_atom.created)  .asym_atom_for_unit_cell_atom.create_copy(crystal.asym_atom_for_unit_cell_atom)
      if (crystal.asym_symop_for_unit_cell_atom.created) .asym_symop_for_unit_cell_atom.create_copy(crystal.asym_symop_for_unit_cell_atom)

      if (crystal.frag_atom_for_unit_cell_atom.created)  .frag_atom_for_unit_cell_atom.create_copy(crystal.frag_atom_for_unit_cell_atom)
      if (crystal.unit_cell_atom_for_frag_atom.created)  .unit_cell_atom_for_frag_atom.create_copy(crystal.unit_cell_atom_for_frag_atom)
      if (crystal.frag_atom_for_asym_atom.created)       .frag_atom_for_asym_atom.create_copy(crystal.frag_atom_for_asym_atom)
      if (crystal.asym_atom_for_frag_atom.created)       .asym_atom_for_frag_atom.create_copy(crystal.asym_atom_for_frag_atom)
      if (crystal.frag_parent_for_cell_atom.created)     .frag_parent_for_cell_atom.create_copy(crystal.frag_parent_for_cell_atom)

      if (crystal.unique_frag_atom.created)              .unique_frag_atom.create_copy(crystal.unique_frag_atom)
      if (crystal.unique_atom_for_frag_atom.created)     .unique_atom_for_frag_atom.create_copy(crystal.unique_atom_for_frag_atom)
      if (crystal.unique_symop_for_frag_atom.created)    .unique_symop_for_frag_atom.create_copy(crystal.unique_symop_for_frag_atom)
      if (crystal.asym_symop_for_frag_atom.created)      .asym_symop_for_frag_atom.create_copy(crystal.asym_symop_for_frag_atom)
      if (crystal.asym_shift_for_frag_atom.created)      .asym_shift_for_frag_atom.create_copy(crystal.asym_shift_for_frag_atom)

      if (crystal.repetition_factor.created)    .repetition_factor.create_copy(crystal.repetition_factor)
      if (crystal.asym_atom_rep_factor.created) .asym_atom_rep_factor.create_copy(crystal.asym_atom_rep_factor)
      if (crystal.asym_atom_stabilizer.created) .asym_atom_stabilizer.create_copy(crystal.asym_atom_stabilizer)

      if (crystal.unit_cell_connection.created)   .unit_cell_connection.create_copy(crystal.unit_cell_connection)
      if (crystal.uc_vdw_connection.created)      .uc_vdw_connection.create_copy(crystal.uc_vdw_connection)
      if (crystal.unit_cell_mol_for_atom.created) .unit_cell_mol_for_atom.create_copy(crystal.unit_cell_mol_for_atom)

      if (crystal.stabilizer_symop.created)  .stabilizer_symop.create_copy(crystal.stabilizer_symop)
      if (crystal.str.created)               .str.create_copy(crystal.str)
      if (crystal.ptr.created)               .ptr.create_copy(crystal.ptr)
      if (crystal.dtr.created)               .dtr.create_copy(crystal.dtr)
      if (crystal.ftr.created)               .ftr.create_copy(crystal.ftr)
      if (crystal.gtr.created)               .gtr.create_copy(crystal.gtr)

      if (crystal.xray_data.created) .xray_data.create_copy(crystal.xray_data)
      if (crystal.pnd_data.created)  .pnd_data.create_copy(crystal.pnd_data)

      if (crystal.core_reflection.created) .core_reflection.create_copy(crystal.core_reflection)

   end

!  ***********
!  Set methods
!  ***********

   set_defaults ::: leaky
   ! Set up a default crystal object

      .CIF_chemical_formula          = "?"
      .n_fragment_atoms              = 0
      .asymmetric_unit_source        = "?"
      .n_asymmetric_unit_atoms       = 0
      .prune_asymmetric_unit         = TRUE
      .n_unit_cell_atoms             = 0
      .fragment_info_made            = FALSE
      .n_unique_frag_atoms           = 0
      .Z                             = ZERO
      .use_manual_repetition_factors = FALSE
      .n_unit_cell_mols              = 0
      .n_stabilizer_symops           = 0
      .data_kind                     = "?"
      .r_free_percentage             = 0
      .finalize                      = TRUE

      ! Subtype defaults
      .spacegroup.set_defaults
      .unit_cell.set_defaults

      ! Set xray_data defualts
      if (.xray_data.created) then; .xray_data.set_defaults
      else;                         nullify(.xray_data)
      end

      ! Set pnd_data defualts
      if (.pnd_data.created) then;  .pnd_data.set_defaults
      else;                         nullify(.pnd_data)
      end

   end

   update ::: leaky
   ! Update the crystal information after setting values.
      if (.xray_data.created) then
        .xray_data.update(.unit_cell,.spacegroup)
        if (.r_free_percentage>0 AND .xray_data.reflections.created) then
           .xray_r_free_data.destroy
           .xray_r_free_data.create_copy(.xray_data)
           .xray_r_free_data.reflections.destroy
           .set_r_free_reflections(.xray_data.reflections,.xray_r_free_data.reflections)
        end
      end
      if (.pnd_data.created) then
        .pnd_data.update(.unit_cell,.spacegroup)
        if (.r_free_percentage>0 AND .pnd_data.reflections.created) then
           .pnd_r_free_data.destroy
           .pnd_r_free_data.create_copy(.xray_data)
           .pnd_r_free_data.reflections.destroy
           .set_r_free_reflections(.pnd_data.reflections,.pnd_r_free_data.reflections)
        end
      end
   end

   set_r_free_reflections(data,free_data) ::: leaky
   ! Set the R free reflection data. "data" is destroyed and created
   ! again without those reflections in "free_data".
      data,free_data :: VEC{REFLECTION}*

   ENSURE(data.created,"no diffraction data")
   ENSURE(free_data.destroyed,"r_free_data exists")

      keep_data :: VEC{REFLECTION}*
      harvest :: VEC{REAL}* 
      free,keep :: VEC{INT}* 
      percentage :: REAL
      i,n :: INT

      if (.r_free_percentage<=0) return
      if (data.destroyed) return

      ! Set the percentage of reflections to reject
      percentage = .r_free_percentage/100.0d0

      ! Harvest random numbers
      n = data.dim
      harvest.create(n)
      call random_number(harvest)

      ! Reflections for r_free have p<percentage
      ! Otherwise, they are kept and used for fitting
      nullify(free)
      nullify(keep)
      do i = 1,n
         if (harvest(i)<percentage) then; free.append(i)
         else;                            keep.append(i)
         end
      end
      harvest.destroy

      stdout.show("No. of reflections kept for R free =",free.dim)
      stdout.flush

      ! Set free_data
      free_data.create(free.dim)
      free_data = data(free)
      free.destroy

      ! Reset data to the kept data
      keep_data.create(keep.dim)
      keep_data = data(keep)
      keep.destroy
      data.destroy
      data => keep_data

   end

   assign_xray 
   ! Assign data to the xray_data
   ENSURE(.xray_data.created, "No X-ray reflection data")
      nullify(.data)
      .data => .xray_data
   end

   assign_xray_r_free
   ! Assign data to the xray_r_free_data
   ENSURE(.xray_r_free_data.created, "No X-ray R-free reflection data")
      nullify(.data)
      .data => .xray_r_free_data
   end

   assign_pnd 
   ! Assign data to the pnd_data
   ENSURE(.pnd_data.created, "No PND reflection data")
      nullify(.data)
      .data => .pnd_data
   end

   assign_pnd_r_free
   ! Assign data to the pnd_r_free_data
   ENSURE(.pnd_r_free_data.created, "No PND R-free PND reflection data")
      nullify(.data)
      .data => .pnd_r_free_data
   end

!  ************
!  Read methods
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR

      word :: STR

      word = keyword
      word.to_lower_case

      select case (word)
         case ("}                             ")  ! exit read_loop
         case ("asymmetric_unit_geometry=     "); .read_asymmetric_unit_geometry
         case ("debug_on                      "); .read_debug_on
         case ("debug_off                     "); .read_debug_off
         case ("destroy                       "); .destroy_ptr_part; .set_defaults
         case ("destroy_asymmetric_unit       "); .destroy_asymmetric_unit
         case ("destroy_spacegroup            "); .spacegroup.destroy_ptr_part
         case ("expand_unique_reflections     "); .expand_unique_reflections
         case ("finalize=                     "); .read_finalize
         case ("junk=                         "); CRYSTAL::read_junk
         case ("kind=                         "); .read_kind
         case ("merge_equivalents             "); .merge_equivalents
         case ("merge_ordered_equivalents     "); .merge_ordered_equivalents
         case ("pnd_data=                     "); .read_pnd_data
         case ("prune_asymmetric_unit=        "); .read_prune_asymmetric_unit
         case ("put                           "); .put
         case ("put_bond_info_with_errors     "); .put_bond_info_with_errors
         case ("put_bond_info_with_errors_to  "); .put_bond_info_with_errors_to
         case ("r_free_percentage=            "); .read_r_free_percentage
         case ("read_cif                      "); .read_CIF
         case ("redirect                      "); .redirect
         case ("repetition_factors=           "); .read_repetition_factors
         case ("revert                        "); .revert
         case ("spacegroup=                   "); .read_spacegroup
         case ("unit_cell=                    "); .read_unit_cell
         case ("units=                        "); CRYSTAL::read_units
         case ("use_manual_repetition_factors="); .read_use_manual_rep_factors
         case ("xray_data=                    "); .read_xray_data
         case default;                       UNKNOWN(word)
      end

   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), selfless, private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.data_kind)
      .data_kind.to_lower_case
      select case (.data_kind)
         case("x-ray")
         case("pnd  ")
         case default; UNKNOWN(.data_kind)
      end
   end

   read_finalize
   ! Read whether to finalize the object.
      stdin.read(.finalize)
   end

   read_r_free_percentage
   ! Read the R free percentage
      stdin.read(.r_free_percentage)
      DIE_IF(.r_free_percentage<0,  "percentage must be non-negative")
      DIE_IF(.r_free_percentage>100,"percentage must be less than 100")
   end

   read_spacegroup ::: leaky
   ! Read the spacegroup
      .spacegroup.read_keywords
      .spacegroup.analyse
   end

   read_unit_cell 
   ! Read the unit cell information
      .unit_cell.read_keywords
      .unit_cell.make_info
   end

   read_xray_data ::: leaky
   ! Read in the xray diffraction data

      WARN_IF(.xray_data.created,"xray diffraction data already defined!")

      if (.xray_data.destroyed) .xray_data.create
      .xray_data.data_kind = "x-ray"

      .xray_data.read_keywords

      .xray_data.update
      .assign_xray

      ! Prune
      if (.xray_data.reflections.created) then
      if (.xray_data.reflections.have_F_exp) then
         .data.prune_negative_F_exp
      end
      end

   end

   read_pnd_data ::: leaky
   ! Read in the pnd diffraction data

      WARN_IF(.pnd_data.created,"pnd diffraction data already defined!")

      if (.pnd_data.destroyed) .pnd_data.create

      .pnd_data.data_kind = "pnd"

      .pnd_data.read_keywords

      .pnd_data.update
      .assign_pnd

   end

   read_use_manual_rep_factors ::: leaky, private
   ! Read whether to use manually entered repetition factors.
   ! If set set FALSE, the repetition factors will be destroyed.
      stdin.read(.use_manual_repetition_factors)
      if (.use_manual_repetition_factors) return
      .repetition_factor.destroy
   end

   read_repetition_factors ::: leaky, private
   ! Read in the crystal fragment repetition factors. Useful to get structure
   ! factor contributions from a small portion of the fragment.
      .repetition_factor.destroy
      stdin.read_ptr(.repetition_factor)
      .use_manual_repetition_factors = TRUE
   end

   read_prune_asymmetric_unit ::: private
   ! Read whether to prune the asymmetric unit or not. Sometimes the asymmetric
   ! unit may not be asymmetric i.e. it may have symmetry-equivalent atoms
   ! repeated. This could be because of an input or CIF file error, or it could
   ! be genuinely correct because the repeated atom corresponds to a disordered
   ! position. For Hirshfeld surface plots, which can cope with disorder, you
   ! probably do not want to prune the asymmetric atom list, but for crystal
   ! calculations you must do so.
      stdin.read(.prune_asymmetric_unit)
   end

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File object, with
   ! the "name" taken from stdin.

      name :: STR
      found :: BIN
      cif :: CIF*

      ! Read name from stdin
      stdin.read(name)

      ! Create and open the CIF
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif,skip_atoms) ::: leaky
   ! Read information from a Crystallographic Information File object, "cif".
   ! If "skip_atoms" is present and TRUE, the atom coordinates are not processed.
      cif :: CIF
      skip_atoms :: BIN, optional
      skip,found :: BIN
      itemvec :: VEC{STR}*

      skip = FALSE
      if (present(skip_atoms)) skip = skip_atoms

      .set_defaults

      ! Read the chemical formula if it is there
      nullify(itemvec)
      cif.read_item("_chemical_formula_sum",.CIF_chemical_formula,itemvec,found)
      if (NOT found) .CIF_chemical_formula = "?"
      DIE_IF(itemvec.created,"multi line chemical formula")

      ! Read the spacegroup 
      .spacegroup.read_CIF(cif)

      ! Read the unit cell
      .unit_cell.read_CIF(cif)

      ! Read the atom list (if requested)
      if (NOT skip) .read_CIF_atoms(cif)

      .update

      ! Eventually, this will be used
      .asymmetric_unit_source = "from-cif"

   end

   read_CIF_atoms(cif) ::: leaky, private
   ! Read atom information from a CIF file, "cif"
   ! This populates the asymmetric_unit_geometry
      cif :: CIF

      ID :: STR
      fs,fx,fy,fz :: BIN
      labels :: VEC{STR}*
      x,y,z :: VEC{REAL}*
      n :: INT

      ! Look for ID's
      ID = "_atom_site_type_symbol"
      cif.find_looped_item(trim(ID),fs)

      ! Try harder to find ID's
      if (NOT fs) then
      ID = "_atom_site_label"
      cif.find_looped_item(trim(ID),fs)
      end

      ! Find coordinated
      cif.find_looped_item("_atom_site_fract_x",fx)
      cif.find_looped_item("_atom_site_fract_y",fy)
      cif.find_looped_item("_atom_site_fract_z",fz)

      ! Found everything?
      ENSURE(fs AND fx AND fy AND fz,"incomplete atom information in CIF file")

      ! Everything's there; read it
      cif.read_looped_item(trim(ID),labels)
      cif.read_looped_item("_atom_site_fract_x",x)
      cif.read_looped_item("_atom_site_fract_y",y)
      cif.read_looped_item("_atom_site_fract_z",z)

      ! Assign the CIF info
      ! Warning: sometimes people don't really put 
      ! an asymmetric unit into the cif
      n = labels.dim
      .n_asymmetric_unit_atoms = n
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,n)
      .asymmetric_unit_geometry(1,:) = x
      .asymmetric_unit_geometry(2,:) = y
      .asymmetric_unit_geometry(3,:) = z

      ! Clean
      z.destroy; y.destroy; x.destroy
      labels.destroy

      .asymmetric_unit_source = "from-cif"

   end

   read_asymmetric_unit_geometry
   ! Read in the asymmetric unit geometry in crystal coordinates.
   ! The coordinates are read in as a single vector ordered as x,y,z
   ! incrementing fastest, for the first to the last atom.
      geometry :: VEC{REAL}*

   WARN_IF(.asymmetric_unit_geometry.created,"asymmetric_unit_geometry exists!")

      stdin.read_ptr(geometry)
      ENSURE(modulo(geometry.dim,3)==0,"number of coordinates must be divisible by 3")

      .n_asymmetric_unit_atoms = geometry.dim/3
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,.n_asymmetric_unit_atoms)
      .asymmetric_unit_geometry = reshape(geometry,[3,.n_asymmetric_unit_atoms])
      geometry.destroy

      .asymmetric_unit_source = "manual-input"

   end

!   set_asymmetric_unit_geometry(geometry) ::: leaky
!   ! Set the asymmetric unit geometry from a CARTESIAN "geometry".
!   ! This is useful if the atomic coordinates have been processed from
!   ! a CIF elsewhere, e.g. in the VEC{ATOM} module.
!      geometry :: MAT{REAL}
!
!   ENSURE(geometry.dim1==3,"wrong 1st dimensions, geometry")
!
!      .destroy_asymmetric_unit
!
!      .n_asymmetric_unit_atoms = geometry.dim2
!      .asymmetric_unit_geometry.create(3,geometry.dim2)
!      .asymmetric_unit_geometry = matmul(.unit_cell.inverse_matrix,geometry)
!
!   end

!   set_asymmetric_unit_geometry(atom) ::: leaky
!   ! Set the asymmetric unit geometry from a list of the asymmetric
!   ! units "atoms". NOTE: coordinates must be cartesian.
!      atom :: VEC{ATOM}
!
!   ENSURE(.unit_cell.info_made,"no unit cell info")
!
!      n,a :: INT
!
!      .destroy_asymmetric_unit
!
!      n = atom.dim
!      .n_asymmetric_unit_atoms = n
!      .asymmetric_unit_geometry.create(3,n)
!
!      ! Assign the positions; convert to crystal axis system
!      do a = 1,n
!         .asymmetric_unit_geometry(:,a) = matmul(.unit_cell.inverse_matrix,atom(a).position)
!      end
!
!   end

!  ***************
!  General methods
!  ***************

   make_k_pts(k_pt)
   ! Convert the .reflection.hkl indices to reciprocal lattice vectors
   ! Dimension of "k_pt" is [.n_refl,3]
      k_pt :: MAT{REAL}, OUT

   ENSURE(.data.created,"no data")

      n :: INT
      hkl :: VEC{INT}(3)
      rcm :: MAT{REAL}(3,3)

      rcm = TWO*PI*.unit_cell.reciprocal_matrix

      do n = 1,.data.reflections.n_refl

         hkl = .data.reflections.indices(n)

         k_pt(n,1) = dot_product(rcm(1,:),hkl(:))
         k_pt(n,2) = dot_product(rcm(2,:),hkl(:))
         k_pt(n,3) = dot_product(rcm(3,:),hkl(:))

      end

   end

   n_unique_SF_k_pts result (res) ::: pure
   ! The number of unique k-points for an SF calculation
      self :: IN
      res :: INT

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      res = .spacegroup.n_unique_SF_symops * .data.reflections.dim

   end

   make_unique_SF_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! for structure factor calculations.
   ! (c) Dylan Jayatilaka, UWA, feb 1996
      k :: MAT{REAL}

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.spacegroup.unique_SF_symop.created,"no unique_SF_symop array!")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")
   ENSURE(k.dim1==.n_unique_SF_k_pts,"wrong dim1, k")
   ENSURE(k.dim2==3,"wrong dim2, k")

      p,u,n :: INT
      b,rcm,symop :: MAT{REAL}(3,3)
      hkl :: VEC{INT}(3)

      rcm = TWO*PI*.unit_cell.reciprocal_matrix

      p = 0

      do u = 1,.spacegroup.n_unique_SF_symops

         symop = .spacegroup.unique_SF_symop_mat(u)
         symop = transpose(symop)
         b = matmul(rcm,symop)

         do n = 1,.data.reflections.dim
            p = p + 1
            hkl(1) = .data.reflections(n).h
            hkl(2) = .data.reflections(n).k
            hkl(3) = .data.reflections(n).l
            k(p,1) = dot_product(b(1,:),hkl)
            k(p,2) = dot_product(b(2,:),hkl)
            k(p,3) = dot_product(b(3,:),hkl)
         end

      end

   end

!  *****************************************
!  Fragment data, Unique operators, Z number
!  *****************************************

   make_fragment_data(atom,warnings) ::: leaky
   ! This routine sets the ".fragment_geometry" from the "atom" list.
   ! The fragment is a portion or model of the crystal, perhaps one
   ! molecule or a cluster of atoms. Then:
   ! A. The .asymmetric_unit_geometry is defined from the symmetry
   !    unique "atoms", if it is not already defined. If it is already
   !    defined the fragment atoms must be symmetry related to these
   !    asymmetric unit atom positions. The asymmetric unit is crucial
   !    NOTE: The .asymmetric_unit_geometry is never destroyed
   ! B. The .asymmetric_unit_atom array is defined from the "atom"
   !    list if possible, This array is never destroyed unless
   !    explicitly requested.
   ! 1. The .unit_cell_geometry is made from the asymmetric unit. 
   !    Mapping arrays which relate the unit cell atoms to the
   !    asymmetric unit atoms are made, 
   ! 2. Other mapping arrays are made which relate the fragment atoms
   !    to the unique asymmetric unit atoms, including sometimes the
   !    symops needed to generate them.
   ! 3. The .repetition factors needed for structure factor calcs on
   !    the fragment are made. The Z number is made.
   !    unchanged (the stabilizer) is made
   ! 4. The unit cell connection table is made.
   ! 5. The set of symmetry operations which leave the fragment
   !    unchanged (the stabilizer) is made
      atom :: VEC{ATOM}*
      warnings :: BIN, optional

   ENSURE(atom.created,"no atom array")

      if (NOT .spacegroup.analysed) return

      ! Store the fragment atom list
      .fragment_atom.create_copy(atom)

      ! Get fragment geometry from the atom list
      .fragment_geometry.destroy
      .fragment_geometry => .fragment_atom.geometry(skip_dummies=TRUE)
      .n_fragment_atoms  = .fragment_geometry.dim2
      .unit_cell.change_into_fractional(.fragment_geometry)

      ! Make asymmetric unit and unit cell geometry from fragment
      ! geometry ... only if they don't already exist
      if (.asymmetric_unit_geometry.destroyed) then
         .make_asymmetric_unit(.prune_asymmetric_unit,warnings)
         if (.asymmetric_unit_source=="?") &
             .asymmetric_unit_source = "from-fragment"
      end

      ! Sanity check
      DIE_IF(.asymmetric_unit_atom.destroyed,"no asymmetric_unit_atom list!")

      if (.debugging("make_fragment_data")) then
         stdout.text("fragment atoms:")
         .fragment_atom.put_coordinates
         stdout.text("asymmetric unit atoms:")
         .asymmetric_unit_atom.put_coordinates
      end

      ! Relate fragment atoms to unit cell
      .make_frag_atom_for_cell_atom

      ! Make unique fragment atoms
      .make_unique_frag_atoms

      ! Make the unit cell connection table
      .make_unit_cell_connections
      .make_uc_vdw_connections

      ! Z factors and zep. factors for SF calculations
      .make_repetition_factors     
      .make_asym_atom_rep_factors     
      .Z = .z_factor

      ! Symops which leave fragment_geometry unchanged
      .make_stabilizer_symops 
      .make_stabilizer_xyz_matrices 

      .fragment_info_made = TRUE

   end

   make_fragment_data(fragment_geometry,cartesian) ::: leaky
   ! Makes an atom list from "fragment_geometry" to which
   ! .fragment_atoms gets set. The .asymmetric_unit_atoms (which must
   ! be in cartesian system) and .unit_cell_geometry have to be
   ! defined. Set "cartesian" to TRUE if the "fragment_geometry" is in
   ! cartesians.
      fragment_geometry :: MAT{REAL}, IN
      cartesian :: BIN, optional

   ENSURE(.unit_cell_geometry.created,           "no .unit_cell_geometry") 
   ENSURE(.asymmetric_unit_atom.created,         "no .asymmetric_unit_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.created, "no .asym_atom_for_unit_cell_atom")

      atom  :: VEC{ATOM}*
      pf,pu,pc :: VEC{REAL}(3)
      fg :: MAT{REAL}*
      f,u,a :: INT
      tol :: REAL
      fn :: STR
      cart,found :: BIN

      cart = FALSE
      if (present(cartesian)) cart = cartesian

      ! Transform fragment geometry to fractional
      fg.create_copy(fragment_geometry)
      if (cart) .unit_cell.change_into_fractional(fg)

      ! Create the atom list -- leaky
      atom.create(fg.dim2)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = TOL(3)    

      ! Find and create fragment atoms
      do f = 1,fg.dim2

         ! Shift fragment atom to unit cell
         pf = fg(:,f)
         .put_to_unit_cell(pf)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            ! Is u the same as f?
            pu = .unit_cell_geometry(:,u)
            found = pu.same_as(pf,tol) 

            if (NOT found) cycle

            ! Set atom f
            a = .asym_atom_for_unit_cell_atom(u)
            atom(f) = .asymmetric_unit_atom(a)

            ! Set its coordinates
            pc = fg(:,f)
            .unit_cell.change_from_fractional(pc)
            atom(f).set_position(pc)

            exit 

         end

         DIE_IF(NOT found,"fragment atom "//trim(f.to_str)//" was not found in the unit cell")

      end

      ! Make the fragment data
      .make_fragment_data(atom,warnings=FALSE)

      ! Clean
      atom.destroy
      fg.destroy

   end

   make_asymmetric_unit(prune_asymmetric_unit,warnings) ::: leaky, private
   ! Get the all the atom positions in the unit cell. Also make the
   ! symops associated with each unit cell atom when it is made from
   ! the asymmetric unit atoms. If "prune_asymmetric_unit" is present
   ! and true, any non-asymmetric unit atoms are eliminated from the
   ! asymmetric unit. This should always be done.
      prune_asymmetric_unit,warnings :: BIN, optional

   ENSURE(.fragment_atom.created,"no .fragment_atom") 
   ENSURE(.fragment_geometry.created,"no .fragment_geometry") 
   ENSURE(.asymmetric_unit_geometry.destroyed,"asymmetric unit exists") 

      pa :: VEC{REAL}(3)
      offset :: VEC{INT}(3)
      asymmetric_unit_geometry :: MAT{REAL}*
      n,a,m,s,col,b :: INT
      prune,warn,found,unique,disorder :: BIN
      list :: VEC{INT}*
      tol :: REAL

      ! Set default options
      prune = TRUE
      warn = TRUE
      if (present(prune_asymmetric_unit)) prune = prune_asymmetric_unit
      if (present(warnings)) warn = warnings

      ! Clean up from before
      .unit_cell_geometry.destroy
      .unique_unit_cell_atom.destroy
      .unique_uc_atom_offset.destroy
      .is_asym_unit_cell_atom.destroy
      .asym_atom_for_unit_cell_atom.destroy
      .asym_symop_for_unit_cell_atom.destroy

      ! Indices of asymmetric unit atoms to be made
      list.create(.n_fragment_atoms)
      list = [(a, a=1,.n_fragment_atoms)]

      ! Initialise asymmetric unit
      .asymmetric_unit_geometry.create_copy(.fragment_geometry)
      .n_asymmetric_unit_atoms = .n_fragment_atoms

      ! Take a copy, put it to the unit cell
      asymmetric_unit_geometry.create_copy(.asymmetric_unit_geometry)
      .put_to_unit_cell(asymmetric_unit_geometry)

      ! Append new atoms "n" to unit cell
      .unit_cell_geometry.create(3,0)

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = TOL(2)/maxval(.unit_cell.length) 
      tol = TOL(3)

      ! Initial loop counters
      disorder = FALSE
      n = 0
      a = 0

      ! Loop: atoms "a" 
      ! in the asymmetric unit
      do 

         ! Next asymmetric unit atom
         a = a + 1

         ! Loop over symops
         do s = 1,.spacegroup.n_seitz

            ! <<< Transform asym unit with symop >>>
            pa = .asymmetric_unit_geometry(:,a)
            .transform_position(pa,1,to_unit_cell=TRUE,unit_cell_shift=offset)

            pa = asymmetric_unit_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)

            ! Is the new position already in the asymmetric unit?
            ! If not, are the atoms at the two sites distinct?
            unique = NOT asymmetric_unit_geometry(:,a+1:).has_column(pa,tol,col)
            if (NOT unique) unique = .fragment_atom.are_distinct(list(a),list(col+a))

            ! If not new, we may have to prune ...
            if (NOT unique) then

               col = col + a
               disorder = TRUE

               if (prune) then

                  do ! Prune all repetitions

                     m = max(a,col)

                     .n_asymmetric_unit_atoms = .n_asymmetric_unit_atoms - 1
                     .asymmetric_unit_geometry.prune_column(m)
                      asymmetric_unit_geometry.prune_column(m)
                     list.prune_element(m)

                     unique = NOT asymmetric_unit_geometry(:,a+1:).has_column(pa,tol,col)
                     if (NOT unique) unique = .fragment_atom.are_distinct(list(a),list(col+a))
                     if (unique) exit
                     col = col + a

                  end

               end

            end ! -- NOT unique

            ! Is the new position already in the unit cell?
            ! If so, is it a distinct atom?
            found = .unit_cell_geometry.has_column(pa,tol,col)
            if (found) then
               b      = .asym_atom_for_unit_cell_atom(col)
               found  = NOT .fragment_atom.are_distinct(list(a),list(b))
            end

            if (found) cycle

            ! New unit cell atom here ...
            n = n + 1 
            .unit_cell_geometry.append_column(pa)
            .asym_atom_for_unit_cell_atom.append(a)
            .asym_symop_for_unit_cell_atom.append(s)

            ! If s=1 it must be an asymmetric unit atom
            if (s==1) then
               .unique_unit_cell_atom.append(n)
               .unique_uc_atom_offset.append(offset)
               .is_asym_unit_cell_atom.append(TRUE)
            else
               .is_asym_unit_cell_atom.append(FALSE)
            end

         end

         ! Finished?
         if (a==.n_asymmetric_unit_atoms) exit

      end

      .n_unit_cell_atoms = n

      WARN_IF(warn AND disorder,"This structure may be disordered")
      WARN_IF(warn AND disorder AND prune,"I had to prune redundant atoms from the unit cell")
      ENSURE(.unit_cell_geometry.created,"could not make unit_cell_geometry")

      ! Make the asymmetric unit atom list
      .asymmetric_unit_atom.create_copy(.fragment_atom(list))

      ! Clean
      asymmetric_unit_geometry.destroy
      list.destroy

   end

   make_frag_atom_for_cell_atom ::: leaky, private
   ! Arrays which relate the fragment atoms to the unit cell atoms.

   ENSURE(.fragment_atom.created,                "no .fragment_atom") 
   ENSURE(.fragment_geometry.created,            "no .fragment_geometry") 
   ENSURE(.unit_cell_geometry.created,           "no .unit_cell_geometry") 
   ENSURE(.asymmetric_unit_atom.created,         "no .asymmetric_unit_atom")
   ENSURE(.asym_atom_for_unit_cell_atom.created, "no .asym_atom_for_unit_cell_atom")
   ENSURE(.asym_symop_for_unit_cell_atom.created,"no .asym_symop_for_unit_cell_atom")
   ENSURE(.spacegroup.analysed,                  "no spacegroup info") 

      pu,pa,pf :: VEC{REAL}(3)
      u,f,a,s :: INT
      found :: BIN
      tol :: REAL

      ! Tolerances to see if atom positions are the same
      ! --- getting this number wrong can stuff things
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)    

      ! Create the arrays we want
      .frag_atom_for_unit_cell_atom.destroy
      .unit_cell_atom_for_frag_atom.destroy
      .frag_atom_for_asym_atom.destroy
      .asym_atom_for_frag_atom.destroy
      .asym_symop_for_frag_atom.destroy
      .asym_shift_for_frag_atom.destroy

      .frag_atom_for_unit_cell_atom.create(.n_unit_cell_atoms)
      .unit_cell_atom_for_frag_atom.create(.n_fragment_atoms)
      .frag_atom_for_asym_atom.create(.n_asymmetric_unit_atoms)
      .asym_atom_for_frag_atom.create(.n_fragment_atoms)
      .asym_symop_for_frag_atom.create(.n_fragment_atoms)
      .asym_shift_for_frag_atom.create(3,.n_fragment_atoms)

      ! Initialise
      .frag_atom_for_unit_cell_atom = 0
      .unit_cell_atom_for_frag_atom = 0
      .frag_atom_for_asym_atom = 0
      .asym_atom_for_frag_atom = 0

      ! Loop over fragment atoms
      do f = 1,.n_fragment_atoms

         ! Shift fragment atom to unit cell
         pf = .fragment_geometry(:,f)
         .put_to_unit_cell(pf)

         found = FALSE

         ! Loop unit cell atoms
         do u = 1,.n_unit_cell_atoms

            ! Asymmetric atom a for unit cell atom u
            a = .asym_atom_for_unit_cell_atom(u)

            ! Unit cell position
            pu = .unit_cell_geometry(:,u)

            ! Is unit cell atom u the fragment atom f?
            found = pu.same_as(pf,tol) 
            found = found AND .asymmetric_unit_atom(a).is_xtal_identical_to(.fragment_atom(f))

            ! Cycle if not the same
            if (NOT found) cycle

            ! Relate unit cell atom and fragment atom
            ! These are identical by translation.
            .frag_atom_for_unit_cell_atom(u) = f
            .unit_cell_atom_for_frag_atom(f) = u

            ! Relate asym unit atom and fragent atom
            ! Maybe >1 frag atom  matching the asym atom
            .asym_atom_for_frag_atom(f) = a
            if (.frag_atom_for_asym_atom(a)==0) &
                .frag_atom_for_asym_atom(a) = f

            ! Asym symop which can generate this frag atom
            s = .asym_symop_for_unit_cell_atom(u)
            .asym_symop_for_frag_atom(f) = s
   
            ! Get shift for asym atom -> frag atom
            pa = .asymmetric_unit_geometry(:,a)
            pf = .fragment_geometry(:,f)
            .transform_position(pa,s,ignore_glide=TRUE)
            .asym_shift_for_frag_atom(:,f) = pf - pa


            exit 

         end

         DIE_IF(NOT found,"fragment atom "//f.to_str.trim//" was not found in the unit cell")

      end

      ! Relate unit cell atom to parent frag atom
      ! These are identical by a crystal symop.
      .frag_parent_for_cell_atom.destroy
      .frag_parent_for_cell_atom.create(.n_unit_cell_atoms)
      do u = 1,.n_unit_cell_atoms
         a = .asym_atom_for_unit_cell_atom(u)
         f = .frag_atom_for_asym_atom(a)
         .frag_parent_for_cell_atom(u) = f
      end

   end

   make_unique_frag_atoms ::: leaky, private
   ! Make the unique fragment atoms (these are those corresponding to
   ! the asymmetric unit atoms) and also make symops which relate the
   ! non-unique to the unique.
   ENSURE(.asym_atom_for_frag_atom.created, "no .asym_atom_for_frag_atom") 
   ENSURE(.unit_cell_atom_for_frag_atom.created, "no .unit_cell_atom_for_frag_atom") 
   ENSURE(.asym_symop_for_unit_cell_atom.created,"no .asym_symop_for_unit_cell_atom") 

      f,a,m,u,s,t :: INT
      unique :: BIN

      ! Create the arrays we want
      .unique_frag_atom.destroy
      .unique_atom_for_frag_atom.destroy
      .unique_symop_for_frag_atom.destroy

      .unique_atom_for_frag_atom.create(.n_fragment_atoms)
      .unique_symop_for_frag_atom.create(.n_fragment_atoms)

      .n_unique_frag_atoms = 0

      ! Loop over the fragment atoms
      do f = 1,.n_fragment_atoms

         ! Asym atom for this fragment atom
         a = .asym_atom_for_frag_atom(f)

         ! Asym symop which can generate this frag atom
         u = .unit_cell_atom_for_frag_atom(f)
         s = .asym_symop_for_unit_cell_atom(u)

         ! Does this asym atom "a" occur before? 
         ! If not, its unique.
         m = .asym_atom_for_frag_atom(1:f-1).index_of_value(a)
         unique = m==0
         if (unique) then
            .n_unique_frag_atoms = .n_unique_frag_atoms + 1
            .unique_atom_for_frag_atom(f) = f
            .unique_symop_for_frag_atom(f) = 1 ! identity
            .unique_frag_atom.append(f)
         else
            .unique_atom_for_frag_atom(f) = m
            u = .unit_cell_atom_for_frag_atom(m)
            t = .asym_symop_for_unit_cell_atom(u)
            t = .spacegroup.inverse_of_symops(t)   ! inverse of symop(t) maps m -> a
            t = .spacegroup.product_of_symops(s,t) ! s maps a -> f (except for trans)
            .unique_symop_for_frag_atom(f) = t
         end

      end

   end

   make_unit_cell_connections ::: leaky
   ! From the .asymmetric_unit_atom list make the .unit_cell_connection
   ! table and the .unit_cell_mol_for_atom list which has the list of
   ! distinct molecules in the unit cell i.e. those groups of unit
   ! cell atoms which are connected to each other (ignoring/accounting
   ! for translational symmetry). NOTE: only connections to
   ! next-neighboring unit cells are considered regardless of the size
   ! of covalent radii.

   ENSURE(.unit_cell_geometry.created,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.created,"no frag_parent_for_cell_atom")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")

      new :: VEC{VEC_{INT}}*
      unit_cell_mol_for_atom,unique :: VEC{INT}*
      geom0,geom1 :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos_i,pos_j,offset :: VEC{REAL}(3)
      i,j,par_i,par_j, h1,h2,h3, mi,mj :: INT
      atom_i,atom_j :: ATOM

      ! Create the arrays we want
      .unit_cell_connection.destroy
      .unit_cell_mol_for_atom.destroy

      .unit_cell_connection.create(.n_unit_cell_atoms,0)
      .unit_cell_mol_for_atom.create(.n_unit_cell_atoms)

      ! Set worst case scenario: all atoms on different molecules
      unit_cell_mol_for_atom.create(.n_unit_cell_atoms)
      do i = 1,.n_unit_cell_atoms         
        unit_cell_mol_for_atom(i) = i
      end

      ! Define a new connected atom: its index and 3-element shift
      new.create(1)
      new(1).element.create(4)           

      ! Get unit cell cartesian geometry
      rcm = .unit_cell.direct_matrix
      geom0.create(3,.n_unit_cell_atoms)  
      geom0 = matmul(rcm,.unit_cell_geometry)

      ! First make connections in the unit cell
      ! and the distinct mols
      h1 = 0                             
      h2 = 0                             
      h3 = 0

        ! Loop over the (0,0,0) unit cell atoms i
        do i = 1,.n_unit_cell_atoms      

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i) 
           atom_i.atomic_number = .asymmetric_unit_atom(par_i).atomic_number
           atom_i.position = pos_i

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i) 

           ! Loop over the (0,0,0) unit cell atoms j
           do j = i+1,.n_unit_cell_atoms 

              ! Gross test for closeness
              pos_j = geom0(:,j)        
              if (abs(pos_j(1)-pos_i(1))>SEVEN) cycle
              if (abs(pos_j(2)-pos_i(2))>SEVEN) cycle
              if (abs(pos_j(3)-pos_i(3))>SEVEN) cycle 

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j) 
              atom_j.atomic_number = .asymmetric_unit_atom(par_j).atomic_number
              atom_j.position = pos_j

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              new(1)[:] = [h1,h2,h3,j]; .unit_cell_connection(i).element.append(new)
              new(1)[4] = i;            .unit_cell_connection(j).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)

              ! Replace all previous by the lowest mol
              if (mj<mi) then        
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end

      ! <<< Now make connections to neighbouring cells
      geom1.create(3,.n_unit_cell_atoms) 
      do h1 = -1,1                       
      do h2 = -1,1
      do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms     

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i) 
           atom_i.atomic_number = .asymmetric_unit_atom(par_i).atomic_number
           atom_i.position = pos_i

           ! Atom i belongs to mol "mi"
           mi = unit_cell_mol_for_atom(i) ! Atom i belongs to mol "mi"

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms   

              ! Gross test for closeness
              pos_j = geom1(:,j)        
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle 

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j) 
              atom_j.atomic_number = .asymmetric_unit_atom(par_j).atomic_number
              atom_j.position = pos_j

              ! Cycle if not bonded ...
              if (NOT atom_i.is_bonded_to(atom_j)) cycle

              new(1)[:] = [h1,h2,h3,j]
              .unit_cell_connection(i).element.append(new)

              ! Atom j belongs to mol "mj"
              mj = unit_cell_mol_for_atom(j)
              if (mj<mi) then        ! replace all previous by the lowest mol
                 where (unit_cell_mol_for_atom==mi) unit_cell_mol_for_atom = mj
                 mi = mj             ! replace mol for atom i too
              else if (mj>mi) then
                 where (unit_cell_mol_for_atom==mj) unit_cell_mol_for_atom = mi
              end

           end
        end

      end
      end
      end

      ! Clean
      geom1.destroy; geom0.destroy
      new.destroy

      ! Now make the .unit_cell_mol_for_atom list consecutive
      .unit_cell_mol_for_atom = unit_cell_mol_for_atom
      unique => unit_cell_mol_for_atom.unique_elements
      unique.sort
      .n_unit_cell_mols = unique.dim
      do mi = 1,.n_unit_cell_mols
        mj = unique(mi)
        if (mj==mi) cycle
        where (unit_cell_mol_for_atom==mj) .unit_cell_mol_for_atom = mi
      end
      unique.destroy
      unit_cell_mol_for_atom.destroy

   end

   make_uc_vdw_connections ::: leaky
   ! From the .asymmetric_unit_atom list make the .uc_vdw_connection
   ! table. Essentially aame as above with different bond criteria.

   ENSURE(.unit_cell_geometry.created,"no unit_cell in the crystal")
   ENSURE(.frag_parent_for_cell_atom.created,"no frag_parent_for_cell_atom")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")
   ENSURE(.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom list")

      vdw :: VEC{VEC_{INT}}*
      geom0,geom1 :: MAT{REAL}*
      rcm :: MAT{REAL}(3,3)
      pos_i,pos_j,offset :: VEC{REAL}(3)
      i,j,par_i,par_j, h1,h2,h3 :: INT
      atom_i,atom_j :: ATOM

      ! Create the arrays we want
      .uc_vdw_connection.destroy
      .uc_vdw_connection.create(.n_unit_cell_atoms,0)

      ! Define a new connected atom: its index and 3-element shift
      vdw.create(1)
      vdw(1).element.create(4)           

      ! Get unit cell cartesian geometry
      rcm = .unit_cell.direct_matrix
      geom0.create(3,.n_unit_cell_atoms)  
      geom0 = matmul(rcm,.unit_cell_geometry)

      ! First make connections in the unit cell
      ! and the distinct mols
      h1 = 0                             
      h2 = 0                             
      h3 = 0

        ! Loop over the (0,0,0) unit cell atoms i
        do i = 1,.n_unit_cell_atoms      

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i) 
           atom_i.atomic_number = .asymmetric_unit_atom(par_i).atomic_number
           atom_i.position = pos_i

           ! Loop over the (0,0,0) unit cell atoms j
           do j = i+1,.n_unit_cell_atoms 

              ! Gross test for closeness
              pos_j = geom0(:,j)        
              if (abs(pos_j(1)-pos_i(1))>SEVEN) cycle
              if (abs(pos_j(2)-pos_i(2))>SEVEN) cycle
              if (abs(pos_j(3)-pos_i(3))>SEVEN) cycle 

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j) 
              atom_j.atomic_number = .asymmetric_unit_atom(par_j).atomic_number
              atom_j.position = pos_j

              if (.unit_cell_mol_for_atom(i)==.unit_cell_mol_for_atom(j)) cycle
              if (NOT atom_i.is_vdw_bonded_to(atom_j)) cycle

              ! Append the bonded atom and the cell it is in ...
              vdw(1)[:] = [h1,h2,h3,j]; .uc_vdw_connection(i).element.append(vdw)
              vdw(1)[4] = i;            .uc_vdw_connection(j).element.append(vdw)

           end
        end

      ! <<< Now make connections to neighbouring cells
      geom1.create(3,.n_unit_cell_atoms) 
      do h1 = -1,1                       
      do h2 = -1,1
      do h3 = -1,1

        if (h1==0 AND h2==0 AND h3==0) cycle

        ! Get offset unit cell positions
        offset = matmul(rcm,[h1,h2,h3])
        geom1 = geom0 + spread(offset,2,.n_unit_cell_atoms)

        ! Loop over (0,0,0) unit cell atoms
        do i = 1,.n_unit_cell_atoms     

           ! Set atom_i
           pos_i = geom0(:,i)
           par_i = .asym_atom_for_unit_cell_atom(i) 
           atom_i.atomic_number = .asymmetric_unit_atom(par_i).atomic_number
           atom_i.position = pos_i

           ! Loop over (h1,h2,h3) unit cell atoms
           do j = 1,.n_unit_cell_atoms   

              ! Gross test for closeness
              pos_j = geom1(:,j)        
              if (abs(pos_j(1)-pos_i(1))>TEN) cycle
              if (abs(pos_j(2)-pos_i(2))>TEN) cycle
              if (abs(pos_j(3)-pos_i(3))>TEN) cycle 

              ! It could be close: Set atom_j
              par_j = .asym_atom_for_unit_cell_atom(j) 
              atom_j.atomic_number = .asymmetric_unit_atom(par_j).atomic_number
              atom_j.position = pos_j

              ! Cycle if not bonded ...
              if (.unit_cell_mol_for_atom(i)==.unit_cell_mol_for_atom(j)) cycle
              if (NOT atom_i.is_vdw_bonded_to(atom_j)) cycle

              vdw(1)[:] = [h1,h2,h3,j]
              .uc_vdw_connection(i).element.append(vdw)

           end
        end

      end
      end
      end

      ! Clean
      geom1.destroy; geom0.destroy
      vdw.destroy

   end

   z_factor result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined
   ! as the ratio of the number of electrons in the unit cell on the
   ! number of electrons in the fragment. 
      res :: REAL

   ENSURE(.asym_atom_for_unit_cell_atom.created,"no asym_atom_for_unit_cell_atom")
   ENSURE(.asym_atom_for_frag_atom.created,"no asym_atom_for_frag_atom")

      ue,fe :: REAL
      n,a,f :: INT

      ! Get # of electrons in unit cell
      ue = ZERO
      do n = 1,.n_unit_cell_atoms
         a = .asym_atom_for_unit_cell_atom(n)
         ue = ue + .asymmetric_unit_atom(a).atomic_number
      end

      ! Get # of electrons in fragment
      fe = ZERO
      do f = 1,.n_fragment_atoms
         a = .asym_atom_for_frag_atom(f)
         fe = fe + .asymmetric_unit_atom(a).atomic_number
      end

      ! Z factor is the ratio
      res = ue/fe

   end

!  ******************
!  Repetition factors
!  ******************

   make_repetition_factors ::: leaky, private
   ! The number of times a fragment atom with index "a" is mapped into
   ! itself under the symmetry group is the ".repetition_factor(a)".
   ! It is used to correct structure factors for fragment geometries
   ! which are "oversampled" relative to the asymmetric cell geometry.

   ENSURE(.fragment_geometry.created, "no fragment_geometry!")

      pa,pb :: VEC{REAL}(3)
      a,b,n,n_same :: INT
      same :: BIN
      tol :: REAL

      if (.use_manual_repetition_factors) then
         ENSURE(.repetition_factor.created,"no repetiton_factors entered!")
      else
         tol = TOL(2)/maxval(.unit_cell.length)
         tol = TOL(3)                        ! <--- getting this number wrong can stuff things
         .repetition_factor.destroy
         .repetition_factor.create(.n_fragment_atoms)
         do a = 1,.n_fragment_atoms
            pa = .fragment_geometry(:,a)
            .put_to_unit_cell(pa)
            n_same = 0
            do b = 1,.n_fragment_atoms
            do n = 1,.spacegroup.n_seitz
               pb = .fragment_geometry(:,b)
               .transform_position(pb,n,to_unit_cell=TRUE)
               same = pa.same_as(pb,tol)
               if (same) n_same = n_same + 1
            end
            end
            .repetition_factor(a) = n_same
         end
      end
   end

   make_asym_atom_rep_factors ::: leaky, private
   ! The number of times an asymmetric cell atom with index "a" is
   ! mapped into itself under the symmetry group is the
   ! ".asym_atom_rep_factor(a)". Also record the stabilizing
   ! operations in ".asym_atom_stabilizer(a)[:]". These are used in
   ! atomic-type structure factor calculations based on the asymmetric
   ! cell geometry.

   ENSURE(.fragment_geometry.created, "no fragment_geometry!")

      pa,pn :: VEC{REAL}(3)
      a,n,n_same :: INT
      same :: BIN
      tol :: REAL

      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      .asym_atom_rep_factor.destroy
      .asym_atom_stabilizer.destroy
      .asym_atom_rep_factor.create(.n_asymmetric_unit_atoms)
      .asym_atom_stabilizer.create(.n_asymmetric_unit_atoms)
      do a = 1,.n_asymmetric_unit_atoms
         pa = .asymmetric_unit_geometry(:,a)
         .put_to_unit_cell(pa)
         n_same = 0
         do n = 1,.spacegroup.n_seitz
            pn = pa
            .transform_position(pn,n,to_unit_cell=TRUE)
            same = pa.same_as(pn,tol)
            if (NOT same) cycle
            n_same = n_same + 1
            .asym_atom_stabilizer(a).element.append(n)
         end
         .asym_atom_rep_factor(a) = n_same
      end
   end

!  *****************************
!  Reset Hydrogen atom positions
!  *****************************

   reset_H_bond_lengths_in(atom,H_bond_length,reset) ::: leaky
   ! Resets the coordinates of the hydrogen atoms in "atoms" so that
   ! they have bond lengths given by the values in the "H_bond_length"
   ! array. Negative values mean no changes. If present "reset" is set
   ! TRUE if at least on the H atom positions was reset. 
   ! WARNING: this routine destroys all the fragment data.
      self :: PTR
      atom :: VEC{ATOM}*
      H_bond_length :: VEC{REAL}*
      reset :: BIN, optional

   ENSURE(H_bond_length.created,"no H_bond_length array")

      lb,ub,ua,fh,fa,uh,Za,n :: INT
      hh,ph,pa,sh,ch,ca,dd,d :: VEC{REAL}(3)
      rcm,inv :: MAT{REAL}(3,3)
      done :: BIN

      if (all(H_bond_length<ZERO)) return

      ! Destroy all the fragment and asymettric unit data
      .destroy_fragment_data
      .destroy_asymmetric_unit

      ! Make unit cell connection table
      .make_fragment_data(atom)

      ! Elements whose bond lengths to change
      lb = lbound(H_bond_length,1)
      ub = ubound(H_bond_length,1)

      ! Cell matrices
      rcm = .unit_cell.direct_matrix
      inv = .unit_cell.inverse_matrix

      done = FALSE

      ! Loop fragment atom positions
      do fh = 1,.n_fragment_atoms

         ! If fragment atom is not H atom, cycle ...
         if (atom(fh).atomic_number/=1) cycle

         ! The H atom  must have only one bond
         uh = .unit_cell_atom_for_frag_atom(fh) 
         if (.unit_cell_connection(uh).element.dim>1) then
            n = .unit_cell_connection(uh).element.dim
            WARN("Hydrogen # "//fh.to_str.trim//" is bonded to "//n.to_str.trim//" atoms")
            cycle
         end

         ! Which frag atom is the H connected to?
         ua = .unit_cell_connection(uh)[1][4]
         fa = .frag_atom_for_unit_cell_atom(ua) 
         if (fa==0) cycle

         ! If it isn't one of those to be reset, cycle
         Za = atom(fa).atomic_number
         if (Za<lb OR Za>ub) cycle
         if (H_bond_length(Za)<ZERO) cycle

         done = TRUE

         ! Get the H atom pos relative to A
         hh = .fragment_geometry(:,fh)
         pa = .fragment_geometry(:,fa)
         dd = hh - pa
         d  = mod(dd,[ONE,ONE,ONE])
         where (d> HALF) d = d - ONE
         where (d<-HALF) d = d + ONE
         ph = pa + d
         sh = ph - hh

         ! Get new cartesian H atom position
         ch = matmul(rcm,ph)
         ca = matmul(rcm,pa)
         dd = ch - ca
         dd.normalise
         ch = ca + H_bond_length(Za)*dd

         ! Put H atom back
         ph = matmul(inv,ch) - sh
         ch = matmul(rcm,ph)

         ! Reset the H atom position
         atom(fh).position = ch

      end

      if (present(reset)) reset = done 

      ! Clean up
      .destroy_fragment_data

   end

!  ****************
!  Position changes
!  ****************

   transform_geometry(g,op,translate,ignore_glide,to_unit_cell)
   ! Transform the positions "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (1,1,1) unit cell.
      g :: MAT{REAL}
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
   ENSURE(g.dim1==3,"incorrect size for array g")
      n :: INT
      do n = 1,g.dim2
         .transform_position(g(:,n),op,translate,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,translate,ignore_glide,to_unit_cell,unit_cell_shift) 
   ! Transform the position "p" in fractional coordinates with the Seitz
   ! operator with index "op". If present, "translate" will be added to the
   ! transformed position. If present and TRUE, "ignore_glide" will not add the
   ! glide vector part of the Seitz operator.  If present and TRUE,
   ! "to_unit_cell" will translate the fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell, and "unit_cell_shift" is set to the translation
   ! vector required to do this.
      p :: VEC{REAL}(3)
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
      unit_cell_shift :: VEC{INT}(3), optional
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
   ENSURE(op>0,"operator index out of bounds")
   ENSURE(op<=.spacegroup.n_seitz,"operator index out of bounds")
      ignore,to_cell :: BIN
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p)
      else
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p) + .spacegroup.seitz(1:3,4,op)
      end
      if (present(translate)) p = p + translate
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p,unit_cell_shift)
   end

   put_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      g :: MAT{REAL}
   ENSURE(g.dim1==3 OR g.dim2==3, "incorrect shape for array g")
      n :: INT
      if (g.dim1==3) then
         do n = 1,g.dim2
            .put_to_unit_cell(g(:,n))
         end
      else
         do n = 1,g.dim1
            .put_to_unit_cell(g(n,:))
         end
      end
   end

   put_to_unit_cell(p,shift)
   ! Transform the position "p" in fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell. If present, "shift" is set to the translation
   ! vector needed to effect the change to the unit cell.
      p :: VEC{REAL}(3)
      shift :: VEC{INT}(3), optional

   ENSURE(size(p)==3, "p must be length 3")

      new :: VEC{REAL}(3)
      tol :: REAL
      i :: INT

    ! new = mod(p - floor(p) + TWO + TOL(3),ONE) - TOL(3)
    ! ! p(:)-floor(p(:))+TWO should make it positive.
      ! I changed this from above, so that now every coordinate having an
      ! integer values will map to zero i.e. the unit cell is 0<=x_i<1, i=1,3
      ! --dylan
    ! tol = TOL(4)/maxval(.unit_cell.length)
      tol = TOL(1)/maxval(.unit_cell.length)
      tol = TOL(3)

      do i = 1,3
              if (abs(p(i))<tol)     then;  p(i) =   ZERO
         else if (abs(p(i)-ONE)<tol) then;  p(i) =    ONE
         else if (abs(p(i)+ONE)<tol) then;  p(i) =   -ONE
         else if (abs(p(i)-TWO)<tol) then;  p(i) =    TWO 
         else if (abs(p(i)+TWO)<tol) then;  p(i) =   -TWO 
         end
      !  if (abs(p(i)-THREE)<tol) p(i) =  THREE 
      !  if (abs(p(i)+THREE)<tol) p(i) = -THREE
      !  if (abs(p(i)-FOUR)<tol)  p(i) =   FOUR
      !  if (abs(p(i)+FOUR)<tol)  p(i) =  -FOUR
      end

      new = p - floor(p)

      if (present(shift)) shift = nint(new - p)

      p = new

   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      g :: MAT{REAL}
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n,n_atom :: INT
      centre :: VEC{INT}(3)
      n_atom = size(g,2)
      centre = .unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - centre
      end
   end

   unit_cell_offset(g) result (res)
   ! Which hkl indices match the centre of the fragment geometry "g" when
   ! expressed in crystal coordinates.  Usually we expect that it is 0,0,0 but
   ! not always.
      g :: MAT{REAL}
      res :: VEC{INT}(3)
   ENSURE(g.dim1==3, "incorrect size for array g")
      res = int(sum(g,dim=2)/g.dim2)
   end

!  ***************
!  Fragment widths
!  ***************

   fragment_width result (res)
   ! Return the width "res" of the fragment in each of the 3 axis directions.
      res :: VEC{REAL}(3)
   ENSURE(.fragment_geometry.created,"no fragment geometry")
      res = .fragment_geometry.max_abs_column_difference
   end

   cartesian_fragment_width result (res)
   ! Return the cartesian width "res" of the fragment in each of the three axis
   ! directions.
      res :: VEC{REAL}(3)
      res = .fragment_width
      .unit_cell.change_from_fractional(res)
   end

!  **************
!  Seitz matrices
!  **************

   make_xyz_seitz_matrices(res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S_cartesian  =  D  S^_crystal  D^-1
   ! NOTE: I think they are not transposed any more ...
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end

   end

   xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. 
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end

   end

   transposed_xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. 
      res :: MAT3{REAL}*

   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")

      i :: INT

      res.create(3,3,.spacegroup.n_seitz) ! leaky
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.reciprocal_matrix, &
                      matmul(transpose(.spacegroup.seitz(1:3,1:3,i)), &
                             transpose(.unit_cell.direct_matrix)))
      end

   end

!  ***********
!  Stabilizers
!  ***********

   make_stabilizer_symops ::: leaky, private
   ! Make a list of the indices of the Seitz matrices, ".stabilizer_symop", which
   ! will generate the same geometries to that in ".fragment_geometry" when
   ! both the original and transformed geometries are converted to unit cell
   ! coordinates.  ".n_stabilizer_symops" is set to the number of these 
   ! symmetry operations.
      g1,gi :: MAT{REAL}*
      i,n :: INT
      identical :: BIN

      .stabilizer_symop.destroy
      .stabilizer_symop.create(.spacegroup.n_seitz)

      g1.create(3,.n_fragment_atoms)
      gi.create(3,.n_fragment_atoms)
      g1 = .fragment_geometry

      n = 1
      .stabilizer_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         gi = .fragment_geometry
         .transform_geometry(gi,i)
         identical  = .is_same_geometry(gi,g1)
         if (NOT identical) cycle
         n = n + 1
         .stabilizer_symop(n) = i
      end
      gi.destroy
      g1.destroy

      .n_stabilizer_symops = n
      .stabilizer_symop.shrink(n)

   end

   is_same_geometry(geom_i,geom_j) result (res) ::: private
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      geom_i,geom_j :: MAT{REAL}
      res :: BIN
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
   ENSURE(geom_i.dim1==3,"incorrect size for array geom_i")
   ENSURE(geom_j.dim1==3,"incorrect size for array geom_j")
   ENSURE(geom_i.dim2==geom_j.dim2,"incompatible sizes for geom_i, geom_j")
      i,j,n_atom :: INT
      skip :: VEC{BIN}*
      same :: BIN
      tol :: REAL
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      n_atom = geom_i.dim2
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j),tol)
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   xyz_stabilizer_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis which stabilize the fragment geometry. 
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
   ENSURE(.stabilizer_symop.created,"no stabilizer symop matrices")
      i,s :: INT
      res.create(3,3,.n_stabilizer_symops)
      do i = 1,.n_stabilizer_symops
         s = .stabilizer_symop(i)
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,s),.unit_cell.inverse_matrix))
      end
   end

   make_stabilizer_xyz_matrices ::: leaky, private
   ! Make the representation matrices for xyz products found in
   ! gaussian shells, i.e. work out matrix R, where the shell row vector
   ! p'(r) = p(S^{-1}r) = p(r)R, and S is a stabilizer symop.
   ! WARNING: this routine is tied to an explicit ordering of the cartesian
   ! gaussian basis functions in a shell.
      str :: MAT3{REAL}*

      .str.destroy
      .ptr.destroy
      .dtr.destroy
      .ftr.destroy
      .gtr.destroy

      str.create(1,1,.n_stabilizer_symops)
      str = ONE
      .str => str                          ! 1  x 1
      .ptr => .xyz_stabilizer_matrices     ! 3  x 1
      .dtr => .ptr.gaussian_d_xyz_matrices ! 6  x 6
      .ftr => .ptr.gaussian_f_xyz_matrices ! 10 x 10
      .gtr => .ptr.gaussian_g_xyz_matrices ! 15 x 15

   end

   xyz_stabilizer_matrix(n,l) result (res)
   ! Return the "n"-th stabilizer representation matrix for xyz
   ! product found in a gaussian shell of angular momentum "l"
      n,l :: INT
      res :: MAT{REAL}*
   ENSURE(l>=0,"l must be non-negative")
   ENSURE(l<5, "l must be less than 5 (no h functions or higher)")
      select case (l)
         case(0); res => .str(:,:,n)
         case(1); res => .ptr(:,:,n)
         case(2); res => .dtr(:,:,n)
         case(3); res => .ftr(:,:,n)
         case(4); res => .gtr(:,:,n)
         case default; DIE("not implemented beyond l=4")
      end
   end

!  *******************************************
!  No. of unique reflections, pruning, merging
!  *******************************************

   make_list_of_equivalents(list,n_unique,show) ::: leaky, private
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
      self :: IN
      list :: VEC{VEC_{INT}}*
      n_unique :: INT, OUT
      show :: BIN, IN, optional

   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")

      i,j,g,n_refl :: INT
      p,q,r :: VEC{INT}(3)
      same,disp :: BIN

      disp = FALSE
      if (present(show)) disp = show

      n_refl = .data.reflections.n_refl
      list.create(n_refl)
      list(1).element.append(1)

      n_unique = 1
      do i = 2,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 
        same = FALSE
        main: do g = 1,.spacegroup.n_seitz
           do j = 1,i-1
              q(1) = .data.reflections(j).h 
              q(2) = .data.reflections(j).k 
              q(3) = .data.reflections(j).l 
              r = int(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
              same = p.same_as(r) OR p.same_as(-r)
              if (NOT same) cycle
              exit main
           end
        end do main
        if (same) then
           list(j).element.append(i)
           list(i).element.append(j)
           if (disp) then
           stdout.text("reflections "//trim(i.to_str)//" and "//trim(j.to_str)//" are the same")
           end
        else
           n_unique = n_unique + 1
           list(i).element.append(i)
        end
      end
   end

   merge_equivalents ::: leaky
   ! This routine will merge this list of equivalents into a single reflections
   ! with a particular sigma value associated with it. WARNING: it assumes that
   ! there are a sufficient number of equivalents so that the sigma value can be
   ! calculated by the standard formula for the standard deviation.

   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")

      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n,i :: INT

      n_refl = .data.reflections.n_refl

      .make_list_of_equivalents(list,n_unique)

      reflections.create(n_unique)
      n = 0
      do i = 1,n_refl
        if (list(i)[1]<i) cycle
        n = n + 1
        reflections(n) = .data.reflections(i)
        reflections(n).F_exp   = .data.reflections(list(i)[:]).F_exp.mean
        reflections(n).F_sigma = .data.reflections(list(i)[:]).F_exp.standard_deviation
      end
      .data.reflections.destroy
      .data.reflections => reflections

      ! Clean up
      list.destroy

   end

   make_list_of_equivalents_ord(list,n_unique,show) ::: leaky, private
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
      self :: IN
      list :: VEC{VEC_{INT}}*
      n_unique :: INT, OUT
      show :: BIN, IN, optional
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
      i,j,g,n_refl :: INT
      p,q,r :: VEC{INT}(3)
      same,disp :: BIN
      disp = FALSE
      if (present(show)) disp = show
      n_refl = .data.reflections.n_refl
      list.create(n_refl)
      list(1).element.append(1)
      n_unique = 1
      do i = 2,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 
        same = FALSE
        j = i-1
        main: do g = 1,.spacegroup.n_seitz
           q(1) = .data.reflections(j).h 
           q(2) = .data.reflections(j).k 
           q(3) = .data.reflections(j).l 
           r = int(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
           same = p.same_as(r) OR p.same_as(-r)
           if (NOT same) cycle
           exit main
        end do main
        if (same) then
           list(j).element.append(i)
           list(i).element.append(j)
           if (disp) then
           stdout.text("reflections "//trim(i.to_str)//" and "//trim(j.to_str)//" are the same")
           end
        else
           n_unique = n_unique + 1
           list(i).element.append(i)
        end
      end
   end

   merge_ordered_equivalents ::: leaky
   ! This routine will merge apartially ordered list of equivalents into a
   ! single reflections with a particular sigma value associated with it.
   ! WARNING: it assumes that there are a sufficient number of equivalents so
   ! that the sigma value can be calculated by the standard formula for the
   ! standard deviation.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n,i :: INT
      n_refl = .data.reflections.n_refl
      .make_list_of_equivalents_ord(list,n_unique)
      reflections.create(n_unique)
      n = 0
      do i = 1,n_refl
        if (list(i)[1]<i) cycle
        n = n + 1
        reflections(n) = .data.reflections(i)
        reflections(n).F_exp   = .data.reflections(list(i)[:]).F_exp.mean
        reflections(n).F_sigma = .data.reflections(list(i)[:]).F_exp.standard_deviation
      end
      .data.reflections.destroy
      .data.reflections => reflections
      list.destroy
   end

   expand_unique_reflections ::: leaky
   ! This routine will expand a unique list of reflections into a
   ! complete redundant list of reflections.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
      list :: VEC{VEC_{INT}}*
      reflections :: VEC{REFLECTION}*
      n_unique,n_refl,n_max,n,i,j,g :: INT
      p,q,r :: VEC{INT}(3)
      same :: BIN

      ! Store the number of reflections
      n_refl = .data.reflections.n_refl

      ! Make the list of equivalents, to detect any repetitions
      .make_list_of_equivalents(list,n_unique,show=TRUE)
      DIE_IF(n_unique/=n_refl,"the list of reflections is not unique")
      list.destroy

      ! Create the maximum possible list of total reflections
      n_max = n_refl*.spacegroup.n_seitz
      reflections.create(n_refl*.spacegroup.n_seitz)

      ! Loop over remaining reflections
      n = 0
      do i = 1,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 

        ! Apply symmetry to this relflection
        do g = 1,.spacegroup.n_seitz
           r = int(matmul(.spacegroup.seitz(1:3,1:3,g),p),kind=INT_KIND)

           ! Is it the same as another in the list? 
           same = FALSE
           do j = 1,n-1
              q(1) = reflections(j).h 
              q(2) = reflections(j).k 
              q(3) = reflections(j).l 
              same = q.same_as(r)
              if (same) exit
           end
           if (NOT same) then
              n = n + 1
              DIE_IF(n>n_max,"more than expected number of reflections")
              reflections(n) = .data.reflections(i)
              reflections(n).h = r(1)
              reflections(n).k = r(2)
              reflections(n).l = r(3)
           end
        end
      end
      reflections.shrink(n)
      .data.reflections.destroy
      .data.reflections => reflections
   end

!  *************************************
!  Service methods used by other modules
!  *************************************

   sum_unique_sf(sf,unique_sf)
   ! Form the structure factors "sf" from the sum of the list of
   ! unique structure factors, "unique_sf".
      sf :: VEC{CPX}
      unique_sf :: VEC{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf(sf,unique_sf,.data.reflections)

   end

   sum_unique_sf_ints(sf_ints,unique_sf_ints)
   ! Form the structure factor integrals "sf_ints" from a sum of the list
   ! of unique structure factors integrals  "unique_sf_ints".
      sf_ints :: MAT3{CPX}
      unique_sf_ints :: MAT3{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_ints(sf_ints,unique_sf_ints,.data.reflections)
   end

   sum_unique_sf_derivs(sf,unique_sf)
   ! Form the structure factor derivatives "sf" from a sum of the list
   ! of unique structure factor derivatives "unique_sf".
      sf :: MAT{CPX}, OUT
      unique_sf :: MAT{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_derivs(sf,unique_sf,.data.reflections)
   end

   sum_unique_sf_derivs_t(sf,unique_sf)
   ! Form the structure factor derivatives "sf" from a sum of the list
   ! of unique structure factor derivatives "unique_sf".
      sf :: MAT{CPX}, OUT
      unique_sf :: MAT{CPX}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_derivs_t(sf,unique_sf,.data.reflections)
   end

   sum_unique_sf_pts(X,k_pts,pts,tf,Fr,Fc)
   ! Form "X", the sum of the FT phase factor e^(i k.r) times the
   ! symmetry phases (which arise from copying the molecule
   ! around the unit cell) for a series of "k_pts" and space "pts",
   ! multiplied by a given k-space factor "(Fr,Fc)". The result "X" is
   ! of length of the number of space points
      X :: VEC{REAL}, OUT
      k_pts,pts :: MAT{REAL}, IN
      tf,Fr,Fc :: VEC{REAL}, IN

   ENSURE(.spacegroup.analysed,"spacegroup not analysed")
   ENSURE(.data.created,"no data")
   ENSURE(.data.reflections.created,"no reflection data")

      .spacegroup.sum_unique_sf_pts(X,k_pts,pts,tf,Fr,Fc,.data.reflections)

   end

! Don't delete code below just yet ...

!   make_phased_matrix_for_symop(u,phase,mask) ::: private
!   ! Return the sum of the "phase" shifts times the seitz matrices for all
!   ! symops which are equivalent to the "u"-th unique symmetry operation,
!   ! .spacegroup.unique_SF_symop(u), as determined by the "mask" array, when
!   ! mask(u)==.spacegroup.unique_SF_symop(u).
!     u :: INT, IN
!     phase :: MAT3{CPX}, OUT
!     mask :: VEC{INT}, IN
!
!   ENSURE(.spacegroup.analysed,"no spacegroup")
!   ENSURE(u<=.spacegroup.n_unique_SF_symops,"symop index out of range")
!   ENSURE(phase.dim1==.data.reflections.n_refl,"wrong size, dim=1, phase array")
!   ENSURE(phase.dim2==3,"wrong size, dim=2, phase array")
!   ENSURE(phase.dim3==3,"wrong size, dim=3, phase array")
!
!     pi2,tx,ty,tz,dot :: REAL
!     s,n,n_refl,h,k,l :: INT
!     seitz :: MAT{REAL}(4,4)
!     refl :: VEC{REFLECTION}*
!
!     refl => .data.reflections
!     n_refl = refl.dim
!     pi2 = TWO*PI
!
!     phase = ZERO
!     do s = 1,.spacegroup.n_seitz
!
!       ! Sum only those which match unique symop u
!       if (mask(s)/=.spacegroup.unique_SF_symop(u)) cycle
!
!       ! Get the symop translation vector
!       seitz = .spacegroup.seitz(:,:,s)
!       tx = pi2*seitz(1,4)
!       ty = pi2*seitz(2,4)
!       tz = pi2*seitz(3,4)
!
!       ! Sum the phase here
!       ! This seems a kludge because we don't know the magnetic symmetry
!       if (seitz(3,3)>0) then                  ! M points along +z always
!         do n = 1,n_refl
!           h = refl(n).h
!           k = refl(n).k
!           l = refl(n).l
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       else                                    ! M points in -z direction
!         seitz(3,:3) = -seitz(3,:3)            ! Invert
!         do n = 1,n_refl
!           h = refl(n).h
!           k = refl(n).k
!           l = refl(n).l
!           dot = h*tx+k*ty+l*tz
!           phase(n,:,:) = phase(n,:,:) + &
!              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
!         end
!       end
!
!     end
!
!   end
!
!   sum_PND_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phased_matrix_for_symop(u,phase,.spacegroup.translated_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              unique_ft_ints(uf+n,:,:)
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              unique_ft_ints(uf+n,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phased_matrix_for_symop(u,phase,.spacegroup.inverted_symop)
!        do n = 1,n_refl
!           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
!              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
!              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
!              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
!              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
!              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
!              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
!              conjg(unique_ft_ints(uf+n,:,:))
!        end
!
!     end
!     phase.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S=sigma/2 operator, and g_e x mu_B = 1.
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_PND_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a_3 integrals "ft_ints", required for the
!   ! PND magnetic structure factors, from a sum of "unique_ft_ints".
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT3{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: MAT3{CPX}*
!     q :: MAT{REAL}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     q.create(n_refl,3)
!     phase.create(n_refl,3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phased_matrix_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*unique_ft_ints(uf+n,:,:,1) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*unique_ft_ints(uf+n,:,:,2) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*unique_ft_ints(uf+n,:,:,3)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phased_matrix_for_symop(u,phase,mask=.spacegroup.translated_symop) ! .inverted_symop here ??????????????
!       do n = 1,n_refl
!         ft_ints(n,:,:) = ft_ints(n,:,:) + &
!          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*conjg(unique_ft_ints(uf+n,:,:,1)) + &
!          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*conjg(unique_ft_ints(uf+n,:,:,2)) + &
!          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*conjg(unique_ft_ints(uf+n,:,:,3))
!       end
!     end
!     phase.destroy
!
!     ! The factor of 2 to convert to Bohr magnetons cancels the factor
!     ! of 1/2 for the Bohr magneton.
!     do n = 1,n_refl
!       ft_ints(n,:,:) = ft_ints(n,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!
!   end
!
!   sum_ft_spin_ints(ft_ints,unique_ft_ints)
!   ! Form the Fourier transform integrals "ft_ints", required for the spin
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
!   ! [.n_refl,n_comp_a,n_comp_b,3,3].
!     ft_ints :: MAT5{CPX}
!     unique_ft_ints :: MAT3{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT{CPX}*
!     u,uf,n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:)
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
!         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
!         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
!         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     do n = 1,n_refl
!        ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
!   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
!   ! magnetic structure factors, from a sum of the list of unique structure
!   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!     B :: VEC{REAL}(3)
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     q :: MAT{REAL}*
!     ints :: MAT3{CPX}*
!     u,uf,n,n_refl :: INT
!     ci :: CPX
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!     q.create(n_refl,3)
!     ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!     .make_k_pts(q)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!       uf = n_refl*(u-1)
!
!       ! Add up translated symop contribution
!       .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!       do n = 1,n_refl
!         ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!
!       ! Add up inverted symop contribution, if any
!       if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!       .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!       do n = 1,n_refl
!         ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
!                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
!         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
!                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
!         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
!                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
!       end
!     end
!     ints.destroy
!
!     ! The factor of two for conversion to Bohr magnetons cancels the
!     ! factor of half for the S operator
!     ci = (ZERO,ONE)
!     do n = 1,n_refl
!       ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!     end
!     q.destroy
!     phase.destroy
!
!   end
!
!   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
!   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!      ft_ints :: MAT4{CPX}
!      unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!      phase :: VEC{CPX}*
!      q :: MAT{REAL}*
!      ints :: MAT3{CPX}*
!      u,uf,n,n_refl :: INT
!
!      n_refl = .data.reflections.n_refl
!      phase.create(n_refl)
!      q.create(n_refl,3)
!      ints.create(ft_ints.dim2,ft_ints.dim3,3)
!
!      .make_k_pts(q)
!
!      ft_ints = ZERO
!      do u = 1,.spacegroup.n_unique_SF_symops
!
!         uf = n_refl*(u-1)
!
!         ! Add up translated symop contribution
!         .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!         do n = 1,n_refl
!            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!         ! Add up inverted symop contribution, if any
!         if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions ...
!         .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!         do n = 1,n_refl
!            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
!            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
!            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
!            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
!         end
!
!      end
!      ints.destroy
!
!      ! The factor of 2 to convert to Bohr magnetons cancels the factor
!      ! of 1/2 for the Bohr magneton
!      ! Extra minus sign introduced, but not sure why ...
!      ! Reversed minus sign introduced ...
!      do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
!      end
!      q.destroy
!      phase.destroy
!
!   end
!
!   sum_ft_j_ints(ft_ints,unique_ft_ints)
!   ! Form the fourier transform j integrals "ft_ints", required for the PND
!   ! magnetic striucture factors, from a sum of "unique_ft_ints".
!   ! Note: only inversions are allowed as symmetry elements for PND simulations.
!   ! Note: the complex conjugate nabla_b integrals are not included.
!   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
!     ft_ints :: MAT4{CPX}
!     unique_ft_ints :: MAT4{CPX}, IN
!
!   ENSURE(.data.created,"no data")
!   ENSURE(.data.reflections.created,"no reflection data")
!   ENSURE(ft_ints.dim1==.data.reflections.n_refl,"wrong size, array ft_ints")
!   ENSURE(unique_ft_ints.dim1==.spacegroup.n_unique_SF_symops*.data.reflections.n_refl,"wrong size, array unique_ft_ints")
!
!     phase :: VEC{CPX}*
!     u,uf, n,n_refl :: INT
!
!     n_refl = .data.reflections.n_refl
!     phase.create(n_refl)
!
!     ft_ints = ZERO
!     do u = 1,.spacegroup.n_unique_SF_symops
!
!        uf = n_refl*(u-1)
!
!        ! Add up translated symop contribution
!        .make_phases_for_symop(u,phase,mask=.spacegroup.translated_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
!        end
!
!        ! Add up inverted symop contribution, if any
!        if ( all(.spacegroup.inverted_symop/=.spacegroup.unique_SF_symop(u)) ) cycle ! for inversions...
!        .make_phases_for_symop(u,phase,mask=.spacegroup.inverted_symop)
!        do n = 1,n_refl
!          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
!        end
!
!     end
!     phase.destroy
!
!   end

!  ****************************
!  Structure refinement methods
!  ****************************

   fit_rigid_atoms(sf_n) ::: leaky
   ! Fit rigid atoms to the calculated structure factors given
   ! the unique static atom structure factors "sf_n" with respect 
   ! to the symmetry-generated k points.
   ! * Cartesian (bohr) coordinates are used since structure factors
   !   are aspherical and calculated from the QM wavefunction
   ! * Also, structure factors are calculated for =unique fragment
   !   atoms= for the same reason 
   ! * HOWEVER, asymmetric unit atoms are used to "store" the updating
   !   geometry because there is no explicit list of unique fragment
   !   atoms; thus unique fragment atom positions and shifts are
   !   calculated (and derivatives with respect to) but these
   !   positions and shifts are always transformed back to the
   !   asymetric unit atoms.
   ! * NOTE: this routine does only one cycle of fitting with the
   !   current unique atom structure factors "sf_n"

      sf_n :: MAT{CPX}, INOUT
 
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,       "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.n_asymmetric_unit_atoms, "sf_n: wrong dim2")
   ENSURE(.data_exists,                        "no data")
   ENSURE(.fragment_info_made,                 "no fragment info")

      ! Create refinement arrays & initialise (leaky)
      .initialise_fit_data

      ! Place asym atom position/ADPs in vector .data.X_fit
      .asymmetric_unit_atom.get_positions_and_ADPs_in(.data.X_fit)
      if (.data.refine_structure) .data.X_ref = .data.X_fit

      ! Banner, options/switches, initial parameters,
      ! start banner, and iteration table header
      .put_fit_header_info

      ! Begin rigid-atom fit loop
      do

         ! Set asym atom positions/ADPs from param vector
         .asymmetric_unit_atom.set_positions_and_ADPs_to(.data.X_fit)

         ! Set frag atom positions/ADPs from asym atoms
         .set_frag_from_asym_pADPs
 
         ! Get unique frag atom shifts in .data.dX  ...
         .get_parameter_shifts(sf_n)

         ! Update "sf_n", the unique (rigid) frag atom SF's
         .shift_update_sf_n(sf_n)

         ! Change unique frag atom to asym atom shifts
         ! Change the covariance matrix too.
         .set_asym_from_ufrag_shifts
         .set_asym_from_ufrag_cov_mx 

         ! Stop symmetry breaking 
         ! NOTE: we should apply this to the gradient *not* 
         ! the shift to make sure the shift maintains symmetry
         .stabilize_asym_atom_shifts

         ! Store old parameter vector, 
         ! Add shift to get new .data.X_fit
         .update_fit_parameters

         ! Set the fit errors e.g. max(dX/esd)
         ! Copy them to the asymmetric unit atoms.
         .update_fit_errors
         .asymmetric_unit_atom.set_position_and_ADP_errors_to(.data.esd)

         ! Put the iteration results
         .put_fit_iteration_results
 
         ! Finished?
         if (.fit_finished) exit
 
      end

      ! Table footer and final results
      .put_fit_footer_info

      ! Remake asymmetric/fragment geometry as well
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_source = "tonto-rigid-atom-fit"
      .make_fragment_data(.fragment_atom,warnings=FALSE) ! a bit lazy

      ! Set the fragment covariances from cov matrix
      .set_fragment_errors

      ! Print out bond length, angle, torsion tables with errors
      .put_bond_info_with_errors

   end

!  Refinement initialisation

   initialise_fit_data ::: leaky
   ! Initialise a rigid-atom fit

   ENSURE(.data_exists,"no diffraction data")

      labels :: VEC{STR}*

      ! Get labels
      labels => .asymmetric_unit_atom.position_ADP_labels

      ! Create refinement arrays & initialise (leaky)
      .data.initialise_fit_data(.n_asymmetric_unit_atoms,.n_fragment_atoms,labels)

      ! Clean
      labels.destroy

   end

   initialise_refinement_data ::: leaky
   ! Initialise a full refinement

   ENSURE(.data_exists,"no diffraction data")

      labels :: VEC{STR}*

      ! Get labels
      labels => .asymmetric_unit_atom.position_ADP_labels

      ! Create refinement arrays & initialise (leaky)
      .data.initialise_refinement_data(.n_asymmetric_unit_atoms,labels)

      ! Clean
      labels.destroy

   end

!  Refinement: shifts and SF update

   get_parameter_shifts(sf_n) ::: leaky, private
   ! Get the *asym* atom shifts ".data.dX" by solving the
   ! normal equations, using:
   ! * "sf_n", the unique *fragment* atom structure factors
   !   for the symmetry related k points
   ! * ".data.X_ref", the *asym* atom parameters 
   !   (positions and ADP's) 
   ! "sf_n" is updated by the shift amount at the end. 

      sf_n :: MAT{CPX}, INOUT

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,        "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim, "sf_n: wrong dim2")
   ENSURE(.data.created,                        "no data")
   ENSURE(.fragment_info_made,                  "no fragment info")

      dFa  :: MAT{REAL}*
      sf_d,dFc :: MAT{CPX}*
      sf_e,Fc :: VEC{CPX}*
      n_refl,n_k,n_p :: INT

      ! Constants
      n_refl = .n_refl
      n_k    = .n_unique_SF_k_pts
      n_p    = 9*.n_asymmetric_unit_atoms

      ! Symmetry generated structure factors
      sf_d.create(n_k,n_p) ! Symmetry generated SF derivatives
      sf_e.create(n_k)     ! Symmetry generated SF's

      ! Make the structure factors and derivatives
      .make_unique_sf_derivs(sf_e,sf_d,sf_n)

      ! Sum the symmetry-generated SF's to get
      ! the actual structure factors Fc
      Fc.create(n_refl) 
      .sum_unique_sf(Fc,sf_e)
      sf_e.destroy

      ! Set the calculated SF's
      .set_F_calc(Fc)
      Fc.destroy

      ! Make chi2 in F (and I?)
      .make_F_predicted

      ! Sum the symmetry-generated SF's to get 
      ! the derivative structure factors dFc
      dFc.create(n_refl,n_p)  ! Derivative complex structure factors
      .sum_unique_sf_derivs_t(dFc,sf_d)
      sf_d.destroy

      ! Get the derivative absolute SF's, 
      ! ... unique fragment atoms only
      dFa.create(n_refl,n_p)
      .d_F_abs_dX(dFa,dFc)
      dFc.destroy

      ! Get the unique atom shifts, dX (leaky)
      .solve_normal_equations(dFa)
      dFa.destroy
 
   end

   shift_update_sf_n(sf_n) ::: private
   ! Update the unique *fragment* atom structure factors "sf_n" 
   ! by the unique *frag* atom positional shift in ".data.dX"

      sf_n :: MAT{CPX}, target, INOUT

   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,       "sf_n: wrong dim1")
   ENSURE(sf_n.dim2==.n_asymmetric_unit_atoms, "sf_n: wrong dim2")
   ENSURE(.data.created,                       "no data")
   ENSURE(.data.dX.created,                    "no data.dX")

      d1,d2,d3,kr  :: REAL
      n_k,u,k,base :: INT
      k1,k2,k3 :: VEC{REAL}*
      sf_u :: VEC{CPX}*
      k_pt :: MAT{REAL}*

      ! Get the k points
      n_k = .n_unique_SF_k_pts
      k_pt.create(n_k,3)      
      .make_unique_SF_k_pts(k_pt)

      ! Components of k
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! Loop over unique *frag* atoms
      do u = 1,.n_asymmetric_unit_atoms

         ! Get the shift
         base = 9*(u-1)
         d1 = .data.dX(base+1)
         d2 = .data.dX(base+2)
         d3 = .data.dX(base+3)

         ! Structure factors, unique atom "u"
         sf_u => sf_n(:,u)

         ! Update sf_u
         do k = 1,n_k
            kr = k1(k)*d1+k2(k)*d2+k3(k)*d3
            sf_u(k) = sf_u(k) * cmplx(cos(kr),sin(kr))
         end

      end

      ! Clean
      k_pt.destroy

   end

   set_fragment_errors  ::: private
   ! Set *all* the errors in the .fragment_atom positions/ADPs
   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.created,"no data")
   ENSURE(.data.fragment_covariance_matrix.created,"no data.fragment_covariance_matrix")

      esd :: VEC{REAL}*

      ! Get the fragment covariances
      .set_frag_from_asym_cov_mx

      ! Get just the positional covariance matrix
      esd.create(9*.n_fragment_atoms)
      .data.fragment_covariance_matrix.put_diagonal_to(esd)
      esd = sqrt(esd)

      ! Set the errors
      .fragment_atom.set_position_and_ADP_errors_to(esd)

      ! Clean
      esd.destroy

   end

!  Refinement: unique frag <-> asym frag parameters

   set_asym_from_ufrag_pADPs ::: private
   ! Set the .asymmetric_unit_atom positions/ADPs from the *unique*
   ! .fragment_atom's positions/ADPs 
   ENSURE(.fragment_info_made,"no fragment info")

      u,f,a,s :: INT
      f_atom,a_atom :: ATOM* 
      seitz :: MAT3{REAL}*
      DM,symop :: MAT{REAL}(3,3)
      pos,shift :: VEC{REAL}(3)

      ! Symmetry operators & cell matrix
      seitz => .xyz_seitz_matrices
      DM    =  .unit_cell.direct_matrix

      ! Loop on *unique* fragment atom's
      ! Set asymmetric_unit_atom position/ADPs 
      ! from the unique fragment_atom's positions/ADPs
      do u = 1,.n_unique_frag_atoms

         ! Links between the atom indices & symop s
         f = .unique_frag_atom(u)
         a = .asym_atom_for_frag_atom(f)
         s = .asym_symop_for_frag_atom(f)

         ! Atoms (fragment, asymmetric)
         f_atom => .fragment_atom(f)
         a_atom => .asymmetric_unit_atom(a)
         
         ! Fragment symops and shifts
         symop = seitz(:,:,s)
         shift = .asym_shift_for_frag_atom(:,f)

         ! Transform unique frag atom position (S^T)
         pos = f_atom.position - matmul(DM,shift)
         pos = matmul(pos,symop)
         a_atom.position = pos

         ! Transform unique frag atom ADP (use S)
         ! Note: ADPs must be in cartesian axes
         f_atom.ADP_tensor.change_basis_to(a_atom.ADP_tensor,symop)

         ! If refining H atom U_iso's make ADP isotropic
         if (.data.refine_H_U_iso) then          
         if (a_atom.atomic_number==1) then              
             a_atom.set_isotropic_ADP
         end
         end

      end

      ! Clean symops
      seitz.destroy

   end

   set_frag_from_asym_pADPs  ::: private
   ! Set *all* .fragment_atom positions/ADPs from the
   ! .asymmetric_unit_atom's positions/ADPs
   ENSURE(.fragment_info_made,"no fragment info")

      f,a,s :: INT
      f_atom,a_atom :: ATOM* 
      seitz :: MAT3{REAL}*
      DM,symop :: MAT{REAL}(3,3)
      pos,shift :: VEC{REAL}(3)

      ! Symmetry operators & cell matrix
      seitz => .xyz_seitz_matrices
      DM    = .unit_cell.direct_matrix

      ! Loop on *all* fragment atom's
      ! Set the .fragment_atom positions/ADP's 
      ! from the .asymmetric_unit_atom's
      do f = 1,.n_fragment_atoms

         ! Links between the atom indices & symop s
         a  = .asym_atom_for_frag_atom(f)
         s  = .asym_symop_for_frag_atom(f)

         ! Atoms (fragment, asymmetric)
         f_atom => .fragment_atom(f)
         a_atom => .asymmetric_unit_atom(a)
         
         ! Fragment symops and shifts
         symop = seitz(:,:,s)
         shift = .asym_shift_for_frag_atom(:,f)

         ! Transform unique frag atom position (S)
         pos = matmul(symop,a_atom.position) + matmul(DM,shift)
         f_atom.position = pos

         ! Transform asym atom ADP (use S^T)
         ! Note: ADPs must be in cartesian axes
         a_atom.ADP_tensor.back_transform_to(f_atom.ADP_tensor,symop)

      end

      ! Clean
      seitz.destroy

   end

   set_asym_from_ufrag_shifts ::: private
   ! From "dX", the unique atom shifts in positions and ADP's in the
   ! .atom list, return the *asymmetric* atom shifts positions and
   ! ADP's in the same "dX" parameter vector.

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.created,"no data")
   ENSURE(.data.dX.created,"no data.dX")

      base,u,f,a,s :: INT
      dA,par :: VEC{REAL}*
      posa :: VEC{REAL}(3)
      ADPa,symop :: MAT{REAL}(3,3)
      seitz :: MAT3{REAL}*
      atom :: ATOM

      ! Asym atom shift vector
      dA.create(.data.dX.dim)
      
      ! Get symops
      seitz => .xyz_seitz_matrices

      ! Loop over unique frag atoms
      do u = 1,.n_unique_frag_atoms

         ! Get the ufrag atom shifts
         base = 9*(u-1)
         par => .data.dX(base+1:base+9) 

         ! Put ufrag shifts in "atom"
         atom.set_position_and_ADPs_to(par)

         ! Link ufrag and asym atoms
         f = .unique_frag_atom(u)
         a = .asym_atom_for_frag_atom(f)
         s = .asym_symop_for_frag_atom(f)

         ! Change ufrag atom shifts -> asym atom shifts
         symop = seitz(:,:,s)
         posa = matmul(atom.position,symop)
         atom.ADP_tensor.change_basis_to(ADPa,symop)

         ! Define asymmetric atom
         atom.position   = posa
         atom.ADP_tensor = ADPa

         ! Set the asym atom parameter vector
         base = 9*(a-1) 
         par => dA(base+1:base+9) 

         ! Store asym shifts shifts
         atom.get_position_and_ADPs_in(par)

      end

      ! Replace .dX
      .data.dX = dA

      ! Clean
      seitz.destroy
      dA.destroy

      ! Debug
      if (.debugging("set_asym_from_ufrag_shifts")) then 
      stdout.text(".data.dX:")
      stdout.put(.data.dX)
      end

   end

   stabilize_asym_atom_shifts ::: private
   ! Stabilize ".dX", parameter vector for asymmetric atom *shifts* 
   ! in positions and ADP's, removing any symmetry breaking.

   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.created,"no data")
   ENSURE(.data.dX.created,"no data.dX")

      fac :: REAL
      n_stab,base,a,s,n :: INT
      stabilizer :: VEC{INT}*
      par :: VEC{REAL}*
      posn,post :: VEC{REAL}(3)
      ADPn,ADPt,symop :: MAT{REAL}(3,3)
      seitz :: MAT3{REAL}*
      atom :: ATOM
      
      ! Get symops
      seitz => .xyz_seitz_matrices

      ! Symmetrize the asym atom positions/ADP's
      do a = 1,.n_asymmetric_unit_atoms

         ! List of stabilizer symops
         stabilizer => .asym_atom_stabilizer(a).element

         ! Any stabilizers?
         n_stab = stabilizer.dim
         if (n_stab<=1) cycle

         ! Block of parameters
         base = 9*(a-1)
         par => .data.dX(base+1:base+9) ! stuff goes in here

         ! Extract shifts
         atom.set_position_and_ADPs_to(par)

         ! Apply symops and accumulate
         posn = atom.position
         ADPn = atom.ADP_tensor
         do n = 2,n_stab
            s = stabilizer(n)
            symop = seitz(:,:,s)
            atom.ADP_tensor.back_transform_to(ADPt,symop)
            post = matmul(symop,atom.position)
            ADPn = ADPn + ADPt
            posn = posn + post
         end

         ! Stabilize
         fac = ONE/n_stab
         atom.position   = posn * fac 
         atom.ADP_tensor = ADPn * fac

         ! Put back shifts
         atom.get_position_and_ADPs_in(par)

      end

      ! Clean
      seitz.destroy

      ! Debug
      if (.debugging("stabilize_asym_atom_shifts")) then 
      stdout.text(".data.dX:")
      stdout.put(.data.dX)
      end

   end

   update_fit_errors ::: private
   ! Set the fit errors e.g. maximum shift on esd and the positional
   ! and ADP errors for the asym unit. 

   ENSURE(.data.created,"no data")

      ! Reset the esd's and maximum shifts on esd
      .data.update_fit_errors

      ! Set asym atom patr value correspondin to the max shift/esd
      .data.max_shift_on_esd_par = .asymmetric_unit_atom.position_ADP_label(.data.max_shift_on_esd_ind)

   end

   update_refinement_errors
   ! Update the refinement errors e.g. maximum shift on esd and the
   ! positional and ADP errors for the asym unit.

   ENSURE(.data.created,"no data")

      ! Set the refinement errors
      .data.update_refinement_errors

      ! Set asym atom max refinement shift on easd par value
      .data.max_refshift_on_esd_par = .asymmetric_unit_atom.position_ADP_label(.data.max_refshift_on_esd_ind)

   end

!  Refinement: transform covariance matrix

   set_asym_from_ufrag_cov_mx ::: private
   ! Set the asymmetric atom covariance matrix from the unique
   ! fragment atom covariance_matrix (produced from refinement)
   ! Note: .covariance_matrix is over-written.
   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.created,"no data")

      n_p,u1,f1,a1,s1, u2,f2,a2,s2, i1,i2,j1,j2 :: INT
      diag :: VEC{REAL}*
      acov,ucov :: MAT{REAL}*
      T1,T2 :: MAT{REAL}(9,9)
      seitz :: MAT3{REAL}*

      ! *Inverse* symops (see below)
      seitz => .transposed_xyz_seitz_matrices

      ! No. of unique atoms (also no. of asymmetric unit atoms)
      n_p = 9*.n_asymmetric_unit_atoms

      ! Aliases: fragment and asymmetric covariances
      ucov => .data.covariance_matrix ! this is overwritten
      acov.create(n_p,n_p)
      acov = ZERO

      ! Copy the unique .fragment_atom to the asym unit covariances
      do u1 = 1,.n_unique_frag_atoms

         f1 = .unique_frag_atom(u1)
         a1 = .asym_atom_for_frag_atom(f1)
         s1 = .asym_symop_for_frag_atom(f1) ! s1 maps asym->ufrag atom
         i1 = (u1-1)*9                      ! input in ufrag order
         j1 = (a1-1)*9                      ! output in asym atom order

         T1 = ZERO
         T1(1:3,1:3) = seitz(:,:,s1)        ! seitz maps ufrag->asym atom
         T1(4:9,4:9).to_tensor_change_basis_of(seitz(:,:,s1),reorder=TRUE)

         do u2 = 1,.n_unique_frag_atoms

            f2 = .unique_frag_atom(u2)
            a2 = .asym_atom_for_frag_atom(f2)
            s2 = .asym_symop_for_frag_atom(f2)
            i2 = (u2-1)*9
            j2 = (a2-1)*9

            T2 = ZERO
            T2(1:3,1:3) = seitz(:,:,s2)
            T2(4:9,4:9).to_tensor_change_basis_of(seitz(:,:,s2),reorder=TRUE)
            
            ucov(i1+1:i1+9,i2+1:i2+9).back_transform_to(acov(j1+1:j1+9,j2+1:j2+9),T1,T2)

         end

      end

      ! Debugging
      if (.debugging("set_asym_from_ufrag_cov_mx")) then
       ! stdout.text("acov:")
       ! stdout.put(acov)
       ! stdout.text("ucov:")
       ! stdout.put(ucov)
         diag.create(acov.dim1)
         acov.put_diagonal_to(diag)
         diag = sign(sqrt(abs(diag)),diag)
         stdout.text("acov esds:")
         stdout.put(diag)
         ucov.put_diagonal_to(diag)
         diag = sign(sqrt(abs(diag)),diag)
         stdout.text("ucov esds:")
         stdout.put(diag)
         diag.destroy
      end

      ! Overwrite with asym-atom cov mx
      .data.covariance_matrix = acov

      ! Clean
      acov.destroy
      seitz.destroy

   end

   set_frag_from_asym_cov_mx ::: private
   ! Set the total frag atom covariance matrix from the asym atom
   ! covariance matrix. Seems correct 12/9/11
   ENSURE(.fragment_info_made,"no fragment info")
   ENSURE(.data.created,"no data")

      f1,a1,s1,f2,a2,s2, i1,i2,j1,j2 :: INT
      acov,fcov :: MAT{REAL}*
      T1,T2 :: MAT{REAL}(9,9)
      seitz :: MAT3{REAL}*

      ! Symops
      seitz => .xyz_seitz_matrices

      ! Aliases: fragment and asymmetric covariances
      fcov => .data.fragment_covariance_matrix
      acov => .data.covariance_matrix

      ! Copy the asymmetric atom covariances to *all* .fragment_atom ADPs
      do f1 = 1,.n_fragment_atoms

         a1 = .asym_atom_for_frag_atom(f1)
         s1 = .asym_symop_for_frag_atom(f1) ! s1 maps asym->frag atom
         i1 = (f1-1)*9                      ! output in frag atom oder
         j1 = (a1-1)*9                      ! input in asym atom order

         T1 = ZERO
         T1(1:3,1:3) = seitz(:,:,s1)        ! seitz maps asym->frag atom
         T1(4:9,4:9).to_tensor_change_basis_of(seitz(:,:,s1),reorder=TRUE)

         do f2 = 1,.n_fragment_atoms

            a2 = .asym_atom_for_frag_atom(f2)
            s2 = .asym_symop_for_frag_atom(f2)
            i2 = (f2-1)*9
            j2 = (a2-1)*9

            T2 = ZERO
            T2(1:3,1:3) = seitz(:,:,s2)
            T2(4:9,4:9).to_tensor_change_basis_of(seitz(:,:,s2),reorder=TRUE)

            acov(j1+1:j1+9,j2+1:j2+9).back_transform_to(fcov(i1+1:i1+9,i2+1:i2+9),T1,T2)

         end

      end

      ! Clean
      seitz.destroy

      ! Debugging
      if (.debugging("set_frag_from_asym_cov_max")) then
         stdout.text("acov:")
         stdout.put(acov)
         stdout.text("fcov:")
         stdout.put(fcov)
      end

   end

!  Refinement: finished?

   update_fit_parameters
   ! Update i.e. increment the fit parameters

   ENSURE(.data_exists,"no diffraction data")

      .data.update_fit_parameters

   end

   update_refinement_parameters
   ! Update the refinement parameters

   ENSURE(.data_exists,"no diffraction data")

      .data.update_refinement_parameters

   end
 
   fit_finished result (res)
   ! Return whether the (rigid) fit has finished
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.fit_finished

      ! Rewind coordinates and ADPs if chi2 increases. 
      ! WARNING: errors and cox mx are not rewound.
      if (.data.chi2_increased) then
         .asymmetric_unit_atom.set_positions_and_ADPs_to(.data.X_fit)
         .set_frag_from_asym_pADPs
      end

   end
 
   refinement_finished result (res)
   ! Return whether the refinement has finished
      res :: BIN

   ENSURE(.data_exists,"no diffraction data")

      res = .data.refinement_finished

   end

!  SF derivatives & normal equations

   make_unique_sf_derivs(sf_e,sf_d,sf_n)
   ! Make "sf_e" and "sf_d", the symmetry-related thermally-smeared
   ! structure factors and their derivatives, from "sf_n" the *unique*
   ! .fragment_atom structure factors and the ".fragment_atom.ADP_tensor".

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, INOUT

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created,                         "no data")

      ! Refine positions and ADPs
      if (.data.refine_positions_and_ADPs) then  

         if (.data.refine_H_ADPs) then      ! ... and refine H ADP's
   
            if (.data.refine_H_U_iso) then; .make_unique_sfd_pos_Y_Hiso_Y(sf_e,sf_d,sf_n)
            else;                           .make_unique_sfd_pos_Y_ADP__Y(sf_e,sf_d,sf_n)
            end
   
         else                               ! ... and don't refine H ADP's

                                            .make_unique_sfd_pos_Y_HADP_N(sf_e,sf_d,sf_n)
         end

      ! Refine positions only, not ADPs
      else if (.data.refine_positions_only) then 

                                            .make_unique_sfd_pos_Y_ADP__N(sf_e,sf_d,sf_n) 

      ! Refine ADP's only, not positions
      else if (.data.refine_ADPs_only) then      

         if (.data.refine_H_ADPs) then      ! ... and refine H ADP's
   
            if (.data.refine_H_U_iso) then; .make_unique_sfd_pos_N_Hiso_Y(sf_e,sf_d,sf_n)
            else;                           .make_unique_sfd_pos_N_ADP__Y(sf_e,sf_d,sf_n)
            end

         else                               ! ... and don't refine H ADP's
   
                                            .make_unique_sfd_pos_N_HADP_N(sf_e,sf_d,sf_n)
         end

      ! wtf?
      else

         DIE("you aren't refining anything!")

      end 

   end

   make_unique_sfd_pos_Y_ADP__Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does *all* parameters, positions and ADPs

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      II,sf,sf2 :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)

         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         do k = 1,n_k

            k1k = k1(k)
            k2k = k2(k)
            k3k = k3(k)

            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

            sf  = sf_u(k) * tf
            sf2 = HALF*sf

            sf_e(k) = sf_e(k) + sf

            sf_d(k,base+1) =   II*k1k*sf
            sf_d(k,base+2) =   II*k2k*sf
            sf_d(k,base+3) =   II*k3k*sf
            sf_d(k,base+4) = -k1k*k1k*sf2
            sf_d(k,base+5) = -k2k*k2k*sf2
            sf_d(k,base+6) = -k3k*k3k*sf2
            sf_d(k,base+7) = -k1k*k2k*sf 
            sf_d(k,base+8) = -k1k*k3k*sf 
            sf_d(k,base+9) = -k2k*k3k*sf 

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy
   
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_Y_ADP__N(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does positions *only*

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      II,sf :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)

         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         do k = 1,n_k

            k1k = k1(k)
            k2k = k2(k)
            k3k = k3(k)

            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

            sf  = sf_u(k) * tf

            sf_e(k) = sf_e(k) + sf

            sf_d(k,base+1) =   II*k1k*sf
            sf_d(k,base+2) =   II*k2k*sf
            sf_d(k,base+3) =   II*k3k*sf

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy
   
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_N_ADP__Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does ADPs *only*

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      sf,sf2 :: CPX

      ! Constants
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)

         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         do k = 1,n_k

            k1k = k1(k)
            k2k = k2(k)
            k3k = k3(k)

            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

            sf  = sf_u(k) * tf
            sf2 = HALF*sf

            sf_e(k) = sf_e(k) + sf

            sf_d(k,base+4) = -k1k*k1k*sf2
            sf_d(k,base+5) = -k2k*k2k*sf2
            sf_d(k,base+6) = -k3k*k3k*sf2
            sf_d(k,base+7) = -k1k*k2k*sf 
            sf_d(k,base+8) = -k1k*k3k*sf 
            sf_d(k,base+9) = -k2k*k3k*sf 

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy
   
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_Y_Hiso_Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does H_U_iso=TRUE derivatives.

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      II,sf,sf2 :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)
         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         if (.fragment_atom(f).atomic_number>1) then

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf = sf_u(k) * tf
               sf2 = HALF*sf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+1) =   II*k1k*sf
               sf_d(k,base+2) =   II*k2k*sf
               sf_d(k,base+3) =   II*k3k*sf
               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 

            end

         else

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf  = sf_u(k) * tf
               sf2 = -HALF * sf * (k1k*k1k+k2k*k2k+k3k*k3k) * THIRD

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+1) = II*k1k*sf
               sf_d(k,base+2) = II*k2k*sf
               sf_d(k,base+3) = II*k3k*sf
               sf_d(k,base+4) = sf2
               sf_d(k,base+5) = sf2
               sf_d(k,base+6) = sf2
               sf_d(k,base+7) = ZERO
               sf_d(k,base+8) = ZERO
               sf_d(k,base+9) = ZERO

            end

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_N_Hiso_Y(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version *no* positions and does H_U_iso=TRUE derivatives.

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      sf,sf2 :: CPX

      ! Constants
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)
         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         if (.fragment_atom(f).atomic_number>1) then

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf = sf_u(k) * tf
               sf2 = HALF*sf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 

            end

         else

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf  = sf_u(k) * tf
               sf2 = -HALF*sf * (k1k*k1k+k2k*k2k+k3k*k3k) * THIRD

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+4) = sf2
               sf_d(k,base+5) = sf2
               sf_d(k,base+6) = sf2

            end

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_Y_HADP_N(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does *not* do H ADPs

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      II,sf,sf2 :: CPX

      ! Constants
      II  = IMAGIFY(ONE)
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)
         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         ! If not hydrogen atom
         if (.fragment_atom(f).atomic_number>1) then

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf = sf_u(k) * tf
               sf2 = HALF*sf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+1) =   II*k1k*sf
               sf_d(k,base+2) =   II*k2k*sf
               sf_d(k,base+3) =   II*k3k*sf
               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 

            end

         else ! this is hydrogen atom

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf  = sf_u(k) * tf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+1) = II*k1k*sf
               sf_d(k,base+2) = II*k2k*sf
               sf_d(k,base+3) = II*k3k*sf

            end

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   make_unique_sfd_pos_N_HADP_N(sf_e,sf_d,sf_n) ::: private
   ! Make the unique structure factors and their derivatives "sf_e"
   ! and "sf_d" corresponding to the unique_SF_k_pts from  the given
   ! set of atom parameters in .fragment_atom.
   ! NOTE: this version does *not* do positions *nor* H ADPs
   !       i.e. it only does heavy atom ADPs

      sf_e :: VEC{CPX}, OUT
      sf_d :: MAT{CPX}, OUT
      sf_n :: MAT{CPX}, target, IN

   ENSURE(sf_e.dim ==.n_unique_SF_k_pts,         "sf_e, wrong dim")
   ENSURE(sf_d.dim1==.n_unique_SF_k_pts,         "sf_d, wrong dim1")
   ENSURE(sf_d.dim2==.n_asymmetric_unit_atoms*9, "sf_d, wrong dim2")
   ENSURE(sf_n.dim1==.n_unique_SF_k_pts,         "sf_n, wrong dim1")
   ENSURE(sf_n.dim2==.asymmetric_unit_atom.dim,  "sf_n, wrong dim2")
   ENSURE(.data.created, "no reflection data")
   ENSURE(.xray_data.created, "no x-ray reflection data")
   ENSURE(.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")

      k_pt,kU  :: MAT{REAL}*
      sf_u :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,tf :: REAL
      n_k,f,u,k,base :: INT
      sf,sf2 :: CPX

      ! Constants
      n_k = .n_unique_SF_k_pts

      ! Symmetry generated k points
      k_pt.create(n_k,3)
      .make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! K times thermal tensors
      kU.create(n_k,3)        

      ! Initialize
      sf_e = ZERO
      sf_d = ZERO

      ! Make the structure factors and derivatives
      parallel do u = 1,.n_unique_frag_atoms

         f = .unique_frag_atom(u)

         kU.to_product_of(k_pt,.fragment_atom(f).ADP_tensor)
         u1 => kU(:,1)
         u2 => kU(:,2)
         u3 => kU(:,3)

         sf_u => sf_n(:,u)

         base = 9*(u-1)

         ! If not hydrogen atom
         if (.fragment_atom(f).atomic_number>1) then

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf = sf_u(k) * tf
               sf2 = HALF*sf

               sf_e(k) = sf_e(k) + sf

               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 

            end

         else ! this is hydrogen atom

            do k = 1,n_k

               k1k = k1(k)
               k2k = k2(k)
               k3k = k3(k)

               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))

               sf  = sf_u(k) * tf

               sf_e(k) = sf_e(k) + sf

            end

         end

      end

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

   end

   d_chi2_dX(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters.  NOTE: this routine assumes that the .scale_factor
   ! and .extinction_factor are fixed.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.d_chi2_dX(res,dFdX)
   end

   d_chi2_dX_plus_se(res,dFdX)
   ! Evaluate "res", the derivative of the chi^2 with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors w.r.t. the X
   ! parameters. Two extra derivatives are included, w.r.t. the
   ! extinction parameter and the scale factor.
      res :: VEC{REAL}, OUT
      dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.d_chi2_dX_plus_se(res,dFdX)
   end

   d_F_abs_dX(res,dFdX)
   ! Evaluate "res", the derivative of the F_abs with respect to some
   ! parameters X (e.g. thermal parameters) given "dFdX", the
   ! derivatives of the complex structure factors  w.r.t. the X
   ! parameters. 
      res :: MAT{REAL}, OUT
      dFdX :: MAT{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.d_F_abs_dX(res,dFdX)
   end

   solve_normal_equations(dFdX) ::: leaky
   ! Get the ".dX" in the parameters by solving the normal
   ! equations, given "dFdX", the derivatives of the absolute
   ! structure factors w.r.t. those parameters. 
      dFdX :: MAT{REAL}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.solve_normal_equations(dFdX)
   end

!   set_parameter_errors
!   ! Set the parameter errors
!   ENSURE(.data_exists,"no diffraction data")
!
!      .data.set_parameter_errors
!
!   end

!  Refinement output

   put_fit_header_info
   ! Put out the fit header
   ENSURE(.data_exists,"no diffraction data")

      ! Turn off printing if refining ...
      if (.data.refine_structure AND NOT .data.show_fit_output) return

      ! Print header
      .data.put_fit_header

      ! Put the fit control switches
      .data.put_refinement_switches

      ! Put the initial parameters
      stdout.flush(2)
      stdout.text("Initial parameter values:")
      .put_fit_parameters(correlation_matrix=FALSE)

      ! Put the fit table header
      .data.put_fit_table_headings

   end

   put_refinement_header_info
   ! Put out the fit header
   ENSURE(.data_exists,"no diffraction data")

      ! Print header
      .data.put_refinement_header

      ! Put the refinement control switches
      .data.put_refinement_switches

      ! Put the initial parameters
      stdout.flush
      stdout.text("Initial asymmetric unit parameter values:")
      .put_fit_parameters(correlation_matrix=FALSE)

      ! Put the refinement header info
      .data.put_refinement_table_headings

   end

   put_fit_parameters(correlation_matrix)
   ! Write refinement results
      correlation_matrix :: BIN, optional

   ENSURE(.data_exists,"no diffraction data")
   ENSURE(.data.esd.created,"no data errors")

      do_corr_mx :: BIN

      ! Put positions and ADPs
      .asymmetric_unit_atom.put_coordinates_and_ADPs(no_header=TRUE)

      ! Whether to print the parameter corelation matrix
      do_corr_mx = .data.display_correlation_matrix
      if (present(correlation_matrix)) do_corr_mx = correlation_matrix

      ! Put correlation matrix
      if (do_corr_mx) .put_correlation_matrix

      ! Put zero eigenvalue information
      if (.data.display_near_0_eigenvectors) .data.put_near_0_eigenvectors

   end

   put_correlation_matrix
   ! Put the correlation matrix
   ENSURE(.data_exists,"no diffraction data")
   ENSURE(.data.esd.created,"no data errors")

      val :: VEC{REAL}*
      row,col :: VEC{INT}*
      label,labr,labc :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*
      min_corr :: REAL
      n_corr :: INT

      ! How many large correlations?
      min_corr = .data.min_correlation
      n_corr   = .data.correlation_matrix.number_in_range([min_corr,0.999d0])

      ! If no large correlations, return
      if (n_corr<0) return

      ! Create
      val.create(n_corr)
      label.create(n_corr)
      row.create(n_corr)
      col.create(n_corr)

      ! Get row and column indices
      .data.correlation_matrix.get_indices_in_range([min_corr,0.9999d0],row,col,val)

      ! Construct the row labels
      labr  => .asymmetric_unit_atom.position_ADP_labels(row)
      labc  => .asymmetric_unit_atom.position_ADP_labels(col)
      label = labr
      label.concatenate_elementwise_with(labr)
      label.concatenate_elementwise_with("--")
      label.concatenate_elementwise_with(labc)

      ! Clean
      labc.destroy
      labr.destroy
      col.destroy
      row.destroy

      ! Make table
      table.create(2)
      table(1).set_heading("Param. Pair"); table(1).set_values(label)
      table(1).set_heading("Correlation"); table(2).set_values(val)
      table.put
      table.destroy

      ! Put the array out
      stdout.flush
      stdout.text("Largest correlations::")
      stdout.flush
      stdout.put(val,row_label=label,col_label="Correlation")

      ! Clean again
      label.destroy
      val.destroy

   end

   put_fit_iteration_results
   ! Print out the current fit iterations results
   ENSURE(.data_exists,"no diffraction data")

      ! Turn off printing if refining ...
      if (.data.refine_structure AND NOT .data.show_fit_output) return

      ! Put the table body
      .data.put_fit_table_body

   end

   put_refinement_iteration_results
   ! Print out the current refinement iterations results
   ENSURE(.data_exists,"no diffraction data")

      ! Put the table body
      .data.put_refinement_table_body

   end

   put_fit_footer_info
   ! Finalise fit, write results
   ENSURE(.data_exists,"no diffraction data")

      ! Turn off printing if refining
      if (.data.refine_structure) return

      ! Iteration footer
      .data.put_fit_results

      ! Put the initial parameters
      stdout.flush(2)
      stdout.text("Final asymmetric unit parameter values:")
      .put_fit_parameters

   end

   put_refinement_footer_info
   ! Finalise refinement, write results
   ENSURE(.data_exists,"no diffraction data")

      ! Iteration footer
      .data.put_refinement_results

      ! Put the initial parameters
      stdout.flush(2)
      stdout.text("Final asymmetric unit parameter values:")
      .put_fit_parameters

   end

   put_bond_info_with_errors
   ! Put out the bond-length, bond-angle and torsion-angle info with
   ! errors in brackets

   ENSURE(.data.created,   "no data")
   ENSURE(.data.fragment_covariance_matrix.created,"no fragment_covariance_matrix")

      cm :: MAT{REAL}*

      ! Turn off printing if refining
      if (.data.refine_structure) return

      ! Positional covariance matrix
      cm.create(3*.n_fragment_atoms,3*.n_fragment_atoms)

      ! Get just the positional covariance matrix
      .data.fragment_covariance_matrix.put_sub_blocks_to(cm,9,3)

      ! Print out the tables with errors
      .fragment_atom.put_bond_length_table(cm)
      .fragment_atom.put_bond_angle_table(cm)
      .fragment_atom.put_torsion_angle_table(cm)

      ! Clean
      cm.destroy

   end

   put_bond_info_with_errors_to
   ! Put out the bond-length, bond-angle and torsion-angle info with
   ! errors with *no* brackets to a file, name read from stdin

   ENSURE(.data.created,   "no data")
   ENSURE(.data.fragment_covariance_matrix.created,"no fragment_covariance_matrix")

      cm :: MAT{REAL}*
      name :: STR
      save,file :: TEXTFILE*

      ! Read the name
      stdin.read(name)

      ! Create the new file
      file.create(trim(name))
      file.open_for("write")

      ! Positional covariance matrix
      cm.create(3*.n_fragment_atoms,3*.n_fragment_atoms)

      ! Get just the positional covariance matrix
      .data.fragment_covariance_matrix.put_sub_blocks_to(cm,9,3)

      ! Print out the tables with errors
      save   => TEXTFILE::stdout
      stdout => file
      .fragment_atom.put_bond_length_table(cm,parentheses=FALSE)
      .fragment_atom.put_bond_angle_table(cm,parentheses=FALSE)
      .fragment_atom.put_torsion_angle_table(cm,parentheses=FALSE)
      stdout => save

      ! Clean
      cm.destroy
      file.close; file.destroy

   end

!  **************
!  Debug printing
!  **************

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT3{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

!  **************
!  Output methods
!  **************

   put
   ! Put out the crystal data to file "out"

      .unit_cell.put

      .spacegroup.put

      if (.asymmetric_unit_geometry.created) .put_asymmetric_unit_geometry

      if (.fragment_geometry.created)        .put_fragment_data

    ! if (.unit_cell_geometry.created)       .put_unit_cell_geometry
    ! if (.unit_cell_connection.created)     .put_uc_connection_table
    ! if (.uc_vdw_connection.created)        .put_uc_vdw_connection_table

      .put_reflection_data

   end

   put_xyz_seitz
   ! Put out the spacegroup seitz matrices.

   ENSURE(.spacegroup.n_seitz>0,"no seitz matrices")

      n :: INT
      seitz :: MAT3{REAL}*

      seitz => .xyz_seitz_matrices

      stdout.flush
      stdout.text("Cartesian (xyz) seitz matrices :")
      do n = 1,.spacegroup.n_seitz
        stdout.flush
        stdout.show("n =",n)
        stdout.put(seitz(:,:,n))
      end

      seitz.destroy

   end

   put_asymmetric_unit_geometry ::: private
   ! Put out the asymmetric unit geometry. 

   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit atoms")
   ENSURE(.asym_atom_rep_factor.created,"no asym_atom_rep_factor")
   ENSURE(.asym_atom_stabilizer.created,"no asym_atom_stabilizer")

      ID :: VEC{STR}*
      rf :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.flush
      stdout.text("===============")
      stdout.text("Asymmetric unit")
      stdout.text("===============")
      stdout.flush
      stdout.show("Asymmetric unit source       =",.asymmetric_unit_source)
      stdout.show("No. of asymmetric unit atoms =",.n_asymmetric_unit_atoms)
      stdout.flush

      ! Data
      ID => .asymmetric_unit_atom.unique_tags
      rf.create(.n_asymmetric_unit_atoms)
      rf = int(.asym_atom_rep_factor)

      ! Table
      table.create(6)
      table(1).set_heading("ID");         table(1).set_values(ID)
      table(2).set_heading("x");          table(2).set_values(.asymmetric_unit_geometry(1,:))
      table(3).set_heading("y");          table(3).set_values(.asymmetric_unit_geometry(2,:))
      table(4).set_heading("z");          table(4).set_values(.asymmetric_unit_geometry(3,:))
      table(3).set_sb3head("/frac")
      table(5).set_heading("Rep");        table(5).set_values(rf)
      table(5).set_subhead("fac")
      table(5).set_sb3head("tor")
      table(6).set_item_spacing(2)
      table(6).set_heading("Stabilizer"); table(6).set_values(.asym_atom_stabilizer)
      table(6).set_subhead("symops")
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      rf.destroy
      ID.destroy

   end

   put_asym_atom_rep_factors ::: private
   ! Put out the asymmetric unit atom repetition factors

   ENSURE(.asym_atom_rep_factor.created,"no asymmetric unit atom repetition factors")
   ENSURE(.asym_atom_stabilizer.created,"no asymmetric unit atom stabilizers")
   ENSURE(.asymmetric_unit_atom.created,"no asymmetric unit atom")

      a,n,rf,st :: INT
      symbol :: STR

      stdout.flush
      stdout.text("Crystal asymmetric unit atom repetition factors:")
      stdout.flush
      stdout.dash(int_fields=3)
      stdout.put("Asym",int_width=TRUE)
      stdout.put("Rep.",int_width=TRUE)
      stdout.put("Stab.",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Factor",int_width=TRUE)
      stdout.put("Symop",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=3)
      do a = 1,.n_asymmetric_unit_atoms
         symbol = .asymmetric_unit_atom(a).chemical_symbol
         symbol = trim(symbol) // " (" // trim(a.to_str) // ")"
         stdout.put(symbol,int_width=TRUE)
         DIE_IF(NOT .asym_atom_rep_factor(a).is_int,"asym_atom_rep_factor not int!")
         rf = int(.asym_atom_rep_factor(a))
         st = .asym_atom_stabilizer(a)[1]
         stdout.put(rf)
         stdout.put(st)
         do n = 2,.asym_atom_stabilizer(a).element.dim
            st = .asym_atom_stabilizer(a)[n]
            stdout.flush
            stdout.tab(int_fields=2)
            stdout.put(st)
         end
         stdout.flush
      end
      stdout.dash(int_fields=3)
   end

   put_unit_cell_geometry ::: private
   ! Put out the unit_cell_geometry. If present, "atom" is assumed to be the
   ! list of fragment atoms.

   ENSURE(.unit_cell_geometry.created,"no unit_cell_geometry")
   ENSURE(.frag_parent_for_cell_atom.created,"no frag_parent_for_cell_atom")

      u,a :: INT
      symbol :: STR

      stdout.flush
      stdout.text("Crystal unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do u = 1,.n_unit_cell_atoms
         stdout.put(u)
         if (.asymmetric_unit_atom.created) then
            a = .asym_atom_for_unit_cell_atom(u)
            symbol = .asymmetric_unit_atom(a).chemical_symbol
            symbol = trim(symbol) // " (" // trim(u.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(u)
         end
         stdout.put(.unit_cell_geometry(1,u))
         stdout.put(.unit_cell_geometry(2,u))
         stdout.put(.unit_cell_geometry(3,u))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_pdb(pdbfile)
   ! pdb file header generation
   ! Put unit cell information 
   !CRYST1   31.595   32.369   24.219  90.00  90.00  90.00 P 21 21 21    8
      pdbfile :: TEXTFILE*
      factor :: REAL
      pdbfile.save
      pdbfile.set_margin_width(0)
      pdbfile.put("CRYST1",width=6)
      pdbfile.set_real_precision(3)
      pdbfile.set_real_width(9)
      pdbfile.put(.unit_cell.length(1).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(2).to_units("angstrom"))
      pdbfile.put(.unit_cell.length(3).to_units("angstrom"))
      pdbfile.set_real_precision(2)
      pdbfile.set_real_width(7)
      pdbfile.put(.unit_cell.angle(1).to_units("degree"))
      pdbfile.put(.unit_cell.angle(2).to_units("degree"))
      pdbfile.put(.unit_cell.angle(3).to_units("degree"))
      pdbfile.put(.spacegroup.HM_symbol,width=10)
      pdbfile.put(.Z,width=5)
      pdbfile.flush
      pdbfile.put("SCALE1",width=6)
      pdbfile.tab(width=6)
      pdbfile.set_real_precision(7)
      pdbfile.set_real_width(10)
      factor=1.0d0
      factor.convert_to("angstrom^-1")
      pdbfile.put(.unit_cell.inverse_matrix(1,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(1,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(1,3)*factor)
      pdbfile.flush
      pdbfile.put("SCALE2",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_matrix(2,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(2,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(2,3)*factor)
      pdbfile.flush
      pdbfile.put("SCALE3",width=6)
      pdbfile.tab(width=6)
      pdbfile.put(.unit_cell.inverse_matrix(3,1)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(3,2)*factor)
      pdbfile.put(.unit_cell.inverse_matrix(3,3)*factor)
      pdbfile.flush
      !SCALE1     0.1053741 0.0175390 0.0172991      0.0000000
      !SCALE2     0.0000000 0.0601636 0.0076747      0.0000000
      !SCALE3     0.0000000 0.0000000 0.0321397      0.0000000
      pdbfile.unsave
   end

   make_cif_errors(esd)
   ! Make the errors "esd" for cif file output (positions and ADP's)
   ! after a refinement i.e. this is done in crystal axis system;
   ! positions are in bohr and ADP's are in bohr^2.
      esd :: VEC{REAL}

   ENSURE(.asymmetric_unit_atom.created,"no asymmetric unit atoms")
   ENSURE(esd.dim==9*.asymmetric_unit_atom.dim,"wrong size, esd")
   ENSURE(.data.created,"no data")
   ENSURE(.data.covariance_matrix.created,"no covariance_matrix")

      n_atom, a,b,i,j :: INT
      T,C :: MAT{REAL}*

      ! No of asymmteric atoms
      n_atom = .asymmetric_unit_atom.dim

      ! The covariance matrix transform
      T.create(9,9)
      T = ZERO
      T(1:3,1:3) = .unit_cell.inverse_matrix
      T(4:9,4:9).to_tensor_change_basis_of(.unit_cell.reciprocal_U_matrix,reorder=TRUE)

      ! Get standard deviations and covariances 
      ! in crystal coordinates
      C.create(9*n_atom,9*n_atom)
      i = 0
      do a = 1,n_atom
         j = 0
         do b = 1,n_atom
            .data.covariance_matrix(i+1:i+9,j+1:j+9).back_transform_to(C(i+1:i+9,j+1:j+9),T)
            j = j + 9
         end
         i = i + 9
      end

      ! Get the esd's
      C.put_diagonal_to(esd)

      ! Clean
      C.destroy
      T.destroy

   end

   put_cif(basis,scf_type)
   ! Put out a standard cif file
      basis,scf_type :: STR

      refinement :: BIN
      Z :: INT
      esd :: VEC{REAL}*

      ! Spacegroup information
      stdout.flush
      stdout.text("# --------------------")
      stdout.text("# Symmetry information")
      stdout.text("# --------------------")
      .spacegroup.put_cif

      ! Unit cell information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Unit cell information")
      stdout.text("# ---------------------")
      .unit_cell.put_cif

      ! Z factor
      ENSURE(REAL:is_int(.z_factor),"Z factor is not an integer")
      Z = int(.z_factor)
      stdout.text("_cell_formula_units_Z "//trim(Z.to_str))

      ! Put refinement information
      refinement = FALSE
      nullify (esd)
      if (.data.created) then
      if (.data.covariance_matrix.created) then

         ! Refinement was done
         refinement = TRUE

         ! Write the details
         stdout.flush
         stdout.text("# ------------------")
         stdout.text("# Refinement details")
         stdout.text("# ------------------")
         .data.put_cif(basis,scf_type)

         ! Standard deviations and covariances
         esd.create(9*.n_asymmetric_unit_atoms)
         .make_cif_errors(esd)
         esd = sqrt(esd)

      end
      end

      ! Put the coordinate information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# ---------------------")

      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell)
      if (refinement) then; .asymmetric_unit_atom.put_cif_with_errors(esd)
      else;                 .asymmetric_unit_atom.put_cif
      end
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell)

      ! Clean
      esd.destroy

      ! Put the reflection data
      if (refinement) then
         stdout.flush
         stdout.text("# -----------------------")
         stdout.text("# Refined reflection data")
         stdout.text("# -----------------------")
         .data.put_cif_reflections
      end

   end

   put_accurate_cif(basis,scf_type)
   ! Put accurate cif file
      basis,scf_type :: STR

      Z :: INT

      if (.data.destroyed) then
         WARN("No data, no refinement? CIF file not made.")
         return
      end

      if (.data.covariance_matrix.destroyed) then
         WARN("No covariance matrix, no CIF file made")
         return
      end

      ! Spacegroup information
      stdout.flush
      stdout.text("# --------------------")
      stdout.text("# Symmetry information")
      stdout.text("# --------------------")
      .spacegroup.put_cif

      ! Unit cell information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Unit cell information")
      stdout.text("# ---------------------")
      .unit_cell.put_cif

      ! Z factor
      ENSURE(REAL:is_int(.z_factor),"Z factor is not an integer")
      Z = int(.z_factor)
      stdout.text("_cell_formula_units_Z "//trim(Z.to_str))

      ! Put refinement information
      stdout.flush
      stdout.text("# ------------------")
      stdout.text("# Refinement details")
      stdout.text("# ------------------")
      .data.put_cif(basis,scf_type)

      ! Put the coordinate information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# ---------------------")
      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell)
      .asymmetric_unit_atom.put_accurate_cif(.data.covariance_matrix)
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell)

   end

   put_molecule_cif(atom,basis,scf_type)
   ! Put cif file with given molecule "atom" list
      atom :: VEC{ATOM}
      basis,scf_type :: STR

      Z :: INT

      ! Spacegroup information
      stdout.flush
      stdout.text("# --------------------")
      stdout.text("# Symmetry information")
      stdout.text("# --------------------")
      .spacegroup.put_cif

      ! Unit cell information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Unit cell information")
      stdout.text("# ---------------------")
      .unit_cell.put_cif

      ! Z factor
      ENSURE(REAL:is_int(.z_factor),"Z factor is not an integer")
      Z = int(.z_factor)
      stdout.text("_cell_formula_units_Z "//trim(Z.to_str))

      ! Put refinement information
      if (.data.created) then
      stdout.flush
      stdout.text("# ------------------")
      stdout.text("# Refinement details")
      stdout.text("# ------------------")
      .data.put_cif(basis,scf_type)
      end

      ! Put the coordinate information
      stdout.flush
      stdout.text("# ---------------------")
      stdout.text("# Coordinates and ADP's")
      stdout.text("# ---------------------")
      atom.change_axis_system_to("crystal",.unit_cell)
      atom.put_accurate_cif
      atom.change_axis_system_to("cartesian",.unit_cell)

   end

   put_NKA_cartesian
   ! Put out the NKA information in cartesian coordinates
      ENSURE(.data.created,"no diffraction data")
      ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")

      ! Cell line
      stdout.flush
      stdout.put("TCEL",width=4)
      stdout.put(.data.NKA_T_sequence_no,width=3)
      stdout.put(.data.temperature,width=6,precision=1)
      stdout.put(.unit_cell.length(1).to_units("angstrom"))
      stdout.put(.unit_cell.length(2).to_units("angstrom"))
      stdout.put(.unit_cell.length(3).to_units("angstrom"))
      stdout.put(.unit_cell.angle(1).to_units("degree"))
      stdout.put(.unit_cell.angle(2).to_units("degree"))
      stdout.put(.unit_cell.angle(3).to_units("degree"))
      stdout.flush

      ! Coordinate information
      .asymmetric_unit_atom.put_NKA_with_errors(.data.NKA_T_sequence_no)

   end

!   put_NKA_crystal
!   ! Put out the NKA information in cartesian coordinates
!      ENSURE(.data.created,"no diffraction data")
!      ENSURE(.data.covariance_matrix.created,"no covariance_matrix")
!      ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")
!
!      n_atom :: INT
!      esd :: VEC{REAL}*
!
!      ! Cell line
!      stdout.flush
!      stdout.put("TCEL",width=4)
!      stdout.put(.data.NKA_T_sequence_no,width=3)
!      stdout.put(.data.temperature,width=6,precision=1)
!      stdout.put(.unit_cell.length(1).to_units("angstrom"))
!      stdout.put(.unit_cell.length(2).to_units("angstrom"))
!      stdout.put(.unit_cell.length(3).to_units("angstrom"))
!      stdout.put(.unit_cell.angle(1).to_units("degree"))
!      stdout.put(.unit_cell.angle(2).to_units("degree"))
!      stdout.put(.unit_cell.angle(3).to_units("degree"))
!      stdout.flush
!
!      ! Change axis system to crystal
!      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell)
!
!      ! Standard deviations and covariances
!      n_atom = .asymmetric_unit_atom.dim
!      esd.create(9*n_atom)
!      .make_cif_errors(esd)
!      esd = sqrt(esd)
!
!      ! Dump the data
!      .asymmetric_unit_atom.put_NKA_with_errors(esd,.data.NKA_T_sequence_no,fractional_coords=TRUE)
!
!      ! Change axes back to cartesian
!      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell)
!
!      ! Clean up
!      esd.destroy
!
!   end

   put_excel_crystal
   ! Put out the coordinate and ADP information in Excel format
      ENSURE(.data.created,"no diffraction data")
      ENSURE(.data.covariance_matrix.created,"no covariance_matrix")
      ENSURE(.asymmetric_unit_atom.created,"no asymmetric_unit_atom list")

      esd :: VEC{REAL}*

      ! Cell line
      stdout.flush
      stdout.put("TCEL",width=4)
      stdout.put(.data.NKA_T_sequence_no,width=3)
      stdout.put(.data.temperature,width=6,precision=1)
      stdout.put(.unit_cell.length(1).to_units("angstrom"))
      stdout.put(.unit_cell.length(2).to_units("angstrom"))
      stdout.put(.unit_cell.length(3).to_units("angstrom"))
      stdout.put(.unit_cell.angle(1).to_units("degree"))
      stdout.put(.unit_cell.angle(2).to_units("degree"))
      stdout.put(.unit_cell.angle(3).to_units("degree"))
      stdout.flush

      ! Get errors in crystal coordinates
      esd.create(9*.n_asymmetric_unit_atoms)
      .make_cif_errors(esd)
      esd = sqrt(esd)

      ! Change axis system to crystal
      .asymmetric_unit_atom.change_axis_system_to("crystal",.unit_cell)

      ! Dump the data
      .asymmetric_unit_atom.put_excel_with_errors(esd,.data.temperature)

      ! Change axes back to cartesian
      .asymmetric_unit_atom.change_axis_system_to("cartesian",.unit_cell)

      ! Clean up
      esd.destroy

   end

   put_uc_connection_table
   ! Put the .unit_cell_connection table

   ENSURE(.unit_cell_connection.created,"no unit_cell_connection")
   ENSURE(.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Unit cell atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)
   
         first = TRUE
         do a = 1,.unit_cell_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle
   
            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE
   
            if (.unit_cell_connection(a).element.dim==0) then
   
               stdout.flush
   
            else
   
               do i = 1,.unit_cell_connection(a).element.dim
   
                  if (i>1) &
                  stdout.tab(int_fields=2)
   
                  b = .unit_cell_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.unit_cell_connection(a)[i][1])
                  stdout.put(.unit_cell_connection(a)[i][2])
                  stdout.put(.unit_cell_connection(a)[i][3])
                  stdout.flush
   
               end
   
            end
         end
      end

      stdout.dash(int_fields=6)

   end

   put_uc_vdw_connection_table
   ! Put the .unit_cell_connection table

   ENSURE(.uc_vdw_connection.created,"no uc_vdw_connection")
   ENSURE(.unit_cell_mol_for_atom.created,"no unit_cell_mol_for_atom")

      m,ma,a,i,b :: INT
      first :: BIN

      stdout.flush
      stdout.text("Cell VDW atom connection table:")
      stdout.flush
      stdout.show("n_unit_cell_mols =",.n_unit_cell_mols)

      stdout.flush
      stdout.dash(int_fields=6)
      stdout.put("UnitCell",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("Joins",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("In Cell",int_width=TRUE)
      stdout.flush

      stdout.put("Mol.",int_width=TRUE)
      stdout.put("Atom 1",int_width=TRUE)
      stdout.put("Atom 2",int_width=TRUE)
      stdout.put("h",int_width=TRUE)
      stdout.put("k",int_width=TRUE)
      stdout.put("l",int_width=TRUE)
      stdout.flush

      stdout.dash(int_fields=6)

      do m = 1,.n_unit_cell_mols

         stdout.put(m)
   
         first = TRUE
         do a = 1,.uc_vdw_connection.dim

            ma = .unit_cell_mol_for_atom(a)
            if (ma/=m) cycle
   
            if (NOT first) &
            stdout.tab(int_fields=1)
            stdout.put(a)
            first = FALSE
   
            if (.uc_vdw_connection(a).element.dim==0) then
   
               stdout.flush
   
            else
   
               do i = 1,.uc_vdw_connection(a).element.dim
   
                  if (i>1) &
                  stdout.tab(int_fields=2)
   
                  b = .uc_vdw_connection(a)[i][4]
                  stdout.put(b)
                  stdout.put(.uc_vdw_connection(a)[i][1])
                  stdout.put(.uc_vdw_connection(a)[i][2])
                  stdout.put(.uc_vdw_connection(a)[i][3])
                  stdout.flush
   
               end
   
            end
         end
      end

      stdout.dash(int_fields=6)

   end

!  ********************************
!  Put Fragment related information
!  ********************************

   put_fragment_data ::: private
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.

      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Crystal fragment")
      stdout.text("================")
      stdout.flush
      stdout.text(". Ab initio calculations are performed on the fragment")
      stdout.text("  to obtain structure factors, charges, etc.")
      stdout.flush
      stdout.text(". The fragment need not be an asymmetric unit.")
      stdout.flush
      stdout.text(". Repeated atoms are assigned a 'repetition factor' which")
      stdout.text("  is used to scale the structure factor contribution from")
      stdout.text("  that atom. You can manually reset this.")
      stdout.flush
      stdout.text(". Only the unique atoms in the fragment have their ")
      stdout.text("  positions and ADPs refined.")
      stdout.flush
      stdout.text(". The Z factor for the crystal is defined with respect to")
      stdout.text("  the no. of electrons in the fragment")

      stdout.flush
      stdout.flush
      stdout.show("No. of fragment atoms        =",.n_fragment_atoms)
      stdout.show("No. of unique fragment atoms =",.n_unique_frag_atoms)
      stdout.show("Z factor                     =",.Z)

      if (.partition_model/=" " OR .thermal_smearing_model/=" ") then
      stdout.flush
      stdout.show("Fragment partition model     =",.partition_model)
      stdout.show("Thermal smearing model       =",.thermal_smearing_model)
      end

      .put_fragment_geometry
    ! .put_stabilizer_symops 
    ! .put_inv_trans_symop_data

   end

   put_stabilizer_symops ::: private
   ! Put out the stabilizer symop data

   ENSURE(.stabilizer_symop.created,"no stabilizer_symop")

      stdout.flush
      stdout.text("Crystal stabilizer symop information:")
      stdout.flush
      stdout.show("n_stabilizer_symops =",.n_stabilizer_symops)
      stdout.flush
      stdout.put(.stabilizer_symop)

   end

   put_fragment_geometry ::: private
   ! Put out the fragment_geometry information

   ENSURE(.fragment_info_made,"no fragment info")

      ID :: VEC{STR}*
      as4f,sy4f,un4f,rf :: VEC{INT}*
      sh4f :: MAT{REAL}*
      table :: VEC{TABLE_COLUMN}*

      stdout.flush
      stdout.flush
      stdout.text("Fragment geometry:")
      stdout.flush

      ! Data
      as4f => .asym_atom_for_frag_atom
      sy4f => .asym_symop_for_frag_atom
      sh4f => .asym_shift_for_frag_atom
      ID   => .asymmetric_unit_atom(as4f).unique_tags
      un4f => .unique_atom_for_frag_atom
      rf.create(.n_fragment_atoms)
      rf = int(.repetition_factor)

      ! Table
      table.create(11)

      table( 1).set_heading("frag");    table(1).set_values(ID)
      table( 1).set_subhead("ID")

      table( 2).set_spacing(2)
      table( 2).set_heading("Rep");     table(2).set_values(rf)
      table( 2).set_subhead("fac")
      table( 2).set_sb3head("tor")

      table( 3).set_spacing(2)
      table( 3).set_heading("Uniq");    table(3).set_values(un4f)
      table( 3).set_subhead("atom")

      table( 4).set_heading("x");       table(4).set_values(.fragment_geometry(1,:))
      table( 5).set_heading("y");       table(5).set_values(.fragment_geometry(2,:))
      table( 6).set_heading("z");       table(6).set_values(.fragment_geometry(3,:))
      table( 5).set_sb3head("/frac")

      table( 7).set_heading("From");    table(7).set_values(as4f)
      table( 7).set_subhead("asym")
      table( 7).set_sb3head("atom")

      table( 8).set_spacing(2)
      table( 8).set_heading("Using");   table(8).set_values(sy4f)
      table( 8).set_subhead("symop")

      table( 9).set_spacing(2)
      table( 9).set_real_precision(1)
      table( 9).set_heading("     ");   table(9).set_values(sh4f(1,:))
      table( 9).set_subhead("    x")
      table(10).set_spacing(2)
      table(10).set_real_precision(1)
      table(10).set_heading("Shift");   table(10).set_values(sh4f(2,:))
      table(10).set_subhead("    y")
      table(11).set_spacing(2)
      table(11).set_real_precision(1)
      table(11).set_heading("     ");   table(11).set_values(sh4f(3,:))
      table(11).set_subhead("    z")
      table(10).set_sb3head("/frac")

      table.put

      ! Clean
      table.clear_columns
      table.destroy
      rf.destroy
      ID.destroy

   end

!  **********************************
!  Put reflection related information
!  **********************************

   put_reflection_data
   ! Put out the reflection data to file "out".  Both Neutron and 
   ! X-ray will be put if present.

      if (.xray_data.created) then
        if (.xray_data.reflections.created) then  
        stdout.flush
        stdout.text("======================")
        stdout.text("X-ray diffraction data")
        stdout.text("======================")
        .xray_data.put_reflection_data(.core_reflection)
        stdout.flush
        end
      end  

      if (.pnd_data.created) then
        if (.pnd_data.reflections.created) then    
        stdout.flush
        stdout.text("==================================")
        stdout.text("Polarised neutron diffraction data")
        stdout.text("==================================")
        .pnd_data.put_reflection_data
        stdout.flush
        end
      end  

   end

   put_correction_data
   ! Output the correction data 
   ENSURE(.data_exists, "no diffraction data")
      .data.put_correction_data
   end

   put_F_statistics
   ! Output the structure factor statistics 
   ENSURE(.data_exists, "no diffraction data")

      .data.put_F_statistics

      if (.core_reflection.destroyed) return

      ! Print out the valence R factor
      stdout.show("Rval (F)                    =", .F_val_r_factor)

   end

   put_PND_sf(name)
   ! outputs the polarised neutron structure factors
      name :: STR
   ENSURE(.data_exists, "no diffraction data")
      .data.put_PND_sf(name)
   end

!  ****************
!  Crystal Explorer
!  ****************

   put_CX(label,formula,spacegroup)
   ! Output some information for the Crystal Explorer program.
       label,formula,spacegroup :: STR
       .unit_cell.put_CX(label,formula,spacegroup)
   end

!  ******************
!  Put plots and maps
!  ******************

   put_fitting_plots
   ! Output all the fitting plot information

      stdout.flush
      stdout.text("====================================")
      stdout.text("Plots based on data used for fitting")
      stdout.text("====================================")

      if (.data.created) then
         .put_chi2_vs_angle_plot(.data)
         .put_fcalc_plots(.data)
         .put_qq_plot(.data)
         .put_labelled_qq_plot(.data)
      end

      stdout.flush
      stdout.text("===================================")
      stdout.text("Plots based on free (reserved) data")
      stdout.text("===================================")

      if (.xray_r_free_data.created) then
         .put_chi2_vs_angle_plot(.data)
         .put_fcalc_plots(.data)
         .put_qq_plot(.data)
         .put_labelled_qq_plot(.data)
      end

   end

   put_chi2_vs_angle_plot(data)
   ! Output a table with the chi^2 for the structure factor data set
   ! broken into sections.  Reads from stdin the number of divisions
   ! in the plot.
      data :: DIFFRACTION_DATA*
   ENSURE(data.created, "no diffraction data")
      data.put_chi2_vs_angle_plot
   end

   put_qq_plot(data)
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
      data :: DIFFRACTION_DATA*
   ENSURE(data.created, "no diffraction data")
      data.put_qq_plot
   end

   put_labelled_qq_plot(data)
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
      data :: DIFFRACTION_DATA*
   ENSURE(data.created, "no diffraction data")
      data.put_labelled_qq_plot
   end

   put_fcalc_plots(data)
   ! Output some different plots about the calculated structure factors.
      data :: DIFFRACTION_DATA*
   ENSURE(data.created, "no diffraction data")
      data.put_fcalc_plots
   end

   make_residual_error_map(map,pts)
   ! Make the crystal residual error "map" for the supplied points "pts" from
   ! the crystal structure factors
      map :: VEC{REAL}
      pts :: MAT{REAL}
   ENSURE(.data.created, "no diffraction data")
   ENSURE(.data.reflections.created, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")
   ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
      k :: MAT{REAL}*
      F :: VEC{CPX}*
      k_dot_rn :: VEC{REAL}*
      fac :: REAL
      ci  :: CPX
      n_refl,n :: INT
      n_refl = .data.reflections.n_refl
      k.create(n_refl,3); .make_k_pts(k)
      F.create(n_refl)
      F = (.data.reflections.F_exp - .data.reflections.F_pred) &
       *.data.reflections.F_calc/abs(.data.reflections.F_calc)
      F = F/.extinction_correction
      ci = (ZERO,ONE)
      k_dot_rn.create(n_refl)
      do n = 1,pts.dim1
        k_dot_rn = matmul(k,pts(n,:))
        map(n) = REALIFY(sum(F*exp(ci*k_dot_rn)))
      end
      k_dot_rn.destroy
      fac = TWO/.unit_cell.volume
      map = fac*map
      F.destroy
      k.destroy
   end

!  ***************
!  Electric fields
!  ***************

!   make_Lorentz_fields(F,sphere_sum)
!   ! Make the Lorentz electric fields at the unit cell atom sites.
!   ! Warning: the asymmetric_unit_atom's should be generated from the
!   ! fragment where charges and dipoles have been done.
!      F :: MAT{REAL}, OUT
!      sphere_sum :: BIN, optional
!
!      symop :: MAT3{REAL}*
!      pos,L0,L1 :: MAT{REAL}* 
!      charge,dipole :: VEC{REAL}*
!      mol :: VEC{INT}*
!      fac :: REAL
!      n_atom,dim, u,a,s, fu,lu :: INT
!
!      ! No. of atoms in unit cell
!      n_atom = .n_unit_cell_atoms    
!      dim    = 3*n_atom
!
!      ! Make the Lorentz factor tensors L0, L1
!      L0.create(dim,n_atom)      ! charge L0 tensor
!      L1.create(dim,dim)         ! dipole L1 tensor
!      pos.create(3,n_atom)
!      pos = matmul(.unit_cell.direct_matrix,.unit_cell_geometry)
!      mol => .unit_cell_mol_for_atom 
!      .unit_cell.make_LFF_tensors(L0,L1,pos,mol,sphere_sum)
!      fac = FOUR*PI/.unit_cell.volume
!      L0 = fac*L0
!      L1 = fac*L1
!
!
!      ! Cartesian symops
!      symop => .xyz_seitz_matrices
!
!      ! Unit cell charges and dipoles
!      charge.create(n_atom)
!      dipole.create(dim)
!
!      ! Get unit cell charges and dipoles
!      lu = 0
!      do u = 1,n_atom
!         a = .asym_atom_for_unit_cell_atom(u)
!         s = .asym_symop_for_unit_cell_atom(u)
!         charge(u) = .asymmetric_unit_atom(a).charge 
!         fu = lu + 1
!         lu = lu + 3
!         dipole(fu:lu) = matmul(symop(:,:,s),.asymmetric_unit_atom(a).dipole)
!      end
!      
!      ! Assign electric fields
!      lu = 0
!      do a = 1,.n_fragment_atoms
!         u  = .unit_cell_atom_for_frag_atom(a)
!         lu = 3*(u-1)
!         fu = lu + 1
!         lu = lu + 3
!       ! F(:,a) = matmul(L0(fu:lu,:),charge) + matmul(L1(fu:lu,:),dipole)
!         F(:,a) = matmul(L1(fu:lu,:),dipole)
!       ! F(:,a) = matmul(L0(fu:lu,:),charge)
!      end
!
!      .put_debug(charge,"make_Lorentz_fields: charge")
!      .put_debug(dipole,"make_Lorentz_fields: dipole")
!      .put_debug(transpose(pos),"make_Lorentz_fields: pos")
!      .put_debug(mol,"make_Lorentz_fields: mol")
!      .put_debug(transpose(F),"make_Lorentz_fields: F")
!      .put_debug(L0,"make_Lorentz_fields: L0")
!      .put_debug(L1,"make_Lorentz_fields: L1")
!      .put_debug(matmul(L0,charge),"make_Lorentz_fields: L0 x charge")
!      .put_debug(matmul(L1,dipole),"make_Lorentz_fields: L1 x dipole")
!      .put_debug(.asym_symop_for_unit_cell_atom,"make_Lorentz_fields: asym_symop_for_unit_cell_atom")
!      .put_debug(.unit_cell_atom_for_frag_atom,"make_Lorentz_fields: unit_cell_atom_for_frag_atom")
!
!      ! Clean up
!      dipole.destroy; charge.destroy
!      symop.destroy
!      pos.destroy
!      L1.destroy; L0.destroy 
!
!   end

!  *******************
!  Tests for existence
!  *******************

   reflection_data_exists result (res)
   ! Return TRUE if reflection data exists
      res :: BIN
      res = associated(.data.reflections)
   end

   data_exists result (res)
   ! Return TRUE if the diffraction data information exists
      res :: BIN
      res = associated(.data)
   end

   asymmetric_unit_exists result (res)
   ! Return TRUE if the asymmetric unit geometry information exists
      res :: BIN
      res = associated(.asymmetric_unit_geometry)
   end

   unit_cell_geometry_exists result (res)
   ! Return TRUE if the unit_cell_geometry information exists
      res :: BIN
      res = associated(.unit_cell_geometry)
   end

   fragment_data_exists result (res)
   ! Return TRUE if a fragment information exists
      res :: BIN
      res = associated(.fragment_geometry)
   end

!*******************************************************************************
!                     Inherited reflection routines
!*******************************************************************************

   n_refl result (res)
   ! The number of reflections
      res :: INT
   ENSURE(.data_exists, "no diffraction data")
      res = .data.n_refl
   end

   F_exp result (res)
   ! The experimental structure factors
      res :: VEC{REAL}(.data.reflections.dim)
   ENSURE(.data_exists, "no diffraction data")
      res = .data.F_exp
   end

   F_sigma result (res)
   ! The structure factor errors
      res :: VEC{REAL}(.data.reflections.dim)
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_sigma
   end

   F_calc result (res)
   ! The calculated structure factors
      res :: VEC{CPX}(.data.reflections.dim)
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_calc
   end

   F_chi2 result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"diffraction data not created")
      res = .data.F_chi2
   end

   F_goodness_of_fit result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_goodness_of_fit
   end

   F_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_r_factor
   end

   F_weighted_r_factor result (res)
   ! Returns data
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"no diffraction data")
      res = .data.F_weighted_r_factor
   end

   F_val_r_factor result (res) 
   ! Valence r factor. The set of "core_reflections" must be supplied.
      self :: IN
      res :: REAL

   ENSURE(.xray_data.created,"no xray data")
   ENSURE(.xray_data.reflection_data_exists,"no xray reflection data")
   ENSURE(.core_reflection.created,"no core electron reflection data")

      res = .xray_data.reflections.F_val_r_factor(.core_reflection)

   end

   set_F_calc(F_calc)
   ! Set the calculated structure factors
      F_calc :: VEC{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
      .data.set_F_calc(F_calc)
   end

   make_F_predicted
   ! Make the predicted magnitude of structure factors, including possibly
   ! an overall scale factor and extinction correction
   ENSURE(.data_exists,"no diffraction data")
      .data.make_F_predicted
   end

   extinction_correction result (res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors.
      res :: VEC{REAL}(.data.reflections.dim)
      res = .data.extinction_correction
   end

   n_param result (res)
   ! Returns number of independent parameters in model 
      self :: IN
      res :: INT
   ENSURE(.data_exists,"diffraction data not created")
      res = .data.n_param
   end

   partition_model result (res)
   ! Model for partitioning fragments of the molecule
      self :: IN
      res :: STR
      if (.data_exists) then; res = .data.partition_model
      else;                   res = " "
      end  
   end

   thermal_smearing_model result (res)
   ! Thermal smearing model for ft integrals.  
      self :: IN
      res :: STR
      if (.data_exists) then; res = .data.thermal_smearing_model
      else;                   res = " "
      end
   end

   correct_dispersion result (res)
   ! True if dispersion is to be corrected
      self :: IN
      res :: BIN
   ENSURE(.data_exists,"no diffraction data")
      res = .data.correct_dispersion
   end

   wavelength result (res)
   ! Experimental wavelength
      self :: IN
      res :: REAL
   ENSURE(.data_exists,"no diffraction data")
      res = .data.wavelength
   end

   optimise_extinction result (res)
   ! True if extinction is to be optimised
      self :: IN
      res :: BIN
   ENSURE(.data_exists,"no diffraction data")
      res = .data.optimise_extinction
   end

   optimise_scale result (res)
   ! True if an overall scale factor is to be optimised, for use in calculating
   ! F_pred
      self :: IN
      res :: BIN
   ENSURE(.data_exists,"no diffraction data")
      res = .data.optimise_scale
   end

   xyz_asymmetric_unit_geometry result (res)
   ! Return the asymmetric unit geometry in cartesian coordinates.
      res :: MAT{REAL}(3,.n_asymmetric_unit_atoms)
   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit")
      res = matmul(.unit_cell.direct_matrix,.asymmetric_unit_geometry)
   end

   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.
   ENSURE(.data_exists,"no diffraction data")
      .data.simulate_new_F_exp
   end

end
