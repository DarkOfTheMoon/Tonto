!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! (c) dylan jayatilaka, daniel grimwood, university of western australia (1999)
!-------------------------------------------------------------------------------
module CRYSTAL

   use TYPES
   use SYSTEM
   use STR
   use INT
   use DBL
   use BUFFER
   use BINVEC
   use IVEC
   use IMAT
   use VEC
   use MAT
   use CVEC
   use CMAT
   use CMAT3
   use CMAT4
   use CMAT5
   use TEXTFILE
   use ATOM
   use ATOMVEC
   use ARCHIVE
   use SPACEGROUP

   implicit none

#  include "macros"
#  include "crystal.int"

!   type crystal_type
!
!   STR :: kind
!   ! Kind of diffraction experiment used.
!
!   SPACEGROUP :: spacegroup
!   ! The crystal spacegroup
!
!   VEC(3) :: unit_cell_angle
!   ! cell angles  (in radians)
!
!   VEC(3) :: unit_cell_length
!   ! cell lengths (in bohr)
!
!   DBL :: unit_cell_volume
!   ! cell volumes (bohr^3)
!
!   MAT(3,3) :: direct_cell_matrix
!   ! direct cell matrix (bohr)
!
!   MAT(3,3) :: direct_U_cell_matrix
!   ! Converts thermal tensors from crystal to cartesian systems.
!
!   MAT(3,3) :: inverse_cell_matrix
!   ! inverse direct cell matrix (bohr^{-1})
!
!   MAT(3,3) :: reciprocal_cell_matrix
!   ! reciprocal cell matrix (bohr^{-1}).
!
!   MAT(3,3) :: reciprocal_U_cell_matrix
!   ! Converts thermal tensors from cartesian to crystal systems.
!
!   INT :: n_fragment_atoms
!   ! No of atoms in the inputted cell fragment
!
!   MAT, PTR :: fragment_geometry
!   ! The geometry for molecular cell fragment under consideration
!
!   INT :: n_unit_cell_atoms
!   ! Total no. of unit cell atoms
!
!   MAT, PTR :: unit_cell_geometry
!   ! The full unit cell geometry
!
!   INT :: n_unique_unit_cell_atoms
!   ! No of unique unit cell atoms
!
!   IVEC, PTR :: unique_atom
!   ! Contains the actual unique (asymmetric) unit cell atoms.
!
!   IVEC, PTR :: unique_atom_for
!   ! If "a" is the index of an atom position in fragment_geometry, fragment_geometry(:,a),
!   ! then unique_atom_for(a) is the index of the unique (asymmetric) unit cell atom
!   ! which generates that position.
!
!   IVEC, PTR :: fragment_atom_for
!   ! If "u" is the index of an atom position in unit_cell_geometry, unit_cell_geometry(:,u),
!   ! then fragment_atom_for(a) is the index of the fragment_atom which generates that position.
!
!   INT :: n_reduced_symops
!   ! No. of symops needed to make the unit_cell_geometry from fragment_geometry
!
!   IVEC, PTR :: reduced_symop
!   ! Indices of the reduced symops in the spacegroup seitz list
!
!   INT :: n_inverted_symops
!   ! Number of symmetry operations related by inversion
!
!   IVEC, PTR :: inverted_symop
!   ! Indices of the unique symops related by inversion
!
!   IVEC, PTR :: translated_symop
!   ! Indices of the unique symops related by translation
!
!   INT :: n_unique_symops
!   ! Number of unique symmetry operations not related by inversion or translation.
!   ! This is used to save work in structure factor calculations.
!
!   IVEC, PTR :: unique_symop
!   ! Indices of the unique symops not related by inversion or translation
!
!   VEC, PTR :: repetition_factor
!   ! The partition factors for cell_geometry
!
!   DBL :: Z
!   ! The crystallographic Z factor for the moleculat cell fragment in the unitcell
!
!   INT :: n_refl
!   ! No. of reflection planes
!
!   IVEC, PTR :: h DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   IVEC, PTR :: k DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   IVEC, PTR :: l DEFAULT_NULL
!   ! Miller indices for the reflections
!
!   VEC, PTR :: F_exp DEFAULT_NULL
!   ! Experimental structure factors
!
!   VEC, PTR :: sigma DEFAULT_NULL
!   ! Experimental sigma
!
!   CVEC, PTR :: F_calc DEFAULT_NULL
!   ! Calculated structure factors
!
!   DBL :: chi2
!   ! Chi^2 agreement statistic
!
!   DBL :: gof
!   ! Goodness of fit parameter
!
!   DBL :: r_factor
!   ! R factor agreement statistic
!
!   DBL :: weighted_r_factor
!   ! Weighted R factor agreement statistic
!
!   INT :: n_param
!   ! No of fitting parameters used
!
!   DBL :: scale_factor
!   ! Scale factor used to minimise chi^2
!
!   DBL :: sf_multiplier
!   ! Arbitrary scale factor.  (abs_F_calc/F_exp)
!
!   BIN :: correct_extinction
!   ! True if extinction is to be corrected
!
!   BIN :: correct_dispersion
!   ! True if dispersion is to be corrected
!
!   DBL :: ext_factor
!   ! Secondary extinction factor
!
!   DBL :: wavelength
!   ! Experiment wavelength
!
!   STR :: thermal_smearing_model       DEFAULT("none")
!   ! Thermal smearing model for ft integrals
!
!   STR :: partition_model
!   ! Model for partitioning fragments of the molecule
!
!   end

contains

!  **************************
!  Create and destroy methods
!  **************************

   create
   ! Create an crystal object
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(CRYSTAL_SIZE)
      .nullify_ptr_part
      .n_refl = 0
      .r_factor = ZERO
      .weighted_r_factor = ZERO
      .chi2 = ZERO
      .gof = ZERO
      .n_param = 0
      .scale_factor = ONE
      .sf_multiplier = ONE
      .correct_extinction = TRUE
      .correct_dispersion = FALSE
      .ext_factor = ZERO
      .wavelength = 0.71069d0       ! Mo K alpha
      .kind = "x-ray"
      .thermal_smearing_model = ""
      .partition_model = ""
   end

   destroy
   ! Destroy an crystal object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(CRYSTAL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object
      .spacegroup.nullify_ptr_part
      nullify(.h)
      nullify(.k)
      nullify(.l)
      nullify(.F_exp)
      nullify(.sigma)
      nullify(.F_calc)
   end

   destroy_ptr_part
   ! Erase all pointer information
      .destroy_reflection_data
   end

   destroy_reflection_data
   ! Erase all reflection data
      if (.reflection_data_exists) then
         .h.destroy
         .k.destroy
         .l.destroy
         .n_refl = 0
         .r_factor = ZERO
         .weighted_r_factor = ZERO
         .chi2 = ZERO
         .gof = ZERO
         .n_param = 0
         .scale_factor = ONE
         .ext_factor = ZERO
         if (.F_calc_exists) .F_calc.destroy
         if (.F_exp_exists) then
            .F_exp.destroy
            .sigma.destroy
         end
      end
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_default [leaky]
   ! Set up a default crystal object
      BIN :: err
      .spacegroup.set_default
      .unit_cell_angle = (/90.0d0,90.0d0,90.0d0/)
      .unit_cell_angle.convert_from("degree",err)
      DIE_IF(err,"error converting angle from degrees")
      .unit_cell_length = (/10.0d0,10.0d0,10.0d0/)
      .make_cell_matrices
      .n_refl = 0
      .r_factor = ZERO
      .weighted_r_factor = ZERO
      .chi2 = ZERO
      .gof = ZERO
      .n_param = 0
      .scale_factor = ONE
      .correct_extinction = TRUE
      .correct_dispersion = TRUE
      .ext_factor = ZERO
      .wavelength = 0.71069d0
      .kind = "x-ray"
      .thermal_smearing_model = ""
      .partition_model = ""
   end

!  ********************
!  Unit cell operations
!  ********************

   make_cell_matrices
   ! Calculate the various unit cell axis matrices.
      .make_cell_volume
      .make_direct_cell_matrix
      .make_reciprocal_cell_matrix
      .make_direct_U_cell_matrix
      .make_reciprocal_U_cell_matrix
   end

   make_cell_volume
   ! Calculate the cell volume
      DBL :: a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      .unit_cell_volume = a*b*c*sqrt(ONE-ca**2-cb**2-cg**2+TWO*ca*cb*cg)
   end

   make_direct_cell_matrix
   ! Calculate the direct cell matrices, in units of BOHRS.
      DBL :: v,a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Direct cell matrix
      .direct_cell_matrix(1,1) = a
      .direct_cell_matrix(1,2) = b*cg
      .direct_cell_matrix(1,3) = c*cb
      .direct_cell_matrix(2,1) = ZERO
      .direct_cell_matrix(2,2) = v/(a*c*sb)
      .direct_cell_matrix(2,3) = ZERO
      .direct_cell_matrix(3,1) = ZERO
      .direct_cell_matrix(3,2) = b*(ca-cg*cb)/sb
      .direct_cell_matrix(3,3) = c*sb
   end

   make_reciprocal_cell_matrix
   ! Calculate the reciprocal cell matrices in units of 1/BOHRS.
      DBL :: v,a,b,c,ca,cb,cg,sb
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Reciprocal cell matrix
      .reciprocal_cell_matrix(1,1) = ONE/a
      .reciprocal_cell_matrix(1,2) = ZERO
      .reciprocal_cell_matrix(1,3) = ZERO
      .reciprocal_cell_matrix(2,1) = b*c*(ca*cb-cg)/sb/v
      .reciprocal_cell_matrix(2,2) = a*c*sb/v
      .reciprocal_cell_matrix(2,3) = a*b*(cb*cg-ca)/sb/v
      .reciprocal_cell_matrix(3,1) = -cb/a/sb
      .reciprocal_cell_matrix(3,2) = ZERO
      .reciprocal_cell_matrix(3,3) = ONE/c/sb
      .inverse_cell_matrix = transpose(.reciprocal_cell_matrix)
   end

   make_direct_U_cell_matrix
   ! Return the transformation matrix which changes the thermal tensor
   ! from the crystal axis system into the cartesian axis system.
   ! See comments for reciprocal_U_tensor_matrix below.
      DBL :: len
      INT :: i
      do i = 1,3
         len = .reciprocal_cell_matrix(:,i).norm
         .direct_U_cell_matrix(i,:) = len*.direct_cell_matrix(:,i)
      end
   end

   make_reciprocal_U_cell_matrix
   ! Return the transformation matrix which changes the thermal tensor
   ! from the cartesian axis system into the crystal axis system.
   ! The thermal tensor in the crystal axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where h are the Miller indices and a^* are the reciprocal lattice
   ! constants (in bohr^{-2}). This is as used by systems like Xtal.
   ! The thermal tensor in the cartesian axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -0.5 U_{ij} k_i k_j )
   ! where k = 2\pi B h, and B is the reciprocal_cell matrix.
      DBL :: len
      INT :: i
      do i = 1,3
         len = ONE/.reciprocal_cell_matrix(:,i).norm
         .reciprocal_U_cell_matrix(:,i) = .reciprocal_cell_matrix(:,i)*len
      end
   end

   change_geometry_from_crystal(g)
   ! Change the geometry array "g" from crystal fractional coordinates into
   ! standard cartesian coordiantes
      MAT :: g
      INT :: n,n_atom
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.direct_cell_matrix)
      end
   end

   change_geometry_to_crystal(g)
   ! Change the geometry array "g" from standard cartesian coordinates into
   ! crystal fractional coordinates
      MAT :: g
      INT :: n,n_atom
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.inverse_cell_matrix)
      end
   end

!  ************
!  Read methods
!  ************

   read(input) [leaky]
   ! Read an CRYSTAL object from file "input"
      TEXTFILE, target, optional :: input
      TEXTFILE, PTR :: in
      STR :: word
      if (present(input)) then
        in => input
      else
        in => stdin
      end
      .set_default
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("end");                     exit read_loop
            case("kind");                    .read_kind
            case("spacegroup_symbol");       .read_spacegroup_IT_symbol
            case("spacegroup_it_symbol");    .read_spacegroup_IT_symbol
            case("spacegroup_hall_symbol");  .read_spacegroup_Hall_symbol
            case("unit_cell_angles");        .read_unit_cell_angles
            case("cell_angles");             .read_unit_cell_angles
            case("unit_cell_lengths");       .read_unit_cell_lengths
            case("unit_cell_dimensions");    .read_unit_cell_lengths
            case("cell_lengths");            .read_unit_cell_lengths
            case("n_refl");                  .read_n_refl
            case("n_hkl");                   .read_n_refl
            case("no_of_reflections");       .read_n_refl
            case("hkl");                     .read_hkl(in)
            case("hkl_experiment");          .read_hkl_experiment(in)
            case("hkl_data");                .read_hkl_data(in)
            case("reflection_data");         .read_reflection_data(in)
            case("sf_multiplier");           .read_sf_multiplier
            case("correct_extinction");      .read_correct_extinction
            case("correct_dispersion");      .read_correct_dispersion
            case("thermal_smearing_model");  .read_thermal_smearing_model
            case("partition_model");         .read_partition_model
            case("sigma_is_sqrt_of_f");      .sigma_is_sqrt_of_f
            case("update_gof_parameters");   .update_gof_parameters
            case("erase_spacegroup");        .spacegroup.destroy_ptr_part
            case("destroy_spacegroup");      .spacegroup.destroy_ptr_part
            case("erase_reflection_data");   .destroy_reflection_data
            case("destroy_reflection_data"); .destroy_reflection_data
            case default;    DIE("unknown option, "// trim(word))
         end
      end do read_loop
      .spacegroup.analyse
      .make_cell_matrices
      if (.F_exp.created) .F_exp = .F_exp * .sf_multiplier
      if (.sigma.created) .sigma = .sigma * .sf_multiplier
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.kind)
   end

   read_spacegroup_IT_symbol
   ! Read the spacegroup international table symbol
      .spacegroup.read_IT_symbol(stdin)
   end

   read_spacegroup_Hall_symbol
   ! Read the spacegroup Hall symbol
      .spacegroup.read_Hall_symbol(stdin)
   end

   read_unit_cell_angles
   ! Read the unit cell angles
      stdin.read(.unit_cell_angle)
   end

   read_unit_cell_lengths
   ! Read the unit cell axis lengths
      stdin.read(.unit_cell_length)
   end

   read_n_refl
   ! Read the number of reflection data
      stdin.read(.n_refl)
   end

   read_hkl(in) [leaky]
   ! Read the hkl Miller index triples from the input
      TEXTFILE :: in
      INT :: i
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.no_reflection_data, "hkl data already exists")
      .h.create(.n_refl)
      .k.create(.n_refl)
      .l.create(.n_refl)
      do i = 1,.n_refl
         in.read(.h(i))
         in.read(.k(i))
         in.read(.l(i))
      end
      in.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
   end

   read_hkl_experiment(in) [leaky]
   ! Read the hkl Miller index triple followed by the experimental structure
   ! factor and the experimental standard deviation
      TEXTFILE :: in
      INT :: i
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.no_reflection_data, "hkl data already exists")
      .h.create(.n_refl)
      .k.create(.n_refl)
      .l.create(.n_refl)
      .F_exp.create(.n_refl); .F_exp = ZERO
      .sigma.create(.n_refl); .sigma = ZERO
      do i = 1,.n_refl
         in.read(.h(i))
         in.read(.k(i))
         in.read(.l(i))
         in.read(.F_exp(i))
         in.read(.sigma(i))
      end
      in.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
   end

   read_hkl_data(in) [leaky]
   ! Read the hkl Miller index triple followed by the experimental structure
   ! factor, then the calculated structure factor, and then experimental
   ! standard deviation
      TEXTFILE :: in
      INT :: i
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.no_reflection_data, "hkl data already exists")
      .h.create(.n_refl)
      .k.create(.n_refl)
      .l.create(.n_refl)
      .F_exp.create(.n_refl);  .F_exp  = ZERO
      .F_calc.create(.n_refl); .F_calc = ZERO
      .sigma.create(.n_refl); .sigma = ZERO
      do i = 1,.n_refl
         in.read(.h(i))
         in.read(.k(i))
         in.read(.l(i))
         in.read(.F_exp(i))
         in.read(.F_calc(i))
         in.read(.sigma(i))
      end
      in.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
   end

   read_reflection_data(in) [leaky]
   ! Read the reflection data from the input
      TEXTFILE :: in
      INT :: i
      STR :: word
      DIE_IF(.reflection_data_exists, "hkl data already exists")
      ENSURE(.n_refl>0, "no reflections to read")
      .h.create(.n_refl)
      .k.create(.n_refl)
      .l.create(.n_refl)
      in.read(.h(1))
      in.read(.k(1))
      in.read(.l(1))
      if ( in.buffer.not_exhausted) then        ! Read experimental data as well
         .F_exp.create(.n_refl); .F_exp = ZERO
         in.read(.F_exp(1))
         if (in.buffer.not_exhausted) then        ! Read experimental data as well
            .sigma.create(.n_refl); .sigma = ZERO
            in.read(.sigma(1))
            do i = 2,.n_refl
               in.read(.h(i))
               in.read(.k(i))
               in.read(.l(i))
               in.read(.F_exp(i))
               in.read(.sigma(i))
            end
         else
            do i = 2,.n_refl
               in.read(.h(i))
               in.read(.k(i))
               in.read(.l(i))
               in.read(.F_exp(i))
            end
         end
      else                                     ! Read only the reflection indices
         do i = 2,.n_refl
            in.read(.h(i))
            in.read(.k(i))
            in.read(.l(i))
         end
      end
      in.read(word)                            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
   end

   add_F_calc [leaky]
   ! Read the hkl Miller index triple followed by the calculated
   ! structure factor to add onto the existing structure factors.
      INT :: i,h,k,l
      CDBL :: Fc
      STR :: word
      ENSURE(.n_refl>0, "no reflections to read")
      ENSURE(.F_calc.created, "require F_calc already")
      do i = 1,.n_refl
         stdin.read(h)
         stdin.read(k)
         stdin.read(l)
         stdin.read(Fc)
         .F_calc(i) = .F_calc(i) + Fc
      end
      stdin.read(word)            !  Expecting the end keyword
      word.to_lower_case
      ENSURE(trim(word) == "end", 'expecting "end" keyword')
   end

   read_sf_multiplier
   ! Read the structure factor multiplier
      stdin.read(.sf_multiplier)
   end

   read_correct_extinction
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.correct_extinction)
   end

   read_correct_dispersion
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      BIN :: allowed_model
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      allowed_model = .thermal_smearing_model=="none"    OR &
                      .thermal_smearing_model==""        OR &
                      .thermal_smearing_model=="coppens" OR &
                      .thermal_smearing_model=="stewart" OR &
                      .thermal_smearing_model=="tanaka"
      ENSURE(allowed_model,"unknown thermal smearing model")
   end

   read_partition_model
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
   end

  sigma_is_sqrt_of_f [leaky]
  ! Set the experimental error to be the square root of the structure factor.
    INT :: n
    ENSURE(.F_exp_exists, "no experimental structure factors")
    if (NOT associated( .sigma)) .sigma.create( .n_refl )
    do n=1, .n_refl
      .sigma(n) = sqrt( abs(.F_exp(n)))
    end
  end

  update_gof_parameters
  ! Make the goodnes of fit parameters, "chi2", "R_factor", "gof",
  ! "scale_factor", for the scaled structure factors.
    DBL :: top1,top2,bot1,bot2
    VEC, PTR :: Fc
    DIE_IF( .no_F_exp, "no experimental structure factors")
    DIE_IF( .no_F_calc, "no calculated structure factors")
    top1 = ZERO; top2 = ZERO
    bot1 = ZERO; bot2 = ZERO
    Fc.create( .n_refl )
    Fc = .scaled_abs_F_calc
    select case (trim(.kind))
      case ("x-ray","xray")
        top1 = sum( abs(Fc - sign(.F_exp,Fc)) )
        top2 = sum( ((Fc - sign(.F_exp,Fc)) / .sigma)**2 )
        bot1 = sum( abs(.F_exp) )
        bot2 = sum( (.F_exp / .sigma)**2 )
      case ("neutron")
        top1 = sum( abs(Fc - .F_exp) )
        top2 = sum( ((Fc - .F_exp) / .sigma)**2 )
        bot1 = sum( abs(.F_exp) )
        bot2 = sum( (.F_exp / .sigma)**2 )
      case default; DIE("data kind not defined.")
    end
    .r_factor = top1/bot1
    .weighted_r_factor = sqrt(top2/bot2)
    .chi2 = top2/max(.n_refl - .n_param,1)
    .gof = sqrt(.chi2)
    Fc.destroy
  end

  get_scale_factor
    INOUT :: self
    DBL :: top,bot
    VEC, PTR :: Fc
    Fc.create(.n_refl)
    Fc = .abs_F_calc
    top = sum( abs(Fc(:) * .F_exp(:) ) / (.sigma(:)*.sigma(:)) )
    bot = sum( (Fc(:)    * Fc(:)     ) / (.sigma(:)*.sigma(:)) )
    Fc.destroy
    .scale_factor = top/bot
    .ext_factor  = ZERO
    .n_param = 1
  end

  abs_F_calc result(res)
  ! Return the magnitude of the structure factors.
    INOUT :: self
    VEC( .n_refl ) :: res
    DIE_IF( .no_F_calc, "no calculated structure factors")
    res = abs(.F_calc)
  end

  scaled_abs_F_calc result(res)
  ! Return the scaled structure factors.
    INOUT :: self
    VEC( .n_refl ) :: res
    res = .abs_F_calc * .extinction_correction
  end

  extinction_correction result(res)
  ! Return the extinction corrections to the individual structure factors.
    INOUT :: self
    VEC( .n_refl ) :: res
    VEC, PTR :: angle_part
    DIE_IF( .no_F_calc, "no calculated structure factors")
    if (.correct_extinction) then
      angle_part.create( .n_refl )
      angle_part = .extinction_angle_part
      .get_extinction_parameters
      res(:) = .scale_factor &
                    * (ONE + .ext_factor * .F_calc(:)*conjg(.F_calc(:)) &
                    * angle_part(:))**(-0.25d0)
      angle_part.destroy
    else
      .get_scale_factor
      res = .scale_factor
    end
  end

  extinction_angle_part result(res)
  ! Angular part of the extinciton correction.
    MAT(3,3) :: rcm
    VEC( .n_refl ) :: res
    INT :: n
    DBL :: kx,ky,kz,stl,twotheta, c,s
    rcm = 2*PI*.reciprocal_cell_matrix
    do n=1, .n_refl
      kx = rcm(1,1) * .h(n) + rcm(1,2) * .k(n) + rcm(1,3) * .l(n)
      ky = rcm(2,1) * .h(n) + rcm(2,2) * .k(n) + rcm(2,3) * .l(n)
      kz = rcm(3,1) * .h(n) + rcm(3,2) * .k(n) + rcm(3,3) * .l(n)
      stl = sqrt(kx*kx+ky*ky+kz*kz)/(4.0d0*PI*BOHR_PER_ANGSTROM)
      twotheta=TWO*asin( stl * .wavelength )
    ! DIE_IF(twotheta==ZERO, "For secondary extinction theta not be 0")
      c = cos(twotheta)
      s = sin(twotheta)
      res = (1+c*c)/(1+c*s)
    end
  end

  get_extinction_parameters
  ! Gets the g and x parameters of Larson's method.  Does not scale the
  ! structure factors.
  ! Larson, A. C., in <I>Crystallographic Computing</I> Ed. Ahmed, F. R.
  ! (Copenhagen, Munksgaard 1970), pp. 291-294.
    DBL :: ghigh,glow,gnew,dghigh,dgnew,dglow
    DBL :: xhigh,xlow,xnew,dxhigh,dxlow,dxnew,xprev,gprev
    VEC, PTR :: angle_bit
    VEC, PTR :: Fc
    INT :: j

    .get_scale_factor
    Fc.create(.n_refl)
    Fc = .abs_F_calc

    .n_param = 2

    if (.scale_factor < 0) then
      WARN("scale_factor < 0.")
      stdout.put(" Setting extinction to zero.",flush=2)
    else

      glow=HALF;    ghigh=TWO;     gprev=ZERO
      angle_bit.create( .n_refl )
      angle_bit= .extinction_angle_part

      outer_loop : do
        do                                    ! get g which minimises dchi2/dg
          gnew=(glow+ghigh)/TWO
          .scale_factor=gnew
          dgnew  = .dchidg(Fc,gnew, .ext_factor ,angle_bit)
          if (abs(dgnew) <= 1E-8) exit
          dglow  = .dchidg(Fc,glow, .ext_factor ,angle_bit)
          dghigh = .dchidg(Fc,ghigh, .ext_factor ,angle_bit)
          .minimise_param(dglow,dghigh,dgnew,glow,ghigh,gnew)
        end

        if ( .dchidx(Fc, .scale_factor, ZERO,angle_bit) > ZERO) then
          .get_scale_factor
          exit outer_loop
        end
        xlow=0
        do j=-15,0
          xhigh=TEN**(j-1)
          if (.dchidx(Fc, .scale_factor, TEN**(j),angle_bit) >= ZERO) then
            exit
          end
        end

        do                                    ! get x which minimises dchi2/dx
          xnew=(xlow+xhigh)/TWO
          .ext_factor=xnew
          dxnew  = .dchidx(Fc, .scale_factor,xnew,angle_bit)
          if (abs(dxnew) <= ONE) exit
          dxlow  = .dchidx(Fc, .scale_factor,xlow,angle_bit)
          dxhigh = .dchidx(Fc, .scale_factor,xhigh,angle_bit)
          .minimise_param(dxlow,dxhigh,dxnew,xlow,xhigh,xnew)
          if (xnew >= ONE) then
            .get_scale_factor
            exit outer_loop
          end
        end

        if ((abs(xprev-xnew) <= abs(xnew*(1E-6))) AND (abs(gprev-gnew) <= abs(gnew*(1E-6)))) exit
        xprev=xnew
        gprev=gnew
      end do outer_loop
      angle_bit.destroy
    end
    Fc.destroy
  end

  minimise_param(dlow,dhigh,dnew,low,high,new)
    DBL, IN :: dlow,dhigh,dnew,new
    DBL :: high,low
    if (dlow <= 0) then
      if (dhigh <= 0) then
        high=1.25d0*high
        low=high
      else if (dnew <= 0) then
        low=new
      else
        high=new
      end
    else
      low=0.75d0 * low
      high=new
    end
  end

  dchidg(Fc,gparam,xparam,angle_bit) result (res)
  ! Derivative of the chi^2 with respect to g.
  ! (c) Daniel Grimwood, UWA, April 1997
    VEC, IN :: Fc,angle_bit
    DBL, IN :: gparam, xparam
    VEC, PTR :: Fexp,sig
    DBL :: res
    DBL :: factor,totalg,a,b
    INT :: j
    Fexp => .F_exp;     sig => .sigma
    totalg = ZERO
    do j = 1, .n_refl
      factor = ONE + xparam * Fc(j) * Fc(j) * angle_bit(j)
      a      = sqrt(factor)
      b      = sqrt(a)
      totalg = totalg + Fc(j) * (Fexp(j)/b - gparam * Fc(j)/a) / (sig(j)*sig(j))
    end
    res = totalg * (-TWO) / .n_refl
  end

  dchidx(Fc,gparam,xparam,angle_bit) result (res)
  ! Derivative of the chi^2 with respect to x.
  ! (c) Daniel Grimwood, UWA, April 1997
    VEC, IN :: Fc,angle_bit
    DBL, IN :: gparam, xparam
    DBL :: res
    DBL :: Fc2,factor,totalx,a,b
    VEC, PTR :: Fexp,sig
    INT :: j
    Fexp => .F_exp;     sig => .sigma
    totalx = ZERO
    do j = 1, .n_refl
      Fc2    = Fc(j) * Fc(j)
      factor = ONE + xparam * Fc2 * angle_bit(j)
      a      = sqrt(factor)
      b      = sqrt(a)
      totalx = totalx + angle_bit(j)*Fc2*Fc(j) * (Fexp(j)/b-gparam*Fc(j)/a) / &
                  (factor*sig(j)*sig(j))
    end
    res= gparam * totalx / (TWO * .n_refl)
  end

   make_k_pts(res)
   ! Convert the hkl indices to reciprocal lattice vectors
   ! Dimension of res is [.n_refl,3]
      MAT :: res
      INT :: n
      MAT(3,3) :: rcm
      rcm = 2*PI*.reciprocal_cell_matrix
      do n = 1, .n_refl
         res(n,1) = rcm(1,1)*.h(n) + rcm(1,2)*.k(n) + rcm(1,3)*.l(n)
         res(n,2) = rcm(2,1)*.h(n) + rcm(2,2)*.k(n) + rcm(2,3)*.l(n)
         res(n,3) = rcm(3,1)*.h(n) + rcm(3,2)*.k(n) + rcm(3,3)*.l(n)
      end
   end

  unique_k_pts result(res) [pure]
    IN :: self
    INT :: res
    res = .n_unique_symops * .n_refl
  end

   make_unique_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! in the reduced crystal spacegroup
   ! (c) Dylan Jayatilaka, UWA, feb 1996
      MAT :: k
      INT :: p,u,n
      MAT(3,3) :: b,rcm
      ENSURE(.unique_symop.created,"unique_symop array does not exist")
      p = 0
      rcm = 2*PI*.reciprocal_cell_matrix
      do u = 1,.n_unique_symops
         b = matmul(rcm,.unique_symop_mat(u))
         do n = 1, .n_refl
            p = p + 1
            k(p,1) = b(1,1)*.h(n) + b(1,2)*.k(n) + b(1,3)*.l(n)
            k(p,2) = b(2,1)*.h(n) + b(2,2)*.k(n) + b(2,3)*.l(n)
            k(p,3) = b(3,1)*.h(n) + b(3,2)*.k(n) + b(3,3)*.l(n)
         end
      end
   end

!  *************************************
!  Service methods used by other modules
!  *************************************

   make_phases_for_symop(u,phase,mask)
   ! Return the sum of the "phase" shifts for each (hkl) reflection from each
   ! glide vector for all symops which are equivalent to the "u"-th
   ! unique symmetry operation, .unique_symop(u), as determined by the mask
   ! array.
      INT, IN :: u
      CVEC, OUT :: phase
      IVEC, IN :: mask
      DBL :: pi2,tx,ty,tz
      INT :: s
      ENSURE( .unique_symop.created,"Unique symop analysis not yet done")
      ENSURE( u<=.n_reduced_symops,"symop index out of range")
      ENSURE( size(phase)==.n_refl,"wrong length for phase array")
      pi2 = TWO*PI
      phase = ZERO
      do s = 1,.spacegroup.n_seitz
         if (mask(s)/=.unique_symop(u)) cycle
         tx = pi2*.spacegroup.seitz(4,1,s)
         ty = pi2*.spacegroup.seitz(4,2,s)
         tz = pi2*.spacegroup.seitz(4,3,s)
         phase(:) = phase(:) + exp(cmplx(ZERO,.h(:)*tx+.k(:)*ty+.l(:)*tz))
      end
   end

   sum_unique_sf(sf,unique_sf)
   ! Form the structure factors "sf" from the sum of the list of
   ! unique structure factors, "unique_sf".
      CVEC :: sf
      CVEC, IN :: unique_sf
      CVEC, PTR :: phase
      INT :: u,uf,ul
      ENSURE( size(sf)==.n_refl,"incorrect size for array sf")
      phase.create(.n_refl)
      sf = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)+1
         ul = .n_refl*u
         .make_phases_for_symop(u,phase,.translated_symop)
         sf(:) = sf(:) + phase(:)*unique_sf(uf:ul)
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         sf(:) = sf(:) + phase(:)*conjg(unique_sf(uf:ul))
      end
      phase.destroy
   end

   sum_unique_sf_ints(sf_ints,unique_sf_ints)
   ! Form the structure factor integrals "sf_ints" from a sum of the list
   ! of unique structure factors integrals  "unique_sf_ints".
      CMAT3 :: sf_ints
      CMAT3, IN :: unique_sf_ints
      CVEC, PTR :: phase
      INT :: u,uf,n
      ENSURE( size(sf_ints,1)==.n_refl,"incorrect size for array sf_ints")
      phase.create(.n_refl)
      sf_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*unique_sf_ints(uf+n,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*conjg(unique_sf_ints(uf+n,:,:))
         end
      end
      phase.destroy
   end

   sum_unique_sf_deriv_U(sf,unique_sf)
   ! Form the structure factor derivatives "sf" (wrt the thermal paramaters,U)
   !  from a sum of the list of unique structure factor derivatives "unique_sf".
      CMAT :: sf
      CMAT, IN :: unique_sf
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(sf,1)==.n_refl,"incorrect size for array sf")
      phase.create(.n_refl)
      sf = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         sf(n,:) = sf(n,:) + phase(n)*unique_sf(uf+n,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         sf(n,:) = sf(n,:) + phase(n)*conjg(unique_sf(uf+n,:))
         end
      end
      phase.destroy
   end

   sum_ft_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints" from a sum of the list
   ! of unique integrals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b].
      CMAT3 :: ft_ints
      CMAT3, IN :: unique_ft_ints
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*unique_ft_ints(uf+n,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*conjg(unique_ft_ints(uf+n,:,:))
         end
      end
      phase.destroy
   end

   sum_ft_spin_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints", required for the spin
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b,3,3].
      CMAT5 :: ft_ints
      CMAT3, IN :: unique_ft_ints
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT, PTR :: ints
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3))
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:)
            ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
            ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
            ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
            ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
         end
      end
      ints.destroy
      ! The factor of two for conversion to Bohr magnetons cancels the
      ! factor of half for the S operator
      do n = 1, .n_refl
          ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      VEC(3) :: B
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT3, PTR :: ints
      INT :: u,uf, n
      CDBL :: ci
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                                - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                                - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                                - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                                - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                                - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                                - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
         end
      end
      ints.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S operator
      ci = (ZERO,ONE)
      do n = 1, .n_refl
          ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      CVEC, PTR :: phase
      MAT, PTR :: q
      CMAT3, PTR :: ints
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      q.create(.n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
      end
      ints.destroy
      ! The factor of 2 to convert to Bohr magnetons cancels the factor
      ! of 1/2 for the Bohr magneton
      ! Extra minus sign introduced, but not sure why ...
      ! Reversed minus sign introduced ...
      do n = 1, .n_refl
          ft_ints(n,:,:,:) =  ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_j_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform j integrals "ft_ints", required for the PND
   ! magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      CMAT4 :: ft_ints
      CMAT4, IN :: unique_ft_ints
      CVEC, PTR :: phase
      INT :: u,uf, n
      ENSURE( size(ft_ints,1)==.n_refl,"incorrect size for array ft_ints")
      phase.create(.n_refl)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = .n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,.n_refl
         ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
         end
      end
      phase.destroy
   end

! ***********************************
! Operations on atomvecs in a crystal
! ***********************************

  generate_unique_symop_list(list)
  ! Returns a list of which seitz matrices generate unique molecules.
  ! Usefull when the molecule is on a special position.
    IN :: self
    BINVEC, OUT :: list
    MAT, PTR :: pos1,pos2
    BINVEC, PTR :: matched
    BIN :: same
    INT :: s1,s2,n,q

    ENSURE(size(list) == .spacegroup.n_seitz, "symop list not correct size")
    pos1.create(3,.n_fragment_atoms)
    pos2.create(3,.n_fragment_atoms)
    matched.create(.n_fragment_atoms)

    do s1=1,.spacegroup.n_seitz
      pos1 = .fragment_geometry
      .move_to_unit_cell(pos1)
      .transform_geometry(pos1,s1)
      .move_to_unit_cell(pos1)
      same = FALSE
      do s2=1,s1-1
        pos2 = .fragment_geometry
        .move_to_unit_cell(pos2)
        .transform_geometry(pos2,s2)
        .move_to_unit_cell(pos2)
        matched = FALSE
        do n = 1, .n_fragment_atoms
          do q = 1, .n_fragment_atoms
            same = pos2(:,n).same_as(pos1(:,q), TOL(3))
            if (same) then
              matched(q) = TRUE
              exit
            end
          end
          if (NOT same) exit   ! atom q doesn't have a match.
        end
        same = all(matched)    ! They are the same if all have a match.
        if (same) exit
      end
      list(s1) = NOT same
    end

    matched.destroy
    pos2.destroy
    pos1.destroy
  end

  create_closest_molecule_list(op_list,dist_list,position,distance_max) [leaky]
  ! Creates a list of the symmetry operations and translations of the molecules
  ! which are within max_distance of the centre of the molecule.
  ! If "position" is specified, it is used instead of the centre of the
  ! molecule.
    IMAT, PTR :: op_list
    VEC, PTR :: dist_list
    VEC, IN :: position
    DBL, optional :: distance_max
    MAT, PTR :: pos1,pos2,pos3
    BINVEC, PTR :: unique_symop_list
    VEC(3) :: centre,diff
    IVEC(3) :: offset
    INT :: n,s,h,k,l,d_h,d_k,d_l,q,maxnum
    DBL :: distance,dist,max_distance,max_cell_distance,a,b,c

    unique_symop_list.create(.spacegroup.n_seitz)
    .generate_unique_symop_list(unique_symop_list)

    max_distance = 10d0
    if (present(distance_max)) max_distance = distance_max

    a = .unit_cell_length(1)
    b = .unit_cell_length(2)
    c = .unit_cell_length(3)
    max_cell_distance = max_distance + a + b + c
    maxnum = unique_symop_list.n_true * &
                              (ceiling(max_cell_distance/min(a,b,c)))**3

    dist_list.create(maxnum)
    op_list.create(4,maxnum)

    pos1.create(3,.n_fragment_atoms)
    pos2.create(3,.n_fragment_atoms)
    pos3.create(3,.n_fragment_atoms)
    pos1 = .fragment_geometry
    .move_to_unit_cell(pos1)

    centre = position                        ! Center of the cluster
    centre.rotate_by(.inverse_cell_matrix)
    offset = floor(centre+0.001d0)           ! hkl offset of cluster
    ! We work with the 0,0,0 cell as the center of the cluster, then translate
    ! by the offset.
    centre = position - offset

    q = 0
    do s = 1, .spacegroup.n_seitz
      if (NOT unique_symop_list(s)) cycle
      pos2 = pos1
      .transform_geometry(pos2,s)

      d_h = ceiling(max_cell_distance/a)
      do h = -d_h,+d_h
        d_k = ceiling((max_cell_distance-abs(h)*a)/b)
        do k = -d_k,+d_k
          d_l = ceiling((max_cell_distance-abs(h)*a-abs(k)*b)/c)
          do l = -d_l,+d_l
            do n=1,.n_fragment_atoms
              pos3(:,n) = pos2(:,n) + (/h,k,l/)      ! Translate through lattice
            end
            .change_geometry_from_crystal(pos3)      ! Put in cartesians.
            diff = pos3(:,1) - centre
            distance = dot_product(diff,diff)
            do n=2,.n_fragment_atoms
              diff = pos3(:,n) - centre
              dist = dot_product(diff,diff)
              if (dist<distance) distance=dist
            end
            if (distance < TOL(6)) distance = ZERO
            distance = sqrt(distance)
            if (distance < max_distance) then
              q = q + 1; dist_list(q) = distance
              op_list(:,q) = (/s,h,k,l/)
            end
          end
        end
      end
    end

    do n=1,q
      op_list(2:4,n) = op_list(2:4,n) + offset       ! Translate cluster to
    end                                              ! correct cell.

    if (q==0) then ! None within required distance.
      dist_list.shrink(1);               dist_list = ZERO
      op_list.shrink(4,1);               op_list = 0
    else
      ! Truncate the lists.
      dist_list.shrink(q)
      op_list.shrink(4,q)

      ! Sort by distance.
      do k = 1, q
       do l = k, q
        if (dist_list(l) < dist_list(k)) then
          op_list.swap_columns(k,l)
          dist_list.swap_elements(k,l)
        end
       end
      end
    end

    unique_symop_list.destroy
  end

!  *****************************************
!  Reduced group, Unique operators, Z number
!  *****************************************

   make_reduced_group_data(atom) [leaky]
   ! The reduced group are those unique seitz operators which are needed to
   ! generate the complete ".unit_cell_geometry" from the atom fragment "atom".
   ! Some of these symmetry operations may only lead to geometries which are
   ! inversions of, or translations of, other operations in the reduced group.
   ! This information is also worked out here, and it can be used to save work
   ! in structure factor calculations.
      ATOMVEC :: atom
      .n_fragment_atoms = size(atom)
      .fragment_geometry.create(3,.n_fragment_atoms)
      atom.get_geometry(.fragment_geometry)
      .change_geometry_to_crystal(.fragment_geometry)
      .make_reduced_symops
      .make_inverted_symops
      .make_translated_symops
      .make_unique_symops
      .make_unique_atoms
      .make_unit_cell_geometry
      .make_repetition_factors
      .Z = .z_factor(atom)
   end

   z_factor(atom) result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined as the
   ! ratio of the number of electrons in the unit cell on the number of
   ! electrons in the fragment. Hence, we require information for each "atom" in
   ! the fragment.
      ATOMVEC :: atom
      DBL :: res,u,f
      INT :: n,a
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      ENSURE(.fragment_atom_for.created,"no reduced_symop array")
      u = ZERO
      do n = 1,.n_unit_cell_atoms
         a = .fragment_atom_for(n)
         u = u + atom(a).atomic_number
      end
      f = ZERO
      do n = 1,.n_fragment_atoms
         f = f + atom(n).atomic_number
      end
      res = u/f
   end

   make_reduced_symops [leaky]
   ! Make a list of the indices of the Seitz matrices, ".reduced_symop",
   ! which will generate distinctly different geometries from that in
   ! ".fragment_geometry". ".n_reduced_symops" is set to the number of
   ! reduced symmetry operations.
      MAT, PTR  :: gi,gu
      INT :: i,j,u, n
      BIN :: identical
      gi.create(3,.n_fragment_atoms)
      gu.create(3,.n_fragment_atoms)
      .reduced_symop.create(.spacegroup.n_seitz)
      n = 1
      .reduced_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         do j = 1,n                            ! Loop over reduced symops
            gi = .fragment_geometry
            gu = .fragment_geometry
            u = .reduced_symop(j)
            .transform_geometry(gi,i,to_unit_cell=TRUE)
            .transform_geometry(gu,u,to_unit_cell=TRUE)
            identical  = .is_same_geometry(gi,gu)
            if (identical) exit
         end
         if (NOT identical) then
            n = n + 1
            .reduced_symop(n) = i
         end
      end
      .n_reduced_symops = n
      .reduced_symop.shrink(n)
      gu.destroy
      gi.destroy
   end

   make_inverted_symops [leaky]
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment cell_geometry" which are related by inversion.
      INT :: n,i,ii,j,jj
      BIN :: inverted
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      .inverted_symop.create(.spacegroup.n_seitz)
      .inverted_symop = 0
      n = 0
      do i = 2,.n_reduced_symops
         ii = .reduced_symop(i)
         do j = 1,i-1
            jj = .reduced_symop(j)
            inverted = .spacegroup.seitz(1:3,1:3,ii).equals( &
                      -.spacegroup.seitz(1:3,1:3,jj) )
            if (inverted) then
               n = n + 1
               .inverted_symop(ii) = j
               exit
            end
         end
      end
      .n_inverted_symops = n
   end

   make_translated_symops [leaky]
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment cell_geometry" which are related by translation, (including
   ! translation by the zero vector), but not inversion
      MAT, PTR :: gi,gj
      INT :: n_atom,i,ii,j,jj
      BIN :: translated
      VEC(3) :: pos_i,pos_j
      ENSURE(.inverted_symop.created,"no inverted_symop array")
      n_atom = size(.fragment_geometry,2)
      gi.create(3,n_atom)
      gj.create(3,n_atom)
      .translated_symop.create(.spacegroup.n_seitz)
      .translated_symop = 0
      do i = 1,.n_reduced_symops
         ii = .reduced_symop(i)
         .translated_symop(ii) = i
         if (.inverted_symop(ii)>0) cycle
         do j = 1,i-1
            jj = .reduced_symop(j)
            gi = .fragment_geometry
            gj = .fragment_geometry
            .transform_geometry(gi,ii)
            .transform_geometry(gj,jj)
            pos_i = gi.sum_column_vectors/n_atom
            pos_j = gj.sum_column_vectors/n_atom
            gi = gi - spread(pos_i,2,.n_fragment_atoms)
            gj = gj - spread(pos_j,2,.n_fragment_atoms)
            translated = .is_same_geometry(gi,gj)
            if (translated) then
               .translated_symop(ii) = j
               exit
            end
         end
      end
      gj.destroy
      gi.destroy
   end

   make_unique_symops [leaky]
   ! Determine which are the unique symops (independent of inversion and
   ! translation) which are a subset of the reduced symops.
      INT :: n,i,ii
      ENSURE(.inverted_symop.created,  "no inverted_symop array")
      ENSURE(.translated_symop.created,"no translated_symop array")
      n = 0
      do i = 1,.n_reduced_symops
         ii = .reduced_symop(i)
         if (.inverted_symop(ii)>0) cycle
         if (.translated_symop(ii)<i) cycle ! Only true translations count
         n = n + 1
      end
      .n_unique_symops = n
      .unique_symop.create(n)
      n = 0
      do i = 1,.n_reduced_symops
         ii = .reduced_symop(i)
         if (.inverted_symop(ii)>0) cycle
         if (.translated_symop(ii)<i) cycle
         n = n + 1
         .unique_symop(n) = i
      end
   end

   is_same_geometry(geom_i,geom_j) result(res)
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      MAT :: geom_i,geom_j
      BIN :: res
      INT :: i,j,n_atom
      BIN :: same
      BINVEC, PTR :: skip
      n_atom = size(geom_i,2)
      ENSURE(.spacegroup.seitz.created, "Seitz matrices not initialised")
      ENSURE(size(geom_i,1)==3, "incorrect size for array geom_i")
      ENSURE(size(geom_j,1)==3, "incorrect size for array geom_j")
      ENSURE(n_atom==size(geom_j,2), "incompatible sizes for geom_i, geom_j")
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j), TOL(3))
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   make_unique_atoms [leaky]
   ! Make the asymmetric unit atoms for the ".fragment_geometry".
      MAT, PTR :: geometry
      VEC(3) :: pa
      INT :: u,a,s,col
      BIN :: found
      ENSURE(.fragment_geometry.created, "no fragment_geometry")
      .unique_atom_for.create(.n_fragment_atoms)
      .unique_atom_for    = 0
      .unique_atom_for(1) = 1
      .unique_atom.create(1)
      .unique_atom(1) = 1
      geometry.create(3,.n_fragment_atoms)
      geometry = .fragment_geometry
      .put_to_unit_cell(geometry)
      u = 1
      do a = 2,.n_fragment_atoms
         found = FALSE
         do s = 1,.spacegroup.n_seitz
            pa = geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = geometry(:,.unique_atom).has_column(pa,TOL(3),col)
            if (.unique_atom_for(a)==0 AND found) then
               .unique_atom_for(a) = col
               exit
            end
         end
         if (NOT found) then
            u = u + 1
            .unique_atom_for(a) = u
            .unique_atom.expand(u)
            .unique_atom(u) = a
         end
      end
      .n_unique_unit_cell_atoms = u
      geometry.destroy
   end

   make_unit_cell_geometry [leaky]
   ! Get the all the atom positions in the unit cell, ".unit_cell_geometry",
   ! given a (possibly) partial or overcomplete set for the cell in array
   ! ".fragment_geometry".
      VEC(3) :: pa
      INT :: n,a,s
      BIN :: found
      ENSURE(.fragment_geometry.created, "no fragment geometry")
      .fragment_atom_for.create(1)
      .fragment_atom_for(1) = 1
      .unit_cell_geometry.create(3,1)
      pa = .fragment_geometry(:,1)
      .put_to_unit_cell(pa)
      .unit_cell_geometry(:,1) = pa
      n = 1
      do a = 1,.n_fragment_atoms
         do s = 1,.spacegroup.n_seitz
            pa = .fragment_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = .unit_cell_geometry.has_column(pa,TOL(3))
            if (NOT found) then
               n = n + 1
               .fragment_atom_for.expand(n)
               .fragment_atom_for(n) = a
               .unit_cell_geometry.expand(3,n)
               .unit_cell_geometry(:,n) = pa
            end
         end
      end
      .n_unit_cell_atoms = n
   end

   make_repetition_factors [leaky]
   ! The number of times an atom with index "a" in mapped into itself under
   ! the reduced group is the ".repetition_factor(a)". It is used to correct
   ! structure factors for fragment geometries which are "oversampled" relative
   ! to the asymmetric cell geometry.
      VEC(3)  :: pa,pb
      INT :: a,b,n,u,n_same
      BIN :: same
      ENSURE(.reduced_symop.created, "Unique symops not analysed!")
      .repetition_factor.create(.n_fragment_atoms)
      do a = 1,.n_fragment_atoms
         pa = .fragment_geometry(:,a)
         .put_to_unit_cell(pa)
         n_same = 0
         do b = 1,.n_fragment_atoms
         do n = 1,.n_reduced_symops
            u = .reduced_symop(n)
            pb = .fragment_geometry(:,b)
            .transform_position(pb,u,to_unit_cell=TRUE)
            same = pa.same_as(pb,TOL(3))
            if (same) n_same = n_same + 1
         end
         end
         .repetition_factor(a) = n_same
      end
   end

   transform_geometry(g,op,ignore_glide,to_unit_cell)
   ! Transform the geometry "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translated fractional
   ! coordinates into the (1,1,1) unit cell.
      MAT :: g
      INT :: op
      BIN, optional :: ignore_glide,to_unit_cell
      INT :: n,n_atom,n_seitz
      n_atom = size(g,2)
      n_seitz = .spacegroup.n_seitz
      ENSURE( size(g,1)==3, "incorrect size for array g")
      do n = 1,n_atom
         .transform_position(g(:,n),op,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,ignore_glide,to_unit_cell)
   ! Transform the position "p" in fractional coordinates with the
   ! Seitz operator with index "op". If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translated fractional
   ! coordinates into the (1,1,1) unit cell.
      VEC(3) :: p
      INT :: op
      BIN, optional :: ignore_glide,to_unit_cell
      BIN :: ignore,to_cell
      INT :: n_seitz
      n_seitz = .spacegroup.n_seitz
      ENSURE( op>0,        "operator index out of bounds")
      ENSURE( op<=n_seitz, "operator index out of bounds")
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(p,.spacegroup.seitz(1:3,1:3,op))
      else
        p = matmul(p,.spacegroup.seitz(1:3,1:3,op)) + .spacegroup.seitz(4,1:3,op)
      end
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p)
   end

   put_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      MAT :: g
      INT :: n,n_atom
      ENSURE( size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      do n = 1,n_atom
         .put_to_unit_cell(g(:,n))
      end
   end

   put_to_unit_cell(p)
   ! Transform the position "p" in fractional coordinates into the
   ! (1,1,1) unit cell.
      VEC(3) :: p
      ENSURE( size(p)==3, "incorrect size for position vector p")
      p(:) = mod(p(:)+TWO+0.001d0,ONE) - 0.001d0
   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      MAT :: g
      INT :: n,n_atom
      IVEC(3) :: centre
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      centre = .unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - centre
      end
   end

   unit_cell_offset(g) result(res)
   ! Which hkl indices match the centre of the fragment.
   ! Usually it's 0,0,0 but not always
      MAT :: g
      INT :: n,n_atom
      IVEC(3) :: res
      VEC(3) :: centre
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      .change_geometry_from_crystal(g)
      centre =  0.001d0
      do n = 1, n_atom
        centre = centre + g(:,n)
      end
      centre.rotate_by(.inverse_cell_matrix)
      res = floor(centre / n_atom)
      .change_geometry_to_crystal(g)
   end

   reduced_symop_mat(r) result (res)
   ! Return the "r"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      MAT(3,3) :: res
      INT :: r
      ENSURE( .reduced_symop.created,"Unique symop analysis not yet done")
      ENSURE( r<=.n_reduced_symops,"symop index out of range")
      ENSURE( r>0, "symop index out of range")
      res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

   unique_symop_mat(u) result (res)
   ! Return the "u"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      MAT(3,3) :: res
      INT :: u,r
      ENSURE( .unique_symop.created,"Unique symop analysis not yet done")
      ENSURE( u<=.n_unique_symops,"symop index out of range")
      ENSURE( u>0,"symop index out of range")
      r = .unique_symop(u)
      res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

!  **************
!  Output methods
!  **************

   put(atom)
   ! Put out the crystal data to stdout
      ATOMVEC, optional :: atom
     .put(stdout,atom)
   end

   put(out,atom)
   ! Put out the crystal data to file "out"
      ATOMVEC, optional :: atom
      TEXTFILE, PTR :: out
      out.flush
      out.text("CRYSTAL information:")
      out.show("kind                        =", .kind)
      .put_unitcell_data(out)
      .spacegroup.put(out)
      if (.fragment_data_exists)   .put_fragment_data(out,atom)
      if (.reflection_data_exists) .put_reflection_data(out)
   end

   put_unitcell_data(out)
   ! Put unitcell information to file "out"
      TEXTFILE :: out
      out.flush
      out.text("Crystal unitcell information:",flush=2)
      out.show("alpha angle(rad)       = ",.unit_cell_angle(1))
      out.show("beta  angle(rad)       = ",.unit_cell_angle(2))
      out.show("gamma angle(rad)       = ",.unit_cell_angle(3))
      out.show("a cell parameter(bohr) = ",.unit_cell_length(1))
      out.show("b cell parameter(bohr) = ",.unit_cell_length(2))
      out.show("c cell parameter(bohr) = ",.unit_cell_length(3))
      out.show("cell volume(bohr^3)    = ",.unit_cell_volume)
      out.flush
      out.text("Direct cell matrix/bohr:")
      out.put(.direct_cell_matrix)
      out.flush
      out.text("Reciprocal cell matrix/(bohr^{-1}):")
      out.put(.reciprocal_cell_matrix)
      out.flush
   end

   put_fragment_data(out,atom)
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.
      TEXTFILE :: out
      ATOMVEC, optional :: atom
      out.flush
      out.text("Crystal cell-fragment data:")
      out.flush
      out.show("Fragment partition model      = ",.partition_model)
      out.show("Thermal smearing model        = ",.thermal_smearing_model)
      out.show("No. of inputted atoms         = ",.n_fragment_atoms,dbl_width=TRUE)
      out.show("No. of unit cell atoms        = ",.n_unit_cell_atoms,dbl_width=TRUE)
      out.show("No. of unique unit cell atoms = ",.n_unique_unit_cell_atoms,dbl_width=TRUE)
      out.show("Z factor                      = ",.Z)
      .put_reduced_symop_data(out)
      if (present(atom)) then
        .put_fragment_geometry(out,atom)
        .put_asymmetric_unit_geometry(out,atom)
        .put_unit_cell_geometry(out,atom)
        .put_repetition_factors(out,atom)
      end
   end

   put_reduced_symop_data(out)
   ! Put out the reduced symop data
      TEXTFILE :: out
      INT :: n,s
      BIN :: inverted,translated
      ENSURE(.fragment_geometry.created,"no fragment_geometry array")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal fragment reduced group information:")
      out.flush
      out.dash(int_fields=5)
      out.put("Reduced",int_width=TRUE)
      out.put("Seitz",int_width=TRUE)
      out.put("Inv.",int_width=TRUE)
      out.put("Trans.",int_width=TRUE)
      out.flush
      out.put("Symop",int_width=TRUE)
      out.put("Symop",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("of?",int_width=TRUE)
      out.put("Unique?",int_width=TRUE)
      out.flush
      out.dash(int_fields=5)
      do n = 1,.n_reduced_symops
         out.put(n)
         s = .reduced_symop(n)
         out.put(s)
         inverted = .inverted_symop(s)>0
         if (inverted) then;   out.put(.inverted_symop(s))
         else;                 out.tab(int_fields=1)
         end
         translated = .translated_symop(s)<n
         out.put(.translated_symop(s))
         if (inverted OR translated) then; out.put("No",int_width=TRUE)
         else;                             out.put("Yes",int_width=TRUE)
         end
         out.flush
      end
      out.dash(int_fields=5)
   end

   put_fragment_geometry(out,atom)
   ! Put out the cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      STR :: symbol
      INT :: n
      ENSURE(.fragment_geometry.created,"no fragment_geometry array")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      out.flush
      out.text("Crystal fragment cell geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Fragment",int_width=TRUE)
      out.put("Unique",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do n = 1,.n_fragment_atoms
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.unique_atom_for(n))
         out.put(.fragment_geometry(1,n))
         out.put(.fragment_geometry(2,n))
         out.put(.fragment_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_asymmetric_unit_geometry(out,atom)
   ! Put out the asymmetric unit cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,u
      STR :: symbol
      ENSURE(.fragment_geometry.created,"no fragment geometry")
      ENSURE(.unique_atom.created,"no unique_atoms array")
      out.flush
      out.text("Crystal asymmetric unit geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Unique",int_width=TRUE)
      out.put("Fragment",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do u = 1,.n_unique_unit_cell_atoms
         out.put(u)
         n = .unique_atom(u)
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.fragment_geometry(1,n))
         out.put(.fragment_geometry(2,n))
         out.put(.fragment_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_unit_cell_geometry(out,atom)
   ! Put out the full unit cell geometry information
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,f
      STR :: symbol
      out.flush
      out.text("Full unit cell geometry:")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      out.put("Cell ",int_width=TRUE)
      out.put("Fragment",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Atom",int_width=TRUE)
      out.put("x")
      out.put("y")
      out.put("z")
      out.flush
      out.dash(int_fields=2,dbl_fields=3)
      do n = 1,.n_unit_cell_atoms
         out.put(n)
         f = .fragment_atom_for(n)
         symbol = atom(f).chemical_symbol.trim // " (" // f.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         out.put(.unit_cell_geometry(1,n))
         out.put(.unit_cell_geometry(2,n))
         out.put(.unit_cell_geometry(3,n))
         out.flush
      end
      out.dash(int_fields=2,dbl_fields=3)
   end

   put_repetition_factors(out,atom)
   ! Put out the repetition factors
      TEXTFILE :: out
      ATOMVEC :: atom
      INT :: n,rf
      STR :: symbol
      out.flush
      out.text("Crystal fragment atom repetition factors:")
      out.flush
      out.dash(int_fields=2)
      out.put("Fragment",int_width=TRUE)
      out.put("Rep.",int_width=TRUE)
      out.flush
      out.put("Atom",int_width=TRUE)
      out.put("Factor",int_width=TRUE)
      out.flush
      out.dash(int_fields=2)
      do n = 1,.n_fragment_atoms
         symbol = atom(n).chemical_symbol.trim // " (" // n.to_str.trim // ")"
         out.put(symbol,int_width=TRUE)
         rf = .repetition_factor(n)
         out.put(rf)
         out.flush
      end
      out.dash(int_fields=2)
   end

   put_gof_data
   ! Output the goodness of fit data to stdout
     .put_gof_data(stdout)
   end

   put_gof_data(out)
   ! Output the goodness of fit data to file "out"
      TEXTFILE :: out
      RETURN_IF(.no_reflection_data)
      RETURN_IF(.no_F_calc OR .no_F_exp)
      .update_gof_parameters
      out.flush
      out.text("Goodness of fit parameters:",flush=2)
      out.show("R factor                    =", .r_factor)
      out.show("Weighted R factor           =", .weighted_r_factor)
      out.show("chi**2                      =", .chi2)
      out.show("Goodness of fit             =", .gof)
      out.show("Scale factor                =", .scale_factor)
      if (.correct_extinction) then
      out.show("Secondary extinction factor =", .ext_factor)
      else
      out.show("Correct extinction?         =", FALSE)
      end
      out.show("Correct dispersion?         =", .correct_dispersion)
      out.show("No of fit parameters        =", .n_param)
   end

   put_reflection_data(output)
   ! Output the reflection data to file "output"
      TEXTFILE, target, optional :: output
      TEXTFILE, PTR :: out
      VEC, PTR :: Fc
      INT :: n
      RETURN_IF(.no_reflection_data)
      if (present(output)) then
        out => output
      else
        out => stdout
      end
      out.flush
      out.text("Reflection data:",flush=2)
      out.show("No. of reflections =",.n_refl)
      if (.F_calc_exists AND .F_exp_exists) then
         .put_gof_data(out)
         out.dash(int_fields=3,dbl_fields=5)
         out.put("h", int_width=TRUE)
         out.put("k", int_width=TRUE)
         out.put("l", int_width=TRUE)
         out.put("Re(F_calc)")
         out.put("Im(F_calc)")
         out.put("scaled |F_calc|")
         out.put("F_exp")
         out.put("sigma")
         out.flush
         out.dash(int_fields=3,dbl_fields=5)
         Fc.create(.n_refl)
         Fc = .scaled_abs_F_calc
         do n = 1,.n_refl
            out.put(.h(n))
            out.put(.k(n))
            out.put(.l(n))
            out.put(.F_calc(n))
            out.put(Fc(n))
            out.put(.F_exp(n))
            out.put(.sigma(n))
            out.flush
         end
         Fc.destroy
         out.dash(int_fields=3,dbl_fields=5)
      else if (.F_calc_exists) then
         out.flush
         out.dash(int_fields=3,dbl_fields=3)
         out.put("h", int_width=TRUE)
         out.put("k", int_width=TRUE)
         out.put("l", int_width=TRUE)
         out.put("Re(F_calc)")
         out.put("Im(F_calc)")
         out.put("scaled |F_calc|")
         out.flush
         out.dash(int_fields=3,dbl_fields=3)
         Fc.create(.n_refl)
         Fc = .abs_F_calc
         do n = 1,.n_refl
            out.put(.h(n))
            out.put(.k(n))
            out.put(.l(n))
            out.put(.F_calc(n))
            out.put(Fc(n))
            out.flush
         end
         Fc.destroy
         out.dash(int_fields=3,dbl_fields=3)
      else if (.F_exp_exists) then
         out.flush
         out.dash(int_fields=3,dbl_fields=2)
         out.put("h", int_width=TRUE)
         out.put("k", int_width=TRUE)
         out.put("l", int_width=TRUE)
         out.put("F_exp")
         out.put("sigma")
         out.flush
         out.dash(int_fields=3,dbl_fields=2)
         do n = 1,.n_refl
            out.put(.h(n))
            out.put(.k(n))
            out.put(.l(n))
            out.put(.F_exp(n))
            out.put(.sigma(n))
            out.flush
         end
         out.dash(int_fields=3,dbl_fields=2)
      end
   end

  put_F_calc
  ! Output F_calc.
    INT :: i
    ENSURE(.F_calc_exists, "no calculated structure factors")
    stdout.flush
    do i=1,.n_refl
      stdout.put(.h(i))
      stdout.put(.k(i))
      stdout.put(.l(i))
      stdout.put(.F_calc(i))
      stdout.flush
    end
  end

  make_qq_plot_grid(grid)
  ! Make the grid for the q-q plot.
  ! It is a plot of the experimental quantile vs expected quantile.
  ! grid(1,:) contains d0j, grid(2,:) contains dj.
    MAT :: grid
    VEC, PTR :: d,Fc
    DBL :: temp
    INT :: n,j
    n = .n_refl
    ENSURE(size(grid,1)==2, "grid wrong size")
    ENSURE(size(grid,2)==n, "grid wrong size")
    ENSURE( .F_calc.created, "no calculated structure factors")
    ENSURE( .F_exp.created, "no experimental structure factors")
    ENSURE( .sigma.created, "no experimental errors")
    d.create(n)                      ! experimental quantile
    Fc.create(n)                     ! calculated quantile
    Fc = .scaled_abs_F_calc
    select case (trim(.kind))
      case ("x-ray","xray")
        do j=1,n                         ! dj = (Fobs - Fcalc)/sigma
          d(j)  = (sign(.F_exp(j),Fc(j)) - Fc(j)) / .sigma(j)
        end
      case ("neutron")
        do j=1,n                         ! dj = (Fobs - Fcalc)/sigma
          d(j)  = (.F_exp(j) - Fc(j)) / .sigma(j)
        end
    end
    d.sort                           ! sort array from lowest to highest.
    grid(2,:) = d
    Fc.destroy
    d.destroy

    do j=1,n                           ! expected quantile, d0j
      temp = real(2*n-2*j+1)/real(2*n) ! cumulative probability
      grid(1,n-j+1) = temp.z_from_p
    end
  end

  put_qq_plot(name)
  ! Output a qq plot to the text file.
  ! It is a plot of the experimental quantile vs expected quantile.
    STR, optional :: name
    ARCHIVE :: archive
    MAT, PTR :: grid
    grid.create(2,.n_refl)
    .make_qq_plot_grid(grid)
    archive.set(root_name=name,name="qq_plot",format="ascii")
    archive.write(grid,order="by_column")
    archive.close
    grid.destroy
  end

!  *******************
!  Tests for existence
!  *******************

   fragment_data_exists result(res)
   ! Return TRUE if a fragment information exists
      BIN :: res
      res = associated(.fragment_geometry)
   end

   no_fragment_data result(res)
   ! Return TRUE if a fragment information exists
      BIN :: res
      res = NOT associated(.fragment_geometry)
   end

   no_reflection_data result(res)
   ! Return TRUE if no reflection data exists
      BIN :: res
      res = NOT associated(.h) OR (.n_refl==0)
   end

   reflection_data_exists result(res)
   ! Return TRUE if reflection data exists
      BIN :: res
      res = associated(.h) AND (.n_refl>0)
   end

   no_F_exp result(res)
   ! Return TRUE if experimental structure factors does not exist
      BIN :: res
      res = NOT associated(.F_exp)
   end

   F_exp_exists result(res)
   ! Return TRUE if experimental structure factors exist
      BIN :: res
      res = associated(.F_exp)
   end

   no_F_calc result(res)
   ! Return TRUE if calculated structure factors does not exist
      BIN :: res
      res = NOT associated(.F_calc)
   end

   F_calc_exists result(res)
   ! Return TRUE if calculated structure factors exist
      BIN :: res
      res = associated(.F_calc)
   end

end
