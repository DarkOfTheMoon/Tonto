!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module CRYSTAL

#ifndef NOGENERIC
   use REALVEC, only: minimise_BFGS_
#else
   use REALVEC, only: REALVEC_minimise_BFGS
#endif

   implicit none

#  undef ENSURE
#  ifndef NOGENERIC
#  define ENSURE(X,Y)       call ensure_(tonto,X,Y)
#  else
#  define ENSURE(X,Y)       call SYSTEM_ensure(tonto,X,Y)
#  endif

   saved_self :: CRYSTAL*

contains

!  **************************
!  Create and destroy methods
!  **************************

   create
   ! Create an crystal object
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(CRYSTAL_SIZE)
      .nullify_ptr_part
      .set_defaults
   end

   destroy
   ! Destroy an crystal object
      self :: PTR
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEMORY(CRYSTAL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object
     .spacegroup.nullify_ptr_part
     nullify(.reflections)
     nullify(.fragment_geometry)
     nullify(.asymmetric_unit_geometry)
     nullify(.unit_cell_geometry)
     nullify(.symop_for_unit_cell_atom)
     nullify(.unique_atom)
     nullify(.unique_atom_for)
     nullify(.unique_atom_symop_for)
     nullify(.fragment_atom_for)
     nullify(.reduced_symop)
     nullify(.inverted_symop)
     nullify(.translated_symop)
     nullify(.unique_symop)
     nullify(.repetition_factor)
   end

   destroy_ptr_part
   ! Erase all pointer information
    .destroy_reflection_data
    .destroy_fragment_data
   end

   destroy_reflection_data
   ! Erase all reflection data
     if (.reflection_data_exists) then
       .scale_factor = ONE
       .exp_scale_factor = ONE
       .extinction_factor = ZERO
       .reflections.destroy
     end
   end

   destroy_fragment_data
   ! Destroy the geometry and symmetry data for the fragment and unitcell.
     .fragment_geometry.destroy
     .asymmetric_unit_geometry.destroy
     .unit_cell_geometry.destroy
     .symop_for_unit_cell_atom.destroy
     .unique_atom.destroy
     .unique_atom_for.destroy
     .unique_atom_symop_for.destroy
     .fragment_atom_for.destroy
     .reduced_symop.destroy
     .inverted_symop.destroy
     .translated_symop.destroy
     .unique_symop.destroy
     .repetition_factor.destroy
   end

!   created result(res)
!   ! Returns true if self has been created
!      self :: PTR
!      res :: BIN
!      res = associated(self)
!   end

!   destroyed result(res)
!   ! Returns true if self has *not* been created
!      self :: PTR
!      res :: BIN
!      res = NOT associated(self)
!   end

   set_defaults ::: leaky
   ! Set up a default crystal object
      .spacegroup.set_defaults
      .unit_cell_angle        = CRYSTAL_UNIT_CELL_ANGLES
      .unit_cell_angle.convert_from("degree")
      .unit_cell_length       = CRYSTAL_UNIT_CELL_LENGTHS
      .make_cell_matrices
      .destroy_reflection_data
      .synthesize_sigma_I     = CRYSTAL_SYNTHESISE_SIGMA_I
      .optimise_scale         = CRYSTAL_OPTIMISE_SCALE
      .optimise_extinction    = CRYSTAL_OPTIMISE_EXTINCTION
      .correct_dispersion     = CRYSTAL_CORRECT_DISPERSION
      .scale_factor           = CRYSTAL_SCALE_FACTOR
      .exp_scale_factor       = CRYSTAL_EXP_SCALE_FACTOR
      .extinction_factor      = CRYSTAL_EXTINCTION_FACTOR
      .wavelength             = CRYSTAL_WAVELENGTH
      .kind                   = CRYSTAL_DATA_KIND
      .thermal_smearing_model = CRYSTAL_THERMAL_SMEARING_MODEL
      .partition_model        = CRYSTAL_PARTITION_MODEL
      .reduced_group_info_made= FALSE
   end

   create_copy(crys) ::: leaky
   ! Create a copy of "crys"
     self :: PTR
     crys :: CRYSTAL, IN
     .create
     .copy(crys)
   end

   copy(crystal) ::: leaky
   ! Set self to be crystal.
     crystal :: CRYSTAL, IN
     self = crystal
     self.nullify_ptr_part
     .spacegroup.copy(crystal.spacegroup)
     if (crystal.fragment_geometry.created) &
        .fragment_geometry.create_copy(crystal.fragment_geometry)
     if (crystal.asymmetric_unit_geometry.created) &
        .asymmetric_unit_geometry.create_copy(crystal.asymmetric_unit_geometry)
     if (crystal.unit_cell_geometry.created) &
        .unit_cell_geometry.create_copy(crystal.unit_cell_geometry)
     if (crystal.symop_for_unit_cell_atom.created) &
        .symop_for_unit_cell_atom.create_copy(crystal.symop_for_unit_cell_atom)
     if (crystal.unique_atom.created) &
        .unique_atom.create_copy(crystal.unique_atom)
     if (crystal.unique_atom_for.created) &
        .unique_atom_for.create_copy(crystal.unique_atom_for)
     if (crystal.unique_atom_symop_for.created) &
        .unique_atom_symop_for.create_copy(crystal.unique_atom_symop_for)
     if (crystal.fragment_atom_for.created) &
        .fragment_atom_for.create_copy(crystal.fragment_atom_for)
     if (crystal.reduced_symop.created) &
        .reduced_symop.create_copy(crystal.reduced_symop)
     if (crystal.cluster_symop.created) &
        .cluster_symop.create_copy(crystal.cluster_symop)
     if (crystal.inverted_symop.created) &
        .inverted_symop.create_copy(crystal.inverted_symop)
     if (crystal.translated_symop.created) &
        .translated_symop.create_copy(crystal.translated_symop)
     if (crystal.unique_symop.created) &
        .unique_symop.create_copy(crystal.unique_symop)
     if (crystal.repetition_factor.created) &
        .repetition_factor.create_copy(crystal.repetition_factor)
     if (crystal.reflections.created) &
        .reflections.create_copy(crystal.reflections)
   end

!  ********************
!  Unit cell operations
!  ********************

   a_star result(res)
   ! Return the a reciprocal lattice length, in bohr.
     res :: REAL
     res = .unit_cell_length(2) * .unit_cell_length(3) * &
           sin(.unit_cell_angle(1)) / .unit_cell_volume
   end

   b_star result(res)
   ! Return the b reciprocal lattice length, in bohr.
     res :: REAL
     res = .unit_cell_length(3) * .unit_cell_length(1) * &
           sin(.unit_cell_angle(2)) / .unit_cell_volume
   end

   c_star result(res)
   ! Return the c reciprocal lattice length, in bohr.
     res :: REAL
     res = .unit_cell_length(1) * .unit_cell_length(2) * &
           sin(.unit_cell_angle(3)) / .unit_cell_volume
   end

   alpha_star result(res)
   ! Return the alpha reciprocal lattice angle, in radians.
     res,tmp,alpha,beta,gamma :: REAL
     alpha = .unit_cell_angle(1)
     beta  = .unit_cell_angle(2)
     gamma = .unit_cell_angle(3)
     tmp = (cos(beta)*cos(gamma)-cos(alpha))/(sin(beta)*sin(gamma))
     res = tmp.arccos
   end

   beta_star result(res)
   ! Return the beta reciprocal lattice angle, in radians.
     res,tmp,alpha,beta,gamma :: REAL
     alpha = .unit_cell_angle(1)
     beta  = .unit_cell_angle(2)
     gamma = .unit_cell_angle(3)
     tmp = (cos(gamma)*cos(alpha)-cos(beta))/(sin(gamma)*sin(alpha))
     res = tmp.arccos
   end

   gamma_star result(res)
   ! Return the gamma reciprocal lattice angle, in radians.
     res,tmp,alpha,beta,gamma :: REAL
     alpha = .unit_cell_angle(1)
     beta  = .unit_cell_angle(2)
     gamma = .unit_cell_angle(3)
     tmp = (cos(alpha)*cos(beta)-cos(gamma))/(sin(alpha)*sin(beta))
     res = tmp.arccos
   end

   make_cell_matrices ::: private
   ! Calculate the various unit cell axis matrices.
      .make_cell_volume
      .make_direct_cell_matrix
      .make_reciprocal_cell_matrix
      .make_direct_U_cell_matrix
      .make_reciprocal_U_cell_matrix
   end

   make_cell_volume ::: private
   ! Calculate the cell volume
      a,b,c,ca,cb,cg,sb :: REAL
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      .unit_cell_volume = a*b*c*sqrt(ONE-ca**2-cb**2-cg**2+TWO*ca*cb*cg)
   end

   make_direct_cell_matrix ::: private
   ! Calculate the direct cell matrices, in units of BOHRS.
      v,a,b,c,ca,cb,cg,sb :: REAL
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Direct cell matrix
      .direct_cell_matrix(1,1) = a
      .direct_cell_matrix(1,2) = b*cg
      .direct_cell_matrix(1,3) = c*cb
      .direct_cell_matrix(2,1) = ZERO
      .direct_cell_matrix(2,2) = v/(a*c*sb)
      .direct_cell_matrix(2,3) = ZERO
      .direct_cell_matrix(3,1) = ZERO
      .direct_cell_matrix(3,2) = b*(ca-cg*cb)/sb
      .direct_cell_matrix(3,3) = c*sb
   end

   make_reciprocal_cell_matrix ::: private
   ! Calculate the reciprocal cell matrices in units of 1/BOHRS.
      v,a,b,c,ca,cb,cg,sb :: REAL
      a = .unit_cell_length(1)
      b = .unit_cell_length(2)
      c = .unit_cell_length(3)
      ca = cos(.unit_cell_angle(1))
      cb = cos(.unit_cell_angle(2))
      cg = cos(.unit_cell_angle(3))
      sb = sin(.unit_cell_angle(2))
      v = .unit_cell_volume
      ! Reciprocal cell matrix
      .reciprocal_cell_matrix(1,1) = ONE/a
      .reciprocal_cell_matrix(1,2) = ZERO
      .reciprocal_cell_matrix(1,3) = ZERO
      .reciprocal_cell_matrix(2,1) = b*c*(ca*cb-cg)/sb/v
      .reciprocal_cell_matrix(2,2) = a*c*sb/v
      .reciprocal_cell_matrix(2,3) = a*b*(cb*cg-ca)/sb/v
      .reciprocal_cell_matrix(3,1) = -cb/a/sb
      .reciprocal_cell_matrix(3,2) = ZERO
      .reciprocal_cell_matrix(3,3) = ONE/c/sb
      .inverse_cell_matrix = transpose(.reciprocal_cell_matrix)
   end

   make_direct_U_cell_matrix ::: private
   ! Return the transformation matrix which changes the thermal tensor
   ! from the crystal axis system into the cartesian axis system.
   ! See comments for reciprocal_U_tensor_matrix below.
      len :: REAL
      i :: INT
      do i = 1,3
         len = .reciprocal_cell_matrix(:,i).norm
         .direct_U_cell_matrix(i,:) = len*.direct_cell_matrix(:,i)
      end
   end

   make_reciprocal_U_cell_matrix ::: private
   ! Return the transformation matrix which changes the thermal tensor
   ! from the cartesian axis system into the crystal axis system.
   ! The thermal tensor in the crystal axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where h are the Miller indices and a^* are the reciprocal lattice
   ! constants (in bohr^{-2}). This is as used by systems like Xtal.
   ! The thermal tensor in the cartesian axis system U_{ij} is defined
   ! by the temperature factor expansion:
   !         TF = exp ( -0.5 U_{ij} k_i k_j )
   ! where k = 2\pi B h, and B is the reciprocal_cell matrix.
      len :: REAL
      i :: INT
      do i = 1,3
         len = ONE/.reciprocal_cell_matrix(:,i).norm
         .reciprocal_U_cell_matrix(:,i) = .reciprocal_cell_matrix(:,i)*len
      end
   end

   change_geometry_from_crystal(g)
   ! Change the geometry array "g" from crystal fractional coordinates into
   ! standard cartesian coordiantes
      g :: REALMAT
      n,n_atom :: INT
      ENSURE(g.dim1==3,"incorrect dimension for g")
      n_atom = g.dim2
      do n = 1,n_atom
         g(:,n).rotate_by(.direct_cell_matrix)
      end
   end

   change_geometry_to_crystal(g)
   ! Change the geometry array "g" from standard cartesian coordinates into
   ! crystal fractional coordinates
      g :: REALMAT
      n,n_atom :: INT
      ENSURE(size(g,1)==3,"incorrect dimension for g")
      n_atom = size(g,2)
      do n = 1,n_atom
         g(:,n).rotate_by(.inverse_cell_matrix)
      end
   end

   change_position_from_crystal(p)
   ! Change the position "p" from crystal fractional coordinates into
   ! standard cartesian coordiantes
      p :: REALVEC(3)
      p.rotate_by(.direct_cell_matrix)
   end

   change_position_to_crystal(p)
   ! Change the position "p" from standard cartesian coordinates into
   ! crystal fractional coordinates
      p :: REALVEC(3)
      p.rotate_by(.inverse_cell_matrix)
   end

   transposed_xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S^T_cartesian  =  B  S^T_crystal  B^-1
      res :: REALMAT3*
      i :: INT
      ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
      res.create(3,3,.spacegroup.n_seitz)
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.reciprocal_cell_matrix, &
                      matmul(transpose(.spacegroup.seitz(1:3,1:3,i)), &
                             transpose(.direct_cell_matrix)))
      end
   end

!  ************
!  Read methods
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR(*)
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
        case ("}                          ")  ! exit read_loop
        case ("cell_angles=               "); .read_unit_cell_angles
        case ("cell_dimensions=           "); .read_unit_cell_lengths
        case ("cell_lengths=              "); .read_unit_cell_lengths
        case ("correct_dispersion=        "); .read_correct_dispersion
        case ("destroy_reflection_data    "); .destroy_reflection_data
        case ("destroy_spacegroup         "); .spacegroup.destroy_ptr_part
        case ("erase_reflection_data      "); .destroy_reflection_data
        case ("erase_spacegroup           "); .spacegroup.destroy_ptr_part
        case ("exp_scale_factor=          "); .read_exp_scale_factor
        case ("kind=                      "); .read_kind
        case ("make_f_predicted           "); .make_F_predicted
        case ("optimise_extinction=       "); .read_optimise_extinction
        case ("optimise_extinction_factor="); .read_optimise_extinction
        case ("optimize_extinction=       "); .read_optimise_extinction
        case ("optimize_extinction_factor="); .read_optimise_extinction
        case ("optimise_scale=            "); .read_optimise_scale
        case ("optimise_scale_factor=     "); .read_optimise_scale
        case ("optimize_scale=            "); .read_optimise_scale
        case ("optimize_scale_factor=     "); .read_optimise_scale
        case ("partition_model=           "); .read_partition_model
        case ("repetition_factors=        "); .read_repetition_factors
        case ("reflection_data=           "); .read_reflection_data
        case ("spacegroup_hall_symbol=    "); .read_spacegroup_Hall_symbol
        case ("spacegroup_it_symbol=      "); .read_spacegroup_IT_symbol
        case ("spacegroup_hm_symbol=      "); .read_spacegroup_HM_symbol
        case ("synthesize_sigma_i=        "); .read_synthesize_sigma_I
        case ("thermal_smearing_model=    "); .read_thermal_smearing_model
        case ("unit_cell_angles=          "); .read_unit_cell_angles
        case ("unit_cell_dimensions=      "); .read_unit_cell_lengths
        case ("unit_cell_lengths=         "); .read_unit_cell_lengths
        case ("wavelength=                "); .read_wavelength
        case ("put                        "); .put
        case ("put_stl                    "); .put_stl
        case default;                       UNKNOWN(word)
      end
     .update
   end

   read_units ::: get_from(OBJECT)
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT)
   ! Read in a junk string, useful for ignoring a field
   end

   update ::: leaky
   ! Update the crystal information
     .spacegroup.analyse
     .make_cell_matrices
     if (.reflections.created) then
       if (.reflections.have_F_exp) then
         .reflections.scale_F_exp(.exp_scale_factor)
       else
         .optimise_scale = FALSE
         .optimise_extinction = FALSE
       end
       if (.reflections.have_F_sigma) then
         .reflections.scale_F_sigma(.exp_scale_factor)
       else
         .optimise_scale = FALSE
         .optimise_extinction = FALSE
       end
       .exp_scale_factor = ONE
     end
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.kind)
      .kind.to_lower_case
      select case (.kind)
         case("x-ray")
         case("pnd  ")
         case default; UNKNOWN(.kind)
      end
   end

   read_spacegroup_IT_symbol ::: private
   ! Read the spacegroup international table symbol
      .spacegroup.read_IT_symbol
   end

   read_spacegroup_HM_symbol ::: private
   ! Read the spacegroup Hall symbol
      .spacegroup.read_HM_symbol
   end

   read_spacegroup_Hall_symbol ::: private
   ! Read the spacegroup Hall symbol
      .spacegroup.read_Hall_symbol
   end

   read_unit_cell_angles ::: private
   ! Read the unit cell angles
      stdin.read(.unit_cell_angle)
   end

   read_unit_cell_lengths ::: private
   ! Read the unit cell axis lengths
      stdin.read(.unit_cell_length)
   end

   read_reflection_data ::: leaky, private
   ! Read in data in the standard order from "stdin".
      .reflections.read_list_keywords
   end

   read_repetition_factors ::: leaky, private
   ! Read in the crystal fragment repetition factors. Useful to get structure
   ! factor contributions from a small portion of the fragment.
     .repetition_factor.destroy
     stdin.read_ptr(.repetition_factor)
   end

   read_exp_scale_factor ::: private
   ! Read the structure factor multiplier
      stdin.read(.exp_scale_factor)
   end

   read_wavelength ::: private
   ! Read the experimental wavelength
      stdin.read(.wavelength)
   end

   read_optimise_scale ::: private
   ! Read the switch whether to use and overall scale factor to minimise
   ! the chi2 statistic when calculating the structure factors.
   ! NOTE: this is not the same at the overall .scale_factor which is applied
   ! to the experimental structure factors.
      stdin.read(.optimise_scale)
   end

   read_synthesize_sigma_I ::: private
   ! Read the switch whether to artificially create sigma(I) errors when
   ! evaluating the chi2 statistics based on intensities. Refer to routine
   ! .I_sigma
      stdin.read(.synthesize_sigma_I)
   end

   read_optimise_extinction ::: private
   ! Read the switch whether to correct extinction or not, according to the
   ! Larson formula
      stdin.read(.optimise_extinction)
   end

   read_correct_dispersion ::: private
   ! Read the switch whether to correct dispersion or not, according to the
   ! atomic dispersion factors
      stdin.read(.correct_dispersion)
   end

   read_thermal_smearing_model ::: private
   ! Read the thermal smearing model to use to correct for thermal vibration
   ! in the calculated structure factors
      stdin.read(.thermal_smearing_model)
      .thermal_smearing_model.to_lower_case
      select case (.thermal_smearing_model)
         case("       ")
         case("none   ")
         case("coppens")
         case("stewart")
         case("tanaka ")
         case default;    UNKNOWN(.thermal_smearing_model)
      end
   end

   read_partition_model ::: private
   ! Read the partition model to used to correct for oversampled fragments
   ! of the unit cell when calculating the structure factors
      stdin.read(.partition_model)
      .partition_model.to_lower_case
      select case(.partition_model)
         case("        ")
         case("none    ")
         case("mulliken")
         case("gaussian")
         case default;    UNKNOWN(.partition_model)
      end
   end

   read_CIF(cif) ::: leaky
   ! Read information from a Crystallographic Information File object, "cif"
      cif :: CIF
      .set_defaults
      .read_CIF_spacegroup(cif)
      .read_CIF_cell_info(cif)
      .read_CIF_atoms(cif)
      .update
   end

   read_CIF_cell_info(cif) ::: private
   ! Read cell information from a CIF file "cif"
      cif :: CIF
      err :: REAL
      found :: BIN
      .unit_cell_angle(1) = 90 ! Reset defaults (already set in read_CIF)
      .unit_cell_angle(2) = 90
      .unit_cell_angle(3) = 90
      cif.read_item("_cell_angle_alpha",.unit_cell_angle(1),err,found)
      cif.read_item("_cell_angle_beta" ,.unit_cell_angle(2),err,found)
      cif.read_item("_cell_angle_gamma",.unit_cell_angle(3),err,found)
      cif.read_item("_cell_length_a",.unit_cell_length(1),err)
      cif.read_item("_cell_length_b",.unit_cell_length(2),err)
      cif.read_item("_cell_length_c",.unit_cell_length(3),err)
      .unit_cell_length.convert_from("angstrom")
      .unit_cell_angle.convert_from("degree")
   end

   read_CIF_spacegroup(cif) ::: leaky, private
   ! Read spacegroup information from a CIF file, "cif"
      cif :: CIF
      .spacegroup.read_CIF(cif)
   end

   read_CIF_atoms(cif) ::: leaky, private
   ! Read atom information from a CIF file, "cif"
      cif :: CIF
      ID :: STR
      fs,fx,fy,fz :: BIN
      labels :: STRVEC*
      x,y,z :: REALVEC*
      n :: INT
      ID = "_atom_site_type_symbol"
      cif.find_looped_item(trim(ID),fs)
      if (NOT fs) then
      ID = "_atom_site_label"
      cif.find_looped_item(trim(ID),fs)
      end
      cif.find_looped_item("_atom_site_fract_x",fx)
      cif.find_looped_item("_atom_site_fract_y",fy)
      cif.find_looped_item("_atom_site_fract_z",fz)
      ENSURE(fs AND fx AND fy AND fz,"incomplete atom information in CIF file")
      cif.read_looped_item(trim(ID),labels)
      cif.read_looped_item("_atom_site_fract_x",x)
      cif.read_looped_item("_atom_site_fract_y",y)
      cif.read_looped_item("_atom_site_fract_z",z)
      ! Assign the CIF info
      n = labels.dim
      .n_asymmetric_unit_atoms = n
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,n)
      .asymmetric_unit_geometry(1,:) = x
      .asymmetric_unit_geometry(2,:) = y
      .asymmetric_unit_geometry(3,:) = z
      z.destroy; y.destroy; x.destroy
      labels.destroy
   end

!  ***************
!  General methods
!  ***************

   lp_factor result(res)
   ! Return the array of the Lorentz Polarization factors for all the
   ! reflections
     res :: REALVEC(size(.reflections))
     n :: INT
     c,s,two_theta :: REAL
     ENSURE(.reflections.created,"no reflection data")
     do n=1, .reflections.n_refl
       two_theta = TWO*asin( .stl(n) * .wavelength )
       c = cos(two_theta)
       s = sin(two_theta)
       if (s.is_zero(TOL(8))) then
         res(n) = ZERO
         WARN("lp_factor for (000) reflection set to zero")
       else
         res(n) = (1+c*c)/(TWO*s)
       end
     end
   end

   I_pred result(res)
   ! Return the array of predicted Intensities. Only the Lorentz Polarization
   ! factor and the angular velocity factor for a single crystal are used.
   ! Fundamental constants appearing in front of this are not calculated
   ! NOTE: unlike I_exp, these may include extinction and dispersion effects.
     res :: REALVEC(size(.reflections))
     n :: INT
     c,s,two_theta,F2 :: REAL
     ENSURE(.reflections.created,"no reflection data")
     ENSURE(.reflections.have_F_exp, "no calculated structure factors")
     do n=1, .reflections.n_refl
       two_theta = TWO*asin( .stl(n) * .wavelength )
       c = cos(two_theta)
       s = sin(two_theta)
       F2 = .reflections(n).F_pred
       F2 = F2*F2
       if (s.is_zero(TOL(8))) then
         res(n) = F2
       else
         res(n) = (1+c*c)/(TWO*s)*F2
       end
     end
   end

   I_exp result(res)
   ! Return the array of experimental Intensities. Only the Lorentz Polarization
   ! factor and the angular velocity factor for a single crystal are used.
   ! Fundamental constants appearing in front of this are not calculated
   ! NOTE: extinction factors, dispersion, multiple scattering corrections
   ! are not included. These are the experimental intensities with these effects
   ! removed.
     res :: REALVEC(size(.reflections))
     n :: INT
     c,s,two_theta,F2 :: REAL
     ENSURE(.reflections.created,"no reflection data")
     ENSURE(.reflections.have_F_exp, "no calculated structure factors")
     do n=1, .reflections.n_refl
       two_theta = TWO*asin( .stl(n) * .wavelength )
       c = cos(two_theta)
       s = sin(two_theta)
       F2 = abs(.reflections(n).F_exp)
       F2 = F2*F2
       if (s.is_zero(TOL(8))) then
          res(n) = F2
       else
          res(n) = (1+c*c)/(TWO*s)*F2
       end
     end
   end

   I_sigma result(res)
   ! Return the array of experimental sigma's in the Intensities.
     res :: REALVEC(size(.reflections))
     rcm :: REALMAT(3,3)
     n :: INT
     c,s,two_theta,F2 :: REAL
     ENSURE(.reflections.created,"no reflection data")
   ENSURE(.reflections.have_I_pred OR .reflections.have_F_exp, "no structure factors")
     if (NOT .reflections.have_F_exp AND NOT .synthesize_sigma_I) then
       WARN("The synthesize_sigma_I flag was not set; it is now set")
       .synthesize_sigma_I = TRUE
     end
     if (.synthesize_sigma_I) then
       res = .reflections.I_pred
       res = sqrt(res/.equivalence_factors)
     else
       rcm = .reciprocal_cell_matrix
       do n=1, .reflections.n_refl
         two_theta = TWO*asin( .stl(n) * .wavelength )
         c = cos(two_theta)
         s = sin(two_theta)
         F2 = abs(.reflections(n).F_exp)
         if (s.is_zero(TOL(8))) then
           res(n) = F2
         else
           res(n) = TWO*(1+c*c)/(TWO*s)*F2
         end
       end
     end
   end

   equivalence_factors result (res)
   ! Return the equivalence factors, the number of distinct reflections
   ! which are symmetry equivalent to a particular (hkl) triple, for all
   ! the reflections.
      res :: INTVEC(size(.reflections))
      hkl,new :: INTVEC(3)
      n,s,u,n_refl :: INT
      ENSURE(.reflections.created,"no reflection data")
      n_refl = .reflections.n_refl
      do n = 1,n_refl
         hkl = .reflections.indices(n)
         u = 1
         do s = 2,.spacegroup.n_seitz
            new = matmul(hkl,.spacegroup.seitz(1:3,1:3,s))
            if (hkl(1)/=new(1) OR hkl(2)/=new(2) OR hkl(3)/=new(3)) u = u + 1
         end
         res(n) = u
      end
   end

   stl(n) result (res)
   ! Return the value of sin(theta) / lambda for reflection n
     self :: IN
     n :: INT, IN
     hkl :: INTVEC(3)
     res,kx,ky,kz :: REAL
     hkl = .reflections.indices(n)
     kx = dot_product(.reciprocal_cell_matrix(1,:),hkl(:))
     ky = dot_product(.reciprocal_cell_matrix(2,:),hkl(:))
     kz = dot_product(.reciprocal_cell_matrix(3,:),hkl(:))
     res = HALF*sqrt(kx*kx+ky*ky+kz*kz)
   end

   make_F_predicted
   ! Make the predicted magnitude of the structure factors, including possibly
   ! an overall scale factor and extinction correction.
     F_pred :: REALVEC*
     self :: INOUT
     DIE_IF(NOT .reflections.created,"no reflection data")
     .n_param = 0
     if (.optimise_extinction OR .optimise_scale) .get_optimum_parameters
     F_pred.create(.reflections.n_refl)
     if (.kind=="pnd") then
       F_pred = .reflections.F_calc * .extinction_correction
     else
       F_pred = abs(.reflections.F_calc) * .extinction_correction
     end
     .reflections.set_F_pred(F_pred)
     F_pred.destroy
   end

   get_optimum_parameters ::: private
   ! Get the scale factors, extinction parameters, etc, which minimise the chi2.
   ! (To get the corrections cooresponding to these parameters see routine
   ! .extinction_correction)
     if (.optimise_extinction) then
       .optimise_extinction_factor
     else if (.optimise_scale) then
       .optimise_scale_factor
     end
   end

   extinction_correction result(res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors.
     res :: REALVEC(size(.reflections))
     res = .extinction_correction(.scale_factor,.extinction_factor)
   end

   extinction_correction(scale_factor,extinction_factor) result(res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors. NOTE: this routine also does scaling
   ! corrections without extinction.
     scale_factor,extinction_factor :: REAL
     F_calc :: CPX
     res :: REALVEC(size(.reflections))
     angle_part :: REALVEC*
     n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(.reflections.created,"no reflection data")
     ENSURE(.reflections.have_F_calc, "no calculated structure factors")
     if (extinction_factor.is_zero(TOL(9))) then
        res(:) = scale_factor
     else
       angle_part.create(n_refl)
       angle_part = .extinction_angle_part
       do n=1, n_refl
         F_calc = .reflections(n).F_calc
         res(n) = scale_factor / sqrt(sqrt(ONE + &
             extinction_factor*F_calc*conjg(F_calc)*angle_part(n)))
       end
       angle_part.destroy
     end
   end

   extinction_angle_part result(res) ::: private
   ! Return the angular part of the extinction correction.
     res :: REALVEC(size(.reflections))
      n :: INT
     twotheta,c,s :: REAL
     do n=1, .reflections.n_refl
       twotheta=TWO*asin( .stl(n) * .wavelength )
       c = cos(twotheta)
       s = sin(twotheta)
       res(n) = (1+c*c)/(1+c*s)
     end
   end

   optimise_scale_factor
   ! Determine the structure factor scale factor to scale the calculated
   ! structure factors .F_calc by in order to minimise the chi2. (But it does
   ! not do any scaling; see .extinction_correction routine for that)
     top,bot,F_pred :: REAL
     n,n_refl :: INT
     ref :: REFLECTION*
     n_refl = .reflections.n_refl
     DIE_IF(NOT .reflections.created,"no reflection data")
     DIE_IF(NOT .reflections.have_F_calc, "no calculated structure factors")
     DIE_IF(NOT .reflections.have_F_exp, "no experimental structure factors")
     DIE_IF(NOT .reflections.have_F_sigma, "no structure factor errors")
     top = ZERO
     bot = ZERO
     do n=1,n_refl
       ref => .reflections(n)
       if (.kind=="pnd") then; F_pred = ref.F_calc
       else;                   F_pred = abs(ref.F_calc)
       end
       ENSURE(ref.F_sigma/=ZERO,"Structure factor has zero error!")
       top = top + F_pred * ref.F_exp  / (ref.F_sigma * ref.F_sigma)
       bot = bot + F_pred * F_pred / (ref.F_sigma * ref.F_sigma)
     end
     .scale_factor = top/bot
     .n_param = 1
   end

   optimise_extinction_factor
   ! Optimize the .scale_factor and .extinction_factor parameter of Larson's
   ! method.
   ! NOTE: the corrections are not applied to .F_pred; use the routine
   ! .extinction_corrections to do that.
   ! Reference: Larson, A. C., in <I>Crystallographic Computing</I>
   !            Ed. Ahmed, F. R. (Copenhagen, Munksgaard 1970), pp. 291-294.
      self :: target
      p :: REALVEC(2)
      chi2_min :: REAL
      .optimise_scale_factor
      p(1) = .scale_factor
      p(2) = ZERO          ! This is the .extinction_factor
    ! saved_self.copy(self)
      saved_self => self
#ifndef NOGENERIC
      call minimise_BFGS_(chi2,d_chi2,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))
#else
      call REALVEC_minimise_BFGS(CRYSTAL_chi2,CRYSTAL_d_chi2,p,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))
#endif
    ! saved_self.destroy_ptr_part
      .scale_factor = p(1)
      .extinction_factor = p(2)
      .n_param = 2
   end

   chi2(p) result (res) ::: selfless
   ! Make the chi2 between the calculated and experimental structure factors
   ! with extinction and scale parameters stored in vector p.
     p :: REALVEC
     res,tmp,tmp1 :: REAL
     ext :: REALVEC*
     ref :: REFLECTION*
     n,n_refl :: INT
     self :: CRYSTAL*
   ! self.copy(saved_self)
     self => saved_self
     ENSURE(.reflections.created,"no reflection data")
     ENSURE(.reflections.have_F_calc, "no calculated structure factors")
     ENSURE(.reflections.have_F_exp, "no experimental structure factors")
     ENSURE(.reflections.have_F_sigma, "no structure factor errors")
     ENSURE(size(p)==2, "wrong size, p")
     n_refl = .reflections.n_refl
     ext.create(n_refl)
     ext = .extinction_correction(p(1),p(2))
     tmp = ZERO
     do n=1,n_refl
       ref => .reflections(n)
       tmp1 = (abs(ref.F_calc) * ext(n) - ref.F_exp) / ref.F_sigma
       tmp = tmp + tmp1 * tmp1
     end
       res = tmp / max(n_refl-.n_param,1)
     ext.destroy
   ! self.destroy_ptr_part
   end

   d_chi2(p) result (res) ::: selfless
   ! Return the derivative of the chi2 with respect to the .scale_factor in
   ! p(1), and with respect to .extinction_factor in p(2). This routine is for
   ! use in the BFGS minimiser.
      p :: REALVEC
      res :: REALVEC(size(p))
      self :: CRYSTAL*
   !  self.copy(saved_self)
      self => saved_self
      ENSURE(size(p)==2, "wrong size, p")
      res(1) = .d_chi2_d_scale(p)
      res(2) = .d_chi2_d_ext(p)
   !  self.destroy_ptr_part
!      res(1) = saved_self.d_chi2_d_scale(p)
!      res(2) = saved_self.d_chi2_d_ext(p)
   end

   d_chi2_d_scale(p) result (res)
   ! Derivative of the chi^2 with respect to the scale factor
     p :: REALVEC
     res,tmp,F_pred :: REAL
     ext :: REALVEC*
     ref :: REFLECTION*
     n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(.reflections.created,"no reflection data")
     ENSURE(.reflections.have_F_calc, "no calculated structure factors")
     ENSURE(.reflections.have_F_exp, "no experimental structure factors")
     ENSURE(.reflections.have_F_sigma, "no structure factor errors")
     ENSURE(size(p)==2, "wrong size, p")
     ext.create(n_refl)
     ext = .extinction_correction(p(1),p(2))
     tmp = ZERO
     do n=1,n_refl
       ref => .reflections(n)
       F_pred = abs(ref.F_calc) * ext(n)
       tmp = tmp + F_pred*F_pred - ref.F_exp*F_pred / (ref.F_sigma*ref.F_sigma)
     end
     res = TWO*tmp/(p(1)*max(n_refl-.n_param,1))
     ext.destroy
   end

   d_chi2_d_ext(p) result (res)
   ! Derivative of the chi^2 with respect to the extinction parameter.
     p :: REALVEC, IN
     res,tmp,extn,p1 :: REAL
     angle_bit,ext :: REALVEC*
     ref :: REFLECTION*
     n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(.reflections.created,"no reflection data")
     ENSURE(.reflections.have_F_calc, "no calculated structure factors")
     ENSURE(.reflections.have_F_exp, "no experimental structure factors")
     ENSURE(.reflections.have_F_sigma, "no structure factor errors")
     ENSURE(size(p)==2, "wrong size, p")
     angle_bit.create(n_refl)
     ext.create(n_refl)
     angle_bit = .extinction_angle_part
     p1 = p(1)
     ext = .extinction_correction(ONE,p(2))
     tmp = ZERO
     do n = 1,n_refl
       ref => .reflections(n)
       extn = ext(n)
       tmp = tmp + (p1 * abs(ref.F_calc) * extn - ref.F_exp) * &
           extn*extn*extn*extn*extn* ref.F_calc*ref.F_calc*ref.F_calc * &
           angle_bit(n) / (ref.F_sigma * ref.F_sigma)
     end
     res = -p1*tmp/(TWO * max(n_refl-.n_param,1))
     ext.destroy
     angle_bit.destroy
   end

   d_chi2_dU(dF) result (res)
   ! Evaluate the derivative of the chi^2 with respect to parameters U
   ! (e.g. thermal parameters) given the derivatives "dF" of where
   ! .F_calc with respect to these parameters U. NOTE: this routine
   ! assumes that the .scale_factor and .extinction_factor are fixed.
     dF :: CPXMAT
     res :: REALVEC(size(dF,2))
     Fc_conjgFcalc :: CPXVEC*
     ref :: REFLECTION*
     ext,angle_bit :: REALVEC*
     fac,Fc,Fc1,extn :: REAL
     u,n_refl,n :: INT
     n_refl = .reflections.n_refl
     ENSURE(.reflections.created,"no reflection data")
     ENSURE(size(dF,1)==n_refl, "wrong size, dF")
     ENSURE(.reflections.have_F_calc, "no calculated structure factors")
     ENSURE(.reflections.have_F_exp, "no experimental structure factors")
     ENSURE(.reflections.have_F_sigma, "no structure factor errors")
     angle_bit.create(n_refl)
     angle_bit = .extinction_angle_part
     ext.create(n_refl)
     ext = .extinction_correction(ONE,.extinction_factor)
     Fc_conjgFcalc.create(n_refl)
     do n = 1,n_refl
       ref => .reflections(n)
       extn = ext(n)
       Fc1 = abs(ref.F_calc)
       Fc = ( (.scale_factor*extn*Fc1 - ref.F_exp) / &
          (ref.F_sigma * ref.F_sigma) ) * &
          (extn / Fc1 - HALF * extn * extn * extn * extn * extn * &
          .extinction_factor * Fc1 * angle_bit(n))
       Fc_conjgFcalc(n) = Fc * conjg(ref.F_calc)
     end
     fac = TWO*.scale_factor/max(n_refl-.n_param,1)
     do u = 1,size(dF,2)
        res(u) = fac * sum( Fc_conjgFcalc(:) * dF(:,u) )
     end
     Fc_conjgFcalc.destroy
     ext.destroy
     angle_bit.destroy
   end

   make_k_pts(res)
   ! Convert the hkl indices to reciprocal lattice vectors
   ! Dimension of res is [.n_refl,3
      res :: REALMAT
       n :: INT
      hkl :: INTVEC(3)
      rcm :: REALMAT(3,3)
      rcm = TWO*PI*.reciprocal_cell_matrix
      do n = 1, .reflections.n_refl
         hkl = .reflections.indices(n)
         res(n,1) = dot_product(rcm(1,:),hkl(:))
         res(n,2) = dot_product(rcm(2,:),hkl(:))
         res(n,3) = dot_product(rcm(3,:),hkl(:))
      end
   end

   n_unique_k_pts result(res) ::: pure
   ! The number of unique k-points for an SF calculation
     self :: IN
     res :: INT
     res = .n_unique_symops * .reflections.n_refl
   end

   make_unique_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! in the reduced crystal spacegroup
   ! (c) Dylan Jayatilaka, UWA, feb 1996
      k :: REALMAT
      p,u,n,n_refl :: INT
      b,rcm :: REALMAT(3,3)
      hkl :: INTVEC(3)
      n_refl = .reflections.n_refl
      ENSURE(.unique_symop.created,"no unique_symop array!")
      p = 0
      rcm = TWO*PI*.reciprocal_cell_matrix
      do u = 1,.n_unique_symops
         b = matmul(rcm,transpose(.unique_symop_mat(u)))
         do n = 1,n_refl
            p = p + 1
            hkl = .reflections.indices(n)
            k(p,1) = dot_product(b(1,:),hkl(:))
            k(p,2) = dot_product(b(2,:),hkl(:))
            k(p,3) = dot_product(b(3,:),hkl(:))
         end
      end
   end

!  *************************************
!  Service methods used by other modules
!  *************************************

   make_phases_for_symop(u,phase,mask) ::: private
   ! Return the sum of the "phase" shifts for each (hkl) reflection from each
   ! glide vector for all symops which are equivalent to the "u"-th
   ! unique symmetry operation, .unique_symop(u), as determined by the mask
   ! array.
     u :: INT, IN
     phase :: CPXVEC, OUT
     mask :: INTVEC, IN
     hkl :: INTVEC(3)
     pi2,tx,ty,tz :: REAL
     s,n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(.unique_symop.created,"no unique_symop array!")
     ENSURE(u<=.n_unique_symops,"symop index out of range")
     ENSURE(size(phase)==n_refl,"wrong length for phase array")
     pi2 = TWO*PI
     phase = ZERO
     do s = 1,.spacegroup.n_seitz
       if (mask(s)/=.unique_symop(u)) cycle
       tx = pi2*.spacegroup.seitz(1,4,s)
       ty = pi2*.spacegroup.seitz(2,4,s)
       tz = pi2*.spacegroup.seitz(3,4,s)
       do n=1,n_refl
         hkl = .reflections.indices(n)
         phase(n) = phase(n) + exp(cmplx(ZERO,hkl(1)*tx+hkl(2)*ty+hkl(3)*tz))
       end
     end
   end

   sum_unique_sf(sf,unique_sf)
   ! Form the structure factors "sf" from the sum of the list of
   ! unique structure factors, "unique_sf".
     sf :: CPXVEC
     unique_sf :: CPXVEC, IN
     phase :: CPXVEC*
     u,uf,ul,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE( size(sf)==n_refl,"incorrect size for array sf")
     phase.create(n_refl)
     sf = ZERO
     do u = 1,.n_unique_symops
        uf = n_refl*(u-1)+1
        ul = n_refl*u
        .make_phases_for_symop(u,phase,.translated_symop)
        sf(:) = sf(:) + phase(:)*unique_sf(uf:ul)
        if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
        .make_phases_for_symop(u,phase,.inverted_symop)
        sf(:) = sf(:) + phase(:)*conjg(unique_sf(uf:ul))
     end
     phase.destroy
   end

   sum_unique_sf_ints(sf_ints,unique_sf_ints)
   ! Form the structure factor integrals "sf_ints" from a sum of the list
   ! of unique structure factors integrals  "unique_sf_ints".
     sf_ints :: CPXMAT3
     unique_sf_ints :: CPXMAT3, IN
     phase :: CPXVEC*
     u,uf,n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(size(sf_ints,1)==n_refl,"wrong size for sf_ints!")
     phase.create(n_refl)
     sf_ints = ZERO
     do u = 1,.n_unique_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*unique_sf_ints(uf+n,:,:)
       end
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*conjg(unique_sf_ints(uf+n,:,:))
       end
     end
     phase.destroy
   end

   sum_unique_sf_deriv_U(sf,unique_sf)
   ! Form the structure factor derivatives "sf" (wrt the thermal paramaters,U)
   !  from a sum of the list of unique structure factor derivatives "unique_sf".
     sf :: CPXMAT
     unique_sf :: CPXMAT, IN
     phase :: CPXVEC*
     u,uf,n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(size(sf,1)==n_refl, "wrong size, matrix sf")
     ENSURE(size(unique_sf,2)==.n_unique_k_pts, "wrong size, matrix sf")
     phase.create(n_refl)
     sf = ZERO
     do u = 1,.n_unique_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         sf(n,:) = sf(n,:) + phase(n)*unique_sf(:,uf+n)
       end
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         sf(n,:) = sf(n,:) + phase(n)*conjg(unique_sf(:,uf+n))
       end
     end
     phase.destroy
   end

   sum_ft_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints" from a sum of the list
   ! of unique integrals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b].
     ft_ints :: CPXMAT3
     unique_ft_ints :: CPXMAT3, IN
     phase :: CPXVEC*
     u,uf,n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
     phase.create(n_refl)
     ft_ints = ZERO
     do u = 1,.n_unique_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*unique_ft_ints(uf+n,:,:)
       end
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*conjg(unique_ft_ints(uf+n,:,:))
       end
     end
     phase.destroy
   end

   make_phased_matrix_for_symop(u,phase,mask) ::: private
   ! Return the sum of the "phase" shifts times the seitz matrices for all
   ! symops which are equivalent to the "u"-th unique symmetry operation,
   ! .unique_symop(u), as determined by the "mask" array, when
   ! mask(u)==.unique_symop(u).
     u :: INT, IN
     phase :: CPXMAT3, OUT
     mask :: INTVEC, IN
     hkl :: INTVEC(3)
     t :: REALVEC(3)
     pi2 :: REAL
     s,n,n_refl :: INT
     seitz :: REALMAT(4,4)
     pi2 = TWO*PI
     phase = ZERO
     n_refl = .reflections.n_refl
   ENSURE(.unique_symop.created,"no unique_symop array!")
   ENSURE(u<=.n_unique_symops,"symop index out of range")
   ENSURE(phase.dim1==n_refl,"wrong size, dim=1, phase array")
   ENSURE(phase.dim2==3,"wrong size, dim=2, phase array")
   ENSURE(phase.dim3==3,"wrong size, dim=3, phase array")
     do s = 1,.spacegroup.n_seitz
       if (mask(s)/=.unique_symop(u)) cycle
       seitz = transpose(.spacegroup.seitz(:,:,s))
       t = (/ pi2*seitz(4,1), pi2*seitz(4,2), pi2*seitz(4,3) /)
       if (seitz(3,3)>0) then                  ! M points along +z always
         do n = 1,n_refl
           hkl = .reflections.indices(n)
           phase(n,:,:) = phase(n,:,:) + &
              seitz(:,:)*exp(cmplx(ZERO,dot_product(t,hkl)))
         end
       else                                    ! M points in -z direction
         seitz(3,:3) = -seitz(3,:3)           ! Invert
         do n = 1,n_refl
           hkl = .reflections.indices(n)
           phase(n,:,:) = phase(n,:,:) + &
              seitz(:,:)*exp(cmplx(ZERO,dot_product(t,hkl)))
         end
       end
     end
   end

   sum_PND_spin_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints", required for the spin
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b,3].
     ft_ints :: CPXMAT4
     unique_ft_ints :: CPXMAT3, IN
     phase :: CPXMAT3*
     q :: REALMAT*
     u,uf,n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
     q.create(n_refl,3)
     phase.create(n_refl,3,3)
     .make_k_pts(q)
     ft_ints = ZERO
     do u = 1,.n_unique_symops
        uf = n_refl*(u-1)
        .make_phased_matrix_for_symop(u,phase,.translated_symop)
        do n = 1,n_refl
           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
              unique_ft_ints(uf+n,:,:)
           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
              unique_ft_ints(uf+n,:,:)
           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
              unique_ft_ints(uf+n,:,:)
        end
        if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
        .make_phased_matrix_for_symop(u,phase,.inverted_symop)
        do n = 1,n_refl
           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
              conjg(unique_ft_ints(uf+n,:,:))
           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
              conjg(unique_ft_ints(uf+n,:,:))
           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
              conjg(unique_ft_ints(uf+n,:,:))
        end
     end
     phase.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S=sigma/2 operator, and g_e x mu_B = 1.
     do n = 1,n_refl
       ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
     end
     q.destroy
   end

   sum_PND_nabla_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform nabla_a_3 integrals "ft_ints", required for the
   ! PND magnetic structure factors, from a sum of "unique_ft_ints".
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
     ft_ints :: CPXMAT3
     unique_ft_ints :: CPXMAT4, IN
     phase :: CPXMAT3*
     q :: REALMAT*
     u,uf,n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
     q.create(n_refl,3)
     phase.create(n_refl,3,3)
     .make_k_pts(q)
     ft_ints = ZERO
     do u = 1,.n_unique_symops
       uf = n_refl*(u-1)
       .make_phased_matrix_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + &
          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*unique_ft_ints(uf+n,:,:,1) + &
          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*unique_ft_ints(uf+n,:,:,2) + &
          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*unique_ft_ints(uf+n,:,:,3)
       end
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
       .make_phased_matrix_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + &
          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*conjg(unique_ft_ints(uf+n,:,:,1)) + &
          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*conjg(unique_ft_ints(uf+n,:,:,2)) + &
          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*conjg(unique_ft_ints(uf+n,:,:,3))
       end
     end
     phase.destroy
     ! The factor of 2 to convert to Bohr magnetons cancels the factor
     ! of 1/2 for the Bohr magneton.
     do n = 1,n_refl
       ft_ints(n,:,:) = ft_ints(n,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
     end
     q.destroy
   end

   sum_ft_spin_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints", required for the spin
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b,3,3].
     ft_ints :: CPXMAT5
     unique_ft_ints :: CPXMAT3, IN
     phase :: CPXVEC*
     q :: REALMAT*
     ints :: CPXMAT*
     u,uf,n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
     phase.create(n_refl)
     q.create(n_refl,3)
     ints.create(size(ft_ints,2),size(ft_ints,3))
     .make_k_pts(q)
     ft_ints = ZERO
     do u = 1,.n_unique_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ints = phase(n)*unique_ft_ints(uf+n,:,:)
         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
       end
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
       end
     end
     ints.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S operator
     do n = 1,n_refl
        ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
     end
     q.destroy
     phase.destroy
   end

   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
     ft_ints :: CPXMAT4
     unique_ft_ints :: CPXMAT4, IN
     B :: REALVEC(3)
     phase :: CPXVEC*
     q :: REALMAT*
     ints :: CPXMAT3*
     u,uf,n,n_refl :: INT
     ci :: CPX
     n_refl = .reflections.n_refl
     ENSURE( size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
     phase.create(n_refl)
     q.create(n_refl,3)
     ints.create(size(ft_ints,2),size(ft_ints,3),3)
     .make_k_pts(q)
     ft_ints = ZERO
     do u = 1,.n_unique_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
       end
       if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
       end
     end
     ints.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S operator
     ci = (ZERO,ONE)
     do n = 1,n_refl
       ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
     end
     q.destroy
     phase.destroy
   end

   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      ft_ints :: CPXMAT4
      unique_ft_ints :: CPXMAT4, IN
      phase :: CPXVEC*
      q :: REALMAT*
      ints :: CPXMAT3*
      u,uf,n,n_refl :: INT
      n_refl = .reflections.n_refl
      ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
      phase.create(n_refl)
      q.create(n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_symops
         uf = n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
         if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
      end
      ints.destroy
      ! The factor of 2 to convert to Bohr magnetons cancels the factor
      ! of 1/2 for the Bohr magneton
      ! Extra minus sign introduced, but not sure why ...
      ! Reversed minus sign introduced ...
      do n = 1,n_refl
          ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_j_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform j integrals "ft_ints", required for the PND
   ! magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
     ft_ints :: CPXMAT4
     unique_ft_ints :: CPXMAT4, IN
     phase :: CPXVEC*
     u,uf, n,n_refl :: INT
     n_refl = .reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
     phase.create(n_refl)
     ft_ints = ZERO
     do u = 1,.n_unique_symops
        uf = n_refl*(u-1)
        .make_phases_for_symop(u,phase,.translated_symop)
        do n = 1,n_refl
          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
        end
        if ( all(.inverted_symop/=.unique_symop(u)) ) cycle ! for inversions...
        .make_phases_for_symop(u,phase,.inverted_symop)
        do n = 1,n_refl
          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
        end
     end
     phase.destroy
   end


!  *****************************************
!  Reduced group, Unique operators, Z number
!  *****************************************

   make_reduced_group_data(atom) ::: leaky
   ! The reduced group are those unique seitz operators which are needed to
   ! generate the complete ".unit_cell_geometry" from the atom fragment "atom".
   ! Some of these symmetry operations may only lead to geometries which are
   ! inversions of, or translations of, other operations in the reduced group.
   ! This information is also worked out here, and it can be used to save work
   ! in structure factor calculations.
      atom :: ATOMVEC
      if (.reduced_group_info_made) .destroy_fragment_data
      .n_fragment_atoms = size(atom)
      .fragment_geometry.create(3,.n_fragment_atoms)
      atom.get_geometry(.fragment_geometry)
      .change_geometry_to_crystal(.fragment_geometry)
      .make_reduced_symops
      .make_cluster_symops
      .make_inverted_symops
      .make_translated_symops
      .make_unique_symops
      .make_unique_atoms
      .make_unit_cell_geometry
      .make_repetition_factors
      .Z = .z_factor(atom)
      .reduced_group_info_made = TRUE
   end

   z_factor(atom) result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined as the
   ! ratio of the number of electrons in the unit cell on the number of
   ! electrons in the fragment. Hence, we require information for each "atom" in
   ! the fragment.
      atom :: ATOMVEC
      res,u,f :: REAL
      n,a :: INT
      ENSURE(.reduced_symop.created,"no reduced_symop array")
      ENSURE(.fragment_atom_for.created,"no reduced_symop array")
      u = ZERO
      do n = 1,.n_unit_cell_atoms
         a = .fragment_atom_for(n)
         u = u + atom(a).atomic_number
      end
      f = ZERO
      do n = 1,.n_fragment_atoms
         f = f + atom(n).atomic_number
      end
      res = u/f
   end

   make_reduced_symops ::: leaky, private
   ! Make a list of the indices of the Seitz matrices, ".reduced_symop", which
   ! will generate different geometries from that in ".fragment_geometry" when
   ! both the original and transformed geometries are converted to unit cell
   ! coordinates.  ".n_reduced_symops" is set to the number of these reduced
   ! symmetry operations.
      gi,gu :: REALMAT*
      i,j,u, n :: INT
      identical :: BIN
      gi.create(3,.n_fragment_atoms)
      gu.create(3,.n_fragment_atoms)
      .reduced_symop.create(.spacegroup.n_seitz)
      n = 1
      .reduced_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         gi = .fragment_geometry
         .transform_geometry(gi,i,to_unit_cell=TRUE)
         do j = 1,n                            ! Loop over reduced symops
            gu = .fragment_geometry
            u = .reduced_symop(j)
            .transform_geometry(gu,u,to_unit_cell=TRUE)
            identical  = .is_same_geometry(gi,gu)
            if (identical) exit
         end
         if (NOT identical) then
            n = n + 1
            .reduced_symop(n) = i
         end
      end
      .n_reduced_symops = n
      .reduced_symop.shrink(n)
      gu.destroy
      gi.destroy
   end

   make_cluster_symops ::: leaky, private
   ! Make a list of the indices of the Seitz matrices, ".cluster_symop", which
   ! will generate different geometries from that in ".fragment_geometry".
   ! This routine is the same as make_reduced_symops except that the geometries
   ! are *not* converted to unit cell coordinates.  ".n_cluster_symops" is set
   ! to the number of these symmetry operations.  These operators are useful for
   ! generating clusters of this fragment. NOTE: the unit operator, element 1,
   ! is part of the set of cluster_symops.
      gi,gu :: REALMAT*
      i,j,u, n :: INT
      identical :: BIN
      gi.create(3,.n_fragment_atoms)
      gu.create(3,.n_fragment_atoms)
      .cluster_symop.create(.spacegroup.n_seitz)
      n = 1
      .cluster_symop(1) = 1
      do i = 2,.spacegroup.n_seitz
         gi = .fragment_geometry
         .transform_geometry(gi,i)
         do j = 1,n                       ! Loop over cluster symops
            gu = .fragment_geometry
            u = .cluster_symop(j)
            .transform_geometry(gu,u)
            identical  = .is_same_geometry(gi,gu)
            if (identical) exit
         end
         if (NOT identical) then
            n = n + 1
            .cluster_symop(n) = i
         end
      end
      .n_cluster_symops = n
      .cluster_symop.shrink(n)
      gu.destroy
      gi.destroy
   end

   make_inverted_symops ::: leaky, private
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment cell_geometry" which are related by inversion.
      n,i,j :: INT
      inverted :: BIN
   ENSURE(.reduced_symop.created,"no reduced_symop array")
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
      .inverted_symop.create(.spacegroup.n_seitz)
      .inverted_symop = 0
      n = 0
      do i = 2,.spacegroup.n_seitz
         do j = 1,i-1
            inverted = .spacegroup.seitz(1:3,1:3,i).equals( &
                      -.spacegroup.seitz(1:3,1:3,j))
            if (inverted) then
               n = n + 1
               .inverted_symop(i) = j
               exit
            end
         end
      end
      .n_inverted_symops = n
   end

   make_translated_symops ::: leaky, private
   ! Determine which of the reduced symops can generate geometries from
   ! ".fragment_cell_geometry" which are related by translation, (including
   ! translation by the zero vector), but not inversion
      i,j :: INT
      translated :: BIN
   ENSURE(.inverted_symop.created,"no inverted_symop array")
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
      .translated_symop.create(.spacegroup.n_seitz)
      .translated_symop = 0
      do i = 1,.spacegroup.n_seitz
         .translated_symop(i) = i
         if (.inverted_symop(i)>0) cycle
         do j = 1,i-1
            translated = .spacegroup.seitz(1:3,1:3,i).equals( &
                         .spacegroup.seitz(1:3,1:3,j) )
            if (translated) then
               .translated_symop(i) = j
               exit
            end
         end
      end
   end

   make_unique_symops ::: leaky, private
   ! Determine which are the unique symops, i.e. those which generate fragment
   ! geometries which are different than a translation or inversion. This list
   ! should be a superset of the reduced symops.
      n,i :: INT
      ENSURE(.inverted_symop.created,  "no inverted_symop array")
      ENSURE(.translated_symop.created,"no translated_symop array")
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle ! Only true translations count
         n = n + 1
      end
      .n_unique_symops = n
      .unique_symop.create(n)
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle
         n = n + 1
         .unique_symop(n) = i
      end
   end

   is_same_geometry(geom_i,geom_j) result(res) ::: private
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      geom_i,geom_j :: REALMAT
      res :: BIN
      i,j,n_atom :: INT
      same :: BIN
      skip :: BINVEC*
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
   ENSURE(geom_i.dim1==3,"incorrect size for array geom_i")
   ENSURE(geom_j.dim1==3,"incorrect size for array geom_j")
   ENSURE(geom_i.dim2==geom_j.dim2,"incompatible sizes for geom_i, geom_j")
      n_atom = geom_i.dim2
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j), TOL(3))
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   make_unique_atoms ::: leaky, private
   ! Make the symmetry unique atoms in the ".fragment_geometry".
      geometry :: REALMAT*
      pa :: REALVEC(3)
      u,a,s,col :: INT
      found :: BIN
      ENSURE(.fragment_geometry.created, "no fragment_geometry")
      .unique_atom_for.create(.n_fragment_atoms)
      .unique_atom_for    = 0
      .unique_atom_for(1) = 1
      .unique_atom.create(1)
      .unique_atom(1) = 1
      .unique_atom_symop_for.create(.n_fragment_atoms)
      .unique_atom_symop_for = 1
      geometry.create(3,.n_fragment_atoms)
      geometry = .fragment_geometry
      .put_to_unit_cell(geometry)
      u = 1
      do a = 2,.n_fragment_atoms
         found = FALSE
         do s = 1,.spacegroup.n_seitz
            pa = geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = geometry(:,.unique_atom).has_column(pa,TOL(3),col)
            if (.unique_atom_for(a)==0 AND found) then
               .unique_atom_for(a) = col
               .unique_atom_symop_for(a) = s
               exit
            end
         end
         if (NOT found) then
            u = u + 1
            .unique_atom_for(a) = u
            .unique_atom.expand(u)
            .unique_atom(u) = a
         end
      end
      .n_unique_unit_cell_atoms = u
      geometry.destroy
   end

   make_unit_cell_geometry ::: leaky, private
   ! Get the all the atom positions in the unit cell, ".unit_cell_geometry",
   ! given a (possibly) partial or overcomplete set for the cell in array
   ! ".fragment_geometry".
      pa :: REALVEC(3)
      n,a,s :: INT
      found :: BIN
      ENSURE(.fragment_geometry.created,"no fragment_geometry")
      .fragment_atom_for.create(1)
      .fragment_atom_for(1) = 1
      .unit_cell_geometry.create(3,1)
      pa = .fragment_geometry(:,1)
      .put_to_unit_cell(pa)
      .unit_cell_geometry(:,1) = pa
      .symop_for_unit_cell_atom.create(1)
      n = 1
      do a = 1,.n_fragment_atoms
         do s = 1,.spacegroup.n_seitz
            pa = .fragment_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE)
            found = .unit_cell_geometry.has_column(pa,TOL(3))
            if (NOT found) then
               n = n + 1
               .fragment_atom_for.expand(n)
               .fragment_atom_for(n) = a
               .unit_cell_geometry.expand(3,n)
               .unit_cell_geometry(:,n) = pa
               .symop_for_unit_cell_atom.expand(n)
               .symop_for_unit_cell_atom(n) = s
            end
         end
      end
      .n_unit_cell_atoms = n
   end

   make_repetition_factors ::: leaky, private
   ! The number of times an atom with index "a" in mapped into itself under
   ! the reduced group is the ".repetition_factor(a)". It is used to correct
   ! structure factors for fragment geometries which are "oversampled" relative
   ! to the asymmetric cell geometry.
      pa,pb :: REALVEC(3)
      a,b,n,n_same :: INT
      same :: BIN
      ENSURE(.reduced_symop.created, "no reduced_symops!")
      .repetition_factor.create(.n_fragment_atoms)
      do a = 1,.n_fragment_atoms
         pa = .fragment_geometry(:,a)
         .put_to_unit_cell(pa)
         n_same = 0
         do b = 1,.n_fragment_atoms
         do n = 1,.spacegroup.n_seitz
            pb = .fragment_geometry(:,b)
            .transform_position(pb,n,to_unit_cell=TRUE)
            same = pa.same_as(pb,TOL(3))
            if (same) n_same = n_same + 1
         end
         end
         .repetition_factor(a) = n_same
      end
   end

   transform_geometry(g,op,translate,ignore_glide,to_unit_cell)
   ! Transform the positions "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (1,1,1) unit cell.
      g :: REALMAT
      op :: INT
      translate :: INTVEC(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
      n :: INT
   ENSURE(g.dim1==3,"incorrect size for array g")
      do n = 1,g.dim2
         .transform_position(g(:,n),op,translate,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,translate,ignore_glide,to_unit_cell) ::: private
   ! Transform the position "p" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (1,1,1) unit cell.
       p :: REALVEC(3)
      op :: INT
      translate :: INTVEC(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
      ignore,to_cell :: BIN
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
   ENSURE(op>0,"operator index out of bounds")
   ENSURE(op<=.spacegroup.n_seitz,"operator index out of bounds")
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p)
      else
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p) + .spacegroup.seitz(1:3,4,op)
      end
      if (present(translate)) p = p + translate
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p)
   end

   put_to_unit_cell(g) ::: private
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      g :: REALMAT
      n,n_atom :: INT
      ENSURE( size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      do n = 1,n_atom
         .put_to_unit_cell(g(:,n))
      end
   end

   put_to_unit_cell(p) ::: private
   ! Transform the position "p" in fractional coordinates into the
   ! (1,1,1) unit cell.
      p :: REALVEC(3)
      ENSURE(size(p)==3, "p must be length 3")
      p(:) = mod(p(:)-floor(p(:))+TWO+0.001d0,ONE) - 0.001d0
      ! p(:)-floor(p(:))+TWO should make it positive.
   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      g :: REALMAT
      n,n_atom :: INT
      centre :: INTVEC(3)
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      centre = .unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - centre
      end
   end

   unit_cell_offset(g) result(res)
   ! Which hkl indices match the centre of the fragment geometry "g" when
   ! expressed in crystal coordinates.  Usually we expect that it is 0,0,0 but
   ! not always.
      g :: REALMAT
      res :: INTVEC(3)
   ENSURE(g.dim1==3, "incorrect size for array g")
      res = sum(g,dim=2)/g.dim2
   end

   fragment_width result(res)
   ! Return the width "res" of the fragment in each of the 3 axis directions.
      res :: REALVEC(3)
   ENSURE(.fragment_geometry.created,"no fragment geometry")
      res = .fragment_geometry.max_abs_column_difference
   end

   cartesian_fragment_width result(res)
   ! Return the cartesian width "res" of the fragment in each of the three axis
   ! directions.
      res :: REALVEC(3)
      res = .fragment_width
      .change_position_from_crystal(res)
   end

   reduced_symop_mat(r) result (res) ::: private
   ! Return the "r"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      res :: REALMAT(3,3)
      r :: INT
   ENSURE(.reduced_symop.created,"no reduced_symops!")
   ENSURE(r<=.n_reduced_symops,"symop index out of range")
   ENSURE(r>0, "symop index out of range")
      res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

   unique_symop_mat(u) result (res) ::: private
   ! Return the "u"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      res :: REALMAT(3,3)
      u,r :: INT
      ENSURE(.unique_symop.created,"no unique_symops!")
      ENSURE(u<=.n_unique_symops,"symop index out of range")
      ENSURE(u>0,"symop index out of range")
      r = .unique_symop(u)
      res = .spacegroup.seitz(1:3,1:3,r)
   !  res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

!  **************
!  Output methods
!  **************

   put(atom)
   ! Put out the crystal data to file "out"
      atom :: ATOMVEC, optional
      stdout.flush
      stdout.text("CRYSTAL information:")
      stdout.show("kind                        = ", .kind)
      .put_unitcell_data
      .spacegroup.put
      if (.asymmetric_unit_exists) .put_asymmetric_unit_geometry(atom)
      if (.fragment_data_exists)   .put_fragment_data(atom)
      if (.reflection_data_exists) .put_reflection_data
   end

   put_stl ::: private
   ! Output sin(theta)/lambda for all reflections.
     n :: integer
     ENSURE(.reflections.created,"No list of reflections")
     ENSURE(.reflections.have_indices,"No list of reflections")
     stdout.text("sin(theta)/lambda for the reflections")
     stdout.dash(int_fields=3,real_fields=1)
     stdout.put("h",int_width=TRUE)
     stdout.put("k",int_width=TRUE)
     stdout.put("l",int_width=TRUE)
     stdout.put("stl")
     stdout.flush
     stdout.dash(int_fields=3,real_fields=1)
     do n=1,size(.reflections)
       stdout.put(.reflections(n).h)
       stdout.put(.reflections(n).k)
       stdout.put(.reflections(n).l)
       stdout.put(.stl(n))
       stdout.flush
     end
     stdout.dash(int_fields=3,real_fields=1)
   end

   put_unitcell_data ::: private
   ! Put unitcell information to file "out"
     stdout.flush
     stdout.text("Crystal unitcell information:",flush=2)
     stdout.show("alpha angle(rad)        = ",.unit_cell_angle(1))
     stdout.show("beta  angle(rad)        = ",.unit_cell_angle(2))
     stdout.show("gamma angle(rad)        = ",.unit_cell_angle(3))
     stdout.show("a cell parameter(bohr)  = ",.unit_cell_length(1))
     stdout.show("b cell parameter(bohr)  = ",.unit_cell_length(2))
     stdout.show("c cell parameter(bohr)  = ",.unit_cell_length(3))
     stdout.show("cell volume(bohr^3)     = ",.unit_cell_volume)
     stdout.flush
     stdout.show("alpha* angle(rad)       = ",.alpha_star)
     stdout.show("beta*  angle(rad)       = ",.beta_star)
     stdout.show("gamma* angle(rad)       = ",.gamma_star)
     stdout.show("a* cell parameter(bohr) = ",.a_star)
     stdout.show("b* cell parameter(bohr) = ",.b_star)
     stdout.show("c* cell parameter(bohr) = ",.c_star)
     stdout.flush
     stdout.text("Direct cell matrix/bohr:")
     stdout.put(.direct_cell_matrix)
     stdout.flush
     stdout.text("Reciprocal cell matrix/(bohr^{-1}):")
     stdout.put(.reciprocal_cell_matrix)
     stdout.flush
     stdout.text("Direct U cell matrix/bohr:")
     stdout.put(.direct_U_cell_matrix)
     stdout.flush
     stdout.text("Reciprocal U cell matrix/(bohr^{-1}):")
     stdout.put(.reciprocal_U_cell_matrix)
     stdout.flush
   end

   put_fragment_data(atom) ::: private
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.
      atom :: ATOMVEC, optional
      stdout.flush
      stdout.text("Crystal cell-fragment data:")
      stdout.flush
      stdout.show("Fragment partition model      = ",.partition_model)
      stdout.show("Thermal smearing model        = ",.thermal_smearing_model)
      stdout.show("No. of inputted atoms         = ",.n_fragment_atoms,real_width=TRUE)
      stdout.show("No. of unit cell atoms        = ",.n_unit_cell_atoms,real_width=TRUE)
      stdout.show("No. of unique unit cell atoms = ",.n_unique_unit_cell_atoms,real_width=TRUE)
      stdout.show("Z factor                      = ",.Z)
      .put_reduced_symop_data
      .put_inv_trans_symop_data
      .put_fragment_geometry(atom)
      .put_unique_atom_geometry(atom)
      .put_unit_cell_geometry(atom)
      .put_repetition_factors(atom)
   end

   put_reduced_symop_data ::: private
   ! Put out the reduced symop data
      n,s :: INT
      inverted,translated :: BIN
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array!")
      stdout.flush
      stdout.text("Crystal fragment reduced group information:")
      stdout.flush
      stdout.text("NOTE: this table is NOT used any more in structure factor calculations")
      stdout.flush
      stdout.dash(int_fields=5)
      stdout.put("Reduced",int_width=TRUE)
      stdout.put("Seitz",int_width=TRUE)
      stdout.put("Inv.",int_width=TRUE)
      stdout.put("Trans.",int_width=TRUE)
      stdout.flush
      stdout.put("Symop",int_width=TRUE)
      stdout.put("Symop",int_width=TRUE)
      stdout.put("of?",int_width=TRUE)
      stdout.put("of?",int_width=TRUE)
      stdout.put("Unique?",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=5)
      do n = 1,.n_reduced_symops
         stdout.put(n)
         s = .reduced_symop(n)
         stdout.put(s)
         inverted = .inverted_symop(s)>0
         if (inverted) then;   stdout.put(.inverted_symop(s))
         else;                 stdout.tab(int_fields=1)
         end
         translated = .translated_symop(s)<n
         stdout.put(.translated_symop(s))
         if (inverted OR translated) then; stdout.put("No",int_width=TRUE)
         else;                             stdout.put("Yes",int_width=TRUE)
         end
         stdout.flush
      end
      stdout.dash(int_fields=5)
   end

   put_inv_trans_symop_data ::: private
   ! Put out the inverted translated symop data
      n :: INT
      inverted,translated :: BIN
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      stdout.flush
      stdout.text("Crystal Inversion/Translation related symop information:")
      stdout.flush
      stdout.text("NOTE: this table is used in structure factor calculations")
      stdout.flush
      stdout.dash(int_fields=4)
      stdout.put("Seitz",int_width=TRUE)
      stdout.put("Inv.",int_width=TRUE)
      stdout.put("Trans.",int_width=TRUE)
      stdout.flush
      stdout.put("Symop",int_width=TRUE)
      stdout.put("of?",int_width=TRUE)
      stdout.put("of?",int_width=TRUE)
      stdout.put("Unique?",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=4)
      do n = 1,.spacegroup.n_seitz
         stdout.put(n)
         inverted = .inverted_symop(n)>0
         if (inverted) then;   stdout.put(.inverted_symop(n))
         else;                 stdout.tab(int_fields=1)
         end
         translated = .translated_symop(n)<n
         stdout.put(.translated_symop(n))
         if (inverted OR translated) then; stdout.put("No",int_width=TRUE)
         else;                             stdout.put("Yes",int_width=TRUE)
         end
         stdout.flush
      end
      stdout.dash(int_fields=4)
   end

   put_fragment_geometry(atom) ::: private
   ! Put out the cell geometry information
      atom :: ATOMVEC, optional
      symbol :: STR
      n :: INT
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      ENSURE(.unique_atom_for.created,"no unique_atom_for array")
      stdout.flush
      stdout.text("Crystal fragment cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Fragment",int_width=TRUE)
      stdout.put("Unique",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do n = 1,.n_fragment_atoms
         if (present(atom)) then
            symbol = trim(atom(n).chemical_symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         stdout.put(.unique_atom_for(n))
         stdout.put(.fragment_geometry(1,n))
         stdout.put(.fragment_geometry(2,n))
         stdout.put(.fragment_geometry(3,n))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_unique_atom_geometry(atom) ::: private
   ! Put out the unique atom unit cell geometry information.
   ! These are unique atoms in fragment geometry, and so are not necessarily the
   ! same as the asymmetric unit atoms.
      atom :: ATOMVEC, optional
      n,u :: INT
      symbol :: STR
      ENSURE(.unique_atom.created,"unique_atoms?")
      ENSURE(.fragment_geometry.created,"fragment_geometry?")
      stdout.flush
      stdout.text("Crystal unique atom unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Unique",int_width=TRUE)
      stdout.put("Fragment",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do u = 1,.n_unique_unit_cell_atoms
         stdout.put(u)
         n = .unique_atom(u)
         if (present(atom)) then
            symbol = trim(atom(n).chemical_symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         stdout.put(.fragment_geometry(1,n))
         stdout.put(.fragment_geometry(2,n))
         stdout.put(.fragment_geometry(3,n))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_unit_cell_geometry(atom) ::: private
   ! Put out the full unit cell geometry information
      atom :: ATOMVEC, optional
      n,f :: INT
      symbol :: STR
      stdout.flush
      stdout.text("Full unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)
      stdout.put("Cell ",int_width=TRUE)
      stdout.put("Fragment",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("symop")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do n = 1,.n_unit_cell_atoms
         stdout.put(n)
         if (present(atom)) then
            f = .fragment_atom_for(n)
            symbol = trim(atom(f).chemical_symbol) // " (" // trim(f.to_str) // ")"
         else
            stdout.put(f)
         end
         stdout.put(symbol,int_width=TRUE)
         stdout.put(.unit_cell_geometry(1,n))
         stdout.put(.unit_cell_geometry(2,n))
         stdout.put(.unit_cell_geometry(3,n))
         stdout.put(.symop_for_unit_cell_atom(n))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_repetition_factors(atom) ::: private
   ! Put out the repetition factors
      atom :: ATOMVEC, optional
      n,rf :: INT
      symbol :: STR
      stdout.flush
      stdout.text("Crystal fragment atom repetition factors:")
      stdout.flush
      stdout.dash(int_fields=2)
      stdout.put("Fragment",int_width=TRUE)
      stdout.put("Rep.",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Factor",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=2)
      do n = 1,.n_fragment_atoms
         if (present(atom)) then
            symbol = trim(atom(n).chemical_symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         rf = .repetition_factor(n)
         stdout.put(rf)
         stdout.flush
      end
      stdout.dash(int_fields=2)
   end

   put_F_calc
   ! Put the hkl Miller index triple followed by the calculated
   ! structure factor to add onto existing structure factors.
      ENSURE(.reflections.created, "no reflection data")
      .reflections.set_keys(["indices","F_calc "])
      .reflections.put
      .reflections.clear_keys
   end

   put_F_stats ::: private
   ! Output the structure factor goodness of fit statistics
   ! stdout.
      .reflections.put_F_stats
      .put_correction_data
   end

   put_I_stats ::: private
   ! Output the intensity goodness of fit statistics
      .reflections.put_I_stats
      .put_correction_data
   end

   put_correction_data
   ! Output the correction data
     real_width :: BIN
     real_width = TRUE
     stdout.flush
     stdout.show("Using scale factor          = ", .optimise_scale,real_width)
     stdout.show("Using extinction            = ", .optimise_extinction,real_width)
     stdout.show("Thermal smearing model      = ", .thermal_smearing_model)
     stdout.show("Fragment partition model    = ", .partition_model)
 !   stdout.show("Correct dispersion?         = ", .correct_dispersion)
     if (.optimise_extinction) then;
     stdout.show("Optimize extinction         = ", TRUE,real_width)
     stdout.show("Secondary extinction factor = ", .extinction_factor)
     else
     stdout.show("Optimize extinction         = ", FALSE,real_width)
     end
     if (.optimise_scale) then
     stdout.show("Optimize scale factor       = ", TRUE,real_width)
     stdout.show("Scale factor                = ", .scale_factor)
     else
     stdout.show("Optimize scale factor       = ", FALSE,real_width)
     end
   end

   put_reflection_data
   ! Output the reflection data t
     ENSURE(.reflections.created,"no reflections")
     if (.have_F_calc OR .have_F_pred) .put_correction_data
     .reflections.put
   end

   put_reflection_phases ::: private
   ! Output the reflection phases
     ENSURE(.reflections.created, "no reflection data")
     .reflections.set_keys(["indices","F_calc ","F_phase"])
     .reflections.put
     .reflections.clear_keys
   end

   put_qq_plot(name)
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
     name :: STR, optional
     ENSURE(.reflections.created, "no reflection data")
     .reflections.put_F_qq_plot(name)
   end

   put_labelled_qq_plot(name)
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
     name :: STR, optional
   ENSURE(.reflections.created, "no reflection data")
     .reflections.put_labelled_F_qq_plot(name)
   end

   put_chi2_vs_angle_plot
   ! Output a table with the chi^2 for the structure factor data set broken
   ! into sections.
   ! Reads from stdin the number of divisions in the plot.
     num_sections :: INT
     n,num,k,n_refl :: INT
     section_for :: INTVEC*
     stl,stl_min,stl_max,chi2,width,stl_mean :: REAL

     stdin.read(num_sections)
   ENSURE(num_sections > 0, "number of sections to plot not positive")
   ENSURE(.reflections.created,"no structure factors")
     n_refl = .reflections.n_refl

     ! Work out the limits of the sin(theta)/lambda.
     stl_min = 1000
     stl_max = ZERO
     do n=1, n_refl
       stl = .stl(n) * BOHR_PER_ANGSTROM
       if (stl < stl_min) stl_min = stl
       if (stl > stl_max) stl_max = stl
     end
     width = (TOL(3) + stl_max - stl_min)/num_sections

     section_for.create(n_refl)
     ! Determine which section each reflection belongs to.
     do n=1, n_refl
       stl = .stl(n) * BOHR_PER_ANGSTROM
       section_for(n) = ceiling((TOL(3) + stl - stl_min) / width)
     end

     stdout.flush
     stdout.text("Chi^2 vs angle plot")
     stdout.flush
     stdout.text("sin(theta)/lambda in Angstrom^(-1)")
     stdout.show("Smallest sin(theta)/lambda  = ",stl_min)
     stdout.show("Largest sin(theta)/lambda   = ",stl_max)
     stdout.flush
     stdout.put("stl")
     stdout.put("chi^2",flush=1)
     stdout.dash(real_fields=2)
     do n = 1, num_sections
       chi2 = ZERO
       num = 0
       stl_mean = stl_min + (n - HALF) * width
       do k = 1, n_refl
         if (n==section_for(k)) then
           chi2 = chi2 + .reflections(k).F_z2
           num = num + 1
         end
       end
       stdout.put(stl_mean)
       if (num==0) then
         stdout.flush
         cycle
       else
         chi2 = chi2 / max(num - .n_param,1)
         stdout.put(chi2,flush=1)
       end
     end
     stdout.flush
     section_for.destroy
   end

   put_fcalc_plots
   ! Output some different plots about the calculated structure factors.
     ext :: REALVEC*
     ext_refs :: REFLECTIONVEC*
     n,n_refl :: INT
     y,w :: REAL

     n_refl = .reflections.n_refl

     stdout.text("The effects of angle.")
     stdout.text("Scatter plot of (Fexp-Fpred)/F_sigma vs sin(theta)/lambda")
     do n=1,n_refl
       stdout.put(.stl(n))
       stdout.put(.reflections(n).F_z)
       stdout.flush
     end
     stdout.flush

     stdout.text("The effects of intensity.")
     stdout.text("Scatter plot of (Fexp-Fpred)/F_sigma vs Fexp")
     do n=1,n_refl
       stdout.put(.reflections(n).F_exp)
       stdout.put(.reflections(n).F_z)
       stdout.flush
     end
     stdout.flush

     ext_refs.create(n_refl)
     ext.create(n_refl)
     ext = .extinction_correction
     ext_refs.set_F_exp(.reflections.F_pred)
     ext_refs.set_F_pred(.reflections.F_pred * ext)
     ext_refs.set_F_sigma(.reflections.F_sigma)
     ext.destroy

     stdout.text("The effects of extinction.")
     w = ZERO
     y = ZERO
     do n=1,n_refl
       y = y + abs(ext_refs(n).F_z)
       w = w + abs(ext_refs(n).F_r)
     end
     y = y / n_refl
     w = w / n_refl
     stdout.show("Average value of abs(Fcalc_ext-Fcalc)/F_sigma is ",y)
     stdout.show("Average value of abs(extinction correction) is ",w)
     stdout.flush

     stdout.text("The effects of intensity on extinction.")
     stdout.text("Scatter plot of (Fcalc_ext-Fcalc)/F_sigma vs Fpred")
     do n=1,n_refl
       stdout.put(ext_refs(n).F_pred)
       stdout.put(ext_refs(n).F_z)
       stdout.flush
     end
     stdout.flush

     stdout.text("The effects of scattering angle on extinction.")
     stdout.text("Scatter plot of (Fcalc_ext-Fcalc)/F_sigma vs sin(theta)/lambda")
     do n=1,n_refl
       stdout.put(.stl(n))
       stdout.put(ext_refs(n).F_z)
       stdout.flush
     end
     ext_refs.destroy

     stdout.flush
   end

   make_crystal_error_map(map,pts)
   ! Make the crystal error "map" for the supplied points "pts" from the crystal
   ! structure factors
     map :: REALVEC
     pts :: REALMAT
      k :: REALMAT*
     F,phase :: REALVEC*
     n_pts,n_refl,n :: INT
     fac :: REAL
   ENSURE(.reflections.created, "no structure factors")
   ENSURE(.have_F_calc, "no calculated structure factors")
   ENSURE(.have_F_exp, "no experimental structure factors")
   ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
     n_pts = size(pts,1)
     n_refl = .reflections.n_refl
     k.create(n_refl,3); .make_k_pts(k)
     F.create(n_refl)
     F = (.reflections.F_exp - .reflections.F_pred) * sign(ONE,real(.reflections.F_calc))
     phase.create(n_refl)
     do n = 1,n_pts
        phase.to_product_of(k,pts(n:n,:),transpose_b=TRUE)
        map(n) = sum(F*cos(phase))
     end
     fac = TWO/.unit_cell_volume
     map = fac*map
     phase.destroy
     F.destroy
     k.destroy
   end

   put_PND_sf(name)
   ! Output the magnetic structure factors
       FM_s :: CPXVEC*
       FM_l :: CPXVEC*
       name :: STR
       arch :: ARCHIVE
        n :: INT
       FM_s.create(.reflections.n_refl)
       arch.set(name,"PND_spin_sf")
       arch.read(FM_s)
       FM_l.create(.reflections.n_refl)
       arch.set(name,"PND_nabla_sf")
       arch.read(FM_l)
       stdout.text("PND magnetic structure factors:")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       stdout.put("h", int_width=TRUE)
       stdout.put("k", int_width=TRUE)
       stdout.put("l", int_width=TRUE)
       stdout.put("FM_s")
       stdout.put("FM_l")
       stdout.put("FM")
       stdout.flush
       stdout.dash(int_fields=3,real_fields=3)
       do n = 1, .reflections.n_refl
          stdout.put(.reflections(n).h)
          stdout.put(.reflections(n).k)
          stdout.put(.reflections(n).l)
          stdout.put(real(FM_s(n)) )
          stdout.put(real(FM_l(n)) )
          stdout.put(real(FM_s(n)+FM_l(n)) )
          stdout.flush
       end
       stdout.dash(int_fields=3,real_fields=3)
       FM_l.destroy
       FM_s.destroy
   end

   put_asymmetric_unit_geometry(atom) ::: private
   ! Put out the asymmetric unit geometry. These are only set if the crystal
   ! will reads itself from  a CIF file directly.
      atom :: ATOMVEC, optional
      n,u :: INT
      symbol :: STR
      ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit atoms")
      stdout.flush
      stdout.text("Crystal asymmetric unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do n = 1,.n_asymmetric_unit_atoms
         stdout.put(n)
         if (present(atom)) then
            symbol = trim(atom(n).chemical_symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         stdout.put(.asymmetric_unit_geometry(1,n))
         stdout.put(.asymmetric_unit_geometry(2,n))
         stdout.put(.asymmetric_unit_geometry(3,n))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_crystalexplorer(label)
   ! Output some information for the Hirshview program.
       label :: STR
       stdout.flush
       stdout.text("begin crystalcell " // label.trim)
       stdout.show("   a =",.unit_cell_length(1).to_units("angstrom"))
       stdout.show("   b =",.unit_cell_length(2).to_units("angstrom"))
       stdout.show("   c =",.unit_cell_length(3).to_units("angstrom"))
       stdout.show("   alpha =",.unit_cell_angle(1).to_units("degree"))
       stdout.show("   beta  =",.unit_cell_angle(2).to_units("degree"))
       stdout.show("   gamma =",.unit_cell_angle(3).to_units("degree"))
       stdout.text("end crystalcell")
   end

!  *******************
!  Tests for existence
!  *******************

   asymmetric_unit_exists result(res)
   ! Return TRUE if the asymmetric unit geometry information exists
     res :: BIN
     res = associated(.asymmetric_unit_geometry)
   end

   fragment_data_exists result(res)
   ! Return TRUE if a fragment information exists
     res :: BIN
     res = associated(.fragment_geometry)
   end

   reflection_data_exists result(res)
   ! Return TRUE if reflection data exists
     res :: BIN
     res = associated(.reflections)
   end

   have_F_exp result(res)
   ! Return TRUE if have some experimental structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_exp
   end

   have_F_calc result(res)
   ! Return TRUE if have some calculated structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_calc
   end

   have_F_pred result(res)
   ! Return TRUE if have some predicted structure factors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_pred
   end

   have_F_sigma result(res)
   ! Return TRUE if have some structure factor errors
      res :: BIN
      res = FALSE
      if (associated(.reflections)) res = .reflections.have_F_sigma
   end

!*******************************************************************************
!                     Inherited reflection routines
!*******************************************************************************

   n_refl result (res)
   ! The number of reflections
     res :: INT
     ENSURE(.reflections.created, "no reflection data")
     res = .reflections.n_refl
   end

   F_calc result (res)
   ! The calculated structure factors
     res :: CPXVEC(size(.reflections))
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.F_calc
   end

   F_pred result (res)
   ! The predicted structure factors
     res :: REALVEC(size(.reflections))
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.F_pred
   end

   F_sigma result (res)
   ! The structure factor errors
     res :: REALVEC(size(.reflections))
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.F_sigma
   end

   F_exp result (res)
   ! The experimental structure factors
     res :: REALVEC(size(.reflections))
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.F_exp
   end

   set_F_calc(F_calc)
   ! Set the calculated structure factors
     F_calc :: CPXVEC, IN
     ENSURE(.reflection_data_exists,"no reflection data")
     .reflections.set_F_calc(F_calc)
   end

   F_chi2 result(res)
   ! Returns data
     self :: IN
     res :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.F_chi2
   end

   F_goodness_of_fit result(res)
   ! Returns data
     self :: IN
     res :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.F_goodness_of_fit
   end

   F_r_factor result(res)
   ! Returns data
     self :: IN
     res :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.F_r_factor
   end

   F_weighted_r_factor result(res)
   ! Returns data
     self :: IN
     res :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.F_weighted_r_factor
   end

   I_chi2 result(res)
   ! Returns data
     self :: IN
     res :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.I_chi2
   end

   I_goodness_of_fit result(res)
   ! Returns data
     self :: IN
     res :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.I_goodness_of_fit
   end

   I_r_factor result(res)
   ! Returns data
     self :: IN
     res :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.I_r_factor
   end

   I_weighted_r_factor result(res)
   ! Returns data
     self :: IN
     res :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     res = .reflections.I_weighted_r_factor
   end

   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.
     F_exp :: REALVEC*
     n :: INT
     chi2,z :: REAL
     ENSURE(.reflection_data_exists,"no reflection data")
     ENSURE(.have_F_exp,"no experimental structure factors")
     ENSURE(.have_F_sigma,"no experimental structure factor errors")
     stdout.flush
     stdout.text("Adding simulated errors to F_exp using F_sigma.")
     F_exp.create(.n_refl)
     F_exp = .reflections.F_exp
     .reflections.simulate_new_F_exp
     chi2=ZERO
     do n=1,.n_refl
       z=(F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
       chi2 = chi2 + z*z
     end
     chi2 = chi2 / max(.n_refl - 1,1)
     stdout.text("chi^2 of old F_exp to new F_exp is " // trim(chi2.to_str))
     stdout.flush
     stdout.dash(real_fields=4)
     stdout.put("F_exp (old)")
     stdout.put("F_exp (new)")
     stdout.put("F_sigma")
     stdout.put("dF/sigma")
     stdout.flush
     stdout.dash(real_fields=4)
     do n=1,.n_refl
       z=(F_exp(n)-.reflections(n).F_exp)/.reflections(n).F_sigma
       stdout.put(F_exp(n))
       stdout.put(.reflections(n).F_exp)
       stdout.put(.reflections(n).F_sigma)
       stdout.put(z)
       stdout.flush
     end
     stdout.dash(real_fields=4)
     F_exp.destroy
   end

end
