!-------------------------------------------------------------------------------
!
! CRYSTAL: Data structure for crystals
!
! $Id$
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
!-------------------------------------------------------------------------------

module CRYSTAL

   implicit none

   saved_self :: CRYSTAL*

contains

!  **************************
!  Create and destroy methods
!  **************************

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the crystal object
     .spacegroup.nullify_ptr_part
     nullify(.fragment_geometry)
     nullify(.shift_for_frag_atom)
     nullify(.fragment_cell_geometry)
     nullify(.symop_for_frag_cell_atom)
     nullify(.shift_for_frag_cell_atom)
     nullify(.frag_atom_for_frag_cell_atom)
     nullify(.unique_frag_atom)
     nullify(.unique_atom_for_frag_atom)
     nullify(.unique_symop_for_frag_atom)
     nullify(.unique_shift_for_frag_atom)
   ! nullify(.reduced_symop)
   ! nullify(.cluster_symop)
     nullify(.inverted_symop)
     nullify(.translated_symop)
     nullify(.unique_SF_symop)
     nullify(.repetition_factor)
     nullify(.asymmetric_unit_geometry)
     nullify(.unit_cell_geometry)
     nullify(.symop_for_unit_cell_atom)
     nullify(.shift_for_unit_cell_atom)
     nullify(.asym_atom_for_unit_cell_atom)
     nullify(.frag_cell_for_unit_cell_atom)
     nullify(.frag_atom_for_unit_cell_atom)
     nullify(.frag_atom_for_asym_unit_atom)
     nullify(.asym_unit_atom_for_frag_atom)
     nullify(.data)
     nullify(.xray_data)
     nullify(.pnd_data)
   end

   destroy_ptr_part ::: leaky
   ! Erase all pointer information
    .spacegroup.destroy_ptr_part
    .destroy_fragment_data
    .destroy_asymmetric_unit
    .destroy_data
   end

   destroy_data ::: leaky
   ! Erase all data pointer information
    nullify(.data)
    .xray_data.destroy
    .pnd_data.destroy
   end

   destroy_fragment_data ::: leaky
   ! Destroy the geometry and symmetry data for the fragment and unit cell.
     .fragment_geometry.destroy
     .shift_for_frag_atom.destroy
     .fragment_cell_geometry.destroy
     .symop_for_frag_cell_atom.destroy
     .shift_for_frag_cell_atom.destroy
     .frag_atom_for_frag_cell_atom.destroy
     .unique_frag_atom.destroy
     .unique_atom_for_frag_atom.destroy
     .unique_symop_for_frag_atom.destroy
     .unique_shift_for_frag_atom.destroy
   ! .reduced_symop.destroy
   ! .cluster_symop.destroy
     .inverted_symop.destroy
     .translated_symop.destroy
     .unique_SF_symop.destroy
     if (NOT .use_manual_repetition_factors) &
        .repetition_factor.destroy
   ! .asymmetric_unit_geometry.destroy ! This is nothing to do with a fragment !
   ! The asymmetric unit will be defined from the fragment if it needs to be
   ! Once set, it will never be destroyed unless explicitly requested.
     .unit_cell_geometry.destroy
     .symop_for_unit_cell_atom.destroy
     .shift_for_unit_cell_atom.destroy
     .asym_atom_for_unit_cell_atom.destroy
     .frag_cell_for_unit_cell_atom.destroy
     .frag_atom_for_unit_cell_atom.destroy
     .frag_atom_for_asym_unit_atom.destroy
     .asym_unit_atom_for_frag_atom.destroy
     .unit_cell_atom_for_frag_atom.destroy
     .fragment_info_made = FALSE
   end

   destroy_asymmetric_unit ::: leaky
   ! Destroy the asymmetric unit geometry. Normally this will be set by reading a CIF
   ! file. If not, it will be set from a given fragment atom list, in the
   ! "make_fragment_data" routine. Once set, it is never destroyed unless
   ! explicitly requested by a call or a keyword.
     .asymmetric_unit_geometry.destroy ! This is nothing to do with a fragment !
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(crystal) ::: leaky
   ! Set self to be crystal.
     crystal :: CRYSTAL, IN
     self = crystal
     .nullify_ptr_part
     .spacegroup.copy(crystal.spacegroup)
     .unit_cell.copy(crystal.unit_cell)
     if (crystal.fragment_geometry.created)        .fragment_geometry.create_copy(crystal.fragment_geometry)
     if (crystal.shift_for_frag_atom.created)      .shift_for_frag_atom.create_copy(crystal.shift_for_frag_atom)
     if (crystal.fragment_cell_geometry.created)   .fragment_cell_geometry.create_copy(crystal.fragment_cell_geometry)
     if (crystal.symop_for_frag_cell_atom.created) .symop_for_frag_cell_atom.create_copy(crystal.symop_for_frag_cell_atom)
     if (crystal.shift_for_frag_cell_atom.created) .shift_for_frag_cell_atom.create_copy(crystal.shift_for_frag_cell_atom)
     if (crystal.frag_atom_for_frag_cell_atom.created) .frag_atom_for_frag_cell_atom.create_copy(crystal.frag_atom_for_frag_cell_atom)
     if (crystal.unique_frag_atom.created)           .unique_frag_atom.create_copy(crystal.unique_frag_atom)
     if (crystal.unique_atom_for_frag_atom.created)  .unique_atom_for_frag_atom.create_copy(crystal.unique_atom_for_frag_atom)
     if (crystal.unique_symop_for_frag_atom.created) .unique_symop_for_frag_atom.create_copy(crystal.unique_symop_for_frag_atom)
     if (crystal.unique_shift_for_frag_atom.created) .unique_shift_for_frag_atom.create_copy(crystal.unique_shift_for_frag_atom)
   ! if (crystal.reduced_symop.created) &
   !    .reduced_symop.create_copy(crystal.reduced_symop)
   ! if (crystal.cluster_symop.created) &
   !    .cluster_symop.create_copy(crystal.cluster_symop)
     if (crystal.inverted_symop.created) .inverted_symop.create_copy(crystal.inverted_symop)
     if (crystal.translated_symop.created) .translated_symop.create_copy(crystal.translated_symop)
     if (crystal.unique_SF_symop.created) .unique_SF_symop.create_copy(crystal.unique_SF_symop)
     if (crystal.repetition_factor.created) .repetition_factor.create_copy(crystal.repetition_factor)
     if (crystal.asymmetric_unit_geometry.created) .asymmetric_unit_geometry.create_copy(crystal.asymmetric_unit_geometry)
     if (crystal.unit_cell_geometry.created) .unit_cell_geometry.create_copy(crystal.unit_cell_geometry)
     if (crystal.symop_for_unit_cell_atom.created) .symop_for_unit_cell_atom.create_copy(crystal.symop_for_unit_cell_atom)
     if (crystal.shift_for_unit_cell_atom.created) .shift_for_unit_cell_atom.create_copy(crystal.shift_for_unit_cell_atom)
     if (crystal.asym_atom_for_unit_cell_atom.created) .asym_atom_for_unit_cell_atom.create_copy(crystal.asym_atom_for_unit_cell_atom)
     if (crystal.frag_cell_for_unit_cell_atom.created) .frag_cell_for_unit_cell_atom.create_copy(crystal.frag_cell_for_unit_cell_atom)
     if (crystal.frag_atom_for_unit_cell_atom.created) .frag_atom_for_unit_cell_atom.create_copy(crystal.frag_atom_for_unit_cell_atom)
     if (crystal.frag_atom_for_asym_unit_atom.created) .frag_atom_for_asym_unit_atom.create_copy(crystal.frag_atom_for_asym_unit_atom)
     if (crystal.asym_unit_atom_for_frag_atom.created) .asym_unit_atom_for_frag_atom.create_copy(crystal.asym_unit_atom_for_frag_atom)
     if (crystal.unit_cell_atom_for_frag_atom.created) .unit_cell_atom_for_frag_atom.create_copy(crystal.unit_cell_atom_for_frag_atom)
     if (crystal.xray_data.created) .xray_data.create_copy(crystal.xray_data)
     if (crystal.pnd_data.created)  .pnd_data.create_copy(crystal.pnd_data)
   end

   set_defaults ::: leaky
   ! Set up a default crystal object
      .spacegroup.set_defaults
      .unit_cell.set_defaults
      .CIF_chemical_formula   = "?"
      .prune_asymmetric_unit  = FALSE
      .fragment_info_made     = FALSE
      .use_manual_repetition_factors = FALSE
      .data_kind              = "?"
      nullify(.data)
      if (.xray_data.created) then; .xray_data.set_defaults
      else;                         nullify(.xray_data)
      end
      if (.pnd_data.created) then;  .pnd_data.set_defaults
      else;                         nullify(.pnd_data)
      end
   end

   update 
   ! Update the crystal information after setting values.
     if (.xray_data.created) .xray_data.update(.unit_cell,.spacegroup)
     if (.pnd_data.created)  .pnd_data.update(.unit_cell,.spacegroup)
   end

   assign_xray 
   ! Assign xray_data to data
   ENSURE(.xray_data.created, "No X-ray reflection data")
      nullify(.data)
      .data => .xray_data
      !stdout.text("assign x-ray")
      !stdout.put(.data.data_kind, flush=1)
   end

   assign_pnd 
   ! Assign pnd_data to data
   ENSURE(.pnd_data.created, "No PND reflection data")
      nullify(.data)
      .data => .pnd_data
      !stdout.text("assign pnd")
      !stdout.put(.data.data_kind, flush=1)
   end

!  ************
!  Read methods
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
        case ("}                             ")  ! exit read_loop
        case ("asymmetric_unit_geometry=     "); .read_asymmetric_unit_geometry
        case ("destroy                       "); .destroy_ptr_part; .set_defaults
        case ("destroy_asymmetric_unit       "); .destroy_asymmetric_unit
        case ("destroy_spacegroup            "); .spacegroup.destroy_ptr_part
        case ("junk=                         "); CRYSTAL::read_junk
        case ("kind=                         "); .read_kind
        case ("merge_equivalents             "); .merge_equivalents
        case ("pnd_data=                     "); .read_pnd_data
        case ("prune_asymmetric_unit=        "); .read_prune_asymmetric_unit
        case ("prune_bad_sigmas              "); .prune_bad_sigmas
        case ("put                           "); .put
        case ("read_cif                      "); .read_CIF
        case ("redirect                      "); .redirect
        case ("repetition_factors=           "); .read_repetition_factors
        case ("revert                        "); .revert
        case ("spacegroup=                   "); .read_spacegroup
        case ("unit_cell=                    "); .read_unit_cell
        case ("units=                        "); CRYSTAL::read_units
        case ("use_manual_repetition_factors="); .read_use_manual_rep_factors
        case ("xray_data=                    "); .read_xray_data
        case default;                       UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT), selfless, private
   ! Read in a junk string, useful for ignoring a field
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input. (This code is for non-pointer self objects).
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
   end

   read_kind
   ! Read the kind of crystal experiment
      stdin.read(.data_kind)
      .data_kind.to_lower_case
      select case (.data_kind)
         case("x-ray")
         case("pnd  ")
         case default; UNKNOWN(.data_kind)
      end
   end

   read_spacegroup ::: leaky
   ! Read the spacegroup
      .spacegroup.read_keywords
      .spacegroup.analyse
   end

   read_unit_cell 
   ! Read the unit cell information
      .unit_cell.read_keywords
      .unit_cell.make_info
   end

   read_xray_data ::: leaky
   ! Read in the xray diffraction data
      WARN_IF(.xray_data.created,"xray diffraction data already defined!")
      if (.xray_data.destroyed) .xray_data.create
      .xray_data.read_keywords
      .xray_data.update
      .assign_xray
      .prune_negative_F_exp
   end

   read_pnd_data ::: leaky
   ! Read in the pnd diffraction data
      WARN_IF(.pnd_data.created,"pnd diffraction data already defined!")
      if (.pnd_data.destroyed) .pnd_data.create
      .pnd_data.data_kind = "pnd"
      .pnd_data.read_keywords
      .pnd_data.update
      .assign_pnd
   end

   read_use_manual_rep_factors ::: leaky, private
   ! Read whether to use manually entered repetition factors.
   ! If set set FALSE, the repetition factors will be destroyed.
     stdin.read(.use_manual_repetition_factors)
     if (.use_manual_repetition_factors) return
     .repetition_factor.destroy
   end

   read_repetition_factors ::: leaky, private
   ! Read in the crystal fragment repetition factors. Useful to get structure
   ! factor contributions from a small portion of the fragment.
     .repetition_factor.destroy
     stdin.read_ptr(.repetition_factor)
     .use_manual_repetition_factors = TRUE
   end

   read_prune_asymmetric_unit ::: private
   ! Read whether to prune the asymmetric unit or not. Sometimes the asymmetric
   ! unit may not be asymmetric i.e. it may have symmetry-equivalent atoms
   ! repeated. This could be because of an input or CIF file error, or it could
   ! be genuinely correct because the repeated atom corresponds to a disordered
   ! position. For Hirshfeld surface plots, which can cope with disorder, you
   ! probably do not want to prune the asymmetric atom list, but for crystal
   ! calculations you must do so.
      stdin.read(.prune_asymmetric_unit)
   end

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File object, with
   ! the "name" taken from stdin.
      name :: STR
      found :: BIN
      cif :: CIF*
      stdin.read(name)
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 
      .read_CIF(cif)
      cif.destroy
   end

   read_CIF(cif,skip_atoms) ::: leaky
   ! Read information from a Crystallographic Information File object, "cif".
   ! If "skip_atoms" is present and TRUE, the atom coordinates are not processed.
      cif :: CIF
      skip_atoms :: BIN, optional
      skip,found :: BIN
      itemvec :: VEC{STR}*
      skip = FALSE
      if (present(skip_atoms)) skip = skip_atoms
      .set_defaults
      ! Read the chemical formula if it is there
      cif.read_item("_chemical_formula_sum",.CIF_chemical_formula,itemvec,found)
      if (NOT found) .CIF_chemical_formula = "?"
      DIE_IF(itemvec.created,"multi line chemical formula")
      ! Read the spacegroup and unit cell and atom list (if requested)
      .spacegroup.read_CIF(cif)
      .unit_cell.read_CIF(cif)
      if (NOT skip) .read_CIF_atoms(cif)
      .update
   end

   read_CIF_atoms(cif) ::: leaky, private
   ! Read atom information from a CIF file, "cif"
      cif :: CIF
      ID :: STR
      fs,fx,fy,fz :: BIN
      labels :: VEC{STR}*
      x,y,z :: VEC{REAL}*
      n :: INT
      ID = "_atom_site_type_symbol"
      cif.find_looped_item(trim(ID),fs)
      if (NOT fs) then
      ID = "_atom_site_label"
      cif.find_looped_item(trim(ID),fs)
      end
      cif.find_looped_item("_atom_site_fract_x",fx)
      cif.find_looped_item("_atom_site_fract_y",fy)
      cif.find_looped_item("_atom_site_fract_z",fz)
      ENSURE(fs AND fx AND fy AND fz,"incomplete atom information in CIF file")
      cif.read_looped_item(trim(ID),labels)
      cif.read_looped_item("_atom_site_fract_x",x)
      cif.read_looped_item("_atom_site_fract_y",y)
      cif.read_looped_item("_atom_site_fract_z",z)
      ! Assign the CIF info
      n = labels.dim
      .n_asymmetric_unit_atoms = n
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,n)
      .asymmetric_unit_geometry(1,:) = x
      .asymmetric_unit_geometry(2,:) = y
      .asymmetric_unit_geometry(3,:) = z
      z.destroy; y.destroy; x.destroy
      labels.destroy
   end

   read_asymmetric_unit_geometry
   ! Read in the asymmetric unit geometry in crystal coordinates.
   ! The coordinates are read in as a single vector ordered as x,y,z
   ! incrementing fastest, for the first to the last atom.
      geometry :: VEC{REAL}*
   WARN_IF(.asymmetric_unit_geometry.created,"asymmetric_unit_geometry exists!")
      stdin.read_ptr(geometry)
      ENSURE(modulo(geometry.dim,3)==0,"number of coordinates must be divisible by 3")
      .n_asymmetric_unit_atoms = geometry.dim/3
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,.n_asymmetric_unit_atoms)
      .asymmetric_unit_geometry = reshape(geometry,[3,.n_asymmetric_unit_atoms])
      geometry.destroy
   end

   set_asymmetric_unit_geometry(geometry) ::: leaky
   ! Set the asymmetric unit geometry from a CARTESIAN "geometry". This is
   ! useful if the atomic coordinates have been processed from a CIF elsewhere,
   ! e.g. in the VEC{ATOM} module.
      geometry :: MAT{REAL}
   ENSURE(geometry.dim1==3,"wrong 1st dimensions, geometry")
      .n_asymmetric_unit_atoms = geometry.dim2
      .asymmetric_unit_geometry.destroy
      .asymmetric_unit_geometry.create(3,geometry.dim2)
      .asymmetric_unit_geometry = matmul(.unit_cell.inverse_matrix,geometry)
   end

!  ***************
!  General methods
!  ***************

   d_chi2_dU(dF) result (res)
   ! Evaluate the derivative of the chi^2 with respect to parameters U
   ! (e.g. thermal parameters) given the derivatives "dF" of where
   ! .data.F_calc with respect to these parameters U. NOTE: this routine
   ! assumes that the .data.scale_factor and .data.extinction_factor are fixed.
     dF :: MAT{CPX}
     res :: VEC{REAL}(dF.dim1)
   ENSURE(.data_exists,"no diffraction data")
     res = .data.d_chi2_dU(dF)
   end

   make_k_pts(res)
   ! Convert the .reflection.hkl indices to reciprocal lattice vectors
   ! Dimension of res is [.n_refl,3]
      res :: MAT{REAL}
       n :: INT
      hkl :: VEC{INT}(3)
      rcm :: MAT{REAL}(3,3)
      rcm = TWO*PI*.unit_cell.reciprocal_matrix
      do n = 1, .data.reflections.n_refl
         hkl = .data.reflections.indices(n)
         res(n,1) = dot_product(rcm(1,:),hkl(:))
         res(n,2) = dot_product(rcm(2,:),hkl(:))
         res(n,3) = dot_product(rcm(3,:),hkl(:))
      end
   end

   n_unique_SF_k_pts result(res) ::: pure
   ! The number of unique k-points for an SF calculation
     self :: IN
     res :: INT
     res = .n_unique_SF_symops * .data.reflections.dim
   end

   make_unique_SF_k_pts(k)
   ! Convert the hkl indices to unique reciprocal lattice vectors "k" required
   ! for structure factor calculations.
   ! (c) Dylan Jayatilaka, UWA, feb 1996
      k :: MAT{REAL}
   ENSURE(.unique_SF_symop.created,"no unique_SF_symop array!")
   ENSURE(k.dim1>0,"no unique k points")
   ENSURE(k.dim1==.n_unique_SF_k_pts,"wrong # of k points")
      p,u,n :: INT
      b,rcm :: MAT{REAL}(3,3)
      hkl :: VEC{INT}(3)
      p = 0
      rcm = TWO*PI*.unit_cell.reciprocal_matrix
      do u = 1,.n_unique_SF_symops
         b = matmul(rcm,transpose(.unique_SF_symop_mat(u)))
         do n = 1,.data.reflections.n_refl
            p = p + 1
            hkl = .data.reflections.indices(n)
            k(p,1) = dot_product(b(1,:),hkl(:))
            k(p,2) = dot_product(b(2,:),hkl(:))
            k(p,3) = dot_product(b(3,:),hkl(:))
         end
      end
   end

!  *************************************
!  Service methods used by other modules
!  *************************************

   make_phases_for_symop(u,phase,mask) ::: private
   ! Return the sum of the "phase" shifts for each (hkl) reflection from each
   ! glide vector for all symops which are equivalent to the "u"-th
   ! unique symmetry operation, .unique_SF_symop(u), as determined by the mask
   ! array.
     u :: INT, IN
     phase :: VEC{CPX}, OUT
     mask :: VEC{INT}, IN
   ENSURE(.unique_SF_symop.created,"no unique_SF_symop array!")
   ENSURE(u<=.n_unique_SF_symops,"symop index out of range")
   ENSURE(size(phase)==.data.reflections.n_refl,"wrong length for phase array")
     pi2,tx,ty,tz,dot :: REAL
     s,n,n_refl,h,k,l :: INT
     seitz :: MAT{REAL}*
     refl :: VEC{REFLECTION}*
     n_refl = .data.reflections.n_refl
     pi2 = TWO*PI
     refl => .data.reflections
     phase = ZERO
     do s = 1,.spacegroup.n_seitz
       if (mask(s)/=.unique_SF_symop(u)) cycle
       seitz => .spacegroup.seitz(:,:,s)
       tx = pi2*seitz(1,4)
       ty = pi2*seitz(2,4)
       tz = pi2*seitz(3,4)
       do n = 1,n_refl
         h = refl(n).h
         k = refl(n).k
         l = refl(n).l
         dot = h*tx+k*ty+l*tz
         phase(n) = phase(n) + exp(cmplx(ZERO,dot,kind=CPX_KIND))
       end
     end
   end

   sum_unique_sf(sf,unique_sf)
   ! Form the structure factors "sf" from the sum of the list of
   ! unique structure factors, "unique_sf".
     sf :: VEC{CPX}
     unique_sf :: VEC{CPX}, IN
     phase :: VEC{CPX}*
     u,uf,ul,n_refl :: INT
     n_refl = .data.reflections.n_refl
     ENSURE( size(sf)==n_refl,"incorrect size for array sf")
     phase.create(n_refl)
     sf = ZERO
     parallel do u = 1,.n_unique_SF_symops
        uf = n_refl*(u-1)+1
        ul = n_refl*u
        .make_phases_for_symop(u,phase,.translated_symop)
        sf(:) = sf(:) + phase(:)*unique_sf(uf:ul)
        if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle
        .make_phases_for_symop(u,phase,.inverted_symop)
        sf(:) = sf(:) + phase(:)*conjg(unique_sf(uf:ul))
     end
     PARALLEL_SUM(sf)
     phase.destroy
   end

   sum_unique_sf_ints(sf_ints,unique_sf_ints)
   ! Form the structure factor integrals "sf_ints" from a sum of the list
   ! of unique structure factors integrals  "unique_sf_ints".
     sf_ints :: MAT3{CPX}
     unique_sf_ints :: MAT3{CPX}, IN
     phase :: VEC{CPX}*
     u,uf,n,n_refl :: INT
     n_refl = .data.reflections.n_refl
     ENSURE(size(sf_ints,1)==n_refl,"wrong size for sf_ints!")
     phase.create(n_refl)
     sf_ints = ZERO
     do u = 1,.n_unique_SF_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*unique_sf_ints(uf+n,:,:)
       end
       if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         sf_ints(n,:,:) = sf_ints(n,:,:) + phase(n)*conjg(unique_sf_ints(uf+n,:,:))
       end
     end
     phase.destroy
   end

   sum_unique_sf_deriv_U(sf,unique_sf)
   ! Form the structure factor derivatives "sf" (wrt the thermal paramaters,U)
   !  from a sum of the list of unique structure factor derivatives "unique_sf".
     sf :: MAT{CPX}
     unique_sf :: MAT{CPX}, IN
     phase :: VEC{CPX}*
     u,uf,n,n_refl :: INT
     n_refl = .data.reflections.n_refl
     ENSURE(size(sf,1)==n_refl, "wrong size, matrix sf")
     ENSURE(size(unique_sf,2)==.n_unique_SF_k_pts, "wrong size, matrix sf")
     phase.create(n_refl)
     sf = ZERO
     do u = 1,.n_unique_SF_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         sf(n,:) = sf(n,:) + phase(n)*unique_sf(:,uf+n)
       end
       if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         sf(n,:) = sf(n,:) + phase(n)*conjg(unique_sf(:,uf+n))
       end
     end
     phase.destroy
   end

   sum_ft_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints" from a sum of the list
   ! of unique integrals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b].
     ft_ints :: MAT3{CPX}
     unique_ft_ints :: MAT3{CPX}, IN
     phase :: VEC{CPX}*
     u,uf,n,n_refl :: INT
     n_refl = .data.reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
     phase.create(n_refl)
     ft_ints = ZERO
     do u = 1,.n_unique_SF_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*unique_ft_ints(uf+n,:,:)
       end
       if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + phase(n)*conjg(unique_ft_ints(uf+n,:,:))
       end
     end
     phase.destroy
   end

   make_phased_matrix_for_symop(u,phase,mask) ::: private
   ! Return the sum of the "phase" shifts times the seitz matrices for all
   ! symops which are equivalent to the "u"-th unique symmetry operation,
   ! .unique_SF_symop(u), as determined by the "mask" array, when
   ! mask(u)==.unique_SF_symop(u).
     u :: INT, IN
     phase :: MAT3{CPX}, OUT
     mask :: VEC{INT}, IN
   ENSURE(.unique_SF_symop.created,"no unique_SF_symop array!")
   ENSURE(u<=.n_unique_SF_symops,"symop index out of range")
   ENSURE(phase.dim1==.data.reflections.n_refl,"wrong size, dim=1, phase array")
   ENSURE(phase.dim2==3,"wrong size, dim=2, phase array")
   ENSURE(phase.dim3==3,"wrong size, dim=3, phase array")
     pi2,tx,ty,tz,dot :: REAL
     s,n,n_refl,h,k,l :: INT
     seitz :: MAT{REAL}(4,4)
     refl :: VEC{REFLECTION}*
     n_refl = .data.reflections.n_refl
     pi2 = TWO*PI
     refl => .data.reflections
     phase = ZERO
     do s = 1,.spacegroup.n_seitz
       if (mask(s)/=.unique_SF_symop(u)) cycle
       seitz = .spacegroup.seitz(:,:,s)
       tx = pi2*seitz(1,4)
       ty = pi2*seitz(2,4)
       tz = pi2*seitz(3,4)
       if (seitz(3,3)>0) then                  ! M points along +z always
         do n = 1,n_refl
           h = refl(n).h
           k = refl(n).k
           l = refl(n).l
           dot = h*tx+k*ty+l*tz
           phase(n,:,:) = phase(n,:,:) + &
              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
         end
       else                                    ! M points in -z direction
         seitz(3,:3) = -seitz(3,:3)            ! Invert
         do n = 1,n_refl
           h = refl(n).h
           k = refl(n).k
           l = refl(n).l
           dot = h*tx+k*ty+l*tz
           phase(n,:,:) = phase(n,:,:) + &
              seitz(:,:)*exp(cmplx(ZERO,dot,kind=CPX_KIND))
         end
       end
     end
   end

   sum_PND_spin_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints", required for the spin
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b,3].
     ft_ints :: MAT4{CPX}
     unique_ft_ints :: MAT3{CPX}, IN
     phase :: MAT3{CPX}*
     q :: MAT{REAL}*
     u,uf,n,n_refl :: INT
     n_refl = .data.reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
     q.create(n_refl,3)
     phase.create(n_refl,3,3)
     .make_k_pts(q)
     ft_ints = ZERO
     do u = 1,.n_unique_SF_symops
        uf = n_refl*(u-1)
        .make_phased_matrix_for_symop(u,phase,.translated_symop)
        do n = 1,n_refl
           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
              unique_ft_ints(uf+n,:,:)
           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
              unique_ft_ints(uf+n,:,:)
           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
              unique_ft_ints(uf+n,:,:)
        end
        if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle ! for inversions...
        .make_phased_matrix_for_symop(u,phase,.inverted_symop)
        do n = 1,n_refl
           ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + &
              ( q(n,3)*q(n,1)*phase(n,1,1) + q(n,3)*q(n,2)*phase(n,2,1)     &
              - q(n,1)*q(n,1)*phase(n,3,1) - q(n,2)*q(n,2)*phase(n,3,1) ) * &
              conjg(unique_ft_ints(uf+n,:,:))
           ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + &
              ( q(n,3)*q(n,1)*phase(n,1,2) + q(n,3)*q(n,2)*phase(n,2,2)     &
              - q(n,1)*q(n,1)*phase(n,3,2) - q(n,2)*q(n,2)*phase(n,3,2) ) * &
              conjg(unique_ft_ints(uf+n,:,:))
           ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + &
              ( q(n,3)*q(n,1)*phase(n,1,3) + q(n,3)*q(n,2)*phase(n,2,3)     &
              - q(n,1)*q(n,1)*phase(n,3,3) - q(n,2)*q(n,2)*phase(n,3,3) ) * &
              conjg(unique_ft_ints(uf+n,:,:))
        end
     end
     phase.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S=sigma/2 operator, and g_e x mu_B = 1.
     do n = 1,n_refl
       ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
     end
     q.destroy
   end

   sum_PND_nabla_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform nabla_a_3 integrals "ft_ints", required for the
   ! PND magnetic structure factors, from a sum of "unique_ft_ints".
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
     ft_ints :: MAT3{CPX}
     unique_ft_ints :: MAT4{CPX}, IN
     phase :: MAT3{CPX}*
     q :: MAT{REAL}*
     u,uf,n,n_refl :: INT
     n_refl = .data.reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
     q.create(n_refl,3)
     phase.create(n_refl,3,3)
     .make_k_pts(q)
     ft_ints = ZERO
     do u = 1,.n_unique_SF_symops
       uf = n_refl*(u-1)
       .make_phased_matrix_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + &
          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*unique_ft_ints(uf+n,:,:,1) + &
          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*unique_ft_ints(uf+n,:,:,2) + &
          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*unique_ft_ints(uf+n,:,:,3)
       end
       if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle ! for inversions ...
       .make_phased_matrix_for_symop(u,phase,.translated_symop) ! .inverted_symop here ??????????????
       do n = 1,n_refl
         ft_ints(n,:,:) = ft_ints(n,:,:) + &
          (q(n,1)*phase(n,2,1)-q(n,2)*phase(n,1,1))*conjg(unique_ft_ints(uf+n,:,:,1)) + &
          (q(n,1)*phase(n,2,2)-q(n,2)*phase(n,1,2))*conjg(unique_ft_ints(uf+n,:,:,2)) + &
          (q(n,1)*phase(n,2,3)-q(n,2)*phase(n,1,3))*conjg(unique_ft_ints(uf+n,:,:,3))
       end
     end
     phase.destroy
     ! The factor of 2 to convert to Bohr magnetons cancels the factor
     ! of 1/2 for the Bohr magneton.
     do n = 1,n_refl
       ft_ints(n,:,:) = ft_ints(n,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
     end
     q.destroy
   end

   sum_ft_spin_ints(ft_ints,unique_ft_ints)
   ! Form the Fourier transform integrals "ft_ints", required for the spin
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  Dimensions of ft_ints are
   ! [.n_refl,n_comp_a,n_comp_b,3,3].
     ft_ints :: MAT5{CPX}
     unique_ft_ints :: MAT3{CPX}, IN
     phase :: VEC{CPX}*
     q :: MAT{REAL}*
     ints :: MAT{CPX}*
     u,uf,n,n_refl :: INT
     n_refl = .data.reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
     phase.create(n_refl)
     q.create(n_refl,3)
     ints.create(size(ft_ints,2),size(ft_ints,3))
     .make_k_pts(q)
     ft_ints = ZERO
     do u = 1,.n_unique_SF_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ints = phase(n)*unique_ft_ints(uf+n,:,:)
         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
       end
       if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle ! for inversions...
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         ints = phase(n)*conjg(unique_ft_ints(uf+n,:,:))
         ft_ints(n,:,:,1,1) = ft_ints(n,:,:,1,1) + q(n,1)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,2,1) = ft_ints(n,:,:,2,1) + q(n,2)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,2,2) = ft_ints(n,:,:,2,2) + q(n,2)*q(n,2)*ints(:,:)
         ft_ints(n,:,:,3,1) = ft_ints(n,:,:,3,1) + q(n,3)*q(n,1)*ints(:,:)
         ft_ints(n,:,:,3,2) = ft_ints(n,:,:,3,2) + q(n,3)*q(n,2)*ints(:,:)
         ft_ints(n,:,:,3,3) = ft_ints(n,:,:,3,3) + q(n,3)*q(n,3)*ints(:,:)
       end
     end
     ints.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S operator
     do n = 1,n_refl
        ft_ints(n,:,:,:,:) = -ft_ints(n,:,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
     end
     q.destroy
     phase.destroy
   end

   sum_ft_r_ints(ft_ints,unique_ft_ints,B)
   ! Form the Fourier transform dipole integrals "ft_ints", required for the PND
   ! magnetic structure factors, from a sum of the list of unique structure
   ! factor intergals "unique_ft_ints".  "B" is the external magnetic field.
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Dimensions of ft are [.n_refl,n_comp_a,n_comp_b,3].
     ft_ints :: MAT4{CPX}
     unique_ft_ints :: MAT4{CPX}, IN
     B :: VEC{REAL}(3)
     phase :: VEC{CPX}*
     q :: MAT{REAL}*
     ints :: MAT3{CPX}*
     u,uf,n,n_refl :: INT
     ci :: CPX
     n_refl = .data.reflections.n_refl
     ENSURE( size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
     phase.create(n_refl)
     q.create(n_refl,3)
     ints.create(size(ft_ints,2),size(ft_ints,3),3)
     .make_k_pts(q)
     ft_ints = ZERO
     do u = 1,.n_unique_SF_symops
       uf = n_refl*(u-1)
       .make_phases_for_symop(u,phase,.translated_symop)
       do n = 1,n_refl
         ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
       end
       if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle ! for inversions ...
       .make_phases_for_symop(u,phase,.inverted_symop)
       do n = 1,n_refl
         ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
         ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1)) &
                                             - q(n,3)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3))
         ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2)) &
                                             - q(n,1)*(B(1)*ints(:,:,2)-B(2)*ints(:,:,1))
         ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*(B(3)*ints(:,:,1)-B(1)*ints(:,:,3)) &
                                             - q(n,2)*(B(2)*ints(:,:,3)-B(3)*ints(:,:,2))
       end
     end
     ints.destroy
     ! The factor of two for conversion to Bohr magnetons cancels the
     ! factor of half for the S operator
     ci = (ZERO,ONE)
     do n = 1,n_refl
       ft_ints(n,:,:,:) = -ci*ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
     end
     q.destroy
     phase.destroy
   end

   sum_ft_nabla_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform nabla_a integrals "ft_ints", required for the
   ! PND magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
      ft_ints :: MAT4{CPX}
      unique_ft_ints :: MAT4{CPX}, IN
      phase :: VEC{CPX}*
      q :: MAT{REAL}*
      ints :: MAT3{CPX}*
      u,uf,n,n_refl :: INT
      n_refl = .data.reflections.n_refl
      ENSURE(size(ft_ints,1)==n_refl,"wrong size for ft_ints!")
      phase.create(n_refl)
      q.create(n_refl,3)
      ints.create(size(ft_ints,2),size(ft_ints,3),3)
      .make_k_pts(q)
      ft_ints = ZERO
      do u = 1,.n_unique_SF_symops
         uf = n_refl*(u-1)
         .make_phases_for_symop(u,phase,.translated_symop)
         do n = 1,n_refl
            ints = phase(n)*unique_ft_ints(uf+n,:,:,:)
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
         if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle ! for inversions ...
         .make_phases_for_symop(u,phase,.inverted_symop)
         do n = 1,n_refl
            ints = -phase(n)*conjg(unique_ft_ints(uf+n,:,:,:)) ! note minus sign
            ft_ints(n,:,:,1) = ft_ints(n,:,:,1) + q(n,2)*ints(:,:,3)-q(n,3)*ints(:,:,2)
            ft_ints(n,:,:,2) = ft_ints(n,:,:,2) + q(n,3)*ints(:,:,1)-q(n,1)*ints(:,:,3)
            ft_ints(n,:,:,3) = ft_ints(n,:,:,3) + q(n,1)*ints(:,:,2)-q(n,2)*ints(:,:,1)
         end
      end
      ints.destroy
      ! The factor of 2 to convert to Bohr magnetons cancels the factor
      ! of 1/2 for the Bohr magneton
      ! Extra minus sign introduced, but not sure why ...
      ! Reversed minus sign introduced ...
      do n = 1,n_refl
          ft_ints(n,:,:,:) = ft_ints(n,:,:,:)/(q(n,1)*q(n,1)+q(n,2)*q(n,2))
      end
      q.destroy
      phase.destroy
   end

   sum_ft_j_ints(ft_ints,unique_ft_ints)
   ! Form the fourier transform j integrals "ft_ints", required for the PND
   ! magnetic striucture factors, from a sum of "unique_ft_ints".
   ! Note: only inversions are allowed as symmetry elements for PND simulations.
   ! Note: the complex conjugate nabla_b integrals are not included.
   ! Dimensions of ft_ints are [.n_refl,n_comp_a,n_comp_b,3].
     ft_ints :: MAT4{CPX}
     unique_ft_ints :: MAT4{CPX}, IN
     phase :: VEC{CPX}*
     u,uf, n,n_refl :: INT
     n_refl = .data.reflections.n_refl
     ENSURE(size(ft_ints,1)==n_refl,"incorrect size for array ft_ints")
     phase.create(n_refl)
     ft_ints = ZERO
     do u = 1,.n_unique_SF_symops
        uf = n_refl*(u-1)
        .make_phases_for_symop(u,phase,.translated_symop)
        do n = 1,n_refl
          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) + phase(n)*unique_ft_ints(uf+n,:,:,:)
        end
        if ( all(.inverted_symop/=.unique_SF_symop(u)) ) cycle ! for inversions...
        .make_phases_for_symop(u,phase,.inverted_symop)
        do n = 1,n_refl
          ft_ints(n,:,:,:) = ft_ints(n,:,:,:) - phase(n)*conjg(unique_ft_ints(uf+n,:,:,:))
        end
     end
     phase.destroy
   end

!  *****************************************
!  Reduced group, Unique operators, Z number
!  *****************************************

   make_fragment_data(atom) ::: leaky
   ! This routine makes a multitude of mapping arrays that relate a given set
   ! fragment "atom" list, or the asymmetric cell atoms, to the unit cell atoms,
   ! or fragment cell atoms which are generated by symmetry; and it may store
   ! the related symmetry operations and unique atoms.  Particularly important
   ! for structure factor calculations are whether certain operations are
   ! inversions or translations, since this can save a lot of work. This latter
   ! things now have nothing to do with fragment stuff but are placed in
   ! here anyway; they should probably be shifted to the spacegroup module.
   ! The ".asymmetric_unit_geometry" is quite important here; it is normally read
   ! in from a CIF file, but if it does not exist it will be created from the
   ! fragment "atom" list. Once created it is never destroyed unless explicitly
   ! requested. Thus, when inputting crystal information it is important that
   ! the crystal information comes before the atom list information.
   ! NOTE: if ".prune_asymmetric_unit" is TRUE then any non-unique atoms in the
   ! ".asymmetric_unit_geometry" are removed. NOTE: this is probably not what
   ! you want for Hirshfeld surface calcs, but it may be what you want when
   ! processing CIF files with possibly overcomplete asymmetric units.
      self :: PTR
      atom :: VEC{ATOM}, IN
 ! col :: VEC{INT}*
      if (NOT .spacegroup.analysed) return
      if (.fragment_info_made) .destroy_fragment_data
      .n_fragment_atoms = size(atom)
      .fragment_geometry.create(3,.n_fragment_atoms)
      atom.get_geometry(.fragment_geometry)
      .unit_cell.change_into_fractional(.fragment_geometry)
    ! .make_reduced_symops         ! These don't seem to be used
    ! .make_cluster_symops
      .make_inverted_symops        ! These are used to save time in SF calcs
      .make_translated_symops
      .make_unique_SF_symops
      .make_unique_frag_atoms      ! See if we have an asymmetric fragment
      .make_fragment_atom_shifts 
      .make_fragment_cell_geometry ! These are to get full unit cell geoms
 ! .put_fragment_cell_geometry
      if (.asymmetric_unit_geometry.destroyed) .make_asymmetric_geometry 
      .make_unit_cell_geometry(.prune_asymmetric_unit)
 ! .put_unit_cell_geometry
 ! col.create(.n_unit_cell_atoms)
 ! .unit_cell_geometry.compare_columns_with(.fragment_cell_geometry,col) 
 ! stdout.text("compare cols:")
 ! stdout.put(col,"column")
      .make_frag_cell_for_unit_cell
      .make_repetition_factors     ! Rep. factors for SF calculations
      .Z = .z_factor(atom)
      .fragment_info_made = TRUE
   end

   z_factor(atom) result (res)
   ! The Z crystallographic factor for ".fragment_geometry", defined as the
   ! ratio of the number of electrons in the unit cell on the number of
   ! electrons in the fragment. Hence, we require information for each "atom" in
   ! the fragment.
      atom :: VEC{ATOM}, IN
      res :: REAL
   ENSURE(.frag_atom_for_frag_cell_atom.created,"no frag_atom_for_frag_cell_atom array")
      u,f :: REAL
      n,a :: INT
      u = ZERO
      do n = 1,.n_fragment_cell_atoms
         a = .frag_atom_for_frag_cell_atom(n)
         u = u + atom(a).atomic_number
      end
      f = ZERO
      do n = 1,.n_fragment_atoms
         f = f + atom(n).atomic_number
      end
      res = u/f
   end

!   make_reduced_symops ::: leaky, private
!   ! Make a list of the indices of the Seitz matrices, ".reduced_symop", which
!   ! will generate different geometries from that in ".fragment_geometry" when
!   ! both the original and transformed geometries are converted to unit cell
!   ! coordinates.  ".n_reduced_symops" is set to the number of these reduced
!   ! symmetry operations.
!      gi,gu :: MAT{REAL}*
!      i,j,u, n :: INT
!      identical :: BIN
!      gi.create(3,.n_fragment_atoms)
!      gu.create(3,.n_fragment_atoms)
!      .reduced_symop.create(.spacegroup.n_seitz)
!      n = 1
!      .reduced_symop(1) = 1
!      do i = 2,.spacegroup.n_seitz
!         gi = .fragment_geometry
!         .transform_geometry(gi,i,to_unit_cell=TRUE)
!         do j = 1,n                            ! Loop over reduced symops
!            gu = .fragment_geometry
!            u = .reduced_symop(j)
!            .transform_geometry(gu,u,to_unit_cell=TRUE)
!            identical  = .is_same_geometry(gi,gu)
!            if (identical) exit
!         end
!         if (NOT identical) then
!            n = n + 1
!            .reduced_symop(n) = i
!         end
!      end
!      .n_reduced_symops = n
!      .reduced_symop.shrink(n)
!      gu.destroy
!      gi.destroy
!   end

!   make_cluster_symops ::: leaky, private
!   ! Make a list of the indices of the Seitz matrices, ".cluster_symop", which
!   ! will generate different geometries from that in ".fragment_geometry".
!   ! This routine is the same as make_reduced_symops except that the geometries
!   ! are *not* converted to unit cell coordinates.  ".n_cluster_symops" is set
!   ! to the number of these symmetry operations.  These operators are useful for
!   ! generating clusters of this fragment. NOTE: the unit operator, element 1,
!   ! is part of the set of cluster_symops.
!      gi,gu :: MAT{REAL}*
!      i,j,u, n :: INT
!      identical :: BIN
!      gi.create(3,.n_fragment_atoms)
!      gu.create(3,.n_fragment_atoms)
!      .cluster_symop.create(.spacegroup.n_seitz)
!      n = 1
!      .cluster_symop(1) = 1
!      do i = 2,.spacegroup.n_seitz
!         gi = .fragment_geometry
!         .transform_geometry(gi,i)
!         do j = 1,n                       ! Loop over cluster symops
!            gu = .fragment_geometry
!            u = .cluster_symop(j)
!            .transform_geometry(gu,u)
!            identical  = .is_same_geometry(gi,gu)
!            if (identical) exit
!         end
!         if (NOT identical) then
!            n = n + 1
!            .cluster_symop(n) = i
!         end
!      end
!      .n_cluster_symops = n
!      .cluster_symop.shrink(n)
!      gu.destroy
!      gi.destroy
!   end

   make_inverted_symops ::: leaky, private
   ! Determine which of the Seitz symops generate geometries which are related
   ! by inversion. Really, we should check the cartesian seitz matrices, but and
   ! inversion is just -1 times the identity, to the cartesian inversion
   ! operator is just the same as the crystal-axis inversion operator, with -1
   ! down the diagonal.
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
      n,i,j :: INT
      inverted :: BIN
      .inverted_symop.create(.spacegroup.n_seitz)
      .inverted_symop = 0
      n = 0
      do i = 2,.spacegroup.n_seitz
         do j = 1,i-1
            inverted = .spacegroup.seitz(1:3,1:3,i).equals( &
                      -.spacegroup.seitz(1:3,1:3,j))
            if (inverted) then
               n = n + 1
               .inverted_symop(i) = j
               exit
            end
         end
      end
      .n_inverted_symops = n
   end

   make_translated_symops ::: leaky, private
   ! Determine which of the Seitz symops generate geometries which are related
   ! by translation, (including translation by the zero vector), but not
   ! inversion. Really we should check the cartesian seitz operators, but the
   ! identity oprator has the same representation in either the crystal or
   ! cartesian axis systems.
   ENSURE(.inverted_symop.created,"no inverted_symop array")
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
      i,j :: INT
      translated :: BIN
      .translated_symop.create(.spacegroup.n_seitz)
      .translated_symop = 0
      do i = 1,.spacegroup.n_seitz
         .translated_symop(i) = i
         if (.inverted_symop(i)>0) cycle
         do j = 1,i-1
            translated = .spacegroup.seitz(1:3,1:3,i).equals( &
                         .spacegroup.seitz(1:3,1:3,j) )
            if (translated) then
               .translated_symop(i) = j
               exit
            end
         end
      end
   end

   make_unique_SF_symops ::: leaky, private
   ! Determine which are the structure-factor unique symops, i.e. those which
   ! generate fragment geometries which are different than a translation or
   ! inversion. This list should be a superset of the reduced symops.
   ENSURE(.inverted_symop.created,  "no inverted_symop array")
   ENSURE(.translated_symop.created,"no translated_symop array")
      n,i :: INT
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle ! Only true translations count
         n = n + 1
      end
      .n_unique_SF_symops = n
      .unique_SF_symop.create(n)
      n = 0
      do i = 1,.spacegroup.n_seitz
         if (.inverted_symop(i)>0) cycle
         if (.translated_symop(i)<i) cycle
         n = n + 1
         .unique_SF_symop(n) = i
      end
   end

   is_same_geometry(geom_i,geom_j) result(res) ::: private
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional
   ! coordinates are the same, exactly.
      geom_i,geom_j :: MAT{REAL}
      res :: BIN
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
   ENSURE(geom_i.dim1==3,"incorrect size for array geom_i")
   ENSURE(geom_j.dim1==3,"incorrect size for array geom_j")
   ENSURE(geom_i.dim2==geom_j.dim2,"incompatible sizes for geom_i, geom_j")
      i,j,n_atom :: INT
      skip :: VEC{BIN}*
      same :: BIN
      tol :: REAL
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      n_atom = geom_i.dim2
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom
         do j = 1,n_atom
            same = geom_i(:,i).same_as(geom_j(:,j),tol)
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
   end

   make_unique_frag_atoms ::: leaky, private
   ! Make a list of the symmetry unique atoms in the ".fragment_geometry". The
   ! atoms in ".fragment_geometry" are first put to the unit cell; then we
   ! transform each of them in turn by all the symmetry operations (placing them
   ! back into the unit cell, if necessary) and accumulating only the unique
   ! ones.
   ENSURE(.fragment_geometry.created, "no fragment_geometry")
      fragment_geometry :: MAT{REAL}*
      pa :: VEC{REAL}(3)
      sh :: VEC{INT}(3)
      u,a,s,col :: INT
      found :: BIN
      tol :: REAL
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      .unique_atom_for_frag_atom.create(.n_fragment_atoms)
      .unique_atom_for_frag_atom    = 0
      .unique_atom_for_frag_atom(1) = 1
      .unique_frag_atom.create(1)
      .unique_frag_atom(1) = 1
      .unique_symop_for_frag_atom.create(.n_fragment_atoms)
      .unique_symop_for_frag_atom = 1
      pa = .fragment_geometry(:,1)
      .transform_position(pa,1,to_unit_cell=TRUE,unit_cell_shift=sh)
      .unique_shift_for_frag_atom.create(3,.n_fragment_atoms)
      .unique_shift_for_frag_atom(:,1) = sh
      fragment_geometry.create_copy(.fragment_geometry)
      .put_to_unit_cell(fragment_geometry)
      u = 1
      do a = 2,.n_fragment_atoms
         found = FALSE
         do s = 1,.spacegroup.n_seitz
            pa = .fragment_geometry(:,a)
            ! .put_to_unit_cell(pa)
            .transform_position(pa,s,to_unit_cell=TRUE,unit_cell_shift=sh)
            found = fragment_geometry(:,.unique_frag_atom).has_column(pa,tol,col)
            if (.unique_atom_for_frag_atom(a)==0 AND found) then
               .unique_atom_for_frag_atom(a) = col
               .unique_symop_for_frag_atom(a) = s
               .unique_shift_for_frag_atom(:,a) = sh
               exit
            end
         end
         if (found) cycle
         u = u + 1 ! new unique atom
         .unique_atom_for_frag_atom(a) = u
         .unique_frag_atom.append(a)
      end
      fragment_geometry.destroy
      .n_unique_frag_atoms = u
   end

   make_fragment_atom_shifts ::: leaky, private
   ! Make the shifts required to transform the fragment atoms to the unit cell.
   ! These will normally all be zero.
   ENSURE(.fragment_geometry.created,"no fragment_geometry")
      pa :: VEC{REAL}(3)
      sh :: VEC{INT}(3)
      a :: INT
      do a = 1,.n_fragment_atoms ! then loop over fragment atoms
         pa = .fragment_geometry(:,a) 
         .put_to_unit_cell(pa,shift=sh)
         .shift_for_frag_atom.append_column(sh)
      end
   end

   make_fragment_cell_geometry ::: leaky, private
   ! Get the all the fragment atom positions in the unit cell,
   ! ".fragment_cell_geometry", given a (possibly) partial or overcomplete set
   ! for the cell in array ".fragment_geometry".
   ENSURE(.fragment_geometry.created,"no fragment_geometry")
      pa :: VEC{REAL}(3)
      sh :: VEC{INT}(3)
      n,a,s :: INT
      found :: BIN
      tol :: REAL
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      n = 0
      do s = 1,.spacegroup.n_seitz  ! NOTE: Loop over symops first
         do a = 1,.n_fragment_atoms ! then loop over fragment atoms
            pa = .fragment_geometry(:,a) 
            ! .put_to_unit_cell(pa) 
            .transform_position(pa,s,to_unit_cell=TRUE,unit_cell_shift=sh)
            if (.fragment_cell_geometry.destroyed) then
              found = FALSE
            else
              found = .fragment_cell_geometry.has_column(pa,tol)
            end
            if (found) cycle
            n = n + 1 ! new atom
            .frag_atom_for_frag_cell_atom.append(a)
            .symop_for_frag_cell_atom.append(s)
            .shift_for_frag_cell_atom.append_column(sh)
            .fragment_cell_geometry.append_column(pa)
         end
      end
      .n_fragment_cell_atoms = n
      ENSURE(.fragment_cell_geometry.created,"could not make fragment_cell_geometry")
   end

   make_unit_cell_geometry(prune_asymmetric_unit) ::: leaky, private
   ! Get the all the atom positions in the unit cell, ".unit_cell_geometry" from
   ! the ".asymmetric_unit_geometry", if it is created. Also checks if the
   ! ".asymmetric_unit_geometry" is really an asymmetric unit! If
   ! "prune_asymmetric_unit" is present and true, any non-asymmetric unit atoms
   ! are eliminated.
      prune_asymmetric_unit :: BIN, optional
   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit geometry") 
   ENSURE(.n_asymmetric_unit_atoms>0,"no asymmetric unit atoms") 
      prune :: BIN
      pa :: VEC{REAL}(3)
      sh :: VEC{INT}(3)
      asymmetric_unit_geometry :: MAT{REAL}*
      n,a,m,s,col :: INT
      found,unique,disorder :: BIN
      tol :: REAL
      prune = FALSE
      if (present(prune_asymmetric_unit)) prune = prune_asymmetric_unit
      asymmetric_unit_geometry.create_copy(.asymmetric_unit_geometry)
      .put_to_unit_cell(asymmetric_unit_geometry)
      nullify(.unit_cell_geometry)
      tol = TOL(2)/maxval(.unit_cell.length) ! <--- getting this number wrong can stuff things
      tol = TOL(3)                           ! <--- getting this number wrong can stuff things
      disorder = FALSE
      n = 0
      a = 1
      do ! a = 1,.n_asymmetric_unit_atoms
         do s = 1,.spacegroup.n_seitz
            pa = asymmetric_unit_geometry(:,a)
            .transform_position(pa,s,to_unit_cell=TRUE,unit_cell_shift=sh)
            unique = NOT asymmetric_unit_geometry(:,a+1:).has_column(pa,tol,col)
            col = col + a
            if (NOT unique) then
               WARN("asymmetric unit atoms "//a.to_str.trim//" and "//col.to_str.trim//" are the same!")
               disorder = TRUE
               if (prune) then
                  do 
                     m = max(a,col) ! "col" will always be bigger, otherwise there may be problems
                     WARN("pruning atom "//m.to_str.trim//" from asymmetric unit atom list")
                     DIE_IF(col<a,"non-unique atom "//col.to_str.trim//" comes earlier in the list!")
                     .n_asymmetric_unit_atoms = .n_asymmetric_unit_atoms - 1
                     .asymmetric_unit_geometry(:,m:.n_asymmetric_unit_atoms) = .asymmetric_unit_geometry(:,m+1:)
                     .asymmetric_unit_geometry.shrink_columns(.n_asymmetric_unit_atoms)
                      asymmetric_unit_geometry(:,m:.n_asymmetric_unit_atoms) =  asymmetric_unit_geometry(:,m+1:)
                      asymmetric_unit_geometry.shrink_columns(.n_asymmetric_unit_atoms)
                     unique = NOT asymmetric_unit_geometry(:,a+1:).has_column(pa,tol,col)
                     col = col + a
                     if (unique) exit
                  end
                  WARN("There are now "//.n_asymmetric_unit_atoms.to_str.trim//" in the asymmetric unit")
               end
            end
            if (.unit_cell_geometry.destroyed) then; found = FALSE
            else;                                    found = .unit_cell_geometry.has_column(pa,tol)
            end
            if (found) cycle
            n = n + 1 ! new aymeetric atom
            .asym_atom_for_unit_cell_atom.append(a)
            .symop_for_unit_cell_atom.append(s)
            .shift_for_unit_cell_atom.append_column(sh)
            .unit_cell_geometry.append_column(pa)
         end
         a = a + 1
         if (a>.n_asymmetric_unit_atoms) exit
      end
      WARN_IF(disorder,"*** This structure may be disordered ***")
      .n_unit_cell_atoms = n
      asymmetric_unit_geometry.destroy
      ENSURE(.unit_cell_geometry.created,"could not make unit_cell_geometry")
   end

!   make_unit_cell_geometry(prune_asymmetric_unit) ::: leaky, private
!   ! Get the all the atom positions in the unit cell, ".unit_cell_geometry" from
!   ! the ".asymmetric_unit_geometry", if it is created. Also checks if the
!   ! ".asymmetric_unit_geometry" is really an asymmetric unit! If
!   ! "prune_asymmetric_unit" is present and true, any non-asymmetric unit atoms
!   ! are eliminated.
!      prune_asymmetric_unit :: BIN, optional
!   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit geometry") 
!      prune :: BIN
!      pa :: VEC{REAL}(3)
!      n,a,m,s,col :: INT
!      found,non_unique :: BIN
!      tol :: REAL
!      prune = FALSE
!      if (present(prune_asymmetric_unit)) prune = prune_asymmetric_unit
!      nullify(.unit_cell_geometry)
!      tol = TOL(3)/maxval(.unit_cell.length)
!      n = 0
!      a = 1
!      do ! a = 1,.n_asymmetric_unit_atoms
!         do s = 1,.spacegroup.n_seitz
!            pa = .asymmetric_unit_geometry(:,a)
!            .transform_position(pa,s,to_unit_cell=TRUE)
!            non_unique = .asymmetric_unit_geometry.has_column(pa,tol,col)
!            non_unique = non_unique AND col/=a
!            if (non_unique) then
!               WARN("asymmetric unit atoms "//a.to_str.trim//" and "//col.to_str.trim//" are the same!")
!               WARN("this may indicate a disordered asymmetric unit")
!               if (prune) then
!                  m = max(a,col) ! I think "col" will always be bigger, otherwise there may be problems
!                  WARN("pruning atom "//m.to_str.trim//" from asymmetric unit atom list")
!                  DIE_IF(col<a,"non-unique atom "//col.to_str.trim//" comes earlier in the list!")
!                  .n_asymmetric_unit_atoms = .n_asymmetric_unit_atoms - 1
!                  .asymmetric_unit_geometry(:,m:.n_asymmetric_unit_atoms) = .asymmetric_unit_geometry(:,m+1:)
!                  .asymmetric_unit_geometry.shrink_columns(.n_asymmetric_unit_atoms)
!                  exit
!               end 
!            end
!            if (.unit_cell_geometry.destroyed) then
!              found = FALSE
!            else
!              found = .unit_cell_geometry.has_column(pa,TOL(3))
!            end
!            if (NOT found) then
!               n = n + 1
!               if (n==1) then
!                 .atom_for_unit_cell_atom.create(1)
!                 .symop_for_unit_cell_atom.create(1)
!                 .unit_cell_geometry.create(3,1)
!               else
!                 .atom_for_unit_cell_atom.expand(n)
!                 .symop_for_unit_cell_atom.expand(n)
!                 .unit_cell_geometry.expand(3,n)
!               end
!               .atom_for_unit_cell_atom(n) = a
!               .symop_for_unit_cell_atom(n) = s
!               .unit_cell_geometry(:,n) = pa
!            end
!         end
!         a = a + 1
!         if (a>.n_asymmetric_unit_atoms) exit
!      end
!      .n_unit_cell_atoms = n
!      ENSURE(.unit_cell_geometry.created,"could not make unit_cell_geometry")
!   end

   make_frag_cell_for_unit_cell ::: leaky, private
   ! Make an array which maps the unit cell geometry positions into the fragment
   ! cell geometry positions.  This should only be used when the fragment cell
   ! geometry is the same as the unit cell geometry. It is used for crystal
   ! cluster calculations based on molecular fragments, and for extracting the
   ! asymmetric unit cell atoms from a given fragment geometry
   ENSURE(.unit_cell_geometry.created,"no unit cell geometry") 
   ENSURE(.fragment_cell_geometry.created,"no fragment cell geometry") 
   ENSURE(.n_asymmetric_unit_atoms>0,"no asymmetric unit atoms") 
      pu,pc :: VEC{REAL}(3)
      u,c,f,a :: INT
      found :: BIN
      tol :: REAL
      tol = TOL(2)/maxval(.unit_cell.length)
      tol = TOL(3)                        ! <--- getting this number wrong can stuff things
      .frag_cell_for_unit_cell_atom.create(.n_unit_cell_atoms)
      .frag_atom_for_unit_cell_atom.create(.n_unit_cell_atoms)
      .frag_atom_for_asym_unit_atom.create(.n_asymmetric_unit_atoms)
      .asym_unit_atom_for_frag_atom.create(.n_fragment_atoms)
      .unit_cell_atom_for_frag_atom.create(.n_fragment_atoms)
      .frag_cell_for_unit_cell_atom = 0
      .frag_atom_for_unit_cell_atom = 0
      .frag_atom_for_asym_unit_atom = 0
      .asym_unit_atom_for_frag_atom = 0
      .unit_cell_atom_for_frag_atom = 0
      do u = 1,.n_unit_cell_atoms
         pu = .unit_cell_geometry(:,u)
         found = FALSE
         do c = 1,.n_fragment_cell_atoms
            pc = .fragment_cell_geometry(:,c)
            found = pu.same_as(pc,tol)
            if (NOT found) cycle
            .frag_cell_for_unit_cell_atom(u) = c
            f = .frag_atom_for_frag_cell_atom(c)
            a = .asym_atom_for_unit_cell_atom(u)
            .frag_atom_for_unit_cell_atom(u) = f
            .unit_cell_atom_for_frag_atom(f) = u
            if (.frag_atom_for_asym_unit_atom(a)==0) &
                .frag_atom_for_asym_unit_atom(a) = f
            .asym_unit_atom_for_frag_atom(f) = a
            exit 
         end
         WARN_IF(NOT found,"unit cell atom "//u.to_str.trim//" was not found in the fragment cell")
      end
   end

   make_repetition_factors ::: leaky, private
   ! The number of times an atom with index "a" is mapped into itself under
   ! the reduced group is the ".repetition_factor(a)". It is used to correct
   ! structure factors for fragment geometries which are "oversampled" relative
   ! to the asymmetric cell geometry.
   ENSURE(.fragment_geometry.created, "no fragment_geometry!")
      pa,pb :: VEC{REAL}(3)
      a,b,n,n_same :: INT
      same :: BIN
      tol :: REAL
      if (.use_manual_repetition_factors) then
         ENSURE(.repetition_factor.created,"no repetiton_factors entered!")
      else
         tol = TOL(2)/maxval(.unit_cell.length)
         tol = TOL(3)                        ! <--- getting this number wrong can stuff things
         .repetition_factor.destroy
         .repetition_factor.create(.n_fragment_atoms)
         do a = 1,.n_fragment_atoms
            pa = .fragment_geometry(:,a)
            .put_to_unit_cell(pa)
            n_same = 0
            do b = 1,.n_fragment_atoms
            do n = 1,.spacegroup.n_seitz
               pb = .fragment_geometry(:,b)
               .transform_position(pb,n,to_unit_cell=TRUE)
               same = pa.same_as(pb,tol)
               if (same) n_same = n_same + 1
            end
            end
            .repetition_factor(a) = n_same
         end
      end
   end

   has_complete_fragment result (res)
   ! Returns TRUE if the the fragment cell and unit cells are equivalent i.e. if
   ! there are enough atoms in the fragment to generate the whole unit cell.
      res :: BIN
      res = .fragment_info_made AND .frag_cell_for_unit_cell_atom.created
      if (NOT res) return
      res = all(.frag_cell_for_unit_cell_atom>0)
   end

   transform_geometry(g,op,translate,ignore_glide,to_unit_cell)
   ! Transform the positions "g" in fractional coordinates with the
   ! Seitz operator with index "op". If present, "translate" will be
   ! added to the transformed position. If present and TRUE, "ignore_glide"
   ! will not add the glide vector part of the Seitz operator.
   ! If present and TRUE, "to_unit_cell" will translate the fractional
   ! coordinates into the (1,1,1) unit cell.
      g :: MAT{REAL}
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
   ENSURE(g.dim1==3,"incorrect size for array g")
      n :: INT
      do n = 1,g.dim2
         .transform_position(g(:,n),op,translate,ignore_glide,to_unit_cell)
      end
   end

   transform_position(p,op,translate,ignore_glide,to_unit_cell,unit_cell_shift) 
   ! Transform the position "p" in fractional coordinates with the Seitz
   ! operator with index "op". If present, "translate" will be added to the
   ! transformed position. If present and TRUE, "ignore_glide" will not add the
   ! glide vector part of the Seitz operator.  If present and TRUE,
   ! "to_unit_cell" will translate the fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell, and "unit_cell_shift" is set to the translation
   ! vector required to do this.
      p :: VEC{REAL}(3)
      op :: INT
      translate :: VEC{REAL}(3), optional
      ignore_glide,to_unit_cell :: BIN, optional
      unit_cell_shift :: VEC{INT}(3), optional
   ENSURE(.spacegroup.seitz.created,"Seitz matrices not initialised")
   ENSURE(op>0,"operator index out of bounds")
   ENSURE(op<=.spacegroup.n_seitz,"operator index out of bounds")
      ignore,to_cell :: BIN
      ignore = FALSE
      if (present(ignore_glide)) ignore = ignore_glide
      if (ignore) then
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p)
      else
        p = matmul(.spacegroup.seitz(1:3,1:3,op),p) + .spacegroup.seitz(1:3,4,op)
      end
      if (present(translate)) p = p + translate
      to_cell = FALSE
      if (present(to_unit_cell)) to_cell = to_unit_cell
      if (to_cell) .put_to_unit_cell(p,unit_cell_shift)
   end

   put_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell.  All atoms will be shifted into the first unit cell
   ! independently, so the resulting geometry may not reflect the shape of the
   ! original molecule.
      g :: MAT{REAL}
   ENSURE(g.dim1==3 OR g.dim2==3, "incorrect shape for array g")
      n :: INT
      if (g.dim1==3) then
         do n = 1,g.dim2
            .put_to_unit_cell(g(:,n))
         end
      else
         do n = 1,g.dim1
            .put_to_unit_cell(g(n,:))
         end
      end
   end

   put_to_unit_cell(p,shift)
   ! Transform the position "p" in fractional coordinates into the
   ! (0:1,0:1,0:1) unit cell. If present, "shift" is set to the translation
   ! vector needed to effect the change to the unit cell.
      p :: VEC{REAL}(3)
      shift :: VEC{INT}(3), optional
   ENSURE(size(p)==3, "p must be length 3")
      new :: VEC{REAL}(3)
      tol :: REAL
      i :: INT
    ! new = mod(p - floor(p) + TWO + TOL(3),ONE) - TOL(3)
    ! ! p(:)-floor(p(:))+TWO should make it positive.
      ! I changed this from above, so that now every coordinate having an
      ! integer values will map to zero i.e. the unit cell is 0<=x_i<1, i=1,3
      ! --dylan
    ! tol = TOL(4)/maxval(.unit_cell.length)
      tol = TOL(1)/maxval(.unit_cell.length)
      tol = TOL(3)
      do i = 1,3
         if (abs(p(i))<tol)       p(i) =   ZERO
         if (abs(p(i)-ONE)<tol)   p(i) =    ONE
         if (abs(p(i)+ONE)<tol)   p(i) =   -ONE
         if (abs(p(i)-TWO)<tol)   p(i) =    TWO 
         if (abs(p(i)+TWO)<tol)   p(i) =   -TWO 
         if (abs(p(i)-THREE)<tol) p(i) =  THREE 
         if (abs(p(i)+THREE)<tol) p(i) = -THREE
         if (abs(p(i)-FOUR)<tol)  p(i) =   FOUR
         if (abs(p(i)+FOUR)<tol)  p(i) =  -FOUR
      end
      new = p - floor(p)
      if (present(shift)) shift = nint(new - p)
      p = new
   end

   move_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the first
   ! lattice cell.  The shape of the molecule remains intact, so some of it
   ! may cross into other cells.  The center of the molecule will be in the
   ! first cell.
      g :: MAT{REAL}
      ENSURE(size(g,1)==3, "incorrect size for array g")
      n,n_atom :: INT
      centre :: VEC{INT}(3)
      n_atom = size(g,2)
      centre = .unit_cell_offset(g)
      do n = 1, n_atom
        g(:,n) = g(:,n) - centre
      end
   end

   unit_cell_offset(g) result(res)
   ! Which hkl indices match the centre of the fragment geometry "g" when
   ! expressed in crystal coordinates.  Usually we expect that it is 0,0,0 but
   ! not always.
      g :: MAT{REAL}
      res :: VEC{INT}(3)
   ENSURE(g.dim1==3, "incorrect size for array g")
      res = sum(g,dim=2)/g.dim2
   end

   fragment_width result(res)
   ! Return the width "res" of the fragment in each of the 3 axis directions.
      res :: VEC{REAL}(3)
   ENSURE(.fragment_geometry.created,"no fragment geometry")
      res = .fragment_geometry.max_abs_column_difference
   end

   cartesian_fragment_width result(res)
   ! Return the cartesian width "res" of the fragment in each of the three axis
   ! directions.
      res :: VEC{REAL}(3)
      res = .fragment_width
      .unit_cell.change_from_fractional(res)
   end

!   reduced_symop_mat(r) result (res) ::: private
!   ! Return the "r"-th reduced symop matrix in the unique list made by routine
!   ! ".make_reduced_symops".
!      res :: MAT{REAL}(3,3)
!      r :: INT
!   ENSURE(.reduced_symop.created,"no reduced_symops!")
!   ENSURE(r<=.n_reduced_symops,"symop index out of range")
!   ENSURE(r>0, "symop index out of range")
!      res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
!   end

   unique_SF_symop_mat(u) result (res) ::: private
   ! Return the "u"-th reduced symop matrix in the unique list made by routine
   ! ".make_reduced_symops".
      res :: MAT{REAL}(3,3)
      u :: INT
   ENSURE(.unique_SF_symop.created,"no unique_SF_symops!")
   ENSURE(u<=.n_unique_SF_symops,"symop index out of range")
   ENSURE(u>0,"symop index out of range")
      r :: INT
      r = .unique_SF_symop(u)
      res = .spacegroup.seitz(1:3,1:3,r)
   !  res = .spacegroup.seitz(1:3,1:3,.reduced_symop(r))
   end

   make_xyz_seitz_matrices(res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S_cartesian  =  D  S^_crystal  D^-1
   ! NOTE: I think they are not transposed any more ...
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
      i :: INT
      res.create(3,3,.spacegroup.n_seitz)
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end
   end

   xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S_cartesian  =  D  S^_crystal  D^-1
   ! NOTE: I think they are not transposed any more ...
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
      i :: INT
      res.create(3,3,.spacegroup.n_seitz)
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.direct_matrix, &
                      matmul(.spacegroup.seitz(1:3,1:3,i),.unit_cell.inverse_matrix))
      end
   end

   transposed_xyz_seitz_matrices result (res) ::: leaky
   ! Create and return a list of the 3x3 part of the seitz matrices
   ! in the cartesian axis system. NOTE: these are actually the
   ! *transpose* of the matrices in Hall's paper.
   !               S^T_cartesian  =  B  S^T_crystal  B^-1
   ! NOTE: I think they are not transposed any more ...
      res :: MAT3{REAL}*
   ENSURE(.spacegroup.seitz.created,"no Seitz matrices")
      i :: INT
      res.create(3,3,.spacegroup.n_seitz)
      do i = 1,.spacegroup.n_seitz
         res(:,:,i) = matmul(.unit_cell.reciprocal_matrix, &
                      matmul(transpose(.spacegroup.seitz(1:3,1:3,i)), &
                             transpose(.unit_cell.direct_matrix)))
      end
   end

!  *******************************************
!  No. of unique reflections, pruning, merging
!  *******************************************

!   n_equivalent_reflections result(res) 
!   ! The number of symmetry equivalent reflections, acording to the spacegroup.
!   ! Friedel pairs are counted as equivalent.
!   ! NOTE: this looks wrong, it looks like the number of NOT same reflections.
!     self :: IN
!     res :: INT
!   ENSURE(.data.created,"no diffraction data")
!   ENSURE(.data.reflections.created,"no reflection data")
!     i,j,g :: INT
!     p,q,r :: VEC{INT}(3)
!     same :: BIN
!     res = 1
!     do i = 2,.data.reflections.n_refl
!        p(1) = .data.reflections(i).h 
!        p(2) = .data.reflections(i).k 
!        p(3) = .data.reflections(i).l 
!        same = FALSE
!        main: do g = 1,.spacegroup.n_seitz
!           do j = 1,i-1
!              q(1) = .data.reflections(j).h 
!              q(2) = .data.reflections(j).k 
!              q(3) = .data.reflections(j).l 
!              r = nint(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
!              same = p.same_as(r) OR p.same_as(-r)
!              if (NOT same) cycle
!              exit main
!           end
!        end do main
!        if (NOT same) res = res + 1
!     end
!   end

   make_list_of_equivalents(list,n_unique) ::: leaky
   ! Make a list of the equivalent reflections. For each reflection i,
   ! list(i).element gives the list of equivalent reflections. If
   ! list(i).element has only one element and its index is less than i then we
   ! know it is an equivalent, and this index is the index of its equivalent.
     self :: IN
     list :: VEC{VEC_{INT}}*
     n_unique :: INT
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     i,j,g,n_refl :: INT
     p,q,r :: VEC{INT}(3)
     same :: BIN
     n_refl = .data.reflections.n_refl
     list.create(n_refl)
     list(1).element.append(1)
     n_unique = 1
     do i = 2,n_refl
        p(1) = .data.reflections(i).h 
        p(2) = .data.reflections(i).k 
        p(3) = .data.reflections(i).l 
        same = FALSE
        main: do g = 1,.spacegroup.n_seitz
           do j = 1,i-1
              q(1) = .data.reflections(j).h 
              q(2) = .data.reflections(j).k 
              q(3) = .data.reflections(j).l 
              r = nint(matmul(.spacegroup.seitz(1:3,1:3,g),q),kind=INT_KIND)
              same = p.same_as(r) OR p.same_as(-r)
              if (NOT same) cycle
              exit main
           end
        end do main
        if (same) then
           list(j).element.append(i)
           list(i).element.append(j)
        else
           n_unique = n_unique + 1
           list(i).element.append(i)
        end
     end
   end

   merge_equivalents ::: leaky
   ! This routine will merge this list of equivalents into a single reflections
   ! with a particular sigma value associated with it. WARNING: it assumes that
   ! there are a sufficient number of equivalents so that the sigma value can be
   ! calculated by the standard formula for the standard deviation.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     list :: VEC{VEC_{INT}}*
     reflections :: VEC{REFLECTION}*
     n_unique,n_refl,n,i :: INT
     n_refl = .data.reflections.n_refl
     .make_list_of_equivalents(list,n_unique)
     reflections.create(n_unique)
     n = 0
     do i = 1,n_refl
        if (list(i)[1]<i) cycle
        n = n + 1
     stdout.show("merged      = ",n)
     stdout.show("first       = ",i)
     stdout.show("equivalents =",list(i)[:])
        reflections(n) = .data.reflections(i)
        reflections(n).F_exp   = .data.reflections(list(i)[:]).F_exp.mean
        reflections(n).F_sigma = .data.reflections(list(i)[:]).F_exp.standard_deviation
     stdout.show("F_exp's      = ",.data.reflections(list(i)[:]).F_exp)
     stdout.show("new F_exp    = ",reflections(n).F_exp)
     stdout.show("new F_sigma  = ",reflections(n).F_sigma)
     end
     .data.reflections.destroy
     .data.reflections => reflections
     list.destroy
   end

   prune_bad_sigmas ::: leaky
   ! This routine will prune away all reflections with sigmas not within a
   ! certain limit.
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     low,high,val :: REAL
     i,dim :: INT
     i = 0
     loop: do 
        i = i + 1
        dim = .data.reflections.dim
        if (i>dim) exit
        low  = .data.F_sigma_min 
        high = .data.F_sigma_max
        val  = .data.reflections(i).F_sigma
        if (val>=low AND val<=high) cycle
        .data.reflections(i:dim-1) = .data.reflections(i+1:dim)
        .data.reflections.shrink(dim-1)
     end do loop
   end

   prune_negative_F_exp ::: leaky
   ! This routine will prune all negative F_exp values. (They are negative if
   ! the original F2 ws negative).
   ENSURE(.data.created,"no diffraction data")
   ENSURE(.data.reflections.created,"no reflection data")
     val :: REAL
     pruned :: BIN
     i,dim :: INT
     pruned = FALSE
     i = 0
     loop: do 
        i = i + 1
        dim = .data.reflections.dim
        if (i>dim) exit
        val  = .data.reflections(i).F_exp
        if (val>=.data.F_exp_min) cycle
        pruned = TRUE
        .data.reflections(i:dim-1) = .data.reflections(i+1:dim)
        .data.reflections.shrink(dim-1)
     end do loop
     WARN_IF(pruned,"negative structure factors have been pruned!")
   end

!  **************
!  Output methods
!  **************

   put(atom)
   ! Put out the crystal data to file "out"
      atom :: VEC{ATOM}, optional
      stdout.flush
      stdout.text("CRYSTAL information:")
      stdout.show("kind                        = ", .data_kind)
      .unit_cell.put
      .spacegroup.put
      .put_xyz_seitz
      if (.asymmetric_unit_geometry.created) .put_asymmetric_unit_geometry(atom)
      if (.unit_cell_geometry.created)       .put_unit_cell_geometry(atom)
      if (.fragment_geometry.created)        .put_fragment_data(atom)
      .put_reflection_data
   end

   put_xyz_seitz
   ! Put out the spacegroup seitz matrices.
   ENSURE(.spacegroup.n_seitz>0,"no seitz matrices")
      n :: INT
      seitz :: MAT3{REAL}*
      seitz => .xyz_seitz_matrices
      stdout.flush
      stdout.text("Cartesian (xyz) seitz matrices :")
      do n = 1,.spacegroup.n_seitz
        stdout.flush
        stdout.show("n = ",n)
        stdout.put(seitz(:,:,n))
      end
      seitz.destroy
   end

   put_asymmetric_unit_geometry(atom) ::: private
   ! Put out the asymmetric unit geometry. If present "atom" is assumed to be
   ! an unpruned asymmetric unit.
      atom :: VEC{ATOM}, optional
   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit atoms")
   ENSURE(.frag_atom_for_asym_unit_atom.created,"no frag_atom_for_asym_atom map")
      n,f :: INT
      symbol :: STR
      stdout.flush
      stdout.text("Crystal asymmetric unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do n = 1,.n_asymmetric_unit_atoms
         stdout.put(n)
         if (present(atom)) then
            f = .frag_atom_for_asym_unit_atom(n)
            if (f==0) then; symbol = "??"
            else;           symbol = atom(f).chemical_symbol
            end
            symbol = trim(symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         stdout.put(.asymmetric_unit_geometry(1,n))
         stdout.put(.asymmetric_unit_geometry(2,n))
         stdout.put(.asymmetric_unit_geometry(3,n))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_unit_cell_geometry(atom) ::: private
   ! Put out the unit_cell_geometry. If present, "atom" is assumed to be the
   ! list of fragment atoms.
      atom :: VEC{ATOM}, optional
   ENSURE(.unit_cell_geometry.created,"no unit_cell_geometry")
   ENSURE(.frag_atom_for_unit_cell_atom.created,"no frag_atom_for_unit_cell_atom map")
      n,u :: INT
      symbol :: STR
      stdout.flush
      stdout.text("Crystal unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do n = 1,.n_unit_cell_atoms
         stdout.put(n)
         if (present(atom)) then
            u = .frag_atom_for_unit_cell_atom(n)
            if (u==0) then; symbol = "??"
            else;           symbol = atom(u).chemical_symbol
            end
            symbol = trim(symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         stdout.put(.unit_cell_geometry(1,n))
         stdout.put(.unit_cell_geometry(2,n))
         stdout.put(.unit_cell_geometry(3,n))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

!  ********************************
!  Put Fragment related information
!  ********************************

   put_fragment_data(atom) ::: private
   ! Put fragment information to file "out". Optional "atom" list may
   ! be used to enhace output.
      atom :: VEC{ATOM}, optional
      stdout.flush
      stdout.text("Crystal fragment data:")
      stdout.flush
      stdout.show("No. of inputted atoms        = ",.n_fragment_atoms,real_width=TRUE)
      stdout.show("No. of fragment cell atoms   = ",.n_fragment_cell_atoms,real_width=TRUE)
      stdout.show("No. of unique fragment atoms = ",.n_unique_frag_atoms,real_width=TRUE)
      stdout.show("Z factor                     = ",.Z)
      stdout.flush
      stdout.show("Fragment partition model     = ",.partition_model)
      stdout.show("Thermal smearing model       = ",.thermal_smearing_model)
    ! .put_reduced_symop_data
      .put_inv_trans_symop_data
      .put_fragment_geometry(atom)
      .put_unique_fragment_geometry(atom)
      .put_fragment_cell_geometry(atom)
      .put_repetition_factors(atom)
   end

!   put_reduced_symop_data ::: private
!   ! Put out the reduced symop data
!   ENSURE(.fragment_geometry.created,"fragment_geometry?")
!   ENSURE(.unique_atom_for_frag_atom.created,"no unique_atom_for_frag_atom array!")
!      n,s :: INT
!      inverted,translated :: BIN
!      stdout.flush
!      stdout.text("Crystal fragment reduced group information:")
!      stdout.flush
!      stdout.text("NOTE: this table is NOT used any more in structure factor calculations")
!      stdout.flush
!      stdout.dash(int_fields=5)
!      stdout.put("Reduced",int_width=TRUE)
!      stdout.put("Seitz",int_width=TRUE)
!      stdout.put("Inv.",int_width=TRUE)
!      stdout.put("Trans.",int_width=TRUE)
!      stdout.flush
!      stdout.put("Symop",int_width=TRUE)
!      stdout.put("Symop",int_width=TRUE)
!      stdout.put("of?",int_width=TRUE)
!      stdout.put("of?",int_width=TRUE)
!      stdout.put("Unique?",int_width=TRUE)
!      stdout.flush
!      stdout.dash(int_fields=5)
!      do n = 1,.n_reduced_symops
!         stdout.put(n)
!         s = .reduced_symop(n)
!         stdout.put(s)
!         inverted = .inverted_symop(s)>0
!         if (inverted) then;   stdout.put(.inverted_symop(s))
!         else;                 stdout.tab(int_fields=1)
!         end
!         translated = .translated_symop(s)<n
!         stdout.put(.translated_symop(s))
!         if (inverted OR translated) then; stdout.put("No",int_width=TRUE)
!         else;                             stdout.put("Yes",int_width=TRUE)
!         end
!         stdout.flush
!      end
!      stdout.dash(int_fields=5)
!   end

   put_inv_trans_symop_data ::: private
   ! Put out the inverted translated symop data
   ENSURE(.fragment_geometry.created,"fragment_geometry?")
   ENSURE(.unique_atom_for_frag_atom.created,"no unique_atom_for_frag_atom array")
      n :: INT
      inverted,translated :: BIN
      stdout.flush
      stdout.text("Crystal Inversion/Translation related symop information:")
      stdout.flush
      stdout.text("NOTE: this table IS used in structure factor calculations")
      stdout.flush
      stdout.dash(int_fields=4)
      stdout.put("Seitz",int_width=TRUE)
      stdout.put("Inv.",int_width=TRUE)
      stdout.put("Trans.",int_width=TRUE)
      stdout.flush
      stdout.put("Symop",int_width=TRUE)
      stdout.put("of?",int_width=TRUE)
      stdout.put("of?",int_width=TRUE)
      stdout.put("Unique?",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=4)
      do n = 1,.spacegroup.n_seitz
         stdout.put(n)
         inverted = .inverted_symop(n)>0
         if (inverted) then;   stdout.put(.inverted_symop(n))
         else;                 stdout.tab(int_fields=1)
         end
         translated = .translated_symop(n)<n
         stdout.put(.translated_symop(n))
         if (inverted OR translated) then; stdout.put("No",int_width=TRUE)
         else;                             stdout.put("Yes",int_width=TRUE)
         end
         stdout.flush
      end
      stdout.dash(int_fields=4)
   end

   put_fragment_geometry(atom) ::: private
   ! Put out the fragment_geometry information
      atom :: VEC{ATOM}, optional
   ENSURE(.fragment_geometry.created,"fragment_geometry?")
   ENSURE(.unique_atom_for_frag_atom.created,"no unique_atom_for_frag_atom array")
      symbol :: STR
      n :: INT
      stdout.flush
      stdout.text("Crystal fragment geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Fragment",int_width=TRUE)
      stdout.put("Unique",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do n = 1,.n_fragment_atoms
         if (present(atom)) then
            symbol = trim(atom(n).chemical_symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         stdout.put(.unique_atom_for_frag_atom(n))
         stdout.put(.fragment_geometry(1,n))
         stdout.put(.fragment_geometry(2,n))
         stdout.put(.fragment_geometry(3,n))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_unique_fragment_geometry(atom) ::: private
   ! Put out the unique fragment_geometry information.  These are unique atoms
   ! in fragment_geometry, and so are not necessarily the same as the asymmetric
   ! unit atoms.
      atom :: VEC{ATOM}, optional
   ENSURE(.unique_frag_atom.created,"unique_frag_atoms?")
   ENSURE(.fragment_geometry.created,"fragment_geometry?")
      n,u :: INT
      symbol :: STR
      stdout.flush
      stdout.text("Crystal unique atom unit cell geometry:")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      stdout.put("Unique",int_width=TRUE)
      stdout.put("Fragment",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=3)
      do u = 1,.n_unique_frag_atoms
         stdout.put(u)
         n = .unique_frag_atom(u)
         if (present(atom)) then
            symbol = trim(atom(n).chemical_symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         stdout.put(.fragment_geometry(1,n))
         stdout.put(.fragment_geometry(2,n))
         stdout.put(.fragment_geometry(3,n))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=3)
   end

   put_fragment_cell_geometry(atom) ::: private
   ! Put out the full fragment cell geometry information
      atom :: VEC{ATOM}, optional
      n,f :: INT
      symbol :: STR
      stdout.flush
      stdout.text("Full fragment cell geometry:")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)
      stdout.put("Cell ",int_width=TRUE)
      stdout.put("Fragment",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("symop",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=3,real_fields=3)
      do n = 1,.n_fragment_cell_atoms
         stdout.put(n)
         f = .frag_atom_for_frag_cell_atom(n)
         if (present(atom)) then
            symbol = trim(atom(f).chemical_symbol) // " (" // trim(f.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(f)
         end
         stdout.put(.fragment_cell_geometry(1,n))
         stdout.put(.fragment_cell_geometry(2,n))
         stdout.put(.fragment_cell_geometry(3,n))
         stdout.put(.symop_for_frag_cell_atom(n))
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=3)
   end

   put_repetition_factors(atom) ::: private
   ! Put out the repetition factors
      atom :: VEC{ATOM}, optional
   ENSURE(.repetition_factor.created,"no repetition factors")
      n,rf :: INT
      symbol :: STR
      stdout.flush
      stdout.text("Crystal fragment atom repetition factors:")
      stdout.flush
      stdout.dash(int_fields=2)
      stdout.put("Fragment",int_width=TRUE)
      stdout.put("Rep.",int_width=TRUE)
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Factor",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=2)
      do n = 1,.n_fragment_atoms
         if (present(atom)) then
            symbol = trim(atom(n).chemical_symbol) // " (" // trim(n.to_str) // ")"
            stdout.put(symbol,int_width=TRUE)
         else
            stdout.put(n)
         end
         rf = .repetition_factor(n)
         stdout.put(rf)
         stdout.flush
      end
      stdout.dash(int_fields=2)
   end

!  **********************************
!  Put reflection related information
!  **********************************

   put_reflection_data
   ! Put out the reflection data to file "out".  Both Neutron and 
   ! X-ray will be put if present.
      stdout.flush
      if (.xray_data.created) then
        if (.xray_data.reflections.created) then  
        stdout.text("X-ray reflection data:")
        stdout.flush
        .xray_data.put_reflection_data
        stdout.flush
        end
      end  
      if (.pnd_data.created) then
        if (.pnd_data.reflections.created) then    
        stdout.text("Polarised neutron reflection data:")
        stdout.flush
        .pnd_data.put_reflection_data
        stdout.flush
        end
      end  
   end

   put_correction_data
   ! Output the correction data 
   ENSURE(.data_exists, "no diffraction data")
     .data.put_correction_data
   end

   put_F_calc
   ! Put the hkl Miller index triple followed by the calculated
   ! structure factor to add onto existing structure factors.
   ENSURE(.data_exists, "no diffraction data")
     .data.put_F_calc
   end

   put_PND_sf(name)
   ! outputs the polarised neutron structure factors
     name :: STR
   ENSURE(.data_exists, "no diffraction data")
     .data.put_PND_sf(name)
   end

!  ****************
!  Crystal Explorer
!  ****************

   put_CX(label,formula,spacegroup)
   ! Output some information for the Crystal Explorer program.
       label,formula,spacegroup :: STR
       .unit_cell.put_CX(label,formula,spacegroup)
   end

!  ******************
!  Put plots and maps
!  ******************

   put_fitting_plots
   ! Output all the fitting plot information
     .put_chi2_vs_angle_plot
     .put_fcalc_plots
     .put_qq_plot
     .put_labelled_qq_plot
   end

   put_chi2_vs_angle_plot
   ! Output a table with the chi^2 for the structure factor data set broken
   ! into sections.
   ! Reads from stdin the number of divisions in the plot.
   ENSURE(.data_exists,"no diffraction data")
     .data.put_chi2_vs_angle_plot
   end

   put_qq_plot
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.data_exists, "no diffraction data")
     .data.put_qq_plot
   end

   put_labelled_qq_plot
   ! Output a qq plot to the text file.
   ! It is a plot of the experimental quantile vs expected quantile.
   ENSURE(.data_exists, "no diffraction data")
     .data.put_labelled_qq_plot
   end

   put_fcalc_plots
   ! Output some different plots about the calculated structure factors.
   ENSURE(.data_exists, "no diffraction data")
     .data.put_fcalc_plots
   end

   make_crystal_error_map(map,pts)
   ! Make the crystal error "map" for the supplied points "pts" from the crystal
   ! structure factors
     map :: VEC{REAL}
     pts :: MAT{REAL}
   ENSURE(.data.created, "no diffraction data")
   ENSURE(.data.reflections.created, "no structure factors")
   ENSURE(.data.have_F_calc, "no calculated structure factors")
   ENSURE(.data.have_F_exp, "no experimental structure factors")
   ENSURE( size(pts,2)==3,  "incorrect dimension for points array")
     k :: MAT{REAL}*
     F,phase :: VEC{REAL}*
     n_pts,n_refl,n :: INT
     fac :: REAL
     n_pts = size(pts,1)
     n_refl = .data.reflections.n_refl
     k.create(n_refl,3); .make_k_pts(k)
     F.create(n_refl)
     F = (.data.reflections.F_exp - .data.reflections.F_pred)*sign(ONE,real(.data.reflections.F_calc))
     phase.create(n_refl)
     do n = 1,n_pts
        phase.to_product_of(k,pts(n,:))
        map(n) = sum(F*cos(phase))
     end
     fac = TWO/.unit_cell.volume
     map = fac*map
     phase.destroy
     F.destroy
     k.destroy
   end

!  *******************
!  Tests for existence
!  *******************

   reflection_data_exists result(res)
   ! Return TRUE if reflection data exists
     res :: BIN
     res = associated(.data.reflections)
   end

   data_exists result(res)
   ! Return TRUE if the diffraction data information exists
     res :: BIN
     res = associated(.data)
   end

   asymmetric_unit_exists result(res)
   ! Return TRUE if the asymmetric unit geometry information exists
     res :: BIN
     res = associated(.asymmetric_unit_geometry)
   end

   unit_cell_geometry_exists result(res)
   ! Return TRUE if the unit_cell_geometry information exists
     res :: BIN
     res = associated(.unit_cell_geometry)
   end

   fragment_data_exists result(res)
   ! Return TRUE if a fragment information exists
     res :: BIN
     res = associated(.fragment_geometry)
   end

!*******************************************************************************
!                     Inherited reflection routines
!*******************************************************************************

   n_refl result (res)
   ! The number of reflections
     res :: INT
   ENSURE(.data_exists, "no diffraction data")
     res = .data.n_refl
   end

   F_exp result (res)
   ! The experimental structure factors
     res :: VEC{REAL}(.data.reflections.dim)
   ENSURE(.data_exists, "no diffraction data")
     res = .data.F_exp
   end

   F_sigma result (res)
   ! The structure factor errors
     res :: VEC{REAL}(.data.reflections.dim)
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_sigma
   end

   F_calc result (res)
   ! The calculated structure factors
     res :: VEC{CPX}(.data.reflections.dim)
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_calc
   end

   F_chi2 result(res)
   ! Returns data
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"diffraction data not created")
     res = .data.F_chi2
   end

   F_goodness_of_fit result(res)
   ! Returns data
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_goodness_of_fit
   end

   F_r_factor result(res)
   ! Returns data
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_r_factor
   end

   F_weighted_r_factor result(res)
   ! Returns data
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"no diffraction data")
     res = .data.F_weighted_r_factor
   end

   set_F_calc(F_calc)
   ! Set the calculated structure factors
     F_calc :: VEC{CPX}, IN
   ENSURE(.data_exists,"no diffraction data")
     .data.set_F_calc(F_calc)
   end

   make_F_predicted
   ! Make the predicted magnitude of structure factors, including possibly
   ! an overall scale factor and extinction correction
   ENSURE(.data_exists,"no diffraction data")
     .data.make_F_predicted
   end

   extinction_correction result (res)
   ! Return the extinction correction  factors "res" to the calculated
   ! individual structure factors.
     res :: VEC{REAL}(.data.reflections.dim)
     res = .data.extinction_correction
   end

   n_param result(res)
   ! Returns number of independent parameters in model 
     self :: IN
     res :: INT
   ENSURE(.data_exists,"diffraction data not created")
     res = .data.n_param
   end

   partition_model result(res)
   ! Model for partitioning fragments of the molecule
     self :: IN
     res :: STR
     if (.data_exists) then
       res = .data.partition_model
     else 
       res = " "
     end  
   end

   thermal_smearing_model result(res)
   ! Thermal smearing model for ft integrals.  
     self :: IN
     res :: STR
     if (.data_exists) then
       res = .data.thermal_smearing_model
     else 
       res = " "
     end
   end

   correct_dispersion result(res)
   ! True if dispersion is to be corrected
     self :: IN
     res :: BIN
   ENSURE(.data_exists,"no diffraction data")
     res = .data.correct_dispersion
   end

   wavelength result(res)
   ! Experimental wavelength
     self :: IN
     res :: REAL
   ENSURE(.data_exists,"no diffraction data")
     res = .data.wavelength
   end

   optimise_extinction result(res)
   ! True if extinction is to be optimised
     self :: IN
     res :: BIN
   ENSURE(.data_exists,"no diffraction data")
     res = .data.optimise_extinction
   end

   optimise_scale result(res)
   ! True if an overall scale factor is to be optimised, for use in calculating
   ! F_pred
     self :: IN
     res :: BIN
   ENSURE(.data_exists,"no diffraction data")
     res = .data.optimise_scale
   end

   make_asymmetric_geometry ::: leaky
   ! Set the asymmetric geometry array from the ".unique_frag_atom" info.
   ! This should not be done if an ".asymmetric_unit_geometry" already exists!
   ENSURE(.asymmetric_unit_geometry.destroyed,"asymmetric unit already exists")
   ENSURE(.unique_frag_atom.created,"unique_frag_atom list does not exist")
     .asymmetric_unit_geometry.create(3,.n_unique_frag_atoms)
     .asymmetric_unit_geometry = .fragment_geometry(:,.unique_frag_atom)
     .n_asymmetric_unit_atoms = .n_unique_frag_atoms
   end

   xyz_asymmetric_unit_geometry result (res)
   ! Return the asymmetric unit geometry in cartesian coordinates.
      res :: MAT{REAL}(3,.n_asymmetric_unit_atoms)
   ENSURE(.asymmetric_unit_geometry.created,"no asymmetric unit")
      res = matmul(.unit_cell.direct_matrix,.asymmetric_unit_geometry)
   end

   simulate_new_F_exp
   ! Simulate a new experiment by adding normally distributed experimental
   ! errors the the F_exp.
   ENSURE(.data_exists,"no diffraction data")
     .data.simulate_new_F_exp
   end

end
