!---------------------------------------------------------------------------
!
!  MAT{INT}: Integer matrix operations ...
!
! Copyright (C) Dylan Jayatilaka, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module MAT{INT}

   implicit none

contains

! *****************
! Memory allocation
! *****************

   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given dimensions
      self :: PTR
      dim1,dim2 :: INT, IN
   end

   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the specified "bounds" for each dimension
      self :: PTR
      bounds :: VEC{INT}(2), IN
   end

   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given dimensions
      self :: PTR
      lb1,ub1,lb2,ub2 :: INT, IN
   end

   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the specified bounds for each dimension
      self :: PTR
      bounds1,bounds2 :: VEC{INT}, IN
   end

   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given bounds for all dimensions
      self :: PTR
      bounds :: MAT{INT}(2,2), IN
   end

   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a replica copy of matrix
      self :: PTR
      matrix :: MAT{INT}, IN
   end

   destroy ::: get_from(MAT{INTRINSIC}), leaky
   ! Destroy the object
      self :: PTR
   end

   created result(res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

! ****************************
! Size-of and shape operations 
! ****************************

   size result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the array
      res :: INT
   end

   dim1 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the 1st dimension
      res :: INT
   end

   dim2 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the 2nd dimension
      res :: INT
   end

   shape result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the shape of "self"
      res :: VEC{INT}(2)
   end

   is_same_shape_as(a) result(res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}), pure
   ! Returns TRUE if the matrix "a" has the same shape as "self"
      self :: IN
      a :: MAT{INT}, IN
      res :: BIN
   end

   is_transposed_shape_of(a) result(res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}), pure
   ! Returns TRUE if the matrix "a" is the transposed shape of self
      self :: IN
      a :: MAT{INT}, IN
      res :: BIN
   end

   is_square result(res) ::: get_from(MAT{INTRINSIC}), pure
   ! Returns TRUE if the matrix is square
      self :: IN
      res :: BIN
   end

! ***********************
! Shrinking and expansion
! ***********************

   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Shrinks self to dimension dim1xdim2.  Contents are retained.
     self :: PTR
     dim1,dim2 :: INT, IN
   end

   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Expands self to dimension dim1xdim2.  Contents are retained.
     self :: PTR
     dim1,dim2 :: INT, IN
   end

   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Shrinks columns of self to dimension dim2. Contents are retained.
     self :: PTR
     dim2 :: INT, IN
   end

   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Expands the columns self to dim2.  Contents are retained.
     self :: PTR
     dim2 :: INT, IN
   end

   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky
   ! Append the columns "cols" onto the end of self.
     self :: PTR
     cols :: MAT{INT}
   end

   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky
   ! Append the column "col" onto the end of self.
     self :: PTR
     col :: VEC{INT}
   end

! ********************
! Comparison functions
! ********************

   equals(b) result(res)
   ! Check if the matrix is the same as "b".
      self :: IN
      b :: MAT{INT}, IN
      res :: BIN
      res = .same_as(b)
   end

   same_as(b) result(res)
   ! Check if the matrix is the same as "b".
      self :: IN
      b :: MAT{INT}, IN
      res :: BIN
   ENSURE(.is_same_shape_as(b),"incompatible dimensions")
      res = all(self==b)
   end

! ****************
! Range operations
! ****************

   all_in_range(range) result(res) ::: get_from(MAT{INTRINSIC})
   ! Return TRUE if all values of self are within the specified "range".
      range :: VEC{INT}(2)
      res :: BIN
   end

   in_range(range) result(res) ::: get_from(MAT{INTRINSIC})
   ! Return element ij as TRUE if self(i,j) is within the specified "range".
      range :: VEC{INT}(2)
      res :: MAT{BIN}(.dim1,.dim2)
   end

   range result(res) ::: get_from(MAT{INTRINSIC})
   ! Return the range (smallest and largest value) of self.
      res :: VEC{INT}(2)
   end

! *****************
! Inquiry functions
! *****************

   is_diagonal result(res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is a diagonal matrix
      self :: IN
      res :: BIN
   end

   has_unit_diagonal result(res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has 1's as diagonal elements
      self :: IN
      res :: BIN
   end

   has_minus_unit_diagonal result(res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has -1's as diagonal elements
      self :: IN
      res :: BIN
   end

   is_unit_matrix result(res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is the unit matrix
      self :: IN
      res :: BIN
   end

   is_inversion_matrix result(res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is an inversion matrix
   ! i.e. minus the unit matrix
      self :: IN
      res :: BIN
   end

   is_symmetric result(res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is a symmetric matrix
      self :: IN
      res :: BIN
   end

   is_antisymmetric result(res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is an antisymmetric matrix
      self :: IN
      res :: BIN
   end

   is_zero result (res) 
   ! Return TRUE if "self" is the zero matrix, i.e. every element is zero.
      res :: BIN
      res = all(self==0)
   end

! *****************
! Column operations 
! *****************

   has_column(c,col) result(res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has a column "c".  If present, the
   ! matching column index "col" is also returned.
      self :: IN
      c :: VEC{INT}, IN
      col :: INT, optional
      res :: BIN
   end

   column_index(c) result(res) ::: get_from(MAT{INTRINSIC})
   ! The matching column index is returned, if the column matches "col".
      self :: IN
      c :: VEC{INT}, IN
      res :: INT
   end

   swap_columns(col1,col2) ::: get_from(MAT{INTRINSIC})
   ! Swap columns "col1" and "col2" of self
      col1,col2 :: INT, IN
   end

   swap_columns(list) ::: get_from(MAT{INTRINSIC})
   ! Sequentially swap all columns in a column "list",
   ! self(:,i)      = self(:,list(i))
   ! self(:,col(i)) = self(:,i)
      list :: VEC{INT}, IN
   end

   column_norms result(res) ::: get_from(MAT{INTRINSIC})
   ! Return the norms of every column
      res :: VEC{REAL}(.dim2)
   end

   get_column_norms(res) ::: get_from(MAT{INTRINSIC})
   ! Return the norms of every column
      res :: VEC{REAL}
   end

   get_column_dot_products(res) ::: get_from(MAT{INTRINSIC})
   ! Return the dot products of every column with itself.
   ! Good for testing distances without using a sqrt.
      res :: VEC{REAL}
   end

   index_of_minimum_column_norm(offset) result(res) ::: get_from(MAT{INTRINSIC})
   ! Return the column index of the column with the *minimum* norm. If present,
   ! "offset" is subtracted from every column beforehand, and then added back
   ! afterwards. This is useful for finding the index of the column with minimum
   ! distance to "offset", for a list of points held in "self".
      offset :: VEC{INT}(.dim1), optional
      res :: INT
   end

   max_abs_column_difference result(res) ::: get_from(MAT{INTRINSIC})
   ! Return the maximum of the absolute difference between all the column vector
   ! pairs of the matrix.
      res :: VEC{REAL}(.dim1)
   end

   mean_column_vector result(res) 
   ! Return the mean of the column vectors.
      res :: VEC{REAL}(.dim1)
      res = real(.sum_column_vectors)/.dim2
   end

   sum_column_vectors result(res) ::: get_from(MAT{INTRINSIC})
   ! Sum the column vectors (i.e. rows) in "self".
      res :: VEC{INT}(.dim1)
   end

   reverse_column_order ::: get_from(MAT{INTRINSIC})
   ! Reverse the order of the columns of self.
   end

! **************
! Row operations
! **************

   sum_row_vectors result(res) ::: get_from(MAT{INTRINSIC})
   ! Sum the row vectors (i.e. columns) in "self".
      res :: VEC{INT}(.dim2)
   end

! ******************************************
! Matrix algebra and vector space operations
! ******************************************

   determinant result(res) ::: get_from(MAT{INTRINSIC})
   ! Return the determinant a 3x3 matrix
      self :: IN
      res :: INT
   end

   cofactor result(res) ::: get_from(MAT{INTRINSIC}), leaky
   ! Return the cofactor of a 3x3 matrix
      self :: IN
      res :: MAT{INT}*
   end

   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{INT}, RES_TYPE=>INT)
   ! Multiply the matrix self by vector "l" on the left and vector "r" on the
   ! right ie:  res = l^dagger self r. Useful for non-unit metric dot_products.
     self :: IN
     l,r :: VEC{INT}, IN
     res :: INT
   end

   rotate(v) ::: get_from(MAT{INTRINSIC})
   ! Rotate vector "v" by self
     v :: VEC{INT}, INOUT
   end

   to_unit_matrix ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the unit matrix
   end

   to_inverse_unit_matrix
   ! Set self to the negative unit matrix
   ENSURE(.is_square,"non-square matrix")
      dim,i :: INT
      dim = .dim1
      self = 0
      do i = 1,dim
         self(i,i) = -1
      end
   end

   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})
   ! Set self to "a"
      a :: MAT{INT}, IN
   ENSURE(.is_same_shape_as(a),"incompatible shape")
   end

   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})
   ! Self becomes the transpose of "a"
     self :: OUT
     a :: MAT{INT}, IN
   end

   to_transpose ::: get_from(MAT{INTRINSIC})
   ! Self becomes its own transpose.
     self :: INOUT
   end

   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})
   ! Add to self the matrix "a"
      a :: MAT{INT}, IN
   end

   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})
   ! Subtract from self the matrix "a"
      a :: MAT{INT}, IN
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, FAC_TYPE=>INT)
   ! Set "self" to matrix "at" scaled by "fac"
      self :: OUT
      a :: MAT{INT}, IN
      fac :: INT, IN
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, FAC_TYPE=>INT)
   ! Add to "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: MAT{INT}, IN
      fac :: INT, IN
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, FAC_TYPE=>INT)
   ! Subtract from "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: A_TYPE, IN
      fac :: FAC_TYPE, IN
   end

   to_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{INT})
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
     self :: OUT
     a,b :: MAT{INT}, IN
     transpose_a, transpose_b :: BIN, optional, IN
   end

   plus_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{INT})
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
     self :: INOUT
     a,b :: MAT{INT}, IN
     transpose_a, transpose_b :: BIN, optional, IN
   end

   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{INT}, FAC_TYPE=>INT)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
     self :: OUT
     a,b :: MAT{INT}, IN
     fac :: INT
     transpose_a, transpose_b :: BIN, optional, IN
   end

   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{INT}, FAC_TYPE=>INT)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! neeb to be transposed.
     self :: INOUT
     a,b :: MAT{INT}, IN
     fac :: INT
     transpose_a, transpose_b :: BIN, optional, IN
   end

   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, DIAG_TYPE=>VEC{INT})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, ""transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      self :: INOUT
      a :: MAT{INT}, IN
      diag :: VEC{INT}, IN
      transpose_a :: BIN, optional, IN
   end

   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT}, DG_TYPE=>VEC{INT})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      self :: OUT
      dg :: VEC{INT}, IN
      a :: MAT{INT}, IN
      transpose_a :: BIN, optional, IN
   end

! ****************
! Trace operations
! ****************

   trace result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of self
      self :: IN
      res :: INT
   end

   trace_product_with(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{INT})
   ! Return the trace of the product of "self" with matrix "a".
      self :: IN
      a :: MAT{INT}, IN
      res :: INT
   end

   trace_product_with(a,b,c) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of the product of "self" with matrices "a", "b" and "c".
      a,b,c :: MAT{INT}
      res :: INT
   end

   trace_product_with(a,b,c,d,e) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of the product of "self" with matrices "a", "b" ... "e".
      a,b,c,d,e :: MAT{INT}
      res :: INT
   end

! **************************
! Operations on the diagonal
! **************************

   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{INT})
   ! Converts the diagonal vector "d" to matrix "self".
      d :: VEC{INT}
   end

   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{INT})
   ! Set the diagonal of "self" to th diagonal vector "d"
      d :: VEC{INT}
   end

   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>INT)
   ! Set the diagonal of "self" to "val"
      val :: INT
   end

   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC})
   ! Get the diagonal elements of "self" in vector "d"
      d :: VEC{INT}
   end

   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>INT)
   ! Add "val" to the diagonal of "self"
      val :: INT
   end

   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>INT)
   ! Weight the diagonal elements of "self" by "fac"
      fac :: INT, IN
   end

   zero_diagonal ::: get_from(MAT{INTRINSIC})
   ! Zero the diagonal elements of "self"
   ENSURE(.is_square,"non-square matrix")
   end

   zero_off_diagonal ::: get_from(MAT{INTRINSIC})
   ! Zero the off diagonal elements of "self"
   ENSURE(.is_square,"non-square matrix")
   end

   max_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})
   ! Get the maximum element on the diagonal of the matrix
      res :: INT
   end

   max_abs_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})
   ! Get the maximum absolute value of the diagonal elements of the self matrix
      res :: REAL
   end

! ************************
! Symmetrising and folding
! ************************

   symmetrize ::: get_from(MAT{INTRINSIC})
   ! Set self to half of itself plus half its transpose, i.e.
   ! self = 1/2 (self + self^T)
   end

   antisymmetrize ::: get_from(MAT{INTRINSIC})
   ! Set self to half of itself minus half its transpose, i.e.
   ! self = 1/2 (self - self^T)
   end

   symmetric_fold ::: get_from(MAT{INTRINSIC})
   ! Add the upper triangle of "self" into the lower triangle
   end

   antisymmetric_fold ::: get_from(MAT{INTRINSIC})
   ! Subtract the upper triangle of "self" into the lower triangle
   end

   symmetric_reflect ::: get_from(MAT{INTRINSIC})
   ! Make the upper triangle of "self" the same as the lower triangle
   end

   antisymmetric_reflect ::: get_from(MAT{INTRINSIC})
   ! Make the upper triangle of "self" the negative of the lower triangle and
   ! make the diagonal zero.
   end

   symmetric_fold_to_triangle(tr) ::: get_from(MAT{INTRINSIC})
   ! Add the upper triangle of "self" into the lower triangle and return
   ! the lower triangle "tr" as a vector across rows.
      tr :: VEC{INT}
   end

! **************************************
! Compression and uncompression routines
! **************************************

   compress_to_triangle(tr) ::: get_from(MAT{INTRINSIC})
   ! Converts the lower triangle of matrix self to the triangle "tr".
   ! using row order.
      self :: IN
      tr :: VEC{INT}
   end

   uncompress_from_triangle(tr) ::: get_from(MAT{INTRINSIC})
   ! Converts the triangle "tr" into the symmetric matrix "self".
      tr :: VEC{INT}
   end

   tri_size result (ltr) ::: get_from(MAT{INTRINSIC})
   ! Returns the size of the lower triangle needed to store self.
      self :: IN
      ltr :: INT
   end

! **********
! Misc stuff
! **********

   make_diagonally_dominant(permutation) ::: get_from(MAT{INTRINSIC})
   ! Rearrange the order of the columns of self so that the largest magnitude
   ! elements in each column occur along the diagonal. If "permutation" is
   ! present, it is the array which achieves this ordering, i.e. at the end of
   ! the routine, what is done is: self = self(:,permutation).
      permutation :: VEC{INT}, optional
   end

   to_gaussian_xyz_powers(l_max)
   ! Make "self(1:3,i)", the three xyz powers of all cartesian gaussian
   ! functions "i" of angular momentum up to "l_max", where "i" is the standard
   ! lexical index of the cartesian gaussian. (This routine essentially defines
   ! the standard order).  The shape of "self" is: [3, l_max.n_comp_sum ].
     self :: OUT
     l_max :: INT, IN
   ENSURE(.dim1==3,"wrong 1st dimension, self")
   ENSURE(.dim2==l_max.n_comp_sum,"wrong 2nd dimension, self")
     i,L,a,b,c :: INT
     i = 1          ! This is the total lexical index
     do L = 0,l_max ! Loop over all shells with momentum L
                    ! Loop over powers a, b, c
       do a = L,floor((L+2)*THIRD),-1
         do b = min(L-a,a),floor((L-a+1)*HALF),-1
           c = L-a-b
           if (a==b AND b==c) then
             self(:,i)   = [a,a,a]
             i = i+1
           else if (a>b AND b==c) then
             self(:,i)   = [a,b,b]
             self(:,i+1) = [b,a,b]
             self(:,i+2) = [b,b,a]
             i = i+3
           else if (a==b AND b>c) then
             self(:,i)   = [a,a,c]
             self(:,i+1) = [a,c,a]
             self(:,i+2) = [c,a,a]
             i = i+3
           else
             self(:,i)   = [a,b,c]
             self(:,i+1) = [a,c,b]
             self(:,i+2) = [b,a,c]
             self(:,i+3) = [c,a,b]
             self(:,i+4) = [b,c,a]
             self(:,i+5) = [c,b,a]
             i = i+6
           end
         end
       end
     end
   end

   to_gaussian_xyz_powers(l_max,index)
   ! Make "self(1:3,i)", the three xyz powers of all cartesian gaussian
   ! functions "i" of angular momentum up to "l_max", where "i" is the standard
   ! lexical index of the cartesian gaussian. (This routine essentially defines
   ! the standard order).  The shape of "self" is: [3, l_max.n_comp_sum ].
   ! Array "index" maps the three xyz powers of each cartesian gaussian back to
   ! its lexical index *within a shell of the same angular momentum* i.e. not
   ! the total lexical index. NOTE: "index" has lower bounds of 0, and so is
   ! passed as a pointer.
     self :: OUT
     l_max :: INT, IN
     index :: MAT3{INT}*
   ENSURE(self.dim1==3,"wrong 1st dimension, self")
   ENSURE(self.dim2==l_max.n_comp_sum,"wrong 2nd dimension, self")
   ENSURE(lbound(index,1)==0,"wrong lower bound, index")
   ENSURE(lbound(index,2)==0,"wrong lower bound, index")
   ENSURE(lbound(index,3)==0,"wrong lower bound, index")
   ENSURE(ubound(index,1)==l_max,"wrong upper bound, index")
   ENSURE(ubound(index,2)==l_max,"wrong upper bound, index")
   ENSURE(ubound(index,3)==l_max,"wrong upper bound, index")
     i,L,k,a,b,c :: INT
     i = 1              ! This is the total lexical index
     do L = 0,l_max     ! Loop over all shells with momentum L
       k = 1            ! This is the local shell lexical index
       !                  Loop over powers a, b, c
       do a = L,floor((L+2)*THIRD),-1
         do b = min(L-a,a),floor((L-a+1)*HALF),-1
           c = L-a-b
           if (a==b AND b==c) then
             self(:,i)   = [a,a,a]
             index(a,a,a) = k
             i = i+1
             k = k+1
           else if (a>b AND b==c) then
             self(:,i)   = [a,b,b]
             self(:,i+1) = [b,a,b]
             self(:,i+2) = [b,b,a]
             index(a,b,b) = k
             index(b,a,b) = k+1
             index(b,b,a) = k+2
             i = i+3
             k = k+3
           else if (a==b AND b>c) then
             self(:,i)   = [a,a,c]
             self(:,i+1) = [a,c,a]
             self(:,i+2) = [c,a,a]
             index(a,a,c) = k
             index(a,c,a) = k+1
             index(c,a,a) = k+2
             i = i+3
             k = k+3
           else
             self(:,i)   = [a,b,c]
             self(:,i+1) = [a,c,b]
             self(:,i+2) = [b,a,c]
             self(:,i+3) = [c,a,b]
             self(:,i+4) = [b,c,a]
             self(:,i+5) = [c,b,a]
             index(a,b,c) = k
             index(a,c,b) = k+1
             index(b,a,c) = k+2
             index(c,a,b) = k+3
             index(b,c,a) = k+4
             index(c,b,a) = k+5
             i = i+6
             k = k+6
           end
         end
       end
     end
   end

   bin_XY_data(X,Y,bin_side_length,data_count) ::: leaky
   ! Set self to a matrix whose ij-th element contains the number of data points
   ! [X(k),Y(k)] which lie in the ij-th bin. A bin is simply a range of values
   ! of side length "bin_side_length" covering the set of points from
   ! [X_min,Y_min] to [X_max,Y_max]. The dimension of self is calculated within
   ! this routine. If "data_count" is present, then the bin count associated
   ! with each data item [X(k),Y(k)] is returned in an array.
      self :: PTR
      X,Y :: VEC{REAL}, IN
      bin_side_length :: REAL, IN
      data_count :: VEC{INT}*, optional
   ENSURE(X.dim==Y.dim,"incompatible data points")
      X_min,X_max,X_mid,X_ran :: REAL
      Y_min,Y_max,Y_mid,Y_ran :: REAL
      X_range,Y_range :: VEC{REAL}(2)
      dim,n_X,n_Y,i,j,k :: INT
      dim = X.dim
      X_min = minval(X); Y_min = minval(Y)
      X_max = maxval(X); Y_max = maxval(Y)
      X_mid = HALF*(X_min+X_max)
      Y_mid = HALF*(Y_min+Y_max)
      X_ran = X_max-X_min
      Y_ran = Y_max-Y_min
      n_X = ceiling(X_ran/bin_side_length)
      n_Y = ceiling(Y_ran/bin_side_length)
      X_min = X_mid - (n_X/TWO)*bin_side_length
      Y_min = Y_mid - (n_Y/TWO)*bin_side_length
      X_ran = X_ran/n_X; Y_ran = Y_ran/n_Y
      ! Now do the binning ...
      self.create(n_X,n_Y)
      if (present(data_count)) data_count.create(dim)
      do i = 1,n_X
      do j = 1,n_Y
         X_range(1) = X_min + (i-1)*bin_side_length
         X_range(2) = X_range(1)  + bin_side_length
         Y_range(1) = Y_min + (j-1)*bin_side_length
         Y_range(2) = Y_range(1)  + bin_side_length
         self(i,j) = count(X.in_range(X_range) AND Y.in_range(Y_range))
         if (present(data_count)) then
         do k = 1,dim
            if (X(k).is_in_range(X_range) AND Y(k).is_in_range(Y_range)) then
            data_count(k) = self(i,j)
            end
         end
         end
      end
      end
   end

end
