!==============================================================================-
!
! MOLECULE.CE: CrystalExplorer related routines
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.main.foo 2881 2006-06-27 11:15:21Z dylan_ $
!==============================================================================-


module MOLECULE.CE

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

contains

! ================
! Crystal Explorer
! ================

   read_CIF ::: leaky
   ! Read in CIF information, reset name of Job to cif file name
      self :: PTR

      head :: STR

      if (.cif.destroyed) .cif.create
      .cif.read_keywords

      if (.cif.file_name/=" " AND .cif.data_block_name/=" ") then

         ! Reset name to the crystal data name
         head = .cif.file_name.filename_head
         .name = head.trim // "_" // .cif.data_block_name
         WARN("Job name has now been set to: "//.name.trim)

      end

   end

   read_CX_file_name 
   ! Read the CX file name
      stdin.read(.CX_file_name)
   end

   read_CX_uses_angstrom 
   ! Read whether CX should use angstroms
      stdin.read(.CX_uses_angstrom)
   end


   process_CIF ::: leaky
   ! Process a CIF file, and try to read crystal and atom information, either
   ! from the current ".cif.data_block_name", or from the first data block in
   ! the CIF file which is accetable.
   ENSURE(.cif.created,"no CIF object created")

      ! Find a data block name
      if (.cif.data_block_name==" ") then
         WARN("no CIF data block as specified, looking for first acceptable data block")
         .CE:find_CIF_crystal_data_block(.cif)
      end

      ! Find the data block
      MOLECULE.CE::open_CIF_at_data_block(.cif)

      ! Read in atoms of asymmetric unit
      .CE:read_CIF_atoms(.cif)   

      ! Read crystal info
      .CE:read_CIF_crystal(.cif) 

   end

   process_CIF_for_CX ::: leaky
   ! Process and entire .cif file by reading all acceptable data blocks (i.e.
   ! those with crystal and atom information) and then writing this information
   ! to a crystal explorer information file. 
      self :: PTR

   ENSURE(.CX_file_name/=" ","no CX file name")
   ENSURE(.cif.created,"no CIF object created")
   ENSURE(.cif.file_name/=" ","no CIF file name specified")

      found,CX_uses_angstrom :: BIN
      cif :: CIF*
      CX_file :: TEXTFILE*

      CX_file.create(.CX_file_name)
      CX_file.open(for="write")

      ! Save .cif outside of self, since it gets destroyed
      cif => .cif   
      nullify(.cif)

      do

         ! Loop ooooover crystal data blocks
         .CE:find_CIF_crystal_data_block(cif,found)
         if (NOT found) exit ! None left

         ! Read in asymmetric unit, and crystal info
         .CE:read_CIF_atoms(cif)            
         .CE:read_CIF_crystal(cif)

         ! Create the cluster
         .cluster.create(.crystal)
         .cluster.radius = ZERO       
         .cluster.generation_method = "fragment"
         .cluster.defragment = FALSE
         .cluster.make_info                   
         .cluster.put

         ! Write out the data
         .CE:put_CX_data(CX_file,cif)       
         CX_uses_angstrom  = .CX_uses_angstrom

         ! Destroy self, create from cif
         .destroy                             
         .create
         .CX_uses_angstrom = CX_uses_angstrom

         ! Next structure
         cif.start_of_data = cif.end_of_data  

      end

      ! Clean
      cif.destroy
      CX_file.destroy

   end

   find_CIF_crystal_data_block(cif,found) 
   ! Find the *first* block of crystal and atom information in the "cif" file
   ! (starting from line cif.start_of_data), and set the locator
   ! "cif.data_block_name".  The name of the molecule (job) is set to be the
   ! name of the cif file concatenated with the data block name.  
      cif :: CIF
      found :: BIN, optional, OUT
   ENSURE(cif.file.created,"no CIF file name")
   ENSURE(cif.file.name/=" ","no CIF file name")
      fnd :: BIN
      head :: STR
      head = cif.file.name.filename_head
      .name = head
      if (NOT cif.file.is_open) cif.open
      cif.find_crystal_data_block(fnd)
      if (present(found)) then
         found = fnd
         if (NOT found) return
      else 
         DIE_IF(NOT fnd,"couldn't find crystal data block")
      end
      .name = head.trim // "_" &
           // cif.data_block_name ! Set name to the crystal data name
      WARN("Job name has now been set to: "//.name.trim)
   end

   open_CIF_at_data_block(cif) ::: selfless, private
   ! Open the "cif" file with name "cif.file_name", and set it to the start of the
   ! data block with name "cif.data_block_name".
      cif :: CIF, PTR

   ENSURE(cif.created,"no CIF object created")
   ENSURE(cif.file_name/=" ","no CIF file name")
   ENSURE(cif.data_block_name/=" ","no CIF data block name")

      data_block_name :: STR

      data_block_name = cif.data_block_name ! Store this, since cif.data_block_name gets overwritten
      cif.open
      cif.file.move_to_line(1)
      cif.find_data_block(data_block_name)

   end


   read_CIF_crystal(cif) ::: leaky
   ! Read crystal unit cell and spacegroup information (but NOT atom
   ! positions) from a CIF file called "cif".
   ! NOTE: only to be called after read the .atoms from the CIF
      cif :: CIF

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Open the CIF if needed
      if (NOT cif.file.is_open) cif.open

      ! Create the crystal; it shouldn't really exist beforehand
      WARN_IF(.crystal.created,"crystal data already defined!")
      if (.crystal.destroyed) .crystal.create

      ! Read in the crystal from the CIF
      .crystal.read_CIF(cif,skip_atoms=TRUE)

      ! Only continue if there are some atoms ...
      if (NOT associated(.atom)) return
 
      ! This sets up all the unit cell etc information arrays
      ! *assuming* the atoms correspond to the asymmetric unit
      .CE:set_atoms_and_crystal(cif) 

      ! Create and read (assumed!) xray data; atoms must exist
      if (.crystal.xray_data.destroyed) .crystal.xray_data.create
      .crystal.assign_xray ! Assumed
      .crystal.data.read_CIF(cif,.atom.dim)

   end

   read_CIF_atoms(cif) ::: leaky
   ! Read atom information from a Crystallographic Information File, "cif".
   ! NOTE: Any previous atom information in destroyed.
      cif :: CIF

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Open the CIF
      if (NOT cif.file.is_open) cif.open

      ! Read the atoms from the CIF
      if (.atom.created) then
         .atom.nullify_basis_part
         .atom.destroy
      end
      .atom.read_CIF(cif)

      ! Set defaults and bases
      .spin_multiplicity = .default_spin_multiplicity
      .set_atom_info
      .resolve_basis_info

      ! Resolve axes in crystal is there
      if (.crystal.destroyed) return
 
      .CE:set_atoms_and_crystal(cif) 

   end

   set_atoms_and_crystal(cif) ::: private, leaky
   ! Set the atom and crystal information when processing the CIF.
   ! We may have to reset H atom positions.
      cif :: CIF

   ENSURE(.atom.created,"no atoms")
   ENSURE(.crystal.created,"no crystal")
 
      H_bond_length :: VEC{REAL}*
      has_Hs,reset :: BIN

      ! Change atom positions to cartesian
      .resolve_axis_system

      ! If the hydrogen's are all single bonded, reset the simple way.
      ! If disordered, this code assumes the disordered atoms are
      ! proximate to their bonded neighbours.
      if (.atom.has_all_Hs_single_bonded(has_Hs)) then

         if (has_Hs) then
         if (cif.apply_BH_bond_length) .atom.set_bond_lengths(5,1,cif.BH_bond_length) 
         if (cif.apply_CH_bond_length) .atom.set_bond_lengths(6,1,cif.CH_bond_length) 
         if (cif.apply_NH_bond_length) .atom.set_bond_lengths(7,1,cif.NH_bond_length) 
         if (cif.apply_OH_bond_length) .atom.set_bond_lengths(8,1,cif.OH_bond_length) 
         end

         .crystal.make_fragment_data(.atom,assign_atom=TRUE)

      else ! There are floating hydrogens or multiple bonded H's ...

         ! Analyse the fragment symmetry information
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)

         ! Use the crystal to reset the hydrogen bond lengths
         H_bond_length.create(5,8)
         H_bond_length(5) =  cif.BH_bond_length
         H_bond_length(6) =  cif.CH_bond_length
         H_bond_length(7) =  cif.NH_bond_length
         H_bond_length(8) =  cif.OH_bond_length
         .crystal.reset_H_bond_lengths_in(.atom,H_bond_length,reset)
         H_bond_length.destroy

         ! Return if nothing was done
         if (NOT reset) return

         if (.atom.has_disorder) then
            WARN_IF(.atom.has_disorder,"DISORDERED ASYMMETRIC CELL MAY BE PRUNED")
            WARN_IF(.atom.has_disorder,"SOME ATOM INFORMATION MAY BE LOST")
         end

         ! Re-analyse the fragment symmetry information
         ! Maybe not all things in here need doing again ...
         .crystal.destroy_asymmetric_unit
         .crystal.make_fragment_data(.atom,assign_atom=TRUE,warnings=FALSE)

      end

   end

   read_CIF_ADPs(cif) ::: leaky
   ! Read atom ADP information from a Crystallographic Information File, "cif".
      cif :: CIF
   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")
   ENSURE(.crystal.created,"must have crystal information")
      if (NOT cif.file.is_open) cif.open
      .atom.read_CIF_ADPs(cif)
      .resolve_axis_system
   end


   put_CX_data
   ! Output information that Crystal Explorer requires to the file 
   ! with name ".CX_file_name".
      .CE:put_CX_data(.cif)
   end

   put_CX_data(cif)
   ! Output information that Crystal Explorer requires to the file 
   ! with name ".CX_file_name".
      cif :: CIF*

      CX_file :: TEXTFILE*

      if (.CX_file_name/=" ") then
         CX_file.create(.CX_file_name)
         CX_file.open(for="write")
         .CE:put_CX_data(CX_file,cif)
         CX_file.close
         CX_file.destroy
      else
         .CE:put_CX_data(TEXTFILE::stdout,cif)
      end

   end

   put_CX_data(CX_file,cif)
   ! Output information that Crystal Explorer requires to file "CX_file".
   ! NOTE: this requires a "cif" file to have been read, and a valid data block
   ! name to be stored in the "cif" object.
      CX_file :: TEXTFILE*
      cif :: CIF*

 ! ENSURE(cif.created,"no CIF object created")
 ! ENSURE(cif.data_block_name/=" ","no CIF data block name")

      save :: TEXTFILE*
      CX_label,CX_name,formula,spacegroup :: STR
      done :: BIN

      if (cif.created) then
         CX_name  = cif.file_name
         CX_label = cif.data_block_name
      else
         CX_name  = "unknown"
         CX_label = "unknown"
      end

      stdout.flush
      stdout.text("Writing Crystal Explorer data file: " // CX_file.name.trim)
      stdout.flush

      ! Redirect stdout to out
      save   => TEXTFILE::stdout                      
      stdout => CX_file

      ! Reset output format
      stdout.save
      stdout.set_int_width(7)
      stdout.set_real_style("f")
      stdout.set_real_precision(5)
      stdout.set_real_width(12)
      stdout.set_using_fields(FALSE)

      stdout.flush
      stdout.text("Crystal Explorer data")

      stdout.flush
      stdout.show("begin CIF ",CX_label,dots=FALSE)
      stdout.show("file_name =",CX_name,dots=FALSE)
      stdout.show("data_block_name =",CX_label,dots=FALSE)
      stdout.text("end CIF")
      stdout.flush

      ! Crystal data and cluster/fragment positions
      ! Try saved cluster first
      done = FALSE
      if (.saved.created) then
      if (.saved.cluster.created) then
        ENSURE(.saved.cluster.info_made,"no cluster information")
        ENSURE(.saved.cluster.crystal.created,"no cluster crystal data")
        ENSURE(.saved.cluster.n_fragment_atoms>0,"no fragment size")
        formula    = .saved.cluster.crystal.CIF_chemical_formula
        spacegroup = .saved.cluster.crystal.spacegroup.HM_symbol
        stdout.show("begin crystal ",CX_label,dots=FALSE)
        .saved.cluster.crystal.put_CX(CX_label,formula,spacegroup) 
        .saved.cluster.put_CX(angstrom=.CX_uses_angstrom)
        stdout.flush
        stdout.text("end crystal")
        done = TRUE
      end
      end

      ! Try normal cluster
      if (NOT done) then
      if (.cluster.created) then
        ENSURE(.cluster.info_made,"no cluster information")
        ENSURE(.cluster.crystal.created,"no cluster crystal data")
        ENSURE(.cluster.n_fragment_atoms>0,"no fragment size")
        formula    = .cluster.crystal.CIF_chemical_formula
        spacegroup = .cluster.crystal.spacegroup.HM_symbol
        stdout.show("begin crystal ",CX_label,dots=FALSE)
        .cluster.crystal.put_CX(CX_label,formula,spacegroup) 
        .cluster.put_CX(angstrom=.CX_uses_angstrom)
        stdout.flush
        stdout.text("end crystal")
        done = TRUE
      end
      end

      ! Finally try .crystal and .atom
      if (NOT done) then
      if (.crystal.created AND .atom.created) then
        formula    = .crystal.CIF_chemical_formula
        spacegroup = .crystal.spacegroup.HM_symbol
        stdout.show("begin crystal ",CX_label)
        .crystal.put_CX(CX_label,formula,spacegroup) 
        .atom.put_CX(CX_label,angstrom=.CX_uses_angstrom)
        stdout.flush
        stdout.text("end crystal")
        done = TRUE
      end
      end

      ! Isosurface information
      if (.isosurface.created) then
      if (.isosurface.atom.created) then 

      ! Try saved cluster first
      done = FALSE
      if (.saved.created) then
      if (.saved.cluster.created) then
        stdout.flush
        stdout.show("begin surface ",.isosurface.surface_label.trim,dots=FALSE)
        .isosurface.put_CX(.saved.cluster.fragment_atom_indices &
                          ,.saved.cluster.nonfragment_atom_indices &
                          ,.atom &
                          ,angstrom=.CX_uses_angstrom)
        .saved.cluster.put_CX_atoms
        .isosurface.put_fingerprint_face_atoms(.saved.cluster.fragment_atom_indices &
                          ,.saved.cluster.nonfragment_atom_indices &
                          ,.atom)
        stdout.text("end surface")
        done = TRUE
      end
      end

      ! Try normal cluster
      if (NOT done) then
      if (.cluster.created) then
        DIE("should we be here?")
        done = TRUE
      end
      end

      ! Finally try isosurface only
      if (NOT done) then
        DIE("should we be here?")
        done = TRUE
      end

      end
      end

      ! Put back stdout
      stdout.unsave
      stdout => save                        

   end

end
