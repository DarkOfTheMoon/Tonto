! $Id$
!-------------------------------------------------------------------------------
!
! SHELL: used to describe contracted cartesian gaussian shells. 
!
! (c) Dylan Jayatilaka, november 1997
!-------------------------------------------------------------------------------
module SHELL

   use TYPES
   use SYSTEM
   use STR
   use INT
   use INPUT
   use OUTPUT
   use VEC
   use IMAT
   use MAT
   use MAT3

   implicit none         

#  include "macros"
#  include "shell.int"

!  type shell_type
!     INT :: l 
!     INT :: n_comp 
!     INT :: n_cc 
!     VEC, PTR :: ex
!     VEC, PTR :: cc
!  end 

contains

   create 
   ! Create a shell object
      PTR :: self
      allocate(self)
      ADD_MEM(SHELL_SIZE)
      .nullify_ptr_part
   end

   destroy 
   ! Destroy a shell object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(SHELL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer part of a shell object
      nullify(.ex)
      nullify(.cc)
   end

   destroy_ptr_part
   ! Destroy pointer part of a shell object
      .ex.destroy
      .cc.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   copy(shell) [leaky]
   ! Copy a shellell object
      SHELL :: shell
      .l = shell%l
      .n_comp = shell%n_comp
      .n_cc = shell%n_cc
      .ex.destroy
      .ex.create(.n_cc)
      .ex = shell%ex
      .cc.destroy
      .cc.create(.n_cc)
      .cc = shell%cc
   end

   set(shell) 
   ! Set a shell object
      SHELL :: shell
      .l = shell%l
      .n_comp = shell%n_comp
      .n_cc = shell%n_cc
      .ex => shell%ex
      .cc => shell%cc
   end

   set_default
   ! Set a default shell
      .l = 0
      .n_comp = 1
      .n_cc = 1
      .ex.create(1)
      .cc.create(1)
      .ex(1) = ONE
      .cc(1) = ONE
   end

   read(in) [leaky]
   ! Read a contracted gaussian self from file "in"
      INPUT :: in
      CHR :: l_c
      INT :: l,n_cc,i
      in.read_chr(l_c)
      in.read(n_cc)
      l_c.to_lower_case
      select case (l_c) 
         case ("s"); l = 0
         case ("p"); l = 1
         case ("d"); l = 2
         case ("f"); l = 3
         case ("g"); l = 4
         case default; 
            DIE_IF(l_c<"g","unknown angular momentum character:"//l_c)
            l = 4 + iachar(l_c)-iachar("g")
      end 
      .l = l
      .n_comp = (l+1)*(l+2)/2
      .n_cc = n_cc
      .ex.create(n_cc)
      .cc.create(n_cc)
      do i = 1,n_cc
         in.read(.ex(i))
         in.read(.cc(i))
      end
   end

   l_chr result(res)
   ! Return a character representation for the angular mtm
      CHR :: res
      INT :: l
      l = .l
      select case (l) 
         case (0); res="s"
         case (1); res="p"
         case (2); res="d"
         case (3); res="f"
         case (4); res="g"
         case default; 
            DIE_IF(l>23,"angular momentum too large:"// l.to_str.trim)
            res = achar(l-4+iachar("g"))
      end select
   end
    
   make_contraction_matrix(ccm)
   ! Return the contraction coefficient matrix
   ! Size of ccm is .n_prim,.n_comp.
      MAT :: ccm
      INT :: b,p,i
      DBL :: f
      VEC, PTR :: fac
      ccm = ZERO
      fac.create( .n_comp );   fac.normalizing_factors( .l )
      do b = 1,.n_comp       ! do over basis components
         p = b               ! primitive p 
         f = fac(b)
         do i = 1,.n_cc      ! do over contractions
            ccm(p,b) = f*.cc(i) 
            p = p + .n_comp
         end
      end
      fac.destroy
   end

   unnormalise
   ! Unnormalise self for cartesian component x^l.
   ! It is up to you to correct this factor with appropriate
   ! double factorial square roots for other components.
      INT :: i,j
      DBL :: sum,a,b,ab,pi2,norm,fac
      sum = ZERO
      do i = 1,.n_cc
         a = .ex(i)
         do j = 1,i-1
            b = .ex(j)  
            ab = TWO*sqrt(a*b)/(a+b);
            sum = sum + TWO*.cc(i)*.cc(j)*ab**(.l+ONE+HALF);
         end
         sum = sum + .cc(i)*.cc(i)
      end
   !  Take the normalization factor out of the primitive
      pi2 = (HALF/PI)**(THREE/FOUR)
      norm = pi2/sqrt(sum)
      do i = 1,.n_cc
         a = FOUR*.ex(i)
         fac = .l.double_factorial
         fac = ONE/sqrt(fac)
   !     this factor should be: fac = 1/sqrt(df(nx)*df(ny)*df(nz))
   !     where n are the cartesian powers of the basis component
         .cc(i) = .cc(i)*norm*fac*a**(HALF*.l+HALF+QUARTER)
      end
   end

   n_prim result(res)
   ! Return the number of primitive gaussians in the shell
      INT :: res
      res = .n_comp*.n_cc
   end

   put(out)
   ! Put the shell information to file "out"
      OUTPUT :: out
      INT :: i
      out.flush
      out.show("L quantum number = ",.l)
      out.dash(int_fields=1,dbl_fields=2)
      out.put("N", int_width=TRUE)
      out.put("Exponents")
      out.put("Contraction",flush=1)
      out.dash(int_fields=1,dbl_fields=2)
      do i = 1, .n_cc
         out.put(i)
         out.put( .ex(i))
         out.put( .cc(i))
         out.flush
      end
      out.flush
   end

end 
