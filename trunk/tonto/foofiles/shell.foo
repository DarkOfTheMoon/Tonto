!-------------------------------------------------------------------------------
!
! SHELL: used to describe contracted cartesian gaussian shells. 
!
! (c) Dylan Jayatilaka, november 1997
!
! $Id$
!-------------------------------------------------------------------------------
module SHELL

   use TYPES
   use SYSTEM
   use STR
   use INT
   use IMAT
   use VEC
   use MAT
   use MAT3
   use TEXTFILE

   implicit none         

#  include "macros"
#  include "shell.int"

!   type shell_type
!
!   INT :: l
!   ! l quantum number for the gaussian shell
!
!   INT :: n_comp
!   ! No. of components for the gaussian shell
!
!   INT :: n_cc
!   ! No. of contractions for the gaussian shell
!
!   VEC, PTR :: ex DEFAULT_NULL
!   ! Exponent vector
!
!   VEC, PTR :: cc DEFAULT_NULL
!   ! Contraction coefficient vector
!   end

contains

!  ******************
!  Allocation methods
!  ******************

   create 
   ! Create a shell object
      PTR :: self
      allocate(self)
      ADD_MEM(SHELL_SIZE)
      .l = 0
      .n_cc = 0
      .n_comp = 0
      .nullify_ptr_part
   end

   destroy 
   ! Destroy a shell object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(SHELL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer part of a shell object
      nullify(.ex)
      nullify(.cc)
   end

   destroy_ptr_part
   ! Destroy pointer part of a shell object
      .ex.destroy
      .cc.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   copy(shell) [leaky]
   ! Copy a shellell object
      SHELL :: shell
      .l = shell.l
      .n_comp = shell.n_comp
      .n_cc = shell.n_cc
      .ex.destroy
      .ex.create(.n_cc)
      .ex = shell.ex
      .cc.destroy
      .cc.create(.n_cc)
      .cc = shell.cc
   end

   set(shell) 
   ! Set a shell object
      SHELL :: shell
      .l = shell.l
      .n_comp = shell.n_comp
      .n_cc = shell.n_cc
      .ex => shell.ex
      .cc => shell.cc
   end

   set_default
   ! Set a default shell
      .l = 0
      .n_cc = 1
      .ex.create(1)
      .cc.create(1)
      .ex(1) = ONE
      .cc(1) = ONE
      .update
   end

   update     
   ! Update the shell data
      .n_comp = (.l+1)*(.l+2)/2
   end

!  *************
!  Input methods
!  *************

   read [leaky]
   ! Read data from "stdin" using keyword style input.
      STR :: word
      read_loop: do             ! Loop over keywords
         stdin.read(word)
         if (stdin.end_of_file) exit read_loop
         if (word=="end")       exit read_loop
         .process(word)      
      end do read_loop
      .update
   end

   process(word) [leaky]
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case, 
   ! the sequence is processed as if it were a separate file.
      STR(*) :: word
      if (word.includes(" ")) then
         stdin.redirect([word])
         .read
      else
         select case (word)
            case("end");    ! exit surrounding loop
            case("shell");  .read
            case("units");  .read_units
            case("l");      .read_l
            case("n_cc");   .read_n_cc
            case("ex");     .read_ex
            case("cc");     .read_cc
            case("ex,cc");  .read_ex_cc
            case default;    DIE("unknown keyword, "//trim(word))
         end
      end
   end

   process(keyword) [leaky]
   ! Process each of the words in the "keyword" list.
      STRVEC :: keyword
      INT :: k,n_key
      n_key = size(keyword)
      do k = 1,n_key
         if (keyword(k)=="end") exit 
         .process(keyword(k)) 
      end
      ENSURE(k>=n_key,"unprocessed words remain in the keyword list")
      .update
   end

   read_units
   ! Read a string which describes the units to be used
      stdin.set_default_units(stdin.next_str)
   end

   read_l
   ! Read in the l symbol
      STR :: word
      CHR :: l_c
      INT :: l
      stdin.read(word)
      if (word.is_int) then
         .l = word.to_int 
      else
         ENSURE(len_trim(word)==1,"unknown L symbol")
         l_c = word
         l_c.to_lower_case
         select case (l_c) 
            case ("s"); l = 0
            case ("p"); l = 1
            case ("d"); l = 2
            case ("f"); l = 3
            case ("g"); l = 4
            case default; 
               DIE_IF(l_c<"g","unknown angular momentum character:"//l_c)
               l = 4 + iachar(l_c)-iachar("g")
         end 
         .l = l
      end
   end

   read_n_cc
   ! Read in the number of vontraction coefficients
      stdin.read(.n_cc)
      ENSURE(.n_cc>0,"n_cc must be positive")
   end

   read_ex [leaky]
   ! Read in the exponents
      ENSURE(.n_cc>0,"n_cc must be entered first")
      ENSURE(.ex.destroyed,"ex already entered")
      .ex.create(.n_cc)
      stdin.read(.ex)
   end

   read_cc [leaky]
   ! Read in the contraction coefficients
      ENSURE(.n_cc>0,"n_cc must be entered first")
      ENSURE(.cc.destroyed,"cc already entered")
      .cc.create(.n_cc)
      stdin.read(.cc)
   end

   read_ex_cc [leaky]
   ! Read in the exponents
      ENSURE(.n_cc>0,"n_cc must be entered first")
      ENSURE(.ex.destroyed,"ex already entered")
      ENSURE(.cc.destroyed,"ex already entered")
      .ex.create(.n_cc)
      .cc.create(.n_cc)
      stdin.read(.ex,.cc)
   end

   l_chr result(res)
   ! Return a character representation for the angular mtm
      CHR :: res
      INT :: l
      l = .l
      select case (l) 
         case (0); res="s"
         case (1); res="p"
         case (2); res="d"
         case (3); res="f"
         case (4); res="g"
         case default; 
            DIE_IF(l>23,"angular momentum too large:"// l.to_str.trim)
            res = achar(l-4+iachar("g"))
      end select
   end
    
   make_contraction_matrix(ccm)
   ! Return the contraction coefficient matrix. Size of ccm is (.n_prim,.n_comp).
      MAT :: ccm
      INT :: b,p,i
      DBL :: f
      VEC, PTR :: fac
      fac.create( .n_comp )
      fac.normalizing_factors( .l )
      do b = 1,.n_comp       ! do over basis components
         p = b               ! primitive p 
         f = fac(b)
         do i = 1,.n_cc      ! do over contractions
            ccm(p,b) = f*.cc(i) 
            p = p + .n_comp
         end
      end
      fac.destroy
   end

   unnormalise
   ! Unnormalise self for cartesian component x^l. It is up to you to correct this 
   ! factor with appropriate double factorial square roots for other components.
      INT :: i,j
      DBL :: sum,a,b,ab,pi2,norm,fac
      sum = ZERO
      do i = 1,.n_cc
         a = .ex(i)
         do j = 1,i-1
            b = .ex(j)  
            ab = TWO*sqrt(a*b)/(a+b);
            sum = sum + TWO*.cc(i)*.cc(j)*ab**(.l+ONE+HALF);
         end
         sum = sum + .cc(i)*.cc(i)
      end
      ! Take the normalization factor out of the primitive
      pi2 = (HALF/PI)**(THREE/FOUR)
      norm = pi2/sqrt(sum)
      do i = 1,.n_cc
         a = FOUR*.ex(i)
         fac = .l.double_factorial
         fac = ONE/sqrt(fac)
         ! this factor should be: fac = 1/sqrt(df(nx)*df(ny)*df(nz))
         ! where n are the cartesian powers of the basis component
         .cc(i) = .cc(i)*norm*fac*a**(HALF*.l+HALF+QUARTER)
      end
   end

   n_prim result(res)
   ! Return the number of primitive gaussians in the shell
      INT :: res
      res = .n_comp*.n_cc
   end

   put
   ! Put the shell information to "stdout"
      INT :: i
      stdout.flush
      stdout.show("L quantum number = ",.l)
      stdout.dash(int_fields=1,dbl_fields=2)
      stdout.put("N", int_width=TRUE)
      stdout.put("Exponents")
      stdout.put("Contraction")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=2)
      do i = 1,.n_cc
         stdout.put(i)
         stdout.put( .ex(i))
         stdout.put( .cc(i))
         stdout.flush
      end
   end

end 
