!-------------------------------------------------------------------------------
!
! SHELL2 : pair of SHELLs
!
! Given two shells, can calculate
!  - Fourier transform of their product, evaluated on a grid
!  - overlap integrals
!  - kinetic energy integrals
!  - nuclear attraction integrals
!
! Based on the Rys method, as described by Lindh et al,
! J. Chem. Phys 84(7) 3963-3974
!
! - overlap (non rys version) and kinetic energy integrals work at least
!   up to (q|q).
! - methods using the rys module are limited up to about (m|m) due to
!   the general rys method algorithm failing.  (As tested with atoms on the
!   same center.  Different centers can go higher, but not recommended).
!
! Copyright (C) Daniel Grimwood, 1998
! Copyright (C) Dylan Jayatilaka 1998-2006
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module SHELL2

   implicit none

   ! List of cartesian powers for gaussian functions in a certain angular
   ! momentum range
!  nx, ny, nz :: VEC{INT}*, private  DEFAULT_NULL
!  gaussian_indices :: MAT{GAUSSIAN_INDICES}*, private  DEFAULT_NULL

   ! These are indexing arrays used for the horizontal recursion relation.
   ! They are set using the set_hrr_indexing_arrays routine.

!  l_max_hrr :: INT, private = -1
!  first_nonzero :: VEC{INT}*, private  DEFAULT_NULL
!  index_m1 :: VEC{INT}*, private  DEFAULT_NULL
!  index_p1 :: MAT{INT}*, private  DEFAULT_NULL

   pair_cutoff :: REAL, private = SHELL2_PAIR_CUTOFF

contains

   create ::: leaky
   ! Creates a shell2 object
     self :: PTR
     nullify(self)
     allocate(self)
     ADD_MEMORY(SELF_TYPE_SIZE)
     .nullify_ptr_part
   end

   create(shell_a,shell_b) ::: leaky
   ! Create a copy of a shell1 objects
     self :: PTR
     shell_a,shell_b :: SHELL1, IN
     .create
     .copy(shell_a,shell_b)
   end

   create(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Create a copy of a shell1 objects with positions
     self :: PTR
     shell_a,shell_b :: SHELL1, IN
     pos_a,pos_b :: VEC{REAL}(3), IN
     .create
     .copy(shell_a,shell_b,pos_a,pos_b)
   end

   create(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Create a copy of a shell1 objects with positions
     self :: PTR
     shell_a,shell_b :: SHELL, IN
     pos_a,pos_b :: VEC{REAL}(3), IN
     .create
     .copy(shell_a,shell_b,pos_a,pos_b)
   end

   destroy ::: leaky
   ! Destroys a shell2 object
     self :: PTR
     if (.destroyed) return
     .destroy_ptr_part
     DELETE_MEMORY(SELF_TYPE_SIZE)
     deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      .a.nullify_ptr_part
      .b.nullify_ptr_part
      nullify(.exponent_sum)
      nullify(.exponent_inv)
    ! nullify(.a_exponent_inv)
    ! nullify(.b_exponent_inv)
      nullify(.cc_prefactor)
      nullify(.cc_s_prefactor)
      nullify(.cc_p_prefactor)
      nullify(.normalising_factors)
      nullify(.pair_center)
      nullify(.center_diff)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self
      if (.destroy_all) then
         .a.destroy_ptr_part
         .b.destroy_ptr_part
         .exponent_sum.destroy
         .exponent_inv.destroy
         .normalising_factors.destroy
         .cc_prefactor.destroy
         .cc_s_prefactor.destroy
         .cc_p_prefactor.destroy
      else
         .a.nullify_ptr_part
         .b.nullify_ptr_part
         nullify(.exponent_sum)
         nullify(.exponent_inv)
         nullify(.normalising_factors)
         if (.same_center) then 
            nullify(.cc_prefactor)
            nullify(.cc_s_prefactor)
            nullify(.cc_p_prefactor)
         else
            .cc_prefactor.destroy
            .cc_s_prefactor.destroy
            .cc_p_prefactor.destroy
         end
      end
      .pair_center.destroy
      .center_diff.destroy
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(shell) ::: leaky
   ! Create a copy from "shell"
     self :: PTR
     shell :: SHELL2, IN
     .create
     .copy(shell)
     .precalculate
   end

   copy(shell) ::: leaky
   ! Make a copy from "shell"
     shell :: SHELL2, IN
     .a.copy(shell.a)
     .b.copy(shell.b)
     .precalculate
   end

   copy(shell_a,shell_b) ::: leaky
   ! Copy the shell2 using shell1 objects
     shell_a,shell_b :: SHELL1, IN
     .a.copy(shell_a)
     .b.copy(shell_b)
     .precalculate
   end

   copy(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Copy the shell2 using shell objects and positions
     shell_a,shell_b :: SHELL1, IN
     pos_a,pos_b :: VEC{REAL}, IN
     .a.copy(shell_a,pos_a)
     .b.copy(shell_b,pos_b)
     .precalculate
   end

   copy(shell_a,shell_b,pos_a,pos_b) ::: leaky
   ! Copy the shell2 using shell objects and positions
     shell_a,shell_b :: SHELL, IN
     pos_a,pos_b :: VEC{REAL}, IN
     .a.copy(shell_a,pos_a)
     .b.copy(shell_b,pos_b)
     .precalculate
   end

   set(shell_a,shell_b)
   ! Set the shell2 using shell1 objects
     shell_a,shell_b :: SHELL1, IN
     .a.set(shell_a)
     .b.set(shell_b)
     .precalculate
   end

   set(shell_a,shell_b,pos_a,pos_b)
   ! Copy the shell2 using shell objects
     shell_a,shell_b :: SHELL, IN
     pos_a,pos_b :: VEC{REAL}, IN
     .a.set(shell_a,pos_a)
     .b.set(shell_b,pos_b)
     .precalculate
   end

   set_pair_cutoff(cutoff)
   ! Set the "cutoff" for the exponential prefactor for the product of two
   ! gaussian primitives, below which that primitive pair is isgnored in the
   ! calculation of the ERI's.
     cutoff :: REAL, IN
   ENSURE(cutoff>ZERO,"cutoff must be pisitive")
     pair_cutoff = cutoff
   end

   set_and_precompute_from(shellpr,pos_a,pos_b,same_center,skip) ::: leaky
   ! Set the a and b parts from "shellpr" but override the positions.
   ! "same_center" should be set TRUE if pos_a==pos_b.
   ! "skip" can be set TRUE if NOT same_center; it skips gaussian product
   ! pairs which are too small to worry about.
   ! NOTE: this does not create many pointer parts
     shellpr :: SHELL1PAIR, IN
     pos_a,pos_b :: VEC{REAL}, IN
     same_center,skip :: BIN, IN
     AB,At,P,b_pos_b :: VEC{REAL}(3)
     a,b,r2ab,b_r2ab,ab_inv,prefac :: REAL
     i,j,bg,ag :: INT
     .a = shellpr.a
     .b = shellpr.b
     .a.pos = pos_a
     .b.pos = pos_b
     .same_center = same_center
     .n_gaussian_pairs = shellpr.n_gaussian_pairs
     .l_max = shellpr.l_max
     .l_min = shellpr.l_min
     .l_sum = shellpr.l_sum
     .first_gaussian = shellpr.first_gaussian
     .last_gaussian  = shellpr.last_gaussian
     .n_gaussian = shellpr.n_gaussian
     .destroy_all = FALSE ! <--------
     .exponent_sum => shellpr.exponent_sum
     .exponent_inv => shellpr.exponent_inv
     .normalising_factors => shellpr.normalising_factors
     .pair_center.create(3,.n_gaussian_pairs)
     .center_diff.create(3,.n_gaussian_pairs)
     if (NOT skip) then
        if (same_center) then
           .cc_prefactor => shellpr.cc_prefactor
           i = 0
           do bg = 1,.b.n_cc
             do ag = 1,.a.n_cc
               i = i + 1
             ! .cc_prefactor(i)  = shellpr.cc_prefactor(i)
               .pair_center(:,i) = pos_a
               .center_diff(:,i) = ZERO
             end
           end
        else
           .cc_prefactor.create(.n_gaussian_pairs)
           AB = pos_a-pos_b
           ! Want position of shell1 with higher angular momentum.
           if (.a.l > .b.l) then; At = pos_a
           else;                  At = pos_b
           end
           r2ab = dot_product(AB,AB)
           i = 0
           do bg = 1,.b.n_cc
             b = .b.ex(bg)
             b_pos_b = b*pos_b
             b_r2ab = b*r2ab
             do ag = 1,.a.n_cc
               i = i + 1
               a = .a.ex(ag)
               ab_inv = .exponent_inv(i)
               .cc_prefactor(i)  = shellpr.cc_prefactor(i)*exp(-a*b_r2ab*ab_inv)
               P = (b_pos_b + a*pos_a) * ab_inv
               .pair_center(:,i) = P
               .center_diff(:,i) = P - At
             end
           end
        end
     else
        .cc_prefactor.create(.n_gaussian_pairs)
        AB = pos_a-pos_b
        ! Want position of shell1 with higher angular momentum.
        if (.a.l > .b.l) then; At = pos_a
        else;                  At = pos_b
        end
        r2ab = dot_product(AB,AB)
        i = 0
        j = 0
        do bg = 1,.b.n_cc
          b = .b.ex(bg)
          b_pos_b = b*pos_b
          b_r2ab = b*r2ab
          do ag = 1,.a.n_cc
            i = i + 1
            a = .a.ex(ag)
            ab_inv = .exponent_inv(i)
            prefac = exp(-a*b_r2ab*ab_inv)
            if (prefac<pair_cutoff) cycle
            j = j + 1
            .cc_prefactor(i)  = prefac*shellpr.cc_prefactor(i)
            P = (b_pos_b + a*pos_a) * ab_inv
            .pair_center(:,j) = P
            .center_diff(:,j) = P - At
          end
        end
     end
    ! .kappa_max = maxval(.cc_prefactor/.exponent_inv**(THREE/TWO))
   end
 
   precalculate ::: leaky
   ! Set up some commonly used intermediates
     anorm,bnorm :: VEC{REAL}*
     AB,At,P :: VEC{REAL}(3)
     b_cc,a,b,exp_sum,exp_inv,r2ab,b_r2ab,a_exp_inv :: REAL
     ag,bg,i,fa,la,fb,lb :: INT
     .n_gaussian_pairs = .a.n_cc*.b.n_cc
     .l_max = max(.a.l,.b.l)
     .l_min = min(.a.l,.b.l)
     .l_sum = .a.l + .b.l
     .destroy_all = TRUE
     .exponent_sum.create(.n_gaussian_pairs)
     .exponent_inv.create(.n_gaussian_pairs)
   ! .a_exponent_inv.create(.n_gaussian_pairs)
   ! .b_exponent_inv.create(.n_gaussian_pairs)
     .cc_prefactor.create(.n_gaussian_pairs)
     .pair_center.create(3,.n_gaussian_pairs)
     .center_diff.create(3,.n_gaussian_pairs)
     .normalising_factors.create(.a.n_comp*.b.n_comp)
     anorm.create(.a.n_comp)
     bnorm.create(.b.n_comp)
     AB = .a.pos-.b.pos
     ! Want position of shell1 with higher angular momentum.
     if (.a.l > .b.l) then; At = .a.pos
     else;                  At = .b.pos
     end
     r2ab = dot_product(AB,AB)
     i = 0
     do bg = 1,.b.n_cc
       b      = .b.ex(bg)
       b_r2ab = b * r2ab
       b_cc   = .b.cc(bg)
       do ag = 1,.a.n_cc
         i = i + 1
         a = .a.ex(ag)
         exp_sum = a + b
         exp_inv = ONE/exp_sum
         P = (b*.b.pos + a*.a.pos) * exp_inv
         .exponent_sum(i)        = exp_sum
         .exponent_inv(i)        = exp_inv
         a_exp_inv               = a*exp_inv
       ! .a_exponent_inv(i)      = a_exp_inv
       ! .b_exponent_inv(i)      = b*exp_inv
         .cc_prefactor(i)        = b_cc*.a.cc(ag) *exp_inv*sqrt(exp_inv)* &
                                                      exp(-b_r2ab*a_exp_inv)
         .pair_center(:,i) = P
         .center_diff(:,i) = P - At
       end
     end
   ! .kappa_max = maxval(.cc_prefactor/.exponent_inv**(THREE/TWO))
     fa = .a.first_gaussian; la = .a.last_gaussian
     fb = .b.first_gaussian; lb = .b.last_gaussian
     anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
     bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)
     i = 0
     do bg=1,.b.n_comp
       do ag=1,.a.n_comp
         i = i + 1
         .normalising_factors(i) = anorm(ag)*bnorm(bg)
       end
     end
   end

!*******************************************************************************
!    Fourier transform integrals
!*******************************************************************************

   normalise_ft(ft)
   ! Multiplies the ft product at a series of k points, by the normalisation
   ! factors for the two gaussian shells.
     ft :: MAT3{CPX}, target
     ft_ab :: VEC{CPX}*
     a,b,i :: INT
     if (.a.l<=1 AND .b.l<=1) return
     i = 0
     do b = 1,.b.n_comp
     do a = 1,.a.n_comp
         i = i + 1
         ft_ab => ft(:,a,b)
         ft_ab(:) = ft_ab(:) * .normalising_factors(i)
     end
     end
   end

   normalise_ft2(ft)
   ! Multiplies the ft product at a series of k points, by the normalisation
   ! factors for the two gaussian shells.
     ft :: MAT3{CPX}, target
     k,a,b,i :: INT
     if (.a.l<=1 AND .b.l<=1) return
     do k = 1,ft.dim3
        i = 0
        do b = 1,.b.n_comp
        do a = 1,.a.n_comp
            i = i + 1
            ft(a,b,k) = ft(a,b,k) * .normalising_factors(i)
        end
        end
     end
   end

   normalise_ft4(ft)
   ! Multiplies the ft product at a series of k points, by the normalisation
   ! factors for the two gaussian shells.
     ft :: MAT4{CPX}, target
     t,k,a,b,i :: INT
     if (.a.l<=1 AND .b.l<=1) return
     do t = 1,ft.dim4
     do k = 1,ft.dim3
        i = 0
        do b = 1,.b.n_comp
        do a = 1,.a.n_comp
            i = i + 1
            ft(a,b,k,t) = ft(a,b,k,t) * .normalising_factors(i)
        end
        end
     end
     end
   end

   skip_ft(cutoff) result (res)
   ! Whether the ft for this shell pair is too small.
     self :: IN
     cutoff :: REAL, IN
     res :: BIN
     R2,gamma,g1,e2,ex,ey,ez,e000x,e000y,e000z :: REAL
     AB :: VEC{REAL}(3)
     a,b,t_max :: INT
     e :: MAT3{REAL}*
     G :: GAUSSIAN2
     G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
     t_max = .a.l + .b.l
     e.create((/0,t_max/),(/0,.a.l/),(/0,.b.l/))
     e = ZERO
     AB = (.a.pos-.b.pos)
     R2 = dot_product(AB,AB)
     res = TRUE
     do a = 1, .a.n_cc
       G.set(ex_a=.a.ex(a))
       do b = 1, .b.n_cc
         G.set(ex_b=.b.ex(b))
         G.make_e_coeff(e,1);   ex=maxval(e); e000x = e(0,0,0)
         G.make_e_coeff(e,2);   ey=maxval(e); e000y = e(0,0,0)
         G.make_e_coeff(e,3);   ez=maxval(e); e000z = e(0,0,0)
         gamma = .a.ex(a) + .b.ex(b)
         g1 = ONE/gamma
!         e2 = ex*ey*ez*(g1)**(THREE/TWO)*exp(-.a.ex(a)*.b.ex(b)*g1*R2)
         e2 = ex*ey*ez*g1*sqrt(g1)*e000x*e000y*e000z
         if (e2>cutoff) then
           res = FALSE
           e.destroy
           return
         end
       end
     end
     e.destroy
   end

   skip_ft(Pmax,cutoff) result (res)
   ! Whether the ft for this shell pair is too small.
     self :: IN
     Pmax,cutoff :: REAL, IN
     res :: BIN
     fac,R2,gamma,g1,e2,ex,ey,ez,e000x,e000y,e000z :: REAL
     AB :: VEC{REAL}(3)
     a,b,t_max :: INT
     e :: MAT3{REAL}*
     G :: GAUSSIAN2
     G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
     t_max = .a.l + .b.l
     e.create((/0,t_max/),(/0,.a.l/),(/0,.b.l/))
     e = ZERO
     AB = (.a.pos-.b.pos)
     R2 = dot_product(AB,AB)
     res = TRUE
     do a = 1, .a.n_cc
       G.set(ex_a=.a.ex(a))
       fac=.a.cc(a)*Pmax
       do b = 1, .b.n_cc
         G.set(ex_b=.b.ex(b))
         G.make_e_coeff(e,1);   ex=maxval(e); e000x = e(0,0,0)
         G.make_e_coeff(e,2);   ey=maxval(e); e000y = e(0,0,0)
         G.make_e_coeff(e,3);   ez=maxval(e); e000z = e(0,0,0)
         gamma = .a.ex(a) + .b.ex(b)
         g1 = ONE/gamma
!         e2 = ex*ey*ez*(g1)**(THREE/TWO)*exp(-.a.ex(a)*.b.ex(b)*g1*R2)
         e2 = ex*ey*ez*g1*sqrt(g1)*e000x*e000y*e000z
         if (e2*.b.cc(b)*fac>cutoff) then
           res = FALSE
           e.destroy
           return
         end
       end
     end
     e.destroy
   end

!   make_e_coeff(e,comp) ::: pure
!   ! Return the McMurchie-Davidson "e" coefficients for component "comp"
!   ! but only for the a component. We can obtain the b component using
!   ! the transfer relation. Also, in this version, one is added to all
!   ! the e indices to allow indexing from 1, not 0.
!      self :: IN
!      comp :: INT, IN
!      e :: MAT{REAL}, OUT ! Generic e coefficient table
!      t,a,b,ap,am,bp,bm,abp,ab,abm,max,l_a,l_b :: INT
!      R,gamma,g1,g2,a1,b1,e000 :: REAL
!      l_a = .a.l
!      l_b = .b.l
!      max = l_a+l_b
!      R = .a.pos(comp)-.b.pos(comp)
!      gamma = .a.ex + .b.ex
!      g1 = 1/gamma
!      b1 = .b.ex*g1*R
!      e000 = exp(-.a.ex*b1*R)
!      e(1,1,1) = e000
!      if (max==0) return               ! Return for e000
!      g2 = HALF*g1
!      a1 = .a.ex*g1*R
!      if (l_a>=1) then
!         e(2,2) =  g2*e000
!         e(1,2) = -b1*e000
!      end
!      if (max==1) return               ! Return for eXX1
!      do a = 2,l_a                     ! Consider case b=0
!         ap = a + 1
!         am = a - 1
!         e(ap,ap) =  g2*e( a,a)
!         e( a,ap) =  g2*e(am,a) - b1*e(a,a)
!         e( 0,ap) = -b1*e( 0,a) +    e(1,a)
!         do t = 1,am
!            e(t,ap) = g2*e(t-1,a) - b1*e(t,a) + (t+1)*e(t+1,a)
!         end
!      end
!   end

   make_ft(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
      res :: MAT3{CPX}, target
      k_pts :: MAT{REAL}, IN
       G :: GAUSSIAN2
      ft_ab :: MAT3{CPX}*
      a,b,k_max,i,j :: INT
      ca,fac :: REAL
      res_ij :: VEC{CPX}*
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      ft_ab.create(k_max,.a.n_comp,.b.n_comp)
      do a = 1, .a.n_cc
         G.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G.set(ex_b=.b.ex(b))
            G.make_ft(ft_ab,k_pts)
            fac = ca * .b.cc(b)
            do j=1,.b.n_comp
              do i=1,.a.n_comp
                res_ij => res(:,i,j)
                res_ij(:) = res_ij(:) + ft_ab(:,i,j) * fac
              end
            end
    ! stdout.text("=== next shell ===")
    !    stdout.show("k =",1)
    !    stdout.show("k =",k_pts(1,:))
    !    stdout.text("first")
    !    stdout.put(ft_ab(1,:,:))
         end
      end
      ft_ab.destroy
      .normalise_ft(res)
   end

   make_ft_fast(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! This version has the gaussian2 stuff inlined and special cases optimised,
   ! it's pretty messy but much faster.
      res :: MAT3{CPX}, target
      k_pts :: MAT{REAL}, target
      ft_x,ft_y,ft_z :: MAT3{CPX}*
      G :: GAUSSIAN2
      e :: MAT3{REAL}*
      pos :: VEC{REAL}(3)
      k_x,k_y,k_z,k_x2,k_y2,k_z2 :: VEC{REAL}*
      res_ij,prefac,ft_xb,ft_yb,ft_zb :: VEC{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      ft_xbx,ft_yby,ft_zbz :: MAT{CPX}*
      ft_x01,ft_x10,ft_y01,ft_y10,ft_z01,ft_z10 :: VEC{CPX}*
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      a,b,k,xa,ya,za,xb,yb,zb,bxlast,bylast,bzlast,aa,bb,k_max,fa,la,fb,lb :: INT
      fac1 :: CPX
      g1_exa,g1_exb,e00,ex_a,ex_b,ca,fac :: REAL
      Ex000,Ey000,Ez000,Ex001,Ey001,Ez001,Ex101,Ey101,Ez101 :: REAL
      Ex010,Ey010,Ez010,Ex110,Ey110,Ez110,Ex111,Ey111,Ez111 :: REAL
      Ex211,Ey211,Ez211,Ex011,Ey011,Ez011 :: REAL
      PA1,PA2,PA3,PB1,PB2,PB3,pp :: REAL
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      select case (.a.l)
        case (0)
          select case(.b.l)
            case (0)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              pos = .a.pos - .b.pos
              pp = dot_product(pos,pos)
              res_ij => res(:,1,1)
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              do a = 1, .a.n_cc
                ca = .a.cc(a)
                ex_a = .a.ex(a)
                do b = 1, .b.n_cc
                  ex_b = .b.ex(b)
                  g1 = ONE/(ex_a+ex_b)
                  g4 = -QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*ex_a
                  g1_exb = g1*ex_b
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  e00 = exp(-ex_a*ex_b*pp*g1)
                  fac1= cmplx(pifac*e00,ZERO,kind=CPX_KIND) * ca * .b.cc(b)
                  do k = 1, k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = g4 * (k1*k1+k2*k2+k3*k3)
                    res_ij(k) = res_ij(k) + (fac1 * exp(cmplx(dot2,dot1,kind=CPX_KIND)))
                  end
                end
              end
            case (1)
              prefac.create(k_max)
              k_x => k_pts(:,1)
              k_y => k_pts(:,2)
              k_z => k_pts(:,3)
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              e.create((/0,1/),(/0,0/),(/0,1/))
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex101 = e(1,0,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey101 = e(1,0,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez101 = e(1,0,1)
                  fac = pifac * ca * .b.cc(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
                  end
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex001,Ex101*k_x,kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,1,2)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey001,Ey101*k_y,kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,1,3)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez001,Ez101*k_z,kind=CPX_KIND)*prefac(:)
                end
              end
              e.destroy
              prefac.destroy
            case default
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
                  end
                  do b=0,.b.l ! incorporate prefac into ft_z
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
                  end
                  bxlast = bx(1)
                  bylast = by(1)
                  bzlast = bz(1)
                  ft_xb => ft_x(:,0,bxlast)
                  ft_yb => ft_y(:,0,bylast)
                  ft_zb => ft_z(:,0,bzlast)
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    if (bxlast/=xb) then
                      ft_xb => ft_x(:,0,xb)
                      bxlast = xb
                    end
                    if (bylast/=yb) then
                      ft_yb=> ft_y(:,0,yb)
                      bylast = yb
                    end
                    if (bzlast/=zb) then
                      ft_zb=> ft_z(:,0,zb)
                      bzlast = zb
                    end
                    res_ij => res(:,1,b)
                    res_ij(:) = res_ij(:) + ft_xb(:)*ft_yb(:)*ft_zb(:)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_y.destroy
              ft_z.destroy
              .normalise_ft(res)
          end
        case (1)
          select case (.b.l)
            case (0)
              prefac.create(k_max)
              e.create((/0,1/),(/0,1/),(/0,0/))
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex010 = e(0,1,0)
                  Ex110 = e(1,1,0)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey010 = e(0,1,0)
                  Ey110 = e(1,1,0)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez010 = e(0,1,0)
                  Ez110 = e(1,1,0)
                  fac = pifac * ca * .b.cc(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
                  end
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex010,Ex110*k_x(:),kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,2,1)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey010,Ey110*k_y(:),kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,3,1)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez010,Ez110*k_z(:),kind=CPX_KIND)*prefac(:)
                end
              end
              e.destroy
              prefac.destroy
            case (1)
              ft_x.create((/1,k_max/),(/0,1/),(/0,1/))
              ft_y.create((/1,k_max/),(/0,1/),(/0,1/))
              ft_z.create((/1,k_max/),(/0,1/),(/0,1/))
              prefac.create(k_max)
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              e.create((/0,2/),(/0,1/),(/0,1/))
              ft_x01.create(k_max)
              ft_x10.create(k_max)
              ft_y01.create(k_max)
              ft_y10.create(k_max)
              ft_z01.create(k_max)
              ft_z10.create(k_max)
              k_x2.create(k_max)
              k_y2.create(k_max)
              k_z2.create(k_max)
              k_x2=k_x*k_x
              k_y2=k_y*k_y
              k_z2=k_z*k_z
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  fac = pifac * ca * .b.cc(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
                  end
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex010 = e(0,1,0)
                  Ex011 = e(0,1,1)
                  Ex101 = e(1,0,1)
                  Ex110 = e(1,1,0)
                  Ex111 = e(1,1,1)
                  Ex211 = e(2,1,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey010 = e(0,1,0)
                  Ey011 = e(0,1,1)
                  Ey101 = e(1,0,1)
                  Ey110 = e(1,1,0)
                  Ey111 = e(1,1,1)
                  Ey211 = e(2,1,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez010 = e(0,1,0)
                  Ez011 = e(0,1,1)
                  Ez101 = e(1,0,1)
                  Ez110 = e(1,1,0)
                  Ez111 = e(1,1,1)
                  Ez211 = e(2,1,1)
                  ft_x01(:) = cmplx(Ex001,Ex101*k_x(:),kind=CPX_KIND)
                  ft_x10(:) = cmplx(Ex010,Ex110*k_x(:),kind=CPX_KIND)
                  ft_y01(:) = cmplx(Ey001,Ey101*k_y(:),kind=CPX_KIND)
                  ft_y10(:) = cmplx(Ey010,Ey110*k_y(:),kind=CPX_KIND)
                  ft_z01(:) = cmplx(Ez001,Ez101*k_z(:),kind=CPX_KIND)
                  ft_z10(:) = cmplx(Ez010,Ez110*k_z(:),kind=CPX_KIND)
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex011-Ex211*k_x2(:),Ex111*k_x(:),kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,2,1)
                  res_ij(:) = res_ij(:) + ft_x01(:)*ft_y10(:)*Ez000*prefac(:)
                  res_ij => res(:,3,1)
                  res_ij(:) = res_ij(:) + ft_x01(:)*Ey000*ft_z10(:)*prefac(:)
                  res_ij => res(:,1,2)
                  res_ij(:) = res_ij(:) + ft_x10(:)*ft_y01(:)*Ez000*prefac(:)
                  res_ij => res(:,2,2)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey011-Ey211*k_y2(:),Ey111*k_y(:),kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,3,2)
                  res_ij(:) = res_ij(:) + Ex000*ft_y01(:)*ft_z10(:)*prefac(:)
                  res_ij => res(:,1,3)
                  res_ij(:) = res_ij(:) + ft_x10(:)*Ey000*ft_z01(:)*prefac(:)
                  res_ij => res(:,2,3)
                  res_ij(:) = res_ij(:) + Ex000*ft_y10(:)*ft_z01(:)*prefac(:)
                  res_ij => res(:,3,3)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez011-Ez211*k_z2(:),Ez111*k_z(:),kind=CPX_KIND)*prefac(:)
                end
              end
              k_z2.destroy
              k_y2.destroy
              k_x2.destroy
              ft_z10.destroy
              ft_z01.destroy
              ft_y10.destroy
              ft_y01.destroy
              ft_x10.destroy
              ft_x01.destroy
              e.destroy
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
            case default
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
                  P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
                  P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
                  end
                  do b=0,.b.l
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
                    ft_z(:,1,b) = ft_z(:,1,b) * prefac(:)
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    ft_xb => ft_x(:,0,xb)
                    ft_yb => ft_y(:,0,yb)
                    ft_zb => ft_z(:,0,zb)
                    res_ij => res(:,1,b)
                    res_ij(:) = res_ij(:) + ft_x(:,1,xb)*ft_yb*ft_zb
                    res_ij => res(:,2,b)
                    res_ij(:) = res_ij(:) + ft_xb*ft_y(:,1,yb)*ft_zb
                    res_ij => res(:,3,b)
                    res_ij(:) = res_ij(:) + ft_xb*ft_yb*ft_z(:,1,zb)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
              .normalise_ft(res)
          end
        case default
          select case (.b.l)
            case (0)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
                  P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
                  P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
                  end
                  do a=0,.a.l
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res_ij => res(:,a,1)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,0)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
              .normalise_ft(res)
            case (1)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1)
              k_y => k_pts(:,2)
              k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
                  P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
                  P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
                  end
                  do a=0,.a.l ! incorporate prefac into ft_z
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                    ft_z(:,a,1) = ft_z(:,a,1) * prefac(:)
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res_ij => res(:,a,1)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,1)*ft_y(:,ya,0)*ft_z(:,za,0)
                    res_ij => res(:,a,2)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,1)*ft_z(:,za,0)
                    res_ij => res(:,a,3)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,1)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
              .normalise_ft(res)
            case default
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1)
              k_y => k_pts(:,2)
              k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              fb = .b.first_gaussian; lb = .b.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
             ! This is the general routine.  It includes reduced multiplication,
             ! and use of pointers to minimise array finding.
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
                  P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
                  P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))
                  end
                  do b=0,.b.l ! incorporate prefac into ft_z
                    do a=0,.a.l
                      ft_z(:,a,b) = ft_z(:,a,b) * prefac(:)
                    end
                  end
                  bxlast = bx(1)
                  bylast = by(1)
                  bzlast = bz(1)
                  ft_xbx => ft_x(:,:,bxlast)
                  ft_yby => ft_y(:,:,bylast)
                  ft_zbz => ft_z(:,:,bzlast)
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    if (bxlast/=xb) then
                      ft_xbx => ft_x(:,:,xb)
                      bxlast = xb
                    end
                    if (bylast/=yb) then
                      ft_yby=> ft_y(:,:,yb)
                      bylast = yb
                    end
                    if (bzlast/=zb) then
                      ft_zbz=> ft_z(:,:,zb)
                      bzlast = zb
                    end
                    do a = 1,.a.n_comp
                      xa = ax(a)
                      ya = ay(a)
                      za = az(a)
                      res_ij => res(:,a,b)
                      res_ij(:) = res_ij(:) + ft_xbx(:,xa+1)*ft_yby(:,ya+1)*ft_zbz(:,za+1)
                    end
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
              .normalise_ft(res)
          end
      end
   end

   make_ft_fast(res,k_pts,thermal,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction and partition factors.
   ! This version has the gaussian2 stuff inlined and special cases optimised,
   ! it's pretty messy but much faster.
      res :: MAT3{CPX}, target
      k_pts :: MAT{REAL}, target
      thermal :: MAT3{REAL}, target
      partition :: MAT{REAL}, IN
      ft_x,ft_y,ft_z :: MAT3{CPX}*
      G :: GAUSSIAN2
      e :: MAT3{REAL}*
      pos :: VEC{REAL}(3)
      therm,k_x,k_y,k_z,k_x2,k_y2,k_z2 :: VEC{REAL}*
      res_ij,prefac,ft_xb,ft_yb,ft_zb :: VEC{CPX}*
      ax,ay,az,bx,by,bz :: VEC{INT}*
      ft_xbx,ft_yby,ft_zbz :: MAT{CPX}*
      ft_x01,ft_x10,ft_y01,ft_y10,ft_z01,ft_z10 :: VEC{CPX}*
      pifac,gamma,g1,g4,dot1,dot2,k1,k2,k3,P1,P2,P3,PI_on_gamma :: REAL
      a,b,k,xa,ya,za,xb,yb,zb,bxlast,bylast,bzlast,aa,bb,k_max,fa,la,fb,lb :: INT
      fac1 :: CPX
      g1_exa,g1_exb,e00,ex_a,ex_b,ca,fac :: REAL
      Ex000,Ey000,Ez000,Ex001,Ey001,Ez001,Ex101,Ey101,Ez101 :: REAL
      Ex010,Ey010,Ez010,Ex110,Ey110,Ez110,Ex111,Ey111,Ez111 :: REAL
      Ex211,Ey211,Ez211,Ex011,Ey011,Ez011 :: REAL
      PA1,PA2,PA3,PB1,PB2,PB3,pp :: REAL
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      select case (.a.l)
        case (0)
          select case(.b.l)
            case (0)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              pos = .a.pos - .b.pos
              pp = dot_product(pos,pos)
              res_ij => res(:,1,1)
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              do a = 1, .a.n_cc
                ca = .a.cc(a)
                ex_a = .a.ex(a)
                do b = 1, .b.n_cc
                  ex_b = .b.ex(b)
                  g1 = ONE/(ex_a+ex_b)
                  g4 = -QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*ex_a
                  g1_exb = g1*ex_b
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  e00 = exp(-ex_a*ex_b*pp*g1)
                  fac1= cmplx(pifac*e00,ZERO,kind=CPX_KIND) * ca * .b.cc(b) * partition(a,b)
                  therm => thermal(:,a,b)
                  do k = 1, k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = g4 * (k1*k1+k2*k2+k3*k3)
                    res_ij(k) = res_ij(k) + therm(k) * (fac1 * exp(cmplx(dot2,dot1,kind=CPX_KIND)))
                  end
                end
              end
            case (1)
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              e.create((/0,1/),(/0,0/),(/0,1/))
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex101 = e(1,0,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey101 = e(1,0,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez101 = e(1,0,1)
                  fac = pifac * ca * .b.cc(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND))*therm(k)
                  end
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex001,Ex101*k_x,kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,1,2)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey001,Ey101*k_y,kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,1,3)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez001,Ez101*k_z,kind=CPX_KIND)*prefac(:)
                end
              end
              e.destroy
              prefac.destroy
            case default
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do b=0,.b.l ! incorporate prefac into ft_z
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
                  end
                  bxlast = bx(1)
                  bylast = by(1)
                  bzlast = bz(1)
                  ft_xb => ft_x(:,0,bxlast)
                  ft_yb => ft_y(:,0,bylast)
                  ft_zb => ft_z(:,0,bzlast)
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    if (bxlast/=xb) then
                      ft_xb => ft_x(:,0,xb)
                      bxlast = xb
                    end
                    if (bylast/=yb) then
                      ft_yb=> ft_y(:,0,yb)
                      bylast = yb
                    end
                    if (bzlast/=zb) then
                      ft_zb=> ft_z(:,0,zb)
                      bzlast = zb
                    end
                    res_ij => res(:,1,b)
                    res_ij(:) = res_ij(:) + ft_xb(:)*ft_yb(:)*ft_zb(:)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_y.destroy
              ft_z.destroy
              .normalise_ft(res)
          end
        case (1)
          select case (.b.l)
            case (0)
              prefac.create(k_max)
              e.create((/0,1/),(/0,1/),(/0,0/))
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex010 = e(0,1,0)
                  Ex110 = e(1,1,0)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey010 = e(0,1,0)
                  Ey110 = e(1,1,0)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez010 = e(0,1,0)
                  Ez110 = e(1,1,0)
                  fac = pifac * ca * .b.cc(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex010,Ex110*k_x(:),kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,2,1)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey010,Ey110*k_y(:),kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,3,1)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez010,Ez110*k_z(:),kind=CPX_KIND)*prefac(:)
                end
              end
              e.destroy
              prefac.destroy
            case (1)
              ft_x.create((/1,k_max/),(/0,1/),(/0,1/))
              ft_y.create((/1,k_max/),(/0,1/),(/0,1/))
              ft_z.create((/1,k_max/),(/0,1/),(/0,1/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              PA1 = .a.pos(1); PA2 = .a.pos(2); PA3 = .a.pos(3)
              PB1 = .b.pos(1); PB2 = .b.pos(2); PB3 = .b.pos(3)
              e.create((/0,2/),(/0,1/),(/0,1/))
              ft_x01.create(k_max)
              ft_x10.create(k_max)
              ft_y01.create(k_max)
              ft_y10.create(k_max)
              ft_z01.create(k_max)
              ft_z10.create(k_max)
              k_x2.create(k_max)
              k_y2.create(k_max)
              k_z2.create(k_max)
              k_x2=k_x*k_x
              k_y2=k_y*k_y
              k_z2=k_z*k_z
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*PA1 + g1_exb*PB1
                  P2 = g1_exa*PA2 + g1_exb*PB2
                  P3 = g1_exa*PA3 + g1_exb*PB3
                  fac = pifac * ca * .b.cc(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  G.make_e_coeff(e,1)
                  Ex000 = e(0,0,0)
                  Ex001 = e(0,0,1)
                  Ex010 = e(0,1,0)
                  Ex011 = e(0,1,1)
                  Ex101 = e(1,0,1)
                  Ex110 = e(1,1,0)
                  Ex111 = e(1,1,1)
                  Ex211 = e(2,1,1)
                  G.make_e_coeff(e,2)
                  Ey000 = e(0,0,0)
                  Ey001 = e(0,0,1)
                  Ey010 = e(0,1,0)
                  Ey011 = e(0,1,1)
                  Ey101 = e(1,0,1)
                  Ey110 = e(1,1,0)
                  Ey111 = e(1,1,1)
                  Ey211 = e(2,1,1)
                  G.make_e_coeff(e,3)
                  Ez000 = e(0,0,0)
                  Ez001 = e(0,0,1)
                  Ez010 = e(0,1,0)
                  Ez011 = e(0,1,1)
                  Ez101 = e(1,0,1)
                  Ez110 = e(1,1,0)
                  Ez111 = e(1,1,1)
                  Ez211 = e(2,1,1)
                  ft_x01(:) = cmplx(Ex001,Ex101*k_x(:),kind=CPX_KIND)
                  ft_x10(:) = cmplx(Ex010,Ex110*k_x(:),kind=CPX_KIND)
                  ft_y01(:) = cmplx(Ey001,Ey101*k_y(:),kind=CPX_KIND)
                  ft_y10(:) = cmplx(Ey010,Ey110*k_y(:),kind=CPX_KIND)
                  ft_z01(:) = cmplx(Ez001,Ez101*k_z(:),kind=CPX_KIND)
                  ft_z10(:) = cmplx(Ez010,Ez110*k_z(:),kind=CPX_KIND)
                  res_ij => res(:,1,1)
                  res_ij(:) = res_ij(:) + cmplx(Ex011-Ex211*k_x2(:),Ex111*k_x(:),kind=CPX_KIND)*Ey000*Ez000*prefac(:)
                  res_ij => res(:,2,1)
                  res_ij(:) = res_ij(:) + ft_x01(:)*ft_y10(:)*Ez000*prefac(:)
                  res_ij => res(:,3,1)
                  res_ij(:) = res_ij(:) + ft_x01(:)*Ey000*ft_z10(:)*prefac(:)
                  res_ij => res(:,1,2)
                  res_ij(:) = res_ij(:) + ft_x10(:)*ft_y01(:)*Ez000*prefac(:)
                  res_ij => res(:,2,2)
                  res_ij(:) = res_ij(:) + Ex000*cmplx(Ey011-Ey211*k_y2(:),Ey111*k_y(:),kind=CPX_KIND)*Ez000*prefac(:)
                  res_ij => res(:,3,2)
                  res_ij(:) = res_ij(:) + Ex000*ft_y01(:)*ft_z10(:)*prefac(:)
                  res_ij => res(:,1,3)
                  res_ij(:) = res_ij(:) + ft_x10(:)*Ey000*ft_z01(:)*prefac(:)
                  res_ij => res(:,2,3)
                  res_ij(:) = res_ij(:) + Ex000*ft_y10(:)*ft_z01(:)*prefac(:)
                  res_ij => res(:,3,3)
                  res_ij(:) = res_ij(:) + Ex000*Ey000*cmplx(Ez011-Ez211*k_z2(:),Ez111*k_z(:),kind=CPX_KIND)*prefac(:)
                end
              end
              k_z2.destroy
              k_y2.destroy
              k_x2.destroy
              ft_z10.destroy
              ft_z01.destroy
              ft_y10.destroy
              ft_y01.destroy
              ft_x10.destroy
              ft_x01.destroy
              e.destroy
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
            case default
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fb = .b.first_gaussian; lb = .b.last_gaussian
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
                  P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
                  P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do b=0,.b.l
                    ft_z(:,0,b) = ft_z(:,0,b) * prefac(:)
                    ft_z(:,1,b) = ft_z(:,1,b) * prefac(:)
                  end
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    ft_xb => ft_x(:,0,xb)
                    ft_yb => ft_y(:,0,yb)
                    ft_zb => ft_z(:,0,zb)
                    res_ij => res(:,1,b)
                    res_ij(:) = res_ij(:) + ft_x(:,1,xb)*ft_yb*ft_zb
                    res_ij => res(:,2,b)
                    res_ij(:) = res_ij(:) + ft_xb*ft_y(:,1,yb)*ft_zb
                    res_ij => res(:,3,b)
                    res_ij(:) = res_ij(:) + ft_xb*ft_yb*ft_z(:,1,zb)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
              .normalise_ft(res)
          end
        case default
          select case (.b.l)
            case (0)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
                  P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
                  P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do a=0,.a.l
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res_ij => res(:,a,1)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,0)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
              .normalise_ft(res)
            case (1)
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
                  P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
                  P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do a=0,.a.l ! incorporate prefac into ft_z
                    ft_z(:,a,0) = ft_z(:,a,0) * prefac(:)
                    ft_z(:,a,1) = ft_z(:,a,1) * prefac(:)
                  end
                  do a = 1,.a.n_comp
                    xa = ax(a)
                    ya = ay(a)
                    za = az(a)
                    res_ij => res(:,a,1)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,1)*ft_y(:,ya,0)*ft_z(:,za,0)
                    res_ij => res(:,a,2)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,1)*ft_z(:,za,0)
                    res_ij => res(:,a,3)
                    res_ij(:) = res_ij(:) + ft_x(:,xa,0)*ft_y(:,ya,0)*ft_z(:,za,1)
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
              .normalise_ft(res)
            case default
              ft_x.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_y.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              ft_z.create((/1,k_max/),(/0,.a.l/),(/0,.b.l/))
              prefac.create(k_max)
              k_x => k_pts(:,1); k_y => k_pts(:,2); k_z => k_pts(:,3)
              fa = .a.first_gaussian; la = .a.last_gaussian
              fb = .b.first_gaussian; lb = .b.last_gaussian
              ax => GAUSSIAN_DATA::px(fa:la); ay => GAUSSIAN_DATA::py(fa:la); az => GAUSSIAN_DATA::pz(fa:la)
              bx => GAUSSIAN_DATA::px(fb:lb); by => GAUSSIAN_DATA::py(fb:lb); bz => GAUSSIAN_DATA::pz(fb:lb)
             ! This is the general routine.  It includes reduced multiplication,
             ! and use of pointers to minimise array finding.
              do aa = 1, .a.n_cc
                ca = .a.cc(aa)
                ex_a=.a.ex(aa)
                G.set(ex_a=ex_a)
                do bb = 1, .b.n_cc
                  ex_b=.b.ex(bb)
                  G.set(ex_b=ex_b)
                  gamma = G.a.ex+G.b.ex
                  g1 = ONE/gamma
                  g4 = QUARTER*g1
                  PI_on_gamma = PI*g1
                  pifac = sqrt(PI_on_gamma) * PI_on_gamma
                  g1_exa = g1*G.a.ex
                  g1_exb = g1*G.b.ex
                  P1 = g1_exa*.a.pos(1) + g1_exb*.b.pos(1)
                  P2 = g1_exa*.a.pos(2) + g1_exb*.b.pos(2)
                  P3 = g1_exa*.a.pos(3) + g1_exb*.b.pos(3)
                  G.make_ft_component(ft_x,1,k_x,k_max)
                  G.make_ft_component(ft_y,2,k_y,k_max)
                  G.make_ft_component(ft_z,3,k_z,k_max)
                  fac = pifac * ca * .b.cc(bb) * partition(aa,bb)
                  therm => thermal(:,aa,bb)
                  do k = 1,k_max
                    k1 = k_x(k);    k2 = k_y(k);    k3 = k_z(k)
                    dot1 = k1*P1+k2*P2+k3*P3
                    dot2 = -g4 * (k1*k1+k2*k2+k3*k3)
                    prefac(k) = fac*exp(cmplx(dot2,dot1,kind=CPX_KIND)) * therm(k)
                  end
                  do b=0,.b.l ! incorporate prefac into ft_z
                    do a=0,.a.l
                      ft_z(:,a,b) = ft_z(:,a,b) * prefac(:)
                    end
                  end
                  bxlast = bx(1)
                  bylast = by(1)
                  bzlast = bz(1)
                  ft_xbx => ft_x(:,:,bxlast)
                  ft_yby => ft_y(:,:,bylast)
                  ft_zbz => ft_z(:,:,bzlast)
                  do b = 1,.b.n_comp
                    xb = bx(b)
                    yb = by(b)
                    zb = bz(b)
                    if (bxlast/=xb) then
                      ft_xbx => ft_x(:,:,xb)
                      bxlast = xb
                    end
                    if (bylast/=yb) then
                      ft_yby=> ft_y(:,:,yb)
                      bylast = yb
                    end
                    if (bzlast/=zb) then
                      ft_zbz=> ft_z(:,:,zb)
                      bzlast = zb
                    end
                    do a = 1,.a.n_comp
                      xa = ax(a)
                      ya = ay(a)
                      za = az(a)
                      res_ij => res(:,a,b)
                      res_ij(:) = res_ij(:) + ft_xbx(:,xa+1)*ft_yby(:,ya+1)*ft_zbz(:,za+1)
                    end
                  end
                end
              end
              prefac.destroy
              ft_x.destroy
              ft_z.destroy
              ft_y.destroy
              .normalise_ft(res)
          end
      end
   end

   make_gaussian_partition(res,factor_a,factor_b)
   ! Make the factors for partitioning the density contribution from
   ! each atom.
   ! Dimensions of res are [.a.n_cc,.b.n_cc].
     res :: MAT{REAL}, OUT
     factor_a,factor_b :: REAL, IN
     a,b :: INT
     ex_a,ex_b,exb_fb :: REAL
     do b = 1, .b.n_cc
       ex_b = .b.ex(b)
       exb_fb = ex_b * factor_b
       do a = 1, .a.n_cc
         ex_a = .a.ex(a)
         res(a,b) = (exb_fb + ex_a * factor_a) / (ex_a + ex_b)
       end
     end
   end

   make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)
   ! Make the thermal smearing correction according to Tanaka.
   ! Dimensions of "res" are [k_max,.a.n_cc,.b.n_cc].
   ! "res" contains the correction for each pair of primitives.
     res :: MAT3{REAL}, OUT
     k_pts,Ua,Ub :: MAT{REAL}, IN
     Ua_ea,Ub_eb,U :: MAT{REAL}(3,3)
     ! S,Utemp :: VEC{REAL}(3)
     ea,eb :: REAL
     U11,U22,U33,U21_12,U31_13,U32_23,S1,S2,S3 :: REAL
     a,b,k,k_max :: INT
     k_max  = size(k_pts,1)
     do a = 1, .a.n_cc
       ea = .a.ex(a)
       Ua_ea = ea * Ua
       do b = 1, .b.n_cc
         eb = .b.ex(b)
         Ub_eb = eb * Ub
         U = - HALF * (Ua_ea + Ub_eb) / (ea + eb)
         U11 = U(1,1)
         U22 = U(2,2)
         U33 = U(3,3)
         U21_12 = U(2,1) + U(1,2)
         U31_13 = U(3,1) + U(1,3)
         U32_23 = U(3,2) + U(2,3)
         do k = 1,k_max
           S1 = k_pts(k,1)
           S2 = k_pts(k,2)
           S3 = k_pts(k,3)
           res(k,a,b) = exp(S1*(S1*U11+S2*U21_12+S3*U31_13)+S2*(S2*U22+S3*U32_23)+S3*S3*U33)
           ! SUS has been expanded to save multiplies and array accesses.
 !          S = k_pts(k,:)
 !          Utemp = matmul(U,S)         ! Change coordinates of the U matrix.
 !          res(k,a,b) = exp(dot_product(S,Utemp))
         end
       end
     end
   end

   make_ft_nabla(res,k_pts)
   ! Calculates the Fourier transform for a product of the gradient of
   ! shell a minus shell b for two contracted gaussian shells, evaluated
   ! at a series of k points k_pts
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      res :: MAT4{CPX}
      k_pts :: MAT{REAL}, IN
       G :: GAUSSIAN2
      ft_ab :: MAT4{CPX}*
      a,b,k_max :: INT
      ca,cb,cacb :: REAL
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1, .a.n_cc
         G.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G.set(ex_b=.b.ex(b))
            cb = .b.cc(b)
            cacb = ca*cb
            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G.make_ft_nabla(ft_ab,k_pts)
            res = res + ft_ab*cacb
            ft_ab.destroy
         end
      end
      .normalise_ft(res(:,:,:,1))
      .normalise_ft(res(:,:,:,2))
      .normalise_ft(res(:,:,:,3))
   end

   make_ft_nabla(res,k_pts,thermal,partition)
   ! Calculates "res" the Fourier transform for a product of the gradient of
   ! shell a minus shell b for two contracted gaussian shells, evaluated
   ! at a series of k points "k_pts", including "thermal" smearing corrections
   ! and "partition" factors.
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      res :: MAT4{CPX}
      k_pts,partition :: MAT{REAL}, IN
      thermal :: MAT3{REAL}, target
      therm :: VEC{REAL}*
       G :: GAUSSIAN2
      ft_ab :: MAT4{CPX}*
      a,b,k_max,i,j :: INT
      ca,cb,fac :: REAL
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1, .a.n_cc
         G.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G.set(ex_b=.b.ex(b))
            cb = .b.cc(b)
            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G.make_ft_nabla(ft_ab,k_pts)
            fac   =  ca*cb*partition(a,b)
            therm => thermal(:,a,b)
            do i = 1,.a.n_comp
            do j = 1,.b.n_comp
                res(:,i,j,1) = res(:,i,j,1) + ft_ab(:,i,j,1) * fac * therm(:)
                res(:,i,j,2) = res(:,i,j,2) + ft_ab(:,i,j,2) * fac * therm(:)
                res(:,i,j,3) = res(:,i,j,3) + ft_ab(:,i,j,3) * fac * therm(:)
            end
            end
            ft_ab.destroy
         end
      end
      .normalise_ft(res(:,:,:,1))
      .normalise_ft(res(:,:,:,2))
      .normalise_ft(res(:,:,:,3))
   end

   make_ft_r(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      k_pts :: MAT{REAL}, IN
      res :: MAT4{CPX}
       G :: GAUSSIAN2
      ft_ab :: MAT4{CPX}*
      a,b,k_max :: INT
      ca,cb,cacb :: REAL
      k_max  = size(k_pts,1)
      res = ZERO
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1, .a.n_cc
         G.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G.set(ex_b=.b.ex(b))
            cb = .b.cc(b)
            cacb = ca*cb
            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G.make_ft_r(ft_ab,k_pts)
            res = res + ft_ab*cacb
            ft_ab.destroy
         end
      end
      .normalise_ft(res(:,:,:,1))
      .normalise_ft(res(:,:,:,2))
      .normalise_ft(res(:,:,:,3))
   end

   make_spherically_averaged_ft(res,k_values)
   ! Calculates the spherically averaged Fourier transform for a product of two
   ! contracted gaussian shells, "res", evaluated at a series of "k_values".
   ! Dimensions of res are [.a.n_comp,.b.n_comp,k_values.dim].
      res :: MAT3{CPX}, target
      k_values :: VEC{REAL}, IN
   ENSURE(res.dim1==.a.n_comp,"wrong 1st dimension for res")
   ENSURE(res.dim2==.b.n_comp,"wrong 2nd dimension for res")
   ENSURE(res.dim3==k_values.dim,"wrong 3rd dimension for res")
      G :: GAUSSIAN2
      k_pts :: MAT{REAL}*
      ft_ab :: MAT3{CPX}*
      wt,fac_wt :: VEC{REAL}*
      k,n,n_pts,t,p, a,b,i,j :: INT
      k_val,k_val_st,th,ph,ct,st,cp,sp,ca,fac :: REAL
      theta,phi :: QUADRATURE*
      ! First set the quadrature objects
      n = 10
      n_pts = 2*n*n
      theta.create 
      theta.set_kind("gauss_legendre")
      theta.set_n_points(n)
      theta.set_quadrature_points
      theta.set_limits([ZERO,PI])
      phi.create 
      phi.set_kind("gauss_legendre")
      phi.set_n_points(2*n)
      phi.set_quadrature_points
      phi.set_limits([ZERO,2*PI])
      ! Loop over each k_value one by one
      res = ZERO
      wt.create(n_pts)
      fac_wt.create(n_pts)
      k_pts.create(n_pts,3)
      ft_ab.create(n_pts,.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do k = 1,k_values.dim
         k_val = k_values(k)
         n = 0
         ! For each k_value, define a shell of spherical k_pts
         do t = 1,theta.n_points
         do p = 1,phi.n_points
            n = n + 1
            th = theta.point(t)
            ph = phi.point(p)
            ct = cos(th); st = sin(th)
            cp = cos(ph); sp = sin(ph)
            k_val_st = k_val*st
            k_pts(n,1) = k_val_st*cp    ! the spherical shell
            k_pts(n,2) = k_val_st*sp
            k_pts(n,3) = k_val*ct
            wt(n) = st*theta.weight(t)*phi.weight(p) ! the area x weights
         end
         end
         ! Now do the Fourier transform for this shell, and average it
       ! .make_ft_fast(ft_ab,k_pts)
       ! .make_ft(ft_ab,k_pts)
       ! do b = 1,.b.n_comp
       ! do a = 1,.a.n_comp
       !    res(a,b,k) = res(a,b,k) + sum(ft_ab(:,a,b)*wt)
       ! end
       ! end
         do a = 1,.a.n_cc
            G.set(ex_a=.a.ex(a))
            ca = .a.cc(a)
            do b = 1,.b.n_cc
               G.set(ex_b=.b.ex(b))
               G.make_ft(ft_ab,k_pts)
               fac = ca*.b.cc(b)
               fac_wt = fac*wt
               do j = 1,.b.n_comp
               do i = 1,.a.n_comp
                   res(i,j,k) = res(i,j,k) + sum(ft_ab(:,i,j)*fac_wt)
               end
               end
            end
         end
      end
      ft_ab.destroy
      k_pts.destroy
      fac_wt.destroy
      wt.destroy
      phi.destroy; theta.destroy
      .normalise_ft2(res) 
      fac = ONE/(FOUR*PI)
      res = fac*res
   end

   make_z_circularly_averaged_ft(res,k_values,n_theta)
   ! Calculates the z circularly averaged Fourier transform for a product of two
   ! contracted gaussian shells, "res", evaluated at a series of "k_values" in
   ! reciprocal space, and with "n_theta" equally spaced angles from the z axis,
   ! from 0 -> 2*Pi. Size of "res" is [.a.n_comp,.b.n_comp,k_values.dim,n_theta].
      res :: MAT4{CPX}, target
      k_values :: VEC{REAL}, IN
      n_theta :: INT, IN
   ENSURE(res.dim1==.a.n_comp,"wrong 1st dimension for res")
   ENSURE(res.dim2==.b.n_comp,"wrong 2nd dimension for res")
   ENSURE(res.dim3==k_values.dim,"wrong 3rd dimension for res")
   ENSURE(res.dim4==n_theta+1,"wrong 4th dimension for res")
      G :: GAUSSIAN2
      k_pts :: MAT{REAL}*
      ft_ab :: MAT3{CPX}*
      wt,fac_wt :: VEC{REAL}*
      k,n,n_pts,t,p, a,b,i,j,f,l :: INT
      k_val,k_val_st,th,ph,ct,st,cp,sp,ca,fac,angle :: REAL
      phi :: QUADRATURE*
      ! First set the quadrature objects
      angle = (PI/(2*n_theta))
      n = 10                  ! points per Pi for phi
      n_pts = 2*n*(n_theta+1) ! 
      phi.create 
      phi.set_kind("gauss_legendre")
      phi.set_n_points(2*n)
      phi.set_quadrature_points
      phi.set_limits([ZERO,2*PI])
      ! Loop over each k_value one by one
      res = ZERO
      wt.create(n_pts)
      fac_wt.create(n_pts)
      k_pts.create(n_pts,3)
      ft_ab.create(n_pts,.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do k = 1,k_values.dim
         k_val = k_values(k)
         n = 0
         ! For each k_value, define a shell of spherical k_pts
         do t = 0,n_theta
         do p = 1,phi.n_points
            n = n + 1
            th = t*angle
            ph = phi.point(p)
            ct = cos(th); st = sin(th)
            cp = cos(ph); sp = sin(ph)
            k_val_st = k_val*st
            k_pts(n,1) = k_val_st*cp    ! the spherical shell
            k_pts(n,2) = k_val_st*sp
            k_pts(n,3) = k_val*ct
         end
         end
         ! Now do the Fourier transform for this shell, and average it
         .make_ft_fast(ft_ab,k_pts)
         f = 1
         l = phi.n_points
         do t = 1,n_theta+1
            do b = 1,.b.n_comp
            do a = 1,.a.n_comp
               res(a,b,k,t) = res(a,b,k,t) + sum(ft_ab(f:l,a,b)*phi.weight)
            end
            end
            f = f + phi.n_points
            l = l + phi.n_points
         end
       ! f = 1
       ! l = phi.n_points
       ! do t = 1,n_theta+1
       !    do a = 1,.a.n_cc
       !       G.set(ex_a=.a.ex(a))
       !       ca = .a.cc(a)
       !       do b = 1,.b.n_cc
       !          G.set(ex_b=.b.ex(b))
       !          G.make_ft(ft_ab,k_pts)
       !          fac = ca*.b.cc(b)
       !          fac_wt = fac*phi.weight
       !          do j = 1,.b.n_comp
       !          do i = 1,.a.n_comp
       !              res(i,j,k,t) = res(i,j,k,t) + sum(ft_ab(f:l,i,j)*fac_wt)
       !          end
       !          end
       !       end
       !    end
       !    f = f + phi.n_points
       !    l = l + phi.n_points
       ! end
      end
      ft_ab.destroy
      k_pts.destroy
      fac_wt.destroy
      wt.destroy
      phi.destroy
      .normalise_ft4(res) 
      fac = ONE/(TWO*PI)
      res = fac*res
   end

!  *********************************
!  Simplistic CADPAC-style integrals
!  *********************************

   make_overlap_ints(S)
   ! Calculates overlap integral matrix, using Gauss-Hermite quadrature, like in
   ! CADPAC
       S :: MAT{REAL}
      SS :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      S = ZERO
      SS.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_overlap_ints(SS)
         cacb = .a.cc(a)*.b.cc(b)
         S = S + SS*cacb
      end
      end
      SS.destroy
      .normalise(S)
   end

   make_oscillator_overlap_ints(S,c,d,lc_min,lc_max,ld_min,ld_max)
   ! Calculates oscillator overlap integral matrix, using Gauss-Hermite
   ! quadrature, like in CADPAC
      S :: MAT4{REAL}
      c,d :: VEC{REAL}(3)
      lc_min,lc_max,ld_min,ld_max :: INT
   ENSURE(S.dim1==.a.n_comp,"wrong size for S")
   ENSURE(S.dim2==.b.n_comp,"wrong size for S")
   ENSURE(S.dim3==(SHELL2::n_comp_up_to(lc_max)-SHELL2::n_comp_up_to(lc_min-1)),"wrong size for S")
   ENSURE(S.dim4==(SHELL2::n_comp_up_to(ld_max)-SHELL2::n_comp_up_to(ld_min-1)),"wrong size for S")
      SS :: MAT4{REAL}*
      G :: GAUSSIAN2
      cacb :: REAL
      a,b,nc,nd :: INT
      S = ZERO
      nc = SHELL2::n_comp_up_to(lc_max) - SHELL2::n_comp_up_to(lc_min-1)
      nd = SHELL2::n_comp_up_to(ld_max) - SHELL2::n_comp_up_to(ld_min-1)
      SS.create(.a.n_comp,.b.n_comp,nc,nd)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         cacb = .a.cc(a)*.b.cc(b)
         G.make_oscillator_overlap_ints(SS,c,d,lc_min,lc_max,ld_min,ld_max)
         S = S + SS*cacb
      end
      end
      SS.destroy
      .normalise(S)
   end

   make_S_1st_deriv_ints(Ax,Ay,Az)
   ! Calculates the derivatives of the overlap integrals with respect to
   ! position A, in "Ax", "Ay", and "Az" using Gauss-Hermite quadrature.
      Ax,Ay,Az :: MAT{REAL}
      AAx,AAy,AAz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Ax = ZERO; Ay = ZERO; Az = ZERO
      AAx.create(.a.n_comp,.b.n_comp)
      AAy.create(.a.n_comp,.b.n_comp)
      AAz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_S_1st_deriv_ints(AAx,AAy,AAz)
         cacb = .a.cc(a)*.b.cc(b)
         Ax = Ax + AAx*cacb
         Ay = Ay + AAy*cacb
         Az = Az + AAz*cacb
      end
      end
      AAz.destroy
      AAy.destroy
      AAx.destroy
      .normalise(Ax); .normalise(Ay); .normalise(Az)
   end

   make_T_1st_deriv_ints(Ax,Ay,Az)
   ! Calculates the derivatives of the kinetic integrals with respect to
   ! position A, in "Ax", "Ay", and "Az" using Gauss-Hermite quadrature.
      Ax,Ay,Az :: MAT{REAL}
      AAx,AAy,AAz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Ax = ZERO; Ay = ZERO; Az = ZERO
      AAx.create(.a.n_comp,.b.n_comp)
      AAy.create(.a.n_comp,.b.n_comp)
      AAz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_T_1st_deriv_ints(AAx,AAy,AAz)
         cacb = .a.cc(a)*.b.cc(b)
         Ax = Ax + AAx*cacb
         Ay = Ay + AAy*cacb
         Az = Az + AAz*cacb
      end
      end
      AAz.destroy
      AAy.destroy
      AAx.destroy
      .normalise(Ax); .normalise(Ay); .normalise(Az)
   end

   make_NA_1st_deriv_ints(Ax,Ay,Az,Bx,By,Bz,c)
   ! Calculates the derivatives of the nuclear attraction integrals with respect to
   ! positions A *and* B, in "Ax", "Ay", "Az", and "Bx", "By", "Bz" for a given
   ! nuclear position "c".
      Ax,Ay,Az, Bx,By,Bz :: MAT{REAL}
       c :: VEC{REAL}(3)
      AAx,AAy,AAz, BBx,BBy,BBz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Ax = ZERO; Ay = ZERO; Az = ZERO
      Bx = ZERO; By = ZERO; Bz = ZERO
      AAx.create(.a.n_comp,.b.n_comp)
      AAy.create(.a.n_comp,.b.n_comp)
      AAz.create(.a.n_comp,.b.n_comp)
      BBx.create(.a.n_comp,.b.n_comp)
      BBy.create(.a.n_comp,.b.n_comp)
      BBz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_NA_1st_deriv_ints(AAx,AAy,AAz,BBx,BBy,BBz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Ax = Ax + AAx*cacb
         Ay = Ay + AAy*cacb
         Az = Az + AAz*cacb
         Bx = Bx + BBx*cacb
         By = By + BBy*cacb
         Bz = Bz + BBz*cacb
      end
      end
      BBz.destroy; BBy.destroy; BBx.destroy
      AAz.destroy; AAy.destroy; AAx.destroy
      .normalise(Ax); .normalise(Ay); .normalise(Az)
      .normalise(Bx); .normalise(By); .normalise(Bz)
   end

   make_dipole_ints(Dx,Dy,Dz,origin)
   ! Make the dipole moment integral matrices "Di"
   ! with gauge origin "origin"
      Dx,Dy,Dz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      DDx,DDy,DDz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Dx = ZERO; Dy = ZERO; Dz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_dipole_ints(DDx,DDy,DDz,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Dx = Dx + DDx*cacb; Dy = Dy + DDy*cacb; Dz = Dz + DDz*cacb
      end
      end
      DDz.destroy; DDy.destroy; DDx.destroy
      .normalise(Dx); .normalise(Dy); .normalise(Dz)
   end

   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin)
   ! Make the quadrupole moment integral matrices "Qij"
   ! with gauge origin "origin"
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      QQxx,QQyy,QQzz,QQxy,QQxz,QQyz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
      Qxy = ZERO; Qxz = ZERO; Qyz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Qxx = Qxx + QQxx*cacb; Qyy = Qyy + QQyy*cacb; Qzz = Qzz + QQzz*cacb
         Qxy = Qxy + QQxy*cacb; Qxz = Qxz + QQxz*cacb; Qyz = Qyz + QQyz*cacb
      end
      end
      QQyz.destroy; QQxz.destroy; QQxy.destroy
      QQzz.destroy; QQyy.destroy; QQxx.destroy
      .normalise(Qxx); .normalise(Qyy); .normalise(Qzz)
      .normalise(Qxy); .normalise(Qxz); .normalise(Qyz)
   end

   make_octupole_ints(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz,origin)
   ! Make the octupole moment integral matrices "Oijk"
   ! with gauge origin "origin"
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Oxxx = ZERO; Oyyy = ZERO; Ozzz = ZERO
      Oxxy = ZERO; Oxxz = ZERO
      Oyyx = ZERO; Oyyz = ZERO
      Ozzx = ZERO; Ozzy = ZERO
      Oxyz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      OOxxx.create(n_a,n_b); OOyyy.create(n_a,n_b); OOzzz.create(n_a,n_b)
      OOxxy.create(n_a,n_b); OOxxz.create(n_a,n_b)
      OOyyx.create(n_a,n_b); OOyyz.create(n_a,n_b)
      OOzzx.create(n_a,n_b); OOzzy.create(n_a,n_b)
      OOxyz.create(n_a,n_b)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_octupole_ints(OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Oxxx = Oxxx + OOxxx*cacb; Oyyy = Oyyy + OOyyy*cacb; Ozzz = Ozzz + OOzzz*cacb
         Oxxy = Oxxy + OOxxy*cacb; Oxxz = Oxxz + OOxxz*cacb
         Oyyx = Oyyx + OOyyx*cacb; Oyyz = Oyyz + OOyyz*cacb
         Ozzx = Ozzx + OOzzx*cacb; Ozzy = Ozzy + OOzzy*cacb
         Oxyz = Oxyz + OOxyz*cacb
      end
      end
      OOxyz.destroy
      OOzzy.destroy; OOzzx.destroy
      OOyyz.destroy; OOyyx.destroy
      OOxxz.destroy; OOxxy.destroy
      OOzzz.destroy; OOyyy.destroy; OOxxx.destroy
      .normalise(Oxxx); .normalise(Oyyy); .normalise(Ozzz)
      .normalise(Oxxy); .normalise(Oxxz)
      .normalise(Oyyx); .normalise(Oyyz)
      .normalise(Ozzx); .normalise(Ozzy)
      .normalise(Oxyz)
   end

   make_nuclear_attraction_ints(N,c)
   ! Make the nuclear attraction integral matrix "N" for nucleus at position "c"
       N :: MAT{REAL}
       c :: VEC{REAL}(3)
      NN :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      N = ZERO
      NN.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_nuclear_attraction_ints(NN,c)
         cacb = .a.cc(a)*.b.cc(b)
         N = N + NN*cacb
      end
      end
      NN.destroy
      .normalise(N)
   end

   make_E_field_ints(Ex,Ey,Ez,p)
   ! Make the electric field integral matrices "Ei" evaluated at
   ! the position "p"
      Ex,Ey,Ez :: MAT{REAL}
       p :: VEC{REAL}(3)
      EEx,EEy,EEz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Ex = ZERO; Ey = ZERO; Ez = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      EEx.create(n_a,n_b); EEy.create(n_a,n_b); EEz.create(n_a,n_b)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_E_field_ints(EEx,EEy,EEz,p)
         cacb = .a.cc(a)*.b.cc(b)
         Ex = Ex + EEx*cacb; Ey = Ey + EEy*cacb; Ez = Ez + EEz*cacb
      end
      end
      EEz.destroy; EEy.destroy; EEx.destroy
      .normalise(Ex); .normalise(Ey); .normalise(Ez)
   end

   make_E_gradient_ints(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)
   ! Make the electric field gradient integral matrices "Eij" evaluated
   ! at the position "c".
      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}
       c :: VEC{REAL}
      EExx,EEyy,EEzz,EExy,EExz,EEyz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Exx = ZERO; Eyy = ZERO; Ezz = ZERO
      Exy = ZERO; Exz = ZERO; Eyz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      EExx.create(n_a,n_b); EEyy.create(n_a,n_b); EEzz.create(n_a,n_b)
      EExy.create(n_a,n_b); EExz.create(n_a,n_b); EEyz.create(n_a,n_b)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_E_gradient_ints(EExx,EEyy,EEzz,EExy,EExz,EEyz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Exx = Exx + EExx*cacb; Eyy = Eyy + EEyy*cacb; Ezz = Ezz + EEzz*cacb
         Exy = Exy + EExy*cacb; Exz = Exz + EExz*cacb; Eyz = Eyz + EEyz*cacb
      end
      end
      EEyz.destroy; EExz.destroy; EExy.destroy
      EEzz.destroy; EEyy.destroy; EExx.destroy
      .normalise(Exx); .normalise(Eyy); .normalise(Ezz)
      .normalise(Exy); .normalise(Exz); .normalise(Eyz)
   end

   make_spin_orbit_ints(Lx,Ly,Lz,c)
   ! Make the spin orbit integral matrices "Lx" "Ly" and "Lz" for nucleus at
   ! position "c"
      Lx,Ly,Lz :: MAT{REAL}
       c :: VEC{REAL}(3)
      LLx,LLy,LLz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Lx = ZERO; Ly = ZERO; Lz = ZERO
      LLx.create(.a.n_comp,.b.n_comp)
      LLy.create(.a.n_comp,.b.n_comp)
      LLz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_spin_orbit_ints(LLx,LLy,LLz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Lx = Lx + LLx*cacb
         Ly = Ly + LLy*cacb
         Lz = Lz + LLz*cacb
      end
      end
      LLz.destroy; LLy.destroy; LLx.destroy
      .normalise(Lx); .normalise(Ly); .normalise(Lz)
   end

   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)
   ! Make the gauge modified (B field) spin orbit integral matrices "Qij"
   ! for nucleus at position "c" and gauge origin "origin"
      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}
      c,origin :: VEC{REAL}(3)
      QQxx,QQxy,QQxz,QQyx,QQyy,QQyz,QQzx,QQzy,QQzz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b,n_a,n_b :: INT
      cacb :: REAL
      Qxx = ZERO; Qyx = ZERO; Qzx = ZERO
      Qxy = ZERO; Qyy = ZERO; Qzy = ZERO
      Qxz = ZERO; Qyz = ZERO; Qzz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      QQxx.create(n_a,n_b); QQyx.create(n_a,n_b); QQzx.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQyy.create(n_a,n_b); QQzy.create(n_a,n_b)
      QQxz.create(n_a,n_b); QQyz.create(n_a,n_b); QQzz.create(n_a,n_b)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_spin_orbit_B_ints(QQxx,QQxy,QQxz,QQyx,QQyy,QQyz,QQzx,QQzy,QQzz,c,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Qxx = Qxx + QQxx*cacb; Qxy = Qxy + QQxy*cacb; Qxz = Qxz + QQxz*cacb
         Qyx = Qyx + QQyx*cacb; Qyy = Qyy + QQyy*cacb; Qyz = Qyz + QQyz*cacb
         Qzx = Qzx + QQzx*cacb; Qzy = Qzy + QQzy*cacb; Qzz = Qzz + QQzz*cacb
      end
      end
      QQzz.destroy; QQyz.destroy; QQxz.destroy
      QQzy.destroy; QQyy.destroy; QQxy.destroy
      QQzx.destroy; QQyx.destroy; QQxx.destroy
      .normalise(Qxx); .normalise(Qxy); .normalise(Qxz)
      .normalise(Qyx); .normalise(Qyy); .normalise(Qyz)
      .normalise(Qzx); .normalise(Qzy); .normalise(Qzz)
   end

   make_L_ints(Lx,Ly,Lz,origin)
   ! Calculate the angular momentum integral matrices "Lx", "Ly", "Lz",
   ! with "origin" as gauge origin, using Gauss-Hermite quadrature
      Lx,Ly,Lz :: MAT{REAL}
      origin :: VEC{REAL}(3)
      LLx,LLy,LLz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Lx = ZERO; Ly = ZERO; Lz = ZERO
      LLx.create(.a.n_comp,.b.n_comp)
      LLy.create(.a.n_comp,.b.n_comp)
      LLz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_L_ints(LLx,LLy,LLz,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Lx = Lx + LLx*cacb
         Ly = Ly + LLy*cacb
         Lz = Lz + LLz*cacb
      end
      end
      LLz.destroy; LLy.destroy; LLx.destroy
      .normalise(Lx); .normalise(Ly); .normalise(Lz)
   end

   make_solenoidal_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal "Ji" integral matrices evaluated at position "c"
      Jx,Jy,Jz :: MAT{REAL}
       c :: VEC{REAL}(3)
      Ix,Iy,Iz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_solenoidal_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
      .normalise(Jx); .normalise(Jy); .normalise(Jz)
   end

   make_irrotational_jp_ints(Jx,Jy,Jz,c)
   ! Make the irrotational "Ji" integral matrices evaluated at position "c"
      Jx,Jy,Jz :: MAT{REAL}
       c :: VEC{REAL}(3)
      Ix,Iy,Iz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_irrotational_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
      .normalise(Jx); .normalise(Jy); .normalise(Jz)
   end

   make_magnetic_jp_ints(Jx,Jy,Jz,c)
   ! Make the magnetic "Ji" integral matrices evaluated at position "c"
      Jx,Jy,Jz :: MAT{REAL}
       c :: VEC{REAL}(3)
      Ix,Iy,Iz :: MAT{REAL}*
       G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_magnetic_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
      .normalise(Jx); .normalise(Jy); .normalise(Jz)
   end

   make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,c)
   ! Make the magnetic "Mij" integral matrices evaluated at position "c"
      Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz :: MAT{REAL}
      c :: VEC{REAL}(3)
      Ixx,Ixy,Ixz,Iyx,Iyy,Iyz,Izx,Izy,Izz :: MAT{REAL}*
      G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Mxx = ZERO; Mxy = ZERO; Mxz = ZERO
      Myx = ZERO; Myy = ZERO; Myz = ZERO
      Mzx = ZERO; Mzy = ZERO; Mzz = ZERO
      Ixx.create(.a.n_comp,.b.n_comp)
      Ixy.create(.a.n_comp,.b.n_comp)
      Ixz.create(.a.n_comp,.b.n_comp)
      Iyx.create(.a.n_comp,.b.n_comp)
      Iyy.create(.a.n_comp,.b.n_comp)
      Iyz.create(.a.n_comp,.b.n_comp)
      Izx.create(.a.n_comp,.b.n_comp)
      Izy.create(.a.n_comp,.b.n_comp)
      Izz.create(.a.n_comp,.b.n_comp)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_magnetic_S_ints(Ixx,Ixy,Ixz,Iyx,Iyy,Iyz,Izx,Izy,Izz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Mxx = Mxx + Ixx*cacb; Mxy = Mxy + Ixy*cacb; Mxz = Mxz + Ixz*cacb
         Myx = Myx + Iyx*cacb; Myy = Myy + Iyy*cacb; Myz = Myz + Iyz*cacb
         Mzx = Mzx + Izx*cacb; Mzy = Mzy + Izy*cacb; Mzz = Mzz + Izz*cacb
      end
      end
      Izz.destroy; Izy.destroy; Izx.destroy
      Iyz.destroy; Iyy.destroy; Iyx.destroy
      Ixz.destroy; Ixy.destroy; Ixx.destroy
      .normalise(Mxx); .normalise(Mxy); .normalise(Mxz)
      .normalise(Myx); .normalise(Myy); .normalise(Myz)
      .normalise(Mzx); .normalise(Mzy); .normalise(Mzz)
   end

   make_magnetic_S_ints(M,c)
   ! Make the magnetic "M(:,:,i,j)" integral matrices evaluated at position "c"
      M :: MAT4{REAL}, target
      c :: VEC{REAL}(3)
   ENSURE(M.dim3==3,"wrong shape for M")
   ENSURE(M.dim4==3,"wrong shape for M")
      I :: MAT4{REAL}*
      G :: GAUSSIAN2
      a,b :: INT
      cacb :: REAL
      Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz :: MAT{REAL}*
      M = ZERO
      I.create(.a.n_comp,.b.n_comp,3,3)
      G.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.set(.a.ex(a),.b.ex(b))
         G.make_magnetic_S_ints(I,c)
         cacb = .a.cc(a)*.b.cc(b)
         M = M + I*cacb
      end
      end
      I.destroy
      Mxx => M(:,:,1,1); Mxy => M(:,:,1,2); Mxz => M(:,:,1,3)
      Myx => M(:,:,2,1); Myy => M(:,:,2,2); Myz => M(:,:,2,3)
      Mzx => M(:,:,3,1); Mzy => M(:,:,3,2); Mzz => M(:,:,3,3)
      .normalise(Mxx); .normalise(Mxy); .normalise(Mxz)
      .normalise(Myx); .normalise(Myy); .normalise(Myz)
      .normalise(Mzx); .normalise(Mzy); .normalise(Mzz)
   end

!  ******************************
!  Roland Lindh's style integrals
!  ******************************

   make_overlap(ab)
   ! Calculate the overlap matrix for the two shells
     ab :: MAT{REAL}
     es :: VEC{REAL}*
     n :: INT
     n = SHELL2::n_comp_up_to(.a.l+.b.l) - SHELL2::n_comp_up_to(.l_max-1)
     es.create(n)
     .make_overlap_es(es)
     .transfer(es,ab)
     es.destroy
     .normalise(ab)
   end

   make_overlap_es(es) ::: private
   ! Make the (es) overlap integrals, summed over primitives
     self :: IN
     es :: VEC{REAL}, OUT
     temp :: VEC{REAL}*
     AB :: VEC{REAL}(3)
     a,b,templb,tempub,i :: INT
     r2ab,ea,eb :: REAL

     tempub = SHELL2::n_comp_up_to(.l_sum)
     templb = SHELL2::n_comp_up_to(.l_max-1) + 1
     temp.create(tempub)

     AB = .a.pos - .b.pos
     r2ab = dot_product(AB,AB)

     es=ZERO
     i = 0
     do b=1, .b.n_cc
       eb=.b.ex(b)
       do a=1, .a.n_cc
         i = i + 1
         ea=.a.ex(a)
         .form_overlap_es(temp,ea,eb,r2ab,i)
         es=es + .a.cc(a) * .b.cc(b) * temp(templb:tempub)
       end
     end
     temp.destroy
   end

   form_overlap_es(es,ea,eb,r2ab,i) ::: private
   ! Form the (es) overlap integrals for a pair of primitives
     self :: IN
     es :: VEC{REAL}, INOUT
     r2ab,ea,eb :: REAL, IN
     i :: INT, IN
     PE :: VEC{REAL}(3)
     half_zinv,zinv,zeta,zz,PI_zinv,PEi :: REAL
     j,ne,z,lz,a1,a2,tmp :: INT

     zeta = .exponent_sum(i)
     zinv = .exponent_inv(i)
     zz = ea*eb/zeta

     PI_zinv = PI/zeta
     es = ZERO
     es(1) = PI_zinv*sqrt(PI_zinv) * exp(-zz*r2ab)          ! s||s

     if (.l_sum > 0) then
       half_zinv = HALF*zinv
       PE = .center_diff(:,i)
       es(2) = PE(1) * es(1)                                ! p||s
       es(3) = PE(2) * es(1)
       es(4) = PE(3) * es(1)

       if (.l_sum > 1) then
         ne = SHELL2::n_comp_up_to(.l_sum)
         do j = 5,ne                                        ! d||s to .l_sum||s
            a1 = GAUSSIAN_DATA::index_m1(j)
            z  = GAUSSIAN_DATA::first_nonzero(j)
            lz = GAUSSIAN_DATA::pp(z,j)
            PEi = PE(z)
            if (lz < 2) then
              es(j) = PEi * es(a1)
            else
              a2 = index_m1(a1)
              es(j) = PEi * es(a1) + half_zinv * (lz-1) * es(a2)
            end
         end
       end
     end
   end

!   s_overlap(zeta,zz,r2) result (res) ::: elemental, private
!   ! Calculate the overlap of two s functions.
!     self :: IN
!     zeta,zz,r2 :: REAL, IN
!     res :: REAL
!     PI_zinv :: REAL
!     PI_zinv = PI/zeta
!     res=PI_zinv*sqrt(PI_zinv) * exp(-zz*r2)
!   end

   get_kei(kei,overlap)
   ! Calculate the kinetic energy and overlap (optional) integrals.
   ! (More efficient than making them separate).
     self :: IN
     kei :: MAT{REAL}, INOUT
     overlap :: MAT{REAL}, INOUT, optional
     .make_kei(kei,overlap)
     if (present(overlap)) .normalise(overlap)
     .normalise(kei)
   end

   make_kei(kei,overlap)
   ! Makes the kei and overlap matrics, summed over primitives
   ! Is called by kei, but does not do the orbital normalisation corrections
     self :: IN
     kei :: MAT{REAL}, INOUT
     overlap :: MAT{REAL}, INOUT, optional
     temp_kei,temp_overlap :: MAT{REAL}*
     P,PA,PB,ara,brb,AB :: VEC{REAL}(3)
     a,b,alb,aub,blb,bub :: INT
     ca,ea,eb,zeta,zinv2,r2ab :: REAL
     alb = SHELL2::n_comp_up_to(.a.l-1) + 1; aub = alb + .a.n_comp -1
     blb = SHELL2::n_comp_up_to(.b.l-1) + 1; bub = blb + .b.n_comp -1
     temp_kei.create(aub,bub)
     temp_overlap.create(aub,bub)
     kei=ZERO
     if (present(overlap)) overlap=ZERO
     AB = .a.pos - .b.pos
     r2ab = dot_product(AB,AB)
     do a=1, .a.n_cc
       ca=.a.cc(a)
       ea=.a.ex(a)
       ara=ea*.a.pos
       do b=1, .b.n_cc
         eb    = .b.ex(b)
         brb   = eb * .b.pos
         zeta  = ea + eb
         zinv2 = HALF / zeta
         P     = (ara + brb) / zeta
         PA    = P - .a.pos
         PB    = P - .b.pos
         if (.a.l > .b.l) then
           .form_overlap_mat_a(temp_kei,temp_overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
         else
           .form_overlap_mat_b(temp_kei,temp_overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
         end
         if (present(overlap)) &
           overlap = overlap + ca * .b.cc(b) * temp_overlap(alb:aub,blb:bub)
         kei = kei + ca * .b.cc(b) * temp_kei(alb:aub,blb:bub)
       end
     end
     temp_kei.destroy
     temp_overlap.destroy
   end

   form_overlap_mat_a(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab) ::: private
   ! Makes the kinetic energy and overlap matrices for a primitive pair
   ! if .a.l > .b.l
     self :: IN
     overlap,kei :: MAT{REAL}, INOUT
     PA,PB :: VEC{REAL}(3), IN
     zinv2,zeta,ea,eb,r2ab :: REAL, IN
     b_momenta :: VEC{INT}(3)
     j,z,lza,lzb,a,a1,a2,b,b1,laub,na,nb,b_n_comp_sum :: INT
     la,lb,la1_n_comp_sum,lb1_n_comp_sum,la_n_comp_sum,lb_n_comp_sum :: INT
     PAi,PBi,PI_zinv,zz,zz2,zinv2_na,zinv2_nb,zz_ea,zz_eb,zz_ea_na :: REAL

     zz       = ea * eb / zeta
     zz2      = 2 * zz
     zz_ea    = zz / ea
     zz_eb    = zz / eb
     b_n_comp_sum = SHELL2::n_comp_up_to(.b.l)

     PI_zinv = PI/zeta
     overlap(1,1) = PI_zinv*sqrt(PI_zinv) * exp(-zz*r2ab)  ! s||s
     kei(1,1)     = zz * (3.0-zz2 * r2ab) * overlap(1,1)

     do j = 2, b_n_comp_sum                                ! s||p to s||lb
       z   = GAUSSIAN_DATA::first_nonzero(j)
       lza = GAUSSIAN_DATA::nn(z,j)
       a1  = GAUSSIAN_DATA::index_m1(j)
       PBi = PB(z)
       PAi = PA(z)
       if (lza < 3) then
         overlap(1,j) = PBi * overlap(1,a1)
         kei(1,j)     = PBi * kei(1,a1) + zz2 * overlap(1,j)
         overlap(j,1) = PAi * overlap(a1,1)
         kei(j,1)     = PAi * kei(a1,1) + zz2 * overlap(j,1)
       else
         na           = lza - 2
         zinv2_na     = zinv2 * na
         a2 = GAUSSIAN_DATA::index_m1(a1)
         overlap(1,j) = PBi * overlap(1,a1) + zinv2_na * overlap(1,a2)
         kei(1,j)     = PBi * kei(1,a1) + zinv2_na * kei(1,a2) + &
                        zz2 * overlap(1,j) - zz_eb * na * overlap(1,a2)
         overlap(j,1) = PAi * overlap(a1,1) + zinv2_na * overlap(a2,1)
         kei(j,1)     = PAi * kei(a1,1) + zinv2_na * kei(a2,1) + &
                        zz2 * overlap(j,1) - zz_ea * na * overlap(a2,1)
       end
     end

     do j = b_n_comp_sum + 1, SHELL2::n_comp_up_to(.a.l-.b.l)   ! lb||s to la-lb||s
       z   = GAUSSIAN_DATA::first_nonzero(j)
       lza = GAUSSIAN_DATA::nn(z,j)
       a1  = GAUSSIAN_DATA::index_m1(j)
       PAi          = PA(z)
       if (lza < 3) then
         overlap(j,1) = PAi * overlap(a1,1)
         kei(j,1)     = PAi * kei(a1,1) + zz2 * overlap(j,1)
       else
         na           = lza - 2
         zinv2_na     = zinv2 * na
         a2 = GAUSSIAN_DATA::index_m1(a1)
         overlap(j,1) = PAi * overlap(a1,1) + zinv2_na * overlap(a2,1)
         kei(j,1)     = PAi * kei(a1,1) + zinv2_na * kei(a2,1) + &
                        zz2 * overlap(j,1) - zz_ea * na * overlap(a2,1)
       end
     end

     laub = .a.l - .b.l
     do lb = 1, .b.l
       lb1_n_comp_sum = SHELL2::n_comp_up_to(lb-1) + 1
       lb_n_comp_sum  = SHELL2::n_comp_up_to(lb)
       laub           = laub + 1
       do la = 1, laub
         la1_n_comp_sum = SHELL2::n_comp_up_to(la-1) + 1
         la_n_comp_sum  = SHELL2::n_comp_up_to(la)
         do a = la1_n_comp_sum, la_n_comp_sum
           z   = GAUSSIAN_DATA::first_nonzero(a)
           lza = GAUSSIAN_DATA::nn(z,a)
           a1  = GAUSSIAN_DATA::index_m1(a)
           PAi          = PA(z)
           if (lza==2) then
             do b = lb1_n_comp_sum,lb_n_comp_sum
               lzb = GAUSSIAN_DATA::nn(z,b)
               if (lzb==1) then
                 overlap(a,b) = PAi * overlap(a1,b)
                 kei(a,b)     = PAi * kei(a1,b) + zz2 * overlap(a,b)
               else
                 b_momenta    = GAUSSIAN_DATA::nn(:,b)
                 b_momenta(z) = b_momenta(z) - 1
                 b1  = GAUSSIAN_DATA::index_of(b_momenta(1),b_momenta(2),b_momenta(3))
                 nb           = lzb - 1
                 zinv2_nb     = zinv2 * nb
                 overlap(a,b) = PAi * overlap(a1,b) + zinv2_nb * overlap(a1,b1)
                 kei(a,b)     = PAi * kei(a1,b) + zinv2_nb * kei(a1,b1) + &
                                zz2 * overlap(a,b)
               end
             end
           else
             na           = lza - 2
             zinv2_na     = zinv2 * na
             zz_ea_na    = zz_ea * na
             a2 = GAUSSIAN_DATA::index_m1(a1)
             do b = lb1_n_comp_sum, lb_n_comp_sum
               lzb = GAUSSIAN_DATA::nn(z,b)
               if (lzb==1) then
                 overlap(a,b) = PAi * overlap(a1,b) + zinv2_na * overlap(a2,b)
                 kei(a,b)     = PAi * kei(a1,b) + zinv2_na * kei(a2,b) + &
                                zz2 * overlap(a,b) - zz_ea_na * overlap(a2,b)
               else
                 b_momenta    = GAUSSIAN_DATA::nn(:,b)
                 b_momenta(z) = b_momenta(z) - 1
                 b1  = GAUSSIAN_DATA::index_of(b_momenta(1),b_momenta(2),b_momenta(3))
                 nb           = lzb - 1
                 zinv2_nb     = zinv2 * nb
                 overlap(a,b) = PAi * overlap(a1,b) + zinv2_na * overlap(a2,b) +&
                                zinv2_nb * overlap(a1,b1)
                 kei(a,b)     = PAi * kei(a1,b) + zinv2_na * kei(a2,b) + &
                                zinv2_nb * kei(a1,b1) + &
                                zz2 * overlap(a,b) - zz_ea_na * overlap(a2,b)
               end
             end
           end
         end
       end
     end
   end

   form_overlap_mat_b(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab) ::: private
   ! Makes the kinetic energy and overlap matrices for a primitive pair
   ! if .b.l > .a.l
     self :: IN
     overlap,kei :: MAT{REAL}, INOUT
     PA,PB :: VEC{REAL}(3), IN
     zinv2,zeta,ea,eb,r2ab :: REAL, IN
     a_momenta :: VEC{INT}(3)
     j,z,lza,lzb,a,a1,b,b1,b2,lbub,la,lb,nb,na,a_n_comp_sum :: INT
     la1_n_comp_sum,lb1_n_comp_sum,la_n_comp_sum,lb_n_comp_sum :: INT
     PAi,PBi,PI_zinv,zz,zz2,zinv2_na,zinv2_nb,zz_ea,zz_eb,zz_eb_nb :: REAL

     zz      = ea * eb / zeta
     zz2     = 2 * zz
     zz_ea    = zz / ea
     zz_eb    = zz / eb
     a_n_comp_sum  = SHELL2::n_comp_up_to(.a.l)

     PI_zinv = PI/zeta
     overlap(1,1) = PI_zinv*sqrt(PI_zinv) * exp(-zz*r2ab) ! s||s
     kei(1,1)     = zz * (3.0-zz2 * r2ab) * overlap(1,1)

     do j = 2, a_n_comp_sum                               ! p||s to la||s
       z   = GAUSSIAN_DATA::first_nonzero(j)
       lzb = GAUSSIAN_DATA::nn(z,j)
       b1  = GAUSSIAN_DATA::index_m1(j)
       PBi          = PB(z)
       PAi          = PA(z)
       if (lzb < 3) then
         overlap(j,1) = PAi * overlap(b1,1)
         kei(j,1)     = PAi * kei(b1,1) + zz2 * overlap(j,1)
         overlap(1,j) = PBi * overlap(1,b1)
         kei(1,j)     = PBi * kei(1,b1) + zz2 * overlap(1,j)
       else
         nb           = lzb - 2
         zinv2_nb     = zinv2 * nb
         b2 = GAUSSIAN_DATA::index_m1(b1)
         overlap(j,1) = PAi * overlap(b1,1) + zinv2_nb * overlap(b2,1)
         kei(j,1)     = PAi * kei(b1,1) + zinv2_nb * kei(b2,1) + &
                        zz2 * overlap(j,1) - zz_ea * nb * overlap(b2,1)
         overlap(1,j) = PBi * overlap(1,b1) + zinv2_nb * overlap(1,b2)
         kei(1,j)     = PBi * kei(1,b1) + zinv2_nb * kei(1,b2) + &
                        zz2 * overlap(1,j) - zz_eb * nb * overlap(1,b2)
       end
     end

     do j= a_n_comp_sum + 1, SHELL2::n_comp_up_to(.b.l-.a.l)      ! s||lb to s||lb-la
       z   = GAUSSIAN_DATA::first_nonzero(j)
       lzb = GAUSSIAN_DATA::nn(z,j)
       b1  = GAUSSIAN_DATA::index_m1(j)
       PBi          = PB(z)
       if (lzb < 3) then
         overlap(1,j) = PBi * overlap(1,b1)
         kei(1,j)     = PBi * kei(1,b1) + zz2 * overlap(1,j)
       else
         nb           = lzb - 2
         zinv2_nb     = zinv2 * nb
         b2 = GAUSSIAN_DATA::index_m1(b1)
         overlap(1,j) = PBi * overlap(1,b1) + zinv2_nb * overlap(1,b2)
         kei(1,j)     = PBi * kei(1,b1) + zinv2_nb * kei(1,b2) + &
                        zz2 * overlap(1,j) - zz_eb * nb * overlap(1,b2)
       end
     end

     lbub = .b.l - .a.l
     do la = 1, .a.l
       la1_n_comp_sum = SHELL2::n_comp_up_to(la-1) + 1
       la_n_comp_sum  = SHELL2::n_comp_up_to(la)
       lbub           = lbub + 1
       do lb = 1, lbub
         lb1_n_comp_sum = SHELL2::n_comp_up_to(lb-1)+1
         lb_n_comp_sum  = SHELL2::n_comp_up_to(lb)
         do b = lb1_n_comp_sum, lb_n_comp_sum
           z   = GAUSSIAN_DATA::first_nonzero(b)
           lzb = GAUSSIAN_DATA::nn(z,b)
           b1  = GAUSSIAN_DATA::index_m1(b)
           PBi          = PB(z)
           if (lzb == 2) then
             do a = la1_n_comp_sum, la_n_comp_sum
               lza = GAUSSIAN_DATA::nn(z,a)
               if (lza == 1) then
                 overlap(a,b) = PBi * overlap(a,b1)
                 kei(a,b)     = PBi * kei(a,b1) + zz2 * overlap(a,b)
               else
                 a_momenta    = GAUSSIAN_DATA::nn(:,a)
                 a_momenta(z) = a_momenta(z) - 1
                 a1  = GAUSSIAN_DATA::index_of(a_momenta(1),a_momenta(2),a_momenta(3))
                 na           = lza - 1
                 zinv2_na     = zinv2 * na
                 overlap(a,b) = PBi * overlap(a,b1) + zinv2_na * overlap(a1,b1)
                 kei(a,b)     = PBi * kei(a,b1) + zinv2_na * kei(a1,b1) + &
                                zz2 * overlap(a,b)
               end
             end
           else
             nb           = lzb - 2
             zinv2_nb     = zinv2 * nb
             zz_eb_nb     = zz_eb * nb
             b2 = GAUSSIAN_DATA::index_m1(b1)
             do a = la1_n_comp_sum, la_n_comp_sum
               lza = GAUSSIAN_DATA::nn(z,a)
               if (lza==1) then
                 overlap(a,b) = PBi * overlap(a,b1) + zinv2_nb * overlap(a,b2)
                 kei(a,b)     = PBi * kei(a,b1) + zinv2_nb * kei(a,b2)+ &
                                zz2 * overlap(a,b) - zz_eb_nb * overlap(a,b2)
               else
                 a_momenta    = GAUSSIAN_DATA::nn(:,a)
                 a_momenta(z) = a_momenta(z) - 1
                 a1  = GAUSSIAN_DATA::index_of(a_momenta(1),a_momenta(2),a_momenta(3))
                 na           = lza - 1
                 zinv2_na     = zinv2 * na
                 overlap(a,b) = PBi * overlap(a,b1) + zinv2_nb * overlap(a,b2) +&
                                zinv2_na * overlap(a1,b1)
                 kei(a,b)     = PBi * kei(a,b1) + zinv2_nb * kei(a,b2) + &
                                zinv2_na * kei(a1,b1) + &
                                zz2 * overlap(a,b) - zz_eb_nb * overlap(a,b2)
               end
             end
           end
         end
       end
     end
   end

   get_nuc(ab,mass_c,pos_c)
   ! Calculate the nuclear attraction matrix for the two shells with the
   ! nucleus at c.
     self :: IN
     ab :: MAT{REAL}, OUT
     mass_c :: REAL, IN
     pos_c :: VEC{REAL}(3), IN
     es :: VEC{REAL}*
     ss :: REAL
     n :: INT
     if (.l_sum==0) then  ! ss
       .make_nuc_ss(ss,mass_c,pos_c)
       ab(1,1)=ss
     else if (.l_sum==1) then ! ps or sp
       .make_nuc_ps(ab,mass_c,pos_c)
     else if (.l_max==1) then
       .make_nuc_pp(ab,mass_c,pos_c)
     else if (.l_sum==2 AND .l_max==2) then ! ds or sd
       .make_nuc_ds(ab,mass_c,pos_c)
       .normalise(ab)
     else if (.l_sum==3 AND .l_max==1) then ! dp or pd
       .make_nuc_dp(ab,mass_c,pos_c)
       .normalise(ab)
     else
       n = SHELL2::n_comp_up_to(.l_sum) - SHELL2::n_comp_up_to(.l_max-1)
       es.create(n)
       .make_nuc_es(es,mass_c,pos_c)
       .transfer(es,ab)
       es.destroy
       .normalise(ab)
     end
   end

   make_nuc_es(es,mass_c,pos_c) ::: private
   ! Make the (es) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
     self :: IN
     es :: VEC{REAL}, OUT
     mass_c :: REAL, IN
     pos_c :: VEC{REAL}(3), IN
     Ixa,Iya,Iza :: MAT{REAL}*
     Ix,Iy,Iz :: VEC{REAL}*
     rys :: RYS*
     rzt,ce,e1_ce,rho_zinv,half_zinv,Ix2,Iy2,Iz2,wt :: REAL
     QPx,QPy,QPz,PAx,PAy,PAz,zeta,zinv,rho,xx,eta_c,two_pi :: REAL
     Ixe,Iye,Ize,Ixe1,Iye1,Ize1,Ixep1,Iyep1,Izep1 :: REAL
     ag,bg,e,ep1,n_roots,i,j,n,n_sum :: INT

     if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
     else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRDS))
     end
     eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

     n_roots=(.l_sum+2)/2
     n_sum = n_roots * .a.n_cc * .b.n_cc
     rys.create(n_roots)
     Ixa.create(n_sum,.l_sum+1)
     Iya.create(n_sum,.l_sum+1)
     Iza.create(n_sum,.l_sum+1)

     two_pi=TWO*PI
     i = 0
     j = 0
     do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         zinv  = .exponent_inv(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         rys.weight = rys.weight * (two_pi * .cc_prefactor(i) * sqrt(rho))
         half_zinv = HALF * zinv
         rho_zinv = rho * zinv

         do n = 1, n_roots
           j = j + 1
           Ix => Ixa(j,:)
           Iy => Iya(j,:)
           Iz => Iza(j,:)
           wt = rys.weight(n)
           Ix(1) = ONE
           Iy(1) = ONE
           Iz(1) = wt
           if (.l_sum>0) then
              rzt   = rys.root(n)*rho_zinv
              Ix2 = PAx+rzt*QPx
              Iy2 = PAy+rzt*QPy
              Iz2 = PAz+rzt*QPz
              Ix(2) = Ix2;    Iy(2) = Iy2;    Iz(2) = Iz2 * wt
              if (.l_sum>1) then
                ce    = (ONE-rzt)*half_zinv
                Ixep1 = Ix2*Ix2+ce
                Iyep1 = Iy2*Iy2+ce
                Izep1 = Iz2*Iz2+ce
                Ix(3) = Ixep1
                Iy(3) = Iyep1
                Iz(3) = Izep1 * wt
                if (.l_sum>2) then
                  Ixe1 = Ix2;      Iye1 = Iy2;      Ize1 = Iz2
                  Ixe = Ixep1;     Iye = Iyep1;     Ize = Izep1
                  e1_ce = ce
                  do e = 3,.l_sum
                    ep1   = e+1
                  ! e1_ce = (e-1)*ce
                    e1_ce = e1_ce+ce
                    Ixep1 = Ix2*Ixe+e1_ce*Ixe1
                    Iyep1 = Iy2*Iye+e1_ce*Iye1
                    Izep1 = Iz2*Ize+e1_ce*Ize1
                    Ix(ep1) = Ixep1; Iy(ep1) = Iyep1; Iz(ep1) = Izep1 * wt
                    Ixe1 = Ixe;      Iye1 = Iye;      Ize1 = Ize
                    Ixe = Ixep1;     Iye = Iyep1;     Ize = Izep1
                  end
                end
              end
           end
         end
       end
     end

     .combine_nuc_2d_ints(es,Ixa,Iya,Iza,Iza(:,1))

     Iza.destroy
     Iya.destroy
     Ixa.destroy
     rys.destroy
   end

   combine_nuc_2d_ints(es,Ix,Iy,Iz,wt) ::: private
   ! Sum the Ix, Iy, and Iz 2d-integrals to get the (e|s) integrals.
     es :: VEC{REAL}
     Ix,Iy,Iz :: MAT{REAL}, IN
     wt :: VEC{REAL}, IN
     Ixy :: VEC{REAL}*
     ex,ey,ez, exyz0,eyz0,exz0,exy0,ez0,ey0,ex0,en0,ea0,erms :: VEC{INT}*
     exy_rms :: VEC{VEC_{INT}}*
     er :: RMS_INDICES*
     ee,eb,em,e,xe,ye,ze,f,l :: INT
     f = .first_gaussian
     l = .last_gaussian
     ex => GAUSSIAN_DATA::nx(f:l); ey => GAUSSIAN_DATA::ny(f:l); ez => GAUSSIAN_DATA::nz(f:l)
     er => GAUSSIAN_DATA::rms_indices(.l_max,.l_min)
     exyz0 => er.xyz0
     eyz0  => er.yz0; exz0 => er.xz0; exy0 => er.xy0
     ez0   => er.z0;  ey0  => er.y0;  ex0  => er.x0
     en0   => er.n0;  ea0  => er.a0
     do ee = 1,exyz0.dim
        e  = exyz0(ee)
        es(e) = sum(wt)
     end
     do ee = 1,eyz0.dim
        e  = eyz0(ee)
        xe = ex(e)
        es(e) = sum(Ix(:,xe)*wt)
     end
     do ee = 1,exz0.dim
        e  = exz0(ee)
        ye = ey(e)
        es(e) = sum(Iy(:,ye)*wt)
     end
     do ee = 1,exy0.dim
        e  = exy0(ee)
        ze = ez(e)
        es(e) = sum(Iz(:,ze)   )
     end
     do ee = 1,ez0.dim
        e  = ez0(ee)
        xe = ex(e)
        ye = ey(e)
        es(e) = sum(Ix(:,xe)*Iy(:,ye)*wt      )
     end
     do ee = 1,ey0.dim
        e  = ey0(ee)
        xe = ex(e)
        ze = ez(e)
        es(e) = sum(Ix(:,xe)         *Iz(:,ze))
     end
     do ee = 1,ex0.dim
        e  = ex0(ee)
        ye = ey(e)
        ze = ez(e)
        es(e) = sum(         Iy(:,ye)*Iz(:,ze))
     end
     exy_rms => er.xy_rms_n 
     if (exy_rms.dim==en0.dim) then
        do ee = 1,en0.dim
           e  = en0(ee)
           xe = ex(e); ye = ey(e); ze = ez(e)
           es(e) = sum(Ix(:,xe)*Iy(:,ye)*Iz(:,ze))
        end
     else if (exy_rms.dim>0) then
        Ixy.create(Ix.dim1)
        do ee = 1,exy_rms.dim                 ! Apply (e) RMS here
           erms => exy_rms(ee).element
           e  = en0(erms(1))
           xe = ex(e)
           ye = ey(e)
           ze = ez(e)
           Ixy = Ix(:,xe)*Iy(:,ye)
           es(e) = sum(Ixy*Iz(:,ze))
           do em = 2,erms.dim
              e = en0(erms(em))
              ze = ez(e)
              es(e) = sum(Ixy*Iz(:,ze))
           end
        end
        Ixy.destroy
     end
   end

!   combine_nuc_2d_ints(es,Ix,Iy,Iz) ::: private
!   ! Sum the Ix, Iy, and Iz 2d-integrals to get the (e|s) integrals.
!     es :: VEC{REAL}
!     Ix,Iy,Iz :: MAT{REAL}, IN
!     Ixy :: VEC{REAL}*
!     ex,ey,ez,erms :: VEC{INT}*
!     exy_rms :: VEC{VEC_{INT}}*
!     er :: RMS_INDICES*
!     ee,em,e,xe,ye,ze,f,l :: INT
!     xe1,ye1,xy1 :: BIN
!   ! ex   => eg.nx;  ey   => eg.ny;  ez   => eg.nz
!!    do e = 1,es.dim
!!       xe = ex(e); ye = ey(e); ze = ez(e)
!!       es(e) = sum(Ix(:,xe)*Iy(:,ye)*Iz(:,ze))
!!    end
!     f = .first_gaussian
!     l = .last_gaussian
!     ex => nx(f:l); ey => ny(f:l); ez => nz(f:l)
!     er => rms_indices(.l_max,.l_min)
!     exy_rms => er.xy_rms  
!     Ixy.create(Ix.dim1)
!     do ee = 1,exy_rms.dim                 ! Apply (e) RMS here
!        erms => exy_rms(ee).element
!        e = erms(1)
!        xe  = ex(e); ye  = ey(e)
!        xe1 = xe==1; ye1 = ye==1; xy1 = xe1 AND ye1
!        if      (xy1) then; ! both factors are one
!        else if (xe1) then; Ixy = Iy(:,ye)
!        else if (ye1) then; Ixy = Ix(:,xe)
!        else;               Ixy = Ix(:,xe) * Iy(:,ye)
!        end
!        do em = 1,erms.dim
!           e = erms(em)
!           ze = ez(e)
!           if (xy1) then; es(e) = sum(    Iz(:,ze))
!           else;          es(e) = sum(Ixy*Iz(:,ze))
!           end
!        end
!     end
!     Ixy.destroy
!   end

   make_nuc_dp(dp,mass_c,pos_c) ::: private
   ! Make the (dp) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
     self :: IN
     dp :: MAT{REAL}, OUT
     mass_c :: REAL, IN
     pos_c :: VEC{REAL}(3), IN
     rys :: RYS*
     rzt,ce,rho_zinv,half_zinv,wt :: REAL
     QPx,QPy,QPz,PAx,PAy,PAz,zeta,zinv,rho,xx,eta_c,two_pi :: REAL
     Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,two_ce,ABx,ABy,ABz :: REAL
     dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s,fxxx_s,fyyy_s,fzzz_s :: REAL
     fxxy_s,fxxz_s,fxyy_s,fyyz_s,fxzz_s,fyzz_s,fxyz_s :: REAL
     ag,bg,i,j,n :: INT

     if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
     else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRDS))
     end
     eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

     rys.create(2)

     two_pi=TWO*PI
     i = 0
     j = 0
     dxx_s = ZERO;  dyy_s = ZERO;  dzz_s = ZERO
     dxy_s = ZERO;  dxz_s = ZERO;  dyz_s = ZERO
     fxxx_s = ZERO; fyyy_s = ZERO; fzzz_s = ZERO
     fxxy_s = ZERO; fxxz_s = ZERO; fxyy_s = ZERO
     fyyz_s = ZERO; fxzz_s = ZERO; fyzz_s = ZERO
     fxyz_s = ZERO
     do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         zinv  = .exponent_inv(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         rys.weight = rys.weight * (two_pi * .cc_prefactor(i) * sqrt(rho))
         half_zinv = HALF * zinv
         rho_zinv = rho * zinv

         do n = 1, 2
           j = j + 1
           wt = rys.weight(n)
           rzt   = rys.root(n)*rho_zinv
           ce    = (ONE-rzt)*half_zinv
           Ix2 = PAx+rzt*QPx
           Iy2 = PAy+rzt*QPy
           Iz2 = PAz+rzt*QPz
           Ix3 = Ix2*Ix2+ce
           Iy3 = Iy2*Iy2+ce
           Iz3 = (Iz2*Iz2+ce)*wt
           Iz2 = Iz2 * wt
           two_ce = ce+ce
           dxx_s  = dxx_s  + Ix3 * wt
           dyy_s  = dyy_s  + Iy3 * wt
           dzz_s  = dzz_s  + Iz3
           dxy_s  = dxy_s  + Ix2 * Iy2 * wt
           dxz_s  = dxz_s  + Ix2 * Iz2
           dyz_s  = dyz_s  + Iy2 * Iz2
           fxxx_s = fxxx_s + Ix2*(Ix3+two_ce) * wt
           fyyy_s = fyyy_s + Iy2*(Iy3+two_ce) * wt
           fzzz_s = fzzz_s + Iz2*(Iz3+two_ce) * wt
           fxxy_s = fxxy_s + Ix3 * Iy2 * wt
           fxxz_s = fxxz_s + Ix3 * Iz2
           fxyy_s = fxyy_s + Ix2 * Iy3 * wt
           fyyz_s = fyyz_s + Iy3 * Iz2
           fxzz_s = fxzz_s + Ix3 * Iz3
           fyzz_s = fyzz_s + Iy2 * Iz3
           fxyz_s = fxyz_s + Ix2 * Iy2 * Iz2
         end
       end
     end

     if (.same_center) then
       if (.a.l==2) then
         dp(1,1) = fxxx_s
         dp(2,1) = fxyy_s
         dp(3,1) = fxzz_s
         dp(4,1) = fxxy_s
         dp(5,1) = fxxz_s
         dp(6,1) = fxyz_s
         dp(1,2) = fxxy_s
         dp(2,2) = fyyy_s
         dp(3,2) = fyzz_s
         dp(4,2) = fxyy_s
         dp(5,2) = fxyz_s
         dp(6,2) = fyyz_s
         dp(1,3) = fxxz_s
         dp(2,3) = fyyz_s
         dp(3,3) = fzzz_s
         dp(4,3) = fxyz_s
         dp(5,3) = fxzz_s
         dp(6,3) = fyzz_s
       else
         dp(1,1) = fxxx_s
         dp(1,2) = fxyy_s
         dp(1,3) = fxzz_s
         dp(1,4) = fxxy_s
         dp(1,5) = fxxz_s
         dp(1,6) = fxyz_s
         dp(2,1) = fxxy_s
         dp(2,2) = fyyy_s
         dp(2,3) = fyzz_s
         dp(2,4) = fxyy_s
         dp(2,5) = fxyz_s
         dp(2,6) = fyyz_s
         dp(3,1) = fxxz_s
         dp(3,2) = fyyz_s
         dp(3,3) = fzzz_s
         dp(3,4) = fxyz_s
         dp(3,5) = fxzz_s
         dp(3,6) = fyzz_s
       end
     else
       if (.a.l==2) then
         ABx = .a.pos(1) - .b.pos(1)
         ABy = .a.pos(2) - .b.pos(2)
         ABz = .a.pos(3) - .b.pos(3)
         dp(1,1) = fxxx_s + ABx * dxx_s
         dp(2,1) = fxyy_s + ABx * dyy_s
         dp(3,1) = fxzz_s + ABx * dzz_s
         dp(4,1) = fxxy_s + ABx * dxy_s
         dp(5,1) = fxxz_s + ABx * dxz_s
         dp(6,1) = fxyz_s + ABx * dyz_s
         dp(1,2) = fxxy_s + ABy * dxx_s
         dp(2,2) = fyyy_s + ABy * dyy_s
         dp(3,2) = fyzz_s + ABy * dzz_s
         dp(4,2) = fxyy_s + ABy * dxy_s
         dp(5,2) = fxyz_s + ABy * dxz_s
         dp(6,2) = fyyz_s + ABy * dyz_s
         dp(1,3) = fxxz_s + ABz * dxx_s
         dp(2,3) = fyyz_s + ABz * dyy_s
         dp(3,3) = fzzz_s + ABz * dzz_s
         dp(4,3) = fxyz_s + ABz * dxy_s
         dp(5,3) = fxzz_s + ABz * dxz_s
         dp(6,3) = fyzz_s + ABz * dyz_s
       else
         ABx = .b.pos(1) - .a.pos(1)
         ABy = .b.pos(2) - .a.pos(2)
         ABz = .b.pos(3) - .a.pos(3)
         dp(1,1) = fxxx_s + ABx * dxx_s
         dp(1,2) = fxyy_s + ABx * dyy_s
         dp(1,3) = fxzz_s + ABx * dzz_s
         dp(1,4) = fxxy_s + ABx * dxy_s
         dp(1,5) = fxxz_s + ABx * dxz_s
         dp(1,6) = fxyz_s + ABx * dyz_s
         dp(2,1) = fxxy_s + ABy * dxx_s
         dp(2,2) = fyyy_s + ABy * dyy_s
         dp(2,3) = fyzz_s + ABy * dzz_s
         dp(2,4) = fxyy_s + ABy * dxy_s
         dp(2,5) = fxyz_s + ABy * dxz_s
         dp(2,6) = fyyz_s + ABy * dyz_s
         dp(3,1) = fxxz_s + ABz * dxx_s
         dp(3,2) = fyyz_s + ABz * dyy_s
         dp(3,3) = fzzz_s + ABz * dzz_s
         dp(3,4) = fxyz_s + ABz * dxy_s
         dp(3,5) = fxzz_s + ABz * dxz_s
         dp(3,6) = fyzz_s + ABz * dyz_s
       end
     end

     rys.destroy
   end

   make_nuc_ds(ds,mass_c,pos_c) ::: private
   ! Make the (ds) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
     self :: IN
     ds :: MAT{REAL}, OUT
     mass_c :: REAL, IN
     pos_c :: VEC{REAL}(3), IN
     rys :: RYS*
     rzt,ce,rho_zinv,half_zinv,Ix2,Iy2,Iz2,wt,Iz2_wt :: REAL
     QPx,QPy,QPz,PAx,PAy,PAz,zeta,zinv,rho,xx,eta_c,two_pi :: REAL
     dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s :: REAL
     ag,bg,i,n :: INT

     if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
     else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRDS))
     end
     eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

     rys.create(2)
     two_pi=TWO*PI
     dxx_s = ZERO;    dyy_s = ZERO;    dzz_s = ZERO
     dxy_s = ZERO;    dxz_s = ZERO;    dyz_s = ZERO
     i = 0
     do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         zinv  = .exponent_inv(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         rys.weight = rys.weight * (two_pi * .cc_prefactor(i) * sqrt(rho))
         half_zinv = HALF * zinv
         rho_zinv = rho * zinv
         do n = 1,2
           wt = rys.weight(n)
           rzt   = rys.root(n)*rho_zinv
           Ix2 = PAx+rzt*QPx
           Iy2 = PAy+rzt*QPy
           Iz2 = PAz+rzt*QPz
           ce  = (ONE-rzt)*half_zinv
           Iz2_wt = Iz2 * wt
           dxx_s = dxx_s + (Ix2*Ix2+ce) * wt
           dyy_s = dyy_s + (Iy2*Iy2+ce) * wt
           dzz_s = dzz_s + (Iz2*Iz2+ce) * wt
           dxy_s = dxy_s + Ix2 * Iy2    * wt
           dxz_s = dxz_s + Ix2 *      Iz2_wt
           dyz_s = dyz_s +      Iy2 * Iz2_wt
         end
       end
     end
     rys.destroy
     if (.a.l==2) then
       ds(1,1) = dxx_s
       ds(2,1) = dyy_s
       ds(3,1) = dzz_s
       ds(4,1) = dxy_s
       ds(5,1) = dxz_s
       ds(6,1) = dyz_s
     else
       ds(1,1) = dxx_s
       ds(1,2) = dyy_s
       ds(1,3) = dzz_s
       ds(1,4) = dxy_s
       ds(1,5) = dxz_s
       ds(1,6) = dyz_s
     end
   end

   make_nuc_pp(pp,mass_c,pos_c) ::: private
   ! Make the (es) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
     self :: IN
     pp :: MAT{REAL}, OUT
     mass_c :: REAL, IN
     pos_c :: VEC{REAL}(3), IN
     rys :: RYS*
     rzt,ce,rho_zinv,half_zinv,Ix2,Iy2,Iz2,wt,Iy2_wt,Iz2_wt :: REAL
     QPx,QPy,QPz,PAx,PAy,PAz,zeta,zinv,rho,xx,eta_c,two_pi :: REAL
     BAx,BAy,BAz,px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s :: REAL
     ag,bg,i,n :: INT

     if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
     else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRDS))
     end
     eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

     rys.create(2)

     two_pi=TWO*PI
     i = 0
     px_s = ZERO;   py_s = ZERO;   pz_s = ZERO
     dxx_s = ZERO;   dyy_s = ZERO;   dzz_s = ZERO
     dxy_s = ZERO;   dxz_s = ZERO;   dyz_s = ZERO
     do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         zinv  = .exponent_inv(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         rys.weight = rys.weight * (two_pi * .cc_prefactor(i) * sqrt(rho))
         half_zinv = HALF * zinv
         rho_zinv = rho * zinv

         do n = 1,2
           wt = rys.weight(n)
           rzt = rys.root(n)*rho_zinv
           Ix2 = PAx+rzt*QPx
           Iy2 = PAy+rzt*QPy
           Iz2 = PAz+rzt*QPz
           ce  = (ONE-rzt)*half_zinv
           Iz2_wt = Iz2 * wt
           Iy2_wt = Iy2 * wt
           px_s = px_s + Ix2 * wt
           py_s = py_s + Iy2_wt
           pz_s = pz_s + Iz2_wt
           dxx_s = dxx_s + (Ix2*Ix2+ce) * wt
           dyy_s = dyy_s + (Iy2*Iy2+ce) * wt
           dzz_s = dzz_s + (Iz2*Iz2+ce) * wt
           dxy_s = dxy_s + Ix2 * Iy2_wt
           dxz_s = dxz_s + Ix2 * Iz2_wt
           dyz_s = dyz_s + Iy2 * Iz2_wt
         end
       end
     end
     rys.destroy

     if (.same_center) then
       pp(1,1) = dxx_s
       pp(1,2) = dxy_s
       pp(1,3) = dxz_s
       pp(2,1) = dxy_s
       pp(2,2) = dyy_s
       pp(2,3) = dyz_s
       pp(3,1) = dxz_s
       pp(3,2) = dyz_s
       pp(3,3) = dzz_s
     else
       BAx = .b.pos(1) - .a.pos(1)
       BAy = .b.pos(2) - .a.pos(2)
       BAz = .b.pos(3) - .a.pos(3)
       pp(1,1) = dxx_s + BAx * px_s
       pp(1,2) = dxy_s + BAx * py_s
       pp(1,3) = dxz_s + BAx * pz_s
       pp(2,1) = dxy_s + BAy * px_s
       pp(2,2) = dyy_s + BAy * py_s
       pp(2,3) = dyz_s + BAy * pz_s
       pp(3,1) = dxz_s + BAz * px_s
       pp(3,2) = dyz_s + BAz * py_s
       pp(3,3) = dzz_s + BAz * pz_s
     end
   end

   make_nuc_ps(ps,mass_c,pos_c) ::: private
   ! Make the (ps) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
     self :: IN
     ps :: MAT{REAL}, OUT
     mass_c :: REAL, IN
     pos_c :: VEC{REAL}(3), IN
     rys :: RYS*
     rzt,wt :: REAL
     QPx,QPy,QPz,PAx,PAy,PAz,zeta,rho,xx,eta_c,two_pi,ps_x,ps_y,ps_z :: REAL
     ag,bg,i :: INT

     if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
     else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRDS))
     end
     eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

     rys.create(1)

     two_pi=TWO*PI
     i = 0
     ps_x = ZERO;   ps_y = ZERO;   ps_z = ZERO
     do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         PAx   = .center_diff(1,i)
         PAy   = .center_diff(2,i)
         PAz   = .center_diff(3,i)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         wt = rys.weight(1) * (two_pi * .cc_prefactor(i) * sqrt(rho))
         rzt   = rys.root(1) * rho * .exponent_inv(i)
         ps_x = ps_x + (PAx+rzt*QPx) * wt
         ps_y = ps_y + (PAy+rzt*QPy) * wt
         ps_z = ps_z + (PAz+rzt*QPz) * wt
       end
     end
     if (.a.l==1) then
       ps(1,1) = ps_x
       ps(2,1) = ps_y
       ps(3,1) = ps_z
     else
       ps(1,1) = ps_x
       ps(1,2) = ps_y
       ps(1,3) = ps_z
     end
     rys.destroy
   end

   make_nuc_ss(es,mass_c,pos_c) ::: private
   ! Make the (ss) nuclear attraction integrals, summed over primitives
   ! Numbers may be slightly different to cadpac due to a relativistic
   ! correction term.
     self :: IN
     es :: REAL, OUT
     mass_c :: REAL, IN
     pos_c :: VEC{REAL}(3), IN
     rys :: RYS*
     QPx,QPy,QPz,zeta,rho,xx,eta_c,two_pi :: REAL
     ag,bg,i :: INT

     if (mass_c < TOL(15)) then; eta_c=1.0d30  ! Very big.
     else;                       eta_c=3880000000d0*(mass_c**(-TWOTHIRDS))
     end
     eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.

     rys.create(1)
     two_pi=TWO*PI
     es = ZERO
     i = 0
     do bg = 1, .b.n_cc
       do ag = 1, .a.n_cc
         i     = i + 1
         zeta  = .exponent_sum(i)
         rho   = zeta * eta_c / (zeta + eta_c)
         QPx   = pos_c(1) - .pair_center(1,i)
         QPy   = pos_c(2) - .pair_center(2,i)
         QPz   = pos_c(3) - .pair_center(3,i)
         xx    = rho * (QPx*QPx + QPy*QPy + QPz*QPz)
         rys.get_weights(xx)
         es    = es + (two_pi * .cc_prefactor(i) * sqrt(rho)) * rys.weight(1)
       end
     end
     rys.destroy
   end

   transfer(es,ab)
   ! Applies the transfer equation to (e|s) to give (a|b)
     self :: IN
     es :: VEC{REAL}, IN
     ab :: MAT{REAL}, OUT
     if (.same_center) then
        if (.a.l > .b.l) then; .transfer_l_a_same(es,ab)
        else;                  .transfer_l_b_same(es,ab)
        end
     else
        if (.a.l > .b.l) then; .transfer_l_a_high(es,ab)
        else;                  .transfer_l_b_high(es,ab)
        end
     end
   end

   transfer_l_a_same(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell a has the higher
   ! angular momentum. This version when a and b have the same center.
     self :: IN
     es :: VEC{REAL}, IN
     ab :: MAT{REAL}, OUT
   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
   ENSURE(es.dim ==(SHELL2::n_comp_up_to(.l_sum)-SHELL2::n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim1==.a.n_comp,"wrong 1st dimension, ab")
   ENSURE(ab.dim2==.b.n_comp,"wrong 2nd dimension, ab")
   ENSURE(first_nonzero.created,"no indexing arrays")
     int_new,int_old :: MAT{REAL}*
     a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,t :: INT
     select case (.b.l)
        case (0)                               ! (a|s) case
           ab(:,1) = es
        case (1)                               
           if (.a.l==1) then                   ! (p|p) case
              ab(1,1) = es(4)
              ab(1,2) = es(7)
              ab(1,3) = es(8)
              ab(2,1) = es(7)
              ab(2,2) = es(5)
              ab(2,3) = es(9)
              ab(3,1) = es(8)
              ab(3,2) = es(9)
              ab(3,3) = es(6)
           else                                ! (a|p) case
              na = .a.n_comp
              fa = SHELL2::n_comp_up_to(.a.l-1)        ! Offset into the index array
              do a = 1,na                      ! Put es straight to ab
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa 
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa 
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa 
                 ab(a,1) = es(a1)
                 ab(a,2) = es(a2)
                 ab(a,3) = es(a3)
              end
           end
        case default                           ! general (a|b) case
           fa = SHELL2::n_comp_up_to(.a.l-1)           ! Offset into the index array
           na = es.dim - SHELL2::n_comp(.l_sum)        ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na                      ! Start with p shell on a
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa 
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa 
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa 
                 int_new(a,1) = es(a1)
                 int_new(a,2) = es(a2)
                 int_new(a,3) = es(a3)
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
              na = na - SHELL2::n_comp(.l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                          ! Previous offset for b, in int_old
              fb = fb + nb                     ! Offset into index arrays
              nb = SHELL2::n_comp(l)                   ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)       ! Transfer component
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    int_new(a,b) = int_old(a1,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                   ! Final transfer into (a|b)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    ab(a,b) = int_old(a1,b1)
                 end
               end
               int_old.destroy
        end ! case statement
   end

   transfer_l_b_same(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell b has the higher
   ! angular momentum. This version when a and b have the same center.
     self :: IN
     es :: VEC{REAL}, IN
     ab :: MAT{REAL}, OUT
   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
   ENSURE(es.dim ==(SHELL2::n_comp_up_to(.l_sum)-SHELL2::n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim1==.a.n_comp,"wrong 1st dimension, ab")
   ENSURE(ab.dim2==.b.n_comp,"wrong 2nd dimension, ab")
   ENSURE(first_nonzero.created,"no indexing arrays")
     int_new,int_old :: MAT{REAL}*
     a,b,a1,b1,b2,b3,bb,l,na,fa,pa,nb,fb,t :: INT
     select case (.a.l)
        case (0)                               ! (s|b) case
           ab(1,:) = es
        case (1)                              
           if (.b.l==1) then                   ! (p|p) case
              ab(1,1) = es(4)
              ab(2,1) = es(7)
              ab(3,1) = es(8)
              ab(1,2) = es(7)
              ab(2,2) = es(5)
              ab(3,2) = es(9)
              ab(1,3) = es(8)
              ab(2,3) = es(9)
              ab(3,3) = es(6)
           else                                ! (p|b) case
              nb = .b.n_comp
              fb = SHELL2::n_comp_up_to(.b.l-1)        ! Offset into the index array
              do b = 1,nb                      ! Put es straight to ab
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb 
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb 
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb 
                 ab(1,b) = es(b1)
                 ab(2,b) = es(b2)
                 ab(3,b) = es(b3)
              end
           end
       case default
           fb = SHELL2::n_comp_up_to(.b.l-1)           ! Offset into the index array
           nb = es.dim - SHELL2:n_comp(.l_sum)        ! No. of b's in int_new goes down
           int_new.create(nb,3)                ! NOTE: int_new ia transposed
              do b = 1,nb                      ! Start with p shell on a
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb 
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb 
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb 
                 int_new(b,1) = es(b1)
                 int_new(b,2) = es(b2)
                 int_new(b,3) = es(b3)
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
              nb = nb - SHELL2::n_comp(.l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                          ! Previous offset for a, in int_old
              fa = fa + na                     ! Offset into index arrays
              na = SHELL2::n_comp(l)                   ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)            ! TRANSPOSED!
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)       ! Transfer component
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    int_new(b,a) = int_old(b1,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                   ! Final transfer into (a|b)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    ab(a,b) = int_old(b1,a1)
                 end
              end
              int_old.destroy
        end ! case statement
   end

   transfer_l_a_high(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell a has the higher
   ! angular momentum. NOTE: .set_hrr_indexing_arrays must be called beforehand.
     self :: IN
     es :: VEC{REAL}, IN
     ab :: MAT{REAL}, OUT
   ENSURE(.a.l>=.b.l,"shell a must have higher momentum than b")
   ENSURE(es.dim ==(SHELL2::n_comp_up_to(.l_sum)-SHELL2::n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim1==.a.n_comp,"wrong 1st dimension, ab")
   ENSURE(ab.dim2==.b.n_comp,"wrong 2nd dimension, ab")
   ENSURE(first_nonzero.created,"no indexing arrays")
     int_new,int_old :: MAT{REAL}*
     R :: VEC{REAL}(3)
     Rt,R1,R2,R3,es_a :: REAL
     a,b,a1,a2,a3,aa,b1,l,na,fa,nb,fb,pb,t :: INT
     select case (.b.l)
        case (0)                               ! (a|s) case
           ab(:,1) = es
        case (1)                               
           R  = .a.pos - .b.pos
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.a.l==1) then                   ! (p|p) case
              es_a = es(1)
              ab(1,1) = es(4) + R1*es_a
              ab(1,2) = es(7) + R2*es_a
              ab(1,3) = es(8) + R3*es_a
              es_a = es(2)
              ab(2,1) = es(7) + R1*es_a
              ab(2,2) = es(5) + R2*es_a
              ab(2,3) = es(9) + R3*es_a
              es_a = es(3)
              ab(3,1) = es(8) + R1*es_a
              ab(3,2) = es(9) + R2*es_a
              ab(3,3) = es(6) + R3*es_a
           else                                ! (a|p) case
              na = .a.n_comp
              fa = SHELL2::n_comp_up_to(.a.l-1)        ! Offset into the index array
              do a = 1,na                      ! Put es straight to ab
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa 
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa 
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa 
                 es_a = es(a)
                 ab(a,1) = es(a1) + R1*es_a
                 ab(a,2) = es(a2) + R2*es_a
                 ab(a,3) = es(a3) + R3*es_a
              end
            ! na = .a.n_comp
            ! fa = SHELL2::n_comp_up_to(.a.l-1)        ! Offset into the index array
            ! do b = 1,3                       ! p shell on b
            !    t = first_nonzero(b+1)        ! The transfer component
            !    Rt = R(t)
            !    do a = 1,na                   ! Put es straight to ab
            !       a1 = index_p1(a+fa,t) - fa 
            !       ab(a,b) = es(a1) + Rt*es(a)
            !    end
            ! end
           end
        case default                           ! general (a|b) case
           R  = .a.pos - .b.pos
           fa = SHELL2::n_comp_up_to(.a.l-1)           ! Offset into the index array
         ! na = SHELL2::n_comp_up_to(.l_sum-1) - fa    ! The momentum for es goes down one
           na = es.dim - SHELL2:n_comp(.l_sum)        ! No. of a's in int_new goes down
           int_new.create(na,3)
              do a = 1,na                      ! Start with p shell on a
                 aa = a+fa
                 a1 = GAUSSIAN_DATA::index_p1(aa,1) - fa 
                 a2 = GAUSSIAN_DATA::index_p1(aa,2) - fa 
                 a3 = GAUSSIAN_DATA::index_p1(aa,3) - fa 
                 es_a = es(a)
                 int_new(a,1) = es(a1) + R1*es_a
                 int_new(a,2) = es(a2) + R2*es_a
                 int_new(a,3) = es(a3) + R3*es_a
              end
           fb = 1
           nb = 3
           do l = 2,.b.l-1
            ! na = SHELL2::n_comp_up_to(.l_sum-l) - fa ! No. of a's in int_new goes down
            ! nb = SHELL2:n_comp(l)                   ! Make only the needed b's
            ! fb = SHELL2::n_comp_up_to(l-1)           ! Offset into index arrays
            ! pb = SHELL2::n_comp_up_to(l-2)           ! Previous offset for b, in int_old
              na = na - SHELL2::n_comp(.l_sum-l+1)     ! No. of a's in int_new goes down
              pb = fb                          ! Previous offset for b, in int_old
              fb = fb + nb                     ! Offset into index arrays
              nb = SHELL2::n_comp(l)                   ! Make only the needed b's
              int_old => int_new
              int_new.create(na,nb)
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)       ! Transfer component
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    int_new(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
              end
              int_old.destroy
           end
              na = .a.n_comp                   ! Final transfer into (a|b)
            ! nb = .b.n_comp
            ! fb = SHELL2::n_comp_up_to(.b.l-1)
            ! pb = SHELL2::n_comp_up_to(.b.l-2)
              pb = fb
              fb = fb + nb
              nb = .b.n_comp
              int_old => int_new
              do b = 1,nb
                 b1 = GAUSSIAN_DATA::index_m1(b+fb) - pb
                 t = GAUSSIAN_DATA::first_nonzero(b+fb)
                 Rt = R(t)
                 do a = 1,na
                    a1 = GAUSSIAN_DATA::index_p1(a+fa,t) - fa
                    ab(a,b) = int_old(a1,b1) + Rt*int_old(a,b1)
                 end
               end
               int_old.destroy
        end ! case statement
   end

   transfer_l_b_high(es,ab) ::: private
   ! Applies the transfer equation to (e|s) to give (a|b) where shell b has the higher
   ! angular momentum. NOTE: .set_hrr_indexing_arrays must be called beforehand.
     self :: IN
     es :: VEC{REAL}, IN
     ab :: MAT{REAL}, OUT
   ENSURE(.b.l>=.a.l,"shell b must have higher momentum than a")
   ENSURE(es.dim ==(SHELL2::n_comp_up_to(.l_sum)-SHELL2::n_comp_up_to(.l_max-1)),"wrong size, es")
   ENSURE(ab.dim1==.a.n_comp,"wrong 1st dimension, ab")
   ENSURE(ab.dim2==.b.n_comp,"wrong 2nd dimension, ab")
   ENSURE(first_nonzero.created,"no indexing arrays")
     int_new,int_old :: MAT{REAL}*
     R :: VEC{REAL}(3)
     Rt,R1,R2,R3,es_b :: REAL
     a,b,a1,b1,b2,b3,bb,l,na,fa,pa,nb,fb,t :: INT
     select case (.a.l)
        case (0)                               ! (s|b) case
           ab(1,:) = es
        case (1)                              
           R  = .b.pos - .a.pos
           R1 = R(1); R2 = R(2); R3 = R(3)
           if (.b.l==1) then                   ! (p|p) case
              es_b = es(1)
              ab(1,1) = es(4) + R1*es_b
              ab(2,1) = es(7) + R2*es_b
              ab(3,1) = es(8) + R3*es_b
              es_b = es(2)
              ab(1,2) = es(7) + R1*es_b
              ab(2,2) = es(5) + R2*es_b
              ab(3,2) = es(9) + R3*es_b
              es_b = es(3)
              ab(1,3) = es(8) + R1*es_b
              ab(2,3) = es(9) + R2*es_b
              ab(3,3) = es(6) + R3*es_b
           else                                ! (p|b) case
              nb = .b.n_comp
              fb = SHELL2::n_comp_up_to(.b.l-1)        ! Offset into the index array
              do b = 1,nb                      ! Put es straight to ab
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb 
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb 
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb 
                 es_b = es(b)
                 ab(1,b) = es(b1) + R1*es_b
                 ab(2,b) = es(b2) + R2*es_b
                 ab(3,b) = es(b3) + R3*es_b
              end
            ! do a = 1,3                       ! p shell on a
            !    t = first_nonzero(a+1)        ! The transfer component
            !    Rt = R(t)
            !    do b = 1,nb                   ! Put es straight to ab
            !       b1 = index_p1(b+fb,t) - fb 
            !       ab(a,b) = es(b1) + Rt * es(b)
            !    end
            ! end
           end
       case default
           R  = .b.pos - .a.pos
           R1 = R(1); R2 = R(2); R3 = R(3)
           fb = SHELL2::n_comp_up_to(.b.l-1)           ! Offset into the index array
         ! nb = SHELL2::n_comp_up_to(.l_sum-1) - fb    ! The momentum for es goes down one
           nb = es.dim - SHELL2:n_comp(.l_sum)        ! No. of b's in int_new goes down
           int_new.create(nb,3)                ! NOTE: int_new ia transposed
              do b = 1,nb                      ! Start with p shell on a
                 bb = b+fb
                 b1 = GAUSSIAN_DATA::index_p1(bb,1) - fb 
                 b2 = GAUSSIAN_DATA::index_p1(bb,2) - fb 
                 b3 = GAUSSIAN_DATA::index_p1(bb,3) - fb 
                 es_b = es(b)
                 int_new(b,1) = es(b1) + R1*es_b
                 int_new(b,2) = es(b2) + R2*es_b
                 int_new(b,3) = es(b3) + R3*es_b
              end
           fa = 1
           na = 3
           do l = 2,.a.l-1
            ! nb = SHELL2::n_comp_up_to(.l_sum-l) - fb ! No. of b's in int_new goes down
            ! na = SHELL2:n_comp(l)                   ! Make only the needed a's
            ! fa = SHELL2::n_comp_up_to(l-1)           ! Offset into index arrays
            ! pa = SHELL2::n_comp_up_to(l-2)           ! Previous offset for b, in int_old
              nb = nb - SHELL2:n_comp(.l_sum-l+1)     ! No. of b's in int_new goes down
              pa = fa                          ! Previous offset for a, in int_old
              fa = fa + na                     ! Offset into index arrays
              na = SHELL2:n_comp(l)                   ! Make only the needed a's
              int_old => int_new
              int_new.create(nb,na)            ! TRANSPOSED!
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa      ! b1 relative to int_old
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)       ! Transfer component
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    int_new(b,a) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
              end
              int_old.destroy
           end
              nb = .b.n_comp                   ! Final transfer into (a|b)
            ! na = .a.n_comp
            ! fa = SHELL2::n_comp_up_to(.a.l-1)
            ! pa = SHELL2::n_comp_up_to(.a.l-2)
              pa = fa
              fa = fa + na
              na = .a.n_comp
              int_old => int_new
              do a = 1,na
                 a1 = GAUSSIAN_DATA::index_m1(a+fa) - pa
                 t = GAUSSIAN_DATA::first_nonzero(a+fa)
                 Rt = R(t)
                 do b = 1,nb
                    b1 = GAUSSIAN_DATA::index_p1(b+fb,t) - fb
                    ab(a,b) = int_old(b1,a1) + Rt*int_old(b,a1)
                 end
              end
              int_old.destroy
        end ! case statement
   end

!   transfer_l_a_high(es,ab) ::: private
!   ! Applies the transfer equation to (e|s) to give (a|b)
!   ! where a has the higher angular momentum.
!     self :: IN
!     es :: VEC{REAL}, IN
!     ab :: MAT{REAL}, OUT
!     ABvec :: VEC{REAL}(3)
!     first_nonzero :: VEC{INT}*
!     momenta :: MAT{INT}*
!     index :: MAT3{INT}*
!     a_momenta,b_momenta :: VEC{INT}(3)
!     int_new,int_old :: MAT{REAL}*
!     a,b,lb,aub,bub,lb1_n_comp_sum,lb2_n_comp_sum :: INT
!     a1,b1,z,eadd,tmp :: INT
!     ABi :: REAL
!
!     select case (.b.l)
!       case (0)
!         ab(:,1)=es
!
!       case (1)
!         ABvec = .a.pos - .b.pos
!         eadd  = SHELL2::n_comp_up_to(.a.l-1)
!         aub   = SHELL2::n_comp_up_to(.l_sum-1) - eadd
!
!         momenta.create(3, SHELL2::n_comp_up_to(.l_sum))
!         index.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         first_nonzero.create(SHELL2::n_comp_up_to(.l_sum))
!       ! tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.l_sum)
!       ! SHELL2:make_gaussian_xyz_powrs(.l_sum,momenta)
!       ! SHELL2:make_index_from_powers(index,momenta)
!         SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero)
!       ! index.make_index_of_components(momenta)
!
!         do b=1,3
!           z   = momenta(:,b+1).index_of_first_nonzero_value
!           ABi = ABvec(z)
!           do a=1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!             a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
!             ab(a,b)      = es(a1) + ABi * es(a)
!           end
!         end
!         first_nonzero.destroy
!         index.destroy
!         momenta.destroy
!
!       case default
!         ABvec = .a.pos - .b.pos
!         eadd  = SHELL2::n_comp_up_to(.l_max-1)
!         aub   = SHELL2::n_comp_up_to(.l_sum-1) - eadd
!
!         momenta.create(3,SHELL2::n_comp_up_to(.l_sum))
!         index.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         first_nonzero.create(SHELL2::n_comp_up_to(.l_sum))
!       ! tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.l_sum)
!       ! SHELL2:make_gaussian_xyz_powrs(.l_sum,momenta)
!       ! SHELL2:make_index_from_powers(index,momenta)
!         SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero)
!       ! index.make_index_of_components(momenta)
!
!         int_new.create(aub,3)
!         do b=1,3
!           z   = momenta(:,b+1).index_of_first_nonzero_value
!           ABi = ABvec(z)
!           do a=1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!             a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
!             int_new(a,b) = es(a1) + ABi * es(a)
!           end
!         end
!
!         do lb=2, .b.l-1
!           lb1_n_comp_sum = SHELL2::n_comp_up_to(lb-1)
!           lb2_n_comp_sum = SHELL2::n_comp_up_to(lb-2)
!           bub            = SHELL2::n_comp_up_to(lb) - lb1_n_comp_sum
!           aub            = SHELL2::n_comp_up_to(.l_sum-lb) - eadd
!           int_old        => int_new
!           nullify(int_new)
!           int_new.create(aub,bub)
!           do b=1,bub
!             b_momenta    = momenta(:, b + lb1_n_comp_sum)
!             z            = b_momenta.index_of_first_nonzero_value
!             b_momenta(z) = b_momenta(z) - 1
!             b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
!             ABi          = ABvec(z)
!             do a=1,aub
!               a_momenta    = momenta(:, a + eadd)
!               a_momenta(z) = a_momenta(z) + 1
!               a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
!               int_new(a,b) = int_old(a1,b1) + ABi * int_old(a,b1)
!             end
!           end
!           int_old.destroy
!         end
!
!         lb1_n_comp_sum = SHELL2::n_comp_up_to(.b.l-1)
!         lb2_n_comp_sum = SHELL2::n_comp_up_to(.b.l-2)
!         bub            = SHELL2::n_comp_up_to(.b.l) - lb1_n_comp_sum
!         aub            = SHELL2::n_comp_up_to(.l_sum-.b.l) - eadd
!         int_old        => int_new
!         do b=1,bub
!           b_momenta    = momenta(:, b + lb1_n_comp_sum)
!           z            = b_momenta.index_of_first_nonzero_value
!           b_momenta(z) = b_momenta(z) - 1
!           b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
!           ABi          = ABvec(z)
!           do a=1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!             a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
!             ab(a,b)      = int_old(a1,b1) + ABi * int_old(a,b1)
!           end
!         end
!         int_old.destroy
!         first_nonzero.destroy
!         index.destroy
!         momenta.destroy
!     end
!   end

!   transfer_l_a_high(es,ab) ::: private
!   ! Applies the transfer equation to (e|s) to give (a|b)
!   ! where a has the higher angular momentum.
!     self :: IN
!     es :: VEC{REAL}, IN
!     ab :: MAT{REAL}, OUT
!     ABvec :: VEC{REAL}(3)
!     first_nonzero,index_m1 :: VEC{INT}*
!     index_p1 :: MAT{INT}*
!     momenta :: MAT{INT}*
!     index :: MAT3{INT}*
!     a_momenta,b_momenta :: VEC{INT}(3)
!     int_new,int_old :: MAT{REAL}*
!     a,b,lb,aub,bub,lb1_n_comp_sum,lb2_n_comp_sum :: INT
!     a1,b1,z,eadd,tmp :: INT
!     ABi :: REAL
!
!     select case (.b.l)
!       case (0)
!         ab(:,1)=es
!
!       case (1)
!         ABvec = .a.pos - .b.pos
!         eadd  = SHELL2::n_comp_up_to(.a.l-1)
!         aub   = SHELL2::n_comp_up_to(.l_sum-1) - eadd
!
!         momenta.create(3, SHELL2::n_comp_up_to(.l_sum))
!         index.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         first_nonzero.create(SHELL2::n_comp_up_to(.l_sum))
!         index_m1.create(SHELL2::n_comp_up_to(.l_sum))
!         index_p1.create(SHELL2::n_comp_up_to(.l_sum),3)
!       ! tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.l_sum)
!       ! SHELL2:make_gaussian_xyz_powrs(.l_sum,momenta)
!       ! SHELL2:make_index_from_powers(index,momenta)
!
!       ! SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero,index_p1,index_m1)
!         SHELL2:make_hrr_indices(.l_sum,first_nonzero,index_m1,index_p1)
!       ! index.make_index_of_components(momenta)
!
!         do b=1,3
!         ! z   = momenta(:,b+1).index_of_first_nonzero_value
!           z = first_nonzero(b+1)
!           ABi = ABvec(z)
!           do a=1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!           ! a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
!             a1 = index_p1(a+eadd,z) - eadd
!             ab(a,b) = es(a1) + ABi * es(a)
!           end
!         end
!         index_p1.destroy
!         index_m1.destroy
!         first_nonzero.destroy
!         index.destroy
!         momenta.destroy
!
!       case default
!        print *, "here"
!         ABvec = .a.pos - .b.pos
!         eadd  = SHELL2::n_comp_up_to(.l_max-1)
!         aub   = SHELL2::n_comp_up_to(.l_sum-1) - eadd
!
!         momenta.create(3,SHELL2::n_comp_up_to(.l_sum))
!         index.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         first_nonzero.create(SHELL2::n_comp_up_to(.l_sum))
!         index_m1.create(SHELL2::n_comp_up_to(.l_sum))
!         index_p1.create(SHELL2::n_comp_up_to(.l_sum),3)
!       ! tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.l_sum)
!       ! SHELL2:make_gaussian_xyz_powrs(.l_sum,momenta)
!       ! SHELL2:make_index_from_powers(index,momenta)
!
!       ! SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero,index_p1,index_m1)
!       ! SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero)
!         SHELL2:make_hrr_indices(.l_sum,first_nonzero,index_m1,index_p1)
!       ! index.make_index_of_components(momenta)
!
!         int_new.create(aub,3)
!         do b=1,3
!         ! z = momenta(:,b+1).index_of_first_nonzero_value
!           z = first_nonzero(b+1)
!           ABi = ABvec(z)
!           do a=1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!             a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
!             a1 = index_p1(a+eadd,z) - eadd
!             int_new(a,b) = es(a1) + ABi * es(a)
!           end
!         end
!
!         do lb=2, .b.l-1
!           lb1_n_comp_sum = SHELL2::n_comp_up_to(lb-1)
!           lb2_n_comp_sum = SHELL2::n_comp_up_to(lb-2)
!           bub            = SHELL2::n_comp_up_to(lb) - lb1_n_comp_sum
!           aub            = SHELL2::n_comp_up_to(.l_sum-lb) - eadd
!           int_old        => int_new
!           nullify(int_new)
!           int_new.create(aub,bub)
!           do b=1,bub
!             b_momenta    = momenta(:, b + lb1_n_comp_sum)
!             z            = b_momenta.index_of_first_nonzero_value
!             z = first_nonzero(b+lb1_n_comp_sum)
!             b_momenta(z) = b_momenta(z) - 1
!             b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
!             b1 = index_m1(b+lb1_n_comp_sum) - lb2_n_comp_sum
!             ABi          = ABvec(z)
!             do a=1,aub
!               a_momenta    = momenta(:, a + eadd)
!               a_momenta(z) = a_momenta(z) + 1
!               a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
!               a1 = index_p1(a+eadd,z) - eadd
!               int_new(a,b) = int_old(a1,b1) + ABi * int_old(a,b1)
!             end
!           end
!           int_old.destroy
!         end
!
!         lb1_n_comp_sum = SHELL2::n_comp_up_to(.b.l-1)
!         lb2_n_comp_sum = SHELL2::n_comp_up_to(.b.l-2)
!         bub            = SHELL2::n_comp_up_to(.b.l) - lb1_n_comp_sum
!         aub            = SHELL2::n_comp_up_to(.l_sum-.b.l) - eadd
!         int_old        => int_new
!         do b=1,bub
!           b_momenta    = momenta(:, b + lb1_n_comp_sum)
!           z            = b_momenta.index_of_first_nonzero_value
!           z = first_nonzero(b+lb1_n_comp_sum)
!           b_momenta(z) = b_momenta(z) - 1
!           b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
!           b1 = index_m1(b+lb1_n_comp_sum) - lb2_n_comp_sum
!           ABi          = ABvec(z)
!           do a=1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!             a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
!             a1 = index_p1(a+eadd,z) - eadd
!             ab(a,b) = int_old(a1,b1) + ABi * int_old(a,b1)
!           end
!         end
!         int_old.destroy
!         index_p1.destroy
!         index_m1.destroy
!         first_nonzero.destroy
!         index.destroy
!         momenta.destroy
!     end
!   end

!   transfer_l_b_high(es,ab) ::: private
!   ! Applies the transfer equation to (e|s) to give (a|b)
!   ! where b has the higher angular momentum.
!     self :: IN
!     es :: VEC{REAL}, IN
!     ab :: MAT{REAL}, OUT
!     BAvec :: VEC{REAL}(3)
!     int_new,int_old :: MAT{REAL}*
!     first_nonzero,index_p1,index_m1 :: VEC{INT}*
!     momenta :: MAT{INT}*
!     index :: MAT3{INT}*
!     a_momenta,b_momenta :: VEC{INT}(3)
!     a,b,la,aub,bub,la1_n_comp_sum,la2_n_comp_sum :: INT
!     a1,b1,z,eadd,tmp :: INT
!     BAi :: REAL
!
!     select case (.a.l)
!       case (0)
!         ab(1,:)=es
!
!       case (1)
!         BAvec = .b.pos - .a.pos
!         eadd  = SHELL2::n_comp_up_to(.b.l-1)
!         bub   = SHELL2::n_comp_up_to(.l_sum-1) - eadd
!
!         momenta.create(3,SHELL2::n_comp_up_to(.l_sum))
!         index.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         first_nonzero.create(SHELL2::n_comp_up_to(.l_sum))
!       ! index_p1.create(SHELL2::n_comp_up_to(.l_sum))
!       ! index_m1.create(SHELL2::n_comp_up_to(.l_sum))
!       ! tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.l_sum)
!       ! SHELL2:make_gaussian_xyz_powrs(.l_sum,momenta)
!       ! SHELL2:make_index_from_powers(index,momenta)
!         SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero)
!       ! SHELL2:make_hrr_indices(.l_sum,first_nonzero,index_p1,index_m1)
!       ! index.make_index_of_components(momenta)
!
!         do a=1,3
!           z   = momenta(:,a+1).index_of_first_nonzero_value
!       !   z = first_nonzero(a+1)
!           BAi = BAvec(z)
!           do b=1, bub
!             b_momenta    = momenta(:, b + eadd)
!             b_momenta(z) = b_momenta(z) + 1
!             b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
!       !     b1 = index_p1(b+eadd) - eadd
!             ab(a,b) = es(b1) + BAi * es(b)
!           end
!         end
!       ! index_m1.destroy
!       ! index_p1.destroy
!         first_nonzero.destroy
!         index.destroy
!         momenta.destroy
!
!       case default
!         BAvec = .b.pos - .a.pos
!         eadd  = SHELL2::n_comp_up_to(.b.l-1)
!         bub   = SHELL2::n_comp_up_to(.l_sum-1) - eadd
!
!         momenta.create(3,SHELL2::n_comp_up_to(.l_sum))
!         index.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         first_nonzero.create(SHELL2::n_comp_up_to(.l_sum))
!       ! index_p1.create(SHELL2::n_comp_up_to(.l_sum))
!       ! index_m1.create(SHELL2::n_comp_up_to(.l_sum))
!       ! tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.l_sum)
!       ! SHELL2:make_gaussian_xyz_powrs(.l_sum,momenta)
!       ! SHELL2:make_index_from_powers(index,momenta)
!         SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero)
!       ! SHELL2:make_hrr_indices(.l_sum,first_nonzero,index_p1,index_m1)
!       ! index.make_index_of_components(momenta)
!
!         int_new.create(3,bub)
!         do a = 1,3
!           z   = momenta(:,a+1).index_of_first_nonzero_value
!       !   z = first_nonzero(a+1)
!           BAi = BAvec(z)
!           do b = 1, bub
!             b_momenta    = momenta(:, b + eadd)
!             b_momenta(z) = b_momenta(z) + 1
!             b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
!       !     b1 = index_p1(b+eadd) - eadd
!             int_new(a,b) = es(b1) + BAi * es(b)
!           end
!         end
!
!         do la=2, .a.l - 1
!           la1_n_comp_sum = SHELL2::n_comp_up_to(la-1)
!           la2_n_comp_sum = SHELL2::n_comp_up_to(la-2)
!           aub            = SHELL2::n_comp_up_to(la) - la1_n_comp_sum
!           bub            = SHELL2::n_comp_up_to(.l_sum-la) - eadd
!           int_old=>int_new
!           nullify(int_new)
!           int_new.create(aub,bub)
!           do a = 1,aub
!             a_momenta    = momenta(:,a + la1_n_comp_sum)
!             z            = a_momenta.index_of_first_nonzero_value
!       !     z = first_nonzero(a+1)
!             a_momenta(z) = a_momenta(z) - 1
!             a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - la2_n_comp_sum
!       !     a1 = index_m1(a+la1_n_comp_sum) - la2_n_comp_sum
!             BAi          = BAvec(z)
!             do b = 1,bub
!               b_momenta    = momenta(:,b + eadd)
!               b_momenta(z) = b_momenta(z) + 1
!               b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
!       !       b1 = index_p1(b+eadd) - eadd
!               int_new(a,b) = int_old(a1,b1) + BAi * int_old(a1,b)
!             end
!           end
!           int_old.destroy
!         end
!
!         la1_n_comp_sum = SHELL2::n_comp_up_to(.a.l-1)
!         la2_n_comp_sum = SHELL2::n_comp_up_to(.a.l-2)
!         aub            = SHELL2::n_comp_up_to(.a.l) - la1_n_comp_sum
!         bub            = SHELL2::n_comp_up_to(.l_sum-.a.l) - eadd
!         int_old=>int_new
!         do a = 1,aub
!           a_momenta    = momenta(:,a + la1_n_comp_sum)
!           z            = a_momenta.index_of_first_nonzero_value
!       !   z = first_nonzero(a+la1_n_comp_sum)
!           a_momenta(z) = a_momenta(z) - 1
!           a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - la2_n_comp_sum
!       !   a1 = index_m1(a+la1_n_comp_sum) - la2_n_comp_sum
!           BAi          = BAvec(z)
!           do b=1,bub
!             b_momenta    = momenta(:,b + eadd)
!             b_momenta(z) = b_momenta(z) + 1
!             b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
!       !     b1 = index_p1(b+eadd) - eadd
!             ab(a,b) = int_old(a1,b1) + BAi * int_old(a1,b)
!           end
!         end
!         int_old.destroy
!       ! index_m1.destroy
!       ! index_p1.destroy
!         first_nonzero.destroy
!         index.destroy
!         momenta.destroy
!     end
!   end

!   transfer_l_a_high(es,ab) ::: private
!   ! Applies the transfer equation to (e|s) to give (a|b)
!   ! where a has the higher angular momentum.
!     self :: IN
!     es :: VEC{REAL}, IN
!     ab :: MAT{REAL}, OUT
!     ABvec :: VEC{REAL}(3)
!     first_nonzero :: VEC{INT}*
!     momenta :: MAT{INT}*
!     index :: MAT3{INT}*
!     a_momenta,b_momenta :: VEC{INT}(3)
!     int_new,int_old :: MAT{REAL}*
!     a,b,lb,aub,bub,lb1_n_comp_sum,lb2_n_comp_sum :: INT
!     a1,b1,z,eadd,tmp :: INT
!     ABi :: REAL
!
!     select case (.b.l)
!       case (0)
!         ab(:,1)=es
!
!       case (1)
!         ABvec = .a.pos - .b.pos
!         eadd  = SHELL2::n_comp_up_to(.a.l-1)
!         aub   = SHELL2::n_comp_up_to(.l_sum-1) - eadd
!
!         momenta.create(3,SHELL2::n_comp_up_to(.l_sum))
!         first_nonzero.create(SHELL2::n_comp_up_to(.l_sum))
!         index.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero) 
!
!         do b = 1,3
!!          z = first_nonzero(b)
!           z   = momenta(:,b+1).index_of_first_nonzero_value
!           ABi = ABvec(z)
!           do a = 1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!             a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
!             ab(a,b)      = es(a1) + ABi * es(a)
!           end
!         end
!         index.destroy
!         first_nonzero.destroy
!         momenta.destroy
!
!       case default
!         ABvec = .a.pos - .b.pos
!         eadd  = SHELL2::n_comp_up_to(.l_max-1)
!         aub   = SHELL2::n_comp_up_to(.l_sum-1) - eadd
!
!         momenta.create(3,SHELL2::n_comp_up_to(.l_sum))
!         first_nonzero.create(SHELL2::n_comp_up_to(.l_sum))
!         index.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         SHELL2:make_gaussian_xyz_powers(.l_sum,momenta,index,first_nonzero)
!
!         int_new.create(aub,3)
!         do b=1,3
!!          z   = first_nonzero(b)
!           z   = momenta(:,b+1).index_of_first_nonzero_value
!           ABi = ABvec(z)
!           do a=1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!             a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
!             int_new(a,b) = es(a1) + ABi * es(a)
!           end
!         end
!
!         do lb=2, .b.l-1
!           lb1_n_comp_sum = SHELL2::n_comp_up_to(lb-1)
!           lb2_n_comp_sum = SHELL2::n_comp_up_to(lb-2)
!           bub            = SHELL2::n_comp_up_to(lb) - lb1_n_comp_sum
!           aub            = SHELL2::n_comp_up_to(.l_sum-lb) - eadd
!           int_old        => int_new
!           nullify(int_new)
!           int_new.create(aub,bub)
!           do b=1,bub
!             b_momenta    = momenta(:, b + lb1_n_comp_sum)
!!            z   = first_nonzero(b)
!             z            = b_momenta.index_of_first_nonzero_value
!             b_momenta(z) = b_momenta(z) - 1
!             b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
!             ABi          = ABvec(z)
!             do a=1,aub
!               a_momenta    = momenta(:, a + eadd)
!               a_momenta(z) = a_momenta(z) + 1
!               a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
!               int_new(a,b) = int_old(a1,b1) + ABi * int_old(a,b1)
!             end
!           end
!           int_old.destroy
!         end
!
!         lb1_n_comp_sum = SHELL2::n_comp_up_to(.b.l-1)
!         lb2_n_comp_sum = SHELL2::n_comp_up_to(.b.l-2)
!         bub            = SHELL2::n_comp_up_to(.b.l) - lb1_n_comp_sum
!         aub            = SHELL2::n_comp_up_to(.l_sum-.b.l) - eadd
!         int_old        => int_new
!         do b=1,bub
!           b_momenta    = momenta(:, b + lb1_n_comp_sum)
!!          z   = first_nonzero(b)
!           z            = b_momenta.index_of_first_nonzero_value
!           b_momenta(z) = b_momenta(z) - 1
!           b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
!           ABi          = ABvec(z)
!           do a=1,aub
!             a_momenta    = momenta(:, a + eadd)
!             a_momenta(z) = a_momenta(z) + 1
!             a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
!             ab(a,b)      = int_old(a1,b1) + ABi * int_old(a,b1)
!           end
!         end
!         int_old.destroy
!         index.destroy
!         first_nonzero.destroy
!         momenta.destroy
!     end
!   end

!   transfer_l_a_high(es,ab) ::: private
!   ! Applies the transfer equation to the basic integrals (e|s), where e are all
!   ! gaussian functions up to angular momentum .a.l+.b.l, to give the required
!   ! integrals (a|b), in the case where a has the higher angular momentum out of
!   ! a and b.
!     self :: IN
!     es :: VEC{REAL}, IN
!     ab :: MAT{REAL}, target, OUT
!     AB :: VEC{REAL}(3)
!     pe :: MAT{INT}*
!     index_of :: MAT3{INT}*
!     pa,pb :: VEC{INT}(3)
!     int_new,int_old :: MAT{REAL}*
!     a,b,lb,aub,bub,lb1_n_comp_sum,lb2_n_comp_sum :: INT
!     a1,b1,z,eadd :: INT
!     ABt :: REAL
!     select case (.b.l)
!       case (0)                                     ! b = s function
!         ab(:,1) = es
!       case (1)                                     ! b = p function
!         AB = .a.pos - .b.pos           ! position difference
!         fa = (.l_max-1).n_comp_sum     ! Minimum for gaussian component powers
!         na = a.n_comp                  ! No. of "a" components to do
!         index_of.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         0.make_gaussian_xyz_powers(pe,.l_sum,index_of)
!         do a = 1,na
!            aa = a + fa
!            pa = pe(:,aa)
!            a1 = index_of( pa(1)+1,pa(2)  ,pa(3)  )
!            a2 = index_of( pa(1)  ,pa(2)+1,pa(3)  )
!            a3 = index_of( pa(1)  ,pa(2)  ,az(2)+1)
!            ab(a,1) = es(a1) + AB(1) * es(a)
!            ab(a,2) = es(a2) + AB(2) * es(a)
!            ab(a,3) = es(a3) + AB(3) * es(a)
!         end
!         index_of.destroy
!         ez.destroy; ey.destroy; ex.destroy
!       case default
!         AB = .a.pos - .b.pos
!         ! The lexical indices for the gaussian functions for all integrals 
!         ! (including intermediate (e|s) integrals) always start from one more 
!         ! than this index. 
!         fa = (.l_max-1).n_comp_sum      
!         la = (.l_sum-1).n_comp_sum 
!         ne =.l_sum.n_comp_sum
!         ! The new integrals go up to angular momentum .l_sum-1. "na" is the
!         ! maximum lexical index of the new integrals minus the lowest possible
!         ! lexical index "la".
!         na = la - fa
!         pe.create(3,ne)
!         transfer.create(ne)
!         index_of.create(0,.l_sum, 0,.l_sum, 0,.l_sum)
!         0.make_gaussian_xyz_powers(pe,.l_sum,index_of,transfer) ! keep as zero for global
!         ! Make the first p-type b integrals in "new_ints"
!         ! Need to do this separately since "es" is a vector
!         new_ints.create(na,3)
!         do a = 1,na
!            aa = a + fa
!            pa = pe(:,aa)
!            a1 = index_of( pa(1)+1,pa(2)  ,pa(3)  )
!            a2 = index_of( pa(1)  ,pa(2)+1,pa(3)  )
!            a3 = index_of( pa(1)  ,pa(2)  ,az(2)+1)
!            new_ints(a,1) = es(a1) + AB(1) * es(a)
!            new_ints(a,2) = es(a2) + AB(2) * es(a)
!            new_ints(a,3) = es(a3) + AB(3) * es(a)
!         end
!         ! Now make the d-type -> .b.l type b integrals in "new_ints"
!         ! The last time "new_ints" stand for the target "ab" integrals.
!         fb = 1 ! first b of the "new_ints" (minus 1)
!         nb = 3
!         do lb = 2,.b.l
!           fo = fb                ! first b of the "old_ints" (minus 1)
!           fb = fb + nb           ! first b of the "new_ints" (minus 1)
!           nb = lb.n_comp         ! Only produce the required lb-shell of "b" ints
!           la = (.l_sum-lb).n_comp_sum
!           na = la - fa
!           old_ints => new_ints
!           if (lb<.b.l) then; new_ints.create(na,nb)
!           else;              new_ints => ab
!           end
!
!           if (lb==1) then
!              do a = 1,na
!                 aa = a + fa
!                 pa = pe(:,aa)
!                 a1 = index_of( pa(1)+1,pa(2)  ,pa(3)  )
!                 a2 = index_of( pa(1)  ,pa(2)+1,pa(3)  )
!                 a3 = index_of( pa(1)  ,pa(2)  ,pa(3)+1)
!                 new_ints(a,1) = es(a1) + AB(1) * es(a)
!                 new_ints(a,2) = es(a2) + AB(2) * es(a)
!                 new_ints(a,3) = es(a3) + AB(3) * es(a)
!              end
!           else
!              do b = 1,nb         ! Loop over "b" shell component
!                bb = b + fb       ! Offset into gaussian power array
!                pb = pe(:,bb)     ! powers of the current "b" shell component
!                t  = transfer(bb) ! transfer this component
!                pb(t) = pb(t) - 1 ! Index of the transferred compenent in "old_ints"
!                b1 = index_of(pb(1),pb(2),pb(3)) - fo
!                ABt = AB(t)       ! The AB transfer component difference
!                do a = 1,na
!                  aa = a + fa
!                  pa = pe(:,aa)
!                  pa(t) = pa(t) + 1
!                  a1 = index_of(pa(1),pa(2),pa(3)) - fa
!                  new_ints(a,b) = old_ints(a1,b1) + ABt * old_ints(a,b1)
!                end
!              end
!           end
!           old_ints.destroy
!         end
!         index_of.destroy
!         pe.destroy
!     end
!   end

!  ******************
!  Indexing functions
!  ******************

   n_comp(l) result(res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of cartesian components in a gaussian shell of momentum "l".
   end

   n_comp_up_to(l) result(res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
   end

!   make_gaussian_xyz_powrs(l_max,powers) ::: selfless, private, pure
!   ! Returns "powers", the powers of the cartesian components of all gaussian
!   ! function with angular momenta between "0" and "l_max". Size of "powers" is
!   ! [3, SHELL2::n_comp_up_to(l_max) - SHELL2::n_comp_up_to(0-1)].
!     powers :: MAT{INT}, OUT
!     l_max :: INT, IN
!   ENSURE(powers.dim1==3,"wrong 1st dimension, powers")
!   ENSURE(powers.dim2==(SHELL2::n_comp_up_to(l_max)-SHELL2::n_comp_up_to(0-1)),"wrong 2nd dimension, powers")
!     l,i,a,b,c :: INT
!     i = 1
!     do l = 0,l_max
!       do a = l,floor((l+2)*THIRD),-1
!         do b = min(l-a,a),floor((l-a+1)*HALF),-1
!           c = l - a - b
!           if (a==b AND b==c) then
!             powers(1:3,i)   = [a,a,a]
!             i = i+1
!           else if (a>b AND b==c) then
!             powers(1:3,i  ) = [a,b,b]
!             powers(1:3,i+1) = [b,a,b]
!             powers(1:3,i+2) = [b,b,a]
!             i = i+3
!           else if (a==b AND b>c) then
!             powers(1:3,i  ) = [a,a,c]
!             powers(1:3,i+1) = [a,c,a]
!             powers(1:3,i+2) = [c,a,a]
!             i = i+3
!           else
!             powers(1:3,i  ) = [a,b,c]
!             powers(1:3,i+1) = [a,c,b]
!             powers(1:3,i+2) = [b,a,c]
!             powers(1:3,i+3) = [c,a,b]
!             powers(1:3,i+4) = [b,c,a]
!             powers(1:3,i+5) = [c,b,a]
!             i = i+6
!           end
!         end
!       end
!     end
!   end

!   make_index_from_powers(index_of,powers) ::: selfless, private, pure
!   ! Returns the lexical index of a gassian function corresponding to the
!   ! powers.  Each dimension of self is powers.dim2.
!     index_of :: MAT3{INT}, OUT
!     powers :: MAT{INT}, IN
!     i,a,b,c :: INT
!     do i = 1,powers.dim2
!        a = powers(1,i)
!        b = powers(2,i)
!        c = powers(3,i)
!        index_of(a+1,b+1,c+1) = i
!     end
!   end

!   make_gaussian_xyz_powers(l_max,power,index_of,first_nonzero,index_p1,index_m1) ::: selfless, private, pure
!   ! Make the cartesian angular momentum powers "power(:,i)" for the gaussian
!   ! with lexical index "i", beginning with the gaussians in the shell with
!   ! angular momentum "0" and going up to angular momentum "l_max".
!   ! "index_of(a,b,c)" is the reverse of array "power" ... it gives the lexical
!   ! index for the gaussian with cartesian angular momenta "a-1", "b-1" and
!   ! "c-1". Note that one must be subtracted because in general the "index_of"
!   ! array will be declared to have a lower bound of 0, whereas in this routine
!   ! it has a lower bound of 1.  "first_nonzero(i)" is the index of the first
!   ! non-zero component in "power(:,i)", used to determine which index is to be
!   ! used in the HRR recursion relations. Note the size of power is:
!   ! [3,SHELL2::n_comp_up_to(l_max) - SHELL2::n_comp_up_to(minl-1)].
!     l_max :: INT, IN
!     power :: MAT{INT}, OUT
!     index_of :: MAT3{INT}, OUT
!     first_nonzero :: VEC{INT}, OUT
!     index_p1,index_m1 :: VEC{INT}, optional, OUT
!   ENSURE(power.dim1==3,"wrong 1st dimension, power")
!   ENSURE(power.dim2==(SHELL2::n_comp_up_to(l_max)-SHELL2::n_comp_up_to(l_min-1)),"wrong 2nd dimension, power")
!   ENSURE(index_of.dim1==(l_max+1),"wrong 1st dimension, index_of")
!   ENSURE(index_of.dim2==(l_max+1),"wrong 2nd dimension, index_of")
!   ENSURE(index_of.dim3==(l_max+1),"wrong 3rd dimension, index_of")
!   ENSURE(first_nonzero.dim==(SHELL2::n_comp_up_to(l_max)-SHELL2::n_comp_up_to(l_min-1)),"wrong dimension, first_nonzero")
!     l,i,a,b,c,a1,b1,c1, f :: INT
!     n,p,m :: VEC{INT}(3)
!     i = 1
!     do l = 0,l_max
!       do a = l,floor((l+2)*THIRD),-1
!         do b = min(l-a,a),floor((l-a+1)*HALF),-1
!           c = l - a - b
!           if (a==b AND b==c) then
!             a1 = a + 1
!             power(1:3,i)       = [a,a,a]
!             index_of(a1,a1,a1) = i
!             first_nonzero(i)   = 1
!             i = i + 1
!           else if (a>b AND b==c) then
!             a1 = a + 1
!             b1 = b + 1
!             power(1:3,i  )     = [a,b,b]
!             power(1:3,i+1)     = [b,a,b]
!             power(1:3,i+2)     = [b,b,a]
!             index_of(a1,b1,b1) = i
!             index_of(b1,a1,b1) = i+1
!             index_of(b1,b1,a1) = i+2
!             first_nonzero(i  ) = 1
!             first_nonzero(i+1) = 2
!             first_nonzero(i+2) = 3
!             if (b>0) then
!               first_nonzero(i+1) = 1
!               first_nonzero(i+2) = 1
!             end
!             i = i + 3
!           else if (a==b AND b>c) then
!             a1 = a + 1
!             c1 = c + 1
!             power(1:3,i  )     = [a,a,c]
!             power(1:3,i+1)     = [a,c,a]
!             power(1:3,i+2)     = [c,a,a]
!             index_of(a1,a1,c1) = i
!             index_of(a1,c1,a1) = i+1
!             index_of(c1,a1,a1) = i+2
!             first_nonzero(i)   = 1
!             first_nonzero(i+1) = 1
!             first_nonzero(i+2) = 2
!             if (c>0) then
!               first_nonzero(i+2) = 1
!             end
!             i = i + 3
!           else
!             a1 = a + 1
!             b1 = b + 1
!             c1 = c + 1
!             power(1:3,i  )     = [a,b,c]
!             power(1:3,i+1)     = [a,c,b]
!             power(1:3,i+2)     = [b,a,c]
!             power(1:3,i+3)     = [c,a,b]
!             power(1:3,i+4)     = [b,c,a]
!             power(1:3,i+5)     = [c,b,a]
!             index_of(a1,b1,c1) = i
!             index_of(a1,c1,b1) = i+1
!             index_of(b1,a1,c1) = i+2
!             index_of(c1,a1,b1) = i+3
!             index_of(b1,c1,a1) = i+4
!             index_of(c1,b1,a1) = i+5
!             if (a>0) then
!               first_nonzero(i  ) = 1
!               first_nonzero(i+1) = 1
!               first_nonzero(i+2) = 2
!               first_nonzero(i+3) = 2
!               first_nonzero(i+4) = 3
!               first_nonzero(i+5) = 3
!             else
!               first_nonzero(i  ) = 3
!               first_nonzero(i+1) = 3
!               first_nonzero(i+2) = 3
!               first_nonzero(i+3) = 3
!               ! i+4,i+5 must have b or c nonzero.
!             end
!             if (b>0) then
!               first_nonzero(i+2) = 1
!               first_nonzero(i+4) = 1
!               first_nonzero(i+5) = 2
!             end
!             if (c>0) then
!               first_nonzero(i+3) = 1
!               first_nonzero(i+5) = 1
!             end
!             i = i + 6
!           end
!         end
!       end
!     end
!     if (NOT present(index_p1)) return
!     if (NOT present(index_m1)) return
!     do i = 1,power.dim2
!        n = power(:,i)
!        f = first_nonzero(i)
!        p = n+1 ! add one for lb=1 on index
!        m = n+1
!        p(f) = p(f) + 1
!        m(f) = m(f) - 1
!        index_p1(i) = index_of(p(1),p(2),p(3))
!        index_m1(i) = index_of(m(1),m(2),m(3))
!     end
!   end

!   make_hrr_indices(l_max,first_nonzero,index_m1,index_p1) ::: selfless, private
!   ! Return "first_nonzero(i)", the cartesian index (between 1 and 3) of the
!   ! first non-zero power for tha gaussian with lexical index "i".  Also return
!   ! "index_m1(i)" and "index_p1(i)", the lexical indices of the gaussians with the
!   ! first nonzero component decremented by one, and incrementred by one,
!   ! respectively. In the latter case we must store all possible increments.
!   ! These are used to determine which gaussian are to be used in the HRR
!   ! recursion relations.  
!     l_max :: INT, IN
!     first_nonzero,index_m1 :: VEC{INT}, OUT
!     index_p1 :: MAT{INT}, OUT
!   ENSURE(first_nonzero.dim==(SHELL2::n_comp_up_to(l_max)),"wrong dimension, first_nonzero")
!   ENSURE(index_m1.dim==first_nonzero.dim,"wrong dimension, index_m1")
!   ENSURE(index_p1.dim1==first_nonzero.dim,"wrong 1st dimension, index_p1")
!   ENSURE(index_p1.dim2==3,"wrong 2nd dimension, index_p1")
!     power :: MAT{INT}*
!     index_of :: MAT3{INT}*
!     l,i,a,b,c,a1,b1,c1, f :: INT
!     n,p,m :: VEC{INT}(3)
!     power.create(3,SHELL2::n_comp_up_to(l_max))
!     index_of.create(l_max+1,l_max+1,l_max+1)
!     i = 1                    ! First make the power, index_of and first_nonzero arrays ...
!     do l = 0,l_max
!       do a = l,floor((l+2)*THIRD),-1
!         do b = min(l-a,a),floor((l-a+1)*HALF),-1
!           c = l - a - b
!           if (a==b AND b==c) then
!             a1 = a + 1
!             power(1:3,i)       = [a,a,a]
!             index_of(a1,a1,a1) = i
!             first_nonzero(i)   = 1
!             i = i + 1
!           else if (a>b AND b==c) then
!             a1 = a + 1
!             b1 = b + 1
!             power(1:3,i  )     = [a,b,b]
!             power(1:3,i+1)     = [b,a,b]
!             power(1:3,i+2)     = [b,b,a]
!             index_of(a1,b1,b1) = i
!             index_of(b1,a1,b1) = i+1
!             index_of(b1,b1,a1) = i+2
!             first_nonzero(i  ) = 1
!             first_nonzero(i+1) = 2
!             first_nonzero(i+2) = 3
!             if (b>0) then
!               first_nonzero(i+1) = 1
!               first_nonzero(i+2) = 1
!             end
!             i = i + 3
!           else if (a==b AND b>c) then
!             a1 = a + 1
!             c1 = c + 1
!             power(1:3,i  )     = [a,a,c]
!             power(1:3,i+1)     = [a,c,a]
!             power(1:3,i+2)     = [c,a,a]
!             index_of(a1,a1,c1) = i
!             index_of(a1,c1,a1) = i+1
!             index_of(c1,a1,a1) = i+2
!             first_nonzero(i)   = 1
!             first_nonzero(i+1) = 1
!             first_nonzero(i+2) = 2
!             if (c>0) then
!               first_nonzero(i+2) = 1
!             end
!             i = i + 3
!           else
!             a1 = a + 1
!             b1 = b + 1
!             c1 = c + 1
!             power(1:3,i  )     = [a,b,c]
!             power(1:3,i+1)     = [a,c,b]
!             power(1:3,i+2)     = [b,a,c]
!             power(1:3,i+3)     = [c,a,b]
!             power(1:3,i+4)     = [b,c,a]
!             power(1:3,i+5)     = [c,b,a]
!             index_of(a1,b1,c1) = i
!             index_of(a1,c1,b1) = i+1
!             index_of(b1,a1,c1) = i+2
!             index_of(c1,a1,b1) = i+3
!             index_of(b1,c1,a1) = i+4
!             index_of(c1,b1,a1) = i+5
!             if (a>0) then
!               first_nonzero(i  ) = 1
!               first_nonzero(i+1) = 1
!               first_nonzero(i+2) = 2
!               first_nonzero(i+3) = 2
!               first_nonzero(i+4) = 3
!               first_nonzero(i+5) = 3
!             else
!               first_nonzero(i  ) = 3
!               first_nonzero(i+1) = 3
!               first_nonzero(i+2) = 3
!               first_nonzero(i+3) = 3
!               ! i+4,i+5 must have b or c nonzero.
!             end
!             if (b>0) then
!               first_nonzero(i+2) = 1
!               first_nonzero(i+4) = 1
!               first_nonzero(i+5) = 2
!             end
!             if (c>0) then
!               first_nonzero(i+3) = 1
!               first_nonzero(i+5) = 1
!             end
!             i = i + 6
!           end
!         end
!       end
!     end
!     do i = 1,power.dim2     ! Now make the index_p1, index_m1 arrays
!        n = power(:,i)
!        f = first_nonzero(i)
!        p = n + 1            ! add one, since lb=1 on index which should 0
!        m = n + 1
!        m(f) = m(f) - 1
!        index_m1(i) = index_of(m(1),m(2),m(3))
!        do f = 1,3
!           p(f) = p(f) + 1
!           index_p1(i,f) = index_of(p(1),p(2),p(3))
!           p(f) = p(f) - 1
!        end
!     end
!     index_of.destroy
!     power.destroy
!   end

!   set_gaussian_indexing_arrays(l_max) ::: leaky
!   ! Set the arrays required to do the transfer relations and the horizontal
!   ! recursion relations to the (e|s) type integrals to give the (a|b) type
!   ! integrals. "l_max" is the maximum angular momentum basis function used in
!   ! the basis set.
!     self :: IN
!     l_max :: INT, IN
!   ENSURE(l_max>=0,"l_max must be positive")
!     l2,lsum,lmax,n :: INT
!     g :: GAUSSIAN_INDICES
!     if (l_max<=l_max_hrr) return
!     l_max_hrr = l_max
!     l2 = 2*l_max         ! Indices go up to 2*l_max
!     index_p1.destroy; index_m1.destroy
!     first_nonzero.destroy
!     nz.destroy; ny.destroy; nx.destroy
!     n = SHELL2::n_comp_up_to(l2)
!     nx.create(n); ny.create(n); nz.create(n)
!     first_nonzero.create(n)
!     index_m1.create(n)
!     index_p1.create(n,3)
!     ! Set the cartesian gaussian indexing arrays
!   ! call make_hrr_indices(l2,first_nonzero,index_m1,index_p1)
!   ! call make_gaussian_xyz_indices(nx,ny,nz,0,l2)
!     call make_gaussian_indexing_arrays(l2,nx,ny,nz,first_nonzero,index_m1,index_p1)
!     gaussian_indices.destroy
!     gaussian_indices.create(0,l_max,0,l_max)
!     gaussian_indices.set_indices
!   end

!   make_gaussian_indexing_arrays(l_max,nx,ny,nz,first_nonzero,index_m1,index_p1) ::: selfless, private
!   ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
!   ! momentum up to "l_max". (Actually adds one to each power to avoid 0 as
!   ! lower bound). Return "first_nonzero(i)", the cartesian index (between 1 and
!   ! 3) of the first non-zero power for the gaussian with lexical index "i".
!   ! Also return "index_m1(i)" and "index_p1(i)", the lexical indices of the
!   ! gaussians with the first nonzero component decremented by one, and
!   ! incrementred by one, respectively. In the latter case we must store all
!   ! possible increments.  These are used to determine which gaussian are to be
!   ! used in the HRR recursion relations.  
!     l_max :: INT, IN
!     nx,ny,nz :: VEC{INT}, OUT
!     first_nonzero,index_m1 :: VEC{INT}, OUT
!     index_p1 :: MAT{INT}, OUT
!   ENSURE(first_nonzero.dim==(SHELL2::n_comp_up_to(l_max)),"wrong dimension, first_nonzero")
!   ENSURE(index_m1.dim==first_nonzero.dim,"wrong dimension, index_m1")
!   ENSURE(index_p1.dim1==first_nonzero.dim,"wrong 1st dimension, index_p1")
!   ENSURE(index_p1.dim2==3,"wrong 2nd dimension, index_p1")
!     a,b,c,i,j,a1,b1,c1,f,n :: INT
!     p,m :: VEC{INT}(3)
!     index_of :: MAT3{INT}*
!     index_of.create(l_max+1,l_max+1,l_max+1)
!     i = 1
!     do j = 0,l_max
!       do a = j,floor((j+2)*THIRD),-1
!          do b = min(j-a,a),floor((j-a+1)*HALF),-1
!            c = j - a - b
!            if (a==b AND b==c) then
!              a1=a+1
!              nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = a1
!              index_of(a1,a1,a1) = i
!              first_nonzero(i)   = 1
!              i =i+1
!            else if (a>b AND b==c) then
!              a1=a+1
!              b1=b+1
!              nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = b1
!              nx(i+1) = b1; ny(i+1) = a1; nz(i+1) = b1
!              nx(i+2) = b1; ny(i+2) = b1; nz(i+2) = a1
!              index_of(a1,b1,b1) = i
!              index_of(b1,a1,b1) = i+1
!              index_of(b1,b1,a1) = i+2
!              first_nonzero(i  ) = 1
!              first_nonzero(i+1) = 2
!              first_nonzero(i+2) = 3
!              if (b>0) then
!                first_nonzero(i+1) = 1
!                first_nonzero(i+2) = 1
!              end
!              i =i+3
!            else if (a==b AND b>c) then
!              a1=a+1
!              c1=c+1
!              nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = c1
!              nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = a1
!              nx(i+2) = c1; ny(i+2) = a1; nz(i+2) = a1
!              index_of(a1,a1,c1) = i
!              index_of(a1,c1,a1) = i+1
!              index_of(c1,a1,a1) = i+2
!              first_nonzero(i)   = 1
!              first_nonzero(i+1) = 1
!              first_nonzero(i+2) = 2
!              if (c>0) then
!                first_nonzero(i+2) = 1
!              end
!              i =i+3
!            else
!              a1=a+1
!              b1=b+1
!              c1=c+1
!              nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = c1
!              nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = b1
!              nx(i+2) = b1; ny(i+2) = a1; nz(i+2) = c1
!              nx(i+3) = c1; ny(i+3) = a1; nz(i+3) = b1
!              nx(i+4) = b1; ny(i+4) = c1; nz(i+4) = a1
!              nx(i+5) = c1; ny(i+5) = b1; nz(i+5) = a1
!              index_of(a1,b1,c1) = i
!              index_of(a1,c1,b1) = i+1
!              index_of(b1,a1,c1) = i+2
!              index_of(c1,a1,b1) = i+3
!              index_of(b1,c1,a1) = i+4
!              index_of(c1,b1,a1) = i+5
!              if (a>0) then
!                first_nonzero(i  ) = 1
!                first_nonzero(i+1) = 1
!                first_nonzero(i+2) = 2
!                first_nonzero(i+3) = 2
!                first_nonzero(i+4) = 3
!                first_nonzero(i+5) = 3
!              else
!                first_nonzero(i  ) = 3
!                first_nonzero(i+1) = 3
!                first_nonzero(i+2) = 3
!                first_nonzero(i+3) = 3
!                ! i+4,i+5 must have b or c nonzero.
!              end
!              if (b>0) then
!                first_nonzero(i+2) = 1
!                first_nonzero(i+4) = 1
!                first_nonzero(i+5) = 2
!              end
!              if (c>0) then
!                first_nonzero(i+3) = 1
!                first_nonzero(i+5) = 1
!              end
!              i =i+6
!            end
!         end
!       end
!     end
!     do i = 1,nx.dim         ! Now make the index_p1, index_m1 arrays
!        p = [nx(i),ny(i),nz(i)]
!        m = p                ! add one, since lb=1 on index which should 0
!        f = first_nonzero(i)
!        m(f) = m(f) - 1
!        index_m1(i) = index_of(m(1),m(2),m(3))
!        do f = 1,3
!           p(f) = p(f) + 1
!           index_p1(i,f) = index_of(p(1),p(2),p(3))
!           p(f) = p(f) - 1
!        end
!     end
!     index_of.destroy
!!    n = nx.dim
!!    xy0.create(n)
!!    xz0.create(n)
!!    yz0.create(n)
!!    x0.create(n)
!!    y0.create(n)
!!    z0.create(n)
!!    n0.create(n)
!!    ixy = 0
!!    ixz = 0
!!    iyz = 0
!!    ix  = 0
!!    iy  = 0
!!    iz  = 0
!!    ii  = 0
!!    do i = 1,nx.dim
!!       if      (nx(i)==1 AND ny(i)==1) then; ixy = ixy + 1; xy0(ixy) = i
!!       else if (nx(i)==1 AND nz(i)==1) then; ixz = ixz + 1; xz0(ixz) = i
!!       else if (ny(i)==1 AND nz(i)==1) then; iyz = iyz + 1; yz0(iyz) = i
!!       else if (nx(i)==1) then;              ix  = ix  + 1;  x0(ix)  = i
!!       else if (ny(i)==1) then;              iy  = iy  + 1;  y0(iy)  = i
!!       else if (nz(i)==1) then;              iz  = iz  + 1;  z0(iz)  = i
!!       else;                                 ii  = ii  + 1;  n0(ii)  = i
!!       end
!!    end
!   end

! ************************************
! Normalization routines and functions
! ************************************

   normalise(ab)
   ! Multiply the matrix by the orbital normalisation coefficients
   ! for orbitals a and b.
     self :: IN
     ab :: MAT{REAL}, INOUT
     a,b,i :: INT
     if (.l_max<2) return
     i = 0
     do b = 1, .b.n_comp
     do a = 1, .a.n_comp
       i = i + 1
       ab(a,b)=ab(a,b)*.normalising_factors(i)
     end
     end
   end

   normalise(ab)
   ! Multiply the matrix by the orbital normalisation coefficients
   ! for orbitals a and b.
     self :: IN
     ab :: MAT4{REAL}, INOUT
     a,b,i :: INT
     if (.l_max<2) return
     i = 0
     do b = 1, .b.n_comp
     do a = 1, .a.n_comp
        i = i + 1
        ab(a,b,:,:)=ab(a,b,:,:)*.normalising_factors(i)
     end
     end
   end

   put
   ! Put the shell2 information on file "out"
     stdout.flush
     stdout.text("Shell a:"); .a.put
     stdout.flush
     stdout.text("Shell b:"); .b.put
     stdout.flush
     stdout.show("n_gaussian_pairs =",.n_gaussian_pairs)
     stdout.show("l_max            =",.l_max)
     stdout.show("l_min            =",.l_min)
     stdout.show("l_sum            =",.l_sum)
     stdout.show("first_gaussian   =",.first_gaussian)
     stdout.show("last_gaussian    =",.last_gaussian)
     stdout.show("n_gaussian       =",.n_gaussian)
     stdout.show("destroy_all      =",.destroy_all)
     stdout.show("same_center      =",.same_center)
     if (.exponent_sum.created) then
     stdout.text("exponent_sum:")
     stdout.put(.exponent_sum,"column")
     end
     if (.exponent_inv.created) then
     stdout.text("exponent_inv:")
     stdout.put(.exponent_inv,"column")
     end
     if (.cc_prefactor.created) then
     stdout.text("cc_prefactor:")
     stdout.put(.cc_prefactor,"column")
     end
     if (.cc_s_prefactor.created) then
     stdout.text("cc_s_prefactor:")
     stdout.put(.cc_s_prefactor,"column")
     end
     if (.cc_p_prefactor.created) then
     stdout.text("cc_p_prefactor:")
     stdout.put(.cc_p_prefactor,"column")
     end
     if (.normalising_factors.created) then
     stdout.text("normalising_factors:")
     stdout.put(.normalising_factors,"column")
     end
     if (.pair_center.created) then
     stdout.text("pair_center:")
     stdout.put(.pair_center)
     end
     if (.center_diff.created) then
     stdout.text("center_diff:")
     stdout.put(.center_diff)
     end
   end

end
