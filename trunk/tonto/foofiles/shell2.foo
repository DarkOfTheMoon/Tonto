!-------------------------------------------------------------------------------
!
! SHELL2 : pair of SHELLs
!
! Given two shells, can calculate
!  - Fourier transform of their product, evaluated on a grid
!  - overlap integrals
!  - kinetic energy integrals
!  - nuclear attraction integrals
!
! Based on the Rys method, as described by Lindh et al,
! J. Chem. Phys 84(7) 3963-3974
!
! - overlap (non rys version) and kinetic energy integrals work at least
!   up to (q|q).
! - methods using the rys module are limited up to about (m|m) due to
!   the general rys method algorithm failing.  (As tested with atoms on the
!   same center.  Different centers can go higher, but not recommended).
! - Accuracy at higher than (d|d) has not been tested.
!
! (c) Daniel Grimwood, 1998
!
! $Id$
!-------------------------------------------------------------------------------

module SHELL2

   use TYPES
   use SYSTEM
   use INT
   use VEC
   use IVEC
   use IMAT
   use IMAT3
   use MAT
   use MAT3
   use CMAT
   use CMAT3
   use OUTPUT
   use SHELL
   use SHELL1
   use RYS
   use GAUSSIAN2

   implicit none         

#include "macros"
#include "shell2.int"

! type shell2_type
!   SHELL1 :: a
!   SHELL1 :: b
! end

contains

  create [leaky]
  ! Creates a shell2 object
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SHELL2_SIZE)
    .nullify_ptr_part
  end

  create(shell_a,shell_b) [leaky]
  ! Create a copy of a shell1 objects
    PTR :: self
    SHELL1, IN :: shell_a,shell_b
    .create
    .copy(shell_a,shell_b)
  end

  create(shell_a,shell_b,pos_a,pos_b) [leaky]
  ! Create a copy of a shell1 objects with positions
    PTR :: self
    SHELL, IN :: shell_a,shell_b
    VEC(3), IN :: pos_a,pos_b
    .create
    .copy(shell_a,shell_b,pos_a,pos_b)
  end

  destroy [leaky]
  ! Destroys a shell2 object
    PTR :: self
    if (.destroyed) return
    .destroy_ptr_part
    DELETE_MEM(SHELL2_SIZE)
    deallocate(self)
  end

  nullify_ptr_part
  ! Nullify the pointer parts of self
     .a.nullify_ptr_part
     .b.nullify_ptr_part
  end

  destroy_ptr_part
  ! Destroy the pointer parts of self
     .a.destroy_ptr_part
     .b.destroy_ptr_part
  end

  created result(res)
  ! Returns true if self has been created
    PTR :: self
    BIN :: res
    res = associated(self)
  end

  destroyed result(res)
  ! Returns true if self has *not* been created
    PTR :: self
    BIN :: res
    res = NOT associated(self)
  end

  put(out)
  ! Put the shell2 information on file "out"
    OUTPUT :: out
    out.put("Shell a:",flush=1)
    .a.put(out)
    out.put("Shell b:",flush=1)
    .b.put(out)
    out.flush
  end

  copy(shell_a,shell_b) [leaky]
  ! Copy the shell2 using shell1 objects
    SHELL1, IN :: shell_a,shell_b
    .a.copy(shell_a)
    .b.copy(shell_b)
  end

  copy(shell_a,shell_b,pos_a,pos_b) [leaky]
  ! Copy the shell2 using shell objects and positions
    SHELL, IN :: shell_a,shell_b
    VEC, IN :: pos_a,pos_b
    .a.copy(shell_a,pos_a)
    .b.copy(shell_b,pos_b)
  end

  set(shell_a,shell_b)
  ! Set the shell2 using shell1 objects
    SHELL1, IN :: shell_a,shell_b
    .a.set(shell_a)
    .b.set(shell_b)
  end

  set(shell_a,shell_b,pos_a,pos_b)
  ! Copy the shell2 using shell objects
    SHELL, IN :: shell_a,shell_b
    VEC, IN :: pos_a,pos_b
    .a.set(shell_a,pos_a)
    .b.set(shell_b,pos_b)
  end

   make_ft(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a%n_comp,.b%n_comp].
      MAT, IN :: k_pts
      CMAT3, OUT :: res
      GAUSSIAN2 :: G_ab
      CMAT3, PTR :: ft_ab
      VEC, PTR :: fac_a,fac_b
      INT :: a,b,k,k_max
      DBL :: ca,cb,cacb
      BIN :: do_norm
      k_max  = size(k_pts,1)
      res = ZERO
      do_norm = (.a%l >1) AND (.b%l >1)
      G_ab.set(.a%l,.a%pos,ZERO,.b%l,.b%pos,ZERO)
      fac_a.create( .a%n_comp ); fac_a.normalizing_factors( .a%l )
      fac_b.create( .b%n_comp ); fac_b.normalizing_factors( .b%l )
      do a = 1, .a%n_cc
         G_ab.set(ex_a=.a%ex(a))
         ca = .a%cc(a)
         do b = 1, .b%n_cc
            G_ab.set(ex_b=.b%ex(b))
            cb = .b%cc(b)
            cacb = ca*cb
            ft_ab.create(k_max, .a%n_comp, .b%n_comp)
            G_ab.make_ft(ft_ab,k_pts)
            ft_ab = ft_ab*cacb
            if (do_norm) then
               do k = 1,k_max
                  ft_ab(k,:,:).change_basis(fac_a,fac_b)
               end
            end
            res = res + ft_ab
            ft_ab.destroy
         end
      end
      fac_a.destroy
      fac_b.destroy
   end

   make_ft(res,k_pts,thermal,dispersion,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a%n_comp,.b%n_comp].
   ! Also adds in some corrections, thermal and dispersion.
   ! Partition factors also included.
      CMAT3, OUT :: res
      MAT, IN :: k_pts,partition
      MAT3, PTR :: thermal
      CMAT, IN :: dispersion
      GAUSSIAN2 :: G_ab
      CMAT3, PTR :: ft_ab
      VEC, PTR :: fac_a,fac_b,therm
      INT :: a,b,k,k_max,i,j,n_comp_a,n_comp_b,aaa
      DBL :: ca,fac,tmp
      CMAT, PTR :: ft_ab_k
      CVEC, PTR :: ft_ab_ij
      MAT, PTR :: norm
      k_max  = size(k_pts,1)
      res = ZERO
      n_comp_a = .a%n_comp; n_comp_b = .b%n_comp
      G_ab.set(.a%l,.a%pos,ZERO,.b%l,.b%pos,ZERO)
      aaa = 0
      if (.a%l<2) aaa = aaa + 1
      if (.b%l<2) aaa = aaa + 2
      select case (aaa)
        case (0)
          norm.create(n_comp_a,n_comp_b)
          fac_a.create(n_comp_a); fac_a.normalizing_factors( .a%l )
          fac_b.create(n_comp_b); fac_b.normalizing_factors( .b%l )
          do a = 1, n_comp_a
            do b = 1, n_comp_b
              norm(a,b) = fac_a(a)*fac_b(b)
            end
          end
          fac_a.destroy
          fac_b.destroy
          ft_ab.create(k_max, .a%n_comp, .b%n_comp)
          do a = 1, .a%n_cc
             G_ab.set(ex_a=.a%ex(a))
             ca = .a%cc(a)
             do b = 1, .b%n_cc
                G_ab.set(ex_b=.b%ex(b))
                G_ab.make_ft(ft_ab,k_pts)
                ft_ab = ft_ab + dispersion(a,b)
                fac = ca * .b%cc(b) * partition(a,b)
                therm => thermal(:,a,b)
                do i=1,n_comp_a
                  do j=1,n_comp_b
                    tmp = fac * norm(i,j)
                    ft_ab_ij => ft_ab(:,i,j)
                    do k = 1,k_max
                      ft_ab_ij(k) = ft_ab_ij(k) * tmp * therm(k)
                    end
                  end
                end
                res = res + ft_ab
             end
          end
          ft_ab.destroy
          norm.destroy
        case (1)
          norm.create(n_comp_a,n_comp_b)
          fac_a.create(n_comp_a); fac_a.normalizing_factors( .a%l )
          ft_ab.create(k_max, .a%n_comp, .b%n_comp)
          do a = 1, .a%n_cc
             G_ab.set(ex_a=.a%ex(a))
             ca = .a%cc(a)
             do b = 1, .b%n_cc
                G_ab.set(ex_b=.b%ex(b))
                G_ab.make_ft(ft_ab,k_pts)
                ft_ab = ft_ab + dispersion(a,b)
                fac = ca * .b%cc(b) * partition(a,b)
                therm => thermal(:,a,b)
                do i=1,n_comp_a
                  tmp = fac * fac_a(i)
                  do j=1,n_comp_b
                    ft_ab_ij => ft_ab(:,i,j)
                    do k = 1,k_max
                      ft_ab_ij(k) = ft_ab_ij(k) * tmp * therm(k)
                    end
                  end
                end
                res = res + ft_ab
             end
          end
          ft_ab.destroy
          fac_a.destroy
        case (2)
          fac_b.create(n_comp_b); fac_b.normalizing_factors( .b%l )
          ft_ab.create(k_max, .a%n_comp, .b%n_comp)
          do a = 1, .a%n_cc
             G_ab.set(ex_a=.a%ex(a))
             ca = .a%cc(a)
             do b = 1, .b%n_cc
                G_ab.set(ex_b=.b%ex(b))
                G_ab.make_ft(ft_ab,k_pts)
                ft_ab = ft_ab + dispersion(a,b)
                fac = ca * .b%cc(b) * partition(a,b)
                therm => thermal(:,a,b)
                do j=1,n_comp_b
                  tmp = fac * fac_b(j)
                  do i=1,n_comp_a
                    ft_ab_ij => ft_ab(:,i,j)
                    do k = 1,k_max
                      ft_ab_ij(k) = ft_ab_ij(k) * tmp * therm(k)
                    end
                  end
                end
                res = res + ft_ab
             end
          end
          ft_ab.destroy
          fac_b.destroy
        case (3)
          ft_ab.create(k_max, .a%n_comp, .b%n_comp)
          do a = 1, .a%n_cc
             G_ab.set(ex_a=.a%ex(a))
             ca = .a%cc(a)
             do b = 1, .b%n_cc
                G_ab.set(ex_b=.b%ex(b))
                G_ab.make_ft(ft_ab,k_pts)
                ft_ab = ft_ab + dispersion(a,b)
                fac = ca * .b%cc(b) * partition(a,b)
                therm => thermal(:,a,b)
                do k = 1,k_max
                  ft_ab_k => ft_ab(k,:,:)
                  ft_ab_k = ft_ab_k * (fac * therm(k))
                end
                res = res + ft_ab
             end
          end
          ft_ab.destroy
          norm.destroy
      end
   end

  make_gaussian_partition(res,factor_a,factor_b)
  ! Make the factors for partitioning the density contribution from
  ! each atom.
  ! Dimensions of res are [.a%n_cc,.b%n_cc].
    MAT, OUT :: res
    DBL, IN :: factor_a,factor_b
    INT :: a,b
    DBL :: ex_a,ex_b,exa_fa
    do a = 1, .a%n_cc
      ex_a = .a%ex(a)
      exa_fa = ex_a * factor_a
      do b = 1, .b%n_cc
        ex_b = .b%ex(b)
        res(a,b) = (exa_fa + ex_b * factor_b) / (ex_a + ex_b)
      end
    end
  end

  make_gaussian_partition(res,factor_a,factor_b)
  ! Make the factors for partitioning the density contribution from
  ! each atom.
  ! Dimensions of res are [.a%n_cc,.b%n_cc].
    CMAT, OUT :: res
    CDBL, IN :: factor_a,factor_b
    INT :: a,b
    DBL :: ex_a,ex_b,exa_fa
    do a = 1, .a%n_cc
      ex_a = .a%ex(a)
      exa_fa = ex_a * factor_a
      do b = 1, .b%n_cc
        ex_b = .b%ex(b)
        res(a,b) = (exa_fa + ex_b * factor_b) / (ex_a + ex_b)
      end
    end
  end

  make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)
  ! Make the thermal smearing correction according to Tanaka.
  ! Dimensions of "res" are [k_max,.a%n_cc,.b%n_cc].
  ! "res" contains the correction for each pair of primitives.
    MAT3, OUT :: res
    MAT, IN :: k_pts,Ua,Ub
    MAT(3,3) :: Ua_ea,Ub_eb,U
    VEC(3) :: S,Utemp
    INT :: a,b,k,k_max
    DBL :: ea,eb
    k_max  = size(k_pts,1)
    do a = 1, .a%n_cc
      ea = .a%ex(a)
      Ua_ea = ea * Ua
      do b = 1, .b%n_cc
        eb = .b%ex(b)
        Ub_eb = eb * Ub
        U = (Ua_ea + Ub_eb) / (ea + eb)
        do k = 1,k_max
          S = k_pts(k,:)
          Utemp = matmul(U,S)         ! Change coordinates of the U matrix.
          res(k,a,b) = exp(-HALF*dot_product(S,Utemp))
        end
      end
    end
  end

   make_ft_nabla(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      MAT, IN :: k_pts
      CMAT4 :: res
      GAUSSIAN2 :: G_ab
      CMAT4, PTR :: ft_ab
      VEC, PTR :: fac_a,fac_b
      INT :: a,b,k,k_max
      DBL :: ca,cb,cacb
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a%l,.a%pos,ZERO,.b%l,.b%pos,ZERO)
      fac_a.create( .a%n_comp ); fac_a.normalizing_factors( .a%l )
      fac_b.create( .b%n_comp ); fac_b.normalizing_factors( .b%l )
      do a = 1, .a%n_cc
         G_ab.set(ex_a=.a%ex(a))
         ca = .a%cc(a)
         do b = 1, .b%n_cc
            G_ab.set(ex_b=.b%ex(b))
            cb = .b%cc(b)
            cacb = ca*cb
            ft_ab.create(k_max,.a%n_comp,.b%n_comp,3)
            G_ab.make_ft_nabla(ft_ab,k_pts)
            ft_ab = ft_ab*cacb
            if (.a%l>=2 OR .b%l>=2) then
            do k = 1,k_max
               ft_ab(k,:,:,1).change_basis(fac_a,fac_b)
               ft_ab(k,:,:,2).change_basis(fac_a,fac_b)
               ft_ab(k,:,:,3).change_basis(fac_a,fac_b)
            end
            end
            res = res + ft_ab
            ft_ab.destroy
         end
      end
      fac_a.destroy
      fac_b.destroy
   end

   make_ft_r(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      MAT, IN :: k_pts
      CMAT4 :: res
      GAUSSIAN2 :: G_ab
      CMAT4, PTR :: ft_ab
      VEC, PTR :: fac_a,fac_b
      INT :: a,b,k,k_max
      DBL :: ca,cb,cacb
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a%l,.a%pos,ZERO,.b%l,.b%pos,ZERO)
      fac_a.create( .a%n_comp ); fac_a.normalizing_factors( .a%l )
      fac_b.create( .b%n_comp ); fac_b.normalizing_factors( .b%l )
      do a = 1, .a%n_cc
         G_ab.set(ex_a=.a%ex(a))
         ca = .a%cc(a)
         do b = 1, .b%n_cc
            G_ab.set(ex_b=.b%ex(b))
            cb = .b%cc(b)
            cacb = ca*cb
            ft_ab.create(k_max,.a%n_comp,.b%n_comp,3)
            G_ab.make_ft_r(ft_ab,k_pts)
            ft_ab = ft_ab*cacb
            if (.a%l>=2 OR .b%l>=2) then
            do k = 1,k_max
               ft_ab(k,:,:,1).change_basis(fac_a,fac_b)
               ft_ab(k,:,:,2).change_basis(fac_a,fac_b)
               ft_ab(k,:,:,3).change_basis(fac_a,fac_b)
            end
            end
            res = res + ft_ab
            ft_ab.destroy
         end
      end
      fac_a.destroy
      fac_b.destroy
   end

!  *********************************
!  Simplistic CADPAC-style integrals
!  *********************************

   make_overlap_ints(S)
   ! Calculates overlap integral matrix, using Gauss-Hermite quadrature, like in CADPAC
      MAT :: S
      MAT, PTR :: SS
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      S = ZERO
      SS.create(.a%n_comp,.b%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_overlap_ints(SS)
         cacb = .a%cc(a)*.b%cc(b)
         S = S + SS*cacb
      end
      end
      SS.destroy
      .normalize(S)
   end

   make_dipole_ints(Dx,Dy,Dz,origin)
   ! Make the dipole moment integral matrices "Di" 
   ! with gauge origin "origin"
      MAT :: Dx,Dy,Dz
      VEC(3) :: origin
      MAT, PTR :: DDx,DDy,DDz
      GAUSSIAN2 :: G
      INT :: a,b,n_a,n_b
      DBL :: cacb
      Dx = ZERO; Dy = ZERO; Dz = ZERO
      n_a = .a%n_comp; n_b = .b%n_comp
      DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_dipole_ints(DDx,DDy,DDz,origin)
         cacb = .a%cc(a)*.b%cc(b)
         Dx = Dx + DDx*cacb; Dy = Dy + DDy*cacb; Dz = Dz + DDz*cacb
      end
      end
      DDz.destroy; DDy.destroy; DDx.destroy
      .normalize(Dx); .normalize(Dy); .normalize(Dz)
   end

   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin)
   ! Make the quadrupole moment integral matrices "Qij" 
   ! with gauge origin "origin"
      MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
      VEC(3) :: origin
      MAT, PTR :: QQxx,QQyy,QQzz,QQxy,QQxz,QQyz
      GAUSSIAN2 :: G
      INT :: a,b,n_a,n_b
      DBL :: cacb
      Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
      Qxy = ZERO; Qxz = ZERO; Qyz = ZERO
      n_a = .a%n_comp; n_b = .b%n_comp
      QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz,origin)
         cacb = .a%cc(a)*.b%cc(b)
         Qxx = Qxx + QQxx*cacb; Qyy = Qyy + QQyy*cacb; Qzz = Qzz + QQzz*cacb
         Qxy = Qxy + QQxy*cacb; Qxz = Qxz + QQxz*cacb; Qyz = Qyz + QQyz*cacb
      end
      end
      QQyz.destroy; QQxz.destroy; QQxy.destroy
      QQzz.destroy; QQyy.destroy; QQxx.destroy
      .normalize(Qxx); .normalize(Qyy); .normalize(Qzz)
      .normalize(Qxy); .normalize(Qxz); .normalize(Qyz)
   end

   make_nuclear_attraction_ints(N,c)
   ! Make the nuclear attraction integral matrix "N" for nucleus at position "c"
      MAT :: N
      VEC(3) :: c
      MAT, PTR :: NN
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      N = ZERO
      NN.create(.a%n_comp,.b%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_nuclear_attraction_ints(NN,c)
         cacb = .a%cc(a)*.b%cc(b)
         N = N + NN*cacb
      end
      end
      NN.destroy
      .normalize(N)
   end

   make_spin_orbit_ints(Lx,Ly,Lz,c,debug)
   ! Make the spin orbit integral matrices "Lx" "Ly" and "Lz" for nucleus at position "c"
      MAT :: Lx,Ly,Lz
      VEC(3) :: c
      BIN, optional :: debug
      MAT, PTR :: LLx,LLy,LLz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Lx = ZERO; Ly = ZERO; Lz = ZERO
      LLx.create(.a%n_comp,.b%n_comp)
      LLy.create(.a%n_comp,.b%n_comp)
      LLz.create(.a%n_comp,.b%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_spin_orbit_ints(LLx,LLy,LLz,c,FALSE)
         cacb = .a%cc(a)*.b%cc(b)
         Lx = Lx + LLx*cacb
         Ly = Ly + LLy*cacb
         Lz = Lz + LLz*cacb
      end
      end
      LLz.destroy; LLy.destroy; LLx.destroy
      .normalize(Lx); .normalize(Ly); .normalize(Lz)
   end

   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)
   ! Make the gauge modified (B field) spin orbit integral matrices "Qij" 
   ! for nucleus at position "c" and gauge origin "origin"
      MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
      VEC(3) :: c,origin
      MAT, PTR :: QQxx,QQxy,QQxz,QQyx,QQyy,QQyz,QQzx,QQzy,QQzz
      GAUSSIAN2 :: G
      INT :: a,b,n_a,n_b
      DBL :: cacb
      Qxx = ZERO; Qyx = ZERO; Qzx = ZERO
      Qxy = ZERO; Qyy = ZERO; Qzy = ZERO
      Qxz = ZERO; Qyz = ZERO; Qzz = ZERO
      n_a = .a%n_comp; n_b = .b%n_comp
      QQxx.create(n_a,n_b); QQyx.create(n_a,n_b); QQzx.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQyy.create(n_a,n_b); QQzy.create(n_a,n_b)
      QQxz.create(n_a,n_b); QQyz.create(n_a,n_b); QQzz.create(n_a,n_b)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_spin_orbit_B_ints(QQxx,QQxy,QQxz,QQyx,QQyy,QQyz,QQzx,QQzy,QQzz,c,origin)
         cacb = .a%cc(a)*.b%cc(b)
         Qxx = Qxx + QQxx*cacb; Qxy = Qxy + QQxy*cacb; Qxz = Qxz + QQxz*cacb
         Qyx = Qyx + QQyx*cacb; Qyy = Qyy + QQyy*cacb; Qyz = Qyz + QQyz*cacb
         Qzx = Qzx + QQzx*cacb; Qzy = Qzy + QQzy*cacb; Qzz = Qzz + QQzz*cacb
      end
      end
      QQzz.destroy; QQyz.destroy; QQxz.destroy
      QQzy.destroy; QQyy.destroy; QQxy.destroy
      QQzx.destroy; QQyx.destroy; QQxx.destroy
      .normalize(Qxx); .normalize(Qxy); .normalize(Qxz)
      .normalize(Qyx); .normalize(Qyy); .normalize(Qyz)
      .normalize(Qzx); .normalize(Qzy); .normalize(Qzz)
   end

   make_L_ints(Lx,Ly,Lz,origin)
   ! Calculate the angular momentum integral matrices "Lx", "Ly", "Lz", 
   ! with "origin" as gauge origin, using Gauss-Hermite quadrature
      MAT :: Lx,Ly,Lz
      VEC(3) :: origin
      MAT, PTR :: LLx,LLy,LLz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Lx = ZERO; Ly = ZERO; Lz = ZERO
      LLx.create(.a%n_comp,.b%n_comp)
      LLy.create(.a%n_comp,.b%n_comp)
      LLz.create(.a%n_comp,.b%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_L_ints(LLx,LLy,LLz,origin)
         cacb = .a%cc(a)*.b%cc(b)
         Lx = Lx + LLx*cacb
         Ly = Ly + LLy*cacb
         Lz = Lz + LLz*cacb
      end
      end
      LLz.destroy; LLy.destroy; LLx.destroy
      .normalize(Lx); .normalize(Ly); .normalize(Lz)
   end

   make_solenoidal_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal "Ji" integral matrices evaluated at position "c"
      MAT :: Jx,Jy,Jz
      VEC(3) :: c
      MAT, PTR :: Ix,Iy,Iz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a%n_comp,.b%n_comp)
      Iy.create(.a%n_comp,.b%n_comp)
      Iz.create(.a%n_comp,.b%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_solenoidal_jp_ints(Ix,Iy,Iz,c)
         cacb = .a%cc(a)*.b%cc(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
      .normalize(Jx); .normalize(Jy); .normalize(Jz)
   end

   make_irrotational_jp_ints(Jx,Jy,Jz,c)
   ! Make the irrotational "Ji" integral matrices evaluated at position "c"
      MAT :: Jx,Jy,Jz
      VEC(3) :: c
      MAT, PTR :: Ix,Iy,Iz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a%n_comp,.b%n_comp)
      Iy.create(.a%n_comp,.b%n_comp)
      Iz.create(.a%n_comp,.b%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l
      G%pos_a = .a%pos; G%pos_b = .b%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G.make_irrotational_jp_ints(Ix,Iy,Iz,c)
         cacb = .a%cc(a)*.b%cc(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
      .normalize(Jx); .normalize(Jy); .normalize(Jz)
   end

!  ******************************
!  Roland Lindh's style integrals
!  ******************************

  s_overlap(zeta,zz,r2) result (res) [elemental]
  ! Calculate the overlap of two s functions.
    IN :: self
    DBL, IN :: zeta,zz,r2
    DBL :: res
    res=(PI/zeta)**(3.0/2.0) * exp(-zz*r2)
  end

  make_overlap(ab)
  ! Calculate the overlap matrix for the two shells
    MAT :: ab
    VEC, PTR :: es
    INT :: n
    n = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    es.create(n)
    .make_overlap_es(es)
    .transfer(es,ab)
    es.destroy
    .to_normalize(ab)
  end

  make_overlap_es(es)
  ! Make the (es) overlap integrals, summed over primitives
    IN :: self
    VEC, OUT :: es
    VEC, PTR :: temp
    VEC(3) :: AB
    INT :: a,b,templb,tempub,n_e
    DBL :: r2ab,ea,eb

    n_e    = .a%l + .b%l
    tempub = n_e.n_comp_sum
    templb = (max(.a%l,.b%l)-1).n_comp_sum + 1
    temp.create(tempub)

    AB = .a%pos - .b%pos
    r2ab = dot_product(AB,AB)

    es=ZERO
    do a=1, .a%n_cc
      ea=.a%ex(a)
      do b=1, .b%n_cc
        eb=.b%ex(b)
        .form_overlap_es(temp,ea,eb,r2ab,n_e)
        es=es + .a%cc(a) * .b%cc(b) * temp(templb:tempub)
      end
    end
    temp.destroy
  end

  form_overlap_es(es,ea,eb,r2ab,n_e)
  ! Form the (es) overlap integrals for a pair of primitives
    IN :: self
    VEC, INOUT :: es
    INT, IN :: n_e
    DBL, IN :: r2ab,ea,eb
    VEC(3) :: PE
    IVEC(3) :: a_momenta
    IMAT3, PTR :: index
    IMAT, PTR :: momenta
    DBL :: zinv2,zeta,zz,PEi
    INT :: j,z,lz,a1,a2,tmp

    zeta=ea+eb
    zz=ea*eb/zeta

    es=ZERO
    es(1)=.s_overlap(zeta,zz,r2ab)

    if (n_e > 0) then
      zinv2=HALF/zeta
      if (.a%l > .b%l) then
        PE=(eb*.b%pos + ea*.a%pos)*TWO*zinv2 - .a%pos
      else
        PE=(eb*.b%pos + ea*.a%pos)*TWO*zinv2 - .b%pos
      end

      es(2) = PE(1) * es(1)                                ! p||s
      es(3) = PE(2) * es(1)
      es(4) = PE(3) * es(1)

      if (n_e > 1) then
        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        do j=5, n_e.n_comp_sum                               ! d||s to n_e||s
          a_momenta = momenta(:,j)
          z = a_momenta.first_nonzero_component
          lz = a_momenta(z)
          a_momenta(z) = a_momenta(z)-1
          a1 = index(a_momenta(1),a_momenta(2),a_momenta(3))
          PEi=PE(z)
          if (lz < 2) then
            es(j) = PEi * es(a1)
          else
            a_momenta(z) = a_momenta(z)-1
            a2 = index(a_momenta(1),a_momenta(2),a_momenta(3))
            es(j) = PEi * es(a1) + zinv2 * (lz-1) * es(a2)
          end
        end
        index.destroy
        momenta.destroy
      end
    end
  end

  get_kei(kei,overlap)
  ! Calculate the kinetic energy and overlap (optional) integrals.
  ! (More efficient than making them separate).
    IN :: self
    MAT, INOUT :: kei
    MAT, INOUT, optional :: overlap

    .make_kei(kei,overlap)
    if (present(overlap)) .to_normalize(overlap)
    .to_normalize(kei)
  end

  make_kei(kei,overlap)
  ! Makes the kei and overlap matrics, summed over primitives
  ! Is called by kei, but does not do the orbital normalization corrections
    IN :: self
    MAT, INOUT :: kei
    MAT, INOUT, optional :: overlap
    MAT, PTR :: temp_kei,temp_overlap
    VEC(3) :: P,PA,PB,ara,brb,AB
    INT :: a,b,alb,aub,blb,bub
    DBL :: ca,ea,eb,zeta,zinv2,r2ab
    alb = (.a%l-1).n_comp_sum + 1; aub = alb + .a%n_comp -1
    blb = (.b%l-1).n_comp_sum + 1; bub = blb + .b%n_comp -1
    temp_kei.create(aub,bub)
    temp_overlap.create(aub,bub)
    kei=ZERO
    if (present(overlap)) overlap=ZERO
    AB = .a%pos - .b%pos
    r2ab = dot_product(AB,AB)
    do a=1, .a%n_cc
      ca=.a%cc(a)
      ea=.a%ex(a)
      ara=ea*.a%pos
      do b=1, .b%n_cc
        eb    = .b%ex(b)
        brb   = eb * .b%pos
        zeta  = ea + eb
        zinv2 = HALF / zeta
        P     = (ara + brb) * TWO * zinv2
        PA    = P - .a%pos
        PB    = P - .b%pos
        if (.a%l > .b%l) then
          .form_overlap_mat_a(temp_kei,temp_overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
        else
          .form_overlap_mat_b(temp_kei,temp_overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
        end
        if (present(overlap)) &
          overlap = overlap + ca * .b%cc(b) * temp_overlap(alb:aub,blb:bub)
        kei = kei + ca * .b%cc(b) * temp_kei(alb:aub,blb:bub)
      end
    end
    temp_kei.destroy
    temp_overlap.destroy
  end

  form_overlap_mat_a(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
  ! Makes the kinetic energy and overlap matrices for a primitive pair
  ! if .a%l > .b%l
    IN :: self
    MAT, INOUT :: overlap,kei
    VEC(3), IN :: PA,PB
    IVEC(3) :: a_momenta, b_momenta
    IMAT3, PTR :: index
    IMAT, PTR :: momenta
    DBL, IN :: zinv2,zeta,ea,eb,r2ab
    INT :: j,z,lza,lzb,a,a1,a2,b,b1,laub
    INT :: la,lb,la1_n_comp_sum,lb1_n_comp_sum,la_n_comp_sum,lb_n_comp_sum
    INT :: na,b_n_comp_sum,tmp
    DBL :: PAi,PBi,zz,zz2,zinv2_na,zinv2_nb,zz_ea,zz_eb,zz_ea_na

    zz       = ea * eb / zeta
    zz2      = 2 * zz
    zz_ea    = zz / ea
    zz_eb    = zz / eb
    b_n_comp_sum = .b%l.n_comp_sum

    overlap(1,1) = .s_overlap(zeta,zz,r2ab)
    kei(1,1)     = zz * (3.0-zz2 * r2ab) * overlap(1,1)

    momenta.create(3, .a%l.n_comp_sum)
    tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.a%l)
    index.create(0,.a%l, 0,.a%l, 0,.a%l)
    index.make_index_of_components(momenta)

    do j = 2, b_n_comp_sum                                ! s||p to s||lb
      a_momenta    = momenta(:,j)                         ! p||s to lb||s
      z            = a_momenta.first_nonzero_component
      lza          = a_momenta(z)
      a_momenta(z) = a_momenta(z) - 1
      a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
      PBi          = PB(z)
      PAi          = PA(z)
      if (lza < 2) then
        overlap(1,j) = PBi * overlap(1,a1)
        kei(1,j)     = PBi * kei(1,a1) + zz2 * overlap(1,j)
        overlap(j,1) = PAi * overlap(a1,1)
        kei(j,1)     = PAi * kei(a1,1) + zz2 * overlap(j,1)
      else
        na           = lza - 1
        zinv2_na     = zinv2 * na
        a_momenta(z) = a_momenta(z) - 1
        a2           = index(a_momenta(1),a_momenta(2),a_momenta(3))
        overlap(1,j) = PBi * overlap(1,a1) + zinv2_na * overlap(1,a2)
        kei(1,j)     = PBi * kei(1,a1) + zinv2_na * kei(1,a2) + &
                       zz2 * overlap(1,j) - zz_eb * na * overlap(1,a2)
        overlap(j,1) = PAi * overlap(a1,1) + zinv2_na * overlap(a2,1)
        kei(j,1)     = PAi * kei(a1,1) + zinv2_na * kei(a2,1) + &
                       zz2 * overlap(j,1) - zz_ea * na * overlap(a2,1)
      end
    end

    do j = b_n_comp_sum + 1, (.a%l-.b%l).n_comp_sum   ! lb||s to la-lb||s
      a_momenta    = momenta(:,j)
      z            = a_momenta.first_nonzero_component
      lza          = a_momenta(z)
      a_momenta(z) = a_momenta(z) - 1
      a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
      PAi          = PA(z)
      if (lza < 2) then
        overlap(j,1) = PAi * overlap(a1,1)
        kei(j,1)     = PAi * kei(a1,1) + zz2 * overlap(j,1)
      else
        na           = lza - 1
        zinv2_na     = zinv2 * na
        a_momenta(z) = a_momenta(z) - 1
        a2           = index(a_momenta(1),a_momenta(2),a_momenta(3))
        overlap(j,1) = PAi * overlap(a1,1) + zinv2_na * overlap(a2,1)
        kei(j,1)     = PAi * kei(a1,1) + zinv2_na * kei(a2,1) + &
                       zz2 * overlap(j,1) - zz_ea * na * overlap(a2,1)
      end
    end

    laub = .a%l - .b%l
    do lb = 1, .b%l
      lb1_n_comp_sum = (lb-1).n_comp_sum + 1
      lb_n_comp_sum  = lb.n_comp_sum
      laub           = laub + 1
      do la = 1, laub
        la1_n_comp_sum = (la-1).n_comp_sum + 1
        la_n_comp_sum  = la.n_comp_sum
        do a = la1_n_comp_sum, la_n_comp_sum
          a_momenta    = momenta(:,a)
          z            = a_momenta.first_nonzero_component
          lza          = a_momenta(z)
          a_momenta(z) = a_momenta(z) - 1
          a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
          PAi          = PA(z)
          if (lza==1) then
            do b = lb1_n_comp_sum,lb_n_comp_sum
              lzb = momenta(z,b)
              if (lzb==0) then
                overlap(a,b) = PAi * overlap(a1,b)
                kei(a,b)     = PAi * kei(a1,b) + zz2 * overlap(a,b)
              else
                b_momenta    = momenta(:,b)
                b_momenta(z) = b_momenta(z) - 1
                b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
                zinv2_nb     = zinv2 * lzb
                overlap(a,b) = PAi * overlap(a1,b) + zinv2_nb * overlap(a1,b1)
                kei(a,b)     = PAi * kei(a1,b) + zinv2_nb * kei(a1,b1) + &
                               zz2 * overlap(a,b)
              end
            end
          else
            na           = lza - 1
            zinv2_na     = zinv2 * na
            zz_ea_na    = zz_ea * na
            a_momenta(z) = a_momenta(z) - 1
            a2           = index(a_momenta(1),a_momenta(2),a_momenta(3))
            do b = lb1_n_comp_sum, lb_n_comp_sum
              lzb = momenta(z,b)
              if (lzb==0) then
                overlap(a,b) = PAi * overlap(a1,b) + zinv2_na * overlap(a2,b)
                kei(a,b)     = PAi * kei(a1,b) + zinv2_na * kei(a2,b) + &
                               zz2 * overlap(a,b) - zz_ea_na * overlap(a2,b)
              else
                zinv2_nb     = zinv2 * lzb
                b_momenta    = momenta(:,b)
                b_momenta(z) = b_momenta(z) - 1
                b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
                overlap(a,b) = PAi * overlap(a1,b) + zinv2_na * overlap(a2,b) +&
                               zinv2_nb * overlap(a1,b1)
                kei(a,b)     = PAi * kei(a1,b) + zinv2_na * kei(a2,b) + &
                               zinv2_nb * kei(a1,b1) + &
                               zz2 * overlap(a,b) - zz_ea_na * overlap(a2,b)
              end
            end
          end
        end
      end
    end
    momenta.destroy
    index.destroy
  end

  form_overlap_mat_b(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
  ! Makes the kinetic energy and overlap matrices for a primitive pair
  ! if .b%l > .a%l
    IN :: self
    MAT, INOUT :: overlap,kei
    VEC(3), IN :: PA,PB
    IVEC(3) :: b_momenta, a_momenta
    IMAT3, PTR :: index
    IMAT, PTR :: momenta
    DBL, IN :: zinv2,zeta,ea,eb,r2ab
    INT :: j,z,lza,lzb,a,a1,b,b1,b2,lbub,la,lb
    INT :: la1_n_comp_sum,lb1_n_comp_sum,la_n_comp_sum,lb_n_comp_sum
    INT :: nb,a_n_comp_sum,tmp
    DBL :: PAi,PBi,zz,zz2,zinv2_na,zinv2_nb,zz_ea,zz_eb,zz_eb_nb

    zz      = ea * eb / zeta
    zz2     = 2 * zz
    zz_ea    = zz / ea
    zz_eb    = zz / eb
    a_n_comp_sum  = .a%l.n_comp_sum

    overlap(1,1) = .s_overlap(zeta,zz,r2ab)
    kei(1,1)     = zz * (3.0-zz2 * r2ab) * overlap(1,1)

    momenta.create(3, .b%l.n_comp_sum)
    tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.b%l)
    index.create(0,.b%l, 0,.b%l, 0,.b%l)
    index.make_index_of_components(momenta)

    do j=2, a_n_comp_sum                               ! p||s to la||s
      b_momenta    = momenta(:,j)                      ! s||p to s||la
      z            = b_momenta.first_nonzero_component
      lzb          = b_momenta(z)
      b_momenta(z) = b_momenta(z)-1
      b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
      PBi          = PB(z)
      PAi          = PA(z)
      if (lzb < 2) then
        overlap(j,1) = PAi * overlap(b1,1)
        kei(j,1)     = PAi * kei(b1,1) + zz2 * overlap(j,1)
        overlap(1,j) = PBi * overlap(1,b1)
        kei(1,j)     = PBi * kei(1,b1) + zz2 * overlap(1,j)
      else
        nb           = lzb - 1
        zinv2_nb     = zinv2 * nb
        b_momenta(z) = b_momenta(z) - 1
        b2           = index(b_momenta(1),b_momenta(2),b_momenta(3))
        overlap(j,1) = PAi * overlap(b1,1) + zinv2_nb * overlap(b2,1)
        kei(j,1)     = PAi * kei(b1,1) + zinv2_nb * kei(b2,1) + &
                       zz2 * overlap(j,1) - zz_ea * nb * overlap(b2,1)
        overlap(1,j) = PBi * overlap(1,b1) + zinv2_nb * overlap(1,b2)
        kei(1,j)     = PBi * kei(1,b1) + zinv2_nb * kei(1,b2) + &
                       zz2 * overlap(1,j) - zz_eb * nb * overlap(1,b2)
      end
    end

    do j= a_n_comp_sum + 1, (.b%l-.a%l).n_comp_sum      ! s||lb to s||lb-la
      b_momenta    = momenta(:,j)                       ! s||p to s||la
      z            = b_momenta.first_nonzero_component
      lzb          = b_momenta(z)
      b_momenta(z) = b_momenta(z) - 1
      b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
      PBi          = PB(z)
      if (lzb < 2) then
        overlap(1,j) = PBi * overlap(1,b1)
        kei(1,j)     = PBi * kei(1,b1) + zz2 * overlap(1,j)
      else
        nb           = lzb - 1
        zinv2_nb     = zinv2 * nb
        b_momenta(z) = b_momenta(z) - 1
        b2           = index(b_momenta(1),b_momenta(2),b_momenta(3))
        overlap(1,j) = PBi * overlap(1,b1) + zinv2_nb * overlap(1,b2)
        kei(1,j)     = PBi * kei(1,b1) + zinv2_nb * kei(1,b2) + &
                       zz2 * overlap(1,j) - zz_eb * nb * overlap(1,b2)
      end
    end

    lbub = .b%l - .a%l
    do la = 1, .a%l
      la1_n_comp_sum = (la-1).n_comp_sum + 1
      la_n_comp_sum  = la.n_comp_sum
      lbub           = lbub + 1
      do lb = 1, lbub
        lb1_n_comp_sum = (lb-1).n_comp_sum+1
        lb_n_comp_sum  = lb.n_comp_sum
        do b = lb1_n_comp_sum, lb_n_comp_sum
          b_momenta    = momenta(:,b)
          z            = b_momenta.first_nonzero_component
          lzb          = b_momenta(z)
          b_momenta(z) = b_momenta(z) - 1
          b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
          PBi          = PB(z)
          if (lzb == 1) then
            do a = la1_n_comp_sum, la_n_comp_sum
              lza = momenta(z,a)
              if (lza == 0) then
                overlap(a,b) = PBi * overlap(a,b1)
                kei(a,b)     = PBi * kei(a,b1) + zz2 * overlap(a,b)
              else
                a_momenta    = momenta(:,a)
                a_momenta(z) = a_momenta(z) - 1
                a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
                zinv2_na     = zinv2 * lza
                overlap(a,b) = PBi * overlap(a,b1) + zinv2_na * overlap(a1,b1)
                kei(a,b)     = PBi * kei(a,b1) + zinv2_na * kei(a1,b1) + &
                               zz2 * overlap(a,b)
              end
            end
          else
            nb           = lzb - 1
            zinv2_nb     = zinv2 * nb
            zz_eb_nb     = zz_eb * nb
            b_momenta(z) = b_momenta(z) - 1
            b2           = index(b_momenta(1),b_momenta(2),b_momenta(3))
            do a = la1_n_comp_sum, la_n_comp_sum
              lza = momenta(z,a)
              if (lza==0) then
                overlap(a,b) = PBi * overlap(a,b1) + zinv2_nb * overlap(a,b2)
                kei(a,b)     = PBi * kei(a,b1) + zinv2_nb * kei(a,b2)+ &
                               zz2 * overlap(a,b) - zz_eb_nb * overlap(a,b2)
              else
                zinv2_na     = zinv2 * lza
                a_momenta    = momenta(:,a)
                a_momenta(z) = a_momenta(z) - 1
                a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
                overlap(a,b) = PBi * overlap(a,b1) + zinv2_nb * overlap(a,b2) +&
                               zinv2_na * overlap(a1,b1)
                kei(a,b)     = PBi * kei(a,b1) + zinv2_nb * kei(a,b2) + &
                               zinv2_na * kei(a1,b1) + &
                               zz2 * overlap(a,b) - zz_eb_nb * overlap(a,b2)
              end
            end
          end
        end
      end
    end
    momenta.destroy
    index.destroy
  end

  get_nuc(ab,mass_c,pos_c)
  ! Calculate the nuclear attraction matrix for the two shells with the
  ! nucleus at c.
    IN :: self
    MAT, OUT :: ab
    DBL, IN :: mass_c
    VEC(3), IN :: pos_c
    VEC, PTR :: es
    INT :: n
    n = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    es.create(n)
    .make_nuc_es(es,mass_c,pos_c)
    .transfer(es,ab)
    es.destroy
    .to_normalize(ab)
  end

  make_nuc_es(es,mass_c,pos_c)
  ! Make the (es) nuclear attraction integrals, summed over primitives
  ! Numbers may be slightly different to cadpac due to a relativistic correction
  ! term.
    IN :: self
    VEC, OUT :: es
    DBL, IN :: mass_c
    VEC(3), IN :: pos_c
    VEC, PTR :: esadd
    MAT, PTR :: Ix,Iy,Iz
    RYS, PTR :: rysa
    VEC, PTR :: rzt,ce
    IMAT, PTR :: momenta
    VEC(3) :: P,PA,PB,QP,ara,AB
    DBL :: QP2,a,b,zeta,zinv,kab,rho,xx,eta_c
    INT :: ag,bg,e,eub,nroots,n_e
    DBL :: norma,normb,norm,r2ab

    eub  = size(es)
    n_e  = .a%l + .b%l
    AB   = .a%pos - .b%pos
    r2ab = dot_product(AB,AB)

    if (mass_c < TOL(15)) then
      eta_c=1.0d30  ! Very big.
    else
      eta_c=3880000000d0*(mass_c**(-TWOTHIRDS))
    end
   eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.
    esadd.create(eub)
    es=ZERO
    nroots=(n_e+2)/2
    rysa.create(nroots)
    Ix.create(nroots,n_e+1)
    Iy.create(nroots,n_e+1)
    Iz.create(nroots,n_e+1)
    rzt.create(nroots)
    ce.create(nroots)

    momenta.create(3, eub)
    max(.a%l,.b%l).make_gaussian_xyz_powers(momenta,n_e)
    momenta = momenta + 1

    norm=TWO*PI
    do ag = 1, .a%n_cc
      a     = .a%ex(ag)
      norma = norm * .a%cc(ag)
      ara   = a * .a%pos
      do bg = 1, .b%n_cc
        b     = .b%ex(bg)
        zeta  = a + b
        zinv  = ONE / zeta
        kab   = exp(-a * b * r2ab * zinv)
        rho   = zeta * eta_c / (zeta + eta_c)
        P     = (ara + b * .b%pos) * zinv
        PA    = P - .a%pos
        PB    = P - .b%pos
        QP    = pos_c - P
        QP2   = dot_product(QP,QP)
        normb = norma * .b%cc(bg) * sqrt(rho*zinv) * kab * zinv
        xx    = rho * QP2
        rysa.get_weights(xx)
        .nuc_form_2d_ints(Ix,Iy,Iz,rysa%r,rho,zinv,PA,PB,QP,rzt,ce,n_e)
        do e=1,eub
          esadd(e) = sum(Ix(:,momenta(1,e)) * Iy(:,momenta(2,e)) * &
                                      Iz(:,momenta(3,e)) * rysa%w)
        end
        es=es+normb*esadd
      end
    end
    momenta.destroy
    Ix.destroy
    Iy.destroy
    Iz.destroy
    rysa.destroy
    esadd.destroy
    rzt.destroy
    ce.destroy
  end

  nuc_form_2d_ints(Ix,Iy,Iz,t2,rho,zinv,PA,PB,QP,rzt,ce,n_e) [pure]
  ! Forms the two dimentional integrals
    IN :: self
    MAT, INOUT :: Ix,Iy,Iz
    VEC, IN :: t2
    DBL, IN :: rho,zinv
    INT, IN :: n_e
    VEC(3), IN :: PA,PB,QP
    VEC, INOUT :: rzt,ce
    INT :: e,e1,ep1
    Ix(:,1) = ONE
    Iy(:,1) = ONE
    Iz(:,1) = ONE
    if (n_e/=0) then
       rzt = rho*t2*zinv
       if (.a%l > .b%l) then
         Ix(:,2)=PA(1)+rzt(:)*QP(1)
         Iy(:,2)=PA(2)+rzt(:)*QP(2)
         Iz(:,2)=PA(3)+rzt(:)*QP(3)
       else
         Ix(:,2)=PB(1)+rzt(:)*QP(1)
         Iy(:,2)=PB(2)+rzt(:)*QP(2)
         Iz(:,2)=PB(3)+rzt(:)*QP(3)
       end
       ce = (ONE-rzt)*HALF*zinv
       if (n_e>1) then
         do e = 2,n_e
           e1=e-1
           ep1=e+1
           Ix(:,ep1)=Ix(:,2)*Ix(:,e)+e1*ce(:)*Ix(:,e1)
           Iy(:,ep1)=Iy(:,2)*Iy(:,e)+e1*ce(:)*Iy(:,e1)
           Iz(:,ep1)=Iz(:,2)*Iz(:,e)+e1*ce(:)*Iz(:,e1)
         end
       end
    end
  end

  transfer(es,ab)
  ! Applies the transfer equation to (e|s) to give (a|b)
    IN :: self
    VEC, IN :: es
    MAT, OUT :: ab
    if (.a%l > .b%l) then
      .transfer_l_a_highest(es,ab)
    else
      .transfer_l_b_highest(es,ab)
    end
  end

  transfer_l_a_highest(es,ab)
  ! Applies the transfer equation to (e|s) to give (a|b)
  ! where a has the higher angular momentum.
    IN :: self
    VEC, IN :: es
    MAT, OUT :: ab
    VEC(3) :: ABvec
    IMAT, PTR :: momenta
    IMAT3, PTR :: index
    IVEC(3) :: a_momenta,b_momenta
    MAT, PTR :: int_new,int_old
    INT :: a,b,lb,aub,bub,lb1_n_comp_sum,lb2_n_comp_sum
    INT :: a1,b1,z,n_e,eadd,tmp
    DBL :: ABi

    select case (.b%l)
      case (0)
        ab(:,1)=es

      case (1)
        ABvec = .a%pos - .b%pos
        eadd  = (.a%l-1).n_comp_sum
        n_e   = .a%l + .b%l
        aub   = (n_e-1).n_comp_sum - eadd

        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        do b=1,3
          z   = momenta(:,b+1).first_nonzero_component
          ABi = ABvec(z)
          do a=1,aub
            a_momenta    = momenta(:, a + eadd)
            a_momenta(z) = a_momenta(z) + 1
            a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
            ab(a,b)      = es(a1) + ABi * es(a)
          end
        end
        index.destroy
        momenta.destroy

      case default
        ABvec = .a%pos - .b%pos
        n_e   = .a%l + .b%l
        eadd  = (max(.a%l,.b%l)-1).n_comp_sum
        aub   = (n_e-1).n_comp_sum - eadd

        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        int_new.create(aub,3)
        do b=1,3
          z   = momenta(:,b+1).first_nonzero_component
          ABi = ABvec(z)
          do a=1,aub
            a_momenta    = momenta(:, a + eadd)
            a_momenta(z) = a_momenta(z) + 1
            a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
            int_new(a,b) = es(a1) + ABi * es(a)
          end
        end

        do lb=2, .b%l-1
          lb1_n_comp_sum = (lb-1).n_comp_sum
          lb2_n_comp_sum = (lb-2).n_comp_sum
          bub            = lb.n_comp_sum - lb1_n_comp_sum
          aub            = (n_e-lb).n_comp_sum - eadd
          int_old        => int_new
          nullify(int_new)
          int_new.create(aub,bub)
          do b=1,bub
            b_momenta    = momenta(:, b + lb1_n_comp_sum)
            z            = b_momenta.first_nonzero_component
            b_momenta(z) = b_momenta(z) - 1
            b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
            ABi          = ABvec(z)
            do a=1,aub
              a_momenta    = momenta(:, a + eadd)
              a_momenta(z) = a_momenta(z) + 1
              a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
              int_new(a,b) = int_old(a1,b1) + ABi * int_old(a,b1)
            end
          end
          int_old.destroy
        end

        lb1_n_comp_sum = (.b%l-1).n_comp_sum
        lb2_n_comp_sum = (.b%l-2).n_comp_sum
        bub            = .b%l.n_comp_sum - lb1_n_comp_sum
        aub            = (n_e-.b%l).n_comp_sum - eadd
        int_old        => int_new
        do b=1,bub
          b_momenta    = momenta(:, b + lb1_n_comp_sum)
          z            = b_momenta.first_nonzero_component
          b_momenta(z) = b_momenta(z) - 1
          b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
          ABi          = ABvec(z)
          do a=1,aub
            a_momenta    = momenta(:, a + eadd)
            a_momenta(z) = a_momenta(z) + 1
            a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
            ab(a,b)      = int_old(a1,b1) + ABi * int_old(a,b1)
          end
        end
        int_old.destroy
        index.destroy
        momenta.destroy
    end
  end

  transfer_l_b_highest(es,ab)
  ! Applies the transfer equation to (e|s) to give (a|b)
  ! where b has the higher angular momentum.
    IN :: self
    VEC, IN :: es
    MAT, OUT :: ab
    VEC(3) :: BAvec
    MAT, PTR :: int_new,int_old
    IMAT, PTR :: momenta
    IMAT3, PTR :: index
    IVEC(3) :: a_momenta,b_momenta
    INT :: a,b,la,aub,bub,la1_n_comp_sum,la2_n_comp_sum
    INT :: a1,b1,z,n_e,eadd,tmp
    DBL :: BAi

    select case (.a%l)
      case (0)
        ab(1,:)=es

      case (1)
        n_e   = .a%l + .b%l
        BAvec = .b%pos - .a%pos
        eadd  = (.b%l-1).n_comp_sum
        bub   = (n_e-1).n_comp_sum - eadd

        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        do a=1,3
          z   = momenta(:,a+1).first_nonzero_component
          BAi = BAvec(z)
          do b=1, bub
            b_momenta    = momenta(:, b + eadd)
            b_momenta(z) = b_momenta(z) + 1
            b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
            ab(a,b)      = es(b1) + BAi * es(b)
          end
        end
        index.destroy
        momenta.destroy

      case default
        BAvec = .b%pos - .a%pos
        n_e   = .a%l + .b%l
        eadd  = (.b%l-1).n_comp_sum
        bub   = (n_e-1).n_comp_sum - eadd

        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        int_new.create(3,bub)
        do a = 1, 3
          z   = momenta(:,a+1).first_nonzero_component
          BAi = BAvec(z)
          do b = 1, bub
            b_momenta    = momenta(:, b + eadd)
            b_momenta(z) = b_momenta(z) + 1
            b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
            int_new(a,b) = es(b1) + BAi * es(b)
          end
        end

        do la=2, .a%l - 1
          la1_n_comp_sum = (la-1).n_comp_sum
          la2_n_comp_sum = (la-2).n_comp_sum
          aub            = la.n_comp_sum - la1_n_comp_sum
          bub            = (n_e-la).n_comp_sum - eadd
          int_old=>int_new
          nullify(int_new)
          int_new.create(aub,bub)
          do a=1,aub
            a_momenta    = momenta(:,a + la1_n_comp_sum)
            z            = a_momenta.first_nonzero_component
            a_momenta(z) = a_momenta(z) - 1
            a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - la2_n_comp_sum
            BAi          = BAvec(z)
            do b=1,bub
              b_momenta    = momenta(:,b + eadd)
              b_momenta(z) = b_momenta(z) + 1
              b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
              int_new(a,b) = int_old(a1,b1) + BAi * int_old(a1,b)
            end
          end
          int_old.destroy
        end

        la1_n_comp_sum = (.a%l-1).n_comp_sum
        la2_n_comp_sum = (.a%l-2).n_comp_sum
        aub            = .a%l.n_comp_sum - la1_n_comp_sum
        bub            = (n_e-.a%l).n_comp_sum - eadd
        int_old=>int_new
        do a=1,aub
          a_momenta    = momenta(:,a + la1_n_comp_sum)
          z            = a_momenta.first_nonzero_component
          a_momenta(z) = a_momenta(z) - 1
          a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - la2_n_comp_sum
          BAi          = BAvec(z)
          do b=1,bub
            b_momenta    = momenta(:,b + eadd)
            b_momenta(z) = b_momenta(z) + 1
            b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
            ab(a,b)      = int_old(a1,b1) + BAi * int_old(a1,b)
          end
        end
        int_old.destroy
        index.destroy
        momenta.destroy
    end
  end

! Normalization routines and functions

  normalize(ab)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for orbitals a and b.
    IN :: self
    MAT, INOUT :: ab
    .to_normalize(ab)
  end

  to_normalize(ab)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for orbitals a and b.
    IN :: self
    MAT, INOUT :: ab
    VEC, PTR :: anorm,bnorm
    INT :: a,b
    if (NOT (.a%l<2 AND .b%l<2)) then
      anorm.create(.a%n_comp);    anorm.normalizing_factors( .a%l )
      bnorm.create(.b%n_comp);    bnorm.normalizing_factors( .b%l )
      do a = 1, .a%n_comp
        do b = 1, .b%n_comp
          ab(a,b)=ab(a,b)*anorm(a)*bnorm(b)
        end
      end
      bnorm.destroy
      anorm.destroy
    end
  end

end
