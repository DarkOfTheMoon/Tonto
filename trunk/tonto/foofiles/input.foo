!-----------------------------------------------------------------------
!
! INPUT : Line-oriented formatted sequential advancing file input, 
! including input from standard input. 
!
! The INPUT object is a FILE with a BUFFER. The only difference to the
! FILE class is that INPUT uses formatted files; the input proceeds via 
! a line buffer. Also, there is a default internal standard input object .
!
! This could be re-implemented using non-advancing input without 
! a buffer, but I am not sure if standard input can be treated this
! way. Also, the use of line numbers would be more tricky, and slower.
!
! Note that the input buffer is limited to size BSTR_SIZE.
!
! Updates the entry in std_system at start of every routine.
! Update the entry in std_system whenever record number is changed.
! Create and destory routines excepted.
!
! (c) dylan jayatilaka, december 1997
!
! $Id$
!-----------------------------------------------------------------------
module INPUT

   use TYPES
   use SYSTEM
   use STR
   use INT
   use BUFFER
   use UNITNUMBER

   implicit none

#include "macros"
#include "input.int"

!   type input_type
!
!   STR :: name
!   ! The name of the file
!
!   INT :: unit
!   ! The unit number
!
!   INT :: record
!   ! The current record of the output
!
!   INT :: io_status
!   ! Set non-zero if there is an error condition
!
!   BUFFER :: buffer
!   ! The input file buffer which holds one line of input
!   end

   interface read
      read_str, read_dbl, read_cdbl, read_int, read_bin, 
      read_ivec, read_vec, read_cvec, read_mat, read_cmat
   end

   interface get
      read_str, read_dbl, read_cdbl, read_int, read_bin, 
      read_ivec, read_vec, read_cvec, read_mat, read_cmat
   end

   INPUT*, public :: std_input
 
contains

!  *****************************
!  File creation type operations
!  *****************************

   create_std_input
   ! Create a the standard input file object, if needed.
      PTR :: self
      if (std_input.destroyed) then
         allocate(std_input)
         ADD_MEM(INPUT_SIZE)
         std_input.name = "std_input"
         std_input.record = 0
         std_input.unit = INPUT_STD_INPUT_UNIT
         std_input.io_status = 0
      end
      std_input.buffer.clear
      self => std_input
   end

   create(name) 
   ! Create an input file object. Does not open the input file.
      PTR :: self
      CHR(*) :: name
      UNITNUMBER :: unitnumber
      nullify(self)
      allocate(self)
      ADD_MEM(INPUT_SIZE)
      .name = name
      .record = 0
      .io_status = 0
      unitnumber.get( .unit)
      .buffer.clear
   end

   destroy
   ! Destroy a input file object
      PTR :: self
      UNITNUMBER :: unitnumber
      if (.destroyed) return
      unitnumber.free( .unit)
      DELETE_MEM(INPUT_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   open
   ! Open the input file. The input file object must already be created
      .system_update
      if (.exists) then
         open(unit=.unit,      &
              file=.name,      &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening old file "//.name)
      else
         open(unit=.unit,      &
              file=.name,      &
              status="new",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening new file "//.name)
      end
   end

   close
   ! Close the input file
      .system_update
      close(unit=.unit)
      .system_done
   end

   close_and_delete
   ! Close the input file and delete it from the file system
      .system_update
      close(unit=.unit,status="delete")
      .system_done
   end

   delete
   ! Delete the input file from the file system
      .system_update
      if (.is_not_open) .open
      .close_and_delete
      .system_done
   end
      
!  **************************
!  Data input type operations
!  **************************

   read_line(ignore_end_of_file) 
   ! Read a line into the buffer from the input file
   ! If "ignore_end_of_file" is present and TRUE, it is not
   ! an error to try to real a line.
      BIN, optional :: ignore_end_of_file
      BIN :: ignore_eof
      INT :: fail
      BSTR :: string
      .system_update
      ignore_eof = FALSE
      if (present(ignore_end_of_file)) ignore_eof = ignore_end_of_file
      string = ""
      fail = 2
      read(unit=.unit,fmt="(a)",end=20,err=10) string
      fail = fail-1
20    fail = fail-1
10    continue
      select case (fail)
        case (0)   ! No errors.  Let's read a line into the buffer.
          .buffer.set(string)
          .record = .record+1 
          .system_update
        case (1)   ! At end of file.
          .io_status = 1
           DIE_IF(NOT ignore_eof,"End of file")
        case (2)   ! Some error, but not end of file.
           DIE("read error")
      end
   end

   move_to_next_item 
   ! Move to the next item. Get a new line if the current buffer is exhausted
      .system_update
      if (.buffer.exhausted) then            ! No more line items to read
         .move_to_next_nonblank_line
      end
   end

   move_to_previous_item 
   ! Move to the previous item in the input file. Backspace a line if required.
      .system_update
      if (.next_line_item==1) then           ! If next item to be read is item 1
         .move_to_previous_nonblank_line
         .move_to_last_item_on_line          ! move to last item on previous line
      else
         .move_to_previous_item_on_line      ! move to the last read item
      end
   end
      
   move_to_next_nonblank_line
   ! Move to the next non blank line in the file
      do
         .read_line
         if (.buffer.not_empty) exit
      end
   end
      
   move_to_previous_nonblank_line
   ! Move to the last non blank line in the file
      do
         .backspace_line
         .system_update
         if (.buffer.not_empty) exit
      end
   end

   move_to_last_item_on_line
   ! Move the cursor over to the beginning of the last item on the line
      INT :: item
      .system_update
      item = .last_line_item
      .move_to_line_item(item) 
   end
      
   move_to_previous_item_on_line
   ! Move the cursor over to the beginning of the previous item on the
      INT :: item
      .system_update
      item = .previous_line_item
      .move_to_line_item(item) 
   end
      
   move_to_line_item(number) 
   ! Move the cursor over to the beginning of the item with index "number"
   ! on the current line
      INT :: number
      INT :: n
      .system_update
      n = number
      .buffer.move_to_item(n)
   end

   look_for( search, from_update)
   ! sets record to the line updateing with "search" string
   ! if from_update is present then the search is updateed from the beginning
   STR(*) :: search
   STR, optional :: from_update
   INT :: update_record, end_record
      .system_update
      update_record = .record
      if (present(from_update)) self.rewind
      do
         if (search.is_included_in( .buffer.buffer_str)) exit
         end_record = .record
         .read_line(ignore_end_of_file=TRUE)
         if (.record == end_record) then
            .move_to_record(update_record)
            exit
         end
      end
   end

   get_next_item(word)
   ! Get the next item in the file
      STR :: word
      .system_update
      .move_to_next_item
      .buffer.get_str(word)
   end

  read_str(word) 
  ! Read a str into "word"
    STR :: word
    .system_update
    .move_to_next_item
    .buffer.get_str(word)
  end

  read_chr(chr) 
  ! Read a character into "chr"
    CHR :: chr
    STR :: word
    .system_update
    .read_str(word)
    if (len_trim(word)>1) then
      .system_update
      DIE("Expecting 1 character, not this: "// trim(word))
    end
    chr = word
  end

  read_dbl(value)
  ! Read a dbl into "value"
    DBL :: value
    .system_update
    .move_to_next_item
    .buffer.get_dbl(value)
  end

  read_formatted_dbl(value,form)
  ! Read a formatted dbl into "value". Does not check the end of line!
    DBL :: value
    CHR(*), IN :: form
    .system_update
    .buffer.get_formatted_dbl(value,form)
  end

   read_cdbl(value)
   ! Read a cdbl into "value"
      CDBL :: value
      DBL :: real,imag
      .system_update
      .move_to_next_item
      .buffer.get_dbl(real)
      .move_to_next_item
      .buffer.get_dbl(imag)
      value = cmplx(real,imag)
   end

   read_int(value) 
   ! Read an integer into "value"
      INT :: value
      .system_update
      .move_to_next_item
      .buffer.get_int(value)
   end

   read_bin(value) 
   ! Read a logical into "value"
      BIN :: value
      .system_update
      .move_to_next_item
      .buffer.get_bin(value)
   end

   read_ivec(v)
   ! Read in an integer vector sequentially. Line breaks are not significant.
      IVEC :: v
      INT :: dim,i
      .system_update
      dim = size(v)
      do i = 1,dim
         .read_int(v(i))
      end
   end
      
   read_vec(v)
   ! Read in a vector sequentially. Line breaks are not significant.
      VEC :: v
      INT :: dim,i
      .system_update
      dim = size(v)
      do i = 1,dim
         .read_dbl(v(i))
      end
   end
      
  rest_of_line(res)
  ! If there is anything left on the input line, then it is returned, else
  ! nothing is returned.  Pointer moves to next line.
    INOUT :: self
    STR :: res
    .system_update
    if ( .buffer.not_empty ) then
      .move_to_next_item
      res = .buffer.buffer_str( .buffer.pos : )
      .read_line
    else
      res = ""
      .read_line
    end
  end

   read_cvec(v)
   ! Read in a complex vector sequentially. Line breaks are not significant.
      CVEC :: v
      INT :: dim,i
      .system_update
      dim = size(v)
      do i = 1,dim
         .read_cdbl(v(i))
      end
   end

   read_mat(m,order)
   ! Read in a complex matrix sequentially by row (default) or by column. 
   ! Line breaks are not significant.
      MAT :: m
      STR(*), optional :: order
      INT :: dim1,dim2,i,j
      STR :: print_order
      .system_update
      dim1 = size(m,1)
      dim2 = size(m,2)
      print_order = "by_row"
      if (present(order)) print_order = order
      select case (print_order)
         case ("by_column","column_major")
            do j = 1,dim2
            do i = 1,dim1
              .read_dbl(m(i,j))
            end
            end
         case ("by_row","row_major")
            do i = 1,dim1
            do j = 1,dim2
              .read_dbl(m(i,j))
            end
            end
         case default
            DIE("unknown print order, "// trim(print_order))
      end
   end

  read_formatted_mat(m,form,items_per_line)
  ! Read a formatted matrix.
    MAT, OUT :: m
    CHR(*), IN :: form
    INT, IN :: items_per_line
    INT :: i,j,d,count

    .system_update
    .buffer.pos = 0

    d = size(m,1)
    count=0
    do i=1,d
      do j=1,d
        .read_formatted_dbl(m(i,j),form)
        count = count + 1
         if (count==items_per_line) then
           do
              .read_line
              if (.buffer.not_empty) exit
           end
           count=0
         end
      end
    end
  end

  read_cadpac_mat(m)
  ! Read in a matrix produced by the constraint part of cadpac.
    IN :: self
    MAT, OUT :: m
    .system_update
    .read_formatted_mat(m,"5D16.8",5)
  end

   read_cmat(m,order)
   ! Read in a complex matrix sequentially by row (default) or by column. 
   ! Line breaks are not significant.
      CMAT :: m
      STR, optional :: order
      INT :: dim1,dim2,i,j
      STR :: print_order
      .system_update
      dim1 = size(m,1)
      dim2 = size(m,2)
      print_order = "by_row"
      if (present(order)) print_order = order
      select case (print_order)
         case ("by_column","column_major")
            do j = 1,dim2
            do i = 1,dim1
              .read_cdbl(m(i,j))
            end
            end
         case ("by_row","row_major")
            do i = 1,dim1
            do j = 1,dim2
              .read_cdbl(m(i,j))
            end
            end
         case default
            DIE("unknown print order, "// trim(print_order))
      end
   end

  next_str result(word) 
  ! Read a str from the input file and return it
    STR :: word
    .system_update
    .read_str(word)
  end

  next_dbl result(value)
  ! Read a dbl from the input file and return it
    DBL :: value
    .system_update
    .read_dbl(value)
  end

  next_cdbl result(value)
  ! Read a cdbl from the input file and return it
    CDBL :: value
    .system_update
    .read_cdbl(value)
  end

  next_int result(value)
  ! Read a integer from the input file and return it
    INT :: value
    .system_update
    .read_int(value)
  end
 
  next_bin result(value)
  ! Read a logical from the input file and return it
    BIN :: value
    .system_update
    .read_bin(value)
  end

  next_chr result(chr)
  ! Read a character into "chr"
    CHR :: chr
    .system_update
    .read_chr(chr)
  end

  next_formatted_dbl(form) result(value)
  ! Read a formatted dbl into "value". Does not check the end of line!
    DBL :: value
    CHR(*), IN :: form
    .system_update
    .read_formatted_dbl(value,form)
  end

!  **********************************
!  Line repositioning type operations
!  **********************************

   rewind
   ! REwind the input file
      .system_update
      rewind(unit=.unit,iostat=.io_status)
      DIE_IF(.io_status>0,"rewind error")
      .record = 0
      .system_update
      .read_line
   end

   move_to_end
   ! Move to the end of the input file
      .system_update
      do
         read(unit=.unit, fmt="()", iostat=.io_status)
         if (.io_status/=0) exit
         .record = .record + 1
         .system_update
      end
      backspace(unit=.unit,iostat=.io_status)
      backspace(unit=.unit,iostat=.io_status)
      .record = max(0,.record-1)
      .system_update
      .read_line
   end

   backspace_line 
   ! Reprocess previously input line
      .system_update
      .move_to_record(.record-1) 
   end

   skip_line
   ! Skip the next line in the input file
      .system_update
      .move_to_record(.record+1) 
   end

   move_to_line(line) 
   ! Move to be positioned *before* the start of the requested "line"
   ! in the input file
      INT :: line
      ENSURE(line>=1,"line number must be non-negative")
      .move_to_record(line-1)
   end

   move_to_record(rec) 
   ! Move to the requested record "rec" in the input file.
   ! Remember: .record is the last processed record.
      INT :: rec 
      ENSURE(rec>=0,"record number must be non-negative")
      .system_update
      if (rec<(.record+1)) then
         do 
            backspace(unit=.unit,iostat=.io_status)
            DIE_IF(.io_status>0,"backspace error")
         !  .record = max(0,.record-1)
            .record = .record-1
            .system_update
            if (rec==(.record+1)) exit
         end
      else if (rec>(.record+1)) then
         do 
            read(unit=.unit,fmt="()",iostat=.io_status)
            DIE_IF(.io_status>0,"read error")
            .record = .record + 1
            .system_update
            if (rec==(.record+1)) exit
         end
      end
      .read_line
   end

!  ***************
!  Inquiry methods
!  ***************

   exists result(res)
   ! Returns true if the file exists on the file system
      BIN :: res
      .system_update
      inquire(file=.name,exist=res)
   end

   is_open result(res)
   ! Returns true if the file has been opened
      BIN :: res
      .system_update
      ! inquire(unit=.unit,opened=res)
      inquire(file=.name,opened=res)
   end

   unit_used result(res)
   ! Returns true if the file unit is in use
      BIN :: res
      .system_update
      inquire(unit=.unit,opened=res)
   end

   next_line_item result (res)
   ! Return the index of the next item to be processed on the line
      INT :: res
      res = .buffer.next_item
   end

   previous_line_item  result (res)
   ! Return the index of the previous item to be processed on the line
      INT :: res
      res = .buffer.item
   end

   last_line_item  result (res)
   ! Return the index of the final item on the line
      INT :: res
      res = .buffer.n_items
   end

   n_line_items result (res)
   ! Return the number of items on the line
      INT :: res
      res = .buffer.n_items
   end

   position result(res) 
   ! Return record position of the file
      INT :: res
      .system_update
      res = .record
   end

   line_number result(res) 
   ! Return the input file line number which is being processed,
   ! or will be processed next.
      INT :: res
      .system_update
      res = .record + 1
   end

   end_of_file result(res)
   ! Read a line into the buffer from the input file
      INT :: fail
      BIN :: res
      BSTR :: string
      .system_update
      fail = 2
      read(unit=.unit,fmt="(a)",end=20,err=10) string
      fail = fail-1
20    fail = fail-1
10    continue
      select case (fail)
        case (0)
          res = FALSE
          backspace(unit=.unit,iostat=.io_status)
          DIE_IF(.io_status>0,"backspace error")
        case (1)
          res = TRUE
        case (2)
          DIE("unknown read error")
      end
   end

  system_update
  ! Lets the system know info about the file being read, in case of error.
    std_system.file_name = .name
    std_system.file_record = .record
    std_system.file_operation = "read"
  end

  system_done
  ! Lets the system know the file has suspended being used.
    std_system.file_name = ""
    std_system.file_record = 0
    std_system.file_operation = ""
  end

end 
