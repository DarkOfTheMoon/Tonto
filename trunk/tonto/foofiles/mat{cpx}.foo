!---------------------------------------------------------------------------
!
!  complex matrix operations :: MAT{CPX} ...
!
! Copyright (C) Dylan Jayatilaka, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module MAT{CPX}

   implicit none

   tol5 :: REAL, private = 1.0d-5
!   tol10 :: REAL, private = 1.0d-10

   interface trace_of_product_with
      trace_product_with
   end

   interface diagonal_set_to
      set_diagonal_to
   end

   interface diagonal_plus
      increment_diagonal_by
   end

   interface diagonal_times
      scale_diagonal_by
   end

   interface diagonal_max_abs
      max_abs_diagonal_element 
   end

contains

! *****************
! Memory allocation
! *****************

   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given dimensions
   end

   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the specified "bounds" for each dimension
   end

   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given dimensions
   end

   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the specified bounds for each dimension
   end

   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given bounds for all dimensions
   end

   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a replica copy of matrix
   end

   destroy ::: get_from(MAT{INTRINSIC}), leaky
   ! Destroy the object
   end

   created result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Returns true if self has *not* been created
   end

! ****************************
! Size-of and shape operations 
! ****************************

   size result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the array
   end

   dim1 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the 1st dimension
   end

   dim2 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the 2nd dimension
   end

   shape result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the shape of "self"
   end

   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}), pure
   ! Returns TRUE if the matrix "a" has the same shape as "self"
   end

   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}), pure
   ! Returns TRUE if the matrix "a" has the same shape as "self"
   end

   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}), pure
   ! Returns TRUE if the matrix "a" is the transposed shape of self
   end

   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}), pure
   ! Returns TRUE if the matrix "a" is the transposed shape of self
   end

   is_square result (res) ::: get_from(MAT{INTRINSIC}), pure
   ! Returns TRUE if the matrix is square
   end

! ***********************
! Shrinking and expansion
! ***********************

   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Shrinks self to dimension dim1xdim2.  Contents are retained.
   end

   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Expands self to dimension dim1xdim2.  Contents are retained.
   end

   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Shrinks columns of self to dimension dim2. Contents are retained.
   end

   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Expands the columns self to dim2.  Contents are retained.
   end

   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky
   ! Append the columns "cols" onto the end of self.
   end

   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky
   ! Append the column "col" onto the end of self.
   end

! ********************
! Comparison functions
! ********************

   equals(b) result (res) ::: get_from(MAT{INTRINSIC})
   ! Check if the matrix is the same as "b".
   end

   same_as(b,eps,diff) result (res) ::: get_from(MAT{INTRINSIC})
   ! Check if the matrix is the same as "b", within "eps", and return the
   ! actual difference in "diff"
   end

! *****************
! Inquiry functions
! *****************

   is_diagonal result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is a diagonal matrix
   end

   has_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has 1's as diagonal elements
   end

   has_minus_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has -1's as diagonal elements
   end

   is_unit_matrix result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is the unit matrix
   end

   is_inversion_matrix result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is an inversion matrix
   ! i.e. minus the unit matrix
   end

   is_symmetric result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is a symmetric matrix
   end

   is_antisymmetric result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is an antisymmetric matrix
   end

   is_zero(eps) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return TRUE is "self" is the zero matrix, i.e. every element is zero.
   ! If present, "eps" is used to decide when a small number is zero.
   end

   is_hermitian(tol) result (res)
   ! Returns TRUE if the matrix is hermitian. You can set the tolerance "tol"
   ! for comparison.
      self :: IN
      res :: BIN
      tol :: REAL, optional
      res = .is_square AND .same_as(transpose(conjg(self)),tol)
   end

   is_antihermitian(tol) result (res)
   ! Returns TRUE if the matrix is antihermitian. You can set the tolerance
   ! "tol" for comparison.
      self :: IN
      res :: BIN
      tol :: REAL, optional
      res = .is_square AND .same_as(-transpose(conjg(self)),tol)
   end

! *****************
! Column operations 
! *****************

   has_column(c,eps,col) result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has a column "c", with "eps" tolerance.
   ! If present, the matching column index "col" is also returned.
   end

   column_index(c,eps) result (res) ::: get_from(MAT{INTRINSIC})
   ! The matching column index is returned, if the column matches "col" to
   ! tolerance "eps", if it is present.
   end

   swap_columns(col1,col2) ::: get_from(MAT{INTRINSIC})
   ! Swap columns "col1" and "col2" of self
   end

   swap_columns(list) ::: get_from(MAT{INTRINSIC})
   ! Sequentially swap all columns in a column "list",
   ! self(:,i)      = self(:,list(i))
   ! self(:,col(i)) = self(:,i)
   end

   column_norms result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the norms of every column
   end

   get_column_norms(res) ::: get_from(MAT{INTRINSIC})
   ! Return the norms of every column
   end

   get_column_dot_products(res) ::: get_from(MAT{INTRINSIC})
   ! Return the dot products of every column with itself.
   ! Good for testing distances without using a sqrt.
   end

   index_of_minimum_column_norm(offset) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the column index of the column with the *minimum* norm. If present,
   ! "offset" is subtracted from every column beforehand, and then added back
   ! afterwards. This is useful for finding the index of the column with minimum
   ! distance to "offset", for a list of points held in "self".
   end

   max_abs_column_difference result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the maximum of the absolute difference between all the column vector
   ! pairs of the matrix.
   end

   mean_column_vector result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the mean of the column vectors.
   end

   sum_column_vectors result (res) ::: get_from(MAT{INTRINSIC})
   ! Sum the column vectors (i.e. rows) in "self".
   end

   reverse_column_order ::: get_from(MAT{INTRINSIC})
   ! Reverse the order of the columns of self.
   end

! **************
! Row operations
! **************

   sum_row_vectors result (res) ::: get_from(MAT{INTRINSIC})
   ! Sum the row vectors (i.e. columns) in "self".
   end

! ******************************************
! Matrix algebra and vector space operations
! ******************************************

   determinant result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the determinant a 3x3 matrix
   end

   cofactor result (res) ::: get_from(MAT{INTRINSIC}), leaky
   ! Return the cofactor of a 3x3 matrix
   end

   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{CPX}, RES_TYPE=>CPX)
   ! Multiply the matrix self by vector "l" on the left and vector "r" on the
   ! right ie:  res = l^dagger self r. Useful for non-unit metric dot_products.
   end

   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{REAL}, RES_TYPE=>CPX)
   ! Multiply the matrix self by vector "l" on the left and vector "r" on the
   ! right ie:  res = l^dagger self r. Useful for non-unit metric dot_products.
   end

   rotate(v) ::: get_from(MAT{INTRINSIC})
   ! Rotate vector "v" by self
   end

   to_unit_matrix ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the unit matrix
   end

   zero_small_values(eps) ::: get_from(MAT{INTRINSIC}), pure
   ! Zero elements of the matrix which are less than "eps" in magnitude
   end

   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Set self to "a"
   end

   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Set self to "a"
   end

   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Self becomes the transpose of "a"
   end

   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Self becomes the transpose of "a"
   end

   to_transpose ::: get_from(MAT{INTRINSIC})
   ! Self becomes its own transpose.
   end

   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Add to self the matrix "a"
   end

   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Add to self the matrix "a"
   end

   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Subtract from self the matrix "a"
   end

   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Subtract from self the matrix "a"
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)
   ! Set "self" to matrix "at" scaled by "fac"
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)
   ! Set "self" to matrix "at" scaled by "fac"
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Set "self" to matrix "at" scaled by "fac"
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Set "self" to matrix "at" scaled by "fac"
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)
   ! Add to "self" matrix "a" scaled by "fac"
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)
   ! Add to "self" matrix "a" scaled by "fac"
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Add to "self" matrix "a" scaled by "fac"
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Add to "self" matrix "a" scaled by "fac"
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)
   ! Subtract from "self" matrix "a" scaled by "fac"
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)
   ! Subtract from "self" matrix "a" scaled by "fac"
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Subtract from "self" matrix "a" scaled by "fac"
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Subtract from "self" matrix "a" scaled by "fac"
   end

   to_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL})
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   end

   to_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   ! Likewise for the dagger operations.
   end

   to_product_of(a,b,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the product of complex matrix "a" and real matrix "b".  If
   ! present, "dagger_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
   end

   to_product_of(a,b,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the product of real matrix "a" and complex matrix "b".  If
   ! present, "transpose_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
   end

   plus_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL})
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   end

   plus_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC})
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   ! Likewise for the dagger operations.
   end

   plus_product_of(a,b,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC})
   ! Add to "self" the product of complex matrix "a" and real matrix "b".  If
   ! present, "dagger_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
   end

   plus_product_of(a,b,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC})
   ! Add to "self" the product of real matrix "a" and complex matrix "b".  If
   ! present, "transpose_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
   end

   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
   end

   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
   end

   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
   end

   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
   end

   to_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Set "self" to the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   to_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Set "self" to the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   to_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Set "self" to the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   to_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Set "self" to the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! neeb to be transposed.
   end

   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! neeb to be transposed.
   end

   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
   end

   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
   end

   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Add to "self" the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Add to "self" the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Add to "self" the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Add to "self" the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
   end

   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, DIAG_TYPE=>VEC{CPX})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, ""transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
   end

   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, DIAG_TYPE=>VEC{REAL})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, ""transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
   end

   to_product_with_diagonal(a,diag,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DIAG_TYPE=>VEC{CPX})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, "dagger_a" or "transpose_a" can be set to TRUE
   ! if "a" needs to be daggered or transposed.
   end

   to_product_with_diagonal(a,diag,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DIAG_TYPE=>VEC{REAL})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, "dagger_a" or "transpose_a" can be set to TRUE
   ! if "a" needs to be daggered or transposed.
   end

   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{CPX}, A_TYPE=>MAT{REAL})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
   end

   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{REAL}, A_TYPE=>MAT{REAL})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
   end

   to_product_with_diagonal(dg,a,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{CPX})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "dagger_a" or "transpose_a" can be set to
   ! TRUE if "a" needs to be daggered or transposed.
   end

   to_product_with_diagonal(dg,a,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{REAL})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "dagger_a" or "transpose_a" can be set to
   ! TRUE if "a" needs to be daggered or transposed.
   end

! ****************
! Trace operations
! ****************

   trace result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of self
   end

   trace_product_with(a,transpose_a,dagger_a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Return the trace of the product of "self" with matrix "a",
   ! and if "dagger_a" is present and TRUE, then dagger "a".
   end

   trace_product_with(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Return the trace of the product of "self" with matrix "a".
   end

   trace_product_with(a,transpose_a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Return the trace of the product of "self" with matrix "a",
   ! and if "transpose_a" is present and TRUE, then transpose "a".
   end

   trace_product_with(a,b,c) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of the product of "self" with matrices "a", "b" and "c".
   end

   trace_product_with(a,b,c,d,e) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of the product of "self" with matrices "a", "b" ... "e".
   end

   dot(a) result (res) 
   ! Synonym for trace_product_with(a) ... Return the trace of the product of
   ! "self" with matrix "a". This is really intended for use with symmetric
   ! matrices only.
      self :: IN
      a :: MAT{CPX}, IN
      res :: CPX
      res = .trace_product_with(a,dagger_a=TRUE)
   end

! ************************
! Change of basis routines
! ************************

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)
   ! Change the basis of "self" using vectors "V"; self = V^dagger self V
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
   ! Change the basis of "self" using vectors "V"; self = V^dagger self V
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>VEC{CPX})
   ! Change the basis of "self" using diagonal matrix "V" (stored as a vector).
   ! self = V self V
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>VEC{REAL})
   ! Change the basis of "self" using diagonal matrix "V" (stored as a vector).
   ! self = V self V
   end

   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{CPX})
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
   end

   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{REAL})
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
   end

   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new".  new = V^dagger self V
   end

   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new".  new = V^dagger self V
   end

   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)
   ! Change the basis of "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L^dagger self R
   end

   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})
   ! Change the basis of "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L^dagger self R
   end

   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)
   ! Back transform "self" using vectors "V", and place the result in "self".
   ! self = V self V^dagger
   end

   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
   ! Back transform "self" using vectors "V", and place the result in "self".
   ! self = V self V^dagger
   end

   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! new = V self V^dagger
   end

   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! new = V self V^dagger
   end

   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)
   ! Back transform "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L self R^dagger
   end

   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})
   ! Back transform "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L self R^dagger
   end

!   similarity_transform(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX})
!   ! Do a similarity transform of "self" using vectors "V": self = V self V^-1
!   end

!   similarity_transform(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
!   ! Do a similarity transform of "self" using vectors "V": self = V self V^-1
!   end

! **************************
! Operations on the diagonal
! **************************

   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{CPX})
   ! Converts the diagonal vector "d" to matrix "self".
   end

   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})
   ! Converts the diagonal vector "d" to matrix "self".
   end

   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{CPX})
   ! Set the diagonal of "self" to th diagonal vector "d"
   end

   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})
   ! Set the diagonal of "self" to th diagonal vector "d"
   end

   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>CPX)
   ! Set the diagonal of "self" to "val"
   end

   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>REAL)
   ! Set the diagonal of "self" to "val"
   end

   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC})
   ! Get the diagonal elements of "self" in vector "d"
   end

   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})
   ! Get the diagonal elements of "self" in vector "d" when the type
   ! of "d" is different from the parent matrix "self"
   end

   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>CPX)
   ! Add "val" to the diagonal of "self"
   end

   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>REAL)
   ! Add "val" to the diagonal of "self"
   end

   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Weight the diagonal elements of "self" by "fac"
   end

   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Weight the diagonal elements of "self" by "fac"
   end

   zero_diagonal ::: get_from(MAT{INTRINSIC})
   ! Zero the diagonal elements of "self"
   end

   zero_off_diagonal ::: get_from(MAT{INTRINSIC})
   ! Zero the off diagonal elements of "self"
   end

   max_abs_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})
   ! Get the maximum absolute value of the diagonal elements of the self matrix
   end

! ************************
! Symmetrising and folding
! ************************

   symmetrize ::: get_from(MAT{INTRINSIC})
   ! Set self to half of itself plus half its transpose, i.e.
   ! self = 1/2 (self + self^T)
   end

   antisymmetrize ::: get_from(MAT{INTRINSIC})
   ! Set self to half of itself minus half its transpose, i.e.
   ! self = 1/2 (self - self^T)
   end

   symmetric_fold ::: get_from(MAT{INTRINSIC})
   ! Add the upper triangle of "self" into the lower triangle
   end

   antisymmetric_fold ::: get_from(MAT{INTRINSIC})
   ! Subtract the upper triangle of "self" into the lower triangle
   end

   symmetric_reflect ::: get_from(MAT{INTRINSIC})
   ! Make the upper triangle of "self" the same as the lower triangle
   end

   antisymmetric_reflect ::: get_from(MAT{INTRINSIC})
   ! Make the upper triangle of "self" the negative of the lower triangle and
   ! make the diagonal zero.
   end

   symmetric_fold_to_triangle(tr) ::: get_from(MAT{INTRINSIC})
   ! Add the upper triangle of "self" into the lower triangle and return
   ! the lower triangle "tr" as a vector across rows.
      tr :: VEC{CPX}
   end

   hermitianize
   ! Set self to half of itself plus half its dagger, i.e.
   ! self = 1/2 (self + self^dagger)
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      val :: CPX
      do i = 1,.dim1
         do j = 1,i
            val = HALF*(self(i,j)+conjg(self(j,i)))
            self(i,j) = val
            self(j,i) = conjg(val)
         end
      end
   end

   antihermitianize
   ! Set self to half of itself minus half its dagger, i.e.
   ! self = 1/2 (self - self^dagger)
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      val :: CPX
      do i = 1,.dim1
         do j = 1,i
            val = HALF*(self(i,j)-conjg(self(j,i)))
            self(i,j) =  val
            self(j,i) = -conjg(val)
         end
      end
   end

   hermitian_fold
   ! Add the hermitian conjugate of the upper half of the matrix into its lower
   ! half, and make the diagonal real.
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(i,j) = self(i,j) + conjg(self(j,i))
         end
         self(i,i) = real(self(i,i),kind=REAL_KIND)
      end
   end

   antihermitian_fold
   ! Subtract the hermitian conjugate of the upper half of the matrix into its
   ! lower half, and make the diagonal complex
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i
            self(i,j) = self(i,j)-conjg(self(j,i))
         end
         self(i,i) = HALF*self(i,i)
      end
   end

   make_hermitian
   ! Make the upper half of self hermitian with respect to the lower half
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = conjg(self(i,j))
         end
      end
      do i = 1,.dim1
         self(i,i) = real(self(i,i),kind=REAL_KIND)
      end
   end

   hermitian_reflect
   ! Make the upper half of self hermitian with respect
   ! to the lower half
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = conjg(self(i,j))
         end
      end
      do i = 1,.dim1
         self(i,i) = real(self(i,i),kind=REAL_KIND)
      end
   end

   make_antihermitian
   ! Make the upper half of self anti-hermitian with respect
   ! to the lower half
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = -conjg(self(i,j))
         end
      end
      do i = 1,.dim1
         self(i,i) = HALF*(self(i,i)-conjg(self(i,i)))
      end
   end

   antihermitian_reflect
   ! Make the upper half of self anti-hermitian with respect
   ! to the lower half
   ENSURE(.is_square,"non-square matrix")
      dim1,i,j :: INT
      dim1 = .dim1
      do i = 1,dim1
         do j = 1,i-1
            self(j,i) = -conjg(self(i,j))
         end
      end
      do i = 1,.dim1
         self(i,i) = HALF*(self(i,i)-conjg(self(i,i)))
      end
   end

! **************************************
! Compression and uncompression routines
! **************************************

   compress_to_square(sq)
   ! Compresses the hermitian matrix self to vector "sq". First comes the
   ! lower half of the real part, then lower half of the imaginary part.
      self :: IN
      sq :: VEC{REAL}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(sq.dim>=self.dim,"sq array too small")
      i,j,ij :: INT
      ij = 0
      do i = 1,.dim1
         do j = 1,i
            sq(ij+j) = real(self(i,j),kind=REAL_KIND)
         end
         ij = ij+i
      end
      do i = 1,.dim1
         do j = 1,i-1
            sq(ij+j) = aimag(self(i,j))
         end
         ij = ij+i-1
      end
   end

   uncompress_from_square(sq)
   ! Uncompress the vector "sq" to a hermitian matrix assuming the lower half
   ! of the real part comes first, then the lower half of the imaginary part.
      sq :: VEC{REAL}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(sq.dim>=self.dim,"sq array too small")
      i,j,ij :: INT
      ij = 0
      do i = 1,.dim1
         do j = 1,i
            self(i,j) = sq(ij+j)
            self(j,i) = sq(ij+j)
         end
         ij = ij+i
      end
      do i = 1,.dim1
         do j = 1,i-1
            self(i,j) = self(i,j) + cmplx(ZERO,sq(ij+j),kind=CPX_KIND)
            self(j,i) = self(j,i) - cmplx(ZERO,sq(ij+j),kind=CPX_KIND)
         end
         ij = ij+i-1
      end
   end

   compress_to_triangle(tr) ::: get_from(MAT{INTRINSIC})
   ! Converts the lower triangle of matrix self to the triangle "tr".
   ! using row order.
   end

   uncompress_from_triangle(tr)
   ! Converts the triangle "tr" into the hermitian matrix "self".
   ! WARNING: won't work for symmetric matrices
      tr :: VEC{CPX}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(tr.dim>=.tri_size,"tr array too small")
      i,j,ij :: INT
      ij = 0
      do i = 1,.dim1
         do j = 1,i
            self(i,j) =       tr(ij+j)
            self(j,i) = conjg(tr(ij+j))
         end
         ij = ij+i
      end
   end

   tri_size result (ltr) ::: get_from(MAT{INTRINSIC})
   ! Returns the size of the lower triangle needed to store self.
   end

! *****************
! Orthogonalisation
! *****************

   schmidt_orthonormalise(S,scale) ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric. If "scale" is present, it is set to the product of the
   ! normalisation factors used to normalise each column after the Schmidt
   ! procedure.
   end

   reverse_schmidt_orthonormalise(S) ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric.
   end

   schmidt_orthonormalise ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self".
   end

   reverse_schmidt_orthogonalise ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" using unit metric.
   end

   symmetrically_orthonormalise(S) ::: get_from(MAT{INTRINSIC})
   ! Symmetrically orthonormalise the column vectors in "self" using "S" as the
   ! metric.
   end

   make_diagonally_dominant(permutation) ::: get_from(MAT{INTRINSIC})
   ! Rearrange the order of the columns of self so that the largest magnitude
   ! elements in each column occur along the diagonal. If "permutation" is
   ! present, it is the array which achieves this ordering, i.e. at the end of
   ! the routine, what is done is: self = self(:,permutation).
   end

! *********************
! Eigenproblem routines
! *********************

   diagonalise_by_jacobi(eigenvalues,eigenvectors,eps,max_iterations)
   ! Diagonalises "self" using the Jacobi rotations method. Returns the
   ! "eigenvalues". Input the accuracy "eps" or the maximum number of iterations
   ! "max_iter", if desired.
      eigenvalues :: VEC{REAL}
      eigenvectors :: MAT{CPX}
      eps :: REAL, optional
      max_iterations :: INT, optional

  ENSURE(.is_hermitian, "self is not symmetrix")
  ENSURE(eigenvalues.dim==.dim1,"wrong size, eigenvalues")
  ENSURE(eigenvectors.is_square, "eigenvectors are not square")
  ENSURE(eigenvalues.dim1>=.dim1,"wrong size, eigenvectors")

      i,j,iter,max_iter  :: INT
      accuracy,tol :: REAL
      done :: BIN
      W :: MAT{CPX}*
      indices :: VEC{INT}*

      accuracy = TOL(8)
      if (present(eps)) accuracy = eps
      max_iter = 500
      if (present(max_iterations)) max_iter = max_iterations

      W.create_copy(self)
      eigenvectors.to_unit_matrix

      iter = 0
      do
        iter = iter + 1
        DIE_IF(iter>max_iter,"too many iterations")
        if (iter>max_iter) exit
        tol = accuracy
        done = TRUE
        do i = 1,.dim1
        do j = 1,i-1
           if (abs(W(i,j))<tol) cycle
           done = FALSE
           W.jacobi_rotation(i,j,eigenvectors)      
        end
        end
        done = done AND iter>3
        if (done) exit
      end

      W.put_diagonal_to(eigenvalues)
      W.destroy

      allocate(indices(.dim1))
      eigenvalues.quick_sort(indices)

      eigenvalues  = eigenvalues(indices)
      eigenvectors = eigenvectors(:,indices)

      deallocate(indices)
   end

   jacobi_rotation(p,q,v)
   ! Do a two dimensional Jacobi rotation in the plane of "p" and "q" so as to
   ! eliminate the off diagonal element self(p,q) and also update the rotation
   ! matrix "v". NOTE: self must be symmetric
      p,q :: INT
      v :: MAT{CPX}

      i :: INT
      s_pp,s_qq,s_pq,tau,s_ip,s_iq,r_ip,r_iq,ph,pc :: CPX
      a_pq,theta,t,c,s :: REAL

      s_pp = self(p,p)
      s_qq = self(q,q)
      s_pq = self(p,q)
      a_pq = abs(s_pq)

      theta = (s_qq-s_pp)/(TWO*a_pq) 
      t = ONE/(abs(theta)+sqrt(theta*theta+ONE))
      if (theta<ZERO) t = -t
      c = ONE/sqrt(t*t+ONE)
      s = t*c
      tau = s/(ONE+c)
      ph = s_pq/a_pq
      pc = conjg(ph)

      do i = 1,.dim1
         s_ip = self(i,p)
         s_iq = self(i,q)
         r_ip = s_ip - s*(pc*s_iq+tau*s_ip)
         r_iq = s_iq + s*(ph*s_ip-tau*s_iq)
         self(i,p) = r_ip
         self(p,i) = r_ip
         self(i,q) = r_iq
         self(q,i) = r_iq
      end
      self(p,p) = s_pp - t*pc*s_pq
      self(q,q) = s_qq + t*pc*s_pq
      self(p,q) = ZERO
      self(q,p) = ZERO

      do i = 1,.dim1
         s_ip = v(i,p)
         s_iq = v(i,q)
         v(i,p) = s_ip - s*(pc*s_iq+tau*s_ip)
         v(i,q) = s_iq + s*(ph*s_ip-tau*s_iq)
      end
   end

   solve_eigenproblem(eigenvalues,eigenvectors,routine)
   ! Solve the hermitian eigenvalue problem for self
      eigenvalues :: VEC{REAL}
      eigenvectors :: MAT{CPX}
      routine :: STR, optional
#ifdef ESSL
      .solve_eigenproblem_ESSL(eigenvalues,eigenvectors,routine)
#else
      .solve_eigenproblem_LAPACK(eigenvalues,eigenvectors,routine)
#endif
   end

   solve_eigenproblem_ESSL(eigenvalues,eigenvectors,routine) ::: private
   ! Solve the hermitian eigenvalue problem for self. ESSL version.
      eigenvalues :: VEC{REAL}
      eigenvectors :: MAT{CPX}
      routine :: STR, optional
   ENSURE(.is_square,"non-square matrix")
   ENSURE(eigenvalues.dim>=.dim1,"supplied eigenvalue array too small")
   ENSURE(eigenvectors.dim>=self.dim,"supplied eigenvector array too small")
   ENSURE(NOT present(routine),"routine specifier not allowed in ESSL version")
      ap :: VEC{CPX}*
      RW :: VEC{REAL}*
      dim :: INT
      dim = .dim1
      ap.create(dim*(dim+1)/2)
      self.compress_to_triangle(ap)
      RW.create(4*dim)
#ifdef ESSL
      call zhpev(21,ap,eigenvalues,eigenvectors,dim,dim,RW,4*dim)
#endif
      RW.destroy
      ap.destroy
   end

   solve_eigenproblem_LAPACK(eigenvalues,eigenvectors,routine) ::: private
   ! Solve the hermitian eigenvalue problem for self. LAPACK version.
      eigenvalues :: VEC{REAL}
      eigenvectors :: MAT{CPX}
      routine :: STR, optional
   ENSURE(.is_square,"non-square matrix")
   ENSURE(eigenvalues.dim>=.dim1,"supplied eigenvalue array too small")
   ENSURE(eigenvectors.dim>=self.dim,"supplied eigenvector array too small")
      rout :: STR
      ap,W :: VEC{CPX}*
      RW :: VEC{REAL}*
      dim,info :: INT
      rout = "zheev"
      if (present(routine)) rout = routine
      dim = .dim1
      select case (rout)
        case ("zheev")
          W.create(dim*dim)
          RW.create(3*dim)
          eigenvectors.set_to(self)
          info = 0
#ifndef ESSL
          call zheev("V","L",dim,eigenvectors,dim,eigenvalues,W,dim*dim,RW,info)
#endif
          RW.destroy
          W.destroy
          ENSURE(info==0,"no solution, error found, info="//trim(info.to_str))
        case ("zhpev")
          ap.create(dim*(dim+1)/2)
          self.compress_to_triangle(ap)
          W.create(2*dim)
          RW.create(3*dim)
#ifndef ESSL
          call zhpev("V","U",dim,ap,eigenvalues,eigenvectors,dim,W,RW,info)
#endif
          RW.destroy
          W.destroy
          ap.destroy
          ENSURE(info==0,"no solution, error found, info="//trim(info.to_str))
      end
   end

! These next few commented routines are unused ESSL routines.

!   solve_general_eigenproblem(eigenvalues,eigenvectors)
!   ! Solve the eigenproblem for "self", yeilding a vector of "eigenvalues" and
!   ! a matrix of "eigenvectors"
!      eigenvalues :: VEC{CPX}
!      eigenvectors :: MAT{CPX}
!       W :: VEC{REAL}*
!      dim1,dim2,dime,dimv :: INT
!      select :: BIN
!      dim1 = .dim1
!      dim2 = .dim2
!      dime = size(eigenvalues)
!      dimv = size(eigenvectors)
!      ENSURE(dim1==dim2,"non-square matrix")
!      ENSURE(dime>=dim1,"supplied eigenvalue array too small")
!      ENSURE(dimv>=dim1*dim1,"supplied eigenvector matrix too small")
!      W.create(3*dim1)
!      call zgeev(1,self,dim1,eigenvalues,eigenvectors,dim1,select,dim1,W,3*dim1)
!      W.destroy
!   end
!
!   solve_linear_equations(rhs,solution)
!   ! Solve the linear equations posed by "self", with "rhs" as the RHS vector,
!   ! yeilding vector "solution" as the answer
!      rhs, solution :: VEC{CPX}
!      err,nrhs :: INT
!      LU :: MAT{CPX}*
!      pivot :: VEC{INT}*
!      dim,dim1,dim2 :: INT
!      dim1 = .dim1
!      dim2 = .dim2
!      ENSURE(dim1==dim2,"non-square matrix")
!      dim = size(rhs)
!      ENSURE(dim==dim1,"incompatible rhs")
!      nrhs = 1
!      LU.create(dim,dim)
!      pivot.create(dim)
!      LU = self
!      solution = rhs
!      call zgef(LU,dim,dim,pivot)
!      call zges(LU,dim,dim,pivot,solution,0)
!      pivot.destroy
!      LU.destroy
!   end
!
!   solve_linear_equations(rhs,solution)
!   ! Solve the linear equations posed by "self", with "rhs" as a matrix of RHS vectors,
!   ! yeilding matrix "solution" as a matrix of solution vectors.
!      rhs, solution :: MAT{CPX}
!      err,nrhs :: INT
!      LU :: MAT{CPX}*
!      pivot :: VEC{INT}*
!      dim1,dim2 :: INT
!      dim1 = .dim1
!      dim2 = .dim2
!      ENSURE(dim1==dim2,"non-square matrix")
!      dim1 = size(rhs,1)
!      nrhs = size(rhs,2)
!      ENSURE(dim1==dim2,"rhs incompatible with coefficient matrix")
!      ENSURE(nrhs>0,"no rhs vectors")
!      LU.create(dim1,dim1)
!      pivot.create(dim1)
!      LU = self
!      solution = rhs
!      call zgef(LU,dim1,dim1,pivot)
!      call zgesm("N",LU,dim1,dim1,pivot,solution,dim1,nrhs)
!      pivot.destroy
!      LU.destroy
!   end

! **********************************************************
! Matrix functions: square roots, inverses, and exponentials
! **********************************************************

   to_sqrt_of(R)
   ! self = sqrt(R), cannot have R=self
      R :: MAT{CPX}
   ENSURE(.is_hermitian,"not hermitian")
      evec :: MAT{CPX}* DEFAULT_NULL
      eval :: VEC{REAL}* DEFAULT_NULL
      veci,vecj :: VEC{CPX}* DEFAULT_NULL
      d,i,j :: INT
      temp :: REAL
      d = R.dim1
      eval.create(d)
      evec.create(d,d)
      R.solve_eigenproblem(eval,evec)
      do i = 1,d
         temp = eval(i)
         if (temp <= ZERO) then
           WARN("non-positive eigenvalue, " // trim(temp.to_str("e15.8")))
         end
         eval(i) = sqrt(abs(temp))
      end
      do i = 1,d
        veci => evec(i,:)
        do j = 1,d
          vecj => evec(j,:)
          self(i,j) = sum(veci*eval*conjg(vecj))
        end
      end
      evec.destroy
      eval.destroy
   end

   to_inverse_sqrt_of(R,tol)
   ! self = sqrt(R)^(-1), cannot have R=self
      R :: MAT{CPX}
      tol :: REAL, optional
   ENSURE(.is_hermitian,"not hermitian")
      evec :: MAT{CPX}* DEFAULT_NULL
      eval :: VEC{REAL}* DEFAULT_NULL
      veci,vecj :: VEC{CPX}* DEFAULT_NULL
      d,i,j :: INT
      val :: STR
      eps,temp :: REAL
      eps = TOL(20)
      if (present(tol)) eps = tol
      d = R.dim1
      eval.create(d)
      evec.create(d,d)
      R.solve_eigenproblem(eval,evec)
      do i = 1,d
         temp = eval(i)
         if (temp<=ZERO) then
            val = temp.to_str("e15.8")
            WARN("non-positive eigenvalue, "// trim(val))
            temp = abs(temp)
         end
         if (temp<eps) then; eval(i) = ZERO
         else;               eval(i) = ONE/sqrt(temp)
         end
      end
      do i = 1,d
        veci => evec(i,:)
        do j = 1,d
          vecj => evec(j,:)
          self(i,j) = sum(veci*eval*conjg(vecj))
        end
      end
      evec.destroy
      eval.destroy
   end

   to_power_series_inverse_of(S,tol,max_it) ::: get_from(MAT{INTRINSIC})
   ! Set self to the power series inverse square root of "S".
   ! If "tol" is present, make sure that the maximum deviation from the exact
   ! answer is less than "tol" times the smallest element of "S". If "max_it"
   ! is present, use this as the maximum number of terms in the power series,
   ! before termination with an error.
   end

   to_power_series_inv_sqrt_of(S,tol,prefactor,max_it) ::: get_from(MAT{INTRINSIC})
   ! Set self to the inverse square root of "S", a matrix which is required to
   ! have a unit diagonal. The method uses a binomial power series expansion.
   ! If "tol" is present, make sure that the maximum deviation from the exact
   ! answer is less than "tol" times the smallest element of "S". If "max_it"
   ! is present, use this as the maximum number of terms in the power series,
   ! before termination with an error.
   end

   to_exponential_of(X,tol) ::: get_from(MAT{INTRINSIC})
   ! Exponentiate the matrix "X" using a power series expansion, self = exp(X),
   end

   exponentiate_to(U,tol) ::: get_from(MAT{INTRINSIC})
   ! Exponentiate the matrix self using a power series expansion, U = exp(self),
   ! so that the maximum deviation from the exact answer is less than "tol"
   ! if present. 
   end

   antisymmetric_exponential_to(U,eval,evec) ::: get_from(MAT{INTRINSIC})
   ! Make unitary matrix U = exp(self) where "self" must be antisymmetric.
   ! Uses the formula:  exp A = V (cos P) V^t + V (sin P)/P V^t A
   !                        P = sqrt diag(eig(A^t A))
   ! (c) dylan jayatilaka, university of western australia, 1993
   ! WARNING: Untested in TONTO and looks wrong.
   end

!  ***********************
!  Spin-orbital operations
!  ***********************

!  Block returning routines

   alpha_alpha result (res) ::: get_from(MAT{INTRINSIC})
   ! return the alpha-alpha sector of the matrix
   end

   beta_alpha result (res) ::: get_from(MAT{INTRINSIC})
   ! return the beta-alpha sector of the matrix
   end

   alpha_beta result (res) ::: get_from(MAT{INTRINSIC})
   ! return the alpha-beta sector of the matrix
   end

   beta_beta result (res) ::: get_from(MAT{INTRINSIC})
   ! return the beta-beta sector of the matrix
   end

!  Set_to routines

   alpha_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Set the alpha-alpha sector of the matrix to "X"
   end

   beta_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Set the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Set the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Set the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Set the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Set the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Set the beta-alpha sector of the matrix to "X"
   end

   alpha_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Set the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Set the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Set the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Set the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Set the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Set the alpha-beta sector of the matrix to "X"
   end

   beta_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Set the beta-beta sector of the matrix to "X"
   end

   beta_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Set the beta-beta sector of the matrix to "X"
   end

   beta_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Set the beta-beta sector of the matrix to "X"
   end

   beta_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Set the beta-beta sector of the matrix to "X"
   end

   beta_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Set the beta-beta sector of the matrix to "X"
   end

   beta_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Set the beta-beta sector of the matrix to "X"
   end

!  Put_to routines

   alpha_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Put the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Put the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Put the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Put the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Put the alpha-alpha sector of the matrix to "X"
   end

   alpha_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Put the alpha-alpha sector of the matrix to "X"
   end

   beta_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Put the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Put the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Put the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Put the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Put the beta-alpha sector of the matrix to "X"
   end

   beta_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Put the beta-alpha sector of the matrix to "X"
   end

   alpha_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Put the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Put the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Put the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Put the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Put the alpha-beta sector of the matrix to "X"
   end

   alpha_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Put the alpha-beta sector of the matrix to "X"
   end

   beta_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Put the beta-beta sector of the matrix to "X"
   end

   beta_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Put the beta-beta sector of the matrix to "X"
   end

   beta_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Put the beta-beta sector of the matrix to "X"
   end

   beta_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Put the beta-beta sector of the matrix to "X"
   end

   beta_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Put the beta-beta sector of the matrix to "X"
   end

   beta_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Put the beta-beta sector of the matrix to "X"
   end

!  plus routines

   alpha_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   alpha_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   alpha_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   alpha_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   alpha_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   alpha_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Add "X" to the alpha-alpha sector of the matrix
   end

   beta_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Add "X" to the beta-alpha sector of the matrix
   end

   beta_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Add "X" to the beta-alpha sector of the matrix
   end

   beta_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Add "X" to the beta-alpha sector of the matrix
   end

   beta_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Add "X" to the beta-alpha sector of the matrix
   end

   beta_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Add "X" to the beta-alpha sector of the matrix
   end

   beta_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Add "X" to the beta-alpha sector of the matrix
   end

   alpha_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Add "X" to the alpha-beta sector of the matrix
   end

   alpha_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Add "X" to the alpha-beta sector of the matrix
   end

   alpha_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Add "X" to the alpha-beta sector of the matrix
   end

   alpha_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Add "X" to the alpha-beta sector of the matrix
   end

   alpha_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Add "X" to the alpha-beta sector of the matrix
   end

   alpha_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Add "X" to the alpha-beta sector of the matrix
   end

   beta_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Add "X" to the beta-beta sector of the matrix
   end

   beta_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Add "X" to the beta-beta sector of the matrix
   end

   beta_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Add "X" to the beta-beta sector of the matrix
   end

   beta_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Add "X" to the beta-beta sector of the matrix
   end

   beta_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Add "X" to the beta-beta sector of the matrix
   end

   beta_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Add "X" to the beta-beta sector of the matrix
   end

end
