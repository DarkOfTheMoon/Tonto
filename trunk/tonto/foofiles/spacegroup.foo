! $Id$
!-------------------------------------------------------------------------------
!
! SPACEGROUP: Crystal space group object
!
! Synopsis
!
! Read in the international symmetry symbol or Hall symbol and make the Seitz 
! matrices for a particular spacegroup. Provide other crystal symmetry 
! information as well. Use the method in: 
! S. R. Hall, Acta Cryst. A37, 517 (1981)
!
! S K Wolff (1st version)
! D Jayatilaka (2nd & 3rd versions)
! D Jayatilaka (4th version)
!
!-------------------------------------------------------------------------------
module SPACEGROUP

   use TYPES
   use ERROR
   use MM
   use STR
   use INPUT
   use OUTPUT
   use INT
   use MAT
   use MAT3

   implicit none

#  include "macros"
#  include "spacegroup.int"

!  type spacegroup_type
!     STR :: IT_symbol              ! International Table (Hermann-Maguin) symmetry symbol
!     INT :: IT_group_number        ! International tables group number
!     STR :: Hall_symbol            ! Hall notation symbol
!     CHR :: lattice_symbol         ! Lattice symmetry symbol
!     STR :: lattice_type           ! Lattice type
!     BIN :: centrosymmetric        ! True if center of symmetry present
!     INT :: order(3)               ! Order of each crystal axis
!     INT :: setting_index(3)       ! Indicates axes of rotation corresponding to x, y, or z, etc.
!     BIN :: has_bar(3)             ! True if bar for this axis
!     BIN :: has_subscript(3)       ! True if subscript present for this axis
!     CHR :: setting_symbol(3)      ! Superscript rotation axis symbols axis
!     CHR :: subscript(3,3)         ! Subscript translations symbols for each axis
!     INT :: lattice_symbol_index   ! Lattice symbol index number
!     INT :: nL                     ! No. of translational lattice generators
!     INT :: nR                     ! No. of rotation generators
!     INT :: nG                     ! No. of generators
!     INT :: n_seitz                ! No. of Seitz matrices
!     MAT3, PTR :: seitz            ! Seitz matrices (these are the transpose of the seitz matrices in Hall's paper)
!     VEC(3) :: position            ! Fractional unit cell position used to reduce the spacegroup symmetry
!     MAT, PTR ::  symop_pos        ! List of Equivalent positions generated by seitx matrices
!     MAT3, PTR :: symop_mat        ! Corresponding symmetry matrix used to generate symop_pos
!     INT :: n_symop                ! No. of equivalent positions 
!     INT :: n_unique               ! No. of equivalent positions unrelated by traslation or inversion
!     IVEC, PTR :: unique_symop     ! Index of unique symops not related by translation or inversion
!     IVEC, PTR :: map_to_unique    ! Maps symop to a unique symop. Negative indicates inversion.
!  end

   ! Symbols used in the Hall space group notation
   STR :: cbar    = "^"             ! Bar symbol, precedes axis orders
   STR :: csub    = "_"             ! Subscript symbol, comes after axis order and setting symbol (if any)
   STR :: cnum    = "1234#6"        ! Symmetry axis orders
   STR :: cdash   = "'"             ! 
   STR :: cddash  = '"'             ! 
   STR :: cstar   = '*'             ! 
   STR :: caxis   = "xyz""'*"       ! Axis setting symbols
   STR :: clat    = "PABCIRF"       ! Allowed lattice symbols
   STR :: ctran   = "abcnuvwd"      ! Allowed alphabetical translation subscripts
   STR :: csn     = "12345"         ! Allowed numerical translation subscripts

   MAT(3,3) :: e = reshape((/ONE,ZERO,ZERO,ZERO,ONE,ZERO,ZERO,ZERO,ONE/),(/3,3/)) ! Unit matrix

   MAT3(3,4,7) :: tL    ! Implied lattice translations; see set_tL
   MAT(3,8) :: tS       ! Alphabetical translations;    see set_tS
   MAT4(3,3,6,6) :: rx  ! Rotation matrices ; see set_rx
   CHR(11), dimension(2,230) :: Hall_conversion_table ! International notation <--> Hall notation

contains

   create
   ! Create a spacegroup
      PTR :: self
      allocate(self)
      std_mm.add(SPACEGROUP_SIZE)
      .nullify_ptr_part
      .set_Hall_conversion_table
   end

   destroy 
   ! Destroy a spacegroup
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      std_mm.delete(SPACEGROUP_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of spacegroup
      nullify(.seitz)
      nullify(.symop_pos)
      nullify(.symop_mat)
      nullify(.unique_symop)
      nullify(.map_to_unique)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of spacegroup
      .seitz.destroy
      .symop_pos.destroy
      .symop_mat.destroy
      .unique_symop.destroy
      .map_to_unique.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_default
   ! Set default spacegroup
      .set_IT_symbol("P1")
      .analyse
   end
   
   set_IT_symbol(sym)
   ! Set the international table symbol
      CHR(*) :: sym
      .IT_symbol = sym
   end

   read(in) [leaky]
   ! Read in the spacegroup data from file "in"
      INPUT :: in
      STR :: word
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("end");              exit read_loop
            case("it_symbol");        .read_IT_symbol(in)
            case("hall_symbol");      .read_Hall_symbol(in)
            case("special_position"); .read_position(in)
            case("origin");           .read_position(in)
         end 
      end do read_loop
   end

   read_IT_symbol(in) [leaky]
   ! Read the internation table symbol and analyse the spacegroup
      INPUT :: in
      STR :: word
      in.read(word)
      .set_IT_symbol(word)
      .get_Hall_symbol    
      .analyse
   end

   read_Hall_symbol(in) [leaky]
   ! Read the Hall symbol and analyse the spacegroup
      INPUT :: in
      in.read( .Hall_symbol )
      .set_IT_symbol("?????")
      .IT_group_number = 0
      .analyse
   end

   read_position(in) [leaky]
   ! Read a special position to reduce the spacegroup, in fractional coordinates
      INPUT :: in
      VEC(3) :: position
      in.read(position)
      .reduce(position)
   end

   analyse [leaky]
      .destroy_ptr_part
      .analyse_Hall_symbol
      .get_lattice_type
      .get_axis_setting
      .get_group_sizes
      .seitz.create(4,4,.n_seitz)
      .seitz = ZERO
      .set_tL
      .form_L_seitz
      .set_tS
      .set_rx
      .form_S_seitz
      .generate_seitz
   end

   get_Hall_symbol
      BIN :: found
      INT :: i
      found = FALSE
      do i = 1,230
         if (.IT_symbol==Hall_conversion_table(1,i)) then
            .Hall_symbol = Hall_conversion_table(2,i)
            .IT_group_number = i
            found = TRUE
            exit
         end
      end
      DIE_IF(NOT found,"unknown space group " // .IT_symbol.trim)
   end

   analyse_Hall_symbol
   ! Analyse the Hall notation symbol for the spacegroup
      STR :: Hall_symbol
      INT :: axis,i
      Hall_symbol = .Hall_symbol
      if (Hall_symbol(1:1)==cbar) then               ! Look for Bar symbol cbar = "^"
         .centrosymmetric = TRUE
         Hall_symbol = Hall_symbol(2:)
      else
         .centrosymmetric = FALSE
      end
      if (clat.includes(Hall_symbol(1:1))) then      ! check for lattice symbols clat = P,A,B,C,I,R,F
         .lattice_symbol = Hall_symbol(1:1)
         .lattice_symbol_index = clat.index_of_substring(Hall_symbol(1:1))
         Hall_symbol = Hall_symbol(2:)
      else
         DIE("unknown lattice symbol")
      end
      .has_bar         = FALSE
      .order      = 1
      .setting_symbol = "_"
      .setting_index  = 0
      .has_subscript   = FALSE
      .subscript  = "_"
      do axis = 1,3                                  ! Loop over crystal axis directions 
         if (Hall_symbol(1:1)==cbar) then            ! Check for bar symbol
            .has_bar(axis) = TRUE
            Hall_symbol = Hall_symbol(2:)
         end
         if (cnum.includes(Hall_symbol(1:1))) then   ! Check for axis order
            .order(axis) = cnum.index_of_substring(Hall_symbol(1:1))
            Hall_symbol = Hall_symbol(2:)
         else if (.has_bar(axis)) then
            DIE("no rotation axis after bar symbol")
         else if (axis==1) then
            DIE("at least one axis order is required")
         end
         if (caxis.includes(Hall_symbol(1:1))) then  ! Check for axis setting symbols
            .setting_symbol(axis) = Hall_symbol(1:1)
            .setting_index(axis) = caxis.index_of_substring(Hall_symbol(1:1))
            Hall_symbol = Hall_symbol(2:)
            if((.setting_symbol(axis)==cdash OR .setting_symbol(axis)==cddash) AND &
               (.order(axis)/=2 OR axis==1)) &
            DIE("impossible axis setting")
            if(.setting_symbol(axis)==cstar AND .order(axis)/=3) &
            DIE("impossible axis setting")
         end
         if (Hall_symbol(1:1)==csub) then            ! Check for subscripts, signified by csub = "_"
            .has_subscript(axis) = TRUE
            Hall_symbol = Hall_symbol(2:)
            do i = 1,3
               if (csn.includes(Hall_symbol(1:1)) AND i==1) then
                  .subscript(i,axis) = Hall_symbol(1:1)
                  Hall_symbol = Hall_symbol(2:)
               else if (ctran.includes(Hall_symbol(1:1))) then
                  .subscript(i,axis) = Hall_symbol(1:1)
                  Hall_symbol = Hall_symbol(2:)
               end
            end
         end
         if (Hall_symbol==" ") exit
      end 
   end

   get_lattice_type
      if (.order(1)==1) then
         .lattice_type = "Triclinic"
      else if (.order(1)==2 AND .order(2)==1) then
         .lattice_type = "Monoclinic"
      else if (.order(1)==2 AND .order(2)==2) then
         .lattice_type = "Orthorhombic"
      else if (.order(1)==4 AND .order(3)/=3) then
         .lattice_type = "Tetragonal"
      else if (.order(1)==3) then
         .lattice_type = "Trigonal"
      else if (.order(1)==6) then
         .lattice_type = "Hexagonal"
      else if (.order(3)==3) then
         .lattice_type = "Cubic"
      end
   end

   get_axis_setting
      INT :: axis
   ! For a partiular axis i,
   ! .setting_index(i) = 1,2,3  means a,b,c
   ! .setting_index(i) = 4      means a+b or "
   ! .setting_index(i) = 5      means a-b or ' 
   ! .setting_index(i) = 6      means a+b+c or * 
      if (.setting_index(1)==0) then
         .setting_symbol(1) = "z"
         .setting_index(1)  = 3
      end
      do axis = 2,3
         if (.setting_index(axis)==0) then
            if (.order(axis)==2) then
               if (.order(axis-1)==2 OR .order(axis-1)==4) then
                  .setting_symbol(axis) = "x"
                  .setting_index(axis)  = 1
               else if (.order(axis-1)==3 OR .order(axis-1)==6) then
                  .setting_symbol(axis) = cdash
                  .setting_index(axis)  = 5
               end
            else if (.order(axis)==3) then
                  .setting_symbol(axis) = cstar
                  .setting_index(axis)  = 6
            end
         end
      end
   end

   get_group_sizes
      INT :: axis
      select case (.lattice_symbol)
         case("P"); .nL = 1  
         case("A"); .nL = 2  
         case("B"); .nL = 2  
         case("C"); .nL = 2  
         case("I"); .nL = 2  
         case("R"); .nL = 3  
         case("F"); .nL = 4  
      end
      if (.centrosymmetric) .nL = 2*.nL   ! No. of translations
      .n_seitz = .nL*product(.order) ! No. of seitz matrices
      .nG = .nL                           ! No. of generators
      do axis = 1,3
         if (.order(axis)>1) .nG = .nG+1
      end
   end

   form_L_seitz
   ! Form the seitz generators corresponding to the lattice symbol L
      INT :: n,v
      n = .nL
      if (.centrosymmetric) n = .nL/2
      do v = 1,n
         .seitz(1:3,1:3,v)   = e
         .seitz(4  ,1:3,v)   = tL(1:3,v,.lattice_symbol_index)
         .seitz(1:3,  4,v)   = ZERO
         .seitz(4  ,  4,v)   = ONE
      end
      if (NOT .centrosymmetric) return
      do v = 1,n
         .seitz(1:3,1:3,n+v) = -e
         .seitz(4  ,1:3,n+v) = tL(1:3,v,.lattice_symbol_index)
         .seitz(1:3,  4,n+v) = ZERO
         .seitz(4  ,  4,n+v) = ONE
      end
   end

   set_tL
   ! tL(:,v,L) = implied lattice translation vector
   ! L         = lattice symbol index number
   ! v         = translation vector index
      tL(:,1,1) = (/ZERO,ZERO,ZERO/)
      tL(:,1,2) = (/ZERO,ZERO,ZERO/) ; tL(:,2,2) = (/ZERO,HALF,HALF/)
      tL(:,1,3) = (/ZERO,ZERO,ZERO/) ; tL(:,2,3) = (/HALF,ZERO,HALF/)
      tL(:,1,4) = (/ZERO,ZERO,ZERO/) ; tL(:,2,4) = (/HALF,HALF,ZERO/)
      tL(:,1,5) = (/ZERO,ZERO,ZERO/) ; tL(:,2,5) = (/HALF,HALF,HALF/)
      tL(:,1,6) = (/ZERO,ZERO,ZERO/) 
      tL(:,2,6) = (/ ONE, TWO, TWO/)/THREE
      tL(:,3,6) = (/ TWO, ONE, ONE/)/THREE
      tL(:,1,7) = (/ZERO,ZERO,ZERO/)
      tL(:,2,7) = (/ZERO,HALF,HALF/)
      tL(:,3,7) = (/HALF,ZERO,HALF/)
      tL(:,4,7) = (/HALF,HALF,ZERO/)
   end

   form_S_seitz
   ! Add the rotational seitz matrices to the generator list
      VEC(3) :: t
      INT :: axis,N,i,v,ax,isign
      .nR = 0
      do axis = 1,3
         N  = .order(axis)
         ax = .setting_index(axis)
         if (N<=1) then 
            cycle
         end
         t(:) = ZERO
         if (.has_subscript(axis)) then
            do i = 1,3
               v = ctran.index_of_substring( .subscript(i,axis))
               if (v/=0) then
                  t(:) = t(:) + tS(:,v)
               end
               v = csn.index_of_substring( .subscript(i,axis))
               if (v/=0 AND i==1) then
                  t(ax) = t(ax) + v/N
               end
            end
         end 
         if (ax==4 OR ax==5) then
            N = .setting_index(axis-1) ! setting of previous rotor symbol
            ! see syd !!!
            DIE_IF(N>3,"dont know how to set rotation matrix")
         end
         isign = 1
         if (.has_bar(axis)) then
            isign = -1
         end
         ! Add the generators to the list here 
         .nR = .nR + 1
         .seitz(1:3,1:3,.nL+.nR) = isign*rx(:,:,ax,N)
         .seitz(4  ,1:3,.nL+.nR) = t(:)
         .seitz(1:3,  4,.nL+.nR) = ZERO
         .seitz(4  ,  4,.nL+.nR) = ONE
      end 
   end

  set_Hall_conversion_table
  ! Set the global constant Hall_conversion_table.
  ! This is in a routine because it takes too many lines for the NAG compiler to
  ! read it all at once.
    Hall_conversion_table(:,1:15) = reshape( (/ &         ! Triclinic
    "P1         ","P1         ",      "P^1        ","P1         ",           "P2         ","P2         ", &
    "P2_1       ","P2_b       ",      "A2         ","A2         ",           "Pm         ","P^2        ", &
    "Pa         ","P^2_a      ",      "Am         ","A^2        ",           "Aa         ","A^2_a      ", &
    "P2/m       ","^P2        ",      "P2_1/m     ","^P2_b      ",           "C2/m       ","^C2        ", &
    "P2/a       ","^P2_a      ",      "P2_1/c     ","^P2_ab     ",           "A2/a       ","^A2_a      "/), &
    (/2,15/))

    Hall_conversion_table(:,16:74) = reshape( (/ &         ! Orthorhombic
    "P222       ","P22        ",      "P222_1     ","P2_c2      ",           "P2_12_12   ","P22_ab     ", &
    "P2_12_12_1 ","P2_ac2_ab  ",      "C222_1     ","C2_c2      ",           "C222       ","C22        ", &
    "F222       ","F22        ",      "I222       ","I22        ",           "I2_12_12_1 ","I2_ac2_ab  ", &
    "Pmm2       ","P2^2       ",      "Pmc2_1     ","P2_c^2     ",           "Pcc2       ","P2^2_c     ", &
    "Pma2       ","P2^2_a     ",      "Pca2_1     ","P2_c^2_ac  ",           "Pnc2       ","P2^2bc     ", &
    "Pmn2_1     ","P2_ac^2    ",      "Pba2       ","P2^2_ab    ",           "Pna2_1     ","P2_c^2_n   ", &
    "Pnn2       ","P2^2_n     ",      "Cmm2       ","C2^2       ",           "Cmc2_1     ","C2_c^2     ", &
    "Ccc2       ","C2^2_c     ",      "Amm2       ","A2^2       ",           "Abm2       ","A2^2_b     ", &
    "Ama2       ","A2^2_a     ",      "Aba2       ","A2^2_ab    ",           "Fmm2       ","F2^2       ", &
    "Fdd2       ","F2^2_d     ",      "Imm2       ","I2^2       ",           "Iba2       ","I2^2_c     ", &
    "Ima2       ","I2^2_a     ",      "Pmmm       ","^P22       ",           "Pnnn       ","^P2_ab2_bc ", &
    "Pccm       ","^P22_c     ",      "Pban       ","^P2_ab2_b  ",           "Pmma       ","^P2_a2_a   ", &
    "Pnna       ","^P2_a2_bc  ",      "Pmna       ","^P2ac2     ",           "Pcca       ","^P2_a2_ac  ", &
    "Pbam       ","^P22_ab    ",      "Pccn       ","^P2_ab2_ac ",           "Pbcm       ","^P2_c2_b   ", &
    "Pnnm       ","^P22_n     ",      "Pmmn       ","^P2_ab2_a  ",           "Pbcn       ","^P2_n2_ab  ", &
    "Pbca       ","^P2_ac2_ab ",      "Pnma       ","^P2_ac2_n  ",           "Cmcm       ","^C2_c2     ", &
    "Cmca       ","^C2_bc2    ",      "Cmmm       ","^C22       ",           "Cccm       ","^C22_c     ", &
    "Cmma       ","^C2_a2     ",      "Ccca       ","^C2_b2_ac  ",           "Fmmm       ","^F22       ", &
    "Fddd       ","^F2_uv2_vw ",      "Immm       ","^I22       ",           "Ibam       ","^I22_c     ", &
    "Ibca       ","^I2_b2_c   ",      "Imma       ","^I2_b2     "/),         (/2,59/))

    Hall_conversion_table(:,75:142) = reshape( (/ &         ! Tetragonal
    "P4         ","P4         ",      "P4_1       ","P4_1       ",           "P4_2       ","P4_c       ", &
    "P4_3       ","P4_3       ",      "I4         ","I4         ",           "I4_1       ","I4_1b      ", &
    "P^4        ","P^4        ",      "I^4        ","I^4        ",           "P4/m       ","^P4        ", &
    "P4_2/m     ","^P4_c      ",      "P4/n       ","^P4_a      ",           "P4_2/n     ","^P4_bc     ", &
    "I4/m       ","^I4        ",      "I4_1/a     ","^I4_ad     ",           "P422       ","P42        ", &
    "P42_12     ","P4_ab2_ab  ",      "P4_122     ","P4_12_c    ",           "P4_12_12   ","P4_3n2_nw  ", &
    "P4_222     ","P4_c2      ",      "P4_22_12   ","P4_n2_n    ",           "P4_322     ","P4_32_c    ", &
    "P4_32_12   ","P4_1n2_abw ",      "I422       ","I42        ",           "I4_122     ","I4_1b2_bw  ", &
    "P4mm       ","P4^2       ",      "P4bm       ","P4^2_ab    ",           "P4_2cm     ","P4_c^2_c   ", &
    "P4_2nm     ","P4_n^2_n   ",      "P4cc       ","P4^2_c     ",           "P4nc       ","P4^2_n     ", &
    "P4_2mc     ","P4_c^2     ",      "P4_2bc     ","P4_c^2_ab  ",           "I4mm       ","I4^2       ", &
    "I4cm       ","I4^2_ab    ",      "I4_1md     ","I4_1b^2    ",           "I4_1cd     ","I4_1b^2c   ", &
    "P^42m      ","P^42       ",      "P^42c      ","P^42_c     ",           "P^42_1m    ","P^42_ab    ", &
    "P^42_1c    ","P^42_n     ",      "P^4m2      ","P^4^2      ",           "P^4c2      ","P^4^2_c    ", &
    "P^4b2      ","P^4^2_ab   ",      "P^4n2      ","P^4^2_n    ",           "I^4m2      ","I^4^2      ", &
    "I^4c2      ","I^4^2_c    ",      "I^42m      ","I^42       ",           "I^42d      ","I^42_bw    ", &
    "P4/mmm     ","^P42       ",      "P4mcc      ","^P42_c     ",           "P4/nbm     ","^P4_a2_b   ", &
    "P4/nnc     ","^P4_a2_bc  ",      "P4/mbm     ","^P42_ab    ",           "P4/mnc     ","^P42_n     ", &
    "P4/nmm     ","^P4_a2_a   ",      "P4/ncc     ","^P4_a2_ac  ",           "P4_2/mmc   ","^P4_c2     ", &
    "P4_2/mcm   ","^P4_c2_c   ",      "P4_2/nbc   ","^P4_ac2_b  ",           "P4_2/nnm   ","^P4_ac2_bc ", &
    "P4_2/mbc   ","^P4_c2_ab  ",      "P4_2/mnm   ","^P4_n2_n   ",           "P4_2nmc    ","^P4_ac2_a  ", &
    "P4_2/ncm   ","^P4_ac2_ac ",      "I4/mmm     ","^I42       ",           "I4/mcm     ","^I42_c     ", &
    "I4_1/amd   ","^I4_bd2    ",      "I4_1/acd   ","^I4bd2_c   "/),         (/2,68/))

   Hall_conversion_table(:,143:167) = reshape( (/ &         ! Trigonal
     'P3         ','P3         ',      'P3_1       ','P3_1       ',           'P3_2       ','P3_2       ', &
     'R3         ','R3         ',      'P^3        ','P^3        ',           'R^3        ','^R3        ', &
     'P312       ','P32        ',      'P321       ','P32"       ',           'P3_112     ','P3_12      ', &
     'P3_121     ','P3_12      ',      'P3_212     ','P3_22      ',           'P3_21      ','P3_22"     ', &
     'R32        ','R32"       ',      'P3m1       ','P3^2"      ',           'P31m       ','P3^2       ', &
     'P3c1       ','P3^2"_c    ',      'P31c       ','P3^2_c     ',           'R3m        ','R3^2"      ', &
     'R3c        ','R3^2"_c    ',      'P^31m      ','^P32       ',           'P^31c      ','^P32_c     ', &
     'P^3m1      ','^P32"      ',      'P^3c1      ','^P32"_c    ',           'R^3m       ','^R32"      ', &
     'R^3c       ','^R32"_c    '/),    (/2,25/))

   Hall_conversion_table(:,168:194) = reshape( (/ &         ! Hexagonal
     "P6         ","P6         ",      "P6_1       ","P6_1       ",           "P6_5       ","P6_5       ", &
     "P6_2       ","P6_2       ",      "P6_4       ","P6_4       ",           "P6_3       ","P6_c       ", &
     "P^6        ","P^6        ",      "P6/m       ","^P6        ",           "P6_3/m     ","^P6_c      ", &
     "P622       ","P62        ",      "P6_122     ","P6_12      ",           "P6_522     ","P6_52      ", &
     "P6_222     ","P6_22      ",      "P6_422     ","P6_42      ",           "P6_322     ","P6_c2      ", &
     "P6mm       ","P6^2       ",      "P6cc       ","P6^2_c     ",           "P6_3cm     ","P6_c^2     ", &
     "P6_3mc     ","P6_c^2_c   ",      "P^6m2      ","P^62       ",           "P^6c2      ","P^6_c2     ", &
     "P^62m      ","P^6^2      ",      "P^62_c     ","P^6_c^2_c  ",           "P6/mmm     ","^P62       ", &
     "P6/mcc     ","^P62_c     ",      "P6_3/mcm   ","^P6_c2     ",           "P6_3/mmc   ","^P6_c2_c   "/), &
     (/2,27/))

   Hall_conversion_table(:,195:230) = reshape( (/ &         ! Cubic
     "P23        ","P223       ",      "F23        ","F223       ",           "I23        ","I223       ", &
     "P2_13      ","P2_ac2_ab3 ",      "I2_13      ","I2_ac2_ab3 ",           "Pm3        ","^P223      ", &
     "Pn3        ","^P2_ab2_bc3",      "Fm3        ","^F223      ",           "Fd3        ","^F2_uv2_vw3", &
     "Im3        ","^I223      ",      "Pa3        ","^P2_ac2_ab3",           "Ia3        ","^I2_ac2_ab3", &
     "P432       ","P423       ",      "P4_232     ","P4_n23     ",           "F432       ","F423       ", &
     "F4_132     ","F4_d23     ",      "I432       ","I423       ",           "P4_332     ","P4_bdn2_ab3", &
     "P4_132     ","P4_bd2_ab3 ",      "I4_132     ","I4_bd2_ab3 ",           "P^43m      ","P^423      ", &
     "F^43m      ","F^423      ",      "I^43m      ","I^423      ",           "P^43n      ","P^4_n23    ", &
     "F^43c      ","F^4_c23    ",      "I^43d      ","I^4_bd2_ab3",           "Pm3m       ","^P423      ", &
     "Pn3n       ","^P4_a2bc3  ",      "Pm3n       ","^P4_n23    ",           "Pn3m       ","^P4_bc2_bc3", &
     "Fm3m       ","^F423      ",      "Fm3c       ","^F4_n23    ",           "Fd3m       ","^F4_vw2_vw3", &
     "Fd3c       ","^F4_ud2_vw3",      "Im3m       ","^I423      ",           "Ia3d       ","^I4bd2ab3  "/), &
     (/2,36/))
  end

   set_rx
      rx(:,:,1,1) = e                                             ! Unit matrix
      rx(:,:,1,2) = reshape( (/ 1, 0, 0, 0,-1, 0, 0, 0,-1/), (/3,3/)) ! 2-fold rotation about a
      rx(:,:,2,2) = reshape( (/-1, 0, 0, 0, 1, 0, 0, 0,-1/), (/3,3/)) ! 2-fold rotation about b
      rx(:,:,3,2) = reshape( (/-1, 0, 0, 0,-1, 0, 0, 0, 1/), (/3,3/)) ! 2-fold rotation about c
      rx(:,:,1,3) = reshape( (/ 1, 0, 0, 0, 0,-1, 0, 1,-1/), (/3,3/)) ! 3-fold rotation about a
      rx(:,:,2,3) = reshape( (/-1, 0, 1, 0, 1, 0,-1, 0, 0/), (/3,3/)) ! 3-fold rotation about b
      rx(:,:,3,3) = reshape( (/ 0,-1, 0, 1,-1, 0, 0, 0, 1/), (/3,3/)) ! 3-fold rotation about c
      rx(:,:,1,4) = reshape( (/ 1, 0, 0, 0, 0,-1, 0, 1, 0/), (/3,3/)) ! 4-fold rotation about a
      rx(:,:,2,4) = reshape( (/ 0, 0, 1, 0, 1, 0,-1, 0, 0/), (/3,3/)) ! 4-fold rotation about b
      rx(:,:,3,4) = reshape( (/ 0,-1, 0, 1, 0, 0, 0, 0, 1/), (/3,3/)) ! 4-fold rotation about c
      rx(:,:,1,6) = reshape( (/ 1, 0, 0, 0, 1,-1, 0, 1, 0/), (/3,3/)) ! 6-fold rotation about a
      rx(:,:,2,6) = reshape( (/ 0, 0, 1, 0, 1, 0,-1, 0, 1/), (/3,3/)) ! 6-fold rotation about b
      rx(:,:,3,6) = reshape( (/ 1,-1, 0, 1, 0, 0, 0, 0, 1/), (/3,3/)) ! 6-fold rotation about c
    ! 2-fold rotations off axis
      rx(:,:,5,1) = reshape( (/-1, 0, 0, 0, 0,-1, 0,-1, 0/), (/3,3/)) ! 2-fold rotation about b-c, preceded by Nx
      rx(:,:,4,1) = reshape( (/-1, 0, 0, 0, 0, 1, 0, 1, 0/), (/3,3/)) ! 2-fold rotation about b+c
      rx(:,:,5,2) = reshape( (/ 0, 0,-1, 0,-1, 0,-1, 0, 0/), (/3,3/)) ! 2-fold rotation about a-c, preceded by Ny
      rx(:,:,4,2) = reshape( (/ 0, 0, 1, 0,-1, 0, 1, 0, 0/), (/3,3/)) ! 2-fold rotation about a+c
      rx(:,:,5,3) = reshape( (/ 0,-1, 0,-1, 0, 0, 0, 0,-1/), (/3,3/)) ! 2-fold rotation about a-b, preceded by Nz
      rx(:,:,4,3) = reshape( (/ 0, 1, 0, 1, 0, 0, 0, 0, 1/), (/3,3/)) ! 2-fold rotation about a+b
    ! 3-fold rotations off axis
      rx(:,:,6,3) = reshape( (/ 0, 0, 1, 1, 0, 0, 0, 1, 0/), (/3,3/)) ! 3-fold rotation about a+b+c
   end

   set_tS
   ! tS(:,v) = alphabetical subscript translation vector
   ! v = alphabetical index number
      tS(:,1) = (/HALF,ZERO,ZERO/)
      tS(:,2) = (/ZERO,HALF,ZERO/)
      tS(:,3) = (/ZERO,ZERO,HALF/)
      tS(:,4) = (/HALF,HALF,HALF/)
      tS(:,5) = HALF*tS(:,1)
      tS(:,6) = HALF*tS(:,2)
      tS(:,7) = HALF*tS(:,3)
      tS(:,8) = HALF*tS(:,4)
   end

   generate_seitz
      INT :: m,i,j,k
      BIN :: equal
      m = .nG
      if (m==.n_seitz) return
      i = 1
      main: do
         i = i+1
         j = 1
         pair_products: do
            j = j+1
            .seitz(:,:,m+1) = matmul(.seitz(:,:,j),.seitz(:,:,i))
            .seitz(4,1,m+1) = mod(.seitz(4,1,m+1)+TWO,ONE)
            .seitz(4,2,m+1) = mod(.seitz(4,2,m+1)+TWO,ONE)
            .seitz(4,3,m+1) = mod(.seitz(4,3,m+1)+TWO,ONE)
            do k = 1,m
               equal = .seitz(:,:,m+1).same_as(.seitz(:,:,k))
               if (equal) exit 
            end
            if (NOT equal) m = m+1
            if (m==.n_seitz) exit main
            if (j==m)        exit pair_products
         end do pair_products
         if (i==m) exit main
      end do main
   end

   reduce(position) [leaky]
   ! From the Seitz matrices work out the equivalent "positions" and reduced
   ! symmetry matrices corresponding to these positions. ALso work out whether
   ! these reduced symmetry matrices are related by translation or inversion.
      VEC(3) :: position
      VEC(4) :: v,pos_tmp
      MAT, PTR :: pos
      IVEC, PTR :: index
      BIN :: same,inverted
      INT :: i,j,n
      ENSURE( .seitz.created, "Seitz matrices not initialised")
      pos.create(3,.n_seitz)            
      .position = position
      v(1:3) = position        ! Determine list of equivalent positions
      v(4)   = ONE
      do i=1,.n_seitz
         pos_tmp  = matmul(v,.seitz(:,:,i))
         pos(:,i) = pos_tmp(1:3)
         pos(:,i) = mod(pos(:,i)+TWO,ONE)        
      end 
      index.create(.n_seitz)   ! Determine unique list of positions and rotation matrices
      n = 0
      do i = 1,.n_seitz
         same = FALSE
         do j = 1,n
            same = pos(:,index(j)).same_as(pos(:,i))
            if (same) exit
         end 
         if (NOT same) then
           n = n+1
           index(n) = i
         end
      end 
      .n_symop = n
      .symop_pos.create(3,.n_symop)
      .symop_mat.create(3,3,.n_symop)
      do i = 1,.n_symop
         .symop_pos(:,i) = pos(:,index(i))
         .symop_mat(:,:,i) = .seitz(1:3,1:3,index(i))
      end
      index.destroy
      pos.destroy
      index.create(.n_symop)
      .map_to_unique.create(.n_symop)
      n = 0
      do i=1,.n_symop                          ! Are any rotation matrices the same or inverted?
         same = FALSE
         inverted = FALSE
         do j = 1,n
            same     = .symop_mat(:,:,index(j)).same_as(  .symop_mat(:,:,i))
            inverted = .symop_mat(:,:,index(j)).same_as( -.symop_mat(:,:,i))
            if (same OR inverted) exit
         end
         if (same) then
            .map_to_unique(i) =  j             ! positive for translation
         else if (inverted) then
            .map_to_unique(i) = -j             ! negative for inversion
         else
             n = n+1
             index(n) = i                      ! index of the nth unique symop
            .map_to_unique(i) = n              ! new nth unique symop
         end
      end
      .n_unique = n
      .unique_symop.create(.n_unique)
      do i = 1,.n_unique
         .unique_symop(i) = index(i)
      end
      index.destroy
   end

   unique_symop_mat(n) result (res)
   ! Return the n-th unique symop matrix in the reduced spacegroup
      INT :: n
      MAT(3,3) :: res
      res = .symop_mat(:,:,.unique_symop(n))
   end

   put(out)
   ! Put out the spacegroup information
      OUTPUT :: out
      INT :: n,order,setting_indices
      STR :: setting_symbol,subscripts
      out.flush
      out.put_text("SPACEGROUP output:",flush=2)
      out.put_text("Information about crystal cell symmetry",flush=2)
      out.show("IT symbol              = ",trim(.IT_symbol))
      out.show("Hall symbol            = ",trim(.Hall_symbol))
      out.show("International table No = ",.IT_group_number,dbl_width=TRUE)
      out.show("Lattice symbol         = ",trim(.lattice_symbol))
      out.show("Lattice type           = ",trim(.lattice_type))
      out.show("Order (n_seitz)        = ",.n_seitz,dbl_width=TRUE)
      out.show("Centro-symmetric?      = ",.centrosymmetric,dbl_width=TRUE)

      order = 100*.order(1) + 10*.order(2) + .order(3)
      setting_symbol = .setting_symbol(1) // .setting_symbol(2) // .setting_symbol(3) 
      setting_indices = 100*.setting_index(1) + 10*.setting_index(2) + .setting_index(3)
      subscripts = &
         .subscript(1,1) // .subscript(2,1) // .subscript(3,1) // " " // &
         .subscript(1,2) // .subscript(2,2) // .subscript(3,2) // " " // &
         .subscript(1,3) // .subscript(2,3) // .subscript(3,3) 
      out.show("Axis orders            = ", order,dbl_width=TRUE)
      out.show("Setting symbols        = ", setting_symbol)
      out.show("Setting indices        = ", setting_indices,dbl_width=TRUE)
      out.show("Translation subscripts = ", subscripts)
      out.show("No of L generators     = ",.nL,dbl_width=TRUE)
      out.show("No of R generators     = ",.nR,dbl_width=TRUE)
      out.show("No of generators       = ",.nG,dbl_width=TRUE)
      out.flush
      out.text("Seitz matrices :")
      do n = 1,.n_seitz
        out.flush
        out.show("n = ",n)
        out.put(.seitz(:,:,n))
      end
      if (associated(.symop_pos)) .put_reduced_group(out)
   end

  put_reduced_group(out)
    OUTPUT :: out
    INT :: n,k,nu
    out.flush
    out.put_text("SPACEGROUP reduced group output:",flush=2)
    out.show("Reducing position = ",.position(1),.position(2),.position(3))
    out.show("Order             = ",.n_symop)
    out.flush
    out.dash(int_fields=1,dbl_fields=4)
    out.put("Pos", int_width=TRUE)
    out.put("x")
    out.put("y")
    out.put("z")
    out.put("Position type")
    out.flush
    out.dash(int_fields=1,dbl_fields=4)
    k = 1
    do n = 1,.n_symop
      out.put(n)
      out.put(.symop_pos(1,n))
      out.put(.symop_pos(2,n))
      out.put(.symop_pos(3,n))
      nu = .map_to_unique(n)
      if (nu==k) then
        out.put("Unique position",flush=1)
        k = k+1
      else if (nu<0) then
        out.put("Inversion of position "// abs(nu).to_str.trim,flush=1)
      else
        out.put("Translation of position "// nu.to_str.trim,flush=1)
      end
    end
    out.dash(int_fields=1,dbl_fields=4)
  end

   test
      OUTPUT, PTR :: out
      out.create("spacegroup.out")
      out.open
      .set_IT_symbol("P6.3/mmc")
      out.flush
      out.put_text(">>> Memory usage report after object creation",flush=2)
      std_mm.report(out)
      out.flush
      out.put_text(">>> set_IT_symbol",flush=2)
      .set_IT_symbol("P6.3/mmc")
      out.flush
      out.put_text(">>> analyse",flush=2)
      .analyse
      out.flush
      out.put_text(">>> Memory usage report",flush=2)
      std_mm.report(out)
      out.flush
      out.put_text(">>> output",flush=2)
      .put(out) 
      out.flush
      out.put_text(">>> reduce_spacegroup",flush=2)
      .reduce((/0.33333333d0, 0.66666666d0, 0.25000000d0/))
      out.flush
      out.put_text(">>> put_reduced_spacegroup",flush=2)
      .put_reduced_group(out)
   end

end
