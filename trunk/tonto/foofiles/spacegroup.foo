!-------------------------------------------------------------------------------
!
! SPACEGROUP: Crystal space group object
!
! Synopsis
!
! Read in the international symmetry symbol or Hall symbol and make the Seitz 
! matrices for a particular spacegroup. Provide other crystal symmetry 
! information as well. Use the method in: 
! S. R. Hall, Acta Cryst. A37, 517 (1981)
!
! (c) 1995 S K Wolff (1st version)
! (c) 1998 D Jayatilaka (2nd & 3rd versions)
! (c) 1999 D Jayatilaka (4th version)
!
! $Id$
!-------------------------------------------------------------------------------
module SPACEGROUP

   use TYPES
   use SYSTEM
   use INT
   use STR
   use BINVEC
   use VEC
   use MAT
   use MAT3
   use INPUT
   use OUTPUT

   implicit none

#  include "macros"
#  include "spacegroup.int"

!   type spacegroup_type
!
!   STR :: IT_symbol
!   ! International Table (Hermann-Maguin) symmetry symbol
!
!   INT :: IT_group_number
!   ! International tables group number
!
!   STR :: Hall_symbol
!   ! Hall notation symbol
!
!   CHR :: lattice_symbol
!   ! Lattice symmetry symbol
!
!   STR :: lattice_type
!   ! Lattice type
!
!   BIN :: centrosymmetric
!   ! True if center of symmetry present
!
!   INT :: order(3)
!   ! Order of each crystal axis
!
!   INT :: setting_index(3)
!   ! Indicates axes of rotation corresponding to x, y, or z...
!
!   BIN :: has_bar(3)
!   ! True if bar for this axis
!
!   BIN :: has_subscript(3)
!   ! True if subscript present for this axis
!
!   CHR :: setting_symbol(3)
!   ! Superscript rotation axis symbols axis
!
!   CHR :: subscript(3,3)
!   ! Subscript translations symbols for each axis
!
!   INT :: lattice_symbol_index
!   ! Lattice symbol index number
!
!   INT :: nL
!   ! No. of translational lattice generators
!
!   INT :: nR
!   ! No. of rotation generators
!
!   INT :: nG
!   ! No. of generators
!
!   INT :: n_seitz
!   ! No. of Seitz matrices
!
!   MAT3, PTR :: seitz DEFAULT_NULL
!   ! Seitz matrices (the transpose, as defined in Hall's paper)
!
!   INT :: n_unique
!   ! No. of equivalent positions unrelated by traslation or inversion
!
!   IVEC, PTR :: unique_symop
!   ! Index of unique symops not related by translation or inversion
!
!   IVEC, PTR :: map_to_unique DEFAULT_NULL
!   ! Maps symop to a unique symop. Negative indicates inversion
!
!   end

   ! Symbols used in the Hall space group notation
   STR :: cbar    = "^"             ! Bar symbol, precedes axis orders
   STR :: csub    = "_"             ! Subscript symbol, comes after axis order and setting symbol (if any)
   STR :: cnum    = "1234#6"        ! Symmetry axis orders
   STR :: cdash   = "'"             ! 
   STR :: cddash  = '"'             ! 
   STR :: cstar   = '*'             ! 
   STR :: caxis   = "xyz""'*"       ! Axis setting symbols
   STR :: clat    = "PABCIRF"       ! Allowed lattice symbols
   STR :: ctran   = "abcnuvwd"      ! Allowed alphabetical translation subscripts
   STR :: csn     = "12345"         ! Allowed numerical translation subscripts

   MAT(3,3) :: e = reshape((/ONE,ZERO,ZERO,ZERO,ONE,ZERO,ZERO,ZERO,ONE/),(/3,3/)) ! Unit matrix

   MAT3(3,4,7) :: tL    ! Implied lattice translations; see set_tL
   MAT(3,8) :: tS       ! Alphabetical translations;    see set_tS
   MAT4(3,3,6,6) :: rx  ! Rotation matrices ; see set_rx
   CHR(11), dimension(2,230) :: Hall_conversion_table ! International notation <--> Hall notation

contains

   create
   ! Create a spacegroup
      PTR :: self
      allocate(self)
      ADD_MEM(SPACEGROUP_SIZE)
      .nullify_ptr_part
      .set_Hall_conversion_table
   end

   destroy 
   ! Destroy a spacegroup
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(SPACEGROUP_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of spacegroup
      nullify(.seitz)
      nullify(.unique_symop)
      nullify(.map_to_unique)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of spacegroup
      .seitz.destroy
      .unique_symop.destroy
      .map_to_unique.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_default
   ! Set default spacegroup
      .set_IT_symbol("P1")
      .analyse
   end
   
   set_IT_symbol(sym)
   ! Set the international table symbol
      CHR(*) :: sym
      .IT_symbol = sym
   end

   read(in) [leaky]
   ! Read in the spacegroup data from file "in"
      INPUT :: in
      STR :: word
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("end");              exit read_loop
            case("it_symbol");        .read_IT_symbol(in)
            case("hall_symbol");      .read_Hall_symbol(in)
         end 
      end do read_loop
      .analyse
   end

   read_IT_symbol(in) [leaky]
   ! Read the internation table symbol and analyse the spacegroup
      INPUT :: in
      STR :: word
      in.read(word)
      .set_IT_symbol(word)
      .get_Hall_symbol    
   end

   read_Hall_symbol(in) [leaky]
   ! Read the Hall symbol and analyse the spacegroup
      INPUT :: in
      in.read( .Hall_symbol )
      .set_IT_symbol("?????")
      .IT_group_number = 0
   end

   analyse [leaky]
      .destroy_ptr_part
      .analyse_Hall_symbol
      .get_lattice_type
      .get_axis_setting
      .get_group_sizes
      .seitz.create(4,4,.n_seitz)
      .seitz = ZERO
      .set_tL
      .form_L_seitz
      .set_tS
      .set_rx
      .form_S_seitz
      .generate_seitz
   end

   get_Hall_symbol
      BIN :: found
      INT :: i
      found = FALSE
      do i = 1,230
         if (.IT_symbol==Hall_conversion_table(1,i)) then
            .Hall_symbol = Hall_conversion_table(2,i)
            .IT_group_number = i
            found = TRUE
            exit
         end
      end
      DIE_IF(NOT found,"unknown space group " // .IT_symbol.trim)
   end

   analyse_Hall_symbol
   ! Analyse the Hall notation symbol for the spacegroup
      STR :: Hall_symbol
      INT :: axis,i
      CHR :: ss
      BIN :: temp_bin
      Hall_symbol = .Hall_symbol
      if (Hall_symbol(1:1)==cbar) then               ! Look for Bar symbol cbar = "^"
         .centrosymmetric = TRUE
         Hall_symbol = Hall_symbol(2:)
      else
         .centrosymmetric = FALSE
      end
      if (clat.includes(Hall_symbol(1:1))) then      ! check for lattice symbols clat = P,A,B,C,I,R,F
         .lattice_symbol = Hall_symbol(1:1)
         .lattice_symbol_index = clat.index_of_substring(Hall_symbol(1:1))
         Hall_symbol = Hall_symbol(2:)
      else
         DIE("unknown lattice symbol")
      end
      .has_bar         = FALSE
      .order      = 1
      .setting_symbol = "_"
      .setting_index  = 0
      .has_subscript   = FALSE
      .subscript  = "_"
      do axis = 1,3                                  ! Loop over crystal axis directions 
         if (Hall_symbol(1:1)==cbar) then            ! Check for bar symbol
            .has_bar(axis) = TRUE
            Hall_symbol = Hall_symbol(2:)
         end
         if (cnum.includes(Hall_symbol(1:1))) then   ! Check for axis order
            .order(axis) = cnum.index_of_substring(Hall_symbol(1:1))
            Hall_symbol = Hall_symbol(2:)
         else if (.has_bar(axis)) then
            DIE("no rotation axis after bar symbol")
         else if (axis==1) then
            DIE("at least one axis order is required")
         end
         if (caxis.includes(Hall_symbol(1:1))) then  ! Check for axis setting symbols
            .setting_symbol(axis) = Hall_symbol(1:1)
            .setting_index(axis) = caxis.index_of_substring(Hall_symbol(1:1))
            Hall_symbol = Hall_symbol(2:)
            ss = .setting_symbol(axis)               ! Temporary variable
            temp_bin = (ss==cdash OR ss==cddash) AND (.order(axis)/=2 OR axis==1)
            DIE_IF(temp_bin,"impossible axis setting")
            temp_bin = ss==cstar AND .order(axis)/=3
            DIE_IF(temp_bin,"impossible axis setting")
         end
         if (Hall_symbol(1:1)==csub) then            ! Check for subscripts, signified by csub = "_"
            .has_subscript(axis) = TRUE
            Hall_symbol = Hall_symbol(2:)
            do i = 1,3
               if (csn.includes(Hall_symbol(1:1)) AND i==1) then
                  .subscript(i,axis) = Hall_symbol(1:1)
                  Hall_symbol = Hall_symbol(2:)
               else if (ctran.includes(Hall_symbol(1:1))) then
                  .subscript(i,axis) = Hall_symbol(1:1)
                  Hall_symbol = Hall_symbol(2:)
               end
            end
         end
         if (Hall_symbol==" ") exit
      end 
   end

   get_lattice_type
      if (.order(1)==1) then
         .lattice_type = "Triclinic"
      else if (.order(1)==2 AND .order(2)==1) then
         .lattice_type = "Monoclinic"
      else if (.order(1)==2 AND .order(2)==2) then
         .lattice_type = "Orthorhombic"
      else if (.order(1)==4 AND .order(3)/=3) then
         .lattice_type = "Tetragonal"
      else if (.order(1)==3) then
         .lattice_type = "Trigonal"
      else if (.order(1)==6) then
         .lattice_type = "Hexagonal"
      else if (.order(3)==3) then
         .lattice_type = "Cubic"
      end
   end

   get_axis_setting
      INT :: axis
   ! For a partiular axis i,
   ! .setting_index(i) = 1,2,3  means a,b,c
   ! .setting_index(i) = 4      means a+b or "
   ! .setting_index(i) = 5      means a-b or ' 
   ! .setting_index(i) = 6      means a+b+c or * 
      if (.setting_index(1)==0) then
         .setting_symbol(1) = "z"
         .setting_index(1)  = 3
      end
      do axis = 2,3
         if (.setting_index(axis)==0) then
            if (.order(axis)==2) then
               if (.order(axis-1)==2 OR .order(axis-1)==4) then
                  .setting_symbol(axis) = "x"
                  .setting_index(axis)  = 1
               else if (.order(axis-1)==3 OR .order(axis-1)==6) then
                  .setting_symbol(axis) = cdash
                  .setting_index(axis)  = 5
               end
            else if (.order(axis)==3) then
                  .setting_symbol(axis) = cstar
                  .setting_index(axis)  = 6
            end
         end
      end
   end

   get_group_sizes
      INT :: axis
      select case (.lattice_symbol)
         case("P"); .nL = 1  
         case("A"); .nL = 2  
         case("B"); .nL = 2  
         case("C"); .nL = 2  
         case("I"); .nL = 2  
         case("R"); .nL = 3  
         case("F"); .nL = 4  
      end
      if (.centrosymmetric) .nL = 2*.nL   ! No. of translations
      .n_seitz = .nL*product(.order) ! No. of seitz matrices
      .nG = .nL                           ! No. of generators
      do axis = 1,3
         if (.order(axis)>1) .nG = .nG+1
      end
   end

   form_L_seitz
   ! Form the seitz generators corresponding to the lattice symbol L
      INT :: n,v
      n = .nL
      if (.centrosymmetric) n = .nL/2
      do v = 1,n
         .seitz(1:3,1:3,v)   = e
         .seitz(4  ,1:3,v)   = tL(1:3,v,.lattice_symbol_index)
         .seitz(1:3,  4,v)   = ZERO
         .seitz(4  ,  4,v)   = ONE
      end
      if (NOT .centrosymmetric) return
      do v = 1,n
         .seitz(1:3,1:3,n+v) = -e
         .seitz(4  ,1:3,n+v) = tL(1:3,v,.lattice_symbol_index)
         .seitz(1:3,  4,n+v) = ZERO
         .seitz(4  ,  4,n+v) = ONE
      end
   end

   set_tL
   ! tL(:,v,L) = implied lattice translation vector
   ! L         = lattice symbol index number
   ! v         = translation vector index
      tL(:,1,1) = (/ZERO,ZERO,ZERO/)
      tL(:,1,2) = (/ZERO,ZERO,ZERO/) ; tL(:,2,2) = (/ZERO,HALF,HALF/)
      tL(:,1,3) = (/ZERO,ZERO,ZERO/) ; tL(:,2,3) = (/HALF,ZERO,HALF/)
      tL(:,1,4) = (/ZERO,ZERO,ZERO/) ; tL(:,2,4) = (/HALF,HALF,ZERO/)
      tL(:,1,5) = (/ZERO,ZERO,ZERO/) ; tL(:,2,5) = (/HALF,HALF,HALF/)
      tL(:,1,6) = (/ZERO,ZERO,ZERO/) 
      tL(:,2,6) = (/ ONE, TWO, TWO/)/THREE
      tL(:,3,6) = (/ TWO, ONE, ONE/)/THREE
      tL(:,1,7) = (/ZERO,ZERO,ZERO/)
      tL(:,2,7) = (/ZERO,HALF,HALF/)
      tL(:,3,7) = (/HALF,ZERO,HALF/)
      tL(:,4,7) = (/HALF,HALF,ZERO/)
   end

   form_S_seitz
   ! Add the rotational seitz matrices to the generator list
      VEC(3) :: t
      INT :: axis,N,i,v,ax,isign
      .nR = 0
      do axis = 1,3
         N  = .order(axis)
         ax = .setting_index(axis)
         if (N<=1) then 
            cycle
         end
         t(:) = ZERO
         if (.has_subscript(axis)) then
            do i = 1,3
               v = ctran.index_of_substring( .subscript(i,axis))
               if (v/=0) then
                  t(:) = t(:) + tS(:,v)
               end
               v = csn.index_of_substring( .subscript(i,axis))
               if (v/=0 AND i==1) then
                  t(ax) = t(ax) + v/N
               end
            end
         end 
         if (ax==4 OR ax==5) then
            N = .setting_index(axis-1) ! setting of previous rotor symbol
            ! see syd !!!
            DIE_IF(N>3,"dont know how to set rotation matrix")
         end
         isign = 1
         if (.has_bar(axis)) then
            isign = -1
         end
         ! Add the generators to the list here 
         .nR = .nR + 1
         .seitz(1:3,1:3,.nL+.nR) = isign*rx(:,:,ax,N)
         .seitz(4  ,1:3,.nL+.nR) = t(:)
         .seitz(1:3,  4,.nL+.nR) = ZERO
         .seitz(4  ,  4,.nL+.nR) = ONE
      end 
   end

  set_Hall_conversion_table
  ! Set the global constant Hall_conversion_table.
  ! This is in a routine because it takes too many lines for the NAG compiler to
  ! read it all at once.
    Hall_conversion_table(:,1:15) = reshape( (/ &         ! Triclinic
    "P1         ","P1         ",      "P^1        ","P1         ",           "P2         ","P2         ", &
    "P2_1       ","P2_b       ",      "A2         ","A2         ",           "Pm         ","P^2        ", &
    "Pa         ","P^2_a      ",      "Am         ","A^2        ",           "Aa         ","A^2_a      ", &
    "P2/m       ","^P2        ",      "P2_1/m     ","^P2_b      ",           "C2/m       ","^C2        ", &
    "P2/a       ","^P2_a      ",      "P2_1/c     ","^P2_ab     ",           "A2/a       ","^A2_a      "/), &
    (/2,15/))

    Hall_conversion_table(:,16:74) = reshape( (/ &         ! Orthorhombic
    "P222       ","P22        ",      "P222_1     ","P2_c2      ",           "P2_12_12   ","P22_ab     ", &
    "P2_12_12_1 ","P2_ac2_ab  ",      "C222_1     ","C2_c2      ",           "C222       ","C22        ", &
    "F222       ","F22        ",      "I222       ","I22        ",           "I2_12_12_1 ","I2_ac2_ab  ", &
    "Pmm2       ","P2^2       ",      "Pmc2_1     ","P2_c^2     ",           "Pcc2       ","P2^2_c     ", &
    "Pma2       ","P2^2_a     ",      "Pca2_1     ","P2_c^2_ac  ",           "Pnc2       ","P2^2bc     ", &
    "Pmn2_1     ","P2_ac^2    ",      "Pba2       ","P2^2_ab    ",           "Pna2_1     ","P2_c^2_n   ", &
    "Pnn2       ","P2^2_n     ",      "Cmm2       ","C2^2       ",           "Cmc2_1     ","C2_c^2     ", &
    "Ccc2       ","C2^2_c     ",      "Amm2       ","A2^2       ",           "Abm2       ","A2^2_b     ", &
    "Ama2       ","A2^2_a     ",      "Aba2       ","A2^2_ab    ",           "Fmm2       ","F2^2       ", &
    "Fdd2       ","F2^2_d     ",      "Imm2       ","I2^2       ",           "Iba2       ","I2^2_c     ", &
    "Ima2       ","I2^2_a     ",      "Pmmm       ","^P22       ",           "Pnnn       ","^P2_ab2_bc ", &
    "Pccm       ","^P22_c     ",      "Pban       ","^P2_ab2_b  ",           "Pmma       ","^P2_a2_a   ", &
    "Pnna       ","^P2_a2_bc  ",      "Pmna       ","^P2ac2     ",           "Pcca       ","^P2_a2_ac  ", &
    "Pbam       ","^P22_ab    ",      "Pccn       ","^P2_ab2_ac ",           "Pbcm       ","^P2_c2_b   ", &
    "Pnnm       ","^P22_n     ",      "Pmmn       ","^P2_ab2_a  ",           "Pbcn       ","^P2_n2_ab  ", &
    "Pbca       ","^P2_ac2_ab ",      "Pnma       ","^P2_ac2_n  ",           "Cmcm       ","^C2_c2     ", &
    "Cmca       ","^C2_bc2    ",      "Cmmm       ","^C22       ",           "Cccm       ","^C22_c     ", &
    "Cmma       ","^C2_a2     ",      "Ccca       ","^C2_b2_ac  ",           "Fmmm       ","^F22       ", &
    "Fddd       ","^F2_uv2_vw ",      "Immm       ","^I22       ",           "Ibam       ","^I22_c     ", &
    "Ibca       ","^I2_b2_c   ",      "Imma       ","^I2_b2     "/),         (/2,59/))

    Hall_conversion_table(:,75:142) = reshape( (/ &         ! Tetragonal
    "P4         ","P4         ",      "P4_1       ","P4_1       ",           "P4_2       ","P4_c       ", &
    "P4_3       ","P4_3       ",      "I4         ","I4         ",           "I4_1       ","I4_1b      ", &
    "P^4        ","P^4        ",      "I^4        ","I^4        ",           "P4/m       ","^P4        ", &
    "P4_2/m     ","^P4_c      ",      "P4/n       ","^P4_a      ",           "P4_2/n     ","^P4_bc     ", &
    "I4/m       ","^I4        ",      "I4_1/a     ","^I4_ad     ",           "P422       ","P42        ", &
    "P42_12     ","P4_ab2_ab  ",      "P4_122     ","P4_12_c    ",           "P4_12_12   ","P4_3n2_nw  ", &
    "P4_222     ","P4_c2      ",      "P4_22_12   ","P4_n2_n    ",           "P4_322     ","P4_32_c    ", &
    "P4_32_12   ","P4_1n2_abw ",      "I422       ","I42        ",           "I4_122     ","I4_1b2_bw  ", &
    "P4mm       ","P4^2       ",      "P4bm       ","P4^2_ab    ",           "P4_2cm     ","P4_c^2_c   ", &
    "P4_2nm     ","P4_n^2_n   ",      "P4cc       ","P4^2_c     ",           "P4nc       ","P4^2_n     ", &
    "P4_2mc     ","P4_c^2     ",      "P4_2bc     ","P4_c^2_ab  ",           "I4mm       ","I4^2       ", &
    "I4cm       ","I4^2_ab    ",      "I4_1md     ","I4_1b^2    ",           "I4_1cd     ","I4_1b^2c   ", &
    "P^42m      ","P^42       ",      "P^42c      ","P^42_c     ",           "P^42_1m    ","P^42_ab    ", &
    "P^42_1c    ","P^42_n     ",      "P^4m2      ","P^4^2      ",           "P^4c2      ","P^4^2_c    ", &
    "P^4b2      ","P^4^2_ab   ",      "P^4n2      ","P^4^2_n    ",           "I^4m2      ","I^4^2      ", &
    "I^4c2      ","I^4^2_c    ",      "I^42m      ","I^42       ",           "I^42d      ","I^42_bw    ", &
    "P4/mmm     ","^P42       ",      "P4mcc      ","^P42_c     ",           "P4/nbm     ","^P4_a2_b   ", &
    "P4/nnc     ","^P4_a2_bc  ",      "P4/mbm     ","^P42_ab    ",           "P4/mnc     ","^P42_n     ", &
    "P4/nmm     ","^P4_a2_a   ",      "P4/ncc     ","^P4_a2_ac  ",           "P4_2/mmc   ","^P4_c2     ", &
    "P4_2/mcm   ","^P4_c2_c   ",      "P4_2/nbc   ","^P4_ac2_b  ",           "P4_2/nnm   ","^P4_ac2_bc ", &
    "P4_2/mbc   ","^P4_c2_ab  ",      "P4_2/mnm   ","^P4_n2_n   ",           "P4_2nmc    ","^P4_ac2_a  ", &
    "P4_2/ncm   ","^P4_ac2_ac ",      "I4/mmm     ","^I42       ",           "I4/mcm     ","^I42_c     ", &
    "I4_1/amd   ","^I4_bd2    ",      "I4_1/acd   ","^I4bd2_c   "/),         (/2,68/))

   Hall_conversion_table(:,143:167) = reshape( (/ &         ! Trigonal
     'P3         ','P3         ',      'P3_1       ','P3_1       ',           'P3_2       ','P3_2       ', &
     'R3         ','R3         ',      'P^3        ','P^3        ',           'R^3        ','^R3        ', &
     'P312       ','P32        ',      'P321       ','P32"       ',           'P3_112     ','P3_12      ', &
     'P3_121     ','P3_12      ',      'P3_212     ','P3_22      ',           'P3_21      ','P3_22"     ', &
     'R32        ','R32"       ',      'P3m1       ','P3^2"      ',           'P31m       ','P3^2       ', &
     'P3c1       ','P3^2"_c    ',      'P31c       ','P3^2_c     ',           'R3m        ','R3^2"      ', &
     'R3c        ','R3^2"_c    ',      'P^31m      ','^P32       ',           'P^31c      ','^P32_c     ', &
     'P^3m1      ','^P32"      ',      'P^3c1      ','^P32"_c    ',           'R^3m       ','^R32"      ', &
     'R^3c       ','^R32"_c    '/),    (/2,25/))

   Hall_conversion_table(:,168:194) = reshape( (/ &         ! Hexagonal
     "P6         ","P6         ",      "P6_1       ","P6_1       ",           "P6_5       ","P6_5       ", &
     "P6_2       ","P6_2       ",      "P6_4       ","P6_4       ",           "P6_3       ","P6_c       ", &
     "P^6        ","P^6        ",      "P6/m       ","^P6        ",           "P6_3/m     ","^P6_c      ", &
     "P622       ","P62        ",      "P6_122     ","P6_12      ",           "P6_522     ","P6_52      ", &
     "P6_222     ","P6_22      ",      "P6_422     ","P6_42      ",           "P6_322     ","P6_c2      ", &
     "P6mm       ","P6^2       ",      "P6cc       ","P6^2_c     ",           "P6_3cm     ","P6_c^2     ", &
     "P6_3mc     ","P6_c^2_c   ",      "P^6m2      ","P^62       ",           "P^6c2      ","P^6_c2     ", &
     "P^62m      ","P^6^2      ",      "P^62_c     ","P^6_c^2_c  ",           "P6/mmm     ","^P62       ", &
     "P6/mcc     ","^P62_c     ",      "P6_3/mcm   ","^P6_c2     ",           "P6_3/mmc   ","^P6_c2_c   "/), &
     (/2,27/))

   Hall_conversion_table(:,195:230) = reshape( (/ &         ! Cubic
     "P23        ","P223       ",      "F23        ","F223       ",           "I23        ","I223       ", &
     "P2_13      ","P2_ac2_ab3 ",      "I2_13      ","I2_ac2_ab3 ",           "Pm3        ","^P223      ", &
     "Pn3        ","^P2_ab2_bc3",      "Fm3        ","^F223      ",           "Fd3        ","^F2_uv2_vw3", &
     "Im3        ","^I223      ",      "Pa3        ","^P2_ac2_ab3",           "Ia3        ","^I2_ac2_ab3", &
     "P432       ","P423       ",      "P4_232     ","P4_n23     ",           "F432       ","F423       ", &
     "F4_132     ","F4_d23     ",      "I432       ","I423       ",           "P4_332     ","P4_bdn2_ab3", &
     "P4_132     ","P4_bd2_ab3 ",      "I4_132     ","I4_bd2_ab3 ",           "P^43m      ","P^423      ", &
     "F^43m      ","F^423      ",      "I^43m      ","I^423      ",           "P^43n      ","P^4_n23    ", &
     "F^43c      ","F^4_c23    ",      "I^43d      ","I^4_bd2_ab3",           "Pm3m       ","^P423      ", &
     "Pn3n       ","^P4_a2bc3  ",      "Pm3n       ","^P4_n23    ",           "Pn3m       ","^P4_bc2_bc3", &
     "Fm3m       ","^F423      ",      "Fm3c       ","^F4_n23    ",           "Fd3m       ","^F4_vw2_vw3", &
     "Fd3c       ","^F4_ud2_vw3",      "Im3m       ","^I423      ",           "Ia3d       ","^I4bd2ab3  "/), &
     (/2,36/))
  end

   set_rx
      rx(:,:,1,1) = e                                             ! Unit matrix
      rx(:,:,1,2) = reshape( (/ 1, 0, 0, 0,-1, 0, 0, 0,-1/), (/3,3/)) ! 2-fold rotation about a
      rx(:,:,2,2) = reshape( (/-1, 0, 0, 0, 1, 0, 0, 0,-1/), (/3,3/)) ! 2-fold rotation about b
      rx(:,:,3,2) = reshape( (/-1, 0, 0, 0,-1, 0, 0, 0, 1/), (/3,3/)) ! 2-fold rotation about c
      rx(:,:,1,3) = reshape( (/ 1, 0, 0, 0, 0,-1, 0, 1,-1/), (/3,3/)) ! 3-fold rotation about a
      rx(:,:,2,3) = reshape( (/-1, 0, 1, 0, 1, 0,-1, 0, 0/), (/3,3/)) ! 3-fold rotation about b
      rx(:,:,3,3) = reshape( (/ 0,-1, 0, 1,-1, 0, 0, 0, 1/), (/3,3/)) ! 3-fold rotation about c
      rx(:,:,1,4) = reshape( (/ 1, 0, 0, 0, 0,-1, 0, 1, 0/), (/3,3/)) ! 4-fold rotation about a
      rx(:,:,2,4) = reshape( (/ 0, 0, 1, 0, 1, 0,-1, 0, 0/), (/3,3/)) ! 4-fold rotation about b
      rx(:,:,3,4) = reshape( (/ 0,-1, 0, 1, 0, 0, 0, 0, 1/), (/3,3/)) ! 4-fold rotation about c
      rx(:,:,1,6) = reshape( (/ 1, 0, 0, 0, 1,-1, 0, 1, 0/), (/3,3/)) ! 6-fold rotation about a
      rx(:,:,2,6) = reshape( (/ 0, 0, 1, 0, 1, 0,-1, 0, 1/), (/3,3/)) ! 6-fold rotation about b
      rx(:,:,3,6) = reshape( (/ 1,-1, 0, 1, 0, 0, 0, 0, 1/), (/3,3/)) ! 6-fold rotation about c
    ! 2-fold rotations off axis
      rx(:,:,5,1) = reshape( (/-1, 0, 0, 0, 0,-1, 0,-1, 0/), (/3,3/)) ! 2-fold rotation about b-c, preceded by Nx
      rx(:,:,4,1) = reshape( (/-1, 0, 0, 0, 0, 1, 0, 1, 0/), (/3,3/)) ! 2-fold rotation about b+c
      rx(:,:,5,2) = reshape( (/ 0, 0,-1, 0,-1, 0,-1, 0, 0/), (/3,3/)) ! 2-fold rotation about a-c, preceded by Ny
      rx(:,:,4,2) = reshape( (/ 0, 0, 1, 0,-1, 0, 1, 0, 0/), (/3,3/)) ! 2-fold rotation about a+c
      rx(:,:,5,3) = reshape( (/ 0,-1, 0,-1, 0, 0, 0, 0,-1/), (/3,3/)) ! 2-fold rotation about a-b, preceded by Nz
      rx(:,:,4,3) = reshape( (/ 0, 1, 0, 1, 0, 0, 0, 0, 1/), (/3,3/)) ! 2-fold rotation about a+b
    ! 3-fold rotations off axis
      rx(:,:,6,3) = reshape( (/ 0, 0, 1, 1, 0, 0, 0, 1, 0/), (/3,3/)) ! 3-fold rotation about a+b+c
   end

   set_tS
   ! tS(:,v) = alphabetical subscript translation vector
   ! v = alphabetical index number
      tS(:,1) = (/HALF,ZERO,ZERO/)
      tS(:,2) = (/ZERO,HALF,ZERO/)
      tS(:,3) = (/ZERO,ZERO,HALF/)
      tS(:,4) = (/HALF,HALF,HALF/)
      tS(:,5) = HALF*tS(:,1)
      tS(:,6) = HALF*tS(:,2)
      tS(:,7) = HALF*tS(:,3)
      tS(:,8) = HALF*tS(:,4)
   end

   generate_seitz
      INT :: m,i,j,k
      BIN :: equal
      m = .nG
      if (m==.n_seitz) return
      i = 1
      main: do
         i = i+1
         j = 1
         pair_products: do
            j = j+1
            .seitz(:,:,m+1) = matmul(.seitz(:,:,j),.seitz(:,:,i))
            .seitz(4,1,m+1) = mod(.seitz(4,1,m+1)+TWO,ONE)
            .seitz(4,2,m+1) = mod(.seitz(4,2,m+1)+TWO,ONE)
            .seitz(4,3,m+1) = mod(.seitz(4,3,m+1)+TWO,ONE)
            do k = 1,m
               equal = .seitz(:,:,m+1).same_as(.seitz(:,:,k))
               if (equal) exit 
            end
            if (NOT equal) m = m+1
            if (m==.n_seitz) exit main
            if (j==m)        exit pair_products
         end do pair_products
         if (i==m) exit main
      end do main
   end

   put_geometry_to_unit_cell(g)
   ! Transform the geometry "g" in fractional coordinates into the
   ! (1,1,1) unit cell
      MAT :: g
      INT :: n,n_atom
      ENSURE( .seitz.created, "Seitz matrices not initialised")
      ENSURE( size(g,1)==3, "incorrect size for array g")
      n_atom = size(g,2)
      do n = 1,n_atom  
         .put_position_to_unit_cell(g(:,n))
      end
   end

   put_position_to_unit_cell(p)
   ! Transform the position "p" in fractional coordinates into the
   ! (1,1,1) unit cell
      VEC(3) :: p
      INT :: n,n_atom
      ENSURE( size(p)==3, "incorrect size for position vector p")
      p(:) = mod(p(:)+TWO,ONE)
   end

   get_partition_factors(pfac,geometry,full) [leaky]
   ! Given a "geometry" array in fractional coordinates for a molecule, 
   ! generate the partition factors or repetition factors "pfac" to be used for 
   ! each atom in a structure factor calculation. If present, the "full" geometry
   ! in fractional coordinates will be returned, where all possible symmetry
   ! distinct atom positions in the unit cell have been generated.
      MAT  :: geometry
      VEC :: pfac
      MAT, PTR, optional :: full
      VEC(3)  :: pa,pb
      INT :: a,b,n,n_atom,n_same
      BIN :: same
      n_atom = size(geometry,2)
      ENSURE( size(geometry,1)==3, "Wrong shape for geometry array")
      ENSURE( size(pfac)==n_atom,  "Incompatible shape for p array")
      ENSURE( .seitz.created,      "Seitz matrices not initialised")
      do a = 1,n_atom
         pa = geometry(:,a)
         .put_position_to_unit_cell(pa)
         n_same = 0
         do n = 1,.n_seitz
         do b = 1,n_atom
            pb = geometry(:,b)
            .transform_position(pb,n)
            .put_position_to_unit_cell(pb)
            same = pa.same_as(pb)
            if (same) n_same = n_same + 1
         end
         end
         pfac(a) = n_same
      end
      if (present(full)) .get_full_geometry(full,geometry,pfac) 
   end

   get_full_geometry(full,geometry,pfac) [leaky]
   ! Get the "full" set of distinct atom positions in the unit cell, given a
   ! (possibly) partial "geometry", and a set of partition factors "pfac".
      MAT, PTR :: full
      MAT  :: geometry
      VEC :: pfac
      VEC(3)  :: pa,pb
      INT :: a,b,n,n_atom,n_full
      BIN :: same
      n_atom = size(geometry,2)
      ENSURE( size(geometry,1)==3, "Wrong shape for geometry array")
      ENSURE( size(pfac)==n_atom,  "Incompatible shape for p array")
      ENSURE( .seitz.created,      "Seitz matrices not initialised")
      n_full = 0
      do a = 1,n_atom
         n_full = n_full + .n_seitz/pfac(a)
      end
      full.create(3,n_full)
      n_full = 0
      do a = 1,n_atom
      do n = 1,.n_seitz
         pa = geometry(:,a)
         .put_position_to_unit_cell(pa)
         .transform_position(pa,n)
         .put_position_to_unit_cell(pa)
         same = FALSE
         do b = 1,n_full
            pb = full(:,b)
            same = pa.same_as(pb)
            if (same) exit
         end
         if (NOT same) then       ! New symmetry generated position
            n_full = n_full+1
            full(:,n_full) = pa
         end
      end
      end
   end

   transform_geometry(g,op)
   ! Transform the geometry "g" in fractional coordinates with the
   ! Seitz operator with index "op"
      MAT :: g
      INT :: op
      INT :: n,n_atom
      ENSURE( .seitz.created, "Seitz matrices not initialised")
      ENSURE( size(g,1)==3, "incorrect size for array g")
      ENSURE( op>0,         "operator index out of bounds")
      ENSURE( op<=.n_seitz, "operator index out of bounds")
      n_atom = size(g,2)
      do n = 1,n_atom  
         .transform_position(g(:,n),op)
      end
   end

   transform_position(p,op)
   ! Transform the position "p" in fractional coordinates with the
   ! Seitz operator with index "op"
      VEC(3) :: p
      INT :: op
      INT :: n,n_atom
      ENSURE( .seitz.created, "Seitz matrices not initialised")
      ENSURE( op>0,         "operator index out of bounds")
      ENSURE( op<=.n_seitz, "operator index out of bounds")
      p = matmul(p,.seitz(1:3,1:3,op)) + .seitz(4,1:3,op)
   end

   is_same_geometry(geom_i,geom_j) result(res)
   ! Return TRUE if the geometries "geom_i" and "geom_j" in fractional coordinates are
   ! the same, to within *traslational* symmetry
      MAT :: geom_i,geom_j
      BIN :: res
      MAT, PTR :: gi,gj
      INT :: i,j,n_atom
      BIN :: same
      BINVEC, PTR :: skip
      n_atom = size(geom_i,2)
      ENSURE( .seitz.created, "Seitz matrices not initialised")
      ENSURE(size(geom_i,1)==3, "incorrect size for array geom_i")
      ENSURE(size(geom_j,1)==3, "incorrect size for array geom_j")
      ENSURE(n_atom==size(geom_j,2), "incompatible sizes for geom_i, geom_j")
      gi.create(3,n_atom); gi = geom_i; .put_geometry_to_unit_cell(gi)
      gj.create(3,n_atom); gj = geom_j; .put_geometry_to_unit_cell(gj)
      skip.create(n_atom); skip(:) = FALSE
      do i = 1,n_atom  
         do j = 1,n_atom
            same = gi(:,i).same_as(gj(:,j))
            if (NOT same OR skip(j)) cycle
            skip(j) = TRUE 
            exit
         end
      end
      res = all(skip) ! True if all atoms in i were matched (skipped) in j
      skip.destroy
      gj.destroy
      gi.destroy
   end

   make_unique_symops(geometry) [leaky]
   ! Check to see if any of the Seitz matrices ".seitz" will change a 
   ! molecular "geometry" by more than just a translation or an inversion 
   ! operation: such a list is called a reduced symop list, or unique symop list. 
   ! Array ".map_to_unique(i)" maps the i-th symmetry operator onto the 
   ! corresponding reduced operator "j" which is equivalent to it by 
   ! translation, or to "-j" if equivalent by inversion. ".unique_symop(j)"
   ! is the first unique Seitz operator in the list. ".n_unique" is set 
   ! to the number of unique symmetry operations.
      MAT :: geometry
      MAT, PTR  :: gi,gu
      IVEC, PTR :: unique_symop
      INT :: n_atom,i,j,u, n
      BIN :: same,inverted
      ENSURE( .seitz.created, "Seitz matrices not initialised")
      n_atom = size(geometry,2)
      gi.create(3,n_atom)
      gu.create(3,n_atom)
      .map_to_unique.create(.n_seitz)
      unique_symop.create(.n_seitz)
      n = 0
      do i = 1,.n_seitz
         same     = FALSE
         inverted = FALSE
         gi = geometry; .transform_geometry(gi,i)
         do j = 1,n                            ! Loop over unique symops
            u = unique_symop(j)
            gu = geometry; .transform_geometry(gu,u)
            same = .is_same_geometry(gi,gu) 
            inverted = .seitz(1:3,1:3,i).equals( -.seitz(1:3,1:3,u) )
            if (same OR inverted) exit
         end 
         if (inverted) then
            .map_to_unique(i) = -j             ! negative for inversion
         else if (same) then
            .map_to_unique(i) =  j             ! positive for translation
         else
            n = n + 1
            unique_symop(n) = i
            .map_to_unique(i) = n              ! map to new unique symop
         end
      end 
      .n_unique = n
      .unique_symop.create(n)
      .unique_symop = unique_symop
      unique_symop.destroy
      gu.destroy
      gi.destroy
   end

   unique_symop_mat(u) result (res)
   ! Return the "u"-th unique symop matrix in the unique list made by routine
   ! ".make_unique_symops".
      MAT(3,3) :: res
      INT :: u
      BIN :: analysis
      analysis = .unique_symop.created
      ENSURE( analysis,"Unique symop analysis not yet done")
      ENSURE( u<=.n_unique,"symop index out of range")
      ENSURE( u>0,         "symop index out of range")
      res = .seitz(1:3,1:3,.unique_symop(u))
   end

   put(out)
   ! Put out the spacegroup information
      OUTPUT :: out
      INT :: n,order,setting_indices
      STR :: setting_symbol,subscripts
      out.flush
      out.put_text("SPACEGROUP output:",flush=2)
      out.put_text("Information about crystal cell symmetry",flush=2)
      out.show("IT symbol              = ",trim(.IT_symbol))
      out.show("Hall symbol            = ",trim(.Hall_symbol))
      out.show("International table No = ",.IT_group_number,dbl_width=TRUE)
      out.show("Lattice symbol         = ",trim(.lattice_symbol))
      out.show("Lattice type           = ",trim(.lattice_type))
      out.show("Order (n_seitz)        = ",.n_seitz,dbl_width=TRUE)
      out.show("Centro-symmetric?      = ",.centrosymmetric,dbl_width=TRUE)

      order = 100*.order(1) + 10*.order(2) + .order(3)
      setting_symbol = .setting_symbol(1) // .setting_symbol(2) // .setting_symbol(3) 
      setting_indices = 100*.setting_index(1) + 10*.setting_index(2) + .setting_index(3)
      subscripts = &
         .subscript(1,1) // .subscript(2,1) // .subscript(3,1) // " " // &
         .subscript(1,2) // .subscript(2,2) // .subscript(3,2) // " " // &
         .subscript(1,3) // .subscript(2,3) // .subscript(3,3) 
      out.show("Axis orders            = ", order,dbl_width=TRUE)
      out.show("Setting symbols        = ", setting_symbol)
      out.show("Setting indices        = ", setting_indices,dbl_width=TRUE)
      out.show("Translation subscripts = ", subscripts)
      out.show("No of L generators     = ",.nL,dbl_width=TRUE)
      out.show("No of R generators     = ",.nR,dbl_width=TRUE)
      out.show("No of generators       = ",.nG,dbl_width=TRUE)
      out.flush
      out.text("Seitz matrices :")
      do n = 1,.n_seitz
        out.flush
        out.show("n = ",n)
        out.put(.seitz(:,:,n))
      end
      if (associated(.unique_symop)) .put_unique_symop(out)
   end

  put_unique_symop(out)
    OUTPUT :: out
    INT :: n,nu,k
    out.flush
    out.put_text("SPACEGROUP unique symop list output:",flush=2)
    out.dash(int_fields=2,dbl_fields=1)
    out.put("Symop", int_width=TRUE)
    out.put("Symop Type")
    out.put("Unique #", int_width=TRUE)
    out.flush
    out.dash(int_fields=2,dbl_fields=1)
    k = 1
    do n = 1,.n_seitz
      out.put(n)
      nu = .map_to_unique(n)
      if (nu==k) then
        out.put("Unique symop")
        k = k+1
      else if (nu<0) then
        out.put("Inversion of")
      else
        out.put("Translation of")
      end
      out.put(nu,flush=1)
    end
    out.dash(int_fields=2,dbl_fields=1)
  end

end
