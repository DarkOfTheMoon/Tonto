! $Id$
!---------------------------------------------------------------------------
!
!  DBL: methods which apply to double precision numbers
!
!  (c) Daniel Grimwood, 1999
!
!---------------------------------------------------------------------------
module DBL

   use TYPES
   use ERROR
   use MM
   use STR
   use INT

   implicit none         

#include "macros"
#include "dbl.int"

   public arcsin

contains

   to_str result(string)
   ! Change self to a "string" using default format.
      STR :: string
      string = ""
      write(string,fmt=*) self
      string.left_justify
   end

   to_str(form) result(string)
   ! Change self to a "string" using specified format "form"
      STR(*) :: form
      STR :: string
      string = ""
      write(string,fmt="("//trim(form)//")") self
      string.left_justify
   end

   raised_to(n) result(res)
   ! Raise "self" to the power "n"
      INT :: n
      DBL :: res
      INT :: i
      res = ONE
      do i = 1,abs(n)
         res = res*self
      end
      if (n<0) res = ONE/res
   end

   arccos result(res)
   ! Return the arccosine for self. Corrects bug for numbers close to 1.
      DBL :: res
      if (abs(abs(self)-ONE)<TOL(5)) then
         if (self<0) then; res = PI
         else;             res = ZERO
         end
      else
         res = acos(self)
      end
   end

   arcsin result(res)
   ! Return the arcsine for self. Corrects bug for numbers close to 1.
      DBL :: res
      if (abs(abs(self)-ONE)<TOL(5)) then
         if (self<0) then; res = -PI/TWO
         else;             res = +PI/TWO
         end
      else
         res = asin(self)
      end
   end

   hermite_polynomial(n,normalise) result(res) 
   ! Return "res", the value of the "n"th hermite polynomial H_n(self).
   ! If present and TRUE, "normalise" gives values normalised for use
   ! in generating harmonic vibrational wavefunctions. See below.
      INT :: n
      BIN, optional :: normalise
      DBL :: res
      VEC, PTR :: coeff
      DBL :: x
      INT :: i
      coeff => n.hermite_polynomial(normalise)
      res = ZERO
      x = ONE
      do i = 0,n
         res = res + coeff(i+1)*x
         x = x*self
      end
      deallocate(coeff)
   end

   harmonic_vibrational_fn(n) result(res)
   ! Return "res", the value of the "n"th harmonic vibrational wavefunction
   ! as a function of the dimensionless normal coordinate "self"
      INT :: n
      DBL :: res
      DBL :: q
      q = self
   !  fac = sqrt( ONE/ (sqrt(PI) * 2**n * n.factorial) )
      res = q.hermite_polynomial(n,normalise=TRUE)*exp(-HALF*q*q)
   end

   integrate(a,b,accuracy) result(res) [recursive] [functional]
   ! Integrate the function "self" between the limits "a" and "b"
   ! using adaptive trapezoidal rule with Simpsons approximation acceleration.
   ! If present, "accuracy" is the required accuracy of the integral.
      interface
         self(x) result(res)
            DBL :: x,res
         end
      end 
      DBL :: a,b
      DBL, optional :: accuracy
      DBL :: res
      res = .integrate_adaptive_trapezoid(a,b,accuracy)
   end

   integrate_adaptive_trapezoid(a,b,accuracy) result(res) [recursive] [functional]
   ! Integrate the function "self" between the limits "a" and "b"
   ! using adaptive trapezoidal rule with Simpsons approximation acceleration.
   ! If present, "accuracy" is the required accuracy of the integral.
      interface
         self(x) result(res)
            DBL :: x,res
         end
      end 
      DBL :: a,b
      DBL, optional :: accuracy
      DBL :: res
      DBL :: tol,h,m,fa,fb,fm,one_trap,two_trap,left,right
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h  = b-a
      m  = (a+b)/TWO
      fa = self(a)
      fb = self(b)
      fm = self(m)
      one_trap = h*(fa+fb)/TWO
      two_trap = h*(fa+TWO*fm+fb)/FOUR
      if (abs(one_trap-two_trap)<THREE*tol) then
         res = (FOUR*two_trap - one_trap)/THREE
      else
         left  = .integrate_adaptive_trapezoid(a,m,tol/TWO)
         right = .integrate_adaptive_trapezoid(m,b,tol/TWO)
         res = left + right
      end
   end

   integrate_adaptive_simpson(a,b,accuracy) result(res) [recursive] [functional]
   ! Integrate the function "self" between the limits "a" and "b"
   ! using adaptive Simpson rule with acceleration.
   ! If present, "accuracy" is the required accuracy of the integral.
      interface
         self(x) result(res)
            DBL :: x,res
         end
      end 
      DBL :: a,b
      DBL, optional :: accuracy
      DBL :: res
      DBL :: tol,h,m1,m2,m3,fa,fb,f1,f2,f3,s1,s2,left,right
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h   = (b-a)/TWO
      m1  = (THREE*a+b)/FOUR
      m2  = (a+b)/TWO
      m3  = (a+THREE*b)/FOUR
      fa = self(a)
      fb = self(b)
      f1 = self(m1)
      f2 = self(m2)
      f3 = self(m3)
      s1 = h*(fa+FOUR*f2+fb)/THREE
      s2 = h*(fa+FOUR*f1+TWO*f2+FOUR*f3+fb)/SIX
      if (abs(s1-s2)<15.0d0*tol) then
         res = (16.0d0*s2 - s1)/15.0d0
      else
         left  = .integrate_adaptive_simpson(a,m2,tol/TWO)
         right = .integrate_adaptive_simpson(m2,b,tol/TWO)
         res = left + right
      end
   end

  fermi_population(E_fermi,temperature) result (res) [elemental]
  ! Returns the population of the level with energy "self".
  ! Input energies in Hartrees, temperature in Kelvin!!!!!
    DBL, IN :: E_fermi,temperature
    IN :: self
    DBL :: res,de,temp,de_on_temp
    de = (self - E_fermi) * JOULE_PER_HARTREE
    temp = temperature * BOLTZMANN_SI
    de_on_temp = de/temp
    if (de_on_temp > 500.0d0) then
      res = ZERO
    else
      if (de_on_temp < (-500.0d0)) then
        res = ONE
      else
        res = ONE / (E**(de_on_temp) + ONE)
        if (res < 1d-20) res = ZERO
        if (res > (1 - 1d-20)) res = ONE
      end
    end
  end

  minimise_bisect(val,previous,kept,tolerance,delta,done) [leaky]
  ! Returns new "self" which should be better than old "self".  Do at least
  ! twice to be sure.  Works by the bisection method.
  ! Dummy variable "done" is returned true if it has converged.
  ! "previous" s automatically created and destroyed.
  ! row 1 is for y, row 2 is for x, for y=f(x).
    MAT, PTR :: previous
    DBL, IN :: val,tolerance,delta
    INT, INOUT :: kept
    BIN, INOUT :: done
    DBL :: x1,x2,x3,y1,y2,y3

    done = FALSE
    if (NOT associated(previous)) then
      allocate(previous(3,2))
      kept = 0
    else
      ENSURE(size(previous,1) == 3, "matrix has wrong dimension")
      ENSURE(size(previous,2) == 2, "matrix has wrong dimension")
      ENSURE(kept <= 3 AND kept >=0,"invalid value for variable 'kept'")
    end
    select case (kept)
      case (0);      kept = 1
        previous(:,1) = (/val ,ZERO,ZERO/)
        previous(:,2) = (/self,ZERO,ZERO/)
        self = self + delta
        done = FALSE
      case (1);      kept = 2
        x1 = previous(1,2);      y1 = previous(1,1)
        if (self<x1) then
          previous(:,1) = (/val ,y1,ZERO/)
          previous(:,2) = (/self,x1,ZERO/)
          self = self - (x1-self)
        else
          previous(:,1) = (/y1,val ,ZERO/)
          previous(:,2) = (/x1,self,ZERO/)
          self = self + (self-x1)
        end
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        if (y1<y2) then
          self = x1 - delta
        else
          self = x2 + delta
        end
        done = FALSE
      case (2);      kept = 3
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        if (self<x1) then
          previous(:,1) = (/val ,y1,y2/)
          previous(:,2) = (/self,x1,x2/)
        else if (self>x2) then
          previous(:,1) = (/y1,y2,val /)
          previous(:,2) = (/x1,x2,self/)
        else
          previous(:,1) = (/y1,val ,y2/)
          previous(:,2) = (/x1,self,x2/)
        end
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        x3 = previous(3,2);      y3 = previous(3,1)

        if (y2<y1) then
          if (y2<y3) then
            if (y1<y3) then
              self = (x1+x2)/2
            else
              self = (x2+x3)/2
            end
          else
            self = x3 + HALF*(x3-x1)
          end
        else !y1<y2
          self = x1 - HALF*(x3-x1)
        end

        x1 = abs(previous(1,2)-self)
        x2 = abs(previous(2,2)-self)
        x3 = abs(previous(3,2)-self)
        y1 = max(x1,x2,x3)
        if (y1 < tolerance) then
          done = TRUE
          deallocate(previous)
        end
      case (3)
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        x3 = previous(3,2);      y3 = previous(3,1)
        if (self<x1) then
          previous(:,1) = (/val ,y1,y2/)
          previous(:,2) = (/self,x1,x2/)
        else if (self>x3) then
          previous(:,1) = (/y2,y3,val /)
          previous(:,2) = (/x2,x3,self/)
        else
          if (self<x2) then
            if (y1<y3) then
              previous(:,1) = (/y1,val ,y2/)
              previous(:,2) = (/x1,self,x2/)
            else
              previous(:,1) = (/y1,y2,val /)
              previous(:,2) = (/x1,x2,self/)
            end
          else
            if (y1>y3) then
              previous(:,1) = (/y2,val ,y3/)
              previous(:,2) = (/x2,self,x3/)
            else
              previous(:,1) = (/y1,y2,val /)
              previous(:,2) = (/x1,x2,self/)
            end
          end
        end
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        x3 = previous(3,2);      y3 = previous(3,1)

        if (y2<y1) then
          if (y2<y3) then
            if (y1<y3) then
              self = (x1+x2)/2
            else
              self = (x2+x3)/2
            end
          else
            self = x3 + HALF*(x3-x1)
          end
        else !y1<y2
          self = x1 - HALF*(x3-x1)
        end
              
        x1 = abs(previous(1,2)-self)
        x2 = abs(previous(2,2)-self)
        x3 = abs(previous(3,2)-self)
        y1 = max(x1,x2,x3)
        if (y1 < tolerance) then
          done = TRUE
          deallocate(previous)
        end
    end
  end

end
