!---------------------------------------------------------------------------
!
!  DBL: methods which apply to double precision numbers
!
!  (c) Daniel Grimwood, 1999
!
! $Id$
!---------------------------------------------------------------------------
module DBL

   use TYPES
   use SYSTEM
   use STR
   use INT

   implicit none         

#include "macros"
#include "dbl.int"

   public arcsin

contains

   to_str result(string)
   ! Change self to a "string" using default format.
      STR :: string
      string = ""
      write(string,fmt=*) self
      string.left_justify
   end

   to_str(form) result(string)
   ! Change self to a "string" using specified format "form"
      STR(*) :: form
      STR :: string
      string = ""
      write(string,fmt="("//trim(form)//")") self
      string.left_justify
   end

   equals(x,eps) result(res)
   ! Return TRUE is self is near enough to "x". If present, "eps"
   ! defines how close before the number is considered the same.
      DBL :: x
      DBL, optional :: eps
      BIN :: res
      DBL :: tol
      tol = DBL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self-x) < tol
   end

   is_zero(eps) result(res)
   ! Return TRUE is self is near enough zero. If present, "eps"
   ! defines how close to zero before the number is considered zero.
      DBL, optional :: eps
      BIN :: res
      DBL :: tol
      tol = DBL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self) < tol
   end

   is_not_zero(eps) result(res)
   ! Return TRUE is self is not zero. If present, "eps" defines how far
   ! from zero before the number is not considered zero.
      DBL, optional :: eps
      BIN :: res
      res = NOT .is_zero(eps)
   end

   raised_to(n) result(res)
   ! Raise "self" to the power "n"
      INT :: n
      DBL :: res
      INT :: i
      res = ONE
      do i = 1,abs(n)
         res = res*self
      end
      if (n<0) res = ONE/res
   end

   arccos result(res)
   ! Return the arccosine for self. Corrects bug for numbers close to 1.
      DBL :: res
      if (abs(abs(self)-ONE)<TOL(5)) then
         if (self<0) then; res = PI
         else;             res = ZERO
         end
      else
         res = acos(self)
      end
   end

   arcsin result(res)
   ! Return the arcsine for self. Corrects bug for numbers close to 1.
      DBL :: res
      if (abs(abs(self)-ONE)<TOL(5)) then
         if (self<0) then; res = -PI/TWO
         else;             res = +PI/TWO
         end
      else
         res = asin(self)
      end
   end

   hermite_polynomial(n,normalise) result(res) 
   ! Return "res", the value of the "n"th hermite polynomial H_n(self).
   ! If present and TRUE, "normalise" gives values normalised for use
   ! in generating harmonic vibrational wavefunctions. See below.
      INT :: n
      BIN, optional :: normalise
      DBL :: res
      VEC, PTR :: coeff
      DBL :: x
      INT :: i
      coeff => n.hermite_polynomial(normalise)
      res = ZERO
      x = ONE
      do i = 0,n
         res = res + coeff(i+1)*x
         x = x*self
      end
      deallocate(coeff)
   end

   harmonic_vibrational_fn(n) result(res)
   ! Return "res", the value of the "n"th harmonic vibrational wavefunction
   ! as a function of the dimensionless normal coordinate "self"
      INT :: n
      DBL :: res
      DBL :: q
      q = self
   !  fac = sqrt( ONE/ (sqrt(PI) * 2**n * n.factorial) )
      res = q.hermite_polynomial(n,normalise=TRUE)*exp(-HALF*q*q)
   end

   integral(a,b,accuracy) result(res) [recursive] [functional]
   ! Integrate the function "self" between the limits "a" and "b"
   ! using adaptive trapezoidal rule with Simpsons approximation acceleration.
   ! If present, "accuracy" is the required accuracy of the integral.
      interface
         self(x) result(res)
            DBL :: x,res
         end
      end 
      DBL :: a,b
      DBL, optional :: accuracy
      DBL :: res
      res = .integrate_adaptive_trapezoid(a,b,accuracy)
   end

   integrate_adaptive_trapezoid(a,b,accuracy) result(res) [recursive] [functional]
   ! Integrate the function "self" between the limits "a" and "b"
   ! using adaptive trapezoidal rule with Simpsons approximation acceleration.
   ! If present, "accuracy" is the required accuracy of the integral.
      interface
         self(x) result(res)
            DBL :: x,res
         end
      end 
      DBL :: a,b
      DBL, optional :: accuracy
      DBL :: res
      DBL :: tol,h,m,fa,fb,fm,one_trap,two_trap,left,right
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h  = b-a
      m  = (a+b)/TWO
      fa = self(a)
      fb = self(b)
      fm = self(m)
      one_trap = h*(fa+fb)/TWO
      two_trap = h*(fa+TWO*fm+fb)/FOUR
      if (abs(one_trap-two_trap)<THREE*tol) then
         res = (FOUR*two_trap - one_trap)/THREE
      else
         left  = .integrate_adaptive_trapezoid(a,m,tol/TWO)
         right = .integrate_adaptive_trapezoid(m,b,tol/TWO)
         res = left + right
      end
   end

   integrate_adaptive_simpson(a,b,accuracy) result(res) [recursive] [functional]
   ! Integrate the function "self" between the limits "a" and "b"
   ! using adaptive Simpson rule with acceleration.
   ! If present, "accuracy" is the required accuracy of the integral.
      interface
         self(x) result(res)
            DBL :: x,res
         end
      end 
      DBL :: a,b
      DBL, optional :: accuracy
      DBL :: res
      DBL :: tol,h,m1,m2,m3,fa,fb,f1,f2,f3,s1,s2,left,right
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h   = (b-a)/TWO
      m1  = (THREE*a+b)/FOUR
      m2  = (a+b)/TWO
      m3  = (a+THREE*b)/FOUR
      fa = self(a)
      fb = self(b)
      f1 = self(m1)
      f2 = self(m2)
      f3 = self(m3)
      s1 = h*(fa+FOUR*f2+fb)/THREE
      s2 = h*(fa+FOUR*f1+TWO*f2+FOUR*f3+fb)/SIX
      if (abs(s1-s2)<15.0d0*tol) then
         res = (16.0d0*s2 - s1)/15.0d0
      else
         left  = .integrate_adaptive_simpson(a,m2,tol/TWO)
         right = .integrate_adaptive_simpson(m2,b,tol/TWO)
         res = left + right
      end
   end

  fermi_population(E_fermi,temperature) result (res) [elemental]
  ! Returns the population of the level with energy "self".
  ! Input energies in Hartrees, temperature in Kelvin!!!!!
    DBL, IN :: E_fermi,temperature
    IN :: self
    DBL :: res,de,temp,de_on_temp
    de = (self - E_fermi) * JOULE_PER_HARTREE
    temp = temperature * BOLTZMANN_SI
    de_on_temp = de/temp
    if (de_on_temp > 500.0d0) then
      res = ZERO
    else
      if (de_on_temp < (-500.0d0)) then
        res = ONE
      else
        res = ONE / (E**(de_on_temp) + ONE)
        if (res < 1d-20) res = ZERO
        if (res > (1 - 1d-20)) res = ONE
      end
    end
  end

  minimise_bisect(val,previous,kept,tolerance,delta,done) [leaky]
  ! Returns new "self" which should be better than old "self".  Do at least
  ! twice to be sure.  Works by the bisection method.
  ! Dummy variable "done" is returned true if it has converged.
  ! "previous" s automatically created and destroyed.
  ! row 1 is for y, row 2 is for x, for y=f(x).
    MAT, PTR :: previous
    DBL, IN :: val,tolerance,delta
    INT, INOUT :: kept
    BIN, INOUT :: done
    DBL :: x1,x2,x3,y1,y2,y3

    done = FALSE
    if (NOT associated(previous)) then
      allocate(previous(3,2))
      kept = 0
    else
      ENSURE(size(previous,1) == 3, "matrix has wrong dimension")
      ENSURE(size(previous,2) == 2, "matrix has wrong dimension")
      ENSURE(kept <= 3 AND kept >=0,"invalid value for variable 'kept'")
    end
    select case (kept)
      case (0);      kept = 1
        previous(:,1) = (/val ,ZERO,ZERO/)
        previous(:,2) = (/self,ZERO,ZERO/)
        self = self + delta
        done = FALSE
      case (1);      kept = 2
        x1 = previous(1,2);      y1 = previous(1,1)
        if (self<x1) then
          previous(:,1) = (/val ,y1,ZERO/)
          previous(:,2) = (/self,x1,ZERO/)
          self = self - (x1-self)
        else
          previous(:,1) = (/y1,val ,ZERO/)
          previous(:,2) = (/x1,self,ZERO/)
          self = self + (self-x1)
        end
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        if (y1<y2) then
          self = x1 - delta
        else
          self = x2 + delta
        end
        done = FALSE
      case (2);      kept = 3
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        if (self<x1) then
          previous(:,1) = (/val ,y1,y2/)
          previous(:,2) = (/self,x1,x2/)
        else if (self>x2) then
          previous(:,1) = (/y1,y2,val /)
          previous(:,2) = (/x1,x2,self/)
        else
          previous(:,1) = (/y1,val ,y2/)
          previous(:,2) = (/x1,self,x2/)
        end
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        x3 = previous(3,2);      y3 = previous(3,1)

        if (y2<y1) then
          if (y2<y3) then
            if (y1<y3) then
              self = (x1+x2)/2
            else
              self = (x2+x3)/2
            end
          else
            self = x3 + HALF*(x3-x1)
          end
        else !y1<y2
          self = x1 - HALF*(x3-x1)
        end

        x1 = abs(previous(1,2)-self)
        x2 = abs(previous(2,2)-self)
        x3 = abs(previous(3,2)-self)
        y1 = max(x1,x2,x3)
        if (y1 < tolerance) then
          done = TRUE
          deallocate(previous)
        end
      case (3)
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        x3 = previous(3,2);      y3 = previous(3,1)
        if (self<x1) then
          previous(:,1) = (/val ,y1,y2/)
          previous(:,2) = (/self,x1,x2/)
        else if (self>x3) then
          previous(:,1) = (/y2,y3,val /)
          previous(:,2) = (/x2,x3,self/)
        else
          if (self<x2) then
            if (y1<y3) then
              previous(:,1) = (/y1,val ,y2/)
              previous(:,2) = (/x1,self,x2/)
            else
              previous(:,1) = (/y1,y2,val /)
              previous(:,2) = (/x1,x2,self/)
            end
          else
            if (y1>y3) then
              previous(:,1) = (/y2,val ,y3/)
              previous(:,2) = (/x2,self,x3/)
            else
              previous(:,1) = (/y1,y2,val /)
              previous(:,2) = (/x1,x2,self/)
            end
          end
        end
        x1 = previous(1,2);      y1 = previous(1,1)
        x2 = previous(2,2);      y2 = previous(2,1)
        x3 = previous(3,2);      y3 = previous(3,1)

        if (y2<y1) then
          if (y2<y3) then
            if (y1<y3) then
              self = (x1+x2)/2
            else
              self = (x2+x3)/2
            end
          else
            self = x3 + HALF*(x3-x1)
          end
        else !y1<y2
          self = x1 - HALF*(x3-x1)
        end
              
        x1 = abs(previous(1,2)-self)
        x2 = abs(previous(2,2)-self)
        x3 = abs(previous(3,2)-self)
        y1 = max(x1,x2,x3)
        if (y1 < tolerance) then
          done = TRUE
          deallocate(previous)
        end
    end
  end

  z_from_p result(res)
  ! Produces the normal deviate Z corresponding to a given lower
  ! tail area of P; Z is accurate to about 1 part in 10**16.
  ! Adapted from the Royal Statistical Society f77 routine "PPND16".
  ! algorithm AS241  appl. statist. (1988) vol 37, no 3.
    IN :: self
    DBL :: res,q,r
    q = self - HALF
    if (abs(q) < 0.425D0) then
      r = 0.180625D0 - q * q
      res = q * (((((((2.5090809287301226727D+3 * r + &
      3.3430575583588128105D+4) * r + 6.7265770927008700853D+4) * r + &
      4.5921953931549871457D+4) * r + 1.3731693765509461125D+4) * r + &
      1.9715909503065514427D+3) * r + 1.3314166789178437745D+2) * r + &
      3.3871328727963666080D0) / (((((((5.2264952788528545610D+3 * r + &
      2.8729085735721942674D+4) * r + 3.9307895800092710610D+4) * r + &
      2.1213794301586595867D+4) * r + 5.3941960214247511077D+3) * r + &
      6.8718700749205790830D+2) * r + 4.2313330701600911252D+1) * r + ONE)
    else
      if (q < ZERO) then
        r = self
      else
        r = ONE - self
      end
      if (r < ZERO) then
        DIE("probability is not between 0 and 1")
        res = ZERO
      else
        r = sqrt(-log(r))
        if (r < FIVE) then
          r = r - 1.6D0
          res = (((((((7.74545014278341407640D-4 * r + &
          2.27238449892691845833D-2) * r + 2.41780725177450611770D-1) * r + &
          1.27045825245236838258D0) * r + 3.64784832476320460504D0) * r + &
          5.76949722146069140550D0) * r + 4.63033784615654529590D0) * r + &
          1.42343711074968357734D0) / (((((((1.05075007164441684324D-9 * r + &
          5.47593808499534494600D-4) * r + 1.51986665636164571966D-2) * r + &
          1.48103976427480074590D-1) * r + 6.89767334985100004550D-1) * r + &
          1.67638483018380384940D0) * r + 2.05319162663775882187D0) * r + ONE)
        else
          r = r - FIVE
          res = (((((((2.01033439929228813265D-7 * r + &
          2.71155556874348757815D-5) * r + 1.24266094738807843860D-3) * r + &
          2.65321895265761230930D-2) * r + 2.96560571828504891230D-1) * r + &
          1.78482653991729133580D0) * r + 5.46378491116411436990D0) * r + &
          6.65790464350110377720D0) / (((((((2.04426310338993978564D-15 * r + &
          1.42151175831644588870D-7) * r + 1.84631831751005468180D-5) * r + &
          7.86869131145613259100D-4) * r + 1.48753612908506148525D-2) * r + &
          1.36929880922735805310D-1) * r + 5.99832206555887937690D-1) * r + ONE)
        end
        if (q < ZERO) res = - res
      end
    end
  end

  convert_to(units) 
  ! Convert the number "self" in atomic units or generic units to a 
  ! new number in "units"
     INOUT :: self
     STR(*), INOUT :: units
     STR :: word
     word = units
     word.to_lower_case
     select case (word)
        case ("degree");         self = self*DEGREE_PER_RADIAN
        case ("angstrom");       self = self*ANGSTROM_PER_BOHR
        case ("meter");          self = self*ANGSTROM_PER_BOHR*METER_PER_ANGSTROM
        case ("amu");            self = self*AMU_PER_MASS_OF_ELECTRON
        case ("wavenumber");     self = self*WAVENUMBER_PER_HARTREE
        case ("ev");             self = self*EV_PER_HARTREE
        case ("kelvin");         self = self*KELVIN_PER_HARTREE
        case ("joule");          self = self*JOULE_PER_HARTREE
        case ("kilojoule");      self = self*KJOULE_PER_HARTREE
        case ("kjoule");         self = self*KJOULE_PER_HARTREE
        case ("kj");             self = self*KJOULE_PER_HARTREE
        case ("kcal/mol");       self = self*KCALMOL_PER_HARTREE
        case default;            units = "unknown"
     end
  end

  convert_from(units) 
  ! Convert the number "self" from "units" system to a new number 
  ! in atomic units or generic units
     INOUT :: self
     STR(*), INOUT :: units
     STR :: word
     word = units
     word.to_lower_case
     select case (word)
        case ("degree");         self = self/DEGREE_PER_RADIAN
        case ("angstrom");       self = self/ANGSTROM_PER_BOHR
        case ("meter");          self = self/ANGSTROM_PER_BOHR*METER_PER_ANGSTROM
        case ("amu");            self = self/AMU_PER_MASS_OF_ELECTRON
        case ("wavenumber");     self = self/WAVENUMBER_PER_HARTREE
        case ("ev");             self = self/EV_PER_HARTREE
        case ("kelvin");         self = self/KELVIN_PER_HARTREE
        case ("joule");          self = self/JOULE_PER_HARTREE
        case ("kilojoule");      self = self/KJOULE_PER_HARTREE
        case ("kjoule");         self = self/KJOULE_PER_HARTREE
        case ("kj");             self = self/KJOULE_PER_HARTREE
        case ("kcal/mol");       self = self/KCALMOL_PER_HARTREE
        case default;            units = "unknown"
     end
  end

  to_units(units) result (res)
  ! Convert the number "self" in atomic units or generic units to a 
  ! new number in "units"
     IN :: self
     DBL :: res
     STR(*), INOUT :: units
     res = self
     res.convert_to(units)
  end

  from_units(units) result (res)
  ! Convert the number "self" from "units" system to a new number 
  ! in atomic units or generic units
     IN :: self
     DBL :: res
     STR(*), INOUT :: units
     res = self
     res.convert_from(units)
  end

  is_known_unit(unit) result (res)
  ! Return TRUE if "unit" is a known unit which can be used for conversion
  ! of "self".
     STR(*) :: unit
     BIN :: res
     STR :: word
     word = unit
     .convert_from(word)
     res = (word /= "unknown")
  end
        
end
