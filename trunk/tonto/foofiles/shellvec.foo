!---------------------------------------------------------------------------
!
!  SHELLVEC: A vector of gaussian SHELL data
!
!  (c) dylan jayatilaka, 1998
!
! $Id$
!---------------------------------------------------------------------------
module SHELLVEC

   use TYPES
   use SYSTEM
   use STR
   use STRVEC
   use TEXTFILE
   use SHELL

   implicit none

#  include "macros"
#  include "shellvec.int"

   STRVEC*, public :: shell_input_data_order DEFAULT_NULL

contains

!  ******************
!  Allocation methods
!  ******************

   create(dim)
   ! Create space for a shell vector
      PTR :: self
      INT :: dim
      nullify(self)
      allocate(self(dim))
      ADD_MEM(dim*SHELL_SIZE)
      .nullify_ptr_part
   end

   destroy
   ! Destroy space for a string vector
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(size(self)*SHELL_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify pointer parts of self
      INT :: s
      do s = 1,size(self)
         self(s).nullify_ptr_part
      end
   end

   destroy_ptr_part
   ! Destroy pointer parts of self
      INT :: s
      do s = 1,size(self)
         self(s).destroy_ptr_part 
      end
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   copy(sh) [leaky]
   ! Copy a shellvec "sh" to self
      SHELLVEC :: sh
      INT :: i
      ENSURE(size(self)==size(sh),"incompatible lengths")
      do i = 1,size(sh)
         self(i).copy(sh(i))
      end
   end

!  *************
!  Input methods
!  *************

   read [leaky]
   ! Read in data in the standard order from "stdin". 
   ! NOTE: Will create an SHELLVEC, if required.
   ! NOTE: defualt input order can be changed with shell_input_data_order.
      PTR :: self
      STRVEC* :: keywords
      STR :: word
      ENSURE(stdin.next_str=="{","expecting open bracket symbol, {")
      ENSURE(stdin.next_str/="}","empty data list!")
      stdin.move_to_previous_item
      if (shell_input_data_order.destroyed) then
         keywords.create(SHELL_INPUT_DATA_ORDER)
      else
         keywords.create(shell_input_data_order)
      end
      read_loop: do              ! Loop over input keywords
         stdin.read(word)
         word.to_lower_case
         select case (word)
            case("}");           exit read_loop
            case("data_order=")
               keywords.destroy
               stdin.read_ptr(keywords)
            case("data=");   
               ENSURE(stdin.next_str=="{","expecting open bracket symbol, {")
               .read_loop(keywords)
               ENSURE(stdin.next_str=="}","expecting close bracket symbol, }")
            case default
               stdin.move_to_previous_item
               .read_loop(keywords)
         end
      end do read_loop
      keywords.destroy
   end 

   read_loop(keywords) [leaky]
   ! Read in an "end" terminated list of plain-style data, where the order of
   ! the data is specified in the list of "keywords".
      PTR :: self
      STRVEC, IN :: keywords
      INT :: length
      length = .data_length(keywords)
      if (.created) then
        DIE_IF(length/=.n_shell,"list length is wrong")
      end
      if (.destroyed) .create(length)
      .process(keywords)
   end

   data_length(keywords) result(length) [leaky]
   ! Read ahead to get the number of data items in the list
   ! The list data begins with the first data item, not a "{" symbol.
   ! The list must be terminated by a "}" symbol.
      PTR :: self
      INT :: length
      STRVEC, IN :: keywords
      STR :: word
      SHELL* :: shell
      INT :: line,item
      ENSURE(stdin.next_str/="}","empty data list!")
      length = 0                      
      line = stdin.line_number        
      item = stdin.previous_line_item
      do                              ! Read ahead for the number of items
         stdin.move_to_previous_item
         shell.create
         shell.process(keywords)
         shell.destroy
         length = length + 1
         stdin.read(word)
         word.to_lower_case
         if (word=="}") exit
      end
      stdin.move_to_line(line)
      stdin.move_to_line_item(item)
   end

   process(keywords) [leaky]
   ! Read in the list information from "stdin". 
      PTR :: self
      STRVEC :: keywords
      INT :: s
      do s = 1,size(self)             ! Read the list
         self(s).process(keywords)
      end
   end 

   maximum_l_value result(res)
   ! Return the maximum l value in the shell vector
      INT :: res
      INT :: n
      res = 0
      do n = 1,size(self)
         res = max(res,self(n)%l)
      end
   end

   same_as(sh) result(same) 
   ! Return TRUE if the shell vector set "self" is the same as "sh". 
      SHELLVEC :: sh
      BIN :: same
      INT :: i
      if (.n_shell /= sh.n_shell) then; same = FALSE; RETURN
      end
      same = TRUE
      do i = 1,.n_shell
         same = same AND self(i).same_as(sh(i))
         if (NOT same) exit
      end
   end

   n_shell result (res)
   ! Return the size of the shell vector
      INT :: res
      res = size(self)
   end

   put
   ! Put the shellvec information to "stdout"
      INT :: i
      stdout.flush
      stdout.show("No. of shells   = ",.n_shell)
      stdout.show("Maximum l value = ",.maximum_l_value)
      stdout.flush
      stdout.text("Shell list:")
      do i = 1,.n_shell
         self(i).put
      end
   end
      
end 
