!-----------------------------------------------------------------------
!
! TEXTFILE : Line-oriented formatted sequential advancing file
! input/output, including input from standard input, and output to
! standard output.
!
! The TEXTFILE object is a FILE with a BUFFER and a REALFMT formatting
! object. The input/output proceeds via a line buffer. It is forbidden
! to open a TEXTFILE simultaneously for input and output.
!
! There is a default internal standard input object, "stdin",
! and a default standard output object, "stdout".
!
! A line count is maintained to allow back-tracking to previous lines,
! and particular items on each line. This is useful for input.
!
! For output, items can be put in columns of a specified width, with
! double precision numbers having a specified precision and "style"
! (set using fortran conventions). This is useful for dynamic tables,
! which the user can change at run time. Rewind and backtracking
! are not allowed for output files.
!
! It is possible to redirect the input or output to a new file
! using the "redirect" command. The previous file can be recovered
! using "unsave", or it will revert back automatically to the previous
! file if the redirected file ends. It is also possible to redirect
! input to an internal file. This is useful for processing a list of
! text as if it were a file. Output to an internal file is not allowed.
!
! Note that the input buffer is limited to size BSTR_SIZE, set in the
! "macros" file.
!
! The system information in "tonto" is updated whenever a I/O operation
! or a buffer operation is performed.
!
! Copyright (C) Dylan Jayatilaka, 1999
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module TEXTFILE

   implicit none

   stdin  :: TEXTFILE*, public DEFAULT_NULL
   stdout :: TEXTFILE*, public DEFAULT_NULL
   stderr :: TEXTFILE*, public DEFAULT_NULL

contains

!  *****************************
!  File creation type operations
!  *****************************

   create_stdin ::: leaky
   ! Create a the standard input file object, if needed.
   ! Return a pointer to it if already created
      self :: PTR

      if (stdin.destroyed) then

         ! Allocate and nullify
         allocate(stdin)
         ADD_LOCATION(SELF_TYPE_SIZE,stdin)
         stdin.nullify_ptr_part

         ! Set defaults
         .set_defaults

         ! Reset some defaults
         stdin.name = "stdin"
         stdin.action = "read"
         stdin.unit = TEXTFILE_STDIN_UNIT

      end

      ! Reset buffer ... ?
      stdin.buffer.set_defaults

      ! Return stdin
      self => stdin

   end

   create_stdout ::: leaky
   ! Create a standard output file object.
   ! Return a pointer to it if already created
      self :: PTR

      if (stdout.destroyed) then

         ! Allocate and nullify
         allocate(stdout)
         ADD_LOCATION(SELF_TYPE_SIZE,stdout)
         stdout.nullify_ptr_part

         ! Set defaults
         .set_defaults

         ! Reset some defaults
         stdout.name = "stdout"
         stdout.action = "write"
         stdout.unit = TEXTFILE_STDOUT_UNIT
      
      end

      ! Reset buffer ... ?
      stdout.buffer.set_defaults
      stdout.clear_and_put_margin

      ! Return stdout
      self => stdout

   end

   create_stderr ::: leaky
   ! Create a standard output file object.
   ! Return a pointer to it if already created
      self :: PTR

      if (stderr.destroyed) then

         ! Allocate and nullify
         allocate(stderr)
         ADD_LOCATION(SELF_TYPE_SIZE,stderr)
         stderr.nullify_ptr_part

         ! Set defaults
         .set_defaults

         ! Reset some defaults
         stderr.name = "stderr"
         stderr.action = "write"
         stderr.unit = TEXTFILE_STDERR_UNIT
      end

      ! Reset buffer ... ?
      stderr.buffer.set_defaults
      stderr.clear_and_put_margin

      ! Return stderr
      self => stderr

   end

   create(name) ::: leaky
   ! Create a textfile, and optionally set the name. Does not open the file.
      self :: PTR
      name :: STR, optional

      unit :: UNIT_NUMBER

      ! Allocate and nullify
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part

      ! Set defaults
      .set_defaults

      ! Set the name if present
      if (present(name)) .name = name

      ! Get a unique unit number
      unit.get(.unit) 

      ! Get ready to write
      .clear_and_put_margin

   end

   create(internal) ::: leaky
   ! Create an internal textfile
      self :: PTR
      internal :: VEC{STR}, IN

   ENSURE(.internal.destroyed,"internal file already exists")

      ! Allocate and nullify
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part

      ! Set defaults
      .set_defaults

      ! Reset some defaults
      .action = "read" 
      .no_of_lines = size(internal)
      .unit = 0

      ! Copy the internal file
      .name = "internal"
      .internal.create(size(internal))
      .internal = internal

      ! Get ready to read
      .read_line

   end

   destroy ::: leaky, recursive
   ! Destroy a textfile
      self :: PTR
      unit :: UNIT_NUMBER

      if (.destroyed) return

      .destroy_ptr_part

      if (.is_open) .close

      unit.free(.unit)

      deallocate(self)
      DELETE_MEMORY(SELF_TYPE_SIZE)

   end

   nullify_ptr_part
   ! Nullify the pointer parts of "self".
      nullify(.replacement_list)
      nullify(.internal)
      nullify(.saved)
      .buffer.nullify_ptr_part
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of "self", including any saved parts,
   ! which are destroyed recursively.
      .buffer.destroy_ptr_part
      .replacement_list.destroy
      .internal.destroy
      .saved.destroy
   end

   destroy_replacement_list ::: leaky
   ! Destroy the .replacement_list; needed if set_replacement_list is used
      .replacement_list.destroy
      .buffer.replacement_list.destroy
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(file) ::: recursive, leaky
   ! Create a copy of this textfile
      self :: PTR
      file :: TEXTFILE
      unit :: UNIT_NUMBER

      ! Create fresh file, with no name
      .create(" ")

      ! Free nameless file unit
      unit.free(.unit) 

      ! Copy the file, unit and all
      .copy(file)

   end

   copy(file,copy_saved) ::: recursive, leaky
   ! Make a copy of this textfile. If "saved" is TRUE, recursively
   ! copy the .saved component. Default is *not* to recursively copy.
      file :: TEXTFILE
      copy_saved :: BIN, optional
      
      ! Non pointer (simple) copy
      self = file

      ! Pointer parts are create-copied
      .nullify_ptr_part
      .buffer.copy(file.buffer)
      if (file.internal.created)         .internal.create_copy(file.internal)
      if (file.replacement_list.created) .replacement_list.create_copy(file.replacement_list)

      ! Copy saved only if requested (recursive)
      if (present(copy_saved)) then
      if (copy_saved) then
      if (file.saved.created)            .saved.create_copy(file.saved)
      end
      end

   end

!  ************
!  Set defaults
!  ************

   set_defaults
   ! Set defaults

      .name = "unknown"
      .action = "unknown"
      .unit = 0
      .record = 0
      .io_status = 0
      .ignore_end_of_file = FALSE
      .no_of_lines = -1

      .set_default_format

      .default_units = " "
      .comment_chars = TEXTFILE_COMMENT_CHARS
      .quote_chars   = TEXTFILE_QUOTE_CHARS
      .ignore_unmatched_quotes = FALSE
      .eliminate_specials = TRUE

      .buffer.set_defaults  ! Set defaults

   end

   set_default_format
   ! Set the default settings for the REAL formatting object
   ! Extra functions added compared to inherited code
      .using_fields       = TEXTFILE_USE_FIELDS
      .n_fields_per_line  = TEXTFILE_N_FIELDS_PER_LINE
      .spacing            = TEXTFILE_SPACING
      .int_width          = TEXTFILE_INT_WIDTH
      .real_width         = TEXTFILE_REAL_WIDTH
      .real_precision     = TEXTFILE_REAL_PRECISION
      .real_style         = TEXTFILE_REAL_STYLE
      .line_format        = " "
      .margin_width       = TEXTFILE_MARGIN_WIDTH
      .using_array_labels = TEXTFILE_USE_ARRAY_LABELS
   end

   set_no_of_lines
   ! Set the number of lines in the file

   ENSURE(.exists, "not an existing file!")
   ENSURE(.action=="read","not a readable file")

      unit,fail,l :: INT
      name :: STR
      line :: STR(8)
      stat :: STR(8)

      unit = .unit
      name = .name
      fail = 0

      ! Open the file
      if (IO_IS_ALLOWED) then

         open(unit=unit,           &
              file=trim(name),     &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=fail)
      end

      PARALLEL_BROADCAST(fail,0)
      DIE_IF(fail/=0,"error opening old file for reading: "//trim(name))
      .io_status = fail

      ! Read the lines until done
      if (IO_IS_ALLOWED) then
         l = 0
         do
            line = " "
            line = line
            read(unit,fmt="(a)",iostat=fail) line
            l = l + 1
          ! inquire(unit,position=stat) 
          ! print *,l,stat,line
            if (fail/=0) exit
         end 
      end

      PARALLEL_BROADCAST(l,0)

      ! Set the number of lines
      .no_of_lines = l - 1

      ! Rewind
      if (IO_IS_ALLOWED) then
         close(unit,iostat=fail)
      end

      PARALLEL_BROADCAST(fail,0)
      DIE_IF(fail/=0,"error closing file for reading: "//trim(name))
      .io_status = fail

   end

!  *******************
!  Saving and unsaving
!  *******************

   save ::: leaky
   ! Saved everything about the current textfile "self" in ".saved"
   ! Do not open a new textfile. Can be used to save style settings.
      self :: PTR
   ENSURE(.created,"no self")

      saved :: TEXTFILE*

      ! Keep self in saved
      saved => self

      ! Allocate fresh space for new self
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)

      ! Copy self --- keep all settings, even line number.
      ! NOTE: can't use self = saved since both are pointers 
      ! and it would copy the target of saved.
      self.copy(saved) 

      ! Make .saved the old self
      .saved => saved

   end

   unsave ::: leaky
   ! Go back to previously saved textfile settings. Note that this
   ! is not the same as reverting to a previously redirected textfile
      self :: PTR
   ENSURE(.saved.created,"no previous settings")

      saved :: TEXTFILE*

      ! Keep the old .saved component
      saved => .saved

      ! Destroy the pointer parts of self
      .buffer.destroy_ptr_part
      .replacement_list.destroy
      .internal.destroy

      ! Now deallocate self
      DELETE_MEMORY(SELF_TYPE_SIZE)
      deallocate(self)

      ! Self is the old .saved
      self  => saved
   end

!  *************************
!  Redirecting and reverting
!  *************************

   redirect(name) ::: leaky
   ! Save all the info for the current file in ".saved", and open a
   ! new textfile.  This is used for input, or output redirection. 
   ! The new file retains the style settings of the saved file
      self :: PTR
      name :: STR

      saved :: TEXTFILE*

      ! Keep self in saved
      saved => self

      ! Create a new self
      .create(name)

      ! The .saved component of new self is the old self
      .saved => saved

      ! Preserve old style settings
      .use_style(saved)

      ! Open the new file
      .open(for=.saved.action)

   end

   redirect(internal) ::: leaky
   ! Save all the info for the current file in ".saved", and open a
   ! new internal textfile. This is used for *only* input redirection.
   ! The new file retains the style settings of the saved file
      self :: PTR
      internal :: VEC{STR}, IN

      saved :: TEXTFILE*

      ! Keep self in saved
      saved => self

      ! Create new .internal file
      nullify(.internal)
      .create(internal)

      ! The .saved component of new self is the old self
      .saved => saved

      ! Preserve old style settings
      .use_style(saved)
   end

   revert ::: leaky
   ! Revert to the previously redirected textfile, but keep current
   ! style settings, including (for example) any default_units settings.
   ENSURE(.saved.created,"no previous settings")
      self :: PTR

      saved :: TEXTFILE*
      unit :: UNIT_NUMBER

      ! Preserve current style settings
      .saved.use_style(self)

      ! Soft-ending
      .saved.io_status = -1     

      ! Keep previous .saved file
      saved => .saved

      ! Destroy pointer parts of self ...
      ! Do not destroy .saved parts recursively, just deallocate
      if (.internal.created) then
         .internal.destroy      
      else
         .buffer.destroy_ptr_part
         .replacement_list.destroy
         .close
         unit.free(.unit)
      end
      DELETE_MEMORY(SELF_TYPE_SIZE)
      deallocate(self)          

      ! Self is the old .saved
      self => saved
   end

   use_style(saved) ::: private
   ! Revert to the previously saved style settings, including any
   ! default units.
      saved :: TEXTFILE

      .n_fields_per_line  = saved.n_fields_per_line
      .int_width          = saved.int_width
      .real_width         = saved.real_width
      .real_precision     = saved.real_precision
      .real_style         = saved.real_style
      .line_format        = saved.line_format
      .margin_width       = saved.margin_width
      .using_array_labels = saved.using_array_labels
      .default_units      = saved.default_units

      ! buffer parsing style ...
      .comment_chars      = saved.comment_chars
      .quote_chars        = saved.quote_chars
      .ignore_unmatched_quotes = saved.ignore_unmatched_quotes
      .eliminate_specials = saved.eliminate_specials

   end

!  ******************************
!  Opening, closing, and deletion
!  ******************************

   open
   ! Open the textfile based on its action attribute
   ENSURE(.action/="unknown","file has unknown action")
     .open(for=.action)
   end

   open(for)
   ! Open the textfile "for" either "read" or "write".
     for :: STR
     select case (for)
        case("read      ","reading   ","read-only ") ; .open_for_read
        case("write     ","writing   ","write-only") ; .open_for_write
        case default; UNKNOWN(for)
     end
   end

   open_for_read ::: private
   ! Open the input file. The input file object must already be created
   ! The file is positioned at the first line.
   ENSURE(.internal.destroyed,"no need to open an internal file")

      unit,fail :: INT
      name :: STR

      .action = "read"
      .io_status = 0

      unit = .unit
      name = .name
      fail = 0

      if (.exists) then
         .set_no_of_lines
      else
         DIE("the file "//trim(name)//" does not exist!")
      end

      if (IO_IS_ALLOWED) then

         open(unit=unit,           &
              file=trim(name),     &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=fail)
      end

      PARALLEL_BROADCAST(fail,0)
      DIE_IF(fail/=0,"error opening old file for reading: "//trim(name))
      .io_status = fail

   end

   open_for_write ::: private
   ! Open the output file associated with the output object

   ENSURE(.internal.destroyed,"no need to open an internal file")

      if (.exists) then; .open_old_file_for_write
      else;              .open_new_file_for_write
      end

   end

   open_old_file_for_write ::: private
   ! Open an old output file for writing

   ENSURE(.internal.destroyed,"no need to open an internal file")
   ENSURE(.exists, "not an existing file!")

      unit,fail :: INT
      name :: STR

      .action = "write"
      .io_status = 0

      unit = .unit
      name = .name
      fail = 0

      if (IO_IS_ALLOWED) then

         open(unit=unit,           &
              file=trim(name),     &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=fail)
      end

      PARALLEL_BROADCAST(fail,0)
      DIE_IF(fail/=0,"error opening old file: "//trim(name))
      .io_status = fail

      .clear_and_put_margin

   end

   open_new_file_for_write ::: private
   ! Open an new output file for writing

   ENSURE(.internal.destroyed,"no need to open an internal file")
   ENSURE(NOT .exists, "output file exists!")

      unit,fail :: INT
      name :: STR

      .action = "write"
      .io_status = 0

      unit = .unit
      name = .name
      fail = 0

      if (IO_IS_ALLOWED) then

         open(unit=unit,           &
              file=trim(name) ,    &
              status="new",        &
              access="sequential", &
              form="formatted",    &
              iostat=fail)
      end

      PARALLEL_BROADCAST(fail,0)
      DIE_IF(fail/=0,"error opening new file "//trim(name))
      .io_status = fail

   end

   close
   ! Close the input file
      opened :: BIN

      if (IO_IS_ALLOWED) then
         inquire(unit=.unit,opened=opened)
         if (opened) then
            close(unit=.unit)
         end
      end

   end

   close_and_delete
   ! Close the input file and delete it from the file system
      if (IO_IS_ALLOWED) then
         close(unit=.unit,status="delete")
      end
   end

   delete
   ! Delete the input file from the file system
      if (NOT .is_open) .open(for="read")
      .close_and_delete
   end

!  ***********************
!  Set quotes and specials
!  ***********************

   set_comment_chars(comment_chars)
   ! Set .comment_chars to "comment_chars".
      comment_chars :: STR
      .comment_chars = comment_chars
      .buffer.set_comment_chars(comment_chars)
   end

   set_quote_chars(quote_chars)
   ! Set .quote_chars to "quote_chars".
      quote_chars :: STR
      .quote_chars = quote_chars
      .buffer.set_quote_chars(quote_chars)
   end

   set_ignore_unmatched_quotes(ignore)
   ! Set .ignoire_unmatched_quote to "ignore".
      ignore :: BIN
      .ignore_unmatched_quotes = ignore
      .buffer.set_ignore_unmatched_quotes(ignore)
   end

   set_eliminate_specials(eliminate)
   ! Set .leiminate_soecials to "eliminate".
      eliminate :: BIN
      .eliminate_specials = eliminate
      .buffer.set_eliminate_specials(eliminate)
   end

   set_replacement_list(list) ::: leaky
   ! Set the replacement_list.
      list :: MAT{STR}*
   ENSURE(list.created,"list destroyed")
   ENSURE(list.dim2==2,"second dimension must be 2")
      .replacement_list.destroy
      .replacement_list.create_copy(list)
      .buffer.set_replacement_list(list)
   end

!  **********
!  Set format
!  **********

   set_int_width(val)
   ! Set the width of an integer field to "val"
      val :: INT
      ENSURE(val>=0,"width less than zero")
      .int_width = val
   end

   set_real_width(val)
   ! Set the width of an integer field to "val"
      val :: INT
      ENSURE(val>=0,"width less than zero")
      ENSURE(val>=.real_precision,"width smaller than precision")
      .real_width = val
   end

   set_n_fields_per_line(val)
   ! Set the number of fields per file to "val"
      val :: INT
   ENSURE(val>=0,"not enough fields")
      .n_fields_per_line = val
   end

   set_spacing(val)
   ! Set the spacing between fields
      val :: INT
   ENSURE(val>=0,"must be non-negative")
      .spacing = val
   end

   set_real_precision(val)
   ! Set the real precision i.e. no of decimal places to "val"
      val :: INT
      ENSURE(val>=0,"precision less than zero")
      ENSURE(val<=.real_width,"precision greater than field width")
      .real_precision = val
   end

   set_real_style(val)
   ! Set the fortran format style string
      val :: STR
      style :: STR
      style = val
      select case (style)
         case ("f","d","e","es","en","g")
         case default; UNKNOWN(style)
      end
      .real_style = style(1:2)
   end

   set_line_format(fmt)
   ! Set the line format from fortran format string "fmt". This should
   ! include the number of fields e.g. "5f10.3". The style must be a
   ! real style, not integer or string.
      fmt :: STR

      f,l,s :: INT
      tmp :: STR

      ! First and last character
      tmp = adjustl(fmt)
      tmp.get_next_item_position(f,l)
      DIE_IF(l==0, "fmt is blank")
      tmp = tmp(:l)
 
      ! Get the number of columns
      s = tmp.index_of_character_not_in("0123456789")
      DIE_IF(s==0, "fmt has no # of fields")
      .set_n_fields_per_line(tmp(:s-1).to_int)

      ! Get the style
      tmp = tmp(s:)
      s = tmp.index_of_character_in("0123456789")
      DIE_IF(s==0, "fmt has no real style")
      .set_real_style(tmp(:s-1))

      ! Get the width
      tmp = tmp(s:)
      s = tmp.index_of_character_not_in("0123456789")
      DIE_IF(s==0, "fmt has no width")
      DIE_IF(tmp(s:s)/=".", "fmt has no dot before precision")
      .set_real_precision(0)
      .set_real_width(tmp(:s-1).to_int)

      ! Get the precision
      tmp = tmp(s+1:)
      .set_real_precision(tmp.to_int)
      
   end

   set_using_fields(val)
   ! Set whether to use fields of fixed width or not.
      val :: BIN
      .using_fields = val
      .set_n_fields_per_line(0)
   end

   set_margin_width(val)
   ! Set the width of the margin in the buffer to "val"
   ! WARNING: buffer is cleared.
      val :: INT
   ENSURE(val>=0,"margin width less than zero")
   ENSURE(val<=STR_SIZE,"margin width too large")
      .margin_width = val
      .clear_and_put_margin
   end

   set_using_array_labels(using_array_labels)
   ! Set whether to use numbered column or row labels on matrix or vector output
      using_array_labels :: BIN
      .using_array_labels = using_array_labels
   end

   set_default_units(units)
   ! Set the .default_units to "units". This is reset back to 1
   ! after a particular number has been read and converted.
      units :: STR
   ENSURE(units==" " OR units.is_known_unit,"Unknown units!")
      .default_units = units
   end

!  *******************
!  Read format options
!  *******************

   read_keywords(in)
   ! Read the default output style parameters from another textfile, "in"
      self :: PTR
      in :: TEXTFILE*

   ENSURE(in.action=="read","file in is not an input file")

      word :: STR

      in.read(word)
      ENSURE(word=="{","expecting a {")

      ! Loop over keywords
      read_loop: do          
         in.read(word)
         word.to_lower_case
         if (word=="}")      exit read_loop
         .process_keyword(word,in)
      end do read_loop

   end

   process_keyword(keyword,infile) ::: leaky
   ! Process a command "keyword". Input keywords are optionally taken
   ! from "infile".
      self :: PTR
      keyword :: STR
      infile :: TEXTFILE*, optional

      input :: TEXTFILE*
      word,sty :: STR
      bin :: BIN
      val :: INT

      if (present(infile)) then; input => infile
      else;                      input => self
      end

      word = keyword
      word.to_lower_case

      select case (word)
         case ("int_width=          "); input.read(val); .set_int_width(val)
         case ("line_format=        "); input.read(sty); .set_line_format(sty)
         case ("margin_width=       "); input.read(val); .set_margin_width(val)
         case ("n_fields_per_line=  "); input.read(val); .set_n_fields_per_line(val)
         case ("precision=          "); input.read(val); .set_real_precision(val)
         case ("real_precision=     "); input.read(val); .set_real_precision(val)
         case ("real_style=         "); input.read(sty); .set_real_style(sty)
         case ("real_width=         "); input.read(val); .set_real_width(val)
         case ("use_array_labels=   "); input.read(bin); .set_using_array_labels(bin)
         case ("using_fields=       "); input.read(bin); .set_using_fields(bin)
         case ("using_array_labels= "); input.read(bin); .set_using_array_labels(bin)
         case default;                  UNKNOWN(word)
      end

   end

!  ***************
!  Inquiry methods
!  ***************

   exists(name) result (res)
   ! Returns true if the file exists on the file system.
   ! Uses "name" if present, otherwise ".name".
      name :: STR, optional
      res :: BIN

      if (present(name)) then
         if (IO_IS_ALLOWED) then
            inquire(file=trim(name),exist=res)
         end
      else
         if (IO_IS_ALLOWED) then
            inquire(file=trim(.name),exist=res)
         end
      end

      PARALLEL_BROADCAST(res,0)

   end

   is_open result (res)
   ! Returns true if the file has been opened
      res :: BIN

      if (.unit==TEXTFILE_STDIN_UNIT OR .unit==TEXTFILE_STDOUT_UNIT) then

         res = TRUE ! not needed for stdin, stdout

      else

        if (IO_IS_ALLOWED) then
           inquire(file=.name,opened=res)
         ! inquire(unit=.unit,opened=res)
        end
        PARALLEL_BROADCAST(res,0)

      end

   end

   unit_used result (res)
   ! Returns true if the file unit is in use
      res :: BIN
      if (IO_IS_ALLOWED) then
        inquire(unit=.unit,opened=res)
      end
      PARALLEL_BROADCAST(res,0)
   end

   next_line_item result (res)
   ! Return the index of the next item to be processed on the line
      res :: INT
      res = .buffer.next_item_number
   end

   previous_line_item  result (res)
   ! Return the index of the previous item to be processed on the line
      res :: INT
      res = .buffer.item_index
   end

   last_line_item  result (res)
   ! Return the index of the final item on the line
      res :: INT
      res = .buffer.n_items
   end

   n_line_items result (res)
   ! Return the number of items on the line
      res :: INT
      res = .buffer.n_items
   end

   at_end_of_line result (res)
   ! Return TRUE if at the end of the line
      res :: BIN
      res = .buffer.item_index==.buffer.n_items
   end

   line_number result (res)
   ! Return the input file line number which is being processed
      res :: INT
      res = .record
   end

   buffer_string result (res)
   ! Put a string into the buffer
      res :: STR(len=BSTR_SIZE)
      res = .buffer.buffer_string
   end

   end_of_file result (res)
   ! See if .io_status/=0, indicating the end of file has been found.
      res :: BIN
      res = .io_status/=0
   end

   reverted result (res)
   ! See if .io_status/=0, indicating an internal file has ended 
   ! i.e. a soft ending).  
      res :: BIN
      res = .io_status/=0 
   end

   reset_io_status
   ! Reset manually the io_status if it is safe to do so.
      .io_status = 0
   end

   at_end_of_file result (res)
   ! Read a line into the buffer from the input file and see if it is
   ! at the end of file. This is an explicit test, not just a viewing
   ! of ".io_status".  NOTE: If all lines to the end of file are
   ! empty, then the result is also true.
      res :: BIN

   ENSURE(.action=="read","file does not have read status")

      word :: STR
      ignore :: BIN

      ! Save ignore EOF status
      ignore = .ignore_end_of_file 
      .ignore_end_of_file = TRUE

      ! Read a word ...
      .read(word)

      ! Is it the end of file?
      res = .end_of_file

      ! Reset .io_status and move back
      .io_status = 0
      .move_to_previous_item

      ! Put back ignore EOF status
      .ignore_end_of_file = ignore 

   end

   buffer_exhausted result (res)
   ! Return whether the buffer is exhausted
     res :: BIN
       res = .buffer.exhausted
   end

!  **********************************
!  Line repositioning type operations
!  **********************************

   read_line
   ! Read a line into the buffer. (The routine is recursive because there may
   ! need to be a reversion to a previously redirected file).
      if (.internal.created) then; .read_line_internal
      else;                        .read_line_external
      end
   end

   read_line_internal ::: private
   ! Read a line into the buffer from the internal file. If the file
   ! ends, this routine dies, UNLESS (1) .ignore_end_of_file is set,
   ! in which case another succesive failure to read a line will
   ! generate an error (this prevents infinite read loops, and is also
   ! useful for testing whether at the end of a file), OR (2) there is
   ! a .saved file, in which case the current file reverts to the
   ! saved file, and an attempt is made to read from that saved file.

   ENSURE(.internal.created,"no internal file")

      string :: STR(len=BSTR_SIZE)

      .update_system_info

      if (.record<size(.internal)) then      ! No errors.

         .io_status = 0
         .record = .record + 1
         string = .internal(.record)
         .buffer.set_and_analyse(string)
      
      else                                   ! At end of file.

         .io_status = 1
         if (.ignore_end_of_file) then       ! Ignore end of file ... 
            .ignore_end_of_file = FALSE      ! Next time don't ignore
         else                               
            if(.saved.created) then          ! It's OK, go back to saved file
               DIE("did you forget to set ignore_end_of_file?")
            else
               DIE("unexpected end of file") ! Die if nothing saved
            end
         end

      end

      .update_system_info

   end

   read_line_external ::: private
   ! Read a line into the buffer from the input file. If the file
   ! ends, this routine dies, UNLESS (1) .ignore_end_of_file is set,
   ! in which case another succesive failure to read a line will
   ! generate an error (this prevents infinite read loops, and is also
   ! useful for testing whether at the end of a file), OR (2) there is
   ! a .saved file, in which case the current file reverts to the
   ! saved file, and an attempt is made to read that saved file.

   ENSURE(.is_open,"file is not open")
   ENSURE(.action=="read","file does not have read action!")

      string :: STR(len=BSTR_SIZE)
      unit,fail :: INT

      ! Update
      .update_system_info

      ! Read a line
      if (IO_IS_ALLOWED) then
         unit = .unit
         fail = 0
         string = " "
         read(unit=unit,fmt="(a)",iostat=fail) string          ! could fail
         if (.record>=.no_of_lines) fail = TEXTFILE_IOSTAT_EOF ! could also fail
       ! inquire(unit=.unit,position=position)
       ! print *,.record
       ! print *,trim(string)
       ! print *,trim(position)
      end

      PARALLEL_BROADCAST(string,0)
      PARALLEL_BROADCAST(fail,0)

      ! Set IO status
      .io_status = fail

      ! Is the read OK?
      select case (.io_status)
         
         case (0)                               

            ! No errors. Analyse the line
            .io_status = 0              
            .buffer.set_and_analyse(string) 
            .record = .record + 1

         case (TEXTFILE_IOSTAT_EOF)             

            ! Expected EOF
            if (.ignore_end_of_file) then       

               ! Next time don't ignore EOF
               .ignore_end_of_file = FALSE      
               .record = .record + 1

            ! Unexpected EOF
            else                               

               if(.saved.created) then          
                  DIE("unexpected end of file -- did you forget to REVERT?")
               else
                  DIE("unexpected end of file") 
               end

            end
         
         case default                           
         
            ! Some error, but not end of file.
            DIE("read error")

      end

      ! Update
      .update_system_info

   end

   update_line ::: private
   ! Get the next non-exhausted line if the current one is exhausted---and in
   ! this case, the buffer pointer is positioned before the first line item.
   ! This routine performs a reversion if there is a .saved file.
      do
         if (.buffer.not_exhausted) exit
         .read_line
         if (.end_of_file) exit  
      end
   end

   revert_line ::: private
   ! Revert back to the previous non-exhausted line in the input file if the
   ! current buffer pointer is before the first item; and in this case,
   ! the buffer pointer is repositioned *after* the last line item.
      do
         if (.next_line_item>1) exit
         .backspace_line
         .move_to_line_item(.last_line_item+1)
      end
   end

   skip_next_item ::: leaky
   ! Move to the next item in the input file.
      .update_line
      .buffer.skip_item
   end

   move_to_previous_item
   ! Move to the previous item in the input file. Backspace a line if required.
      .revert_line
      .move_to_previous_item_on_line     ! move to the last read item
   end

   move_to_last_item_on_line
   ! Move the cursor over to the beginning of the last item on the line
      item :: INT
      item = .last_line_item
      .move_to_line_item(item)
   end

   move_to_previous_item_on_line
   ! Move the cursor over to the beginning of the previous item on the
      item :: INT
      item = .previous_line_item
      .move_to_line_item(item)
   end

   move_to_line_item(number)
   ! Move the cursor over to the beginning of the item with index "number"
   ! on the current line. (More accurately: after the end of the previous item
   ! on the current line. So if there are "nitems" on the line you can move to
   ! "nitem+1" if you want to, and that will be the end of the line).
      number :: INT
      n :: INT
      .update_system_info
      n = number
      .buffer.move_to_item(n)
   end

   rest_of_line result (res)
   ! If there is anything left on the input line, then it is returned, else
   ! nothing is returned.  Record moves to the next line.
      res :: STR
   ENSURE(.action=="read","file does not have read action!")
      if (NOT .buffer.empty) then
         res = .buffer.string(.buffer.item_end+1: )
         .read_line
      else
         res = " "
         .read_line
      end
   end

   rewind
   ! Rewind the input file, reading the first line for read-only files.
      if (.internal.created) then; .rewind_internal
      else;                        .rewind_external
      end
      select case (.action)
         case("read      ","reading   ","read-only "); .read_line
         case("write     ","writing   ","write-only") 
         case default; UNKNOWN(.action)
      end
   end

   rewind_internal ::: private
   ! Rewind the input file, but do not read a line.
      .record = 0
      .io_status = 0
   end

   rewind_external ::: private
   ! Rewind the input file, but do not read a line.

      fail :: INT

      .update_system_info

      fail = 0
      if (IO_IS_ALLOWED) then
         rewind(unit=.unit,iostat=fail)
      end
      PARALLEL_BROADCAST(fail,0)
      DIE_IF(fail>0,"rewind error")
      .io_status = fail

      .record = 0

   end

   move_to_end
   ! Move to the end of the input file
      if (.internal.created) then; .move_to_end_internal
      else;                        .move_to_end_external
      end
   end

   move_to_end_internal ::: private
   ! Move to the end of the input file
      .record = size(.internal)-1
      .read_line
   end

   move_to_end_external ::: private
   ! Move to the end of the input file

      fail :: INT

      .update_system_info

      ! Read till failure
      do

         fail = 0
         if (IO_IS_ALLOWED) then
            read(unit=.unit, fmt="()", iostat=fail)
         end
         PARALLEL_BROADCAST(fail,0)

         if (fail/=0) exit

         .record = .record + 1

      end

      ! Backspace twice
      if (IO_IS_ALLOWED) then
         backspace(unit=.unit,iostat=fail)
         backspace(unit=.unit,iostat=fail)
      end
      PARALLEL_BROADCAST(fail,0)

      ! Set the IO status
      .io_status = fail

      ! Set the record
      .record = max(0,.record-1)

      ! Get the last line
      .read_line

   end

   backspace_line
   ! Reprocess previously input line
      .move_to_record(.record-1)
   end

   skip_line
   ! Skip the next line in the input file
      .move_to_record(.record+1)
   end

   move_to_line(line)
   ! Make sure that "line" was the last one processed
   ! in the input file
      line :: INT
   ENSURE(line>=0,"line number must be non-negative")
      .move_to_record(line)
   end

   move_to_record(rec)
   ! Move to the requested record "rec" in the input file.
   ! and read it into the buffer. Set .record to the 
   ! last processed record.
      rec :: INT
      if (.internal.created) then; .move_to_record_internal(rec)
      else;                        .move_to_record_external(rec)
      end
   end

   move_to_record_internal(rec) ::: private
   ! Move to the requested record "rec" in the internal file.
   ! and read it into the buffer. Set .record to the 
   ! last processed record.
      rec :: INT
   ENSURE(rec>=0,"record number must be non-negative")
   ENSURE(rec<=size(.internal),"record outside file range")
      .record = rec-1
      .read_line
   end

   move_to_record_external(rec) ::: private
   ! Move to the requested record "rec" in the input file.
   ! and read it into the buffer. Set .record to the 
   ! last processed record.
      rec :: INT

   ENSURE(rec>=0,"record number must be non-negative")

      fail :: INT

      .update_system_info

      if (rec<(.record+1)) then

         do

            fail = 0
            if (IO_IS_ALLOWED) then
               backspace(unit=.unit,iostat=fail)
            end
            PARALLEL_BROADCAST(fail,0)
            DIE_IF(fail>0,"backspace error")
            .io_status = fail

            .record = .record - 1

            if (rec==(.record+1)) exit

         end

      else if (rec>(.record+1)) then

         do

           fail = 0
           if (IO_IS_ALLOWED) then
              read(unit=.unit,fmt="()",iostat=fail)
           end
           PARALLEL_BROADCAST(fail,0)
           DIE_IF(fail>0,"read error")
            .io_status = fail

           .record = .record + 1

           if (rec==(.record+1)) exit

         end

      end

      .read_line

   end

!  ***********
!  Line search
!  ***********

   look_for_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)
   ! Scans through the file for a token which includes the given "item" (the
   ! token in the file must be a separate thing surrounded by whitespace, begin
   ! or end of line, or comment characters; whereas "item" may may match only a
   ! part of a given token). If a token matching "item" exists, the file cursor
   ! is left just after this token. If no match is found, the file is rewound to
   ! the initial line of the search.  If "from" is present then it is used as
   ! the start line for the search. If "until" is present, it is used as the
   ! last line of the search. If "end_tokens" is present then an exact match to
   ! any of these tokens indicates the end of search for "item".  If
   ! "exact_match" is present and TRUE, then "item" must match exactly the token
   ! in the file, instead of just being included in it. If "head_match" is
   ! present and TRUE, then occurs only if the characters at the head of the
   ! "item" string match the token in the file. only If "return_cursor" is
   ! present and FALSE, the cursor is not returned to the starting line of the
   ! search in the case where no match is found. If "found" is present, it is
   ! set TRUE when the item is found, else FALSE. 
      item :: STR, IN
      from,until :: INT, IN, optional
      end_tokens :: VEC{STR}, IN, optional
      exact_match,head_match,return_cursor :: BIN, IN, optional
      found :: BIN, OUT, optional

      start_record :: INT
      word :: STR
      fnd,exact,head,put_back,has_item,has_end,match :: BIN
      i :: INT

      .ignore_end_of_file = TRUE
      fnd = FALSE

      ! Look from current record
      start_record = .record                

      ! Look from record "from"
      if (present(from)) then
         start_record = from
         if (from==1) then; .rewind
         else;              .move_to_record(from)
         end
      end

      ! Rewind to original record?
      put_back = TRUE
      if (present(return_cursor)) put_back = return_cursor

      ! Loop over file lines
      if (NOT .end_of_file) then

        if (present(until)) then
        ENSURE(until>=start_record,"ending line must be greater than starting line")
        end

        exact = FALSE; if (present(exact_match)) exact = exact_match
        head = FALSE;  if (present(head_match))  head = head_match
        ENSURE(NOT (head AND exact),"don't specify head *and* exact match")

        has_end = FALSE

        line_search: do                       ! Now do the search here ...

           has_item = .buffer.string.includes(item)
           if (present(end_tokens) AND .record>start_record) &
           has_end = .buffer.string.includes_any_in(end_tokens)

           if (has_item OR has_end) then

              do i = 1,.buffer.n_items

                 .get_next_item(word)

                 if (has_item) then
                    if (head) then;           match = word.includes(item,at_start=TRUE)
                    else if (exact) then;     match = word==item
                    else if (NOT exact) then; match = word.includes(item)
                    end
                    if (match) then           ! Found a match
                       fnd = TRUE; exit line_search
                    end
                 end

                 if (has_end) then
                    if (end_tokens.has_any_included_in(word,at_start=TRUE)) exit line_search
                 end

              end

           end

           if (present(until)) then
              if (.record==until) exit line_search
           end

           .read_line

           if (.end_of_file) exit line_search

        end do line_search

      end

      if (present(found)) found = fnd
      if (NOT fnd AND put_back) .move_to_record(start_record)

      .ignore_end_of_file = FALSE

   end

   look_backwards_for_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)
   ! Scans *backwards* through the file for a token which includes the given
   ! "item" (the token in the file must be a separate thing surrounded by
   ! whitespace, begin or end of line, or comment characters; whereas "item" may
   ! may match only a part of a given token). If a token matching "item" exists,
   ! the file cursor is left just after this token. If no match is found, the
   ! file is rewound to the initial line of the search.  If "from" is present
   ! then it is used as the start line for the search. If "until" is present, it
   ! is used as the last line of the search. If "end_tokens" is present then an
   ! exact match to any of these tokens indicates the end of search for "item".
   ! If "exact_match" is present and TRUE, then "item" must match exactly the
   ! token in the file, instead of just being included in it. If "head_match" is
   ! present and TRUE, then occurs only if the characters at the head of the
   ! "item" string match the token in the file. only If "return_cursor" is
   ! present and FALSE, the cursor is not returned to the starting line of the
   ! search in the case where no match is found. If "found" is present, it is
   ! set TRUE when the item is found, else FALSE. 
      item :: STR, IN
      from,until :: INT, IN, optional
      end_tokens :: VEC{STR}, IN, optional
      exact_match,head_match,return_cursor :: BIN, IN, optional
      found :: BIN, OUT, optional

      start_record,end_record :: INT
      word :: STR
      fnd,exact,head,put_back,has_item,has_end,match :: BIN
      i :: INT

      .ignore_end_of_file = TRUE

      fnd = FALSE

      start_record = .record                ! Initialise switches and counters

      if (present(from)) start_record = from

      .move_to_record(start_record)         ! Possible EOF here ...

      put_back = TRUE; if (present(return_cursor)) put_back = return_cursor

      if (NOT .end_of_file) then
        .move_to_last_item_on_line
        end_record = 1; if (present(until)) end_record = until
        ENSURE(end_record<=start_record,"ending line must be smaller than starting line")
        exact = FALSE; if (present(exact_match)) exact = exact_match
        head = FALSE;  if (present(head_match))  head = head_match
        ENSURE(NOT (head AND exact),"don't specify head *and* exact match")

        has_end = FALSE

        line_search: do                       ! Now do the search here ...

           has_item = .buffer.string.includes(item)
           if (present(end_tokens) AND .record>start_record) &
           has_end = .buffer.string.includes_any_in(end_tokens)

           if (has_item OR has_end) then
              do i = .buffer.n_items,1,-1     ! Look backwards ...
                 .move_to_line_item(i)
                 .get_next_item(word)
                 if (has_item) then
                    if (head) then;           match = word.includes(item,at_start=TRUE)
                    else if (exact) then;     match = word==item
                    else if (NOT exact) then; match = word.includes(item)
                    end
                    if (match) then           ! Found a match
                       fnd = TRUE; exit line_search
                    end
                 end
                 if (has_end) then
                    if (end_tokens.has_any_included_in(word,at_start=TRUE)) exit line_search
                 end
              end
           end

           if (.record==end_record) exit line_search

           .backspace_line                    ! Move to previous line

        end do line_search

      end

      if (present(found)) found = fnd

      if (NOT fnd AND put_back) .move_to_record(start_record)

      .ignore_end_of_file = FALSE

   end

   look_for_any_item(item,from,until,end_tokens,exact_match,head_match,return_cursor,found)
   ! Scans through the file for a token which includes the any of the given
   ! elements in the "item" list (the token in the file must be a separate thing
   ! surrounded by whitespace, begin or end of line, or comment characters;
   ! whereas "item" may may match only a part of a given token). If a token
   ! matching "item" exists, the file cursor is left just after this token. If
   ! no match is found, the file is rewound to the initial line of the search.
   ! If "from" is present then it is used as the start line for the search. If
   ! "until" is present, it is used as the last line of the search. If
   ! "end_tokens" is present then an exact match to any of these tokens
   ! indicates the end of search for "item".  If "exact_match" is present and
   ! TRUE, then "item" must match exactly the token in the file, instead of just
   ! being included in it. If "head_match" is present and TRUE, then occurs only
   ! if the characters at the head of the "item" string match the token in the
   ! file. only If "return_cursor" is present and FALSE, the cursor is not
   ! returned to the starting line of the search in the case where no match is
   ! found. If "found" is present, it is set TRUE when the item is found, else
   ! FALSE. 
      item :: VEC{STR}, IN
      from,until :: INT, IN, optional
      end_tokens :: VEC{STR}, IN, optional
      exact_match,head_match,return_cursor :: BIN, IN, optional
      found :: BIN, OUT, optional
      start_record :: INT
      word :: STR
      fnd,exact,head,put_back,has_item,has_end,match :: BIN
      i,j :: INT
      .ignore_end_of_file = TRUE
      fnd = FALSE
      start_record = .record                ! Initialise switches and counters
      if (present(from)) then
         start_record = from
         if (from==1) then; .rewind         ! The following may yeild an EOF
         else;              .move_to_record(from)
         end
      end
      put_back = TRUE; if (present(return_cursor)) put_back = return_cursor
      if (NOT .end_of_file) then
        if (present(until)) then
        ENSURE(until>=start_record,"ending line must be greater than starting line")
        end
        exact = FALSE; if (present(exact_match)) exact = exact_match
        head = FALSE;  if (present(head_match))  head = head_match
        ENSURE(NOT (head AND exact),"don't specify head *and* exact match")
        has_end = FALSE
        line_search: do                       ! Now do the search here ...
           has_item = .buffer.string.includes_any_in(item)
           if (present(end_tokens) AND .record>start_record) &
           has_end = .buffer.string.includes_any_in(end_tokens)
           if (has_item OR has_end) then
              do i = 1,.buffer.n_items
                 .get_next_item(word)
                 if (has_item) then
                    if (head) then
                       do j = 1,item.dim
                          match = word.includes(item(j),at_start=TRUE)
                          if (match) exit
                       end
                    else if (exact) then
                       do j = 1,item.dim
                          match = word==item(j)
                          if (match) exit
                       end
                    else if (NOT exact) then
                       do j = 1,item.dim
                          match = word.includes(item(j))
                          if (match) exit
                       end
                    end
                    if (match) then           ! Found a match
                       fnd = TRUE; exit line_search
                    end
                 end
                 if (has_end) then
                    if (end_tokens.has_any_included_in(word,at_start=TRUE)) exit line_search
                 end
              end
           end
           if (present(until)) then
              if (.record==until) exit line_search
           end
           .read_line
           if (.end_of_file) exit line_search
        end do line_search
      end
      if (present(found)) found = fnd
      if (NOT fnd AND put_back) .move_to_record(start_record)
      .ignore_end_of_file = FALSE
   end

   look_for(item,from,until,first,found)
   ! Scans through the file for a line which includes string "item".  If there,
   ! the file record is left at the first line at which the match occured.  If
   ! no match is found, the file is rewound to the initial line before the
   ! search.  If "from" is present then it is used as the start line for the
   ! search, and if "item" is not found the file record is returned to that
   ! line.  If "until" is present then matches to these tokens are used to
   ! indicate the end of search condition for "item". If "first" is present and
   ! TRUE, then the item is matched only if it is the first non-blank token in
   ! the input, and likewise the search is terminated only when the "until"
   ! tokens are the first characters in the input. If "found" is present, it is
   ! set TRUE when the item is found, else FALSE.
      item :: STR, IN
      from :: INT, IN, optional
      until :: VEC{STR}, IN, optional
      first :: BIN, IN, optional
      found :: BIN, OUT, optional

      start_record :: INT
      word :: STR

      start_record = .record

      if (present(from)) then
         if (from==1) then
            .rewind
            start_record = 1
         else
            .move_to_record(from)
            start_record = from
         end
      else
         ENSURE(start_record>0,"must start looking from +ve line number")
      end

      if (present(found)) found = FALSE

      .ignore_end_of_file = TRUE

      line_search: do

         word = .buffer.string.trim_blanks_from_start

         if (item.is_included_in(word,first)) then
            if (present(found)) found = TRUE
            exit line_search
         end

         if (present(until) AND .record>start_record) then
         if (until.has_any_included_in(word,first)) then
            .move_to_record(start_record)
            if (present(found)) found = FALSE
            exit line_search
         end
         end

         .read_line
         if (.end_of_file) then
            .move_to_record(start_record)
            if (present(found)) found = FALSE
            exit line_search
         end

      end do line_search

      .ignore_end_of_file = FALSE

   end

   look_backwards_for(item,from,until,first,found)
   ! Scans backward through the file for a line which includes string "item".
   ! If there, the file record is left at the first line at which the match
   ! occured.  If no match is found, the file is rewound to the initial line
   ! before the search.  If "from" is present then it is used as the start line
   ! for the search, and if "item" is not found the file record is returned to
   ! that line.  If "until" is present then matches to these tokens are used to
   ! indicate the end of search condition for "item". If "first" is present and
   ! TRUE, then the item is matched only if it is the first non-blank token in
   ! the input, and likewise the search is terminated only when the "until"
   ! tokens are the first characters in the input. If "found" is present, it is
   ! set TRUE when the item is found, else FALSE.
      item :: STR, IN
      from :: INT, IN, optional
      until :: VEC{STR}, IN, optional
      first :: BIN, IN, optional
      found :: BIN, OUT, optional
      start_record :: INT
      word :: STR
      start_record = .record
      if (present(from)) then
         .move_to_record(from)
         start_record = from
      end
      if (present(found)) found = FALSE
      .ignore_end_of_file = TRUE
      do
         word = .buffer.string.trim_blanks_from_start
         if (item.is_included_in(word,first)) then
            if (present(found)) found = TRUE
            exit
         end
         if (.record==1) then ! This is the start of the file
            .move_to_record(start_record)
            if (present(found)) found = FALSE
            exit
         end
         .backspace_line
         if (present(until) AND .record<start_record) then
         if (until.has_any_included_in(word,first)) then
            .move_to_record(start_record)
            if (present(found)) found = FALSE
            exit
         end
         end
      end
      .ignore_end_of_file = FALSE
   end

   has_string(search) result (res)
   ! Returns TRUE if the file contains string "search". The file is returned
   ! to its original line number after this routine.
      search :: STR
      res :: BIN
      update_record :: INT
      found :: BIN
      update_record = .record
      .rewind
      .ignore_end_of_file = TRUE
      found = FALSE
      do
         if (search.is_included_in(.buffer.string)) then
           found = TRUE
           exit
         end
         .read_line
         if (.end_of_file) exit
      end
      .move_to_record(update_record)
      .ignore_end_of_file = FALSE
      res = found
   end

!  **************************
!  Data input type operations
!  **************************

! Basic

   get_next_item(word) ::: private
   ! Get the next item in the file
      word :: STR
      .update_line
      .buffer.get(word)
   end

   next_item result(word) ::: leaky
   ! Read a str from the input file and return it but
   ! *do not advance the cursor*. Use next_str for that.
      word :: STR
      .read(word)
      .move_to_previous_item
   end

   next_str result(word) ::: leaky
   ! Read a str from the input file and return it and advance the cursor
      word :: STR
      .read(word)
   end

! Read a built-in TYPE 

   read(value) ::: template
   ! Read a built-in type into "value".
      value :: TYPE, OUT

   ENSURE(.action=="read","file does not have read action!")

      .update_line
      .buffer.get(value)

   end

   read(value) ::: get_from(TEXTFILE, TYPE=>STR)
   ! Read a built-in type into "value".
   end

   read(value) ::: get_from(TEXTFILE, TYPE=>BIN)
   ! Read a built-in type into "value".
   end

   read(value) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Read a built-in type into "value".
   end

   read(value) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Read a built-in type into "value".
   end

   read(value,format)
   ! Read a formatted REAL into "value". Does not check the end of line!
      value :: REAL, OUT
      format :: STR, IN

   ENSURE(.action=="read","file does not have read action!")

      .update_line
      .buffer.get(value,format)

   end

   read(value,error)
   ! Read a REAL into "value" and also its associated "error", which appears in
   ! parentheses after it.
      value,error :: REAL, OUT

   ENSURE(.action=="read","file does not have read action!")

      .update_line
      .buffer.get(value,error)

   end

   read(value) ::: get_from(TEXTFILE, TYPE=>CPX)
   ! Read a built-in type into "value".
   end

! Read a built-in TYPE quantity

   read_quantity(value) ::: template
   ! Read a number quantity (with optional units) into "value".
   ! WARNING: You must *not* be at the end of file to use this
   ! routine, since it will try to read the next token as a units specifier. 
      value :: TYPE, OUT

   ENSURE(.action=="read","file does not have read action!")

      units :: STR
      known_unit :: BIN

      ! Read the value
      .read(value)

      ! Convert from assumed default units
      if (.default_units/=" ") &
        value.convert_from(.default_units)

      ! Check for explicit units
      if (NOT .at_end_of_file) then

        ! Is there a known unit next?
        .read(units)
        known_unit = units.is_known_unit

        ! Has conversion already been done?
        DIE_IF(known_unit AND .default_units/=" ","two units specified!")

        ! Convert from known units if we can ...
        ! Or move back to where we were
        if (known_unit) then; value.convert_from(units)              
        else;                 .move_to_previous_item
        end

      end

      ! Reset default units
      .default_units = " "

   end

   read_quantity(value) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Read a number quantity (with optional units) into "value".
   ! WARNING: You must *not* be at the end of file to use this
   ! routine, since it will try to read the next token as a units specifier. 
   end

   read_quantity(value) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Read a number quantity (with optional units) into "value".
   ! WARNING: You must *not* be at the end of file to use this
   ! routine, since it will try to read the next token as a units specifier. 
   end

! Read VEC{TYPE}

   read(v) ::: template
   ! Read in a vector sequentially. Line breaks are not significant.
      v :: VEC{TYPE}, OUT
      i :: INT
      do i = 1,v.dim
         .read(v(i))
      end
   end

   read(v) ::: get_from(TEXTFILE, TYPE=>STR)
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v) ::: get_from(TEXTFILE, TYPE=>BIN)
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Read in a vector sequentially. Line breaks are not significant.
   end

   read(v) ::: get_from(TEXTFILE, TYPE=>CPX)
   ! Read in a vector sequentially. Line breaks are not significant.
   end

! Read VEC{TYPE} quantities

   read_quantity(v) ::: template
   ! Read in a vector quantity (with units).  Line breaks are not
   ! significant.  WARNING: You must *not* be at the end of file to
   ! use this routine, since it will try to read the next token after
   ! the vector as a units specifier. 
      v :: VEC{TYPE}, OUT

      units :: STR
      known_unit :: BIN

      ! Read the vector
      .read(v)

      ! Convert from assumed default units
      if (.default_units/=" ") &
         v.convert_from(.default_units)

      ! Check for explicit units
      if (NOT .at_end_of_file) then
        
        ! Is there a known unit next?
        .read(units)                      
        known_unit = units.is_known_unit

        ! Has conversion already been done?
        DIE_IF(known_unit AND .default_units/=" ","two units specified!")

        ! Convert from known units if we can ...
        ! Or move back to where we were
        if (known_unit) then; v.convert_from(units)              
        else;                 .move_to_previous_item
        end

      end

      ! Reset default units
      .default_units = " "

   end

   read_quantity(v) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Read in a vector quantity (with units).  Line breaks are not
   ! significant.  WARNING: You must *not* be at the end of file to
   ! use this routine, since it will try to read the next token after
   ! the vector as a units specifier. 
   end

   read_quantity(v) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Read in a vector quantity (with units).  Line breaks are not
   ! significant.  WARNING: You must *not* be at the end of file to
   ! use this routine, since it will try to read the next token after
   ! the vector as a units specifier. 
   end

! Read VEC{TYPE}*

   list_length result (res) ::: leaky, private
   ! Return the size of the list, by reading the input after an
   ! initial opening bracket "{" until a *matching* end bracket "}"
   ! token is found. Line breaks are not significant. 
      res :: INT

      line,item, n :: INT
      word :: STR

      ! Store original pos
      line = .line_number
      item = .next_line_item

      ! Read open brace
      .read(word)
      ENSURE(word=="{","list does not begin with {")

      ! Count the items
      n = 0
      res = 0
      do
         .read(word)
         if (word=="{") n = n + 1
         if (word=="}" AND n==0) exit
         if (word=="}" AND n>0) n = n - 1
         res = res + 1
      end

      ! Reinstate original position
      .move_to_line(line)
      .move_to_line_item(item)

   end

   read_ptr(v) ::: template
   ! Read in a vector pointer "v" sequentially. Line breaks are not
   ! significant. The "v" vector pointer is created.
      v :: VEC{TYPE}*

      dim :: INT
      word :: STR

      ! Find out the list length
      dim = .list_length
      v.create(dim)

      ! Read opening brace
      .read(word)
      ENSURE(word=="{","list does not begin with a {")

      ! Read vector
      .read(v)

      ! Read closing brace
      .read(word)
      ENSURE(word=="}","list does not end with a }")

   end

   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>STR), leaky
   ! Read in a vector pointer "v" sequentially. Line breaks are not
   ! significant. The "v" vector pointer is created.
   end

   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>BIN), leaky
   ! Read in a vector pointer "v" sequentially. Line breaks are not
   ! significant. The "v" vector pointer is created.
   end

   read_ptr(v) ::: leaky
   ! Read in a fancy vector pointer "v" sequentially. Fancy because a
   ! looping construct in understood. Line breaks are not significant.
   ! The "v" vector pointer is created.
      v :: VEC{INT}*

      dim,f,l,i :: INT
      word,first,second :: STR

      ! Read opening brace and first two items
      .read(word)
      ENSURE(word=="{","list does not begin with a {")
      .read(first)      
      .read(second)

      ! If second item is looping construct ..
      if (second=="...") then 

         ! Read last index & create "v"
         .read(l)
         f = first.to_int
         dim = l - f + 1
         v.create(abs(dim))

         ! Define sequental "v"
         if (dim>0) then; v = [ (i, i=f,l)    ]
         else           ; v = [ (i, i=f,l,-1) ]
         end

         ! Read closing brace
         .read(word)
         ENSURE(word=="}","list does not end with a {")

      ! Plain old VEC{INT}*
      else

         ! Backtrack before "{"
         .move_to_previous_item
         .move_to_previous_item
         .move_to_previous_item

         ! Read "v" in
         .read_ptr_helper(v)

      end

   end

   read_ptr_helper(v) ::: get_from(TEXTFILE:read_ptr, TYPE=>INT), leaky, private
   ! Read in a vector pointer "v" sequentially. Line breaks are not
   ! significant. The "v" vector pointer is created.
   end

   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky
   ! Read in a vector pointer "v" sequentially. Line breaks are not
   ! significant. The "v" vector pointer is created.
   end

   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>CPX), leaky
   ! Read in a vector pointer "v" sequentially. Line breaks are not
   ! significant. The "v" vector pointer is created.
   end

! Read VEC{TYPE}* quantity

   read_ptr_quantity(v) ::: template
   ! Read in a vector pointer quantity (with units) sequentially.
   ! Line breaks are not significant.  WARNING: You must *not* be at
   ! the end of file to use this routine, since it will try to read
   ! the next token after the vector as a units specifier. 
      v :: VEC{TYPE}*, OUT

      units :: STR
      known_unit :: BIN

      ! Read the vector pointer
      .read_ptr(v)

      ! Convert from assumed default units
      if (.default_units/=" ") &
         v.convert_from(.default_units)

      ! Check for explicit units
      if (NOT .at_end_of_file) then
        
        ! Is there a known unit next?
        .read(units)                      
        known_unit = units.is_known_unit

        ! Has conversion already been done?
        DIE_IF(known_unit AND .default_units/=" ","two units specified!")

        ! Convert from known units if we can ...
        ! Or move back to where we were
        if (known_unit) then; v.convert_from(units)              
        else;                 .move_to_previous_item
        end

      end

      ! Reset default units
      .default_units = " "

   end

   read_ptr_quantity(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky
   ! Read in a vector pointer quantity (with units) sequentially.
   ! Line breaks are not significant.  WARNING: You must *not* be at
   ! the end of file to use this routine, since it will try to read
   end

! Read VEC{T1}, VEC{T2} pairs 

   read(v1,v2) ::: template
   ! Read in a pair of vectors sequentially, alternating. Line breaks
   ! are not significant.
      v1 :: VEC{T1}, OUT
      v2 :: VEC{T2}, OUT

   ENSURE(v1.dim==v2.dim,"incompatible vectors")

      i :: INT

      do i = 1,v1.dim
         .read(v1(i))
         .read(v2(i))
      end

   end

   read(v1,v2) ::: get_from(TEXTFILE, T1=>INT, T2=>INT)
   ! Read in a pair of vectors sequentially, alternating. Line breaks
   ! are not significant.
   end

   read(v1,v2) ::: get_from(TEXTFILE, T1=>REAL, T2=>REAL)
   ! Read in a pair of vectors sequentially, alternating. Line breaks
   ! are not significant.
   end

! Read VEC{T1}, VEC{T2}, VEC{T3} triples

   read(v1,v2,v3) ::: template
   ! Read in a triple of vectors sequentially, alternating. Line
   ! breaks are not significant.
      v1 :: VEC{T1}, OUT
      v2 :: VEC{T2}, OUT
      v3 :: VEC{T3}, OUT

   ENSURE(v1.dim==v2.dim,"incompatible vectors")
   ENSURE(v1.dim==v3.dim,"incompatible vectors")

      i :: INT

      do i = 1,v1.dim
         .read(v1(i))
         .read(v2(i))
         .read(v3(i))
      end

   end

   read(v1,v2,v3) ::: get_from(TEXTFILE, T1=>REAL, T2=>REAL, T3=>REAL)
   ! Read in a triple of vectors sequentially, alternating. Line
   ! breaks are not significant.
   end

! Read MAT{TYPE}

   read(mx,by_column) ::: template
   ! Read in MAT{TYPE} sequentially by row. If "by_column" is present
   ! and TRUE it is read in sequentially by column. Line breaks are
   ! not significant.
      mx :: MAT{TYPE}, OUT
      by_column :: BIN, optional

      i,j :: INT
      read_by_column :: BIN

      ! Get input order
      read_by_column = FALSE
      if (present(by_column)) read_by_column = by_column

      ! Read by column or (default) by row
      if (read_by_column) then
         do j = 1,mx.dim2
         do i = 1,mx.dim1
            .read(mx(i,j))
         end
         end
      else
         do i = 1,mx.dim1
         do j = 1,mx.dim2
            .read(mx(i,j))
         end
         end
      end

   end

   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>STR)
   ! Read in MAT{TYPE} sequentially by row. If "by_column" is present
   ! and TRUE it is read in sequentially by column. Line breaks are
   ! not significant.
   end

   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>BIN)
   ! Read in MAT{TYPE} sequentially by row. If "by_column" is present
   ! and TRUE it is read in sequentially by column. Line breaks are
   ! not significant.
   end

   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Read in MAT{TYPE} sequentially by row. If "by_column" is present
   ! and TRUE it is read in sequentially by column. Line breaks are
   ! not significant.
   end

   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Read in MAT{TYPE} sequentially by row. If "by_column" is present
   ! and TRUE it is read in sequentially by column. Line breaks are
   ! not significant.
   end

   read(mx,format,items_per_line)
   ! Read a formatted matrix "mx" with fortran "format" and a given
   ! number of "items_per_line". Extra line items are skipped!
     mx :: MAT{REAL}, OUT
     format :: STR, IN
     items_per_line :: INT, IN

     i,j,n :: INT

     .buffer.move_to_item(1)

     do i = 1,mx.dim1

        ! Read a row i
        n = 0
        do j = 1,mx.dim2
           .read(mx(i,j),format)
           n = n + 1
           if (n==items_per_line) exit
        end

        ! Next non-empty line
        do
           .read_line
           if (NOT .buffer.empty) exit
        end

     end

   end

   read(mx,by_column) ::: get_from(TEXTFILE, TYPE=>CPX)
   ! Read in MAT{TYPE} sequentially by row. If "by_column" is present
   ! and TRUE it is read in sequentially by column. Line breaks are
   ! not significant.
   end

! Read MAT{TYPE}*

   get_matrix_shape(dim) ::: private
   ! Returns dim(1) as the number of lines which are not blank, and
   ! dim(2) as the number of items per line between an opening and
   ! closing brace. It is an error if there are a different number of
   ! items per line on every non-blank line.
      dim :: VEC{INT}(2)

      line,item,first_line :: INT
      word :: STR
      dim1,dim2 :: INT

      ! Store initial position
      item = .next_line_item
      line = .line_number

      ! Opening brace?
      .read(word)
      ENSURE(word=="{","list does not begin with a {")

      ! Initialize
      dim1 = 0
      dim2 = 0
      dim = [dim1,dim2]

      ! First token. Return if clsing brace
      .read(word)                       
      if (word == "}") return

      ! Line on which first item lies; at least one row
      first_line = .line_number 
      dim1 = 1                              

      ! The number of columns; it shouldn't change
      dim2 = .n_line_items                  
      dim(2) = dim2

      ! Opening { is on the same line as first item
      if (first_line==line) dim2 = dim2 - 1 

      ! Process all lines
      do

         ! Next line
         .skip_line

         ! Skip empty lines
         if (.n_line_items==0) cycle

         ! Exit if first item of next non-blank line
         ! is closing brace
         .read(word)                    
         if (word == "}") exit 

         ! If not empty and not clsing brace, add another row
         dim1 = dim1 + 1                    
         dim2 = .n_line_items

         ! If non matching dim2, it must be a closing brace
         ! (if so, exit) it is an error if not the same
         if (dim2>dim(2)) then
            dim2 = dim(2)
            .move_to_line_item(dim2+1)
            DIE_IF(.next_item/="}","different number of line items on succesive lines")
            exit
         else
            DIE_IF(dim2/=dim(2),"different number of line items on succesive lines")
         end
      end

      ! Return to initial position
      .move_to_line(line)
      .move_to_line_item(item)

      ! Set the shape
      dim = [dim1,dim2]

   end

   read_ptr(mx) ::: template
   ! Read in a MAT{TYPE}* matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are not significant.
      mx :: MAT{TYPE}*

      word :: STR
      dim :: VEC{INT}(2)

      ! Get the shape
      .get_matrix_shape(dim)

      ! Opening brace
      .read(word)
      ENSURE(word=="{","matrix does not begin with a {")

      ! Read the matrix
      mx.create(dim(1),dim(2))
      .read(mx)

      ! Closing brace
      .read(word)
      ENSURE(word=="}","expecting close bracket symbol: }")

   end

   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>STR), leaky
   ! Read in a MAT{TYPE}* matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are not significant.
   end

   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>BIN), leaky
   ! Read in a MAT{TYPE}* matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are not significant.
   end

   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>INT), leaky
   ! Read in a MAT{TYPE}* matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are not significant.
   end

   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>REAL), leaky
   ! Read in a MAT{TYPE}* matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are not significant.
   end

   read_ptr(mx) ::: get_from(TEXTFILE, TYPE=>CPX), leaky
   ! Read in a MAT{TYPE}* matrix "mx" sequentially. The shape is
   ! induced from the formatting. Line breaks are not significant.
   end

! Read VEC{VEC_{TYPE}}

   read(v) ::: template
   ! Read in an VEC{VEC_{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
      v :: VEC{VEC_{TYPE}}, OUT

      i :: INT

      do i = 1,v.dim
         .read_ptr(v(i).element)
      end

   end

   read(v) ::: get_from(TEXTFILE, TYPE=>INT), leaky
   ! Read in an VEC{VEC_{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

   read(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky
   ! Read in an VEC{VEC_{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

! Read VEC{VEC_{TYPE}}*

   list_list_length result (res) ::: leaky, private
   ! Return the size of an VEC{VEC_{INT}} list, by reading the input
   ! until an end bracket "}" token is found. Line breaks are not
   ! significant.
      res :: INT

      line,item :: INT
      word :: STR
      v :: VEC{STR}*

      ! Store original pos
      line = .line_number
      item = .next_line_item

      ! Read opening brace
      .read(word)
      ENSURE(word=="{","list does not begin with {")

      ! Count enclosed lists
      res = 0
      do
         .read(word)
         if (word=="}") exit
         .move_to_previous_item
         .read_ptr(v)
         v.destroy
         res = res + 1
      end

      ! Reinstate original position
      .move_to_line(line)
      .move_to_line_item(item)

   end

   read_ptr(v) ::: template
   ! Read in a VEC{VEC_{TYPE}}* "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
      v :: VEC{VEC_{TYPE}}*

      word :: STR
      dim :: INT

      ! Find out the list length
      dim = .list_list_length
      v.create(dim)

      ! Read opening brace
      .read(word)
      ENSURE(word=="{","list does not begin with a {")

      ! Read vector
      .read(v)

      ! Read closing brace
      .read(word)
      ENSURE(word=="}","list does not end with a {")

   end

   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>INT), leaky
   ! Read in a VEC{VEC_{TYPE}}* "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

   read_ptr(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky
   ! Read in a VEC{VEC_{TYPE}}* "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

! Read VEC{MAT{TYPE}}

   read(v) ::: template
   ! Read in an VEC{MAT_{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
      v :: VEC{MAT_{TYPE}}, OUT

      i :: INT

      do i = 1,v.dim
         .read_ptr(v(i).element)
      end

   end

   read(v) ::: get_from(TEXTFILE, TYPE=>INT), leaky
   ! Read in an VEC{MAT_{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

   read(v) ::: get_from(TEXTFILE, TYPE=>REAL), leaky
   ! Read in an VEC{MAT_{TYPE}} "v" sequentially. Line breaks are not
   ! significant. The "v" is created.
   end

! Read MAT3{TYPE}

   read(mx) ::: template
   ! Read a MAT3{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
      mx :: MAT3{TYPE}, OUT

      i1,i2,i3, j1,j2,j3 :: INT

      do i1 = 1,mx.dim1
      do i2 = 1,mx.dim2
      do i3 = 1,mx.dim3
         .read(j1)
         .read(j2)
         .read(j3)
         .read(mx(j1,j2,j3))
      end
      end
      end

   end

   read(mx) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Read a MAT3{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

   read(mx) ::: get_from(TEXTFILE, TYPE=>CPX)
   ! Read a MAT3{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

! Read MAT4{TYPE}

   read(mx) ::: template
   ! Read a MAT4{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
      mx :: MAT4{TYPE}, OUT

      i1,i2,i3,i4, j1,j2,j3,j4 :: INT

      do i1 = 1,mx.dim1
      do i2 = 1,mx.dim2
      do i3 = 1,mx.dim3
      do i4 = 1,mx.dim4
         .read(j1)
         .read(j2)
         .read(j3)
         .read(j4)
         .read(mx(j1,j2,j3,j4))
      end
      end
      end
      end

   end

   read(mx) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Read a MAT4{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

   read(mx) ::: get_from(TEXTFILE, TYPE=>CPX)
   ! Read a MAT4{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

! Read MAT5{TYPE}

   read(mx) ::: template
   ! Read a MAT5{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
      mx :: MAT5{TYPE}, OUT

      i1,i2,i3,i4,i5, j1,j2,j3,j4,j5 :: INT

      do i1 = 1,mx.dim1
      do i2 = 1,mx.dim2
      do i3 = 1,mx.dim3
      do i4 = 1,mx.dim4
      do i5 = 1,mx.dim5
         .read(j1)
         .read(j2)
         .read(j3)
         .read(j4)
         .read(j5)
         .read(mx(j1,j2,j3,j4,j5))
      end
      end
      end
      end
      end

   end

   read(mx) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Read a MAT5{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

   read(mx) ::: get_from(TEXTFILE, TYPE=>CPX)
   ! Read a MAT5{TYPE} matrix "mx". Indices for the element precede
   ! the element value.
   end

!  ********************
!  Data output routines
!  ********************

! Clearing, flushing, tabbing, dashing & plain text line

   clear_and_put_margin
   ! Clear the buffer and put a margin in
       .buffer.clear
       if (.margin_width==0) return
       .buffer.put(repeat(" ",.margin_width))
   end

   flush
   ! Flush the buffer to the output file
   ENSURE(.action=="write","file does not have write action!")

      unit :: UNIT_NUMBER
      fail :: INT

      fail = 0
      if (IO_IS_ALLOWED) then
         ENSURE(.is_open,"file is not open!")
         write(unit=.unit,iostat=fail,fmt="(a)") trim(.buffer.string)
      end
      PARALLEL_BROADCAST(fail,0)
      DIE_IF(fail>0,"read error")
      .io_status = fail

      if (IO_IS_ALLOWED) then
         unit.unit = .unit
         unit.flush_buffer
      end

      .clear_and_put_margin

      .record = .record + 1

   end

   flush(times)
   ! Flush the buffer multiple times to get extra carriage returns
     times :: INT
     i :: INT
     do i = 1,times
        .flush
     end
   end

   tab(real_fields,int_fields,bin_fields,width)
   ! Tab across the specified number of fields in the output buffer
   ! "real_fields", "int_fields" and "bin_fields" refer to the number of
   ! real, integer and logical fields to tab; "width" is the width of spaces
   ! to tab.
      real_fields :: INT, optional
      int_fields :: INT, optional
      bin_fields :: INT, optional
      width :: INT, optional

      if (present(real_fields)) .buffer.put(repeat(repeat(" ",.real_width),real_fields))
      if (present(int_fields))  .buffer.put(repeat(repeat(" ",.int_width),int_fields))
      if (present(bin_fields))  .buffer.put(repeat(repeat(" ",.int_width),bin_fields))
      if (present(width))       .buffer.put(repeat(" ",width))

   end

   dash(symbol,real_fields,int_fields,bin_fields,width)
   ! Put a dashed line into the buffer. "real_fields", "int_fields" and
   ! "bin_fields" refer to the number of real, integer and logical fields
   ! to draw the line over; "width" is the width of characters to draw the
   ! dashed line. 
      symbol :: STR(1), optional
      real_fields :: INT, optional
      int_fields :: INT, optional
      bin_fields :: INT, optional
      width :: INT, optional

      dsh :: STR(1)

      dsh = "-"
      if (present(symbol)) dsh = symbol

      if (present(real_fields)) .buffer.put(repeat(dsh,.real_width*real_fields))
      if (present(int_fields))  .buffer.put(repeat(dsh,.int_width *int_fields))
      if (present(bin_fields))  .buffer.put(repeat(dsh,.int_width *bin_fields))
      if (present(width))       .buffer.put(repeat(dsh,width))

      .flush

   end

   text(string,real_width,int_width,flush)
   ! Put text into the output buffer as is and flush, unless
   ! flush is present and FALSE. You can specify widths too.
      string :: STR
      real_width :: BIN, optional
      int_width :: BIN, optional
      flush :: BIN, optional

      int_string :: STR(.int_width)
      real_string :: STR(.real_width)
      use_real_width,use_int_width,do_flush :: BIN

      use_real_width = FALSE
      if (present(real_width)) use_real_width = real_width

      use_int_width = FALSE
      if (present(int_width)) use_int_width = int_width

      do_flush = TRUE
      if (present(flush)) do_flush = flush
      
      if (use_real_width AND len(string)<=.real_width) then
         real_string = string
         .buffer.put(real_string)
      else if (use_int_width AND len(string)<=.int_width) then
         int_string = string
         .buffer.put(int_string)
      else
         .buffer.put(string)
      end

      if (do_flush) .flush

   end

! Put TYPE methods (no flush)

   put(string,left,center,int_width,width)
   ! Put a "string" into the output buffer; if it is too big, put as is.
   ! NOTE: Head space is never altered, but trailing spaces are trimmed.
   ! If present and TRUE:
   ! . "left" ........ left justifies output         (default: right justified)
   ! . "center" ...... centers the output            (overrides "left")
   ! . "int_width" ... field width set to .int_width (default: .real_width)
   ! If present:
   ! . "width" ....... sets field width in chars     (overrides "int_width")
      string :: STR, IN
      left :: BIN, IN, optional
      center :: BIN, IN, optional
      int_width :: BIN, IN, optional
      width :: INT, IN, optional

      tmpcpy :: STR 
      wid,len :: INT
      leftify,centrify :: BIN

      if (NOT .using_fields) then

         ! Put string as is, separated by a space
         ! Head space preserved, trailing space trimmed
         if (.buffer.item_end==0) then; .buffer.put(trim(string))
         else;                          .buffer.put(" "//trim(string))
         end

      else 

         ! Get the field width
         wid = .real_width
         if (present(int_width)) then
         if (int_width) then
            wid = .int_width
         end
         end
         if (present(width)) wid = width

         ! Whether to left-justify
         leftify = FALSE
         if (present(left)) leftify = left

         ! Whether to center
         centrify = FALSE
         if (present(center)) centrify = center

         ! Sanity check
         DIE_IF(leftify AND centrify,"too many justifications")

         ! The actual string lenth
         len = len_trim(string)

         if (len>wid) then

            ! If string too long, just put it in, with a space in
            ! front (unless it is the first item). 
            if (.buffer.item_end==0) then; .buffer.put(trim(string))
            else;                          .buffer.put(" "//trim(string))
            end

         else if (len==wid) then

            if (present(width)) then

               ! If it just fits, and the user specified the character
               ! width, put it in just as the user wanted
               .buffer.put(trim(string))

            else 

               ! If it just fits, and the user didn't specify width,
               ! put it in with a spacer in front
               .buffer.put(" "//trim(string))

            end

         else if (centrify) then

            ! Centered
            tmpcpy = string
            tmpcpy(1:wid).center_justify
            .buffer.put(tmpcpy(1:wid))

         else

            ! Finally: put it in with the specified width
            ! This works for blanks too ...
            .buffer.put(string.to_str(wid,leftify))

         end

      end

   end

   put(value,left,center,real_width,width) ::: template
   ! Put a "value" into the output buffer. If present and TRUE:
   ! . "left" will left justify the string (default is right justified)
   ! . "center" will center the string (overrides left-justification)
   ! . "real_width" sets width to .real_width (default width is .int_width)
   ! If present:
   ! . "width" sets the field_width (default width is .int_width)
      value :: VALUE, IN
      left :: BIN, IN, optional
      center :: BIN, IN, optional
      real_width :: BIN, IN, optional
      width :: INT, IN, optional

      int_width :: BIN

      int_width = TRUE
      if (present(real_width)) int_width = NOT real_width

      ! Change to string, and put it out
      .put(value.to_str,left,center,int_width,width)

   end

   put(value,left,center,real_width,width) ::: get_from(TEXTFILE:put, VALUE=>BIN)
   ! Put a "value" into the output buffer. If present and TRUE:
   ! . "left" will left justify the string (default is right justified)
   ! . "center" will center the string (overrides left-justification)
   ! . "real_width" sets width to .real_width (default width is .int_width)
   ! If present:
   ! . "width" sets the field_width (default width is .int_width)
   end

   put(value,left,center,real_width,width) ::: get_from(TEXTFILE:put, VALUE=>INT)
   ! Put a "value" into the output buffer. If present and TRUE:
   ! . "left" will left justify the string (default is right justified)
   ! . "center" will center the string (overrides left-justification)
   ! . "real_width" sets width to .real_width (default width is .int_width)
   ! If present:
   ! . "width" sets the field_width (default width is .int_width)
   end

   put_bit_string(value,left,center,int_width,width)
   ! Put a "value" into the output buffer. If present and TRUE:
   ! . "int_width" sets width to .int_width (default width is .real_width)
   ! . "left" will left justify the string (default is right justified)
   ! . "center" will center the string (overrides left-justification)
   ! If present:
   ! . "width" sets the field_width (default width is .int_width)
      value :: INT, IN
      left :: BIN, IN, optional
      center :: BIN, IN, optional
      int_width :: BIN, IN, optional
      width :: INT, IN, optional

      ! Change to string, and put it out
      .put(value.to_bit_string,left,center,int_width,width)

   end

   put(value,left,center,int_width,style,width,precision)
   ! Put a real "value" into the output buffer. 
   ! If present and TRUE:
   ! . "left" will left justify the string    (default: right-justified)
   ! . "center" will center the string        (default: left-justified)
   ! . "int_width" sets width to .inty_width  (default: .real_width)
   ! If present:
   ! . "style" sets the fortran style         (default: .real_style)
   ! . "width" sets the field_width           (default: .real_width)
   ! . "precision" sets the fortran precision (default: .real_precision)
      value :: REAL, IN
      left :: BIN, IN, optional
      center :: BIN, IN, optional
      int_width :: BIN, IN, optional
      style :: STR, IN, optional
      width :: INT, IN, optional
      precision :: INT, IN, optional

      sty :: STR
      wid,pre :: INT

      ! Defaults
      sty = .real_style
      wid = .real_width
      pre = .real_precision

      ! Set int_width option
      if (present(int_width)) then
      if (int_width) then
         wid = .int_width
         pre = 3 
      end
      end

      ! Set options
      if (present(style))     sty = style
      if (present(width))     wid = width
      if (present(precision)) pre = precision

      ! Change to string, and put it out
      .put(value.to_str(sty,wid,pre),left,center,FALSE,width=wid)

   end

   put(value,left,center,int_width,style,width,precision)
   ! Put a complex "value" into the output buffer. 
   ! If present and TRUE:
   ! . "left" will left justify the string    (default: right-justified)
   ! . "center" will center the string        (default: left-justified)
   ! . "int_width" sets width to .inty_width  (default: .real_width)
   ! If present:
   ! . "style" sets the fortran style         (default: .real_style)
   ! . "width" sets the field_width           (default: .real_width)
   ! . "precision" sets the fortran precision (default: .real_precision)
      value :: CPX, IN
      left :: BIN, IN, optional
      center :: BIN, IN, optional
      int_width :: BIN, IN, optional
      style :: STR, IN, optional
      width :: INT, IN, optional
      precision :: INT, IN, optional

      sty :: STR
      wid,pre :: INT

      ! Defaults
      sty = .real_style
      wid = .real_width
      pre = .real_precision

      ! Set int_width option
      if (present(int_width)) then
      if (int_width) then
         wid = .int_width
         pre = 3 
      end
      end

      ! Set options
      if (present(style))     sty = style
      if (present(width))     wid = width
      if (present(precision)) pre = precision

      ! Change to string, and put it out
      ! CPX:to_str assumes wid is the real width, used twice
      .put(value.to_str(sty,wid,pre),left,center,FALSE,width=2*wid)

   end

!   put(value,error,units)
!   ! Put a formatted REAL into the output buffer with bracketed error. 
!      value :: REAL, IN
!      error :: REAL, IN
!      units :: STR, optional
!
!      .put(value.to_str(error,.real_width,.real_precision,units))
!
!   end

   put(value,error,int_width,width,precision)
   ! Put a real "value" into the output buffer which has "error".
   ! You can specify the "width" (defualt .real_width) or the
   ! maximum "precision". You better make sure ther error is larger
   ! than the precision! The decimal points are lined up.
      value,error :: REAL, IN
      int_width :: BIN, IN, optional
      width :: INT, IN, optional
      precision :: INT, IN, optional

      wid,pre,pr,sp :: INT
      valstr :: STR

      ! Defaults
      wid = .real_width
      pre = .real_precision

      ! Set int_width option
      if (present(int_width)) then
      if (int_width) then
         wid = .int_width
         pre = 3 
      end
      end

      ! Set options
      if (present(width))     wid = width
      if (present(precision)) pre = precision

      ! Change to string, and put it out. Need to use wid+3 to allow
      ! for the error e.g. 1.002(2) takes up three extra spaces.
      valstr = value.to_str(error,wid,pre,pr=pr)
      if (pr<pre) then
         sp = pre - pr
         .put(valstr,width=wid-sp)
         .put(repeat(" ",sp),width=sp) ! line up decimal place
      else
         .put(valstr,width=wid)
      end

   end

!   put(value,error,left,center,int_width,width,precision)
!   ! Put a real "value" into the output buffer which has "error".
!   ! If present and TRUE:
!   ! . "left" will left justify the string    (default: right-justified)
!   ! . "center" will center the string        (default: left-justified)
!   ! . "int_width" sets width to .inty_width  (default: .real_width)
!   ! If present:
!   ! . "width" sets the field_width           (default: .real_width)
!   ! . "precision" sets the fortran precision (default: .real_precision)
!      value,error :: REAL, IN
!      left :: BIN, IN, optional
!      center :: BIN, IN, optional
!      int_width :: BIN, IN, optional
!      width :: INT, IN, optional
!      precision :: INT, IN, optional
!
!      wid,pre,pr,sp :: INT
!      valstr :: STR
!
!      ! Defaults
!      wid = .real_width
!      pre = .real_precision
!
!      ! Set int_width option
!      if (present(int_width)) then
!      if (int_width) then
!         wid = .int_width
!         pre = 3 
!      end
!      end
!
!      ! Set options
!      if (present(width))     wid = width
!      if (present(precision)) pre = precision
!
!      ! Change to string, and put it out. Need to use wid+3 to allow
!      ! for the error e.g. 1.002(2) takes up three extra spaces.
!      valstr = value.to_str(error,wid,pre,pr=pr)
!      if (pr<pre) then
!         sp = pre - pr
!         .put(valstr,left,center,FALSE,width=wid-sp)
!         .put(repeat(" ",sp),width=sp) ! line up decimal place
!      else
!         .put(valstr,left,center,FALSE,width=wid)
!      end
!
!   end

! Put VEC{TYPE}

   put(v,by_row,by_column,left,width,auto_width) ::: template
   ! Put VEC{TYPE} into the output buffer
      v :: VEC{TYPE}, IN
      by_row :: BIN, IN, optional
      by_column :: BIN, IN, optional
      left :: BIN, IN, optional
      width :: INT, IN, optional
      auto_width :: BIN, IN, optional

   ENSURE(NOT (present(by_row) AND present(by_column)),"row and column options present!")

      i,dim,iwid,rwid, block,n_block,fields,f,l :: INT
      column,auto :: BIN

      ! Vector length
      dim = v.dim
      WARN_IF(dim==0,"zero sized dimension!")

      ! Extract options
      column = TRUE
      if (present(by_row))    column = NOT by_row
      if (present(by_column)) column = by_column

      iwid = dim.str_length(.spacing)
      rwid = .real_width
      if (present(width)) rwid = width

      auto = FALSE
      if (present(auto_width)) auto = auto_width

      ! Auto field width overrides width
      if (auto) rwid = v.LEN(ARG)

      if (column) then

         ! Put vector "v" as vertical column
         if (.using_array_labels) then
            do i = 1,dim
               .put(i,left,width=iwid)
               .put(v(i),left,width=rwid)
               .flush
            end
         else
            do i = 1,dim
               .put(v(i),left,width=rwid)
               .flush
            end
         end

      else

         fields = .n_fields_per_line
         if (fields==0) fields = dim
         n_block = int((dim-0.1)/fields) + 1

         ! Put vector "v" as horizontal row
         if (.using_array_labels) then
            do block = 1,n_block
               f = 1 + fields*(block-1)
               l = min(f+fields-1,dim)
               if (block>1) .flush
               do i = f,l
                  .put(i,left,width=rwid)
               end
               .flush(2)
               do i = f,l
                  .put(v(i),left,width=rwid)
               end
               .flush
            end
         else
            do block = 1,n_block
               f = 1 + fields*(block-1)
               l = min(f+fields-1,dim)
               if (block>1) .flush
               do i = f,l
                  .put(v(i),left,width=rwid)
               end
            end
            .flush
         end

      end

   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>STR, LEN=>str_length, ARG=>.spacing)
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>BIN, LEN=>str_length, ARG=>.spacing)
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>INT, LEN=>str_length, ARG=>.spacing)
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>REAL, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing )
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,by_row,by_column,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>CPX, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing )
   ! Put VEC{TYPE} into the output buffer
   end

   put(v,row_label,col_label,left) ::: template
   ! Put VEC{TYPE} into output as column, with "row_labels" and a
   ! single "col_label".
      v :: VEC{TYPE}, IN
      row_label :: VEC{STR}, IN
      col_label :: STR, IN
      left :: BIN, IN, optional

      wid,widc,widr, i :: INT

      ! Warning ...
      WARN_IF(v.dim==0,"zero sized dimensiont!")

      ! Get the width
      widr = row_label.str_length(.spacing)
      widc = col_label.str_length(.spacing)
      wid  = max(widr,widc,.real_width)

      ! Tab column width & put column label
      .tab(width=wid)
      .put(col_label,left,width=wid)
      .flush(2)

      ! Put vector "v" as vertical column
      do i = 1,v.dim
         .put(row_label(i),left,width=wid)
         .put(v(i),left,width=wid)
         .flush
      end

   end

   put(v,row_label,col_label,left) ::: get_from(TEXTFILE), TYPE=>REAL
   ! Put VEC{TYPE} into output as column, with "row_labels" and a
   ! single "col_label".
   end

! Put MAT{TYPE}

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: template
   ! Put MAT{TYPE} into the output buffer
      mx :: MAT{TYPE}, IN
      by_row :: BIN, IN, optional
      by_column :: BIN, IN, optional
      transpose :: BIN, IN, optional
      left :: BIN, IN, optional
      width :: INT, IN, optional
      auto_width :: BIN, IN, optional

   ENSURE(NOT (present(by_row) AND present(by_column)),"row and column options present!")

      row,column,trans,auto :: BIN
      i,j,dim1,dim2,maxdim,rwid,iwid, block,n_block,fields,f,l :: INT

      ! Dimensions
      WARN_IF(any(mx.shape==0),"zero sized dimensions present!")
      dim1 = mx.dim1
      dim2 = mx.dim2

      ! Extract options
      row = FALSE
      if (present(by_row)) row = by_row

      column = FALSE
      if (present(by_column)) column = by_column

      trans = FALSE
      if (present(transpose)) trans = transpose

      ! Width
      maxdim = max(dim1,dim2)
      iwid   = maxdim.str_length(.spacing)
      rwid   = .real_width
      if (present(width)) rwid = width

      auto = FALSE
      if (present(auto_width)) auto = auto_width

      ! Auto field width overrides real_width
      if (auto) rwid = mx.LEN(ARG)

      ! No of fields per line
      fields = .n_fields_per_line

      if (column) then
         
         ! Put columns as rows, new line for new column
         if (fields==0) fields = dim1
         do j = 1,dim2
            do i = 1,dim1
               .put(mx(i,j),left,width=rwid)
               if(mod(i,fields)==0) .flush
            end
           .flush
         end

      else if (row) then

         ! Put as rows, new line for new row
         if (fields==0) fields = dim2
         do i = 1,dim1
            do j = 1,dim2
               .put(mx(i,j),left,width=rwid)
               if(mod(j,fields)==0) .flush
            end
           .flush
         end

      else 

         if (NOT trans) then ! NO TRANSPOSE

            if (NOT .using_fields) then

               do i = 1,dim1
                  do j = 1,dim2
                     .put(mx(i,j),left,width=rwid)
                  end
                  .flush
               end

            else
            
               if (fields==0) fields = dim2
               n_block = int((dim2-0.1)/fields) + 1
      
               ! Put in (row & column labelled) blocks
               if (.using_array_labels) then
                  do block = 1,n_block
                     f = 1 + fields*(block-1)
                     l = min(f+fields-1,dim2)
                     if (block>1) .flush
                     .tab(width=iwid)
                     do j = f,l
                        .put(j,left,width=rwid)
                     end
                     .flush(2)
                     do i = 1,dim1
                        .put(i,left,width=iwid)
                        do j = f,l
                           .put(mx(i,j),left,width=rwid)
                        end
                        .flush
                     end
                  end
               else
                  do block = 1,n_block
                     f = 1 + fields*(block-1)
                     l = min(f+fields-1,dim2)
                     if (block>1) .flush
                     do i = 1,dim1
                        .tab(width=iwid)
                        do j = f,l
                           .put(mx(i,j),left,width=rwid)
                        end
                        .flush
                     end
                  end
               end

            end

         else ! TRANSPOSE

            if (NOT .using_fields) then

               do j = 1,dim2
                  do i = 1,dim1
                     .put(mx(i,j),left,width=rwid)
                  end
                  .flush
               end

            else

               if (fields==0) fields = dim1
               n_block = int((dim1-0.1)/fields) + 1
      
               ! Put in (row & column labelled) blocks
               if (.using_array_labels) then
                  do block = 1,n_block
                     f = 1 + fields*(block-1)
                     l = min(f+fields-1,dim1)
                     if (block>1) .flush
                     .tab(width=iwid)
                     do i = f,l
                        .put(i,left,width=rwid)
                     end
                     .flush(2)
                     do j = 1,dim2
                        .put(j,left,width=iwid)
                        do i = f,l
                           .put(mx(i,j),left,width=rwid)
                        end
                        .flush
                     end
                  end
               else
                  do block = 1,n_block
                     f = 1 + fields*(block-1)
                     l = min(f+fields-1,dim1)
                     if (block>1) .flush
                     do j = 1,dim2
                        .tab(int_fields=1)
                        do i = f,l
                           .put(mx(i,j),left,width=rwid)
                        end
                        .flush
                     end
                  end
               end

            end

         end

      end

   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>STR, LEN=>str_length, ARG=>.spacing)
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>BIN, LEN=>str_length, ARG=>.spacing)
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>INT, LEN=>str_length, ARG=>.spacing)
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>REAL, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing )
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,by_row,by_column,transpose,left,width,auto_width) ::: get_from(TEXTFILE, TYPE=>CPX, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing )
   ! Put MAT{TYPE} into the output buffer
   end

   put(mx,row_label,col_label,left) ::: template
   ! Put MAT{TYPE} into output with "row_labels" and "column_labels"
      mx :: MAT{TYPE}, IN
      row_label,col_label :: VEC{STR}, IN
      left :: BIN, IN, optional

      wid,widc,widr, i,j,block,n_block,fields,f,l :: INT

      ! Warning ...
      WARN_IF(any(mx.shape==0),"zero sized dimensions present!")

      ! Get the width
      widr = row_label.str_length(.spacing)
      widc = col_label.str_length(.spacing)
      wid  = max(widr,widc,.real_width)

      ! No of fields per line
      fields = .n_fields_per_line
      if (fields==0) fields = mx.dim2

      ! No of matrix column-blocks
      n_block = int((fields-0.1)/fields) + 1

      ! Put in (row and column-labeled) column-blocks
      l = 0
      do block = 1,n_block

         ! First and last columns
         f = l + 1
         l = min(l+fields,mx.dim2)

         ! New block requires new line
         if (block>1) .flush

         ! Tab column width
         .tab(width=wid)

         ! Column labels
         do j = f,l
            .put(col_label(j),left,width=wid)
         end
         .flush(2)

         ! The rows of the matrix
         do i = 1,mx.dim1

            ! The row label
            .put(row_label(i),left,width=wid)

            ! The row of the matrix
            do j = f,l
               .put(mx(i,j),left,width=wid)
            end
            .flush

         end

      end

   end

   put(mx,row_label,col_label,left) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Put MAT{TYPE} into output with "row_labels" and "column_labels"
   end

! Put MAT3{TYPE}

   put(mx,by_dim3_matrices,width,auto_width) ::: template
   ! Put a MAT3{TYPE} into the output buffer flat style
      mx :: MAT3{TYPE}, IN
      by_dim3_matrices :: BIN, optional
      width :: INT, IN, optional
      auto_width :: BIN, IN, optional

      dim1,dim2,dim3,maxdim,rwid,iwid,i1,i2,i3 :: INT
      by_d3_matrices,auto :: BIN

      ! Dimensions
      WARN_IF(any(mx.shape==0),"zero sized dimensions present!")
      dim1 = mx.dim1
      dim2 = mx.dim2
      dim3 = mx.dim3

      ! Extract options
      by_d3_matrices = FALSE
      if (present(by_dim3_matrices)) by_d3_matrices = by_dim3_matrices

      ! Width
      maxdim = max(dim1,dim2,dim3)
      iwid   = maxdim.str_length(.spacing)
      rwid = .real_width
      if (present(width)) rwid = width

      auto = FALSE
      if (present(auto_width)) auto = auto_width

      ! Auto field width overrides width
      if (auto) rwid = mx.LEN(ARG)

      if (by_d3_matrices) then
 
         do i3 = 1,dim3
         do i2 = 1,dim2
         do i1 = 1,dim1
            .put(i1,width=iwid)
            .put(i2,width=iwid)
            .put(i3,width=iwid)
            .put(mx(i1,i2,i3),width=rwid)
            .flush
         end
         end
         end
 
      else
 
         do i3 = 1,dim3
            stdout.flush
            stdout.show("matrix =",i3)
            stdout.flush
            .put(mx(:,:,i3),width=rwid)
         end
 
      end

   end

   put(mx,by_dim3_matrices,width,auto_width) ::: get_from(TEXTFILE, TYPE=>INT, LEN=>str_length, ARG=>.spacing)
   ! Put a MAT3{TYPE} into the output buffer flat style
   end

   put(mx,by_dim3_matrices,width,auto_width) ::: get_from(TEXTFILE, TYPE=>REAL, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing)
   ! Put a MAT3{TYPE} into the output buffer flat style
   end

   put(mx,by_dim3_matrices,width,auto_width) ::: get_from(TEXTFILE, TYPE=>CPX, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing)
   ! Put a MAT3{TYPE} into the output buffer flat style
   end

! Put MAT4{TYPE}

   put(mx,by_matrices,width,auto_width) ::: template
   ! Put a MAT4{TYPE} into the output buffer
      mx :: MAT4{TYPE}, IN
      by_matrices :: BIN, optional
      width :: INT, IN, optional
      auto_width :: BIN, IN, optional

      dim1,dim2,dim3,dim4,maxdim,rwid,iwid,i1,i2,i3,i4 :: INT
      do_matrices,auto :: BIN

      ! Dimensions
      WARN_IF(any(mx.shape==0),"zero sized dimensions present!")
      dim1 = mx.dim1
      dim2 = mx.dim2
      dim3 = mx.dim3
      dim4 = mx.dim4

      ! Extract options
      do_matrices = TRUE
      if (present(by_matrices)) do_matrices = by_matrices

      ! Width
      maxdim = max(dim1,dim2,dim3,dim4)
      iwid   = maxdim.str_length(.spacing)
      rwid = .real_width
      if (present(width)) rwid = width

      auto = FALSE
      if (present(auto_width)) auto = auto_width

      ! Auto field width overrides width
      if (auto) rwid = mx.LEN(ARG)

      if (do_matrices) then
 
         do i4 = 1,dim4
         do i3 = 1,dim3
            stdout.flush
            stdout.text("matrix = (:,:,"//trim(i3.to_str)//","//trim(i4.to_str)//")")
            stdout.flush
            .put(mx(:,:,i3,i4),width=rwid)
         end
         end
 
      else
 
         do i4 = 1,dim4
         do i3 = 1,dim3
         do i2 = 1,dim2
         do i1 = 1,dim1
            .put(i1,width=iwid)
            .put(i2,width=iwid)
            .put(i3,width=iwid)
            .put(i4,width=iwid)
            .put(mx(i1,i2,i3,i4),width=rwid)
            .flush
         end
         end
         end
         end
 
      end

   end

   put(mx,by_matrices,width,auto_width) ::: get_from(TEXTFILE, TYPE=>INT, LEN=>str_length, ARG=>.spacing)
   ! Put a MAT4{TYPE} into the output buffer
   end

   put(mx,by_matrices,width,auto_width) ::: get_from(TEXTFILE, TYPE=>REAL, LEN=>str_length_with_precision, ARG=>.real_precision)
   ! Put a MAT4{TYPE} into the output buffer
   end

   put(mx,by_matrices,width,auto_width) ::: get_from(TEXTFILE, TYPE=>CPX, LEN=>str_length_with_precision, ARG=>.real_precision,.spacing)
   ! Put a MAT4{TYPE} into the output buffer
   end

! Put MAT5{TYPE}

   put(mx) ::: template
   ! Put a MAT5{TYPE} into the output buffer flat style
     mx :: MAT5{TYPE}, IN

     i1,i2,i3,i4,i5 :: INT

   WARN_IF(any(mx.shape==0),"there are zero sized dimensions")

     do i5 = 1,mx.dim5
     do i4 = 1,mx.dim4
     do i3 = 1,mx.dim3
     do i2 = 1,mx.dim2
     do i1 = 1,mx.dim1
        .put(i1)
        .put(i2)
        .put(i3)
        .put(i4)
        .put(i5)
        .put(mx(i1,i2,i3,i4,i5))
        .flush
     end
     end
     end
     end
     end

   end

   put(mx) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Put a MAT5{TYPE} into the output buffer flat style
   end

   put(mx) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Put a MAT5{TYPE} into the output buffer flat style
   end

   put(mx) ::: get_from(TEXTFILE, TYPE=>CPX)
   ! Put a MAT5{TYPE} into the output buffer flat style
   end

! Put VEC{VEC_{TYPE}}

   put(v) ::: template
   ! Put a VEC{VEC_{TYPE}} list into the output buffer
      v :: VEC{VEC_{TYPE}}, IN

      i :: INT
      using_array_labels :: BIN

      ! Save label status
      using_array_labels = .using_array_labels
      .set_using_array_labels(FALSE)

      do i = 1,v.dim
         .text("Vector "//trim(i.to_str)//":")
         .put(v(i).element,by_row=TRUE)
      end

      ! Restore labels
      .set_using_array_labels(using_array_labels)

   end

   put(v) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Put a VEC{VEC_{TYPE}} list into the output buffer
   end

   put(v) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Put a VEC{VEC_{TYPE}} list into the output buffer
   end

! Put VEC{MAT_{TYPE}}

   put(v) ::: template
   ! Put a VEC{MAT_{TYPE}} list into the output buffer
      v :: VEC{MAT_{TYPE}}, IN

      i :: INT
      using_array_labels :: BIN

      ! Save label status
      using_array_labels = .using_array_labels
      .set_using_array_labels(FALSE)

      do i = 1,v.dim
         .text("Matrix "//trim(i.to_str)//":")
         .put(v(i).element,by_row=TRUE)
      end

      ! Restore labels
      .set_using_array_labels(using_array_labels)

   end

   put(v) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Put a VEC{MAT_{TYPE}} list into the output buffer
   end

   put(v) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Put a VEC{MAT_{TYPE}} list into the output buffer
   end

! Put OPVECTOR and OPMATRIX objects

   put(v)
   ! Outputs the OPVECTOR "v"
     v :: OPVECTOR, IN

     if (v.restricted.created) then
       .flush
       .text("Restricted part:")
       .flush(2)
       .put(v.restricted)
     end

     if (v.alpha.created) then
       .flush
       .text("Alpha part:")
       .flush(2)
       .put(v.alpha)
     end

     if (v.beta.created) then
       .flush
       .text("Beta part:")
       .put(v.beta)
     end

     if (v.general.created) then
       .flush
       .text("General part:")
       .flush(2)
       .put(v.general)
     end

   end

   put(mx,by_row,by_column)
   ! Outputs the OPMATRIX "mx"
     mx :: OPMATRIX, IN
     by_row :: BIN, IN, optional
     by_column :: BIN, IN, optional

     if (mx.restricted.created) then
       .flush
       .text("Restricted part:")
       .flush(2)
       .put(mx.restricted,by_row,by_column)
     end

     if (mx.alpha.created) then
       .flush
       .text("Alpha part:")
       .flush(2)
       .put(mx.alpha,by_row,by_column)
     end

     if (mx.beta.created) then
       .flush
       .text("Beta part:")
       .flush(2)
       .put(mx.beta,by_row,by_column)
     end

     if (mx.general.created) then
       .flush
       .text("General part:")
       .flush(2)
       .put(mx.general,by_row,by_column)
     end

     if (mx.restricted_complex.created) then
       .flush
       .text("Complex restricted part:")
       .put(mx.restricted_complex,by_row,by_column)
     end

     if (mx.alpha_complex.created) then
       .flush
       .text("Complex alpha part:")
       .flush(2)
       .put(mx.alpha_complex,by_row,by_column)
     end

     if (mx.beta_complex.created) then
       .flush
       .text("Complex beta part:")
       .put(mx.beta_complex,by_row,by_column)
     end

     if (mx.general_complex.created) then
       .flush
       .text("Complex general part:")
       .flush(2)
       .put(mx.general_complex,by_row,by_column)
     end

   end

! Miscellaneous

   put_ppm(mx)
   ! Creates a ppm file from a 3*w*h array of RGB
   ! values and write to disk
   
     mx :: MAT3{INT}
     ENSURE(minval(mx)>=0, "rgb values should be positive")
     ENSURE(mx.dim1==3, "array should have dimensions 3*w*h")

     i,w,h,k,m :: INT

     i = maxval(mx)
     w = mx.dim2
     h = mx.dim3
     
     .text("P3")
     .put(w); .flush
     .put(h); .flush
     .put(i); .flush

     do k=1,h
       do m=1,w
         .put(mx(1,m,k))
         .put(mx(2,m,k))
         .put(mx(3,m,k))
         .flush
       end  
     end
   
   end

!  ************
!  Show methods
!  ************

   show(pretext,value) ::: template
   ! Put a left-justfied formatted scalar into the output buffer with
   ! some descriptive "pretext".
      pretext :: STR, IN
      value :: TYPE, IN

      description :: STR(len=(len(pretext)+4))
      l :: INT

      ! Modify the description pretext
      description = " "
      description = pretext
      description.replace_end_from(" =",".",plus=1)
      l = len(description)
      description(l:l) = " "

      ! Show it
      .text(description,flush=FALSE)
      .put(value,left=TRUE,width=.real_width)
      .flush

   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>STR)
   ! Put a left-justfied formatted scalar into the output buffer with
   ! some descriptive "pretext".
   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>BIN)
   ! Put a left-justfied formatted scalar into the output buffer with
   ! some descriptive "pretext".
   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Put a left-justfied formatted scalar into the output buffer with
   ! some descriptive "pretext".
   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Put a left-justfied formatted scalar into the output buffer with
   ! some descriptive "pretext".
   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>CPX)
   ! Put a left-justfied formatted scalar into the output buffer with
   ! some descriptive "pretext".
   end

   show_bit_string(pretext,value,int_width,width)
   ! Put a formatted INT as a binary number into the output buffer,
   ! with descriptive "pretext".
      pretext :: STR
      value :: INT
      int_width :: BIN, optional
      width :: INT, optional

      .text(pretext,flush=FALSE)
      .put_bit_string(value,width=.real_width)
      .flush

   end

! Show two TYPE's

   show(pretext,val1,val2) ::: template
   ! Put two REAL's "val1", "val2" into the output buffer, with
   ! descriptive "pretext" before.
      pretext :: STR, IN
      val1,val2 :: TYPE, IN

      .text(pretext,flush=FALSE)
      .put(val1)
      .put(val2)
      .flush

   end

   show(pretext,val1,val2) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Put two REAL's "val1", "val2" into the output buffer, with
   ! descriptive "pretext" before.
   end

   show(pretext,val1,val2) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Put two REAL's "val1", "val2" into the output buffer, with
   ! descriptive "pretext" before.
   end

! Show three TYPE's

   show(pretext,val1,val2,val3) ::: template
   ! Put three REAL's "val1", "val2" and "val3" into the output buffer, with
   ! descriptive "pretext" before.
      pretext :: STR, IN
      val1,val2,val3 :: TYPE, IN

      .text(pretext,flush=FALSE)
      .put(val1,width=.real_width)
      .put(val2,width=.real_width)
      .put(val3,width=.real_width)
      .flush

   end

   show(pretext,val1,val2,val3) ::: get_from(TEXTFILE, TYPE=>BIN)
   ! Put three REAL's "val1", "val2" and "val3" into the output buffer, with
   ! descriptive "pretext" before.
   end

   show(pretext,val1,val2,val3) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Put three REAL's "val1", "val2" and "val3" into the output buffer, with
   ! descriptive "pretext" before.
   end

   show(pretext,val1,val2,val3) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Put three REAL's "val1", "val2" and "val3" into the output buffer, with
   ! descriptive "pretext" before.
   end

! Show VEC{TYPE}

   show(pretext,value) ::: template
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
      pretext :: STR, IN
      value :: VEC{TYPE}, IN

      description :: STR(len=(len(pretext)+4))
      l :: INT

      ! Modify the description pretext
      description = " "
      description = pretext
      description.replace_end_from(" =",".",plus=1)
      l = len(description)
      description(l:l) = " "

      ! Show it
      .text(description,flush=FALSE)
      .put(value.to_concatenated_str(separator=" "),left=TRUE,width=.real_width)
      .flush

   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>STR)
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>BIN)
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>INT)
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
   end

   show(pretext,value) ::: get_from(TEXTFILE, TYPE=>REAL)
   ! Put a formatted VEC{TYPE} "value" into the output buffer with
   ! descriptive "pretext".
   end

!  ****************
!  Output self info
!  ****************

   put
   ! Put all the available molecule information on file "out"
      stdout.show("Name       =",.name)
      stdout.show("I/O action =",.action)
      stdout.show("Unit       =",.unit)
      stdout.show("Line       =",.record)
      stdout.show("Buffer     =",trim(.buffer.string))
      stdout.show("Cursor pos =",trim(.buffer.cursor_pointer))
   end

! ***************
! System routines
! ***************

   update_system_info ::: private
   ! Lets the system know info about the file being read, in case 
   ! of error.
     self :: target
#ifndef NO_TONTO_SYSTEM_CALLS
     tonto.io_file => self
#endif
   end

end
