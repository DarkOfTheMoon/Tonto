!-------------------------------------------------------------------------------
!
! MOL_chris:  Roby stuff
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_CHRIS

   use TYPES
   use SYSTEM
   use TIME
   use STR
   use INT
   use DBL

   use IVEC
   use VEC
   use IMAT
   use MAT

   use OPVEC
   use OPMAT

   use ATOM
   use ATOMVEC

   use TEXTFILE
   use ARCHIVE

   use SCFDATA
   use MOL

   implicit none         

#  include "macros"
#  include "mol_chris.int"

!   type mol_type
!
!   STR :: name
!   ! Name of molecule
!
!   INT :: charge
!   ! Electric charge of the molecule
!
!   INT :: mult
!   ! Spin multiplicity of the molecule
!
!   VEC(3) :: E_field
!   ! Applied electric field in atomic units
!
!   VEC(3) :: B_field
!   ! Applied magnetic field in atomic units
!
!   VEC(3) :: gauge_origin
!   ! Global gauge origin for magnetic field
!
!   VEC(3) :: quantization_axis
!   ! Axis for quantizing any momenta
!
!   ATOMVEC, PTR :: atom DEFAULT_NULL
!   ! List of atoms in molecule
!
!   BASISVEC, PTR :: basis DEFAULT_NULL
!   ! List of basis sets used
!
!   PLOTGRID, PTR :: grid DEFAULT_NULL
!   ! Rectangular grid data, for plots
!
!   DFTGRID, PTR :: dftgrid DEFAULT_NULL
!   ! DFT integration grid data
!
!   CRYSTAL, PTR :: crystal DEFAULT_NULL
!   ! Crystal data for the enclosing crystal
!
!   POINTGROUP, PTR :: pointgroup DEFAULT_NULL
!   ! Pointgroup symmetry of the molecule
!
!   INT :: n_e
!   ! No of electrons
!
!   INT :: n_a
!   ! No of alpha electrons
!
!   INT :: n_b
!   ! No of beta electrons
!
!   INT :: n_atom
!   ! No of atoms
!
!   INT :: n_atom_kind
!   ! No of atoms of a different kind
!
!   INT :: n_basis
!   ! No of basis sets
!
!   INT :: n_shell
!   ! Total number of shells in the molecular basis set
!
!   INT :: n_shell_pairs
!   ! Total number of shell pairs in the molecular basis set
!
!   INT :: n_bf
!   ! Total number of basis functions in the molecular basis set
!
!   INT :: n_prim
!   ! Total number of primitives in the molecular basis set
!
!   IVEC, PTR :: atom_for_shell DEFAULT_NULL
!   ! Atom index for molecular shell index array
!
!   IVEC, PTR :: atom_shell_for_shell DEFAULT_NULL
!   ! Atom shell index for molecular shell index array
!
!   IVEC, PTR :: first_shell_for_atom DEFAULT_NULL
!   ! First molecule shell index for an atom
!
!   IVEC, PTR :: first_basis_fn_for_shell DEFAULT_NULL
!   ! First basis function for a given shell
!
!   IVEC, PTR :: last_basis_fn_for_shell DEFAULT_NULL
!   ! Last basis function for a given shell
!
!   IVEC, PTR :: atom_kind DEFAULT_NULL
!   ! The unique kind of each atom in .atom
!
!   IVEC, PTR :: unique_atom DEFAULT_NULL
!   ! List of the unique atoms (of different kind)
!
!   IVEC, PTR :: first_basis_fn_for_atom DEFAULT_NULL
!   ! For the atom basis function limits
!
!   IVEC, PTR :: last_basis_fn_for_atom DEFAULT_NULL
!   ! For the atom basis function limits
!
!   SCFDATA, PTR :: scfdata DEFAULT_NULL
!   ! SCF data object
!
!   OPVEC, PTR :: orbital_energies DEFAULT_NULL
!   ! The orbital energies
!
!   OPMAT, PTR :: molecular_orbitals DEFAULT_NULL
!   ! The (real) molecular orbitals
!
!   OPMAT, PTR :: density_matrix DEFAULT_NULL
!   ! The real density matrix
!
!   OPMAT, PTR :: natural_orbitals DEFAULT_NULL
!   ! The natural orbitals
!
!   OPVEC, PTR :: occupation DEFAULT_NULL
!   ! The associated occupation numbers
!
!   OPMAT, PTR :: fock_matrix DEFAULT_NULL
!   ! The real fock matrix
!
!   MAT4VEC, PTR :: ab_ab_ERI DEFAULT_NULL
!   ! The two electron integrals of the form ab|ab
!
!   BIN :: optimise_thermals
!   ! Whether to optimise the thermal parameters
!
!   end

contains

!  ***************************
!  Population analysis methods
!  ***************************

   make_roby_atoms
   ! Sets up the roby_atoms for various analyses
   IVEC, PTR :: roby_atom, unique_atom
   IVECVEC, PTR :: atom_kind
   INT :: n_atom_kind, i, j, a, b
     .read_roby_atom(roby_atom)
     .atom(roby_atom).make_atom_kind_list(atom_kind)
     n_atom_kind = size(atom_kind)
     unique_atom.create(n_atom_kind)
     .atom(roby_atom).make_unique_atom_list(unique_atom)
     do i=1,n_atom_kind
       a=roby_atom(unique_atom(i))
       .prepare_roby_atom(a)
       do j=1,size(atom_kind(i).vec)
         b=roby_atom(atom_kind(i).vec(j))
         if (a==b) cycle
         .atom(b).natural_orbitals => .atom(a).natural_orbitals
         .atom(b).occupation       => .atom(a).occupation
         .atom(b).energy = .atom(a).energy
       end
     end
     roby_atom.destroy   
     atom_kind.destroy
     unique_atom.destroy
   end

   prepare_roby_atoms  [leaky]
   ! Provides the preliminary data required to do the Roby population analysis
     .make_ANO_data
   end

   prepare_roby_atom(a) [leaky]
   ! prepares the atom "a" for roby population
   ! analysis
     INT :: a,n_no
     MOL, PTR :: mol
     mol.create
     .make_molecule_from_atom(a,mol)
     mol.scfdata.output = FALSE
     mol.scf
     mol.make_ao_density_matrix
     mol.pointgroup.create("oh")
     mol.symmetrise(mol.density_matrix)
     mol.make_natural_orbitals
     .atom(a).natural_orbitals => mol.natural_orbitals
     .atom(a).occupation       => mol.occupation
     .atom(a).energy = mol.scfdata.energy
     mol.atom.nullify_ptr_part     ! do not destroy these
     nullify(mol.natural_orbitals) ! do not destroy this
     nullify(mol.occupation)       ! do not destroy this
     nullify(mol.basis)            ! do not destroy this
     mol.destroy
     n_no = .atom(a).occupation.restricted.no_of_elements_larger_than(0.05d0)
     stdout.show("n_no=",n_no)
     .atom(a).put_natural_orbitals
   end

   make_ANO_data [leaky]
   ! Prepare the restricted atomic natural orbital (ANO) data 
      INT :: k,u,n_no, j
      MOL, PTR :: mol
      BIN :: output
      output = TRUE
      do k = 1,.n_atom_kind ! Do an SCF for every different kind of atom
        mol.create
        u = .unique_atom(k)
        .make_molecule_from_atom(u,mol)
        mol.scfdata.output = FALSE
        mol.scf
        mol.make_ao_density_matrix
        mol.pointgroup.create("oh")
        mol.symmetrise(mol.density_matrix)
        mol.make_natural_orbitals
        .atom(u).natural_orbitals => mol.natural_orbitals
        .atom(u).occupation       => mol.occupation
        .atom(u).energy = mol.scfdata.energy
        do j = u+1,.n_atom
           if (.atom_kind(j)/=k) cycle
           .atom(j).natural_orbitals => .atom(u).natural_orbitals
           .atom(j).occupation       => .atom(u).occupation
           .atom(j).energy = .atom(u).energy
        end
        mol.atom.nullify_ptr_part     ! do not destroy these
        nullify(mol.natural_orbitals) ! do not destroy this
        nullify(mol.occupation)       ! do not destroy this
        nullify(mol.basis)            ! do not destroy this
        mol.destroy
        if (NOT output) cycle
        if (.mult /=1) then
            n_no = .atom(u).occupation.restricted.no_of_elements_larger_than(real(0.025,kind=DBL_KIND))
        else 
            n_no = .atom(u).occupation.restricted.no_of_elements_larger_than(real(0.05,kind=DBL_KIND))
        end
        stdout.show("n_no=",n_no)
        .atom(u).put_natural_orbitals
      end
   end

   ! I guess we can probably scrap this if the unres. works using only
   ! spatial orbitals ... or keep it for old times' sake ...  
   make_ANSO_data [leaky]
   ! Prepare the unrestricted atomic natural spin orbital (ASNO) data 
      INT :: k,u,a
      MOL, PTR :: mol
      BIN :: output
      output = TRUE
      do k = 1,.n_atom_kind ! Do an SCF for every different kind of atom
         mol.create
         u = .unique_atom(k)
         .make_molecule_from_atom(u,mol)
         mol.scfdata.output = FALSE
         mol.scf
         mol.density_matrix.convert_to("unrestricted",factor=HALF)
         mol.density_matrix.restricted.destroy
         mol.pointgroup.create("oh")
         mol.symmetrise(mol.density_matrix)
         mol.make_natural_orbitals
         .atom(u).natural_orbitals => mol.natural_orbitals
         .atom(u).occupation       => mol.occupation
         .atom(u).energy = mol.scfdata.energy
         do a = u+1,.n_atom
            if (.atom_kind(a)/=k) cycle
            .atom(a).natural_orbitals => .atom(u).natural_orbitals
            .atom(a).occupation       => .atom(u).occupation
            .atom(a).energy= .atom(u).energy
         end
         mol.atom.nullify_ptr_part     ! do not destroy these
         nullify(mol.natural_orbitals) ! do not destroy this
         nullify(mol.occupation)       ! do not destroy this
         nullify(mol.basis)            ! do not destroy this
         mol.destroy
         if (NOT output) cycle
         .atom(u).put_natural_orbitals
      end
   end

!----------------------------------------------------------!
! Roby population analysis - general analysis procedure    !
!----------------------------------------------------------!
 
   atomic_roby_population [leaky]
   ! Do a Roby population analysis for the atoms in a molecule specified
   ! on the input deck by roby_atom
     IVEC, PTR :: roby_atom
     INT :: a, n_roby_atom
     .read_roby_atom(roby_atom)
     n_roby_atom = size(roby_atom)
     do a=1,n_roby_atom
       .prepare_roby_atom(roby_atom(a))
       stdout.put("Roby Population is: ")
       stdout.put( .roby_population( (/ roby_atom(a) /) ))
       stdout.flush
     end
   end 

   roby_population_analysis [leaky]
   ! Do a Roby population analysis of a molecule
     VEC, PTR :: n1
     MAT, PTR :: n2
     INT :: n_atom, i, j
     MAT, PTR :: index, cov
     .prepare_roby_atoms
     n_atom = .n_atom
     n1.create(n_atom)           ! Roby populations
     n2.create(n_atom,n_atom)    ! Roby pair populations
     index.create(n_atom,n_atom) ! Bond indices between pairs of atoms
     cov.create(n_atom,n_atom)   ! Covalency of each two atom bond
     index.zero; cov.zero
     do i = 1,n_atom
       n1(i) = .roby_population((/i/)) 
     end
     do i = 2,n_atom
     do j = 1,i-1
       n2(i,j) = .roby_population((/i,j/)) 
       if (.atom.not_bonded(i,j)) cycle
             ! if (.mult /= 1) then 
             !  .unrestricted_roby_gould_index((/i,j/), index(i,j), cov(i,j))
             ! else
       .roby_gould_bond_index((/i,j/), index(i,j), cov(i,j)) 
             ! end
     end
     end
     .put_roby_populations( n1, n2, index, cov)
     n1.destroy; n2.destroy
     cov.destroy; index.destroy
   end

   put_roby_populations(n1, n2, index, covalency)
   ! Put to stdout the Roby population analysis data
      VEC  :: n1
      MAT  :: n2
      MAT :: index, covalency
      INT :: a,b
      STR :: symbol_a,symbol_b
      stdout.flush
      stdout.text("Roby populations:",flush=2)
      stdout.dash(int_fields=1,dbl_fields=1)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Population")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=1)
      do a = 1,.n_atom
        symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
        stdout.put( symbol_a,int_width=TRUE)
        stdout.put( n1(a))
        stdout.flush
      end
      stdout.dash(int_fields=1,dbl_fields=1)
      stdout.flush
      stdout.text("Roby pair populations:",flush=2)
      stdout.dash(int_fields=2,dbl_fields=4)
      stdout.put("Atom_a",int_width=TRUE)
      stdout.put("Atom_b",int_width=TRUE)
      stdout.put("n_ab")
      stdout.put("s_ab")
      stdout.put("Bond Index")
      stdout.put("% Covalency")
      stdout.flush
      stdout.dash(int_fields=2,dbl_fields=4)
      do a = 1,.n_atom
      do b = 1,a-1
        symbol_a = .atom(a).chemical_symbol.trim // " (" // a.to_str.trim // ")"
        symbol_b = .atom(b).chemical_symbol.trim // " (" // b.to_str.trim // ")"
        stdout.put(symbol_a,int_width=TRUE)
        stdout.put(symbol_b,int_width=TRUE)
        stdout.put(n2(a,b))
        stdout.put(n1(a)+n1(b)-n2(a,b))
        stdout.put(index(a,b))
        stdout.put(covalency(a,b))
        stdout.flush
      end
      end
      stdout.dash(int_fields=2,dbl_fields=4)
   end

   get_homoleptic_bond_index
   ! Retuns the bond index between groups of atoms
     IVEC, PTR :: roby_atom, roby_atom1, roby_atom2
     DBL :: index, covalency
     .read_roby_groups(roby_atom,roby_atom1,roby_atom2)
     .roby_gould_bond_index(roby_atom1,roby_atom2,index,covalency)
     stdout.show("Bond Index is: ", index)
     stdout.show("% Covalency is: ", covalency) 
     roby_atom.destroy; roby_atom1.destroy; roby_atom2.destroy
   end


!------------------------------------------!
! Routines to get Roby Shared Populations  !
!------------------------------------------!

   get_roby_shared_populations(roby_atom, pop_groups) result(sp)
   ! returns the Roby shared population of "roby_atom"
   ! as well as the calculated sub-group populations "pop_groups"
   IVEC :: roby_atom
   VEC :: pop_groups
   DBL :: sp 
   INT :: m, k, n_k, n_roby_atom
   IMAT, PTR :: comb_mat
      n_roby_atom = size(roby_atom)
      sp = 0
      do k = 1,n_roby_atom
         n_k = n_roby_atom.choose(k)
         comb_mat.create(k,n_k)
         comb_mat = roby_atom.get_combination_matrix_from(k)
         ! comb_mat is the matrix of all combinations of groups
         ! of size k atoms taken from the atoms listed in roby_atom
         pop_groups(k) = 0
         do m = 1,n_k
            pop_groups(k) = pop_groups(k) + .roby_population(comb_mat(:,m))
         end      
         comb_mat.destroy
         sp = sp - ((-1)**k)*pop_groups(k)
      end
   end

   put_roby_shared_population
   ! Evaluate and put the Roby shared population for any group of atoms
   DBL :: shared_population
   INT :: n_roby_atom,a,k
   IVEC, PTR :: roby_atom
   VEC, PTR :: pop_groups
      .read_roby_atom(roby_atom)
      n_roby_atom = size(roby_atom)
      pop_groups.create(n_roby_atom)
      shared_population = .get_roby_shared_populations(roby_atom, pop_groups)
      stdout.flush
      stdout.text("Roby multi-atom shared population analysis:")
      stdout.flush
      stdout.put_text("Atom list         =")
      do k = 1,n_roby_atom
         a = roby_atom(k)
         stdout.put_text( " " )
         stdout.put_text( .atom(a).chemical_symbol.trim)
         stdout.put_text( "(" )
         stdout.put_text( a.to_str.trim )
         stdout.put_text( ")" )
      end
      stdout.flush
      stdout.show("Shared population =",shared_population)
      stdout.flush
      stdout.text("Shared populations by group order:")
      stdout.dash(int_fields=1,dbl_fields=1)
      stdout.put("Order",int_width=TRUE)
      stdout.put("Population")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=1)
      do k = 1,n_roby_atom
         stdout.put(k)
         stdout.put(pop_groups(k))
         stdout.flush
      end
      stdout.dash(int_fields=1,dbl_fields=1)
      pop_groups.destroy
      roby_atom.destroy
   end

!---------------------------------------------!
! Roby Energy and Shared Energy calculations  !
!---------------------------------------------!

   roby_energy_analysis
   ! directs the energy analysis of a diatomic
    IVEC, PTR :: roby_atom
    DBL :: Ep_A, Ep_B, Ep_AB, E_A, E_B, E_AB
    INT :: a,b
    .read_roby_atom(roby_atom)
    ENSURE( size(roby_atom)==2, "Must supply a diatomic...")
    a = roby_atom(1); b=roby_atom(2)
    .put_roby_atom_energy( (/ a /) )
    .put_roby_atom_energy( (/ b /) )
    .put_roby_atom_energy( roby_atom )
    Ep_A = .roby_atom_energy( (/a/))
    Ep_B = .roby_atom_energy( (/b/))
    Ep_AB = .roby_atom_energy( roby_atom)
    E_A = .roby_total_atom_energy((/ a /), nuclei=roby_atom,output=TRUE)
    E_B = .roby_total_atom_energy((/ b /), nuclei=roby_atom,output=TRUE)
    E_AB = .roby_total_atom_energy(roby_atom, nuclei=roby_atom,output=TRUE)
!    E_AB = .roby_atom_energy(roby_atom)
    stdout.show( "Binding Energy: ", HALF * (E_A + E_B - E_AB + Ep_A + Ep_B - Ep_AB) )
    .put_roby_shared_energy(roby_atom)
    .put_roby_ionic_energy(roby_atom)
    stdout.show("Nuclear potential for A:", .atom.nuclear_energy( (/ a /) ))
    stdout.show("Nuclear potential for B:", .atom.nuclear_energy( (/ b /) ))
    roby_atom.destroy
   end

   get_roby_shared_energy(roby_atom) result(se) [leaky]
   ! returns the shared energy of the atoms given in "roby_atom"
   ! as well as the energy of all sub-groups of atoms "en_groups"
     IVEC :: roby_atom
     DBL :: se, energy_subgroup, en_groups 
     INT :: m,k, n_k, n_roby_atom
     IMAT, PTR :: comb_mat
     n_roby_atom = size(roby_atom)
     se = 0
     do k = 1,n_roby_atom
       n_k = n_roby_atom.choose(k)
       comb_mat.create(k,n_k)
       comb_mat = roby_atom.get_combination_matrix_from(k)
       en_groups = 0
       do m = 1,n_k
         energy_subgroup = .roby_total_atom_energy(comb_mat(:,m),output=FALSE)
         en_groups = en_groups + energy_subgroup
       end      
       comb_mat.destroy
       se = se - ((-1)**k)*en_groups
     end
   end

   get_roby_ionic_energy(roby_atom, roby_atom2) result(ionic_energy) [leaky]
   ! returns the shared energy of the atoms given in "roby_atom"
   ! as well as the energy of all sub-groups of atoms "en_groups"
   IVEC :: roby_atom, roby_atom2
   DBL :: ionic_energy, energy_group1, energy_group2 
   DBL :: ground1, ground2
       energy_group1 = .roby_total_atom_energy(roby_atom,output=FALSE)  
       energy_group2 = .roby_total_atom_energy(roby_atom2,output=FALSE) 
       ground1 = sum(.atom(roby_atom).energy)
       ground2 = sum(.atom(roby_atom2).energy)
       stdout.flush
       stdout.dash(dbl_fields=3)
       stdout.put("Ground State Energy of Atom 1"); stdout.put(ground1)
       stdout.flush
       stdout.put("Ground State Energy of Atom 2"); stdout.put(ground2)
       stdout.flush
       stdout.dash(dbl_fields=3)
       stdout.flush
       ionic_energy = energy_group1 - energy_group2 
       ionic_energy = ionic_energy - ground1 + ground2
   end

   put_roby_shared_energy(atoms) [leaky]
   ! Evaluate and put the Roby shared energy for a group of atoms
      IVEC, OPTIONAL :: atoms
      DBL :: shared_energy
      IVEC, PTR :: roby_atom
      if (PRESENT(atoms)) then
          roby_atom.create(size(atoms))
          roby_atom = atoms
      else
          .read_roby_atom(roby_atom)
      end
      shared_energy = .get_roby_shared_energy(roby_atom)
      stdout.flush
      stdout.dash(dbl_fields=3)
      stdout.show("Shared energy =",shared_energy)
      roby_atom.destroy
   end

   put_roby_ionic_energy(atoms) [leaky]
   ! Evaluate and put the Roby ionic energy for a group of atoms
      IVEC, OPTIONAL :: atoms
      INT :: n_roby_atom
      IVEC, PTR :: roby_atom
      if (PRESENT(atoms)) then
          roby_atom.create(size(atoms))
          roby_atom = atoms
      else
          .read_roby_atom(roby_atom)
      end
      n_roby_atom = size(roby_atom)
      ENSURE(n_roby_atom == 2, "current routine only for two atoms")
      stdout.dash(dbl_fields=3) 
      stdout.show("Ionic Energy =", .get_roby_ionic_energy( roby_atom(1:1), roby_atom(2:2)))
      stdout.flush
      roby_atom.destroy
   end

   put_roby_atom_energy(atoms) [leaky]
   ! Evaluate and put the Roby ionic energy for a group of atoms
      IVEC, OPTIONAL :: atoms
      INT :: n_roby_atom, i, a
      IVEC, PTR :: roby_atom
      DBL :: E_T, E_P, E_A
      if (PRESENT(atoms)) then
          roby_atom.create(size(atoms))
          roby_atom = atoms
      else
          .read_roby_atom(roby_atom)
      end
      n_roby_atom = size(roby_atom)
      stdout.dash(dbl_fields=3) 
      stdout.flush
      stdout.text("Roby atom energy analysis:")
      stdout.flush
      stdout.dash(dbl_fields=3) 
      stdout.flush
      stdout.text("Atoms =")
      do i=1,n_roby_atom
        a = roby_atom(i)
        stdout.text(trim(.atom(a).label))
      end 
      E_T = .roby_total_atom_energy(roby_atom)
      E_P = .roby_atom_energy(roby_atom)
      E_A = E_T/2 + E_P/2
      stdout.flush
      stdout.show("Atom Total Energy =", E_T)
      stdout.flush
      stdout.show("Promoted Atom Energy =", E_P)
      stdout.flush
      stdout.show("Partitioned Atom Energy =", E_A)
      stdout.flush
      stdout.dash(dbl_fields=3) 
      stdout.flush
      roby_atom.destroy
   end

   roby_atom_energy(roby_atom) result(energy) [leaky]
   ! Return the Roby promoted atom energy for the group of atoms whose
   ! indices are given in "roby_atom".
      IVEC :: roby_atom
      DBL :: energy
      OPMAT, PTR :: D,D_save
      MAT, PTR :: P, Q
      D_save => .density_matrix
      P.create(.n_bf, .n_bf)
      if (.mult/=1) then
        Q.create(.n_bf, .n_bf)
        .make_roby_projected_density(P,.density_matrix.alpha, roby_atom)
        .make_roby_projected_density(Q,.density_matrix.beta, roby_atom)
        D.create(.n_bf,"unrestricted")
        D.alpha = P        ! P is projected density
        D.beta = Q         ! P is projected density
        Q.destroy
      else
        D.create(.n_bf,"restricted")
        .make_roby_projected_density(P, roby_atom)
        D.restricted = P        ! P is projected density
      end
      .density_matrix => D
      .make_fock_matrix(core=FALSE)
      if (.mult/=1) then
          .add_core_hamiltonian(.fock_matrix.beta, roby_atom)
          .add_core_hamiltonian(.fock_matrix.alpha, roby_atom)
      else
          .add_core_hamiltonian(.fock_matrix.restricted, roby_atom)
      end
      energy = .scf_electronic_energy(D,roby_atom) + .atom(roby_atom).nuclear_energy
      .density_matrix => D_save
      D.destroy
      P.destroy
   end

   roby_total_atom_energy(roby_atom, nuclei, output) result(energy) [leaky]
   ! Return the total Roby energy for the group of atoms whose
   ! indices are given in "roby_atom" If output is present and false energy breakdown
   ! output is suppressed. If nuclei is given then only the nuclei specified
   ! are used for E_N and N_N and N_E interactions, and the projected atoms specified by nuclei for the E_E
   ! repulsions
      IVEC :: roby_atom
      IVEC, optional :: nuclei
      BIN, optional :: output
      BIN :: do_output
      DBL :: energy, E_k, Na_Em, Na_Ea, Ea_Nm, Ea_Em, Ea_Ea
      MAT, PTR :: Pa, Pb, Za, Zm, T
      MAT, PTR :: D, D_save
      do_output=TRUE
      if (present(output)) do_output=output              ! puts out the energies and sub-energies and all that
      T.create(.n_bf, .n_bf); Pa.create(.n_bf, .n_bf)
      Za.create(.n_bf, .n_bf); Zm.create(.n_bf, .n_bf)
      if (present(nuclei)) then
         .make_nuclear_matrix(Zm,nuclei)   ! The e->n attractions of the atoms electrons for the "nuclei"
      else
         .make_nuclear_matrix(Zm)          ! The e->n attractions of the atoms electrons for all the nuclei
      end
      .make_nuclear_matrix(Za,roby_atom)   ! The n->e attractions felt by the nuclei in the roby atom
      .make_kinetic_matrix(T,output=FALSE) ! The electronic kinetic energy matrix
      if (.mult/=1) then
        Pb.create(.n_bf, .n_bf)
        if (present(nuclei)) then          ! if we only want to look at interactions with subgroups of the molecule
          D_save => .density_matrix.alpha  ! store the "real" density matrix of the molecule
          D => .density_matrix.beta
          .make_roby_projected_density(Pa, .density_matrix.alpha, nuclei)
          .make_roby_projected_density(Pb, .density_matrix.beta, nuclei)
          .density_matrix.alpha => Pa      ! replace the "real" density matrix with the projected "nuclei"
          .density_matrix.beta => Pb 
          .make_fock_matrix(core=FALSE)    ! calculate e-e repulsions for all electrons in projected "nuclei" 
          Na_Em = Za.trace_of_product(.density_matrix.alpha) + Za.trace_of_product(.density_matrix.beta)
                                           ! calculate n-e repulsions for all electrons in projected "nuclei"
                                           ! and nuclei in "roby_atom"
          .density_matrix.alpha => D_save  ! restore "real" density matrix
          .density_matrix.beta => D
        else
          .make_fock_matrix(core=FALSE)    ! calculate e-e repulsions for all electrons in molecule
          Na_Em = Za.trace_of_product(.density_matrix.alpha) + Za.trace_of_product(.density_matrix.beta)
                                           ! calculate e-e repulsions for all electrons in molecule with roby_atom
        end
        D_save => .density_matrix.alpha    ! save "real" density matrix 
        D => .density_matrix.beta
        .make_roby_projected_density(Pa,.density_matrix.alpha, roby_atom)
        .make_roby_projected_density(Pb,.density_matrix.beta, roby_atom)
        Ea_Em = .fock_matrix.alpha.trace_of_product(Pa) + .fock_matrix.beta.trace_of_product(Pb)
        E_k = T.trace_of_product(Pa) + T.trace_of_product(Pb)     ! calculate Kinetic Energy for "roby_atom" electrons
        Na_Ea = Za.trace_of_product(Pa) + Za.trace_of_product(Pb) ! calculate Nuclear -> electron energy  (A->A)
        Ea_Nm = Zm.trace_of_product(Pa) + Zm.trace_of_product(Pb) ! calculate Nuclear -> electron energy  (M->A)
        .density_matrix.alpha => Pa        ! set "real" density matrix to be the projected atoms "roby_atom"
        .density_matrix.beta => Pb
        .make_fock_matrix(core=FALSE)      ! calculate repulsions within the "roby_atom"
        Ea_Ea = .fock_matrix.alpha.trace_of_product(Pa) + .fock_matrix.beta.trace_of_product(Pb)
        Ea_Em = Ea_Em - Ea_Ea/2            ! subtract 1/2 of the internal atom repulsions for double up
        .density_matrix.alpha => D_save 
        .density_matrix.beta => D          ! reset "real" density matrix
        Pb.destroy
      else
        if (present(nuclei)) then             ! to look at the energy of the atom in the field of only certain atoms "nuclei"
          D_save => .density_matrix.restricted          ! save the "real" density matrix
          .make_roby_projected_density(Pa, nuclei)   ! reset the "real" density matrix to a projected density
          .density_matrix.restricted => Pa 
          Na_Em = Za.trace_of_product(.density_matrix.restricted)
          .make_fock_matrix(core=FALSE)      ! no core and for the whole molecule
          .density_matrix.restricted => D_save
        else
          Na_Em = Za.trace_of_product(.density_matrix.restricted)
          .make_fock_matrix(core=FALSE)
        end
        D_save => .density_matrix.restricted
        .make_roby_projected_density(Pa, roby_atom)
        Ea_Em = .fock_matrix.restricted.trace_of_product(Pa)
        Na_Ea = Za.trace_of_product(Pa)
        Ea_Nm = Zm.trace_of_product(Pa)
        E_k = T.trace_of_product(Pa)
        .density_matrix.restricted => Pa
        .make_fock_matrix(core=FALSE)      ! no core and for the whole molecule
        Ea_Ea = .fock_matrix.restricted.trace_of_product(Pa)
        Ea_Em = Ea_Em - Ea_Ea/2
        .density_matrix.restricted => D_save 
      end
      energy = Na_Em + E_k + Ea_Em + Ea_Nm - Na_Ea 
      if (present(nuclei)) then
        energy = energy + .atom.nuclear_energy(roby_atom,nuclei)
      else
        energy = energy + .atom.nuclear_energy(roby_atom)
      end
      if (do_output) then
       stdout.dash(dbl_fields=3)
       stdout.show("N_a to E_m:",Na_Em)
       stdout.show("N_a to E_a:",Na_Ea)
       stdout.show("E_a to N_m:",Ea_Nm)
       stdout.show("E_a to E_m:",Ea_Em)
       stdout.show("N_a to N_m:", .atom.nuclear_energy(roby_atom))
       stdout.show("Kinetic Energy:", E_k)
       stdout.show("Total Energy:", energy)
       stdout.dash(dbl_fields=3)
      end
      Pa.destroy
   end

!-----------------------------------------------------------!
! Plot the density surface of a roby_atom in the molecule   !
!-----------------------------------------------------------!

   plot_subspace_density
   ! plots the density of the subspace given in the input file
   OPMAT, PTR :: subspace_NOs, subspace_density, saved_density, saved_NOs
   VEC, PTR :: projected_density_grid
   IVEC, PTR :: roby_atom
   ARCHIVE :: archive
      .read_roby_atom( roby_atom)
      if (.mult /= 1)then
          subspace_density.create( .n_bf, "unrestricted")
          subspace_NOs.create( .n_bf, "unrestricted")
          .make_roby_projected_NOs(subspace_NOs.alpha, .natural_orbitals.alpha, roby_atom)
          .make_roby_projected_NOs(subspace_NOs.beta, .natural_orbitals.beta, roby_atom)
          .make_roby_projected_density(subspace_density.alpha, .density_matrix.alpha, roby_atom)
          .make_roby_projected_density(subspace_density.beta, .density_matrix.beta, roby_atom)
      else
          subspace_density.create( .n_bf, "restricted")
          subspace_NOs.create( .n_bf, "restricted")
          .make_roby_projected_NOs(subspace_NOs.restricted, roby_atom)
          .make_roby_projected_density(subspace_density.restricted, roby_atom)
      end
      saved_NOs => .natural_orbitals
      saved_density => .density_matrix
      .natural_orbitals => subspace_NOs
      .density_matrix => subspace_density
      projected_density_grid.create( .grid.n_pt)
      .make_density_grid(projected_density_grid)
      archive.set(.name,"projected_density_grid,gnuplot",format="ascii")
      archive.write_gnuplot(projected_density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      .natural_orbitals => saved_NOs
      .density_matrix => saved_density
      saved_density.nullify_ptr_part; saved_NOs.nullify_ptr_part
      roby_atom.destroy; subspace_NOs.destroy
      subspace_density.destroy
   end

!-----------------------------------------!
! Plot covalent and ionic theta orbitals  !
!-----------------------------------------!

   plot_covalent_orbitals(density)
   ! creates the covalent operator for the roby_atom
   ! and plots the theta orbitals
   ! If density supplied and TRUE will output the orbital density rather
   ! than the wavefunction 
   IVEC, PTR :: roby_atom, roby_atom1, roby_atom2
   BIN, OPTIONAL :: density
   BIN :: do_density
   INT :: n_bf
   MAT, PTR :: R
     do_density=FALSE
     if (present(density)) do_density=density
     .read_roby_groups(roby_atom,roby_atom1,roby_atom2)
     n_bf= .atom(roby_atom).n_bf
     R.create(n_bf,n_bf)
     .make_roby_shared_operator(R,roby_atom1,roby_atom2)
     .plot_theta_orbitals(roby_atom,R,do_density)
     roby_atom.destroy
     roby_atom1.destroy
     roby_atom2.destroy
     R.destroy
   end

   plot_covalent_density_orbitals
   ! creates the covalent operator for the roby_atom
   ! and plots the theta density orbitals
      .plot_covalent_orbitals(density=TRUE)
   end

   plot_ionic_orbitals(density)
   ! creates the ionic operator for the roby_atom
   ! and plots the theta orbitals
   ! If density supplied and TRUE will output the orbital density rather
   ! than the wavefunction 
   IVEC, PTR :: roby_atom, roby_atom1, roby_atom2
   BIN, OPTIONAL :: density
   BIN :: do_density
   INT :: n_bf
   MAT, PTR :: I
     do_density=FALSE
     if (present(density)) do_density=density
     .read_roby_groups(roby_atom,roby_atom1,roby_atom2)
     n_bf= .atom(roby_atom).n_bf
     I.create(n_bf,n_bf)
     .make_roby_ionic_operator(I,roby_atom1,roby_atom2)
     .plot_theta_orbitals(roby_atom,I,do_density)
     roby_atom.destroy
     roby_atom1.destroy
     roby_atom2.destroy
     I.destroy
   end

   plot_ionic_density_orbitals
   ! creates the covalent operator for the roby_atom
   ! and plots the theta density orbitals
      .plot_ionic_orbitals(density=TRUE)
   end

   plot_theta_orbitals(roby_atom,operator, density)
   ! plots all the theta orbitals involving the diatomic specified
   ! "operator" is the matrix of either the cosine or sine operator
   ! which determines whether covalent or ionic orbitals are produced
   ! "density" is present and TRUE gives orbital density plots.
      IVEC, PTR :: roby_atom
      MAT :: operator
      BIN, optional :: density
      BIN :: make_density
      INT :: i, size_theta
      VEC,PTR :: eigenval
      OPMAT, PTR :: proj_NOs, saved_NOs
      MAT, PTR :: theta
      .grid.put
      make_density = FALSE
      if (present(density)) make_density = density 
      size_theta = .atom(roby_atom).n_bf
      theta.create(size_theta,size_theta)
      eigenval.create(size_theta)
      .make_gould_theta_orbitals(operator,roby_atom,theta,eigenval)
      saved_NOs => .natural_orbitals
      do i = 1, size_theta
        if (abs(eigenval(i))<1.0d-05) cycle 
        if (.mult/=1) then
           proj_NOs.create( .n_bf, "unrestricted")
           .make_roby_projected_NOs(proj_NOs.alpha, .natural_orbitals.alpha, roby_atom, theta(:,i:i))
           .make_roby_projected_NOs(proj_NOs.beta, .natural_orbitals.beta, roby_atom, theta(:,i:i))
           proj_NOs.convert_to("restricted")
        else
           proj_NOs.create( .n_bf, "restricted")
           .make_roby_projected_NOs(proj_NOs.restricted, roby_atom, theta(:,i:i))
        end   
        .natural_orbitals => proj_NOs
        if (make_density) then
           .make_orbital_density_grid(i)
        else
           .make_orbital_grid(i)
        end
        !----------------------------------------------------!
        ! WARNING: These will be written to either:          !
        ! ?name?:orbital_grid?orb?,gnuplot,ascii             !
        ! ?name?:orbital_density_grid?orb?,gnuplot,ascii     !
        ! regardless of being covalent or ionic orbitals.    !
        !----------------------------------------------------!
        .natural_orbitals => saved_NOs
        proj_NOs.destroy
      end 
      eigenval.destroy
      theta.destroy
      saved_NOs.nullify_ptr_part
   end

!-----------------------------------------!
! Routines to calculate Roby populations  !
!-----------------------------------------!
 
   roby_population(roby_atom) result(population) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom".
      IVEC :: roby_atom
      DBL :: alpha_population, beta_population, population
      MAT, PTR :: X,Y
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
!      if (.mult /= 1) then
!         ! Unrestricted Roby procedure
!         X_A.create( n_bf,  n_bf)
!         Y_A.create(.n_bf, .n_bf)
!         X_B.create( n_bf,  n_bf)
!         Y_B.create(.n_bf, .n_bf)
!         spin="alpha"
!         .make_roby_projection_matrix(X_A,spin,roby_atom)
!         spin="beta"
!         .make_roby_projection_matrix(X_B,spin,roby_atom)
!         .roby_overlap_transform(X_A,Y_A,roby_atom)
!         .roby_overlap_transform(X_B,Y_B,roby_atom)
!         population = HALF * ( Y_A.trace_of_product( .density_matrix.alpha) &
!              + Y_A.trace_of_product( .density_matrix.beta) &
!              + Y_B.trace_of_product( .density_matrix.alpha) &
!              + Y_B.trace_of_product( .density_matrix.beta) )
!         Y_A.destroy; X_A.destroy; Y_B.destroy; X_B.destroy
!      else
         ! Restricted Roby procedure
         X.create( n_bf,  n_bf)
         Y.create(.n_bf, .n_bf)
         .make_roby_projection_matrix(X,roby_atom)
         .roby_overlap_transform(X,Y,roby_atom)
         if (.mult/=1) then
           alpha_population = Y.trace_of_product( .density_matrix.alpha)
           beta_population = Y.trace_of_product( .density_matrix.beta)
           population = alpha_population + beta_population
         else
           population = Y.trace_of_product( .density_matrix.restricted)
         end
         Y.destroy
         X.destroy
!      end
   end

   roby_population_from_rho(roby_atom,rho) result(population) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom" and for which the density matrix
   ! used for projection is given by rho 
      IVEC :: roby_atom
      MAT, PTR :: rho 
      DBL :: population
      MAT, PTR :: X,Y
      INT :: n_bf
      ENSURE(size(rho,1)==.n_bf,"rho has wrong size")
      ENSURE(size(rho,2)==.n_bf,"rho has wrong size")
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      Y.create(.n_bf, .n_bf)
      .make_roby_projection_matrix(X,roby_atom)
      .roby_overlap_transform(X,Y,roby_atom)
      population = Y.trace_of_product( rho)
      Y.destroy
      X.destroy
   end

   roby_population(roby_atom,ANO) result(population) 
   ! Return the (total) Roby population for the group of atoms whose
   ! indices are given in "roby_atom" and for which the roby projection
   ! operator orbitals are defined by columns of "ANO"
      IVEC :: roby_atom
      MAT :: ANO
      DBL :: population
      MAT, PTR :: X,Y
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      Y.create(.n_bf, .n_bf)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      .roby_overlap_transform(X,Y,roby_atom)
      if (.mult /= 1) then
         population = Y.trace_of_product( .density_matrix.alpha + .density_matrix.beta)
      else
         population = Y.trace_of_product( .density_matrix.restricted)
      end
      Y.destroy
      X.destroy
   end

   roby_population(roby_atom,ANO,atom) result(population) 
   ! Return the (total) Roby population for atom "atom" of the group of atoms
   ! whose indices are given in "roby_atom" and for which the roby projection
   ! operator orbitals are defined by columns of "ANO"
      IVEC :: roby_atom
      MAT :: ANO
      INT :: atom
      DBL :: population
      MAT, PTR :: X,Y,PA,Z,W
      INT :: n_bf,n_af
      n_bf = .atom(roby_atom).no_of_basis_functions
      n_af = .atom(roby_atom(atom)).no_of_basis_functions
      X.create(n_bf, n_bf)
      Y.create(n_af, n_af)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      .roby_overlap_transform(X,Y,roby_atom,roby_atom(atom:atom))
      PA.create(n_af,n_af)
      .make_roby_projection_matrix(PA,roby_atom(atom:atom))
      Z.create(n_af,n_af)
      .roby_project(Y,Z,PA)
      W.create(.n_bf,.n_bf) 
      .roby_overlap_transform(Z,W,roby_atom(atom:atom)) 
      if (.mult/=1) then
        population = W.trace_of_product( .density_matrix.alpha + &
              .density_matrix.beta)
      else 
        population = W.trace_of_product( .density_matrix.restricted)
      end
      W.destroy 
      Z.destroy 
      PA.destroy 
      Y.destroy
      X.destroy
   end

!------------------------------------------!
! Routines to get Roby-Gould bond indices  !
!------------------------------------------!

   roby_gould_bond_index(roby_atom, bond_index, pcc)
   ! Calculates the Roby-Gould bond index and percentage covalent
   ! character for two atoms 
      IVEC :: roby_atom
      DBL :: bond_index, pcc
      INT :: a, b
      ENSURE(size(roby_atom)==2,"roby_atom has wrong size")
      a = roby_atom(1)
      b = roby_atom(2)
      .roby_gould_bond_index( (/ a /), (/ b /), bond_index, pcc)
   end

   roby_gould_bond_index(roby_atom1, roby_atom2, bond_index, pcc)
   ! Calculates the Roby-Gould bond index and percentage covalent
   ! character for two atoms for restricted molecules
      IVEC :: roby_atom1, roby_atom2
      IVEC, PTR :: roby_atom
      DBL :: bond_index, pcc
      MAT, PTR :: C, theta_c, S, theta_s
      VEC, PTR :: cval, c_p, sval, s_p 
      VEC, PTR :: c_a, c_b, s_a, s_b
      VEC, PTR :: covalency,ionicity
      IVEC, PTR :: c_pair, s_pair
      INT :: n_a, n_b, n_ab
      BIN :: output
      DBL :: total_i,total_c,cutoff
      output = TRUE
      n_a = .atom(roby_atom1).no_of_basis_functions
      n_b = .atom(roby_atom2).no_of_basis_functions
      n_ab = n_a + n_b
      roby_atom.create(size(roby_atom1) + size(roby_atom2))
      roby_atom(1:size(roby_atom1)) = roby_atom1
      roby_atom(size(roby_atom1)+1:) = roby_atom2
      C.create(n_ab,n_ab); theta_c.create(n_ab, n_ab); cval.create(n_ab)
      S.create(n_ab,n_ab); theta_s.create(n_ab, n_ab); sval.create(n_ab)
      c_p.create(n_ab); s_p.create(n_ab)
      c_a.create(n_ab); c_b.create(n_ab)
      s_a.create(n_ab); s_b.create(n_ab)
      .make_roby_shared_operator(C,roby_atom1,roby_atom2)
      .make_roby_ionic_operator(S,roby_atom1,roby_atom2)
      .make_gould_theta_orbitals(C,roby_atom,theta_c,cval)
      .make_gould_theta_orbitals(S,roby_atom,theta_s,sval)
      .get_theta_populations(roby_atom, theta_c, c_p, c_a, c_b)
      .get_theta_populations(roby_atom, theta_s, s_p, s_a, s_b)
      c_pair.create(n_ab); s_pair.create(n_ab)
      cutoff = 0.025
      cval.find_opposite_pairs(c_pair,cutoff,ONE-cutoff)
      sval.find_opposite_pairs(s_pair,cutoff,ONE-cutoff)
      covalency.create(n_ab); ionicity.create(n_ab)
      total_c = .get_roby_gould_index(c_pair,c_p,covalency,pi_space=TRUE)
      total_i = .get_roby_gould_index(s_pair,s_p,ionicity,pi_space=FALSE)
!      total_i = total_i + HALF*(sum(.atom(roby_atom2).atomic_number) - sum(.atom(roby_atom1).atomic_number))
      bond_index = sqrt( total_c**2 + total_i **2)
      pcc = (total_c/bond_index)**2
      if (output) then
        .put_roby_gould_data(roby_atom1,roby_atom2,bond_index,pcc,1-pcc)
        .put_roby_gould_c_data(covalency,ionicity,cval,c_p,c_pair,c_a,c_b)
        .put_roby_gould_s_data(covalency,ionicity,sval,s_p,s_pair,s_a,s_b)
      end
      covalency.destroy
      ionicity.destroy
      C.destroy; theta_c.destroy; cval.destroy
      S.destroy; theta_s.destroy; sval.destroy
      c_p.destroy; c_pair.destroy; c_b.destroy; s_b.destroy
      s_p.destroy; s_pair.destroy; c_a.destroy; s_a.destroy
      roby_atom.destroy
   end   

   ! can probably get rid of this too
   unrestricted_roby_gould_index(roby_atom, bond_index,pcc)
   ! Calculates the Roby-Gould index and percentage covalent
   ! character for diatomics in unrestricted molecules
     IVEC :: roby_atom
     DBL :: bond_index, pcc
     DBL :: cov_a, ion_a, cov_b, ion_b
     STR :: alpha, beta
     alpha = "alpha"; beta="beta"
     .get_unres_roby_gould_data(roby_atom, cov_a, ion_a, alpha)
     .get_unres_roby_gould_data(roby_atom, cov_b, ion_b, beta)
     bond_index = sqrt( ((cov_a + cov_b)/2)**2 + ((ion_a + ion_b)/2)**2)
     pcc = (HALF*(cov_a + cov_b)/bond_index)**2
     .put_roby_gould_data( roby_atom(1:1), roby_atom(2:2), bond_index, pcc, 1-pcc)
   end
     
   get_roby_gould_index(pair,population,orbital_strength,pi_space) result(index)
   ! calculates the index "ind" from the theta "population" data
   ! NOTE : returns only the ionic or covalent index !!!!!!
   ! "orbital_strength" = (#bonding - #anti-bonding) / 2
   ! If "pi_space"=TRUE pi/2 orbitals calc'd from orbital_strength = occupation
   ! "pair" is the anti-bonding/bonding pair list
      IVEC :: pair
      VEC :: population, orbital_strength 
      BIN, OPTIONAL :: pi_space
      BIN :: do_pi
      INT :: j, n_ab
      DBL :: index
      n_ab = size(population)
      orbital_strength.zero
      do_pi=FALSE
      if (present(pi_space)) do_pi=pi_space
      do j = 1, n_ab
         if (do_pi) then 
           if (pair(j) == (-2)) orbital_strength(j) =  population(j)/2 
           if (pair(j) == (-1)) orbital_strength(j) = -population(j)/2 
         end
         if (pair(j) <= 0) cycle 
         orbital_strength(j) = (population(j) - population(pair(j)))/2
      end
      index = sum(orbital_strength) 
   end

   get_theta_populations(roby_atom, theta, p, a, b)
   ! returns the theta populations of the "theta" orbitals from "roby_atom"
   ! including the population, "p", and the populations of the atoms
   ! as "a" and "b" if present.
     IVEC :: roby_atom
     MAT :: theta
     VEC :: p
     VEC, optional :: a, b
     INT :: i
     do i = 1, size(p)
       p(i) = .roby_population(roby_atom,theta(:,i:i)) 
       a(i) = .roby_population(roby_atom,theta(:,i:i),1) 
       b(i) = .roby_population(roby_atom,theta(:,i:i),2) 
     end
   end

   get_unres_roby_gould_data(roby_atom, total_c, total_i, spin_case) 
   ! provides the covalency and ionicity of orbitals for the roby_gould
   ! bond index calculation required in the unrestricted case
   ! spin_case is a STR describing whether alpha or beta orbitals
   ! are required.
      IVEC :: roby_atom
      DBL :: total_i,total_c
      STR :: spin_case
      MAT, PTR :: C, theta_c, S, theta_s
      VEC, PTR :: cval, c_p, sval, s_p
      VEC, PTR :: covalency,ionicity
      IVEC, PTR :: c_pair, s_pair
      INT :: n_a, n_b, n_ab, a, b
      ENSURE(size(roby_atom)==2,"roby_atom has wrong size")
      a = roby_atom(1)
      b = roby_atom(2)
      n_a = .atom(a).no_of_basis_functions
      n_b = .atom(b).no_of_basis_functions
      n_ab = n_a + n_b
      C.create(n_ab,n_ab); theta_c.create(n_ab, n_ab); cval.create(n_ab)
      S.create(n_ab,n_ab); theta_s.create(n_ab, n_ab); sval.create(n_ab)
      c_p.create(n_ab); s_p.create(n_ab)
      .make_roby_shared_operator(C,(/ a /), (/ b /),spin_case)
      .make_roby_ionic_operator(S,(/a /), (/ b /),spin_case)
      .make_gould_theta_orbitals(C,roby_atom,theta_c,cval)
      .make_gould_theta_orbitals(S,roby_atom,theta_s,sval)
      .get_theta_populations(roby_atom, theta_c, c_p)
      .get_theta_populations(roby_atom, theta_s, s_p)
      c_pair.create(n_ab); s_pair.create(n_ab)
      cval.find_opposite_pairs(c_pair,TOL(5),ONE-TOL(5))
      sval.find_opposite_pairs(s_pair,TOL(5),ONE-TOL(5))
      covalency.create(n_ab)
      ionicity.create(n_ab)
      total_c = .get_roby_gould_index(c_pair,c_p,covalency)
      total_i = .get_roby_gould_index(s_pair,s_p,ionicity)
      covalency.destroy   ! may want to use later ...
      ionicity.destroy    ! .. ditto ..
      C.destroy; theta_c.destroy; cval.destroy
      S.destroy; theta_s.destroy; sval.destroy
      c_p.destroy; c_pair.destroy
      s_p.destroy; s_pair.destroy
   end   

   put_roby_gould_data(roby_atom1,roby_atom2,bond_index,pc_covalency,pc_ionicity)
   ! Output detailed Roby-Gould bond index information
      IVEC :: roby_atom1,roby_atom2
      DBL :: bond_index,pc_covalency,pc_ionicity
      INT :: i, a
      stdout.flush
      stdout.text("Gould bond index data:",flush=2)
      stdout.put("Atom_a           =")
      do i = 1,size(roby_atom1)
         a = roby_atom1(i)
         stdout.put(.atom(a).label)
      end
      stdout.flush
      stdout.put("Atom_b           =")
      do i = 1,size(roby_atom2)
         a = roby_atom2(i)
         stdout.put(.atom(a).label)
      end
      stdout.flush
      stdout.show("Total bond_index =",bond_index)
      stdout.show("% Covalency      =",pc_covalency)
      stdout.show("% Ionicity       =",pc_ionicity)
   end

   put_roby_gould_c_data(covalency,ionicity,cos_theta,c_p,c_pair,c_a,c_b)
   ! Output detailed Roby-Gould bond index information
      VEC :: covalency,ionicity,cos_theta,c_p,c_a,c_b
      IVEC :: c_pair
      INT :: i, n_ab
      stdout.flush
      n_ab =size(c_p)
      stdout.flush
      stdout.text("Cos(theta) subspace data:")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=5)
      stdout.put("Theta/dg",int_width=TRUE)
      stdout.put("Theta(+) pop")
      stdout.put("Theta(a+) pop")
      stdout.put("Theta(b+) pop")
      stdout.put("Covalent Index")
      stdout.put("Ionic Index")
      stdout.flush
      stdout.tab(int_fields=1)
      stdout.put("Theta(-) pop")
      stdout.put("Theta(a-) pop")
      stdout.put("Theta(b-) pop")
      stdout.flush
      stdout.tab(int_fields=1)
      stdout.put("Theta    pop")
      stdout.put("Theta(a ) pop")
      stdout.put("Theta(b ) pop")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=5)
      do i = 1, n_ab
         if (c_pair(i) <= 0) cycle
         stdout.put(nint(180* cos_theta(i).arccos/ PI))
         stdout.put(c_p(i))
         stdout.put(c_a(i))
         stdout.put(c_b(i))
         stdout.put(covalency(i))
         stdout.put(ionicity(i))
         stdout.flush
         stdout.tab(int_fields=1)
         stdout.put(c_p(c_pair(i)))
         stdout.put(c_a(c_pair(i)))
         stdout.put(c_b(c_pair(i)))
         stdout.flush
         stdout.tab(int_fields=1)
         stdout.put(c_p(i)+c_p(c_pair(i)))
         stdout.put(c_a(i)+c_a(c_pair(i)))
         stdout.put(c_b(i)+c_b(c_pair(i)))
         stdout.flush
      end
      stdout.dash(int_fields=1,dbl_fields=5)
   end

   put_roby_gould_s_data(covalency,ionicity,sin_theta,s_p,s_pair,s_a,s_b)
   ! Output detailed Roby-Gould bond index information
      VEC :: covalency,ionicity,sin_theta,s_p,s_a,s_b
      IVEC :: s_pair
      INT :: i, n_ab, theta
      stdout.flush
      n_ab =size(s_p)
      stdout.flush
      stdout.text("Sin(theta) subspace data:")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=5)
      stdout.put("Theta/dg",int_width=TRUE)
      stdout.put("Theta(+) pop")
      stdout.put("Theta(a+) pop")
      stdout.put("Theta(b+) pop")
      stdout.put("Covalent Index")
      stdout.put("Ionic Index")
      stdout.flush
      stdout.tab(int_fields=1)
      stdout.put("Theta(-) pop")
      stdout.put("Theta(a-) pop")
      stdout.put("Theta(b-) pop")
      stdout.flush
      stdout.tab(int_fields=1)
      stdout.put("Theta    pop")
      stdout.put("Theta(a ) pop")
      stdout.put("Theta(b ) pop")
      stdout.flush
      stdout.dash(int_fields=1,dbl_fields=5)
      do i = 1, n_ab
         theta = nint(180* sin_theta(i).arcsin/ PI)
         if (s_pair(i) > 0 OR abs(theta)==90) then
            stdout.put(theta)
            stdout.put(s_p(i))
            stdout.put(s_a(i))
            stdout.put(s_b(i))
            stdout.put(covalency(i))
            stdout.put(ionicity(i))
            stdout.flush
         end
         if (s_pair(i) > 0) then
            stdout.tab(int_fields=1)
            stdout.put(s_p(s_pair(i)))
            stdout.put(s_a(s_pair(i)))
            stdout.put(s_b(s_pair(i)))
            stdout.flush
            stdout.tab(int_fields=1)
            stdout.put(s_p(i)+s_p(s_pair(i)))
            stdout.put(s_a(i)+s_a(s_pair(i)))
            stdout.put(s_b(i)+s_b(s_pair(i)))
            stdout.flush
         end
      end
      stdout.dash(int_fields=1,dbl_fields=5)
   end

!---------------------------------------------------!
! Roby-Gould partitioning information               !
! Used to verify the additivity of the operators    !
!---------------------------------------------------!

   roby_gould_partitioning(cval,c_p,c_pair,sval,s_p,s_pair)
   ! Calculates the roby_gould partitioning data
   ! where the ionic and shared components are extracted
   ! from the eigenvector populations and gives this as output.
      VEC :: cval, c_p, s_p, sval
      IVEC :: c_pair, s_pair
      IVEC, PTR :: angle_c, angle_s, angle_pairs
      VEC, PTR :: s_ab, i_ab 
      VEC, PTR :: s_total, i_total
      VEC, PTR :: n2
      INT :: i
      s_ab.create(size(c_p))
      s_ab = abs(cval) * c_p
      ! make the |I_AB| data for each theta orbital = i_ab
      i_ab.create(size(c_p))
      i_ab = abs(sval) * s_p
      stdout.dash(dbl_fields=4,int_fields=1)
      stdout.put("Roby Gould Partitioning."); stdout.flush
      stdout.dash(dbl_fields=4,int_fields=1)
      stdout.flush
      stdout.put("Theta (dg)", int_width=TRUE)
      stdout.put("Covalent")
      stdout.put("Ionic")
      stdout.put("Sum Weighted")
      stdout.put("Total")
      stdout.flush
      stdout.tab(int_fields=1)
      stdout.put("Population")
      stdout.put("Population")
      stdout.put("Squares")
      stdout.put("Population")
      stdout.flush
      stdout.dash(dbl_fields=4,int_fields=1)
      angle_c.create(size(c_p)) 
      angle_s.create(size(s_p))
      s_total.create(size(c_p)); s_total.zero
      i_total.create(size(s_p)); i_total.zero
      do i = 1, size(c_p)
        angle_c(i) = nint(180*cval(i).arccos/PI)
        angle_s(i) = nint(180*sval(i).arcsin/PI)
         if (c_pair(i) <= 0) cycle
         s_total(i) = s_ab(i) + s_ab(c_pair(i))
         if (s_pair(i) == 0) cycle
         if (s_pair(i) == (-1)) then
            i_total(i) = i_ab(i)
         else
            i_total(i) = i_ab(i) + i_ab(s_pair(i))
         end
      end
      angle_pairs.create(size(c_p))
      angle_pairs.pair_vec_from(angle_c,angle_s)
      n2.create(size(c_p)); n2.zero
      do i = 1, size(c_p)
        if (angle_pairs(i)==0) cycle
        if (c_pair(i)==0) cycle
        n2(i) = sqrt(i_total(angle_pairs(i))**2 + s_total(i)**2)
        stdout.put(angle_c(i))
        stdout.put(s_total(i))
        stdout.put(i_total(i))
        stdout.put(n2(i))
        stdout.put(c_p(i) + c_p(c_pair(i)))
        stdout.flush
      end
      stdout.dash(int_fields=1,dbl_fields=4)
      angle_c.destroy; angle_s.destroy
      s_total.destroy; i_total.destroy
      i_ab.destroy; s_ab.destroy
      angle_pairs.destroy
      n2.destroy
   end

   make_roby_gould_superoperators(roby_atom,R_AB,I_AB,theta_c)
   ! Makes the superoperators R_AB^2 and calculates the expectation value
   ! of this over each theta orbital. Similarly for I_AB^2.
   ! R_AB^2 = -P_A - P_B +P_AB + P_A.P_B + P_B.P_A
   ! I_AB^2 = P_A + P_B - P_A.P_B - P_B.P_A
   IVEC :: roby_atom
   VEC :: R_AB, I_AB
   MAT :: theta_c
   MAT, PTR :: rho_A, rho_B, rho_t
   VEC, PTR :: p_a, p_b, p_ab, bp_a, ap_b
   INT :: i, n_theta
    rho_A.create( .n_bf, .n_bf)
    rho_B.create( .n_bf, .n_bf)
    rho_t.create( .n_bf, .n_bf)
    n_theta = size(theta_c,1)
    p_a.create( n_theta)
    p_b.create( n_theta)
    p_ab.create( n_theta)
    bp_a.create( n_theta)
    ap_b.create( n_theta)
    do i = 1, size(theta_c,1)
      p_a(i)  = .roby_population(roby_atom,theta_c(:,i:i),1)  ! P_A  rho_theta
      p_b(i)  = .roby_population(roby_atom,theta_c(:,i:i),2)  ! P_B  rho_theta
      p_ab(i) = .roby_population(roby_atom,theta_c(:,i:i))    ! P_AB rho_theta
      .make_roby_projected_density(rho_t,roby_atom,theta_c(:,i:i))
      .make_roby_projected_density(rho_A,rho_t,roby_atom(1:1))
      .make_roby_projected_density(rho_B,rho_t,roby_atom(2:2))
      bp_a(i) = .roby_population_from_rho(roby_atom(2:2),rho_A) ! P_B.P_A rho_t
      ap_b(i) = .roby_population_from_rho(roby_atom(1:1),rho_B) ! P_A.P_B rho_t 
    end
    R_AB = -p_a - p_b + p_ab + bp_a + ap_b
    I_AB = p_a + p_b - ap_b - bp_a
    rho_A.destroy; rho_B.destroy; rho_t.destroy
    p_a.destroy; p_b.destroy; p_ab.destroy; bp_a.destroy; ap_b.destroy
   end

   put_roby_gould_superoperators(R_AB,I_AB,c_p,c_pair, cval)
   ! outputs the Roby_gould superoperator relationships for the bond
   VEC :: R_AB, I_AB, c_p, cval
   IVEC :: c_pair
   INT :: i
     stdout.dash(int_fields=1,dbl_fields=4)
     stdout.put("Roby-Gould super operator relationships.")
     stdout.flush
     stdout.dash(int_fields=1,dbl_fields=4)
     stdout.put("Theta (dg)",int_width=TRUE)
     stdout.put("R_AB^2")
     stdout.put("I_AB^2")
     stdout.put("I_AB^2 + R_AB^2")
     stdout.put("n_theta"); stdout.flush
     stdout.dash(int_fields=1,dbl_fields=4)
     do i = 1, size(c_p)
      if (c_pair(i)<=0) cycle
      stdout.put(nint(180*cval(i).arccos/PI))
      stdout.put(R_AB(i) + R_AB(c_pair(i)))
      stdout.put(I_AB(i) + I_AB(c_pair(i)))
      stdout.put(R_AB(i) + I_AB(i) + R_AB(c_pair(i)) + I_AB(c_pair(i)))
      stdout.put(c_p(i) + c_p(c_pair(i))); stdout.flush
     end
     stdout.dash(int_fields=1,dbl_fields=4)
   end

!---------------------!
! Make Roby operators !
!---------------------!

   make_roby_projection_matrix(P,roby_atom)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom"
     MAT :: P
     IVEC :: roby_atom
     MAT, PTR :: W,X,Y
     INT :: n_roby_atom, n_occ,n_bf
     n_bf  = .atom(roby_atom).no_of_basis_functions
     ENSURE(size(P,1)==n_bf,"P is incorrectly dimensioned")
     ENSURE(size(P,2)==n_bf,"P is incorrectly dimensioned")
     n_occ = .atom(roby_atom).no_of_occupied_ANOs(tol=real(0.05,kind=DBL_KIND))
     n_roby_atom = size(roby_atom)
     W.create(n_bf,n_occ)                   ! W = columns of ANO's
     .make_ANO_matrix(W, roby_atom)
     Y.create(n_bf,n_bf)                    ! Y = overlap matrix for roby_atoms(:) basis
     .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
     X.create(n_occ,n_occ)
     Y.change_basis(X,W)                    ! X = S in the ANO basis
     Y.destroy
     Y.create(n_occ,n_occ)
     Y.to_inverse_of(X)                     ! Y = (ANO overlap matrix)^{-1}
     X.destroy
     Y.back_transform(P,W)                  ! P = Y in the roby_atom(:) AO basis
     Y.destroy
     W.destroy
  end

   make_roby_projection_matrix(P,spin_case,roby_atom)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom"
      MAT :: P
      IVEC :: roby_atom
      STR :: spin_case
      STR :: alpha
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      alpha="alpha"
      ENSURE(size(P,1)==n_bf,"P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,"P is incorrectly dimensioned")
      ENSURE((spin_case=="alpha") OR (spin_case=="beta"), "must specify spin of projector")
      n_occ = .atom(roby_atom).no_of_occupied_ANOs(spin_case,tol=real(0.05,kind=DBL_KIND))
      !need number of "spinkind" NOs
      n_roby_atom = size(roby_atom)
      if (n_occ == 0) then 
         n_occ = .atom(roby_atom).no_of_occupied_ANOs(alpha,tol=real(0.05,kind=DBL_KIND))
         !need number of "spinkind" NOs
         spin_case="alpha"
      end
       W.create(n_bf,n_occ)                 ! W = columns of ANO's
       .make_ANO_matrix(W, spin_case, roby_atom)
       Y.create(n_bf,n_bf)          ! Y = overlap matrix for roby_atoms(:) basis
       .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
       X.create(n_occ,n_occ)
       Y.change_basis(X,W)                  ! X = S in the ANO basis
       Y.destroy
       Y.create(n_occ,n_occ)
       Y.to_inverse_of(X)                   ! Y = (ANO overlap matrix)^{-1}
       X.destroy
       Y.back_transform(P,W)                ! P = Y in the roby_atom(:) AO basis
       Y.destroy
       W.destroy
   end

   make_roby_projection_matrix(P,roby_atom,ANO)
   ! Make the Roby projection matrix in the AO basis made from the concatenated 
   ! basis sets for each atom in "roby_atom" using the columns of "ANO" as 
   ! orbital coefficients to form the projection operator.
      MAT :: P
      IVEC :: roby_atom
      MAT :: ANO
      MAT, PTR :: W,X,Y
      INT :: n_roby_atom, n_occ,n_bf
      n_bf  = .atom(roby_atom).no_of_basis_functions
      ENSURE(size(P,1)==n_bf,  "P is incorrectly dimensioned")
      ENSURE(size(P,2)==n_bf,  "P is incorrectly dimensioned")
      ENSURE(size(ANO,1)==n_bf,"ANO is incorrectly dimensioned")
      n_occ = size(ANO,2)
      n_roby_atom = size(roby_atom)
      W.create(n_bf,n_occ)                  ! W = columns of ANO's
      W = ANO                                
      Y.create(n_bf,n_bf)           ! Y = overlap matrix for roby_atoms(:) basis
      .make_roby_overlap_matrix(Y,roby_atom,roby_atom) 
      X.create(n_occ,n_occ)
      Y.change_basis(X,W)                   ! X = S in the ANO basis
      Y.destroy
      Y.create(n_occ,n_occ)
      Y.to_inverse_of(X)                    ! Y = (ANO overlap matrix)^{-1}
      X.destroy
      Y.back_transform(P,W)                 ! P = Y in the roby_atom(:) AO basis
      Y.destroy
      W.destroy
   end

   make_roby_shared_operator(R,roby_atom1,roby_atom2,spin_case)
   ! constructs the roby_shared_operator R_AB = P_A + P_B - P_AB
   ! if spin_case is supplied then either the alpha or beta
   ! operator is constructed, depending on the value of spin_case
   MAT :: R
   IVEC :: roby_atom1,roby_atom2
   IVEC, PTR :: roby_atom
   STR,optional :: spin_case
   MAT, PTR :: P_A,P_B,P_AB
   INT :: n_a, n_b, n_ab
      n_a = .atom(roby_atom1).no_of_basis_functions
      n_b = .atom(roby_atom2).no_of_basis_functions
      n_ab = n_a + n_b
      roby_atom.create(size(roby_atom1) + size(roby_atom2))
      roby_atom(1:size(roby_atom1)) = roby_atom1
      roby_atom(size(roby_atom1)+1:) = roby_atom2
      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)
      P_AB.create(n_ab,n_ab)
    !  if ( .mult /= 1) then
    !    .make_roby_projection_matrix(P_A , spin_case,roby_atom1  )
    !     .make_roby_projection_matrix(P_B , spin_case,roby_atom2  )
    !     .make_roby_projection_matrix(P_AB, spin_case,roby_atom)
    !  else
         .make_roby_projection_matrix(P_A , roby_atom1)
         .make_roby_projection_matrix(P_B , roby_atom2)
         .make_roby_projection_matrix(P_AB, roby_atom )
    !  end
      R = ZERO
      R(    1:n_a ,     1:n_a ) =  P_A
      R(n_a+1:n_ab, n_a+1:n_ab) =  P_B
      R = R - P_AB
      P_AB.destroy
      P_B.destroy
      P_A.destroy
      roby_atom.destroy
   end

   make_roby_ionic_operator(I,roby_atom1,roby_atom2,spin_case)
   ! constructs the roby/gould ionic operator I_AB = P_A - P_B
   IVEC :: roby_atom1,roby_atom2
   MAT, PTR :: P_B,P_A
   STR, optional :: spin_case
   MAT :: I
   INT :: n_a, n_b, n_ab
      n_a = .atom(roby_atom1).no_of_basis_functions
      n_b = .atom(roby_atom2).no_of_basis_functions
      n_ab = n_a + n_b
      P_A.create(n_a,n_a)
      P_B.create(n_b,n_b)
   !  if ( .mult /= 1) then
   !      .make_roby_projection_matrix(P_A , spin_case,roby_atom1  )
   !      .make_roby_projection_matrix(P_B , spin_case,roby_atom2  )
   !   else
         .make_roby_projection_matrix(P_A , roby_atom1 )
         .make_roby_projection_matrix(P_B , roby_atom2  )
   !   end
      I = ZERO
      I(    1:n_a ,     1:n_a ) =  P_A
      I(n_a+1:n_ab, n_a+1:n_ab) = -P_B
      P_A.destroy; P_B.destroy
   end

!-----------------------------------------------!
! Make theta bonding and anti-bonding orbitals  !
!-----------------------------------------------!

   make_gould_theta_orbitals(X,roby_atom,theta,eigenvalues)
   ! For a given operator "X" (either cos theta or sin theta) in the
   ! concatenated AO basis of the atoms in "roby_atom", make the Gould "theta"
   ! bonding orbitals and corresponding "eigenvalues".
      MAT :: X,theta
      IVEC :: roby_atom
      VEC :: eigenvalues
      MAT, PTR :: XX,XV, SS,SI,SH
      INT :: n_ab
      n_ab = .atom(roby_atom).no_of_basis_functions
      XX.create(n_ab,n_ab); XV.create(n_ab,n_ab)
      SS.create(n_ab,n_ab); SI.create(n_ab,n_ab); SH.create(n_ab,n_ab)
      .make_roby_overlap_matrix(SS,roby_atom,roby_atom)
      SH.to_sqrt(SS)
      SI.to_inverse_of(SH)
      X.back_transform(XX,SH)
      XX.solve_eigenproblem(eigenvalues,XV)
      theta.to_product(SI,XV)
      SH.destroy; SI.destroy; SS.destroy
      XV.destroy; XX.destroy
   end

!---------------------------------------!
! Make roby projected densities and NOs !
!---------------------------------------!

   make_roby_projected_density(rho,roby_atom)
   ! Make the Roby-projected density matrix in the concatenated basis 
   ! of AO functions of the atoms in "roby_atoms" and copy it into
   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
   ! corresponding to basis functions in "roby_atoms" are made zero.
      MAT :: rho
      IVEC :: roby_atom
      MAT, PTR :: D,P,rho_W
      INT :: n_bf
      ENSURE(size(rho,1)==.n_bf,"rho has wrong shape")
      ENSURE(size(rho,2)==.n_bf,"rho has wrong shape")
      n_bf = .atom(roby_atom).no_of_basis_functions
      D.create(n_bf,n_bf)
      .roby_overlap_transform( .density_matrix.restricted,D,col_atom=roby_atom)
      P.create(n_bf,n_bf)
      .make_roby_projection_matrix(P,roby_atom)
      rho_W.create(n_bf,n_bf)
      .roby_project(D,rho_W,P) ! rho_W(small) = P_W(small) D(small) P_W(small)
      .AO_subspace_set(rho,rho_W,A_row_atom=roby_atom,A_col_atom=roby_atom)
      rho_W.destroy
      P.destroy
      D.destroy
   end

   make_roby_projected_density(rho,rho_old,roby_atom)
   ! Make the Roby-projected density matrix in the concatenated basis 
   ! of AO functions of the atoms in "roby_atoms" and copy it into
   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
   ! corresponding to basis functions in "roby_atoms" are made zero.
   ! rho_old specifies that the density_matrix to be used is supplied
      MAT :: rho, rho_old
      IVEC :: roby_atom
      MAT, PTR :: D,P,rho_W
      INT :: n_bf
      ENSURE(size(rho,1)==.n_bf,"rho has wrong shape")
      ENSURE(size(rho,2)==.n_bf,"rho has wrong shape")
      n_bf = .atom(roby_atom).no_of_basis_functions
      D.create(n_bf,n_bf)
      .roby_overlap_transform( rho_old,D,col_atom=roby_atom)
      P.create(n_bf,n_bf)
      .make_roby_projection_matrix(P,roby_atom)
      rho_W.create(n_bf,n_bf)
      .roby_project(D,rho_W,P) ! rho_W(small) = P_W(small) D(small) P_W(small)
      .AO_subspace_set(rho,rho_W,A_row_atom=roby_atom,A_col_atom=roby_atom)
      rho_W.destroy
      P.destroy
      D.destroy
   end

   make_roby_projected_density(rho,roby_atom,ANO) 
   ! Make the Roby-projected density matrix in the concatenated basis 
   ! of AO functions of the atoms in "roby_atoms" and copy it into
   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
   ! corresponding to basis functions in "roby_atoms" are made zero.
   ! The orbitals for roby projection are supplied in the ANO matrix
      MAT :: ANO, rho
      IVEC :: roby_atom
      MAT, PTR :: X, D, rho_W
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      D.create(n_bf,n_bf) 
      .roby_overlap_transform( .density_matrix.restricted,D,col_atom=roby_atom)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      rho_W.create(n_bf,n_bf)
      .roby_project(D,rho_W,X)
      .AO_subspace_set(rho,rho_W,A_row_atom=roby_atom, A_col_atom=roby_atom) 
      rho_W.destroy; D.destroy
      X.destroy
   end

   make_roby_projected_density(rho,rho_old,roby_atom,ANO) 
   ! Make the Roby-projected density matrix in the concatenated basis 
   ! of AO functions of the atoms in "roby_atoms" and copy it into
   ! a matrix .n_bf x .n_bf, where all other matrix elements not 
   ! corresponding to basis functions in "roby_atoms" are made zero.
   ! The orbitals for roby projection are supplied in the ANO matrix
      MAT :: ANO, rho, rho_old
      IVEC :: roby_atom
      MAT, PTR :: X, D, rho_W
      INT :: n_bf
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      D.create(n_bf,n_bf) 
      .roby_overlap_transform( rho_old,D,col_atom=roby_atom)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      rho_W.create(n_bf,n_bf)
      .roby_project(D,rho_W,X)
      .AO_subspace_set(rho,rho_W,A_row_atom=roby_atom, A_col_atom=roby_atom) 
      rho_W.destroy; D.destroy
      X.destroy
   end

   make_roby_projected_NOs(NOs,roby_atom) 
   ! Make the Roby-projected natural orbitals.
      MAT :: NOs
      IVEC :: roby_atom
      MAT, PTR :: X, D
      INT :: n_bf
      ENSURE(size(NOs,1)==.n_bf, "NOs matrix is wrong size")
      ENSURE(size(NOs,2)==.n_bf, "NOs matrix is wrong size")
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      .make_roby_projection_matrix(X,roby_atom)
      D.create( .n_bf, .n_bf)
      .AO_subspace_set(D,X,A_row_atom=roby_atom, A_col_atom=roby_atom)
      NOs = matmul(D,.natural_orbitals.restricted)
      D.destroy
      X.destroy
   end

   make_roby_projected_NOs(NOs,NO_old,roby_atom) 
   ! Make the Roby-projected natural orbitals.
   ! Projects onto the specific NO matrix given in NO_old
      MAT :: NOs, NO_old
      IVEC :: roby_atom
      MAT, PTR :: X, D
      INT :: n_bf
      ENSURE(size(NOs,1)==.n_bf, "NOs matrix is wrong size")
      ENSURE(size(NOs,2)==.n_bf, "NOs matrix is wrong size")
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      .make_roby_projection_matrix(X,roby_atom)
      D.create( .n_bf, .n_bf)
      .AO_subspace_set(D,X,A_row_atom=roby_atom, A_col_atom=roby_atom)
      NOs = matmul(D,NO_old)
      D.destroy
      X.destroy
   end

   make_roby_projected_NOs(NOs,roby_atom,ANO) 
   ! Make the Roby-projected natural orbitals.
   ! The orbitals for roby projection are supplied in the ANO matrix
      MAT :: NOs
      IVEC :: roby_atom
      MAT :: ANO
      MAT, PTR :: X, D
      INT :: n_bf
      ENSURE(size(NOs,1)==.n_bf, "NOs matrix is wrong size")
      ENSURE(size(NOs,2)==.n_bf, "NOs matrix is wrong size")
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      D.create( .n_bf, .n_bf)
      .AO_subspace_set(D,X,A_row_atom=roby_atom, A_col_atom=roby_atom)
      NOs = matmul(D,.natural_orbitals.restricted)
      D.destroy
      X.destroy
   end
   
   make_roby_projected_NOs(NOs,NO_old,roby_atom,ANO) 
   ! Make the Roby-projected natural orbitals.
   ! The orbitals for roby projection are supplied in the ANO matrix
   ! Projects onto the specific NO matrix given in NO_old
      MAT :: NOs,NO_old
      IVEC :: roby_atom
      MAT :: ANO
      MAT, PTR :: X, D
      INT :: n_bf
      ENSURE(size(NOs,1)==.n_bf, "NOs matrix is wrong size")
      ENSURE(size(NOs,2)==.n_bf, "NOs matrix is wrong size")
      n_bf = .atom(roby_atom).no_of_basis_functions
      X.create( n_bf,  n_bf)
      .make_roby_projection_matrix(X,roby_atom,ANO)
      D.create( .n_bf, .n_bf)
      .AO_subspace_set(D,X,A_row_atom=roby_atom, A_col_atom=roby_atom)
      NOs = matmul(D,NO_old)
      D.destroy
      X.destroy
   end

!--------------------------------------------!
! Low level routines used all over the place !
!--------------------------------------------!

   read_roby_atom(roby_atom) [leaky]
   ! Reads from the input file the roby_atom for consideration
      IVEC, PTR :: roby_atom
      INT :: k, n_roby_atom
      n_roby_atom = stdin.buffer.n_items - 1
      roby_atom.create(n_roby_atom)
      do k = 1,n_roby_atom
         roby_atom(k) = stdin.next_int
      end
   end

   read_roby_groups(roby_atom, roby_atom1, roby_atom2) [leaky]
   ! Reads from the input file the roby_atom for consideration
   ! and then separates into groups 1 and 2.
      IVEC, PTR :: roby_atom, roby_atom1, roby_atom2
      INT :: i, k, n_roby_atom
      .read_roby_atom(roby_atom)
      n_roby_atom = size(roby_atom)
      ENSURE(ANY(roby_atom==0),"Use ZERO (0) to separate atomic groups")
      do i = 1, n_roby_atom
       if (roby_atom(i) == 0) then
          k=i
          exit
       end
      end
      roby_atom1.create(k-1) 
      roby_atom2.create(n_roby_atom - k)
      roby_atom1 = roby_atom(1:k-1)
      roby_atom2 = roby_atom(k+1:n_roby_atom)
      roby_atom.destroy
      roby_atom.create(n_roby_atom-1) 
      roby_atom(1:size(roby_atom1)) = roby_atom1
      roby_atom(size(roby_atom1)+1:n_roby_atom - 1) = roby_atom2
   end


   make_roby_overlap_matrix(SS,row_atom,col_atom)
   ! Make an overlap section "SS" from the basis functions of the atoms
   ! specified in "row_atom" and "col_atom".
      MAT :: SS
      IVEC, optional :: row_atom,col_atom
      MAT, PTR :: S
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      .AO_subspace_set(SS,S,B_row_atom=row_atom,B_col_atom=col_atom)
      S.destroy
   end

   make_ANO_matrix(ANO,roby_atom)
   ! Make the ANO matrix "ANO" comprised of columns of the occupied atomic
   ! natural orbitals, for each atom whose index appears in "roby_atom".
      MAT :: ANO
      IVEC :: roby_atom
      INT :: n_roby_atom,a,ra,n_bf,n_occ,B,N
      n_roby_atom = size(roby_atom)
      ANO = ZERO
      b = 0; n = 0
      do a = 1,n_roby_atom
         ra = roby_atom(a)
         n_bf  = .atom(ra).no_of_basis_functions
         n_occ = .atom(ra).no_of_occupied_NOs(tol=real(0.05,kind=DBL_KIND))
         ANO(b+1:b+n_bf,n+1:n+n_occ) = .atom(ra).natural_orbitals.restricted(:,1:n_occ)
         b = b + n_bf
         n = n + n_occ
      end      
   end

   make_ANO_matrix(ANO,spin_case,roby_atom)
   ! Make the ANO matrix "ANO" comprised of columns of the occupied atomic
   ! natural orbitals, for each atom whose index appears in "roby_atom".
      MAT :: ANO
      IVEC :: roby_atom
      STR(*) :: spin_case
      INT :: n_roby_atom,a,ra,n_bf,n_occ,B,N
      n_roby_atom = size(roby_atom)
      ANO = ZERO
      b = 0; n = 0
      do a = 1,n_roby_atom
         ra = roby_atom(a)
         n_bf  = .atom(ra).no_of_basis_functions
         n_occ = .atom(ra).no_of_occupied_NOs(spin_case,tol=real(0.05,kind=DBL_KIND))
         select case(spin_case)
            case("alpha"); 
              ANO(b+1:b+n_bf,n+1:n+n_occ) = .atom(ra).natural_orbitals.alpha(:,1:n_occ)
            case("beta");
              ANO(b+1:b+n_bf,n+1:n+n_occ) = .atom(ra).natural_orbitals.beta(:,1:n_occ)
         end 
         b = b + n_bf
         n = n + n_occ
      end      
   end

   roby_project(X,Y,P)
   ! Do: Y = P X P
      MAT :: X,Y,P
      X.change_basis(Y,P)
   end

   roby_overlap_transform(X,Y,row_atom,col_atom)
   ! Do: Y = S(col_atom,row_atom) X S(row_atom,col_atom)
   ! where S(col_atom,row_atom) is the AO subspace section of the full
   ! overlap matrix specified by the basis functions on the atom indices
   ! in "row_atom" and "col_atom".
      MAT :: X,Y
      IVEC, optional :: row_atom, col_atom
      MAT, PTR :: S,SS
      INT :: n_row,n_col
      n_row = .n_bf
      if (present(row_atom)) then
      n_row = .atom(row_atom).no_of_basis_functions
      end
      n_col = .n_bf
      if (present(col_atom)) then
      n_col = .atom(col_atom).no_of_basis_functions
      end
      S.create(.n_bf,.n_bf)
      SS.create(n_row,n_col)
      .get_overlap_matrix(S)
      .AO_subspace_set(SS,S,B_row_atom=row_atom,B_col_atom=col_atom)
      X.change_basis(Y,SS) 
      SS.destroy
      S.destroy
   end

   AO_subspace_set(A,B,A_row_atom,A_col_atom,B_row_atom,B_col_atom)
   ! If either "B_row_atom" or "B_col_atom" is present, then:
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom 
   ! indices in "B_row_atom" and "B_col_atom". If either is missing,
   ! then copy the entire row. (i.e. A(small) = B(big))
   ! If either "A_row_atom" or "A_col_atom" is present, then:
   ! Set the AO subspace blocks of "A" specified by the atom 
   ! indices in "A_row_atom" and "A_col_atom" equal to "B". If either
   ! "A_row_atom" and "A_col_atom" is missing then copy the entire row.
   ! Uncopied blocks are set to zero. (i.e. A(big) = B(small))
      MAT :: A,B
      IVEC, optional :: A_row_atom,A_col_atom
      IVEC, optional :: B_row_atom,B_col_atom
      INT :: n_row_atoms,n_col_atoms, a1,a2, b1,b2 
      INT :: i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j
      if (present(B_row_atom) OR present(B_col_atom)) then
         ENSURE(size(B,1)==.n_bf,"B has wrong shape")
         ENSURE(size(B,2)==.n_bf,"B has wrong shape")
         if (present(B_row_atom) AND present(B_col_atom)) then
            n_row_atoms = size(B_row_atom)
            n_col_atoms = size(B_col_atom)
            a1 = .atom(B_row_atom).no_of_basis_functions
            a2 = .atom(B_col_atom).no_of_basis_functions
            ENSURE(size(A,1)==a1,   "A has wrong shape")
            ENSURE(size(A,2)==a2,   "A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(B_row_atom(i))
               l_i = .last_basis_fn_for_atom( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).no_of_basis_functions
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = .first_basis_fn_for_atom(B_col_atom(j))
                  l_j = .last_basis_fn_for_atom( B_col_atom(j))
                  n_j = .atom(B_col_atom(j)).no_of_basis_functions
                  A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
                  b_j = b_j + n_j
               end 
               b_i = b_i + n_i
            end
         else if (present(B_row_atom)) then
            n_row_atoms = size(B_row_atom)
            a1 = .atom(B_row_atom).no_of_basis_functions
            a2 = .n_bf
            ENSURE(size(A,1)==a1,"A has wrong shape")
            ENSURE(size(A,2)==a2,"A has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(B_row_atom(i));
               l_i = .last_basis_fn_for_atom( B_row_atom(i))
               n_i = .atom(B_row_atom(i)).no_of_basis_functions
               A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
               b_i = b_i + n_i
            end
         else if (present(B_col_atom)) then
            n_col_atoms = size(B_col_atom)
            a1 = .n_bf
            a2 = .atom(B_col_atom).no_of_basis_functions
            ENSURE(size(A,1)==a1,"A has wrong shape")
            ENSURE(size(A,2)==a2,"A has wrong shape")
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(B_col_atom(j));
               l_j = .last_basis_fn_for_atom( B_col_atom(j))
               n_j = .atom(B_col_atom(j)).no_of_basis_functions
               A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)
               b_j = b_j + n_j
            end
         end
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      else if (present(A_row_atom) OR present(A_col_atom)) then
         ENSURE(size(A,1)==.n_bf,"A has wrong shape")
         ENSURE(size(A,2)==.n_bf,"A has wrong shape")
         A = ZERO
         if (present(A_row_atom) AND present(A_col_atom)) then
            n_row_atoms = size(A_row_atom)
            n_col_atoms = size(A_col_atom)
            b1 = .atom(A_row_atom).no_of_basis_functions
            b2 = .atom(A_col_atom).no_of_basis_functions
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(A_row_atom(i))
               l_i = .last_basis_fn_for_atom( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).no_of_basis_functions
               b_j = 0
               do j = 1,n_col_atoms
                  f_j = .first_basis_fn_for_atom(A_col_atom(j))
                  l_j = .last_basis_fn_for_atom( A_col_atom(j))
                  n_j = .atom(A_col_atom(j)).no_of_basis_functions
                  A(f_i:l_i,f_j:l_j) = B(b_i+1:b_i+n_i,b_j+1:b_j+n_j) 
                  b_j = b_j + n_j
               end 
               b_i = b_i + n_i
            end
         else if (present(A_row_atom)) then
            n_row_atoms = size(A_row_atom)
            b1 = .atom(A_row_atom).no_of_basis_functions
            b2 = .n_bf
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_i = 0
            do i = 1,n_row_atoms
               f_i = .first_basis_fn_for_atom(A_row_atom(i));
               l_i = .last_basis_fn_for_atom( A_row_atom(i))
               n_i = .atom(A_row_atom(i)).no_of_basis_functions
               A(f_i:l_i,:) = B(b_i+1:b_i+n_i,:)
               b_i = b_i + n_i
            end
         else if (present(A_col_atom)) then
            n_col_atoms = size(A_col_atom)
            b1 = .atom(A_col_atom).no_of_basis_functions
            b2 = .n_bf
            ENSURE(size(B,1)==b1,"B has wrong shape")
            ENSURE(size(B,2)==b2,"B has wrong shape")
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(A_col_atom(j));
               l_j = .last_basis_fn_for_atom( A_col_atom(j))
               n_j = .atom(A_col_atom(j)).no_of_basis_functions
               A(:,f_j:l_j) = B(:,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end
         end
      else
         DIE("must specify A or B row atoms")
      end
   end

end 
