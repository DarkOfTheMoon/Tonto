!-------------------------------------------------------------------------------
!
! ARCHIVE: For archiving tonto objects to disk
!
! A polymorphic file object which can store ascii or binary format.
! Archives with the string "ascii" somewhere in their name are assumed to be
! ascii files, otherwise they are binary files.
!
! An archive can't be used for input and output at the same time.
!
! Read and write routines are used to deal with entire single objects.
! The archive is closed after the requested IO operation.
!
! If the above behaviour is not what is needed, the archive can be opened
! for multiple object I/O in one archive (say, a list of integral blocks)
! and you can deal by hand with appropriate component of the archive.
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module ARCHIVE

   implicit none

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the opmatrix object
      nullify(.file)
      nullify(.textfile)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of the opmatrix object
      .file.destroy
      .textfile.destroy
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   copy(archive) ::: leaky
   ! Make a copy
     archive :: ARCHIVE
     self = archive
     .nullify_ptr_part
     if (archive.file.created) .file.create_copy(archive.file)
   end

   set_defaults
   ! Set up a default archive object
      .root_name = "unknown"
      .name      = "unknown"
      .genre     = " " ! generic genre
      .format    = " " ! assume binary format
   end

   create(root_name,name,genre,format)
   ! Reset an archive to have main name "root_name", sub name "name"
   ! "genre" (if present) is used to identify components of OPMATRIX and
   ! OPVECTOR objects.
   ! "format" (if present) is used to identify file format (e.g. ascii). The
   ! default is binary.
   ! Otherwise use defaults.
      self :: PTR
      root_name,name :: STR
      genre,format :: STR, optional
      .create
      .root_name = root_name
      .name      = name
      if (present(genre))  .genre      = genre
      if (present(format)) .format    = format
   end

   set(root_name,name,genre,format)
   ! Reset an archive to have main name "root_name", sub name "name"
   ! "genre" (if present) is used to identify components of OPMATRIX and
   ! OPVECTOR objects.
   ! "format" (if present) is used to identify file format (e.g. ascii). The
   ! default is binary.
   ! Otherwise use defaults.
      root_name,name :: STR, optional
      genre,format :: STR, optional
      .set_defaults
      if (present(root_name)) .root_name = root_name
      if (present(name))      .name      = name
      if (present(genre))      .genre      = genre
      if (present(format))    .format    = format
   end

   set_root_name(root_name)
   ! Set an archive to have sub name "name".
      root_name :: STR
      .destroy_ptr_part
      .root_name = root_name
   end

   set_root(root_name)
   ! Set an archive to have sub name "name".
      root_name :: STR
      .destroy_ptr_part
      .root_name = root_name
   end

   set_name(name)
   ! Set an archive to have sub name "name".
      name :: STR
      .destroy_ptr_part
      .name = name
   end

   set_genre(genre)
   ! Set an archive to have genre "genre".
      genre :: STR
      .destroy_ptr_part
      .genre = genre
   end

   set_format(format)
   ! Set an archive to have format "format".
      format :: STR
      .destroy_ptr_part
      .format = format
   end

   file_name(genre) result (res)
   ! Return the archive file name from string ".root_name" by prepending the
   ! archive header ".name". If present "genre" is also appended. If present,
   ! ".format" is also appended.
      genre :: STR, optional
      res :: STR
      k :: STR
      res = " "
      if (.root_name /=" ") res = trim(res) // trim(.root_name)
      if (.name /=" ") res = trim(res) // "." // trim(.name)
      k = .genre
      if (present(genre)) k = genre
      if (k/=" ")       res = trim(res) // "," // trim(k)
      if (.format/=" ") res = trim(res) // "," // .format
   end

   is_a_text_file result (res) ::: private
   ! Return true if the file is a text file
      res :: BIN
      res = .format.includes("ascii")
   end

   exists(genre) result (res)
   ! Return TRUE if the archive exists in some form on disk.
      genre :: STR, optional
      res :: BIN
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         res = .textfile.exists
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         res = .file.exists
         .file.destroy
      end
   end

   open(for,buffered,type,genre,ascii) ::: leaky
   ! Open archive file
      for :: STR
      type :: STR, optional
      buffered :: BIN, optional
      genre :: STR, optional
      ascii :: BIN, optional
      text :: BIN
      text = FALSE
      if (present(ascii)) text = ascii
      if (text OR .is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         .textfile.open(for)
      else
         .file.create(trim(.file_name(genre)))
         .file.open(for,buffered,type)
      end
   end

   close ::: leaky
   ! Close *and* destroy the archive file part.
      if (.textfile.created) then
          .textfile.close
          .textfile.destroy
      end
      if (.file.created) then
          .file.close
          .file.destroy
      end
   end

   delete(genre)
   ! Delete archive file if it exists, *and* destroy the archive file part
      genre :: STR, optional
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         if (.textfile.exists) .textfile.delete
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         if (.file.exists) .file.delete
         .file.destroy
      end
   end

   delete_all_genres
   ! Delete all genres of archive file, if they exists.
      .delete
      .delete("restricted")
      .delete("unrestricted")
      .delete("alpha")
      .delete("beta")
      .delete("general")
      .delete("restricted_complex")
      .delete("unrestricted_complex")
      .delete("alpha_complex")
      .delete("beta_complex")
      .delete("general_complex")
      .delete("complex_restricted")
      .delete("complex_unrestricted")
      .delete("complex_alpha")
      .delete("complex_beta")
      .delete("complex_general")
   end

!  ************************************
!  Read routines: read an entire object
!  ************************************

   read(item,genre) ::: template
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE, OUT
      genre :: STR, IN, optional
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         ENSURE(.textfile.exists,"no text archive "// trim(.name))
         .textfile.open(for="read")
         .textfile.read(item)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         ENSURE(.file.exists,"no binary archive "// trim(.name))
         .file.open(for="read-only",buffered=TRUE,type="BUFFER_TYPE")
         .file.read(item)
         .file.close
         .file.destroy
      end
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>INT, BUFFER_TYPE=>INT)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>REAL, BUFFER_TYPE=>REAL)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{CPX}, BUFFER_TYPE=>CPX)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{CPX}, BUFFER_TYPE=>CPX)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{CPX}, BUFFER_TYPE=>CPX)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT5{CPX}, BUFFER_TYPE=>CPX)
   ! Read from the archive, a single "item".
   end

   read(item,genre,order) ::: template
   ! Read a matrix "item" from the archive. If present, "order" is the input
   ! order for the matrix.
      item :: ITEM_TYPE, OUT
      genre,order :: STR, IN, optional
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         ENSURE(.textfile.exists,"no text archive "// trim(.textfile.name))
         .textfile.open(for="read")
         .textfile.read(item,order)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         ENSURE(.file.exists,"no binary archive "// trim(.file.name))
         .file.open(for="read-only",buffered=TRUE,type="BUFFER_TYPE")
         .file.read(item)
         .file.close
         .file.destroy
      end
   end

   read(item,genre,order) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{REAL}, BUFFER_TYPE=>REAL)
   ! Read a matrix "item" from the archive. If present, "order" is the input
   ! order for the matrix.
   end

   read(item,genre,order) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{CPX}, BUFFER_TYPE=>CPX)
   ! Read a matrix "item" from the archive. If present, "order" is the input
   ! order for the matrix.
   end

   read(item1,item2) ::: template
   ! Read from the archive, "item1" followed by "item2"
      item1 :: ITEM1_TYPE, OUT
      item2 :: ITEM2_TYPE, OUT
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name))
         ENSURE(.textfile.exists,"no text archive "// trim(.file_name))
         .textfile.open(for="read")
         .textfile.read(item1)
         .textfile.read(item2)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name))
         if (NOT .file.exists) &
            DIE("no binary archive "// trim(.file_name))
         .file.open(for="read-only",buffered=TRUE,type="BUFFER_TYPE")
         .file.read(item1)
         .file.read(item2)
         .file.close
         .file.destroy
      end
   end

   read(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>VEC{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, "item1" followed by "item2"
   end

   read(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>MAT{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, "item1" followed by "item2"
   end

   read(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>VEC{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, "item1" followed by "item2"
   end

   read(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>MAT{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, "item1" followed by "item2"
   end

   read(item,genre) ::: leaky
   ! Read from the archive operator vector "item". If present, "genre" is the
   ! genre of "item" to be read in.
      item :: OPVECTOR
      genre :: STR, IN, optional
      itemgenre :: STR
      if (present(genre) ) then;  itemgenre = genre
      else if (.genre/=" ") then; itemgenre = .genre
      else;                      itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted")
            item.destroy("restricted")
            item.create("restricted")
            .read( item.restricted,genre="restricted")
         case ("unrestricted")
            item.destroy("unrestricted")
            item.create("unrestricted")
            .read( item.alpha,genre="alpha")
            .read( item.beta,genre="beta")
         case ("alpha")
            item.destroy("alpha")
            item.create("alpha")
            .read( item.alpha,genre="alpha")
         case ("beta")
            item.destroy("beta")
            item.create("beta")
            .read( item.beta,genre="beta")
         case ("general")
            item.destroy("general")
            item.create("general")
            .read( item.general,genre="general")
         case default
            DIE("unknown genre, "//trim(itemgenre))
      end
!      if (.is_a_text_file) .write(item,itemgenre)
   end

   read(item,genre,order) ::: leaky
   ! Read from the archive operator matrix "item". If present, "genre" is the
   ! genre of "item" to be read in. "order" indicated the input order for ascii
   ! files.
      item :: OPMATRIX
      genre,order :: STR, IN, optional
      itemgenre :: STR
      if (present(genre))   then; itemgenre = genre
      else if (.genre/=" ") then; itemgenre = .genre
      else;                       itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted")
            item.destroy("restricted")
            item.create("restricted")
            .read( item.restricted,"restricted",order)
         case ("unrestricted")
            item.destroy("unrestricted")
            item.create("unrestricted")
            .read( item.alpha,"alpha",order)
            .read( item.beta,"beta",order)
         case ("alpha")
            item.destroy("alpha")
            item.create("alpha")
            .read( item.alpha,"alpha",order)
         case ("beta")
            item.destroy("beta")
            item.create("beta")
            .read( item.beta,"beta",order)
         case ("general")
            item.destroy("general")
            item.create("general")
            .read( item.general,"general",order)
         case ("restricted_complex","complex_restricted")
            item.destroy("restricted_complex")
            item.create("restricted_complex")
            .read( item.restricted_complex,"restricted_complex",order)
         case ("unrestricted_complex","complex_unrestricted")
            item.destroy("unrestricted_complex")
            item.create("unrestricted_complex")
            .read( item.alpha_complex,"alpha_complex",order)
            .read( item.beta_complex,"beta_complex",order)
         case ("alpha_complex","complex_alpha")
            item.destroy("alpha_complex")
            item.create("alpha_complex")
            .read( item.alpha_complex,"alpha_complex",order)
         case ("beta_complex","complex_beta")
            item.destroy("beta_complex")
            item.create("beta_complex")
            .read( item.beta_complex,"beta_complex",order)
         case ("general_complex","complex_general")
            item.destroy("general_complex")
            item.create("general_complex")
            .read( item.general_complex,"general_complex",order)
         case default
            DIE("unknown genre, "//trim(itemgenre))
      end
!      if (.is_a_text_file) .write(item,genre,order)
   end

!  **************
!  Write routines
!  **************

   write(item,genre,ascii) ::: template
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE, IN
      genre :: STR, IN, optional
      ascii :: BIN, optional
      text :: BIN
      text = FALSE
      if (present(ascii)) text = ascii
      if (text OR .is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         .textfile.open(for="write")
         .textfile.set_use_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.put(item)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item)
         .file.close
         .file.destroy
      end
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>INT, TYPE=>"int")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>REAL, TYPE=>"real")
   ! Write to the archive, a single "item".
   end

   write(item,genre,format,ascii) ::: template
   ! Write to the archive, a single vector or matrix "item".
      item :: ITEM_TYPE, IN
      genre,format :: STR, IN, optional
      ascii :: BIN, optional
      fmt :: STR
      text :: BIN
      text = FALSE
      if (present(ascii)) text = ascii
      if (text OR .is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         .textfile.open(for="write")
         .textfile.set_use_labels(FALSE)
         .textfile.set_real_style("e")
         fmt = "row"; if (present(format)) fmt = format
         .textfile.put(item,fmt)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item)
         .file.close
         .file.destroy
      end
   end

   write(item,genre,format,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,format,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,format,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,format,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{REAL}, TYPE=>"real")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{REAL}, TYPE=>"real")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT5{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
   end

   write(item1,item2,ascii) ::: template
   ! Write to the archive, "item1" followed by "item2".
      item1 :: ITEM1_TYPE, IN
      item2 :: ITEM2_TYPE, IN
      ascii :: BIN, optional
      text :: BIN
      text = FALSE
      if (present(ascii)) text = ascii
      if (text OR .is_a_text_file) then
         .textfile.create(trim(.file_name))
         .textfile.set_use_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.open(for="write")
         .textfile.set_use_labels(FALSE)
         .textfile.put(item1)
         .textfile.put(item2)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item1)
         .file.write_buffered(item2)
         .file.close
         .file.destroy
      end
   end

   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
   end

   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
   end

   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
   end

   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
   end

   write(item,genre,order,ascii)
   ! Write to the archive operator vector "item". "order" indicated the output
   ! order for ascii files.
      item :: OPVECTOR, IN
      genre,order :: STR, IN, optional
      ascii :: BIN, optional
      itemgenre :: STR
      if (present(genre)) then; itemgenre = genre
      else;                     itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted  "); .write( item.restricted,"restricted",order,ascii)
         case ("unrestricted"); .write( item.alpha,"alpha",order,ascii)
                                .write( item.beta,"beta",order,ascii)
         case ("alpha       "); .write( item.alpha,"alpha",order,ascii)
         case ("beta        "); .write( item.beta,"beta",order,ascii)
         case ("general     "); .write( item.general,"general",order,ascii)
         case default;          UNKNOWN(itemgenre)
      end
   end

   write(item,genre,order,ascii)
   ! Write to the archive operator vector "item". "order" indicates the output
   ! order for ascii files.
      item :: OPMATRIX, IN
      genre,order :: STR, IN, optional
      ascii :: BIN, optional
      itemgenre :: STR
      if (present(genre)) then; itemgenre = genre
      else;                     itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted"); .write(item.restricted,"restricted",order,ascii)
         case ("unrestricted");         .write(item.alpha,"alpha",order,ascii)
                                        .write(item.beta,"beta",order,ascii)
         case ("alpha");                .write(item.alpha,"alpha",order,ascii)
         case ("beta");                 .write(item.beta,"beta",order,ascii)
         case ("general");              .write(item.general,"general",order,ascii)
         case ("restricted_complex");   .write(item.restricted_complex,"restricted_complex",order,ascii)
         case ("unrestricted_complex"); .write(item.alpha_complex,"alpha_complex",order,ascii)
                                        .write(item.beta_complex,"beta_complex",order,ascii)
         case ("alpha_complex");        .write(item.alpha_complex,"alpha_complex",order,ascii)
         case ("beta_complex");         .write(item.beta_complex,"beta_complex",order,ascii)
         case ("general_complex");      .write(item.general_complex,"general_complex",order,ascii)
         case default;                  DIE("unknown genre, "//trim(itemgenre))
      end
   end

   write_ppm(matrix,max_colours)
   ! Writes a ppm file.  Requires a 2D matrix of data
   ! values (width of image specified first then height)
   ! max_colours is the range
     matrix :: MAT{REAL}
     max_colours :: INT, IN, optional
     name :: STR
     cf :: COLOURFUNCTION*
     colours :: MAT3{INT}*
     n_div :: INT
     minv,maxv :: REAL

     n_div = 256
     if (present(max_colours)) n_div = max_colours

     name = .file_name.trim // ".ppm"
     .textfile.create(trim(name))
     .textfile.open(for="write")

     cf.create
     colours.create(3,matrix.dim1,matrix.dim2)

     minv = minval(matrix)
     maxv = maxval(matrix)
     cf.rescale_data((/minv,maxv/))
     minv = 0
     maxv = n_div
     cf.rescale_RGB((/minv,maxv/))
     cf.get_RGB_for(matrix,colours)
 
     .textfile.put_ppm(colours)

     colours.destroy
     cf.destroy

     .textfile.close
     .textfile.destroy
   end
   
!  **********************
!  Write gnuplot routines
!  **********************

   write_gnuplot(density,n_x,n_y,n_z)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in gnuplot format (suitable for an splot).
      density :: VEC{REAL}
      n_x,n_y,n_z :: INT
      n,x,y,z :: INT
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)
      n = 1
      do z = 1,n_z
         if (n_z>1) .textfile.show(" z = ",z)
         do y = 1,n_y
         do x = 1,n_x
            .textfile.put(density(n),flush=1)
            n = n+1
         end
         .textfile.flush
         end
      end
      .close
   end

   write_mathematica(density,n_x,n_y,n_z)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in Mathematica format
      density :: VEC{REAL}
      n_x,n_y,n_z :: INT
      n,x,y,z,l :: INT
      d :: REAL
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)
      .textfile.text("{")
      n = 1
      do z = 1,n_z
         do y = 1,n_y
            .textfile.text("{")
            do x = 1,n_x
               d = density(n)
               if (d==ZERO) then; l = 0
               else;              l = floor(log10(abs(d)))
               end
               d = d*TEN**(-l)
               if (x==n_x AND y==n_y AND z==n_z) then
                  .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//"}")
               else if (x==n_x) then
                  .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//"},")
               else
                  .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//",")
               end
               n = n+1
            end
            .textfile.flush
         end
      end
      .textfile.text("}")
      .close
   end

   write_mathematica(density,grid,atom,math_pos,bonds)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y" in Mathematica format. You must supplu the atom list and
   ! the mathematica positions "math_pos" in rotated grid coordinates.
      density :: VEC{REAL}, IN
      grid :: PLOT_GRID, IN   
      atom :: VEC{ATOM}, IN  
      math_pos :: MAT{REAL}, IN 
      bonds :: VEC{VEC_{INT}}, IN

   ENSURE(atom.dim==math_pos.dim1,"atom and math_pos incompatible")
   ENSURE(math_pos.dim2==3,"wrong dim2, math_pos")
   ENSURE(bonds.dim==atom.dim,"bonds and atom incompatible")

      has_bonds :: BIN
      n,x,y,z,l, a,b,c,nb :: INT  
      d,ax,ay,bx,by,minim,maxim :: REAL
      at_label,line,hue :: STR     
      ob,cb :: STR(len=1)
      ba :: VEC{REAL}(2)

      ! Fix the square brackets
      ob = achar(91)
      cb = achar(93)

      ! Open the file and set the output style
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)

      ! Dump the Mathematica contour data
      .textfile.text("<<Graphics`Legend`")   
      .textfile.text("ShowLegend"//ob)   
      .textfile.text("Show"//ob)   
      .textfile.text("ContourGraphics"//ob)   
      .textfile.text("{")
      n = 1
      do y = 1,grid.n_y
         .textfile.text("{")
         do x = 1,grid.n_x
            d = density(n)
            if (d==ZERO) then; l = 0
            else;              l = floor(log10(abs(d)))
            end
            d = d*TEN**(-l)
            if (x==grid.n_x AND y==grid.n_y) then
               .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//"}")
            else if (x==grid.n_x) then
               .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//"},")
            else
               .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//",")
            end
            n = n+1
         end
         .textfile.flush
      end
      .textfile.text("}")
      .textfile.text(cb//",") 
      maxim = maxval(density)
      minim = minval(density)

      ! Has any bonds?
      has_bonds = FALSE
      do a = 1,n
         if (bonds(a).element.dim==0) cycle
         has_bonds = TRUE
         exit
      end

      ! Print the atom labels in Epilog
      .textfile.text("Epilog->{")

      n = math_pos.dim1
      do a = 1,n

        at_label = "Text"//ob//'"'//trim(atom(a).label)//'",{'
        at_label = trim(at_label)//trim(math_pos(a,1).to_str("F7.1"))//","
        at_label = trim(at_label)//trim(math_pos(a,2).to_str("F7.1"))//"}"//cb

        if (a<n OR has_bonds) at_label = trim(at_label)//","

        .textfile.text(at_label)
      end

      ! Print the atom bond lines
      if (has_bonds) then

         ! Loop over atoms with bonds
         do a = 1,n
            if (bonds(a).element.dim==0) cycle

            ! Loop over the bonded atoms
            nb = bonds(a).element.dim
            do b = 1,nb

               ! Index of bonded atom
               c  = bonds(a)[b]
               if (c<=a) cycle
 
               ! Calculate line start and finish
               ba = math_pos(c,1:2) - math_pos(a,1:2)
               ax = math_pos(a,1) + 0.1d0*ba(1)
               ay = math_pos(a,2) + 0.1d0*ba(2)
               bx = ax + 0.8d0*ba(1)
               by = ay + 0.8d0*ba(2)

               ! Print out the line
               line = "Line"//ob//"{{"
               line = trim(line)//trim(ax.to_str("F7.1"))//","
               line = trim(line)//trim(ay.to_str("F7.1"))//"},{"
               line = trim(line)//trim(bx.to_str("F7.1"))//","
               line = trim(line)//trim(by.to_str("F7.1"))//"}}"//cb
          !    if((a < n OR b /= nb) AND n>0) line = trim(line)//","
          !    if(a == n AND b == nb) line = trim(line)
               if (b<=nb AND n>0) &
               line = trim(line)//"," ! comma only if there are atoms to follow
               .textfile.text(line)
            end
         end
      end
      ! End Epilog
      .textfile.text("},")

      ! Print the ContourGraphics options
      .textfile.text("Frame->False,")
      .textfile.text("Contours->10,")
      .textfile.text("ColorFunctionScaling->True,")
      hue ="(Hue"//ob//"0.7-0.7#"//cb//" &)"
      .textfile.text("ColorFunction->"//trim(hue)//cb//",")

      ! Print the ShowLegend options
      .textfile.text("{")
      .textfile.text(trim(hue))
      .textfile.text(",20,")
      .textfile.text('"'//trim(minim.to_str("F12.7"))//'",')    !default format
      .textfile.text('"'//trim(maxim.to_str("F12.7"))//'",')
      .textfile.text("LegendPosition->{1,0},")
      .textfile.text("LegendShadow->None")
      .textfile.text("}")
      .textfile.text(cb)

      .close
   end

   write_gnuplot(j,n_x,n_y,n_z,norm,normalise)
   ! Write a current density vector "j" corresponding to a grid with dimensions
   ! "n_x", "n_y", "n_z" in gnuplot format (suitable for an splot).
   ! If "norm" is present and TRUE write the norm of the vector field
   ! If "normalise" is present and TRUE write the normalised of the vector field
       j :: MAT{REAL}
      n_x,n_y,n_z :: INT
      norm,normalise :: BIN, optional
      n,x,y,z :: INT
      write_norm,write_normalised :: BIN
       v :: VEC{REAL}(3)
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)
      write_norm = FALSE; if (present(norm)) write_norm = norm
      write_normalised = FALSE; if (present(normalise)) write_normalised = normalise
      n = 1
      do z = 1,n_z
         if (n_z>1) then
            .textfile.put(" z = ")
            .textfile.put(z)
            .textfile.flush
         end
         do y = 1,n_y
         do x = 1,n_x
            v = j(n,:)
            if (write_norm) then
               .textfile.put( v.norm)
            else
               if (write_normalised) v.normalise
               .textfile.put(v(1))
               .textfile.put(v(2))
               .textfile.put(v(3))
            end
            .textfile.flush
            n = n+1
         end
         .textfile.flush
         end
      end
      .close
   end

   write_contour_a_la_nancy(density,grid,atom)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in the "contour" format for work in Nancy. This also requires
   ! the "atom" list and plot "grid" as well.
      density :: VEC{REAL}
      grid :: PLOT_GRID
      atom :: VEC{ATOM}
      n,f,l :: INT
      vec :: VEC{REAL}(3)
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(20)
      .textfile.set_real_precision(12)
      .textfile.text("Tonto output for the contour program used in Nancy ...")
      .textfile.put(atom.dim,real_width=TRUE)
      vec = grid.width
      vec.convert_to("angstrom")
      .textfile.put(vec(1))
      .textfile.put(vec(2))
      .textfile.put(vec(3))
      .textfile.flush
      do n = 1,atom.dim
         .textfile.put(atom(n).label)
         vec = atom(n).pos
         vec.convert_to("angstrom")
         .textfile.put(vec(1))
         .textfile.put(vec(2))
         .textfile.put(vec(3))
         .textfile.flush
      end
      .textfile.put(grid.n_x)
      .textfile.put(grid.n_y)
      .textfile.put(grid.n_z)
      .textfile.flush
      .textfile.set_use_labels(FALSE)
      f = 1
      l = grid.n_x
      do n = 1,grid.n_y*grid.n_z
         .textfile.put(density(f:l))
         f = f + grid.n_x
         l = l + grid.n_x
      end
      .close
   end

   write_a_la_xdgraph(density,grid,atom)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in the "xdgraph" format. This also requires the "atom" list
   ! and plot "grid" as well.
      density :: VEC{REAL}
      grid :: PLOT_GRID
      atom :: VEC{ATOM}
      n,f,l :: INT
      vec :: VEC{REAL}(3)
      atm :: VEC{INT}(3)
      axes :: MAT{REAL}(3,3)
      allowed :: BIN
      allowed = grid.x_atom_1/=0 AND grid.x_atom_2/=0
      allowed = grid.y_atom_1/=0 AND grid.y_atom_2/=0 AND allowed
      allowed = grid.y_atom_1==grid.x_atom_1 AND allowed
      WARN_IF(NOT allowed,"must use x and y axis atoms, and x and y atom 1 must be the same")
      if (NOT allowed) return
      .open(for="writing",ascii=TRUE)
      .textfile.set_margin(0)
      if (grid.n_z==1) then; .textfile.put("2DGRDFIL",width=8)
      else;                  .textfile.put("3DGRDFIL",width=8)
      end
      .textfile.put(0,width=3)
      .textfile.flush
      .textfile.put("TONTO",width=5)
      .textfile.put("FOU",width=7)
      .textfile.flush
      .textfile.flush
      .textfile.put("! Gridpoints, Origin, Physical Dimensions")
      .textfile.flush
      .textfile.put(grid.n_x,width=15)
      .textfile.put(grid.n_y,width=15)
      .textfile.put(grid.n_z,width=15)
      .textfile.flush
      .textfile.set_real_style("f")
      .textfile.set_real_width(11)
      .textfile.set_real_precision(4)
      vec = grid.width
      vec.convert_to("angstrom")
      .textfile.put(vec(1)*HALF)
      .textfile.put(vec(2)*HALF)
      .textfile.put(vec(3)*HALF)
      .textfile.flush
      .textfile.put(vec(1))
      .textfile.put(vec(2))
      .textfile.put(vec(3))
      .textfile.flush
      .textfile.put("! Objects",width=9)
      .textfile.flush
      .textfile.put(atom.dim,width=10)
      .textfile.flush
      .textfile.set_real_style("f")
      .textfile.set_real_width(10)
      .textfile.set_real_precision(5)
      axes(1,:) = grid.x_axis
      axes(2,:) = grid.y_axis
      axes(3,:) = grid.z_axis
      atm = [grid.x_atom_1,grid.x_atom_2,grid.y_atom_2]
      do n = 1,atom(atm).dim
         l = min(len_trim(atom(atm(n)).label),8)
         .textfile.put(atom(atm(n)).label,width=l)
         .textfile.tab(width=8-l)
         vec = atom(atm(n)).pos
         vec = vec - grid.centre
         vec = matmul(axes,vec)
         vec.convert_to("angstrom")
         .textfile.put(vec(1))
         .textfile.put(vec(2))
         .textfile.put(vec(3))
         .textfile.put("ATOM",width=5)
         .textfile.flush
      end
      do n = 1,atom.dim
         if (n==grid.x_atom_1) cycle
         if (n==grid.x_atom_2) cycle
         if (n==grid.y_atom_2) cycle
         l = min(len_trim(atom(n).label),8)
         .textfile.put(atom(n).label,width=l)
         .textfile.tab(width=8-l)
         vec = atom(n).pos
         vec = vec - grid.centre
         vec = matmul(axes,vec)
         vec.convert_to("angstrom")
         .textfile.put(vec(1))
         .textfile.put(vec(2))
         .textfile.put(vec(3))
         .textfile.put("ATOM",width=5)
         .textfile.flush
      end
      .textfile.put("! Connections",width=13)
      .textfile.flush
      .textfile.put(0,width=10)
      .textfile.flush
      .textfile.put("! Values",width=8)
      .textfile.flush
      .textfile.set_use_labels(FALSE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(13)
      .textfile.set_real_precision(5)
      .textfile.set_n_fields(6)
      f = 1
      l = grid.n_x
      do n = 1,grid.n_y*grid.n_z
         .textfile.put(density(f:l))
         f = f + grid.n_x
         l = l + grid.n_x
      end
      .close
   end

   write_gaussian_cube(density,grid,atom,title)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in the gaussian cube format. This also requires the "atom"
   ! list and plot "grid" as well.
      density :: VEC{REAL}
      grid :: PLOT_GRID
      atom :: VEC{ATOM}
      title :: STR
      n,n_atom,x,y,z :: INT
      an :: REAL
      axes :: MAT{REAL}(3,3)
      low,high,pos :: VEC{REAL}(3)
      reverse :: MAT3{REAL}*

      if (grid.n_z<=1) return

      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(13)
      .textfile.set_real_precision(5)

      .textfile.text("3DGRIDFILE  0")
      .textfile.text("TITLE  "//trim(title))

      ! Find out the number of atoms which are within the plot grid box.
      ! We have to change into the plot axis system.
      axes(1,:) = grid.x_axis
      axes(2,:) = grid.y_axis
      axes(3,:) = grid.z_axis
      low  = -HALF*grid.width ! bottom left front in plot axis system
      high =  HALF*grid.width ! top right back ....
      n_atom = 0
      do n = 1,atom.dim
         pos = atom(n).pos - grid.centre
         pos = matmul(axes,pos)
         if (NOT pos(:).is_in_range(low,high)) cycle
         n_atom = n_atom + 1
      end

      .textfile.put(n_atom)
      .textfile.put(low(1))
      .textfile.put(low(2))
      .textfile.put(low(3))
      .textfile.flush

      .textfile.put(grid.n_x)
      .textfile.put(grid.del_x)
      .textfile.put(ZERO)
      .textfile.put(ZERO)
      .textfile.flush

      .textfile.put(grid.n_y)
      .textfile.put(ZERO)
      .textfile.put(grid.del_y)
      .textfile.put(ZERO)
      .textfile.flush

      .textfile.put(grid.n_z)
      .textfile.put(ZERO)
      .textfile.put(ZERO)
      .textfile.put(grid.del_z)
      .textfile.flush

      do n = 1,atom.dim
         pos = atom(n).pos - grid.centre
         pos = matmul(axes,pos)
         if (NOT pos(:).is_in_range(low,high)) cycle
         .textfile.put(atom(n).atomic_number) ! Z
         an = atom(n).atomic_number
         .textfile.put(an,precision=1)        ! Charge
         .textfile.put(pos(1))                ! Pos in plot grid axis system
         .textfile.put(pos(2))
         .textfile.put(pos(3))
         .textfile.flush
      end

      reverse.create(grid.n_x,grid.n_y,grid.n_z)
      reverse = reshape(density,[grid.n_x,grid.n_y,grid.n_z])

      do x = 1,grid.n_x
      do y = 1,grid.n_y
      do z = 1,grid.n_z
         .textfile.put(reverse(x,y,z))
         if (mod(z,6)==0 OR z==grid.n_z) .textfile.flush
      end
      end
      end

      reverse.destroy

      .close

   end

end
