!-------------------------------------------------------------------------------
!
! ARCHIVE: For archiving tonto objects to disk
!
! A polymorphic file object which can store ascii or binary format.
! Archives with the string "ascii" somewhere in their name are assumed to be
! ascii files, otherwise they are binary files.
!
! An archive can't be used for input and output at the same time.
!
! Read and write routines are used to deal with entire single objects.
! The archive is closed after the requested IO operation.
!
! If the above behaviour is not what is needed, the archive can be opened
! for multiple object I/O in one archive (say, a list of integral blocks)
! and you can deal by hand with appropriate component of the archive.
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module ARCHIVE

   implicit none

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object
      self :: PTR
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the opmatrix object
      nullify(.file)
      nullify(.textfile)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of the opmatrix object
      .file.destroy
      .textfile.destroy
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   copy(archive) ::: leaky
   ! Make a copy
      archive :: ARCHIVE
      self = archive
      .nullify_ptr_part
      if (archive.file.created) .file.create_copy(archive.file)
   end

   set_defaults
   ! Set up a default archive object
      .root_name = "unknown"
      .name      = "unknown"
      .genre     = " " ! generic genre
      .format    = " " ! assume binary format
   end

   create(root_name,name,genre,format)
   ! Reset an archive to have main name "root_name", sub name "name"
   ! "genre" (if present) is used to identify components of OPMATRIX and
   ! OPVECTOR objects.
   ! "format" (if present) is used to identify file format (e.g. ascii). The
   ! default is binary.
   ! Otherwise use defaults.
      self :: PTR
      root_name,name :: STR
      genre,format :: STR, optional
      .create
      .root_name = root_name
      .name      = name
      if (present(genre))  .genre      = genre
      if (present(format)) .format    = format
   end

   set(root_name,name,genre,format)
   ! Reset an archive to have main name "root_name", sub name "name"
   ! "genre" (if present) is used to identify components of OPMATRIX and
   ! OPVECTOR objects.
   ! "format" (if present) is used to identify file format (e.g. ascii). The
   ! default is binary.
   ! Otherwise use defaults.
      root_name :: STR, optional
      name      :: STR, optional
      genre     :: STR, optional
      format    :: STR, optional

      .set_defaults

      if (present(root_name)) .root_name = root_name
      if (present(name))      .name      = name
      if (present(genre))     .genre     = genre
      if (present(format))    .format    = format

   end

   set_root_name(root_name)
   ! Set an archive to have sub name "name".
      root_name :: STR
      .destroy_ptr_part
      .root_name = root_name
   end

   set_root(root_name)
   ! Set an archive to have sub name "name".
      root_name :: STR
      .destroy_ptr_part
      .root_name = root_name
   end

   set_name(name)
   ! Set an archive to have sub name "name".
      name :: STR
      .destroy_ptr_part
      .name = name
   end

   set_genre(genre)
   ! Set an archive to have genre "genre".
      genre :: STR
      .destroy_ptr_part
      .genre = genre
   end

   set_format(format)
   ! Set an archive to have format "format".
      format :: STR
      .destroy_ptr_part
      .format = format
   end

   file_name(genre) result (res)
   ! Return the archive file name from string ".root_name" by prepending the
   ! archive header ".name". If present "genre" is also appended. If present,
   ! ".format" is also appended.
      genre :: STR, optional
      res :: STR

   ENSURE(.root_name/=" ","must have an archive root_name!")

      k :: STR

      res = trim(.root_name)

      ! Add the file name
      if (.name /=" ") &
         res = trim(res) // "." // trim(.name)

      ! Add the genrw
      k = .genre
      if (present(genre)) k = genre
      if (k/=" ")  &
         res = trim(res) // "," // trim(k)

      ! Add the format
      if (.format/=" ") &
         res = trim(res) // "," // .format

   end

   is_a_text_file result (res) ::: private
   ! Return true if the file is a text file
      res :: BIN
      res = .format.includes("ascii")
   end

   exists(genre) result (res)
   ! Return TRUE if the archive exists in some form on disk.
      genre :: STR, optional
      res :: BIN

      file_name :: STR

      file_name = .file_name(genre)

      if (.is_a_text_file) then
         .textfile.create(trim(file_name))
         res = .textfile.exists
         .textfile.destroy
      else
         .file.create(trim(file_name))
         res = .file.exists
         .file.destroy
      end

   end

   open(for,buffered,type,genre,ascii) ::: leaky
   ! Open archive file
      for :: STR
      type :: STR, optional
      buffered :: BIN, optional
      genre :: STR, optional
      ascii :: BIN, optional

      file_name :: STR
      text :: BIN

      text = FALSE
      if (present(ascii)) text = ascii

      file_name = .file_name(genre)

      if (text OR .is_a_text_file) then
         .textfile.create(trim(file_name))
         .textfile.open(for)
      else
         .file.create(trim(file_name))
         .file.open(for,buffered,type)
      end

   end

   close ::: leaky
   ! Close *and* destroy the archive file part.
      if (.textfile.created) then
          .textfile.close
          .textfile.destroy
      end
      if (.file.created) then
          .file.close
          .file.destroy
      end
   end

   delete(genre)
   ! Delete archive file if it exists, *and* destroy the archive file part
      genre :: STR, optional

      file_name :: STR

      file_name = .file_name(genre)

      if (.is_a_text_file) then
         .textfile.create(trim(file_name))
         if (.textfile.exists) .textfile.delete
         .textfile.destroy
      else
         .file.create(trim(file_name))
         if (.file.exists) .file.delete
         .file.destroy
      end

   end

   delete_all_genres
   ! Delete all genres of archive file, if they exists.
      .delete
      .delete("restricted")
      .delete("unrestricted")
      .delete("alpha")
      .delete("beta")
      .delete("general")
      .delete("restricted_complex")
      .delete("unrestricted_complex")
      .delete("alpha_complex")
      .delete("beta_complex")
      .delete("general_complex")
      .delete("complex_restricted")
      .delete("complex_unrestricted")
      .delete("complex_alpha")
      .delete("complex_beta")
      .delete("complex_general")
   end

!  ====================================
!  Read routines: read an entire object
!  ====================================

   read(item,genre) ::: template
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE, OUT
      genre :: STR, IN, optional

      file_name :: STR

      file_name = .file_name(genre)

      if (.is_a_text_file) then
         .textfile.create(trim(file_name))
         ENSURE(.textfile.exists,"no text archive "// trim(.name))
         .textfile.open(for="read")
         .textfile.read(item)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(file_name))
         ENSURE(.file.exists,"no binary archive "// trim(.name))
         .file.open(for="read-only",buffered=TRUE,type="BUFFER_TYPE")
         .file.read(item)
         .file.close
         .file.destroy
      end

   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>INT, BUFFER_TYPE=>INT)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>REAL, BUFFER_TYPE=>REAL)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{INT}, BUFFER_TYPE=>INT)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{CPX}, BUFFER_TYPE=>CPX)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{CPX}, BUFFER_TYPE=>CPX)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{REAL}, BUFFER_TYPE=>REAL)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{CPX}, BUFFER_TYPE=>CPX)
   ! Read from the archive, a single "item".
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT5{CPX}, BUFFER_TYPE=>CPX)
   ! Read from the archive, a single "item".
   end

   read(item,genre,by_column) ::: template
   ! Read a matrix "item" from the archive. If present, "by_column" is
   ! the input order for the matrix.
      item :: ITEM_TYPE, OUT
      genre :: STR, IN, optional
      by_column :: BIN, IN, optional

      file_name :: STR

      file_name = .file_name(genre)

      if (.is_a_text_file) then
         .textfile.create(trim(file_name))
         ENSURE(.textfile.exists,"no text archive "// trim(.textfile.name))
         .textfile.open(for="read")
         .textfile.read(item,by_column)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(file_name))
         ENSURE(.file.exists,"no binary archive "// trim(.file.name))
         .file.open(for="read-only",buffered=TRUE,type="BUFFER_TYPE")
         .file.read(item)
         .file.close
         .file.destroy
      end

   end

   read(item,genre,by_column) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{REAL}, BUFFER_TYPE=>REAL)
   ! Read a matrix "item" from the archive. If present, "by_column" is
   ! the input order for the matrix.
   end

   read(item,genre,by_column) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{CPX}, BUFFER_TYPE=>CPX)
   ! Read a matrix "item" from the archive. If present, "by_column" is
   ! the input order for the matrix.
   end

   read(item,genre) ::: template
   ! Read a binary archive.
     item :: ITEM_TYPE
     genre :: STR, optional
   DIE_IF(.is_a_text_file,"text files not implemented")

      file_name :: STR

      file_name = .file_name(genre)
     .file.create(trim(file_name))
     ENSURE(.file.exists,"no binary archive "// trim(file_name))
     .file.open(for="read-only",buffered=TRUE,type="real")
     .file.read(item)
     .file.close
     .file.destroy

   end

   read(item,genre)  ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{MAT_{REAL}})
   ! Read a binary archive.
   end

   read(item,genre) ::: leaky
   ! Read from the archive operator vector "item". If present, "genre" is the
   ! genre of "item" to be read in.
      item :: OPVECTOR
      genre :: STR, IN, optional
      itemgenre :: STR
      if (present(genre) ) then;  itemgenre = genre
      else if (.genre/=" ") then; itemgenre = .genre
      else;                      itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted")
            item.destroy("restricted")
            item.create("restricted")
            .read( item.restricted,genre="restricted")
         case ("unrestricted")
            item.destroy("unrestricted")
            item.create("unrestricted")
            .read( item.alpha,genre="alpha")
            .read( item.beta,genre="beta")
         case ("alpha")
            item.destroy("alpha")
            item.create("alpha")
            .read( item.alpha,genre="alpha")
         case ("beta")
            item.destroy("beta")
            item.create("beta")
            .read( item.beta,genre="beta")
         case ("general")
            item.destroy("general")
            item.create("general")
            .read( item.general,genre="general")
         case default
            DIE("unknown genre, "//trim(itemgenre))
      end
!      if (.is_a_text_file) .write(item,itemgenre)
   end

   read(item,genre,by_column) ::: leaky
   ! Read from the archive operator matrix "item". If present, "genre" is the
   ! genre of "item" to be read in. "order" indicated the input order for ascii
   ! files.
      item :: OPMATRIX
      genre :: STR, IN, optional
      by_column :: BIN, IN, optional

      itemgenre :: STR

      if (present(genre))   then; itemgenre = genre
      else if (.genre/=" ") then; itemgenre = .genre
      else;                       itemgenre = item.spinorbital_kind
      end

      select case (itemgenre)
         case ("restricted")
            item.destroy("restricted")
            item.create("restricted")
            .read( item.restricted,"restricted",by_column)
         case ("unrestricted")
            item.destroy("unrestricted")
            item.create("unrestricted")
            .read( item.alpha,"alpha",by_column)
            .read( item.beta,"beta",by_column)
         case ("alpha")
            item.destroy("alpha")
            item.create("alpha")
            .read( item.alpha,"alpha",by_column)
         case ("beta")
            item.destroy("beta")
            item.create("beta")
            .read( item.beta,"beta",by_column)
         case ("general")
            item.destroy("general")
            item.create("general")
            .read( item.general,"general",by_column)
         case ("restricted_complex","complex_restricted")
            item.destroy("restricted_complex")
            item.create("restricted_complex")
            .read( item.restricted_complex,"restricted_complex",by_column)
         case ("unrestricted_complex","complex_unrestricted")
            item.destroy("unrestricted_complex")
            item.create("unrestricted_complex")
            .read( item.alpha_complex,"alpha_complex",by_column)
            .read( item.beta_complex,"beta_complex",by_column)
         case ("alpha_complex","complex_alpha")
            item.destroy("alpha_complex")
            item.create("alpha_complex")
            .read( item.alpha_complex,"alpha_complex",by_column)
         case ("beta_complex","complex_beta")
            item.destroy("beta_complex")
            item.create("beta_complex")
            .read( item.beta_complex,"beta_complex",by_column)
         case ("general_complex","complex_general")
            item.destroy("general_complex")
            item.create("general_complex")
            .read( item.general_complex,"general_complex",by_column)
         case default
            DIE("unknown genre, "//trim(itemgenre))
      end

   end

!  ==============
!  Write routines
!  ==============

   write(item,genre,ascii) ::: template
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE, IN
      genre :: STR, IN, optional
      ascii :: BIN, optional

      file_name :: STR
      text :: BIN

      text = FALSE
      if (present(ascii)) text = ascii

      file_name = .file_name(genre)

      if (text OR .is_a_text_file) then
         .textfile.create(trim(file_name))
         .textfile.open(for="write")
         .textfile.set_using_array_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.put(item)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(file_name))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item)
         .file.close
         .file.destroy
      end

   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>INT, TYPE=>"int")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>REAL, TYPE=>"real")
   ! Write to the archive, a single "item".
   end

   write(item,genre,by_row,by_column,ascii) ::: template
   ! Write to the archive, a single vector or matrix "item".
      item :: ITEM_TYPE, IN
      genre :: STR, IN, optional
      by_row :: BIN, optional
      by_column :: BIN, optional
      ascii :: BIN, optional

      file_name :: STR
      text :: BIN

      text = FALSE
      if (present(ascii)) text = ascii

      file_name = .file_name(genre)

      if (text OR .is_a_text_file) then
         .textfile.create(trim(file_name))
         .textfile.open(for="write")
         .textfile.set_using_array_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.put(item,by_row,by_column)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(file_name))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item)
         .file.close
         .file.destroy
      end

   end

   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{INT}, TYPE=>"int")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,by_row,by_column,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single vector or matrix "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{REAL}, TYPE=>"real")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{REAL}, TYPE=>"real")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
   end

   write(item,genre,ascii) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT5{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
   end

   write(item1,item2,ascii) ::: template
   ! Write to the archive, "item1" followed by "item2".
      item1 :: ITEM1_TYPE, IN
      item2 :: ITEM2_TYPE, IN
      ascii :: BIN, optional

      file_name :: STR
      text :: BIN

      text = FALSE
      if (present(ascii)) text = ascii

      file_name = .file_name

      if (text OR .is_a_text_file) then
         .textfile.create(trim(file_name))
         .textfile.set_using_array_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.open(for="write")
         .textfile.set_using_array_labels(FALSE)
         .textfile.put(item1)
         .textfile.put(item2)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(file_name))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item1)
         .file.write_buffered(item2)
         .file.close
         .file.destroy
      end

   end

   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
   end

   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
   end

   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
   end

   write(item1,item2,ascii) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
   end

   write(item) ::: template
   ! Write to a binary archive
      item :: ITEM_TYPE
   DIE_IF(.is_a_text_file,"text files not implemented")

      file_name :: STR

      file_name = .file_name
      .file.create(trim(file_name))
      .file.open(for="write-only",buffered=TRUE,type="real")
      .file.write_buffered(item)
      .file.close
      .file.destroy

   end

   write(item) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{MAT_{REAL}})
   ! Write to a binary archive
   end

   write(item,genre,by_column,ascii)
   ! Write to the archive operator vector "item". "by_column"
   ! indicated the output order for ascii files.
      item :: OPVECTOR, IN
      genre :: STR, IN, optional
      by_column :: BIN, IN, optional
      ascii :: BIN, optional
      itemgenre :: STR

      if (present(genre)) then; itemgenre = genre
      else;                     itemgenre = item.spinorbital_kind
      end

      select case (itemgenre)
         case ("restricted  "); .write(item.restricted,"restricted",by_column,ascii)
         case ("unrestricted"); .write(item.alpha,"alpha",by_column,ascii)
                                .write(item.beta,"beta",by_column,ascii)
         case ("alpha       "); .write(item.alpha,"alpha",by_column,ascii)
         case ("beta        "); .write(item.beta,"beta",by_column,ascii)
         case ("general     "); .write(item.general,"general",by_column,ascii)
         case default;          UNKNOWN(itemgenre)
      end

   end

   write(item,genre,by_column,ascii)
   ! Write to the archive operator vector "item". "by_column"
   ! indicates the output order for ascii files.
      item :: OPMATRIX, IN
      genre :: STR, IN, optional
      by_column :: BIN, IN, optional
      ascii :: BIN, optional
      itemgenre :: STR

      if (present(genre)) then; itemgenre = genre
      else;                     itemgenre = item.spinorbital_kind
      end

      select case (itemgenre)
         case ("restricted");           .write(item.restricted,"restricted",by_column,ascii)
         case ("unrestricted");         .write(item.alpha,"alpha",by_column,ascii)
                                        .write(item.beta,"beta",by_column,ascii)
         case ("alpha");                .write(item.alpha,"alpha",by_column,ascii)
         case ("beta");                 .write(item.beta,"beta",by_column,ascii)
         case ("general");              .write(item.general,"general",by_column,ascii)
         case ("restricted_complex");   .write(item.restricted_complex,"restricted_complex",by_column,ascii)
         case ("unrestricted_complex"); .write(item.alpha_complex,"alpha_complex",by_column,ascii)
                                        .write(item.beta_complex,"beta_complex",by_column,ascii)
         case ("alpha_complex");        .write(item.alpha_complex,"alpha_complex",by_column,ascii)
         case ("beta_complex");         .write(item.beta_complex,"beta_complex",by_column,ascii)
         case ("general_complex");      .write(item.general_complex,"general_complex",by_column,ascii)
         case default;                  DIE("unknown genre, "//trim(itemgenre))
      end

   end

   write_ppm(matrix,max_colours)
   ! Writes a ppm file.  Requires a 2D matrix of data
   ! values (width of image specified first then height)
   ! max_colours is the range
      matrix :: MAT{REAL}
      max_colours :: INT, IN, optional
      name :: STR
      cf :: COLOUR_FUNCTION*
      colours :: MAT3{INT}*
      n_div :: INT
      minv,maxv :: REAL

      n_div = 256
      if (present(max_colours)) n_div = max_colours

      name = .file_name.trim // ".ppm"
      .textfile.create(trim(name))
      .textfile.open(for="write")

      cf.create
      colours.create(3,matrix.dim1,matrix.dim2)

      minv = minval(matrix)
      maxv = maxval(matrix)
      cf.rescale_data((/minv,maxv/))
      minv = 0
      maxv = n_div
      cf.rescale_RGB((/minv,maxv/))
      cf.get_RGB_for(matrix,colours)
 
      .textfile.put_ppm(colours)

      colours.destroy
      cf.destroy

      .textfile.close
      .textfile.destroy
   end
   
!  ======================
!  Write gnuplot routines
!  ======================

   write_orbital(gcu,gcd,n_pt)
   ! Write the up and down component of an orbital with the number of
   ! "n_pt" grid points,
      gcu,gcd :: VEC{CPX}
      n_pt :: INT
      n :: INT
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)
      do n = 1,n_pt
            .textfile.put(gcu(n))
            .textfile.put(gcd(n))
            .textfile.flush
      end
      .close
   end

   write_gnuplot(density,n_x,n_y,n_z)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in gnuplot format (suitable for an splot).
      density :: VEC{REAL}
      n_x,n_y,n_z :: INT
      n,x,y,z :: INT
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(16)
      .textfile.set_real_precision(8)
      n = 1
      do z = 1,n_z
         if (n_z>1) .textfile.show(" z =",z)
         do y = 1,n_y
         do x = 1,n_x
            .textfile.put(density(n))
            .textfile.flush
            n = n+1
         end
         .textfile.flush
         end
      end
      .close
   end

   write_mathematica(density,n_x,n_y,n_z)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in Mathematica format
      density :: VEC{REAL}
      n_x,n_y,n_z :: INT
      n,x,y,z,l :: INT
      d :: REAL
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)
      .textfile.text("{")
      n = 1
      do z = 1,n_z
         do y = 1,n_y
            .textfile.text("{")
            do x = 1,n_x
               d = density(n)
               if (d==ZERO) then; l = 0
               else;              l = floor(log10(abs(d)))
               end
               d = d*TEN**(-l)
               if (x==n_x AND y==n_y AND z==n_z) then
                  .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//"}")
               else if (x==n_x) then
                  .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//"},")
               else
                  .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//",")
               end
               n = n+1
            end
            .textfile.flush
         end
      end
      .textfile.text("}")
      .close
   end

   write_mathematica(density,grid,atom,math_pos,bonds)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y" in Mathematica format. You must supplu the atom list and
   ! the mathematica positions "math_pos" in rotated grid coordinates.
      density :: VEC{REAL}, IN
      grid :: PLOT_GRID, IN   
      atom :: VEC{ATOM}, IN  
      math_pos :: MAT{REAL}, IN 
      bonds :: VEC{VEC_{INT}}, IN

   ENSURE(atom.dim==math_pos.dim1,"atom and math_pos incompatible")
   ENSURE(math_pos.dim2==3,"wrong dim2, math_pos")
   ENSURE(bonds.dim==atom.dim,"bonds and atom incompatible")

      has_bonds :: BIN
      n,x,y,l, a,b,c,nb :: INT  
      d,ax,ay,bx,by,minim,maxim :: REAL
      at_label,line,hue :: STR     
      ob,cb :: STR(len=1)
      ba :: VEC{REAL}(2)

      ! Fix the square brackets
      ob = achar(91)
      cb = achar(93)

      ! Open the file and set the output style
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)

      ! Dump the Mathematica contour data
      .textfile.text("<<Graphics`Legend`")   
      .textfile.text("ShowLegend"//ob)   
      .textfile.text("Show"//ob)   
      .textfile.text("ContourGraphics"//ob)   
      .textfile.text("{")
      n = 1
      do y = 1,grid.n_y
         .textfile.text("{")
         do x = 1,grid.n_x
            d = density(n)
            if (d==ZERO) then; l = 0
            else;              l = floor(log10(abs(d)))
            end
            d = d*TEN**(-l)
            if (x==grid.n_x AND y==grid.n_y) then
               .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//"}")
            else if (x==grid.n_x) then
               .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//"},")
            else
               .textfile.text(d.to_str.trim//" * 10^"//l.to_str.trim//",")
            end
            n = n+1
         end
         .textfile.flush
      end
      .textfile.text("}")
      .textfile.text(cb//",") 
      maxim = maxval(density)
      minim = minval(density)

      ! Has any bonds?
      has_bonds = FALSE
      do a = 1,n
         if (bonds(a).element.dim==0) cycle
         has_bonds = TRUE
         exit
      end

      ! Print the atom labels in Epilog
      .textfile.text("Epilog->{")

      n = math_pos.dim1
      do a = 1,n

        at_label = "Text"//ob//'"'//trim(atom(a).label)//'",{'
        at_label = trim(at_label)//trim(math_pos(a,1).to_str("F7.1"))//","
        at_label = trim(at_label)//trim(math_pos(a,2).to_str("F7.1"))//"}"//cb

        if (a<n OR has_bonds) at_label = trim(at_label)//","

        .textfile.text(at_label)
      end

      ! Print the atom bond lines
      if (has_bonds) then

         ! Loop over atoms with bonds
         do a = 1,n
            if (bonds(a).element.dim==0) cycle

            ! Loop over the bonded atoms
            nb = bonds(a).element.dim
            do b = 1,nb

               ! Index of bonded atom
               c  = bonds(a)[b]
               if (c<=a) cycle
 
               ! Calculate line start and finish
               ba = math_pos(c,1:2) - math_pos(a,1:2)
               ax = math_pos(a,1) + 0.1d0*ba(1)
               ay = math_pos(a,2) + 0.1d0*ba(2)
               bx = ax + 0.8d0*ba(1)
               by = ay + 0.8d0*ba(2)

               ! Print out the line
               line = "Line"//ob//"{{"
               line = trim(line)//trim(ax.to_str("F7.1"))//","
               line = trim(line)//trim(ay.to_str("F7.1"))//"},{"
               line = trim(line)//trim(bx.to_str("F7.1"))//","
               line = trim(line)//trim(by.to_str("F7.1"))//"}}"//cb
          !    if((a < n OR b /= nb) AND n>0) line = trim(line)//","
          !    if(a == n AND b == nb) line = trim(line)
               if (b<=nb AND n>0) &
               line = trim(line)//"," ! comma only if there are atoms to follow
               .textfile.text(line)
            end
         end
      end
      ! End Epilog
      .textfile.text("},")

      ! Print the ContourGraphics options
      .textfile.text("Frame->False,")
      .textfile.text("Contours->10,")
      .textfile.text("ColorFunctionScaling->True,")
      hue ="(Hue"//ob//"0.7-0.7#"//cb//" &)"
      .textfile.text("ColorFunction->"//trim(hue)//cb//",")

      ! Print the ShowLegend options
      .textfile.text("{")
      .textfile.text(trim(hue))
      .textfile.text(",20,")
      .textfile.text('"'//trim(minim.to_str("F12.7"))//'",')    !default format
      .textfile.text('"'//trim(maxim.to_str("F12.7"))//'",')
      .textfile.text("LegendPosition->{1,0},")
      .textfile.text("LegendShadow->None")
      .textfile.text("}")
      .textfile.text(cb)

      .close
   end

   write_gnuplot(j,n_x,n_y,n_z,norm,normalise)
   ! Write a current density vector "j" corresponding to a grid with dimensions
   ! "n_x", "n_y", "n_z" in gnuplot format (suitable for an splot).
   ! If "norm" is present and TRUE write the norm of the vector field
   ! If "normalise" is present and TRUE write the normalised of the vector field
       j :: MAT{REAL}
      n_x,n_y,n_z :: INT
      norm,normalise :: BIN, optional
      n,x,y,z :: INT
      write_norm,write_normalised :: BIN
       v :: VEC{REAL}(3)
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)
      write_norm = FALSE; if (present(norm)) write_norm = norm
      write_normalised = FALSE; if (present(normalise)) write_normalised = normalise
      n = 1
      do z = 1,n_z
         if (n_z>1) then
            .textfile.put(" z = ")
            .textfile.put(z)
            .textfile.flush
         end
         do y = 1,n_y
         do x = 1,n_x
            v = j(n,:)
            if (write_norm) then
               .textfile.put( v.norm)
            else
               if (write_normalised) v.normalise
               .textfile.put(v(1))
               .textfile.put(v(2))
               .textfile.put(v(3))
            end
            .textfile.flush
            n = n+1
         end
         .textfile.flush
         end
      end
      .close
   end

   write_contour_a_la_nancy(density,grid,atom)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in the "contour" format for work in Nancy. This also requires
   ! the "atom" list and plot "grid" as well.
      density :: VEC{REAL}
      grid :: PLOT_GRID
      atom :: VEC{ATOM}
      n,f,l :: INT
      vec :: VEC{REAL}(3)
      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(20)
      .textfile.set_real_precision(12)
      .textfile.text("Tonto output for the contour program used in Nancy ...")
      .textfile.put(atom.dim,real_width=TRUE)
      vec = grid.width
      vec.convert_to("angstrom")
      .textfile.put(vec(1))
      .textfile.put(vec(2))
      .textfile.put(vec(3))
      .textfile.flush
      do n = 1,atom.dim
         .textfile.put(atom(n).label)
         vec = atom(n).position
         vec.convert_to("angstrom")
         .textfile.put(vec(1))
         .textfile.put(vec(2))
         .textfile.put(vec(3))
         .textfile.flush
      end
      .textfile.put(grid.n_x)
      .textfile.put(grid.n_y)
      .textfile.put(grid.n_z)
      .textfile.flush
      .textfile.set_using_array_labels(FALSE)
      f = 1
      l = grid.n_x
      do n = 1,grid.n_y*grid.n_z
         .textfile.put(density(f:l))
         f = f + grid.n_x
         l = l + grid.n_x
      end
      .close
   end

   write_a_la_xdgraph(density,grid,atom)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in the "xdgraph" format. This also requires the "atom" list
   ! and plot "grid" as well.
      density :: VEC{REAL}
      grid :: PLOT_GRID
      atom :: VEC{ATOM}

      n,f,l :: INT
      vec :: VEC{REAL}(3)
      atm :: VEC{INT}(3)
      axes :: MAT{REAL}(3,3)
      has_axis_atoms :: BIN

      has_axis_atoms = grid.x_atom_1/=0 AND grid.x_atom_2/=0 &
                   AND grid.y_atom_1/=0 AND grid.y_atom_2/=0 &
                   AND grid.y_atom_1==grid.x_atom_1 

      if (has_axis_atoms) then
         .open(for="writing",ascii=TRUE)
         .textfile.set_margin_width(0)
         if (grid.n_z==1) then; .textfile.put("2DGRDFIL",width=8)
         else;                  .textfile.put("3DGRDFIL",width=8)
         end
         .textfile.put(0,width=3)
         .textfile.flush
         .textfile.put("TONTO",width=5)
         .textfile.put("FOU",width=7)
         .textfile.flush
         .textfile.flush
         .textfile.put("! Gridpoints, Origin, Physical Dimensions")
         .textfile.flush
         .textfile.put(grid.n_x,width=15)
         .textfile.put(grid.n_y,width=15)
         .textfile.put(grid.n_z,width=15)
         .textfile.flush
         .textfile.set_real_style("f")
         .textfile.set_real_width(11)
         .textfile.set_real_precision(4)
         vec = grid.width
         vec.convert_to("angstrom")
         .textfile.put(vec(1)*HALF)
         .textfile.put(vec(2)*HALF)
         .textfile.put(vec(3)*HALF)
         .textfile.flush
         .textfile.put(vec(1))
         .textfile.put(vec(2))
         .textfile.put(vec(3))
         .textfile.flush
         .textfile.put("! Objects",width=9)
         .textfile.flush
         .textfile.put(atom.dim,width=10)
         .textfile.flush
         .textfile.set_real_style("f")
         .textfile.set_real_width(10)
         .textfile.set_real_precision(5)
         axes(1,:) = grid.x_axis
         axes(2,:) = grid.y_axis
         axes(3,:) = grid.z_axis
         atm = [grid.x_atom_1,grid.x_atom_2,grid.y_atom_2]
         do n = 1,atom(atm).dim
            l = min(len_trim(atom(atm(n)).label),8)
            .textfile.put(atom(atm(n)).label,width=l)
            .textfile.tab(width=8-l)
            vec = atom(atm(n)).position
            vec = vec - grid.centre
            vec = matmul(axes,vec)
            vec.convert_to("angstrom")
            .textfile.put(vec(1))
            .textfile.put(vec(2))
            .textfile.put(vec(3))
            .textfile.put("ATOM",width=5)
            .textfile.flush
         end
         do n = 1,atom.dim
            if (n==grid.x_atom_1) cycle
            if (n==grid.x_atom_2) cycle
            if (n==grid.y_atom_2) cycle
            l = min(len_trim(atom(n).label),8)
            .textfile.put(atom(n).label,width=l)
            .textfile.tab(width=8-l)
            vec = atom(n).position
            vec = vec - grid.centre
            vec = matmul(axes,vec)
            vec.convert_to("angstrom")
            .textfile.put(vec(1))
            .textfile.put(vec(2))
            .textfile.put(vec(3))
            .textfile.put("ATOM",width=5)
            .textfile.flush
         end
         .textfile.put("! Connections",width=13)
         .textfile.flush
         .textfile.put(0,width=10)
         .textfile.flush
         .textfile.put("! Values",width=8)
         .textfile.flush
         .textfile.set_using_array_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.set_real_width(13)
         .textfile.set_real_precision(5)
         .textfile.set_n_fields_per_line(6)
         f = 1
         l = grid.n_x
         do n = 1,grid.n_y*grid.n_z
            .textfile.put(density(f:l),by_row=TRUE)
            f = f + grid.n_x
            l = l + grid.n_x
         end
         .close
      
      else ! No axis atoms

         .open(for="writing",ascii=TRUE)
         .textfile.set_margin_width(0)
         if (grid.n_z==1) then; .textfile.put("2DGRDFIL",width=8)
         else;                  .textfile.put("3DGRDFIL",width=8)
         end

         .textfile.put(0,width=3)
         .textfile.flush
         .textfile.put("TONTO",width=5)
         .textfile.put("FOU",width=7)
         .textfile.flush
         .textfile.flush

         .textfile.put("! Gridpoints, Origin, Physical Dimensions")
         .textfile.flush
         .textfile.put(grid.n_x,width=15)
         .textfile.put(grid.n_y,width=15)
         .textfile.put(grid.n_z,width=15)
         .textfile.flush
         .textfile.set_real_style("f")
         .textfile.set_real_width(11)
         .textfile.set_real_precision(4)
         .textfile.put(HALF)
         .textfile.tab(width=4)
         .textfile.put(HALF)
         .textfile.tab(width=4)
         .textfile.put(HALF)
         .textfile.flush
         .textfile.put(ONE)
         .textfile.tab(width=4)
         .textfile.put(ONE)
         .textfile.tab(width=4)
         .textfile.put(ONE)
         .textfile.flush

         .textfile.put("! Objects",width=9)
         .textfile.flush
         .textfile.put(0,width=10)
         .textfile.flush
         .textfile.set_real_style("f")
         .textfile.set_real_width(10)
         .textfile.set_real_precision(5)

         .textfile.put("! Connections",width=13)
         .textfile.flush
         .textfile.put(0,width=10)
         .textfile.flush
         .textfile.put("! Values",width=8)
         .textfile.flush
         .textfile.set_using_array_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.set_real_width(13)
         .textfile.set_real_precision(5)
         .textfile.set_n_fields_per_line(6)
         f = 1
         l = grid.n_x
         do n = 1,grid.n_y*grid.n_z
            .textfile.put(density(f:l),by_row=TRUE)
            f = f + grid.n_x
            l = l + grid.n_x
         end
         .close
      end

   end

   write_gaussian_cube(density,grid,atom,title)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in the gaussian cube format. This also requires the "atom"
   ! list and plot "grid" as well.
      density :: VEC{REAL}
      grid :: PLOT_GRID
      atom :: VEC{ATOM}
      title :: STR
      n,n_atom,x,y,z :: INT
      an :: REAL
      axes :: MAT{REAL}(3,3)
      low,high,pos :: VEC{REAL}(3)
      reverse :: MAT3{REAL}*

      if (grid.n_z<=1) return

      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("f")
      .textfile.set_real_width(12)
      .textfile.set_real_precision(6)

      .textfile.text("3DGRIDFILE  0")
      .textfile.text("TITLE  "//trim(title))

      ! Find out the number of atoms which are within the plot grid box.
      ! We have to change into the plot axis system.
      axes(1,:) = grid.x_axis
      axes(2,:) = grid.y_axis
      axes(3,:) = grid.z_axis
      low  = -HALF*grid.width ! bottom left front in plot axis system
      high =  HALF*grid.width ! top right back ....
      n_atom = 0
      do n = 1,atom.dim
         pos = atom(n).position - grid.centre
         pos = matmul(axes,pos)
         if (NOT pos(:).is_in_range(low,high)) cycle
         n_atom = n_atom + 1
      end

      .textfile.put(n_atom,width=5)
      .textfile.put(low(1))
      .textfile.put(low(2))
      .textfile.put(low(3))
      .textfile.flush

      .textfile.put(grid.n_x,width=5)
      .textfile.put(grid.del_x)
      .textfile.put(ZERO)
      .textfile.put(ZERO)
      .textfile.flush

      .textfile.put(grid.n_y,width=5)
      .textfile.put(ZERO)
      .textfile.put(grid.del_y)
      .textfile.put(ZERO)
      .textfile.flush

      .textfile.put(grid.n_z,width=5)
      .textfile.put(ZERO)
      .textfile.put(ZERO)
      .textfile.put(grid.del_z)
      .textfile.flush

      do n = 1,atom.dim
         pos = atom(n).position - grid.centre
         pos = matmul(axes,pos)
         if (NOT pos(:).is_in_range(low,high)) cycle
         an = atom(n).atomic_number
         if (an<1) cycle
         .textfile.put(int(an),width=5)       ! Z
         .textfile.put(an)                    ! Charge
         .textfile.put(pos(1))                ! Pos in plot grid axis system
         .textfile.put(pos(2))
         .textfile.put(pos(3))
         .textfile.flush
      end

      .textfile.set_real_style("e")
      .textfile.set_real_width(13)
      .textfile.set_real_precision(5)

      reverse.create(grid.n_x,grid.n_y,grid.n_z)
      reverse = reshape(density,[grid.n_x,grid.n_y,grid.n_z])

      do x = 1,grid.n_x
      do y = 1,grid.n_y
      do z = 1,grid.n_z
         .textfile.put(reverse(x,y,z))
         if (mod(z,6)==0 OR z==grid.n_z) .textfile.flush
      end
      end
      end

      reverse.destroy

      .close

   end

   write_xcrysden_xsf(density,grid,atom,title)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in the XSF format. This also requires the "atom"
   ! list and plot "grid" as well.
      density :: VEC{REAL}
      grid :: PLOT_GRID
      atom :: VEC{ATOM}
      title :: STR

      n,x,y,z,an :: INT
      fac :: REAL
      axes :: MAT{REAL}(3,3)
      low,high,pos :: VEC{REAL}(3)
      density3d :: MAT3{REAL}*
      units :: STR

      if (grid.n_z<=1) return

      .open(for="writing",ascii=TRUE)
      .textfile.set_real_style("e")
      .textfile.set_real_width(13)
      .textfile.set_real_precision(5)

      ! Coordinates: shift to grid center and rotate
      ! Plot only atoms which are within the plot grid box.
      ! To do this we have to change into the plot axis system.
      .textfile.text("ATOMS")
      axes(1,:) = grid.x_axis
      axes(2,:) = grid.y_axis
      axes(3,:) = grid.z_axis
      units = "angstrom"
      fac = units.conversion_factor
      low  = -HALF*grid.width * fac ! bottom left front in plot axis system
      high =  HALF*grid.width * fac ! top right back ....
      do n = 1,atom.dim
         pos = atom(n).position - grid.centre
         pos = matmul(axes,pos)
         pos = pos * fac
         if (NOT pos(:).is_in_range(low,high)) cycle
         an = atom(n).atomic_number
         if (an<1) cycle
         .textfile.put(an)                    ! Z
         .textfile.put(pos(1))                ! Pos in plot grid axis system
         .textfile.put(pos(2))
         .textfile.put(pos(3))
         .textfile.flush
      end

      ! Create the 3d grid
      density3d.create(grid.n_x,grid.n_y,grid.n_z)
      density3d = reshape(density,[grid.n_x,grid.n_y,grid.n_z])

      ! Write out the grid
      .textfile.flush
      .textfile.text("BEGIN_BLOCK_DATAGRID_3D")
      .textfile.text(title)
      .textfile.text("BEGIN_DATAGRID_3D_"//trim(title))
      .textfile.put(grid.n_x)
      .textfile.put(grid.n_y)
      .textfile.put(grid.n_z)
      .textfile.flush
      .textfile.put(low(1))
      .textfile.put(low(2))
      .textfile.put(low(3))
      .textfile.flush
      .textfile.put(grid.width(1)*fac)
      .textfile.put(ZERO)
      .textfile.put(ZERO)
      .textfile.flush
      .textfile.put(ZERO)
      .textfile.put(grid.width(2)*fac)
      .textfile.put(ZERO)
      .textfile.flush
      .textfile.put(ZERO)
      .textfile.put(ZERO)
      .textfile.put(grid.width(3)*fac)
      .textfile.flush
      do z = 1,grid.n_z
      do y = 1,grid.n_y
      do x = 1,grid.n_x
         .textfile.put(density3d(x,y,z))
         if (mod(x,6)==0 OR x==grid.n_z) .textfile.flush
      end
      end
      end
      .textfile.text("END_DATAGRID_3D")
      .textfile.text("END_BLOCK_DATAGRID_3D")

      ! Clean
      density3d.destroy
      .close

   end

   write_vapor(density,n_x,n_y,n_z)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in VAPOR format
      density :: VEC{REAL}(n_x*n_y*n_z)
      n_x,n_y,n_z :: INT, IN
      u :: INT

      ! Get a free unit number
      UNIT_NUMBER:get_available_unit_number(u)

      ! Get the size of the record
      open(u,FILE=TRIM(.file_name), FORM="UNFORMATTED", ACCESS="STREAM")

      ! Write code "8" for single precision data
      write(u) density

      ! Close and free
      close(u)
      UNIT_NUMBER:free_the_used_unit_number(u)

   end

   write_drishti(density,n_x,n_y,n_z)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in drishti format
      density :: VEC{REAL}
      n_x,n_y,n_z :: INT

      u,ios,  n,x,y,z, n_xy, offx,offy,offz :: INT
      ival4 :: INT(INT_4_KIND)
      rval4 :: REAL(REAL_4_KIND)

      ! Sizes
      n_xy = n_x*n_y

      ! Get a free unit number
      UNIT_NUMBER:get_available_unit_number(u)

      ! Get the size of the record
      open(u,file=trim(.file_name),access="stream",iostat=ios)
      DIE_IF(ios/=0,"error opening stream file")

      ! Write code "8" for single precision data
      rval4 = EIGHT
      write(u) rval4

      ! Write code "8" for single precision data
      DIE_IF(n_x>huge(n_x)/2,"n_x dimension too large for unsigned int")
      DIE_IF(n_y>huge(n_y)/2,"n_y dimension too large for unsigned int")
      DIE_IF(n_z>huge(n_z)/2,"n_z dimension too large for unsigned int")
      ival4 = n_x; write(u) ival4
      ival4 = n_y; write(u) ival4
      ival4 = n_z; write(u) ival4


      ! Now write out the data in z-y-x order
      offx = 0
      do x = 1,n_x
         offy = 0
         do y = 1,n_y
            offz = 0
            do z = 1,n_z
               n = offx + offy + offz + 1
               rval4 = density(n)
               write(u) rval4
               offz = offz + n_xy
            end
            offy = offy + n_x
         end
         offx = offx + 1
      end

      ! Close and free
      close(u)
      UNIT_NUMBER:free_the_used_unit_number(u)

   end

   write_vtk(density,grid,title)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in VTK format
      density :: VEC{REAL}, IN
      grid :: PLOT_GRID, IN
      title :: STR, IN

      lf :: STR(len=1)
      u,i,n_x,n_y,n_z :: INT
      d_x,d_y,d_z,o_x,o_y,o_z :: REAL

      ! Get a free unit number
      UNIT_NUMBER:free_the_used_unit_number(u)

      ! Open the file in stream mode
      open(u,FILE=trim(.file_name), ACCESS="STREAM")

      ! Header info
      lf = char(10)
      n_x = grid.n_x;       n_y = grid.n_y;       n_z = grid.n_z
      d_x = grid.del_x;     d_y = grid.del_y;     d_z = grid.del_z
      o_x = grid.origin(1); o_y = grid.origin(2); o_z = grid.origin(3)
      write(u) "# vtk DataFile Version 3.0"//lf
      write(u) trim(title)  //lf
      write(u) "BINARY"     //lf
      write(u) "DATASET STRUCTURED_POINTS"//lf
      write(u) "DIMENSIONS "//trim(n_x.to_str)//" "//trim(n_y.to_str)//" "//trim(n_z.to_str)//lf
      write(u) "ORIGIN "    //trim(o_x.to_str)//" "//trim(o_y.to_str)//" "//trim(o_z.to_str)//lf
      write(u) "SPACING"    //trim(d_x.to_str)//" "//trim(d_y.to_str)//" "//trim(d_z.to_str)//lf

      ! Data
      write(u) "SCALARS "   //trim(title)//" double"//lf
      write(u) "LOOKUP_TABLE default"//lf
      write(u) (density(i),i=1,n_x*n_y*n_z)

      ! Close and free
      close(u)
      UNIT_NUMBER:get_available_unit_number(u)

   end

end
