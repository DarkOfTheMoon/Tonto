!---------------------------------------------------------------------------
!
! CPX: Complex numbers
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module CPX

   implicit none

contains

   equals(c,eps) result (res) ::: pure
   ! Test to see if "self" is the same as "c"
      self :: IN
      c :: CPX, IN
      eps :: REAL, IN, optional
      res :: BIN
      res = .same_as(c,eps)
   end

   same_as(c,eps) result (res) ::: pure
   ! Test to see if "self" is the same as "c"
      self :: IN
      c :: CPX, IN
      eps :: REAL, IN, optional
      res :: BIN
      tol :: REAL
      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self-c) < tol
   end

   is_zero(eps) result (res) ::: pure
   ! Return TRUE if self is near enough zero. If present, "eps" defines how
   ! close to zero before the number is considered zero.
      self :: IN
      eps :: REAL, IN, optional
      res :: BIN
      tol :: REAL
      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self) < tol
   end

   is_one(eps) result (res) ::: pure
   ! Return TRUE if self is near enough one. If present, "eps" defines how
   ! close to one before the number is considered zero.
      self :: IN
      eps :: REAL, IN, optional
      res :: BIN
      tol :: REAL
      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self-ONE) < tol
   end

   is_minus_one(eps) result (res) ::: pure
   ! Return TRUE if self is near enough minus one. If present, "eps" defines how
   ! close to minus one before the number is considered zero.
      self :: IN
      eps :: REAL, IN, optional
      res :: BIN
      tol :: REAL
      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self+ONE) < tol
   end

end
