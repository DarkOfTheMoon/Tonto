!-------------------------------------------------------------------------------
!
! SHELL4 : Group of 4 contracted gaussian SHELL1's, used mainly for integrals
! (c) Daniel Grimwood, March 1998
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 5889-5897.
!
! $Id$
!-------------------------------------------------------------------------------

module SHELL4

  use TYPES
  use SYSTEM
  use INT
  use VEC
  use IVEC
  use IMAT
  use IMAT3
  use MAT
  use MAT3
  use MAT4
  use OUTPUT
  use SHELL1
  use SHELL2
  use RYS
  use GAUSSIAN4

  implicit none         

#include "macros"
#include "shell4.int"

! type shell4_type
!   SHELL1 :: a
!   SHELL1 :: b
!   SHELL1 :: c
!   SHELL1 :: d
! end

contains

  create
  ! Create a shell4 object, but no its component shells.
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SHELL4_SIZE)
    .nullify_ptr_part
  end

  create(shell_a,shell_b,shell_c,shell_d)
  ! Create a shell4 object from copies of shell1s.
    PTR :: self
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .create
    .copy(shell_a,shell_b,shell_c,shell_d)
  end

  create(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  ! Create a shell4 object from copies of shells and their positions.
    PTR :: self
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC(3), IN :: pos_a,pos_b,pos_c,pos_d
    .create
    .copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  end

  destroy
  ! Destroy a shell4 object.
    PTR :: self
    if (associated(self)) then
      .destroy_ptr_part
      DELETE_MEM(SHELL4_SIZE)
      deallocate(self)
    end
  end

  created result(res)
  ! Returns true if self has been created
    PTR :: self
    BIN :: res
    res = associated(self)
  end

  destroyed result(res)
  ! Returns true if self has *not* been created
    PTR :: self
    BIN :: res
    res = NOT associated(self)
  end

  nullify_ptr_part
  ! Nullify the pointer parts of self
    .a.nullify_ptr_part
    .b.nullify_ptr_part
    .c.nullify_ptr_part
    .d.nullify_ptr_part
  end

  destroy_ptr_part
  ! Destroy the pointer parts of self
    .a.destroy_ptr_part
    .b.destroy_ptr_part
    .c.destroy_ptr_part
    .d.destroy_ptr_part
  end

  put(out)
  ! Put the shell4 information to file "out"
    OUTPUT :: out
    out.put("Shell a:",flush=1)
    .a.put(out)
    out.put("Shell b:",flush=1)
    .b.put(out)
    out.put("Shell c:",flush=1)
    .c.put(out)
    out.put("Shell d:",flush=1)
    .d.put(out)
    out.flush
  end

  copy(shell_a,shell_b,shell_c,shell_d) [leaky]
  ! Copy the shell4 using from shell1 objects
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .a.copy(shell_a)
    .b.copy(shell_b)
    .c.copy(shell_c)
    .d.copy(shell_d)
  end

  copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) [leaky]
  ! Set the shell4 using shell objects and positions
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC, IN :: pos_a,pos_b,pos_c,pos_d
    .a.copy(shell_a,pos_a)
    .b.copy(shell_b,pos_b)
    .c.copy(shell_c,pos_c)
    .d.copy(shell_d,pos_d)
  end

  set(shell_a,shell_b,shell_c,shell_d)
  ! Set the shell4 using from shell1 objects
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .a.set(shell_a)
    .b.set(shell_b)
    .c.set(shell_c)
    .d.set(shell_d)
  end

  set(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  ! Set the shell4 using shell objects and positions
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC, IN :: pos_a,pos_b,pos_c,pos_d
    .a.set(shell_a,pos_a)
    .b.set(shell_b,pos_b)
    .c.set(shell_c,pos_c)
    .d.set(shell_d,pos_d)
  end

  unnormalize
  ! Unnormalize each shell in this shell quartet
    .a.unnormalize
    .b.unnormalize
    .c.unnormalize
    .d.unnormalize
  end

  skip_ERI result (res)
  ! Whether the ERI block will be less than a cutoff value.
    BIN :: res
    VEC(3) :: AB,CD
    DBL :: factor,r2ab,r2cd,ex_a,ex_b,ex_c,ex_d,k_ab,k_cd,cc_a,cc_b,cc_c
    INT :: a,b,c,d
    DBL :: ex_a_r2ab, ex_c_r2cd
    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    res = TRUE
    do a = 1, .a%n_cc
      ex_a = .a%ex(a)
      cc_a = .a%cc(a)
      ex_a_r2ab = ex_a * r2ab
      do b = 1, .b%n_cc
        ex_b = .b%ex(b)
        cc_b = .b%cc(b) * cc_a
        k_ab = sign(ex_a_r2ab * ex_b / (ex_a + ex_b),-1.0d0)
        do c = 1, .c%n_cc
          ex_c = .c%ex(c)
          cc_c = .c%cc(c) * cc_b
          ex_c_r2cd = ex_c * r2cd
          do d = 1, .d%n_cc
            ex_d = .d%ex(d)
            k_cd = sign(ex_c_r2cd * ex_d / (ex_c + ex_d),-1.0d0)
            factor = abs(exp(k_ab + k_cd) * cc_c * .d%cc(d))
            if (factor > SHELL4_ERI_CUTOFF) then
              res = FALSE
              return
            end
          end
        end
      end
    end
  end

!  **********************
!  CADPAC-style integrals
!  **********************

   make_ERI_ints(I)
   ! Make the ERI integral matrix, using Gauss-Hermite quadrature, like in
   ! CADPAC.
   ! This is not expected to be as efficient as Daniel's code, below!
   ! But probably much easier to understand.
      MAT4 :: I
      MAT4, PTR :: II
      GAUSSIAN4 :: G
      INT :: a,b,c,d
      I = ZERO
      II.create(.a%n_comp,.b%n_comp,.c%n_comp,.d%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_ERI_ints(II)
         I = I + II*.a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
      end
      end
      end
      end
      II.destroy
      .to_normalize(I)
   end

   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
   ! Make the spin same orbit integrals, "Sx", ... , and the
   ! spin other orbit integrals "Ox", ... , using 
   ! Gauss-Hermite quadrature. Probably not the best implementation.
      MAT4 :: Sx,Sy,Sz,Ox,Oy,Oz
      MAT4, PTR :: SSx,SSy,SSz,OOx,OOy,OOz
      GAUSSIAN4 :: G
      INT :: a,b,c,d,na,nb,nc,nd
      DBL :: cc
      Sx = ZERO; Sy = ZERO; Sz = ZERO
      Ox = ZERO; Oy = ZERO; Oz = ZERO
      na = .a%n_comp; nb = .b%n_comp; nc =.c%n_comp; nd =.d%n_comp
      SSx.create(na,nb,nc,nd); SSy.create(na,nb,nc,nd); SSz.create(na,nb,nc,nd)
      OOx.create(na,nb,nc,nd); OOy.create(na,nb,nc,nd); OOz.create(na,nb,nc,nd)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_spin_orbit_ints(SSx,SSy,SSz,OOx,OOy,OOz)
         cc = .a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
         Sx = Sx + SSx*cc; Sy = Sy + SSy*cc; Sz = Sz + SSz*cc
         Ox = Ox + OOx*cc; Oy = Oy + OOy*cc; Oz = Oz + OOz*cc
      end 
      end
      end
      end
      OOz.destroy; OOy.destroy; OOx.destroy
      SSz.destroy; SSy.destroy; SSx.destroy
      .to_normalize(Sx); .to_normalize(Sy); .to_normalize(Sz)
      .to_normalize(Ox); .to_normalize(Oy); .to_normalize(Oz)
   end

   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
   ! Make the spin spin magnetic dipole integrals, "Dij"
   ! using Gauss-Hermite quadrature. For sure, not the 
   ! best implementation, but where else will you get em', eh?
      MAT4 :: Dxx,Dyy,Dzz,Dxy,Dxz,Dyz
      MAT4, PTR :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
      GAUSSIAN4 :: G
      INT :: a,b,c,d,na,nb,nc,nd
      DBL :: cc
      Dxx = ZERO; Dyy = ZERO; Dzz = ZERO
      Dxy = ZERO; Dxz = ZERO; Dyz = ZERO
      na = .a%n_comp; nb = .b%n_comp; nc =.c%n_comp; nd =.d%n_comp
      Mxx.create(na,nb,nc,nd); Myy.create(na,nb,nc,nd); Mzz.create(na,nb,nc,nd)
      Mxy.create(na,nb,nc,nd); Mxz.create(na,nb,nc,nd); Myz.create(na,nb,nc,nd)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_spin_spin_dipole_ints(Mxx,Myy,Mzz,Mxy,Mxz,Myz)
         cc = .a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
         Dxx = Dxx + Mxx*cc; Dyy = Dyy + Myy*cc; Dzz = Dzz + Mzz*cc
         Dxy = Dxy + Mxy*cc; Dxz = Dxz + Mxz*cc; Dyz = Dyz + Myz*cc
      end 
      end
      end
      end
      Myz.destroy; Mxz.destroy; Mxy.destroy
      Mzz.destroy; Myy.destroy; Mxx.destroy
      .to_normalize(Dxx); .to_normalize(Dyy); .to_normalize(Dzz)
      .to_normalize(Dxy); .to_normalize(Dxz); .to_normalize(Dyz)
   end

!  ****************************
!  Roland Lindh-style integrals
!  ****************************

  get_eri(abcd)
  ! The main routine to produce the block (ab|cd)
  ! (uses the transfer equation to make (ab|cd) from (es|fs))
  ! The routines are now all specialised, they will break if you use the wrong
  ! one.  Best to just use this main routine.
    IN :: self
    MAT4, INOUT :: abcd
    MAT3, PTR :: escd
    MAT, PTR :: esfs
    VEC, PTR :: ssfs,esss
    SHELL2, PTR :: sh
    INT :: n_e,n_f,eub,fub,opt

    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    opt=0
    if (n_e==0) opt = opt+1
    if (n_f==0) opt = opt+2
    if (n_e==1) opt = opt+4
    if (n_f==1) opt = opt+4

    select case (opt)
      case (0,4)                                            ! ab|cd integrals
        nullify(esfs)
        nullify(escd)
        eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum
        esfs.create(eub,fub)
        .make_esfs(esfs)
        escd.create(eub, .c%n_comp, .d%n_comp)
        .transfer(esfs,escd)
        .transfer(escd,abcd)
        escd.destroy
        esfs.destroy
        .to_normalize(abcd)
      case (1)                                              ! ss|cd integrals
        fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum
        ssfs.create(fub)
        .make_ssfs(ssfs)
        sh.create(.c,.d)
        sh.transfer(ssfs,abcd(1,1,:,:))
        sh.destroy
        ssfs.destroy
        .to_normalize(abcd)
      case (2)                                              ! ab|ss integrals
        eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        esss.create(eub)
        .make_esss(esss)
        sh.create(.a,.b)
        sh.transfer(esss,abcd(:,:,1,1))
        sh.destroy
        ssfs.destroy
        .to_normalize(abcd)
      case (3)                                              ! ss|ss integrals
        .make_ssss_eri(abcd)
      case (5)                                              ! ss|ps integrals
        ssfs.create(3)
        .make_ssps(ssfs)
        if (.c%l == 1) abcd(1,1,:,1) = ssfs
        if (.d%l == 1) abcd(1,1,1,:) = ssfs
        ssfs.destroy
        .to_normalize(abcd)
      case (6)                                              ! ps|ss integrals
        esss.create(3)
        .make_psss(esss)
        if (.a%l == 1) abcd(:,1,1,1) = esss
        if (.b%l == 1) abcd(1,:,1,1) = esss
        esss.destroy
        .to_normalize(abcd)
      case (8)                                              ! ps|ps integrals
        nullify(esfs)
        esfs.create(3,3)
        .make_psps(esfs)
        if (.a%l == 1) then
          if (.c%l ==1) then
            abcd(:,1,:,1) = esfs
          else
            abcd(:,1,1,:) = esfs
          end
        else
          if (.c%l ==1) then
            abcd(1,:,:,1) = esfs
          else
            abcd(1,:,1,:) = esfs
          end
        end
        esfs.destroy
    end
  end

  make_esfs(esfs)
  ! Creates the initial (es|fs) integrals, summed over the primitives
    IN :: self
    MAT, INOUT:: esfs
    MAT3, PTR :: esfsadd
    MAT4, PTR :: Ix,Iy,Iz
    RYS, PTR :: rysa
    VEC(3) :: P,Q,PAi,QCi,QPi,brb,drd,AB,CD,C_tmp,A_tmp
    DBL :: a,b,c,d,zeta,kab,eta,kcd,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg,nroots,eub,fub,dim1,dim2,i,n_cc,n_e,n_f
    DBL :: normb,normc,normd,zinvi,rhoi,einvi,norm,d_r2cd,b_r2ab
    IVEC, PTR :: e_x,e_y,e_z,f_x,f_y,f_z
    VEC, PTR :: rho,zinv,einv
    MAT, PTR :: weights,roots,PA,QC,QP

    n_cc = .a%n_cc * .b%n_cc * .c%n_cc * .d%n_cc
    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum

    dim1 = n_e + 1
    dim2 = n_f + 1
    nroots = (dim1+dim2)/2

    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    if (.a%l > .b%l) then
      A_tmp = .a%pos
    else
      A_tmp = .b%pos
    end
    if (.c%l > .d%l) then
      C_tmp = .c%pos
    else
      C_tmp = .d%pos
    end

    weights.create(n_cc,nroots)
    roots.create(n_cc,nroots)
    rho.create(n_cc)
    zinv.create(n_cc)
    einv.create(n_cc)
    PA.create(3,n_cc)
    QC.create(3,n_cc)
    QP.create(3,n_cc)

    rysa.create(nroots)
    i = 1
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      drd   = d* .d%pos
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c     = .c%ex(cg)
        eta   = c + d
        einvi = ONE / eta
        kcd   = sqrt(einvi) * einvi * exp(-c * d_r2cd * einvi)
        normc = normd * .c%cc(cg) * kcd
        Q     = (drd + c * .c%pos) * einvi
        QCi   = Q - C_tmp
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          normb = normc * .b%cc(bg)
          brb   = b* .b%pos
          b_r2ab = b * r2ab
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinvi = ONE / zeta
            kab   = exp(-a * b_r2ab * zinvi)
            P     = (brb + a* .a%pos) * zinvi
            PAi   = P - A_tmp
            QPi   = Q - P
            rhoi  = zeta * eta / (zeta + eta)
            xx    = rhoi * dot_product(QPi,QPi)         ! xx = rho QP^2
            rysa.get_weights(xx)
            norm = normb * .a%cc(ag) * sqrt(rhoi*zinvi)*zinvi*kab
            weights(i,:) = rysa%w * norm
            roots(i,:) = rysa%r
            rho(i)  = rhoi
            einv(i) = einvi
            zinv(i) = zinvi
            PA(:,i) = PAi
            QC(:,i) = QCi
            QP(:,i) = QPi
            i = i + 1
          end
        end
      end
    end
    rysa.destroy

    Ix.create(n_cc,nroots,dim1,dim2)
    Iy.create(n_cc,nroots,dim1,dim2)
    Iz.create(n_cc,nroots,dim1,dim2)
    .form_2d_ints(Ix,Iy,Iz,nroots,roots,rho,zinv,einv,PA,QC,QP,n_cc)
    .form_esfs(Ix,Iy,Iz,weights,esfs,eub,fub,nroots,dim1,dim2,n_cc)
    Iz.destroy
    Iy.destroy
    Ix.destroy

    QP.destroy
    QC.destroy
    PA.destroy
    einv.destroy
    zinv.destroy
    rho.destroy
    roots.destroy
    weights.destroy
  end

  form_2d_ints(Ix,Iy,Iz,nroots,t2,rho,zinv,einv,PA,QC,QP,n_cc)
  ! Forms the two dimentional integrals
    IN :: self
    MAT4, target, OUT :: Ix,Iy,Iz
    INT, IN :: nroots,n_cc
    MAT :: t2,PA,QC,QP
    VEC, IN :: rho,zinv,einv
    MAT(n_cc,nroots) :: ce,cf,bb,ce1
    MAT, PTR :: Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22
    MAT, PTR :: Ixa,Ixb,Ixc,Ixd,Iya,Iyb,Iyc,Iyd,Iza,Izb,Izc,Izd ! temp matrices
    MAT, PTR :: Ixe,Iye,Ize,Ixf,Iyf,Izf
    INT :: e,f,e1,f1,fp1,ep1,n_e,n_f,i,n,opt
    DBL :: tmp,tmp2,tmp3,tmp4,tmp5,QPx,QPy,QPz,zinvi,einvi
    DBL :: Ix12in,Iy12in,Iz12in,Ix21in,Iy21in,Iz21in
    
    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    Ix(:,:,1,1) = ONE
    Iy(:,:,1,1) = ONE
    Iz(:,:,1,1) = ONE

    opt=0
    if (n_e==0) opt = opt+2
    if (n_e==1) opt = opt+1
    if (n_f==0) opt = opt+6
    if (n_f==1) opt = opt+3
    select case (opt)
      case (0)                                              ! ab|cd integrals
            Ix12 => Ix(:,:,1,2); Iy12 => Iy(:,:,1,2); Iz12 => Iz(:,:,1,2)
            Ix21 => Ix(:,:,2,1); Iy21 => Iy(:,:,2,1); Iz21 => Iz(:,:,2,1)
            Ix22 => Ix(:,:,2,2); Iy22 => Iy(:,:,2,2); Iz22 => Iz(:,:,2,2)
            do n=1,nroots
              do i=1,n_cc
                zinvi = zinv(i); einvi = einv(i)
                tmp  = t2(i,n) * rho(i)
                tmp2 = tmp * zinvi
                tmp3 = tmp * einvi
                tmp4 = HALF * einvi
                tmp5 = tmp2 * tmp4
                cf(i,n) = (ONE - tmp3) * tmp4
                ce(i,n) = (ONE - tmp2) * HALF * zinvi
                bb(i,n) = tmp5
                QPx = QP(1,i); QPy = QP(2,i); QPz = QP(3,i)
                Ix12in = QC(1,i) - tmp3 * QPx
                Iy12in = QC(2,i) - tmp3 * QPy
                Iz12in = QC(3,i) - tmp3 * QPz
                Ix21in = PA(1,i) + tmp2 * QPx
                Iy21in = PA(2,i) + tmp2 * QPy
                Iz21in = PA(3,i) + tmp2 * QPz
                Ix12(i,n) = Ix12in; Iy12(i,n) = Iy12in; Iz12(i,n) = Iz12in
                Ix21(i,n) = Ix21in; Iy21(i,n) = Iy21in; Iz21(i,n) = Iz21in
                Ix22(i,n) = Ix12in * Ix21in + tmp5
                Iy22(i,n) = Iy12in * Iy21in + tmp5
                Iz22(i,n) = Iz12in * Iz21in + tmp5
              end
            end
            do f = 2,n_f
              f1  = f - 1
              fp1 = f + 1
              Ixa => Ix(:,:,1,fp1); Iya => Iy(:,:,1,fp1); Iza => Iz(:,:,1,fp1)
              Ixb => Ix(:,:,1,f);   Iyb => Iy(:,:,1,f);   Izb => Iz(:,:,1,f)
              Ixc => Ix(:,:,1,f1);  Iyc => Iy(:,:,1,f1);  Izc => Iz(:,:,1,f1)
              do n=1,nroots
                do i=1,n_cc
                  tmp = f1*cf(i,n)
                  Ixa(i,n) = Ix12(i,n) * Ixb(i,n) + tmp * Ixc(i,n)
                  Iya(i,n) = Iy12(i,n) * Iyb(i,n) + tmp * Iyc(i,n)
                  Iza(i,n) = Iz12(i,n) * Izb(i,n) + tmp * Izc(i,n)
                end
              end
            end
            do e = 2, n_e
              e1  = e - 1
              ep1 = e + 1
              Ixa => Ix(:,:,ep1,1); Iya => Iy(:,:,ep1,1); Iza => Iz(:,:,ep1,1)
              Ixb => Ix(:,:,e,1);   Iyb => Iy(:,:,e,1);   Izb => Iz(:,:,e,1)
              Ixc => Ix(:,:,e1,1);  Iyc => Iy(:,:,e1,1);  Izc => Iz(:,:,e1,1)
              do n=1,nroots
                do i=1,n_cc
                  tmp = e1 * ce(i,n)
                  Ixa(i,n) = Ix21(i,n) * Ixb(i,n) + tmp * Ixc(i,n)
                  Iya(i,n) = Iy21(i,n) * Iyb(i,n) + tmp * Iyc(i,n)
                  Iza(i,n) = Iz21(i,n) * Izb(i,n) + tmp * Izc(i,n)
                end
              end
            end
            do f=2,n_f
              f1  = f - 1
              fp1 = f + 1
              Ixa => Ix(:,:,2,fp1); Iya => Iy(:,:,2,fp1); Iza => Iz(:,:,2,fp1)
              Ixb => Ix(:,:,2,f);   Iyb => Iy(:,:,2,f);   Izb => Iz(:,:,2,f)
              Ixc => Ix(:,:,2,f1);  Iyc => Iy(:,:,2,f1);  Izc => Iz(:,:,2,f1)
              Ixd => Ix(:,:,1,f);   Iyd => Iy(:,:,1,f);   Izd => Iz(:,:,1,f)
              do n=1,nroots
                do i=1,n_cc
                  tmp = f1 * cf(i,n)
                  tmp2 = bb(i,n)
                  Ixa(i,n) = Ix12(i,n)*Ixb(i,n) + tmp*Ixc(i,n) + tmp2*Ixd(i,n)
                  Iya(i,n) = Iy12(i,n)*Iyb(i,n) + tmp*Iyc(i,n) + tmp2*Iyd(i,n)
                  Iza(i,n) = Iz12(i,n)*Izb(i,n) + tmp*Izc(i,n) + tmp2*Izd(i,n)
                end
              end
            end
            do e = 2, n_e
              e1  =e - 1
              ep1 =e + 1
              ce1 =e1 * ce
              do f1=1, n_f
                f = f1 + 1
                Ixa => Ix(:,:,ep1,f); Iya => Iy(:,:,ep1,f); Iza => Iz(:,:,ep1,f)
                Ixb => Ix(:,:,e,f);   Iyb => Iy(:,:,e,f);   Izb => Iz(:,:,e,f)
                Ixc => Ix(:,:,e1,f);  Iyc => Iy(:,:,e1,f);  Izc => Iz(:,:,e1,f)
                Ixd => Ix(:,:,e,f1);  Iyd => Iy(:,:,e,f1);  Izd => Iz(:,:,e,f1)
                do n=1,nroots
                  do i=1,n_cc
                    tmp = ce1(i,n)
                    tmp2 = f1*bb(i,n)
                    Ixa(i,n) = Ix21(i,n)*Ixb(i,n) + tmp*Ixc(i,n) + tmp2*Ixd(i,n)
                    Iya(i,n) = Iy21(i,n)*Iyb(i,n) + tmp*Iyc(i,n) + tmp2*Iyd(i,n)
                    Iza(i,n) = Iz21(i,n)*Izb(i,n) + tmp*Izc(i,n) + tmp2*Izd(i,n)
                  end
                end
              end
            end
      case (1)                                              ! ps|cd integrals
            Ix12 => Ix(:,:,1,2); Iy12 => Iy(:,:,1,2); Iz12 => Iz(:,:,1,2)
            Ix21 => Ix(:,:,2,1); Iy21 => Iy(:,:,2,1); Iz21 => Iz(:,:,2,1)
            Ix22 => Ix(:,:,2,2); Iy22 => Iy(:,:,2,2); Iz22 => Iz(:,:,2,2)
            do n=1,nroots
              do i=1,n_cc
                einvi = einv(i)
                tmp  = t2(i,n) * rho(i)
                tmp2 = tmp * zinv(i)
                tmp3 = tmp * einvi
                tmp4 = HALF * einvi
                tmp5 = tmp2 * tmp4
                cf(i,n) = (ONE - tmp3) * tmp4
                bb(i,n) = tmp5
                QPx = QP(1,i); QPy = QP(2,i); QPz = QP(3,i)
                Ix12in = QC(1,i) - tmp3 * QPx
                Iy12in = QC(2,i) - tmp3 * QPy
                Iz12in = QC(3,i) - tmp3 * QPz
                Ix21in = PA(1,i) + tmp2 * QPx
                Iy21in = PA(2,i) + tmp2 * QPy
                Iz21in = PA(3,i) + tmp2 * QPz
                Ix12(i,n) = Ix12in; Iy12(i,n) = Iy12in; Iz12(i,n) = Iz12in
                Ix21(i,n) = Ix21in; Iy21(i,n) = Iy21in; Iz21(i,n) = Iz21in
                Ix22(i,n) = Ix12in * Ix21in + tmp5
                Iy22(i,n) = Iy12in * Iy21in + tmp5
                Iz22(i,n) = Iz12in * Iz21in + tmp5
              end
            end
            do f=2,n_f
              f1  = f - 1
              fp1 = f + 1
              Ixa => Ix(:,:,2,fp1); Iya => Iy(:,:,2,fp1); Iza => Iz(:,:,2,fp1)
              Ixb => Ix(:,:,2,f);   Iyb => Iy(:,:,2,f);   Izb => Iz(:,:,2,f)
              Ixc => Ix(:,:,2,f1);  Iyc => Iy(:,:,2,f1);  Izc => Iz(:,:,2,f1)
              Ixd => Ix(:,:,1,fp1); Iyd => Iy(:,:,1,fp1); Izd => Iz(:,:,1,fp1)
              Ixe => Ix(:,:,1,f);   Iye => Iy(:,:,1,f);   Ize => Iz(:,:,1,f)
              Ixf => Ix(:,:,1,f1);  Iyf => Iy(:,:,1,f1);  Izf => Iz(:,:,1,f1)
              do i=1,n_cc
                do n=1,nroots
                  tmp = f1 * cf(i,n)
                  tmp2 = bb(i,n)
                  Ix12in = Ix12(i,n); Iy12in = Iy12(i,n); Iz12in = Iz12(i,n)
                  tmp3 = Ixe(i,n); tmp4 = Iye(i,n); tmp5 = Ize(i,n)
                  Ixd(i,n) = Ix12in * tmp3 + tmp * Ixf(i,n)
                  Iyd(i,n) = Iy12in * tmp4 + tmp * Iyf(i,n)
                  Izd(i,n) = Iz12in * tmp5 + tmp * Izf(i,n)
                  Ixa(i,n) = Ix12in * Ixb(i,n) + tmp * Ixc(i,n) + tmp2*tmp3
                  Iya(i,n) = Iy12in * Iyb(i,n) + tmp * Iyc(i,n) + tmp2*tmp4
                  Iza(i,n) = Iz12in * Izb(i,n) + tmp * Izc(i,n) + tmp2*tmp5
                end
              end
            end
      case (2)                                              ! ss|cd integrals
            Ix12 => Ix(:,:,1,2); Iy12 => Iy(:,:,1,2); Iz12 => Iz(:,:,1,2)
            do n=1,nroots
              do i=1,n_cc
                einvi = einv(i)
                tmp = t2(i,n) * rho(i) * einvi
                cf(i,n) = (ONE - tmp) * HALF * einvi
                Ix12(i,n) = QC(1,i) - tmp * QP(1,i)
                Iy12(i,n) = QC(2,i) - tmp * QP(2,i)
                Iz12(i,n) = QC(3,i) - tmp * QP(3,i)
              end
            end
            do f = 2,n_f
              f1  = f - 1
              fp1 = f + 1
              Ixa => Ix(:,:,1,fp1); Iya => Iy(:,:,1,fp1); Iza => Iz(:,:,1,fp1)
              Ixb => Ix(:,:,1,f);   Iyb => Iy(:,:,1,f);   Izb => Iz(:,:,1,f)
              Ixc => Ix(:,:,1,f1);  Iyc => Iy(:,:,1,f1);  Izc => Iz(:,:,1,f1)
              do n=1,nroots
                do i=1,n_cc
                  tmp = f1*cf(i,n)
                  Ixa(i,n) = Ix12(i,n) * Ixb(i,n) + tmp * Ixc(i,n)
                  Iya(i,n) = Iy12(i,n) * Iyb(i,n) + tmp * Iyc(i,n)
                  Iza(i,n) = Iz12(i,n) * Izb(i,n) + tmp * Izc(i,n)
                end
              end
            end
      case (3)                                              ! ab|ps integrals
            Ix12 => Ix(:,:,1,2); Iy12 => Iy(:,:,1,2); Iz12 => Iz(:,:,1,2)
            Ix21 => Ix(:,:,2,1); Iy21 => Iy(:,:,2,1); Iz21 => Iz(:,:,2,1)
            Ix22 => Ix(:,:,2,2); Iy22 => Iy(:,:,2,2); Iz22 => Iz(:,:,2,2)
            do n=1,nroots
              do i=1,n_cc
                zinvi = zinv(i)
                tmp  = t2(i,n) * rho(i)
                tmp2 = tmp * zinvi
                tmp3 = tmp * einv(i)
                tmp4 = HALF * zinvi
                tmp5 = tmp3 * tmp4
                ce(i,n) = (ONE - tmp2) * tmp4
                bb(i,n) = tmp5
                QPx = QP(1,i); QPy = QP(2,i); QPz = QP(3,i)
                Ix12in = QC(1,i) - tmp3 * QPx
                Iy12in = QC(2,i) - tmp3 * QPy
                Iz12in = QC(3,i) - tmp3 * QPz
                Ix21in = PA(1,i) + tmp2 * QPx
                Iy21in = PA(2,i) + tmp2 * QPy
                Iz21in = PA(3,i) + tmp2 * QPz
                Ix12(i,n) = Ix12in; Iy12(i,n) = Iy12in; Iz12(i,n) = Iz12in
                Ix21(i,n) = Ix21in; Iy21(i,n) = Iy21in; Iz21(i,n) = Iz21in
                Ix22(i,n) = Ix12in * Ix21in + tmp5
                Iy22(i,n) = Iy12in * Iy21in + tmp5
                Iz22(i,n) = Iz12in * Iz21in + tmp5
              end
            end
            do e = 2, n_e
              e1  =e - 1
              ep1 =e + 1
              Ixa => Ix(:,:,ep1,1); Iya => Iy(:,:,ep1,1); Iza => Iz(:,:,ep1,1)
              Ixb => Ix(:,:,e,1);   Iyb => Iy(:,:,e,1);   Izb => Iz(:,:,e,1)
              Ixc => Ix(:,:,e1,1);  Iyc => Iy(:,:,e1,1);  Izc => Iz(:,:,e1,1)
              do n=1,nroots
                do i=1,n_cc
                  tmp = e1 * ce(i,n)
                  ce1(i,n) = tmp
                  Ixa(i,n) = Ix21(i,n) * Ixb(i,n) + tmp * Ixc(i,n)
                  Iya(i,n) = Iy21(i,n) * Iyb(i,n) + tmp * Iyc(i,n)
                  Iza(i,n) = Iz21(i,n) * Izb(i,n) + tmp * Izc(i,n)
                end
              end
              do f1=1, n_f
                f = f1 + 1
                Ixa => Ix(:,:,ep1,f); Iya => Iy(:,:,ep1,f); Iza => Iz(:,:,ep1,f)
                Ixb => Ix(:,:,e,f);   Iyb => Iy(:,:,e,f);   Izb => Iz(:,:,e,f)
                Ixc => Ix(:,:,e1,f);  Iyc => Iy(:,:,e1,f);  Izc => Iz(:,:,e1,f)
                Ixd => Ix(:,:,e,f1);  Iyd => Iy(:,:,e,f1);  Izd => Iz(:,:,e,f1)
                do n=1,nroots
                  do i=1,n_cc
                    tmp = ce1(i,n)
                    tmp2 = f1*bb(i,n)
                    Ixa(i,n) = Ix21(i,n)*Ixb(i,n) + tmp*Ixc(i,n) + tmp2*Ixd(i,n)
                    Iya(i,n) = Iy21(i,n)*Iyb(i,n) + tmp*Iyc(i,n) + tmp2*Iyd(i,n)
                    Iza(i,n) = Iz21(i,n)*Izb(i,n) + tmp*Izc(i,n) + tmp2*Izd(i,n)
                  end
                end
              end
            end
      case (4)                                              ! ps|ps integrals
            Ix12 => Ix(:,:,1,2); Iy12 => Iy(:,:,1,2); Iz12 => Iz(:,:,1,2)
            Ix21 => Ix(:,:,2,1); Iy21 => Iy(:,:,2,1); Iz21 => Iz(:,:,2,1)
            Ix22 => Ix(:,:,2,2); Iy22 => Iy(:,:,2,2); Iz22 => Iz(:,:,2,2)
            do n=1,nroots
              do i=1,n_cc
                zinvi = zinv(i)
                tmp  = t2(i,n) * rho(i)
                tmp2 = tmp * zinvi
                tmp3 = tmp * einv(i)
                tmp4 = HALF * tmp3 * zinvi
                QPx = QP(1,i); QPy = QP(2,i); QPz = QP(3,i)
                Ix12in = QC(1,i) - tmp3 * QPx
                Iy12in = QC(2,i) - tmp3 * QPy
                Iz12in = QC(3,i) - tmp3 * QPz
                Ix21in = PA(1,i) + tmp2 * QPx
                Iy21in = PA(2,i) + tmp2 * QPy
                Iz21in = PA(3,i) + tmp2 * QPz
                Ix12(i,n) = Ix12in; Iy12(i,n) = Iy12in; Iz12(i,n) = Iz12in
                Ix21(i,n) = Ix21in; Iy21(i,n) = Iy21in; Iz21(i,n) = Iz21in
                Ix22(i,n) = Ix12in * Ix21in + tmp4
                Iy22(i,n) = Iy12in * Iy21in + tmp4
                Iz22(i,n) = Iz12in * Iz21in + tmp4
              end
            end
      case (5)                                              ! ss|ps integrals
            Ix12 => Ix(:,:,1,2); Iy12 => Iy(:,:,1,2); Iz12 => Iz(:,:,1,2)
            do n=1,nroots
              do i=1,n_cc
                tmp = t2(i,n) * rho(i) * einv(i)
                Ix12(i,n) = QC(1,i) - tmp * QP(1,i)
                Iy12(i,n) = QC(2,i) - tmp * QP(2,i)
                Iz12(i,n) = QC(3,i) - tmp * QP(3,i)
              end
            end
      case (6)                                              ! ab|ss integrals
        Ix21 => Ix(:,:,2,1)
        Iy21 => Iy(:,:,2,1)
        Iz21 => Iz(:,:,2,1)
        do n=1,nroots
          do i=1,n_cc
            zinvi = zinv(i)
            tmp = t2(i,n) * zinvi * rho(i)
            ce(i,n) = (ONE - tmp) * HALF * zinvi
            Ix21(i,n) = PA(1,i) + tmp * QP(1,i)
            Iy21(i,n) = PA(2,i) + tmp * QP(2,i)
            Iz21(i,n) = PA(3,i) + tmp * QP(3,i)
          end
        end
        do e = 2, n_e
          e1  = e - 1
          ep1 = e + 1
          Ixa => Ix(:,:,ep1,1); Iya => Iy(:,:,ep1,1); Iza => Iz(:,:,ep1,1)
          Ixb => Ix(:,:,e,1);   Iyb => Iy(:,:,e,1);   Izb => Iz(:,:,e,1)
          Ixc => Ix(:,:,e1,1);  Iyc => Iy(:,:,e1,1);  Izc => Iz(:,:,e1,1)
          do n=1,nroots
            do i=1,n_cc
              tmp = e1 * ce(i,n)
              Ixa(i,n) = Ix21(i,n) * Ixb(i,n) + tmp * Ixc(i,n)
              Iya(i,n) = Iy21(i,n) * Iyb(i,n) + tmp * Iyc(i,n)
              Iza(i,n) = Iz21(i,n) * Izb(i,n) + tmp * Izc(i,n)
            end
          end
        end
      case (7)                                              ! ps|ss integrals
        Ix21 => Ix(:,:,2,1)
        Iy21 => Iy(:,:,2,1)
        Iz21 => Iz(:,:,2,1)
        do n=1,nroots
          do i=1,n_cc
            tmp = t2(i,n) * zinv(i) * rho(i)
            Ix21(i,n) = PA(1,i) + tmp * QP(1,i)
            Iy21(i,n) = PA(2,i) + tmp * QP(2,i)
            Iz21(i,n) = PA(3,i) + tmp * QP(3,i)
          end
        end
      case (8)                                              ! ss|ss integrals
    end
  end

  form_esfs(Ix,Iy,Iz,W,esfs,eub,fub,nroots,dime,dimf,n_cc)
  ! Forms (es|fs) from the two dimensional integrals for a single
  ! set of primitives
    IN :: self
    MAT4, target :: Ix,Iy,Iz
    MAT, INOUT :: W
    MAT, OUT :: esfs
    INT, IN :: eub,fub,nroots,dime,dimf,n_cc
    IVEC, PTR :: e_x,e_y,e_z,f_x,f_y,f_z
    IMAT, PTR :: e_powers,f_powers
    MAT, PTR :: Ixef,Iyef,Izef,Ieeff
    INT :: e,f,ub1,ub2,n,i,n_e,n_f,zf,yf,xf,ze,ye,xe,dime1,dimf1,minle,minlf
    INT :: iie,iif,dimf2,dime2,opt
    DBL :: temp
    MAT4, PTR :: Ief
    MAT3, PTR :: I1

    e_powers.create(eub,3)
    f_powers.create(fub,3)
    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    e_x => e_powers(:,1); e_y => e_powers(:,2); e_z => e_powers(:,3)
    f_x => f_powers(:,1); f_y => f_powers(:,2); f_z => f_powers(:,3)
    max(.a%l,.b%l).make_gaussian_xyz_indices(e_x,e_y,e_z,n_e)
    max(.c%l,.d%l).make_gaussian_xyz_indices(f_x,f_y,f_z,n_f)
    minle=min(.a%l,.b%l)
    minlf=min(.c%l,.d%l)

    opt = 0
    if (minle > 2) opt = opt + 1
    if (minlf > 2) opt = opt + 2

    do f=1,dimf                          ! Merge the wieghts into Iz.
      do e=1,dime
        Izef => Iz(:,:,e,f)
        Izef(:,:) = Izef(:,:) * W(:,:)
      end
    end

    select case (opt)
      case (0)
        ! This version does not use the reduced multiplication scheme.
        do f=1,fub
          xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
          do e=1,eub
            Ixef => Ix(:,:,e_x(e),xf)
            Iyef => Iy(:,:,e_y(e),yf)
            Izef => Iz(:,:,e_z(e),zf)
            temp = ZERO
            do i=1,n_cc
              temp = temp + sum(Ixef(i,:) * Iyef(i,:) * Izef(i,:))
            end
            esfs(e,f) = temp
          end
        end
      case (1)
        ! Apply the reduced multiplication scheme to merge the Iy and Iz 2d
        ! integrals into a single matrix (upper triangle).
        dime1 = dime+1
        dime2 = 2*dime
        I1.create(n_cc,nroots,dime*dime1/2)
        do f=1,fub
          xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
          iie = 0
          do ze=1,dime
            do ye=1,dime1-ze
              iie = iie + 1
              I1(:,:,iie) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
            end
          end
          ! Now add in the Ix 2d integrals and sum over nroots
          do e=1,eub
            Ixef => Ix(:,:,e_x(e),xf)
            ye = e_y(e); ze = e_z(e)
            iie = (ye-1)*(dime2 - (ye-2))/2 + ze
            Ieeff => I1(:,:,iie)
            temp = ZERO
            do i=1,n_cc
              temp = temp + sum(Ixef(i,:) * Ieeff(i,:))
            end
            esfs(e,f) = temp
          end
        end
        I1.destroy
      case (2)
        dimf1 = dimf+1
        dimf2 = 2*dimf
        I1.create(n_cc,nroots,dimf*dimf1/2)
        do e=1,eub
          xe = e_x(e);    ye = e_y(e);    ze = e_z(e)
          iif = 0
          do zf=1,dimf
            do yf=1,dimf1-zf
              iif = iif + 1
              I1(:,:,iif) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
            end
          end
          ! Now add in the Ix 2d integrals and sum over nroots
          do f=1,fub
            Ixef => Ix(:,:,xe,f_x(f))
            yf = f_y(f); zf = f_z(f)
            iif = (yf-1)*(dimf2 - (yf-2))/2 + zf
            Ieeff => I1(:,:,iif)
            temp = ZERO
            do i=1,n_cc
              temp = temp + sum(Ixef(i,:) * Ieeff(i,:))
            end
            esfs(e,f) = temp
          end
        end
        I1.destroy
      case (3)
        dime1=dime+1
        dimf1=dimf+1
        Ief.create(n_cc,nroots,dime*dime1/2,dimf*dimf1/2)
        iif = 0
        do zf=1,dimf
          do yf=1,dimf1-zf
            iif = iif + 1
            iie = 0
            do ze=1,dime
              do ye=1,dime1-ze
                iie = iie + 1
                Ief(:,:,iie,iif) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
              end
            end
          end
        end
        ! Now add in the Ix 2d integrals and sum over nroots
        dimf2 = 2*dimf
        dime2 = 2*dime
        do f=1,fub
          xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
          iif = (yf-1)*(dimf2 - (yf-2))/2 + zf
          do e=1,eub
            Ixef => Ix(:,:,e_x(e),xf)
            ye = e_y(e); ze = e_z(e)
            iie = (ye-1)*(dime2 - (ye-2))/2 + ze
            Ieeff => Ief(:,:,iie,iif)
            temp = ZERO
            do i=1,n_cc
              temp = temp + sum(Ixef(i,:) * Ieeff(i,:))
            end
            esfs(e,f) = temp
          end
        end
        Ief.destroy
    end
    f_powers.destroy
    e_powers.destroy
  end

  make_psps(psps)
  ! Creates the initial (ps|ps) integrals, summed over the primitives
  ! Does ps|ps, ps|sp, sp|ps, sp|sp.
    IN :: self
    MAT, INOUT:: psps
    MAT(3,3) :: pspsadd
    RYS, PTR :: rysa
    VEC(3) :: P,Q,PA,QC,QP,brb,drd,AB,CD,C_tmp,A_tmp
    DBL :: a,b,c,d,zeta,kab,eta,kcd,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg,eub,fub,dim1,dim2,n
    DBL :: normb,normc,normd,zinv,rho,einv,norm
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,PAx,PAy,PAz
    DBL :: tmp1,tmp2,tmp3,tmp4,weight,d_r2cd,b_r2ab
    DBL :: Iz11,Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22

    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    if (.a%l > .b%l) then
      A_tmp = .a%pos
    else
      A_tmp = .b%pos
    end
    if (.c%l > .d%l) then
      C_tmp = .c%pos
    else
      C_tmp = .d%pos
    end

    psps=ZERO
    rysa.create(2)
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      drd  = d* .d%pos
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = sqrt(einv) * einv * exp(-c * d_r2cd * einv)
        normc = normd * .c%cc(cg) * kcd
        Q    = (drd + c * .c%pos) * einv
        QC   = Q - C_tmp
        QCx = QC(1); QCy = QC(2); QCz = QC(3)
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          normb = normc * .b%cc(bg)
          brb   = b* .b%pos
          b_r2ab = b * r2ab
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            kab   = exp(-a * b_r2ab * zinv)
            rho  = zeta * eta / (zeta + eta)
            norm = normb * .a%cc(ag) * sqrt(rho*zinv)*zinv*kab
            if (abs(norm) < SHELL4_ERI_CUTOFF) cycle
            P     = (brb + a* .a%pos) * zinv
            PA    = P - A_tmp
            PAx = PA(1); PAy = PA(2); PAz = PA(3)
            QP   = Q - P
            QPx = QP(1); QPy = QP(2); QPz = QP(3)
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rysa.get_weights(xx)
            do n=1,2
              tmp1 = rysa%r(n) * rho
              tmp2 = tmp1 * zinv
              tmp3 = tmp1 * einv
              tmp4 = HALF * tmp3 * zinv
              Ix12 = QCx - tmp3 * QPx
              Iy12 = QCy - tmp3 * QPy
              Iz12 = QCz - tmp3 * QPz
              Ix21 = PAx + tmp2 * QPx
              Iy21 = PAy + tmp2 * QPy
              Iz21 = PAz + tmp2 * QPz
              Ix22 = Ix12 * Ix21 + tmp4
              Iy22 = Iy12 * Iy21 + tmp4
              Iz22 = Iz12 * Iz21 + tmp4
              weight = rysa%w(n) * norm      ! Merge the wieghts and
              Iz11 =        weight           ! normalization into Iz.
              Iz12 = Iz12 * weight
              Iz21 = Iz21 * weight
              Iz22 = Iz22 * weight
              pspsadd(1,1) = Ix22        * Iz11  ! Combine the 2D integrals.
              pspsadd(2,1) = Ix12 * Iy21 * Iz11  ! Blanked out things are 1.
              pspsadd(3,1) = Ix12        * Iz21
              pspsadd(1,2) = Ix21 * Iy12 * Iz11
              pspsadd(2,2) =        Iy22 * Iz11
              pspsadd(3,2) =        Iy12 * Iz21
              pspsadd(1,3) = Ix21        * Iz12
              pspsadd(2,3) =        Iy21 * Iz12
              pspsadd(3,3) =               Iz22
              psps = psps + pspsadd
            end
          end
        end
      end
    end
    rysa.destroy
  end

  make_esss(esss)
  ! Creates the initial (es|ss) integrals, summed over the primitives.
  ! Don't use this if .a%l + .b%l + .c%l + .d%l < 2.  Use the special routines.
    IN :: self
    VEC, OUT:: esss
    VEC, PTR :: esssadd
    MAT, PTR :: Ix,Iy,Iz
    MAT, PTR :: Iyz
    RYS, PTR :: rysa
    VEC(3) :: P,Q,PA,QP,brb,drd,AB,CD,A_tmp,C_tmp
    DBL :: QP2,a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg,n_e,nroots,eub,maxl,dim,minl
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab
    IMAT, PTR :: e_powers
    IVEC, PTR :: x,y,z

    n_e = .a%l + .b%l
    maxl = max(.a%l,.b%l)
    minl = min(.a%l,.b%l)
    dim = n_e+1
    eub = n_e.n_comp_sum - (maxl-1).n_comp_sum

    nroots = (n_e + 2) / 2
    rysa.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*(dim+1)/2)
    esssadd.create(eub)

    e_powers.create(eub,3)
    x => e_powers(:,1); y => e_powers(:,2); z => e_powers(:,3)
    maxl.make_gaussian_xyz_indices(x,y,z,n_e)

    AB   = .a%pos - .b%pos
    CD   = .c%pos - .d%pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)
    if (.a%l > .b%l) then
      A_tmp = .a%pos
    else
      A_tmp = .b%pos
    end

    esss = ZERO
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      drd  = d* .d%pos
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = sqrt(einv) * einv * exp(-c * d_r2cd * einv)
        normc = normd * .c%cc(cg) * kcd
        Q    = (drd + c * .c%pos) * einv
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          normb = normc * .b%cc(bg)
          brb   = b* .b%pos
          b_r2ab = b * r2ab
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            kab   = exp(-a * b_r2ab * zinv)
            rho  = zeta * eta / (zeta + eta)
            norm = normb * .a%cc(ag) * sqrt(rho*zinv)*zinv*kab
            if (abs(norm) < SHELL4_ERI_CUTOFF) cycle
            P     = (brb + a* .a%pos) * zinv
            PA    = P - A_tmp
            QP   = Q - P
            xx   = rho * dot_product(QP,QP)           ! xx = rho QP^2
            rysa.get_weights(xx)
            rysa%w = rysa%w * norm
            .form_2d_ints_0(Ix,Iy,Iz,nroots,rysa%r,rho,zinv,PA,-QP,n_e)
            .form_esfs_0(Ix,Iy,Iz,Iyz,rysa%w,esssadd,x,y,z,dim,eub,nroots,minl)
            esss = esss + esssadd
          end
        end
      end
    end
    e_powers.destroy
    esssadd.destroy
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rysa.destroy
  end

  make_ssfs(ssfs)
  ! Creates the (ss|fs) integrals, summed over the primitives.
  ! Don't use this if .a%l + .b%l + .c%l + .d%l < 2.  Use the special routines.
    IN :: self
    VEC, OUT:: ssfs
    VEC, PTR :: ssfsadd
    MAT, PTR :: Ix,Iy,Iz
    MAT, PTR :: Iyz
    RYS, PTR :: rysa
    VEC(3) :: P,Q,QC,QP,brb,drd,AB,CD,A_tmp,C_tmp
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg,n_f,nroots,fub,maxl,dim,minl
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab
    IMAT, PTR :: f_powers
    IVEC, PTR :: x,y,z

    n_f = .c%l + .d%l
    maxl = max(.c%l,.d%l)
    minl = min(.c%l,.d%l)
    dim = n_f+1
    fub = n_f.n_comp_sum - (maxl-1).n_comp_sum

    nroots = (n_f+2)/2
    rysa.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*(dim+1)/2)
    ssfsadd.create(fub)

    f_powers.create(fub,3)
    x => f_powers(:,1); y => f_powers(:,2); z => f_powers(:,3)
    maxl.make_gaussian_xyz_indices(x,y,z,n_f)

    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    if (.c%l > .d%l) then
      C_tmp = .c%pos
    else
      C_tmp = .d%pos
    end

    ssfs=ZERO
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      drd  = d* .d%pos
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = sqrt(einv) * einv * exp(-c * d_r2cd * einv)
        normc = normd * .c%cc(cg) * kcd
        Q    = (drd + c * .c%pos) * einv
        QC   = Q - C_tmp
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          normb = normc * .b%cc(bg)
          brb   = b* .b%pos
          b_r2ab = b * r2ab
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            kab   = exp(-a * b_r2ab * zinv)
            rho  = zeta * eta / (zeta + eta)
            norm = normb * .a%cc(ag) * sqrt(rho*zinv)*zinv*kab
            if (abs(norm) < SHELL4_ERI_CUTOFF) cycle
            P     = (brb + a* .a%pos) * zinv
            QP   = Q - P
            xx   = rho * dot_product(QP,QP)              ! xx = rho QP^2
            rysa.get_weights(xx)
            rysa.get_weights(xx)
            rysa%w = rysa%w * norm
            .form_2d_ints_0(Ix,Iy,Iz,nroots,rysa%r,rho,einv,QC,QP,n_f)
            .form_esfs_0(Ix,Iy,Iz,Iyz,rysa%w,ssfsadd,x,y,z,dim,fub,nroots,minl)
            ssfs = ssfs + ssfsadd
          end
        end
      end
    end
    f_powers.destroy
    ssfsadd.destroy
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rysa.destroy
  end

  form_2d_ints_0(Ix,Iy,Iz,nroots,t2,rho,einv,QC,QP,n_f)
  ! Forms the two dimentional integrals, where e = 0 or f = 0.
  ! Don't use this if .a%l + .b%l + .c%l + .d%l < 2.  Use the special routines.
    IN :: self
    MAT, target, OUT :: Ix,Iy,Iz
    VEC, IN :: t2
    DBL, IN :: rho,einv
    INT, IN :: n_f,nroots
    VEC(3), IN :: QC,QP
    VEC(nroots) :: c
    DBL :: ret,cf1,tmp,tmp2
    INT :: f,f1,fp1,n
    VEC, PTR :: Ix2,Iy2,Iz2

    tmp  = rho*einv
    tmp2 = HALF*einv
    Ix2 => Ix(:,2); Iy2 => Iy(:,2); Iz2 => Iz(:,2)
    do n=1,nroots
      ret     = t2(n) * tmp
      c(n) = (ONE - ret) * tmp2
      Ix(n,1) = ONE
      Iy(n,1) = ONE
      Iz(n,1) = ONE
      Ix2(n) = QC(1) - ret * QP(1)
      Iy2(n) = QC(2) - ret * QP(2)
      Iz2(n) = QC(3) - ret * QP(3)
    end
    do f = 2, n_f
      f1  = f - 1
      fp1 = f + 1
      do n=1, nroots
        cf1 = f1 * c(n)
        Ix(n,fp1) = Ix2(n) * Ix(n,f) + cf1 * Ix(n,f1)
        Iy(n,fp1) = Iy2(n) * Iy(n,f) + cf1 * Iy(n,f1)
        Iz(n,fp1) = Iz2(n) * Iz(n,f) + cf1 * Iz(n,f1)
      end
    end
  end

  form_esfs_0(Ix,Iy,Iz,Iyz,weights,esfsadd,fx,fy,fz,dim,fub,nroots,minl)
  ! Forms (es|fs) from the two dimensional integrals for a single
  ! set of primitives, where e = 0 or f = 0.
    IN :: self
    MAT, target :: Ix,Iy,Iz,Iyz
    VEC, IN :: weights
    VEC, OUT :: esfsadd
    IVEC, IN :: fx,fy,fz
    INT, IN :: dim,fub,nroots,minl
    INT :: f,x,y,z,n,dim1,dim2,ii
    DBL :: w,Iz_w
    VEC, PTR :: Izz

    ! Apply the reduced multiplication scheme to merge the Iy and Iz 2d
    ! integrals into a single matrix (upper triangle).
    if (minl > 2) then
      dim1 = dim+1
      dim2 = dim*2
      ii = 0
      do z=1,dim
        Izz => Iz(:,z)
        Izz(:) = Izz(:) * weights(:)  ! Merge the weights into Iz.
        do y=1,dim1-z
          ii = ii + 1
          Iyz(:,ii) = Izz * Iy(:,y)
        end
      end
      do f=1,fub
        x  = fx(f);  y = fy(f);  z = fz(f)
        ii = (y-1)*(dim2 - (y-2))/2 + z
        esfsadd(f)=sum(Ix(:,x) * Iyz(:,ii))
      end
    else
      do z=1,dim
        Izz => Iz(:,z)
        Izz(:) = Izz(:) * weights(:)  ! Merge the weights into Iz.
      end
      do f=1,fub
        x  = fx(f);  y = fy(f);  z = fz(f)
        esfsadd(f)=sum(Ix(:,x) * Iy(:,y) * Iz(:,z))
      end
    end
  end

  make_psss(psss)
  ! Creates the initial (ps|ss) or (sp|ss) integrals, summed over the
  ! primitives.
    IN :: self
    VEC, OUT:: psss
    RYS, PTR :: rysa
    VEC(3) :: P,Q,PA,QP,brb,drd,AB,CD,A_tmp,C_tmp,psssadd
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg
    DBL :: normb,normc,normd,norm,rzt,PAx,PAy,PAz,QPx,QPy,QPz,d_r2cd,b_r2ab

    rysa.create(1)

    AB   = .a%pos - .b%pos
    CD   = .c%pos - .d%pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)
    if (.a%l > .b%l) then
      A_tmp = .a%pos
    else
      A_tmp = .b%pos
    end

    psss = ZERO
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      drd  = d* .d%pos
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = sqrt(einv) * einv * exp(-c * d_r2cd * einv)
        normc = normd * .c%cc(cg) * kcd
        Q    = (drd + c * .c%pos) * einv
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          normb = normc * .b%cc(bg)
          brb   = b* .b%pos
          b_r2ab = b * r2ab
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            kab   = exp(-a * b_r2ab * zinv)
            rho  = zeta * eta / (zeta + eta)
            norm = normb * .a%cc(ag) * sqrt(rho*zinv)*zinv*kab
            if (abs(norm) < SHELL4_ERI_CUTOFF) cycle
            P     = (brb + a* .a%pos) * zinv
            PA    = P - A_tmp
            PAx = PA(1); PAy = PA(2); PAz = PA(3)
            QP   = Q - P
            QPx = QP(1); QPy = QP(2); QPz = QP(3)
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rysa.get_weights(xx)
            rzt = rysa%r(1) * rho * zinv
            psssadd(1) = PAx + rzt * QPx
            psssadd(2) = PAy + rzt * QPy
            psssadd(3) = PAz + rzt * QPz
            psss = psss + norm * rysa%w(1) * psssadd
          end
        end
      end
    end
    rysa.destroy
  end

  make_ssps(ssps)
  ! Creates the (ss|ps) or (ss|sp) integrals, summed over the primitives.
    IN :: self
    VEC, OUT:: ssps
    RYS, PTR :: rysa
    VEC(3) :: P,Q,QC,QP,brb,drd,AB,CD,A_tmp,C_tmp,sspsadd
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg
    DBL :: normb,normc,normd,norm,ret,QCx,QCy,QCz,QPx,QPy,QPz,d_r2cd,b_r2ab

    rysa.create(1)

    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    if (.c%l > .d%l) then
      C_tmp = .c%pos
    else
      C_tmp = .d%pos
    end

    ssps=ZERO
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      drd  = d* .d%pos
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = sqrt(einv) * einv * exp(-c * d_r2cd * einv)
        normc = normd * .c%cc(cg) * kcd
        Q    = (drd + c * .c%pos) * einv
        QC   = Q - C_tmp
        QCx = QC(1); QCy = QC(2); QCz = QC(3)
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          normb = normc * .b%cc(bg)
          brb   = b* .b%pos
          b_r2ab = b * r2ab
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            kab   = exp(-a * b_r2ab * zinv)
            rho  = zeta * eta / (zeta + eta)
            norm = normb * .a%cc(ag) * sqrt(rho*zinv)*zinv*kab
            if (abs(norm) < SHELL4_ERI_CUTOFF) cycle
            P     = (brb + a* .a%pos) * zinv
            QP   = Q - P
            QPx  = QP(1); QPy = QP(2); QPz = QP(3)
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rysa.get_weights(xx)
            ret = rysa%r(1) * rho * einv
            sspsadd(1) = QCx - ret * QPx
            sspsadd(2) = QCy - ret * QPy
            sspsadd(3) = QCz - ret * QPz
            ssps = ssps + norm * rysa%w(1) * sspsadd
          end
        end
      end
    end
    rysa.destroy
  end

  make_ssss_eri(ssss)
  ! Creates the (ss|ss) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: ssss
    RYS, PTR :: rysa
    VEC(3) :: P,Q,QP,brb,drd,AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg
    DBL :: normb,normc,normd,norm,ssssadd,d_r2cd,b_r2ab

    rysa.create(1)

    ssssadd = ZERO
    AB   = .a%pos - .b%pos
    CD   = .c%pos - .d%pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)

    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      drd  = d* .d%pos
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = sqrt(einv) * einv * exp(-c * d_r2cd * einv)
        normc = normd * .c%cc(cg) * kcd
        Q    = (drd + c * .c%pos) * einv
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          normb = normc * .b%cc(bg)
          brb   = b* .b%pos
          b_r2ab = b * r2ab
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            kab   = exp(-a * b_r2ab * zinv)
            rho  = zeta * eta / (zeta + eta)
            norm = normb * .a%cc(ag) * sqrt(rho*zinv)*zinv*kab
            if (abs(norm) < SHELL4_ERI_CUTOFF) cycle
            P     = (brb + a* .a%pos) * zinv
            QP   = Q - P
            xx   = rho * dot_product(QP,QP)          ! xx = rho QP^2
            rysa.get_weights(xx)
            ssssadd = ssssadd + norm * rysa%w(1)
          end
        end
      end
    end
    rysa.destroy
    ssss(1,1,1,1)=ssssadd
  end

  transfer(esfs,escd) [pure]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    if (.c%l > .d%l) then
      .transfer_l_c_highest(esfs,escd)
    else
      .transfer_l_d_highest(esfs,escd)
    end
  end

  transfer(escd,abcd) [pure]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    if (.a%l > .b%l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

  transfer_l_c_highest(esfs,escd) [pure]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3, PTR :: int_new,int_old
    IMAT, allocatable :: momenta
    IMAT3, allocatable :: index
    IVEC(3) :: d_momenta,c_momenta
    VEC(3) :: CD
    INT :: c,d,ld,ld1_n_comp_sum,ld2_n_comp_sum,c1,d1,cub,dub
    INT :: z,n_f,fadd,e,eub,tmp,c2,c3
    DBL :: CDi,CDx,CDy,CDz,tmp2

    select case (.d%l)
      case (0)
        escd(:,:,1)=esfs

      case (1)
        fadd = (.c%l-1).n_comp_sum
        eub = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        cub  = (n_f-1).n_comp_sum - fadd

        allocate(momenta(3, n_f.n_comp_sum))
        tmp=0; tmp.make_gaussian_xyz_powers(momenta,n_f)
        allocate(index(0:n_f,0:n_f,0:n_f))
        index.make_index_of_components(momenta)

        CDx = CD(1)
        CDy = CD(2)
        CDz = CD(3)
        do c = 1, cub
          c_momenta    = momenta(:,c+fadd)
          c1 = index(c_momenta(1)+1,c_momenta(2),c_momenta(3)) - fadd
          c2 = index(c_momenta(1),c_momenta(2)+1,c_momenta(3)) - fadd
          c3 = index(c_momenta(1),c_momenta(2),c_momenta(3)+1) - fadd
          do e = 1, eub
            tmp2 = esfs(e,c)
            escd(e,c,1) = esfs(e,c1) + CDx * tmp2
            escd(e,c,2) = esfs(e,c2) + CDy * tmp2
            escd(e,c,3) = esfs(e,c3) + CDz * tmp2
          end
        end

!        do d = 1, 3
!          z   = momenta(:,d+1).first_nonzero_component
!          CDi = CD(z)
!          do c = 1, cub
!            c_momenta    = momenta(:,c+fadd)
!            c_momenta(z) = c_momenta(z) + 1
!            c1 = index(c_momenta(1),c_momenta(2),c_momenta(3)) - fadd
!            do e = 1, eub
!              escd(e,c,d) = esfs(e,c1) + CDi * esfs(e,c)
!            end
!          end
!        end
        deallocate(momenta)
        deallocate(index)

      case default
        fadd = (.c%l-1).n_comp_sum
        eub = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        cub  = (n_f-1).n_comp_sum - fadd

        allocate(momenta(3, n_f.n_comp_sum))
        tmp=0; tmp.make_gaussian_xyz_powers(momenta,n_f)
        allocate(index(0:n_f,0:n_f,0:n_f))
        index.make_index_of_components(momenta)

        nullify(int_new)
        allocate(int_new(eub,cub,3))

        CDx = CD(1);   CDy = CD(2);   CDz = CD(3)
        do c = 1, cub
          c_momenta = momenta(:,c+fadd)
          c1 = index(c_momenta(1)+1,c_momenta(2),c_momenta(3)) - fadd
          c2 = index(c_momenta(1),c_momenta(2)+1,c_momenta(3)) - fadd
          c3 = index(c_momenta(1),c_momenta(2),c_momenta(3)+1) - fadd
          do e = 1, eub
            tmp2 = esfs(e,c)
            int_new(e,c,1) = esfs(e,c1) + CDx * tmp2
            int_new(e,c,2) = esfs(e,c2) + CDy * tmp2
            int_new(e,c,3) = esfs(e,c3) + CDz * tmp2
          end
        end

!        do d=1,3
!          z=momenta(:,d+1).first_nonzero_component
!          CDi=CD(z)
!          do c=1,cub
!            c_momenta=momenta(:,c+fadd)
!            c_momenta(z)=c_momenta(z)+1
!            c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-fadd
!            do e=1,eub
!              int_new(e,c,d)=esfs(e,c1)+CDi*esfs(e,c)
!            end
!          end
!        end
        do ld=2, .d%l - 1
          ld1_n_comp_sum = (ld-1).n_comp_sum
          ld2_n_comp_sum = (ld-2).n_comp_sum
          dub            = ld.n_comp
          cub            = (n_f-ld).n_comp_sum - fadd
          int_old=>int_new
          nullify(int_new)
          allocate(int_new(eub,cub,dub))
          do d=1,dub
            d_momenta=momenta(:,d+ld1_n_comp_sum)
            z=d_momenta.first_nonzero_component
            d_momenta(z)=d_momenta(z)-1
            d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-ld2_n_comp_sum
            CDi=CD(z)
            do c=1,cub
              c_momenta=momenta(:,c+fadd)
              c_momenta(z)=c_momenta(z)+1
              c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-fadd
              do e=1,eub
                int_new(e,c,d)=int_old(e,c1,d1)+CDi*int_old(e,c,d1)
              end
            end
          end
          deallocate(int_old)
        end

        ld1_n_comp_sum = (.d%l-1).n_comp_sum
        ld2_n_comp_sum = (.d%l-2).n_comp_sum
        dub            = .d%n_comp
        cub            = .c%n_comp
        int_old=>int_new
        do d=1,dub
          d_momenta=momenta(:,d+ld1_n_comp_sum)
          z=d_momenta.first_nonzero_component
          d_momenta(z)=d_momenta(z)-1
          d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-ld2_n_comp_sum
          CDi=CD(z)
          do c=1,cub
            c_momenta=momenta(:,c+fadd)
            c_momenta(z)=c_momenta(z)+1
            c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-fadd
            do e=1,eub
              escd(e,c,d)=int_old(e,c1,d1)+CDi*int_old(e,c,d1)
            end
          end
        end
        deallocate(int_old)
        deallocate(momenta)
        deallocate(index)
    end
  end

  transfer_l_d_highest(esfs,escd) [pure]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3, PTR :: int_new,int_old
    IMAT, allocatable :: momenta
    IMAT3, allocatable :: index
    IVEC(3) :: d_momenta,c_momenta
    VEC(3) :: CD
    INT :: c,d,lc,lc1_n_comp_sum,lc2_n_comp_sum,c1,d1,cub,dub
    INT :: z,n_f,fadd,e,eub,tmp
    DBL :: DCi

    select case (.c%l)
      case (0)
        escd(:,1,:)=esfs

      case (1)
        fadd = (.d%l-1).n_comp_sum
        eub = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        dub  = (n_f-1).n_comp_sum - fadd

        allocate(momenta(3, n_f.n_comp_sum))
        tmp=0; tmp.make_gaussian_xyz_powers(momenta,n_f)
        allocate(index(0:n_f,0:n_f,0:n_f))
        index.make_index_of_components(momenta)

        do c=1,3
          z=momenta(:,c+1).first_nonzero_component
          DCi=-CD(z)
          do d=1,dub
            d_momenta=momenta(:,d+fadd)
            d_momenta(z)=d_momenta(z)+1
            d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-fadd
            do e=1,eub
              escd(e,c,d)=esfs(e,d1)+DCi*esfs(e,d)
            end
          end
        end
        deallocate(momenta)
        deallocate(index)

      case default
        fadd = (.d%l-1).n_comp_sum
        eub = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        dub  = (n_f-1).n_comp_sum - fadd

        allocate(momenta(3, n_f.n_comp_sum))
        tmp=0; tmp.make_gaussian_xyz_powers(momenta,n_f)
        allocate(index(0:n_f,0:n_f,0:n_f))
        index.make_index_of_components(momenta)

        nullify(int_new)
        allocate(int_new(eub,3,dub))
        do c=1,3
          z=momenta(:,c+1).first_nonzero_component
          DCi=-CD(z)
          do d=1,dub
            d_momenta=momenta(:,d+fadd)
            d_momenta(z)=d_momenta(z)+1
            d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-fadd
            do e=1,eub
              int_new(e,c,d)=esfs(e,d1)+DCi*esfs(e,d)
            end
          end
        end
        do lc=2, .c%l - 1
          lc1_n_comp_sum = (lc-1).n_comp_sum
          lc2_n_comp_sum = (lc-2).n_comp_sum
          cub            = lc.n_comp
          dub            = (n_f-lc).n_comp_sum - fadd
          int_old=>int_new
          nullify(int_new)
          allocate(int_new(eub,cub,dub))
          do c=1,cub
            c_momenta=momenta(:,c+lc1_n_comp_sum)
            z=c_momenta.first_nonzero_component
            c_momenta(z)=c_momenta(z)-1
            c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-lc2_n_comp_sum
            DCi=-CD(z)
            do d=1,dub
              d_momenta=momenta(:,d+fadd)
              d_momenta(z)=d_momenta(z)+1
              d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-fadd
              do e=1,eub
                int_new(e,c,d)=int_old(e,c1,d1)+DCi*int_old(e,c1,d)
              end
            end
          end
          deallocate(int_old)
        end
        lc1_n_comp_sum = (.c%l-1).n_comp_sum
        lc2_n_comp_sum = (.c%l-2).n_comp_sum
        cub            = .c%n_comp
        dub            = .d%n_comp
        int_old=>int_new
        do c=1,cub
          c_momenta=momenta(:,c+lc1_n_comp_sum)
          z=c_momenta.first_nonzero_component
          c_momenta(z)=c_momenta(z)-1
          c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-lc2_n_comp_sum
          DCi=-CD(z)
          do d=1,dub
            d_momenta=momenta(:,d+fadd)
            d_momenta(z)=d_momenta(z)+1
            d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-fadd
            do e=1,eub
              escd(e,c,d)=int_old(e,c1,d1)+DCi*int_old(e,c1,d)
            end
          end
        end
        deallocate(int_old)
        deallocate(momenta)
        deallocate(index)
    end
  end

  transfer_l_a_highest(escd,abcd) [pure]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4, PTR :: int_new,int_old
    IMAT, allocatable :: momenta
    IMAT3, allocatable :: index
    IVEC(3) :: a_momenta,b_momenta
    VEC(3) :: AB
    INT :: a1,b1,lb1_n_comp_sum,lb2_n_comp_sum,a,b,c,d,lb,aub,bub
    INT :: z,n_e,eadd,cub,dub,tmp
    DBL :: ABi

    select case (.b%l)
      case (0)
        abcd(:,1,:,:)=escd

      case (1)
        eadd = (.a%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        aub  = (n_e-1).n_comp_sum - eadd
        cub  = .c%n_comp
        dub  = .d%n_comp

        allocate(momenta(3, n_e.n_comp_sum))
        tmp=0; tmp.make_gaussian_xyz_powers(momenta,n_e)
        allocate(index(0:n_e,0:n_e,0:n_e))
        index.make_index_of_components(momenta)

        do b=1,3
          z=momenta(:,b+1).first_nonzero_component
          ABi=AB(z)
          do a=1,aub
            a_momenta=momenta(:,a+eadd)
            a_momenta(z)=a_momenta(z)+1
            a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=escd(a1,c,d) + ABi * escd(a,c,d)
            end
          end
        end
        deallocate(momenta)
        deallocate(index)

      case default
        eadd = (.a%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        aub  = (n_e-1).n_comp_sum - eadd
        bub  = .b%n_comp
        cub  = .c%n_comp
        dub  = .d%n_comp

        allocate(momenta(3, n_e.n_comp_sum))
        tmp=0; tmp.make_gaussian_xyz_powers(momenta,n_e)
        allocate(index(0:n_e,0:n_e,0:n_e))
        index.make_index_of_components(momenta)

        nullify(int_new)
        allocate(int_new(aub,bub,cub,dub))
        do b=1,3
          z=momenta(:,b+1).first_nonzero_component
          ABi=AB(z)
          do a=1,aub
            a_momenta=momenta(:,a+eadd)
            a_momenta(z)=a_momenta(z)+1
            a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              int_new(a,b,c,d)=escd(a1,c,d) + ABi * escd(a,c,d)
            end
          end
        end

        do lb=2, .b%l - 1
          lb1_n_comp_sum = (lb-1).n_comp_sum
          lb2_n_comp_sum = (lb-2).n_comp_sum
          bub            = lb.n_comp
          aub            = (n_e-lb).n_comp_sum - eadd
          int_old=>int_new
          nullify(int_new)
          allocate(int_new(aub,bub,cub,dub))
          do b=1,bub
            b_momenta=momenta(:,b+lb1_n_comp_sum)
            z=b_momenta.first_nonzero_component
            b_momenta(z)=b_momenta(z)-1
            b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-lb2_n_comp_sum
            ABi=AB(z)
            do a=1,aub
              a_momenta=momenta(:,a+eadd)
              a_momenta(z)=a_momenta(z)+1
              a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-eadd
              forall (c=1:cub, d=1:dub)
                int_new(a,b,c,d)=int_old(a1,b1,c,d) + ABi * int_old(a,b1,c,d)
              end
            end
          end
          deallocate(int_old)
        end
        lb1_n_comp_sum = (.b%l-1).n_comp_sum
        lb2_n_comp_sum = (.b%l-2).n_comp_sum
        bub            = .b%n_comp
        aub            = .a%n_comp
        int_old=>int_new
        do b=1,bub
          b_momenta=momenta(:,b+lb1_n_comp_sum)
          z=b_momenta.first_nonzero_component
          b_momenta(z)=b_momenta(z)-1
          b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-lb2_n_comp_sum
          ABi=AB(z)
          do a=1,aub
            a_momenta=momenta(:,a+eadd)
            a_momenta(z)=a_momenta(z)+1
            a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=int_old(a1,b1,c,d) + ABi * int_old(a,b1,c,d)
            end
          end
        end
        deallocate(int_old)
        deallocate(momenta)
        deallocate(index)
    end
  end

  transfer_l_b_highest(escd,abcd) [pure]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4, PTR :: int_new,int_old
    IMAT, allocatable :: momenta
    IMAT3, allocatable :: index
    IVEC(3) :: a_momenta,b_momenta
    VEC(3) :: AB
    INT :: a1,b1,la1_n_comp_sum,la2_n_comp_sum,a,b,c,d,la,aub,bub
    INT :: z,n_e,eadd,cub,dub,tmp,b2,b3
    DBL :: BAi,BAx,BAy,BAz,tmp2

    select case (.a%l)
      case (0)
        abcd(1,:,:,:)=escd

      case (1)
        eadd = (.b%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        bub  = (n_e-1).n_comp_sum - eadd
        cub  = .c%n_comp
        dub  = .d%n_comp

        allocate(momenta(3, n_e.n_comp_sum))
        tmp=0; tmp.make_gaussian_xyz_powers(momenta,n_e)
        allocate(index(0:n_e,0:n_e,0:n_e))
        index.make_index_of_components(momenta)

        BAx = -AB(1);    BAy = -AB(2);    BAz = -AB(3)
        do b = 1, bub
          b_momenta = momenta(:,b+eadd)
          b1 = index(b_momenta(1)+1,b_momenta(2),b_momenta(3)) - eadd
          b2 = index(b_momenta(1),b_momenta(2)+1,b_momenta(3)) - eadd
          b3 = index(b_momenta(1),b_momenta(2),b_momenta(3)+1) - eadd
          do d = 1, dub
            do c = 1, cub
              tmp2 = escd(b,c,d)
              abcd(1,b,c,d) = escd(b1,c,d) + BAx * tmp2
              abcd(2,b,c,d) = escd(b2,c,d) + BAy * tmp2
              abcd(3,b,c,d) = escd(b3,c,d) + BAz * tmp2
            end
          end
        end

!        do a=1,3
!          z=momenta(:,a+1).first_nonzero_component
!          BAi=-AB(z)
!          do b=1,bub
!            b_momenta=momenta(:,b+eadd)
!            b_momenta(z)=b_momenta(z)+1
!            b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-eadd
!            forall (c=1:cub, d=1:dub)
!              abcd(a,b,c,d)=escd(b1,c,d) + BAi * escd(b,c,d)
!            end
!          end
!        end

        deallocate(momenta)
        deallocate(index)

      case default
        eadd = (.b%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        bub  = (n_e-1).n_comp_sum - eadd
        aub  = .a%n_comp
        cub  = .c%n_comp
        dub  = .d%n_comp

        allocate(momenta(3, n_e.n_comp_sum))
        tmp=0; tmp.make_gaussian_xyz_powers(momenta,n_e)
        allocate(index(0:n_e,0:n_e,0:n_e))
        index.make_index_of_components(momenta)

        nullify(int_new)
        allocate(int_new(aub,bub,cub,dub))

        BAx = -AB(1);    BAy = -AB(2);    BAz = -AB(3)
        do b = 1, bub
          b_momenta = momenta(:,b+eadd)
          b1 = index(b_momenta(1)+1,b_momenta(2),b_momenta(3)) - eadd
          b2 = index(b_momenta(1),b_momenta(2)+1,b_momenta(3)) - eadd
          b3 = index(b_momenta(1),b_momenta(2),b_momenta(3)+1) - eadd
          do d = 1, dub
            do c = 1, cub
              tmp2 = escd(b,c,d)
              int_new(1,b,c,d) = escd(b1,c,d) + BAx * tmp2
              int_new(2,b,c,d) = escd(b2,c,d) + BAy * tmp2
              int_new(3,b,c,d) = escd(b3,c,d) + BAz * tmp2
            end
          end
        end

!        do a=1,3
!          z=momenta(:,a+1).first_nonzero_component
!          BAi=-AB(z)
!          do b=1,bub
!            b_momenta=momenta(:,b+eadd)
!            b_momenta(z)=b_momenta(z)+1
!            b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-eadd
!            forall (c=1:cub, d=1:dub)
!              int_new(a,b,c,d)=escd(b1,c,d) + BAi * escd(b,c,d)
!            end
!          end
!        end

        do la=2, .a%l - 1
          la1_n_comp_sum = (la-1).n_comp_sum
          la2_n_comp_sum = (la-2).n_comp_sum
          aub            = la.n_comp
          bub            = (n_e-la).n_comp_sum - eadd
          int_old=>int_new
          nullify(int_new)
          allocate(int_new(aub,bub,cub,dub))
          do a=1,aub
            a_momenta=momenta(:,a+la1_n_comp_sum)
            z=a_momenta.first_nonzero_component
            a_momenta(z)=a_momenta(z)-1
            a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-la2_n_comp_sum
            BAi=-AB(z)
            do b=1,bub
              b_momenta=momenta(:,b+eadd)
              b_momenta(z)=b_momenta(z)+1
              b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-eadd
              forall (c=1:cub, d=1:dub)
                int_new(a,b,c,d)=int_old(a1,b1,c,d) + BAi * int_old(a1,b,c,d)
              end
            end
          end
          deallocate(int_old)
        end
        la1_n_comp_sum = (.a%l-1).n_comp_sum
        la2_n_comp_sum = (.a%l-2).n_comp_sum
        aub            = .a%n_comp
        bub            = .b%n_comp
        int_old=>int_new
        do a=1,aub
          a_momenta=momenta(:,a+la1_n_comp_sum)
          z=a_momenta.first_nonzero_component
          a_momenta(z)=a_momenta(z)-1
          a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-la2_n_comp_sum
          BAi=-AB(z)
          do b=1,bub
            b_momenta=momenta(:,b+eadd)
            b_momenta(z)=b_momenta(z)+1
            b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=int_old(a1,b1,c,d) + BAi * int_old(a1,b,c,d)
            end
          end
        end
        deallocate(int_old)
        deallocate(momenta)
        deallocate(index)
    end
  end

  to_normalize(abcd)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, b, c and d.
    IN :: self
    MAT4, target :: abcd
    VEC, PTR :: anorm,bnorm,cnorm,dnorm
    INT :: aub,bub,cub,dub,a,b,c,d,opt
    DBL :: normb,normc,normd
    MAT, PTR :: ab_cd

    opt = 0
    if (.a%l + .b%l == 0) opt = opt + 1
    if (.c%l + .d%l == 0) opt = opt + 2
    select case (opt)
      case (0)                                      ! The general routine.
        aub=.a%n_comp
        bub=.b%n_comp
        cub=.c%n_comp
        dub=.d%n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a%l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b%l )
        cnorm.create(cub);   cnorm.normalizing_factors( .c%l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d%l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            normc=normd*cnorm(c)
            ab_cd => abcd(:,:,c,d)
            do b=1,bub
              normb=normc*bnorm(b)
              ab_cd(:,b)=ab_cd(:,b)*normb*anorm(:)
            end
          end
        end
        anorm.destroy; bnorm.destroy; cnorm.destroy; dnorm.destroy
      case (1)                                      ! .a%l = .b%l = 0
        cub = .c%n_comp
        dub = .d%n_comp
        cnorm.create(cub);   cnorm.normalizing_factors( .c%l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d%l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            abcd(1,1,c,d)=abcd(1,1,c,d)*normd*cnorm(c)
          end
        end
        cnorm.destroy; dnorm.destroy
      case (2)                                      ! .c%l = .d%l = 0
        aub = .a%n_comp
        bub = .b%n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a%l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b%l )
        do b=1,bub
          normb=bnorm(b)
          abcd(:,b,1,1)=abcd(:,b,1,1)*normb*anorm(:)
        end
        anorm.destroy; bnorm.destroy
      case (3)                                 ! .a%l = .b%l = .c%l = .d%l = 0
        ! do nothing
    end
  end

end
