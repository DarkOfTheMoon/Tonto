! $Id$
!---------------------------------------------------------------------------
!  Matrix operations ...
!  (c) dylan jayatilaka, 1996
!---------------------------------------------------------------------------
module MAT

   use TYPES
   use ERROR
   use MM
   use VEC
   use IVEC

   implicit none         

#  include "macros"
#  include "mat.int"

!  define MAT(A,B)   ARRAY2(DBL,A,B)

contains

   create(dim1,dim2)
   ! Create a matrix with dimensions "dim1" and "dim2"
      PTR :: self
      INT, IN :: dim1,dim2
      nullify(self)
      allocate(self(dim1,dim2))
      std_mm.add(dim1*dim2*DBL_SIZE)
   end

   create(lb1,ub1,lb2,ub2)
   ! Create a matrix with the given bounds
      PTR :: self
      INT, IN :: lb1,ub1,lb2,ub2
      nullify(self)
      allocate(self(lb1:ub1,lb2:ub2))
      std_mm.add((ub1-lb1+1)*(ub2-lb2+1)*DBL_SIZE)
   end

   create(bounds1,bounds2)
   ! Create a matrix with the given bounds for each dimension
      PTR :: self
      IVEC(2), IN :: bounds1,bounds2
      .create(bounds1(1),bounds1(2),bounds2(1),bounds2(2))
   end

   create(bounds)
   ! Create a matrix with the given bounds for all dimensions
      PTR :: self
      IMAT(2,2), IN :: bounds
      .create(bounds(1,1),bounds(1,2),bounds(2,1),bounds(2,2))
   end

   destroy
   ! Destroy a matrix
      PTR :: self
      if (.destroyed) return
      std_mm.delete(size(self)*DBL_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   determinant result(res)
   ! Return the cofactor fo a 3x3 matrix
      DBL :: res
      INT :: dim1,dim2
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dim1<4,"only works for up to size 3 matrices")
      select case (dim1)
          case (1)
             res = self(1,1)
          case (2)
             res = self(1,1)*self(2,2) - self(2,1)*self(1,2)
          case (3)
             res = self(1,3)*(self(2,1)*self(3,2) - self(3,1)*self(2,2) ) &
                 + self(2,3)*(self(3,1)*self(1,2) - self(1,1)*self(3,2) ) &
                 + self(3,3)*(self(1,1)*self(2,2) - self(2,1)*self(1,2) )
      end
   end

   cofactor result(res)
   ! Return the cofactor fo a 3x3 matrix
      MAT, PTR :: res
      INT :: dim1,dim2
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dim1==3,"only works for 3x3 matrices")
      nullify(res)
      res.create(3,3)
      res(1,1) =  (self(2,2)*self(3,3) - self(2,3)*self(3,2))
      res(1,2) = -(self(2,1)*self(3,3) - self(2,3)*self(3,1))
      res(1,3) =  (self(2,1)*self(3,2) - self(2,2)*self(3,1))
      res(2,1) = -(self(1,2)*self(3,3) - self(1,3)*self(3,2))
      res(2,2) =  (self(1,1)*self(3,3) - self(1,3)*self(3,1))
      res(2,3) = -(self(1,1)*self(3,2) - self(1,2)*self(3,1))
      res(3,1) =  (self(1,2)*self(2,3) - self(1,3)*self(2,2))
      res(3,2) = -(self(1,1)*self(2,3) - self(1,3)*self(2,1))
      res(3,3) =  (self(1,1)*self(2,2) - self(1,2)*self(2,1))
   end

   to_product(mat_a,mat_b,transpose_a,transpose_b)
   ! Set "self" to the matrix product of "mat_a" and "mat_b". If present,
   ! "transpose_a" and "transpose_b" can be set to TRUE if "mat_a" and "mat_b"
   ! neeb to be transposed.
      MAT :: mat_a, mat_b
      BIN, optional :: transpose_a, transpose_b
      INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,dim2,i,j,k
      BIN :: trans_a,trans_b

      trans_a = FALSE;       trans_b = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      if (present(transpose_b)) trans_b = transpose_b

      dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
      dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
      dim1   = size(self,1);            dim2 = size(self,2)

      if (trans_a) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        if (trans_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + mat_a(k,i) * mat_b(j,k)
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + mat_a(k,i) * mat_b(k,j)
              end
            end
          end
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        if (trans_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + mat_a(i,k) * mat_b(j,k)
              end
            end
          end
        else
          ENSURE(dim1==dim_a1,"array dimensions do not agree")
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + mat_a(i,k) * mat_b(k,j)
              end
            end
          end
        end
      end
   end

  to_product(a)
  ! Multiply the matrix by the scalar "a".
    DBL, IN :: a
    self = a * self
  end

   to_scaled_product(fac,mat_a,mat_b,transpose_a,transpose_b)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
      MAT :: mat_a, mat_b
      DBL :: fac
      BIN, optional :: transpose_a, transpose_b
      INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,dim2,i,j,k
      BIN :: trans_a,trans_b

      trans_a = FALSE;       trans_b = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      if (present(transpose_b)) trans_b = transpose_b

      dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
      dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
      dim1   = size(self,1);            dim2 = size(self,2)

      if (trans_a) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        if (trans_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + fac * mat_a(k,i) * mat_b(j,k)
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + fac * mat_a(k,i) * mat_b(k,j)
              end
            end
          end
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        if (trans_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + fac * mat_a(i,k) * mat_b(j,k)
              end
            end
          end
        else
          ENSURE(dim1==dim_a1,"array dimensions do not agree")
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
          self = ZERO
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + fac * mat_a(i,k) * mat_b(k,j)
              end
            end
          end
        end
      end
   end

   plus_product(mat_a,mat_b,transpose_a,transpose_b)
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a" 
   ! and "transpose_b" can be set to TRUE if "a" and "b" neeb to be transposed.
      MAT :: mat_a, mat_b
      BIN, optional :: transpose_a, transpose_b
      INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,dim2,i,j,k
      BIN :: trans_a,trans_b

      trans_a = FALSE;       trans_b = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      if (present(transpose_b)) trans_b = transpose_b

      dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
      dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
      dim1   = size(self,1);            dim2 = size(self,2)

      if (trans_a) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        if (trans_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + mat_a(k,i) * mat_b(j,k)
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + mat_a(k,i) * mat_b(k,j)
              end
            end
          end
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        if (trans_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + mat_a(i,k) * mat_b(j,k)
              end
            end
          end
        else
          ENSURE(dim1==dim_a1,"array dimensions do not agree")
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + mat_a(i,k) * mat_b(k,j)
              end
            end
          end
        end
      end
   end
      
   plus_scaled_product(fac,mat_a,mat_b,transpose_a,transpose_b)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
      MAT :: mat_a, mat_b
      DBL :: fac
      BIN, optional :: transpose_a, transpose_b
      INT :: dim_a1,dim_a2,dim_b1,dim_b2,dim1,dim2,i,j,k
      BIN :: trans_a,trans_b

      trans_a = FALSE;       trans_b = FALSE
      if (present(transpose_a)) trans_a = transpose_a
      if (present(transpose_b)) trans_b = transpose_b

      dim_a1 = size(mat_a,1);           dim_a2 = size(mat_a,2)
      dim_b1 = size(mat_b,1);           dim_b2 = size(mat_b,2)
      dim1   = size(self,1);            dim2 = size(self,2)

      if (trans_a) then
        ENSURE(dim1==dim_a2,"array dimensions do not agree")
        if (trans_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + fac * mat_a(k,i) * mat_b(j,k)
              end
            end
          end
        else
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a1
                self(i,j) = self(i,j) + fac * mat_a(k,i) * mat_b(k,j)
              end
            end
          end
        end
      else
        ENSURE(dim1==dim_a1,"array dimensions do not agree")
        if (trans_b) then
          ENSURE(dim2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + fac * mat_a(i,k) * mat_b(j,k)
              end
            end
          end
        else
          ENSURE(dim1==dim_a1,"array dimensions do not agree")
          ENSURE(dim2==dim_b2,"array dimensions do not agree")
          ENSURE(dim_a2==dim_b1,"array dimensions do not agree")
          do i=1,dim1
            do j=1,dim2
              do k=1,dim_a2
                self(i,j) = self(i,j) + fac * mat_a(i,k) * mat_b(k,j)
              end
            end
          end
        end
      end
   end

   to_product_with_diagonal(a,diag,transpose_a)
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, "transpose_a" can be set to TRUE if "a" needs to
   ! be transposed.
      MAT :: a
      VEC :: diag
      BIN, optional :: transpose_a
      INT :: a1,a2,s1,s2,d1,i,j
      s1 = size(self,1); s2 = size(self,2)
      a1 = size(a,1);    a2 = size(a,2)
      d1 = size(diag)
      ENSURE(s1==a1 AND s2==a2,"incompatible dimensions")
      if (present(transpose_a)) then
         ENSURE(a1==d1,"incompatible dimensions")
         forall (i=1:s1, j=1:s2)
            self(i,j) = a(j,i)*diag(j)
         end
      else
         ENSURE(a2==d1,"incompatible dimensions")
         forall (i=1:s1, j=1:s2)
            self(i,j) = a(i,j)*diag(j)
         end
      end
   end

   to_product_with_diagonal(dg,a,transpose_a)
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      MAT :: a
      VEC :: dg
      BIN, optional :: transpose_a
      INT :: a1,a2,s1,s2,d1,i,j
      s1 = size(self,1); s2 = size(self,2)
      a1 = size(a,1);    a2 = size(a,2)
      d1 = size(dg)
      ENSURE(s1==a1 AND s2==a2,"incompatible dimensions")
      if (present(transpose_a)) then
         ENSURE(a2==d1,"incompatible dimensions")
         forall (i=1:s1, j=1:s2)
            self(i,j) = dg(i)*a(j,i)
         end
      else
         ENSURE(a1==d1,"incompatible dimensions")
         forall (i=1:s1, j=1:s2)
            self(i,j) = dg(i)*a(i,j)
         end
      end
   end

   trace result (res)
   ! Return the trace of "self" 
      DBL :: res
      INT :: dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      res = ZERO
      do i = 1,dim1
         res = res + self(i,i)
      end
   end
       
   solve_eigenproblem(eigenvalues,eigenvectors)
   ! Solve the symmetric eigenproblem for "self", yeilding a vector of "eigenvalues" and
   ! a matrix of "eigenvectors"
      VEC :: eigenvalues
      MAT :: eigenvectors
      VEC, PTR :: W
      INT :: dim1,dim2,dime,dimv,fail,lwork
      dim1 = size(self,1)
      dim2 = size(self,2)
      dime = size(eigenvalues)
      dimv = size(eigenvectors)
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dime>=dim1,"supplied eigenvalue array too small")
      ENSURE(dimv>=dim1*dim1,"supplied eigenvector matrix too small")
      lwork = max(dim1*dim1,3*dim1-1)
      W.create(lwork)
      eigenvectors = self
      fail = 0
      call dsyev("V","L",dim1,eigenvectors,dim1,eigenvalues,W,lwork,fail)
      ENSURE(fail==0,"no solution, error found")
      W.destroy
   end

   solve_linear_equations(rhs,solution)
   ! Solve the linear equations posed by "self", with "rhs" as the RHS vector,
   ! yeilding vector "solution" as the answer
      VEC :: rhs, solution
      INT :: err,nrhs
      MAT, PTR :: LU
      IVEC, PTR :: pivot
      INT :: dim,dim1,dim2
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      dim = size(rhs)
      ENSURE(dim==dim1,"incompatible rhs")
      nrhs = 1
      nullify(LU); LU.create(dim,dim)
      nullify(pivot); pivot.create(dim)
      LU = self
      solution = rhs
      call dgesv(dim,nrhs,LU,dim,pivot,solution,dim,err)
      ENSURE(err==0,"no solution, error found")
      pivot.destroy
      LU.destroy
   end
      
   solve_linear_equations(rhs,solution)
   ! Solve the linear equations posed by "self", with "rhs" as a matrix of RHS vectors,
   ! yeilding matrix "solution" as a matrix of solution vectors.
      MAT :: rhs, solution
      INT :: err,nrhs
      MAT, PTR :: LU
      IVEC, PTR :: pivot
      INT :: dim1,dim2
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      dim1 = size(rhs,1)
      nrhs = size(rhs,2)
      ENSURE(dim1==dim2,"rhs incompatible with coefficient matrix")
      ENSURE(nrhs>0,"no rhs vectors")
      LU.create(dim1,dim1)
      pivot.create(dim1)
      LU = self
      solution = rhs
      call dgesv(dim1,nrhs,LU,dim1,pivot,solution,dim1,err)
      ENSURE(err==0,"no solution, error found")
      pivot.destroy
      LU.destroy
   end

! Dylan's IBM stuff.  Doesn't work on DEC      
!   solve_eigenproblem(eigenvalues,eigenvectors)
!   ! Solve the symmetric eigenproblem for "self", yeilding a vector of
!   ! "eigenvalues" and a matrix of "eigenvectors"
!      VEC :: eigenvalues
!      MAT :: eigenvectors
!      VEC, PTR :: ap,W
!      INT :: dim1,dim2,dime,dimv
!      dim1 = size(self,1)
!      dim2 = size(self,2)
!      dime = size(eigenvalues)
!      dimv = size(eigenvectors)
!      ENSURE(dim1==dim2,"non-square matrix")
!      ENSURE(dime>=dim1,"supplied eigenvalue array too small")
!      ENSURE(dimv>=dim1*dim1,"supplied eigenvector matrix too small")
!      ap.create(dim1*(dim1+1)/2)
!      self.to_tri(ap)
!      W.create(2*dim1)
!      call dspev(21,ap,eigenvalues,eigenvectors,dim1,dim1,W,2*dim1)
!      W.destroy
!      ap.destroy
!   end
      
   solve_general_eigenproblem(eigenvalues,eigenvectors)
   ! Solve the eigenproblem for "self", yeilding a vector of "eigenvalues" and
   ! a matrix of "eigenvectors"
      CVEC :: eigenvalues
      CMAT :: eigenvectors
      VEC, PTR :: W
      INT :: dim1,dim2,dime,dimv
      BIN :: select
      dim1 = size(self,1)
      dim2 = size(self,2)
      dime = size(eigenvalues)
      dimv = size(eigenvectors)
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dime>=dim1,"supplied eigenvalue array too small")
      ENSURE(dimv>=dim1*dim1,"supplied eigenvector matrix too small")
      W.create(2*dim1)
      call dgeev(1,self,dim1,eigenvalues,eigenvectors,dim1,select,dim1,W,2*dim1)
      W.destroy
   end
      
! Dylan's IBM stuff.  Doesn't work on DEC      
!   solve_linear_equations(rhs,solution)
!   ! Solve the linear equations posed by "self", with "rhs" as the RHS vector,
!   ! yeilding vector "solution" as the answer
!      VEC :: rhs, solution
!      INT :: err,nrhs
!      MAT, PTR :: LU
!      IVEC, PTR :: pivot
!      INT :: dim,dim1,dim2
!      dim1 = size(self,1)
!      dim2 = size(self,2)
!      ENSURE(dim1==dim2,"non-square matrix")
!      dim = size(rhs)
!      ENSURE(dim==dim1,"incompatible rhs")
!      nrhs = 1
!      LU.create(dim,dim)
!      pivot.create(dim)
!      LU = self
!      solution = rhs
!      call dgef(LU,dim,dim,pivot)
!      call dges(LU,dim,dim,pivot,solution,0)
!      pivot.destroy
!      LU.destroy
!   end
!      
!   solve_linear_equations(rhs,solution)
!   ! Solve the linear equations posed by "self", with "rhs" as a matrix of RHS
!   ! vectors, yeilding matrix "solution" as a matrix of solution vectors.
!      MAT :: rhs, solution
!      INT :: err,nrhs
!      MAT, PTR :: LU
!      IVEC, PTR :: pivot
!      INT :: dim1,dim2
!      dim1 = size(self,1)
!      dim2 = size(self,2)
!      ENSURE(dim1==dim2,"non-square matrix")
!      dim1 = size(rhs,1)
!      nrhs = size(rhs,2)
!      ENSURE(dim1==dim2,"rhs incompatible with coefficient matrix")
!      ENSURE(nrhs>0,"no rhs vectors")
!      LU.create(dim1,dim1)
!      pivot.create(dim1)
!      LU = self
!      solution = rhs
!      call dgef(LU,dim1,dim1,pivot)
!      call dgesm("N",LU,dim1,dim1,pivot,solution,dim1,nrhs)
!      pivot.destroy
!      LU.destroy
!   end
      
   trace_product_with(b) result (res)
   ! Return the trace of the product of "self" with matrix b.
      MAT :: b 
      DBL :: res
      INT :: a1,a2,b1,b2,i
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      ENSURE(a2==b1 AND a1==b2,"incompatible dimensions")
      res = ZERO 
      do i = 1,a1
         res = res + sum( self(i,:)*b(:,i) )
      end
   end

   trace_of_product(b) result (res)
   ! Return the trace of the product of "self" with matrix b.
      MAT :: b 
      DBL :: res
      INT :: a1,a2,b1,b2,i
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      ENSURE(a2==b1 AND a1==b2,"incompatible dimensions")
      res = ZERO 
      do i = 1,a1
         res = res + sum( self(i,:)*b(:,i) )
      end
   end

   equals(b) result(res)
   ! Check if the matrix is the same as "b".
      IN :: self
      MAT, IN :: b
      BIN :: res
      res = .same_as(b)
   end

   same_as(b, tol,diff) result(res)
   ! Check if the matrix is the same as "b", within "tol", and return the
   ! actual difference in "diff"
      IN :: self
      MAT, IN :: b 
      DBL, optional :: tol
      DBL, optional :: diff
      BIN :: res
      INT :: a1,a2,b1,b2,i
      DBL :: del,tolerance
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      ENSURE(a1==b1 AND a2==b2,"incompatible dimensions")
      if (present(tol))     tolerance = tol
      if (NOT present(tol)) tolerance = TOL(5)
      del = ZERO 
      do i = 1,a1
         del = del + sum( (self(:,i)-b(:,i))**2 )
      end
      del = sqrt(del)
      res = FALSE
      if (del<tolerance) res=TRUE
      if (present(diff)) diff=del
   end
      
   swap_columns(col1,col2)
   ! Swap columns "col1" and "col2" in "self".
      INT :: col1,col2
      INT :: a1,a2,i
      DBL :: val
      a1 = size(self,1)
      a2 = size(self,2)
      ENSURE(col1<=a1 AND col2<=a2,"columns exceed dimesions")
      do i = 1,a1
         val = self(i,col1)
         self(i,col1) = self(i,col2)
         self(i,col2) = val
      end
   end
      
   set_to(b)
   ! Set "self" to "b"
      MAT :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      ENSURE(b1==a1 AND b2==a2,"error in limits")
      self = b
   end
      
   plus(b)
   ! Add matrix "b" to "self"
      MAT :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      ENSURE(b1==a1 AND b2==a2,"error in limits")
      self = self+b
   end
      
   minus(b)
   ! Subtract matrix "b" from "self"
      MAT :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      ENSURE(b1==a1 AND b2==a2,"error in limits")
      self = self-b
   end
      
   to_scaled_mat(fac,b)
   ! Set "self" to matrix "b" scaled by "fac"
      MAT :: b
      DBL :: fac
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      ENSURE(b1==a1 AND b2==a2,"error in limits")
      self = fac*b
   end
      
   plus_scaled_mat(fac,b)
   ! Add to "self" matrix "b" scaled by "fac"
      MAT :: b
      DBL :: fac
      INT :: a1,a2,b1,b2
      a1 = size(self,1)
      a2 = size(self,2)
      b1 = size(b,1)
      b2 = size(b,2)
      ENSURE(b1==a1 AND b2==a2,"error in limits")
      self = self+fac*b
   end
      
   zero
   ! Zero the matrix
      self = ZERO
   end
   
   zero_small_values(tol) [pure]
   ! Zero elements of the matrix which are less than "tol" in magnitude
      INOUT :: self
      DBL, IN :: tol
      where (abs(self)<tol) self = ZERO
   end
      
   change_basis(V) 
   ! Change the basis of "self" using vectors "V"; self = V^T self V
      MAT :: V
      MAT, PTR :: W
      INT :: o1,o2,v1,v2
      o1 = size(self,1); o2 = size(self,2)
      v1 = size(V,1)   ; v2 = size(V,2)
      ENSURE(o1==o2,"non-square matrix")
      ENSURE(v1==v2,"non-square matrix")
      ENSURE(o2==v1,"incompatible sizes")
      W.create(o1,v2)
      W.to_product(self,V)
      self.to_product(V,W,transpose_a=TRUE)
      W.destroy
   end
      
   change_basis(new,V)
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new".  new = V^T self V
      MAT :: new,V
      MAT, PTR :: W
      INT :: o1,o2,n1,n2,v1,v2
      o1 = size(self,1); o2 = size(self,2)
      n1 = size(new,1);  n2 = size(new,2)
      v1 = size(v,1);    v2 = size(v,2)
      ENSURE(o1==o2,"non-square matrix")
      ENSURE(o2==v1,"incompatible sizes")
      ENSURE(n1==n2,"non-square matrix")
      ENSURE(n1==v2,"non-square matrix")
      W.create(o1,v2)
      W.to_product(self,V)
      new.to_product(V,W,transpose_a=TRUE)
      W.destroy
   end

   change_basis(L,R)
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
      VEC :: L,R
      MAT, PTR :: W
      INT :: s1,s2,l1,r1
      s1 = size(self,1); s2 = size(self,2)
      l1 = size(L)
      r1 = size(R)
      ENSURE(s1==l1 AND s2==r1,"incompatible sizes")
      W.create(l1,r1)
      W.to_product_with_diagonal(self,R)
      self.to_product_with_diagonal(L,W)
      W.destroy
   end

   change_basis(V)
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
      VEC :: V
      MAT, PTR :: W
      INT :: s1,s2,v1
      s1 = size(self,1); s2 = size(self,2)
      v1 = size(V)
      ENSURE(s1==v1,"incompatible sizes")
      W.create(v1,v1)
      W.to_product_with_diagonal(self,V)
      self.to_product_with_diagonal(V,W)
      W.destroy
   end

   back_transform(new,V)
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! new = V self V^T
      MAT :: new,V
      MAT, PTR :: W
      INT :: o1,o2,n1,n2,v1,v2
      o1 = size(self,1); o2 = size(self,2)
      n1 = size(new,1);  n2 = size(new,2)
      v1 = size(v,1);    v2 = size(v,2)
      ENSURE(o1==o2,"non-square matrix")
      ENSURE(o1==v2,"incompatible sizes")
      ENSURE(n1==n2,"non-square matrix")
      ENSURE(n1==v1,"incompatible sizes")
      W.create(v1,o2)
      W.to_product(V,self)
      new.to_product(W,V,transpose_b=TRUE)
      W.destroy
   end

   back_transform(V)
   ! Back transform "self" using vectors "V", and place the result in "self".
   ! self = V self V^T
      MAT :: V
      MAT, PTR :: W
      INT :: o1,o2,v1,v2
      o1 = size(self,1); o2 = size(self,2)
      v1 = size(v,1);    v2 = size(v,2)
      ENSURE(o1==o2,"non-square matrix")
      ENSURE(v1==v2,"non-square matrix")
      ENSURE(o1==v2,"incompatible sizes")
      W.create(v1,o2)
      W.to_product(V,self)
      self.to_product(W,V,transpose_b=TRUE)
      W.destroy
   end

   to_tri(tr)
   ! Converts the lower triangle of matrix self to the triangle "tr".
   ! using row order.
      IN :: self
      TRI :: tr
      INT :: dim1,dim2,i,j,ij,ltr
      dim1 = size(self,1)
      dim2 = size(self,2)
      ltr = dim1*(dim1+1)/2
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(size(tr)>=ltr,"triangle array too small")
      ij = 0
      do i = 1,dim1
         forall (j = 1:i)
            tr(ij+j) = self(j,i)
         end
         ij = ij+i
      end
   end

   from_tri(tr)
   ! Converts the triangle "tr" into the symmetric matrix "self".
      TRI :: tr
      INT :: dim1,dim2,i,j,ij,ltr
      dim1 = size(self,1)
      dim2 = size(self,2)
      ltr = dim1*(dim1+1)/2
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(size(tr)>=ltr,"triangle array too small")
      ij = 0
      do i = 1,dim1
         forall (j = 1:i)
            self(j,i) = tr(ij+j)
            self(i,j) = tr(ij+j)
         end
         ij = ij+i
      end
   end

   from_diagonal(d)
   ! Converts the diagonal vector "d" to matrix "self".
      VEC :: d
      INT :: dim1,dim2,dim,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      dim  = size(d)
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(dim1==dim, "incompatibale diagonal length")
      self = ZERO
      do i = 1,dim
         self(i,i) = d(i)
      end
   end

  tri_size result (ltr)
  ! Returns the size of the lower triangle needed to store self.
    IN :: self
    INT :: dim1,dim2,ltr
    dim1 = size(self,1)
    dim2 = size(self,2)
    ENSURE(dim1==dim2,"non-square matrix")
    ltr = dim1*(dim1+1)/2
  end
      
   to_unit_matrix
   ! Set "self" to the unit matrix
      .to_unit_mat
   end
      
   to_unit_mat
   ! Set "self" to the unit matrix
      INT :: dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      self = ZERO
      forall (i = 1:dim1)
         self(i,i) = ONE
      end
   end
      
   set_diagonal(val)
   ! Set the diagonal of "self" to "val"
      DBL :: val
      INT :: dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      forall (i = 1:dim1)
         self(i,i) = val
      end
   end
      
   add_to_diagonal(val)
   ! Add "val" to the diagonal of "self"
      DBL :: val
      INT :: dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      forall (i = 1:dim1)
         self(i,i) = self(i,i) + val
      end
   end
      
   zero_diagonal
   ! Zero the diagonal elements of "self"
      INT :: dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      forall (i = 1:dim1)
         self(i,i) = ZERO
      end
   end
      
   zero_off_diagonal
   ! Zero the off diagonal elements of "self"
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
      do j = 1,dim2
         if (i==j) cycle
         self(i,j) = ZERO
      end
      end
   end
      
   weight_diagonal(fac)
   ! Weight the diagonal elements of "self" by "fac"
      DBL, IN :: fac
      INT :: dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      forall (i = 1:dim1)
         self(i,i) = fac*self(i,i)
      end
   end
      
   get_diagonal(diag)
   ! Get the diagonal elements of "self" in vector "diag"
      VEC :: diag
      INT :: dim1,dim2,dim,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      dim  = size(diag)
      ENSURE(dim==min(dim1,dim2),"size of diagonal vector is incompatible")
      forall (i = 1:dim)
         diag(i) = self(i,i)
      end
   end

   symmetric_fold
   ! Add the upper triangle of "self" into the lower triangle
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j=1:i-1)
            self(i,j) = self(i,j)+self(j,i)
         end
      end
   end
      
   antisymmetric_fold
   ! Subtract the upper triangle of "self" into the lower triangle
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j=1:i-1)
            self(i,j) = self(i,j)-self(j,i)
         end
      end
   end
      
   symmetric_fold_to_tri(tr)
   ! Add the upper triangle of "self" into the lower triangle and return 
   ! the lower triangle "tr"
      TRI :: tr
      INT :: dim1,dim2,i,j,ij,ltr
      dim1 = size(self,1)
      dim2 = size(self,2)
      ltr = dim1*(dim1+1)/2
      ENSURE(dim1==dim2,"non-square matrix")
      ENSURE(size(tr)>=ltr,"triangle array too small")
      ij = 0
      do i = 1,dim1
         do j = 1,i
            ij = ij+1
            if (i==j) then
               tr(ij) = self(i,j)
            else
               tr(ij) = self(i,j)+self(i,j)
            end
         end
      end
   end
      
   make_symmetric
   ! Make the upper triangle of "self" the same as the lower triangle
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j = 1:i-1)
            self(j,i) = self(i,j)
         end
      end
   end
      
   symmetric_reflect
   ! Make the upper triangle of "self" the same as the lower triangle
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j = 1:i-1)
            self(j,i) = self(i,j)
         end
      end
   end
      
   make_antisymmetric
   ! Make the upper triangle of "self" the negative of the lower triangle
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j = 1:i-1)
            self(j,i) = -self(i,j)
         end
      end
      forall (i = 1:dim1)
         self(i,i) = ZERO
      end
   end
      
   antisymmetric_reflect
   ! Make the upper triangle of "self" the negative of the lower triangle
      INT :: dim1,dim2,i,j
      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"non-square matrix")
      do i = 1,dim1
         forall (j = 1:i-1)
            self(j,i) = -self(i,j)
         end
      end
      forall (i = 1:dim1)
         self(i,i) = ZERO
      end
   end
      
  schmidt_orthonormalise(S)
  ! Schmidt ortyhonormalise the column vectors in "self" using "S" as the
  ! metric.
    MAT :: S
    INT :: dim,dimS,n,k,j
    DBL :: proj,norm
    VEC, PTR :: T
    dim = size(self,1)
    dimS = size(S,1)
    ENSURE(dim==size(self,2),"non-square matrix")
    ENSURE(dimS==size(S,2),"non-square matrix")
    ENSURE(dim==dimS,"matrices not same size")

    T.create(dim)
    do n=1,dim
      do j=1,dim
        T(j) = dot_product(self(:j,n),S(:j,j))
        T(1:j-1) = T(1:j-1) + self(j,n) * S(:j-1,j)
      end
      do k=1,n-1
        proj = - dot_product(self(:,k),T)
        self(:,n) = self(:,n) + proj * self(:,k)
      end
      do j=1,dim
        T(j) = dot_product(self(:j,n), S(:j,j))
        T(:j-1) = T(:j-1) + self(j,n) * S(:j-1,j)
      end
      norm = dot_product(T,self(:,n))
      self(:,n) = self(:,n) / sqrt(norm)
    end
    T.destroy
  end

   to_sqrt(R)
   ! self = sqrt(R), cannot have R=self
      MAT :: R
      MAT, PTR :: evec
      VEC, PTR :: eval
      INT :: d,i,j
      STR :: val
      d = size(R,1)
      eval.create(d)
      evec.create(d,d)
      R.solve_eigenproblem(eval,evec)
      do i = 1,d
         val = eval(i).to_str("e15.8")
         WARN_IF(eval(i)<ZERO,"negative eigenvalue, "// trim(val))
      end
      forall (i=1:d, j=1:d)
         self(i,j) = sum( evec(i,:)*sqrt(abs(eval(:)))*evec(j,:))
      end
      evec.destroy
      eval.destroy
   end

   to_inverse_sqrt(R)
   ! self = sqrt(R)^(-1), cannot have R=self
      MAT :: R
      MAT, PTR :: evec
      VEC, PTR :: eval
      INT :: d,i,j
      STR :: val
      d = size(R,1)
      eval.create(d)
      evec.create(d,d)
      R.solve_eigenproblem(eval,evec)
      do i = 1,d
         val = eval(i).to_str("e15.8")
         WARN_IF(eval(i)<=ZERO,"non-positive eigenvalue, "// trim(val))
      end
      forall (i=1:d, j=1:d)
         self(i,j) = sum( evec(i,:)*(1/sqrt(abs(eval(:))))*evec(j,:))
      end
      evec.destroy
      eval.destroy
   end

   to_inverse_of(R)
   ! self = (R)^(-1), cannot have R=self
      MAT :: R
      MAT, PTR :: evec
      VEC, PTR :: eval
      INT :: d,i,j
      STR :: val
      d = size(R,1)
      eval.create(d)
      evec.create(d,d)
      R.solve_eigenproblem(eval,evec)
      do i = 1,d
         val = eval(i).to_str("e15.8")
         WARN_IF(abs(eval(i))<=TOL(6),"small eigenvalue, "// trim(val))
      end
      forall (i=1:d, j=1:d)
         self(i,j) = sum( evec(i,:)*(1/eval(:))*evec(j,:))
      end
      evec.destroy
      eval.destroy
   end
      
   antisymmetric_exponential(U, eval,evec)
   ! Make unitary matrix U = exp(self) where "self" must be antisymmetric. 
   ! Uses the formula:  exp A = V (cos P) V^t + V (sin P)/P V^t A
   !                        P = sqrt diag(eig(A^t A))
   ! (c) dylan jayatilaka, university of western australia, 1993
   ! Untested in TONTO.
      MAT :: U
      MAT, PTR, optional :: evec
      VEC, PTR, optional :: eval
      MAT, PTR :: W
      INT :: dim1,dim2,dim,k
      DBL :: e,e2,cs,sn
      MAT, PTR :: v_k

      dim1 = size(self,1)
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"self is a non-square matrix")
      dim1 = size(U,1)
      dim2 = size(U,2)
      ENSURE(dim1==dim2,"U is a non-square matrix")
      dim2 = size(self,2)
      ENSURE(dim1==dim2,"self and U incompatible")
      dim = dim1
      if (NOT present(eval)) then
         eval.create(dim)
      else
         dim2 = size(eval)
         ENSURE(dim2>=dim,"eval too small")
      end
      if (NOT present(evec)) then
         evec.create(dim,dim)
      else
         dim1 = size(evec,1)
         dim2 = size(evec,2)
         ENSURE(dim1==dim AND dim2==dim,"evec incompatible")
      end
      W.create(dim,dim)

      U = matmul(self,self)   ! U = -self^t*self = self^2, makes U hermitian 
      U.solve_eigenproblem(eval,evec) ! diagonalise U ... 

      U = ZERO
      do k = 1,dim            ! do the exponential ... loop over eigenvalues ...
         e2 = eval(k)
         if (e2<0)  then
            e = sqrt(-e2); cs = cos(e);  sn = sin(e)/e; 
         end
         if (e2>0)  then
            e = sqrt(e2) ; cs = cosh(e); sn = sinh(e)/e 
         end
         if (e2==0) then
            cs = ONE    ; sn = ONE      
         end
         v_k => evec(1:dim,k:k)
         W.to_product(v_k,v_k,transpose_b=TRUE) ! V V^\dag part
         U.plus_scaled_product(sn,W,self)       ! sin part
         U.plus_scaled_mat(cs,W)                ! cos part
      end
      if (NOT present(eval)) eval.destroy
      if (NOT present(evec)) evec.destroy
   end

   alpha_alpha result(res)
   ! return the alpha-alpha sector of the matrix
      TARGET :: self
      MAT, PTR :: res
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(1:n,1:n)
   end

   beta_alpha result(res)
   ! return the beta-alpha sector of the matrix
      TARGET :: self
      MAT, PTR :: res
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(n+1:2*n,1:n)
   end

   alpha_beta result(res)
   ! return the alpha-beta sector of the matrix
      TARGET :: self
      MAT, PTR :: res
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(1:n,n+1:2*n)
   end

   beta_beta result(res)
   ! return the beta-beta sector of the matrix
      TARGET :: self
      MAT, PTR :: res
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      res => self(n+1:2*n,n+1:2*n)
   end

   alpha_alpha_set_to(X,factor)
   ! Set the alpha-alpha sector of the matrix to "X"
      MAT :: X
      DBL, optional :: factor
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      if (present(factor)) then; self(1:n,1:n) = factor*X
      else;                      self(1:n,1:n) = X
      end
   end

   beta_alpha_set_to(X,factor)
   ! Set the beta-alpha sector of the matrix to "X"
      MAT :: X
      DBL, optional :: factor
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      if (present(factor)) then; self(n+1:2*n,1:n) = factor*X
      else;                      self(n+1:2*n,1:n) = X
      end
   end

   alpha_beta_set_to(X,factor)
   ! Set the alpha-beta sector of the matrix to "X"
      MAT :: X
      DBL, optional :: factor
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      if (present(factor)) then; self(1:n,n+1:2*n) = factor*X
      else;                      self(1:n,n+1:2*n) = X
      end
   end

   beta_beta_set_to(X,factor)
   ! Set the beta-beta sector of the matrix to "X"
      MAT :: X
      DBL, optional :: factor
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      if (present(factor)) then; self(n+1:2*n,n+1:2*n) = factor*X
      else;                      self(n+1:2*n,n+1:2*n) = X
      end
   end

   alpha_alpha_put_to(X,factor)
   ! Put the alpha-alpha sector of the matrix to "X"
      MAT :: X
      DBL, optional :: factor
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      if (present(factor)) then; X = factor*self(1:n,1:n)
      else;                      X = self(1:n,1:n)
      end
   end

   beta_alpha_put_to(X,factor)
   ! Put the beta-alpha sector of the matrix to "X"
      MAT :: X
      DBL, optional :: factor
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      if (present(factor)) then; X = factor*self(n+1:2*n,1:n)
      else;                      X = self(n+1:2*n,1:n)
      end
   end

   alpha_beta_put_to(X,factor)
   ! Put the alpha-beta sector of the matrix to "X"
      MAT :: X
      DBL, optional :: factor
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      if (present(factor)) then; X = factor*self(1:n,n+1:2*n)
      else;                      X = self(1:n,n+1:2*n)
      end
   end

   beta_beta_put_to(X,factor)
   ! Put the beta-beta sector of the matrix to "X"
      MAT :: X
      DBL, optional :: factor
      INT :: n1,n2,n
      n1 = size(self,1)
      n2 = size(self,2)
      n  = n1
      ENSURE(n1==n2,"self is a non-square matrix")
      ENSURE(n==2*(n/2),"self is not even-dimensioned")
      n = n/2
      if (present(factor)) then; X = factor*self(n+1:2*n,n+1:2*n)
      else;                      X = self(n+1:2*n,n+1:2*n)
      end
   end

end
