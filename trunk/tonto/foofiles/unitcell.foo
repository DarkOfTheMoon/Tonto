! $Id$
!-------------------------------------------------------------------------------
! UNITCELL: Crystal unit cell data
!
! Synopsis
!
! Read in the unit cell angles and cell dimensions and create the unit cell
! matrices.
!
! (c) Stephen K Wolff & Dylan Jayatilaka, UWA, feb 1996
!-------------------------------------------------------------------------------
module UNITCELL

   use TYPES
   use SYSTEM
   use STR
   use BUFFER
   use INPUT
   use OUTPUT
   use MAT

   implicit none

#  include "macros"
#  include "unitcell.int"

!  type unitcell_type
!     VEC(3) :: angle                                   ! cell angles  (in radians)
!     VEC(3) :: length                                  ! cell lengths (in bohr)
!     DBL :: cell_volume                                ! cell volumes (bohr^3)
!     MAT(3,3) :: cell_matrix                           ! direct cell matrix (bohr)
!     MAT(3,3) :: inverse_cell_matrix                   ! inverse direct cell matrix (bohr^{-1})
!     MAT(3,3) :: reciprocal_cell_matrix                ! reciprocal cell matrix (bohr^{-1})
!     MAT(3,3) :: rotation_matrix                       ! Rotation matrix applied to reciprocal cell
!     MAT(3,3) :: rrcm                                  ! Rotated reciprocal cell matrix (bohr^{-1}) times 2 PI
!  end

contains

   create
   ! Create a unitcell
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(UNITCELL_SIZE)
      .set_default
   end

   create(angle,length,rotation,radians,bohr)
   ! Create a unitcell with specified "angles" and cell "lengths".
   ! If present, a "rotation" matrix applied to the cell matrix.
   ! If present and TRUE, "radians" indicates the angles are in radians (default degrees)
   ! If present and TRUE, "bohr" indicates the lengths are in Bohr (default Angstrom)
      PTR :: self
      VEC(3) :: angle,length
      MAT(3,3), optional :: rotation
      BIN, optional :: radians,bohr
      BIN :: convert_degrees,convert_angstrom
      .create

      convert_degrees = TRUE          ! assumed in degrees
      convert_angstrom = TRUE         ! assumed in angstroms
      if (present(radians)) convert_degrees = NOT radians
      if (present(bohr)) convert_angstrom = NOT bohr
      if (convert_degrees) .angle = angle*PI/180.0d0
      if (convert_degrees) .length = length*BOHR_PER_ANGSTROM

      if (present(rotation)) .rotation_matrix = rotation
   end

   destroy 
   ! Destroy a unitcell
      PTR :: self
      if (.destroyed) return
      deallocate(self)
      DELETE_MEM(UNITCELL_SIZE)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set(angle,length,rotation,angle_unit,length_unit)
   ! Set the unit cell parameters
      VEC(3) :: angle,length
      MAT(3,3), optional :: rotation
      CHR(*), optional :: angle_unit,length_unit
      .set_angles(angle,angle_unit)
      .set_lengths(length,length_unit)
      if (present(rotation)) .rotation_matrix = rotation
      .make_cell_matrices
   end

   set_default
   ! Set the default unit cell parameters
      VEC(3) :: angle,length
      angle = (/90.0d0,90.0d0,90.0d0/)
      length = (/10.0d0,10.0d0,10.0d0/)
      .rotation_matrix.to_unit_mat
      .set(angle,length,angle_unit="degrees",length_unit="bohr")
   end

   set_angles(angle,units)
   ! Set the unit cell "angles", with optional "units" set to "degrees" or "radians".
      VEC(3) :: angle
      CHR(*), optional :: units
      STR :: un
      un = "degrees"
      if (present(units)) un = units
      un.to_lower_case
      select case (un)
         case("d","degree","degrees"); .angle = angle*PI/180.0d0    
         case("r","radian","radians"); .angle = angle
         case default;                 DIE("unknown angle unit " // trim(un))
      end
   end

   set_lengths(length,units)
   ! Set the unit cell lengths
      VEC(3) :: length
      CHR(*), optional :: units
      STR :: un
      un = "angstrom"
      if (present(units)) un = units
      un.to_lower_case
      select case (un)
         case("a","angstrom","angstroms"); .length = length*BOHR_PER_ANGSTROM 
         case("au","bohr","bohrs");        .length = length
         case default;                     DIE("unknown length unit, " // trim(un))
      end
   end

   read(in)
   ! Read in the unit cell data from file "in"
      INPUT :: in
      STR :: word
      .set_default
      read_loop : do
         in.read(word)
         word.to_lower_case
         select case (word)
            case("end");             exit read_loop
            case("angles");          .read_angles(in)
            case("dimensions");      .read_lengths(in)
            case("lengths");         .read_lengths(in)
            case("rotation_matrix"); .read_rotation(in)
            case default;            DIE("unknown option, "// word.trim)
         end 
      end do read_loop
      .make_cell_matrices
   end

   read_angles(in)
   ! Read in the unitcell angles from file "in"
      INPUT :: in
      VEC(3) :: angles
      STR :: units
      in.read(angles) 
      .set_angles(angles)
      if ( in%buffer.exhausted) return
      in.read(units)
      .set_angles(angles,units)
      DIE_IF( in%buffer.not_exhausted,"too many line items")
   end

   read_lengths(in)
   ! Read in the unit cell lengths from file "in"
      INPUT :: in
      VEC(3) :: lengths
      STR :: units
      in.read(lengths) 
      .set_lengths(lengths)
      if ( in%buffer.exhausted) return
      in.read(units)
      .set_lengths(lengths,units)
      DIE_IF( in%buffer.not_exhausted,"too many line items")
   end

   read_rotation(in)
   ! Read an a rotation matrix to apply to the unit cell from file "in"
      INPUT :: in
      in.read(.rotation_matrix) 
   end

   make_cell_matrices
   ! Calculate the direct and reciprocal cell matrices
   ! The units of the direct cell matix is BOHRS.
   ! The units of the reciprocal cell matix is 1/BOHRS.
      DBL :: v,a,b,c,alph,beta,gamm,ca,cb,cg,sb
      alph = .angle(1)
      beta = .angle(2)
      gamm = .angle(3)
      a = .length(1)
      b = .length(2)
      c = .length(3)
      ca = cos(alph)
      cb = cos(beta)
      cg = cos(gamm)
      sb = sin(beta)
      ! Volume of the cell (det(cell_matrix))
      v = a*b*c*sqrt(ONE-ca**2-cb**2-cg**2+TWO*ca*cb*cg)
      .cell_volume = v
      ! Direct cell matrix
      .cell_matrix(1,1) = a
      .cell_matrix(1,2) = b*cg
      .cell_matrix(1,3) = c*cb
      .cell_matrix(2,1) = ZERO 
      .cell_matrix(2,2) = v/(a*c*sb)
      .cell_matrix(2,3) = ZERO 
      .cell_matrix(3,1) = ZERO 
      .cell_matrix(3,2) = b*(ca-cg*cb)/sb
      .cell_matrix(3,3) = c*sb
      ! Reciprocal cell matrix
      .reciprocal_cell_matrix(1,1) = ONE/a
      .reciprocal_cell_matrix(1,2) = ZERO 
      .reciprocal_cell_matrix(1,3) = ZERO 
      .reciprocal_cell_matrix(2,1) = b*c*(ca*cb-cg)/sb/v
      .reciprocal_cell_matrix(2,2) = a*c*sb/v
      .reciprocal_cell_matrix(2,3) = a*b*(cb*cg-ca)/sb/v
      .reciprocal_cell_matrix(3,1) = -cb/a/sb
      .reciprocal_cell_matrix(3,2) = ZERO 
      .reciprocal_cell_matrix(3,3) = ONE/c/sb
      .inverse_cell_matrix = transpose(.reciprocal_cell_matrix)
      .rrcm = 2*PI*matmul( .rotation_matrix, .reciprocal_cell_matrix)
   end

   put(out)
   ! Put unitcell information to file "out"
      OUTPUT :: out
      out.flush
      out.text("UNTICELL output:",flush=2)
      out.text("Information about crystal unit cell",flush=2)
      out.show("alpha angle      = ",.angle(1))
      out.show("beta  angle      = ",.angle(2))
      out.show("gamma angle      = ",.angle(3))
      out.show("a cell parameter = ",.length(1))
      out.show("b cell parameter = ",.length(2))
      out.show("c cell parameter = ",.length(3))
      out.show("cell volume      = ",.cell_volume)
      out.flush
      out.text("Direct cell matrix :")
      out.put(.cell_matrix)
      out.flush
      out.text("Reciprocal cell matrix :")
      out.put(.reciprocal_cell_matrix)
      out.flush
      out.text("Unit cell rotation matrix :")
      out.put(.rotation_matrix)
      out.flush
      out.text("Rotated reciprocal cell matrix :")
      out.put(.rrcm)
   end

end
