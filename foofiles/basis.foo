! $Id$
!-------------------------------------------------------------------------------
! BASIS: basis sets
! (c) Dylan Jayatilaka, 1998
!-------------------------------------------------------------------------------
module BASIS

   use TYPES
   use SYSTEM
   use INPUT
   use OUTPUT
   use STR
   use IVEC
   use VEC
   use IMAT
   use MAT
   use MAT3
   use SHELL
   use SHELLVEC

   implicit none         

#  include "macros"
#  include "basis.int"

!  type basis_type
!     STR :: label
!     INT :: n_shell
!     INT :: n_bf
!     INT :: n_prim
!     SHELLVEC, PTR :: shell
!  end 

contains

!  ******************
!  Allocation methods
!  ******************

   create
   ! Create a basis object
      PTR :: self
      nullify(self)
      allocate(self)
      .nullify_ptr_part
      ADD_MEM(BASIS_SIZE)
   end

   destroy 
   ! Destroy a basis object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(BASIS_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the shell parts of self
      nullify(.shell)
   end

   destroy_ptr_part
   ! Destroy the shell parts of self
      .shell.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self) 
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end
 
   set_default
   ! Create and set up a default basis set
      INT :: err
!      allocate(.shell(1),stat=err)
!      DIE_IF(err>0,"shell list allocation error")
!      ADD_MEM(SHELL_SIZE)           
      .shell.create(1)
      .shell(1).set_default
      .n_shell = .no_of_shells
      .n_bf    = .no_of_basis_functions
      .n_prim  = .no_of_primitives
      .label = "Default"
   end

!  *************
!  Input methods
!  *************

   read(in) [leaky]
   ! Read in a basis set from file "in"
      INPUT :: in
      .read_label(in)
      .read_shellvec(in)
   end

   read_label(in)
   ! Read only the basis label from file "in"
      INPUT :: in
      in.read(.label)
   end

   read_shellvec(in) [leaky]
   ! Create and read only the shellvec part of the basis from file "in"
      INPUT :: in
      .shell.read(in)
      .n_shell = .no_of_shells
      .n_bf    = .no_of_basis_functions
      .n_prim  = .no_of_primitives
   end

!  *******
!  Methods
!  *******

   contraction_matrix result(ccm) 
   ! Set the contraction coefficient matrix
   ! Its dimensions are (.n_prim,.n_bf).
      MAT( .n_prim, .n_bf) :: ccm
      INT :: b,p,n_p,n_b,i
      SHELL, PTR :: sh
      p = 0                       ! no of primitives in all previous shells
      b = 0                       ! basis number
      ccm.zero
      do i = 1,.n_shell           ! For segmented basis sets !
         sh => .shell(i)
         n_b = sh%n_comp
         n_p = sh.n_prim
         sh.make_contraction_matrix(ccm(p+1:p+n_p,b+1:b+n_b))
         b = b + n_b
         p = p + n_p
      end
   end

   unnormalise 
   ! Take the normalisation factors out of the basis functions, assuming
   ! that the contraction coeff's refer to normalised basis functions
      INT :: i 
      do i= 1,.n_shell
         .shell(i).unnormalise
      end
   end

   put(out)
   ! Put out the basis information to file "out"
      OUTPUT :: out
      SHELL, PTR :: sh
      INT :: i,j,b,p
      out.put_text("Basis set " // trim(.label), flush=2)
      out.put_dash(int_fields=3,dbl_fields=2,flush=1)
      out.put("Type",int_width=TRUE)
      out.put("Fn",int_width=TRUE)
      out.put("Prim",int_width=TRUE)
      out.put("Exponent")
      out.put("Contraction")
      out.flush
      out.put_dash(int_fields=3,dbl_fields=2,flush=1)
      b = 1
      p = 1
      do i = 1,.n_shell
         sh    => .shell(i)
         do j = 1,sh%n_cc
            if (j==1) then
               out.put( sh.l_chr,int_width=TRUE)
               out.put(b)
            else
               out.tab(int_fields=2)
            end
            out.put(p)
            out.put( sh%ex(j)); out.put( sh%cc(j))
            out.flush
            p = p + sh%n_comp
         end
         b = b + sh%n_comp
      end 
      out.put_dash(int_fields=3,dbl_fields=2,flush=1)
   end 

!  ***************
!  Inquiry methods
!  ***************

   no_of_shells result(res) 
      INT :: res
      res = size(.shell)
   end

   no_of_basis_functions result (res)
      INT :: res
      INT :: i
      res = 0
      do i = 1,.n_shell
         res = res + .shell(i)%n_comp
      end
   end

   no_of_primitives result (res)
      INT :: res
      INT :: i
      res = 0
      do i= 1,.n_shell
         res = res + .shell(i)%n_comp*.shell(i)%n_cc
      end
   end

end 
