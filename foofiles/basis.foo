!-------------------------------------------------------------------------------
!
! BASIS: For gaussian basis sets
!
! (c) Dylan Jayatilaka, 1998
!
! $Id$
!-------------------------------------------------------------------------------
module BASIS

   use TYPES
   use SYSTEM
   use STR
   use IVEC
   use IMAT
   use VEC
   use MAT
   use MAT3
   use TEXTFILE
   use SHELL
   use SHELLVEC

   implicit none         

#  include "macros"
#  include "basis.int"

!   type basis_type
!
!   STR :: label
!   ! Unique label for the basis set
!
!   INT :: n_shell
!   ! No. of shells in the basis, equal to size(shell)
!
!   INT :: n_bf
!   ! No. of basis functions for the shell
!
!   INT :: n_prim
!   ! No. of primitives for the shell
!
!   SHELLVEC* :: shell
!   ! The list of gaussian shells in the basis set
!
!   end

contains

!  ******************
!  Allocation methods
!  ******************

   create
   ! Create a basis object
      PTR :: self
      nullify(self)
      allocate(self)
      .nullify_ptr_part
      ADD_MEM(BASIS_SIZE)
   end

   destroy 
   ! Destroy a basis object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(BASIS_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the shell parts of self
      nullify(.shell)
   end

   destroy_ptr_part
   ! Destroy the shell parts of self
      .shell.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self) 
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   copy(b) [leaky]
   ! Copy a basis "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
      BASIS :: b
      self = b
      self.shell.create(b.shell.n_shell)
      self.shell.copy(b.shell)
   end
 
   set_default
   ! Create and set up a default basis set
      .shell.create(1)
      .shell(1).set_default
      .label = "Default"
      .update
   end
 
   update
   ! Update the shell data
      .n_shell = .no_of_shells
      .n_bf    = .no_of_basis_functions
      .n_prim  = .no_of_primitives
   end

!  *************
!  Input methods
!  *************

   read [leaky]
   ! Read data from "stdin" using keyword style input.
      STR :: word
      ENSURE(stdin.next_str=="{","expecting an open bracket symbol, {")
      read_loop: do             ! Loop over keywords
         stdin.read(word)
         if (stdin.reverted)    exit read_loop
         if (word=="}")         exit read_loop
         .process_input(word)      
      end do read_loop
      .update
   end

   process_input(word) [leaky]
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case, 
   ! the sequence is processed as if it were a separate file.
      STR(*) :: word
      if (word.includes(" ")) then
         stdin.redirect([word])
         .read
      else
         select case (word)
            case("basis");     .read
            case("units");     .read_units
            case("label");     .read_label
            case("shells");    .read_shells
            case("gamess-us"); .read_gamess_us
            case default;    DIE("unknown keyword, "//trim(word))
         end
      end
   end

   process_input(keyword) [leaky]
   ! Process each of the words in the "keyword" list.
      STRVEC :: keyword
      INT :: k,n_key
      n_key = size(keyword)
      do k = 1,n_key
         if (keyword(k)=="}") exit 
         .process_input(keyword(k)) 
      end
      ENSURE(k>=n_key,"unprocessed words remain in the keyword list")
      .update
   end

   read_units
   ! Read a string which describes the units to be used
      stdin.set_default_units(stdin.next_str)
   end

   read_label
   ! Read only the basis label
      stdin.read(.label)
   end

   read_shells [leaky]
   ! Create and read only the shellvec part of the basis 
      .shell.read
   end

   read_gamess_us [leaky]
   ! Create and read a GAMESS-US style basis set
      .read_label
      shell_input_data_order.create((/"l_chr     ","n_cc      ","junk,ex,cc"/))
      .read_shells
      shell_input_data_order.destroy
   end

!  *******
!  Methods
!  *******

   same_as(b) result(res) 
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      BASIS :: b
      BIN :: res
      res = .shell.same_as(b.shell)
   end

   contraction_matrix result(ccm) 
   ! Set the contraction coefficient matrix. Its dimensions are (.n_prim,.n_bf).
      MAT( .n_prim, .n_bf) :: ccm
      INT :: b,p,n_p,n_b,i
      SHELL* :: sh
      p = 0                       ! no of primitives in all previous shells
      b = 0                       ! basis number
      ccm = ZERO
      do i = 1,.n_shell           ! For segmented basis sets !
         sh => .shell(i)
         n_b = sh.n_comp
         n_p = sh.n_prim
         sh.make_contraction_matrix(ccm(p+1:p+n_p,b+1:b+n_b))
         b = b + n_b
         p = p + n_p
      end
   end

   unnormalise 
   ! Take the normalisation factors out of the primitives, assuming
   ! that the contraction coeff's refer to normalised basis functions
      .shell.unnormalise
   end

   renormalise 
   ! Put back in the normalisation factors of the primitives, assuming
   ! that the contraction coeff's refer to unnormalised basis functions
      .shell.renormalise
   end

   put
   ! Put out the basis information to file "stdout"
      stdout.flush
      stdout.show("Basis set : ",trim(.label))
      stdout.flush
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .put_table
   end 

   put_table
   ! Put out the basis information to file "stdout"
      SHELL* :: sh
      INT :: i,j,b,p
      stdout.flush
      stdout.dash(int_fields=3,dbl_fields=2)
      stdout.put("Type",int_width=TRUE)
      stdout.put("Fn",int_width=TRUE)
      stdout.put("Prim",int_width=TRUE)
      stdout.put("Exponent")
      stdout.put("Contraction")
      stdout.flush
      stdout.dash(int_fields=3,dbl_fields=2)
      b = 1
      p = 1
      do i = 1,.n_shell
         sh => .shell(i)
         do j = 1,sh.n_cc
            if (j==1) then
               stdout.put(sh.l_chr,int_width=TRUE)
               stdout.put(b)
            else
               stdout.tab(int_fields=2)
            end
            stdout.put(p)
            stdout.put(sh.ex(j))
            stdout.put(sh.cc(j))
            stdout.flush
            p = p + sh.n_comp
         end
         b = b + sh.n_comp
      end 
      stdout.dash(int_fields=3,dbl_fields=2)
   end 

!  ***************
!  Inquiry methods
!  ***************

   no_of_shells result(res) 
   ! Work out and return the number of shells in the basis set
      INT :: res
      res = size(.shell)
   end

   no_of_basis_functions result (res)
   ! Work out and return the number of basis functions in the basis set
      INT :: res
      INT :: i
      res = 0
      do i = 1,.n_shell
         res = res + .shell(i).n_comp
      end
   end

   no_of_primitives result (res)
   ! Work out and return the number of primitives in the basis set
      INT :: res
      INT :: i
      res = 0
      do i= 1,.n_shell
         res = res + .shell(i).n_comp*.shell(i).n_cc
      end
   end

end 
