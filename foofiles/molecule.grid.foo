!===============================================================================
!
! MOLECULE.PLOT: An object representation of a molecule, plotting procedures.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996-2012
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: $
!===============================================================================

module MOLECULE.GRID

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

contains

!  ========
!  Do plots
!  ========

! 2D

   do_plot ::: leaky
   ! Do one of the many kinds of plot calculations. These are usually
   ! 2D plots but they can be rectilinear volumetric plots, depending
   ! on how .plot_grid was defined by the user.
   ENSURE(.plot_grid.created, "no grid")

      select case (.plot_grid.plot_kind)
         case("b_field                             "); .::make_B_field_grid
         case("b_l_field                           "); .::make_B_L_field_grid
         case("b_s_field                           "); .::make_B_S_field_grid
         case("bond_weight                         "); .::make_bond_weight_grid
         case("crystal_error_map                   "); .::make_crystal_error_map
         case("current_density                     "); .::make_j_grid
         case("deformation_bond_density            "); .::make_def_bond_density_grid
         case("deformation_density                 "); .::make_deformation_density_grid
         case("deformation_dft_eff_potential       "); .::make_def_dft_eff_pot_grid
         case("deformation_dft_energy              "); .::make_def_dft_energy_grid
         case("deformation_dft_xc_potential        "); .::make_def_dft_xc_pot_grid
         case("deformation_electric_potential      "); .::make_def_e_pot_grid
         case("deformation_g_kinetic_energy        "); .::make_def_G_kinetic_grid
         case("deformation_g_kirzhnits             "); .::make_def_G_Kirzhnits_grid
         case("deformation_h_dft_energy            "); .::make_def_H_dft_energy_grid
         case("deformation_h_from_virial           "); .::make_def_H_from_virial_grid
         case("deformation_h_kirzhnits             "); .::make_def_H_Kirzhnits_grid
         case("deformation_k_kinetic_energy        "); .::make_def_K_kinetic_grid
         case("deformation_laplacian               "); .::make_def_laplacian_grid
         case("deformation_v_from_virial           "); .::make_def_V_from_virial_grid
         case("deformation_v_kirzhnits             "); .::make_def_V_Kirzhnits_grid
         case("deformation_reduced_g_kinetic_energy"); .::make_def_rG_kinetic_grid
         case("deformation_reduced_h_from_virial   "); .::make_def_rH_from_virial_grid
         case("deformation_reduced_k_kinetic_energy"); .::make_def_rK_kinetic_grid
         case("deformation_reduced_v_from_virial   "); .::make_def_rV_from_virial_grid
         case("dft_eff_potential                   "); .::make_dft_eff_pot_grid
         case("dft_energy                          "); .::make_dft_energy_grid
         case("dft_xc_potential                    "); .::make_dft_xc_pot_grid
         case("div_jp                              "); .::make_div_jp_grid
         case("electric_potential                  "); .::make_electric_potential_grid
         case("electric_polarisation_density       "); .::make_e_polarization_grid
         case("electric_polarization_density       "); .::make_e_polarization_grid
         case("electron_density                    "); .::make_electron_density_grid
         case("elf                                 "); .::make_ELF_grid
         case("e_hf_density_from_rho               "); .::make_E_hf_dens_from_rho_grid
         case("eli_d                               "); .::make_ELI_D_grid
       ! case("energy_density_from_rho             "); .::make_deformation_density_grid
         case("fermi_mobility                      "); .::make_fermi_mobility_grid
         case("g_kinetic_energy                    "); .::make_G_kinetic_energy_grid
         case("g_kirzhnits                         "); .::make_G_Kirzhnits_grid
         case("grad_rho_on_rho                     "); .::make_grad_rho_on_rho_grid
         case("h_dft_energy                        "); .::make_H_dft_energy_grid
         case("h_kirzhnits                         "); .::make_H_Kirzhnits_grid
         case("h_from_virial                       "); .::make_H_from_virial_grid
         case("hirshfeld_atom_grid                 "); .::make_Hirshfeld_atom_grid
         case("hirshfeld_density                   "); .::make_Hirshfeld_density_grid
         case("hirshfeld_weight                    "); .::make_Hirshfeld_density_grid
         case("j                                   "); .::make_j_grid
         case("jd                                  "); .::make_jd_grid
         case("jp                                  "); .::make_jp_grid
         case("jp_irrotational                     "); .::make_irrotational_jp_grid
         case("jp_solenoidal                       "); .::make_solenoidal_jp_grid
         case("k_kinetic_energy                    "); .::make_K_kinetic_energy_grid
         case("laplacian                           "); .::make_laplacian_grid
         case("local_ionisation_energy             "); .::make_local_ionisation_grid
         case("local_virial_ratio                  "); .::make_local_virial_ratio_grid
         case("negative_laplacian                  "); .::make_neg_laplacian_grid
       ! case("orbital_current_density             "); .::make_orbital_j_grid
         case("orbital_density                     "); .::make_orbital_density_grid
         case("orbital                             "); .::make_orbital_grid
         case("oscillator_orbital                  "); .::make_oscillator_orbital_grid
         case("promolecule_density                 "); .::make_promolecule_density_grid
         case("reduced_g_kinetic_energy            "); .::make_rG_kinetic_energy_grid
         case("reduced_h_from_virial               "); .::make_rH_from_virial_grid
         case("reduced_k_kinetic_energy            "); .::make_rK_kinetic_energy_grid
         case("reduced_v_from_virial               "); .::make_rV_from_virial_grid
       ! case("spin_current_density                "); .::make_spin_j_grid
         case("spin_density                        "); .::make_spin_density_grid
         case("spherical_atom_density              "); .::make_spherical_atom_grid
         case("stockholder_density                 "); .::make_stockholder_density_grid
         case("stockholder_weight                  "); .::make_Hirshfeld_density_grid
         case("true_fermi_mobility                 "); .::make_true_fermi_mobility_grid
         case("tsirelson_elf                       "); .::make_Tsirelson_ELF_grid
         case("v_kirzhnits                         "); .::make_V_Kirzhnits_grid
         case("v_from_virial                       "); .::make_V_from_virial_grid
         case default;                UNKNOWN(.plot_grid.plot_kind)
      end

   end

! Isosurface

   do_isosurface_plot 
   ! Do one of the many kinds of isosurface plot calculations
   ENSURE(.isosurface.created,"no isosurface")

      select case (.isosurface.iso_kind)
         case("bond_density_atom                "); .isosurface.cubify(::bond_density_atom_grid)
         case("bond_weight                      "); .isosurface.cubify(::bond_weight_grid)
         case("deformation_bond_density         "); .isosurface.cubify(::deformation_bond_density_grid)
         case("deformation_density              "); .isosurface.cubify(::deformation_density_grid)
         case("deformation_dft_eff_potential    "); .isosurface.cubify(::def_dft_eff_pot_grid)
         case("deformation_dft_energy           "); .isosurface.cubify(::def_dft_energy_grid)
         case("deformation_dft_xc_potential     "); .isosurface.cubify(::def_dft_xc_pot_grid)
         case("deformation_electric_potential   "); .isosurface.cubify(::def_e_pot_grid)
         case("deformation_g_kinetic_energy     "); .isosurface.cubify(::def_G_kinetic_grid)
         case("deformation_h_dft_energy         "); .isosurface.cubify(::def_H_dft_energy_grid)
         case("deformation_k_kinetic_energy     "); .isosurface.cubify(::def_K_kinetic_grid)
         case("deformation_laplacian            "); .isosurface.cubify(::def_laplacian_grid)
         case("dft_eff_potential                "); .isosurface.cubify(::dft_eff_pot_grid)
         case("dft_energy                       "); .isosurface.cubify(::dft_energy_grid)
         case("dft_xc_potential                 "); .isosurface.cubify(::dft_xc_pot_grid)
         case("electric_potential               "); .isosurface.cubify(::electric_potential_grid)
         case("electron_density                 "); .isosurface.cubify(::electron_density_grid)
         case("elf                              "); .isosurface.cubify(::ELF_grid)
         case("eli_d                            "); .isosurface.cubify(::ELI_D_grid)
         case("fermi_mobility                   "); .isosurface.cubify(::fermi_mobility_grid)
         case("grad_rho_on_rho                  "); .isosurface.cubify(::grad_rho_on_rho_grid)
         case("g_kinetic_energy                 "); .isosurface.cubify(::G_kinetic_energy_grid)
         case("h_dft_energy                     "); .isosurface.cubify(::H_dft_energy_grid)
         case("hirshfeld_density                "); .isosurface.cubify(::Hirshfeld_density_grid)
         case("hirshfeld_weight                 "); .isosurface.cubify(::Hirshfeld_density_grid)
         case("k_kinetic_energy                 "); .isosurface.cubify(::K_kinetic_energy_grid)
         case("laplacian                        "); .isosurface.cubify(::laplacian_grid)
         case("local_ionisation_energy          "); .isosurface.cubify(::local_ionisation_grid)
         case("orbital                          "); .isosurface.cubify(::orbital_grid)
         case("oscillator_orbital               "); .isosurface.cubify(::oscillator_orbital_grid)
         case("orbital_density                  "); .isosurface.cubify(::orbital_density_grid)
         case("promolecule_density              "); .isosurface.cubify(::promolecule_density_grid)
         case("spin_density                     "); .isosurface.cubify(::spin_density_grid)
         case("stockholder_density              "); .isosurface.cubify(::stockholder_density_grid)
         case("stockholder_weight               "); .isosurface.cubify(::Hirshfeld_density_grid)
         case("true_fermi_mobility              "); .isosurface.cubify(::true_fermi_mobility_grid)
         case("tsirelson_elf                    "); .isosurface.cubify(::Tsirelson_ELF_grid)
         case default;                UNKNOWN(.isosurface.iso_kind)
      end

   end

   do_plot_property_on_isosurface 
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface===useful for mapping properties on a surface.
      select case (.isosurface.surface_property)
         case("bond_density_atom               "); .isosurface.plot_function(::bond_density_atom_grid)
         case("deformation_bond_density        "); .isosurface.plot_function(::deformation_bond_density_grid)
         case("deformation_density             "); .isosurface.plot_function(::deformation_density_grid)
         case("deformation_dft_eff_potential   "); .isosurface.plot_function(::def_dft_eff_pot_grid)
         case("deformation_dft_energy          "); .isosurface.plot_function(::def_dft_energy_grid)
         case("deformation_dft_xc_potential    "); .isosurface.plot_function(::def_dft_xc_pot_grid)
         case("deformation_electric_potential  "); .isosurface.plot_function(::def_e_pot_grid)
         case("deformation_g_kinetic_energy    "); .isosurface.plot_function(::def_G_kinetic_grid)
         case("deformation_h_dft_energy        "); .isosurface.plot_function(::def_H_dft_energy_grid)
         case("deformation_k_kinetic_energy    "); .isosurface.plot_function(::def_K_kinetic_grid)
         case("deformation_laplacian           "); .isosurface.plot_function(::def_laplacian_grid)
         case("dft_eff_potential               "); .isosurface.plot_function(::dft_eff_pot_grid)
         case("dft_energy                      "); .isosurface.plot_function(::dft_energy_grid)
         case("dft_xc_potential                "); .isosurface.plot_function(::dft_xc_pot_grid)
         case("electric_potential              "); .isosurface.plot_function(::electric_potential_grid)
         case("electron_density                "); .isosurface.plot_function(::electron_density_grid)
         case("elf                             "); .isosurface.plot_function(::ELF_grid)
         case("eli_d                           "); .isosurface.plot_function(::ELI_D_grid)
         case("fermi_mobility                  "); .isosurface.plot_function(::fermi_mobility_grid)
         case("g_kinetic_energy                "); .isosurface.plot_function(::G_kinetic_energy_grid)
         case("grad_rho_on_rho                 "); .isosurface.plot_function(::grad_rho_on_rho_grid)
         case("h_dft_energy                    "); .isosurface.plot_function(::H_dft_energy_grid)
         case("hirshfeld_density               "); .isosurface.plot_function(::Hirshfeld_density_grid)
         case("hirshfeld_weight                "); .isosurface.plot_function(::Hirshfeld_density_grid)
         case("k_kinetic_energy                "); .isosurface.plot_function(::K_kinetic_energy_grid)
         case("laplacian                       "); .isosurface.plot_function(::laplacian_grid)
         case("local_ionisation_energy         "); .isosurface.plot_function(::local_ionisation_grid)
         case("orbital                         "); .isosurface.plot_function(::orbital_grid)
         case("oscillator_orbital              "); .isosurface.plot_function(::oscillator_orbital_grid)
         case("orbital_density                 "); .isosurface.plot_function(::orbital_density_grid)
         case("promolecule_density             "); .isosurface.plot_function(::promolecule_density_grid)
         case("spin_density                    "); .isosurface.plot_function(::spin_density_grid)
         case("stockholder_density             "); .isosurface.plot_function(::stockholder_density_grid)
         case("stockholder_weight              "); .isosurface.plot_function(::Hirshfeld_density_grid)
         case("true_fermi_mobility             "); .isosurface.plot_function(::true_fermi_mobility_grid)
         case("tsirelson_elf                   "); .isosurface.plot_function(::Tsirelson_ELF_grid)
         case default;                UNKNOWN(.isosurface.surface_property)
      end
   end

!  ============================
!  Nuclear & electric potential
!  ============================

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
   ! This is useful for numerical integration of nuclear attraction
   ! integrals. Dummay atom charges are included.
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      n_pts,n,i :: INT
      Z_n,r :: REAL
      pos :: VEC{REAL}(3)

      n_pts = size(pts,1)
      values = ZERO
      do n = 1,.n_atom
         Z_n = .atom(n).nuclear_charge
         pos = .atom(n).position
         do i = 1,n_pts
            r = pos.distance_to(pts(i,:))
            if (r>tiny(r)) then
              values(i) = values(i) + Z_n / r
            else
              values(i) = values(i) + huge(ONE)
            end
         end
      end

   end

   electric_potential(values,grid,charges,positions) ::: selfless
   ! Calculate the electric potential "values" at a set of "grid" points, coming
   ! from a given set "charges" located at "positions".  This is useful for
   ! numerical integration of the potential.
      values,charges :: VEC{REAL}
      grid,positions :: MAT{REAL}

   ENSURE(charges.dim==positions.dim1,"inconsistent charges and positions arrays")
   ENSURE(positions.dim2==3,"wrong 2nd dimension, positions array")
   ENSURE(values.dim==grid.dim1,"inconsistent values and grid array")

      n,i :: INT
      q,r :: REAL
      pos :: VEC{REAL}(3)

      values = ZERO
      do n = 1,charges.dim
         q = charges(n)
         pos = positions(n,:)
         do i = 1,grid.dim1
            r = pos.distance_to(grid(i,:))
            if (r>tiny(r)) then
              values(i) = values(i) + q / r
            else
              values(i) = values(i) + TEN**6 ! something very large
            end
         end
      end

   end

!  ============
!  Orbital grid
!  ============

   make_orbital_grid
   ! Work out the orbital on ".plot_grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      arch :: ARCHIVE
      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      gcu,gcd :: VEC{CPX}*
      orb :: INT
      relativity,okind :: STR

      ! Restricted or general complex?
      okind = .natural_orbitals.spinorbital_kind

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Kind of relativity to use
      relativity = "none"
      if (.scfdata.created) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if   

      select case (relativity)

         case ("douglas-kroll-hess","dkh")

            select case (okind)

               case("restricted") 
                  WARN("NOTE: You will loose the phase of the ploted orbitals! :(")
                  WARN("to obtain the phase (signs) switch use_PCE_corr off!!")
                  gr.create(.plot_grid.n_pt)
                  .::make_DKH_orbital_grid_r(gr,orb,pt,square=FALSE)
                  .::dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy

               case default
                  DIE("unimplemented")
            end

         case ("iotc")

            select case (okind)

               case("restricted") 
                  WARN("NOTE: You will loose the phase of the ploted orbitals! :(")
                  WARN("to obtain the phase (signs) switch use_PCE_corr off!!")
                  gr.create(.plot_grid.n_pt)
                  .::make_IOTC_orbital_grid_r(gr,orb,pt,square=FALSE)
                  .::dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy

               case default
                  DIE("unimplemented")
            end

         case ("none")

            select case (okind)

               case("restricted") 
                  gr.create(.plot_grid.n_pt)
                  .::make_orbital_grid_r(gr,.natural_orbitals.restricted(:,orb),pt)
                  .::dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy

               case("general_complex") 
                  gcu.create(.plot_grid.n_pt)
                  gcd.create(.plot_grid.n_pt)
                  .::make_orbital_grid_gc(gcu,gcd,.natural_orbitals.general_complex(:,orb),pt)
                  arch.set(.name,"orbital_"//trim(orb.to_str)//"_grid",format="ascii")
                  arch.write_orbital(gcu,gcd,.plot_grid.n_pt)
                  gcu.destroy
                  gcd.destroy

               case default
                  DIE("unimplemented")
            end

         case default

            DIE("Unimplemented")

      end

      pt.destroy

   end

   orbital_grid(g,pt) ::: selfless
   ! Work out the orbital grid "g" for a series of points "pt" for using
   ! the ".natural orbitals", for a partcular orbital .plot_grid.orbital.
   ! NOTE: for complex orbitals, the absolute value times the sign of
   ! the complex part
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      gc :: VEC{CPX}*
      n_pt,orb :: INT
      grid :: PLOT_GRID*
      self :: MOLECULE*

      ! Get back self
      .BASE:set_from_saved_self

      n_pt = pt.dim1
      grid => .isosurface.plot_grid
      orb = grid.orbital

      if (orb==0) then
         if      (grid.HOMO_orbital/=0 ) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                 orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end

      if (trim(.natural_orbitals.number_kind)== "real") then
         .::make_orbital_grid_r(g,.natural_orbitals.restricted(:,orb),pt)
      else
         gc.create(n_pt)
         .::make_orbital_grid_c(gc,.natural_orbitals.restricted_complex(:,orb),pt)
         g = sign(RE(gc),IM(gc))
         gc.destroy
      end

   end

   make_orbital_grid_r(g,orb,pt,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt"
      g :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,a,fa,la,na :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      g = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)

         sh.make_grid(sh_grid,pt)

         g.plus_product_of(sh_grid,orb(fa:la))

         sh_grid.destroy
         sh.destroy_ptr_part

      end

      if (sq) g = g*g

   end

   make_orbital_grid_c(g,orb,pt,square)
   ! Evaluate the orbital density for *one* AO-basis orbital coefficient vector
   ! "orb" on a set of grid points "pt"
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,a,fa,la,na :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      g = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)

         sh.make_grid(sh_grid,pt)

         g.plus_product_of(sh_grid,orb(fa:la))

         sh_grid.destroy
         sh.destroy_ptr_part

      end

      if (sq) g = conjg(g)*g

   end

   make_orbital_grid_gc(g,orb,pt)
   ! Evaluate the orbital density for *one* AO-basis orbital coefficient vector
   ! "orb" on a set of grid points "pt"
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      gu,gd :: VEC{CPX}*
      n_pt,np,fa,la,na,a :: INT

      n_pt = pt.dim1
      np   = .n_prim

      gu.create(n_pt)
      gd.create(n_pt)

      g  = ZERO
      gu = ZERO
      gd = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)

         gu.plus_product_of(sh_grid,orb(fa   :la   )) ! aa or ba
         gd.plus_product_of(sh_grid,orb(fa+np:la+np)) !ab or bb

         sh_grid.destroy
         sh.destroy_ptr_part

      end

      g = conjg(gu)*gu + conjg(gd)*gd 

      gu.destroy
      gd.destroy

   end

   make_orbital_grid_gc(gu,gd,orb,pt)
   ! Evaluate the orbital density for *one* AO-basis orbital coefficient vector
   ! "orb" on a set of grid points "pt"
      gu,gd :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,np,fa,la,na,a :: INT

      n_pt = pt.dim1
      np   = .n_prim

      gu = ZERO
      gd = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na)

         sh.make_grid(sh_grid,pt)

         gu.plus_product_of(sh_grid,orb(fa   :la   )) ! aa or ba
         gd.plus_product_of(sh_grid,orb(fa+np:la+np)) !ab or bb

         sh_grid.destroy
         sh.destroy_ptr_part

      end

   end

!  ====================
!  Orbital density grid
!  ====================

   make_orbital_density_grid
   ! Work out the orbital on ".plot_grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      gc :: VEC{CPX}*
      orb :: INT
      relativity,okind :: STR

      ! Restricted or general complex?
      okind = .natural_orbitals.spinorbital_kind

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Orbital density here
      gr.create(.plot_grid.n_pt)

      ! Kind of relativity to use
      relativity = "none"
      if (.scfdata.created) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if   

      select case (relativity)

         case ("douglas-kroll-hess","dkh")

            select case (okind)

               case("restricted") 
                  .::make_DKH_orbital_grid_r(gr,orb,pt,square=TRUE)

               case("general_complex") 
                  gc.create(.plot_grid.n_pt)
                  .::make_DKH_orb_dens_grid_gc(gc,orb,pt)
                  gr = RE(gc)
                  gc.destroy

               case default
                  DIE("unimplemented")

            end

         case ("iotc")

            select case (okind)

               case("restricted") 
                  .::make_IOTC_orbital_grid_r(gr,orb,pt,square=TRUE)

               case("general_complex") 
                  gc.create(.plot_grid.n_pt)
                  .::make_IOTC_orb_dens_grid_gc(gc,orb,pt)
                  gr = RE(gc)
                  gc.destroy

               case default
                  DIE("unimplemented")
            end

         case ("none")

            select case (okind)

               case("restricted") 
                  .::make_orbital_grid_r(gr,.natural_orbitals.restricted(:,orb),pt,square=TRUE)

               case("general_complex") 
                  gc.create(.plot_grid.n_pt)
                  .::make_orbital_grid_gc(gc,.molecular_orbitals.general_complex(:,orb),pt)
                  gr = RE(gc)
                  gc.destroy

               case default
                  DIE("unimplemented")
            end

         case default

            DIE("Unimplemented")

      end

      .::dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_density_grid")

      gr.destroy
      pt.destroy

   end

   orbital_density_grid(g,pt) ::: selfless
   ! Work out the orbital density grid "g" for a series of points "pt" for using
   ! the ".natural orbitals", for a partcular orbital .plot_grid.orbital.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      gc :: VEC{CPX}*
      n_pt,orb :: INT
      grid :: PLOT_GRID*
      self :: MOLECULE*

      ! Get back self
      .BASE:set_from_saved_self

      n_pt = pt.dim1
      grid => .isosurface.plot_grid

      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0 ) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                 orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end

      if (trim(.natural_orbitals.number_kind)== "real") then
         .::make_orbital_grid_r(g,.natural_orbitals.restricted(:,orb),pt,square=TRUE)
      else
         gc.create(n_pt)
         .::make_orbital_grid_c(gc,.natural_orbitals.restricted_complex(:,orb),pt,square=TRUE)
         g = RE(gc)
         gc.destroy
      end

   end

! DKH restricted orbital grid

   make_DKH_orbital_grid_r(density_grid,orb,pt,square)
   ! ???
     ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
     density_grid :: VEC{REAL}, OUT 
     orb :: INT, IN
     pt :: MAT{REAL}, IN
     square :: BIN, IN, optional
     MO :: MAT{REAL}*

        MO => .molecular_orbitals.restricted(:,1:.n_a)

        .::density_DKH_orb_r(density_grid,pt,MO(:,orb),square)

   end

   density_DKH_orb_r(density_grid,pt,MO,square)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      density_grid :: VEC{REAL} , OUT
      pt :: MAT{REAL} , IN
      MO :: VEC{REAL} , IN
      square :: BIN , IN, optional

      n_gcm,n_pt :: INT
      n,i,j :: INT
      g :: REAL
      m_out :: MAT{INT}* 
      YU,GG,S,R,Z,PZP,PPZPP :: MAT{REAL}*
      P2,Ap,Ep :: VEC{REAL}*

      n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)  

      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      S.create(n_gcm,n_gcm)
      S=ZERO 
      .REL:get_da_gcm_now(R,S,m_out) 
      R.destroy 

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .REL:make_DKH_mxs(YU,Ap,Ep,P2)

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      .REL:make_DKH_mxs2(Z,PZP,YU)

      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
         PPZPP.create(n_gcm,n_gcm)
        .REL:make_DKH_mxs4(PPZPP,YU)
      end if

      GG.create(.n_bf,.n_bf)

      do n = 1,n_pt

         ! here it comes babes
         ! point for point the density will be on and on calculated
         ! I am sincerely sorry, but the code comparing to its non-relativistic
         ! counterpart is really not effective :(
         .::make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,Z,PZP,PPZPP)

         g = ZERO

         ! This is a diangonal change-basis & sum --dylan
         do i=1,.n_bf
         do j=1,.n_bf
           g = g + MO(i)*GG(i,j)*MO(j)
         end            
         end            

         ! Unfortunatelly the PCE corrected orbitals lose phase :(
         if (NOT square) g = sqrt(g)

         density_grid(n) = g

      end

      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
         PPZPP.destroy
      end if

      S.destroy
      Z.destroy
      PZP.destroy
      GG.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy

   end

   make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,PPZPP) ::: private
   ! correct the picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_core_matrix(H) routine
      self :: IN
      GG :: MAT{REAL}, OUT
      YU :: MAT{REAL}, IN
      Ap,Ep,P2 :: VEC{REAL}, IN
      xx,yy,zz :: REAL, IN
      m_out :: MAT{INT}, IN
      n_gcm :: INT, IN
      S,sZ,sPZP :: MAT{REAL}, IN
      PPZPP :: MAT{REAL}, optional, IN

      c :: REAL  
      i,j,k :: INT   
      R :: MAT{REAL}*  
      D,PDP,PPDPP,T,WW,W2,X,TX :: MAT{REAL}*
      SOx,SOy,SOz,sPZPx,sPZPy,sPZPz,ZXX,PZPXX :: MAT{REAL}*
      Rx,Ry,Rz :: MAT{REAL}*
      A,B,Z,PZP :: MAT{REAL}*
      M,buco :: MAT{REAL}* 

      !!!  the density operator X !!!
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_density_matrix(R,xx,yy,zz)

      ! put the potential energy matrix into the n_gcm non-redundant space
      D.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,D,m_out)  
 
      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,D,transpose_a=TRUE)
      D.to_product_of(A,YU)
 
      !!!  PDP MATRIX  !!!
      .REL:make_primitive_pDp_matrix(R,xx,yy,zz) 
 
      ! put the PDP matrix into the n_gcm non-redundant space
      PDP.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,PDP,m_out)  
      A.to_product_of(YU,PDP,transpose_a=TRUE)
      PDP.to_product_of(A,YU)
 
      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
         .REL:make_primitive_ppDpp_matrix(R,xx,yy,zz) 
         PPDPP.create(n_gcm,n_gcm)
         .REL:get_da_gcm_now(R,PPDPP,m_out)  
         A.to_product_of(YU,PPDPP,transpose_a=TRUE)
         PPDPP.to_product_of(A,YU)
      end if 
 
      !!! A-O LETS GO !!!
      c = SPEED_OF_LIGHT_AU
 
      do i = 1,n_gcm
      do j = 1,n_gcm
         D(i,j) = Ap(i)*D(i,j)*Ap(j)
         PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
      end
      end
 
      B.create(n_gcm,n_gcm) 
 
      if (.scfdata.DK1_PCE) then

         A = ZERO
         B = ZERO  

         do i = 1,n_gcm
            B(i,i) = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
            A(i,i) = ONE/B(i,i)
         end do
 
         T.create(n_gcm,n_gcm)
         T =     matmul(sPZP, matmul(A,PDP) )
         T = T - matmul(sPZP,D)
         T = T - matmul(sZ,PDP)
         T = T + matmul(sZ, matmul(B,D) )
         T = T + matmul(D, matmul(B,sZ) )
         T = T - matmul(PDP,sZ)
         T = T - matmul(D,sPZP)
         T = T + matmul(PDP, matmul(A,sPZP) )

         if (.scfdata.using_SO_FDFF) then

            ! these are additional scalar terms due to presence of SO terms
            ! - (SOx*1/P2*sSOx + SOy*1/P2*sSOy + SOz*1/P2*sSOz 
            ! sSOx*1/P2*SOx + sSOy*1/P2*SOy + sSOz*1/P2*SOz)

            !!!  SO MATRICES  !!!
            SOx.create(n_gcm,n_gcm)
            SOy.create(n_gcm,n_gcm)
            SOz.create(n_gcm,n_gcm)

            ! put the SO matrices into the n_gcm non-redundant space
            Rx.create(.n_prim,.n_prim)
            Ry.create(.n_prim,.n_prim)
            Rz.create(.n_prim,.n_prim)

            .REL:make_primitive_pDp_SO_matrix(Rx,Ry,Rz,xx,yy,zz) 
            .REL:get_da_gcm_now(Rx,SOx,m_out)  
            .REL:get_da_gcm_now(Ry,SOy,m_out)  
            .REL:get_da_gcm_now(Rz,SOz,m_out)  

            Rx.destroy
            Ry.destroy
            Rz.destroy

              ZXX.create(n_gcm,n_gcm)
            PZPXX.create(n_gcm,n_gcm) 
      
            ZXX.to_product_of(YU,SOx,transpose_a=TRUE)
            SOx.to_product_of(ZXX,YU)
            ZXX.to_product_of(YU,SOy,transpose_a=TRUE)
            SOy.to_product_of(ZXX,YU)
            ZXX.to_product_of(YU,SOz,transpose_a=TRUE)
            SOz.to_product_of(ZXX,YU)

            do i = 1,n_gcm
            do j = 1,n_gcm
               SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
               SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
               SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
            end
            end
 
            sPZPx.create(n_gcm,n_gcm)
            sPZPy.create(n_gcm,n_gcm)
            sPZPz.create(n_gcm,n_gcm)
 
            .::make_DKH_mxs3(ZXX,PZPXX,sPZPx,sPZPy,sPZPz,YU)
 
            ZXX.destroy
            PZPXX.destroy
 
            T = T - matmul(SOx, matmul(A,sPZPx) ) 
            T = T - matmul(SOy, matmul(A,sPZPy) ) 
            T = T - matmul(SOz, matmul(A,sPZPz) ) 
            T = T - matmul(sPZPx, matmul(A,SOx) )
            T = T - matmul(sPZPy, matmul(A,SOy) )
            T = T - matmul(sPZPz, matmul(A,SOz) )
     
            SOx.destroy
            SOy.destroy
            SOz.destroy;
            sPZPx.destroy
            sPZPy.destroy
            sPZPz.destroy;
 
         end if
 
         if (.scfdata.DK2_PCE) then

            !!! W1W1
            WW.create(n_gcm,n_gcm)
            WW =    - matmul(sZ, matmul(B,sZ) )
            WW = WW + matmul(sPZP,sZ) 
            WW = WW + matmul(sZ,sPZP) 
            WW = WW - matmul(sPZP, matmul(A,sPZP) ) 
      
            X.create(n_gcm,n_gcm)
            TX.create(n_gcm,n_gcm)
            X = D + PDP
            TX=HALF*(matmul(WW,X)+matmul(X,WW))
            WW.destroy
      
            Z.create(n_gcm,n_gcm)
            PZP.create(n_gcm,n_gcm)
 
            if (.scfdata.using_ppzpp) then

               ! use the second derivatives in the [W1,[W1,X(even,0)]]
               ! and [W2,X(odd,0)] terms   

               do i=1,n_gcm
               do j=1,n_gcm
                  PPDPP(i,j) = Ap(i)*(c**4)/((Ep(i)+c*c)**2)*PPDPP(i,j)*Ap(j)/( (Ep(j)+c*c)**2 ) 
                  Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
                  PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
               end do
               end do

               X  = PPDPP + PDP
               TX = TX - matmul(sPZP,matmul(A,matmul(X,sZ)))
               TX = TX + matmul(sPZP,matmul(A, matmul(X, matmul(A,sPZP))))
               TX = TX + matmul(sZ,matmul(X,sZ))
               TX = TX - matmul(sZ,matmul(X, matmul(A,sPZP)))

               PPDPP.destroy 
               X.destroy
       
               !!! The -[W2,X(odd,0)] terms
               W2.create(n_gcm,n_gcm)
               W2 = ZERO
               do i=1,n_gcm
               do j=1,n_gcm
               do k=1,n_gcm
                  W2(i,j) = W2(i,j)                        &
                     + sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
                     - sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
                     - (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )*A(j,j)  & 
                     + (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   
               end do
               end do
               end do
               TX = TX + matmul(W2,PDP)
       
               W2 = ZERO
               do i=1,n_gcm
               do j=1,n_gcm
               do k=1,n_gcm
                  W2(i,j) = W2(i,j)                        &
                     + sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
                     - A(i,i)*sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
                     - A(i,i)*(PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )  &
                     + A(i,i)*(PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )  
               end do
               end do
               end do

               TX = TX + matmul(PDP,W2)
       
               W2 = ZERO
               do i=1,n_gcm
               do j=1,n_gcm
               do k=1,n_gcm
                  W2(i,j) = W2(i,j)                        &
                     -  B(i,i)*sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
                     +  sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
                     +  (PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   &
                     -  (PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )   
               end do
               end do
               end do

               TX = TX + matmul(D,W2)
       
               W2 = ZERO
               do i=1,n_gcm
               do j=1,n_gcm
               do k=1,n_gcm
                  W2(i,j) = W2(i,j)                         &
                    -  sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
                    +  sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
                    +  (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )    &
                    -  (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )*B(j,j)    
               end do
               end do
               end do

               TX = TX + matmul(W2,D)
       
            else  

               ! the second derivatives are not used in the
               ! [W1,[W1,E(even,0)]] and [W2,X(odd,0)] terms   

               X.destroy
               do i=1,n_gcm
               do j=1,n_gcm
                  Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
                  PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
               end do
               end do

               TX = TX - matmul(sPZP,matmul(A,matmul(PDP,sZ)))
               TX = TX - matmul(sPZP,matmul(D,matmul(B,sZ)))
               TX = TX + matmul(sPZP,matmul(A, matmul(PDP, matmul(A,sPZP))))
               TX = TX + matmul(sPZP, matmul(D,sPZP))
               TX = TX + matmul(sZ,matmul(PDP,sZ))
               TX = TX + matmul(sZ,matmul(B, matmul(D, matmul(B,sZ))))
               TX = TX - matmul(sZ,matmul(PDP, matmul(A,sPZP)))
               TX = TX - matmul(sZ,matmul(B, matmul(D,sPZP)))
       
               !!!  The [W2,X(odd,0)] terms
               !   the second derivatives are not used
               W2.create(n_gcm,n_gcm)
               W2 =    matmul( sPZP, matmul(A, matmul(PZP,A) ) )
               W2 = W2 + matmul( sPZP, Z )
               W2 = W2 - matmul( sZ, ( matmul(PZP,A) ) )
               W2 = W2 - matmul( sZ, ( matmul(B,Z) ) )
               W2 = W2 - matmul( Z,  matmul(sPZP,A)  )
               W2 = W2 - matmul( PZP,  matmul(sPZP,A)  )
               W2 = W2 + matmul( Z,  sZ  )
               W2 = W2 + matmul( PZP,  sZ  )
               do i=1,n_gcm
               do j=1,n_gcm
                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
               end do
               end do
       
               TX = TX + matmul(W2,PDP)
       
               W2 =      matmul( sZ, Z )
               W2 = W2 + matmul( sZ, PZP )
               W2 = W2 - matmul( matmul(A,sPZP), Z )
               W2 = W2 - matmul( matmul(A,sPZP), PZP )
               W2 = W2 - matmul( matmul(A,PZP)  ,   sZ)
               W2 = W2 - matmul( matmul(Z,B)  ,   sZ)
               W2 = W2 + matmul( matmul(A,matmul(PZP,A)) , sPZP)
               W2 = W2 + matmul( Z , sPZP)
               do i=1,n_gcm
               do j=1,n_gcm
                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
               end do
               end do
       
               TX = TX + matmul(PDP,W2)
       
               W2 =    - matmul( matmul(B,sZ), Z )
               W2 = W2 - matmul( matmul(B,sZ), PZP )
               W2 = W2 + matmul( sPZP  ,   Z )
               W2 = W2 + matmul( sPZP  , PZP )
               W2 = W2 + matmul( PZP   ,  sZ )
               W2 = W2 + matmul( matmul(B,matmul(Z,B)) , sZ)
               W2 = W2 - matmul( matmul(PZP,A) , sPZP )
               W2 = W2 - matmul( matmul(B,Z) , sPZP )
               do i=1,n_gcm
               do j=1,n_gcm
                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
               end do
               end do
       
               TX = TX + matmul(D,W2)
       
               W2 =    - matmul( sPZP  , matmul(A,PZP) )
               W2 = W2 - matmul( sPZP  , matmul(Z,B) )
               W2 = W2 + matmul( sZ    , PZP)
               W2 = W2 + matmul( sZ    , matmul( B, matmul(Z,B) ) )
               W2 = W2 + matmul( Z , sPZP  )
               W2 = W2 + matmul( PZP , sPZP  )
               W2 = W2 - matmul( Z ,  matmul(sZ,B) )
               W2 = W2 - matmul( PZP ,  matmul(sZ,B) )
               do i=1,n_gcm
               do j=1,n_gcm
                  W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
               end do
               end do
       
               TX = TX + matmul(W2,D)
 
            end if

            W2.destroy
            Z.destroy
            PZP.destroy
 
         end if

      end if

      D = D + PDP
      PDP.destroy

      if(.scfdata.DK1_PCE)then
         D = D + T
         T.destroy
      end if   
 
      if(.scfdata.DK2_PCE)then
         D = D + TX
         TX.destroy
      end if
 
      B.to_product_of(S,YU)
      A.to_product_of(B,D)
      D.to_product_of(A,B,transpose_b=TRUE)
 
      A.destroy
      B.destroy
 
      !!! moving back to tonto style primitive basis sets 
      ! put the Fock matrix back to the space .n_prim space
      .REL:get_back_prim_now(D,R,m_out)  
      D.destroy
 
      !!! moving back to contracted basis sets 
      M.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(M)
      buco.create(.n_bf,.n_prim)
      buco.to_product_of(M,R,transpose_a=TRUE)
      R.destroy
 
      GG.to_product_of(buco,M)
 
      M.destroy
      buco.destroy

   end   

   make_DKH_mxs3(Z,PZP,Lx,Ly,Lz,YU) ::: private
   ! get the Z and PZP matrix 
   ! which are in the momentum space
      self :: IN
      Z,PZP,Lx,Ly,Lz :: MAT{REAL}, OUT
      YU :: MAT{REAL}, IN

      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      c :: REAL
      R,SOx,SOy,SOz,A,X :: MAT{REAL}*
      Ep,Ap,P2 :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      !!!  Z MATRIX  !!!
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_nuclear_matrix(R)
      .REL:get_da_gcm_now(R,Z,m_out)  
 
      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)

      !!! PZP and SO MATRICES  !!!
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz) 
      .REL:get_da_gcm_now(R,PZP,m_out)  
      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)

      .REL:get_da_gcm_now(SOx,Lx,m_out)  
      A.to_product_of(YU,Lx,transpose_a=TRUE)
      Lx.to_product_of(A,YU)
      .REL:get_da_gcm_now(SOy,Ly,m_out)  
      A.to_product_of(YU,Ly,transpose_a=TRUE)
      Ly.to_product_of(A,YU)
      .REL:get_da_gcm_now(SOz,Lz,m_out)  
      A.to_product_of(YU,Lz,transpose_a=TRUE)
      Lz.to_product_of(A,YU)
 
      A.destroy
      R.destroy
      SOx.destroy
      SOy.destroy
      SOx.destroy
      m_out.destroy
 
      c = SPEED_OF_LIGHT_AU

      X.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .REL:make_DKH_mxs(X,Ap,Ep,P2)
 
      do i=1,n_gcm
      do j=1,n_gcm
           Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
         PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
          Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
          Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
          Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))* Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
      end
      end
 
      X.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy

   end

! DKH general complex orbital grid (naming problem?)

   make_DKH_orb_dens_grid_gc(density_grid,orb,pt)
   ! ???
      density_grid :: VEC{CPX}, OUT 
      orb :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")

      CMO :: MAT{CPX}*

      CMO => .molecular_orbitals.general_complex(:,1:.n_e)
      .::density_DKH_orb_gc(density_grid,pt,CMO(:,orb))

   end

   density_DKH_orb_gc(density,pt,MO)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density :: VEC{CPX}, OUT
      pt :: MAT{REAL}, IN
      MO :: VEC{CPX}, IN

      n_gcm,n_pt :: INT
      n,i,j :: INT
      II,gc :: CPX
      m_out :: MAT{INT}* 
      YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
      P2,Ap,Ep :: VEC{REAL}*
      SOx,SOy,SOz :: MAT{REAL}*
      GG22,Z2,PZP2 :: MAT{CPX}*

      n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)  

      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out) 
      R.destroy 

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)
      .::make_DKH_mxs_2(YU,Ap,Ep,P2)

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
      .::make_DKH_mxs3_2(Z,PZP,SOx,SOy,SOz,YU)

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
         PPZPP.create(n_gcm,n_gcm)
         .REL:make_DKH_mxs4(PPZPP,YU)
         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
      end if

      GG22.create(2*.n_bf,2*.n_bf)
        Z2.create(2*.n_bf,2*.n_bf)
      PZP2.create(2*.n_bf,2*.n_bf)

      Z2 = (ZERO,ZERO)
      Z2.alpha_alpha_plus(Z)
      Z2.beta_beta_plus(Z)

      II = (ZERO,ONE)

      PZP2 = (ZERO,ZERO)
      PZP2.alpha_alpha_plus(PZP)
      PZP2.beta_beta_plus(PZP)
      PZP2.beta_alpha_plus(SOx,II)
      PZP2.beta_alpha_plus(SOy,-ONE)
      PZP2.alpha_alpha_plus(SOz,II)
      PZP2.beta_beta_plus(SOz,-II)
      PZP2.make_hermitian

      Z.destroy
      PZP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy

      do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to its non-relativistic counterpart is really not
         ! effective :(
         .::make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,Z2,PZP2)

         gc = (ZERO,ZERO)
         do i = 1,2*.n_bf
         do j = 1,2*.n_bf
            gc = gc + conjg(MO(i))*GG22(i,j)*MO(j)
         end            
         end      

         density(n) = gc

      end

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp) PPZPP.destroy

      S.destroy
      Z2.destroy
      PZP2.destroy
      GG22.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy

   end

   make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,xx,yy,zz,n_gcm,S,sZ2,sPZP2) ::: private
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_core_matrix(H) routine
      self :: IN
      GG22 :: MAT{CPX}, OUT
      YU :: MAT{REAL}, IN
      Ap,Ep,P2 :: VEC{REAL}, IN
      xx,yy,zz :: REAL, IN
      n_gcm :: INT, IN
      S :: MAT{REAL} , IN
      sZ2,sPZP2 :: MAT{CPX}, IN

      c,fac :: REAL  
      i,j :: INT   
      D,PDP,SOx,SOy,SOz :: MAT{REAL}*  
      D2,PDP2 :: MAT{CPX}*  
      WW,W2,TX,Z2,PZP2,X,T,A2,B2,M2 :: MAT{CPX}*  
      A,B,M :: MAT{REAL}*
      II :: CPX

      !!!  the density X operator !!!
      D.create(n_gcm,n_gcm)
      .REL:make_primitive_density_matrix(D,xx,yy,zz)

      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,D,transpose_a=TRUE)
      D.to_product_of(A,YU)

      !!!  the density PXP operator !!!
      PDP.create(n_gcm,n_gcm)
      .REL:make_primitive_pDp_matrix(PDP,xx,yy,zz) 
      A.to_product_of(YU,PDP,transpose_a=TRUE)
      PDP.to_product_of(A,YU)

      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
      SOx=ZERO; SOy=ZERO; SOz=ZERO
      .REL:make_primitive_pDp_SO_matrix(SOx,SOy,SOz,xx,yy,zz) 
      A.to_product_of(YU,SOx,transpose_a=TRUE)
      SOx.to_product_of(A,YU)
      A.to_product_of(YU,SOy,transpose_a=TRUE)
      SOy.to_product_of(A,YU)
      A.to_product_of(YU,SOz,transpose_a=TRUE)
      SOz.to_product_of(A,YU)
      A.destroy

      !!! A-O LETS GO !!!

      B.create(2*n_gcm,2*n_gcm) 
      A.create(2*n_gcm,2*n_gcm) 

      c = SPEED_OF_LIGHT_AU

      do i=1,n_gcm
      do j=1,n_gcm
         D(i,j) = Ap(i)*D(i,j)*Ap(j)                                        
         PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
         SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
         SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
         SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
      end
      end

      D2.create(2*n_gcm,2*n_gcm)
      D2=(ZERO,ZERO)
      D2.alpha_alpha_plus(D)
      D2.beta_beta_plus(D)

      II = (ZERO,ONE)
      fac=ONE

      PDP2.create(2*n_gcm,2*n_gcm)
      PDP2=(ZERO,ZERO)
      PDP2.alpha_alpha_plus(PDP)
      PDP2.beta_beta_plus(PDP)
      PDP2.beta_alpha_plus(SOx,fac*II)
      PDP2.beta_alpha_plus(SOy,-fac)
      PDP2.alpha_alpha_plus(SOz,fac*II)
      PDP2.beta_beta_plus(SOz,-fac*II)
      PDP2.make_hermitian

      D.destroy
      PDP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy

      if (.scfdata.DK1_PCE) then

         A = ZERO  
         B = ZERO  

         do i = 1,n_gcm
             B(i,i)             = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
             B(i+n_gcm,i+n_gcm) = (c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
             A(i,i)             = ONE/B(i,i)
             A(i+n_gcm,i+n_gcm) = ONE/B(i,i)
         end

         ! SO part comes first 
         ! fdff am not sure if it is implemented, seems not
         T.create(2*n_gcm,2*n_gcm)
         T =        matmul(sPZP2, matmul(A,PDP2) )
         T =  T  -  matmul(sPZP2,D2)
         T =  T  -  matmul(sZ2,PDP2)
         T =  T  +  matmul(sZ2, matmul(B,D2) )
         T =  T  +  matmul(D2, matmul(B,sZ2) )
         T =  T  -  matmul(PDP2,sZ2)
         T =  T  -  matmul(D2,sPZP2)
         T =  T  +  matmul(PDP2, matmul(A,sPZP2) )

         ! only the scalar second order correction
         if (.scfdata.DK2_PCE) then

            !!! W1W1
            WW.create(2*n_gcm,2*n_gcm)
            WW =      -  matmul(sZ2, matmul(B,sZ2) )
            WW =  WW  +  matmul(sPZP2,sZ2) 
            WW =  WW  +  matmul(sZ2,sPZP2) 
            WW =  WW  -  matmul(sPZP2, matmul(A,sPZP2) ) 
      
            X.create(2*n_gcm,2*n_gcm)
            TX.create(2*n_gcm,2*n_gcm)

            X  = D2 + PDP2
            TX = HALF*(matmul(WW,X)+matmul(X,WW))

            WW.destroy
            X.destroy
      
            Z2.create(2*n_gcm,2*n_gcm)
            PZP2.create(2*n_gcm,2*n_gcm)

            Z2   = (ZERO,ZERO)
            PZP2 = (ZERO,ZERO)

            do i=1,n_gcm
            do j=1,n_gcm
                Z2(i,j)=sZ2(i,j)*(Ep(i)+Ep(j))
                Z2(i+n_gcm,j+n_gcm)=sZ2(i+n_gcm,j+n_gcm)*(Ep(i)+Ep(j))
                PZP2(i,j)=sPZP2(i,j)*(Ep(i)+Ep(j))
                PZP2(i+n_gcm,j+n_gcm)=sPZP2(i+n_gcm,j+n_gcm)*(Ep(i)+Ep(j))
                PZP2(i,j+n_gcm)=sPZP2(i,j+n_gcm)*(Ep(i)+Ep(j))
                PZP2(i+n_gcm,j)=sPZP2(i+n_gcm,j)*(Ep(i)+Ep(j))
            end do
            end do
    
            TX = TX - matmul(sPZP2,matmul(A,matmul(PDP2,sZ2)))
            TX = TX - matmul(sPZP2,matmul(D2,matmul(B,sZ2)))
            TX = TX + matmul(sPZP2,matmul(A, matmul(PDP2, matmul(A,sPZP2))))
            TX = TX + matmul(sPZP2, matmul(D2,sPZP2))
            TX = TX + matmul(sZ2,matmul(PDP2,sZ2))
            TX = TX + matmul(sZ2,matmul(B, matmul(D2, matmul(B,sZ2))))
            TX = TX - matmul(sZ2,matmul(PDP2, matmul(A,sPZP2)))
            TX = TX - matmul(sZ2,matmul(B, matmul(D2,sPZP2)))
    
            !!!  The [W2,X(odd,0)] terms
            !   the second derivatives are not used
            W2.create(2*n_gcm,2*n_gcm)
            W2 =      matmul( sPZP2, matmul(A, matmul(PZP2,A) ) )
            W2 = W2 + matmul( sPZP2, Z2 )
            W2 = W2 - matmul( sZ2, ( matmul(PZP2,A) ) )
            W2 = W2 - matmul( sZ2, ( matmul(B,Z2) ) )
            W2 = W2 - matmul( Z2,  matmul(sPZP2,A)  )
            W2 = W2 - matmul( PZP2,  matmul(sPZP2,A)  )
            W2 = W2 + matmul( Z2,  sZ2  )
            W2 = W2 + matmul( PZP2,  sZ2  )
            do i=1,n_gcm
            do j=1,n_gcm
               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) ) 
               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) ) 
               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) ) 
            end do
            end do
    
            TX = TX + matmul(W2,PDP2)
    
            W2 =    matmul( sZ2, Z2 )
            W2 = W2 + matmul( sZ2, PZP2 )
            W2 = W2 - matmul( matmul(A,sPZP2), Z2 )
            W2 = W2 - matmul( matmul(A,sPZP2), PZP2 )
            W2 = W2 - matmul( matmul(A,PZP2)  ,   sZ2)
            W2 = W2 - matmul( matmul(Z2,B)  ,   sZ2)
            W2 = W2 + matmul( matmul(A,matmul(PZP2,A)) , sPZP2)
            W2 = W2 + matmul( Z2 , sPZP2)
            do i=1,n_gcm
            do j=1,n_gcm
               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) ) 
               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) ) 
               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) ) 
            end do
            end do
    
            TX = TX + matmul(PDP2,W2)
    
            W2 =    - matmul( matmul(B,sZ2), Z2 )
            W2 = W2 - matmul( matmul(B,sZ2), PZP2 )
            W2 = W2 + matmul( sPZP2  ,   Z2 )
            W2 = W2 + matmul( sPZP2  , PZP2 )
            W2 = W2 + matmul( PZP2   ,  sZ2 )
            W2 = W2 + matmul( matmul(B,matmul(Z2,B)) , sZ2)
            W2 = W2 - matmul( matmul(PZP2,A) , sPZP2 )
            W2 = W2 - matmul( matmul(B,Z2) , sPZP2 )
            do i=1,n_gcm
            do j=1,n_gcm
               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) ) 
               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) ) 
               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) ) 
            end do
            end do
    
            TX = TX + matmul(D2,W2)
    
            W2 =    - matmul( sPZP2  , matmul(A,PZP2) )
            W2 = W2 - matmul( sPZP2  , matmul(Z2,B) )
            W2 = W2 + matmul( sZ2    , PZP2)
            W2 = W2 + matmul( sZ2    , matmul( B, matmul(Z2,B) ) )
            W2 = W2 + matmul( Z2 , sPZP2  )
            W2 = W2 + matmul( PZP2 , sPZP2  )
            W2 = W2 - matmul( Z2 ,  matmul(sZ2,B) )
            W2 = W2 - matmul( PZP2 ,  matmul(sZ2,B) )
            do i=1,n_gcm
            do j=1,n_gcm
               W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
               W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) ) 
               W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) ) 
               W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) ) 
            end do
            end do
    
            TX = TX + matmul(W2,D2)
    
            W2.destroy 
            Z2.destroy
            PZP2.destroy

         end if

      end if

      D2 = D2 + PDP2

      PDP2.destroy

      if(.scfdata.DK1_PCE)then
         D2 = D2 + T
         T.destroy
      end if

      if(.scfdata.DK2_PCE)then
         D2 = D2 + TX
         TX.destroy
      end if

      A.destroy
      B.destroy

      ! back to cartesian basis set
      A2.create(2*n_gcm,2*n_gcm)

      B2.create(2*n_gcm,2*n_gcm)
      B.create(n_gcm,n_gcm) 

      B.to_product_of(S,YU)
      B2 = (ZERO,ZERO)
      B2.alpha_alpha_plus(B)
      B2.beta_beta_plus(B)

      A2.to_product_of(B2,D2)
      D2.to_product_of(A2,B2,dagger_b=TRUE)
 
      B.destroy
      B2.destroy
 
      !!! moving back to contracted basis sets 
      M2.create(2*.n_prim,2*.n_prim)
      M.create(.n_prim,.n_prim)

      .BASE:make_normalised_contraction_mx(M)

      M2 = (ZERO,ZERO)
      M2.alpha_alpha_plus(M)
      M2.beta_beta_plus(M)
      A2.to_product_of(M2,D2,dagger_a=TRUE)
      D2.to_product_of(A2,M2)
 
      GG22 = D2

      .BASE:put_debug(GG22,"GG22 matrix")

      M.destroy
      M2.destroy
      A2.destroy
      D2.destroy

   end   

   make_DKH_mxs_2(YU,Ap,Ep,P2) ::: private
   ! things necessary for the DKH transformation 
   ! within the PCE and the dkh_norm staff
      self :: IN
      YU :: MAT{REAL}, OUT
      Ap,Ep :: VEC{REAL}, OUT
      P2 :: VEC{REAL}
 
      m_out :: MAT{INT}* 
      i,n_gcm :: INT
      c :: REAL
      S,Y,U :: MAT{REAL}*
 
      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)
 
      !!! OVERLAP ENERGY MATRIX  !!!
      S.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(S)
      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)
 
      !!!  KINETIC ENERGY MATRIX  !!!
      .REL:make_primitive_kinetic_matrix(S) 
      m_out.destroy
 
      U.create(n_gcm,n_gcm)
      U.to_product_of(Y,S)   
      S.to_product_of(U,Y)   
      S.solve_eigenproblem(P2,U)
      S.destroy

      P2= TWO * P2
 
      c = SPEED_OF_LIGHT_AU
      do i = 1,n_gcm
         Ep(i)= c * sqrt(P2(i) + c * c)
         Ap(i)= sqrt( (Ep(i) + c * c)/(TWO * Ep(i)) )  
      end  
 
      YU.to_product_of(Y,U)
 
      Y.destroy
      U.destroy

   end

   make_DKH_mxs3_2(Z,PZP,Lx,Ly,Lz,YU) ::: private
   ! get the Z and PZP matrix 
   ! which are in the momentum space
      self :: IN
      Z,PZP,Lx,Ly,Lz :: MAT{REAL}, OUT
      YU :: MAT{REAL}, IN

      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      c :: REAL
      A,X :: MAT{REAL}*
      Ep,Ap,P2 :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)

      !!!  Z MATRIX  !!!
      .REL:make_primitive_nuclear_matrix(Z)
 
      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)
 
      !!!  PZP and SO MATRICES  !!!
      .REL:make_primitive_DKH_matrices(PZP,Lx,Ly,Lz) 
      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)
      A.to_product_of(YU,Lx,transpose_a=TRUE)
      Lx.to_product_of(A,YU)
      A.to_product_of(YU,Ly,transpose_a=TRUE)
      Ly.to_product_of(A,YU)
      A.to_product_of(YU,Lz,transpose_a=TRUE)
      Lz.to_product_of(A,YU)
 
      A.destroy
      m_out.destroy
 
      c = SPEED_OF_LIGHT_AU

      X.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

      .REL:make_DKH_mxs(X,Ap,Ep,P2)
 
      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
         PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
         Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
         Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
         Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
      end
      end
 
      X.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy

   end

! IOTC real orbitals

   make_IOTC_orbital_grid_r(density_grid,orb,pt,square) 
   !  ???
      self :: IN
      density_grid :: VEC{REAL}, OUT 
      orb :: INT, IN
      pt :: MAT{REAL}, IN
      square :: BIN, IN, optional

   ENSURE(.molecular_orbitals.created("restricted"),"no MO's")

      MO :: MAT{REAL}*

      MO => .molecular_orbitals.restricted(:,1:.n_a)

      .::density_IOTC_orb_r(density_grid,pt,MO(:,orb),square)

   end

   density_IOTC_orb_r(density_grid,pt,MO,square) 
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      MO :: VEC{REAL}, IN
      square :: BIN, optional, IN

      n_gcm,n_pt :: INT
      n,i,j,k :: INT
      g,c,alpha,alpha2 :: REAL
      m_out :: MAT{INT}*
      R,Y,U,A,T,O :: MAT{REAL}*
      SOx,SOy,SOz,Yr :: MAT{REAL}*
      YU,GG,S,Z,PZP :: MAT{REAL}*
      P2,Ap,E,p,ep,bp :: VEC{REAL}*

      n_pt = pt.dim1

      !!! analysis of the primitive basis set via the overap matrix
      !!! trying to lower the problem to an general contracted basis set
      !!!  OVERLAP MATRIX !!!
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      m_out.create(.n_prim,.n_prim) 
      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)  
      ! put the overlap matrix into the n_gcm non-redundant space
      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out)  
 
      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)
 
      !!!  KINETIC ENERGY MATRIX !!!
      .REL:make_primitive_kinetic_matrix(R) 
      T.create(n_gcm,n_gcm)
      ! put the kinetic energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,T,m_out)  
 
      A.create(n_gcm,n_gcm)
      A.to_product_of(Y,T)   
      T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
      U.create(n_gcm,n_gcm)
      P2.create(n_gcm)
      T.solve_eigenproblem(P2,U)
      P2= TWO * P2
      YU.create(n_gcm,n_gcm)
      YU.to_product_of(Y,U)
      T.destroy
      Y.destroy
      U.destroy
 
      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
      .REL:make_primitive_nuclear_matrix(R)
      Z.create(n_gcm,n_gcm)
      ! put the potential energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,Z,m_out)  
 
      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)
 
      !!!  PZP MATRIX  !!!
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
      SOx.destroy
      SOy.destroy
      SOz.destroy
 
      PZP.create(n_gcm,n_gcm)
      ! put the PZP matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,PZP,m_out) 
 
      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)
 
      !!! A-O LETS GO !!!
      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha
 
      E.create(n_gcm)
      p.create(n_gcm)
      ep.create(n_gcm)
      Ap.create(n_gcm)
      bp.create(n_gcm)
 
      do i = 1,n_gcm
         E(i)  = c * sqrt(P2(i) + c*c)
         p(i)  = sqrt(P2(i))
         ep(i) = sqrt(ONE+P2(i)*alpha2) 
         Ap(i) = sqrt( (E(i) + c * c)/(TWO * E(i)) )  
         bp(i) = ONE/(ep(i)+ONE)
      end  

      P2.destroy
 
      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
      end
      end
 
      ! lets find the transforation matrix
      Yr.create(n_gcm,n_gcm)
 
      .REL:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
 
      ! lets make ready the normalzation matrix
      O.create(n_gcm,n_gcm)
      O = ZERO
      do i = 1,n_gcm
         O(i,i) = ONE
         do j=1,n_gcm
         do k=1,n_gcm
            O(i,j) = O(i,j) + Yr(k,i)*Yr(k,j)
         end do
         end do
      end do
 
      A.to_inverse_sqrt_of(O)
      O = A
      Z.destroy
      PZP.destroy
      A.destroy
 
      GG.create(.n_bf,.n_bf)

      do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .::make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
 
         g = ZERO
 
         do i = 1,.n_bf
         do j = 1,.n_bf
            g = g + MO(i)*GG(i,j)*MO(j)
         end            
         end           
 
         ! unfortunatelly the PCE corrected orbitals lose phase :(
         if (NOT square) g = sqrt(g)
 
         density_grid(n) = g
 
      end
 
      R.destroy
      S.destroy
      O.destroy
      GG.destroy
      YU.destroy
      Yr.destroy
      Ap.destroy
      E.destroy
      p.destroy
      bp.destroy
      ep.destroy
      m_out.destroy

   end

   make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O) ::: private
   ! correct the picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_core_matrix(H) routine
      self :: IN
      GG :: MAT{REAL} , OUT
      Yr,YU :: MAT{REAL} , IN
      Ap,bp,p :: VEC{REAL} , IN
      ep :: VEC{REAL}
      xx,yy,zz :: REAL , IN
      m_out :: MAT{INT} , IN
      n_gcm :: INT , IN
      S,O :: MAT{REAL} , IN

      i,j :: INT   
      R :: MAT{REAL}*  
      D,PDP,PPDPP :: MAT{REAL}*
      A,B :: MAT{REAL}*
      M,buco :: MAT{REAL}* 

      ep = ep
 
      !!!  the density operator X !!!
      R.create(.n_prim,.n_prim)
      ! it do not exist in the moment
      .REL:make_primitive_density_matrix(R,xx,yy,zz)
      D.create(n_gcm,n_gcm)
      ! put the potential energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,D,m_out)  
 
      A.create(n_gcm,n_gcm)
      A.to_product_of(YU,D,transpose_a=TRUE)
      D.to_product_of(A,YU)
 
      !!!  PDP MATRIX  !!!
      .REL:make_primitive_pDp_matrix(R,xx,yy,zz) 
 
      PDP.create(n_gcm,n_gcm)
      ! put the PDP matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,PDP,m_out)  
      A.to_product_of(YU,PDP,transpose_a=TRUE)
      PDP.to_product_of(A,YU)
 
      if (.scfdata.using_ppzpp) then
         .REL:make_primitive_ppDpp_matrix(R,xx,yy,zz) 
         PPDPP.create(n_gcm,n_gcm)
         .REL:get_da_gcm_now(R,PPDPP,m_out)  
         A.to_product_of(YU,PPDPP,transpose_a=TRUE)
         PPDPP.to_product_of(A,YU)
      end if 
 
      !!! A-O LETS GO !!!
 
      do i=1,n_gcm
      do j=1,n_gcm
         D(i,j)   = Ap(i)*D(i,j)*Ap(j)
         PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)                                        
      end
      end
 
      if(.scfdata.using_ppzpp)then
         ! use the second derivatives in the [W1,[W1,X(even,0)]] and [W2,X(odd,0)] terms   
         do i=1,n_gcm
         do j=1,n_gcm
            PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j) 
         end do
         end do
      end if  
 
      B.create(n_gcm,n_gcm) 
      if (.scfdata.using_ppzpp) then; .::build_da_IOTC_dens(B,Yr,PDP,D,p,bp,n_gcm,PPDPP)
      else;                           .::build_da_IOTC_dens(B,Yr,PDP,D,p,bp,n_gcm)
      end if  
 
      D=ZERO
      D=matmul(O,matmul(B,O))
 
     PDP.destroy
     if(.scfdata.using_ppzpp)then
      PPDPP.destroy
     end if 
 
      B=ZERO
      B.to_product_of(S,YU)
 
      A=ZERO
      A.to_product_of(B,D)
      D.to_product_of(A,B,transpose_b=TRUE)
 
      A.destroy
      B.destroy
 
 !!! moving back to tonto style primitive basis sets 
      R=ZERO
 ! put the Fock matrix back to the space .n_prim space
      .REL:get_back_prim_now(D,R,m_out)  
      D.destroy
 
 !!! moving back to contracted basis sets 
      M.create(.n_prim,.n_bf)
      .BASE:make_normalised_contraction_mx(M)
      buco.create(.n_bf,.n_prim)
      buco.to_product_of(M,R,transpose_a=TRUE)
      R.destroy
 
      GG.to_product_of(buco,M)
 
      M.destroy
      buco.destroy

   end   

   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,n_gcm,ppApp) ::: private
   ! build the IOTC Y matrix, real version
      self :: IN
      F :: MAT{REAL}, OUT
      Yr,PAP,A :: MAT{REAL}, IN
      p,bp :: VEC{REAL}, IN
      n_gcm :: INT, IN
      ppApp :: MAT{REAL}, optional, IN

      i,j :: INT
      c,alpha,alpha2 :: REAL
      AAA,F1R,F1L,F2 :: MAT{REAL}*

      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha
 
      F1L.create(n_gcm,n_gcm)
      F1R.create(n_gcm,n_gcm)
       F2.create(n_gcm,n_gcm)
      AAA.create(n_gcm,n_gcm)
 
      if( .scfdata.using_ppzpp)then
         do i = 1,n_gcm
         do j = 1,n_gcm
            AAA(i,j) = alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
         end do
         end do
      else
         do i = 1,n_gcm
         do j = 1,n_gcm
            AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
         end do
         end do
      end
 
      do i = 1,n_gcm
      do j = 1,n_gcm
          F(i,j)  = A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) = alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
         F1R(i,j) = alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
          F2(i,j) = PAP(i,j)/p(j)/p(i) + AAA(i,j)
         end do
      end do

      F2.change_basis_using(Yr)
 
      F.plus_product_of( Yr,F1L,transpose_a=TRUE)
      F.plus_product_of(F1R,Yr)
      F.plus(F2)
      
      ! Remove matmuls -- dylan
    ! F=F+matmul(transpose(Yr),F1L) 
    ! F=F+matmul(F1R,Yr)
    ! F=F+matmul(transpose(Yr),matmul(F2,Yr))
 
      AAA.destroy     
       F2.destroy
      F1R.destroy
      F1L.destroy

   end

! IOTC general complex orbitals

   make_IOTC_orb_dens_grid_gc(density_grid,orb,pt)
   ! ???
      self :: IN
      density_grid :: VEC{CPX}, OUT 
      orb :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")

      CMO :: MAT{CPX}*

      CMO => .molecular_orbitals.general_complex(:,1:.n_e)
      .::density_IOTC_orb_gc(density_grid,pt,CMO(:,orb))

   end

   density_IOTC_orb_gc(density_grid,pt,MO)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density_grid :: VEC{CPX}, OUT
      pt :: MAT{REAL} , IN
      MO :: VEC{CPX} , IN

      n_gcm,n_pt :: INT
      n,i,j :: INT
      g,c,alpha,alpha2,eps :: REAL
      II :: CPX
      m_out,mmm :: MAT{INT}* 
      Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
      GG22 :: MAT{CPX}*
      SOx,SOy,SOz :: MAT{REAL}*
      A2,PAP,O,Ox,Yr :: MAT{CPX}*
      Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*
  
      n_pt = pt.dim1

      !test
      mmm.create(.n_prim,.n_prim)
      .REL:get_n_gcm(mmm,n_gcm)
      mmm.destroy 

      if ( abs(.n_prim-n_gcm)> 0 OR abs(.n_prim-.n_bf)>0) then
         DIE(" It seems you are using contracted gaussians this does not work for IOTC at gchf level!")
      end if    
 
      !!! n_gcm = .n_prim = .n_bf ??? --dylan
 
      ! this is actually not needed but I am also using n_gcm 
      m_out.create(.n_prim,.n_prim) 
      .REL:make_ready_da_gcm_tr2(m_out,n_gcm) 

      R.create(.n_prim,.n_prim)
      S.create(n_gcm,n_gcm)
      Y.create(n_gcm,n_gcm)

      !!!  OVERLAP MATRIX + Y MX !!!
      .REL:make_primitive_overlap_matrix(S)
      Y.to_inverse_sqrt_of(S)
      !  .make_S_Y(S,Y)  !  ???
 
      !!!  KINETIC ENERGY MATRIX -> U & P2!!!
      T.create(n_gcm,n_gcm)
      .REL:make_primitive_kinetic_matrix(T)
      R.to_product_of(Y,T)   
      T.to_product_of(R,Y)              
      ! T=YTY  kinetic energy in an orthogonal basis
      P2.create(n_gcm)
      U.create(n_gcm,n_gcm)
      T.solve_eigenproblem(P2,U)
      ! the momentum squared instead of kinetic energy
      P2= TWO * P2
 
      YU.create(n_gcm,n_gcm)
      YU.to_product_of(Y,U)
      Y.destroy
      U.destroy
      T.destroy
 
      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
      Z.create(n_gcm,n_gcm)
      .REL:make_primitive_nuclear_matrix(Z)
      ! put the potential energy matrix into the YU space
      R.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(R,YU)
 
      !!!  PZP MATRIX  !!!
      PZP.create(n_gcm,n_gcm)
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
 
      R.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(R,YU)
      R.to_product_of(YU,SOx,transpose_a=TRUE)
      SOx.to_product_of(R,YU)
      R.to_product_of(YU,SOy,transpose_a=TRUE)
      SOy.to_product_of(R,YU)
      R.to_product_of(YU,SOz,transpose_a=TRUE)
      SOz.to_product_of(R,YU)
 
      !!! A-O LETS GO !!!
      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha
 
      E.create(2*n_gcm)
      ep.create(2*n_gcm)
      p.create(2*n_gcm)
      bp.create(2*n_gcm)
      Ap.create(n_gcm)
 
      do i = 1,n_gcm
         E(i)       = c * sqrt(P2(i) + c * c)
         E(i+n_gcm) = c * sqrt(P2(i) + c * c)
         p(i)       = sqrt(P2(i))
         p(i+n_gcm) = sqrt(P2(i))
         ep(i)      = sqrt(ONE+P2(i)*alpha2)
         ep(i+n_gcm)= sqrt(ONE+P2(i)*alpha2) 
         bp(i)      = ONE/(ep(i)+ONE)
         bp(i+n_gcm)= ONE/(ep(i)+ONE)
         Ap(i)      = sqrt( (E(i) + c * c)/(TWO * E(i)) )  
      end do
 
      P2.destroy
 
      do i = 1,n_gcm
      do j=1,n_gcm
         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
         SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
         SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
         SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
      end
      end
 
      A2.create(2*n_gcm,2*n_gcm)
      A2 = (ZERO,ZERO)
      A2.alpha_alpha_plus(Z)
      A2.beta_beta_plus(Z)

      PAP.create(2*n_gcm,2*n_gcm)
      PAP = (ZERO,ZERO)
      PAP.alpha_alpha_plus(PZP)
      PAP.beta_beta_plus(PZP)
      II = (ZERO,ONE)
      PAP.beta_alpha_plus(SOx,II)
      PAP.beta_alpha_plus(SOy,-ONE)
      PAP.alpha_alpha_plus(SOz,II)
      PAP.beta_beta_plus(SOz,-II)
      PAP.make_hermitian   

      ! lets find the transforation matrix
      Yr.create(2*n_gcm,2*n_gcm)
      Y0.create(n_gcm,n_gcm)

      .REL:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)

      Z.destroy
      PZP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy
      R.destroy
 
      ! lets find the transforation matrix
      Yr = (ZERO,ZERO)
      Yr.alpha_alpha_plus(Y0)
      Yr.beta_beta_plus(Y0)
      Y0.destroy
 
      .REL:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
 
      PAP.destroy
      A2.destroy
 
      O.create(2*n_gcm,2*n_gcm)
      Ox.create(2*n_gcm,2*n_gcm)
      Ox= (ZERO,ZERO)
      do i=1,2*n_gcm
         Ox(i,i)=ONE
      end do
      O.to_product_of(Yr,Yr,dagger_a=TRUE)
      Ox = Ox + O

      ! make ready the preconditioning
      UN.create(2*n_gcm)
      do i=1,2*n_gcm
         UN(i)=ONE/sqrt(real(Ox(i,i)))
      end 
 
      do i=1,2*n_gcm
      do j=1,2*n_gcm
         Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
      end
      end  

      eps=TOL(15)
      O.to_power_series_inv_sqrt_of(Ox,eps)
      do i=1,2*n_gcm
      do j=1,2*n_gcm
         O(i,j) = O(i,j)*UN(j)
      end
      end  

      UN.destroy
      Ox.destroy
 
      GG22.create(2*n_gcm,2*n_gcm)
 
      do n = 1,n_pt
 
         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .::make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
  
         g = ZERO
  
         do i=1,2*.n_bf
         do j=1,2*.n_bf
            g = g + REALIFY(conjg(MO(i))*GG22(i,j)*MO(j))
         end            
         end            
 
         density_grid(n)= g      
 
      end
  
      S.destroy
      O.destroy
      Yr.destroy
      GG22.destroy
      YU.destroy
      Ap.destroy
      E.destroy
      bp.destroy
      ep.destroy
      p.destroy
      m_out.destroy

   end

   make_DENSITY_IOTC_PCE_SO_off(GG,Yr,YU,Ap,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O) ::: private
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_core_matrix(H) routine
      self :: IN
      GG :: MAT{CPX}, OUT
      Yr :: MAT{CPX}, IN
      YU :: MAT{REAL} , IN
      Ap,bp,p :: VEC{REAL} , IN
      ep :: VEC{REAL} 
      xx,yy,zz :: REAL , IN
      m_out :: MAT{INT} , IN
      n_gcm :: INT , IN
      S :: MAT{REAL} , IN
      O :: MAT{CPX} 

      II :: CPX
      fac :: REAL  
      i,j :: INT  
      F,A2,B2,M2,buco,PAP,ppApp :: MAT{CPX}*
      R :: MAT{REAL}*  
      D,PDP,SOx,SOy,SOz,PPDPP :: MAT{REAL}*  
      A,B,M :: MAT{REAL}*

      ep = ep

      !!!  the density X operator !!!
      R.create(.n_prim,.n_prim)
      D.create(n_gcm,n_gcm)
      .REL:make_primitive_density_matrix(D,xx,yy,zz)

      A.create(n_gcm,n_gcm)
      A=ZERO
      A.to_product_of(YU,D,transpose_a=TRUE)
      D.to_product_of(A,YU)
 !!!  the density PXP operator !!!
      PDP.create(n_gcm,n_gcm)
      PDP=ZERO
      .REL:make_primitive_pDp_matrix(PDP,xx,yy,zz) 
      A=ZERO
      A.to_product_of(YU,PDP,transpose_a=TRUE)
      PDP.to_product_of(A,YU)
 !!!  SO MATRICES  !!!
      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
       SOx=ZERO; SOy=ZERO; SOz=ZERO
      .REL:make_primitive_pDp_SO_matrix(SOx,SOy,SOz,xx,yy,zz) 
      A=ZERO
      A.to_product_of(YU,SOx,transpose_a=TRUE)
      SOx.to_product_of(A,YU)
      A=ZERO
      A.to_product_of(YU,SOy,transpose_a=TRUE)
      SOy.to_product_of(A,YU)
      A=ZERO
      A.to_product_of(YU,SOz,transpose_a=TRUE)
      SOz.to_product_of(A,YU)
 
 !!! A-O LETS GO !!!
 
      A=ZERO
 
      do i=1,n_gcm
        do j=1,n_gcm
 
         D(i,j) = Ap(i)*D(i,j)*Ap(j)                                        
         PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
         SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
         SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
         SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)
 
        end
      end
 
      if(.scfdata.using_ppzpp)then
        PPDPP.create(n_gcm,n_gcm)
        PPDPP=ZERO
        .REL:make_primitive_ppDpp_matrix(PPDPP,xx,yy,zz) 
        .REL:get_da_gcm_now(R,PPDPP,m_out)  
        A=ZERO
        A.to_product_of(YU,PPDPP,transpose_a=TRUE)
        PPDPP.to_product_of(A,YU)
 
         do i=1,n_gcm
           do j=1,n_gcm
             PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j)
           end do
         end do
       end if  
     A.destroy
 
    A2.create(2*n_gcm,2*n_gcm)
    A2=(ZERO,ZERO)
      A2.alpha_alpha_plus(D)
      A2.beta_beta_plus(D)
 !   A.make_hermitian   
     .BASE:put_debug(A2,"A matrix")
    PAP.create(2*n_gcm,2*n_gcm)
    PAP=(ZERO,ZERO)
      PAP.alpha_alpha_plus(PDP)
      PAP.beta_beta_plus(PDP)
      II = (ZERO,ONE)
      fac= ONE
       PAP.beta_alpha_plus(SOx,fac*II)
       PAP.beta_alpha_plus(SOy,-fac)
       PAP.alpha_alpha_plus(SOz,fac*II)
       PAP.beta_beta_plus(SOz,-fac*II)
    PAP.make_hermitian   
     .BASE:put_debug(PAP,"PAP matrix")
    if( .scfdata.using_ppzpp)then
    ppApp.create(2*n_gcm,2*n_gcm)
    ppApp=(ZERO,ZERO)
      ppApp.alpha_alpha_plus(PPDPP)
      ppApp.beta_beta_plus(PPDPP)
 !  ppApp.make_hermitian   
     .BASE:put_debug(ppApp,"ppApp matrix")
      PPDPP.destroy
    end if
      D.destroy
      PDP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy
      R.destroy
 
      ! the hamiltonian is gonna be built
      F.create(2*n_gcm,2*n_gcm)
      if (.scfdata.using_ppzpp) then; .::build_da_IOTC_dens(F,Yr,PAP,A2,p,bp,ppApp)
      else;                           .::build_da_IOTC_dens(F,Yr,PAP,A2,p,bp)
      end if 
 
      PAP.destroy
      if( .scfdata.using_ppzpp)then
        ppApp.destroy
      end if 
 
      A2=(ZERO,ZERO)
      ! normalization
      A2.to_product_of(F,O)
      F.to_product_of(O,A2,dagger_a=TRUE)
 
      ! back to cartesian basis set
      B2.create(2*n_gcm,2*n_gcm)
      B.create(n_gcm,n_gcm) 

      B.to_product_of(S,YU)

      B2=(ZERO,ZERO)
      B2.alpha_alpha_plus(B)
      B2.beta_beta_plus(B)
      B.destroy
 
      A2.to_product_of(B2,F)
      F.to_product_of(A2,B2,dagger_b=TRUE)
 
      B2.destroy
 
      !!! moving back to contracted basis sets 
      M.create(.n_prim,.n_bf)

      .BASE:make_normalised_contraction_mx(M)

      M2.create(2*.n_prim,2*.n_prim)
      M2 = (ZERO,ZERO)
      M2.alpha_alpha_plus(M)
      M2.beta_beta_plus(M)

      buco.create(2*.n_prim,2*.n_prim)
      buco.to_product_of(M2,F,dagger_a=TRUE)
      A2.to_product_of(buco,M2)

      M.destroy
      F.destroy
      M2.destroy
      buco.destroy
 
      GG = A2

      A2.destroy

      .BASE:put_debug(GG,"GG matrix")

   end   

   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,ppApp) ::: private
   ! build the IOTC Y matrix, general complex version 
      self :: IN
      F :: MAT{CPX}, OUT
      Yr,PAP,A :: MAT{CPX}, IN
      p,bp :: VEC{REAL}, IN
      ppApp :: MAT{CPX}, optional, IN

      i,j,n_gcm,dim :: INT
      c,alpha,alpha2 :: REAL
      AAA,F1R,F1L,F2 :: MAT{CPX}*

      n_gcm=.n_prim
      c = SPEED_OF_LIGHT_AU
      alpha = ONE/c
      alpha2= alpha*alpha
 
      dim = 2*n_gcm
 
      F1L.create(dim,dim)
      F1R.create(dim,dim)
       F2.create(dim,dim)
      AAA.create(dim,dim)
 
      if (.scfdata.using_ppzpp) then

         do i = 1,dim
         do j = 1,dim
            AAA(i,j) = alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
         end do
         end do

      else

         do i = 1,dim
         do j = 1,dim
            AAA(i,j) = alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
         end do
         end do

      end
 
      do i = 1,dim
      do j = 1,dim
          F(i,j)  =  A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
          F2(i,j) =  PAP(i,j)/p(j)/p(i) + AAA(i,j)
      end do
      end do
 
      F2.change_basis_using(Yr)

      F.plus_product_of( Yr,F1L,dagger_a=TRUE)
      F.plus_product_of(F1R,Yr)
      F.plus(F2)

      ! Remove matmuls
    ! AAA.to_product_of(Yr,F1L,dagger_a=TRUE)
    ! F=F+AAA+matmul(F1R,Yr)
    ! AAA.to_product_of(Yr,F2,dagger_a=TRUE)
    ! F=F+matmul(AAA,Yr)
 
      AAA.destroy     
      F1L.destroy
      F1R.destroy
      F2.destroy

   end

!  ==================
!  Nabla orbital grid
!  ==================

   make_nabla_orbital_grid_r(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{REAL}
      h :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")

      orb_a :: VEC{REAL}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      g = ZERO
      h = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na,3)
         sh_grid0.create(n_pt,na)

         sh.make_nabla_grid(sh_grid,sh_grid0,pt)

         orb_a => orb(fa:la)
         g(:,1).plus_product_of(sh_grid(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid(:,:,3),orb_a)
              h.plus_product_of(sh_grid0,      orb_a)

         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part

      end

   end

   make_nabla_orbital_grid_c(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{CPX}
      h :: VEC{CPX}
      orb :: VEC{CPX}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")

      orb_a :: VEC{CPX}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      g = ZERO
      h = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid.create(n_pt,na,3)
         sh_grid0.create(n_pt,na)

         sh.make_nabla_grid(sh_grid,sh_grid0,pt)

         orb_a => orb(fa:la)
         g(:,1).plus_product_of(sh_grid(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid(:,:,3),orb_a)
              h.plus_product_of(sh_grid0,      orb_a)

         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part

      end

   end

!  ==================
!  Nabla density grid
!  ==================

!   make_nabla_density_grid_fdm_r(nabla_grid,pts)
!   ! Work out the nabla density on ".plot_grid" using ".natural orbitals" and the
!   ! ".occupation" number vector.
!   ! This method uses the finite difference method to calculate the gradient
!   ! from the density.  It is much slower, but useful for checking.
!     nabla_grid, pts :: MAT{REAL}
!   ENSURE(pts.dim2==3,  "wrong dimension for points array")
!   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
!     orb :: VEC{REAL}*
!     dens_1,dens_2,nabla_orb,comp :: VEC{REAL}*
!     pt1 :: MAT{REAL}*
!     alpha :: REAL
!     n_occ,n,n_pts,i :: INT
!     alpha = TOL(6)
!     n_pts = size(pts,1)
!     pt1.create(n_pts,3)
!     nabla_grid = ZERO
!     orb.create(n_pts)
!     dens_1.create(n_pts)
!     dens_2.create(n_pts)
!     nabla_orb.create(n_pts)
!     n_occ = .BASE:no_of_occupied_NOs
!     do n = 1,n_occ
!        do i = 1,3
!          comp => pt1(:,i)
!          pt1 = pts;    comp = comp + alpha
!          .::make_orbital_grid_r(dens_1,.natural_orbitals.restricted(:,n),pt1,square=TRUE)
!          pt1 = pts;    comp = comp - alpha
!          .::make_orbital_grid_r(dens_2,.natural_orbitals.restricted(:,n),pt1,square=TRUE)
!          nabla_orb = HALF/alpha * (dens_1 - dens_2)
!          .::make_orbital_grid_r(orb,.natural_orbitals.restricted(:,n), pts)
!          nabla_grid(:,i) = nabla_grid(:,i) + .occupation_numbers.restricted(n)*orb(:)*nabla_orb
!        end
!     end
!     nabla_grid = TWO*nabla_grid
!     nabla_orb.destroy
!     dens_2.destroy
!     dens_1.destroy
!     orb.destroy
!     pt1.destroy
!   end

   make_nabla_density_grid(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid" on the set of point "pts".
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (trim(.natural_orbitals.number_kind)=="real") then
         .::make_nabla_density_grid_r(nabla_grid,pts)
      else
         DIE("not implemented")
      end

   end

   make_nabla_density_grid(nabla_grid,grid,pts)
   ! Work nabla of the density, "nabla_grid", and the density, "grid, evaluated
   ! on the set of points "pts".
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (trim(.natural_orbitals.number_kind)=="real") then
         .::make_nabla_density_grid_r(nabla_grid,grid,pts)
      else
         DIE("not implemented")
      end

   end

   make_nabla_density_grid_r(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid", on the grid "pts" using
   ! ".natural_orbitals" and the ".occupation" number vector.
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = pts.dim1
      n_occ = .BASE:no_of_occupied_NOs

      nabla_grid = ZERO

      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      do n = 1,n_occ

         .::make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)

         occ = .occupation_numbers.restricted(n)

         nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
         nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
         nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)

      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

   make_nabla_density_grid_r(nabla_grid,grid,pts)
   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
   ! using the grid "pts" and the ".natural_orbitals" and the ".occupation"
   ! number vector.
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT

      n_pts = pts.dim1
      n_occ = .BASE:no_of_occupied_NOs

      nabla_grid = ZERO
      grid = ZERO

      orb.create(n_pts)
      nabla_orb.create(n_pts,3)

      do n = 1,n_occ

         .::make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)

         occ = .occupation_numbers.restricted(n)

         nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
         nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
         nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
         grid(:)         = grid(:)         + occ*orb(:)*orb(:)

      end

      nabla_grid = TWO*nabla_grid

      orb.destroy
      nabla_orb.destroy

   end

!  ======================
!  Laplacian orbital grid
!  ======================

   make_laplacian_orbital_grid_r(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{REAL}
      i :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid1,sh_grid2 :: MAT3{REAL}*
      sh_grid3 :: MAT{REAL}*
      orb_a :: VEC{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      g = ZERO
      h = ZERO
      i = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid1.create(n_pt,na,3)
         sh_grid2.create(n_pt,na,3)
         sh_grid3.create(n_pt,na)

         sh.make_laplacian_grid(sh_grid1,sh_grid2,sh_grid3,pt)

         orb_a => orb(fa:la)
         g(:,1).plus_product_of(sh_grid1(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid1(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid1(:,:,3),orb_a)
         h(:,1).plus_product_of(sh_grid2(:,:,1),orb_a)
         h(:,2).plus_product_of(sh_grid2(:,:,2),orb_a)
         h(:,3).plus_product_of(sh_grid2(:,:,3),orb_a)
              i.plus_product_of(sh_grid3,       orb_a)

         sh_grid3.destroy
         sh_grid2.destroy
         sh_grid1.destroy
         sh.destroy_ptr_part

      end

   end

   make_laplacian_orbital_grid_c(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{CPX}
      i :: VEC{CPX}
      orb :: VEC{CPX}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid1,sh_grid2 :: MAT3{REAL}*
      sh_grid3 :: MAT{REAL}*
      orb_a :: VEC{CPX}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      g = ZERO
      h = ZERO
      i = ZERO

      do a = 1,.n_shell

         .BASE:get_shell(sh,a,fa,la,na)

         sh_grid1.create(n_pt,na,3)
         sh_grid2.create(n_pt,na,3)
         sh_grid3.create(n_pt,na)

         sh.make_laplacian_grid(sh_grid1,sh_grid2,sh_grid3,pt)

         orb_a => orb(fa:la)
         g(:,1).plus_product_of(sh_grid1(:,:,1),orb_a)
         g(:,2).plus_product_of(sh_grid1(:,:,2),orb_a)
         g(:,3).plus_product_of(sh_grid1(:,:,3),orb_a)
         h(:,1).plus_product_of(sh_grid2(:,:,1),orb_a)
         h(:,2).plus_product_of(sh_grid2(:,:,2),orb_a)
         h(:,3).plus_product_of(sh_grid2(:,:,3),orb_a)
              i.plus_product_of(sh_grid3,       orb_a)

         sh_grid3.destroy
         sh_grid2.destroy
         sh_grid1.destroy
         sh.destroy_ptr_part

      end

   end

!  =========================
!  Electron density routines
!  =========================

   make_density_grid(density_grid,pt,sgn)
   ! Work out the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector. If "sgn" is present and equal to -1, the
   ! spin density is produced (provided alpha and beta natural orbitals are
   ! present).
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
      sgn :: INT, IN, optional

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      relativity,okind :: STR

      okind = .natural_orbitals.spinorbital_kind

      relativity = "none"
      if (.scfdata.created) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if   

      select case (relativity)

         case ("douglas-kroll-hess","dkh")
            select case (okind)
               case ("restricted");       .::make_DKH_density_grid(density_grid,pt)
               case ("unrestricted");     .::make_DKH_density_grid(density_grid,pt,sgn)
               case ("general_complex");  .::make_DKH_density_grid(density_grid,pt)
               case default; WARN("Unimplemented orbital kind! Sorry :(")
            end

         case ("iotc")
            select case (okind)
               case ("restricted");       .::make_IOTC_density_grid(density_grid,pt)
               case ("unrestricted");     .::make_IOTC_density_grid(density_grid,pt,sgn)
               case ("general_complex");  .::make_IOTC_density_grid(density_grid,pt)
               case default; WARN("Unimplemented orbital kind! Sorry :(")
            end

         case ("none")
            select case (okind)
               case ("restricted");       .::make_density_grid_r(density_grid,pt)
               case ("unrestricted");     .::make_density_grid_u(density_grid,pt,sgn)
               case ("general_complex");  .::make_density_grid_gc(density_grid,pt)
               case default;   DIE("unimplemented")
            end

         case default; DIE("unimplemented")

      end

   end

   make_density_grid(p_a,p_b,pt)
   ! Make the alpha and beta density grids, "p_a" and "p_b" respectively, from
   ! the unrestricted natural orbitals.
      p_a,p_b :: VEC{REAL}
      pt :: MAT{REAL}, IN

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("unrestricted"),"no natural orbitals")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")

      NO :: MAT{REAL}*
      occ :: VEC{REAL}*

      NO  => .natural_orbitals.restricted ! backup pointers
      occ => .occupation_numbers.restricted

      .natural_orbitals.restricted   => .natural_orbitals.alpha
      .occupation_numbers.restricted => .occupation_numbers.alpha
      .::make_density_grid(p_a,pt)

      .natural_orbitals.restricted   => .natural_orbitals.beta
      .occupation_numbers.restricted => .occupation_numbers.beta
      .::make_density_grid(p_b,pt)

      .natural_orbitals.restricted   => NO ! restore backups
      .occupation_numbers.restricted => occ

   end

   make_density_grid_r(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation numbers")

      NO :: VEC{REAL}*
      occ :: REAL
      n_occ,n :: INT

      n_occ = .BASE:no_of_occupied_NOs
      NO.create(pt.dim1)

      density_grid = ZERO

      parallel do n = 1,n_occ
        .::make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n), pt)
        occ = .occupation_numbers.restricted(n)
        density_grid = density_grid + occ*NO*NO
      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SUM(density_grid)
      end

      NO.destroy

   end

   make_density_grid_u(density_grid,pt,sgn)
   ! Make the "density_grid" for the supplied points "pt" from unrestricted real
   ! natural orbitals. If present "sgn" is used to determine whether the total
   ! density or spin density is to be calculated: sgn=1 means sum the alpha and
   ! beta densities to form the total density, sgn=-1 means to subtract, forming
   ! the Sz spin density.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
      sgn :: INT, IN, optional

   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.natural_orbitals.created("unrestricted"), "no unrestricted NO's")
   ENSURE(.occupation_numbers.alpha.created, "no alpha occupation numbers")
   ENSURE(.occupation_numbers.beta.created, "no beta occupation numbers")

      NO :: VEC{REAL}*
      occ,fac :: REAL
      na,nb,n :: INT

      fac = ONE
      if (present(sgn)) fac = REALIFY(sgn)

      na = .BASE:no_of_occupied_NOs("alpha")
      nb = .BASE:no_of_occupied_NOs("beta")

      NO.create(pt.dim1)

      density_grid = ZERO

      do n = 1,na
         .::make_orbital_grid_r(NO,.natural_orbitals.alpha(:,n),pt)
         occ = .occupation_numbers.alpha(n)
         density_grid = density_grid + occ*NO*NO
      end

      do n = 1,nb
         .::make_orbital_grid_r(NO,.natural_orbitals.beta(:,n),pt)
         occ = .occupation_numbers.beta(n)
         density_grid = density_grid + fac*occ*NO*NO
      end

      ! Clean
      NO.destroy

   end

   make_density_grid_c(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.created("restricted_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.restricted.created, "no occupation numbers")

      NO :: VEC{CPX}*
      occ :: REAL
      n_occ,n :: INT

      n_occ = .BASE:no_of_occupied_NOs

      density_grid = ZERO

      NO.create(pt.dim1)
      do n = 1,n_occ
         .::make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n), pt)
         occ = .occupation_numbers.restricted(n)
         density_grid = density_grid + occ * RE(conjg(NO(:))*NO(:))
      end

      NO.destroy

   end

   make_density_grid_gc(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.created("general_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.created("general"), "no occupation numbers")

      gd,gu :: VEC{CPX}*
      n_occ,n :: INT
      occ :: REAL

      n_occ = .BASE:no_of_occupied_NOs

      gu.create(pt.dim1)
      gd.create(pt.dim1)

      density_grid = ZERO
      do n = 1,n_occ
         .::make_orbital_grid_gc(gu,gd,.natural_orbitals.general_complex(:,n),pt)
         occ = .occupation_numbers.general(n) 
         density_grid = density_grid  +  occ * REALIFY(conjg(gd)*gd + conjg(gu)*gu)
      end

      gd.destroy
      gu.destroy

   end

   make_density_grid_r(density_grid,pt,NO,occ)
   ! Make the "density_grid" for the supplied points "pt" from the
   ! natural orbitals "NO" and occupuation numbers "occ".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      NO  :: MAT{REAL}
      occ :: VEC{REAL}

   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")

      NOn  :: VEC{REAL}*
      n  :: INT

      NOn.create(pt.dim1)

      density_grid = ZERO

      do n = 1,NO.dim2

         if (occ(n)==ZERO) cycle

         .::make_orbital_grid_r(NOn,NO(:,n),pt)
         density_grid = density_grid + occ(n)*NOn*NOn

      end

      NOn.destroy

   end

! DKH densities

   make_DKH_density_grid(density_grid,pt,sgn)
   ! this is kevin
   ! here begins the PCE correction of density
   ! welcome
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      sgn :: INT, optional, IN
     
      fac :: REAL
      MO,MOa,MOb :: MAT{REAL}*
      CMO :: MAT{CPX}*
      D,Da,Db :: MAT{REAL}*
      CD :: MAT{CPX}*
      grid_a,grid_b :: VEC{REAL}*

      select case (.scfdata.scf_kind)
 
         case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")

            ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
            ENSURE(.spin_multiplicity==1,"this is not a singlet state")

            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted

            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

            grid_a.create(pt.dim1)
            .::density_DKH_r(grid_a,pt,D)
            density_grid = grid_a
            grid_a.destroy
  
         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

            ENSURE(.molecular_orbitals.created("unrestricted"),"no MO's")

            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta

            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)

            grid_a.create(pt.dim1)
            grid_b.create(pt.dim1)
            .::density_DKH_r(grid_a,pt,Da)
            .::density_DKH_r(grid_b,pt,Db)

            if (present(sgn)) then; fac = -ONE
            else;                   fac = ONE
            end

            density_grid = grid_a 
            density_grid = density_grid + fac * grid_b 

            grid_a.destroy
            grid_b.destroy
  
         case ("gchf")

            ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")

            CD  => .density_matrix.general_complex
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)

            CD.to_product_of(CMO,CMO,dagger_b=TRUE)

            .::density_DKH_gc(density_grid,pt,CD)
  
         case default
            DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))
 
      end

   end

   density_DKH_r(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density_grid :: VEC{REAL} , OUT
      pt :: MAT{REAL} , IN
      D :: MAT{REAL} , IN

      n_gcm,n_pt :: INT
      n,i,j :: INT
      g :: REAL
      m_out :: MAT{INT}* 
      YU,GG,S,R,sZ,sPZP,PPZPP :: MAT{REAL}*
      P2,Ap,Ep :: VEC{REAL}*

      n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm)  

      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)

      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out) 
      R.destroy 
  
      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)
  
      .REL:make_DKH_mxs(YU,Ap,Ep,P2)
  
      sZ.create(n_gcm,n_gcm)
      sPZP.create(n_gcm,n_gcm)
      .REL:make_DKH_mxs2(sZ,sPZP,YU)
  
      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
         WARN(" The use_ppzpp seems to give larger value of density at nucleus for very large exponents in the basis set E+08")
         PPZPP.create(n_gcm,n_gcm)
         .REL:make_DKH_mxs4(PPZPP,YU)
      end if
     
      GG.create(.n_bf,.n_bf)
     
      do n = 1,n_pt
     
         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .::make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,sZ,sPZP,PPZPP)
     
         g = ZERO
     
         do i = 1,.n_bf
         do j = 1,.n_bf
            g = g + D(i,j)*GG(i,j)
         end            
         end            
     
         density_grid(n) = g

      end
     
      S.destroy
      sZ.destroy
      sPZP.destroy
      GG.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy
     
      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
         PPZPP.destroy
      end if

   end

   density_DKH_gc(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density_grid :: VEC{REAL} , OUT
      pt :: MAT{REAL} , IN
      D :: MAT{CPX} , IN

      n_gcm,n_pt, n,i,j :: INT
      g :: REAL
      II :: CPX
      m_out :: MAT{INT}*
      YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
      Z2,PZP2 :: MAT{CPX}*
      SOx,SOy,SOz :: MAT{REAL}*
      GG22 :: MAT{CPX}*
      P2,Ap,Ep :: VEC{REAL}*

      n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .REL:get_n_gcm(m_out,n_gcm) 

      if (abs(.n_prim-n_gcm)> 0 AND abs(.n_prim-.n_bf) > 0) then
         DIE(" It seems you are using contracted gaussians this does not work for DKH at gchf level!")
      end if     

      R.create(.n_prim,.n_prim)
      S.create(n_gcm,n_gcm)
      .REL:make_primitive_overlap_matrix(S)
      R.destroy 
  
      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)
      .::make_DKH_mxs_2(YU,Ap,Ep,P2)
  
      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
      ! actually the output matrices are the sX matrices (see DKH for the
      ! use of the s index)  -- ??? dylan
      .::make_DKH_mxs3_2(Z,PZP,SOx,SOy,SOz,YU)
  
        Z2.create(2*n_gcm,2*n_gcm)
      PZP2.create(2*n_gcm,2*n_gcm)

      Z2 = (ZERO,ZERO)
      Z2.alpha_alpha_plus(Z)
      Z2.beta_beta_plus(Z)

      II   = (ZERO,ONE)
      PZP2 = (ZERO,ZERO)
      PZP2.alpha_alpha_plus(PZP)
      PZP2.beta_beta_plus(PZP)
      PZP2.beta_alpha_plus(SOx,II)
      PZP2.beta_alpha_plus(SOy,-ONE)
      PZP2.alpha_alpha_plus(SOz,II)
      PZP2.beta_beta_plus(SOz,-II)
      PZP2.make_hermitian

      Z.destroy
      PZP.destroy
      SOx.destroy
      SOy.destroy
      SOz.destroy
  
      GG22.create(2*.n_bf,2*.n_bf)
  
      if (.scfdata.DK2_PCE AND .scfdata.using_ppzpp) then
         WARN(" The use_ppzpp seems to give larger value of density at nucleus")
         PPZPP.create(n_gcm,n_gcm)
         .REL:make_DKH_mxs4(PPZPP,YU)
      end if
  
      do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .::make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,Z2,PZP2)
  
         g = ZERO
  
         do i=1,2*.n_bf
         do j=1,2*.n_bf
            g = g + REALIFY(D(j,i)*GG22(i,j))
         end            
         end            

         density_grid(n) = g

      end
  
      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
         PPZPP.destroy
      end if
  
      S.destroy
      Z2.destroy
      PZP2.destroy
      GG22.destroy
      YU.destroy
      Ap.destroy
      Ep.destroy
      P2.destroy
      m_out.destroy

   end

! IOTC densities

   make_IOTC_density_grid(density_grid,pt,sgn)
   ! this is kevin
   ! here begins the PCE correction of density
   ! welcome
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      sgn :: INT, optional, IN
 
      fac :: REAL
      MO,MOa,MOb :: MAT{REAL}*
      CMO :: MAT{CPX}*
      D,Da,Db :: MAT{REAL}*
      CD :: MAT{CPX}*
      grid_a,grid_b :: VEC{REAL}*
 
      select case (.scfdata.scf_kind)
 
         case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
 
            ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
            ENSURE(.spin_multiplicity==1,"this is not a singlet state")
 
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted

            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

            grid_a.create(pt.dim1)
            .::density_IOTC_r(grid_a,pt,D)

            density_grid = grid_a

            grid_a.destroy
  
         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

            ENSURE(.molecular_orbitals.created("unrestricted"),"no MO's")

            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta

            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)

            grid_a.create(pt.dim1)
            grid_b.create(pt.dim1)
            .::density_IOTC_r(grid_a,pt,Da)
            .::density_IOTC_r(grid_b,pt,Db)

            if (present(sgn)) then; fac = -ONE
            else;                   fac = ONE
            end

            density_grid = grid_a 
            density_grid = density_grid + fac * grid_b 
            grid_a.destroy
            grid_b.destroy
  
         case ("gchf")

            ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")

            CD  => .density_matrix.general_complex
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)

            CD.to_product_of(CMO,CMO,dagger_b=TRUE)
            .::density_IOTC_gc(density_grid,pt,CD)
  
         case default
            DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))
 
      end

   end

   density_IOTC_r(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D :: MAT{REAL}, IN

      n_gcm,n_pt :: INT
      n,i,j,k :: INT
      g,c,alpha,alpha2 :: REAL
      m_out :: MAT{INT}*
      R,Y,U,A,T,O :: MAT{REAL}*
      SOx,SOy,SOz,Yr :: MAT{REAL}*
      YU,GG,S,Z,PZP :: MAT{REAL}*
      P2,Ap,E,p,ep,bp :: VEC{REAL}*

      n_pt = pt.dim1

      !!! analysis of the primitive basis set via the overap matrix
      !!! trying to lower the problem to an general contracted basis set
      !!!  OVERLAP MATRIX !!!
      R.create(.n_prim,.n_prim)
      .REL:make_primitive_overlap_matrix(R)
 
      m_out.create(.n_prim,.n_prim) 
      .REL:make_ready_da_gcm_tr2(m_out,n_gcm)  
      ! put the overlap matrix into the n_gcm non-redundant space
      S.create(n_gcm,n_gcm)
      .REL:get_da_gcm_now(R,S,m_out)  
 
      Y.create(n_gcm,n_gcm)
      Y.to_inverse_sqrt_of(S)
 
      !!!  KINETIC ENERGY MATRIX !!!
      .REL:make_primitive_kinetic_matrix(R) 
      T.create(n_gcm,n_gcm)
      ! put the kinetic energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,T,m_out)  
 
      A.create(n_gcm,n_gcm)
      A.to_product_of(Y,T)   
      T.to_product_of(A,Y)              
      ! T=YTY  kinetic energy in an orthogonal basis
      U.create(n_gcm,n_gcm)
      P2.create(n_gcm)
      T.solve_eigenproblem(P2,U)
      P2= TWO * P2
      YU.create(n_gcm,n_gcm)
      YU.to_product_of(Y,U)
      T.destroy
      Y.destroy
      U.destroy
 
      !!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
      .REL:make_primitive_nuclear_matrix(R)
      Z.create(n_gcm,n_gcm)
      ! put the potential energy matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,Z,m_out)  
 
      A.to_product_of(YU,Z,transpose_a=TRUE)
      Z.to_product_of(A,YU)
 
 !!!  PZP MATRIX  !!!
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .REL:make_primitive_DKH_matrices(R,SOx,SOy,SOz)
      SOx.destroy
      SOy.destroy
      SOz.destroy
 
      PZP.create(n_gcm,n_gcm)
      ! put the PZP matrix into the n_gcm non-redundant space
      .REL:get_da_gcm_now(R,PZP,m_out) 
 
      A.to_product_of(YU,PZP,transpose_a=TRUE)
      PZP.to_product_of(A,YU)
      R.destroy
 
      !!! A-O LETS GO !!!
      c      = SPEED_OF_LIGHT_AU
      alpha  = ONE/c
      alpha2 = alpha*alpha
 
      E.create(n_gcm)
      p.create(n_gcm)
      ep.create(n_gcm)
      Ap.create(n_gcm)
      bp.create(n_gcm)
 
      do i = 1,n_gcm
         E(i)  = c * sqrt(P2(i) + c * c)
         p(i)  = sqrt(P2(i))
         ep(i) = sqrt(ONE+P2(i)*alpha2) 
         Ap(i) = sqrt( (E(i) + c * c)/(TWO * E(i)) )  
         bp(i) = ONE/(ep(i)+ONE)
      end  

      P2.destroy
 
      do i=1,n_gcm
      do j=1,n_gcm
         Z(i,j)   = Ap(i)*Z(i,j)*Ap(j)
         PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
      end
      end

      ! lets find the transforation matrix
      Yr.create(n_gcm,n_gcm)
 
      .REL:find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
 
      ! lets make ready the normalzation matrix
      O.create(n_gcm,n_gcm)
      O = ZERO
      do i = 1,n_gcm
         O(i,i) = ONE
         do j=1,n_gcm
         do k=1,n_gcm
            O(i,j) = O(i,j) + Yr(k,i)*Yr(k,j)
         end do
         end do
      end do
 
      A.to_inverse_sqrt_of(O)
      O = A

      Z.destroy
      PZP.destroy
      A.destroy
 
      GG.create(.n_bf,.n_bf)
 
      do n = 1,n_pt

         ! here it comes babes point for point the density will be on
         ! and on calculated I am sincerely sorry, but the code
         ! comparing to it's non-relativistic counter part really not
         ! effective :(
         .::make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)
 
        g=ZERO
 
        do i=1,.n_bf
          do j=1,.n_bf
            g = g + D(i,j)*GG(i,j)
          end            
        end            
 
        density_grid(n)= g
       end
 
     S.destroy
     O.destroy
     GG.destroy
     YU.destroy
     Yr.destroy
     Ap.destroy
     E.destroy
     p.destroy
     bp.destroy
     ep.destroy
     m_out.destroy

   end

   density_IOTC_gc(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{REAL} , OUT
    pt :: MAT{REAL} , IN
    D :: MAT{CPX} , IN

    n_gcm,n_pt :: INT
    n,i,j :: INT
    g,fac,c,alpha,alpha2,eps :: REAL
    gc,II :: CPX
    m_out,mmm :: MAT{INT}* 
    Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
    GG22 :: MAT{CPX}*
    SOx,SOy,SOz :: MAT{REAL}*
    A2,PAP,O,Ox,Yr :: MAT{CPX}*
    Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*

    n_pt = pt.dim1
     !test
     mmm.create(.n_prim,.n_prim)
      .REL:get_n_gcm(mmm,n_gcm)
     mmm.destroy 
     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
       DIE(" It seems you are using contracted gaussians this does not work for IOTC at gchf level!")
     end if    

  !!! n_gcm = .n_prim = .n_bf

! this is actually not needed but I am also using n_gcm 
     m_out.create(.n_prim,.n_prim) 
     .REL:make_ready_da_gcm_tr2(m_out,n_gcm) 
     R.create(.n_prim,.n_prim)
     S.create(n_gcm,n_gcm)
     Y.create(n_gcm,n_gcm)
     !!!  OVERLAP MATRIX + Y MX !!!
     .REL:make_primitive_overlap_matrix(S)
     Y.to_inverse_sqrt_of(S)
   !  .make_S_Y(S,Y)  !  ???

!!!  KINETIC ENERGY MATRIX -> U & P2!!!
     T.create(n_gcm,n_gcm)
     T=ZERO
     .REL:make_primitive_kinetic_matrix(T)
     R=ZERO
     R.to_product_of(Y,T)   
     T.to_product_of(R,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     P2.create(n_gcm)
     U.create(n_gcm,n_gcm)
     P2=ZERO;U=ZERO
     T.solve_eigenproblem(P2,U)
     ! the momentum squared instead of kinetic energy
     P2= TWO * P2

     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     Y.destroy
     U.destroy
     T.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     Z.create(n_gcm,n_gcm)
    .REL:make_primitive_nuclear_matrix(Z)
! put the potential energy matrix into the YU space
     R.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(R,YU)
     R=ZERO

!!!  PZP MATRIX  !!!
     PZP.create(n_gcm,n_gcm)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
         .REL:make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
    .BASE:put_debug(PZP,"PZP matrix")
    .BASE:put_debug(SOx,"SOx matrix")
    .BASE:put_debug(SOy,"SOy matrix")
    .BASE:put_debug(SOz,"SOz matrix")

     R.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(R,YU)
     R=ZERO

    .BASE:put_debug(PZP,"PZP matrix YU")
    .BASE:put_debug(SOx,"SOx matrix YU")
    .BASE:put_debug(SOy,"SOy matrix YU")
    .BASE:put_debug(SOz,"SOz matrix YU")
!    .BASE:put_debug(ppZpp,"ppZpp matrix YU")

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
     Ap.create(n_gcm)

     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)
     end do

     P2.destroy

     do i = 1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

       end
     end

    .BASE:put_debug(PZP,"PZP matrix YUAp")
    .BASE:put_debug(SOx,"SOx matrix YUAp")
    .BASE:put_debug(SOy,"SOy matrix YUAp")
    .BASE:put_debug(SOz,"SOz matrix YUAp")

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(Z)
     A2.beta_beta_plus(Z)
!   A.make_hermitian   
    .BASE:put_debug(A2,"A matrix")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PZP)
     PAP.beta_beta_plus(PZP)
     II = (ZERO,ONE)
     fac= ONE
      PAP.beta_alpha_plus(SOx,fac*II)
      PAP.beta_alpha_plus(SOy,-fac)
      PAP.alpha_alpha_plus(SOz,fac*II)
      PAP.beta_beta_plus(SOz,-fac*II)
      PAP.make_hermitian   
    .BASE:put_debug(PAP,"PAP matrix")

     Y0.create(n_gcm,n_gcm)
     Y0=ZERO
     .REL:find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)

     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy

! lets find the transforation matrix
     Yr.create(2*n_gcm,2*n_gcm)
     Yr=(ZERO,ZERO)
     Yr.alpha_alpha_plus(Y0)
     Yr.beta_beta_plus(Y0)
     Y0.destroy

!    .find_da_Y_iterative(Yr,PZP,SOx,SOy,SOz,Z,p,bp,ep)
    .REL:find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
    .BASE:put_debug(Yr,"Y matrix")

    PAP.destroy
    A2.destroy

     O.create(2*n_gcm,2*n_gcm)
     Ox.create(2*n_gcm,2*n_gcm)
     O=(ZERO,ZERO)
!     A=(ZERO,ZERO)
     Ox=(ZERO,ZERO)
     do i=1,2*n_gcm
       Ox(i,i)=ONE
     end do
     O.to_product_of(Yr,Yr,dagger_a=TRUE)
     Ox=Ox+O
     O=(ZERO,ZERO)
    UN.create(2*n_gcm)
    UN=ZERO

    ! make ready the preconditioning
    do i=1,2*n_gcm
      UN(i)=ONE/sqrt(real(Ox(i,i)))
    end 

    do i=1,2*n_gcm
      do j=1,2*n_gcm
        Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
      end
    end  
    .BASE:put_debug(Ox,"Ox matrix")
     eps=TOL(15)
     O.to_power_series_inv_sqrt_of(Ox,eps)
    do i=1,2*n_gcm
      do j=1,2*n_gcm
        O(i,j)=O(i,j)*UN(j)
      end
    end  
    UN.destroy
    Ox.destroy

    .BASE:put_debug(O,"O matrix")

    GG22.create(2*n_gcm,2*n_gcm)
    do n = 1,n_pt
       GG22=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code is comparing to it's non-relativistic
! counter part really not effective :(
     .::make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)

       gc=(ZERO,ZERO)

       do i=1,2*.n_bf
         do j=1,2*.n_bf
             gc = gc + D(j,i)*GG22(i,j)
         end            
       end            
       g=ZERO
       g= real(gc)      
       density_grid(n)= g
    end

    S.destroy
    O.destroy
    Yr.destroy
    GG22.destroy
    YU.destroy
    Ap.destroy
    E.destroy
    bp.destroy
    ep.destroy
    p.destroy
    m_out.destroy
   end

!  ===================================
!  Efficient electron density routines
!  ===================================

   make_rho_grid(N0,pt,D) ::: leaky
   ! Make the density "N0" on an arbitrary grid "pt" skipping as many
   ! points as possible. This routine will probably have to be batched
   ! over *spatially localised* points to reduce memory requirements.
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(N0.dim==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      bf_lgval :: VEC{VEC_{INT}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      ra :: VEC{REAL}(3)
      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      overlapping_atom, lga,lgb, sp :: VEC{INT}*
      grida0,gridb0, DD :: MAT{REAL}*
      sha :: SHELL1
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n  :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT

      ! Basis function cutoff 
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)
   
         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt) 
   
         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom => .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)
            if (atom_b>atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Loop shells on atom a
            do sa = fsa,lsa
      
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
      
               ! Set shell for index "sa"
               bs           = .basis_shell_for_shell(sa)
               sha          = .precomputed_basis_shellpair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grida0 and lga values
               grida0.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(grida0,n_pt,na,xa,ya,za,a2,lga)
   
               ! Save the values
               bf_grid0(sa).element => grida0
               bf_lgval(sa).element => lga

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)
   
                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1
   
                  ! Get the "sb" basis function grid
                  lgb    => bf_lgval(sb).element 
                  gridb0 => bf_grid0(sb).element 
   
                  ! How many points in common?
                  n_keep = count(lga+lgb>=cutoff)
                  if (n_keep==0) cycle
   
                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=lga+lgb>=cutoff)
   
                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE
   
                  ! Density block
                  DD => D(fa:la,fb:lb)
   
                  if (na*nb==1) then
   
                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     do p = 1,n_keep
                        n = sp(p)
                        ga = ga0(n)
                        gb = gb0(n)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end
   
                  else
   
                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              n = sp(p)
                              ga = ga0(n)
                              gb = gb0(n)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end
   
                     ! Clean up
   
                  end ! if ss or not ss
               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

   end

   make_derivative_rho_grid(N0,pt,D) ::: leaky
   ! Make the field "N0" on an arbitrary grid "pt" skipping as many
   ! points as possible. This routine will probably have to be batched
   ! over *spatially localised* points to reduce memory requirements.
      N0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT3{REAL}, target, IN

   ENSURE(N0.dim1==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(N0.dim2== D.dim3,"N0 and D: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      bf_lgval :: VEC{VEC_{INT}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      ra :: VEC{REAL}(3)
      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      overlapping_atom, lga,lgb, sp :: VEC{INT}*
      grida0,gridb0 :: MAT{REAL}*
      DD :: MAT3{REAL}*
      sha :: SHELL1
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n, q,n_dens :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT

      ! No of densities
      n_dens = D.dim3

      ! Basis function cutoff 
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)
   
         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt) 
   
         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom => .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)
            if (atom_b>atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Loop shells on atom a
            do sa = fsa,lsa
      
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
      
               ! Set shell for index "sa"
               bs           = .basis_shell_for_shell(sa)
               sha          = .precomputed_basis_shellpair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grida0 and lga values
               grida0.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(grida0,n_pt,na,xa,ya,za,a2,lga)
   
               ! Save the values
               bf_grid0(sa).element => grida0
               bf_lgval(sa).element => lga

             ! if (.BASE:debugging("make_rho_grid:sa")) then
             !    stdout.text("grid0:")
             !    stdout.put(grida0,auto_width=TRUE)
             !    stdout.text("lga:")
             !    stdout.put(lga,by_column=TRUE,auto_width=TRUE)
             ! end

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)
   
                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1
   
                  ! Get the "sb" basis function grid
                  gridb0 => bf_grid0(sb).element 
                  lgb    => bf_lgval(sb).element 
   
                  ! How many points in common?
                  n_keep = count((lga+lgb)>=cutoff)
                  if (n_keep==0) cycle
   
                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=(lga+lgb)>=cutoff)

                ! if (.BASE:debugging("make_rho_grid:sb")) then
                !    stdout.show("n_keep =",n_keep)
                !    stdout.text("sp:")
                !    stdout.put(sp(1:n_keep),by_column=TRUE,auto_width=TRUE)
                ! end
   
                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE
   
                  ! Density block
                  DD => D(fa:la,fb:lb,:)
   
                  if (na*nb==1) then
   
                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     do q = 1,n_dens
                        Dab = fac*DD(1,1,q)
                        do p = 1,n_keep
                           n = sp(p)
                           ga = ga0(n)
                           gb = gb0(n)
                           val = ga*gb*Dab
                           N0(n,q) = N0(n,q) + val
                        end
                     end
   
                  else
   
                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           do q = 1,n_dens
                              Dab = fac*DD(a,b,q)
                              do p = 1,n_keep
                                 n = sp(p)
                                 ga = ga0(n)
                                 gb = gb0(n)
                                 val = ga*gb*Dab
                                 N0(n,q) = N0(n,q) + val
                              end
                           end
                        end
                     end
   
                     ! Clean up
   
                  end ! if ss or not ss
               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

      if (.BASE:debugging("make_rho_grid:n0")) then
         stdout.text("N0:")
         stdout.put(N0,auto_width=TRUE)
      end

   end

!   make_nabla_density_grid_r_A(grid1,grid0,pt,atoms,ex)
!   ! Evaluate the nabla density grid "grid1" and density grid "grid0" on a set
!   ! of grid points "pt", for use in matrix elements needed by DFT grid
!   ! integration. "atoms" lists the atoms whose grid points are to be used in
!   ! DFT matrix element integration.  Normally they will be the atom-pair
!   ! corresponding to the basis function pair in the matrix element. We don't
!   ! have to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it does not depend on having the natural orbitals
!   ! defined.
!      grid1 :: MAT{REAL}, OUT
!      grid0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      ex :: VEC{REAL}, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
!   ENSURE(grid1.dim1==pt.dim1,"grid1 has wrong 1st dimension")
!   ENSURE(grid1.dim2==3,"grid1 has wrong 2nd dimension")
!   ENSURE(grid0.dim==pt.dim1,"grid0 has wrong 1st dimension")
!   ENSURE(ex.dim==pt.dim1,"ex has wrong dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!      xa,ya,za,aa,xb,yb,zb,bb :: VEC{REAL}*
!      keep  :: VEC{BIN}*
!      sha,shb :: SHELL1
!      a0,a1,a2,a3,b0,bP :: MAT{REAL}*
!      atom_a,sa,fsa,lsa,fa,la,atom_b,sb,fsb,lsb,fb,lb, n_pt,na,nb,i,j :: INT
!      cutoff,val,ea,eb,fac :: REAL
!      cutoff = -log(.becke_grid.rho_cutoff)              ! Cutoff
!      keep.create(pt.dim1)
!      sha.nullify_ptr_part
!      shb.nullify_ptr_part
!      grid1 = ZERO
!      grid0 = ZERO
!      ! Loop over density basis functions "a" and "b". Keep only significant
!      ! points at each stage using a density cutoff not basis function cutoff.
!      do atom_a = 1,.n_atom                                 
!         if (NOT .BASE:is_overlapping_atom(atom_a,atoms)) cycle  
!         fsa = .first_shell_for_atom(atom_a)
!         lsa = .last_shell_for_atom(atom_a)
!         .atom(atom_a).make_displaced_points(xa,ya,za,aa,pt,create=TRUE)
!         do atom_b = 1,atom_a
!            if (NOT .BASE:is_overlapping_atom(atom_b,atoms)) cycle
!            if (NOT .BASE:is_overlapping_atom(atom_a,atom_b)) cycle     ! Only atom pairs which overlap
!            fsb = .first_shell_for_atom(atom_b)
!            lsb = .last_shell_for_atom(atom_b)
!            .atom(atom_b).make_displaced_points(xb,yb,zb,bb,pt,create=TRUE)
!            do sa = fsa,lsa
!               .get_shell(sha,sa,fa,la)
!               na = sha.n_comp
!               ea = minval(sha.ex)
!               do sb = fsb,min(sa,lsb)
!                  .get_shell(shb,sb,fb,lb)
!                  nb = shb.n_comp
!                  eb = minval(shb.ex)
!                  keep = ea*aa+eb*bb<=cutoff
!                  keep = TRUE
!                  n_pt = count(keep)                                   ! # of significant points
!    ! stdout.text("============")
!    ! stdout.show("atom_a=",atom_a)
!    ! stdout.show("atom_b=",atom_b)
!    ! stdout.show("sa=",sa)
!    ! stdout.show("sb=",sb)
!    ! stdout.show("cutoff=",cutoff)
!    ! stdout.show("n_pt0 =",n_pt)
!    ! stdout.text("============")
!                  if (n_pt>0) then
!                     fac = TWO
!                     if (sa==sb) fac = ONE
!                     a0.create(n_pt,na)
!                     a1.create(n_pt,na); a2.create(n_pt,na); a3.create(n_pt,na)
!                     sha.make_nabla_grid(a1,a2,a3,a0,xa,ya,za,aa,keep) 
!                     bP.create(n_pt,na)
!                     b0.create(n_pt,nb)
!                     shb.make_grid(b0,xb,yb,zb,bb,keep)
!                     bP = matmul(b0,.density_matrix.restricted(fb:lb,fa:la))
!                     b0.destroy
!                     do j = 1,na
!                     do i = 1,n_pt
!                        val = fac*bP(i,j)
!                        grid0(i)   = grid0(i)   + a0(i,j)*val
!                        grid1(i,1) = grid1(i,1) + a1(i,j)*val
!                        grid1(i,2) = grid1(i,2) + a2(i,j)*val
!                        grid1(i,3) = grid1(i,3) + a3(i,j)*val
!                     end
!                     end
!                     bP.destroy
!                     a0.destroy; a3.destroy; a2.destroy; a1.destroy
!                  end
!                  shb.destroy_ptr_part
!               end
!               sha.destroy_ptr_part
!            end
!            .atom(atom_b).tidy_displaced_points(xb,yb,zb,bb)
!         end
!         .atom(atom_a).tidy_displaced_points(xa,ya,za,aa)
!      end
!      keep.destroy
!      grid1 = TWO*grid1
!   end

!   make_nabla_density_grid_r_A(grid1,grid0,pt,atoms)
!   ! Evaluate the nabla density grid "grid1" as well as the density grid "grid0"
!   ! on a set of grid points "pt", for use in matrix elements needed by DFT grid
!   ! integration. "atoms" lists the atoms whose grid points are to be used in
!   ! DFT matrix element integration.  Normally they will be the atom-pair
!   ! corresponding to the basis function pair in the matrix element. We don't
!   ! have to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it does not depend on having the natural orbitals
!   ! defined.
!      grid1 :: MAT{REAL}, OUT
!      grid0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
!   ENSURE(grid1.dim1==pt.dim1,"grid1 has wrong 1st dimension")
!   ENSURE(grid1.dim2==3,"grid1 has wrong 2nd dimension")
!   ENSURE(grid0.dim==pt.dim1,"grid0 has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!      sha,shb :: SHELL1
!      a1 :: MAT3{REAL}*
!      a0,b0,bP :: MAT{REAL}*
!      n_pt,a,sa,fa,la,b,sb,fb,lb :: INT
!      fac :: REAL
!      grid1 = ZERO
!      grid0 = ZERO
!      n_pt = pt.dim1
!      do a = 1,.n_atom
!         if (NOT .BASE:is_overlapping_atom(a,atoms)) cycle
!         do sa = .first_shell_for_atom(a),.last_shell_for_atom(a)
!            .get_shell(sha,sa,fa,la)
!            a1.create(n_pt,sha.n_comp,3)
!            a0.create(n_pt,sha.n_comp)
!            sha.make_nabla_grid(a1,a0,pt)         ! Call this as little as possible
!            do b = 1,.n_atom
!               if (NOT .BASE:is_overlapping_atom(b,atoms)) cycle
!               do sb = .first_shell_for_atom(b),.last_shell_for_atom(b)
!                  .get_shell(shb,sb,fb,lb)
!                  bP.create(n_pt,sha.n_comp)
!                  b0.create(n_pt,shb.n_comp)
!                  shb.make_grid(b0,pt)            ! Call this as little as possible
!                  bP = matmul(b0,.density_matrix.restricted(fb:lb,fa:la))
!                  b0.destroy
!                  grid0      = grid0      + sum(a0*bP,dim=2)
!                  grid1(:,1) = grid1(:,1) + sum(a1(:,:,1)*bP,dim=2)
!                  grid1(:,2) = grid1(:,2) + sum(a1(:,:,2)*bP,dim=2)
!                  grid1(:,3) = grid1(:,3) + sum(a1(:,:,3)*bP,dim=2)
!                  bP.destroy
!                  shb.destroy_ptr_part
!               end
!            end
!            a0.destroy; a1.destroy
!            sha.destroy_ptr_part
!         end
!      end
!      grid1 = TWO*grid1
!   end

!  ===============
!  Hirshfeld grids
!  ===============

   make_Hirshfeld_rho_grid(N0,pt,wt,c,D) ::: leaky
   ! Make the density "N0" on the Becke grid ("pt","wt") for atom
   ! "c" given AO density matrix "D". Density "N0" weighted by the
   ! grid weights and by the Hirshfeld partition weight for atom "c". 
      N0 :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DD :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Get the Becke grid for atom "c"
      .becke_grid.make_grid(pt,wt,gridc0,c)
      n_pt = pt.dim1

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Make stockholder weight function "Wc" for atom "c"
      ! If using interpolatators, then overlapping_atoms 
      ! are not needed ... otherwise nothing is skipped
      .::apply_stockholder_atom_weight(wt,c,pt)

      ! Prune the grid with new "wt", get saved bf grid gridc0, 
      ! and new no of points, n_pt -- leaky
      .becke_grid.prune_grid(pt,wt,gridc0)
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt)
      N0 = ZERO
      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep)
                     pj.create(n_keep)
                     pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Weight the density
      N0 = N0*wt

      ! Clean up
      bf_grid0.destroy
      bf_skip.destroy
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

!  ===================
!  Becke density grids
!  ===================

   set_up_becke_grid ::: leaky
   ! Set up the Becke grids and overlapping atoms

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")

      if (.becke_grid.destroyed) .becke_grid.create 

      ! ALWAYS Set up integration grid 
      ! (in case of new positions) (leaky)
      .becke_grid.set_grid_data(.atom) ! leaky

      ! ALWAYS make the overlapping atom lists
      .BASE:make_overlapping_atoms

   end

   make_rho_becke_atom_grid(N0,pt,wt,bf_skip,bf_grid0,c,D) ::: leaky
   ! Make the density "N0" on the Becke grid ("pt","wt") for atom
   ! "c" given AO density matrix "D". Also return the "bf_skip" arrays
   ! and the "bf_grid0" array used for evaluating the rho (or other
   ! density functionals) on the grid.
      N0 :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DD :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,c,overlapping_atom) 
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt)
      N0 = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

   make_density_grid_r_B(rho0,pt,atoms,a0,b0)
   ! Evaluate the density grid "rho0" at the grid points "pt", for use in matrix
   ! elements needed by DFT grid integration.  "atoms" is a list of indices of
   ! the atoms whose grid points are to be used in DFT integrations.  "a0" and
   ! "b0" are the basis function grids for the atoms listed in "atoms".  These
   ! are the grids for the atoms whose matrix elements are to be evaluated. We
   ! don't have to calculate the density contributions for any atoms which do
   ! not have basis functions which overlap with those in "atoms", because the
   ! orbital density from those atoms evaluated at those in the "atoms" list
   ! will be negligible. NOTE: this routine depends on having the
   ! .overlapping_atoms array defined. NOTE: it depends on having the natural
   ! orbitals defined, and it may take much more memory than version A above,
   ! but it may be quicker.
      rho0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a0,b0 :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho0.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no restrictd occupation numbers")

      sh :: SHELL1
      g0,sh_grid0,NO :: MAT{REAL}*
      n_pt,n_occ,a,s,f,l,fs,ls,ns,n :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .occupation_numbers.no_of_occupied("restricted")

      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      g0.create(n_pt,n_occ)
      g0 = ZERO
      do a = 1,.n_atom
         if (any(a==atoms)) then                                ! Use the supplied grids
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NO => .natural_orbitals.restricted(f:l,:n_occ)      ! Multiply by all orbitals
            if (a==atoms(1)) then; g0 = g0 + matmul(a0,NO)      ! Re-use a0
            else;                  g0 = g0 + matmul(b0,NO)      ! Re-use b0
            end
         else if (.BASE:is_overlapping_atom(a,atoms)) then      ! Do only overlapping atoms
            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
               .BASE:get_shell(sh,s,fs,ls,ns)
               sh_grid0.create(n_pt,ns)
               sh.make_grid(sh_grid0,pt)                        ! Call this as little as possible
               NO => .natural_orbitals.restricted(fs:ls,:n_occ) ! Multiply by all orbitals
               g0 = g0 + matmul(sh_grid0,NO)
               sh_grid0.destroy
               sh.destroy_ptr_part
            end
         end
      end

      ! Now square up each natural orbital. We can't skip any NO's
      ! since they could be all delocalised.
      rho0 = ZERO
      do n = 1,n_occ
         occ = .occupation_numbers.restricted(n)
         rho0 = rho0 + occ*g0(:,n)*g0(:,n)
      end
      g0.destroy

   end

   make_rho_becke_atom_grid(N0,Nx,Ny,Nz,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,D) ::: leaky
   ! Make the density "N0" and its derivatives "Nx", "Ny", "Nz", on
   ! the Becke grid ("pt","wt") for atom "c" given AO density matrix
   ! "D". Also return the "bf_skip" array, and the basis function and
   ! basis function derivative arrays "bf_grid0", "bf_gridx",
   ! "bf_gridy", "bf_gridz" used for evaluating the density
   ! functionals on the grid.
      N0,Nx,Ny,Nz :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2 :: VEC{REAL}*
      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      DD :: MAT{REAL}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      gridc0,gridcx,gridcy,gridcz :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Dab, fac, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba,offset, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,gridcx,gridcy,gridcz,c,overlapping_atom) 
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt); N0 = ZERO
      Nx.create(n_pt); Nx = ZERO
      Ny.create(n_pt); Ny = ZERO
      Nz.create(n_pt); Nz = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)
      bf_gridx.create(.n_shell)
      bf_gridy.create(.n_shell)
      bf_gridz.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            gridax.create(n_keep,na)
            griday.create(n_keep,na)
            gridaz.create(n_keep,na)
            if (oa==c) then
               offset = fa-fba
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+offset)
                     gridax(i,a) = gridcx(n,a+offset)
                     griday(i,a) = gridcy(n,a+offset)
                     gridaz(i,a) = gridcz(n,a+offset)
                  end
               end
            else
               sha.make_skip_nabla_grid(gridax,griday,gridaz,grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0
            bf_gridx(sa).element => gridax
            bf_gridy(sa).element => griday
            bf_gridz(sa).element => gridaz

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 
                  gridbx => bf_gridx(sb).element 
                  gridby => bf_gridy(sb).element 
                  gridbz => bf_gridz(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        N0(n) = N0(n) + Dab* ga*gb
                        Nx(n) = Nx(n) + Dab*(gax(i)*gb + ga*gbx(j))
                        Ny(n) = Ny(n) + Dab*(gay(i)*gb + ga*gby(j))
                        Nz(n) = Nz(n) + Dab*(gaz(i)*gb + ga*gbz(j))
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              N0(n) = N0(n) + Dab* ga*gb
                              Nx(n) = Nx(n) + Dab*(gax(i)*gb + ga*gbx(j))
                              Ny(n) = Ny(n) + Dab*(gay(i)*gb + ga*gby(j))
                              Nz(n) = Nz(n) + Dab*(gaz(i)*gb + ga*gbz(j))
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridcz.destroy
      gridcy.destroy
      gridcx.destroy
      gridc0.destroy

   end

   make_nabla_density_grid_r_B(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,n_occ,bf_cutoff)
   ! Evaluate the nabla density grid "rho1" as well as the density grid
   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
   ! the basis function grids for the atoms listed in "atoms". These are the
   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
   ! to calculate the density contributions for any atoms which do not have
   ! basis functions which overlap with those in "atoms", because the orbital
   ! density from those atoms evaluated at those in the "atoms" list will be
   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
   ! array defined. NOTE: it depends on having the natural orbitals defined, and
   ! it may take much more memory than version A above, but it may be quicker.
      rho1 :: MAT{REAL}, OUT
      rho0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a1,b1 :: MAT3{REAL}
      a0,b0 :: MAT{REAL}
      ma,mb :: INT, IN
      n_occ :: INT, IN
      bf_cutoff :: REAL, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
   ENSURE(pt.dim1==(ma+mb),"pt, inconsistent 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      sh :: SHELL1
      shell :: VEC{SHELL}*
      pos :: VEC{REAL}(3) 
      skip :: VEC{BIN}*
      list :: VEC{INT}*
      x,y,z,r2 :: VEC{REAL}*
      g1,gg1,sh_grid1 :: MAT3{REAL}*
      g0,gg0,sh_grid0,NO :: MAT{REAL}*
      n_pt,n_cut,aa,a,s,f,l,fs,ls,n, i,k :: INT
      cut,occ,val :: REAL
      do_a,do_b :: BIN

      ! Basis function cutoff for orbitals
      cut = bf_cutoff

      ! Orbital, and orbital gradient arrays
      n_pt = pt.dim1
      g1.create(n_pt,n_occ,3); g1 = ZERO
      g0.create(n_pt,n_occ);   g0 = ZERO

      ! List of atoms which overlap "atoms" basis functions
      list => .BASE:overlapping_atoms_for(atoms)

      ! Loop only over the overlapping atoms
      do aa = 1,list.dim

         a = list(aa)

         ! Atom "a" is one where basis functions are centered.
         ! Use the supplied (precalculated) basis function grids.
         if (any(a==atoms)) then                               

            ! Multiply by all orbitals
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NO => .natural_orbitals.restricted(f:l,:n_occ)     

            if (a==atoms(1)) then
               g1(:,:,1) = g1(:,:,1) + matmul(a1(:,:,1),NO)
               g1(:,:,2) = g1(:,:,2) + matmul(a1(:,:,2),NO)
               g1(:,:,3) = g1(:,:,3) + matmul(a1(:,:,3),NO)
               g0        = g0        + matmul(a0,NO)
            else
               g1(:,:,1) = g1(:,:,1) + matmul(b1(:,:,1),NO)
               g1(:,:,2) = g1(:,:,2) + matmul(b1(:,:,2),NO)
               g1(:,:,3) = g1(:,:,3) + matmul(b1(:,:,3),NO)
               g0        = g0        + matmul(b0,NO)
            end

         ! Atom "a" is NOT one where basis functions are centered.
         else                                                  

            ! Do both atoms overlap?
            do_a = .BASE:is_overlapping_atom(a,atoms(1))
            if (atoms.dim==1) then; do_b = TRUE
            else;                   do_b = .BASE:is_overlapping_atom(a,atoms(2))
            end

            pos = .atom(a).position
            shell => .atom(a).basis.shell
            ls = .first_basis_fn_for_atom(a) - 1

            ! Both atoms overlap (or only one in "atoms")
            if (do_a AND do_b) then                            

               do s = 1,shell.dim

                  sh.set(shell(s),pos)

                  sh.make_significant_points(x,y,z,r2,skip,pt,cut)

                  if (x.destroyed) cycle

                  ! Call this as little as possible
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)   

                  ! Multiply by all orbitals
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ) 
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)

                  k = 0
                  do i = 1,n_pt
                     if (skip(i)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end

                  ! Clean
                  gg0.destroy
                  gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy
                  y.destroy
                  z.destroy
                  r2.destroy
                  skip.destroy

               end

            ! Only the first overlaps
            else if (do_a) then                               

               do s = 1,shell.dim

                  sh.set(shell(s),pos)

                  sh.make_significant_points(x,y,z,r2,skip,pt(:ma,:),cut)

                  if (x.destroyed) cycle

                  ! Call this as little as possible
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)    

                  ! Multiply by all orbitals
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ)  
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)

                  k = 0
                  do i = 1,ma
                     if (skip(i)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end

                  ! Clean
                  gg0.destroy
                  gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy
                  y.destroy
                  z.destroy
                  r2.destroy
                  skip.destroy

               end

            ! Only the second overlaps
            else if (atoms.dim==2 AND do_b) then               

               do s = 1,shell.dim

                  sh.set(shell(s),pos)

                  sh.make_significant_points(x,y,z,r2,skip,pt(ma+1:,:),cut)

                  if (x.destroyed) cycle

                  ! Call this as little as possible
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)   

                  ! Multiply by all orbitals
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ) 
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)
                  k = 0
                  do i = ma+1,n_pt
                     if (skip(i-ma)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end

                  ! Clean
                  gg0.destroy
                  gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy
                  y.destroy
                  z.destroy
                  r2.destroy
                  skip.destroy

               end

            end
         end
      end

      ! Now square up each natural orbital. We can't skip any NO's
      ! since they could be all delocalised.
      cut = cut/sqrt(REALIFY(n_occ))
      rho1 = ZERO
      rho0 = ZERO
      do n = 1,n_occ
         occ = .occupation_numbers.restricted(n)
         do i = 1,n_pt
            val = g0(i,n)
            if (abs(val)<cut) cycle
            rho1(i,1) = rho1(i,1) + occ*val*g1(i,n,1)
            rho1(i,2) = rho1(i,2) + occ*val*g1(i,n,2)
            rho1(i,3) = rho1(i,3) + occ*val*g1(i,n,3)
            rho0(i)   = rho0(i)   + occ*val*val
         end
      end

      ! Clean
      g0.destroy
      g1.destroy
      list.destroy

      ! Scale
      rho1 = TWO*rho1

   end

   make_rho_becke_atom_grid(N0a,N0b,pt,wt,bf_skip,bf_grid0,c,Da,Db) ::: leaky
   ! Make the alpha and beta densities "N0a", "N0b" on the Becke grid
   ! ("pt","wt") for atom "c" given AO density matrices "Da", "Db".
   ! Also return the "bf_skip" arrays and the "bf_grid0" array used
   ! for evaluating the density (or density functionals) on the grid.
      N0a,N0b :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      Da,Db  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DDa,DDb :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Da_ab,Db_ab, fac, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,c,overlapping_atom) 
      n_pt = pt.dim1

      ! Create N0a, N0b
      N0a.create(n_pt); N0a = ZERO
      N0b.create(n_pt); N0b = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        gab = ga*gb
                        N0a(n) = N0a(n) + Da_ab*gab
                        N0b(n) = N0b(n) + Db_ab*gab
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              gab = ga*gb
                              N0a(n) = N0a(n) + Da_ab*gab
                              N0b(n) = N0b(n) + Db_ab*gab
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridc0.destroy

   end

   make_density_grid_u_B(rho0a,rho0b,pt,atoms,a0,b0)
   ! Evaluate the alpha and beta density grids "rho0a" and "rho0b" at the grid
   ! points "pt", for use in matrix elements needed by DFT grid integration.
   ! "atoms" is a list of indices of the atoms whose grid points are to be used
   ! in DFT integrations.  "a0" and "b0" are the basis function grids for the
   ! atoms listed in "atoms".  These are the grids for the atoms whose matrix
   ! elements are to be evaluated. We don't have to calculate the density
   ! contributions for any atoms which do not have basis functions which overlap
   ! with those in "atoms", because the orbital density from those atoms
   ! evaluated at those in the "atoms" list will be negligible. NOTE: this
   ! routine depends on having the .overlapping_atoms array defined. NOTE: it
   ! depends on having the natural orbitals defined, and it may take much more
   ! memory than version A above, but it may be quicker.
      rho0a,rho0b :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a0,b0 :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(rho0b.dim==pt.dim1,"rho0b has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("unrestricted"), "no unrestricted NO's")
   ENSURE(.occupation_numbers.created("unrestricted"),"no unrestrictd occupation numbers")

      sh :: SHELL1
      g0a,g0b,sh_grid0,NOa,NOb :: MAT{REAL}*
      n_pt,na,nb,a,s,f,l,fs,ls,ns,n :: INT
      occ :: REAL

      n_pt = pt.dim1
      na = .occupation_numbers.no_of_occupied("alpha")
      nb = .occupation_numbers.no_of_occupied("beta")

      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      g0a.create(n_pt,na)
      g0b.create(n_pt,nb)
      g0a = ZERO
      g0b = ZERO
      do a = 1,.n_atom
         if (any(a==atoms)) then                                ! Use the supplied grids
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NOa => .natural_orbitals.alpha(f:l,:na)             ! Multiply by all orbitals
            NOb => .natural_orbitals.beta(f:l,:nb)     
            if (a==atoms(1)) then
               g0a = g0a + matmul(a0,NOa)                       ! Re-use a0
               g0b = g0b + matmul(a0,NOb)
            else
               g0a = g0a + matmul(b0,NOa)                       ! Re-use b0
               g0b = g0b + matmul(b0,NOb)
            end
         else if (.BASE:is_overlapping_atom(a,atoms)) then           ! Do only overlapping atoms
            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
               .BASE:get_shell(sh,s,fs,ls,ns)
               sh_grid0.create(n_pt,ns)
               sh.make_grid(sh_grid0,pt)                        ! Call this as little as possible
               NOa => .natural_orbitals.alpha(fs:ls,:na)        ! Multiply by all orbitals
               NOb => .natural_orbitals.beta(fs:ls,:nb)     
               g0a = g0a + matmul(sh_grid0,NOa)
               g0b = g0b + matmul(sh_grid0,NOb)
               sh_grid0.destroy
               sh.destroy_ptr_part
            end
         end
      end

      ! Now square up each natural orbital. We can't skip any NO's since they
      ! could be all delocalised.
      rho0a = ZERO
      rho0b = ZERO
      do n = 1,na
         occ = .occupation_numbers.alpha(n)
         rho0a = rho0a + occ*g0a(:,n)*g0a(:,n)
      end
      do n = 1,nb
         occ = .occupation_numbers.beta(n)
         rho0b = rho0b + occ*g0b(:,n)*g0b(:,n)
      end
      g0b.destroy
      g0a.destroy

   end

   make_rho_becke_atom_grid(N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,Da,Db) ::: leaky
   ! Make the densities "N0a", "N0b" and their alpha/beta derivatives
   ! "Nxa", "Nya", "Nza", "Nxb", "Nyb", "Nzb", on the Becke grid
   ! ("pt","wt") for atom "c" given AO density matrices "Da", "Db".
   ! Also return the "bf_skip" array, and the basis function and basis
   ! function derivative arrays "bf_grid0", "bf_gridx", "bf_gridy",
   ! "bf_gridz" for evaluating the density functionals on the grid.
      N0a,N0b :: VEC{REAL}*
      Nxa,Nya,Nza :: VEC{REAL}*
      Nxb,Nyb,Nzb :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      Da,Db :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2 :: VEC{REAL}*
      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      DDa,DDb :: MAT{REAL}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      gridc0,gridcx,gridcy,gridcz :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Da_ab,Db_ab, fac, ga,gb,gab,gx,gy,gz :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba,offset, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,gridcx,gridcy,gridcz,c,overlapping_atom) 
      n_pt = pt.dim1

      ! Create N0 arrays
      N0a.create(n_pt); Nxa.create(n_pt); Nya.create(n_pt); Nza.create(n_pt)
      N0b.create(n_pt); Nxb.create(n_pt); Nyb.create(n_pt); Nzb.create(n_pt)
      N0a = ZERO; Nxa = ZERO; Nya = ZERO; Nza = ZERO
      N0b = ZERO; Nxb = ZERO; Nyb = ZERO; Nzb = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)
      bf_gridx.create(.n_shell)
      bf_gridy.create(.n_shell)
      bf_gridz.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            gridax.create(n_keep,na)
            griday.create(n_keep,na)
            gridaz.create(n_keep,na)
            if (oa==c) then
               offset = fa-fba
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+offset)
                     gridax(i,a) = gridcx(n,a+offset)
                     griday(i,a) = gridcy(n,a+offset)
                     gridaz(i,a) = gridcz(n,a+offset)
                  end
               end
            else
               sha.make_skip_nabla_grid(gridax,griday,gridaz,grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0
            bf_gridx(sa).element => gridax
            bf_gridy(sa).element => griday
            bf_gridz(sa).element => gridaz

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 
                  gridbx => bf_gridx(sb).element 
                  gridby => bf_gridy(sb).element 
                  gridbz => bf_gridz(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        gab = ga*gb
                        gx  = gax(i)*gb+ga*gbx(j)
                        gy  = gay(i)*gb+ga*gby(j)
                        gz  = gaz(i)*gb+ga*gbz(j)
                        N0a(n) = N0a(n) + Da_ab*gab
                        Nxa(n) = Nxa(n) + Da_ab*gx
                        Nya(n) = Nya(n) + Da_ab*gy
                        Nza(n) = Nza(n) + Da_ab*gz
                        N0b(n) = N0b(n) + Db_ab*gab
                        Nxb(n) = Nxb(n) + Db_ab*gx
                        Nyb(n) = Nyb(n) + Db_ab*gy
                        Nzb(n) = Nzb(n) + Db_ab*gz
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              gx  = gax(i)*gb+ga*gbx(j)
                              gy  = gay(i)*gb+ga*gby(j)
                              gz  = gaz(i)*gb+ga*gbz(j)
                              N0a(n) = N0a(n) + Da_ab*gab
                              Nxa(n) = Nxa(n) + Da_ab*gx
                              Nya(n) = Nya(n) + Da_ab*gy
                              Nza(n) = Nza(n) + Da_ab*gz
                              N0b(n) = N0b(n) + Db_ab*gab
                              Nxb(n) = Nxb(n) + Db_ab*gx
                              Nyb(n) = Nyb(n) + Db_ab*gy
                              Nzb(n) = Nzb(n) + Db_ab*gz
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      gridcz.destroy
      gridcy.destroy
      gridcx.destroy
      gridc0.destroy

   end

   make_nabla_density_grid_u_A(rho1a,rho1b,rho0a,rho0b,pt,atoms,aa1,aa0,bb1,bb0,cutoff)
   ! See below.
      rho1a,rho1b :: MAT{REAL}, OUT
      rho0a,rho0b :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      aa1,bb1 :: MAT3{REAL}
      aa0,bb0 :: MAT{REAL}
    ! ma,mb :: INT, IN
      cutoff :: REAL, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
 ! ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
 ! ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")

      sha,shb :: SHELL1
      list :: VEC{INT}*
      skipa,skipb :: VEC{BIN}*
      xa,ya,za,ra2,xb,yb,zb,rb2 :: VEC{REAL}*
      a1 :: MAT3{REAL}*
      a0,b0,a0Pa,a0Pb,b0Pa,b0Pb,Pa,Pb :: MAT{REAL}*
      n_pt,a_pt,b_pt,aa,a,sa,fa,la,na,bb,b,sb,fb,lb,nb, i,k,l :: INT
      fac :: REAL

      rho1a = ZERO; rho1b = ZERO
      rho0a = ZERO; rho0b = ZERO

      n_pt = pt.dim1

      ! List of atoms which overlap "atoms" basis functions
      list => .BASE:overlapping_atoms_for(atoms)

      ! Loop only over the overlapping atoms
      do aa = 1,list.dim

         a = list(aa)

         .atom(a).make_significant_points(xa,ya,za,ra2,skipa,pt,cutoff)

         if (xa.destroyed) cycle

         a_pt = xa.dim

         do sa = .first_shell_for_atom(a),.last_shell_for_atom(a)

            .BASE:get_shell(sha,sa,fa,la)

            a1.create(a_pt,sha.n_comp,3)
            a0.create(a_pt,sha.n_comp)

            sha.make_nabla_grid(a1,a0,xa,ya,za,ra2,cutoff) ! Call this as little as possible

            do bb = 1,list.dim

               b = list(bb)

               if (any(a==atoms) AND any(b==atoms)) cycle  ! Do with saved grids -- below

               .atom(b).make_significant_points(xb,yb,zb,rb2,skipb,pt,skipa,cutoff)

               if (xb.destroyed) cycle

               b_pt = xb.dim

               b0Pa.create(b_pt,sha.n_comp); b0Pa = ZERO
               b0Pb.create(b_pt,sha.n_comp); b0Pb = ZERO

               do sb = .first_shell_for_atom(b),.last_shell_for_atom(b)
                  .BASE:get_shell(shb,sb,fb,lb)
                  b0.create(b_pt,shb.n_comp)
                  shb.make_grid(b0,xb,yb,zb,rb2,cutoff) ! Call this as little as possible
                  Pa => .density_matrix.alpha(fb:lb,fa:la)
                  Pb => .density_matrix.beta(fb:lb,fa:la)
                  b0Pa = b0Pa + matmul(b0,Pa)
                  b0Pb = b0Pb + matmul(b0,Pb)
                  b0.destroy
                  shb.destroy_ptr_part
               end

               k = 0
               l = 0
               do i = 1,n_pt

                  if (skipa(i)) cycle
                  l = l + 1

                  if (skipb(i)) cycle
                  k = k + 1

                  rho1a(i,1) = rho1a(i,1) + sum(a1(l,:,1)*b0Pa(k,:))
                  rho1a(i,2) = rho1a(i,2) + sum(a1(l,:,2)*b0Pa(k,:))
                  rho1a(i,3) = rho1a(i,3) + sum(a1(l,:,3)*b0Pa(k,:))
                  rho1b(i,1) = rho1b(i,1) + sum(a1(l,:,1)*b0Pb(k,:))
                  rho1b(i,2) = rho1b(i,2) + sum(a1(l,:,2)*b0Pb(k,:))
                  rho1b(i,3) = rho1b(i,3) + sum(a1(l,:,3)*b0Pb(k,:))

               end

               if (bb<=aa) then
               if (aa==bb) then; fac = ONE
               else;             fac = TWO
               end

               k = 0
               l = 0
               do i = 1,n_pt

                  if (skipa(i)) cycle
                  l = l + 1

                  if (skipb(i)) cycle

                  k = k + 1
                  rho0a(i)   = rho0a(i)   + fac*sum(a0(l,:)  *b0Pa(k,:))
                  rho0b(i)   = rho0b(i)   + fac*sum(a0(l,:)  *b0Pb(k,:))

               end
               end

               ! Clean
               b0Pb.destroy
               b0Pa.destroy
               xb.destroy
               yb.destroy
               zb.destroy
               rb2.destroy
               skipb.destroy

            end

            ! Clean
            a0.destroy
            a1.destroy
            sha.destroy_ptr_part

         end

         ! Clean
         xa.destroy
         ya.destroy
         za.destroy
         ra2.destroy
         skipa.destroy

      end

      ! Clean
      list.destroy

      ! Now re-use the given grid data
      if (atoms.dim==1) then

         b = atoms(1)

         fb = .first_basis_fn_for_atom(b)
         lb =  .last_basis_fn_for_atom(b)
         nb = lb - fb + 1
         fa = fb
         la = lb
         na = nb

         b0Pa.create(n_pt,na)
         b0Pb.create(n_pt,na)

         Pa => .density_matrix.alpha(fb:lb,fa:la)
         Pb => .density_matrix.beta(fb:lb,fa:la)

         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + sum(aa0(:,:)  *b0Pa,dim=2)
         rho0b      = rho0b      + sum(aa0(:,:)  *b0Pb,dim=2)

         ! Clean
         b0Pb.destroy
         b0Pa.destroy

      else

         a = atoms(1)
         b = atoms(2)

         fa = .first_basis_fn_for_atom(a)
         fb = .first_basis_fn_for_atom(b)
         la =  .last_basis_fn_for_atom(a)
         lb =  .last_basis_fn_for_atom(b)

         na = la - fa + 1
         nb = lb - fb + 1

         b0Pa.create(n_pt,na)
         b0Pb.create(n_pt,na)

         Pa => .density_matrix.alpha(fb:lb,fa:la)
         Pb => .density_matrix.beta(fb:lb,fa:la)

         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + TWO*sum(aa0(:,:)*b0Pa,dim=2)
         rho0b      = rho0b      + TWO*sum(aa0(:,:)*b0Pb,dim=2)

         ! Clean
         b0Pb.destroy
         b0Pa.destroy

         a0Pa.create(n_pt,nb)
         a0Pb.create(n_pt,nb)

         Pa => .density_matrix.alpha(fa:la,fb:lb)
         Pb => .density_matrix.beta(fa:la,fb:lb)

         a0Pa = matmul(aa0,Pa)
         a0Pb = matmul(aa0,Pb)

         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*a0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*a0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*a0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*a0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*a0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*a0Pb,dim=2)

         ! Clean
         a0Pb.destroy
         a0Pa.destroy

         a0Pa.create(n_pt,na)
         a0Pb.create(n_pt,na)

         Pa => .density_matrix.alpha(fa:la,fa:la)
         Pb => .density_matrix.beta(fa:la,fa:la)

         a0Pa = matmul(aa0,Pa)
         a0Pb = matmul(aa0,Pb)

         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*a0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*a0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*a0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*a0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*a0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*a0Pb,dim=2)
         rho0a      = rho0a      + sum(aa0(:,:)  *a0Pa,dim=2)
         rho0b      = rho0b      + sum(aa0(:,:)  *a0Pb,dim=2)

         ! Clean
         a0Pb.destroy
         a0Pa.destroy

         b0Pa.create(n_pt,nb)
         b0Pb.create(n_pt,nb)

         Pa => .density_matrix.alpha(fb:lb,fb:lb)
         Pb => .density_matrix.beta(fb:lb,fb:lb)

         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)

         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + sum(bb0(:,:)  *b0Pa,dim=2)
         rho0b      = rho0b      + sum(bb0(:,:)  *b0Pb,dim=2)

         ! Clean
         b0Pb.destroy
         b0Pa.destroy

      end

      rho1a = TWO*rho1a
      rho1b = TWO*rho1b

   end

!  ==================================
!  Propert/plot densities (templates)
!  ==================================

   prop_grid ::: template
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
      grid :: VEC{REAL}*
      pt :: MAT{REAL}*

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the grid values
      .GRID(grid,pt)

      ! Print out
      .::dump_plot_grid(grid,LABEL)

      ! Clean up
      pt.destroy
      grid.destroy

   end

   def_grid(grid,pt) ::: template
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.natural_orbitals.created,"no natural orbitals")
   ENSURE(.occupation_numbers.created,"no natural orbitals")

      promolecule_grid :: VEC{REAL}*

      ! Make the normal grid values
      .GRID(grid,pt)

      ! Make the promolecule grid values
      promolecule_grid.create(grid.dim)
      .PRO(promolecule_grid,pt)

      ! Subtract to form deformation grid
      grid = grid - promolecule_grid

      ! Clean up
      promolecule_grid.destroy

   end

   pro_grid(density_grid,pt) ::: template
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")

      grid :: VEC{REAL}*
      a :: INT

      ! Create space for an atom's grid values
      grid.create(density_grid.dim)

      ! Sum up the atom grid values
      density_grid = ZERO
      parallel do a = 1,.n_atom
         .atom(a).GRID(grid,pt)
         density_grid = density_grid + grid
      end

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(density_grid)
      end

      ! Clean up
      grid.destroy

   end

   pro_dft_grid(density_grid,pt) ::: template
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      grid :: VEC{REAL}*
      a :: INT

      ! Create
      grid.create(density_grid.dim)

      ! Make the grid of values
      density_grid = ZERO
      do a = 1,.n_atom
        .atom(a).GRID(grid,pt,.scfdata.dft_exchange_functional,.scfdata.dft_correlation_functional)
        density_grid = density_grid + grid
      end

      ! Clean
      grid.destroy

   end

!  ==========================
!  Plot printing and deletion
!  ==========================

   dump_plot_grid(grid,name)
   ! Dump out the plot "grid" to an appropriate with with "name", in various
   ! formats. If present, "factor" is a conversion factor to apply.

      grid :: VEC{REAL}
      name :: STR

   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.atom.created, "no atoms")

      pos :: MAT{REAL}*
      valid :: VEC{INT}*
      bonds :: VEC{VEC_{INT}}*
      arch :: ARCHIVE
      title :: STR
      fac,z_range :: REAL

      if (.plot_grid.plot_units/=" ") then
         fac = .plot_grid.plot_units.conversion_factor
         grid = fac*grid
      end

      if (.plot_grid.use_plot_max) then
         where (grid>.plot_grid.plot_max) grid = .plot_grid.plot_max
      end

      if (.plot_grid.use_plot_min) then
         where (grid<.plot_grid.plot_min) grid = .plot_grid.plot_min
      end

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      ! Dump all formats if none specified
      if (.plot_grid.plot_format=="all") then   

         arch.set(title,name,format="contour")
         arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)
         arch.set(title,name,format="drishti.raw")
         arch.write_drishti(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
         arch.set(title,name,format="gnuplot")
         arch.write_gnuplot(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
         arch.set(title,name,format="gaussian.cube")
         arch.write_gaussian_cube(grid,.plot_grid,.atom,name)
         arch.set(title,name,format="mathematica")
         arch.write_mathematica(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
         arch.set(title,name,format="spackman")
         arch.write_contour_a_la_spackman(grid,.plot_grid,.atom)
         arch.set(title,name,format="vapor.raw")
         arch.write_vapor(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
         arch.set(title,name,format="vtk")
         arch.write_vtk(grid,.plot_grid,name)
         arch.set(title,name,format="xdgraph")
         arch.write_a_la_xdgraph(grid,.plot_grid,.atom)
         arch.set(title,name,format="xcrysden.xsf")
         arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)

         if (.plot_grid.n_z==1) then
            arch.set(title,name,format="mathematica")
            nullify(pos)
            nullify(valid)
            nullify(bonds)
            z_range = ONE
            .plot_grid.get_rotoranged_atom_positions(pos,z_range,valid)
            .atom(valid).make_connection_table(bonds)
            arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),pos,bonds)
            bonds.destroy
            pos.destroy
            valid.destroy
         end

      ! Dump specified format
      else

         select case (.plot_grid.plot_format)

            case ("contour")

               arch.set(title,name,format="contour")
               arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)

            case ("cube")

               arch.set(title,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

            case ("drishti")

               arch.set(title,name,format="drishti.raw")
               arch.write_drishti(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            case ("gaussian")

               arch.set(title,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

            case ("gaussian.cube")

               arch.set(title,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

            case ("gnuplot")

               arch.set(title,name,format="gnuplot")
               arch.write_gnuplot(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            case ("gnuplot.contour")

               ! Get rotated positions and data
               .atom.make_connection_table(bonds)
               .plot_grid.get_rotated_atom_positions(pos)

               stdout.text("pos^T:")
               stdout.put(transpose(pos))

               ! Make the gnuplot plot archive
               arch.set(title,name,format="gnuplot.contour")
               arch.write_gnuplot_contour(grid,.plot_grid,pos,bonds)

               ! Clean
               pos.destroy
               bonds.destroy

            case ("spackman")

               arch.set(title,name,format="spackman")
               arch.write_contour_a_la_spackman(grid,.plot_grid,.atom)

            case ("mathematica")

               arch.set(title,name,format="mathematica")
               arch.write_mathematica(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

               if (.plot_grid.n_z==1) then
                  arch.set(title,name,format="mathematica")
                  nullify(pos)
                  nullify(valid)
                  nullify(bonds)
                  z_range = ONE
                  .plot_grid.get_rotoranged_atom_positions(pos,z_range,valid)
                  .atom(valid).make_connection_table(bonds)
                  arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),pos,bonds)
                  bonds.destroy
                  pos.destroy
                  valid.destroy
               end

            case ("vapor")

               arch.set(title,name,format="vapor.raw")
               arch.write_vapor(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            case ("vtk")

               arch.set(title,name,format="vtk")
               arch.write_vtk(grid,.plot_grid,name)

            case ("xcrysden")

               arch.set(title,name,format="xcrysden.xsf")
               arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)
            
            case ("xdgraph")

               arch.set(title,name,format="xdgraph")
               arch.write_a_la_xdgraph(grid,.plot_grid,.atom)

            case default

               UNKNOWN(.plot_grid.plot_format)

         end

      end

   end

   delete_plot_grid(name)
   ! Delete the plot grid called "name".

      name :: STR

      title :: STR
      arch :: ARCHIVE

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      arch.set(title,name,format="gnuplot");        arch.delete_all_genres
      arch.set(title,name,format="mathematica");    arch.delete_all_genres
      arch.set(title,name,format="contour");        arch.delete_all_genres
      arch.set(title,name,format="gaussian.cube");  arch.delete_all_genres
      arch.set(title,name,format="xdgraph");        arch.delete_all_genres

   end

   delete_plot_grid
   ! Delete the plot grid whose name is specified on the input line

   DIE_IF(stdin.buffer.n_items/=2,"must specify grid to delete in input")
   DIE_IF(stdin.buffer.item_index==2,"must be on the last item")

      name :: STR
      title :: STR
      arch :: ARCHIVE

      stdin.read(name)

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      arch.set(title,name,format="gnuplot");        arch.delete_all_genres
      arch.set(title,name,format="mathematica");    arch.delete_all_genres
      arch.set(title,name,format="contour");        arch.delete_all_genres
      arch.set(title,name,format="gaussian.cube");  arch.delete_all_genres
      arch.set(title,name,format="xdgraph");        arch.delete_all_genres

   end

!  ======================
!  Electron density grids
!  ======================

   make_electron_density_grid ::: get_from(prop_grid, GRID=>::make_density_grid, LABEL=>"electron_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   electron_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_density_grid(g,pt)
   end


   make_deformation_density_grid ::: get_from(prop_grid, GRID=>::make_deformation_density_grid, LABEL=>"deformation_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_deformation_density_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_density_grid, PRO=>::make_promolecule_density_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   deformation_density_grid(g,pt) ::: selfless
   ! Work out the electron deformation density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_deformation_density_grid(g,pt)
   end

!  ==================
!  Spin density grids
!  ==================

   make_spin_density_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
      pt :: MAT{REAL}*
      grid :: VEC{REAL}*

      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)
      .::make_density_grid(grid,pt,sgn=-1)
      .::dump_plot_grid(grid,"spin_density_grid")

      pt.destroy
      grid.destroy

   end

   spin_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals" and ".occupation_numbers" vector.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_density_grid(g,pt,sgn=-1)
   end

!  ==================
!  Bond density grids
!  ==================

   make_def_bond_density_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.bond_density_atom.created, "no grid bond density atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .::make_def_bond_density_grid(grid,pt,.plot_grid.bond_density_atom)

      ! Make the plot label
      label = "deformation_bond_("
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str) // ","
      label = trim(label) // trim(.plot_grid.bond_density_atom(2).to_str) 
      if (.plot_grid.bond_density_atom.dim==3) &
      label = trim(label) // ":" // trim(.plot_grid.bond_density_atom(3).to_str) 
      label = trim(label) // ")_density_grid" 

      ! Print out
      .::dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_def_bond_density_grid(density_grid,pt,bond_density_atom)
   ! Make the bond deformation "density_grid" for the points "pt". 
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*

   ENSURE(.atom.created,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! Make the deformation density
      .::make_deformation_density_grid(density_grid,pt)

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z))
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = density_grid(n)*exp(-(x*x+y*y+z*z))/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

   make_def_bond_density_grid(density_grid,pt,bond_density_atom,def_density_grid)
   ! Make the bond deformation "density_grid" for the points "pt". 
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*
      def_density_grid :: VEC{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z,r_inv :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        r_inv = ONE/r_ab.norm
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z)*r_inv)
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           r_inv = ONE/r_ab.norm
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = def_density_grid(n)*exp(-(x*x+y*y+z*z)*r_inv)/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

!   make_def_bond_density_grid(density_grid,pt,bond_density_atom,def_density_grid)
!   ! Make the bond deformation "density_grid" for the points "pt". 
!   ! If there are two atoms in .plot_grid.bond_atom then the whole
!   ! bond density is made; if there are three then the third atom
!     self :: IN
!     density_grid :: VEC{REAL}, OUT
!     pt :: MAT{REAL}, IN
!     bond_density_atom :: VEC{INT}*
!     def_density_grid :: VEC{REAL}, IN
!
!   ENSURE(.atom.created,"no atoms")
!
!     n_atoms,n_pt,a,b,c,n :: INT
!     x,y,z :: REAL
!     r_ab :: VEC{REAL}(3)
!     rho_pr,rho_a,rho_b :: VEC{REAL}*
!
!     ! No of bond density atoms
!     n_atoms = bond_density_atom.dim
!
!     ! No of grid points
!     n_pt = density_grid.dim
!
!     ! Create space for pair density
!     rho_pr.create(n_pt)
!
!     ! Get the atom pair density for whole molecule
!     rho_pr = ZERO
!     do a = 2,.n_atom
!     do b = 1,a-1
!        if (NOT .atom.bonded(a,b)) cycle
!        r_ab = HALF*(.atom(a).position + .atom(b).position)
!        do n = 1,n_pt
!           x  = pt(n,1) - r_ab(1)
!           y  = pt(n,2) - r_ab(2)
!           z  = pt(n,3) - r_ab(3)
!           rho_pr(n) = rho_pr(n) + exp(-(x*x + y*y + z*z))
!        end
!     end
!     end
!
!     ! Indices of bonded pair
!     a = bond_density_atom(1)
!     b = bond_density_atom(2)
!
!     ! Make the deformation bond pair density
!     r_ab = HALF*(.atom(a).position + .atom(b).position)
!     do n = 1,n_pt
!        if (rho_pr(n)>epsilon(ONE)) then
!           x  = pt(n,1) - r_ab(1)
!           y  = pt(n,2) - r_ab(2)
!           z  = pt(n,3) - r_ab(3)
!           density_grid(n) = def_density_grid(n)*exp(-(x*x+y*y+z*z))/rho_pr(n)
!        else
!           density_grid(n) = ZERO
!        end
!     end
!
!     ! Make the atom contribution === if required
!     if (n_atoms==3) then
!
!        rho_a.create(n_pt)
!        rho_b.create(n_pt)
!
!        .atom(a).make_density_grid(rho_a,pt)
!        .atom(b).make_density_grid(rho_b,pt)
!
!        rho_pr = rho_a + rho_b
!
!        c = bond_density_atom(3)
!        if (c==a) then
!           where (rho_pr>epsilon(ONE)); density_grid = (rho_a/rho_pr)*density_grid
!           elsewhere;                   density_grid = ZERO
!           end
!        else if (c==b) then
!           where (rho_pr>epsilon(ONE)); density_grid = (rho_b/rho_pr)*density_grid
!           elsewhere;                   density_grid = ZERO
!           end
!        else
!           DIE("atom is not one of those in the bond")
!        end
!        
!        rho_b.destroy
!        rho_a.destroy
!
!     end
!
!     ! Clean up
!     rho_pr.destroy
!
!   end

   deformation_bond_density_grid(g,pt) ::: selfless
   ! Work out the deformation bond density grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_bond_density_grid(g,pt,.isosurface.plot_grid.bond_density_atom)
   end


   make_bond_weight_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.bond_density_atom.created, "no grid bond density atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .::make_bond_weight_grid(grid,pt,.plot_grid.bond_density_atom)

      ! Make the plot label
      label = "bond_("
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str) // ","
      label = trim(label) // trim(.plot_grid.bond_density_atom(2).to_str) 
      if (.plot_grid.bond_density_atom.dim==3) &
      label = trim(label) // ":" // trim(.plot_grid.bond_density_atom(3).to_str) 
      label = trim(label) // ")_weight_grid" 

      ! Print out
      .::dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_bond_weight_grid(density_grid,pt,bond_density_atom)
   ! Make the bond deformation "density_grid" for the points "pt". 
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*

   ENSURE(.atom.created,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z))
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = exp(-(x*x+y*y+z*z))/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

   bond_weight_grid(g,pt) ::: selfless
   ! Work out the bond weight grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_bond_weight_grid(g,pt,.isosurface.plot_grid.bond_density_atom)
   end


   make_bond_density_atom_grid
   ! Work out the bond density atom on ".plot_grid"
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.bond_density_atom.created, "no grid bond density atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .::make_bond_density_atom_grid(grid,pt,.plot_grid.bond_density_atom(1))

      ! Make the plot label
      label = "bond_density_atom_"
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str)
      label = trim(label) // "_grid" 

      ! Print out
      .::dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_bond_density_atom_grid(density_grid,pt,a)
   ! Make the bond density atom grid "density_grid" for the points
   ! "pt" for atom with index "a". 
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      a :: INT

   ENSURE(.atom.created,"no atoms")

      n_pt,i :: INT
      rho_bond,def_density_grid :: VEC{REAL}*
      bond_density_atom :: VEC{INT}*

      ! No of grid points
      n_pt = density_grid.dim

      ! Do only the spherical part if a<0
      if (a<0) then 

        .atom(-a).make_density_grid(density_grid,pt)

      ! Do the whole BDA 
      else

        ! Allocate
        def_density_grid.create(n_pt)
        rho_bond.create(n_pt)

        ! Space for bond density atoms
        bond_density_atom.create(3)
        bond_density_atom(1) = a
        bond_density_atom(3) = a

        ! Make the deformation density
        .::make_deformation_density_grid(def_density_grid,pt)

        ! Add spherical part
        .atom(a).make_density_grid(density_grid,pt)

        ! Get bond density contributions
        do i = 1,.n_atom
           if (i==a) cycle
           if (NOT .atom.bonded(i,a)) cycle
           bond_density_atom(2) = i
           .::make_def_bond_density_grid(rho_bond,pt,bond_density_atom,def_density_grid)
           density_grid = density_grid + rho_bond
        end

        ! Clean up
        bond_density_atom.destroy
        rho_bond.destroy
        def_density_grid.destroy

      end

   end

   bond_density_atom_grid(g,pt) ::: selfless
   ! Work out the bond density atom grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_bond_density_atom_grid(g,pt,.isosurface.plot_grid.bond_density_atom(1))
   end

!  ============================
!  Local ionisation energy grid
!  ============================

   make_local_ionisation_grid ::: get_from(prop_grid, GRID=>::make_local_ionisation_grid, LABEL=>"local_ionisation_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_local_ionisation_grid(grid,pt)
   ! Work out Politzer's local ionisation energy "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")

      if (trim(.molecular_orbitals.number_kind)=="real") then
        .::make_local_ionisation_grid_r(grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_local_ionisation_grid_r(grid,pt)
   ! Work out Politzer's local ionisation energy "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.molecular_orbitals.created("restricted"), "no restricted MO's")
   ENSURE(.orbital_energies.created("restricted"), "no restricted orbital energies")

      rho,MO :: VEC{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      MO.create(n_pt)

      rho  = ZERO
      grid = ZERO

      parallel do n = 1,n_occ
        .::make_orbital_grid_r(MO,.molecular_orbitals.restricted(:,n),pt,square=TRUE)
        rho  = rho  + MO
        grid = grid - MO*.orbital_energies.restricted(n)
      end

      PARALLEL_SUM(rho)
      PARALLEL_SUM(grid)

      grid = grid/rho

      MO.destroy
      rho.destroy

   end

   local_ionisation_grid(g,pt) ::: selfless
   ! Work out the local ionisation grid "g" for a series of points "pt"
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_local_ionisation_grid(g,pt)
   end

!  =======================
!  Local virial ratio grid
!  =======================

   make_local_virial_ratio_grid ::: get_from(prop_grid, GRID=>::make_local_virial_ratio_grid, LABEL=>"local_virial_ratio_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_local_virial_ratio_grid(grid,pt)
   ! Work out local virial ratio "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")

      if (trim(.molecular_orbitals.number_kind)=="real") then
        .::make_local_virial_ratio_grid_r(grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_local_virial_ratio_grid_r(grid,pt)
   ! Work out local virial ratio  "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")

      L, G :: VEC{REAL}*
      n_pt :: INT

      n_pt = pt.dim1

      L.create(n_pt)
      G.create(n_pt)

      .::make_laplacian_grid_r(L,pt)
      .::make_G_kinetic_density_grid_r(G,pt)

      grid = TWO - QUARTER*L/G  

      G.destroy
      L.destroy

   end

! ==========================
! Laplacian density routines
! ==========================

   make_laplacian_grid ::: get_from(prop_grid, GRID=>::make_laplacian_grid, LABEL=>"laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)=="real") then
         .::make_laplacian_grid_r(laplacian_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_laplacian_grid_r(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO

      parallel do n = 1,n_occ

         .::make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         laplacian_grid = laplacian_grid &
            + occ * (NO*(D(:,1)+D(:,2)+D(:,3)) &
                  + P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3))

      end
      PARALLEL_SUM(laplacian_grid)

      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   laplacian_grid(g,pt) ::: selfless
   ! Work out the laplacian density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_laplacian_grid(g,pt)
   end


   make_def_laplacian_grid ::: get_from(prop_grid, GRID=>::make_def_laplacian_grid, LABEL=>"deformation_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_laplacian_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_laplacian_grid, PRO=>::make_pro_laplacian_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_laplacian_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_laplacian_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

   def_laplacian_grid(g,pt) ::: selfless
   ! Work out the deformation laplacian density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_laplacian_grid(g,pt)
   end


   make_neg_laplacian_grid ::: get_from(prop_grid, GRID=>::make_neg_laplacian_grid, LABEL=>"negative_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_neg_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)=="real") then
        .::make_laplacian_grid_r(laplacian_grid,pt)
        laplacian_grid = -laplacian_grid
      else
        DIE("code not written yet")
      end

   end


   make_rL_grid ::: get_from(prop_grid, GRID=>::make_rL_grid, LABEL=>"reduced_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rL_grid(laplacian_grid,pt)
   ! Work out the reduced "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
        .::make_rL_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_rL_grid_r(laplacian_grid,pt)
   ! Make the reduced "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt  = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO
      rho = ZERO

      do n = 1,n_occ

         .::make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         laplacian_grid = laplacian_grid +  occ * ( &
            NO * (D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3)))
         rho = rho + occ*NO*NO

      end

      laplacian_grid = TWO*laplacian_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

!  ===============================
!  K-type kinetic density routines
!  ===============================

   make_K_kinetic_energy_grid ::: get_from(prop_grid, GRID=>::make_K_kinetic_energy_grid, LABEL=>"K_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_K_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type kinetic energy density (using the nabla^2) on "pt" using
   ! ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .::make_K_kinetic_density_grid_r(K_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_K_kinetic_density_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      K_grid = ZERO

      do n = 1,n_occ

         .::make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         K_grid = K_grid  + .occupation_numbers.restricted(n) * NO * (D(:,1)+D(:,2)+D(:,3)) 

      end

      K_grid = -HALF*K_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   K_kinetic_energy_grid(g,pt) ::: selfless
   ! Work out the K-type kinetic energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_K_kinetic_energy_grid(g,pt)
   end


   make_def_K_kinetic_grid ::: get_from(prop_grid, GRID=>::make_def_K_kinetic_grid, LABEL=>"deformation_K_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_K_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_K_kinetic_energy_grid, PRO=>::make_pro_K_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_K_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_K_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

   def_K_kinetic_grid(g,pt) ::: selfless
   ! Work out the deformation K-type kinetic density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_K_kinetic_grid(g,pt)
   end


   make_rK_kinetic_energy_grid ::: get_from(prop_grid, GRID=>::make_rK_kinetic_energy_grid, LABEL=>"reduced_K_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rK_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type reduced kinetic energy density (using the nabla^2) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .::make_rK_kinetic_density_grid_r(K_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_rK_kinetic_density_grid_r(K_grid,pt)
   ! Make the K-type reduced kinetic energy density "K_grid" for the supplied
   ! points "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO,rho :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      K_grid = ZERO
      rho = ZERO

      do n = 1,n_occ

         .::make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         K_grid = K_grid + occ*NO*(D(:,1)+D(:,2)+D(:,3)) 
         rho    = rho    + occ*NO*NO

      end

      K_grid = -HALF*K_grid/rho

      D.destroy
      P.destroy
      NO.destroy
      rho.destroy

   end

   make_def_rK_kinetic_grid ::: get_from(prop_grid, GRID=>::make_def_rK_kinetic_grid, LABEL=>"deformation_reduced_K_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rK_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_rK_kinetic_energy_grid, PRO=>::make_pro_rK_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_rK_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_rK_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

!  ===============================
!  G-type kinetic density routines
!  ===============================

   make_G_kinetic_energy_grid ::: get_from(prop_grid, GRID=>::make_G_kinetic_energy_grid, LABEL=>"G_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_G_kinetic_energy_grid(G_grid,pt)
   ! Work out the G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .::make_G_kinetic_density_grid_r(G_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_G_kinetic_density_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)

      G_grid = ZERO

      do n = 1,n_occ
         .::make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
         G_grid(:) = G_grid(:) &
                   + .occupation_numbers.restricted(n) &
                   * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
      end

      G_grid(:) = HALF*G_grid(:)

      P.destroy
      NO.destroy

   end

   G_kinetic_energy_grid(g,pt) ::: selfless
   ! Work out the G-type kinetic energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_G_kinetic_energy_grid(g,pt)
   end


   make_G_Kirzhnits_grid ::: get_from(prop_grid, GRID=>::make_G_Kirzhnits_grid, LABEL=>"G_Kirzhnits_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_G_Kirzhnits_grid(G_grid,pt)
   ! Work out the G-type Kirzhnits kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .::make_G_Kirzhnits_grid_r(G_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_G_Kirzhnits_grid_r(G_grid,pt)
   ! Make the G-type Kirzhnits kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO,rho,nab_ro2,lap_rho :: VEC{REAL}*
      G,L,nab_rho :: MAT{REAL}*
      lambda,k2,fac,occ,occ2 :: REAL
      n_occ,n,n_pt :: INT

      n_pt =  pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      lap_rho.create(n_pt)
      nab_ro2.create(n_pt)
      nab_rho.create(n_pt,3)
      NO.create(n_pt)
      G.create(n_pt,3)
      L.create(n_pt,3)

      rho     = ZERO
      lap_rho = ZERO 
      nab_rho = ZERO 

      do n = 1,n_occ

         .::make_laplacian_orbital_grid_r(L,G,NO,.natural_orbitals.restricted(:,n), pt)

         occ  = .occupation_numbers.restricted(n)
         occ2 = TWO*occ

         rho          = rho          + occ *NO*NO
         nab_rho(:,1) = nab_rho(:,1) + occ2*NO*G(:,1)
         nab_rho(:,2) = nab_rho(:,2) + occ2*NO*G(:,2)
         nab_rho(:,3) = nab_rho(:,3) + occ2*NO*G(:,3)
         lap_rho      = lap_rho      + occ2*(NO*(L(:,1)+L(:,2)+L(:,3))) &
                                     + occ2*(G(:,1)*G(:,1) + G(:,2)*G(:,2) + G(:,3)*G(:,3))
      end

      L.destroy
      G.destroy
      NO.destroy

      nab_ro2 = nab_rho(:,1)*nab_rho(:,1) + nab_rho(:,2)*nab_rho(:,2) + nab_rho(:,3)*nab_rho(:,3)
      nab_rho.destroy

      lambda = ONE/72.0d0
      k2 = HALF/SIX
      fac = 0.3d0*(THREE*PI*PI)**(TWOTHIRDS)
      G_grid = fac*rho**(FIVE/THREE) + lambda*nab_ro2/rho + k2*lap_rho

      nab_ro2.destroy
      lap_rho.destroy
      rho.destroy

   end


   make_def_G_kinetic_grid ::: get_from(prop_grid, GRID=>::make_def_G_kinetic_grid, LABEL=>"deformation_G_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_G_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_G_kinetic_energy_grid, PRO=>::make_pro_G_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_G_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_G_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

   def_G_kinetic_grid(g,pt) ::: selfless
   ! Work out the deformation G-type kinetic density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_G_kinetic_grid(g,pt)
   end


   make_def_G_Kirzhnits_grid ::: get_from(prop_grid, GRID=>::make_def_G_Kirzhnits_grid, LABEL=>"deformation_G_Kirzhnits_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_G_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_G_Kirzhnits_grid, PRO=>::make_pro_G_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_G_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_G_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rG_kinetic_energy_grid ::: get_from(prop_grid, GRID=>::make_rG_kinetic_energy_grid, LABEL=>"reduced_G_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rG_kinetic_energy_grid(G_grid,pt)
   ! Work out the reduced G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .::make_rG_kinetic_density_grid_r(G_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_rG_kinetic_density_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      rho,NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      rho.create(n_pt)
      NO.create(n_pt)
      P.create(n_pt,3)

      G_grid = ZERO
      rho = ZERO

      do n = 1,n_occ

         .::make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
         rho    = rho    + occ*NO*NO

      end

      G_grid = HALF*G_grid/rho

      P.destroy
      NO.destroy
      rho.destroy

   end

   make_def_rG_kinetic_grid ::: get_from(prop_grid, GRID=>::make_def_rG_kinetic_grid, LABEL=>"deformation_reduced_G_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rG_kinetic_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_rG_kinetic_energy_grid, PRO=>::make_pro_rG_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_rG_kinetic_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_rG_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

!  ===============================
!  G and K-type kinetic densities
!  ===============================

   make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
   ! Work out the G and K-type kinetic energy density on "pt" using
   ! ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid,K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (.natural_orbitals.number_kind=="real") then
         .::make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt)
      else
         DIE("code not written yet")
      end

   end

   make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt)
   ! Make the G and K-type kinetic energy grids for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid,K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_occ = .BASE:no_of_occupied_NOs
      n_pt = pt.dim1

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      G_grid = ZERO
      K_grid = ZERO

      do n = 1,n_occ

         .::make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
         K_grid = K_grid + occ * NO * (D(:,1)+D(:,2)+D(:,3)) 

      end

      G_grid =  HALF*G_grid
      K_grid = -HALF*K_grid

      D.destroy
      P.destroy
      NO.destroy

   end

!  =============================
!  Energy density from rho grids
!  =============================

   make_E_hf_dens_from_rho_grid ::: get_from(prop_grid, GRID=>::make_E_hf_dens_from_rho_grid, LABEL=>"E_hf_density_from_rho_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_E_hf_dens_from_rho_grid(E_grid,pt)
   ! Work out the energy density as the scaled electron density.
      E_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.created,"no scfdata") 
   ENSURE(.scfdata.scf_kind.is_one_of(["rhf","uhf"]),"scf kind is not Hartree-Fock") 

      fac :: REAL

      .::make_density_grid(E_grid,pt)
      fac = .scfdata.energy/.n_e
      E_grid = fac*E_grid

   end

   make_def_E_hf_from_rho_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_E_hf_dens_from_rho_grid, PRO=>::make_E_hf_dens_from_rho_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

!  ========================================================
!  H-type total energy density obtained from virial theorem
!  ========================================================

   make_H_from_virial_grid ::: get_from(prop_grid, GRID=>::make_H_from_virial_grid, LABEL=>"H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_from_virial_grid(H_grid,pt)
   ! Work out the energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .::make_G_kinetic_energy_grid(G_grid,pt)
      .::make_laplacian_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_H_from_virial_grid ::: get_from(prop_grid, GRID=>::make_def_H_from_virial_grid, LABEL=>"deformation_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_H_from_virial_grid, PRO=>::make_pro_H_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_H_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_H_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_H_Kirzhnits_grid ::: get_from(prop_grid, GRID=>::make_H_Kirzhnits_grid, LABEL=>"H_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_Kirzhnits_grid(H_grid,pt)
   ! Work out the energy density using the Kirzhnits relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .::make_G_Kirzhnits_grid(G_grid,pt)
      .::make_laplacian_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_H_Kirzhnits_grid ::: get_from(prop_grid, GRID=>::make_def_H_Kirzhnits_grid, LABEL=>"deformation_H_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_H_Kirzhnits_grid, PRO=>::make_pro_H_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_H_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_H_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rH_from_virial_grid ::: get_from(prop_grid, GRID=>::make_rH_from_virial_grid, LABEL=>"reduced_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rH_from_virial_grid(H_grid,pt)
   ! Work out the reduced energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .::make_rG_kinetic_energy_grid(G_grid,pt)
      .::make_rL_grid(H_grid,pt)

      H_grid = QUARTER*H_grid - G_grid

      G_grid.destroy

   end

   make_def_rH_from_virial_grid ::: get_from(prop_grid, GRID=>::make_def_rH_from_virial_grid, LABEL=>"deformation_reduced_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rH_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_rH_from_virial_grid, PRO=>::make_pro_rH_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_rH_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_rH_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

!  =====================================================
!  Potential energy density obtained from virial theorem
!  =====================================================

   make_V_from_virial_grid ::: get_from(prop_grid, GRID=>::make_V_from_virial_grid, LABEL=>"V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_V_from_virial_grid(V,pt)
   ! Work out the energy density from usiang the virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*

      G.create(.plot_grid.n_pt)

      .::make_G_kinetic_energy_grid(G,pt)
      .::make_laplacian_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_V_from_virial_grid ::: get_from(prop_grid, GRID=>::make_def_V_from_virial_grid, LABEL=>"deformation_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_V_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_V_from_virial_grid, PRO=>::make_pro_V_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_V_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_V_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_V_Kirzhnits_grid ::: get_from(prop_grid, GRID=>::make_V_Kirzhnits_grid, LABEL=>"V_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_V_Kirzhnits_grid(V,pt)
   ! Work out the energy density from usiang the Kirzhnits theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}

      G :: VEC{REAL}*
      G.create(.plot_grid.n_pt)

      .::make_G_Kirzhnits_grid(G,pt)
      .::make_laplacian_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_V_Kirzhnits_grid ::: get_from(prop_grid, GRID=>::make_def_V_Kirzhnits_grid, LABEL=>"deformation_V_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_V_Kirzhnits_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_V_Kirzhnits_grid, PRO=>::make_pro_V_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_V_Kirzhnits_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_V_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rV_from_virial_grid ::: get_from(prop_grid, GRID=>::make_rV_from_virial_grid, LABEL=>"reduced_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rV_from_virial_grid(V,pt)
   ! Work out the energy density from usiang the virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*

      G.create(.plot_grid.n_pt)

      .::make_rG_kinetic_energy_grid(G,pt)
      .::make_rL_grid(V,pt)

      V = QUARTER*V - TWO*G

      G.destroy

   end

   make_def_rV_from_virial_grid ::: get_from(prop_grid, GRID=>::make_def_rV_from_virial_grid, LABEL=>"deformation_reduced_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rV_from_virial_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_rV_from_virial_grid, PRO=>::make_pro_rV_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_rV_from_virial_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_rV_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

!  ==================
!  Electric potential
!  ==================

   make_electric_potential_grid ::: get_from(prop_grid, GRID=>::make_electric_potential_grid, LABEL=>"electric_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_electric_potential_grid(pot_grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      .BASE:make_ao_density_matrix

      if (trim(.density_matrix.number_kind)=="real") then
         .::make_electric_potential_grid_r(pot_grid,pt,.density_matrix.restricted)
      else
         .::make_electric_potential_grid_c(pot_grid,pt,.density_matrix.restricted_complex)
      end

   end

   make_electric_potential_grid_r(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}

      elec_grid :: VEC{REAL}*

      elec_grid.create(size(pot_grid))

      .::nuclear_potential(pot_grid,pt)
      .::make_electronic_pot_grid_r(elec_grid,pt,dens)

      pot_grid = pot_grid + elec_grid

      elec_grid.destroy

   end

   make_electric_potential_grid_c(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{CPX}

      elec_grid :: VEC{REAL}*

      elec_grid.create(size(pot_grid))

      .::nuclear_potential(pot_grid,pt)
      .::make_electronic_pot_grid_c(elec_grid,pt,dens)

      pot_grid = pot_grid + elec_grid

      elec_grid.destroy

   end

   electric_potential_grid(g,pt) ::: selfless
   ! Make the electric potential grid "g" on a series of points "pt"
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_electric_potential_grid(g,pt)
   end


   make_electronic_pot_grid(pot_grid,pt)
   ! Make the electronic potential "pot_grid" on a series of points "pt"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      .BASE:make_ao_density_matrix

      if (trim(.density_matrix.number_kind)=="real") then
         .::make_electronic_pot_grid_r(pot_grid,pt,.density_matrix.restricted)
      else
         .::make_electronic_pot_grid_c(pot_grid,pt,.density_matrix.restricted_complex)
      end

   end

   make_electronic_pot_grid_r(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}, target

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Vab,Dba :: MAT{REAL}*
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      pot_grid = ZERO

      parallel do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Dba => dens(fa:la,fb:lb)
         Vab.create(na,nb)
         if (fa/=fb) then
           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*Dba)
           end
         else
           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             pot_grid(k) = pot_grid(k) - sum(Vab*Dba)
           end
         end
         Vab.destroy

         if (DO_IN_PARALLEL) then
            PARALLEL_SUM(pot_grid)
         end

         sh.destroy_ptr_part

      end

   end

   make_electronic_pot_grid_c(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Vab :: MAT{REAL}*
      Dba :: MAT{CPX}*
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      pot_grid = ZERO

      do q = 1,.n_shell_pairs

         .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Dba => dens(fa:la,fb:lb)
         Vab.create(na,nb)
         if (fa/=fb) then
           do k = 1,n_pt
             sh.make_nuclear_attraction_ints(Vab,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*RE(Dba))
           end
         else
           do k = 1,n_pt
             sh.make_nuclear_attraction_ints(Vab,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*RE(Dba))
           end
         end
         Vab.destroy

         sh.destroy_ptr_part

      end

   end


   make_def_e_pot_grid ::: get_from(prop_grid, GRID=>::make_def_e_pot_grid, LABEL=>"deformation_electric_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_e_pot_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_electric_potential_grid, PRO=>::make_pro_e_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_e_pot_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_electric_potential_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

   def_e_pot_grid(g,pt) ::: selfless
   ! Work out the deformation electric potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_e_pot_grid(g,pt)
   end

!  ================
!  DFT xc potential
!  ================

   make_dft_xc_pot_grid ::: get_from(prop_grid, GRID=>::make_dft_xc_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_xc_pot_grid(V,pt)
   ! Work out the DFT potential on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      V :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*

      rho.create(V.dim)

      .::make_density_grid(rho,pt)

      V = ZERO
      dft.set_defaults
      dft.new_r_potential(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_potential(.scfdata.dft_correlation_functional,V,rho)

      rho.destroy

   end

   dft_xc_pot_grid(g,pt) ::: selfless
   ! Work out the DFT exchange corelation density grid "g" for a the
   ! points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_dft_xc_pot_grid(g,pt)
   end


   make_def_dft_xc_pot_grid ::: get_from(prop_grid, GRID=>::make_def_dft_xc_pot_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_xc_pot_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_dft_xc_pot_grid, PRO=>::make_pro_dft_xc_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_dft_xc_pot_grid(density_grid,pt) ::: get_from(pro_dft_grid, GRID=>make_dft_xc_pot_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

   def_dft_xc_pot_grid(g,pt) ::: selfless
   ! Work out the deformation DFT exchange corelation density grid "g" for a the
   ! points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_dft_xc_pot_grid(g,pt)
   end

!  =======================
!  DFT effective potential
!  =======================

! The effective potential includes the classical electrostatic potential

   make_dft_eff_pot_grid ::: get_from(prop_grid, GRID=>::make_dft_eff_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_eff_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_eff_pot_grid(V,pt)
   ! Work out the Slater DFT potential "V" (i.e. the Slater potential plus the
   ! classical electric potential) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
   ENSURE(NOT .scfdata.using_GGA_functional,"so far, must not be a GGA functional")

      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*

      rho.create(V.dim)

      .::make_electric_potential_grid(V,pt)
      .::make_density_grid(rho,pt)

      dft.set_defaults
      dft.new_r_potential(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_potential(.scfdata.dft_correlation_functional,V,rho)

      rho.destroy

   end

   dft_eff_pot_grid(g,pt) ::: selfless
   ! Work out the DFT effective potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_dft_eff_pot_grid(g,pt)
   end


   make_def_dft_eff_pot_grid ::: get_from(prop_grid, GRID=>::make_def_dft_eff_pot_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_eff_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_eff_pot_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_dft_eff_pot_grid, PRO=>::make_pro_dft_eff_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_dft_eff_pot_grid(density_grid,pt) ::: get_from(pro_dft_grid, GRID=>make_dft_eff_pot_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

   def_dft_eff_pot_grid(g,pt) ::: selfless
   ! Work out the deformation DFT effective potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_dft_eff_pot_grid(g,pt)
   end

!  ==================
!  DFT energy density
!  ==================

! The energy density includes the classical electrostatic potential, but no
! kinetic energy density terms

   make_dft_energy_grid ::: get_from(prop_grid, GRID=>::make_dft_energy_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_energy_grid(V,pt)
   ! Work out the Slater DFT energy "V" (i.e. the Slater potential times the
   ! density plus the classical electric energy) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      dft :: DFT_FUNCTIONAL
      Ve,rho :: VEC{REAL}*

      Ve.create(V.dim)
      rho.create(V.dim)

      .::nuclear_potential(V,pt)
      .::make_electronic_pot_grid(Ve,pt)
      V = -V - HALF*Ve
      .::make_density_grid(rho,pt)

      dft.set_defaults
      dft.new_r_energy_density(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_energy_density(.scfdata.dft_correlation_functional,V,rho)
      V = V*rho

      Ve.destroy
      rho.destroy

   end

   dft_energy_grid(g,pt) ::: selfless
   ! Work out the DFT energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_dft_energy_grid(g,pt)
   end


   make_def_dft_energy_grid ::: get_from(prop_grid, GRID=>::make_def_dft_energy_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_energy_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_dft_energy_grid, PRO=>::make_pro_dft_energy_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_dft_energy_grid(density_grid,pt) ::: get_from(pro_dft_grid, GRID=>make_dft_energy_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

   def_dft_energy_grid(g,pt) ::: selfless
   ! Work out the deformation DFT energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_dft_energy_grid(g,pt)
   end

!  =========================
!  H-type DFT energy density
!  =========================

! H = G + V(DFT)

   make_H_dft_energy_grid ::: get_from(prop_grid, GRID=>::make_H_dft_energy_grid, LABEL=>"H_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_dft_energy_grid(H_grid,pt)
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"must be a DFT calculation")

      G_grid :: VEC{REAL}*

      G_grid.create(.plot_grid.n_pt)

      .::make_G_kinetic_energy_grid(G_grid,pt)
      .::make_dft_energy_grid(H_grid,pt)

      H_grid = H_grid + G_grid

      G_grid.destroy

   end

   H_dft_energy_grid(g,pt) ::: selfless
   ! Work out the H-type DFT energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_H_dft_energy_grid(g,pt)
   end


   make_def_H_dft_energy_grid ::: get_from(prop_grid, GRID=>::make_def_H_dft_energy_grid, LABEL=>"deformation_H_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_dft_energy_grid(grid,pt) ::: get_from(def_grid, GRID=>::make_H_dft_energy_grid, PRO=>::make_pro_H_dft_energy_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_H_dft_energy_grid(density_grid,pt) ::: get_from(pro_dft_grid, GRID=>make_H_dft_energy_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

   def_H_dft_energy_grid(g,pt) ::: selfless
   ! Work out the deformation slater H energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_def_H_dft_energy_grid(g,pt)
   end

!  =======================
!  Hirshfeld (slater) grid
!  =======================

   make_Hirshfeld_density_grid ::: get_from(prop_grid, GRID=>::make_Hirshfeld_density_grid, LABEL=>"stockholder_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_Hirshfeld_density_grid(density_grid,pt)
   ! WARNING: this version calls directly the interpolated slaterbasis routine.
   ! Make the Hirshfeld stockholder "density_grid" for the supplied
   ! points "pt". The promolecule electron density used to define the
   ! Hirshfeld surface is calculated using a tabulated slater basis
   ! set. 
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

!  ENSURE(.saved.created, "no saved molecule")
!  ENSURE(.saved.cluster.created, "no saved cluster data")
!  ENSURE(.saved.cluster.info_made, "no saved cluster info")
!  ENSURE(.saved.cluster.radius>ZERO, "saved cluster radius is zero")
!  ENSURE(.saved.cluster.n_atoms==.atom.dim,"inconsistent saved cluster and atom list")
!  ENSURE(.atom.created,"no atoms")
!  ENSURE(.atom.has_all_density_data,"no atomic orbitals")

      rho_fragment :: VEC{REAL}*
      is_fragment_atom :: VEC{BIN}*
      n_atoms,n_pt,a :: INT

      n_pt = density_grid.dim
      rho_fragment.create(n_pt)
      rho_fragment = ZERO

      n_atoms = .atom.dim
      is_fragment_atom => .saved.cluster.is_fragment_atom

      if (NOT .atom.has_disorder) then

         do a = 1,n_atoms
            if (NOT is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_density_grid(rho_fragment,pt,.atom(a).position)
         end
         density_grid = rho_fragment

         do a = 1,n_atoms
            if (is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_density_grid(density_grid,pt,.atom(a).position)
         end

      else

         do a = 1,n_atoms
            if (NOT is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_density_grid(rho_fragment,pt,.atom(a).position,.atom(a).site_occupancy)
         end
         density_grid = rho_fragment
 
         do a = 1,n_atoms
            if (is_fragment_atom(a)) cycle
            .atom(a).slaterbasis.add_density_grid(density_grid,pt,.atom(a).position,.atom(a).site_occupancy)
         end

      end

      where (density_grid>ZERO)
         density_grid = rho_fragment/density_grid
      elsewhere
         density_grid = ZERO
      end

      rho_fragment.destroy

   end

   Hirshfeld_density_grid(g,pt) ::: selfless
   ! Work out the Hirshfeld density grid "g" for a series of points.
   ! WARNING: this version cuts corners.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_Hirshfeld_density_grid(g,pt)
   end

!  ===========
!  Stockholder
!  ===========

   make_stockholder_density_grid ::: get_from(prop_grid, GRID=>::make_stockholder_density_grid, LABEL=>"stockholder_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_stockholder_density_grid(density_grid,pt)
   ! Make the Hirschfeld stockholder "density_grid" for the supplied points
   ! "pt". The promolecule electron density used to define the Hirshfeld surface
   ! is calculated as follows: if a slater basis set is available, then that is
   ! used to calculate the promolecule electron density; if a coppens basis set
   ! is available, then that is used to get the promolecule density; otherwise,
   ! if restricted real natural orbitals are available for all atoms (in terms
   ! of gaussian basis functions), then those are used to calculate the
   ! promolecule densisties. In principle, we can caculate Hirshfeld surfaces
   ! for *molecular* fragment densities, rather than promolecule densities as
   ! done here. That would require a different keyword and different code.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.saved.created, "no saved molecule")
   ENSURE(.saved.cluster.created, "no saved cluster data")
   ENSURE(.saved.cluster.info_made, "no saved cluster info")
   ENSURE(.saved.cluster.radius>ZERO, "saved cluster radius is zero")
   ENSURE(.saved.cluster.n_atoms==.atom.dim,"inconsistent saved cluster and atom list")
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")

      rho_fragment :: VEC{REAL}*
      is_fragment_atom :: VEC{BIN}*
      n_atoms,n_pt,a :: INT

      ! No. of fragment atoms
      n_atoms = .atom.dim

      ! Locate fragment atoms in cluster
      is_fragment_atom => .saved.cluster.is_fragment_atom

      ! Fragment density grid
      n_pt = density_grid.dim
      rho_fragment.create(n_pt)
      rho_fragment = ZERO

      ! Make fragment density
      do a = 1,n_atoms
         if (NOT is_fragment_atom(a)) cycle
         .atom(a).add_density_grid(rho_fragment,pt)
      end

      density_grid = rho_fragment
      do a = 1,n_atoms
         if (is_fragment_atom(a)) cycle
         .atom(a).add_density_grid(density_grid,pt)
      end

      ! density_grid = rho_fragment/density_grid
      do a = 1,size(density_grid)
         if (density_grid(a)>epsilon(ONE)) then
            density_grid(a) = rho_fragment(a)/density_grid(a)
         else
            density_grid(a) = ZERO
         end
      end

      ! Clean up
      rho_fragment.destroy

   end

!   make_stockholder_weight_d_grid(w0,w1,w2,pt)
!   ! Make the Hirschfeld stockholder derivative density grid "d1_grid"
!   ! for the supplied points "pt". The promolecule electron density
!   ! used to define the Hirshfeld surface is calculated as follows: if
!   ! a slater basis set is available, then that is used to calculate
!   ! the promolecule electron density; if a coppens basis set is
!   ! available, then that is used to get the promolecule density;
!   ! otherwise, if restricted real natural orbitals are available for
!   ! all atoms (in terms of gaussian basis functions), then those are
!   ! used to calculate the promolecule densisties. In principle, we
!   ! can caculate Hirshfeld surfaces for *molecular* fragment
!   ! densities, rather than promolecule densities as done here. That
!   ! would require a different keyword and different code.
!     self :: IN
!     w0 :: VEC{REAL}, OUT
!     w1 :: MAT{REAL}, OUT
!     w2 :: MAT3{REAL}, OUT
!     pt :: MAT{REAL}, IN
!   ENSURE(w1.dim1==3, "wrong size w1")
!   ENSURE(w2.dim1==3, "wrong size w2")
!   ENSURE(w2.dim2==3, "wrong size w2")
!   ENSURE(w0.dim1==w1.dim2, "incompatible w0 and w1")
!   ENSURE(w0.dim1==w2.dim3, "incompatible w0 and w2")
!   ENSURE(.cluster.created, "no cluster data")
!   ENSURE(.cluster.info_made, "no cluster info")
!   ENSURE(.cluster.radius>ZERO, "cluster radius is zero")
!   ENSURE(.atom.created,"no atoms")
!   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
!     d0,rho0f,rho0a :: VEC{REAL}*
!     d1,rho1f,rho1a :: MAT{REAL}*
!     d2,rho2f,rho2a :: MAT3{REAL}*
!     f1,a1 :: VEC{REAL}(3)
!     f0,bot,bot2,bot3,fac :: REAL
!     n_pt,a,b,i :: INT
!   ! w  = (sum_IN rho_IN) /(sum_ALL rho_ALL)
!   ! w' = (sum_IN rho'_IN)/(sum_ALL rho_ALL)
!   !    - (sum_IN rho_IN)(sum_ALL rho'_ALL)/(sum_ALL rho_ALL)^2
!   ! w^ab = (sum_IN rho^ab_IN)/(sum_ALL rho_ALL)
!   !      - (sum_IN rho^a_IN)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho^b_IN)(sum_ALL rho^a_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho_IN)(sum_ALL rho^ab_ALL)/(sum_ALL rho_ALL)^2
!   !    + 2 (sum_IN rho_IN)(sum_ALL rho^a_ALL)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^3
!     n_pt = w0.dim1
!     d0.create(n_pt);     rho0f.create(n_pt);     rho0a.create(n_pt)
!     d1.create(3,n_pt);   rho1f.create(3,n_pt);   rho1a.create(3,n_pt)
!     d2.create(3,3,n_pt); rho2f.create(3,3,n_pt); rho2a.create(3,3,n_pt)
!     rho0f = ZERO; rho0a = ZERO
!     rho1f = ZERO; rho1a = ZERO
!     rho2f = ZERO; rho2a = ZERO
!     do a = 1,.cluster.n_atoms
!        if (NOT .cluster.is_fragment_atom(a)) cycle
!        .atom(a).make_d_density_grid(d0,d1,d2,pt) ! this incorporates a skip step
!        rho0f = rho0f + d0
!        rho1f = rho1f + d1
!        rho2f = rho2f + d2
!     end
!     rho0a = rho0f
!     rho1a = rho1f
!     rho2a = rho2f
!     do a = 1,.cluster.n_atoms
!        if (.cluster.is_fragment_atom(a)) cycle
!        .atom(a).make_d_density_grid(d0,d1,d2,pt) ! this incorporates a skip step
!        rho0a = rho0a + d0
!        rho1a = rho1a + d1
!        rho2a = rho2a + d2
!     end
!   ! w  = (sum_IN rho_IN) /(sum_ALL rho_ALL)
!   ! w' = (sum_IN rho'_IN)/(sum_ALL rho_ALL)
!   !    - (sum_IN rho_IN)(sum_ALL rho'_ALL)/(sum_ALL rho_ALL)^2
!   ! w^ab = (sum_IN rho^ab_IN)/(sum_ALL rho_ALL)
!   !      - (sum_IN rho^a_IN)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho^b_IN)(sum_ALL rho^a_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho_IN)(sum_ALL rho^ab_ALL)/(sum_ALL rho_ALL)^2
!   !    + 2 (sum_IN rho_IN)(sum_ALL rho^a_ALL)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^3
!     do i = 1,rho0a.dim
!       if (rho0a(a)>epsilon(ONE)) then
!         bot = ONE/rho0a(i)
!         bot2 = bot*bot
!         bot3 = TWO*bot2*bot
!         f0   = rho0f(i)
!         w0(i) = f0*bot
!         f1 = rho1f(:,i)
!         a1 = rho1a(:,i)
!         fac = f0*bot2
!         w1(:,i) = f1*bot - a1*fac
!         do a = 1,3
!         do b = 1,a
!            w2(a,b,i) = rho2f(a,b,i)*bot &
!                      - (f1(a)*a1(b)+f1(b)*a1(a))*bot2 &
!                      - f0*rho2a(a,b,i)*bot2 &
!                      + f0*a1(a)*a1(b)*bot3 
!            if (a==b) cycle
!            w2(b,a,i) = w2(a,b,i)
!         end
!         end
!       else
!         w0(i) = ZERO
!         w1(:,i) = ZERO
!         w2(:,:,i) = ZERO
!       end
!     end
!     rho2a.destroy; rho2f.destroy; d2.destroy
!     rho1a.destroy; rho1f.destroy; d1.destroy
!     rho0a.destroy; rho0f.destroy; d0.destroy
!   end

   stockholder_density_grid(g,pt) ::: selfless
   ! Work out the Hirshfeld stockholder density grid "g" for a series of points.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_stockholder_density_grid(g,pt)
   end

!  ===================
!  Hirshfeld atom grid
!  ===================

   make_Hirshfeld_atom_grid
   ! Work out the Hirshfeld atom density density on ".plot_grid" 
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.center_atom>0, "no center_atom to plot")
   ENSURE(.density_matrix.created("restricted"), "no restricted density matrix")

      grid :: VEC{REAL}*
      pt,D :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the hirshfeld atom density
      D => .density_matrix.restricted
      .::make_Hirshfeld_atom_grid(grid,pt,.plot_grid.center_atom,D)

      ! Make the plot label
      label = "hirshfeld_atom_"
      label = trim(label) // trim(.plot_grid.center_atom.to_str) 
      label = trim(label) // "_density_grid" 

      ! Print out
      .::dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_Hirshfeld_atom_grid(N0,pt,c,D)
   ! Make the hirshfeld atom density grid "N0" for the grid "pt" for
   ! atom "c" given AO density matrix "D". Density "N0" weighted by
   ! Hirshfeld partition weight for atom "c". 
      N0 :: VEC{REAL}
      pt :: MAT{REAL}
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0, DD :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Grid size
      n_pt = pt.dim1

      ! Initialise N0
      N0 = ZERO

      ! Basis function cutoff
      cutoff = BECKE_GRID_BASIS_FUNCTION_CUTOFF

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            sha.make_skip_grid(grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy
                     pj.destroy
                     pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Apply stockholder weight function for atom "c" to "N0".
      ! If using interpolatators, then overlapping_atoms 
      ! are not needed ... otherwise nothing is skipped
      .::apply_stockholder_atom_weight(N0,c,pt)

      ! Clean up
      bf_grid0.destroy
      bf_skip.destroy
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy

   end

!  =====================
!  Stockholder atom grid
!  =====================

   apply_stockholder_atom_weight(grid,a,pt)
   ! Apply i.e. multiply the "grid" by the stockholder weight function
   ! for the atom with index "a" using supplied points "pt". 
   ! * If .use_interpolators is TRUE then interpolators are used.
   ! * If .use_interpolators is FALSE then interpolators could still
   !   be used if explicitly set for each atom (however the
   !   overlapping_atoms array will not be used to eliminate work).
   !   More likely the density will be explicitly evaluated.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      Wa :: VEC{REAL}*
      overlapping_atom :: VEC{INT}*
      n_pt :: INT

      ! Only needed for more than one atom
      if (.n_atom>1) then

         ! Get weights
         n_pt = pt.dim1
         Wa.create(n_pt)
         if (.use_interpolators) then
            DIE_IF(.overlapping_atoms_for_atom.destroyed,"no overlapping_atoms_for_atom!")
            overlapping_atom => .overlapping_atoms_for_atom(a).element
            .::make_stockholder_atom_grid_int(Wa,a,pt,overlapping_atom)
         else
            .::make_stockholder_atom_grid_acc(Wa,a,pt)
         end

         ! Apply them
         grid = grid*Wa

         ! Clean
         Wa.destroy

      end

   end

   make_stockholder_atom_grid(grid,a,pt,overlapping_atom)
   ! Make the Hirshfeld stockholder density "grid" for the atom with
   ! index "a" using supplied points "pt". 
   ! * If .use_interpolators is TRUE and "overlapping_atoms" is
   !   supplised then interpolators are used.
   ! * If .use_interpolators is FALSE then interpolators could still
   !   be used if explicitly set for each atom. More likely the
   !   density will be explicitly evaluated.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
      overlapping_atom :: VEC{INT}, IN, optional

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      if (.n_atom>1) then
         
         if (.use_interpolators) then
            ENSURE(present(overlapping_atom),"no overlapping_atom")
            .::make_stockholder_atom_grid_int(grid,a,pt,overlapping_atom)
         else
            .::make_stockholder_atom_grid_acc(grid,a,pt)
         end

      else

         grid = ONE

      end

   end

   make_stockholder_atom_grid_acc(grid,a,pt) ::: private
   ! Make the Hirshfeld stockholder desity "grid" for the atom with
   ! index "a" using supplied points "pt". 
   ! NOTE: This DOES NOT USE an interpolated density for each atom
   ! UNLESS use_interpolators is explicitly set. In this case you
   ! should probably use the next routine which uses the
   ! overlapping_atoms.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      rho_a :: VEC{REAL}*
      n_pt,i :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_density_grid(rho_a,pt)

      ! Make total density in "grid"
      grid = rho_a
      do i = 1,.n_atom
         if (i==a) cycle
         .atom(i).add_density_grid(grid,pt)
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
         else;                           grid(i) = ZERO
         end
      end
      rho_a.destroy

   end

   make_stockholder_atom_grid_int(grid,a,pt,overlapping_atom) ::: private
   ! Make the Hirshfeld stockholder desity "grid" for the atom with
   ! index "a" using supplied points "pt" and given a list of
   ! "overlapping_atom". This makes use of a previously calculated
   ! interpolated density for each atom.
   ! NOTE: the CLUSTER_ATOM_DENSITY_CUTOFF must be the same as the
   ! BECKE_GRID_BASIS_FUNCTION_CUTOFF
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
      overlapping_atom :: VEC{INT}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_interpolators_any_kind,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      rho_a :: VEC{REAL}*
      n_pt,i,j :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_interpolated_density(rho_a,pt)

      ! Make total density in "grid"
      grid = rho_a
      do j = 1,overlapping_atom.dim
         i = overlapping_atom(j)
         if (i==a) cycle
         .atom(i).add_interpolated_density(grid,pt)
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
         else;                           grid(i) = ZERO
         end
      end
      rho_a.destroy

   end

!  ================
!  Promolecule grid 
!  ================

   make_promolecule_density_grid ::: get_from(prop_grid, GRID=>::make_promolecule_density_grid, LABEL=>"promolecule_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_promolecule_density_grid(density_grid,pt) ::: get_from(pro_grid, GRID=>make_density_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

   promolecule_density_grid(g,pt) ::: selfless
   ! Work out the promolecule density grid "g" for a series of points.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_promolecule_density_grid(g,pt)
   end


   make_spherical_atom_grid ::: get_from(prop_grid, GRID=>::make_spherical_atom_grid, LABEL=>"spherical_atom_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_spherical_atom_grid(density_grid,pt)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.plot_grid.created,"no plot_grid")
   ENSURE(.plot_grid.center_atom>0,"no plot_grid center atom")

      .atom(.plot_grid.center_atom).make_density_grid(density_grid,pt)

   end

!  =======================
!  Grad rho on rho density
!  =======================

   make_grad_rho_on_rho_grid ::: get_from(prop_grid, GRID=>::make_grad_rho_on_rho_grid, LABEL=>"grad_rho_on_rho_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_grad_rho_on_rho_grid(grid,pt)
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim1==grid.dim,"array dimensions do not match")

      rho :: VEC{REAL}*
      grad_rho :: MAT{REAL}*
      n_pt,i :: INT

      n_pt = pt.dim1

      rho.create(n_pt)
      grad_rho.create(n_pt,3)

      rho = ZERO
      grid=ZERO

      .::make_density_grid(rho,pt)
      .::make_nabla_density_grid(grad_rho,pt)

      do i=1,n_pt
         if (rho(i)>ZERO) then
            grid(i)=sqrt(dot_product(grad_rho(i,:),grad_rho(i,:)))/rho(i)
         else
            grid(i)=ZERO
         end
      end

      grad_rho.destroy
      rho.destroy

   end

   grad_rho_on_rho_grid(g,pt) ::: selfless
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_grad_rho_on_rho_grid(g,pt)
   end

!  =============
!  ELI-D density
!  =============

   make_ELI_D_grid ::: get_from(prop_grid, GRID=>::make_ELI_D_grid, LABEL=>"ELI_D_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ELI_D_grid(ELI_grid,pt)
   ! Work out the Electron Localisation Indicator (D) (ELI) density "ELI_grid" 
   ! on a set of grid points "pt", using ".natural orbitals" and the ".occupation" 
   ! number vector.
     ELI_grid :: VEC{REAL}
     pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

     if (trim(.natural_orbitals.number_kind)=="real") then
        .::make_ELI_D_grid_r(ELI_grid,pt)
     else
        DIE("no complex implementation")
     end

   end

   make_ELI_D_grid_r(ELI_grid,pt)
   ! Work out the Electron Localisation Indicator (D) grid (ELI_D) density 
   ! on a set of grid points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
   ! Reference: Wagner et al (2007), Chem Eur. J. 13, p. 5724
   ! (Look at appendix for definition of g!)
      ELI_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "natural orbitals must be restricted")

      DD :: MAT{REAL}*
      g,gx,gy,gz,rho_s,rhox,rhoy,rhoz,tau,NO :: VEC{REAL}*
      i,n_pt :: INT

      ! No of grid points
      n_pt = pt.dim1

      rho_s.create(n_pt)
      rho_s  = ZERO

      ! Make the density of alpha electrons
      .::make_density_grid(rho_s,pt)
      rho_s = HALF*rho_s

      ! Temporaries
      g.create(n_pt);     g     = ZERO
      tau.create(n_pt);   tau   = ZERO
      rhox.create(n_pt);  rhox  = ZERO
      rhoy.create(n_pt);  rhoy  = ZERO
      rhoz.create(n_pt);  rhoz  = ZERO

      NO.create(n_pt)
      DD.create(n_pt,3)

      ! Sum the orbital gradient and density gradient bit
      do i = 1,.BASE:no_of_occupied_NOs

         .::make_nabla_orbital_grid_r(DD,NO,.natural_orbitals.restricted(:,i), pt)

         ! Orbital gradients
         gx => DD(:,1)
         gy => DD(:,2)
         gz => DD(:,3)

         ! Fermi hole curvature
         g = g + rho_s * (gx*gx + gy*gy + gz*gz) 

         ! This is only the orbital gradient part
         rhox = rhox + gx*NO
         rhoy = rhoy + gy*NO
         rhoz = rhoz + gz*NO

      end

      DD.destroy
      NO.destroy

      g = g - rhox*rhox - rhoy*rhoy - rhoz*rhoz

      ELI_grid = rho_s * (12.0d0/g)**(THREE/EIGHT)

      ! Clean up
      rhoz.destroy
      rhoy.destroy
      rhox.destroy
      tau.destroy
      g.destroy
      rho_s.destroy

   end

   ELI_D_grid(g,pt) ::: selfless
   ! Work out the Electron Localisation Indicator (ELI-D) density "g" for a series
   ! of points "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_ELI_D_grid(g,pt)
   end

!  ===========
!  ELF density
!  ===========

   make_ELF_grid ::: get_from(prop_grid, GRID=>::make_ELF_grid, LABEL=>"ELF_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ELF_grid(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density "g" on a set of
   ! grid points "pt", using ".natural orbitals" and the ".occupation" number
   ! vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .::make_ELF_grid_r(ELF_grid,pt)
      else
         .::make_ELF_grid_c(ELF_grid,pt)
      end

   end

   make_ELF_grid_r(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density on a set of grid
   ! points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "natural orbitals must be restricted")

      DD :: MAT{REAL}*
      mo_val,gx,gy,gz,rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s,NO :: VEC{REAL}*
      occu,factor,mo_val_n,gx_n,gy_n,gz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)

      n_occ = .BASE:no_of_occupied_NOs

      do i = 1,n_occ

         .::make_nabla_orbital_grid_r(DD,NO,.natural_orbitals.restricted(:,i), pt)
         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)
         occu   = HALF*.occupation_numbers.restricted(i)

         do n = 1,n_pt
           mo_val_n  = mo_val(n)
           gx_n      = gx(n)
           gy_n      = gy(n)
           gz_n      = gz(n)
           occ_mo    = occu*mo_val_n
           rho_s(n)  = rho_s(n)  + occ_mo*mo_val_n
           tau(n)    = tau(n)    + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
           rho_sx(n) = rho_sx(n) + occ_mo*gx_n ! this is half grad_x rho_s
           rho_sy(n) = rho_sy(n) + occ_mo*gy_n
           rho_sz(n) = rho_sz(n) + occ_mo*gz_n
         end

      end

      DD.destroy
      NO.destroy

      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s

      rho_sz.destroy
      rho_sy.destroy
      rho_sx.destroy
      tau.destroy

      d0_s.create(n_pt)
      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)

      rho_s.destroy

      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))

      ! this could be more efficient if the d0_s*d0_s is written
      ! factor2*rho_s**(TWO+FIVE/THREE)
      d0_s.destroy; d_s.destroy

   end

   make_ELF_grid_c(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density on a set of grid
   ! points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      mo_val,gx,gy,gz,NO :: VEC{CPX}*
      DD :: MAT{CPX}*
      rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s :: VEC{REAL}*
      occu,factor :: REAL
      n_occ,n,n_pt :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)

      n_occ = .BASE:no_of_occupied_NOs

      do n = 1,n_occ

         .::make_nabla_orbital_grid_c(DD,NO,.natural_orbitals.restricted_complex(:,n), pt)

         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)

         occu   = HALF*.occupation_numbers.restricted(n)
         rho_s  = rho_s  + occu * RE(conjg(mo_val)*mo_val)
         tau    = tau    + occu * RE(conjg(gx)*gx+conjg(gy)*gy+conjg(gz)*gz)
         rho_sx = rho_sx + occu * RE(conjg(gx)*mo_val) ! this is half grad_x rho_s
         rho_sy = rho_sy + occu * RE(conjg(gy)*mo_val)
         rho_sz = rho_sz + occu * RE(conjg(gz)*mo_val)

      end

      DD.destroy
      NO.destroy

      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s

      rho_sz.destroy
      rho_sy.destroy
      rho_sx.destroy
      tau.destroy

      d0_s.create(n_pt)

      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)

      rho_s.destroy

      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))

      d0_s.destroy; d_s.destroy

   end

   ELF_grid(g,pt) ::: selfless
   ! Work out the Electron Localisation Function (ELF) density "g" for a series
   ! of points "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_ELF_grid(g,pt)
   end

!  =====================
!  Tsirelson ELF density
!  =====================

   make_Tsirelson_ELF_grid ::: get_from(prop_grid, GRID=>::make_Tsirelson_ELF_grid, LABEL=>"Tsirelson-Stash_ELF_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_Tsirelson_ELF_grid(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)=="real") then
         .::make_Tsirelson_ELF_grid_r(ELF_grid,pt)
      else
         .::make_Tsirelson_ELF_grid_c(ELF_grid,pt)
      end

   end

   make_Tsirelson_ELF_grid_r(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      DD,LL :: MAT{REAL}*
      mo_val,gx,gy,gz,lx,ly,lz,rho,rho_x,rho_y,rho_z,lap,d_p,d_0,NO :: VEC{REAL}*
      occu,factor,mo_val_n,gx_n,gy_n,gz_n,lx_n,ly_n,lz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT

      ELF_grid = ZERO

      n_pt = pt.dim1
      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)

      n_occ = .BASE:no_of_occupied_NOs

      do i = 1,n_occ

         .::make_laplacian_orbital_grid_r(LL,DD,NO,.natural_orbitals.restricted(:,i), pt)

         mo_val => NO(:)
         gx => DD(:,1); gy => DD(:,2); gz => DD(:,3)
         lx => LL(:,1); ly => LL(:,2); lz => LL(:,3)

         occu = .occupation_numbers.restricted(i)

         do n = 1,n_pt

            mo_val_n = mo_val(n)
            gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
            lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)

            occ_mo   = occu*mo_val_n                        ! this is n_i phi_i
            rho(n)   = rho(n)   + occ_mo*mo_val_n           ! this is rho
            rho_x(n) = rho_x(n) + occ_mo*gx_n               ! this is half grad_x rho
            rho_y(n) = rho_y(n) + occ_mo*gy_n
            rho_z(n) = rho_z(n) + occ_mo*gz_n
            lap(n)   = lap(n)   + occ_mo*(lx_n+ly_n+lz_n) & ! this is half nabla^2 rho
                                + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
         end

      end

      LL.destroy
      DD.destroy
      NO.destroy

      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)

      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
                + lap/THREE

      lap.destroy

      rho_z.destroy
      rho_y.destroy
      rho_x.destroy
      rho.destroy

      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))

      d_p.destroy; d_0.destroy

   end

   make_Tsirelson_ELF_grid_c(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      mo_val,gx,gy,gz,lx,ly,lz,NO :: VEC{CPX}*
      DD,LL :: MAT{CPX}*
      rho,rho_x,rho_y,rho_z,lap,d_0,d_p :: VEC{REAL}*
      occu,factor :: REAL
      mo_val_n,gx_n,gy_n,gz_n,lx_n,ly_n,lz_n,occ_mo :: CPX
      n_occ,n_pt,n,i :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1

      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)

      n_occ = .BASE:no_of_occupied_NOs

      do i = 1,n_occ

         .::make_laplacian_orbital_grid_c(LL,DD,NO,.natural_orbitals.restricted_complex(:,i), pt)

         mo_val => NO(:)
         gx => DD(:,1); gy => DD(:,2); gz => DD(:,3)
         lx => LL(:,1); ly => LL(:,2); lz => LL(:,3)

         occu = .occupation_numbers.restricted(i)

         do n = 1,n_pt

           mo_val_n = mo_val(n)
           gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
           lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)

           occ_mo   = occu*mo_val_n                                          ! this is n_i phi_i
           rho(n)   = rho(n)   + RE(occ_mo*conjg(mo_val_n)) ! this is rho
           rho_x(n) = rho_x(n) + RE(occ_mo*conjg(gx_n))     ! this is half grad_x rho
           rho_y(n) = rho_y(n) + RE(occ_mo*conjg(gy_n))
           rho_z(n) = rho_z(n) + RE(occ_mo*conjg(gz_n))
                                                        ! this is half nabla^2 rho
           lap(n)   = lap(n) + RE(occ_mo*(conjg(lx_n)+conjg(ly_n)+conjg(lz_n))) &
                        + occu*RE(conjg(gx_n)*gx_n+conjg(gy_n)*gy_n+conjg(gz_n)*gz_n)
         end

      end

      LL.destroy
      DD.destroy
      NO.destroy

      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)

      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
                + lap/THREE

      lap.destroy
      rho_z.destroy
      rho_y.destroy
      rho_x.destroy
      rho.destroy

      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))

      d_p.destroy; d_0.destroy

   end

   Tsirelson_ELF_grid(g,pt) ::: selfless
   ! Work out the Tsirelson-Stash version of the Electron Localisation Function
   ! (ELF) density "g" for a series of points "pt" for using the ".natural
   ! orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_Tsirelson_ELF_grid(g,pt)
   end

!  ======================
!  Fermi mobility density
!  ======================

   make_fermi_mobility_grid ::: get_from(prop_grid, GRID=>::make_fermi_mobility_grid, LABEL=>"fermi_mobility_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_fermi_mobility_grid(f,pt)
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
      f :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .::make_fermi_mobility_grid_r(f,pt)
      else
         DIE("code not written yet")
      end

   end

   make_fermi_mobility_grid_r(f,pt)
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      del_gi :: MAT{REAL}*
      dg,gi,rho,dgx,dgy,dgz,orb :: VEC{REAL}*
      n,n_pt,i,n_occ :: INT
      delx,dely,delz,fac :: REAL

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      dg.create(n_pt);    dg  = ZERO
      dgx.create(n_pt);   dgx = ZERO
      dgy.create(n_pt);   dgy = ZERO
      dgz.create(n_pt);   dgz = ZERO
      gi.create(n_pt)
      del_gi.create(n_pt,3)

      do i = 1,n_occ

         orb => .natural_orbitals.restricted(:,i)

         .::make_nabla_orbital_grid_r(del_gi,gi,orb,pt)

         do n = 1,n_pt
            delx = del_gi(n,1)
            dely = del_gi(n,2)
            delz = del_gi(n,3)
            dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
            dgx(n) = dgx(n) + delx*gi(n)
            dgy(n) = dgy(n) + dely*gi(n)
            dgz(n) = dgz(n) + delz*gi(n)
         end

      end

      del_gi.destroy
      gi.destroy

      rho.create(n_pt)
      .::make_density_grid(rho,pt)

      fac = (THREE*PI/FOUR) * HALF**TWOTHIRDS
      f = ONE/rho * (dg - TWO*(dgx*dgx + dgy*dgy + dgz*dgz)/rho) - fac * rho**TWOTHIRDS

      rho.destroy
      dgz.destroy
      dgy.destroy
      dgx.destroy
      dg.destroy

   end

   fermi_mobility_grid(g,pt) ::: selfless
   ! Work out the Luken's fermi mobility density on a series of grid points "g"
   ! using ".natural orbitals" and the ".occupation_numbers" vector. A Gnuplot
   ! ascii file is generated.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_fermi_mobility_grid(g,pt)
   end

!  ===========================
!  True Fermi mobility density
!  ===========================

   make_true_fermi_mobility_grid ::: get_from(prop_grid, GRID=>::make_true_fermi_mobility_grid, LABEL=>"true_fermi_mobility_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_true_fermi_mobility_grid(f,pt)
   ! Work out the the true fermi mobility density "f" on a series of grid points
   ! "pt" using ".natural orbitals" and the ".occupation_numbers" vector. The
   ! true function differs from that above in that the kinetic energy density is
   ! evaluated exactly.
      f :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .::make_true_fermi_mobil_grid_r(f,pt)
      else
         DIE("code not written yet")
      end

   end

   make_true_fermi_mobil_grid_r(f,pt)
   ! Evaluate the true Fermi hole mobility grid "f" on a set of grid points
   ! "pt".  The true function differs from that above in that the kinetic energy
   ! density is evaluated exactly.
   ! NOTE: this routine is only valid for single determinant wavefunctions.
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.kinetic_energy_matrix.created, "no kinetic energy matrix")

      dg,rho,NO,K,gj,Tj :: VEC{REAL}*
      dgx,dgy,dgz,gi :: VEC{REAL}*
      n,n_pt,i,j,n_occ :: INT
      delx,dely,delz :: REAL
      del_gi,g,T :: MAT{REAL}*

      n_pt = pt.dim1
      n_occ = .BASE:no_of_occupied_NOs

      dg.create(n_pt);    dg  = ZERO
      dgx.create(n_pt);   dgx = ZERO
      dgy.create(n_pt);   dgy = ZERO
      dgz.create(n_pt);   dgz = ZERO
      g.create(n_pt,n_occ)
      del_gi.create(n_pt,3)

      ! Assemble intermediate terms
      do i = 1,n_occ

         NO => .natural_orbitals.restricted(:,i)
         gi => g(:,i)

         .::make_nabla_orbital_grid_r(del_gi,gi,NO,pt)

         do n = 1,n_pt
            delx = del_gi(n,1)
            dely = del_gi(n,2)
            delz = del_gi(n,3)
            dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
            dgx(n) = dgx(n) + delx*gi(n)
            dgy(n) = dgy(n) + dely*gi(n)
            dgz(n) = dgz(n) + delz*gi(n)
         end

      end

      del_gi.destroy

      ! Make kinetic energy matrix part
      K.create(n_pt)
      K = ZERO
      T.create(.n_bf,.n_bf)
      T = .kinetic_energy_matrix.restricted
      T.change_basis_using(.natural_orbitals.restricted)

      do j = 1,n_occ
         gj => g(:,j)
         Tj => T(:,j)
         do i = 1,n_occ
            K = K + g(:,i)*gj(:)*Tj(i)
         end
      end
      T.destroy

      ! Now do the final assembly
      rho.create(n_pt)
      .::make_density_grid(rho,pt)
      f = ONE/rho * (dg - TWO*(dgx*dgx+dgy*dgy+dgz*dgz)/rho - TWO*K)

      ! Clean
      rho.destroy
      K.destroy
      g.destroy
      dgz.destroy
      dgy.destroy
      dgx.destroy
      dg.destroy

   end

   true_fermi_mobility_grid(g,pt) ::: selfless
   ! Work out the Luken's true fermi mobility density (the one using kinetic
   ! energy matrix elements) on a series of grid points "g" using ".natural
   ! orbitals" and the ".occupation_numbers" vector. A Gnuplot ascii file is
   ! generated.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*
      .BASE:set_from_saved_self
      .::make_true_fermi_mobility_grid(g,pt)
   end

!  ==============
!  Magnetic Field
!  ==============

   make_B_field_grid 
   ! Work out the field density on ".plot_grid" and dump output
   ENSURE(.plot_grid.created, "no grid")

      B_L,B_S :: MAT{REAL}*
      fx,fy,fz,mag :: VEC{REAL}*
      pt :: MAT{REAL}*

      if(.plot_grid.points_filename/="no_made-up_points") then 
        stdout.text("=====================================")
        stdout.text("use of read-in grid to be implemented")
        stdout.text("TONTO will stop here ...")
        stdout.text("=====================================")
        stop
      else

      ! Make space for the field and grid points
      B_L.create(.plot_grid.n_pt,3)
      B_S.create(.plot_grid.n_pt,3)
      mag.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

        ! Make the grid of field values
  !      .::make_B_field_grid(B_L,B_S,pt)
        .::make_B_L_field_grid(B_L,pt)
        .::make_B_S_field_grid(B_S,pt)

        ! Print B_L field components
        fx => B_L(:,1)
        fy => B_L(:,2)
        fz => B_L(:,3)
        .::dump_plot_grid(fx,"B_L_field.x")
        .::dump_plot_grid(fy,"B_L_field.y")
        .::dump_plot_grid(fz,"B_L_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .::dump_plot_grid(mag,"B_L_field.magnitude")
  
        ! Print B_S field components
        fx => B_S(:,1)
        fy => B_S(:,2)
        fz => B_S(:,3)
        .::dump_plot_grid(fx,"B_S_field.x")
        .::dump_plot_grid(fy,"B_S_field.y")
        .::dump_plot_grid(fz,"B_S_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .::dump_plot_grid(mag,"B_S_field.magnitude")
  
        ! Print B field components
        B_L = B_L + B_S
        fx => B_L(:,1)
        fy => B_L(:,2)
        fz => B_L(:,3)
        .::dump_plot_grid(fx,"B_field.x")
        .::dump_plot_grid(fy,"B_field.y")
        .::dump_plot_grid(fz,"B_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .::dump_plot_grid(mag,"B_field.magnitude")

      end

      ! Clean up
      pt.destroy
      B_S.destroy
      B_L.destroy

   end
 
!   make_B_field_grid(B_L,B_S,pt) 
!   ! Make the magnetic field "B" field due to the linear current and
!   ! the spin current on a series of points "pt"
!      B_L,B_S :: MAT{REAL}, OUT
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.density_matrix.any_created,"no density matrix")
!
!      M :: MAT4{REAL}*
!      S :: MAT3{REAL}*
!      D,DD,S1,S2,S3,J1,J2,J3 :: MAT{REAL}*
!      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
!      fac :: REAL
!      sh :: SHELL2
!
!      ! No of grid points
!      n_pt = pt.dim1
!
!      ! The imaginary part of AO density matrix
!      D.create(.n_bf,.n_bf)
!      .BASE:make_ao_IM_density_matrix(D)
!
!      ! Make the real part of AO spin density matrix
!      S.create(.n_bf,.n_bf,3)
!      .BASE:make_ao_RE_spin_densities(S)
!
!      ! Initialize
!      B_L = ZERO
!      B_S = ZERO
!
!      ! Loop over integral blocks
!      parallel do q = 1,.n_shell_pairs
!
!        ! Get shell indices (leaky)
!        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
!
!        ! Get the density matrix
!        DD.create(nb,na); DD = D(fb:lb,fa:la)
!
!        ! Get the spin density matrix
!        S1.create(nb,na); S1 = S(fb:lb,fa:la,1)
!        S2.create(nb,na); S2 = S(fb:lb,fa:la,2)
!        S3.create(nb,na); S3 = S(fb:lb,fa:la,3)
!
!        ! Space for integrals
!        M.create(na,nb,3,3)
!        J1 => M(:,:,1,1)
!        J2 => M(:,:,2,2)
!        J3 => M(:,:,3,3)
!
!        ! Loop over points
!        do p = 1,n_pt
!
!           ! Make the B-field integrals for point k
!           sh.make_nabla_field_ints(M,pt(p,:))
!
!           ! Factor
!           fac =TWO 
!           if (fa==fb) fac = ONE
!
!           ! Sum over the spin density matrices
!           ! Factor 2 should be put here, since S ints are symmetric so it
!           ! is introduced once at the end
!           B_S(p,2) = B_S(p,2) + fac*M(:,:,2,1).trace_product_with(S1)
!           B_S(p,3) = B_S(p,3) + fac*M(:,:,3,1).trace_product_with(S1)
!           B_S(p,1) = B_S(p,1) - fac*M(:,:,2,2).trace_product_with(S1)
!           B_S(p,1) = B_S(p,1) - fac*M(:,:,3,3).trace_product_with(S1)
!
!           B_S(p,1) = B_S(p,1) + fac*M(:,:,1,2).trace_product_with(S2)
!           B_S(p,3) = B_S(p,3) + fac*M(:,:,3,2).trace_product_with(S2)
!           B_S(p,2) = B_S(p,2) - fac*M(:,:,1,1).trace_product_with(S2)
!           B_S(p,2) = B_S(p,2) - fac*M(:,:,3,3).trace_product_with(S2)
!
!           B_S(p,1) = B_S(p,1) + fac*M(:,:,1,3).trace_product_with(S3)
!           B_S(p,2) = B_S(p,2) + fac*M(:,:,2,3).trace_product_with(S3)
!           B_S(p,3) = B_S(p,3) - fac*M(:,:,1,1).trace_product_with(S3)
!           B_S(p,3) = B_S(p,3) - fac*M(:,:,2,2).trace_product_with(S3)
!
!           ! Cross product part
!           J1 = M(:,:,2,3) - M(:,:,3,2)
!           J2 = M(:,:,3,1) - M(:,:,1,3)
!           J3 = M(:,:,1,2) - M(:,:,2,1)
!
!           ! Get magnetic field contribution
!           ! Extra factor 2 needed from left derivative in M
!           ! is deferred to end.
!           B_L(p,1) = B_L(p,1) + fac*J1.trace_product_with(DD)
!           B_L(p,2) = B_L(p,2) + fac*J2.trace_product_with(DD)
!           B_L(p,3) = B_L(p,3) + fac*J3.trace_product_with(DD)
!
!        end
!
!        ! Clean
!        M.destroy
!        S3.destroy; S2.destroy; S1.destroy
!        DD.destroy
!        sh.destroy_ptr_part
!
!      end
!
!      ! Clean
!      S.destroy
!      D.destroy
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(B_S)
!         PARALLEL_SUM(B_L)
!      end
!
!      ! Minus sign not necessary? CHECK
!      fac = -ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B_L = fac*B_L
!
!      ! Spin Factor
!  !    fac = -G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!  ! minus sign is cancelled by that of the Bohr magneton, 
!  ! the 1/2 of the bohr magneton is cancelled from a factor 2
!  ! arising in simplification by symmetry of the formula
!      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B_S = fac*B_S
!
!   end

   field_grid ::: template
   ! Work out the field density on ".plot_grid" and dump output
   ENSURE(.plot_grid.created, "no grid")

      field :: MAT{REAL}*
      fx,fy,fz :: VEC{REAL}*
      pt :: MAT{REAL}*

      ! Make space for the field and grid points
      field.create(.plot_grid.n_pt,3)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the grid of field values
      .FIELD(field,pt)

      ! Assign field components
      fx => field(:,1)
      fy => field(:,2)
      fz => field(:,3)

      ! Print out
      .::dump_plot_grid(fx,LABEL//".x")
      .::dump_plot_grid(fy,LABEL//".y")
      .::dump_plot_grid(fz,LABEL//".z")

      ! Get the magnitude
      fx = sqrt(fx*fx+fy*fy+fz*fz)

      ! Print out
      .::dump_plot_grid(fx,LABEL//".magnitude")

      ! Clean up
      pt.destroy
      field.destroy

   end

   make_B_L_field_grid ::: get_from(field_grid, FIELD=>::make_B_L_field_grid, LABEL=>"B_L_field")
   ! Work out the field density on ".plot_grid" and dump output
   end
 
   make_B_L_field_grid(B,pt) 
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.any_created,"no density matrix")

      Mleft,Mright :: MAT4{REAL}*
      D,Dba,J1,J2,J3 :: MAT{REAL}*
      Dab,J4,J5,J6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! The imaginary part of AO density matrix
      D.create(.n_bf,.n_bf)
      .BASE:make_ao_IM_density_matrix(D)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the density matrix
        Dab.create(na,nb)
        Dab = D(fa:la,fb:lb)
        Dba.create(nb,na)
        Dba = D(fb:lb,fa:la)

        ! Space for integrals
        Mleft.create(nb,na,3,3)
        Mright.create(na,nb,3,3)
        J1 => Mright(:,:,1,1)
        J2 => Mright(:,:,2,2)
        J3 => Mright(:,:,3,3)
        J4 => Mleft(:,:,1,1)
        J5 => Mleft(:,:,2,2)
        J6 => Mleft(:,:,3,3)

        ! Loop over points
        do p = 1,n_pt

           if (fa==fb) then

             ! Make the B-field integrals for point k
             sh.make_nabla_field_ints(Mright,pt(p,:))
  
             ! Cross product part
             J1 = Mright(:,:,2,3) - Mright(:,:,3,2)
             J2 = Mright(:,:,3,1) - Mright(:,:,1,3)
             J3 = Mright(:,:,1,2) - Mright(:,:,2,1)
  
             ! Get magnetic field contribution
             B(p,1) = B(p,1) + J1.trace_product_with(Dba)
             B(p,2) = B(p,2) + J2.trace_product_with(Dba)
             B(p,3) = B(p,3) + J3.trace_product_with(Dba)

           else

             ! Make the B-field integrals for point k
             sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))
  
             ! Cross product part
             J1 = Mright(:,:,2,3) - Mright(:,:,3,2)
             J2 = Mright(:,:,3,1) - Mright(:,:,1,3)
             J3 = Mright(:,:,1,2) - Mright(:,:,2,1)
             J4 = Mleft(:,:,2,3) - Mleft(:,:,3,2)
             J5 = Mleft(:,:,3,1) - Mleft(:,:,1,3)
             J6 = Mleft(:,:,1,2) - Mleft(:,:,2,1)
  
             ! Get magnetic field contribution
             B(p,1) = B(p,1) + J1.trace_product_with(Dba)
             B(p,2) = B(p,2) + J2.trace_product_with(Dba)
             B(p,3) = B(p,3) + J3.trace_product_with(Dba)
             B(p,1) = B(p,1) + J4.trace_product_with(Dab)
             B(p,2) = B(p,2) + J5.trace_product_with(Dab)
             B(p,3) = B(p,3) + J6.trace_product_with(Dab)

           end

        end

        ! Clean
        Mleft.destroy
        Mright.destroy
        Dba.destroy
        Dab.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      D.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Minus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = -ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end
 
!   make_B_L_field_grid_checked(B,pt) 
!   ! Make the magnetic field "B" field due to the linear current on a
!   ! series of points "pt"
!      B :: MAT{REAL}, OUT
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.density_matrix.any_created,"no density matrix")
!
!      D :: MAT{REAL}*
!      Dba :: MAT{REAL}*
!      Jx,Jy,Jz :: MAT{REAL}*
!      q,fa,fb,la,lb,na,nb, k,n_pt :: INT
!      fac :: REAL
!      sh :: SHELL2
!
!      ! No of grid points
!      n_pt = pt.dim1
!
!      ! Make the AO density matrix
!      D.create(.n_bf,.n_bf)
!      .BASEmake_ao_IM_density_matrix(D)
!
!      ! Initialize
!      B = ZERO
!
!      ! Loop over integral blocks
!      parallel do q = 1,.n_shell_pairs
!
!        ! Get shell indices (leaky)
!        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
!        fac = TWO
!        if (fa==fb) fac = ONE
!
!        ! Get the density matrix
!        Dba.create(nb,na)
!        Dba = D(fb:lb,fa:la)
!
!        ! Space for integrals
!        Jx.create(na,nb)
!        Jy.create(na,nb)
!        Jz.create(na,nb)
!
!        ! Loop over points
!        do k = 1,n_pt
!
!           ! Make the integrals for point k
!           sh.make_magnetic_jp_ints(Jx,Jy,Jz,pt(k,:))
!
!           ! Get magnetic field contribution
!           B(k,1) = B(k,1) + fac*Jx.trace_product_with(Dba)
!           B(k,2) = B(k,2) + fac*Jy.trace_product_with(Dba)
!           B(k,3) = B(k,3) + fac*Jz.trace_product_with(Dba)
!
!        end
!
!        ! Clean
!        Jz.destroy; Jy.destroy; Jx.destroy
!        Dba.destroy
!        sh.destroy_ptr_part
!
!      end
!
!      ! Clean
!      D.destroy
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(B)
!      end
!
!      ! Minus sign not necessary? CHECK
!      fac = -HALF/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B   = fac*B
!
!   end

   make_B_S_field_grid ::: get_from(field_grid, FIELD=>::make_B_S_field_grid, LABEL=>"B_S_field")
   ! Work out the field density on ".plot_grid" and dump output
   end
 
   make_B_S_field_grid(B,pt) 
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.any_created,"no density matrix")

      ! Not the most efficient, but should work ...
      if (.density_matrix.alpha.created) then; .::make_B_S_field_grid_u(B,pt)
      else;                                    .::make_B_S_field_grid_gc(B,pt)
      end

   end
 
   make_B_S_field_grid_u(B,pt) 
   ! Make the magnetic field "B" field due to the spin current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.alpha.created,"no alpha density matrix")
   ENSURE(.density_matrix.beta.created,"no beta density matrix")

      Mright,Mleft :: MAT4{REAL}*
      S,S3,S6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! Make the AO Sz density matrix
      S.create(.n_bf,.n_bf)
      .BASE:make_ao_sz_density_matrix(S)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the z spin density matrix block
        S3.create(nb,na); S3 = S(fb:lb,fa:la)
        S6.create(na,nb); S6 = S(fa:la,fb:lb)

        ! Space for integrals
        Mright.create(na,nb,3,3)
        Mleft.create(nb,na,3,3)

        ! Loop over points
        do p = 1,n_pt

          if (fa==fb) then

            ! Make the B-field integrals for point k
            sh.make_nabla_field_ints(Mright,pt(p,:))

 
            ! Sum over the spin density matrices
            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
 
          else
          ! Make the B-field integrals for point k
          !
            sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))

            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
 
            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S6)
            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S6)

          ! To add to make it work even if S is not Hermitian
          ! (useful to test a single matrix element)
          ! but then a factor HALF should be inserted

! 
!            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S6,TRUE)
!            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S6,TRUE)
! 
!           
!            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S3,TRUE)
!            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S3,TRUE)


          end

        end

        ! Clean
        Mright.destroy
        Mleft.destroy
        S3.destroy
        S6.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      S.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Spin Factor
      ! Plus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end
 
   make_B_S_field_grid_gc(B,pt) 
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")

!pcc      M :: MAT4{REAL}*
      Mleft,Mright :: MAT4{REAL}*
      S :: MAT3{REAL}*
      S1,S2,S3 :: MAT{REAL}*
      S4,S5,S6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! Make the AO density matrix
      S.create(.n_bf,.n_bf,3)
      .BASE:make_ao_RE_spin_densities(S)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the spin density matrix
        S1.create(nb,na); S1 = S(fb:lb,fa:la,1)
        S2.create(nb,na); S2 = S(fb:lb,fa:la,2)
        S3.create(nb,na); S3 = S(fb:lb,fa:la,3)
        S4.create(na,nb); S4 = S(fa:la,fb:lb,1)
        S5.create(na,nb); S5 = S(fa:la,fb:lb,2)
        S6.create(na,nb); S6 = S(fa:la,fb:lb,3)

        ! Space for integrals
        Mright.create(na,nb,3,3)
        Mleft.create(nb,na,3,3)

        ! Loop over points
        do p = 1,n_pt


          if (fa==fb) then

          ! Make the B-field integrals for point k
            sh.make_nabla_field_ints(Mright,pt(p,:))

 
            ! Sum over the spin density matrices
            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S1)
            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S1)
 
            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S2)
            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S2)
 
            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
 
          else
          ! Make the B-field integrals for point k
          !
            sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))

            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S1)
            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S1)

            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S2)
            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S2)
 
            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
 
           
            B(p,2) = B(p,2) + Mleft(:,:,2,1).trace_product_with(S4)
            B(p,3) = B(p,3) + Mleft(:,:,3,1).trace_product_with(S4)
            B(p,1) = B(p,1) - Mleft(:,:,2,2).trace_product_with(S4)
            B(p,1) = B(p,1) - Mleft(:,:,3,3).trace_product_with(S4)
 
            B(p,1) = B(p,1) + Mleft(:,:,1,2).trace_product_with(S5)
            B(p,3) = B(p,3) + Mleft(:,:,3,2).trace_product_with(S5)
            B(p,2) = B(p,2) - Mleft(:,:,1,1).trace_product_with(S5)
            B(p,2) = B(p,2) - Mleft(:,:,3,3).trace_product_with(S5)
 
            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S6)
            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S6)

          ! To add to make it work even if S is not Hermitian
          ! (useful to test a single matrix element)
          ! but then a factor HALF should be inserted

!            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S4,TRUE)
!            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S4,TRUE)
!            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S4,TRUE)
!            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S4,TRUE)
!
!            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S5,TRUE)
!            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S5,TRUE)
!            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S5,TRUE)
!            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S5,TRUE)
! 
!            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S6,TRUE)
!            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S6,TRUE)
! 
!           
!            B(p,2) = B(p,2) + Mleft(:,:,2,1).trace_product_with(S1,TRUE)
!            B(p,3) = B(p,3) + Mleft(:,:,3,1).trace_product_with(S1,TRUE)
!            B(p,1) = B(p,1) - Mleft(:,:,2,2).trace_product_with(S1,TRUE)
!            B(p,1) = B(p,1) - Mleft(:,:,3,3).trace_product_with(S1,TRUE)
! 
!            B(p,1) = B(p,1) + Mleft(:,:,1,2).trace_product_with(S2,TRUE)
!            B(p,3) = B(p,3) + Mleft(:,:,3,2).trace_product_with(S2,TRUE)
!            B(p,2) = B(p,2) - Mleft(:,:,1,1).trace_product_with(S2,TRUE)
!            B(p,2) = B(p,2) - Mleft(:,:,3,3).trace_product_with(S2,TRUE)
! 
!            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S3,TRUE)
!            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S3,TRUE)
          end
        end
 
        ! Clean
        Mright.destroy
        Mleft.destroy
        S3.destroy
        S2.destroy
        S1.destroy
        S6.destroy
        S5.destroy
        S4.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      S.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Spin Factor
      ! Plus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B
  !   stdout.text("Bs")
  !   stdout.put(B)
   end
 
   make_B_L_matrices(Bx,By,Bz,c) 
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      Bx,By,Bz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      q,fa,fb,la,lb,na,nb :: INT
      sh :: SHELL2

      ! Initialize
      Bx = ZERO
      By = ZERO
      Bz = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! shell indices (leaky)
        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Make the integrals, point c
        sh.make_magnetic_jp_ints(Bx(fa:la,fb:lb),By(fa:la,fb:lb),Bz(fa:la,fb:lb),c)

        ! Clean
        sh.destroy_ptr_part

      end

      ! Symmetrize
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(Bx)
         PARALLEL_SYMMETRIC_SUM(By)
         PARALLEL_SYMMETRIC_SUM(Bz)
      else
         Bx.symmetric_reflect
         By.symmetric_reflect
         Bz.symmetric_reflect
      end

   end

!  ======================================
!  Crystal structure factor residual maps
!  ======================================

   make_crystal_error_map ::: leaky
   ! Work out the crystal_error map on ".plot_grid". A Gnuplot ascii file is
   ! generated.
   ENSURE(.plot_grid.created, "no grid")

      map :: VEC{REAL}*

      map.create(.plot_grid.n_pt)
      .::make_crystal_error_map(map)
      .::dump_plot_grid(map,"crystal_error_map")
      map.destroy

   end

   make_crystal_error_map(map)
   ! Make the crystal error "map".
      map :: VEC{REAL}

   ENSURE(.plot_grid.created, "no grid")

      pt :: MAT{REAL}*
      n_pt :: INT

      map = ZERO
      n_pt = .plot_grid.n_pt
      pt.create(n_pt,3)
      .plot_grid.make_points(pt)
      .crystal.make_residual_error_map(map,pt)
      pt.destroy

   end

!  ======================
!  Polarizability density
!  ======================

   make_e_polarization_grid 
   ! Work out the electric polarization grid, either along a
   ! projection or all three directions and magnitude.

   ENSURE(.plot_grid.created, "no grid")

      if (.plot_grid.projection_direction.is_zero) then
         .::make_e_polarization_vgrid
      else
         .::make_e_polarization_pgrid
      end

   end

   make_e_polarization_vgrid ::: get_from(field_grid, FIELD=>::make_e_polarization_vgrid, LABEL=>"electric_polarization_density")
   ! Work out the field density on ".plot_grid" and dump output
   end
 
   make_e_polarization_vgrid(E,pt) 
   ! Make the (vector as opposed to projected) electric polarization
   ! density "E" on a series of grid points "pt"
      E :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.molecular_orbitals.restricted.created,"no MO's")
   ENSURE(.U_electric_dipole.created,"no U matrices: did you do a dipole_polarizability?")
   ENSURE(E.dim1==pt.dim1, "E and pt: inconsistent no. of points")
   ENSURE(E.dim2==3      , "E : wrong dim2")

      D :: MAT3{REAL}*
      MO :: MAT{REAL}*
      n_occ, i :: INT

      ! Dimensions
      n_occ = .n_a 

      ! Get derivative density matrices (restricted only)
      D.create(.n_bf,.n_bf,3)
      MO => .molecular_orbitals.restricted
      do i = 1,3 ! x,y,z electric fields
         .U_electric_dipole(:,:,1).back_transform_to(D(:,:,1),MO(:,n_occ+1:),MO(:,:n_occ))
         D(:,:,i).symmetrize              
      end
      D = FOUR*D

      ! Debug
      if (.BASE:debugging("make_e_polarization_grid")) then
         stdout.flush
         stdout.text("Derivative density matrices")
         stdout.put(D)
      end

      ! Make the derivative rho grid
      .::make_derivative_rho_grid(E,pt,D)

      ! Clean
      D.destroy

   end

   make_e_polarization_pgrid ::: get_from(prop_grid, GRID=>::make_e_polarization_pgrid, LABEL=>"electric_polarization_density.projected")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end
 
   make_e_polarization_pgrid(grid,pt) 
   ! Make the (vector as opposed to projected) electric polarization
   ! density "E" on a series of grid points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}, IN

   ENSURE(grid.dim==pt.dim1, "grid and pt: inconsistent no. of points")

      E :: MAT{REAL}*
      n_pt :: INT

      ! Dimensions
      n_pt  = pt.dim1

      ! Space
      E.create(n_pt,3)

      ! Make electric polarization density
      .::make_e_polarization_vgrid(E,pt) 

      ! Do the projection
      grid = E(:,1)*.plot_grid.projection_direction(1) &
           + E(:,2)*.plot_grid.projection_direction(2) &
           + E(:,3)*.plot_grid.projection_direction(3)

      ! Clean
      E.destroy

   end

!  ======================
!  Set interpolator grids
!  ======================

   make_ANO_interpolators ::: leaky
   ! Get the gaussian ANO interpolators

   ENSURE(.atom.created,"no atoms")
   ENSURE(.BASE:has_all_ANOs,"no ANOs")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      template :: INTERPOLATOR*
      kind,a,b :: INT
      atom_a,atom_b :: ATOM*

      if (.atom(1).ANO_interpolators_made) return
      if (.atom(1).interpolators_made) return

      stdout.flush
      stdout.text("Making gaussian ANO interpolators ...")

      do a = 1,.n_atom

         atom_a => .atom(a)

         ! Unique atom?
         if (NOT atom_a.is_unique_kind) cycle

         kind = atom_a.kind

         ! Make the interpolator
         if (.interpolator.created) then 

            atom_a.make_interpolator(.interpolator)

         else

            .::make_interpolator_sqrt_x1x(template)
            atom_a.make_interpolator(template)
            template.destroy

         end

        ! Copy to the other atoms
        do b = a+1,.n_atom

           atom_b => .atom(b)

           if (atom_b.kind/=kind) cycle

           atom_b.interpolator => atom_a.interpolator

        end

      end

      .atom.set_ANO_interpolators_made(TRUE)

   end

   make_slater_interpolators ::: leaky
   ! Make the slaterbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
   ENSURE(.slaterbasis.created,"no slaterbasis")

      template :: INTERPOLATOR*
      i :: INT

      stdout.flush
      stdout.text("Making slater interpolators ...")

      ! Make the interpolators
      if (.interpolator.created) then

         do i = 1,.slaterbasis.dim   
            .slaterbasis(i).make_interpolator(.interpolator)
         end                         

      else

         .::make_interpolator_sqrt(template)
         do i = 1,.slaterbasis.dim   
           .slaterbasis(i).make_interpolator(template)
         end                         
         template.destroy

      end

      ! Set .atom to use this interpolator
      if (.atom.created) .atom.set_basis_kind("slater")

   end

   make_coppens_interpolators ::: leaky
   ! Make the coppensbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
   ! Otherwise use an atom density cutoff "tol".
   ! NOTE: any existing interpolators are destroyed first
   ENSURE(.coppensbasis.created,"no slaterbasis")

      template :: INTERPOLATOR*
      i :: INT

      stdout.flush
      stdout.text("Making coppens interpolators ...")

      ! Make the interpolators
      if (.interpolator.created) then

         do i = 1,.coppensbasis.dim  ! Make the interpolators
            .coppensbasis(i).make_interpolator(.interpolator)
         end                      

      else

         .::make_interpolator_sqrt(template)
         do i = 1,.coppensbasis.dim  ! Make the interpolators
            .coppensbasis(i).make_interpolator(template)
         end                      
         template.destroy

      end

      ! Set .atom to use this interpolator
      if (.atom.created) .atom.set_basis_kind("coppens")

   end

   make_interpolator_sqrt(interpolator) ::: leaky
   ! Make a non-gaussian interpolator. These typically used for
   ! stockholder weight functions.
      interpolator :: INTERPOLATOR*

      ! Create default interpolator
      interpolator.create  

      ! Reset default table eps
      interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! If a saved cluster exists, use a table eps from that
      if (.saved.created) then
      if (.saved.cluster.created) then
      if (.saved.cluster.info_made) then
         interpolator.set_table_eps(.saved.cluster.atom_density_cutoff)
      end
      end
      end

      ! Set a linear-sqrt interpolator
      interpolator.set_interpolation_method("linear")
      interpolator.set_range_mapping("none")
      interpolator.set_domain_mapping("sqrt")
      interpolator.set_table_length(900d0)
      interpolator.set_table_spacing(0.1d0)

   end

   make_interpolator_sqrt_x1x(interpolator) ::: leaky
   ! Make a gaussian interpolator. 
      interpolator :: INTERPOLATOR*

      ! Create default interpolator
      interpolator.create  

      ! Reset default table eps
      interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! If a saved cluster exists, use a table eps from that
      if (.saved.created) then
      if (.saved.cluster.created) then
      if (.saved.cluster.info_made) then
         interpolator.set_table_eps(.saved.cluster.atom_density_cutoff)
      end
      end
      end

      ! Set a linear-sqrt interpolator
      interpolator.set_interpolation_method("cubic_spline")
      interpolator.set_range_mapping("none")
      interpolator.set_domain_mapping("sqrt(x/(1-x))*scale")
      interpolator.set_table_length(ONE) 
      interpolator.set_spacing(0.0001d0) 

   end

!  ============================
!  Angyan's oscillator orbitals
!  ============================

   make_oscillator_orbital_grid
   ! Work out the oscillator orbital on ".plot_grid" using ".natural orbitals" for
   ! orbital "orb". 

   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
   ENSURE(.localiser.created, "no localiser orbject created")

      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      orb :: INT

      orb = .plot_grid.orbital
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      if (trim(.natural_orbitals.number_kind)=="real") then

         gr.create(.plot_grid.n_pt)
         .::make_oscillator_orbital_grid_r(gr,orb,pt)
         .::dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
         gr.destroy

      else

         DIE("complex case not yet implemented")

      end

      pt.destroy

   end

   make_oscillator_orbital_grid_r(g,ind,pt,square)
   ! Evaluate the oscillator orbital density grid "g" for the localised orbital
   ! with index "ind" on a set of grid points "pt". You must supply on the input
   ! line the angular momentum "l" and component "n" of the oscillator orbital,
   ! which is an awful hack for the moment.
      g :: VEC{REAL}, OUT
      ind :: INT
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.localiser.created, "no localiser orbject created")

      os :: VEC{REAL}*
      c  :: VEC{REAL}(3)
      l,n :: INT
      sh :: SHELL1

      os.create(pt.dim1)
      c = .localiser.dipole(ind,ind,:)

      stdin.read(l)
      stdin.read(n)

      sh.make_oscillator_orbital_mask(os,c,l,n,pt)
      .::make_orbital_grid_r(g,.localiser.MO(:,ind),pt,square)
      g = g*os

      os.destroy

   end

   make_p_oscillator_orb_grid_r(g,ind,pt,square)
   ! Evaluate the oscillator orbital density grid "g" for the projected
   ! localised orbital with index "ind" on a set of grid points "pt". You must
   ! supply on the input line the angular momentum "l" and component "n" of the
   ! oscillator orbital, which is an awful hack for the moment.
      g :: VEC{REAL}, OUT
      ind :: INT
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.localiser.created, "no localiser orbject created")

      gg,os :: VEC{REAL}*
      c  :: VEC{REAL}(3)
      maxl,l,n,ln, i,j :: INT
      coeff :: REAL
      sh :: SHELL1

      gg.create(pt.dim1)
      os.create(pt.dim1)
      c = .localiser.dipole(ind,ind,:)

      stdin.read(maxl)
      stdin.read(l)
      stdin.read(n)

      .::make_orbital_grid_r(gg,.localiser.MO(:,ind),pt,square)

      ln = GAUSSIAN_DATA:n_comp_up_to(l-1)*.n_a + (ind-1)*GAUSSIAN_DATA:n_comp(l) + n
      g = ZERO
      i = 0
      do l = 0,maxl
      do n = 1,GAUSSIAN_DATA:n_comp(l)
      do j = 1,.n_a
         i = i + 1
         coeff = .localiser.TM(i,ln)
         if (coeff.is_zero) cycle
         sh.make_oscillator_orbital_mask(os,c,l,n,pt)
         g = g + coeff*gg*os
      end
      end
      end

      os.destroy
      gg.destroy

   end

   oscillator_orbital_grid(g,pt) ::: selfless
   ! Work out the oscillator orbital grid "g" for a series of points "pt" for
   ! using the ".natural orbitals", for a partcular orbital .plot_grid.orbital.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.localiser.created, "no localiser orbject created")

      orb :: INT
      grid :: PLOT_GRID*
      self :: MOLECULE*

      ! Get back self
      .BASE:set_from_saved_self

      grid => .isosurface.plot_grid

      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end

      if (trim(.natural_orbitals.number_kind)== "real") then
         .::make_oscillator_orbital_grid_r(g,orb,pt)
      else
         DIE("complex case not yet implemented")
      end

   end

!  ===============
!  Current density
!  ===============

   make_j_grid
   ! Make the current density on ".plot_grid" using ".natural orbitals"
   ! and the ".occupation_numbers" vector.
   !    J(r) = J_p(r) + J_d(r)
   ENSURE(.plot_grid.created, "no grid")

      title :: STR
      arch :: ARCHIVE
      j,jd,jp :: MAT{REAL}*

      ! Make jd
      jd.create(.plot_grid.n_pt,3)
      .::make_jd_grid(jd)

      ! Make jp
      jp.create(.plot_grid.n_pt,3)
      .::make_jp_grid(jp)

      ! Add
      jd = jd + jp

      ! Dump?
      j => jd

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      arch.set(title,"current_density")
      arch.write(j)
      arch.set(title,"current_density",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(title,"current_norm_density",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(title,"current_density,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy
      jd.destroy

   end

   make_jd_grid
   ! Work out the diamagnetic current density on ".plot_grid" using ".natural
   ! orbitals" and the ".occupation_numbers" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)

   ENSURE(.plot_grid.created, "no grid")

      title :: STR
      arch :: ARCHIVE
      jd :: MAT{REAL}*

      ! Make grid
      jd.create(.plot_grid.n_pt,3)
      .::make_jd_grid(jd)

      ! Set title to be molecule name + sub-title from plot
      title = .name
      if (.plot_grid.plot_label/=" ") &
         title = trim(.name)//","//trim(.plot_grid.plot_label)

      ! Dump
      arch.set(title,"jd_density")
      arch.write(jd)
      arch.set(title,"jd_density",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(title,"jd_norm_density",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(title,"jd_density,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jd.destroy

   end

   make_jd_grid(jd)
   ! Work out the diamagnetic current density on ".plot_grid" using ".natural
   ! orbitals" and the ".occupation_numbers" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)
      jd :: MAT{REAL}, OUT

   ENSURE(.plot_grid.created, "no grid")
   ENSURE(jd.dim1==.plot_grid.n_pt, "wrong dim1, jd")
   ENSURE(jd.dim2==3, "wrong dim2, jd")

      r :: MAT{REAL}*
      rho :: VEC{REAL}*

      if (.B_field.norm<TOL(10)) then
         jd = ZERO
         return
      end

      rho.create(.plot_grid.n_pt)
      r.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(r)

      jd(:,1) = .B_field(2)*r(:,3) - .B_field(3)*r(:,2)
      jd(:,2) = .B_field(3)*r(:,1) - .B_field(1)*r(:,3)
      jd(:,3) = .B_field(1)*r(:,2) - .B_field(2)*r(:,1)

      .GRID:make_density_grid(rho,r)

      jd(:,1) = -HALF*jd(:,1)*rho
      jd(:,2) = -HALF*jd(:,2)*rho
      jd(:,3) = -HALF*jd(:,3)*rho

      r.destroy
      rho.destroy

   end

   make_jp_grid
   ! Work out the paramagnetic current density on ".plot_grid" using ".natural
   ! orbitals".  A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created("restricted_complex"), "no restricted_complex natural orbitals")

      arch :: ARCHIVE
      jp :: MAT{REAL}*


      ! Make grid
      jp.create(.plot_grid.n_pt,3)
      .::make_jp_grid(jp)

      ! Dump
      arch.set(.name,"jp_density_grid")
      arch.write(jp)
      arch.set(.name,"jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"jp_norm_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"jp_density_grid,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy

   end

   make_jp_grid(jp)
   ! Work out the paramagnetic current density "jp" on ".plot_grid" using ".natural
   ! orbitals" .
   !    J_p(r) = - (eh/m) Re [ \sum_i n_i \phi^*_i(r) \nabla \phi^*_i(r)
      jp :: MAT{REAL}

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created("restricted_complex"), "no restricted_complex natural orbitals")

      pt :: MAT{REAL}*
      P :: MAT{CPX}*
      D :: VEC{CPX}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      ! Make plot points
      n_pt = .plot_grid.n_pt
      pt.create(n_pt,3)
      .plot_grid.make_points(pt)

      ! Temporaries
      D.create(n_pt)
      P.create(n_pt,3)
      n_occ = .BASE:no_of_occupied_NOs

      ! Initialize
      jp = ZERO

      ! Loop over NO's
      do n = 1,n_occ

         .GRID:make_nabla_orbital_grid_c(P,D,.natural_orbitals.restricted_complex(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         jp(:,1) = jp(:,1) - occ*aimag(conjg(D(:))*P(:,1))
         jp(:,2) = jp(:,2) - occ*aimag(conjg(D(:))*P(:,2))
         jp(:,3) = jp(:,3) - occ*aimag(conjg(D(:))*P(:,3))

      end

      ! Clean
      P.destroy
      D.destroy
      pt.destroy

   end

   make_div_jp_grid
   ! Work out the divergence of the paramagnetic current density on ".plot_grid"
   ! using ".natural orbitals".  A Gnuplot ascii file is generated.

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(trim(.natural_orbitals.number_kind)=="complex", "natural orbitals not complex")
   ENSURE(.natural_orbitals.created("restricted_complex"), "no restricted_complex natural orbitals")

      arch :: ARCHIVE
      div_jp :: VEC{REAL}*

      ! Make
      div_jp.create(.plot_grid.n_pt)
      .::make_div_jp_grid(div_jp)

      ! Dump
      arch.set(.name,"div_jp_density_grid")
      arch.write(div_jp)
      arch.set(.name,"div_jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(div_jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      
      ! Clean
      div_jp.destroy

   end

   make_div_jp_grid(div_jp)
   ! Work out the divergence of the paramagnetic current density "jp" on ".plot_grid"
   ! using ".natural orbitals" .
   !  \nabla .  J_p(r) = - (eh/m) \sum_i n_i Im[ \phi^*_i(r) \nabla^2 \phi^_i(r) ]
      div_jp :: VEC{REAL}

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created("restricted_complex"), "no restricted_complex natural orbitals")

      pt :: MAT{REAL}*
      L :: MAT{CPX}*
      P :: MAT{CPX}*
      D :: VEC{CPX}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = .plot_grid.n_pt
      n_occ = .BASE:no_of_occupied_NOs

      pt.create(n_pt,3)
      D.create(n_pt)
      P.create(n_pt,3)
      L.create(n_pt,3)

      .plot_grid.make_points(pt)

      div_jp = ZERO

      do n = 1,n_occ
         .GRID:make_laplacian_orbital_grid_c(L,P,D,.natural_orbitals.restricted_complex(:,n), pt)
         occ = .occupation_numbers.restricted(n)
         div_jp = div_jp - occ*aimag(conjg(D(:))*(L(:,1)+L(:,2)+L(:,3)))
      end

      L.destroy
      P.destroy
      D.destroy
      pt.destroy

   end

   make_solenoidal_jp_grid
   ! Make the solenoidal paramagnetic current density grid "jp" on ".plot_grid"

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created("restricted_complex"), "no restricted complex density matrix")

      arch :: ARCHIVE
      jp :: MAT{REAL}*

      ! Make
      jp.create(.plot_grid.n_pt,3)
      .::make_solenoidal_jp_grid(jp,.density_matrix.restricted_complex)

      ! Dump
      arch.set(.name,"solenoidal_jp_density_grid")
      arch.write(jp)
      arch.set(.name,"solenoidal_jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"solenoidal_jp_norm_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"solenoidal_jp_density_grid,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy

   end

   make_solenoidal_jp_grid(jp,dens)
   ! Make the solenoidal paramagnetic current density grid "jp" on ".plot_grid"
   ! using AO density matrix "dens"
      jp :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Dba :: MAT{CPX}*
      pt,Jxab,Jyab,Jzab :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb,k :: INT
      fac :: REAL
      sh :: SHELL2

      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)

      jp = ZERO

      do q = 1,.n_shell_pairs

        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (fa==fb) fac=ONE

        Jxab.create(na,nb)
        Jyab.create(na,nb)
        Jzab.create(na,nb)

        do k = 1,.plot_grid.n_pt
          sh.make_solenoidal_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_product_with(aimag(Dba))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_product_with(aimag(Dba))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_product_with(aimag(Dba))
        end

        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        sh.destroy_ptr_part

      end

      pt.destroy

      jp.zero_small_values(TOL(10))

   end

   make_irrotational_jp_grid
   ! Make the irrotational paramagnetic current density grid "jp" on ".plot_grid"

   ENSURE(.plot_grid.destroyed,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created("restricted_complex"), "no restricted complex density matrix")

      arch :: ARCHIVE
      jp :: MAT{REAL}*

      ! Make
      jp.create(.plot_grid.n_pt,3)
      .::make_irrotational_jp_grid(jp,.density_matrix.restricted_complex)

      ! Dump
      arch.set(.name,"irrotational_jp_density_grid")
      arch.write(jp)
      arch.set(.name,"irrotational_jp_density_grid",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"irrotational_jp_norm_density_grid",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"irrotational_jp_density_grid,normalized",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy

   end

   make_irrotational_jp_grid(jp,dens)
   ! Make the irrotational paramagnetic current density grid "jp" on ".plot_grid"
   ! using AO density matrix "dens"
      jp :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Dba :: MAT{CPX}*
      pt,Jxab,Jyab,Jzab :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb,k :: INT
      fac :: REAL
      sh :: SHELL2

      pt.create(.plot_grid.n_pt,3)

      .plot_grid.make_points(pt)

      jp = ZERO

      do q = 1,.n_shell_pairs

        .BASE:get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (fa==fb) fac=ONE

        Jxab.create(na,nb)
        Jyab.create(na,nb)
        Jzab.create(na,nb)

        do k = 1,.plot_grid.n_pt
          sh.make_irrotational_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_product_with(aimag(Dba))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_product_with(aimag(Dba))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_product_with(aimag(Dba))
        end

        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        sh.destroy_ptr_part

      end

      pt.destroy

      jp.zero_small_values(TOL(10))

   end

end
