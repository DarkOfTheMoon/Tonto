!
! Copyright (C) Daniel Grimwood, 2003
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!*******************************************************************************

module VEC{PERIODIC_FMM_LEVEL}

  implicit none

contains

!*******************************************************************************
! Memory allocation
!*******************************************************************************

   create(lb,ub) ::: get_from(VEC{OBJECT}), leaky
   ! Create the vector with lower bound "lb", upper bound "ub"
   end

   destroy ::: get_from(VEC{OBJECT}), leaky
   ! Destroy space for object
   end

   nullify_ptr_part ::: get_from(VEC{OBJECT})
   ! Nullify the pointer parts of self
   end

   destroy_ptr_part ::: get_from(VEC{OBJECT})
   ! Destroy the pointer parts of self
   end

   set_defaults
   ! Set default values.
   end

!*******************************************************************************
! Misc
!*******************************************************************************

  set_first_level(n_div)
  ! Set the variables that go into the first level.
    n_div :: INT, IN
    self(1).set_number_of_divisions(n_div)
  end

  make_all_levels
  ! Make the multipole expansion for each level.
    ENSURE(.dim>1,"must have at least two levels")
    ENSURE(self(1).level_number >= 0, "starting level must not be negative")
    i,h,k,l,n_a,n_b,n_c,l_n :: INT
    do i=2,.dim
      self(i).make_level_from_previous_level(self(i-1))
    end
  end

  check_levels_match
  ! Check whether the levels are all related.
    ENSURE(.dim>1,"must have at least two levels")
    i,n_a,n_b,n_c :: INT
    centre :: VEC{REAL}(3)
    div_match,centre_match :: BIN
    n_a = self(1).divisions(1)
    n_b = self(1).divisions(2)
    n_c = self(1).divisions(3)
    centre = self(1).box_centre
    div_match = TRUE
    centre_match = TRUE
    do i=1,.dim
      if (NOT n_a==self(i).divisions(1)) div_match = FALSE
      if (NOT n_b==self(i).divisions(2)) div_match = FALSE
      if (NOT n_c==self(i).divisions(3)) div_match = FALSE
      if (NOT centre.same_as(self(i).box_centre)) centre_match = FALSE
    end
    ENSURE(div_match,"number of divisions not consistent")
    ENSURE(centre_match,"box centres not consistent")
  end

end
