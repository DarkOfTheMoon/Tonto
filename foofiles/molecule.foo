!===============================================================================
!
! MOLECULE: An object representation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!===============================================================================

module MOLECULE

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

   saved_self :: MOLECULE*, private

   debug_list :: VEC{STR}*  DEFAULT_NULL

contains

!  ==========================
!  Create and destroy methods
!  ==========================

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, recursive
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the molecule

      nullify(.atom)
      nullify(.atom_group)

      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      nullify(.plot_grid)
      nullify(.interpolator)
      nullify(.isosurface)

      nullify(.becke_grid)

      nullify(.crystal)
      nullify(.cluster)
      nullify(.cif)
      nullify(.pointgroup)

      nullify(.atom_for_shell)
      nullify(.atom_shell_for_shell)
      nullify(.first_shell_for_atom)
      nullify(.last_shell_for_atom)
      nullify(.basis_shell_for_shell)
      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.angular_moment_for_shell)
      nullify(.first_basis_fn_for_atom)
      nullify(.last_basis_fn_for_atom)
      nullify(.precomputed_basis_shellpair)
      nullify(.max_I)
      nullify(.overlapping_atoms)
      nullify(.overlapping_atoms_for_atom)

      nullify(.scfdata)

      nullify(.orbital_energies)
      nullify(.molecular_orbitals)
      nullify(.density_matrix)
      nullify(.old_density_matrix)
      nullify(.delta_density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation_numbers)
      nullify(.overlap_matrix)
      nullify(.overlap_eigenvectors)
      nullify(.overlap_eigenvalues)
      nullify(.max_S)
      nullify(.core_matrix)
      nullify(.fock_matrix)
      nullify(.fock_2e_matrix)
      nullify(.constraint_matrix)

      nullify(.roby)
      nullify(.saved)
      nullify(.localiser)

      nullify(.U_electric_dipole)
      nullify(.dipole_polarisability)
      nullify(.dipole_hyperpolarisability)

   end

   destroy_ptr_part ::: recursive, leaky
   ! Destroy the pointer parts of a molecule object

      g :: INT
      mol :: MOLECULE*

      ! Saved molecule
      .saved.destroy

      ! Atoms (nullify pointed-to atoms before)
      .atom.destroy

      ! Atom_groups
      if (.atom_group.created) then
         do g = 1,.atom_group.dim
            mol => .atom_group(g).mol
            if (mol.destroyed) cycle
            mol.atom.nullify_ptr_part ! do not destroy these
            nullify(mol.basis)        ! do not destroy this
            nullify(mol.slaterbasis)  ! do not destroy this
            nullify(mol.coppensbasis) ! do not destroy this
            mol.destroy
         end
      end
      .atom_group.destroy

      ! Destroy bases and pointed
      .basis.destroy
      .slaterbasis.destroy
      .coppensbasis.destroy

      ! Grids, interpolators & plots
      .plot_grid.destroy
      .interpolator.destroy
      .isosurface.destroy
      .becke_grid.destroy

      ! Crystals and clusters
      .crystal.destroy
      .cluster.destroy
      .cif.destroy
      .pointgroup.destroy

      ! Basis set & integral info arrays
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .basis_shell_for_shell.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .precomputed_basis_shellpair.destroy
      .max_I.destroy
      .overlapping_atoms.destroy
      .overlapping_atoms_for_atom.destroy

      ! SCF data
      .scfdata.destroy

      ! SCF info
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .max_S.destroy

      ! SCF intermediates
      .core_matrix.destroy
      .fock_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy

      ! Bond analysis
      .roby.destroy

      ! Localised MO's
      .localiser.destroy

      ! CPHF and response properties
      .U_electric_dipole.destroy
      .dipole_polarisability.destroy
      .dipole_hyperpolarisability.destroy

   end

   destroy_matrices ::: leaky
   ! Destroy the matrices of a molecule object
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy

      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .max_S.destroy
      .core_matrix.destroy
      .fock_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy

      .atom_group.destroy

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   save ::: leaky
   ! Save everything about "self" in ".saved".
      self :: PTR
      saved :: MOLECULE*
      saved => self
      .create
      .saved => saved
   end

   unsave ::: leaky
   ! Revert back to a previously saved molecule stored in .saved, and
   ! destroy everything about the current molecule in "self".
   ! WARNING: be careful when setting up self, make sure none of its pointer
   ! parts refer to .saved information.
      self :: PTR
   ENSURE(.saved.created,"no previous settings")
      saved :: MOLECULE*
      saved => .saved
      nullify(.saved) ! don't destroy this
      .destroy        ! careful no .saved information is destroyed
      self => saved   ! restore
   end

   create_copy(mol) ::: leaky
   ! Create a copy of "mol"
      self :: PTR
      mol :: MOLECULE, IN
      .create
      .copy(mol)
   end

   copy(mol) ::: leaky
   ! Set self to be a copy of "mol"
      mol :: MOLECULE, IN

      ! Copy all non-pointer fields
      self = mol

      ! Create a copy of all pointer fields
      .nullify_ptr_part

      if (mol.atom.created)                       .atom.create_copy(mol.atom)

      if (mol.basis.created)                      .basis.create_copy(mol.basis)
      if (mol.slaterbasis.created)                .slaterbasis.create_copy(mol.slaterbasis)
      if (mol.coppensbasis.created)               .coppensbasis.create_copy(mol.coppensbasis)

      if (mol.plot_grid.created)                  .plot_grid.create_copy(mol.plot_grid)
      if (mol.interpolator.created)               .interpolator.create_copy(mol.interpolator)
      if (mol.isosurface.created)                 .isosurface.create_copy(mol.isosurface)

      if (mol.becke_grid.created)                 .becke_grid.create_copy(mol.becke_grid)

      if (mol.crystal.created)                    .crystal.create_copy(mol.crystal)
      if (mol.cluster.created)                    .cluster.create_copy(mol.cluster)
      if (mol.cif.created)                        .cif.create_copy(mol.cif)
      if (mol.pointgroup.created)                 .pointgroup.create_copy(mol.pointgroup)

      if (mol.saved.created)                      .saved.create_copy(mol.saved)

      if (mol.atom_for_shell.created)             .atom_for_shell.create_copy(mol.atom_for_shell)
      if (mol.atom_shell_for_shell.created)       .atom_shell_for_shell.create_copy(mol.atom_shell_for_shell)
      if (mol.first_shell_for_atom.created)       .first_shell_for_atom.create_copy(mol.first_shell_for_atom)
      if (mol.last_shell_for_atom.created)        .last_shell_for_atom.create_copy(mol.last_shell_for_atom)
      if (mol.first_basis_fn_for_shell.created)   .first_basis_fn_for_shell.create_copy(mol.first_basis_fn_for_shell)
      if (mol.last_basis_fn_for_shell.created)    .last_basis_fn_for_shell.create_copy(mol.last_basis_fn_for_shell)
      if (mol.angular_moment_for_shell.created)   .angular_moment_for_shell.create_copy(mol.angular_moment_for_shell)
      if (mol.overlapping_atoms.created)          .overlapping_atoms.create_copy(mol.overlapping_atoms)
      if (mol.overlapping_atoms_for_atom.created) .overlapping_atoms_for_atom.create_copy(mol.overlapping_atoms_for_atom)
      if (mol.first_basis_fn_for_atom.created)    .first_basis_fn_for_atom.create_copy(mol.first_basis_fn_for_atom)
      if (mol.last_basis_fn_for_atom.created)     .last_basis_fn_for_atom.create_copy(mol.last_basis_fn_for_atom)

      if (mol.scfdata.created)                    .scfdata.create_copy(mol.scfdata)

      if (mol.orbital_energies.created)           .orbital_energies.create_copy(mol.orbital_energies)
      if (mol.molecular_orbitals.created)         .molecular_orbitals.create_copy(mol.molecular_orbitals)
      if (mol.density_matrix.created)             .density_matrix.create_copy(mol.density_matrix)
      if (mol.old_density_matrix.created)         .old_density_matrix.create_copy(mol.old_density_matrix)
      if (mol.delta_density_matrix.created)       .delta_density_matrix.create_copy(mol.delta_density_matrix)
      if (mol.natural_orbitals.created)           .natural_orbitals.create_copy(mol.natural_orbitals)
      if (mol.occupation_numbers.created)         .occupation_numbers.create_copy(mol.occupation_numbers)
      if (mol.overlap_matrix.created)             .overlap_matrix.create_copy(mol.overlap_matrix)
      if (mol.overlap_eigenvectors.created)       .overlap_eigenvectors.create_copy(mol.overlap_eigenvectors)
      if (mol.overlap_eigenvalues.created)        .overlap_eigenvalues.create_copy(mol.overlap_eigenvalues)
      if (mol.max_S.created)                      .max_S.create_copy(mol.max_S)

      if (mol.core_matrix.created)                .core_matrix.create_copy(mol.core_matrix)
      if (mol.fock_matrix.created)                .fock_matrix.create_copy(mol.fock_matrix)
      if (mol.fock_2e_matrix.created)             .fock_2e_matrix.create_copy(mol.fock_2e_matrix)
      if (mol.constraint_matrix.created)          .constraint_matrix.create_copy(mol.constraint_matrix)

      if (mol.atom_group.created)                 .atom_group.create_copy(mol.atom_group)

      if (mol.U_electric_dipole.created)          .U_electric_dipole.create_copy(mol.U_electric_dipole)
      if (mol.dipole_polarisability.created)      .dipole_polarisability.create_copy(mol.dipole_polarisability)
      if (mol.dipole_hyperpolarisability.created) .dipole_hyperpolarisability.create_copy(mol.dipole_hyperpolarisability)
   end

!  ===========
!  Set methods
!  ===========

   set_defaults ::: leaky
   ! Set up a default molecule

      .name = "unknown"
      .charge = 0
      .spin_multiplicity = 1
      .n_e = 0
      .n_a = 0
      .n_b = 0
      .E_field = ZERO
      .B_field = ZERO
      .gauge_origin = ZERO

      .n_atom = 0
      .atom_info_made = FALSE
      .n_atom_kind = 0

      .n_bf = 0
      .basis_name = " "
      .n_basis = 0
      .basis_l_max = -1
      .use_spherical_basis = FALSE
      .n_bf = 0
      .n_prim = 0
      .slaterbasis_name = " "
      .coppensbasis_name = " "
      .basis_info_made = FALSE

      .use_interpolators = TRUE

      .n_shell = 0
      .n_shell_pairs = 0
      .n_unique_shells = 0

      .CX_file_name = " "
      .CX_uses_angstrom = FALSE

      .Hirshfeld_atom_info_made = FALSE
      .atomic_polarisabilities_made = FALSE

      .invariom_database_directory = " "
      .invariom_refinement = FALSE

      if (.atom.created) then
        .name = .chemical_formula
        .spin_multiplicity = .default_spin_multiplicity
        .set_atom_info
      end

   end

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self
   end

   set_atom_info ::: leaky
   ! Set the associated atom information, including the number of alpha and beta
   ! electrons. NOTE: The multiplicity must be right for this to work.  The
   ! routine tries to reassign the multiplicity so that it will be consistent
   ! with the charge.
   ENSURE(.atom.created,"no atom info")
   ENSURE(.atom_group.destroyed,"don't reset atom info after groups are defined!")

      ! Finalize
      .atom.update

      ! No. of atoms
      .n_atom = .atom.dim

      ! No. of atom kinds
      .n_atom_kind = maxval(.atom.kind)

      ! Reset multiplicity?
      if (NOT .has_valid_no_of_beta_electrons) then
         WARN("Inconsistent charge and multiplicity")
         WARN("Reassigning the multiplicity")
         .spin_multiplicity = .default_spin_multiplicity
      end

      ! Now can set # of electrons
      .n_e = .no_of_electrons
      .n_a = .no_of_alpha_electrons
      .n_b = .no_of_beta_electrons

      .atom_info_made = TRUE

   end

   resolve_basis_info ::: leaky
   ! Match the basis set labels for every atom with the actual atomic basis set.
   ! Also perform any finalization procedures to fully define all objects.
   ! This version is supposed to work for multiple bases.
      .resolve_coppensbases
      .resolve_slaterbases
      .resolve_gaussianbases
   end

   resolve_gaussianbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.destroyed) return

      if (.n_atom<1) return

      if (.atom.bases_are_resolved) then
         stdout.flush
         stdout.text("Gaussian bases all resolved")
         return
      end

      ! Resolve from a library .....
      if (.basis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.basis.created) .basis.renormalise

         ! Read the basis from the library
         library = .basis.library_file(.basis_name)
         library_basis_labels => .atom.library_basis_labels(.basis_name)
         .basis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         stdout.flush
         stdout.text("Added "//trim(n_unique.to_str)//" bases from library: "//trim(.basis_name))

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.basis.created) then
            .basis.set_spherical(.use_spherical_basis)
            .atom.resolve_bases(.basis,.basis_name)
            .atom.set_basis_kind("gaussian")

            ! Unnormalise if completely done
            .basis.unnormalise        
            .set_basis_info         
         end

      ! Resolve from existing .basis .....
      else if (.basis.created) then

            .basis.set_spherical(.use_spherical_basis)
            .atom.resolve_bases(.basis)
            .atom.set_basis_kind("gaussian")

            ! Unnormalise if completely done
            if (.atom.bases_are_resolved) .set_basis_info          
      end

      if (.basis.created) then
      if (.atom.bases_are_resolved) then
         stdout.flush
         stdout.text("Gaussian bases all resolved")
      else
         stdout.flush
         WARN("not all Gaussian bases were resolved")
      end
      end

   end

   resolve_slaterbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.destroyed) return

      if (.n_atom<1) return

      if (.atom.slaterbases_are_resolved) then
         stdout.flush
         stdout.text("Slater bases all resolved")
         return
      end

      ! Resolve from a library .....
      if (.slaterbasis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.slaterbasis.created) .slaterbasis.renormalise

         ! Read the basis from the library
         library = .slaterbasis.library_file(.slaterbasis_name)
         library_basis_labels => .atom.library_basis_labels(.slaterbasis_name)
         .slaterbasis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         stdout.flush
         stdout.text("Added "//trim(n_unique.to_str)//" bases from library: "//trim(.slaterbasis_name))

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.slaterbasis.created) then
            .atom.resolve_bases(.slaterbasis,.slaterbasis_name)
            .atom.set_basis_kind("slater")

            ! Unnormalise if completely done
            .slaterbasis.unnormalise        
         end

      ! Resolve from existing .basis .....
      else if (.slaterbasis.created) then

            .atom.resolve_bases(.slaterbasis)
            .atom.set_basis_kind("slater")

      end

      if (.slaterbasis.created) then
      if (.atom.slaterbases_are_resolved) then
         stdout.flush
         stdout.text("Slater bases all resolved")
      else
         stdout.flush
         WARN("not all Slater bases were resolved")
      end
      end

   end

   resolve_coppensbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.destroyed) return

      if (.n_atom<1) return

      if (.atom.coppensbases_are_resolved) then
         stdout.flush
         stdout.text("Coppens bases all resolved")
         return
      end

      ! Resolve from a library .....
      if (.coppensbasis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.coppensbasis.created) .coppensbasis.renormalise

         ! Read the basis from the library
         library = .coppensbasis.library_file(.coppensbasis_name)
         library_basis_labels => .atom.library_basis_labels(.coppensbasis_name)
         .coppensbasis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         stdout.flush
         stdout.text("Added "//trim(n_unique.to_str)//" bases from library: "//trim(.coppensbasis_name))

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.coppensbasis.created) then
            .atom.resolve_bases(.coppensbasis,.coppensbasis_name)
            .atom.set_basis_kind("coppens")

            ! Unnormalise if completely done
            .coppensbasis.unnormalise        
         end

      ! Resolve from existing .basis .....
      else if (.coppensbasis.created) then

            .atom.resolve_bases(.coppensbasis)
            .atom.set_basis_kind("coppens")

      end

      if (.coppensbasis.created) then
      if (.atom.coppensbases_are_resolved) then
         stdout.flush
         stdout.text("Coppens bases all resolved")
      else
         stdout.flush
         WARN("not all Coppens bases were resolved")
      end
      end

   end

   resolve_axis_system
   ! Change the axis system to crystal coordinates, if required.
      if (.crystal.destroyed) return
      if (.atom.destroyed) return
      .atom.resolve_axis_system(.crystal.unit_cell)
   end

   change_axis_system_to
   ! Change the axis system to crystal coordinates, if required.
      axis_system :: STR
      if (.crystal.destroyed) return
      if (.atom.destroyed) return
      stdin.read(axis_system)
      .atom.change_axis_system_to(axis_system,.crystal.unit_cell)
   end

   set_basis_info ::: leaky
   ! Set the molecule basis set information; the atom list must exist.
   ENSURE(.atom.created,"no atom info")

      if (.basis.destroyed) return

      if (NOT .atom.bases_are_resolved) then

         .basis_info_made = FALSE

      else

         .n_basis = size(.basis)
         .n_bf = .atom.n_bf
         .n_prim = .atom.n_prim
         .n_shell = .atom.n_shell
         .n_shell_pairs = .no_of_shell_pairs

         .make_shell_info ! leaky

         .basis_info_made = TRUE

      end

   end

   set_basis_name(name) ::: leaky
   ! Set a gaussian *library* basis set name
      name :: STR
   ENSURE(all(name/=non_gaussian),"basis "//trim(name)//"is not a gaussian basis")
      non_gaussian :: VEC{STR}(len=17,4) = ["Clementi-Roetti  ","Thakkar          ","vanLenthe-Barends","Coppens          "]

      ! Set the basis kind
      .basis_name = name

      ! Destroy links to previous bases
      if (.atom.created) .atom.nullify_basis_part 
      .basis.destroy

      ! Make fresh basis set links (might be leaky)
      .resolve_gaussianbases

   end

   set_slaterbasis_name(name) ::: leaky
   ! Set a slater *library* basis set name
      name :: STR
   ENSURE(any(name==slater),"basis "//trim(name)//"is not a known slater basis")
      slater :: VEC{STR}(len=17,3) = ["Clementi-Roetti  ","Thakkar          ","vanLenthe-Barends"]

      ! Set the basis kind
      .slaterbasis_name = name

      ! Destroy links to previous bases
      if (.atom.created) .atom.nullify_slaterbasis_part 
      .slaterbasis.destroy

      ! Make fresh basis set links (might be leaky)
      .resolve_slaterbases

   end

   set_coppensbasis_name(name) ::: leaky
   ! Set a coppens *library* basis set name
      name :: STR
   ENSURE(name=="Coppens","basis "//trim(name)//"is not a known coppens basis")

      ! Set the basis kind
      .coppensbasis_name = name

      ! Destroy links to previous bases
      if (.atom.created) .atom.nullify_coppensbasis_part 
      .coppensbasis.destroy

      ! Make fresh basis set links (might be leaky)
      .resolve_coppensbases

   end

   assign_NOs_to_MOs ::: leaky
   ! Assign the natural orbitals to be the molecular_orbitals
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")
      NO_kind :: STR
      .natural_orbitals.destroy
      .natural_orbitals.create_copy(.molecular_orbitals)
      NO_kind = .natural_orbitals.spinorbital_kind
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,NO_kind)
      .occupation_numbers.set_to_zero
      .set_scf_occupations(NO_kind)
   end

   assign_MOs_to_NOs ::: leaky
   ! Assign the MOs to be the same as the natural orbitals
      NO_kind :: STR
      .molecular_orbitals.destroy
      .molecular_orbitals.create_copy(.natural_orbitals)
      NO_kind = .natural_orbitals.spinorbital_kind
      .occupation_numbers.destroy
      .occupation_numbers.create(NO_kind)
      .occupation_numbers.set_to_zero
      .set_scf_occupations(NO_kind)
   end

   set_scf_occupations(NO_kind)
   ! Set the SCF occupation numbers for the natural orbitals
      NO_kind :: STR
      select case (NO_kind)
         case ("restricted")
            .occupation_numbers.restricted(1:.n_a) = TWO
         case ("unrestricted")
            .occupation_numbers.alpha(1:.n_a) = ONE
            .occupation_numbers.beta(1:.n_b) = ONE
         case ("general")
            .occupation_numbers.general(1:.n_e) = ONE
         case ("restricted_complex")
            .occupation_numbers.restricted(1:.n_a) = TWO
         case ("unrestricted_complex")
            .occupation_numbers.alpha(1:.n_a) = ONE
            .occupation_numbers.beta(1:.n_b) = ONE
         case ("general_complex")
            .occupation_numbers.general(1:.n_e) = ONE
      end
   end

!  ===========================
!  VEC{ATOM} information methods
!  ===========================

   default_spin_multiplicity result (res)
   ! Return the default multiplicity for a molecule.
      self :: IN
      res :: INT

   ENSURE(.atom.created,"no atom info")

      n_e :: INT

      n_e = .no_of_electrons

      if (size(.atom)==1) then; res = .atom(1).ground_state_multiplicity(n_e)
      else;                     res = mod(n_e,2) + 1
      end

   end

   nuclear_repulsion_energy result (res)
   ! Return the nuclear repulsion energy
      res :: REAL

   ENSURE(.atom.created,"atom list required")

      i :: INT
      scf_kind :: STR

      scf_kind = "unknown"
      if (.scfdata.created) scf_kind = .scfdata.scf_kind

      i = 0
      res = ZERO
      select case (scf_kind)
         case ("embedded_rhf"); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
         case ("crystal_rhf "); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
         case default;          res = .atom.nuclear_repulsion_energy
      end

   end

   chemical_formula(with_spaces) result (res)
   ! Return the chemical formula for the molecule, as a string, in alphabetical
   ! order of elements
      with_spaces :: BIN, optional
      res :: STR
   ENSURE(.atom.created,"atom list required")
      res = .atom.chemical_formula(with_spaces)
   end

   centre_of_mass result(centre)
   ! Return the centre of mass
      centre :: VEC{REAL}(3)
   ENSURE(.atom.created,"atom list required")
      centre = .atom.centre_of_mass
   end

   centre_of_atoms result(centre)
   ! Return the centroid of the atom positions
      centre :: VEC{REAL}(3)
   ENSURE(.atom.created,"atom list required")
      centre = .atom.centre_of_atoms
   end

   change_to_principal_axes
   ! Move the origin to the centre of mass and change to the principal axis
   ! coordinate system
   ENSURE(.atom.created,"atom list required")
      .atom.change_to_principal_axes
   end

   change_to_principal_top_axes
   ! Move the origin to the centre of mass and change to the principal axis
   ! coordinate system, where the symmetric top axis is the z axis and where the
   ! determinant of the axes transformation is 1.
   ENSURE(.atom.created,"atom list required")
      .atom.change_to_principal_top_axes
   end

   molecular_weight result (res)
   ! Return the molceular weight
      res :: REAL
   ENSURE(.atom.created,"atom list required")
      res = .atom.molecular_weight
   end

   reduced_mass result (res)
   ! Return the reduced mass
      res :: REAL
   ENSURE(.atom.created,"atom list required")
      res = .atom.reduced_mass
   end

   move_origin_to_centre_of_mass
   ! Move the origin to the centre of mass
   ENSURE(.atom.created,"atom list required")

      .atom.move_origin_to_centre_of_mass

      if (.becke_grid.created) .becke_grid.set_grid_data(.atom) ! leaky

   end

   move_origin_to_centre_of_atoms
   ! Move the origin to the centre of atoms
   ENSURE(.atom.created,"atom list required")

      .atom.move_origin_to_centre_of_atoms

      if (.becke_grid.created) .becke_grid.set_grid_data(.atom) ! leaky

   end

   move_origin
   ! Move the origin by a user specified vector
   ENSURE(.atom.created,"atom list required")
   ENSURE(stdin.buffer.n_items==4 OR stdin.buffer.n_items==5,"origin shift needed on same line")
      shift :: VEC{REAL}(3)

      stdin.read(shift)
      .atom.translate_by(shift)

      if (.becke_grid.created) .becke_grid.set_grid_data(.atom) ! leaky

   end

   atom_index_from_position(pos) result (res)
   ! Return the index of atom from its position "pos"
      pos :: VEC{REAL}(3)
      res :: INT
   ENSURE(.atom.created,"atom list required")
      res = .atom.atom_index_from_position(pos)
   end

   put_coordinates_to(g,skip_dummies)
   ! Put the atom coordinates to "g"
      g :: MAT{REAL}
      skip_dummies :: BIN, IN, optional

   ENSURE(.atom.created,"no atom list")

      .atom.put_coordinates_to(g,skip_dummies)

   end

!  ================================
!  VEC{ATOM} shell extraction methods
!  ================================

   get_shell(shell,index) ::: leaky
   ! Get basis set "shell" corresponding to "index"
      index :: INT, IN
      shell :: SHELL, OUT
      aa,sa :: INT
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(.atom(aa).basis.shell(sa) )
   end

   get_shell(shell,index) ::: leaky
   ! Update the shell1 "shell".
      index :: INT, IN
      shell :: SHELL1, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   get_shell(shell,index,fa,la) ::: leaky
   ! Update the shell1 "shell".
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   get_shell(shell,index,fa,la,na) ::: leaky
   ! Update the shell1 "shell".
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la,na :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      na = la - fa + 1

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

!  =================
!  Atom pair indices
!  =================

   get_atom_pair_indices(index,a,b,fa,la,na,fb,lb,nb) 
   ! Return the atom indicies "a" and "b" which map to an atom-pair "index".
   ! Also get "fa", "la" and "fb", "lb", the indices of first and last basis
   ! functions for atoms "a" and "b", and "na" and "nb", the number of basis
   ! functions on those atoms, respectively. NOTE: "fa" and "fb" are actually
   ! the first basis functions for atoms "a" and "b" *minus 1*.  
      index :: INT, IN
      a,b,fa,la,na,fb,lb,nb :: INT, OUT
      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2
      fa = .first_basis_fn_for_atom(a) - 1
      la =  .last_basis_fn_for_atom(a)
      na = la - fa
      fb = .first_basis_fn_for_atom(b) - 1
      lb =  .last_basis_fn_for_atom(b)
      nb = lb - fb
   end


   is_overlapping_atom(a,b) result (res)
   ! Return TRUE if atoms "a" and "b" overlap.
      a,b :: INT, IN
      res :: BIN
   ENSURE(.overlapping_atoms.created,"no .overlapping_atoms")
      aa,bb,ab :: INT
      if (a==b) then
         res = TRUE
      else
         aa = max(a,b)
         bb = min(a,b)
         ab = int(HALF*aa*(aa-1)) + bb
         res = .overlapping_atoms(ab)
      end
   end

   is_overlapping_atom(a,list) result (res)
   ! Return TRUE if atom "a" overlaps with *any* atoms in the "list".
      a :: INT, IN
      list :: VEC{INT}, IN
      res :: BIN
   ENSURE(.overlapping_atoms.created,"no .overlapping_atoms")
      i,b,aa,bb,ab :: INT
      res = FALSE
      do i = 1,list.dim
         b = list(i)
         if (a==b) then
            res = TRUE
            exit
         else
            aa = max(a,b)
            bb = min(a,b)
            ab = int(HALF*aa*(aa-1)) + bb
            if (.overlapping_atoms(ab)) then
               res = TRUE
               exit
            end
         end
      end
   end

   overlapping_atoms_for(list) result (res) ::: leaky
   ! Return the list of atoms which overlaps with those in "list".
      list :: VEC{INT}, IN
      res :: VEC{INT}*
      a,k :: INT
      res.create(.n_atom)
      k = 0
      do a = 1,.n_atom
         if (NOT .is_overlapping_atom(a,list)) cycle
         k = k + 1
         res(k) = a
      end
      res.shrink(k)
   end

   make_max_S_for_shell_pairs(max_S)
   ! Make "max_S", the maximum of the overlap integrals between basis
   ! functions in pairs of shells.
      max_S :: VEC{REAL}

   ENSURE(.overlap_matrix.created,"no overlap_matrix")
   ENSURE(max_S.dim==.no_of_shell_pairs,"wrong size, S_max")

      ab,a,b,fa,fb,la,lb :: INT

      do ab = 1,.n_shell_pairs
         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)
         max_S(ab) = maxval(abs(.overlap_matrix(fa:la,fb:lb)))
      end

   end

! Below does not work ... but it does with lower cutoff

   make_overlapping_atoms ::: leaky
   ! Make the list of overlapping atoms
   ENSURE(.basis_info_made,"no basis set")
   ENSURE(.becke_grid.created,"no becke_grid")
      r_max :: VEC{REAL}*
      d :: VEC{REAL}(3)
      r :: REAL
      a,b,ab,n_atom_pairs :: INT

      n_atom_pairs = .no_of_atom_pairs

      ! Overlapping atoms pair array
      .overlapping_atoms.destroy
      .overlapping_atoms.create(n_atom_pairs)

      ! Overlapping atoms list array
      .overlapping_atoms_for_atom.destroy
      .overlapping_atoms_for_atom.create(.n_atom)

      ! Make the maximum radii
      r_max.create(.n_atom)
      do a = 1,.n_atom
         ! sqrt because we are dealing with overlaps
         r_max(a) = .atom(a).r_max(.becke_grid.basis_function_cutoff)
      end 
      .put_debug(r_max,"make_overlapping_atoms: r_max")

      ! Make the overlapping atom arrays
      do ab = 1,n_atom_pairs
         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2
         d = .atom(a).position - .atom(b).position
         r = sqrt(dot_product(d,d))
         if (r>(r_max(a)+r_max(b))) then
            .overlapping_atoms(ab) = FALSE
         else 
            .overlapping_atoms(ab) = TRUE
         end
      end

      ! Make the overlapping atom arrays
      do a = 1,.n_atom

         ! Atom a overlaps itself
         .overlapping_atoms_for_atom(a).element.append(a)

         ! Loop over other atoms "b"
         do b = 1,a-1

            ! Distance "r" to atom "b"
            d = .atom(a).position - .atom(b).position
            r = sqrt(dot_product(d,d))
            if (r>(r_max(a)+r_max(b))) cycle

            ! Atoms "a" and "b" overlap
            .overlapping_atoms_for_atom(a).element.append(b)
            .overlapping_atoms_for_atom(b).element.append(a)

         end

      end

      r_max.destroy

      ! Reorder the lists
      do a = 1,.n_atom
         .overlapping_atoms_for_atom(a).element.sort
      end 

   end

!   make_overlapping_atoms2 ::: leaky
!   ! Make the list of overlapping atoms
!   ENSURE(.basis_info_made,"no basis set")
!   ENSURE(.scfdata.created,"no scfdata")
!      S_max :: VEC{REAL}*
!      n_atom_pairs :: INT
!      n_atom_pairs = .no_of_atom_pairs
!      .overlapping_atoms.destroy
!      .overlapping_atoms.create(n_atom_pairs)
!      S_max.create(n_atom_pairs)
!      .make_S_max_for_atom_pairs(S_max)
!      .overlapping_atoms = S_max>.scfdata.atom_overlap_cutoff
!      S_max.destroy
!   end
!
!   make_S_max_for_atom_pairs(S_max)
!   ! Make "S_max", the maximum of the overlap integrals between *pairs of atoms*
!      S_max :: VEC{REAL}
!   ENSURE(S_max.dim==.no_of_atom_pairs,"wrong size, S_max")
!      ab,a,b,fa,fb,la,lb :: INT
!      .get_overlap_matrix
!      do ab = 1, .no_of_atom_pairs
!       a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
!       b = ab - a*(a-1)/2
!       fa = .first_basis_fn_for_atom(a)
!       la = .last_basis_fn_for_atom(a)
!       fb = .first_basis_fn_for_atom(b)
!       lb = .last_basis_fn_for_atom(b)
!       S_max(ab) = maxval(.overlap_matrix(fa:la,fb:lb))
!      end
!   end

!  ==================
!  Shell pair indices
!  ==================

   get_shell_pair_indices(index,a,b,fa,la,na,fb,lb,nb)
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      a,b,fa,la,fb,lb,na,nb :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      na = la - fa + 1
      nb = lb - fb + 1

   end

   get_shell_pair_indices(index,a,b,fa,la,na,fb,lb,nb,atom_a,atom_b)
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
   ! Also return the atom indices "atom_a" and "atom_b" for each shell.
      index :: INT, IN
      a,b,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      na = la - fa + 1
      nb = lb - fb + 1

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

   end

!  ===========
!  Shell pairs
!  ===========

   get_precomputed_shell_pair(shell,index,fa,la,na,fb,lb,nb) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      fa,la,na,fb,lb,nb :: INT, OUT
      a,b,aa,sa,bb,sb :: INT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb), & 
         .atom(aa).position,.atom(bb).position, &
         aa==bb,skip=FALSE)

      .put_debug(shell,"get_precomputed_shell_pair: shell")

   end

   get_precomputed_shell_pair(shell,index,fa,la,na,fb,lb,nb,atom_a,atom_b) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      fa,la,na,fb,lb,nb,atom_a,atom_b :: INT, OUT
      a,b,sa,sb :: INT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb), & 
         .atom(atom_a).position,.atom(atom_b).position, &
         atom_a==atom_b,FALSE)

   end

!  =====================
!  Shell quartet indices
!  =====================

   get_shell_quartet_indices(index,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky
   ! For the quartet index "index" return the shell indicies "a", "b",
   ! "c" and "d" which map to "index". Also return the basis function
   ! start indices "fa", "la", etc ...
      index :: INT, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, OUT
      a,b,c,d :: INT
      ab,cd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)

   end

   get_shell_quartet_indexes(index,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
   ! For the quartet index "index" return the shell indicies "a", "b", "c" and
   ! "d" which map to "index" and the corresponding atom centers. Note different
   ! spelling for this routine and the one above to avoid overload problems.
      index :: INT, IN
      a,b,c,d,atom_a,atom_b,atom_c,atom_d :: INT, OUT
      ab,cd :: INT
      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)
   end

!  ==============
!  Shell quartets
!  ==============

   copy_shell_quartet(shell,a,b,c,d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the indicies "a", "b", "c"
   ! and "d".
      shell :: SHELL4, OUT
      a,b,c,d :: INT, IN
      aa,sa,bb,sb,cc,sc,dd,sd :: INT

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

   end

   copy_shell_quartet(shell,index,a,b,c,d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d :: INT, OUT
      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

   end

   copy_shell_quartet(shell,index,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld :: INT, OUT
      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)

   end

   copy_shell_quartet(shell,index,a,b,c,d,atom_a,atom_b,atom_c,atom_d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Plus the atoms which the shells are on.
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d,atom_a,atom_b,atom_c,atom_d :: INT, OUT
      ab,cd,sa,sb,sc,sd :: INT
      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      atom_b = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      atom_c = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      atom_d = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(atom_a).basis.shell(sa), .atom(atom_b).basis.shell(sb), &
                 .atom(atom_c).basis.shell(sc), .atom(atom_d).basis.shell(sd), &
                 .atom(atom_a).position, .atom(atom_b).position, &
                 .atom(atom_c).position, .atom(atom_d).position )
   end

   copy_shell_quartet_ab(shell,a,b) ::: leaky
   ! Set the a and b parts of the "shell" SHELL4 object.
      shell :: SHELL4, INOUT
      a,b :: INT, IN
      aa,sa,bb,sb :: INT

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)

      shell.copy_ab(.atom(aa).basis.shell(sa), &
                    .atom(bb).basis.shell(sb), &
                    .atom(aa).position, .atom(bb).position)

   end

   copy_shell_quartet_cd(shell,c,d) ::: leaky
   ! Set the c and d parts of the "shell" SHELL4 object.
      shell :: SHELL4, INOUT
      c,d :: INT, IN
      cc,sc,dd,sd :: INT

      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy_cd(.atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(cc).position, .atom(dd).position)

   end


   set_new_shell_quartet_ab(shell,a,b,skip) ::: leaky
   ! Set the "a" and "b" parts of the "shell" SHELL4 object. If "skip" is TRUE
   ! then some primitive pairs are ignored, if too small (this should not be set
   ! if any atoms in the qurtet are the same; if in doubt set skip=FALSE).
      shell :: SHELL1QUARTET, INOUT
      a,b :: INT, IN
      skip :: BIN

      aa,sa,bb,sb :: INT

      aa = .atom_for_shell(a)         !which atom.
      bb = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)  !which shell.
      sb = .basis_shell_for_shell(b)

      shell.set_ab_new(.precomputed_basis_shellpair(sa,sb),   &
                       .atom(aa).position,.atom(bb).position, &
                       aa==bb,skip)

   end

   set_new_shell_quartet_cd(shell,c,d,skip) ::: leaky
   ! Set the "c" and "d" parts of the "shell" SHELL4 object. If "skip" is TRUE
   ! then some primitive pairs are ignored, if too small (this should not be set
   ! if any atoms in the qurtet are the same; if in doubt set skip=FALSE).
      shell :: SHELL1QUARTET, INOUT
      c,d :: INT, IN
      skip :: BIN

      cc,sc,dd,sd :: INT

      cc = .atom_for_shell(c)         !which atom.
      dd = .atom_for_shell(d)

      sc = .basis_shell_for_shell(c)  !which shell.
      sd = .basis_shell_for_shell(d)

      shell.set_cd_new(.precomputed_basis_shellpair(sc,sd),   &
                       .atom(cc).position,.atom(dd).position, &
                       cc==dd,skip)

   end

!  ========================
!  Contraction Coefficients
!  ========================

   make_contraction_matrix(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      cc_mat :: MAT{REAL}, OUT
   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      b = 1
      p = 1
      cc_mat = ZERO
      do a = 1,.n_atom
         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf
         .atom(a).basis.make_contraction_matrix(cc_mat(p:p+ap-1,b:b+ab-1))
         p = p + ap
         b = b + ab
      end

   end

   make_normalised_contraction_mx(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each
   ! basis set. Size of cc_mat is [.n_prim,.n_bf]. Primitive components
   ! are properly normalised.
      cc_mat :: MAT{REAL}, OUT
   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      .basis.renormalise

      b = 1
      p = 1
      cc_mat = ZERO
      do a = 1,.n_atom
         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf
         .atom(a).basis.make_normalised_contraction_mx(cc_mat(p:p+ap-1,b:b+ab-1))
         p = p + ap
         b = b + ab
      end

      .basis.unnormalise

   end

!  ======================
!  Make shell information
!  ======================

   make_shell_info ::: leaky
   ! Define a vector of atom numbers corresponding to the molecule's
   ! basis set shell numbers; also define a vector of atom shell numbers
   ! corresponding to the molecule basis set shell number
   ENSURE(.atom.created,"no atom information")
   ENSURE(.atom.bases_are_resolved,"gaussian bases not all resolved")
   ENSURE(.n_atom>0,"no atoms")
   ENSURE(.basis.created,"no basis set")

      ! Set basis l_max before anything else
      .basis_l_max = .basis.maximum_basis_set_l_value
      GAUSSIAN_DATA:set_indices(.basis_l_max) 

      ! Set atom for shell 
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .atom_for_shell       => .atom.atom_for_shell
      .atom_shell_for_shell => .atom.atom_shell_for_shell

      ! Set first/last shell for atom 
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .first_shell_for_atom.create(.n_atom)
      .last_shell_for_atom.create(.n_atom)
      .atom.make_shell_for_atom_limits(.first_shell_for_atom,.last_shell_for_atom)

      ! Set first/last bf for shell
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .atom.make_shell_limits(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      ! Set first/last bf for atom
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .atom.make_atom_basis_fn_limits(.first_basis_fn_for_atom,.last_basis_fn_for_atom)

      .make_basis_shell_for_shell

      .make_precomputed_shellpairs

   end

   make_precomputed_shellpairs ::: leaky
   ! Make a SHELLPAIR vector "shellpair" which includes precomputed data for the
   ! basis set.
   ! NOTE for later: n_unique_shells should be a basisvec routine.
   ! NOTE for later: precomputed_basis_shellpair should be a MAT{REAL} type
   ENSURE(.basis.created,"no basis set")
      i,j,a,b,p,q :: INT
      .n_unique_shells = .basis.no_of_shells
      .precomputed_basis_shellpair.destroy
      .precomputed_basis_shellpair.create(.n_unique_shells,.n_unique_shells)
      p = 0
      do i = 1,.basis.dim    ! Loop over bases
      do a = 1,.basis(i).n_shell
        p = p + 1
        q = 0
        do j = 1,.basis.dim ! Loop over bases
        do b = 1,.basis(j).n_shell
           q = q + 1
           .precomputed_basis_shellpair(p,q).copy_a(.basis(i).shell(a))
           .precomputed_basis_shellpair(p,q).copy_b(.basis(j).shell(b))
           .precomputed_basis_shellpair(p,q).make_precalculated_data
        end
        end
      end
      end
   end

   first_basis_shell_for_atom(atom) result (res)
   ! Return the index of the first shell in .basis (treating .basis as a
   ! flattened list of shells) which has the same basis label as "atom".
   ! NOTE for later: this should be a basisvec routine.
      atom :: INT, IN
      res :: INT

      i,j :: INT

      res = 0

      i = 1
      ! Loop over bases
      do j = 1,.basis.dim 
         if (.basis(j).label==.atom(atom).basis.label) then
            res = i
            exit
         else
            i = i + .basis(j).n_shell
         end
      end

      DIE_IF(res==0,"atom basis label not found")

   end

   make_basis_shell_for_shell ::: leaky
   ! Return the index of the first shell in .basis (treating .basis as
   ! a flattened list of shells) for a given shell index in the
   ! molecular basis set (i.e. the flattened list of shells in the
   ! .atom list).  NOTE for later: this should be a basisvec routine.
   ENSURE(.basis.created,"no basis set")

      sh,at,atom_shell,ind :: INT

      .basis_shell_for_shell.destroy
      .basis_shell_for_shell.create(.n_shell)

      do sh=1,.n_shell
         at = .atom_for_shell(sh)                 ! which atom
         atom_shell = .atom_shell_for_shell(sh)   ! which shell for this atom
         ind = .first_basis_shell_for_atom(at)    ! first shell for this atom in
                                                ! the basis set
         .basis_shell_for_shell(sh) = ind + atom_shell - 1
      end

   end

!  ======================
!  Density matrix methods
!  ======================

   make_scf_density_matrix(damp,n_a,method) ::: leaky
   ! Make the density matrix from the molecular orbitals. If "damp" is present
   ! use it to damp the updated density matrix. If "n_a" is present it is used
   ! as the number of alpha electrons in embedded scf calculations. If
   ! "method" is present it is used as the kind of density matrix to make.
   ! NOTE: the final computed density matrix is written to an archive
   ! NOTE: if any old density matrix exists, it is saved in an old archive.
      damp :: BIN, optional
      n_a :: INT, optional
      method :: STR, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")

      T :: REAL
      damping,do_archive,do_delta_density,use_pFON :: BIN
      MO,D,MOa,MOb,Da,Db,F,Fa,Fb :: MAT{REAL}*
      CMO,CD,CMOa,CMOb,CDa,CDb :: MAT{CPX}*
      scf_method,genre :: STR

      ! Determine (or guess) the kind of SCF method to be used.
      if      (present(method))  then; scf_method = method
      else if (.scfdata.created) then; scf_method = .scfdata.scf_kind
      else;                            scf_method = .molecular_orbitals.guess_scf_kind
      end

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .molecular_orbitals.spinorbital_kind
      end

      ! Make the delta density matrix?
      do_delta_density = .delta_density_matrix.created
      if (.scfdata.created) do_delta_density = do_delta_density AND .scfdata.do_delta_build

      ! Determine if density matrix damping is to be used
      damping = .old_density_matrix.created
      if      (present(damp)) then;    damping = damping AND damp
      else if (.scfdata.created) then; damping = damping AND .scfdata.apply_damping
      end

      ! Determine if pFON should be used
      use_pFON = FALSE
      if (.scfdata.created AND .fock_matrix.created(genre)) use_pFON = .scfdata.apply_pFON

      ! Create the density matrix (leaky)
      if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)

      ! Save the old density if damping
      .old_density_matrix.destroy
      if (do_delta_density OR damping) then
         .old_density_matrix.create_copy(.density_matrix)
         .old_density_matrix.compress
      end

      ! Do it: make the density matrix
      select case (scf_method)

       case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")
         if (use_pFON) then
            D  => .density_matrix.restricted
            MO => .molecular_orbitals.restricted
            F  => .fock_matrix.restricted
            T = .scfdata.temperature_for_pFON
            MOLECULE:make_finite_T_density_matrix(D,MO,F,T,.n_a)
            D = TWO*D
         else
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted
            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
         end
         if (scf_method(1:4)=="xray" AND .scfdata.stabilize_density) .stabilize(D)
         .put_debug(.density_matrix,"make_scf_density_matrix: restricted density matrix")

       case ("progroup")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")
         ENSURE(present(n_a),"n_a must be specified")
         MO => .molecular_orbitals.restricted(:,1:n_a)
         D  => .density_matrix.restricted
         D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

       case ("rohf")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         MOa => .molecular_orbitals.restricted(:,1:.n_a)
         MOb => .molecular_orbitals.restricted(:,1:.n_b)
         Da => .density_matrix.alpha
         Db => .density_matrix.beta
         Da.to_product_of(MOa,MOa,transpose_b=TRUE)
         Db.to_product_of(MOb,MOb,transpose_b=TRUE)

       case ("uhf","uks","xray_uhf","xray_uks", &
             "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         ENSURE(.molecular_orbitals.created("unrestricted"),"no MO's")
         if (use_pFON) then
            MOa => .molecular_orbitals.alpha
            MOb => .molecular_orbitals.beta
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Fa => .fock_matrix.alpha
            Fb => .fock_matrix.beta
            T = .scfdata.temperature_for_pFON
            MOLECULE:make_finite_T_density_matrix(Da,MOa,Fa,T,.n_a)
            MOLECULE:make_finite_T_density_matrix(Db,MOb,Fb,T,.n_b)
         else
            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)
         end

       case ("ghf")
         ENSURE(.molecular_orbitals.created("general"),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")
         MO => .molecular_orbitals.general(:,1:.n_e)
         D =>  .density_matrix.general
         D.to_product_of(MO,MO,transpose_b=TRUE)

       case ("rchf")
         ENSURE(.molecular_orbitals.created("restricted_complex"),"no MO's")
         CMO => .molecular_orbitals.restricted_complex(:,1:.n_a)
         CD  => .density_matrix.restricted_complex
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)
         CD = TWO*CD

       case ("uchf")
         ENSURE(.molecular_orbitals.created("unrestricted_complex"),"no MO's")
         CMOa => .molecular_orbitals.alpha_complex(:,1:.n_a)
         CMOb => .molecular_orbitals.beta_complex(:,1:.n_b)
         CDa => .density_matrix.alpha_complex
         CDb => .density_matrix.beta_complex
         CDa.to_product_of(CMOa,CMOa,dagger_b=TRUE)
         CDb.to_product_of(CMOb,CMOb,dagger_b=TRUE)

       case ("gchf")
         ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")
         CMO => .molecular_orbitals.general_complex(:,1:.n_e)
         CD =>  .density_matrix.general_complex
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)

       case default
         DIE("unknown SCF kind, "//trim(scf_method))

      end

      ! Damp the density matrix if required
      if (damping) then
         .old_density_matrix.uncompress
         .density_matrix.damp(.old_density_matrix,.scfdata.damp_factor)
      end

      ! Archive density matrix?
      do_archive = FALSE
      if (do_archive) .archive(.density_matrix,"density_matrix")

      ! Debug
      .put_debug(.density_matrix,"make_scf_density_matrix: density matrix")

      ! Save the delta density matrix for incremental Fock build
      if (do_delta_density) then
         .delta_density_matrix => .old_density_matrix
         .delta_density_matrix.to_scaled(.delta_density_matrix,-ONE)
         .delta_density_matrix.plus(.density_matrix)
      else
         .old_density_matrix.destroy
      end

   end

   make_finite_T_density_matrix(D,MO,F,T,n_e) ::: selfless
   ! Make the finite temperature density matrix "D" from molecular orbitals "MO"
   ! according to the pFON method with temperature "T" and number of electrons
   ! "n_e" *for a given spin*, as in Rabuck and Scuseria, JCP 110, 695 (1999).
   ! There must exist a current fock_matrix "F" made from "D" which is used to
   ! get the eigenvalues for the Fermi-Dirac distribution.
      D,MO :: MAT{REAL}
      F :: MAT{REAL}
      T :: REAL
      n_e :: INT

   ENSURE(F.is_square,"F must be square")
   ENSURE(F.is_same_shape_as(MO),"incompatible F and MO")
   ENSURE(n_e<MO.dim2,"fewer MO's than electrons")
   ENSURE(T>=ZERO,"T must be positive")

      W :: MAT{REAL}*
      occ :: VEC{REAL}*
      ind :: VEC{INT}*
      beta,e_homo,e_lumo,e_fermi,homo_lumo_gap :: REAL
      n_orb,i,j,n_frac :: INT

      n_orb = F.dim1

      occ.create(n_orb)     
      ind.create(n_orb)

      ! Make the occupation numbers
      W.create(n_orb,n_orb)
      W.to_product_of(F,MO)
      do i = 1,n_orb        ! These are energies
        occ(i) = dot_product(MO(:,i),W(:,i))
      end
      occ.quick_sort(ind)   ! "ind" has the energies sorted
      W.destroy

      beta    = KELVIN_PER_HARTREE/T
      e_homo  = occ(ind(n_e))
      e_lumo  = occ(ind(n_e+1))
      e_fermi = HALF*(e_homo + e_lumo)
      homo_lumo_gap = e_lumo - e_homo
      do j = 1,n_orb        ! These are the occupation numbers
         i = ind(j)
         occ(i) = ONE/(ONE+exp(beta*(occ(i)-e_fermi)))
      end                   

      ! The number of fractional orbitals
      if      (homo_lumo_gap>0.135d0) then; n_frac = 5
      else if (homo_lumo_gap<0.090d0) then; n_frac = 3
      else;                                 n_frac = 4
      end

      ! Reset the fractional occupancies
      do j = 1,n_orb        
         i = ind(j)
         if      (j<=n_e-n_frac) then; occ(i) = ONE
         else if (j >n_e+n_frac) then; occ(i) = ZERO
         end
      end

      ! Form the temperature broadended density
      D = ZERO
      do j = 1,n_e+n_frac   
         i = ind(j)
         D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ(i),transpose_b=TRUE)
      end

      ind.destroy
      occ.destroy

   end

   make_ao_density_matrix ::: leaky
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix. The result is placed in the "restricted" part of the density
   ! matrix. 

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      .make_ao_density_matrix(.density_matrix)   ! leaky

   end

   make_ao_density_matrix(D) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. 
      D :: OPMATRIX*

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.created, "no density matrix")
   ENSURE(D.any_created, "no density matrix")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = D.spinorbital_kind
      end

      select case (genre)

         case ("restricted")
            ! do nothing

         case ("unrestricted")

            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.alpha + D.beta

         case ("general")

            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.general.alpha_alpha + D.general.beta_beta

         case ("restricted_complex")
            ! do nothing

         case ("unrestricted_complex")

            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.alpha_complex + D.beta_complex

         case ("general_complex")

            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.general_complex.alpha_alpha + D.general_complex.beta_beta

         case default

            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_density_matrix(P)
   ! Make the AO (spin independent) density matrix "P" from the
   ! existing density matrix. 
      P :: MAT{REAL}
      .make_ao_RE_density_matrix(P)
   end

   make_ao_RE_density_matrix(P)
   ! Make the REAL AO (spin independent) density matrix "P" from the
   ! existing density matrix. 
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      select case (genre)

         case ("restricted")
            P = .density_matrix.restricted

         case ("unrestricted")
            P = .density_matrix.alpha + .density_matrix.beta

         case ("general")
            P = .density_matrix.general.alpha_alpha &
              + .density_matrix.general.beta_beta

         case ("restricted_complex")
            P = RE(.density_matrix.restricted_complex)

         case ("unrestricted_complex")
            P = RE(.density_matrix.alpha_complex) &
              + RE(.density_matrix.beta_complex)

         case ("general_complex")
            P = RE(.density_matrix.general_complex.alpha_alpha) &
              + RE(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_IM_density_matrix(P)
   ! Make the IMAGINARY AO (spin independent) density matrix "P" from
   ! the existing density matrix. 
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      P = ZERO

      if (genre=="restricted")   return
      if (genre=="unrestricted") return
      if (genre=="general")      return

      select case (genre)

         case ("restricted_complex")
            P = IM(.density_matrix.restricted_complex)

         case ("unrestricted_complex")
            P = IM(.density_matrix.alpha_complex) &
              + IM(.density_matrix.beta_complex)

         case ("general_complex")
            P = IM(.density_matrix.general_complex.alpha_alpha) &
              + IM(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_sz_density_matrix ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included.

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      .make_ao_sz_density_matrix(.density_matrix)   ! leaky

   end

   make_ao_sz_density_matrix(D) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included!
      D :: OPMATRIX*

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.created, "no density matrix")
   ENSURE(D.any_created, "no density matrix")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = D.spinorbital_kind
      end

      if (genre=="restricted") return

      select case (genre)

         case ("unrestricted")
            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.alpha - D.beta

         case ("general")
            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.general.alpha_alpha - D.general.beta_beta

         case ("unrestricted_complex")
            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.alpha_complex - D.beta_complex

         case ("general_complex")
            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.general_complex.alpha_alpha - D.general_complex.beta_beta

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_sz_density_matrix(P) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included!
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            P = .density_matrix.alpha - .density_matrix.beta

         case ("general")
            P = .density_matrix.general.alpha_alpha - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            P = RE(.density_matrix.alpha_complex) - RE(.density_matrix.beta_complex )

         case ("general_complex")
            P = RE(.density_matrix.general_complex.alpha_alpha) - RE(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_spin_densities(S) ::: leaky
   ! Make  the AO spin density matrices. 
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{CPX}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            S(:,:,3) = .density_matrix.alpha - .density_matrix.beta

         case ("general")
            S(:,:,1) = .density_matrix.general.alpha_beta  &
                     + .density_matrix.general.beta_alpha
            S(:,:,3) = .density_matrix.general.alpha_alpha &
                     - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            S(:,:,3) = .density_matrix.alpha_complex &
                     - .density_matrix.beta_complex

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) =   .density_matrix.general_complex.alpha_beta  &
                     +   .density_matrix.general_complex.beta_alpha
            S(:,:,2) = I*.density_matrix.general_complex.alpha_beta  &
                     - I*.density_matrix.general_complex.beta_alpha
            S(:,:,3) =   .density_matrix.general_complex.alpha_alpha & 
                     -   .density_matrix.general_complex.beta_beta

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_ao_RE_spin_densities(S) ::: leaky
   ! Make the REAL part of the AO spin density matrices. 
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            S(:,:,3) = .density_matrix.alpha - .density_matrix.beta

         case ("general")
            S(:,:,1) = .density_matrix.general.alpha_beta  &
                     + .density_matrix.general.beta_alpha
            S(:,:,3) = .density_matrix.general.alpha_alpha &
                     - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            S(:,:,3) = RE(.density_matrix.alpha_complex) &
                     - RE(.density_matrix.beta_complex)

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) = RE(  .density_matrix.general_complex.alpha_beta)  &
                     + RE(  .density_matrix.general_complex.beta_alpha)
            S(:,:,2) = RE(I*.density_matrix.general_complex.alpha_beta)  &
                     - RE(I*.density_matrix.general_complex.beta_alpha)
            S(:,:,3) = RE(  .density_matrix.general_complex.alpha_alpha) & 
                     - RE(  .density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_ao_IM_spin_densities(S) ::: leaky
   ! Make the IMAGINARY part of the AO spin density matrices. 
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted")   return
      if (genre=="unrestricted") return
      if (genre=="general")      return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted_complex")
            S(:,:,3) = IM(.density_matrix.alpha_complex) &
                     - IM(.density_matrix.beta_complex)

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) = IM(  .density_matrix.general_complex.alpha_beta)  &
                     - IM(  .density_matrix.general_complex.beta_alpha)
            S(:,:,2) = IM(I*.density_matrix.general_complex.alpha_beta)  &
                     - IM(I*.density_matrix.general_complex.beta_alpha)
            S(:,:,3) = IM(  .density_matrix.general_complex.alpha_alpha) & 
                     - IM(  .density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_scf_density_matrix(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals.
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      n :: INT, IN
      nb :: INT, IN, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
      MO,D,MOa,MOb,Da,Db :: MAT{REAL}*
      CMO,CD,CMOa,CMOb,CDa,CDb :: MAT{CPX}*
      genre :: STR
      arch :: ARCHIVE
      m :: INT
      uhf :: BIN
      uhf = .scfdata.scf_kind.includes("unrestricted")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")
      m = n
      if (present(nb)) m = nb
      genre = .scfdata.spinorbital_kind
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)
      arch.set(.name,"density_matrix",genre)
      select case (.scfdata.scf_kind)
         case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")
            ENSURE(.spin_multiplicity==1,"this is not a singlet state")
            D  => .density_matrix.restricted
            if (n>0 AND n<=.n_a) then
               MO => .molecular_orbitals.restricted(:,n:n)
               D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            else
               D = ZERO
            end
         case ("rohf")
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            if (n>0 AND n<=.n_b) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               MOb => .molecular_orbitals.restricted(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
               Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            else if (n>nb AND n<=.n_a) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
               Db = ZERO
            else
               Da = ZERO
               Db = ZERO
            end
         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            if (n>0 AND n<=.n_a) then
               MOa => .molecular_orbitals.alpha(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            else
               Da = ZERO
            end
            if (m>0 AND m<=.n_b) then
               MOb => .molecular_orbitals.beta(:,m:m)
               Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            else
               Db = ZERO
            end
         case ("ghf")
            ENSURE(.spin_multiplicity==1,"this is not a singlet state")
            D =>  .density_matrix.general
            if (n>0 AND n<=.n_e) then
               MO => .molecular_orbitals.general(:,n:n)
               D.to_product_of(MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end
         case ("rchf")
            CD  => .density_matrix.restricted_complex
            if (n>0 AND n<=.n_a) then
               CMO => .molecular_orbitals.restricted_complex(:,n:n)
               CD.to_scaled_product_of(CMO,CMO,fac=TWO,dagger_b=TRUE)
            else
               CD = ZERO
            end
         case ("uchf")
            CDa => .density_matrix.alpha_complex
            CDb => .density_matrix.beta_complex
            if (n>0 AND n<=.n_a) then
               CMOa => .molecular_orbitals.alpha_complex(:,n:n)
               CDa.to_product_of(CMOa,CMOa,dagger_b=TRUE)
            else
               CDa = ZERO
            end
            if (m>0 AND m<=.n_b) then
               CMOb => .molecular_orbitals.beta_complex(:,m:m)
               CDb.to_product_of(CMOb,CMOb,dagger_b=TRUE)
            else
               CDb = ZERO
            end
         case ("gchf")
            CD =>  .density_matrix.general_complex
            if (n>0 AND n<=.n_e) then
               CMO => .molecular_orbitals.general_complex(:,n:n)
               CD.to_product_of(CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end
         case default;
            DIE("unknown kind, "//trim(.scfdata.scf_kind))
      end
      arch.write(.density_matrix)
   end

   make_progroup_density_matrix ::: leaky
   ! Make the density matrix which is a sum of density matrices for
   ! each group specified in the molecule in the atom_group array.
   ! This will destroy any existing restricted density matrix archive.
      archive :: ARCHIVE
      P :: OPMATRIX*
      .make_progroup_density ! leaky
      P.create(.n_bf)
      archive.set_defaults
      archive.set(.name,"progroup_density_matrix", genre="restricted")
      archive.read(P, genre="restricted")
      archive.set(.name,"density_matrix", genre="restricted")
      archive.write(P, genre="restricted")
      P.destroy
   end

   make_group_density_matrix ::: leaky
   ! Make the promolecule density matrix from *symmetrically orthonormalised*
   ! group (monomer) molecular orbitals. Do not confuse this with the progroup
   ! density matrix, made with .make_progroup_density_matrix. The symmetrically
   ! orthonormalised molecular orbitals are made and are ordered by group.  This
   ! will destroy any existing restricted density matrix and MOs.
   ENSURE(.molecular_orbitals.created,"no MO's")
      .make_progroup_density(MOs=TRUE) ! leaky
      .symorthonormalise_occupied_MOs  ! leaky
      .natural_orbitals => .molecular_orbitals
      .make_density_matrix
      nullify(.natural_orbitals)
   end

   symorthonormalise_occupied_MOs ::: leaky
   ! Symmetrically orthonormalise the occupied MO's. The occupied
   ! orbitals are defined by the .occupation_numbers vector. The
   ! virtual orbitals are schmidt orthonormalised to the occupied MOs.
   ! Only works for restricted at the moment.
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no rhf MO's")

      occ,vir,all :: VEC{INT}*
      MO :: MAT{REAL}*
      i,no,nv :: INT

      ! Hoe many occupied and virtual?
      no = count(.occupation_numbers.restricted >0.1)
      nv = count(.occupation_numbers.restricted<=0.1)
      ENSURE((no+nv)==.n_bf,"error determining no and nv")

      ! Banner
      stdout.flush
      stdout.text("Symorthnormalising occupied MO's")
      stdout.flush
      stdout.text("The occupied orbitals are defined by the current occupation numbers.")
      stdout.text("Virtual orbitals are Schmidt-orthonormalised to the occupied MO's.")
      stdout.flush
      stdout.show("No. of occupied MO's =",no)
      stdout.show("No. of virtual  MO's =",nv)

      ! Get indices of occ & virtuals
      occ.create(no)
      vir.create(nv)
      i = 0
      occ = pack([(i,i=1,.n_bf)],.occupation_numbers.restricted> 0.1)
      vir = pack([(i,i=1,.n_bf)],.occupation_numbers.restricted<=0.1)

      if (.debugging("symorthonormalise_occupied_MOs")) then
         stdout.flush
         stdout.text("Occupied orbital indices:")
         stdout.put(occ,by_column=TRUE)
         stdout.flush
         stdout.text("Virtual orbital indices:")
         stdout.put(vir,by_column=TRUE)
      end

      ! Make sure overlap exists
      .get_overlap_matrix

      ! Symmetric orthonormalise the occupied MO's
      MO.create(.n_bf,no)
      MO = .molecular_orbitals.restricted(:,occ)
      MO.symmetrically_orthonormalise(.overlap_matrix)
      .molecular_orbitals.restricted(:,occ) = MO
      MO.destroy

      ! Schmidt orthonormalise the virtuals to the occupieda
      all.append(occ,vir)
      MO.create(.n_bf,.n_bf)
      MO = .molecular_orbitals.restricted(:,all)
      MO.schmidt_orthonormalise(.overlap_matrix)
      .molecular_orbitals.restricted(:,all) = MO

      ! Clean up
      all.destroy
      MO.destroy
      vir.destroy
      occ.destroy

   end

   make_density_matrix ::: leaky
   ! Make the .density_matrix from the .natural_orbitals and the
   ! .occupation_numbers vector. Only restricted so far.
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
      NO,D :: MAT{REAL}*
      occ :: VEC{REAL}*
      genre :: STR
      arch :: ARCHIVE
      genre = .natural_orbitals.spinorbital_kind
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)
      arch.set(.name,"density_matrix",genre)
      select case (genre)
       case ("restricted")
         ENSURE(.natural_orbitals.created("restricted"),"no NO's")
         occ.create(.n_bf)
         occ = sqrt(.occupation_numbers.restricted)
         NO.create(.n_bf,.n_bf)
         NO.to_product_with_diagonal(.natural_orbitals.restricted,occ)
         D  => .density_matrix.restricted
         D.to_product_of(NO,NO,transpose_b=TRUE)
         NO.destroy
         occ.destroy
       case default
         DIE("unknown SCF kind, "//trim(genre))
      end
      arch.write(.density_matrix)
   end

!  ===============
!  Inquiry methods
!  ===============

   no_of_electrons result (res)
   ! Work out and return the number of electrons in the molecule.
      res :: INT
   ENSURE(.atom.created,  "no atom list")
      res = .atom.no_of_electrons - .charge
   end

   no_of_alpha_electrons result (res)
   ! Work out and return the number of alpha electrons in the molecule.
      res :: INT
      res = .no_of_electrons - .no_of_beta_electrons
   end

   no_of_beta_electrons result (res)
   ! Work out and return the number of beta electrons in the molecule
      res :: INT
      tmp :: INT
      tmp = .no_of_electrons - .no_of_unpaired_electrons
      res = tmp/2
      ENSURE(tmp.is_even,"Inconsistent multiplicity, non integer # of beta electrons")
   end

   has_valid_no_of_beta_electrons result (res)
   ! Return TRUE if the number of beta electrons is valid based on the assigned
   ! charge and multiplicity i.e. it must come out integral.
      res :: BIN
      tmp :: INT
      tmp = .no_of_electrons - .no_of_unpaired_electrons
      res = tmp.is_even
   end

   no_of_unpaired_electrons result (res)
   ! Work out and return the number of unpaired electrons in the molecule
      res :: INT
      res = .spin_multiplicity - 1
      ENSURE(res<=.no_of_electrons,"Wrong multiplicity, not enough electrons")
   end

   no_of_atom_pairs result (res)
   ! Return the number of atom pairs in the molecule
      res :: INT
   ENSURE(.atom.created,"no atom list")
      res = .n_atom*(.n_atom+1)/2
   end

   no_of_shell_pairs result (res)
   ! Return the number of shell pairs in the basis set for the molecule
      res :: INT
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.atom.bases_are_resolved,"gaussian bases not all resolved")
      n_shell :: INT
      n_shell = .atom.n_shell
      res = n_shell*(n_shell+1)/2
   end

   n_shell_quartets result (res)
   ! Return the number of shell quartets in the basis set for the molecule
   ! Note, "res" will die at 22 shells for integer(2).
   !       "res" will die at 361 shells for integer(4).
   !       "res" will die at 92681 shells for integer(8).
      res :: INT
      n_shell_pair :: INT
      n_shell_pair = .no_of_shell_pairs
      if (n_shell_pair/sqrt(TWO) <= (huge(n_shell_pair))**HALF) then
         res = n_shell_pair*(n_shell_pair+1)/2
      else
         WARN("too many shells")
         res = 0
      end
   end

   no_of_occupied_NOs(genre,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      genre :: STR, optional
      tol :: REAL, optional
      res :: INT
   ENSURE(.occupation_numbers.created,"no occupation numbers")
      res = .occupation_numbers.no_of_occupied(genre,tol)
   end

!  ================
!  Natural orbitals
!  ================

   make_natural_orbitals(genre) ::: leaky
   ! Make the natural orbitals from the density matrix
      genre :: STR, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
      orb_kind :: STR

      if (present(genre)) then; orb_kind = genre
      else;                     orb_kind = .density_matrix.spinorbital_kind
      end

      select case (orb_kind)
         case ("restricted        "); .make_restricted_NOs
         case ("unrestricted      "); .make_unrestricted_NOs
!        case ("general           "); .make_general_NOs
         case ("restricted_complex"); .make_restricted_complex_NOs
         case ("general_complex   "); .make_general_complex_NOs
         case default;                UNKNOWN(orb_kind)
      end

   end

   make_restricted_NOs ::: leaky
   ! Make the restricted natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no density matrix")

      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"restricted")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"restricted")
      .get_overlap_matrix

      .make_r_NOs(.natural_orbitals.restricted,.occupation_numbers.restricted,.density_matrix.restricted)

   end

   make_unrestricted_NOs ::: leaky
   ! Make the unrestricted natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.alpha.created, "no density matrix")
   ENSURE(.density_matrix.beta.created, "no density matrix")

      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"unrestricted")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"unrestricted")
      .get_overlap_matrix

      .make_r_NOs(.natural_orbitals.alpha,.occupation_numbers.alpha,.density_matrix.alpha)
      .make_r_NOs(.natural_orbitals.beta, .occupation_numbers.beta, .density_matrix.beta)

   end

   make_r_NOs(NO,occupation,P)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      NO,P :: MAT{REAL}
      occupation :: VEC{REAL}

   ENSURE(.overlap_matrix.created,"no overlap matrix")

      V,X :: MAT{REAL}*

      V.create(.n_bf,.n_bf)
      .make_overlap_sqrt(V)

      X.create(.n_bf,.n_bf)
      P.change_basis_to(X,V)

      X.solve_eigenproblem(occupation,V)

      .make_overlap_inverse_sqrt(X)
      NO.to_product_of(X,V)

      X.destroy
      V.destroy

      occupation = occupation(.n_bf:1:-1)
      occupation.zero_small_values(TOL(10))

      NO = NO(:,.n_bf:1:-1)

   end

   make_restricted_complex_NOs ::: leaky
   ! Make the restricted complex natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted_complex.created, "no density matrix")

      V,X :: MAT{CPX}*
      O :: MAT{REAL}*

      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"restricted_complex")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"restricted")

      .get_overlap_matrix
      V.create(.n_bf,.n_bf)
      O.create(.n_bf,.n_bf)

      .make_overlap_sqrt(O)

      X.create(.n_bf,.n_bf)
      .density_matrix.restricted_complex.change_basis_to(X,O)

      X.solve_eigenproblem(.occupation_numbers.restricted,V)
      X.destroy

      .make_overlap_inverse_sqrt(O)

      .natural_orbitals.restricted_complex.to_product_of(O,V)

      O.destroy

      V.destroy
      .occupation_numbers.restricted = .occupation_numbers.restricted(.n_bf:1:-1)
      .occupation_numbers.restricted.zero_small_values(TOL(10))

      .natural_orbitals.restricted_complex = .natural_orbitals.restricted_complex(:,.n_bf:1:-1)

   end

   make_general_complex_NOs ::: leaky
   ! Make the general natural orbitals and occupations from the complex density
   ! matrix.
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.general_complex.created,"no density matrix")

      R :: MAT{REAL}*
      V,X :: MAT{CPX}*

      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"general_complex")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"general")

      .get_overlap_matrix
      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)
      .make_overlap_sqrt(R)

      V = ZERO
      V.alpha_alpha_set_to(R)
      V.beta_beta_set_to(R)
      R.destroy

      X.create(2*.n_bf,2*.n_bf)
      X = .density_matrix.general_complex
      X.change_basis_using(V)
      X.solve_eigenproblem(.occupation_numbers.general,V)

      R.create(.n_bf,.n_bf)
      .make_overlap_inverse_sqrt(R)

      X = ZERO
      X.alpha_alpha_set_to(R)
      X.beta_beta_set_to(R)
      R.destroy

      .natural_orbitals.general_complex.to_product_of(X,V)
      .occupation_numbers.general = .occupation_numbers.general(2*.n_bf:1:-1)
      .occupation_numbers.general.zero_small_values(TOL(10))
      .natural_orbitals.general = .natural_orbitals.general(:,2*.n_bf:1:-1)

      X.destroy
      V.destroy

   end

!  ==============
!  Debug printing
!  ==============

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>STR)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>BIN)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>INT)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>SHELL2)
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG)
   ! Put *opmatrix* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

!  ========================
!  Overlap matrix formation
!  ========================

   get_overlap_matrix ::: leaky
   ! Get the overlap matrix.

      small,tol :: REAL
      n :: INT

      if (.overlap_matrix.created) return

      ! Make the overlap matrix
      .overlap_matrix.create(.n_bf,.n_bf)
      .make_overlap_matrix(.overlap_matrix)

      ! Get overlap eigenvalues and eigenvectors
      .overlap_eigenvalues.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvectors.create(.n_bf,.n_bf)
      .overlap_eigenvalues.create(.n_bf)
      .overlap_matrix.solve_eigenproblem(.overlap_eigenvalues,.overlap_eigenvectors)

      ! Test overlap eigenvalues
      if (.scfdata.created) then
         small = minval(abs(.overlap_eigenvalues))
         tol = .scfdata.linear_dependence_tol
         if (small<=tol) then
            n = count(abs(.overlap_eigenvalues) <= tol)
            WARN(" ")
            WARN("Smallest cartesian overlap eigenvalue is "//trim(small.to_str("e15.8")))
            WARN("There are "//trim(n.to_str)//" linear dependent functions")
            WARN("The overlap tolerance is set to "//trim(tol.to_str("e15.8")))
            WARN(" ")
         end
      end

      ! Make maximum overlap between basis fns in shell pairs ...
      .max_S.destroy
      .max_S.create(.n_shell_pairs)
      .make_max_S_for_shell_pairs(.max_S)

   end

   make_overlap_matrix(S)
   ! Calculate the overlap matrix "S"
      S :: MAT{REAL}
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")

      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      S = ZERO

      parallel do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
         sh.make_overlap(S(fa:la,fb:lb))
         sh.destroy_ptr_part
      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(S)
      else
        S.symmetric_reflect
      end

      .put_debug(S,"make_overlap_matrix: S")

   end

   make_overlap_sqrt(S_sqrt) ::: leaky
   ! Get "S_sqrt", the sqrt overlap matrix 
      S_sqrt :: MAT{REAL}

   ENSURE(.overlap_eigenvectors.created,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.created,"no overlap_values")
   ENSURE(S_sqrt.is_square,"non-square S_qrt")
   ENSURE(S_sqrt.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.overlap_matrix.destroyed) .get_overlap_matrix

      if (.scfdata.created) then
         tol   = .scfdata.linear_dependence_tol
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

   make_overlap_inverse_sqrt(S_inv) ::: leaky
   ! Get "S_inv", the inverse sqrt overlap matrix 
      S_inv :: MAT{REAL}

   ENSURE(.overlap_eigenvectors.created,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.created,"no overlap_values")
   ENSURE(S_inv.is_square,"non-square S_inv")
   ENSURE(S_inv.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.overlap_matrix.destroyed) .get_overlap_matrix

      if (.scfdata.created) then
         tol   = .scfdata.linear_dependence_tol
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

!   make_rxhf_overlap_matrix(S)
!   ! Calculate the overlap matrix "S" for a restricted crystal Hartree-Fock
!   ! calculation.
!     S :: MAT{REAL}, target
!   ENSURE(.atom.created,  "no fragment atom list")
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.crystal.created,"no crystal data")
!   ENSURE(.cluster.created,"no cluster data")
!   ENSURE(.cluster.atom.created,"no cluster atom data")
!   ENSURE(.cluster.info_made,"no cluster data")
!   ENSURE(S.is_square,"S is not square")
!   ENSURE(S.dim1==.cluster.atom.no_of_basis_functions,"S has wrong shape")
!     n_shell_pairs,q,fa,la,fb,lb,start,step :: INT
!     sh :: SHELL2
!     stdout.text("here")
!     n_shell_pairs = .cluster.atom.n_shell_pairs
!     stdout.show("n_shell_pairs =",n_shell_pairs)
!     do q = start,n_shell_pairs,step
!       .cluster.atom.get_shell_pair(sh,q,fa,la,fb,lb)
!       sh.make_overlap(S(fa:la,fb:lb))
!       sh.destroy_ptr_part
!     end
!     stdout.text("here2")
!     S.symmetric_reflect
!   end

   make_primitive_overlap_matrix(S)
   ! Calculate the primitive overlap matrix "S"
   ! NOTE: if the contraction coefficients have been unnormalised (as
   ! is usually the case) then this overlap matrix will not have one's
   ! on the diagonal. The make normalised overlap integrals refers to
   ! the fact that the l > d shell type factors have been inlcuded and
   ! not the overall normalisation of the primitive.
      S :: MAT{REAL}
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(S.is_square, "S must be square")
   ENSURE(S.dim1==.n_prim, "wrong size, S")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,fb,lb :: INT
      G :: GAUSSIAN2
   ! ccm,Sb :: MAT{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! Calculate the primitive integrals
      nps = frst.dim
      do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_overlap_ints(S(fa:la,fb:lb),.use_spherical_basis)
        end
      end

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy

      ! Make a symmetric matrix
      S.symmetric_reflect
      .put_debug(S,"make_primitive_overlap_matrix: S")

   end

!  =================
!  Kinetic integrals
!  =================

   make_kinetic_energy_mx(T)
   ! Calculate the kinetic energy matrix "T".
      T :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      T = ZERO

      parallel do q = 1,.n_shell_pairs
        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
        sh.get_kei(T(fa:la,fb:lb))
        sh.destroy_ptr_part
      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(T)
      else
        T.symmetric_reflect
      end

      .put_debug(T,"make_kinetic_energy_mx: T")

   end

   make_primitive_kinetic_matrix(T)
   ! Calculate the primitive kinetic matrix "T"
      T :: MAT{REAL}
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,fb,lb :: INT
      G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! Calculate the primitive integrals
      nps = frst.dim
      do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_kinetic_ints(T(fa:la,fb:lb),.use_spherical_basis)
        end
      end

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy

      ! Make a symmetric matrix
      T.symmetric_reflect
      .put_debug(T,"make_primitive_kinetic_matrix: T")

      ! Test
   ! ccm.create(.n_prim,.n_bf)
   ! Tb.create(.n_bf,.n_bf)
   ! .make_normalised_contraction_mx(ccm)
   ! T.change_basis_to(Tb,ccm)
   ! .put_debug(Tb,"basis fn overlap matrix")
   ! Tb.destroy
   ! ccm.destroy

   end

!  =============================
!  Kinetic and overlap integrals
!  =============================

!   get_kinetic_overlap(T,S)
!   ! Set "S" to the overlap matrix and "T" to the kinetic matrix
!   ! If both archives exists, read them; otherwise make them both!
!      T,S :: MAT{REAL}
!      write_archive,calc_it :: BIN
!      T_archive,S_archive :: ARCHIVE
!      S_archive.set(.name,"overlap_matrix")
!      T_archive.set(.name,"kinetic_matrix")
!      calc_it = .scfdata.using_direct_scf
!      write_archive = NOT .scfdata.using_direct_scf
!      if (NOT calc_it) then
!        if ((S_archive.exists) AND (T_archive.exists)) then
!          S_archive.read(S)
!          T_archive.read(T)
!          calc_it = FALSE
!          write_archive = FALSE
!        else
!          calc_it = TRUE
!        end
!      end
!      if (calc_it) then
!         if      (.scfdata.using_NDDO) then; .make_NDDO_kinetic_overlap(T,S)
!         else if (.scfdata.using_NUDO) then; .make_NUDO_kinetic_overlap(T,S)
!         else;                               .make_kinetic_overlap(T,S)
!         end
!      end
!      if (write_archive) then
!        S_archive.write(S)
!        T_archive.write(T)
!      end
!   end
!
!   make_kinetic_overlap(T,S)
!   ! Calculate the kinetic energy matrix "T" and overlap integral matrix "S"
!     T,S :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!     q,fa,la,fb,lb :: INT
!     sh :: SHELL2
!     do q=1,.n_shell_pairs
!       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
!       sh.get_kei(T(fa:la,fb:lb), S(fa:la,fb:lb))
!       sh.destroy_ptr_part
!     end
!     S.symmetric_reflect
!     T.symmetric_reflect
!     .put_debug(S,"overlap matrix")
!     .put_debug(T,"kinetic matrix")
!   end
!
!   make_NDDO_kinetic_overlap(T,S)
!   ! Calculate the NDDO kinetic energy matrix "T" and overlap integral matrix
!   ! "S"
!     T,S :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!     q,fa,la,fb,lb,atom_a,atom_b :: INT
!     sh :: SHELL2
!     do q=1,.n_shell_pairs
!       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!       if (atom_a==atom_b) then; sh.get_kei(T(fa:la,fb:lb),S(fa:la,fb:lb))
!       else;                     T(fa:la,fb:lb) = ZERO; S(fa:la,fb:lb) = ZERO
!       end
!       sh.destroy_ptr_part
!     end
!     S.symmetric_reflect
!     T.symmetric_reflect
!   end
!
!   make_NUDO_kinetic_overlap(T,S)
!   ! Calculate the NUDO kinetic energy matrix "T" and overlap integral matrix
!   ! "S"
!     T,S :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!     q,fa,la,fb,lb,atom_a,atom_b :: INT
!     sh :: SHELL2
!     do q=1,.n_shell_pairs
!       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!       if (.atom.bonded(atom_a,atom_b)) then; sh.get_kei(T(fa:la,fb:lb),S(fa:la,fb:lb))
!       else;                                  T(fa:la,fb:lb) = ZERO; S(fa:la,fb:lb) = ZERO
!       end
!       sh.destroy_ptr_part
!     end
!     S.symmetric_reflect
!     T.symmetric_reflect
!   end

!  ===========================
!  Nuclear attracton integrals
!  ===========================

   make_nuclear_attraction_mx(Z)
   ! Calculate the nuclear attraction matrix "Z".
      Z :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      atom :: ATOM*
      Z_c :: MAT{REAL}*
      q,c,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      Z = ZERO

      parallel do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Z_c.create(na,nb)
         do c = 1,.n_atom
            atom => .atom(c)
            sh.get_nuc(Z_c, atom.mass, atom.position)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.nuclear_charge * Z_c
         end

         Z_c.destroy
         sh.destroy_ptr_part

      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(Z)
      else
        Z.symmetric_reflect
      end

      .put_debug(Z,"make_nuclear_attraction_mx: Z")

   end

   make_nuclear_attraction_mx(Z,nuclei)
   ! Calculate the nuclear attraction matrix "Z" only for a specified
   ! list of "nuclei".
      Z :: MAT{REAL}
      nuclei :: VEC{INT}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      atom_c :: ATOM*
      Z_c :: MAT{REAL}*
      q,c,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      Z = ZERO

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Z_c.create(na,nb)
         do c = 1,size(nuclei)
            atom_c => .atom(nuclei(c))
            sh.get_nuc(Z_c, atom_c.mass,atom_c.position)
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom_c.nuclear_charge * Z_c
         end

         Z_c.destroy
         sh.destroy_ptr_part

      end

      Z.symmetric_reflect

   end

   make_nuclear_attraction_mx(Z,charges,points)
   ! Calculate the nuclear attraction matrix "Z" given a set of "charges" at a
   ! set of "points".
      Z,points :: MAT{REAL}
      charges :: VEC{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(charges.dim==points.dim1,"inconsistent charges and points arrays")
   ENSURE(points.dim2==3,"wrong 2nd dimension, points array")

      Z_c :: MAT{REAL}*
      q,c,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      Z = ZERO

      parallel do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Z_c.create(na,nb)
         do c = 1,charges.dim
            sh.get_nuc(Z_c,ZERO,points(c,:))
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - charges(c) * Z_c
         end

         Z_c.destroy
         sh.destroy_ptr_part

      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(Z)
      else
        Z.symmetric_reflect
      end

   end

   make_primitive_nuclear_matrix(Z)
   ! Calculate the primitive nuclear attraction matrix "Z"
      Z :: MAT{REAL}
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(Z.is_square, "Z must be square")
   ENSURE(Z.dim1==.n_prim, "wrong size, Z")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,c :: INT
      G :: GAUSSIAN2
      atom :: ATOM*
      Zc :: MAT{REAL}*
   ! ccm,Zb :: MAT{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! Calculate the primitive integrals
      Z = ZERO
      nps = frst.dim

      do a = 1,nps

        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a); na = la - fa + 1

        do b = 1,a

           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b); nb = lb - fb + 1

           Zc.create(na,nb)
           do c = 1,.n_atom
              atom => .atom(c)
              G.make_normalised_NA_ints(Zc,atom.position,.use_spherical_basis)
              Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.nuclear_charge * Zc
           end

           Zc.destroy

        end

      end

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy

      ! Make a symmetric matrix
      Z.symmetric_reflect
      .put_debug(Z,"make_primitive_nuclear_matrix: Z")

      ! Test
   ! ccm.create(.n_prim,.n_bf)
   ! Zb.create(.n_bf,.n_bf)
   ! .make_normalised_contraction_mx(ccm)
   ! Z.change_basis_to(Zb,ccm)
   ! .put_debug(Zb,"basis fn NA matrix")
   ! Zb.destroy
   ! ccm.destroy

   end

!  ===========
!  Core matrix
!  ===========

   get_core_matrix ::: leaky
   ! Get the core hamiltonian matrix. 
   ! If already in memory, do nothing. Otherwise make it.
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      spinorbital_kind :: STR

      ! No scfdata ====> make restricted core_matrix
      if (.scfdata.destroyed) then

         if (.core_matrix.destroyed("restricted")) then
            .core_matrix.create(.n_bf,"restricted") ! leaky
            .make_r_core_matrix(.core_matrix.restricted)
         end

      ! Has scfdata ====> make scfdata.spinorbital_kind core matrix
      else

         spinorbital_kind = .scfdata.spinorbital_kind

         if (.core_matrix.created(spinorbital_kind)) return

         select case (spinorbital_kind)

            case ("general_complex")
               .get_gc_core_matrix

            case ("restricted")
               .get_r_core_matrix

            case default
               .get_r_core_matrix
               .core_matrix.convert_to(spinorbital_kind) ! leaky

         end

      end

   end


   get_r_core_matrix ::: leaky
   ! Get the *restricted* core hamiltonian matrix appropriate for the
   ! current scf calculation. If already in memory, do nothing: else
   ! make it.
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.scfdata.created,  "no scfdata")

      Z,H :: MAT{REAL}*

      ! Return if already there
      if (.core_matrix.created("restricted")) return

      ! Allocate core matrix 
      if (.core_matrix.destroyed) then; .core_matrix.create(.n_bf)
      else;                             .core_matrix.set(.n_bf)
      end
      .core_matrix.create("restricted") 

      ! === ALIAS ===
      H => .core_matrix.restricted            

      ! Make the core matrix here (relativistic vs non-rel)
      select case (.scfdata.relativity_kind)
         case ("douglas-kroll-hess-2","dkh-2"); .make_r_DKH_matrix2(H)
         case ("douglas-kroll-hess","dkh");     .make_r_DKH_matrix(H)
         case ("iotc");                         .make_r_IOTC_matrix(H)
         case default;                          .make_r_core_matrix(H)
      end

      ! No cluster charges for SCF guess
      if (.scfdata.is_guess)  return

      ! Add cluster charges if needed 
      ! NOTE: includes the self-consisten case
      if (.scfdata.using_cluster_charges) then
         if  (NOT .Hirshfeld_atom_info_made) then
            ENSURE(.crystal.created,"no crystal")
            .make_Hirshfeld_atom_info(output=FALSE)
         end
         Z.create(.n_bf,.n_bf)
         .make_pt_charge_matrix(Z) ! leaky
         H = H + Z
         Z.destroy

      ! Add Lorentz fields if needed 
      else if (.scfdata.using_SC_Lorentz_fields) then
         if  (NOT .Hirshfeld_atom_info_made) then
            ENSURE(.crystal.created,"no crystal")
            .make_Hirshfeld_atom_info(output=FALSE)
         end
         Z.create(.n_bf,.n_bf)
         .make_Lorentz_core(Z)
         H = H + Z
         Z.destroy
      end

      .put_debug(H,"get_r_core_matrix: H")

   end

   make_r_core_matrix(H)
   ! Make the core hamiltonian (T+NA) matrix "H".
      H :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Z,W,Dx,Dy,Dz :: MAT{REAL}*

      .make_kinetic_energy_mx(H)

      Z.create(.n_bf,.n_bf)
      .make_nuclear_attraction_mx(Z)

      if (NOT .E_field.is_zero) then

         ! Get electronic contribution
         W.create(.n_bf,.n_bf)
         Dx.create(.n_bf,.n_bf)
         Dy.create(.n_bf,.n_bf)
         Dz.create(.n_bf,.n_bf)
         .make_dipole_matrices(Dx,Dy,Dz)
         W = Dx*.E_field(1) + Dy*.E_field(2) + Dz*.E_field(3)
         Dz.destroy; Dy.destroy; Dx.destroy

         .put_debug(W,"make_r_core_matrix: W")

         ! Add it to core
         Z = Z + W
         W.destroy

      end

      H = H + Z

      Z.destroy

      .put_debug(H,"make_r_core_matrix: H")

   end

   get_gc_core_matrix ::: leaky
   ! Get the general complex core hamiltonian matrix. 
   ! If already in memory, do nothing; otherwise make it.
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.scfdata.created,  "no scfdata")

      ! Return if core matrix already there
      if (.core_matrix.created("general_complex")) then
         return
      end

      ! Allocate core matrix 
      if (.core_matrix.destroyed) then; .core_matrix.create(.n_bf)
      else;                             .core_matrix.set(.n_bf)
      end
      .core_matrix.create("general_complex")
      .core_matrix.general_complex = (ZERO,ZERO)

      ! Add the lower half in ... depending on the method
      ! NOTE: there may be some failures here ...
      select case (.scfdata.relativity_kind)
         case ("douglas-kroll-hess"); .add_gc_DKH_core_matrix
         case ("dkh");                .add_gc_DKH_core_matrix
         case ("zora");               .add_gc_ZORA_core_matrix
         case ("iotc");               .set_gc_IOTC_core_matrix
         case ("pauli");              .add_gc_Pauli_core_matrix
         case ("none");               .add_gc_core_matrix
      end

      ! Make it Hermitian
      .core_matrix.general_complex.make_hermitian

   end

   add_gc_DKH_core_matrix
   ! Add the DKH core hamiltonian
   ! NOTE: only lower half is made
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.core_matrix.created("general_complex"),"no core matrix")

      HH :: MAT{CPX}*
      T,Lx,Ly,Lz :: MAT{REAL}*
      fac :: REAL
      I :: CPX

      I = (ZERO,ONE)

      T.create(.n_bf,.n_bf)
      Lx.create(.n_bf,.n_bf)
      Ly.create(.n_bf,.n_bf)
      Lz.create(.n_bf,.n_bf)

      .make_DKH_matrices(T,Lx,Ly,Lz)

      ! === ALIAS ===
      HH => .core_matrix.general_complex  

      HH.alpha_alpha_plus(T)
      HH.beta_beta_plus(T)

      fac= ONE
      HH.beta_alpha_plus(Lx,fac*I)
      HH.beta_alpha_plus(Ly,-fac)
      HH.alpha_alpha_plus(Lz,fac*I)
      HH.beta_beta_plus(Lz,-fac*I)

      T.destroy
      Lz.destroy; Ly.destroy; Lx.destroy

   end

   add_gc_ZORA_core_matrix
   ! Add the core hamiltonain to a general complex "F"
   ! NOTE: only lower half is made
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.scfdata.using_1e_zora_term," no Pauli?")
   ENSURE(.core_matrix.created("general_complex"),"no core matrix")

      HH :: MAT{CPX}*
      T,Lx,Ly,Lz :: MAT{REAL}*
      fac :: REAL
      I :: CPX

      I = (ZERO,ONE)

      T.create(.n_bf,.n_bf)
      Lx.create(.n_bf,.n_bf)
      Ly.create(.n_bf,.n_bf)
      Lz.create(.n_bf,.n_bf)
      .make_1e_ZORA_matrices(T,Lx,Ly,Lz)

      ! === ALIAS ===
      HH => .core_matrix.general_complex  

      HH.alpha_alpha_plus(T)
      HH.beta_beta_plus(T)

      fac = G_FACTOR/TWO
      fac = fac * .scfdata.sl_1e_factor
      HH.beta_alpha_plus(Lx,-fac*I)
      HH.beta_alpha_plus(Ly,fac)
      HH.alpha_alpha_plus(Lz,-fac*I)
      HH.beta_beta_plus(Lz,fac*I)

      T.destroy
      Lz.destroy; Ly.destroy; Lx.destroy

   end

   set_gc_IOTC_core_matrix
   ! Add the core hamiltonain to a general complex "F"
   ! NOTE: only lower half is made
   ENSURE(.scfdata.created,"no scfdata")
 !  ENSURE(.scfdata.using_iotc," no iotc ?")
   ENSURE(.core_matrix.created("general_complex"),"no core matrix")

      H :: MAT{CPX}*

      H => .core_matrix.general_complex

      .make_gc_IOTC_matrix(H)

      .put_debug(H,"set_gc_IOTC_core_matrix: H")

   end

   add_gc_Pauli_core_matrix
   ! Add the Pauli core hamiltonian ... including B-field terms
   ! NOTE: only lower half is made
   ENSURE(.scfdata.created,"no scfdata")
 !  ENSURE(.scfdata.using_pauli_terms," no Pauli?")
   ENSURE(.core_matrix.created("general_complex"),"no core matrix")

      HH :: MAT{CPX}*
      T,xx,yy,zz,xy,xz,yz,Lx,Ly,Lz :: MAT{REAL}*
      BB :: MAT{REAL}(3,3)
      k,l :: INT
      fac :: REAL
      I :: CPX

      I = (ZERO,ONE)

      ! Diagonal part
      .get_r_core_matrix

      ! === ALIAS ===
      HH => .core_matrix.general_complex           

      HH.alpha_alpha_plus(.core_matrix.restricted)
      HH.beta_beta_plus(.core_matrix.restricted)

      ! The Pauli terms below are not normally active if Douglas-Kroll
      ! has been used
      if (.scfdata.using_1e_sl_term) then

            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .make_spin_orbit_matrices(Lx,Ly,Lz)
            fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
            fac = fac * .scfdata.sl_1e_factor
            HH.beta_alpha_plus(Lx,-fac*I)
            HH.beta_alpha_plus(Ly,fac)
            HH.alpha_alpha_plus(Lz,-fac*I)
            HH.beta_beta_plus(Lz,fac*I)
            Lz.destroy; Ly.destroy; Lx.destroy

      end

      if (NOT .B_field.is_zero) then

         if (.scfdata.using_bs_term) then
            .get_overlap_matrix
            fac = G_FACTOR/FOUR
            HH.alpha_alpha_plus(.overlap_matrix,fac*.B_field(3))
            HH.beta_beta_plus(.overlap_matrix,-fac*.B_field(3))
            HH.beta_alpha_plus(.overlap_matrix,fac*.B_field(1))
            HH.beta_alpha_plus(.overlap_matrix,fac*.B_field(2)*I)
         end

         if (.scfdata.using_bs_t_term) then
            T.create(.n_bf,.n_bf)
            .make_kinetic_energy_mx(T)
            fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU**2)
            HH.alpha_alpha_plus(T,fac*.B_field(3))
            HH.beta_beta_plus(T,-fac*.B_field(3))
            HH.beta_alpha_plus(T,fac*.B_field(1))
            HH.beta_alpha_plus(T,fac*.B_field(2)*I)
            T.destroy
         end

         if (.scfdata.using_bl_term) then
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .make_L_matrices(Lx,Ly,Lz)
            Lx = Lx*.B_field(1) + Ly*.B_field(2) + Lz*.B_field(3)
            fac = HALF
            HH.alpha_alpha_plus(Lx,fac*I)
            HH.beta_beta_plus(Lx,fac*I)
            Lz.destroy; Ly.destroy; Lx.destroy
         end

         if (.scfdata.using_aa_term) then
           xx.create(.n_bf,.n_bf); yy.create(.n_bf,.n_bf); zz.create(.n_bf,.n_bf)
           xy.create(.n_bf,.n_bf); xz.create(.n_bf,.n_bf); yz.create(.n_bf,.n_bf)
           .make_quadrupole_matrices(xx,yy,zz,xy,xz,yz)
           fac = ONE/EIGHT
           do k = 1,3
              BB(k,k) = fac*(sum(.B_field*.B_field) - .B_field(k)*.B_field(k))
           end
           do k = 1,3
           do l = k+1,3
              BB(k,l) = -TWO*fac*.B_field(k)*.B_field(l)
           end
           end
           xx =      BB(1,1)*xx; xx = xx + BB(2,2)*yy; xx = xx + BB(3,3)*zz
           xx = xx + BB(1,2)*xy; xx = xx + BB(1,3)*xz; xx = xx + BB(2,3)*yz
           HH.alpha_alpha_plus(xx)
           HH.beta_beta_plus(xx)
           yz.destroy; xz.destroy; xy.destroy
           zz.destroy; yy.destroy; xx.destroy
         end

         if (.scfdata.using_1e_srxa_term) then
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .make_spin_orbit_B_matrices(Lx,Ly,Lz)
            fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
            HH.beta_alpha_plus(Lx,fac)
            HH.beta_alpha_plus(Ly,fac*I)
            HH.alpha_alpha_plus(Lz,fac)
            HH.beta_beta_plus(Lz,-fac)
            Lz.destroy; Ly.destroy; Lx.destroy
         end

      end

   end

   add_gc_core_matrix
   ! Add the Pauli core hamiltonian ... including B-field terms
   ! NOTE: only lower half is made
   ENSURE(.scfdata.created,"no scfdata")
 !  ENSURE(.scfdata.using_pauli_terms," no Pauli?")
   ENSURE(.core_matrix.created("general_complex"),"no core matrix")

      HH :: MAT{CPX}*

      ! Diagonal part
      .get_r_core_matrix

      ! === ALIAS ===
      HH => .core_matrix.general_complex           

      HH.alpha_alpha_plus(.core_matrix.restricted)
      HH.beta_beta_plus(.core_matrix.restricted)

   end

!   get_gc_core_hamiltonian
!   ! Add the core hamiltonain to a general complex "F"
!   ENSURE(.scfdata.created,"no scfdata")
!
!      HH :: MAT{CPX}*
!      S,T,xx,yy,zz,xy,xz,yz,Lx,Ly,Lz :: MAT{REAL}*
!      BB :: MAT{REAL}(3,3)
!      k,l :: INT
!      fac :: REAL
!      I :: CPX
!
!      ! Return if already there
!      if (.core_matrix.created("general_complex")) return
!
!      ! Make the core matrix 
!      .core_matrix.create(.n_bf,"general_complex") ! leaky
!      HH => .core_matrix.general_complex           ! === ALIAS ===
!      HH = ZERO
!
!      I = (ZERO,ONE)
!            
!      if(.scfdata.using_douglas_kroll_hess) then
!            T.create(.n_bf,.n_bf)
!            Lx.create(.n_bf,.n_bf)
!            Ly.create(.n_bf,.n_bf)
!            Lz.create(.n_bf,.n_bf)
!            .make_DKH_matrices(T,Lx,Ly,Lz)
!            HH.alpha_alpha_plus(T)
!            HH.beta_beta_plus(T)
!
!            fac= ONE
!            HH.beta_alpha_plus(Lx,factor=fac*I)
!            HH.beta_alpha_plus(Ly,factor==fac)
!            HH.alpha_alpha_plus(Lz,factor=fac*I)
!            HH.beta_beta_plus(Lz,factor==fac*I)
!
!            T.destroy
!            Lz.destroy; Ly.destroy; Lx.destroy
!
!      else
!
!        HH.alpha_alpha_plus(.core_matrix.restricted)
!        HH.beta_beta_plus(.core_matrix.restricted)
!
!      end
!
!      ! The Pauli terms below are not normally active if Douglas-Kroll
!      ! has been used
!
!      if (.scfdata.using_1e_sl_term) then
!
!            Lx.create(.n_bf,.n_bf)
!            Ly.create(.n_bf,.n_bf)
!            Lz.create(.n_bf,.n_bf)
!            .make_spin_orbit_matrices(Lx,Ly,Lz)
!            fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
!            fac = fac * .scfdata.sl_1e_factor
!            HH.beta_alpha_plus(Lx,factor==fac*I)
!            HH.beta_alpha_plus(Ly,factor=fac)
!            HH.alpha_alpha_plus(Lz,factor==fac*I)
!            HH.beta_beta_plus(Lz,factor=fac*I)
!            Lz.destroy; Ly.destroy; Lx.destroy
!
!      else if (.scfdata.using_1e_zora_term) then
!
!            T.create(.n_bf,.n_bf)
!            Lx.create(.n_bf,.n_bf)
!            Ly.create(.n_bf,.n_bf)
!            Lz.create(.n_bf,.n_bf)
!            .make_1e_ZORA_matrices(T,Lx,Ly,Lz)
!            HH.alpha_alpha_plus(T)
!            HH.beta_beta_plus(T)
!            .make_kinetic_energy_mx(T) ! remove normal kinetic energy
!            HH.alpha_alpha_plus(T,factor==ONE)
!            HH.beta_beta_plus(T,factor==ONE)
!            fac = G_FACTOR/TWO
!            fac = fac * .scfdata.sl_1e_factor
!            HH.beta_alpha_plus(Lx,factor==fac*I)
!            HH.beta_alpha_plus(Ly,factor=fac)
!            HH.alpha_alpha_plus(Lz,factor==fac*I)
!            HH.beta_beta_plus(Lz,factor=fac*I)
!            T.destroy
!            Lz.destroy; Ly.destroy; Lx.destroy
!
!      end
!
!      if (NOT .B_field.is_zero) then
!
!         if (.scfdata.using_bs_term) then
!            .get_overlap_matrix
!            fac = G_FACTOR/FOUR
!            HH.alpha_alpha_plus(.overlap_matrix,factor=fac*.B_field(3))
!            HH.beta_beta_plus(.overlap_matrix,factor==fac*.B_field(3))
!            HH.beta_alpha_plus(.overlap_matrix,factor=fac*.B_field(1))
!            HH.beta_alpha_plus(.overlap_matrix,factor=fac*.B_field(2)*I)
!         end
!
!         if (.scfdata.using_bs_t_term) then
!            T.create(.n_bf,.n_bf)
!            .make_kinetic_energy_mx(T)
!            fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU**2)
!            HH.alpha_alpha_plus(T,factor=fac*.B_field(3))
!            HH.beta_beta_plus(T,factor==fac*.B_field(3))
!            HH.beta_alpha_plus(T,factor=fac*.B_field(1))
!            HH.beta_alpha_plus(T,factor=fac*.B_field(2)*I)
!            T.destroy
!         end
!
!         if (.scfdata.using_bl_term) then
!            Lx.create(.n_bf,.n_bf)
!            Ly.create(.n_bf,.n_bf)
!            Lz.create(.n_bf,.n_bf)
!            .make_L_matrices(Lx,Ly,Lz)
!            Lx = Lx*.B_field(1) + Ly*.B_field(2) + Lz*.B_field(3)
!            fac = HALF
!            HH.alpha_alpha_plus(Lx,factor=fac*I)
!            HH.beta_beta_plus(Lx,factor=fac*I)
!            Lz.destroy; Ly.destroy; Lx.destroy
!         end
!
!         if (.scfdata.using_aa_term) then
!           xx.create(.n_bf,.n_bf); yy.create(.n_bf,.n_bf); zz.create(.n_bf,.n_bf)
!           xy.create(.n_bf,.n_bf); xz.create(.n_bf,.n_bf); yz.create(.n_bf,.n_bf)
!           .get_quadrupole_matrices(xx,yy,zz,xy,xz,yz)
!           fac = ONE/EIGHT
!           do k = 1,3
!              BB(k,k) = fac*(sum(.B_field*.B_field) - .B_field(k)*.B_field(k))
!           end
!           do k = 1,3
!           do l = k+1,3
!              BB(k,l) = -TWO*fac*.B_field(k)*.B_field(l)
!           end
!           end
!           xx =      BB(1,1)*xx; xx = xx + BB(2,2)*yy; xx = xx + BB(3,3)*zz
!           xx = xx + BB(1,2)*xy; xx = xx + BB(1,3)*xz; xx = xx + BB(2,3)*yz
!           HH.alpha_alpha_plus(xx)
!           HH.beta_beta_plus(xx)
!           yz.destroy; xz.destroy; xy.destroy
!           zz.destroy; yy.destroy; xx.destroy
!         end
!
!         if (.scfdata.using_1e_srxa_term) then
!            Lx.create(.n_bf,.n_bf)
!            Ly.create(.n_bf,.n_bf)
!            Lz.create(.n_bf,.n_bf)
!            .make_spin_orbit_B_matrices(Lx,Ly,Lz)
!            fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
!            HH.beta_alpha_plus(Lx,factor=fac)
!            HH.beta_alpha_plus(Ly,factor=fac*I)
!            HH.alpha_alpha_plus(Lz,factor=fac)
!            HH.beta_beta_plus(Lz,factor==fac)
!            Lz.destroy; Ly.destroy; Lx.destroy
!         end
!
!      end
!
!      HH.make_hermitian
!
!   end


   make_pt_charge_matrix(Z) ::: leaky
   ! Make the point charge matrix "Z" from the point charges in .atom
   ! and the positions derived from ".scfdata.cluster".
   ! WARNING: the crystal asym unit charges must be defined.
      Z :: MAT{REAL}

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created,"no crystal data")
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.Hirshfeld_atom_info_made, "no Hirshfeld atom info")

      charge  :: VEC{REAL}*
      Z_c,pos :: MAT{REAL}*
      n_charges,q,c,fa,la,na,fb,lb,nb :: INT
      q_c :: REAL
      sh :: SHELL2

      ! Set up the cluster ... leaky
      .scfdata.cluster.destroy
      .scfdata.cluster.create(.crystal)
    ! .scfdata.cluster.set_fragment_geometry(.atom.coordinates,cartesian=TRUE)

      if (.debugging("make_pt_charge_matrix")) then
      stdout.text("crystal unit cell:")
      .scfdata.cluster.crystal.put_unit_cell_geometry
      end

      ! Make the cluster
      .scfdata.cluster.set_generation_method("within_radius")
      .scfdata.cluster.defragment= TRUE
      .scfdata.cluster.radius = .scfdata.cluster_radius
      .scfdata.cluster.make_info ! leaky

      if (.debugging("cluster charges")) then
      stdout.text("cluster information:")
      .scfdata.cluster.put
      end

      ! Make the cluster charges
      n_charges = .scfdata.cluster.n_atoms - .scfdata.cluster.n_fragment_atoms

      if (NOT .scfdata.using_qq_cluster_charges) then
         n_charges = 3*n_charges
         charge.create(n_charges)
         pos.create(3,n_charges)
         .scfdata.cluster.make_non_fragment_mu_charges(pos,charge)
      else
         n_charges = 9*n_charges
         charge.create(n_charges)
         pos.create(3,n_charges)
         .scfdata.cluster.make_non_fragment_qq_charges(pos,charge)
      end

      if (.debugging("cluster charges")) then
      stdout.text("Cluster point charges:")
      stdout.put(charge)
      stdout.text("Cluster point charge positions:")
      stdout.put(transpose(pos))
      end

      ! Make the charge contribution to one electron Hamiltonian
      Z = ZERO

      parallel do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Z_c.create(na,nb)
         do c = 1,charge.dim
            q_c = charge(c)
            if (q_c.equals(ZERO)) cycle
            sh.get_nuc(Z_c,ZERO,pos(:,c))
            Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - q_c*Z_c
         end

         Z_c.destroy
         sh.destroy_ptr_part

      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(Z)
      else
         Z.symmetric_reflect
      end
      .put_debug(Z,"make_pt_charge_matrix: Z")


      if (.scfdata.save_cluster_charges) then
         .scfdata.cluster_charges.destroy
         .scfdata.cluster_charge_positions.destroy
         .scfdata.cluster_charges => charge
         .scfdata.cluster_charge_positions => pos
      else
         pos.destroy
         charge.destroy
      end

   end

   make_Lorentz_core(Z) ::: leaky
   ! Add the local electric fields "F"  to the core matrix, made from
   ! the Lorentz factor tensors
      Z :: MAT{REAL}, target

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.Hirshfeld_atom_info_made,"no Hirshfeld charges and dipoles")

      wt, xa,ya,za,a2 :: VEC{REAL}*
      rF,r1,r2,r3, ga,gb, pF,ww :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      F,ZZ,pt,grida,gridb,bf_save :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      cutoff, fac,val :: REAL
      n_pt,n_keep, c,ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, as, a,b,i,j,n,p :: INT

      ! Set up grids, atomic densities, overlapping_atoms -- leaky
      .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Make the local Lorentz fields at every atom
      F.create(3,.n_atom)
      .make_Lorentz_fields(F) 

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Initialise
      Z = ZERO

      ! Loop over integration atoms "c"
      parallel do c = 1,.n_atom

         ! Get the Becke grid for atom "c"
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Overlapping atoms
         overlapping_atom => .overlapping_atoms_for_atom(c).element

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms 
         ! are used ... otherwise nothing is skipped
         .apply_stockholder_atom_weight(wt,c,pt)

         ! Prune the grid with new "wt", get saved bf grid bf_save, 
         ! and new no of points, n_pt -- leaky
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Integration points
         r1 => pt(:,1) 
         r2 => pt(:,2) 
         r3 => pt(:,3)

         ! r.F for each grid point
         rF.create(n_pt)
         rF = r1*F(1,c) + r2*F(2,c) + r3*F(3,c)

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Loop c-overlapping atoms "oa"
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "oa" 
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .precomputed_basis_shellpair(as,1).a
               sha.position = ra

               ! Make shell "sa" skipa list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element => skipa

               ! Make/copy the "sa" basis function grida
               ! This must be copied since skipa could be TRUE
               grida.create(n_keep,na)
               if (oa==c) then
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        grida(i,a) = bf_save(n,a+fa-fba)
                     end
                  end
               else
                  sha.make_skip_grid(grida,n_keep,na,xa,ya,za,a2,skipa,n_pt)
               end
               bf_grid(sa).element => grida

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob) 
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     if (bf_skip(sb).element.destroyed) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb => bf_skip(sb).element 
                     gridb => bf_grid(sb).element 

                     ! How many points in common?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Density block
                     ZZ => Z(fa:la,fb:lb)

                     if (na*nb==1) then

                        ! Add density contribution to rho
                        ga => grida(:,1)
                        gb => gridb(:,1)
                        i = 0; j = 0
                        val = ZERO
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           fac = ga(i)*gb(j)*wt(n)
                           val = val + fac * rF(n)
                        end
                        ZZ(1,1) = ZZ(1,1) + val

                     else

                        ! Create space for gathered index info
                        pi.create(n_keep); pj.create(n_keep); ww.create(n_keep)
                        pF.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           ww(p) = wt(n)
                           pF(p) = rF(n)
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga => grida(:,a)
                           do b = 1,nb
                              gb  => gridb(:,b)
                              val = ZERO
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 fac = ga(i)*gb(j)*ww(p)
                                 val = val + fac * pF(p)
                              end
                              ZZ(a,b) = ZZ(a,b) + val
                           end
                        end

                        ! Clean up
                        pF.destroy
                        ww.destroy; pj.destroy; pi.destroy

                     end

                  end ! -- loops sa,sb
               end
            end       ! -- lops ca,cb
         end

         ! Clean up
         bf_save.destroy
         bf_grid.destroy
         bf_skip.destroy
         rF.destroy
         wt.destroy
         pt.destroy

      end ! -- integration atom c

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy; ya.destroy; xa.destroy
      F.destroy

      ! Parallel
      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(Z)
      else
         Z.symmetric_reflect
      end

      .put_debug(Z,"make_Lorentz_core: Z")

   end

   make_Lorentz_fields(F) 
   ! Make the local Lorentz electric fields "F" at each atom site due
   ! to the crystal environment calculated from the charges and
   ! dipoles on each atom (so the Hirshfeld or other charges and
   ! dipoles need to be made). Only monopole and dipole contributions
   ! are made.
      F :: MAT{REAL}

   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.Hirshfeld_atom_info_made,"no Hirshfeld charges and dipoles")
   ENSURE(F.dim1==3,"wromg dim1, F")
   ENSURE(F.dim2==.n_atom,"wromg dim1, F")

      cluster :: CLUSTER*

      ! Set up the cluster ... leaky
      cluster.create(.crystal)
      cluster.set_fragment_geometry(.atom.coordinates,cartesian=TRUE)
      cluster.set_generation_method("within_radius")
      cluster.defragment= FALSE
      cluster.radius = 0.0d0
      cluster.make_info ! leaky

      ! Make the local Lorentz fields at every atom
      cluster.make_Lorentz_fields(F)
      cluster.destroy

      .put_debug(transpose(F),"make_Lorentz_fields: F")

   end

   make_Lorentz_interactions(I0,I1) 
   ! Make the local Lorentz interactions terms with charges and
   ! dipoles due to dipoles ONLY on the atoms in the crystal
   ! environment (so the Hirshfeld or other charges and dipoles need
   ! to be made).  A minus sign is neede when combined.
      I0 :: VEC{REAL}
      I1 :: MAT{REAL}

   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created,"no crystal")
   ENSURE(.Hirshfeld_atom_info_made,"no Hirshfeld charges and dipoles")
   ENSURE(I1.dim1==3,"wrong dim1, I2")
   ENSURE(I1.dim2==.n_atom,"wrong dim2, I2")
   ENSURE(I0.dim ==.n_atom,"wrong dim, I0")

      cluster :: CLUSTER*

      ! Set up the cluster ... leaky
      cluster.create(.crystal)
      cluster.set_fragment_geometry(.atom.coordinates,cartesian=TRUE)
      cluster.set_generation_method("within_radius")
      cluster.defragment= FALSE
      cluster.radius = 0.0d0
      cluster.make_info ! leaky

      ! Make the local Lorentz interactions with charges
      ! and dipoles at every atom
      cluster.make_Lorentz_interactions(I0,I1)
      cluster.destroy

   end

!  =======================
!  Dipole moment integrals
!  =======================

   make_dipole_matrices(Dx,Dy,Dz)
   ! Make "Di", the dipole moment integral matrices.
      Dx,Dy,Dz :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      DDx,DDy,DDz :: MAT{REAL}*
      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      Dx = ZERO
      Dy = ZERO
      Dz = ZERO

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         DDx.create(na,nb)
         DDy.create(na,nb)
         DDz.create(na,nb)
         sh.make_dipole_ints(DDx,DDy,DDz, .gauge_origin)

         Dx(fa:la,fb:lb) = Dx(fa:la,fb:lb) + DDx
         Dy(fa:la,fb:lb) = Dy(fa:la,fb:lb) + DDy
         Dz(fa:la,fb:lb) = Dz(fa:la,fb:lb) + DDz

         DDz.destroy
         DDy.destroy
         DDx.destroy
         sh.destroy_ptr_part

      end

      Dx.symmetric_reflect
      Dy.symmetric_reflect
      Dz.symmetric_reflect

   end

   electronic_dipole_moment result (res)
   ! Return the electronic dipole moment
      res :: VEC{REAL}(3)
      Dx,Dy,Dz :: MAT{REAL}*
      Dx.create(.n_bf,.n_bf)
      Dy.create(.n_bf,.n_bf)
      Dz.create(.n_bf,.n_bf)
      .make_dipole_matrices(Dx,Dy,Dz)
      res(1) = -.expectation(Dx) ! Minus sign for electron charge
      res(2) = -.expectation(Dy)
      res(3) = -.expectation(Dz)
      Dz.destroy; Dy.destroy; Dx.destroy
   end

   nuclear_dipole_moment result (res)
   ! Return the nuclear dipole moment
      res :: VEC{REAL}(3)
      res = .atom.nuclear_dipole_moment
   end

!  ===========================
!  Quadrupole moment integrals
!  ===========================

   make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
   ! Make "Qij", the quadrupole moment integral matrices.
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      QQxx,QQyy,QQzz,QQxy,QQxz,QQyz :: MAT{REAL}*
      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
      Qxy = ZERO; Qxz = ZERO; Qyz = ZERO

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         QQxx.create(na,nb); QQyy.create(na,nb); QQzz.create(na,nb)
         QQxy.create(na,nb); QQxz.create(na,nb); QQyz.create(na,nb)
         sh.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz, .gauge_origin)

         Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) + QQxx
         Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) + QQyy
         Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) + QQzz
         Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) + QQxy
         Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) + QQxz
         Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) + QQyz

         QQyz.destroy; QQxz.destroy; QQxy.destroy
         QQzz.destroy; QQyy.destroy; QQxx.destroy
         sh.destroy_ptr_part

      end

      Qxx.symmetric_reflect; Qyy.symmetric_reflect; Qzz.symmetric_reflect
      Qxy.symmetric_reflect; Qxz.symmetric_reflect; Qyz.symmetric_reflect

   end

   electronic_quadrupole_moment result (res)
   ! Return the electronic quadrupole moments as a vectors in the
   ! order: xx, yy, zz, xy, xz, yz
      res :: VEC{REAL}(6)
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}*
      Qxx.create(.n_bf,.n_bf)
      Qyy.create(.n_bf,.n_bf)
      Qzz.create(.n_bf,.n_bf)
      Qxy.create(.n_bf,.n_bf)
      Qxz.create(.n_bf,.n_bf)
      Qyz.create(.n_bf,.n_bf)
      .make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
      res(1) = -.expectation(Qxx) ! Minus sign for electron charge
      res(2) = -.expectation(Qyy)
      res(3) = -.expectation(Qzz)
      res(4) = -.expectation(Qxy)
      res(5) = -.expectation(Qxz)
      res(6) = -.expectation(Qyz)
      Qyz.destroy; Qxz.destroy; Qxy.destroy
      Qzz.destroy; Qyy.destroy; Qxx.destroy
   end

   nuclear_quadrupole_moment result (res)
   ! Return the nuclear quadrupole moment
      res :: VEC{REAL}(6)
      res = .atom.nuclear_quadrupole_moment
   end

!  =========================
!  Octupole moment integrals
!  =========================

   make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
   ! Make "Oijk", the octupole moment integral matrices.
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz :: MAT{REAL}*
      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      Oxxx = ZERO; Oyyy = ZERO; Ozzz = ZERO
      Oxxy = ZERO; Oxxz = ZERO
      Oyyx = ZERO; Oyyz = ZERO
      Ozzx = ZERO; Ozzy = ZERO
      Oxyz = ZERO

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         OOxxx.create(na,nb); OOyyy.create(na,nb); OOzzz.create(na,nb)
         OOxxy.create(na,nb); OOxxz.create(na,nb)
         OOyyx.create(na,nb); OOyyz.create(na,nb)
         OOzzx.create(na,nb); OOzzy.create(na,nb)
         OOxyz.create(na,nb)
         sh.make_octupole_ints(OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz,.gauge_origin)

         Oxxx(fa:la,fb:lb) = Oxxx(fa:la,fb:lb) + OOxxx
         Oyyy(fa:la,fb:lb) = Oyyy(fa:la,fb:lb) + OOyyy
         Ozzz(fa:la,fb:lb) = Ozzz(fa:la,fb:lb) + OOzzz
         Oxxy(fa:la,fb:lb) = Oxxy(fa:la,fb:lb) + OOxxy
         Oxxz(fa:la,fb:lb) = Oxxz(fa:la,fb:lb) + OOxxz
         Oyyx(fa:la,fb:lb) = Oyyx(fa:la,fb:lb) + OOyyx
         Oyyz(fa:la,fb:lb) = Oyyz(fa:la,fb:lb) + OOyyz
         Ozzx(fa:la,fb:lb) = Ozzx(fa:la,fb:lb) + OOzzx
         Ozzy(fa:la,fb:lb) = Ozzy(fa:la,fb:lb) + OOzzy
         Oxyz(fa:la,fb:lb) = Oxyz(fa:la,fb:lb) + OOxyz

         OOxyz.destroy
         OOzzy.destroy; OOzzx.destroy
         OOyyz.destroy; OOyyx.destroy
         OOxxz.destroy; OOxxy.destroy
         OOzzz.destroy; OOyyy.destroy; OOxxx.destroy
         sh.destroy_ptr_part

      end

      Oxxx.symmetric_reflect; Oyyy.symmetric_reflect; Ozzz.symmetric_reflect
      Oxxy.symmetric_reflect; Oxxz.symmetric_reflect
      Oyyx.symmetric_reflect; Oyyz.symmetric_reflect
      Ozzx.symmetric_reflect; Ozzy.symmetric_reflect
      Oxyz.symmetric_reflect

   end

   electronic_octupole_moment result (res)
   ! Return the electronic octupole moments as a vectors in the
   ! order: xxx, yyy, zzz, xxy, xxz, yyx, yyz, zzx, zzy, xyz
      res :: VEC{REAL}(10)
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}*
      Oxxx.create(.n_bf,.n_bf)
      Oyyy.create(.n_bf,.n_bf)
      Ozzz.create(.n_bf,.n_bf)
      Oxxy.create(.n_bf,.n_bf)
      Oxxz.create(.n_bf,.n_bf)
      Oyyx.create(.n_bf,.n_bf)
      Oyyz.create(.n_bf,.n_bf)
      Ozzx.create(.n_bf,.n_bf)
      Ozzy.create(.n_bf,.n_bf)
      Oxyz.create(.n_bf,.n_bf)
      .make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
      res(1)  = -.expectation(Oxxx) ! Minus sign for electron charge
      res(2)  = -.expectation(Oyyy)
      res(3)  = -.expectation(Ozzz)
      res(4)  = -.expectation(Oxxy)
      res(5)  = -.expectation(Oxxz)
      res(6)  = -.expectation(Oyyx)
      res(7)  = -.expectation(Oyyz)
      res(8)  = -.expectation(Ozzx)
      res(9)  = -.expectation(Ozzy)
      res(10) = -.expectation(Oxyz)
      Oxyz.destroy
      Ozzy.destroy; Ozzx.destroy
      Oyyz.destroy; Oyyx.destroy
      Oxxz.destroy; Oxxy.destroy
      Ozzz.destroy; Oyyy.destroy; Oxxx.destroy
   end

   nuclear_octupole_moment result (res)
   ! Return the nuclear octupole moment
      res :: VEC{REAL}(10)
      res = .atom.nuclear_octupole_moment
   end

!  ========================
!  Electric field integrals
!  ========================

   make_electric_field_matrices(Ex,Ey,Ez,c)
   ! Make "Ei", the electric fields integral matrices evaluated at
   ! position "c".
      Ex,Ey,Ez :: MAT{REAL}
       c :: VEC{REAL}(3)

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      EEx,EEy,EEz :: MAT{REAL}*
      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      Ex = ZERO; Ey = ZERO; Ez = ZERO

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         EEx.create(na,nb); EEy.create(na,nb); EEz.create(na,nb)
         sh.make_E_field_ints(EEx,EEy,EEz,c)

         Ex(fa:la,fb:lb) = Ex(fa:la,fb:lb) + EEx
         Ey(fa:la,fb:lb) = Ey(fa:la,fb:lb) + EEy
         Ez(fa:la,fb:lb) = Ez(fa:la,fb:lb) + EEz

         sh.destroy_ptr_part
         EEz.destroy; EEy.destroy; EEx.destroy

      end

      Ex.symmetric_reflect; Ey.symmetric_reflect; Ez.symmetric_reflect

   end

   electronic_E_field_at_nuclei result (res)
   ! Return the electronic contribution to the electric fields
   ! at the nuclei as a (3 x .n_atom) array
      res :: MAT{REAL}(3,.n_atom)
      Ex,Ey,Ez :: MAT{REAL}*
       a :: INT
      Ex.create(.n_bf,.n_bf)
      Ey.create(.n_bf,.n_bf)
      Ez.create(.n_bf,.n_bf)
      do a = 1,.n_atom
         .make_electric_field_matrices(Ex,Ey,Ez,.atom(a).position)
         res(1,a) = -.expectation(Ex) ! minus sign for electron charge
         res(2,a) = -.expectation(Ey)
         res(3,a) = -.expectation(Ez)
      end
      Ez.destroy; Ey.destroy; Ex.destroy
   end

   nuclear_E_field_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields
   ! at the nuclei as a (3 x .n_atom) array
      res :: MAT{REAL}(3,.n_atom)
      res = .atom.nuclear_E_field_at_nuclei
   end

!  =================================
!  Electric field gradient integrals
!  =================================

   make_EFG_matrices(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)
   ! Make "Eij", the electric field gradient (EFG) integral matrices evaluated
   ! at point "c".
      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}
      c :: VEC{REAL}(3)

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      EExx,EEyy,EEzz,EExy,EExz,EEyz :: MAT{REAL}*
      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      Exx = ZERO; Eyy = ZERO; Ezz = ZERO
      Exy = ZERO; Exz = ZERO; Eyz = ZERO
      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         EExx.create(na,nb); EEyy.create(na,nb); EEzz.create(na,nb)
         EExy.create(na,nb); EExz.create(na,nb); EEyz.create(na,nb)
         sh.make_E_gradient_ints(EExx,EEyy,EEzz,EExy,EExz,EEyz,c)

         Exx(fa:la,fb:lb) = Exx(fa:la,fb:lb) + EExx
         Eyy(fa:la,fb:lb) = Eyy(fa:la,fb:lb) + EEyy
         Ezz(fa:la,fb:lb) = Ezz(fa:la,fb:lb) + EEzz
         Exy(fa:la,fb:lb) = Exy(fa:la,fb:lb) + EExy
         Exz(fa:la,fb:lb) = Exz(fa:la,fb:lb) + EExz
         Eyz(fa:la,fb:lb) = Eyz(fa:la,fb:lb) + EEyz

         sh.destroy_ptr_part
         EEyz.destroy; EExz.destroy; EExy.destroy
         EEzz.destroy; EEyy.destroy; EExx.destroy

      end

      Exx.symmetric_reflect; Eyy.symmetric_reflect; Ezz.symmetric_reflect
      Exy.symmetric_reflect; Exz.symmetric_reflect; Eyz.symmetric_reflect

   end

   electronic_EFG_at_nuclei result (res)
   ! Return the electronic contribution to the electric field gradient
   ! (EFG) at the nuclei as a (6 x .n_atom) array. The order of the
   ! electric field gradient elements is: xx, yy, zz, xy, xz, yz
      res :: MAT{REAL}(6,.n_atom)
      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}*
       a :: INT
      Exx.create(.n_bf,.n_bf)
      Eyy.create(.n_bf,.n_bf)
      Ezz.create(.n_bf,.n_bf)
      Exy.create(.n_bf,.n_bf)
      Exz.create(.n_bf,.n_bf)
      Eyz.create(.n_bf,.n_bf)
      do a = 1,.n_atom
         .make_EFG_matrices(Exx,Eyy,Ezz,Exy,Exz,Eyz,.atom(a).position)
         res(1,a) = -.expectation(Exx)
         res(2,a) = -.expectation(Eyy)
         res(3,a) = -.expectation(Ezz)
         res(4,a) = -.expectation(Exy)
         res(5,a) = -.expectation(Exz)
         res(6,a) = -.expectation(Eyz)
      end
      Eyz.destroy; Exz.destroy; Exy.destroy
      Ezz.destroy; Eyy.destroy; Exx.destroy
   end

   nuclear_EFG_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields gradient (EFG)
   ! at the nuclei as a (6 x .n_atom) array
      res :: MAT{REAL}(6,.n_atom)
      res = .atom.nuclear_EFG_at_nuclei
   end

!  ==========================
!  Angular momentum integrals
!  ==========================

   make_L_matrices(Lx,Ly,Lz)
   ! Make the angular momentum matrices  "Lx", "Ly", and "Lz".
      Lx,Ly,Lz :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2

      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
         sh.make_L_ints(Lx(fa:la,fb:lb),Ly(fa:la,fb:lb),Lz(fa:la,fb:lb), .gauge_origin)
         sh.destroy_ptr_part
      end

      Lx.antisymmetric_reflect
      Ly.antisymmetric_reflect
      Lz.antisymmetric_reflect

   end

!  ====================
!  Spin-orbit integrals
!  ====================

   make_spin_orbit_matrices(SOx,SOy,SOz)
   ! Calculate the spin orbit matrices "SOx" "SOy" and "SOz"
      SOx,SOy,SOz :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      SOx_c,SOy_c,SOz_c :: MAT{REAL}*
      q,c,fa,la,na,fb,lb,nb :: INT
      Z :: REAL
      sh :: SHELL2

      SOx = ZERO; SOy = ZERO; SOz = ZERO
      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         SOx_c.create(na,nb)
         SOy_c.create(na,nb)
         SOz_c.create(na,nb)
         do c = 1,.n_atom
            Z = .atom(c).nuclear_charge
            sh.make_spin_orbit_ints(SOx_c,SOy_c,SOz_c, .atom(c).position)
            SOx(fa:la,fb:lb) = SOx(fa:la,fb:lb) + Z*SOx_c
            SOy(fa:la,fb:lb) = SOy(fa:la,fb:lb) + Z*SOy_c
            SOz(fa:la,fb:lb) = SOz(fa:la,fb:lb) + Z*SOz_c
         end
         sh.destroy_ptr_part
         SOz_c.destroy; SOy_c.destroy; SOx_c.destroy

      end

      SOx.antisymmetric_reflect
      SOy.antisymmetric_reflect
      SOz.antisymmetric_reflect

   end

   make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
   ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy"
   ! and "SOBz"
      SOBx,SOBy,SOBz :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}*
      n_bf :: INT

      n_bf = .n_bf

      Qxx.create(n_bf,n_bf); Qxy.create(n_bf,n_bf); Qxz.create(n_bf,n_bf)
      Qyx.create(n_bf,n_bf); Qyy.create(n_bf,n_bf); Qyz.create(n_bf,n_bf)
      Qzx.create(n_bf,n_bf); Qzy.create(n_bf,n_bf); Qzz.create(n_bf,n_bf)

      .make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)

      SOBx = (Qyy + Qzz)*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
      SOBy = (Qxx + Qzz)*.B_field(2) - Qyx*.B_field(1) - Qyz*.B_field(3)
      SOBz = (Qxx + Qyy)*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2)

      Qzz.destroy; Qzy.destroy; Qzx.destroy
      Qyz.destroy; Qyy.destroy; Qyx.destroy
      Qxz.destroy; Qxy.destroy; Qxx.destroy

      SOBx.symmetric_reflect
      SOBy.symmetric_reflect
      SOBz.symmetric_reflect

   end

   make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
   ! Calculate the gauge modified (B field) spin orbit quadrupole matrices
   ! "Qij".
      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      xx,xy,xz,yx,yy,yz,zx,zy,zz :: MAT{REAL}*
      q,c,fa,la,na,fb,lb,nb :: INT
      Z :: REAL
      sh :: SHELL2

      Qxx = ZERO; Qxy = ZERO; Qxz = ZERO
      Qyx = ZERO; Qyy = ZERO; Qyz = ZERO
      Qzx = ZERO; Qzy = ZERO; Qzz = ZERO

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         xx.create(na,nb); xy.create(na,nb); xz.create(na,nb)
         yx.create(na,nb); yy.create(na,nb); yz.create(na,nb)
         zx.create(na,nb); zy.create(na,nb); zz.create(na,nb)

         do c = 1,.n_atom
            Z = .atom(c).nuclear_charge
            sh.make_spin_orbit_B_ints(xx,xy,xz,yx,yy,yz,zx,zy,zz, &
                                    .atom(c).position, .gauge_origin)
            ! minus due to r-c, not c-r in the electric field part
            ! this comment should go in gaussian2?
            Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) - Z*xx
            Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) - Z*xy
            Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) - Z*xz
            Qyx(fa:la,fb:lb) = Qyx(fa:la,fb:lb) - Z*yx
            Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) - Z*yy
            Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) - Z*yz
            Qzx(fa:la,fb:lb) = Qzx(fa:la,fb:lb) - Z*zx
            Qzy(fa:la,fb:lb) = Qzy(fa:la,fb:lb) - Z*zy
            Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) - Z*zz
         end

         sh.destroy_ptr_part
         zz.destroy; zy.destroy; zx.destroy
         yz.destroy; yy.destroy; yx.destroy
         xz.destroy; xy.destroy; xx.destroy

      end

      Qxx.symmetric_reflect; Qxy.symmetric_reflect; Qxz.symmetric_reflect
      Qyx.symmetric_reflect; Qyy.symmetric_reflect; Qyz.symmetric_reflect
      Qzx.symmetric_reflect; Qzy.symmetric_reflect; Qzz.symmetric_reflect

   end

!  ==============
!  ZORA integrals
!  ==============

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
   ! This is useful for numerical integration of nuclear attraction
   ! integrals. Dummay atom charges are included.
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      n_pts,n,i :: INT
      Z_n,r :: REAL
      pos :: VEC{REAL}(3)

      n_pts = size(pts,1)
      values = ZERO
      do n = 1,.n_atom
         Z_n = .atom(n).nuclear_charge
         pos = .atom(n).position
         do i = 1,n_pts
            r = pos.distance_to(pts(i,:))
            if (r>tiny(r)) then
              values(i) = values(i) + Z_n / r
            else
              values(i) = values(i) + huge(ONE)
            end
         end
      end

   end

   electric_potential(values,grid,charges,positions) ::: selfless
   ! Calculate the electric potential "values" at a set of "grid" points, coming
   ! from a given set "charges" located at "positions".  This is useful for
   ! numerical integration of the potential.
      values,charges :: VEC{REAL}
      grid,positions :: MAT{REAL}
   ENSURE(charges.dim==positions.dim1,"inconsistent charges and positions arrays")
   ENSURE(positions.dim2==3,"wrong 2nd dimension, positions array")
   ENSURE(values.dim==grid.dim1,"inconsistent values and grid array")
      n,i :: INT
      q,r :: REAL
      pos :: VEC{REAL}(3)
      values = ZERO
      do n = 1,charges.dim
         q = charges(n)
         pos = positions(n,:)
         do i = 1,grid.dim1
            r = pos.distance_to(grid(i,:))
            if (r>tiny(r)) then
              values(i) = values(i) + q / r
            else
              values(i) = values(i) + TEN**6 ! something very large
            end
         end
      end
   end

   ZORA_potential(values,pts)
   ! Calculate the one electron ZORA potential "values" of a given set of "pts".
   ! This is useful for numerical integration.
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN
      fac :: REAL
      .nuclear_potential(values,pts)
      fac    = ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      values = ONE/(TWO + fac*values)
   end

   make_1e_ZORA_matrices(T,Zx,Zy,Zz)
   ! Calculate the one-electron ZORA spin orbit matrices numerically.
   ! This includes the relativitically modified kinetic energy integrals.
      T, Zx,Zy,Zz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.overlapping_atoms.created,"no overlapping_atoms")
      ZORA  :: MAT4{REAL}*
      a1,b1 :: MAT3{REAL}*
      pt    :: MAT{REAL}*
      wt,V0 :: VEC{REAL}*
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      q,atom_a,atom_b,n_pt,fa,la,na,fb,lb,nb,k,l,a,b,aa,bb,ma,mb :: INT
      same_atoms :: BIN

      ZORA.create(.n_bf,.n_bf,3,3)

      ! Make the lower half of the ZORA spin orbit integrals
      nullify(a1); nullify(b1)

      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2
         end                                    ! Make the grid points and weights
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                         ! Keep the weight_is_0 array
         V0.create(n_pt)                        ! local potential grids
         .ZORA_potential(V0,pt)
         .becke_grid.make_bf_grids(a1,b1,ma,mb,pt,atoms)
         V0 = wt*V0
         wt.destroy; pt.destroy
         do k = 1,3
         do l = 1,3
         do a = 1,na
         do b = 1,nb
            aa = fa + a
            bb = fb + b
            ZORA(aa,bb,k,l) = sum(V0*a1(:,a,k)*b1(:,b,l))
         end
         end
         end
         end
         V0.destroy
         if (same_atoms) then; a1.destroy; nullify(b1)
         else;                 b1.destroy; a1.destroy
         end
      end

      ! Make the upper half of the ZORA spin orbit integrals
      do k = 1,3
      do l = 1,3
      do a = 1,.n_bf
      do b = 1,a-1
         ZORA(b,a,l,k) = ZORA(a,b,k,l)
      end
      end
      end
      end

      ! Assemble the ZORA contribution to the 1 electron hamiltonian
      ! Scalar kinetic energy contribution
      T = ZORA(:,:,1,1) + ZORA(:,:,2,2) + ZORA(:,:,3,3)

      ! Spin-dependent spin-orbit contribution
      Zx = ZORA(:,:,2,3) - ZORA(:,:,3,2)
      Zy = ZORA(:,:,3,1) - ZORA(:,:,1,3)
      Zz = ZORA(:,:,1,2) - ZORA(:,:,2,1)

      ZORA.destroy

   end

   make_ENA_matrix(Z)
   ! Calculate the one-electron electron nuclear attraction matrix numerically.
      Z :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")

      pt,a0,b0 :: MAT{REAL}*
      wt,V0 :: VEC{REAL}*
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      q,atom_a,atom_b,n_pt,fa,la,na,fb,lb,nb,a,b,aa,bb,ma,mb :: INT
      same_atoms :: BIN

      nullify(a0); nullify(b0)
      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2
         end                                    ! Make the grid points and weights
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                         ! Keep the weight_is_0 array
         V0.create(n_pt)                        ! local potential grids
         .nuclear_potential(V0,pt)
         .becke_grid.make_bf_grids(a0,b0,ma,mb,pt,atoms)
         V0 = wt*V0
         wt.destroy; pt.destroy
         do a = 1,na
         do b = 1,nb
            aa = fa + a
            bb = fb + b
            Z(aa,bb) = sum(V0*a0(:,a)*b0(:,b))
         end
         end
         V0.destroy
         if (same_atoms) then; a0.destroy; nullify(b0)
         else;                 b0.destroy; a0.destroy
         end
      end

      Z.symmetric_reflect

   end

!  ================================
!  Douglas-Kroll-Hess PVP integrals
!  ================================

   make_primitive_DKH_matrices(T,SOx,SOy,SOz)
   ! Calculate the primitive Douglas-Kroll-Hess integrals
      T,SOx,SOy,SOz :: MAT{REAL}
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")
   ENSURE(SOx.is_same_shape_as(T),"wrong shape, SOx")
   ENSURE(SOy.is_same_shape_as(T),"wrong shape, SOy")
   ENSURE(SOz.is_same_shape_as(T),"wrong shape, SOz")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,c :: INT
      Z :: REAL
      G :: GAUSSIAN2
      atom :: ATOM*
      Tc,SOxc,SOyc,SOzc :: MAT{REAL}*

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! Calculate the primitive integrals
      nps = frst.dim
      T = ZERO
      SOx = ZERO; SOy = ZERO; SOz = ZERO
      do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a); na = la - fa + 1
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b); nb = lb - fb + 1
             Tc.create(na,nb)
           SOxc.create(na,nb)
           SOyc.create(na,nb)
           SOzc.create(na,nb)
           do c = 1,.n_atom
              atom => .atom(c)
              G.make_normalised_DKH_ints(Tc,SOxc,SOyc,SOzc,atom.position,.use_spherical_basis)
              Z = atom.nuclear_charge
                T(fa:la,fb:lb) =   T(fa:la,fb:lb) - Z * Tc
              SOx(fa:la,fb:lb) = SOx(fa:la,fb:lb) - Z * SOxc
              SOy(fa:la,fb:lb) = SOy(fa:la,fb:lb) - Z * SOyc
              SOz(fa:la,fb:lb) = SOz(fa:la,fb:lb) - Z * SOzc
           end
           SOzc.destroy; SOyc.destroy; SOxc.destroy
           Tc.destroy
        end
      end

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy

      ! Make a symmetric matrix
      T.symmetric_reflect
      SOx.antisymmetric_reflect
      SOy.antisymmetric_reflect
      SOz.antisymmetric_reflect

      ! Debug, turn on with debug_on "key"
      .put_debug(T,  "make_primitive_DKH_matrices: T")
      .put_debug(SOx,"make_primitive_DKH_matrices: SOx")
      .put_debug(SOy,"make_primitive_DKH_matrices: SOy")
      .put_debug(SOz,"make_primitive_DKH_matrices: SOz")

      ! Test
    ! .make_fd_DKH_matrix(T,SOx,SOy,SOz)

   end

   make_primitive_DK3_ppZpp_mx(ppZpp)
   ! Calculate the primitive Douglas-Kroll-Hess integrals
      ppZpp :: MAT{REAL}
!     SOx,SOy,SOz :: MAT{REAL}
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(ppZpp.is_square, "T must be square")
   ENSURE(ppZpp.dim1==.n_prim, "wrong size, T")
!   ENSURE(SOx.is_same_shape_as(T),"wrong shape, SOx")
!   ENSURE(SOy.is_same_shape_as(T),"wrong shape, SOy")
!   ENSURE(SOz.is_same_shape_as(T),"wrong shape, SOz")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,na,fb,lb,nb,c :: INT
     Z :: REAL
     G :: GAUSSIAN2
     atom :: ATOM*
     Tc :: MAT{REAL}*
!     SOxc,SOyc,SOzc :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a); na = la - fa + 1
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b); nb = lb - fb + 1
           Tc.create(na,nb)
           do c = 1,.n_atom
              atom => .atom(c)
              G.make_normalised_DK3_ppZpp_ints(Tc,atom.position,.use_spherical_basis)
              Z = atom.nuclear_charge
              ppZpp(fa:la,fb:lb) =   ppZpp(fa:la,fb:lb) - Z * Tc
           end
           Tc.destroy
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     ppZpp.symmetric_reflect

     ! Debug, turn on with debug_on "key"
     .put_debug(ppZpp,"make_primitive_DK3_ppZpp_mx: ppZpp")

   end

   make_fd_DKH_matrix(T,SOx,SOy,SOz)
   ! Calculate the primitive nuclear attraction matrix "Z"
   ! Using finidit difference to check the routine above.
      T,SOx,SOy,SOz :: MAT{REAL}
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")
   ENSURE(SOx.is_same_shape_as(T),"wrong shape, SOx")
   ENSURE(SOy.is_same_shape_as(T),"wrong shape, SOy")
   ENSURE(SOz.is_same_shape_as(T),"wrong shape, SOz")

      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*
      nps,a,b,fa,la,na,fb,lb,nb,c :: INT
      G :: GAUSSIAN2
      atom :: ATOM*
      Zc :: MAT{REAL}*

      Zpq :: MAT4{REAL}*
      i,j,p,q :: INT
      pos  :: VEC{REAL}(3)
      step,step2 :: REAL

      step  = 0.00005d0
      step2 = QUARTER/(step*step)

      ! Make the indexing arrays
      .atom.make_primitive_limits(frst,last,at,l,ex)

      ! Calculate the primitive integrals
      nps = frst.dim
      Zpq.create(.n_prim,.n_prim,3,3)
      Zpq = ZERO

      ! Loop over finide difference steps
      do p =  1,3
      do i = -1,1,2
      do q =  1,3
      do j = -1,1,2

        ! Calculate Z integrals for this step
        do a = 1,nps
           G.a.set_l(l(a))
           pos = .atom(at(a)).position
           pos(p) = pos(p) + i*step
           G.a.set_position(pos)
           G.a.set_exponent(ex(a))
           fa = frst(a); la = last(a); na = la - fa + 1
           do b = 1,a
              G.b.set_l(l(b))
              pos = .atom(at(b)).position
              pos(q) = pos(q) + j*step
              G.b.set_position(pos)
              G.b.set_exponent(ex(b))
              fb = frst(b); lb = last(b); nb = lb - fb + 1
              Zc.create(na,nb)
              do c = 1,.n_atom
                 atom => .atom(c)
                 G.make_normalised_NA_ints(Zc,atom.position,.use_spherical_basis)
                 Zpq(fa:la,fb:lb,p,q) = Zpq(fa:la,fb:lb,p,q) - i*j*atom.nuclear_charge*Zc*step2
              end
              Zc.destroy
           end
        end

      end
      end
      end
      end

      ! Clean up indexing arrays
      ex.destroy; l.destroy; at.destroy
      last.destroy; frst.destroy

      ! Make a symmetric matrix
      do p =  1,3
      do q =  1,3
        Zpq(:,:,p,q).symmetric_reflect
      end
      end

      ! Make the T, SOx, SOy, SOz matrices
       T = Zpq(:,:,1,1) + Zpq(:,:,2,2) + Zpq(:,:,3,3)
      SOx = Zpq(:,:,2,3) - Zpq(:,:,3,2)
      SOy = Zpq(:,:,3,1) - Zpq(:,:,1,3)
      SOz = Zpq(:,:,1,2) - Zpq(:,:,2,1)

      ! Clean up
      Zpq.destroy

      .put_debug(T  ,"make_fd_DKH_matrix: T")
      .put_debug(SOx,"make_fd_DKH_matrix: SOx")
      .put_debug(SOy,"make_fd_DKH_matrix: SOy")
      .put_debug(SOz,"make_fd_DKH_matrix: SOz")

   end

!  ==========================
!  Crystal structure routines
!  ==========================

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)]
      dens :: MAT{REAL}, target
      k_pts :: MAT{REAL}, IN
      res :: VEC{CPX}, OUT

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      k_max,k,fa,fb,la,lb,na,nb,q,atom_a,atom_b :: INT
      ft_ab :: MAT3{CPX}*
      dens_ba :: MAT{REAL}*
      cutoff :: REAL
      sh :: SHELL2

      k_max = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs

      res = ZERO

      parallel do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (sh.skip_ft(cutoff)) then
           sh.destroy_ptr_part
           cycle
         end

         ft_ab.create(k_max,na,nb)
         .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)

         dens_ba => dens(fa:la,fb:lb)
         if (fa/=fb) then ! count off-diagonals twice.
           do k = 1,k_max
              res(k) = res(k) + TWO*sum(ft_ab(k,:,:)*dens_ba(:,:))
           end
         else
           do k = 1,k_max
              res(k) = res(k) + sum(ft_ab(k,:,:)*dens_ba(:,:))
           end
         end

         ft_ab.destroy
         sh.destroy_ptr_part

      end

      PARALLEL_SUM(res)

   end

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)].
      dens :: MAT{CPX}, target
      k_pts :: MAT{REAL}
      res :: VEC{CPX}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      k_max,q,k,fa,la,fb,lb,na,nb,atom_a,atom_b :: INT
      ft_ab :: MAT3{CPX}*
      dens_ba :: MAT{CPX}*
      cutoff :: REAL
      sh :: SHELL2

      k_max = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs

      res = ZERO

      parallel do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (sh.skip_ft(cutoff)) then
           sh.destroy_ptr_part
           cycle
         end

         ft_ab.create(k_max,na,nb)
         .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)

         dens_ba => dens(fb:lb,fa:la)
         if (fa/=fb) then ! count off-diagonals twice.
           do k = 1,k_max
              res(k) = res(k) + TWO*ft_ab(k,:,:).trace_product_with(dens_ba)
           end
         else
           do k = 1,k_max
              res(k) = res(k) + ft_ab(k,:,:).trace_product_with(dens_ba)
           end
         end

         ft_ab.destroy
         sh.destroy_ptr_part

      end

      PARALLEL_SUM(res)

   end

   make_ft_deriv_U(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [k_max,n_atom*6]
      dens :: MAT{REAL}, target
      k_pts :: MAT{REAL}, IN
      res :: MAT{CPX}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      ft_ab2,tmp1,tmp2,tmpa1,tmpa2,tmpa3,tmpa4,tmpa5,tmpa6 :: CPX
      k_max,k,fa,fb,la,lb,na,nb,q,atom_a,atom_b,basea,baseb :: INT
      delta,g,separation,x,y,z,z2 :: REAL
      diff :: VEC{REAL}(3)
      ft_ab :: MAT3{CPX}*
      dens_ba :: MAT{REAL}*
      cutoff :: REAL
      sh :: SHELL2

      k_max = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs

      res = ZERO

      parallel do q = 1,.n_shell_pairs

       .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

       if (sh.skip_ft(cutoff)) then
         sh.destroy_ptr_part
         cycle
       end

       ft_ab.create(k_max,na,nb)
       .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)

       dens_ba => dens(fb:lb,fa:la)

       if (fa/=fb) ft_ab = TWO * ft_ab ! count off-diagonals twice.

       diff = .atom(atom_a).position-.atom(atom_b).position
       separation = diff.norm
       g = HALF
       if (separation > 2.5d0) g=QUARTER
       g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

       basea = (atom_a-1) * 6

       if (atom_a==atom_b) then

         delta = TWO * g
         do k = 1,k_max
           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * delta
           x = k_pts(k,1)           ! SBh_x
           y = k_pts(k,2)           ! SBh_y
           z = k_pts(k,3)           ! SBh_z
           tmp1 = ft_ab2 * x
           tmp2 = ft_ab2 * y
           z2 = TWO * z
           res(basea+1,k) = res(basea+1,k) + tmp1 * x
           res(basea+2,k) = res(basea+2,k) + tmp1 * y * TWO
           res(basea+3,k) = res(basea+3,k) + tmp1 * z2
           res(basea+4,k) = res(basea+4,k) + tmp2 * y
           res(basea+5,k) = res(basea+5,k) + tmp2 * z2
           res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
         end

       else

         baseb = (atom_b-1) * 6
         do k = 1,k_max
           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * g
           x = k_pts(k,1)           ! SBh_x
           y = k_pts(k,2)           ! SBh_y
           z = k_pts(k,3)           ! SBh_z
           tmp1 = ft_ab2 * x
           tmp2 = ft_ab2 * y
           z2 = TWO * z
           tmpa1 = tmp1 * x
           tmpa2 = tmp1 * y * TWO
           tmpa3 = tmp1 * z2
           tmpa4 = tmp2 * y
           tmpa5 = tmp2 * z2
           tmpa6 = ft_ab2 * z * z
           res(basea+1,k) = res(basea+1,k) + tmpa1
           res(basea+2,k) = res(basea+2,k) + tmpa2
           res(basea+3,k) = res(basea+3,k) + tmpa3
           res(basea+4,k) = res(basea+4,k) + tmpa4
           res(basea+5,k) = res(basea+5,k) + tmpa5
           res(basea+6,k) = res(basea+6,k) + tmpa6
           res(baseb+1,k) = res(baseb+1,k) + tmpa1
           res(baseb+2,k) = res(baseb+2,k) + tmpa2
           res(baseb+3,k) = res(baseb+3,k) + tmpa3
           res(baseb+4,k) = res(baseb+4,k) + tmpa4
           res(baseb+5,k) = res(baseb+5,k) + tmpa5
           res(baseb+6,k) = res(baseb+6,k) + tmpa6
         end
       end

       ft_ab.destroy
       sh.destroy_ptr_part

      end

      PARALLEL_SUM(res)

   end

   make_ft_deriv_U(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [k_max,n_atom*6]
      dens :: MAT{CPX}, target
      k_pts :: MAT{REAL}, IN
      res :: MAT{CPX}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      ft_ab2,tmp1,tmp2 :: CPX
      k_max,k,fa,fb,la,lb,na,nb,q,atom_a,atom_b,basea,baseb :: INT
      delta,g,separation,x,y,z :: REAL
      diff :: VEC{REAL}(3)
      ft_ab :: MAT3{CPX}*
      dens_ba :: MAT{CPX}*
      cutoff :: REAL
      sh :: SHELL2

      k_max = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs

      res = ZERO

      parallel do q = 1, .n_shell_pairs

       .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

       if (sh.skip_ft(cutoff)) then
         sh.destroy_ptr_part
         cycle
       end

       ft_ab.create(k_max,na,nb)
       .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)

       dens_ba => dens(fb:lb,fa:la)
       if (fa/=fb) ft_ab = TWO * ft_ab ! count off-diagonals twice.

       diff = .atom(atom_a).position-.atom(atom_b).position
       separation = diff.norm
       g=HALF
       if (separation > 2.5d0) g=QUARTER
       g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

       basea = (atom_a-1) * 6
       if (atom_a==atom_b) then

         delta = TWO * g
         do k = 1,k_max
           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * delta
           x = k_pts(k,1)           ! SBh_x
           y = k_pts(k,2)           ! SBh_y
           z = k_pts(k,3)           ! SBh_z
           tmp1 = ft_ab2 * x
           tmp2 = ft_ab2 * y
           res(basea+1,k) = res(basea+1,k) + tmp1 * x
           res(basea+2,k) = res(basea+2,k) + tmp1 * y
           res(basea+3,k) = res(basea+3,k) + tmp1 * z
           res(basea+4,k) = res(basea+4,k) + tmp2 * y
           res(basea+5,k) = res(basea+5,k) + tmp2 * z
           res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
         end

       else

         baseb = (atom_b-1) * 6
         do k = 1,k_max
           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * g
           x = k_pts(k,1)           ! SBh_x
           y = k_pts(k,2)           ! SBh_y
           z = k_pts(k,3)           ! SBh_z
           tmp1 = ft_ab2 * x
           tmp2 = ft_ab2 * y
           res(basea+1,k) = res(basea+1,k) + tmp1 * x
           res(basea+2,k) = res(basea+2,k) + tmp1 * y
           res(basea+3,k) = res(basea+3,k) + tmp1 * z
           res(basea+4,k) = res(basea+4,k) + tmp2 * y
           res(basea+5,k) = res(basea+5,k) + tmp2 * z
           res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
           res(baseb+1,k) = res(baseb+1,k) + tmp1 * x
           res(baseb+2,k) = res(baseb+2,k) + tmp1 * y
           res(baseb+3,k) = res(baseb+3,k) + tmp1 * z
           res(baseb+4,k) = res(baseb+4,k) + tmp2 * y
           res(baseb+5,k) = res(baseb+5,k) + tmp2 * z
           res(baseb+6,k) = res(baseb+6,k) + ft_ab2 * z * z
         end
       end

       ft_ab.destroy
       sh.destroy_ptr_part

      end

      PARALLEL_SUM(res)

   end

   make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)
   ! Make_ft for one pair of gaussians.
   ! Includes partitioning and thermal smearing.
      ft_ab :: MAT3{CPX}
      k_pts :: MAT{REAL}, IN
      sh :: SHELL2, IN
      atom_a,atom_b :: INT, IN
   ENSURE(.crystal.created,"no crystal data")

      is_zero :: BIN
      t :: MAT3{REAL}*
      p :: MAT{REAL}*
      k_max :: INT

      k_max = size(k_pts,1)

      p.create(sh.a.n_cc,sh.b.n_cc)
      .make_partition_factors(p,sh,atom_a,atom_b,is_zero)

      if (NOT is_zero) then
        t.create(k_max,sh.a.n_cc,sh.b.n_cc)
        .thermal_smearing_correction(t,k_pts,atom_a,atom_b,sh)
      ! sh.make_ft_fast(ft_ab,k_pts,t,p)
        sh.make_ft(ft_ab,k_pts,t,p)
        t.destroy
      else
        ft_ab = ZERO
      end

      p.destroy

   end

!   make_partition_factor(p,atom_a,is_zero)
!   ! Make the partitition factor "p" for a particular thermal smearing
!   ! "model", for "atom_a". Return "is_zero" as TRUE if p is zero.
!      p :: REAL
!      atom_a :: INT, IN
!      is_zero :: BIN, OUT, optional
!
!   ENSURE(.crystal.created,"no crystal data")
!
!      ra,fa :: REAL
!
!      ra = .crystal.repetition_factor(atom_a)
!
!      if (present(is_zero)) then
!        if (ra<1) then; is_zero = TRUE; return
!        else;           is_zero = FALSE
!        end
!      end
!
!      if (ra<1) then; fa = ZERO
!      else;           fa = ONE/ra
!      end
!
!      select case (trim(.crystal.partition_model))
!         case (" ","none"); p = ONE
!         case ("mulliken"); p = fa
!         case ("gaussian"); p = fa
!         case default;      DIE("unknown model, "//trim(.crystal.partition_model))
!      end
!
!   end

   make_partition_factors(p,sh,atom_a,atom_b,is_zero)
   ! Make the partitition factors "p" for a particular thermal smearing "model",
   ! for a given "sh" pair with atom centres "atom_a" and "atom_b".
       p :: MAT{REAL}
      sh :: SHELL2, IN
      atom_a,atom_b :: INT, IN
      is_zero :: BIN, OUT, optional
   ENSURE(.crystal.created,"no crystal data")
      ra,rb,fa,fb :: REAL
      ra = .crystal.repetition_factor(atom_a)
      rb = .crystal.repetition_factor(atom_b)
      if (present(is_zero)) then
        if (ra<1 AND rb<1) then
          is_zero = TRUE
          return
        else
          is_zero = FALSE
        end
      end
      if (ra<1) then; fa = ZERO
      else;           fa = ONE/ra
      end
      if (rb<1) then; fb = ZERO
      else;           fb = ONE/rb
      end
      select case (trim(.crystal.partition_model))
         case (" ","none")
            p = ONE
         case ("mulliken")
            p = HALF * (fa + fb)
         case ("gaussian")
            sh.make_gaussian_partition(p,fa,fb)
         case default
            DIE("unknown model, "//trim(.crystal.partition_model))
      end
   end

   thermal_smearing_correction(res,k_pts,a,b,sh)
   ! Makes the thermal smearing correction term.  Note that res
   ! is done over the contraction coefficients.
   ! Dimensions of "res" are [k_max,.a.n_cc,.b.n_cc].
      res :: MAT3{REAL}, OUT
      k_pts :: MAT{REAL}, IN
      a,b :: INT, IN
      sh :: SHELL2, IN

      Ua,Ub,Uab :: MAT{REAL}(3,3)
      S,US :: VEC{REAL}(3)
      k_max,k :: INT
      separation,bondlength,Ta,Tb,g :: REAL
      diff :: VEC{REAL}(3)

      k_max = k_pts.dim1

      select case (trim(.crystal.thermal_smearing_model))

       case (" ","none")
         res = ONE

       case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
         Ua = -HALF * .atom(a).ADP_tensor
         Ub = -HALF * .atom(b).ADP_tensor
         do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(Ua,S)
            Ta = dot_product(S,US)
            US = matmul(Ub,S)
            Tb = dot_product(S,US)
            res(k,:,:) = HALF*(exp(Ta)+exp(Tb))
         end

       case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4]
         bondlength=2.5
         Ua = .atom(a).ADP_tensor
         Ub = .atom(b).ADP_tensor
         Uab = Ua + Ub
         diff = .atom(a).position-.atom(b).position
         separation = diff.norm
         g=HALF
         if (separation > bondlength) g=QUARTER
         Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
         do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(Uab,S)
            Ta = dot_product(S,US)
            res(k,:,:) = exp(Ta)
         end

       case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
         Ua = .atom(a).ADP_tensor
         Ub = .atom(b).ADP_tensor
         sh.make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)

       case default
         DIE("unknown model, "//trim(.crystal.thermal_smearing_model))

      end

   end

   ft_thermally_smear(ft_ab,k_pts,a,b)
   ! Thermally smear the fourier transform integrals "ft_ab" evaluated
   ! on "k_pts" for shell pair (ab) centered on atoms "a" and "b" .
      a,b :: INT
      k_pts :: MAT{REAL}
      ft_ab :: MAT3{CPX}
      Ua,Ub,Uab :: MAT{REAL}(3,3)
      S,US,diff :: VEC{REAL}(3)
      separation,bondlength,Ta,Tb,g :: REAL
      k,k_max :: INT
      k_max = size(k_pts,1)
      select case (trim(.crystal.thermal_smearing_model))
       case (" ","none")
       case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
         Ua = -HALF * .atom(a).ADP_tensor
         Ub = -HALF * .atom(b).ADP_tensor
         do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(Ua,S)
            Ta = dot_product(S,US)
            US = matmul(Ub,S)
            Tb = dot_product(S,US)
            ft_ab(k,:,:) = ft_ab(k,:,:) * HALF*(exp(Ta)+exp(Tb))
         end
       case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
         bondlength=2.5
         Ua = .atom(a).ADP_tensor
         Ub = .atom(b).ADP_tensor
         Uab = Ua + Ub
         diff = .atom(a).position-.atom(b).position
         separation = diff.norm
         g=HALF
         if (separation > bondlength) g=QUARTER
         Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
         do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(Uab,S)
            Ta = dot_product(S,US)
            ft_ab(k,:,:) = exp(Ta)*ft_ab(k,:,:)
         end
       case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
         DIE("cannot thermally smear at contracted level.")
       case default
         DIE("unknown thermal smearing model, "//trim(.crystal.thermal_smearing_model))
      end
   end

   add_dispersion_correction(ft,k_pts)
   ! Adds the dispersion correction to "ft".
   ! WARNING: does not add thermal smearing !!!!

      k_pts :: MAT{REAL}, target
      ft :: VEC{CPX}

   ENSURE(.crystal.created,"no crystal")

      dc :: CPX
      k1,k2,k3 :: VEC{REAL}*
      pos :: VEC{REAL}(3)
      x,y,z :: REAL
      a,n :: INT

      if (NOT .crystal.correct_dispersion) return

      k1 => k_pts(:,1)
      k2 => k_pts(:,2)
      k3 => k_pts(:,3)

      do n = 1,.crystal.n_unit_cell_atoms

        a = .crystal.frag_atom_for_unit_cell_atom(n)
        if (a==0) cycle

        dc = .atom(a).dispersion_correction(.crystal.wavelength)

        pos = .crystal.unit_cell_geometry(:,n)
        .crystal.unit_cell.change_from_fractional(pos)
        x = pos(1); y = pos(2); z = pos(3)

        ft = ft + dc * exp(cmplx(ZERO,k1*x+k2*y+k3*z,kind=CPX_KIND))

      end

   end

!   add_dispersion_correction(ft,k_pts)
!   ! Adds the dispersion correction to "ft".
!
!      k_pts :: MAT{REAL}
!      ft :: VEC{CPX}
!
!   ENSURE(.crystal.created,"no crystal")
!
!      disp,phase :: CPX
!      pos :: VEC{REAL}(3)
!      U,seitz :: MAT{REAL}(3,3)
!      Bh,UBh :: VEC{REAL}(3)
!      phases :: VEC{CPX}*
!      x,y,z,T :: REAL
!      a,symop,n,k,k_max :: INT
!
!      if (NOT .crystal.correct_dispersion) then
!         return
!      end
!
!      select case (.crystal.thermal_smearing_model)
!
!       case (" ","none")
!
!         phases.create(ft.dim)
!
!         do n = 1,.crystal.n_unit_cell_atoms
!
!           a = .crystal.frag_atom_for_unit_cell_atom(n)
!           if (a==0) cycle
!
!           disp = .atom(a).dispersion_correction(.crystal.wavelength)
!
!           pos = .crystal.unit_cell_geometry(:,n)
!           .crystal.unit_cell.change_from_fractional(pos)
!           x = pos(1); y = pos(2); z = pos(3)
!
!           phases = disp * exp(cmplx(ZERO,k_pts(:,1)*x + k_pts(:,2)*y + k_pts(:,3)*z,kind=CPX_KIND))
!           ft(:) = ft(:) + phases
!
!         end
!
!         phases.destroy
!
!       ! What is this? Why bring thermal smearing into it?
!       ! ==dylan 29/1/07
!       case default ! thermal smearing methods collapse to be the same
!                    ! when dealing with one atom.
!
!         k_max = k_pts.dim1
!
!         do n = 1,.crystal.n_unit_cell_atoms
!
!           a = .crystal.frag_atom_for_unit_cell_atom(n)
!           if (a==0) cycle
!
!           symop = .crystal.asym_symop_for_unit_cell_atom(n)
!           seitz = .crystal.spacegroup.seitz(1:3,1:3,symop)
!
!           U = .atom(a).ADP_tensor
!           ! to crystal coordinates
!           U.change_basis_using(.crystal.unit_cell.reciprocal_U_matrix)
!           ! apply seitz operation
!           U.change_basis_using(transpose(seitz))
!           ! to cartesian coordinates
!           U.change_basis_using(.crystal.unit_cell.direct_U_matrix)
!
!           U = -HALF * U
!
!           disp = .atom(a).dispersion_correction(.crystal.wavelength)
!
!           pos = .crystal.unit_cell_geometry(:,n)
!           .crystal.unit_cell.change_from_fractional(pos)
!           x = pos(1); y = pos(2); z = pos(3)
!
!           do k = 1,k_max
!             Bh = k_pts(k,:)
!             UBh = matmul(U,Bh)
!             T = (dot_product(Bh,UBh))
!             phase = exp(cmplx(T,Bh(1)*x + Bh(2)*y + Bh(3)*z,kind=CPX_KIND))
!             ft(k) = ft(k) + disp * phase
!           end
!
!         end
!      end
!
!   end

   check_dispersion_correction
   ! Adds dispersion correction to the F_exp, to compare
   ! with other experimental structure factors that have the 
   ! dispersion correction made to them.
   ENSURE(.crystal.created,"no crystal")

      k_pts :: MAT{REAL}*
      ft :: VEC{CPX}*

      ft.create(.crystal.n_refl)
      ft= .crystal.data.F_pred

      k_pts.create(.crystal.n_refl,3)
      .crystal.make_k_pts(k_pts)
      .add_dispersion_correction(ft,k_pts)
      k_pts.destroy

      .crystal.set_F_calc(ft)
      ft.destroy

      .crystal.make_F_predicted


      stdout.text("Dispersion corrected F_exp")
      .crystal.data.reflections.put_structure_factor_data

   end

   get_ft_ints
   ! Get the fourier transform of the overlap integrals.
   ! If the archive file exists, read it; otherwise make it.
      arch :: ARCHIVE
      arch.set(.name,"ft_ints")
      if (NOT arch.exists) .make_ft_ints
   end

   make_ft_ints
   ! Make the fourier transform of the overlap integrals on an archive file
   ENSURE(.crystal.created, "no crystal")
      arch :: ARCHIVE
      k_pts :: MAT{REAL}*
      q,fa,la,fb,lb,na,nb,atom_a,atom_b :: INT
      ft_ab_eq,ft_ab :: MAT3{CPX}*
      sh :: SHELL2

      arch.set(.name,"ft_ints")
      arch.open(for="write-only")

      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

         ft_ab_eq.create(size(k_pts,1),na,nb)
         ft_ab.create(.crystal.n_refl,na,nb)
         .make_ft_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
         .crystal.sum_unique_sf_ints(ft_ab,ft_ab_eq)

         arch.Bfile.write(ft_ab)

         ft_ab.destroy
         ft_ab_eq.destroy
         sh.destroy_ptr_part

      end

      k_pts.destroy
      arch.close
   end

   make_x_structure_factors
   ! Make the X-ray structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.density_matrix.created, "no density matrix")
      .crystal.assign_xray
      if (.crystal.thermal_smearing_model=="hirshfeld") then
         .make_H_structure_factors
      else
         .make_x_structure_factors_p
      end
   end

   make_xf_structure_factors
   ! Make the *free* X-ray structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.xray_r_free_data.created, "no x-ray R-free reflection data")
   ENSURE(.density_matrix.created, "no density matrix")
      .crystal.assign_xray_r_free
      if (.crystal.thermal_smearing_model=="hirshfeld") then
         .make_H_structure_factors
      else
         .make_x_structure_factors_p
      end
   end

   make_x_structure_factors_p ::: private
   ! Make the structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.density_matrix.created, "no density matrix")

      sf_eq,Fc :: VEC{CPX}*
      k_pts :: MAT{REAL}*
      genre :: STR

      Fc.create(.crystal.n_refl)
      k_pts.create(.crystal.n_unique_SF_k_pts,3)

      .crystal.make_unique_SF_k_pts(k_pts)
      .make_ao_density_matrix
      genre = .density_matrix.spinorbital_kind

      sf_eq.create(k_pts.dim1)
      if (genre.includes("complex")) then
        .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts)
      else
        .make_ft(sf_eq,.density_matrix.restricted,k_pts)
        if (.scfdata.created) then
        if (.scfdata.spinorbital_kind=="unrestricted") then
           .density_matrix.destroy("restricted")
        end
        end
      end
      k_pts.destroy

      .crystal.sum_unique_sf(Fc,sf_eq)
      if (.crystal.correct_dispersion) then
        k_pts.create(.crystal.n_refl,3)
        .crystal.make_k_pts(k_pts)
        .add_dispersion_correction(Fc,k_pts)
        k_pts.destroy
      end
      sf_eq.destroy

      .crystal.set_F_calc(Fc)
      Fc.destroy

      .crystal.make_F_predicted

   end

   make_x_structure_factors_h(D)
   ! Make the structure factors from a rhf density matrix "D".
      D :: MAT{REAL}

   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")

      sf_eq,Fc :: VEC{CPX}*
      k_pts :: MAT{REAL}*

      ! Allocate complex structure factors
      Fc.create(.crystal.n_refl)

      ! Make unique k points
      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)

      ! Make the unique structure factors
      sf_eq.create(k_pts.dim1)
      .make_ft(sf_eq,D,k_pts)

      ! Clean
      k_pts.destroy

      ! Sum up unique SF's to get Fc
      .crystal.sum_unique_sf(Fc,sf_eq)

      ! Make dispersion correction
      if (.crystal.correct_dispersion) then
        k_pts.create(.crystal.n_refl,3)
        .crystal.make_k_pts(k_pts)
        .add_dispersion_correction(Fc,k_pts)
        k_pts.destroy
      end

      ! Clean
      sf_eq.destroy

      ! Set the calculated SF's
      .crystal.set_F_calc(Fc)

      ! Clean
      Fc.destroy

      ! Make predicted structure factors
      .crystal.make_F_predicted

      ! Debugging
      if (.debugging("make_x_structure_factors_h")) then
         stdout.text("X-ray structure factor data")
         .crystal.data.reflections.put_structure_factor_data
      end

   end

   make_n_structure_factors
   ! Make the PND structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
      DIE_IF(NOT .crystal.spacegroup.centrosymmetric,"crystal must be centrosymmetric")
      .crystal.assign_pnd  ! <============ Assign PND data here
      if (.crystal.thermal_smearing_model=="hirshfeld") then
         .make_H_Sz_structure_factors
      else
         .make_n_structure_factors_p
      end
   end

   make_nf_structure_factors
   ! Make the free PND structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
      .crystal.assign_pnd_r_free
      if (.crystal.thermal_smearing_model=="hirshfeld") then
         .make_H_Sz_structure_factors
      else
         .make_n_structure_factors_p
      end
   end

   make_n_structure_factors_p ::: private
   ! Make the structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
      sf_eq,Fc :: VEC{CPX}*
      k_pts :: MAT{REAL}*
      genre :: STR
      complx :: BIN
      Fc.create(.crystal.n_refl)
      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_sz_density_matrix ! make S_z density matrix
      genre = .density_matrix.spinorbital_kind
      complx = genre.includes("complex")
      if (complx) then; .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts)
      else;             .make_ft(sf_eq,.density_matrix.restricted,k_pts)
      end
      .crystal.sum_unique_sf(Fc,sf_eq)
      ! Now destroy the S_z density matrix
      if (complx) then; .density_matrix.destroy("restricted_complex")
      else;             .density_matrix.destroy("restricted")
      end
      sf_eq.destroy
      k_pts.destroy
      .crystal.set_F_calc(Fc)
      .crystal.make_F_predicted
      Fc.destroy
   end

!  ===========================
!  Hirshfeld structure factors
!  ===========================

   make_H_structure_factors(output) ::: leaky
   ! Make the H structure factors efficiently
      output :: BIN, optional

   ENSURE(.density_matrix.created,"no density matrix")
 ! ENSURE(.density_matrix.restricted.created,"no restricted density matrix")

      sf_eq,Fc :: VEC{CPX}*
      wt, xa,ya,za,a2 :: VEC{REAL}*
      rho, k1,k2,k3, u1,u2,u3, r1,r2,r3, ga,gb :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab,skipa,skipb :: VEC{BIN}*
      D,DD,k_pts,kU,pt,grida,gridb,bf_save :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      sf  :: CPX
      cutoff,rf, k1k,k2k,k3k,kr, Dab, fac, n_e,val :: REAL
      n_refl,n_k,n_pt,n_keep, c,ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, as, a,b,i,j,k,n,p :: INT
      D_destroyed,out :: BIN

      ! Number of reflections
      n_refl = .crystal.n_refl

      ! Calculated complex structure factors
      Fc.create(n_refl)

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts
      sf_eq.create(n_k)
      k_pts.create(n_k,3)
      kU.create(n_k,3)

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      .crystal.make_unique_SF_k_pts(k_pts)
      k1 => k_pts(:,1)
      k2 => k_pts(:,2)
      k3 => k_pts(:,3)

      ! Density matrix
      D_destroyed = .density_matrix.restricted.destroyed
      .make_ao_density_matrix
      D => .density_matrix.restricted
      .put_debug(D,"make_H_structure_factors: D")

      ! Set up grids, atomic densities, overlapping_atoms -- leaky
      .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Make the constraint
      n_e = ZERO
      sf_eq = ZERO

      ! Loop over integration atoms "c"
      parallel do c = 1,.n_atom

         ! Repetition factor for this atom
         rf = .crystal.repetition_factor(c)
         if (rf.is_zero) cycle
         rf = ONE/rf

         ! Get the Becke grid for atom "c"
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Overlapping atoms
         overlapping_atom => .overlapping_atoms_for_atom(c).element

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms 
         ! are used ... otherwise nothing is skipped
         .apply_stockholder_atom_weight(wt,c,pt)

         ! Prune the grid with new "wt", get saved bf grid bf_save, 
         ! and new no of points, n_pt 
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Density for atom "c"
         rho.create(n_pt)
         rho = ZERO

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .precomputed_basis_shellpair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element => skipa

               ! Make/copy the "sa" basis function grida
               ! This must be copied since skipa could be TRUE
               grida.create(n_keep,na)
               if (oa==c) then
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        grida(i,a) = bf_save(n,a+fa-fba)
                     end
                  end
               else
                  sha.make_skip_grid(grida,n_keep,na,xa,ya,za,a2,skipa,n_pt)
               end
               bf_grid(sa).element => grida

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points
                     if (bf_skip(sb).element.destroyed) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb => bf_skip(sb).element 
                     gridb => bf_grid(sb).element 

                     ! How many points in common?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block
                     DD => D(fa:la,fb:lb)

                     if (na*nb==1) then

                        ! Add density contribution to rho
                        ga => grida(:,1)
                        gb => gridb(:,1)
                        Dab = fac*DD(1,1)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                     else

                        ! Create space for gathered index info
                        pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga => grida(:,a)
                           do b = 1,nb
                              gb  => gridb(:,b)
                              Dab = fac*DD(a,b)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val
                              end
                           end
                        end

                        ! Clean up
                        pn.destroy; pj.destroy; pi.destroy

                     end

                  end
               end
            end
         end

         ! Temperature factor for this atom for all k_pts
         kU = matmul(k_pts,.atom(c).ADP_tensor)
         u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)

         ! Weight the atom "c" density
         rho = rho*wt
         n_e = n_e + sum(rho)

         ! Make the (unique) matrix elements
         do k = 1,n_k
            k1k = k1(k); k2k = k2(k); k3k = k3(k)
            sf = (ZERO,ZERO)
            do i = 1,n_pt 
               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
               sf = sf + rho(i)*cmplx(cos(kr),sin(kr))
            end
            sf = sf * rf
            sf_eq(k) = sf_eq(k) + sf * exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
         end

         ! Clean up atom "c" stuff
         rho.destroy
         bf_grid.destroy
         bf_skip.destroy
         bf_save.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
      if (D_destroyed) .density_matrix.destroy("restricted")
      kU.destroy; k_pts.destroy

      ! Check integration accuracy
      out = FALSE
      if (present(output)) out = output
      if (out) then
      stdout.flush
      stdout.text("==================================")
      stdout.text("Making Hirshfeld structure factors")
      stdout.text("==================================")
      stdout.flush
      stdout.show("Check: no. of electrons      =",n_e)
      end

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_eq)
      end

      ! Sum the symmetry equivalent SF's
      .crystal.sum_unique_sf(Fc,sf_eq)
      sf_eq.destroy

      ! Dispersion correction
      if (.crystal.correct_dispersion) then
        k_pts.create(.crystal.n_refl,3)
        .crystal.make_k_pts(k_pts)
        .add_dispersion_correction(Fc,k_pts)
        k_pts.destroy
      end

      ! Set the calculated SF's
      .crystal.set_F_calc(Fc)
      Fc.destroy

      ! Make chi2
      .crystal.make_F_predicted
      if (out) .crystal.put_F_statistics

   end

   make_H_Sz_structure_factors(output) ::: leaky
   ! Make the H Sz structure factors efficiently
      output :: BIN, optional

   ENSURE(.density_matrix.created,"no density matrix")
 ! ENSURE(.density_matrix.restricted.created,"no restricted density matrix")

      sf_eq,Fc :: VEC{CPX}*
      wt, xa,ya,za,a2 :: VEC{REAL}*
      rho, k1,k2,k3, u1,u2,u3, r1,r2,r3, ga,gb :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab,skipa,skipb :: VEC{BIN}*
      D,DD,k_pts,kU,pt,grida,gridb,bf_save :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      sf  :: CPX
      cutoff,rf, k1k,k2k,k3k,kr, Dab, fac, n_e,val :: REAL
      n_refl,n_k,n_pt,n_keep, c,ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, as, a,b,i,j,k,n,p :: INT
      out :: BIN

      ! Number of reflections
      n_refl = .crystal.n_refl

      ! Calculated complex structure factors
      Fc.create(n_refl)

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts
      sf_eq.create(n_k)
      k_pts.create(n_k,3)
      kU.create(n_k,3)

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      .crystal.make_unique_SF_k_pts(k_pts)
      k1 => k_pts(:,1)
      k2 => k_pts(:,2)
      k3 => k_pts(:,3)

      ! Density matrix
      .make_ao_sz_density_matrix ! make S_z density matrix
      ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
      D => .density_matrix.restricted
      .put_debug(D,"make_H_structure_factors: D")

      ! Make max_P and overlap matrix for schwarz-like test
    ! schwarz_cutoff = .scfdata.eri_schwarz_cutoff
    ! max_P.create(.n_shell_pairs)
    ! .make_max_density_elements(max_P,D)
    ! .get_overlap_matrix

      ! Set up grids, atomic densities, overlapping_atoms -- leaky
      .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Make the constraint
      n_e = ZERO
      sf_eq = ZERO

      ! Loop over integration atoms "c"
      parallel do c = 1,.n_atom

         ! Repetition factor for this atom
         rf = .crystal.repetition_factor(c)
         if (rf.is_zero) cycle
         rf = ONE/rf

         ! Get the Becke grid for atom "c"
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Overlapping atoms
         overlapping_atom => .overlapping_atoms_for_atom(c).element

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms 
         ! are used ... otherwise nothing is skipped
         .apply_stockholder_atom_weight(wt,c,pt)

         ! Prune the grid with new "wt", get saved bf grid bf_save, 
         ! and new no of points, n_pt 
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Density for atom "c"
         rho.create(n_pt)
         rho = ZERO

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .precomputed_basis_shellpair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element => skipa

               ! Make/copy the "sa" basis function grida
               ! This must be copied since skipa could be TRUE
               grida.create(n_keep,na)
               if (oa==c) then
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        grida(i,a) = bf_save(n,a+fa-fba)
                     end
                  end
               else
                  sha.make_skip_grid(grida,n_keep,na,xa,ya,za,a2,skipa,n_pt)
               end
               bf_grid(sa).element => grida

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points
                     if (bf_skip(sb).element.destroyed) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Skip test 
                   ! bs = .basis_shell_for_shell(sb)
                   ! sh2.set_and_precompute_from(.precomputed_basis_shellpair(as,bs),ra,rb,oa==ob,skip=FALSE)
                   ! if (sh2.skip_ft(cutoff)) then
                   !    sh2.destroy_ptr_part
                   !    cycle
                   ! end

                     ! Set the "sb" basis function grid
                     skipb => bf_skip(sb).element 
                     gridb => bf_grid(sb).element 

                     ! How many points in common?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Density block
                     DD => D(fa:la,fb:lb)

                     if (na*nb==1) then

                        ! Add density contribution to rho
                        ga => grida(:,1)
                        gb => gridb(:,1)
                        Dab = fac*DD(1,1)
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val    = ga(i)*gb(j)*Dab
                           rho(n) = rho(n) + val
                        end

                     else

                        ! Create space for gathered index info
                        pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        ! Add density contribution to rho
                        do a = 1,na
                           ga => grida(:,a)
                           do b = 1,nb
                              gb  => gridb(:,b)
                              Dab = fac*DD(a,b)
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val    = ga(i)*gb(j)*Dab
                                 rho(n) = rho(n) + val
                              end
                           end
                        end

                        ! Clean up
                        pn.destroy; pj.destroy; pi.destroy

                     end

                  end
               end
            end
         end

         ! Temperature factor for this atom for all k_pts
         kU = matmul(k_pts,.atom(c).ADP_tensor)
         u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)

         ! Weight the atom "c" density
         rho = rho*wt
         n_e = n_e + sum(rho)

         ! Make the (unique) matrix elements
         do k = 1,n_k
            k1k = k1(k); k2k = k2(k); k3k = k3(k)
            sf = (ZERO,ZERO)
            do i = 1,n_pt 
               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
               sf = sf + rho(i)*cmplx(cos(kr),sin(kr))
            end
            sf = sf * rf
            sf_eq(k) = sf_eq(k) + sf * exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
         end

         ! Clean up atom "c" stuff
         rho.destroy
         bf_grid.destroy
         bf_skip.destroy
         bf_save.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
    ! max_P.destroy
      .density_matrix.destroy("restricted")
      kU.destroy; k_pts.destroy

      ! Check integration accuracy
      out = FALSE
      if (present(output)) out = output
      if (out) then
      stdout.flush
      stdout.text("Making Hirshfeld structure factors ...")
      stdout.flush
      stdout.show("Check: no. of electrons        =",n_e)
      end

      ! Parallel
      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_eq)
      end

      ! Sum the symmetry equivalent SF's
      .crystal.sum_unique_sf(Fc,sf_eq)
      sf_eq.destroy

      ! Dispersion correction
      if (.crystal.correct_dispersion) then
        k_pts.create(.crystal.n_refl,3)
        .crystal.make_k_pts(k_pts)
        .add_dispersion_correction(Fc,k_pts)
        k_pts.destroy
      end

      ! Set the calculated SF's
      .crystal.set_F_calc(Fc)
      Fc.destroy

      ! Make chi2
      .crystal.make_F_predicted
      if (out) .crystal.put_F_statistics

   end

!   make_PND_scalar_magnetic_sf
!   ! Make the PND scalar magnetic structure factors and assign them
!   ! To the crystal objects structure factors for analysis
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.reflection_data_exists, "no reflection data")
!      FM_s, FM_l, FM_r, Fc :: VEC{CPX}*
!      n_refl :: INT
!      arch :: ARCHIVE
!      .crystal.assign_pnd
!      n_refl = .crystal.n_refl
!      Fc.create(n_refl)
!      ! Spin contribution
!      .make_PND_spin_sf
!      FM_s.create(n_refl)
!      arch.set(.name,"PND_spin_sf")
!      arch.read(FM_s)
!      ! Orbital contribution
!    ! .make_PND_nabla_sf
!    ! FM_l.create(n_refl)
!    ! arch.set(.name,"PND_nabla_sf")
!    ! arch.read(FM_l)
!      ! Diamagnetic contribution
!    ! .make_PND_r_sf
!    ! FM_r.create(n_refl)
!    ! arch.set(.name,"PND_r_sf")
!    ! arch.read(FM_r)
!      ! Make F_calc
!      Fc = FM_s ! + FM_l ! + FM_r
!      arch.set(.name,"PND_scalar_magnetic_sf")
!      arch.write(Fc)
!      .crystal.set_F_calc(Fc)
!      .crystal.make_F_predicted
!    ! FM_r.destroy
!    ! FM_l.destroy
!      FM_s.destroy
!      Fc.destroy
!   end
!
!   make_PND_spin_sf
!   ! Make the PND structure factors
!   ENSURE(.density_matrix.created, "no density")
!      genre :: STR
!      genre = .density_matrix.spinorbital_kind
!      select case (genre)
!         case ("unrestricted");    .make_u_PND_spin_sf
!         case ("general_complex"); .make_gc_PND_spin_sf
!         case default
!            DIE("not implemented for "//trim(genre))
!      end
!   end
!
!   make_u_PND_spin_sf
!   ! Make the scalar spin magnetic structure factors assuming an applied field
!   ! in the z direction, and assuming an unrestricted density matrix exists.
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.density_matrix.created, "no density")
!   ENSURE(.density_matrix.alpha.created, "no density")
!      arch :: ARCHIVE
!      fac,ans :: REAL
!      d_aa,d_bb :: MAT{REAL}*
!      ft_ab :: MAT4{CPX}*
!      FM :: VEC{CPX}*
!      sh :: SHELL2*
!      k_max,i,q,fa,la,fb,lb :: INT
!      arch.set(.name,"PND_ft_spin_ints")
!      if (NOT arch.exists) .make_PND_ft_spin_ints
!      arch.open(for="read-only",type="real")
!      k_max = .crystal.n_refl
!      FM.create(k_max)
!      FM = ZERO
!      sh.create
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
!         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
!         arch.Bfile.read(ft_ab)
!         d_aa => .density_matrix.alpha(fb:lb,fa:la)
!         d_bb => .density_matrix.beta( fb:lb,fa:la)
!         fac = TWO
!         if (fa==fb) fac=ONE
!         do i = 1,k_max
!            ans = ans +    ft_ab(i,:,:,3).trace_product_with(d_aa)
!            ans = ans -    ft_ab(i,:,:,3).trace_product_with(d_bb)
!            FM(i) = FM(i) + fac*ans
!         end
!         ft_ab.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      arch.close
!      arch.set(.name,"PND_spin_sf")
!      arch.write(FM)
!      FM.destroy
!   end
!
!   make_gc_PND_spin_sf
!   ! Make the scalar spin magnetic structure factors assuming an applied field
!   ! in the z direction, and assuming a general complex denisty matrix exists
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.density_matrix.created, "no density")
!   ENSURE(.density_matrix.general_complex.created, "no density")
!      arch :: ARCHIVE
!      fac,ans :: REAL
!      d_aa,d_bb,d_ba :: MAT{CPX}*
!      ft_ab :: MAT4{CPX}*
!      FM :: VEC{CPX}*
!      ci :: CPX
!      sh :: SHELL2*
!      k_max,i,q,fa,la,fb,lb :: INT
!      arch.set(.name,"PND_ft_spin_ints")
!      if (NOT arch.exists) .make_PND_ft_spin_ints
!      arch.open(for="read-only",type="real")
!      ci = (ZERO,ONE)
!      k_max = .crystal.n_refl
!      FM.create(k_max)
!      FM = ZERO
!      sh.create
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
!         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
!         arch.Bfile.read(ft_ab)
!         d_aa => .density_matrix.general_complex(      fb:      lb,      fa:      la)
!         d_bb => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
!         d_ba => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,      fa:      la)
!         fac = TWO
!         if (fa==fb) fac=ONE
!         do i = 1,k_max
!            ans =          ft_ab(i,:,:,1).trace_product_with(d_ba)
!            ans = ans - ci*ft_ab(i,:,:,2).trace_product_with(d_ba)
!            ans = ans +    ft_ab(i,:,:,3).trace_product_with(d_aa)
!            ans = ans -    ft_ab(i,:,:,3).trace_product_with(d_bb)
!            FM(i) = FM(i) + fac*ans
!         end
!         ft_ab.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      arch.close
!      arch.set(.name,"PND_spin_sf")
!      arch.write(FM)
!      FM.destroy
!   end
!
!   get_PND_ft_spin_ints
!   ! Get the PND ft spin integrals on disk if they don't already exist
!      arch :: ARCHIVE
!      arch.set(.name,"PND_ft_spin_ints")
!      if (NOT arch.exists) .make_PND_ft_spin_ints
!   end
!
!   make_PND_ft_spin_ints
!   ! Make the fourier transform of the PND spin integrals on the archive
!   ENSURE(.crystal.created, "no crystal")
!      arch :: ARCHIVE
!      k_pts :: MAT{REAL}*
!      sh :: SHELL2*
!      ft_ab_eq :: MAT3{CPX}*
!      ft_ab :: MAT4{CPX}*
!      q,fa,la,fb,lb,atom_a,atom_b :: INT
!      arch.set(.name,"PND_ft_spin_ints")
!      arch.open(for="write-only",type="cpx")
!      k_pts.create(.crystal.n_unique_SF_k_pts,3)
!      .crystal.make_unique_SF_k_pts(k_pts)
!      sh.create
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!         ft_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp)
!         .make_ft_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
!         ft_ab.create(.crystal.n_refl,sh.a.n_comp,sh.b.n_comp,3)
!         .crystal.sum_PND_spin_ints(ft_ab,ft_ab_eq)
!         arch.Bfile.write(ft_ab)
!         ft_ab.destroy
!         ft_ab_eq.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      k_pts.destroy
!      arch.close
!   end
!
!   make_PND_nabla_sf
!   ! Make PND nabla structure factors
!   ENSURE(.density_matrix.created, "no density")
!      genre :: STR
!      genre = .density_matrix.spinorbital_kind
!      select case (genre)
!         case ("general_complex"); .make_gc_PND_nabla_sf
!         case default
!            DIE("not implemented for "//trim(genre))
!      end
!   end
!
!   make_gc_PND_nabla_sf
!   ! Make the scalar nabla magnetic structure factors assuming an applied field
!   ! in the z direction, and assuming a general complex density exists
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.density_matrix.created, "no density")
!   ENSURE(.density_matrix.general_complex.created, "no density")
!      arch :: ARCHIVE
!      fac :: REAL
!      dens :: MAT{CPX}*
!      ft_ab_z :: MAT3{CPX}*
!      FM :: VEC{CPX}*
!      sh :: SHELL2*
!      k_max,i,q,fa,la,fb,lb :: INT
!      arch.set(.name,"PND_ft_nabla_ints")
!      if (NOT arch.exists) .make_PND_ft_nabla_ints
!      arch.open(for="read-only",type="real")
!      k_max = .crystal.n_refl
!      FM.create(k_max)
!      FM = ZERO
!      sh.create
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
!         ft_ab_z.create(k_max,sh.a.n_comp,sh.b.n_comp)
!         arch.Bfile.read(ft_ab_z)
!         dens.create(sh.b.n_comp,sh.a.n_comp)
!         dens =        .density_matrix.general_complex(      fb:      lb,      fa:      la)
!         dens = dens + .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
!         fac = TWO
!         if (fa==fb) fac=ONE
!         do i = 1,k_max
!            FM(i) = FM(i) + fac*ft_ab_z(i,:,:).trace_product_with(dens)
!         end
!         dens.destroy
!         ft_ab_z.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      arch.close
!      arch.set(.name,"PND_nabla_sf")
!      arch.write(FM)
!      FM.destroy
!   end
!
!   get_PND_ft_nabla_ints
!   ! Get the PND ft nabla integrals on disk if they don't already exist
!      arch :: ARCHIVE
!      arch.set(.name,"PND_ft_nabla_ints")
!      if (NOT arch.exists) .make_PND_ft_nabla_ints
!   end
!
!   make_PND_ft_nabla_ints
!   ! Make the fourier transform of the nabla integrals on the archive
!   ENSURE(.crystal.created, "no crystal")
!      arch :: ARCHIVE
!      k_pts :: MAT{REAL}*
!      sh :: SHELL2*
!      ft_ab_eq :: MAT4{CPX}*
!      ft_ab_z :: MAT3{CPX}*
!      q,fa,la,fb,lb,atom_a,atom_b :: INT
!      arch.set(.name,"PND_ft_nabla_ints")
!      arch.open(for="write-only",type="cpx")
!      k_pts.create(.crystal.n_unique_SF_k_pts,3)
!      .crystal.make_unique_SF_k_pts(k_pts)
!      sh.create
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!         ft_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp,3)
!         .make_ft_nabla_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
!       ! sh.make_ft_nabla(ft_ab_eq,k_pts)
!       ! .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
!       ! .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
!       ! .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
!         ft_ab_z.create(.crystal.n_refl,sh.a.n_comp,sh.b.n_comp)
!         .crystal.sum_PND_nabla_ints(ft_ab_z,ft_ab_eq)
!         arch.Bfile.write(ft_ab_z)
!         ft_ab_z.destroy
!         ft_ab_eq.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      k_pts.destroy
!      arch.close
!   end
!
!   make_ft_nabla_pair(ft_ab,k_pts,sh,atom_a,atom_b)
!   ! Make_ft for one pair of gaussians.
!   ! Includes partitioning, dispersion and thermal smearing.
!      ft_ab :: MAT4{CPX}
!      k_pts :: MAT{REAL}, IN
!      sh :: SHELL2, IN
!      atom_a,atom_b :: INT, IN
!   ENSURE(.crystal.created,"no crystal data")
!       t :: MAT3{REAL}*
!       p :: MAT{REAL}*
!      k_max :: INT
!      k_max = size(k_pts,1)
!      t.create(k_max,sh.a.n_cc,sh.b.n_cc)
!      .thermal_smearing_correction(t,k_pts,atom_a,atom_b,sh)
!      p.create(sh.a.n_cc,sh.b.n_cc)
!      .make_partition_factors(p,sh,atom_a,atom_b)
!      sh.make_ft_nabla(ft_ab,k_pts,t,p)
!      p.destroy
!      t.destroy
!   end
!
!   make_PND_r_sf
!   ! Make the scalar dipole magnetic structure factors assuming an applied field
!   ! in the z direction
!   ENSURE(.crystal.created, "no crystal")
!      arch :: ARCHIVE
!      fac,ans :: REAL
!      d_aa,d_bb :: MAT{CPX}*
!      ft_ab :: MAT4{CPX}*
!      FM :: VEC{CPX}*
!      sh :: SHELL2*
!      k_max,i,q,fa,la,fb,lb :: INT
!      arch.set(.name,"PND_ft_r_ints")
!      if (NOT arch.exists) .make_PND_ft_r_ints
!      arch.open(for="read-only",type="real")
!      k_max = .crystal.n_refl
!      FM.create(k_max)
!      FM = ZERO
!      sh.create
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
!         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
!         arch.Bfile.read(ft_ab)
!         d_aa => .density_matrix.general_complex(      fb:      lb,      fa:      la)
!         d_bb => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
!         fac = TWO
!         if (fa==fb) fac=ONE
!         do i = 1,k_max
!            ans =       fac*ft_ab(i,:,:,3).trace_product_with(d_aa)
!            ans = ans + fac*ft_ab(i,:,:,3).trace_product_with(d_bb)
!            FM(i) = FM(i) + ans
!         end
!         ft_ab.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      arch.close
!      arch.set(.name,"PND_r_sf")
!      arch.write(FM)
!      FM.destroy
!   end
!
!   get_PND_ft_r_ints
!   ! Get the PND ft r integrals on disk if they don't already exist
!      arch :: ARCHIVE
!      arch.set(.name,"PND_ft_r_ints")
!      if (NOT arch.exists) .make_PND_ft_r_ints
!   end
!
!   make_PND_ft_r_ints
!   ! Make the fourier transform of the dipole "r" integrals on the archive
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.reflection_data_exists, "no structure factor data")
!      arch :: ARCHIVE
!      k_pts :: MAT{REAL}*
!      sh :: SHELL2*
!      ft_ab_eq, ft_ab :: MAT4{CPX}*
!      q,fa,la,fb,lb,atom_a,atom_b,n_refl :: INT
!      n_refl = .crystal.n_refl
!      arch.set(.name,"PND_ft_r_ints")
!      arch.open(for="write-only",type="cpx")
!      k_pts.create(.crystal.n_unique_SF_k_pts,3)
!      .crystal.make_unique_SF_k_pts(k_pts)
!      sh.create
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!         ft_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp,3)
!         sh.make_ft_r(ft_ab_eq,k_pts)
!         .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
!         .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
!         .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
!         ft_ab.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
!         .crystal.sum_ft_r_ints(ft_ab,ft_ab_eq,.B_field)
!         arch.Bfile.write(ft_ab)
!         ft_ab.destroy
!         ft_ab_eq.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      k_pts.destroy
!      arch.close
!   end
!
!   make_PND_fit_ints(ints,lambda)
!   ! Make the PND constraint integrals on the archive
!      ints :: MAT{CPX}, target
!      lambda :: REAL
!      spin_archive,nabla_archive :: ARCHIVE
!      Fc,F_exp,F_sigma :: VEC{REAL}*
!      ints_aa,ints_bb,ints_ba :: MAT{CPX}*
!      nabla_z :: MAT3{CPX}*
!      spin :: MAT4{CPX}*
!      sh :: SHELL2*
!      ci :: CPX
!      fac,fac1 :: REAL
!      i,q,fa,la,fb,lb,n_bf,n_refl :: INT
!      .get_PND_ft_spin_ints
!      .get_PND_ft_nabla_ints
!      .get_PND_ft_r_ints
!      spin_archive.set(.name,"PND_ft_spin_ints")
!      nabla_archive.set(.name,"PND_ft_nabla_ints")
!    ! r_archive.set(.name,"PND_ft_r_ints")
!      spin_archive.open(for="read-only",type="real")
!    ! r_archive.open(for="read-only",type="real")
!      ci = (ZERO,ONE)
!      n_bf   =  .n_bf
!      n_refl =  .crystal.n_refl
!      Fc.create(n_refl)
!      F_exp.create(n_refl)
!      F_sigma.create(n_refl)
!      Fc = abs(.crystal.F_calc)
!      F_exp  = .crystal.F_exp
!      F_sigma  = .crystal.F_sigma
!      ints = ZERO
!      sh.create
!      fac1 = TWO*lambda/n_refl
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
!         spin.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
!         spin_archive.Bfile.read(spin)
!         ints_aa => ints(     fa:     la,     fb:     lb)
!         ints_bb => ints(n_bf+fa:n_bf+la,n_bf+fb:n_bf+lb)
!         ints_ba => ints(n_bf+fa:n_bf+la,     fb:     lb)
!         do i = 1,n_refl
!            fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i))
!            ints_ba = ints_ba +    fac*spin(i,:,:,1)
!            ints_ba = ints_ba + ci*fac*spin(i,:,:,2)
!            ints_aa = ints_aa +    fac*spin(i,:,:,3)
!            ints_bb = ints_bb -    fac*spin(i,:,:,3)
!         end
!         spin.destroy
!         nabla_z.create(n_refl,sh.a.n_comp,sh.b.n_comp)
!         nabla_archive.Bfile.read(nabla_z)
!         do i = 1,n_refl
!            fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i))
!            ints_aa = ints_aa + fac*nabla_z(i,:,:)
!            ints_bb = ints_bb + fac*nabla_z(i,:,:)
!         end
!         nabla_z.destroy
!       ! r.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
!       ! r_archive.Bfile.read(r)
!       ! do i = 1,n_refl
!       !    fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i)*)
!       !    ints_aa = ints_aa + fac*r(i,:,:,3)
!       !    ints_bb = ints_bb + fac*r(i,:,:,3)
!       ! end
!       ! r.destroy
!         sh.destroy_ptr_part
!      end
!      sh.destroy
!      ints.make_hermitian
!    ! r_archive.close
!      nabla_archive.close
!      spin_archive.close
!      F_sigma.destroy
!      F_exp.destroy
!      Fc.destroy
!   end

!  ================
!  Symmetry methods
!  ================

   symmetrise(mat,orb_kind)
   ! Symmetrise an opmatrix matrix "mat" of spinorbital_kind "orb_kind" (if
   ! specified)
      mat :: OPMATRIX
      orb_kind :: STR, optional
      itemkind :: STR
      itemkind = mat.spinorbital_kind
      if (present(orb_kind)) itemkind = orb_kind
      select case (itemkind)
         case ("restricted");           .symmetrise(mat.restricted)
         case ("unrestricted");         .symmetrise(mat.alpha)
                                        .symmetrise(mat.beta)
         case ("general");              .symmetrise(mat.general.alpha_alpha)
                                        .symmetrise(mat.general.beta_beta)
                                        .symmetrise(mat.general.alpha_beta)
                                        .symmetrise(mat.general.beta_alpha)
         case ("restricted_complex");   .symmetrise(mat.restricted_complex)
         case ("unrestricted_complex"); .symmetrise(mat.alpha_complex)
                                        .symmetrise(mat.beta_complex)
         case ("general_complex");      .symmetrise(mat.general_complex.alpha_alpha)
                                        .symmetrise(mat.general_complex.beta_beta)
                                        .symmetrise(mat.general_complex.alpha_beta)
                                        .symmetrise(mat.general_complex.beta_alpha)
         case default;   DIE("unknown kind, "//trim(orb_kind))
      end
   end

   symmetrise(mat) ::: template
   ! Symmetrise a matrix
      mat :: MAT{TYPE}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.pointgroup.created, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,W :: MAT{TYPE}*
      tra,trb :: MAT{REAL}*
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}*

      image.create(.n_shell, .pointgroup.order)
      .make_image_of_shell(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.pointgroup.order

         do a = 1,.n_shell

            tra => .pointgroup.xyz_matrix(n,.angular_moment_for_shell(a))
            i = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb => .pointgroup.xyz_matrix(n,.angular_moment_for_shell(b))
               j = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               W.create(na,nb)
               W.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(W,trb,transpose_b=TRUE)
               W.destroy

            end

         end

      end

      mat = sym/REALIFY(.pointgroup.order)

      sym.destroy
      image.destroy

   end

   symmetrise(mat) ::: get_from(MOLECULE, TYPE=>REAL)
   ! Symmetrise a matrix
   end

   symmetrise(mat) ::: get_from(MOLECULE, TYPE=>CPX)
   ! Symmetrise a matrix
   end

   make_image_of_shell(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! pointgroup operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      res :: MAT{INT}, OUT
   ENSURE(.pointgroup.created, "no pointgroup")
   ENSURE(res.dim1==.n_shell, "dimension 1 of matrix incorrect")
   ENSURE(res.dim2==.pointgroup.order, "dimension 2 of matrix incorrect")
      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            aa = .atom_for_shell(a)
            as = .atom_shell_for_shell(a)
            new_pos = matmul(.pointgroup.mat(:,:,n), .atom(aa).position)
            new_atom = .atom_index_from_position(new_pos)
            fs = .first_shell_for_atom(new_atom)
            res(a,n) = fs+as-1
         end
      end
   end


   stabilize(mat,orb_kind) ::: get_from(MOLECULE, symmetrise=>stabilize)
   ! Symmetrise an opmatrix matrix "mat" of spinorbital_kind "orb_kind" (if
   ! specified)
   end

   stabilize(mat) ::: template
   ! Stabilize a matrix
      mat :: MAT{TYPE}

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,w :: MAT{TYPE}*
      tra,trb :: MAT{REAL}*
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}*

      image.create(.n_shell, .crystal.n_stabilizer_symops)
      .make_image_of_stabilizer(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.crystal.n_stabilizer_symops

         do a = 1,.n_shell
            tra => .crystal.xyz_stabilizer_matrix(n,.angular_moment_for_shell(a))
            i = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell
               trb => .crystal.xyz_stabilizer_matrix(n,.angular_moment_for_shell(b))
               j = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               w.create(na,nb)
               w.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(w,trb,transpose_b=TRUE)
               w.destroy
            end

         end

      end

      mat = sym/REALIFY(.crystal.n_stabilizer_symops)

      sym.destroy
      image.destroy

   end

   stabilize(mat) ::: get_from(MOLECULE, TYPE=>REAL)
   ! Stabilize a matrix
   end

   stabilize(mat) ::: get_from(MOLECULE, TYPE=>CPX)
   ! Stabilize a matrix
   end

   make_image_of_stabilizer(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! a crystal stabilizer operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      res :: MAT{INT}, OUT
   ENSURE(.crystal.created, "no crystal")
   ENSURE(res.dim1==.n_shell, "dimension 1 of matrix incorrect")
   ENSURE(res.dim2==.crystal.n_stabilizer_symops, "dimension 2 of matrix incorrect")
      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT
      do n = 1,.crystal.n_stabilizer_symops
         do a = 1,.n_shell
            aa = .atom_for_shell(a)
            as = .atom_shell_for_shell(a)
            new_pos = matmul(.crystal.ptr(:,:,n), .atom(aa).position)
            new_atom = .atom_index_from_position(new_pos)
            fs = .first_shell_for_atom(new_atom)
            res(a,n) = fs+as-1
         end
      end
   end

!  =============
!  Read routines
!  =============

   read_name
   ! Read in the name of the molecule. This must always be
   ! the first keyword inputted.
      stdin.read(.name)
   end

   read_spin_multiplicity
   ! Read in the spin multiplicity
      stdin.read(.spin_multiplicity)
   ENSURE(.spin_multiplicity/=0,"cannot have zero multiplicity")
      if (.atom.created) then
         .n_a = .no_of_alpha_electrons
         .n_b = .no_of_beta_electrons
      end
   end

   read_charge
   ! Read in the total molecular charge
      stdin.read(.charge)
      if (.atom.created) .n_e = .no_of_electrons
   end

   read_E_field
   ! Read in the applied electric E field
      stdin.read_quantity(.E_field)
   end

   read_B_field
   ! Read in the applied magnetic B field
      stdin.read_quantity(.B_field)
   end

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      stdin.read_quantity(.gauge_origin)
   end

   read_plot_grid ::: leaky
   ! Read in the plot grid data

      ! Set up a defualt grid
      .plot_grid.destroy
      .plot_grid.create(.atom)

      ! Read options
      .plot_grid.read_keywords

      ! Check
      DIE_IF(.plot_grid.plot_format==" ","plot_format not specified (try all)")

   end

   read_isosurface ::: leaky
   ! Read in the isosurface data. NOTE: the isosurface has its own plotgrid,
   ! different from that used in normal density plots.

      if (.isosurface.destroyed) .isosurface.create(.atom)

      .isosurface.read_keywords

   end

   read_CX_isosurface ::: leaky
   ! Read in special crystalexplorer isosurface data. This only works
   ! if there is a .saved.cluster created . This CX isosurface differs from a normal
   ! isosurface in that the default box sizes for the isosurface are set from
   ! the cluster fragment (as opposed to the .atom list for normal isosurfaces),
   ! and there is a default isosurface kind, which is the "stockholder_density".
   ! NOTE: the isosurface has its own plotgrid, different from that used in 
   ! normal density plots. 

   ENSURE(.saved.created,"no saved molecule")
   ENSURE(.saved.cluster.created,"no saved cluster data")
   ENSURE(.saved.cluster.info_made, "no saved cluster info")
   ENSURE(.saved.atom.created,"no saved atom list")
   ENSURE(.atom.created,"no atom list")

      if (.isosurface.destroyed) .isosurface.create(.atom)

      .isosurface.plot_grid.set_defaults(.saved.atom)
      .isosurface.plot_grid.n_x = 2**ISOSURFACE_MINIMUM_SCAN_LEVEL + 1
      .isosurface.plot_grid.set_points_widths_origin

      .isosurface.iso_kind = "stockholder_weight"  

      !!!!!!!!!!!!!!!!!!!!!!!!!
      .isosurface.read_keywords
      !!!!!!!!!!!!!!!!!!!!!!!!!

      ! Use unit cell as bbox if requested
      if (.isosurface.plot_grid.use_unit_cell_as_bbox) then
         WARN("resetting plot axes, plot widths from unit cell")
         .isosurface.plot_grid.set_bbox_from_unit_cell(.saved.cluster.crystal.unit_cell)
      end

   end

   read_becke_grid ::: leaky
   ! Read in the Becke integration grid data
   ENSURE(.atom.created,"input atom information before becke_grid information")
      if (.becke_grid.destroyed) .becke_grid.create

      .becke_grid.set_atom_info(.atom) ! leaky
      .becke_grid.read_keywords
      .becke_grid.set_grid_data

   end

   read_crystal ::: leaky
   ! Read in the crystal data. If the ".atom" list data is available,
   ! its coordinates will be resolved into cartesians at this point.
   ! IMPORTANT NOTE: normally the crystal information will be inputted
   ! from a CIF file.  However, if the crystal information is inputted
   ! explicitly, and the asymmetric unit is not specified, then the
   ! symmetry unique atoms in the ".atom" list are used to define the
   ! crystal asymmetric unit. Once defined, the asymmetric unit in the
   ! crystal is never destroyed. Thus, in this case, you must ensure
   ! that your atom list has enough atoms to generate the entire
   ! crystal; for co-crystals this may be a problem. Use the CIF file
   ! method for input in this case, or be careful.

      WARN_IF(.crystal.created,"crystal data already defined!")

      if (.crystal.destroyed) .crystal.create

      .crystal.read_keywords

      if (.crystal.finalize) then

         .crystal.update

         if (.atom.created) then
            .resolve_axis_system
            .crystal.make_fragment_data(.atom,assign_atom=TRUE)
         end

      end

      ! Reset to finalize next time
      .crystal.finalize = TRUE 

   end

   read_pointgroup ::: leaky
   ! Read in the pointgroup data
      if (.pointgroup.destroyed) .pointgroup.create
      .pointgroup.read_keywords
   end

   read_scfdata ::: leaky
   ! Read in the scf data

      if (.scfdata.destroyed) .scfdata.create

      ! Read options
      .scfdata.read_keywords

      ! Internal post-process options
      .scfdata.finalize

   end

   read_robydata ::: leaky
   ! Read in the Roby data. NOTE: this keyword must appear after a basis set
   ! has been defined
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")

      if (.roby.created) .roby.destroy

      .get_overlap_matrix
      .roby.create(self)

      .roby.read_keywords

      .roby.finalize

   end

   read_atoms ::: leaky
   ! Read in the atom list information
      DIE_IF(.cluster.created,"cluster already defined! swap cluster= and atoms= ?")
      WARN_IF(.atom.created,"atom list already defined!")

      .atom.read_list_keywords
      .set_atom_info ! Always call this after reading
      .resolve_basis_info

      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

      .isosurface.destroy

   end

   read_basis_directory
   ! Read in the basis directory (for all kinds of bases)
      directory :: STR
      stdin.read(directory)
      .basis.set_library_directory(directory)
      .slaterbasis.set_library_directory(directory)
      .coppensbasis.set_library_directory(directory)
   end

   read_basis_name ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms.
      this :: STR
      stdin.read(this)
      .set_basis_name(this)
   end

   read_slaterbasis_name ::: leaky
   ! Read in the *slater* basis type to be used for the atoms.
      this :: STR
      stdin.read(this)
      .set_slaterbasis_name(this)
   end

   read_coppensbasis_name ::: leaky
   ! Read in the *coppens* basis type to be used for the atoms.
      this :: STR
      stdin.read(this)
      .set_coppensbasis_name(this)
   end

   read_saved_basis_name ::: leaky
   ! Read in the *gaussian* basis type to be used for the atoms in the
   ! *saved* molecule.
   ENSURE(.saved.created,"there is no saved molecule")
      this :: STR
      stdin.read(this)
      .saved.set_basis_name(this)
   end

   read_saved_slaterbasis_name ::: leaky
   ! Read in the *slater* basis type to be used for the atoms in the
   ! *saved* molecule.
   ENSURE(.saved.created,"there is no saved molecule")
      this :: STR
      stdin.read(this)
      .saved.set_slaterbasis_name(this)
   end

   read_saved_coppensbasis_name ::: leaky
   ! Read in the *coppens* basis type to be used for the atoms in the
   ! *saved* molecule.
   ENSURE(.saved.created,"there is no saved molecule")
      this :: STR
      stdin.read(this)
      .saved.set_coppensbasis_name(this)
   end

   read_basis_sets ::: leaky
   ! Read in a list of atomic basis sets for the molecule
      WARN_IF(.basis.created,"basis sets already defined!")

      ! Copy bases
      if (.atom.created)  .atom.nullify_basis_part 

      if (.basis.created) .basis.renormalise ! NOTE this
      .basis.read_list_keywords
      if (.basis.created) .basis.unnormalise ! NOTE this

      .resolve_basis_info
   end

   read_slaterbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      WARN_IF(.slaterbasis.created,"slaterbasis sets already defined!")

      if (.atom.created)  .atom.nullify_slaterbasis_part 

      if (.slaterbasis.created) .slaterbasis.renormalise
      .slaterbasis.read_list_keywords
      if (.slaterbasis.created) .slaterbasis.unnormalise

      .resolve_basis_info
   end

   read_coppensbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      WARN_IF(.coppensbasis.created,"coppensbasis sets already defined!")

      if (.atom.created)  .atom.nullify_coppensbasis_part 

      if (.coppensbasis.created) .coppensbasis.renormalise
      .coppensbasis.read_list_keywords
      if (.coppensbasis.created) .coppensbasis.unnormalise

      .resolve_basis_info
   end

   read_atom_groups ::: leaky
   ! Read in the .atom_group information
   ENSURE(.atom.created,"atom groups must be defined after atoms=")

      ! Read the atom groups
      .atom_group.read_list_keywords
      .atom_group.finalise(.atom)

      ! Make the atom groups
      .make_atom_group_info

   end

!  ==================
!  Read/write archive
!  ==================

   read_archive ::: leaky
   ! Read the archive called "name". Must also specify a basis "orb_kind", e.g.
   ! "restricted".  For use with TONTO generated archives.
   ENSURE(stdin.n_line_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")
      name,orb_kind :: STR
      stdin.read(name)
      stdin.read(orb_kind)
      stdout.text("reading archive : " // trim(name))
      .read_archive(name,orb_kind)
   end

   read_archive(name,orb_kind) ::: leaky
   ! Read the archive called "name". Must also specify a basis "orb_kind", e.g.
   ! "restricted".  For use with TONTO generated archives.
   ENSURE(.n_bf>0, "need to already know the number of basis functions")
      name,orb_kind :: STR, IN

      arch :: ARCHIVE

      arch.set(.name,name,genre=orb_kind)

      select case (name)

         case ("molecular_orbitals")
           if (.molecular_orbitals.destroyed) .molecular_orbitals.create(.n_bf)
           arch.read(.molecular_orbitals)
         ! .symmetrically_orthonormalise(.molecular_orbitals)

         case ("density_matrix    ")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix)

         case ("MP2_density_matrix")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix)

         case ("MP3_density_matrix")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix)

         case ("fock_matrix       ")
           if (.fock_matrix.destroyed) .fock_matrix.create(.n_bf)
           arch.read(.fock_matrix)

         case ("orbital_energies  ")
           if (.orbital_energies.destroyed) .orbital_energies.create(.n_bf)
           arch.read(.orbital_energies)

         case ("natural_orbitals  ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals)
           .symmetrically_orthonormalise(.natural_orbitals)

         case ("occupation_numbers")
           if (.occupation_numbers.destroyed) .occupation_numbers.create(.n_bf)
           arch.read(.occupation_numbers)

         case ("covalent_orbitals ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals)

         case ("ionic_orbitals    ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals)

         case ("U_electric_dipole ")
           if (.U_electric_dipole.destroyed) .U_electric_dipole.create(.n_bf,.n_bf,3)
           arch.read(.U_electric_dipole)

         case default
           UNKNOWN(name)

      end

      arch.close

   end

   read_ascii_archive ::: leaky
   ! Read the archive called "name". Must also specify a basis
   ! "orb_kind", e.g.  "restricted".  If required, the input order may
   ! be specified as "by_row" (default) or "by_column".
   ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,orb_kind,order :: STR
      by_column :: BIN
      arch :: ARCHIVE

      stdin.read(name)
      stdin.read(orb_kind)

      order = "by_row"
      if (NOT stdin.buffer_exhausted) stdin.read(order)

      by_column = FALSE
      if      (order=="by_row") then;    by_column = FALSE
      else if (order=="by_column") then; by_column = TRUE
      else; DIE("unknown matrix order: "//trim(order))
      end

      arch.set(.name,name,genre=orb_kind,format="ascii")

      select case (name)
         case ("molecular_orbitals")
           if (.molecular_orbitals.destroyed) .molecular_orbitals.create(.n_bf)
           arch.read(.molecular_orbitals,by_column=by_column)
         case ("density_matrix    ")
           if (.density_matrix.destroyed)     .density_matrix.create(.n_bf)
           arch.read(.density_matrix,by_column=by_column)
         case ("MP2_density_matrix")
           if (.density_matrix.destroyed)     .density_matrix.create(.n_bf)
           arch.read(.density_matrix,by_column=by_column)
         case ("MP3_density_matrix")
           if (.density_matrix.destroyed)     .density_matrix.create(.n_bf)
           arch.read(.density_matrix,by_column=by_column)
         case ("orbital_energies  ")
           if (.orbital_energies.destroyed)   .orbital_energies.create(.n_bf)
           arch.read(.orbital_energies)
         case ("natural_orbitals  ")
           if (.natural_orbitals.destroyed)   .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals,by_column=by_column)
         case ("occupation_numbers")
           if (.occupation_numbers.destroyed) .occupation_numbers.create(.n_bf)
           arch.read(.occupation_numbers)
         case ("covalent_orbitals ")
           if (.natural_orbitals.destroyed)   .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals,by_column=by_column)
         case ("ionic_orbitals    ")
           if (.natural_orbitals.destroyed)   .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals,by_column=by_column)
         case ("fock_matrix       ")
           if (.fock_matrix.destroyed)        .fock_matrix.create(.n_bf)
           arch.read(.fock_matrix,by_column=by_column)
         case default;                UNKNOWN(name)
      end
      arch.close
   end

   write_archive
   ! Write the archive called "name". The kind is defined by the object to be
   ! written.
      name :: STR
      arch :: ARCHIVE
      stdin.read(name)
      arch.set(.name,name)
      select case (name)
         case ("molecular_orbitals")
            DIE_IF(.molecular_orbitals.destroyed,"no molecular_orbitals")
            arch.write(.molecular_orbitals)
         case ("density_matrix    ")
            DIE_IF(.density_matrix.destroyed,"no density_matrix")
            arch.write(.density_matrix)
         case ("natural_orbitals  ")
            DIE_IF(.natural_orbitals.destroyed,"no natural_orbitals")
            arch.write(.natural_orbitals)
         case ("occupation_numbers")
            DIE_IF(.occupation_numbers.destroyed,"no occupation_numbers")
            arch.write(.occupation_numbers)
         case ("fock_matrix       ")
            DIE_IF(.fock_matrix.destroyed,"no fock_matrix")
            arch.write(.fock_matrix)
         case ("orbital_energies  ")
            DIE_IF(.orbital_energies.destroyed,"no orbital_energies")
            arch.write(.orbital_energies)
         case ("U_electric_dipole ")
            DIE_IF(.U_electric_dipole.destroyed,"no U_electric_dipole")
            arch.write(.U_electric_dipole)
         case default
            UNKNOWN(name)
      end
      arch.close
   end

   write_ascii_archive
   ! Write the archive called "name". The kind is defined by the object to be
   ! written. If required, the output order may be specified as
   ! "by_row" (default) or "by_column".

      name,order :: STR
      by_column :: BIN
      arch :: ARCHIVE

      stdin.read(name)

      order = "by_row"
      if (NOT stdin.buffer_exhausted) stdin.read(order)

      by_column = FALSE
      if      (order=="by_row") then;    by_column = FALSE
      else if (order=="by_column") then; by_column = TRUE
      else; DIE("unknown matrix order: "//trim(order))
      end

      arch.set(.name,name,format="ascii")

      select case (name)
         case ("molecular_orbitals"); arch.write(.molecular_orbitals,by_column=by_column)
         case ("density_matrix    "); arch.write(.density_matrix,by_column=by_column)
         case ("natural_orbitals  "); arch.write(.natural_orbitals,by_column=by_column)
         case ("occupation_numbers"); arch.write(.occupation_numbers,by_column=by_column)
         case ("fock_matrix       "); arch.write(.fock_matrix,by_column=by_column)
         case ("orbital_energies  "); arch.write(.orbital_energies,by_column=by_column)
         case default;     UNKNOWN(name)
      end
      arch.close
   end

!  ======================
!  Gaussian chk interface
!  ======================

   read_g09_FChk_file(name) ::: leaky
   ! Read a g09 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy :: VEC{REAL}*
      temp_mat,DD,MO :: MAT{REAL}*
      Z, a,s,t, f,l,g,h :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE
      Nc :: REAL

      ! Destroy existing basis, and atom list
      if (.basis.created) .basis.destroy
      if (.atom.created)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open(for="read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independ",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis functions different to no. of independent functions")
      WARN_IF(.n_bf/=n_independent,"The MO's will be wrong but the density matrix is correct")

      ! Read in atoms
      chkfile.look_for("Atomic numbers",from=1); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
      end

      ! Read in nuclear charges
      chkfile.look_for("Nuclear charges",from=1); chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(Nc)
         .atom(a).set_nuclear_charge(Nc)
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(.atom(a).position)
      end

      chkfile.look_for("Number of contracted shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)


      ! Read gaussian shell info.
      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + sum(atom_p)
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis. Expand out L shells.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy; G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy; G_ex.destroy; G_cc.destroy
      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis 
      .set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! .basis.unnormalise ! NOTE this
      .set_atom_info
      .resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf,n_independent)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .swap_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .density_matrix.destroy
      .read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.created) then
         if (.molecular_orbitals.restricted.created) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .read_gX_MP2_dm(chkfile,restricted)

      ! Extract MP3 density matrix to file.  UHF untested
      .read_gX_MP3_dm(chkfile,restricted)

      ! Extract CC density matrix to file.  UHF untested
      .read_gX_CC_dm(chkfile,restricted)

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archiveive files
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   read_g03_FChk_file(name) ::: leaky
   ! Read a g09 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy :: VEC{REAL}*
      temp_mat,DD,MO :: MAT{REAL}*
      Z, a,s,t, f,l,g,h :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE
      Nc :: REAL

      ! Destroy existing basis, and atom list
      if (.basis.created) .basis.destroy
      if (.atom.created)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open(for="read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independant functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis functions different to no. of independent functions")
      WARN_IF(.n_bf/=n_independent,"The MO's will be wrong but the density matrix is correct")

      chkfile.look_for("Number of contracted shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! Read in atoms
      chkfile.look_for("Atomic numbers",from=1); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
      end

      ! Read in nuclear charges
      chkfile.look_for("Nuclear charges",from=1); chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(Nc)
         .atom(a).set_nuclear_charge(Nc)
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(.atom(a).position)
      end

      ! Read gaussian shell info.
      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + sum(atom_p)
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis. Expand out L shells.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy; G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy; G_ex.destroy; G_cc.destroy
      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis 
      .set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! Set atom/basis info
      .set_atom_info
      .resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf,n_independent)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .swap_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .density_matrix.destroy
      .read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.created) then
         if (.molecular_orbitals.restricted.created) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .read_gX_MP2_dm(chkfile,restricted)

      ! Extract MP3 density matrix to file.  UHF untested
      .read_gX_MP3_dm(chkfile,restricted)

      ! Extract CC density matrix to file.  UHF untested
      .read_gX_CC_dm(chkfile,restricted)

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archiveive files
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   read_g94_FChk_file(name) ::: leaky
   ! Read a g94 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy :: VEC{REAL}*
      temp_mat,DD,MO :: MAT{REAL}*
      Z, a,s,t, f,l,g,h :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE

      ! Destroy existing basis, and atom list
      if (.basis.created) .basis.destroy
      if (.atom.created)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open(for="read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independant functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis functions different to no. of independent functions")
      WARN_IF(.n_bf/=n_independent,"The MO's will be wrong but the density matrix is correct")

      chkfile.look_for("Number of contracted shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! Read in atoms
      chkfile.look_for("Atomic numbers",from=1); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(.atom(a).position)
      end

      ! Read gaussian shell info.
      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + sum(atom_p)
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis. 
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        ! Expand out L shell
        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        ! Normal shell
        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy; G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy; G_ex.destroy; G_cc.destroy
      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis 
      .set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! .basis.unnormalise ! NOTE this
      .set_atom_info
      .resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf,n_independent)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .swap_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .density_matrix.destroy
      .read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.created) then
         if (.molecular_orbitals.restricted.created) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .read_gX_MP2_dm(chkfile,restricted)

      ! Extract MP3 density matrix to file.  UHF untested
      .read_gX_MP3_dm(chkfile,restricted)

      ! Extract CC density matrix to file.  UHF untested
      .read_gX_CC_dm(chkfile,restricted)

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archiveive files
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   set_basis_from_gX_data(l_4_shell,n_cc_4_sh,atom_4_sh,ex_4_prim,cc_4_prim) ::: private, leaky
   ! Set the basis from gaussian data "XXX_4_sh" are the shell data
   ! flattened over all molecular shells. "XXX_4_prim" are (likewise)
   ! data flattened over molecular primitives.
      l_4_shell,n_cc_4_sh,atom_4_sh :: VEC{INT}, IN
      ex_4_prim,cc_4_prim :: VEC{REAL}, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.atom.created,"no atonm list")
   ENSURE(.atom.dim==.n_atom,"wrong size, atom list")

      n_basis,n_shell,n_cc :: INT
      a,s,t, f,l, b :: INT
      basis :: BASIS*
      sh :: SHELL*
      same :: BIN

      ! Molecular basis (to be appended to)
      n_basis = 0
      .basis.create(n_basis)

      ! Basis fn/shell counters
      l = 0   ! Last primitive, flattened over all atoms
      t = 0   ! Last shell, flattened over all shells

      ! Loop atom "a"
      do a = 1,.n_atom

         ! Basis for atom "a"
         basis.create
         basis.label = trim(.atom(a).chemical_symbol) // ":gaussian"

         ! Set basis label and kind
         .atom(a).set_basis_label(basis.label)
         .atom(a).set_basis_kind("gaussian")

         ! No. of shells
         n_shell = count(atom_4_sh==a)

         ! Create basis shells
         basis.n_shell = n_shell
         basis.shell.create(n_shell)
         basis.shell.nullify_ptr_part

         ! Set basis shells
         do s = 1,n_shell

            ! This shell
            sh => basis.shell(s)

            ! Set shell L
            sh.set_l(l_4_shell(t+s))
            sh.set_n_comp

            ! Set shell n_cc
            n_cc    = n_cc_4_sh(t+s)
            sh.n_cc = n_cc

            ! Set shell exponents/contractions
            sh.exponent.create(n_cc)
            sh.contraction.create(n_cc)
            f = l + 1
            l = l + n_cc
            sh.exponent    = ex_4_prim(f:l)
            sh.contraction = cc_4_prim(f:l)

         end

         ! Set no. of bf'd and primitives
         basis.n_bf   = basis.no_of_basis_functions
         basis.n_prim = basis.no_of_primitives
         basis.unnormalise ! Note this

         t = t + n_shell

         ! Seen basis before?
         same = FALSE
         do b = 1,n_basis
            if (NOT .basis(b).same_as(basis)) cycle
            same = TRUE
            exit
         end

         ! Append only new basis to .basis
         if (NOT same) then
            n_basis = n_basis + 1
            .basis.append(basis)
         end

         ! Clean
         basis.destroy

      end

   end

   read_gX_dm(chkfile,restricted,dm) ::: template, private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
      chkfile :: TEXTFILE*
      restricted :: BIN, IN
      dm :: OPMATRIX*, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.n_bf>0,"no basis functions")

      D,spin,total :: OPMATRIX*
      archive :: ARCHIVE

      ! Extract density matrix
      if (NOT chkfile.has_string("TAG Density")) return

      if (restricted) then

         ! Read restricted density (triangle) "name" into "D"
         D.create(.n_bf, "restricted")
         D.triangle.create(D.l_compress("restricted"))
         chkfile.look_for("Total TAG Density")
         chkfile.read_line
         chkfile.read(D.triangle)
         D.uncompress

         ! Swap orbital order
         .swap_g94_orbital_order(D.restricted,"row")
         .swap_g94_orbital_order(D.restricted,"column")

      else

         ! Create
         D.create(.n_bf,"unrestricted")
         total.create(.n_bf, "restricted")
         spin.create(.n_bf, "restricted")

         ! Read total density (triangle) TAG into "total"
         total.triangle.create(total.l_compress("restricted"))
         chkfile.look_for("Total TAG Density")
         chkfile.read_line
         chkfile.read(total.triangle)
         total.uncompress

         ! Read spin density (triangle) trim(tag) into "spin"
         spin.triangle.create(spin.l_compress("restricted"))
         chkfile.look_for("Spin TAG Density")
         chkfile.read_line
         chkfile.read(spin.triangle)
         spin.uncompress

         ! Define alpha and beta densities
         D.beta  = (total.restricted - spin.restricted)/2
         D.alpha = (spin.restricted  + total.restricted)/2

         ! Clean
         spin.destroy
         total.destroy

         ! Swap orbital order
         .swap_g94_orbital_order(D.alpha,"row")
         .swap_g94_orbital_order(D.alpha,"column")
         .swap_g94_orbital_order(D.beta, "row")
         .swap_g94_orbital_order(D.beta, "column")

      end

      ! Archive the density "D"
      archive.set_defaults
      archive.set(.name,NAME)
      archive.write(D)

      ! Clean
      if (present(dm)) then; dm => D
      else;                  D.destroy
      end

   end

   read_gX_SCF_dm(chkfile,restricted,dm) ::: get_from(MOLECULE:read_gX_dm, TAG=>SCF, NAME=>"SCF_density_matrix"), private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP2_dm(chkfile,restricted,dm) ::: get_from(MOLECULE:read_gX_dm, TAG=>MP2,  NAME=>"MP2_density_matrix"), private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP3_dm(chkfile,restricted,dm) ::: get_from(MOLECULE:read_gX_dm, TAG=>MP3,  NAME=>"MP3_density_matrix"), private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_CC_dm(chkfile,restricted,dm) ::: get_from(MOLECULE:read_gX_dm, TAG=>CC,  NAME=>"CC_density_matrix"), private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
   end

   swap_g94_orbital_order(X,swap)
   ! Swap the order of f orbitals on matrix "X" after reading a
   ! gaussian checkpoint file, for "swap" equal to "row" or "1", or
   ! "coloumn" or "2". Also: remove the intra-shell basis function
   ! normalisation factors which are not used in Tonto.
      X :: MAT{REAL}
      swap :: STR
      s,f,l,ls,fg,lg,i,j :: INT
      fac :: VEC{REAL}*
      ff :: VEC{INT}(10) = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 /)
      select case (swap)
         case("row","1")
            do s = 1,.n_shell
               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)
               ENSURE(ls<=3,"cannot yet convert order for g shells")
               if (ls==3) then ! swap f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
               if (ls>1) then  ! normalisation factors
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1     
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do i = f,l
                     X(i,:) = X(i,:)*fac(i-f+1)
                  end
               end
            end
         case("column","2")
            do s = 1,.n_shell
               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)
               ENSURE(ls<=3,"cannot yet convert order for g shells")
               if (ls==3) then ! swap f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
               if (ls>1) then  ! normalisation factors
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1     
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do j = f,l
                     X(:,j) = X(:,j)*fac(j-f+1)
                  end
               end
            end
         case default
            DIE("unknown swap kind, "//trim(swap))
      end
   end

!  ========================
!  AIM2000/Morphy interface
!  ========================

   write_morphy98_wfn_file ::: leaky
   ! Write a morphy98 .wfn file

   ENSURE(.occupation_numbers.created("restricted"), "No occupation numbers")
   ENSURE(.orbital_energies.created("restricted"), "No orbital energies")
   ENSURE(.molecular_orbitals.created("restricted"), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}*
      evec :: VEC{REAL}*
      dmatrix, cc :: MAT{REAL}*
      sh :: SHELL*
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
!      title_format :: STR, parameter = "(A80)"
      n_vars_format :: STR, parameter = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(name)
      wfnfile.open(for="write")

      if (mod(.n_e, 2)==0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end

      write(unit = wfnfile.unit, fmt = '(a)') trim(name) // " computed by TONTO"
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).position, REALIFY(.atom(i).atomic_number) , i = 1, .n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )

      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atomn  = .atom_for_shell(a)
        shelln = .atom_shell_for_shell(a)
        sh => .atom(atomn).basis.shell(shelln)
        l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
        do j = 1, sh.n_cc
          if (sh.l==3) then
            lvec(pcount  ) = l + 1
            lvec(pcount+1) = l + 2
            lvec(pcount+2) = l + 3
            lvec(pcount+3) = l + 4
            lvec(pcount+4) = l + 5
            lvec(pcount+5) = l + 7
            lvec(pcount+6) = l + 6
            lvec(pcount+7) = l + 8
            lvec(pcount+8) = l + 9
            lvec(pcount+9) = l + 10
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              pcount = pcount + 1
            end
          else
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              lvec(pcount) = l + i
              pcount = pcount + 1
            end
          end
        end
      end

      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec
      lvec.destroy
      evec.destroy
      dmatrix.create(.n_prim, .n_bf)
      dmatrix = ZERO
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)

      dmatrix.to_product_of(cc,.molecular_orbitals.restricted)
      do i = 1, n_orbitals
         write(unit = wfnfile.unit, fmt = mol_title_format) &
            "MO  ", i, &
            "OCC NO = ", .occupation_numbers.restricted(i), &
            " ORB. ENERGY = ", .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end

      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      if (.scfdata.created) then
      write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      else
      write(unit = wfnfile.unit, fmt = e_v_format) ZERO, 2.0D00
      end

      ! Clean
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy

   end

   write_aim2000_wfn_file ::: leaky
   ! Writes a proaim2000 .wfn file
   ENSURE(.occupation_numbers.created("restricted"), "No occupation numbers")
   ENSURE(.orbital_energies.created("restricted"), "No orbital energies")
   ENSURE(.molecular_orbitals.created("restricted"), "No orbitals")
      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}*
      evec :: VEC{REAL}*
      dmatrix, cc :: MAT{REAL}*
      sh :: SHELL*
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
!      title_format :: STR, parameter = "(A80)"
      n_vars_format :: STR, parameter = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "('MO  ', I3,'    MO 0.0        OCC NO =',F13.7,'  ORB. ENERGY =',F12.7)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(name)
      wfnfile.open(for="write")

      if (mod(.n_e, 2)==0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end

      write(unit = wfnfile.unit, fmt = '(a)') trim(name) // " computed by TONTO"
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).position, REALIFY(.atom(i).atomic_number) , i = 1, .n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )

      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atomn  = .atom_for_shell(a)
        shelln = .atom_shell_for_shell(a)
        sh => .atom(atomn).basis.shell(shelln)
        l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
        do j = 1, sh.n_cc
          if (sh.l==3) then
            lvec(pcount  ) = l + 1
            lvec(pcount+1) = l + 2
            lvec(pcount+2) = l + 3
            lvec(pcount+3) = l + 4
            lvec(pcount+4) = l + 5
            lvec(pcount+5) = l + 7
            lvec(pcount+6) = l + 6
            lvec(pcount+7) = l + 8
            lvec(pcount+8) = l + 9
            lvec(pcount+9) = l + 10
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              pcount = pcount + 1
            end
          else
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              lvec(pcount) = l + i
              pcount = pcount + 1
            end
          end
        end
      end

      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec
      lvec.destroy
      evec.destroy
      dmatrix.create(.n_prim, .n_bf)
      dmatrix = ZERO
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)

      dmatrix.to_product_of(cc,.molecular_orbitals.restricted)
      do i = 1, n_orbitals
         write(unit=wfnfile.unit, fmt=mol_title_format) &
            i, .occupation_numbers.restricted(i), .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end

      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      if (.scfdata.created) then
      write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      else
      write(unit = wfnfile.unit, fmt = e_v_format) ZERO, 2.0D00
      end

      ! Clean
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy

   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put all the available molecule information on file

   DIE_IF(tonto.destroyed,"no tonto variable")

      .put_basics

      if (tonto.low_verbosity) then
      if (.atom.created) then
         if (.atom.dim>100) return
      end
      end

      if (.atom.created)        .put_atoms
      if (.atom_group.created)  .atom_group.put
      if (.pointgroup.created)  .put_pointgroup
      if (.crystal.created)     .put_crystal
      if (.cluster.created)     .put_cluster
      if (.becke_grid.created)  .put_becke_grid

      if (.overlapping_atoms.created AND .atom.created) then
         .put_overlapping_atoms
         .put_overlapping_atoms_4_atom
      end

   end

   put_basics
   ! Put basic molecule information

      stdout.flush
      stdout.flush
      stdout.text("====================")
      stdout.text("Molecule information")
      stdout.text("====================")

      stdout.flush
      stdout.show("Name                   =",.name)

      stdout.flush
      stdout.show("Chemical Formula       =",trim(.chemical_formula(with_spaces=TRUE)))
      stdout.show("Molecular weight       =",.atom.molecular_weight)

      stdout.flush
      stdout.show("Charge                 =",.charge)
      stdout.show("Multiplicity           =",.spin_multiplicity)

      stdout.flush
      stdout.show("No. of atoms           =",.n_atom)
      stdout.show("No. of electrons       =",.n_e)
      stdout.show("No. of alpha electrons =",.n_a)
      stdout.show("No. of beta  electrons =",.n_b)

      if (.atom.has_all_bases) stdout.flush
      if (.basis_name/=" ") then
      stdout.show("Gaussian basis name    =",.basis_name)
      stdout.show("Spherical harmonics?   =",.use_spherical_basis)
      end
      if (.slaterbasis_name/=" ") &
      stdout.show("Slater basis name      =",.slaterbasis_name)
      if (.coppensbasis_name/=" ") &
      stdout.show("Coppens basis name     =",.coppensbasis_name)

      if (NOT .E_field.is_zero) &
      stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
      if (NOT .B_field.is_zero) &
      stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
      if (NOT .gauge_origin.is_zero) &
      stdout.show("B field Gauge origin   =",.gauge_origin)

   end

   put_atoms
   ! Output the atom coordinate and basis set information
   ENSURE(.atom.created,"no atom list")
      .atom.put_coordinate_info
      if (.basis.created)        .put_bases
    ! if (.coppensbasis.created) .put_coppensbases
    ! if (.slaterbasis.created)  .put_slaterbases
    ! .put_atom_ADP_tensors
   end

   put_principal_axes
   ! Output the atom principal axes
   ENSURE(.atom.created,"no atom list")
      .atom.put_principal_axes
   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.
   ENSURE(.atom.created,"no atom list")
   ENSURE(.basis.created,"no basis set list")
      if (NOT .atom.bases_are_resolved) return

      stdout.flush
      stdout.flush
      stdout.text("===================")
      stdout.text("Gaussian basis sets")
      stdout.text("===================")
      stdout.flush
      stdout.show("Basis name             =",.basis_name)
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.no_of_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      stdout.flush

      .basis.renormalise
      .basis.put
      .basis.unnormalise

   end

   put_slaterbases
   ! Output the molecule slaterbasis set information, if the bases are all
   ! resolved.
   ENSURE(.atom.created,"no atom list")
   ENSURE(.slaterbasis.created,"no basis set list")
      if (NOT .atom.slaterbases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom slaterbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.slaterbasis.dim)
      .slaterbasis.put
   end

   put_coppensbases
   ! Output the molecule coppensbasis set information, if the bases are all
   ! resolved.
   ENSURE(.atom.created,"no atom list")
   ENSURE(.coppensbasis.created,"no basis set list")
      if (NOT .atom.coppensbases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom coppensbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.coppensbasis.dim)
      stdout.show("Maximum N value   =",.coppensbasis.maximum_basis_n_value)
      stdout.show("No. of orbitals   =",.coppensbasis.no_of_orbitals)
      stdout.show("No. of primitives =",.coppensbasis.no_of_primitives)
      .coppensbasis.put
   end

!   put_atom_ADP_tensors
!   ! Output the ADP (thermal) tensors if they exist.
!   
!   ENSURE(.atom.created,"no atom info")
!
!      xmodel,nmodel :: STR
!
!      if (NOT .atom.has_thermal_factors) return
!
!      xmodel = "none"
!      nmodel = "none"
!      if (.crystal.created) then
!         if (.crystal.xray_data.created) xmodel = .crystal.xray_data.thermal_smearing_model
!         if (.crystal.pnd_data.created)  nmodel = .crystal.pnd_data.thermal_smearing_model
!      end
!
!      stdout.flush
!      stdout.flush
!      stdout.text("==============================")
!      stdout.text("Atomic displacement parameters")
!      stdout.text("==============================")
!      stdout.flush
!      stdout.show("X-ray ADP model =",xmodel)
!      stdout.show("PND   ADP model =",nmodel)
!
!      .atom.put_ADPs(.crystal.unit_cell)
!
!   end

   put_atom_groups
   ! Out out the .atom_group info array
   ENSURE(.atom_group.created,"no atom group information")
      .atom_group.put
   end

   put_overlapping_atoms
   ! Out out the .overlapping_atom info array
   ENSURE(.overlapping_atoms.created,"no overlapping_atoms")
   ENSURE(.atom.created,"no atoms")
      i,j,k :: INT
      stdout.save
      stdout.set_int_width(4)
      stdout.set_n_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)
      stdout.text(" ")
      stdout.text("Overlapping atoms:")
      stdout.text(" ")
      do i = 1,.atom.dim
         k = 1
         stdout.put(i)
         do j = 1,.atom.dim
            if (NOT .is_overlapping_atom(i,j)) cycle
            k = k + 1
            stdout.put(j)
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end
      stdout.unsave
   end

   put_overlapping_atoms_4_atom
   ! Out out the .overlapping_atoms_for_atom info array
   ENSURE(.overlapping_atoms.created,"no overlapping_atoms")
   ENSURE(.atom.created,"no atoms")
      i,j,k :: INT
      stdout.save
      stdout.set_int_width(4)
      stdout.set_n_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)
      stdout.text(" ")
      stdout.text("Overlapping atoms for atom:")
      stdout.text(" ")
      do i = 1,.atom.dim
         stdout.put(i)
         k = 1
         do j = 1,.overlapping_atoms_for_atom(i).element.dim
            k = k + 1
            stdout.put(.overlapping_atoms_for_atom(i)[j])
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end
      stdout.unsave
   end

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put
   end

   put_plot_grid
   ! Output the current grid.
   ENSURE(.plot_grid.created,"no plot grid to output")
      .plot_grid.put
   end

   put_becke_grid
   ! Output the current DFT grid.
   ENSURE(.becke_grid.created,"no Becke integration grid to output")
      .becke_grid.put
   end

   put_crystal
   ! Output the current crystal
      .crystal.put
   end

   put_cluster
   ! Put out the cluster information
   ENSURE(.cluster.created,"no cluster data")
      .cluster.put
   end

   put_crystal_reflection_data
   ! Output the current crystal
      .crystal.put_reflection_data
   end

   put_crystal_F_statistics
   ! Output the current crystal
      .crystal.put_F_statistics
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_MOs_and_energies
   ! Output the current associated molecular orbitals and their energies
      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.orbital_energies)
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_MO_energies
   ! Output the molecular orbital energies
      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.orbital_energies)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put(.occupation_numbers)
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix
   ENSURE(.density_matrix.created,"no density matrix")
      stdout.flush
      stdout.text("Density matrix:")
      stdout.put(.density_matrix)
   end

   put_fock_matrix
   ! Output the current associated fock matrix
   ENSURE(.fock_matrix.created,"no fock matrix")
      stdout.flush
      stdout.text("Fock matrix:")
      stdout.put(.fock_matrix)
   end

   put_PND_sf
   ! Output the magnetic structure factors
      .crystal.put_PND_sf(.name)
   end

   put_current_time(timer)
   ! Output the current time
      timer :: TIME
      if (FALSE) self = self
      stdout.text(timer.current_time_message)
   end

   put_time_taken(timer)
   ! Output the time taken as given by the "timer" object
      timer :: TIME
      if (FALSE) self = self
      stdout.text(timer.elapsed_time_message)
   end

   put_vrml
   ! Output a VRML file for the coordinate geometry
   ENSURE(.atom.created,"no atom list!")
      out :: TEXTFILE*
      out.create(trim(.name)//achar(46)//"wrl")
      out.open(for="write")
      stdout.text("Generating VRML molecule")
      out.text("#VRML V2.0 utf8")
      out.text("NavigationInfo { type " // achar(34) // "EXAMINE" // achar(34) // " }")
      out.text("Viewpoint { ")
      out.text("position 0 0 10")
      out.text("fieldOfView 1")
      out.text("orientation 0 0 1 0")
      out.text('description "camera z"')
      out.text("}")
      out.text("DirectionalLight {")
      out.text("  color 1 1 1")
      out.text("  direction 1 0 0")
      out.text("  intensity 0.4")
      out.text("}")
      .atom.put_vrml(out)
      if (.isosurface.created) .isosurface.put_vrml(out)
      stdout.text("done VRML molecule")
   end

!  =======================
!  One electron properties
!  =======================

   put_1e_properties ::: leaky
   ! Put all the available one elctron properties
   ENSURE(.density_matrix.created,"no density")
   ENSURE(.atom.created,"no atoms")
   ENSURE(.basis.created,"no basis sets specified")
    ! charge :: VEC{REAL}*

      .make_ao_density_matrix    ! leaky

      .put_mulliken_populations  ! leaky

      .put_dipole

    ! charge.create(.n_atom)
    ! .put_gaussian_atom_charges(charge)
    ! .put_gaussian_atom_dipoles(charge)
    ! charge.destroy

    ! .put_GH_atom_charges

      .put_Hirshfeld_atom_info ! leaky
      if (.density_matrix.alpha.created) .put_uHirshfeld_atom_info

      .put_quadrupole
      .put_octupole
      .put_E_field_at_nuclei
      .put_EFG_at_nuclei

      .delete_atom_scf_archives ! clean up leak here

   end

   put_mulliken_populations ::: leaky
   ! sets the mulliken population matrix and the outputs it.
      mulliken_matrix, density :: MAT{REAL}*
      diagonals :: VEC{REAL}*
      S2 :: MAT{REAL}*
      mulliken_matrix2 :: MAT{CPX}*
      diagonals2 :: VEC{CPX}*

      ! Create space
      mulliken_matrix.create(.n_bf, .n_bf)
      diagonals.create(.n_bf)

      ! Overlap matrix
      .get_overlap_matrix ! leaky

      ! general complex case (LBxxx)
      if (.density_matrix.created("general_complex")) then

         ! these objects are twice as large as usually
         S2.create(2*.n_bf,2*.n_bf)
         mulliken_matrix2.create(2*.n_bf,2*.n_bf)
         diagonals2.create(2*.n_bf)
         S2=ZERO; mulliken_matrix2=(ZERO,ZERO); diagonals2=(ZERO,ZERO)
         S2.alpha_alpha_set_to(.overlap_matrix)
         S2.beta_beta_set_to(.overlap_matrix)

         stdout.flush
         stdout.text(" These are the GCHF Mulliken populations! ")

         ! fill the general_complex mulliken matrix and diagonals
         mulliken_matrix2.to_product_of(.density_matrix.general_complex,S2)
         mulliken_matrix2.put_diagonal_to(diagonals2)

         ! Make use of the restricted mulliken matrix
         diagonals = REALIFY(diagonals2(1:.n_bf)) + REALIFY(diagonals2(.n_bf+1:2*.n_bf))
         mulliken_matrix = REALIFY(mulliken_matrix2(1:.n_bf,1:.n_bf)) +  &
                           REALIFY(mulliken_matrix2(.n_bf+1:2*.n_bf,.n_bf+1:2*.n_bf))

         ! Put the atomic populations
         .put_mulliken_populations(mulliken_matrix, diagonals)

         mulliken_matrix2.destroy
         diagonals2.destroy
         S2.destroy

      ! Unrestricted case
      else if (.density_matrix.created("unrestricted")) then

         ! Temporary
         density.create(.n_bf,.n_bf)

         ! Restricted density matrix
         density = .density_matrix.alpha + .density_matrix.beta

         ! Normal mulliken population
         mulliken_matrix = matmul(density,.overlap_matrix)
         mulliken_matrix.put_diagonal_to(diagonals)

         ! Put the populations
         .put_mulliken_populations(mulliken_matrix, diagonals)

         ! Unpaired density matrix
         density = .density_matrix.alpha - .density_matrix.beta
         mulliken_matrix = matmul(density,.overlap_matrix)
         mulliken_matrix.put_diagonal_to(diagonals)

         ! Put the spin populations
         .put_mulliken_spins(mulliken_matrix, diagonals)

         ! Clean up
         density.destroy

      ! Restricted case
      else if (.density_matrix.created("restricted")) then

         ! Make the restricted mulliken matrix
         mulliken_matrix = matmul(.density_matrix.restricted,.overlap_matrix)
         mulliken_matrix.put_diagonal_to(diagonals)

         ! Put the atomic populations
         .put_mulliken_populations(mulliken_matrix, diagonals)

      else

        DIE("Mulliken populations not yet implemented for this case")

      end

      ! Clean up
      mulliken_matrix.destroy
      diagonals.destroy

   end

   put_mulliken_populations(mulliken_matrix, diagonals)
   ! outputs the mulliken populations to the output file

  ! ENSURE(NOT .use_spherical_basis,"not implemented")

      mulliken_matrix :: MAT{REAL}
      diagonals :: VEC{REAL}
      atom_pop :: VEC{REAL}*
      pop :: REAL
      o_count, a, b, c, n_comp :: INT

      stdout.flush
      stdout.text("Mulliken population analysis: ")
      stdout.dash(int_fields=2,real_fields=1)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Type", int_width = TRUE)
      stdout.put("Population")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=1)
      o_count = 1
      atom_pop.create(.n_atom)
      atom_pop = ZERO
      do a = 1, .n_atom
         do b = 1, .atom(a).basis.n_shell
         !LBxxx
           if(.use_spherical_basis)then 
              n_comp=.atom(a).basis.shell(b).n_sph
           else
              n_comp=.atom(a).basis.shell(b).n_comp
           end if  
       !LBxxx     do c = 1, .atom(a).basis.shell(b).n_comp
            do c = 1, n_comp
               stdout.put(.atom(a).label, int_width = TRUE)
               stdout.put(.atom(a).basis.shell(b).l_chr, int_width = TRUE)
               pop = diagonals(c + o_count - 1)
               stdout.put(pop)
               atom_pop(a) = atom_pop(a) + pop
               stdout.flush
            end
        !    o_count = o_count + .atom(a).basis.shell(b).n_comp
            o_count = o_count + n_comp
         end
      end
      stdout.dash(int_fields=2,real_fields=1)
      stdout.flush
      stdout.show("Trace of the Mulliken matrix =",mulliken_matrix.trace)
      stdout.flush
      stdout.text("Atomic Populations: ")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=2)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Population")
      stdout.put("Charge")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=2)
      do a = 1, .n_atom
         stdout.put(.atom(a).label, int_width = TRUE)
         stdout.put(atom_pop(a))
         stdout.put(.atom(a).atomic_number-atom_pop(a))
         stdout.flush
      end
      stdout.dash(int_fields=1, real_fields=2)
      atom_pop.destroy
      stdout.flush
    ! stdout.text("Mulliken matrix:")
    ! stdout.put(mulliken_matrix)
   end

   put_mulliken_spins(mulliken_matrix,diagonals)
   ! Outputs the mulliken populations to the output file
      mulliken_matrix :: MAT{REAL}
      diagonals :: VEC{REAL}

   ! ENSURE(NOT .use_spherical_basis,"not implemented")

      atom_pop :: VEC{REAL}*
      pop :: REAL
      o_count, a, b, c, n_comp :: INT

      ! Print out the spins for every basis function
      stdout.flush
      stdout.text("Mulliken spin population analysis: ")
      stdout.dash(int_fields=2,real_fields=1)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Type", int_width = TRUE)
      stdout.put("Spin pop")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=1)
      o_count = 1
      atom_pop.create(.n_atom)
      atom_pop = ZERO
      do a = 1, .n_atom
         do b = 1, .atom(a).basis.n_shell
           if(.use_spherical_basis)then 
              n_comp=.atom(a).basis.shell(b).n_sph
           else
              n_comp=.atom(a).basis.shell(b).n_comp
           end if  
            do c = 1, n_comp
               stdout.put(.atom(a).label, int_width = TRUE)
               stdout.put(.atom(a).basis.shell(b).l_chr, int_width = TRUE)
               pop = diagonals(c + o_count - 1)
               stdout.put(pop)
               atom_pop(a) = atom_pop(a) + pop ! Add up the atomic spins for below
               stdout.flush
            end
            o_count = o_count + n_comp
         end
      end
      stdout.dash(int_fields=2,real_fields=1)

      stdout.flush
      stdout.show("Trace of the Mulliken spin matrix =",mulliken_matrix.trace)

      ! Print out the spins
      stdout.flush
      stdout.text("Atomic spin populations: ")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=1)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Spin")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=1)
      do a = 1, .n_atom
         stdout.put(.atom(a).label, int_width = TRUE)
         stdout.put(atom_pop(a))
         stdout.flush
      end
      stdout.dash(int_fields=1, real_fields=1)

      ! Clean up
      atom_pop.destroy
      stdout.flush

   end

   put_dipole
   ! Put out the dipole to stdout
      electronic,nuclear,total :: VEC{REAL}(3)
      dmag :: REAL
      axis :: VEC{STR}(3)
      i :: INT
      axis = [ "x", "y", "z" ]
      electronic = .electronic_dipole_moment
      nuclear    = .nuclear_dipole_moment
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Dipole moments:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,3
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye"))
         stdout.put(nuclear(i).to_units("debye"))
         stdout.put(total(i).to_units("debye"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)
      stdout.flush
      dmag = sqrt(dot_product(total,total))
      stdout.show("Dipole magnitude/au    =",dmag)
      stdout.show("Dipole magnitude/Debye =",dmag.to_units("debye"))
   end

   put_quadrupole
   ! Put out the quadrupole to stdout
      electronic,nuclear,total :: VEC{REAL}(6)
      axis :: VEC{STR}(6)
      i :: INT
      axis = [ "xx","yy","zz","xy","xz","yz" ]
      electronic = .electronic_quadrupole_moment
      nuclear    = .nuclear_quadrupole_moment
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Quadrupole moments:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye-A")
      stdout.put("/Debye-A")
      stdout.put("/Debye-A")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,6
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye-angstrom"))
         stdout.put(nuclear(i).to_units("debye-angstrom"))
         stdout.put(total(i).to_units("debye-angstrom"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)
   end

   put_octupole
   ! Put out the octupole to stdout
      electronic,nuclear,total :: VEC{REAL}(10)
      axis :: VEC{STR}(10)
      i :: INT
      axis = [ "xxx","yyy","zzz","xxy","xxz","yyx","yyz","zzx","zzy","xyz" ]
      electronic = .electronic_octupole_moment
      nuclear    = .nuclear_octupole_moment
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Octupole moments:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye-A2")
      stdout.put("/Debye-A2")
      stdout.put("/Debye-A2")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,10
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye-angstrom^2"))
         stdout.put(nuclear(i).to_units("debye-angstrom^2"))
         stdout.put(total(i).to_units("debye-angstrom^2"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)
   end

   put_E_field_at_nuclei
   ! Put out the electric field at every nuclear position

      cluster :: CLUSTER*
      electronic,nuclear,molecule,LF,xtal, pos :: MAT{REAL}*
      charge :: VEC{REAL}*
      r,d,F :: VEC{REAL}(3)
      axis :: VEC{STR}(3)
      symbol :: VEC{STR}*
      mol_rms,LF_rms,xtal_rms, d3 :: REAL
      a,i, n_charges :: INT

      axis = [ "x", "y", "z" ]
      symbol => .atom.unique_tags

      electronic.create(3,.n_atom)
      nuclear.create(3,.n_atom)
      molecule.create(3,.n_atom)

      electronic = .electronic_E_field_at_nuclei
      nuclear    = .nuclear_E_field_at_nuclei
      molecule   = electronic + nuclear

      ! Table
      stdout.flush
      stdout.text("Electric fields at nuclei:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.tab(real_fields=1,int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Atom")
      stdout.put("E_i",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_atom
      do i = 1,3
         if (i==1) then; stdout.put(symbol(a))
         else;           stdout.tab(real_fields=1)
         end
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i,a))
         stdout.put(nuclear(i,a))
         stdout.put(molecule(i,a))
         stdout.flush
      end
      end
      stdout.dash(int_fields=1,real_fields=4)

      ! Add crystal field?
      if (.crystal.created) then

         ! Make atomic charges and dipoles
         if  (NOT .Hirshfeld_atom_info_made) .make_Hirshfeld_atom_info

         ! Set up the cluster ... leaky
         LF.create(3,.n_atom)
         cluster.create(.crystal)
         cluster.set_fragment_geometry(.atom.coordinates,cartesian=TRUE)
         cluster.set_generation_method("within_radius")
         cluster.defragment= TRUE
         cluster.radius = 10.0d0
         if (.scfdata.created) cluster.radius = .scfdata.cluster_radius
         cluster.make_info ! leaky

         ! Make Lorentz field ... does not need full cluster
         cluster.make_Lorentz_fields(LF)

         ! Make Xtal electric field
         xtal => electronic
         xtal = LF + molecule

         ! RMS values
         mol_rms  = ZERO
         LF_rms   = ZERO
         xtal_rms = ZERO

         ! Table
         stdout.flush
         stdout.text("Electric fields at nuclei--including crystal environment:")
         stdout.text("Calculated using charge and dipole Lorentz field tensors,")
         stdout.text("and Hirshfeld charges and dipoles at every u/c atom site")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=4)
         stdout.tab(real_fields=1,int_fields=1)
         stdout.put("Molecule")
         stdout.put("Environment")
         stdout.put("Crystal")
         stdout.flush
         stdout.put("Atom")
         stdout.put("E_i",int_width=TRUE)
         stdout.put("/au")
         stdout.put("/au")
         stdout.put("/au")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=4)
         do a = 1,.n_atom
         do i = 1,3
            if (i==1) then; stdout.put(symbol(a))
            else;           stdout.tab(real_fields=1)
            end
            stdout.put(axis(i),int_width=TRUE)
            stdout.put(molecule(i,a))
            stdout.put(LF(i,a))
            stdout.put(xtal(i,a))
            stdout.flush
            mol_rms  = mol_rms   + dot_product(molecule(:,a),molecule(:,a))
            LF_rms   = LF_rms    + dot_product(LF(:,a),LF(:,a))
            xtal_rms = xtal_rms  + dot_product(xtal(:,a),xtal(:,a))
         end
         end
         stdout.dash(int_fields=1,real_fields=4)

         mol_rms  = sqrt(mol_rms/.n_atom)
         LF_rms   = sqrt(LF_rms/.n_atom)
         xtal_rms = sqrt(xtal_rms/.n_atom)

         stdout.flush
         stdout.show("RMS value for molecular    E field =",mol_rms)
         stdout.show("RMS value for environment  E field =",LF_rms)
         stdout.show("RMS value for Xtal (total) E field =",xtal_rms)

         ! Make the cluster charges
         n_charges = cluster.n_atoms - cluster.n_fragment_atoms
         n_charges = 3*n_charges
       ! n_charges = 2*n_charges
       ! n_charges = n_charges
         charge.create(n_charges)
         pos.create(3,n_charges)
         cluster.make_non_fragment_mu_charges(pos,charge)
       ! cluster.make_non_fragment_positions2(pos,charge)
       ! cluster.make_non_fragment_positions3(pos,charge)

         ! Get the point charge electric fields
         LF = ZERO
         do a = 1,.n_atom
            r = .atom(a).position
            F = ZERO
            do i = 1,n_charges
               d  = r - pos(:,i)
               d3 = sqrt(dot_product(d,d))
               d3 = d3*d3*d3
               F = F + charge(i)*d/d3
            end
            LF(:,a) = F
         end

         ! Make Xtal electric field
         xtal => electronic
         xtal = LF + molecule

         ! RMS values
         mol_rms  = ZERO
         LF_rms   = ZERO
         xtal_rms = ZERO

         ! Table
         stdout.flush
         stdout.text("Electric fields at nuclei--including crystal environment:")
         stdout.text("Calculated using Hirshfeld point charges and dipoles")
         stdout.show("Cluster radius in au =",cluster.radius)
         stdout.flush
         stdout.dash(int_fields=1,real_fields=4)
         stdout.tab(real_fields=1,int_fields=1)
         stdout.put("Molecule")
         stdout.put("Environment")
         stdout.put("Crystal")
         stdout.flush
         stdout.put("Atom")
         stdout.put("E_i",int_width=TRUE)
         stdout.put("/au")
         stdout.put("/au")
         stdout.put("/au")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=4)
         do a = 1,.n_atom
         do i = 1,3
            if (i==1) then; stdout.put(symbol(a))
            else;           stdout.tab(real_fields=1)
            end
            stdout.put(axis(i),int_width=TRUE)
            stdout.put(molecule(i,a))
            stdout.put(LF(i,a))
            stdout.put(xtal(i,a))
            stdout.flush
            mol_rms  = mol_rms   + dot_product(molecule(:,a),molecule(:,a))
            LF_rms   = LF_rms    + dot_product(LF(:,a),LF(:,a))
            xtal_rms = xtal_rms  + dot_product(xtal(:,a),xtal(:,a))
         end
         end
         stdout.dash(int_fields=1,real_fields=4)

         mol_rms  = sqrt(mol_rms/.n_atom)
         LF_rms   = sqrt(LF_rms/.n_atom)
         xtal_rms = sqrt(xtal_rms/.n_atom)

         stdout.flush
         stdout.show("RMS value for molecular    E field =",mol_rms)
         stdout.show("RMS value for environment  E field =",LF_rms)
         stdout.show("RMS value for Xtal (total) E field =",xtal_rms)

         ! Clean up
         pos.destroy; charge.destroy
         cluster.destroy
         LF.destroy

      end

      molecule.destroy
      nuclear.destroy
      electronic.destroy
      symbol.destroy

   end

   put_EFG_at_nuclei
   ! Put out the electric field gradient at every nuclear position
      electronic,nuclear,total :: MAT{REAL}*
      axis :: VEC{STR}(6)
      symbol :: VEC{STR}*
      a,i :: INT
      axis = [ "xx","yy","zz","xy","xz","yz" ]
      symbol => .atom.unique_tags
      electronic.create(6,.n_atom)
      nuclear.create(6,.n_atom)
      total.create(6,.n_atom)
      electronic = .electronic_EFG_at_nuclei
      nuclear    = .nuclear_EFG_at_nuclei
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Electric field gradient at nuclei:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.tab(real_fields=1,int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Atom")
      stdout.put("E_ij",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_atom
      do i = 1,6
         if (i==1) then; stdout.put(symbol(a))
         else;           stdout.tab(real_fields=1)
         end
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i,a))
         stdout.put(nuclear(i,a))
         stdout.put(total(i,a))
         stdout.flush
      end
      end
      stdout.dash(int_fields=1,real_fields=4)
      total.destroy
      nuclear.destroy
      electronic.destroy
      symbol.destroy
   end

! ====================
! Hirshfeld properties
! ====================

   put_Hirshfeld_atom_info ::: leaky
   ! Put the Hirshfeld charges
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
      e_dipole,n_dipole,t_dipole :: VEC{REAL}(3)
      ed,nd,td,dp :: REAL
      a :: INT

      a = 1

      ! Make and set the atom properties first ...
      .make_Hirshfeld_atom_info(output=TRUE)

      ! Calculate dipole contributions
      e_dipole = ZERO
      n_dipole = ZERO
      do a = 1,.n_atom
         e_dipole = e_dipole + .atom(a).dipole
         n_dipole = n_dipole + .atom(a).charge*.atom(a).position
      end
      t_dipole = e_dipole + n_dipole
      ed = e_dipole.norm
      nd = n_dipole.norm
      td = t_dipole.norm

      ! Write results in au
      stdout.flush
      stdout.text("Hirshfeld atom charges and Hirshfeld atom dipole moments (au):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.tab(int_fields=1)
      stdout.put("q")
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).charge)
         stdout.put(.atom(a).dipole(1))
         stdout.put(.atom(a).dipole(2))
         stdout.put(.atom(a).dipole(3))
         dp = .atom(a).dipole.norm
         stdout.put(dp)
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=5)
      stdout.flush
      stdout.text("Distributed dipole moments:")
      stdout.flush
      stdout.show("Total electronic dipole magnitude/au    =",ed)
      stdout.show("Total nuclear dipole magnitude/au       =",nd)
      stdout.show("Total dipole magnitude/au               =",td)

      ! Write results in Debye
      stdout.flush
      stdout.text("Hirshfeld atom charges and Hirshfeld atom dipole moments (Debye):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.tab(int_fields=1)
      stdout.put("q")
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).charge)
         stdout.put(.atom(a).dipole(1).to_units("debye"))
         stdout.put(.atom(a).dipole(2).to_units("debye"))
         stdout.put(.atom(a).dipole(3).to_units("debye"))
         dp = .atom(a).dipole.norm
         stdout.put(dp.to_units("debye"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=5)
      stdout.flush
      stdout.show("Total electronic dipole magnitude/Debye =",ed.to_units("debye"))
      stdout.show("Total nuclear dipole magnitude/Debye    =",nd.to_units("debye"))
      stdout.show("Total dipole magnitude/Debye            =",td.to_units("debye"))

      ! Write results in au
      stdout.flush
      stdout.text("Hirshfeld atom quadrupole moments (au):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Qxx")
      stdout.put("Qyy")
      stdout.put("Qzz")
      stdout.put("Qxy")
      stdout.put("Qxz")
      stdout.put("Qyz")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.tab(int_fields=1)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).quadrupole(1,1))
         stdout.put(.atom(a).quadrupole(2,2))
         stdout.put(.atom(a).quadrupole(3,3))
         stdout.put(.atom(a).quadrupole(1,2))
         stdout.put(.atom(a).quadrupole(1,3))
         stdout.put(.atom(a).quadrupole(2,3))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)

   end

   make_Hirshfeld_atom_info(output) ::: leaky
   ! Make the Hirshfeld atom properties
      output :: BIN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      pt,D :: MAT{REAL}*
      wt,N0,r1,r2,r3 :: VEC{REAL}*
      q,n_e,c1,c2,c3 :: REAL
      dipole :: VEC{REAL}(3)
      quadrupole :: MAT{REAL}(3,3)
      c :: INT
      archive :: ARCHIVE
      genre :: STR
      out :: BIN

      out = TRUE
      if (present(output)) out = output

      ! If no density in memory get from disk
      if (.density_matrix.destroyed) then

         ! Create density
         WARN("no density matrix, trying to read from file")
         .density_matrix.create(.n_bf)

         ! Get genre
         if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
         else;                       genre = "restricted"
         end

         ! Read density or make it from MO's
         archive.set_defaults
         archive.set(.name,"density_matrix",genre)
         if (archive.exists) then
            archive.read(.density_matrix)
         else
            .molecular_orbitals.destroy
            .molecular_orbitals.create(.n_bf)
            archive.set(.name,"molecular_orbitals",genre)
            archive.read(.molecular_orbitals)
            .make_scf_density_matrix
         end

      end

      ! Make the AO density matrix
      D.create(.n_bf,.n_bf)
      .make_ao_density_matrix(D)

      ! Make the ANO information if missing
      .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Total no of electrons (check)
      n_e = ZERO

      ! Loop over atoms "c"
      do c = 1,.n_atom

         if (.atom(c).atomic_number<1) cycle

         ! Get Hirshfeld density N0 for atom "c"
         .make_Hirshfeld_rho_grid(N0,pt,wt,c,D)

         ! Integration points
         r1 => pt(:,1) 
         r2 => pt(:,2) 
         r3 => pt(:,3)

         ! Atom c position
         c1 = .atom(c).position(1)
         c2 = .atom(c).position(2)
         c3 = .atom(c).position(3)

         ! Make moments
         q               = sum(N0)
         n_e             = n_e + q

         dipole(1)       = sum(N0*(r1-c1))
         dipole(2)       = sum(N0*(r2-c2))
         dipole(3)       = sum(N0*(r3-c3))

         quadrupole(1,1) = sum(N0*(r1-c1)*(r1-c1))
         quadrupole(2,2) = sum(N0*(r2-c2)*(r2-c2))
         quadrupole(3,3) = sum(N0*(r3-c3)*(r3-c3))
         quadrupole(1,2) = sum(N0*(r1-c1)*(r2-c2))
         quadrupole(1,3) = sum(N0*(r1-c1)*(r3-c3))
         quadrupole(2,3) = sum(N0*(r2-c2)*(r3-c3))

         quadrupole(2,1) = quadrupole(1,2)
         quadrupole(3,1) = quadrupole(1,3)
         quadrupole(3,2) = quadrupole(2,3)


         ! charges and moments
         q          = -q + .atom(c).atomic_number
         dipole     = -dipole
         quadrupole = -quadrupole

         ! Assign the charges and moments
         .atom(c).set_charge(q)
         .atom(c).set_dipole(dipole)
         .atom(c).set_quadrupole(quadrupole)

         ! Clean up
         wt.destroy; pt.destroy
         N0.destroy

      end ! -- integration atom c

      ! Clean up
      D.destroy

      ! Check integration accuracy
      if (out) then
      stdout.flush
      stdout.text("Making Hirshfeld atom info ...")
      stdout.flush
      stdout.show("Check: no. of electrons =",n_e)
      end

      ! Put charges to asymmetric unit
      if (.crystal.created) then
         .crystal.destroy_asymmetric_unit
         .crystal.make_fragment_data(.atom,assign_atom=TRUE,warnings=FALSE) 
      end

      .Hirshfeld_atom_info_made = TRUE

   end

   make_Hirshfeld_rho_grid(N0,pt,wt,c,D) ::: leaky
   ! Make the density "N0" on the Becke grid ("pt","wt") for atom
   ! "c" given AO density matrix "D". Density "N0" weighted by the
   ! grid weights and by the Hirshfeld partition weight for atom "c". 
      N0 :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DD :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Get the Becke grid for atom "c"
      .becke_grid.make_grid(pt,wt,gridc0,c)
      n_pt = pt.dim1

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Make stockholder weight function "Wc" for atom "c"
      ! If using interpolatators, then overlapping_atoms 
      ! are not needed ... otherwise nothing is skipped
      .apply_stockholder_atom_weight(wt,c,pt)

      ! Prune the grid with new "wt", get saved bf grid gridc0, 
      ! and new no of points, n_pt -- leaky
      .becke_grid.prune_grid(pt,wt,gridc0)
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt)
      N0 = ZERO
      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Weight the density
      N0 = N0*wt

      ! Clean up
      bf_grid0.destroy; bf_skip.destroy
      skipab.destroy; skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
      gridc0.destroy

   end

   put_uHirshfeld_atom_info 
   ! Make the unrestricted Hirshfeld atom properties
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
      dp :: REAL
      a :: INT

      ! Make and set the atom properties first ...
      .make_uHirshfeld_atom_info(output=TRUE)

      ! Write results in au
      stdout.flush
      stdout.text("Hirshfeld unpaired spin and unpaired spin dipole moments (au):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.tab(int_fields=1)
      stdout.put("spin")
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).spin)
         stdout.put(.atom(a).spin_dipole(1))
         stdout.put(.atom(a).spin_dipole(2))
         stdout.put(.atom(a).spin_dipole(3))
         dp = .atom(a).spin_dipole.norm
         stdout.put(dp)
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=5)
      stdout.flush

      ! Write results in Debye
      stdout.flush
      stdout.text("Hirshfeld unpaired charges and dipole moments (Debye):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      stdout.tab(int_fields=1)
      stdout.put("spin")        !<=== ?      
      stdout.put("mu_x")
      stdout.put("mu_y")
      stdout.put("mu_z")
      stdout.put("|mu|")
      stdout.flush
      stdout.put("Atom",int_width=TRUE)
      stdout.tab(real_fields=1)
      stdout.put("/au")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=5)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(.atom(a).spin)
         stdout.put(.atom(a).spin_dipole(1).to_units("debye"))
         stdout.put(.atom(a).spin_dipole(2).to_units("debye"))
         stdout.put(.atom(a).spin_dipole(3).to_units("debye"))
         dp = .atom(a).spin_dipole.norm
         stdout.put(dp.to_units("debye"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=5)

   end

   make_uHirshfeld_atom_info(output) ::: leaky
   ! Make the H structure factors efficiently
      output :: BIN, optional

   ENSURE(.density_matrix.created,"no density matrix")

      wt, xa,ya,za,a2 :: VEC{REAL}*
      r1,r2,r3, ga,gb :: VEC{REAL}*
      ra,dipole :: VEC{REAL}(3)
      overlapping_atom :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      D,pt,grida,gridb,bf_save :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      cutoff, n_e,q,c1,c2,c3, Dab, fac,val :: REAL
      n_pt,n_keep, c,ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb, a,b,i,j,n :: INT
      out :: BIN

      out = TRUE
      if (present(output)) out = output

      ! Make the AO density matrix
      D.create(.n_bf,.n_bf)
      .make_ao_sz_density_matrix(D)

      ! Set up grids, atomic densities, overlapping_atoms -- leaky
      .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff
!     cutoff = ZERO

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom
    ! stdout.show("maximum n_pt =",n_pt)

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Total no of electrons
      n_e = ZERO

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Get the Becke grid for atom "c"
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Overlapping atoms
         overlapping_atom => .overlapping_atoms_for_atom(c).element

         ! Make stockholder weight function "Wc" for atom "c"
         .apply_stockholder_atom_weight(wt,c,pt)

         ! Prune the grid with new "wt", get saved bf grid bf_save, 
         ! and new no of points, n_pt -- leaky
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Integration points
         r1 => pt(:,1) 
         r2 => pt(:,2) 
         r3 => pt(:,3)

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Atom c position
         c1 = .atom(c).position(1)
         c2 = .atom(c).position(2)
         c3 = .atom(c).position(3)

         ! Charges and dipoles
         q  = ZERO
         dipole = ZERO

         ! Loop c-overlapping atoms "oa"
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "oa" 
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

            ! Loop shells on atom a
            do sa = fsa,lsa

               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               ba = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .precomputed_basis_shellpair(ba,1).a
               sha.position = ra

               ! Make shell "sa" skipa list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

!              if (n_keep<n_pt) then
!              stdout.show("shell sa =",sa)
!              stdout.show("n_keep   =",n_keep)
!              stdout.show("n_pt     =",n_pt)   
!            ! stdout.text("skipa:")
!            ! stdout.put(skipa)
!              end

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element => skipa

               ! Make/copy the "sa" basis function grida
               ! This must be copied since skipa could be TRUE
               grida.create(n_keep,na)
!              if (FALSE) then
               if (oa==c) then
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        grida(i,a) = bf_save(n,a+fa-fba)
                     end
                  end
               else
                  sha.make_skip_grid(grida,n_keep,na,xa,ya,za,a2,skipa,n_pt)
               end
               bf_grid(sa).element => grida

             ! stdout.text("grida:")
             ! stdout.put(grida)

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob) 
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     if (bf_skip(sb).element.destroyed) cycle

                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)

                     ! Set the "sb" basis function grid
                     skipb => bf_skip(sb).element 
                     gridb => bf_grid(sb).element 

                   ! stdout.text("skipb:")
                   ! stdout.put(skipb)
                   ! stdout.text("gridb:")
                   ! stdout.put(gridb)

                     ! How many points in common?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Factor
                     fac = TWO
                     if (sa==sb) fac = ONE

                     ! Make the ab bf product
                     do a = fa,la
                        ga => grida(:,a-fa+1)
                        do b = fb,lb
                           gb  => gridb(:,b-fb+1)
                           Dab = fac*D(a,b)
                           i = 0; j = 0
                           do n = 1,n_pt
                              if (NOT skipa(n)) i = i + 1
                              if (NOT skipb(n)) j = j + 1
                              if (skipab(n)) cycle
                              val = ga(i)*gb(j)*wt(n)*Dab
                              n_e = n_e + val
                              q   = q   + val
                              dipole(1) = dipole(1) + val * (r1(n)-c1)
                              dipole(2) = dipole(2) + val * (r2(n)-c2)
                              dipole(3) = dipole(3) + val * (r3(n)-c3)
                           end
                        end
                     end

                  end ! -- loops sa,sb
               end
            end       ! -- lops ca,cb
         end

         ! Assign the charges and d[poles
         .atom(c).set_spin(q)
         .atom(c).set_spin_dipole(dipole)

         ! Clean up
         bf_save.destroy
         bf_grid.destroy
         bf_skip.destroy
         wt.destroy
         pt.destroy

      end ! -- integration atom c

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy
      za.destroy; ya.destroy; xa.destroy
      D.destroy

      ! Put back the AO density matrix
      .make_ao_density_matrix

      ! Check integration accuracy
      if (out) then
      stdout.flush
      stdout.text("Making unpaired Hirshfeld atom info ...")
      stdout.flush
      stdout.show("Check: no. of unpaired electrons =",n_e)
      end

   end


   make_H_polarisabilities ::: leaky
   ! Make Hirshfeld polarisabilities

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      pt,E :: MAT{REAL}*
      wt,r1,r2,r3 :: VEC{REAL}*
      c1,c2,c3 :: REAL
      n_pt,c :: INT

      ! Make Becke grid if missing (leaky)
      .set_up_becke_grid

      ! Loop over atoms "c"
      do c = 1,.n_atom

         if (.atom(c).atomic_number<1) cycle

         ! Get the Becke grid for atom "c"
         .becke_grid.make_grid(pt,wt,c)
         n_pt = pt.dim1
   
         ! Apply stockholder weight for atom "c" to "wt".
         ! NOTE: interpolatators may be used if set by user
         .apply_stockholder_atom_weight(wt,c,pt)
   
         ! Prune the grid with new "wt", get saved bf grid gridc0, 
         ! and new no of points, n_pt -- leaky
         .becke_grid.prune_grid(pt,wt)
         n_pt = pt.dim1

         ! Make the field-derivative density grid
         E.create(n_pt,3)
         .make_e_polarization_vgrid(E,pt) 

         ! Multiply by the weights
         E(:,1) = E(:,1)*wt
         E(:,2) = E(:,2)*wt
         E(:,3) = E(:,3)*wt

         ! Integration points
         r1 => pt(:,1) 
         r2 => pt(:,2) 
         r3 => pt(:,3)

         ! Atom c position
         c1 = .atom(c).position(1)
         c2 = .atom(c).position(2)
         c3 = .atom(c).position(3)

         ! Make moments
         .atom(c).charge_polarisability(1)   = -sum(E(:,1))
         .atom(c).charge_polarisability(2)   = -sum(E(:,2))
         .atom(c).charge_polarisability(3)   = -sum(E(:,3))
         .atom(c).dipole_polarisability(1,1) = -sum(E(:,1)*(r1-c1))
         .atom(c).dipole_polarisability(1,2) = -sum(E(:,2)*(r1-c1))
         .atom(c).dipole_polarisability(1,3) = -sum(E(:,3)*(r1-c1))
         .atom(c).dipole_polarisability(2,1) = -sum(E(:,1)*(r2-c2))
         .atom(c).dipole_polarisability(2,2) = -sum(E(:,2)*(r2-c2))
         .atom(c).dipole_polarisability(2,3) = -sum(E(:,3)*(r2-c2))
         .atom(c).dipole_polarisability(3,1) = -sum(E(:,1)*(r3-c3))
         .atom(c).dipole_polarisability(3,2) = -sum(E(:,2)*(r3-c3))
         .atom(c).dipole_polarisability(3,3) = -sum(E(:,3)*(r3-c3))

         ! Clean up
         E.destroy
         wt.destroy; pt.destroy

      end ! -- integration atom c

      ! Put charges to asymmetric unit
      if (.crystal.created) then
         .crystal.destroy_asymmetric_unit
         .crystal.make_fragment_data(.atom,assign_atom=TRUE,warnings=FALSE) 
      end

   end

   put_H_polarisabilities ::: leaky
   ! Put the Hirshfeld polarizabilities
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")

      ID :: VEC{STR}*
      dim :: INT
      qx,qy,qz    :: VEC{REAL}*
      a1x,a1y,a1z :: VEC{REAL}*
      a2x,a2y,a2z :: VEC{REAL}*
      a3x,a3y,a3z :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*

      ! Make and set the atom properties first ...
      .make_H_polarisabilities

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==========================")
      stdout.text("Hirshfeld polarizabilities")
      stdout.text("==========================")
      stdout.flush
      stdout.text(". The results are presented in au")
      stdout.text(". The indices 1..3 label the moment wrt the atom center")
      stdout.text(". The indices x..z label the electric field component")

      ! Monpoles
      stdout.flush
      stdout.text("Monopole polarisabiities:")
      stdout.flush

      ! Get data
      dim = .atom.dim
      ID.create(dim);  ID  = .atom.tag
      qx.create(dim);  qx  = .atom.charge_polarisability(1)
      qy.create(dim);  qy  = .atom.charge_polarisability(2)
      qz.create(dim);  qz  = .atom.charge_polarisability(3)

      ! Make table
      table.create(4)
      table(1).set_heading("ID");         table(1).set_values(ID)
      table(2).set_heading("q(x)");       table(2).set_values(qx)
      table(3).set_heading("q(y)");       table(3).set_values(qy)
      table(4).set_heading("q(z)");       table(4).set_values(qz)
      table.put

      ! Clean
      table.destroy
      qz.destroy
      qy.destroy
      qx.destroy

      ! Dipoles
      stdout.flush
      stdout.text("Dipole polarisabiities:")
      stdout.flush

      ! Get data
      a1x.create(dim); a1x = .atom.dipole_polarisability(1,1)
      a1y.create(dim); a1y = .atom.dipole_polarisability(1,2)
      a1z.create(dim); a1z = .atom.dipole_polarisability(1,3)
      a2x.create(dim); a2x = .atom.dipole_polarisability(2,1)
      a2y.create(dim); a2y = .atom.dipole_polarisability(2,2)
      a2z.create(dim); a2z = .atom.dipole_polarisability(2,3)
      a3x.create(dim); a3x = .atom.dipole_polarisability(3,1)
      a3y.create(dim); a3y = .atom.dipole_polarisability(3,2)
      a3z.create(dim); a3z = .atom.dipole_polarisability(3,3)

      ! Make table
      table.create(10)
      table( 1).set_heading("ID");         table( 1).set_values(ID)
      table( 2).set_heading("alpha(1x)");  table( 2).set_values(a1x)
      table( 3).set_heading("alpha(1y)");  table( 3).set_values(a1y)
      table( 4).set_heading("alpha(1z)");  table( 4).set_values(a1z)
      table( 5).set_heading("alpha(2x)");  table( 5).set_values(a2x)
      table( 6).set_heading("alpha(2y)");  table( 6).set_values(a2y)
      table( 7).set_heading("alpha(2z)");  table( 7).set_values(a2z)
      table( 8).set_heading("alpha(3x)");  table( 8).set_values(a3x)
      table( 9).set_heading("alpha(3y)");  table( 9).set_values(a3y)
      table(10).set_heading("alpha(3z)");  table(10).set_values(a3z)
      table.put

      ! Clean
      table.destroy
      a3z.destroy; a3y.destroy; a3x.destroy
      a2z.destroy; a2y.destroy; a2x.destroy
      a1z.destroy; a1y.destroy; a1x.destroy
      ID.destroy

   end


   set_up_Hirshfeld_info(skip_NOs) ::: leaky
   ! Set up the atomic natural orbital information, for Hirshfeld
   ! weight generation, and the becke grid for numerial integration.
   ! Assign the NO's to the MO's ready for density integration,
   ! provided that skip_NOs is not present and not TRUE.
      skip_NOs :: BIN, optional

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")

      ! Set up integration grid if not there
      .set_up_becke_grid

      if (.n_atom>1) then

         ! ANOs for stockholder weights (leaky)
         .make_ANO_data

         ! ANO interpolators (leaky)
         .make_ANO_interpolators

      end

      ! Skip NO's?
      if (present(skip_NOs)) then
      if (skip_NOs) return
      end

      ! Can't assign NO's if there are no MO's!
      if (.molecular_orbitals.destroyed) return

      ! Assign NO's to MO's for density evaluation
      .assign_NOs_to_MOs

   end

   set_up_becke_grid ::: leaky
   ! Set up the Becke grids and overlapping atoms

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")

      ! Set up integration grid if not there
      if (.becke_grid.destroyed) then
         .becke_grid.create               ! leaky
         .becke_grid.set_grid_data(.atom) ! leaky
      else
         ENSURE(.becke_grid.finalized,"no finalized becke_grid")
      end

      ! ALWAYS make the overlapping atom lists
      .make_overlapping_atoms

   end


!  ===============
!  Atom group info
!  ===============

   make_atom_group_info ::: leaky
   ! Make the .atom_group information
   ENSURE(.atom.created,"atom groups must be defined after atoms=")

      mol :: MOLECULE*
      g :: INT

      do g = 1,.atom_group.dim 
         mol.create
         .make_molecule_from_atom_group(g,mol)
         .atom_group(g).mol => mol
      end

   end

   update_atom_group_info ::: leaky
   ! Make the .atom_group information
   ENSURE(.atom.created,"atom groups must be defined after atoms=")

      mol :: MOLECULE*
      g :: INT

      do g = 1,.atom_group.dim 

         mol => .atom_group(g).mol
         ENSURE(mol.created,"atom_group molecule "//trim(g.to_str)//" does not exist")

         ! Don't remake ANO data if there
         mol.set_ANO_data_from_sublist_of(self,.atom_group(g).atom_index)

         ! Assign the crystal
         ! WARNING: dont destroy ...
         if (.crystal.created) mol.crystal => .crystal

         ! Set guess-type SCF defaults
         mol.set_scf_guess_defaults_from(.scfdata)

      end

   end

   set_ANO_data_from_sublist_of(mol,list)
   ! Set ANO data and atom shell info from molecule "mol" from the
   ! sublist "list". Make sure none of these are destroyed!
   ! NOTE: No point to assign non-unique data since it is unique so
   ! therefore can't be reusued/assigned.
      mol :: MOLECULE, IN
      list :: VEC{INT}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.n_atom_kind>0,"atoms not finalized")
   ENSURE(mol.atom.created,"mol has no atoms")
   ENSURE(mol.n_atom_kind>0,"mol atoms not finalized")
   ENSURE(list.dim==.atom.dim,"inconsistent list length")

      a,b :: INT
      made_ANO,made_int,made_shl :: BIN

      ! Assign ANO orbitals
      made_ANO = mol.atom(1).ANO_data_made
      .atom.set_ANO_data_made(made_ANO)
      if (made_ANO) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).density_matrix     => mol.atom(b).density_matrix
            .atom(a).natural_orbitals   => mol.atom(b).natural_orbitals
            .atom(a).occupation_numbers => mol.atom(b).occupation_numbers
            .atom(a).atomic_orbitals    => mol.atom(b).atomic_orbitals
            .atom(a).set_energy(mol.atom(b).energy)
         end
      end

      ! Assign ANO interpolators
      made_ANO = mol.atom(1).ANO_interpolators_made
      made_int = mol.atom(1).interpolators_made
      .atom.set_ANO_interpolators_made(made_ANO)
      .atom.set_interpolators_made(made_int)
      if (made_ANO OR made_int) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).interpolator => mol.atom(b).interpolator
         end
      end

      ! Assign atom shell info
      made_shl = mol.atom(1).shell_info_made 
      .atom.set_shell_info_made(made_shl)
      if (made_shl) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).first_basis_fn_for_shell    => mol.atom(b).first_basis_fn_for_shell
            .atom(a).last_basis_fn_for_shell     => mol.atom(b).last_basis_fn_for_shell
            .atom(a).precomputed_basis_shellpair => mol.atom(b).precomputed_basis_shellpair
         end
      end

      ! Since all are ptr assigned, no atom is unique
      ! and all ptrs must be nullified
      .atom.set_is_unique_kind(FALSE)

   end

!  =====================================
!  Make molecule from atom or atom group
!  =====================================

   make_molecule_from_atom(n,mol) ::: leaky
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
   ! The new molecule is ready for an SCF calculation.
   ! DANGER: see warnings below
      n :: INT, IN
      mol :: MOLECULE

   ENSURE(n<=.n_atom,"atom number n too big")

      i :: INT

      ! Clear the pointer part
      mol.nullify_ptr_part

      ! Create the single atom and copy its pointers
      ! WARNING: dont destroy ptr parts of mol.atom 
      mol.atom.create(1)
      mol.atom(1) = .atom(n) ! <<< pointer copy here
      mol.atom(1).set_position([ZERO,ZERO,ZERO])

      ! Set default molecule e.g. the name, atom_info
      ! and default multiplicity ...
      mol.set_defaults

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol 
      mol.set_basis_data_from(self)

      ! Don't remake ANO data if there
      i = 0
      mol.set_ANO_data_from_sublist_of(self,[(i,i=n,n)])

      ! Set guess-type SCF defaults
      mol.set_scf_guess_defaults_from(.scfdata)

   end

   make_molecule_from_atom_group(n,mol) ::: leaky
   ! Make a fully fledged molecule "mol" from group "n" of atoms
   ! specified in .atom_group(n).element(:), ready fro an SCF calculation.
      n :: INT
      mol :: MOLECULE

   ENSURE(.atom_group.created,"no atom_group info")
   ENSURE(n<=.atom_group.dim,"group number n too big")

      ! Clear the pointer part
      mol.nullify_ptr_part

      ! Create the single atom and copy its pointers
      ! WARNING: dont destroy ptr parts of mol.atom 
      mol.atom.create(.atom_group(n).n_atoms)
      mol.atom = .atom(.atom_group(n).atom_index) 

      ! Set default molecule e.g. the name, atom_info
      ! and default multiplicity ...
      mol.set_defaults

      ! Reset .name after .set_defaults
      mol.name  =  .atom_group(n).name 
      mol.charge = .atom_group(n).charge
      mol.spin_multiplicity = mol.default_spin_multiplicity
      mol.set_atom_info

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol !
      mol.set_basis_data_from(self)

      ! Don't remake ANO data if there
      mol.set_ANO_data_from_sublist_of(self,.atom_group(n).atom_index)

      ! Assign the crystal
      ! WARNING: dont destroy ...
      if (.crystal.created) mol.crystal => .crystal

      ! Set guess-type SCF defaults
      mol.set_scf_guess_defaults_from(.scfdata)

   end

!   make_scfdata_cluster_molecule(n,mol) ::: leaky
!   ! Make a fully fledged molecule "mol" from the cluster stored 
!   ! in the .scfdata.cluster "n".
!      n :: INT
!      mol :: MOLECULE
!
!   ENSURE(.scfdata.created,"no scfdata")
!   ENSURE(.scfdata.cluster.created,"no scfdata cluster")
!   ENSURE(.atom_group.created,"no atom_group info")
!   ENSURE(n<=.scfdata.cluster.n_molecules," n too big")
!
!      ! Clear the pointer part
!      mol.nullify_ptr_part
!
!      ! Create the single atom and copy its pointers
!      ! WARNING: dont destroy ptr parts of mol.atom 
!      mol.atom.create(.atom_group(n).n_atoms)
!      mol.atom = .atom(.atom_group(n).atom_index) 
!
!      ! Reset the .atom list to the cluster fragment
!      .cluster.create_fragment_atom_list(mol.atom) 
!      mol.set_atom_info
!      mol.resolve_basis_info
!      mol.set_basis_info
!
!      ! The name for the new cluster
!      mol.name = trim(.name) // "_" // trim(n.to_str)
!
!      ! If a CIF exists, copy that
!      if (.saved.cif.created) .cif.create_copy(.saved.cif)
!
!      ! We want the saved crystal 
!      ! It should be consistent with the cluster.
!      mol.crystal.create_copy(.crystal) 
!
!      ! Set up basis sets
!      if (.atom.created) .atom.nullify_bases
!      if (mol.basis.created)               mol.basis.create_copy(.basis)
!      if (.saved.slaterbasis.created)   mol.slaterbasis.create_copy(.slaterbasis)
!      if (.saved.coppensbasis.created)  mol.coppensbasis.create_copy(.coppensbasis)
!      mol.basis_name        = .saved.basis_name
!      mol.slaterbasis_name  = .saved.slaterbasis_name
!      mol.coppensbasis_name = .saved.coppensbasis_name
!      .resolve_basis_info
!      .set_basis_info
!
!   end

   set_basis_data_from(mol) ::: leaky
   ! Set the basis data from molecule "mol" 
   ! Make sure none of these bases are destroyed.
      mol :: MOLECULE, IN

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol 
      .use_spherical_basis = mol.use_spherical_basis
      .basis              => mol.basis                   
      .slaterbasis        => mol.slaterbasis
      .coppensbasis       => mol.coppensbasis

      .set_basis_info ! leaky

   end

   set_scf_guess_defaults_from(scfdata) ::: leaky
   ! Set scf  data options for a guess-type SCF defaults
      scfdata :: SCFDATA*

      ! Set the SCF defaults: leaky
      if (scfdata.destroyed) then
         .set_scf_defaults
         .scfdata.set_output(FALSE) ! Default, except output=> FALSE
      else if (scfdata.use_default_guess_options) then
         .set_scf_defaults
         .scfdata.set_output(FALSE) ! Default, except output=> FALSE
      else
         .set_scf_defaults(scfdata) ! leaky
      end

      ! Reset some defaults from scfdata, if it is there
      if (scfdata.created) then
         .scfdata.set_output(scfdata.guess_output) 
         .scfdata.set_convergence(scfdata.convergence)
         .scfdata.diis.set_convergence_tolerance(scfdata.diis.convergence_tolerance)
         .scfdata.set_relativity_kind(scfdata.relativity_kind)
      end

      ! Nuclear energy
      .scfdata.nuclear_repulsion_energy = .nuclear_repulsion_energy

      ! Finalise
      .scfdata.finalize

   end

   set_scf_defaults(scfdata) ::: leaky
   ! Set up scf defaults for molecule
      scfdata :: SCFDATA*, optional

      if (.scfdata.destroyed) then; .scfdata.create
      else;                         .scfdata.set_defaults
      end

      if (.spin_multiplicity==1) .scfdata.set_scf_kind("rhf")
      if (.spin_multiplicity/=1) .scfdata.set_scf_kind("uhf")

      if (present(scfdata)) then
         .scfdata = scfdata
         nullify(.scfdata.cluster)
         nullify(.scfdata.cluster_charges)
         nullify(.scfdata.cluster_charge_positions)
         if (.scfdata.scf_kind/=" ") then
         if (.scfdata.is_DFT_calculation) then
            if (.spin_multiplicity==1) .scfdata.set_scf_kind("rks")
            if (.spin_multiplicity/=1) .scfdata.set_scf_kind("uks")
         end
         end
      end

      .scfdata.nuclear_repulsion_energy = .nuclear_repulsion_energy

      .initialise_DFT_grids

   end

!  ============
!  SCF routines
!  ============

   scf ::: recursive, leaky
   ! Do an SCF calculation. The following :
   !   .molecular_orbitals, .orbital_energies, .density_matrix
   ! are produced as results.
   ENSURE(.scfdata.created,"no scfdata provided")

      select case (.scfdata.scf_kind)

      !  case ("embedded_rhf")
      !     .embedded_scf

      !  case ("crystal_rhf")
      !     .crystal_scf

         case ("xray_rhf","xray_rks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
            .constrained_scf

         case default
            .usual_scf
      end

   end

!  =========
!  Usual SCF
!  =========

   usual_scf ::: recursive, leaky
   ! Do an SCF calculation. The following :
   !   .molecular_orbitals, .orbital_energies, .density_matrix
   ! are produced as results.

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,   "no atom list")
   ENSURE(.scfdata.created,"no scfdata")

      .initialise_scf

      .put_scf_banner_and_options
      .put_scf_table_header

      do

         .extrapolate_fock_matrix
         .update_molecular_orbitals
         .make_scf_density_matrix
         .make_fock_matrix
         .update_scfdata
         .update_scfdata_error

         .put_scf_table_body

         if (.scfdata.scf_done) exit

      end

      .put_scf_results
      .archive_scf_results
      .cleanup_scf

   end

   initialise_scf ::: leaky, recursive
   ! Initialise any SCF procedure
   ENSURE(.scfdata.created,"no scfdata")

      ! Overlap and core matrix
      .get_overlap_matrix
      .core_matrix.destroy; .get_core_matrix

      ! Integration grids
      .initialise_DFT_grids

      ! Get initial guess and Fock
      .get_initial_guess
      .make_fock_matrix

      ! === Make structure factors ===
      if (.scfdata.fitting) .make_constraint_data

      ! Reset all SCF data (except DFT parts)
      .scfdata.reset                     
      .scfdata.set_crystal(.crystal)                     
      if (.scfdata.fitting) .scfdata.set_penalty
      .update_scfdata_energies

      ! === Add constraint to F ===
      if (.scfdata.fitting) .add_constraint_to_fock_matrix

      ! Initialise DIIS error
      .update_scfdata_error

      ! Initialise Schwarz inequality test integrals
      .initialise_max_I

      ! Initialise SCF table (leaky)
      .scfdata.set_table

   end

   initialise_DFT_grids ::: leaky
   ! Initialise DFT grids, if not already done so.
   ENSURE(.scfdata.created,"no scfdata")

      if (NOT .scfdata.is_DFT_calculation) return

      if (.becke_grid.destroyed) then
         .becke_grid.create
         .becke_grid.set_grid_data(.atom)
      end

      .make_overlapping_atoms

   end

   update_scfdata_energies ::: private
   ! Update SCF energies
   ENSURE(.scfdata.created,"no scfdata")

      ! Energies
      .scfdata.nuclear_repulsion_energy  = .nuclear_repulsion_energy
      .scfdata.nuclear_attraction_energy = .nuclear_attraction_energy
      if (.scfdata.using_cluster_charges) &
      .scfdata.charge_attraction_energy  = .charge_attraction_energy
      .scfdata.kinetic_energy            = .kinetic_energy

      ! Total SCF energy [including V(nuc) repulsion]
      ! and penalty
      .scfdata.update_energy(.scf_energy)

      ! Initialise electron repulsion by subtraction
      .scfdata.electron_repulsion_energy = .scfdata.energy &
                                         - .scfdata.nuclear_repulsion_energy &
                                         - .scfdata.nuclear_attraction_energy &
                                         - .scfdata.charge_attraction_energy &
                                         - .scfdata.kinetic_energy 

   end

   update_scfdata
   ! Update the scf iteration count, scf energies used to 
   ! test for convergence in the SCF procedure.
   ENSURE(.scfdata.created,"no scfdata")

      ! New iteration
      .scfdata.update_iteration

      ! Update energies and penalty
      .update_scfdata_energies

   end

   update_scfdata_error
   ! Update the scfdata gradient of the SCF energy with respect to
   ! orbital rotations, otherwise known as the "diis error". This is
   ! used to check for SCF convergence.

      diis_error :: REAL

      .make_diis_error_length(diis_error)

   end

   put_scf_banner_and_options
   ! Put out the SCF banner and options
   ENSURE(.scfdata.created,            "no scfdata")
   ENSURE(.scfdata.iteration==0,       "iteration is not 0!")
   ENSURE(.scfdata.lambda_iteration==0,"lambda_iteration is not 0!")

      ! SCF banner and options
      .scfdata.put_banner
      .scfdata.put_options

      ! Diffraction data-treatment options
      if (.scfdata.fitting) then

         if (.crystal.xray_data.created AND .scfdata.scf_kind.includes("xray")) then
            .crystal.assign_xray
            stdout.flush
            stdout.text("X-ray data-treatment options:")
            .crystal.put_correction_data
         end

         if (.crystal.pnd_data.created AND .scfdata.scf_kind.includes("pnd")) then
            .crystal.assign_pnd
            stdout.flush
            stdout.text("PND data-treatment options:")
            .crystal.put_correction_data
         end

      end

      ! Initial guess energies
      .scfdata.put_initial_guess_energies

   end

   put_scf_table_header
   ! Put out the SCF iteration table header
   ENSURE(.scfdata.created,"no scfdata")

      ! Table head & 0-th iteration results
      .scfdata.put_table_head
      .scfdata.put_table_body_and_footer

   end

   put_scf_table_body(flush)
   ! Put out the SCF iteration results, body and footer
      flush :: BIN, optional

   ENSURE(.scfdata.created,"no scfdata")

      .scfdata.put_table_body_and_footer(flush)

   end

   put_scf_results
   ! Put out the SCF results
   ENSURE(.scfdata.created,"no scfdata")
      .scfdata.put_results
   end

   initialise_max_I ::: leaky
   ! Initialise Schwarz inequality test integrals
      .max_I.destroy
      .max_I.create(.n_shell_pairs)
      .make_max_abab_integrals(.max_I)
   end

!  ===============
!  Constrained SCF
!  ===============

   constrained_scf ::: leaky
   ! Do a constrained SCF calculation.
   ! The following objects are produced as results:
   !   .molecular_orbitals, .orbital_energies, .density_matrix

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      .initialise_scf

      .put_scf_banner_and_options
      .put_scf_table_header

      do

         do

            .extrapolate_fock_matrix
            .update_molecular_orbitals
            .make_scf_density_matrix
            .make_fock_matrix
            .make_constraint_data
            .update_scfdata       
            .add_constraint_to_fock_matrix
            .update_scfdata_error

            .put_scf_table_body(flush=TRUE)

            if (.scfdata.scf_done) exit

         end

         .archive_scf_results

         .scfdata.update_lambda
         if (.scfdata.exceeded_lambda_max) exit

         .reset_for_next_lambda
         .update_scfdata_error

      end

      .put_scf_results

      .cleanup_scf
      .crystal.put_reflection_data

   end

   make_constraint_data
   ! Make the predicted constraint data, e.g. X-ray structure factors or
   ! PND structure factors, or whatever data are to be used in the constrained
   ! wavefunction procedure
   ENSURE(.scfdata.created,"no scfdata")

      scf_kind :: STR

      scf_kind = .scfdata.scf_kind

      select case (scf_kind)

         case ("xray_rhf","xray_rks","xray_uhf","xray_uks"); 
            .make_x_structure_factors
            if (.crystal.xray_r_free_data.created) .make_xf_structure_factors

         case ("pnd_uhf","pnd_uks");                         
            .make_n_structure_factors
            if (.crystal.pnd_r_free_data.created)  .make_nf_structure_factors

         case ("xray_pnd_uhf","xray_pnd_uks");               
            .make_x_structure_factors
            .make_n_structure_factors
            if (.crystal.xray_r_free_data.created) .make_xf_structure_factors
            if (.crystal.pnd_r_free_data.created)  .make_nf_structure_factors

         case default
            DIE("unknown wavefunction fitting kind, "//scf_kind.trim)

      end

   end

   add_constraint_to_fock_matrix
   ! Make the constraint matrix for wavefunction fitting and add it to the fock
   ! matrix to obtain the effective fock matrix.
      ENSURE(.scfdata.created,"no scf data")
      ENSURE(.fock_matrix.created,"no fock matrix")
      ENSURE(.fock_matrix.any_created,"no fock matrix")

      C :: OPMATRIX*

      C.create(.n_bf,.scfdata.spinorbital_kind)

      if (.scfdata.lambda.is_zero) then

         C.set_to_zero

      else

         .make_constraint(C)
         .fock_matrix.plus_scaled(C,.scfdata.lambda)

      end

      ! Clean up
      C.destroy

   end

   make_constraint(C)
   !Make constraint matrix for restricted or unrestricted SCF cases
      C :: OPMATRIX, INOUT

   ENSURE(any(.scfdata.spinorbital_kind==["restricted  ","unrestricted"]),"can only do restricted or unrestricted cases")
   ENSURE(.crystal.created,  "no crystal info")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      tmp :: OPMATRIX*

      select case (.scfdata.scf_kind)

         case ("xray_rhf","xray_rks")
            .crystal.assign_xray
            if (.crystal.thermal_smearing_model=="hirshfeld") then
               .make_H_r_constraint(C.restricted)
            else
               .make_r_constraint(C.restricted)
            end

         case ("xray_uhf","xray_uks")
            .crystal.assign_xray
            if (.crystal.thermal_smearing_model=="hirshfeld") then
               .make_H_r_constraint(C.alpha)
            else
               .make_r_constraint(C.alpha)
            end
            C.beta = C.alpha

         case ("pnd_uhf","pnd_uks")
            .crystal.assign_pnd
            if (.crystal.thermal_smearing_model=="hirshfeld") then
               .make_H_r_constraint(C.alpha) ! This is NOT correct 22/3/10, dylan
            else
               .make_pnd_constraint(C.alpha)
            end
            C.beta = -C.alpha

         case ("xray_pnd_uhf","xray_pnd_uks")
            .crystal.assign_xray
            tmp.create(.n_bf,.scfdata.spinorbital_kind)
            .make_r_constraint(tmp.alpha)
            tmp.beta = tmp.alpha
            C.to_scaled(tmp,ONE/.crystal.F_chi2)
            .crystal.assign_pnd
            .make_pnd_constraint(tmp.alpha)
            tmp.beta = -tmp.alpha
            C.plus_scaled(tmp,ONE/.crystal.F_chi2)
            tmp.destroy

      end 

   end  

   make_r_constraint(C)
   ! Make the constraint matrix "C" for restricted wavefunction fitting.
     C :: MAT{REAL}, INOUT
     k_pts :: MAT{REAL}*
     ft_ab_eq,ft_ab :: MAT3{CPX}*
     Fc :: VEC{CPX}*
     fac_times_alpha,Fm,Fexp,Fsig,alpha,Fcr,Fci :: VEC{REAL}*
     fac,cutoff :: REAL
     q,fa,la,fb,lb,na,nb,i,j,n_refl,n_unique,atom_a,atom_b :: INT
     sh :: SHELL2

     n_unique = .crystal.n_unique_SF_k_pts
     n_refl = .crystal.n_refl
     fac = TWO/max(n_refl - .crystal.n_param,1)

     fac_times_alpha.create(n_refl)

     Fcr.create(n_refl)
     Fci.create(n_refl)

     Fc.create(n_refl)
     Fc = .crystal.F_calc

     alpha.create(n_refl)
     alpha = .crystal.extinction_correction

     Fexp.create(n_refl);  Fexp = .crystal.F_exp
     Fsig.create(n_refl);  Fsig = .crystal.F_sigma
     Fm.create(n_refl);    Fm = max(abs(Fc),TOL(10))

     fac_times_alpha = fac * alpha * (alpha * Fm - Fexp) / (Fsig * Fsig * Fm)

     Fm.destroy
     Fsig.destroy
     Fexp.destroy
     alpha.destroy

     Fcr = fac_times_alpha * RE(Fc)
     Fci = fac_times_alpha * IM(Fc)

     fac_times_alpha.destroy
     Fc.destroy

     k_pts.create(n_unique,3)
     .crystal.make_unique_SF_k_pts(k_pts)

     cutoff = TOL(10) / .n_shell_pairs

     C = ZERO

     parallel do q = 1, .n_shell_pairs

       .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

       if (sh.skip_ft(cutoff)) then
         sh.destroy_ptr_part
         cycle
       end

       ft_ab.create([1,n_refl],[fa,la],[fb,lb])
       ft_ab_eq.create(n_unique,na,nb)
       .make_ft_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
       .crystal.sum_unique_sf_ints(ft_ab,ft_ab_eq)
       ft_ab_eq.destroy

       do i = fa,la
       do j = fb,min(lb,i)
          C(i,j) = sum( RE(ft_ab(:,i,j))*Fcr + IM(ft_ab(:,i,j))*Fci )
       end
       end

       ft_ab.destroy
       sh.destroy_ptr_part

     end

     ! Symmetrise
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(C)
      else
        C.symmetric_reflect
     end

     ! Get rid of OO block if requested
     if (.scfdata.zero_oo_constraint_block) then
        C.change_basis_using(.molecular_orbitals.restricted)
        C(1:.n_a,1:.n_a) = ZERO
        C.back_transform_using(.molecular_orbitals.restricted)
     end

     ! Shift linear dependence
!    if (.scfdata.created) .shift_dependence_from_r(C)

     ! Clean up
     k_pts.destroy
     Fci.destroy
     Fcr.destroy

   end

   make_H_r_constraint(constraint)
   ! Make the "constraint" matrix for restricted X-ray wavefunction
   ! fitting ...using Hirshfeld atoms to do thermal smearing
      constraint :: MAT{REAL}, target

   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
   ENSURE(.scfdata.created,"no scf data")
   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.basis_info_made,"no basis info")

      Fc :: VEC{CPX}*
      Fm,Fexp,Fsig,alpha,Fcr,Fci, X, wt, xa,ya,za,a2 :: VEC{REAL}*
      fac_times_alpha,k1,k2,k3, u1,u2,u3, tf, ga,gb :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab,skipa,skipb :: VEC{BIN}*
      k_pts,kU,pt,grida,gridb,bf_save, CC :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid :: VEC{MAT_{REAL}}*
      fac,cutoff,rf, val :: REAL
      n_refl,n_k,n_pt,n_keep, c,ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, as, a,b,i,j,n,p :: INT

      ! Number of reflections
      n_refl   = .crystal.n_refl

      ! Multipliers for the ft integrals
      Fcr.create(n_refl)
      Fci.create(n_refl)

      ! The calculated (complex) structure factors
      Fc.create(n_refl)
      Fc = .crystal.F_calc

      ! Make the multipliers ... and clean up
      fac = TWO/max(n_refl - .crystal.n_param,1)
      fac_times_alpha.create(n_refl)
      alpha.create(n_refl)
      alpha = .crystal.extinction_correction
      Fexp.create(n_refl);  Fexp = .crystal.F_exp
      Fsig.create(n_refl);  Fsig = .crystal.F_sigma
      Fm.create(n_refl);    Fm = max(abs(Fc),TOL(10))
      fac_times_alpha = fac * alpha * (alpha * Fm - Fexp) / (Fsig * Fsig * Fm)
      Fm.destroy
      Fsig.destroy
      Fexp.destroy
      alpha.destroy
      Fcr = fac_times_alpha * RE(Fc)
      Fci = fac_times_alpha * IM(Fc)
      fac_times_alpha.destroy
      Fc.destroy

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts
      k_pts.create(n_k,3)
      kU.create(n_k,3)

      ! Make list of symmetry non-equivalent symops
      ! and the necessary k points
      .crystal.make_unique_SF_k_pts(k_pts)
      k1 => k_pts(:,1)
      k2 => k_pts(:,2)
      k3 => k_pts(:,3)

      ! Set up grids, atomic densities, overlapping_atoms -- shouldn't be leaky
      .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Max no of becke grid points per atom
      n_pt = .becke_grid.max_no_of_points_per_atom

      ! Atom "a" displaced points and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt)
      a2.create(n_pt)
      skipa0.create(n_pt)
      skipab.create(n_pt)

      ! Initialse the constraint
      constraint = ZERO

      ! Loop over integration atoms "c"
      parallel do c = 1,.n_atom

         ! Repetition factor for this atom
         rf = .crystal.repetition_factor(c)
         if (rf.is_zero) cycle
         rf = ONE/rf

         ! Get the Becke grid for atom "c"
         .becke_grid.make_grid(pt,wt,bf_save,c)
         n_pt = pt.dim1

         ! Overlapping atoms
         overlapping_atom => .overlapping_atoms_for_atom(c).element

         ! Make stockholder weight function "Wc" for atom "c"
         ! If using interpolatators, then on overlapping atoms 
         ! are used ... otherwise nothing is skipped
         .apply_stockholder_atom_weight(wt,c,pt)

         ! Prune the grid with new "wt", get saved bf grid bf_save, 
         ! and new no of points, n_pt -- leaky
         .becke_grid.prune_grid(pt,wt,bf_save)
         n_pt = pt.dim1

         ! Basis function grid and skip list
         bf_skip.create(.n_shell)
         bf_grid.create(.n_shell)

         ! Temperature factor for this atom for all k_pts
         kU = matmul(k_pts,.atom(c).ADP_tensor)
         u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)

         ! Make the effective density matrix "X", fold into "wt"
         X.create(n_pt)
         tf.create(n_k)
         tf = exp(-HALF*(u1*k1+u2*k2+u3*k3))
         .crystal.sum_unique_sf_pts(X,k_pts,pt,tf,Fcr,Fci)
         wt = rf * wt * X
         tf.destroy
         X.destroy

         ! Loop c-overlapping atoms a
         do ca = 1,overlapping_atom.dim

            oa  = overlapping_atom(ca)
            fsa = .first_shell_for_atom(oa)
            lsa =  .last_shell_for_atom(oa)
            fba = .first_basis_fn_for_atom(oa)
            ra  = .atom(oa).position

            ! Make the displaced points for atom "a"
            .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

            ! Loop shells on atom a
            do sa = fsa,lsa

               ! Shell a limits
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
               as = .basis_shell_for_shell(sa)

               ! Set shell "sa"
               sha = .precomputed_basis_shellpair(as,1).a
               sha.position = ra

               ! Make shell "sa" skip list
               skipa.create(n_pt)
               sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

               ! Next shell "sa" if no sig. points
               if (n_keep==0) then
                  skipa.destroy
                  cycle
               end

               ! Assign the "sa" skipa list
               bf_skip(sa).element => skipa

               ! Make/copy the "sa" basis function grida
               ! This must be copied since skipa could be TRUE
               grida.create(n_keep,na)
               if (oa==c) then
                  do a = 1,na
                     i = 0
                     do n = 1,n_pt
                        if (skipa(n)) cycle
                        i = i + 1
                        grida(i,a) = bf_save(n,a+fa-fba)
                     end
                  end
               else
                  sha.make_skip_grid(grida,n_keep,na,xa,ya,za,a2,skipa,n_pt)
               end
               bf_grid(sa).element => grida

               ! Loop c-overlapping atoms b
               do cb = 1,ca

                  ob  = overlapping_atom(cb)
                  fsb = .first_shell_for_atom(ob)
                  lsb =  .last_shell_for_atom(ob)

                  ! Loop shells on atom b
                  do sb = fsb,min(lsb,sa)

                     ! No significant points
                     if (bf_skip(sb).element.destroyed) cycle

                     ! Shell b limits
                     fb = .first_basis_fn_for_shell(sb)
                     lb = .last_basis_fn_for_shell(sb)
                     nb = lb - fb + 1

                     ! Set the "sb" basis function grid
                     skipb => bf_skip(sb).element 
                     gridb => bf_grid(sb).element 

                     ! How many points in common?
                     skipab(1:n_pt) = skipa OR skipb
                     n_keep = count(NOT skipab(1:n_pt))
                     if (n_keep==0) cycle

                     ! Product of ga and gb and effective density for "c"
                     ! Add the contribution to constraint "C"
                     CC => constraint(fa:la,fb:lb)

                     if (na*nb==1) then

                        ga => grida(:,1)
                        gb => gridb(:,1)
                        val = ZERO
                        i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           val = val +  ga(i)*gb(j)*wt(n)
                        end
                        CC(1,1) = CC(1,1) + val

                     else

                        ! Create space for gathered index info
                        pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                        ! Make mapper arrays
                        p = 0; i = 0; j = 0
                        do n = 1,n_pt
                           if (NOT skipa(n)) i = i + 1
                           if (NOT skipb(n)) j = j + 1
                           if (skipab(n)) cycle
                           p = p + 1
                           pi(p) = i
                           pj(p) = j
                           pn(p) = n
                        end

                        do a = 1,na
                           ga => grida(:,a)
                           do b = 1,nb
                              gb => gridb(:,b)
                              val = ZERO
                              do p = 1,n_keep
                                 i = pi(p)
                                 j = pj(p)
                                 n = pn(p)
                                 val = val +  ga(i)*gb(j)*wt(n)
                              end
                              CC(a,b) = CC(a,b) + val
                           end
                        end

                        ! Clean up
                        pn.destroy; pj.destroy; pi.destroy

                     end

                  end
               end
            end
         end

         ! Clean up atom "c" stuff
         bf_grid.destroy
         bf_skip.destroy
         bf_save.destroy
         wt.destroy
         pt.destroy

      end ! -- loop over atom "c"

      ! Clean up
      skipab.destroy
      skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
      kU.destroy
      k_pts.destroy
      Fci.destroy
      Fcr.destroy

      ! Symmetrise
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(constraint)
       else
         constraint.symmetric_reflect
      end

      ! Get rid of OO block if requested
      if (.scfdata.zero_oo_constraint_block) then
         constraint.change_basis_using(.molecular_orbitals.restricted)
         constraint(1:.n_a,1:.n_a) = ZERO
         constraint.back_transform_using(.molecular_orbitals.restricted)
      end

      ! Shift linear dependence
      if (.scfdata.created) .shift_dependence_from_r(constraint)

   end

   make_pnd_constraint(C)
   ! Make the constraint matrix "C" for restricted wavefunction fitting.
      C :: MAT{REAL}, INOUT

   ENSURE(.crystal.created,"no crystal info")
   ENSURE(.crystal.spacegroup.centrosymmetric,"crystal must be centrosymmetric")
   DIE_IF(NOT .crystal.spacegroup.centrosymmetric,"crystal must be centrosymmetric")

      k_pts :: MAT{REAL}*
      ft_ab_eq,ft_ab :: MAT3{CPX}*
      Fc,fac_times_alpha :: VEC{CPX}*
      Fexp,Fsig,alpha :: VEC{REAL}*
      fac,cutoff :: REAL
      q,fa,la,fb,lb,na,nb,i,j,n_refl,n_unique,atom_a,atom_b :: INT
      sh :: SHELL2


      n_unique = .crystal.n_unique_SF_k_pts
      n_refl = .crystal.n_refl
      fac = -G_FACTOR/(TWO*max(n_refl - .crystal.n_param,1))

      fac_times_alpha.create(n_refl)

      Fc.create(n_refl)
      Fc = .crystal.F_calc

      alpha.create(n_refl)
      alpha = .crystal.extinction_correction

      Fexp.create(n_refl);  Fexp = .crystal.F_exp
      Fsig.create(n_refl);  Fsig = .crystal.F_sigma
      fac_times_alpha = fac * alpha * (alpha * Fc - Fexp) / (Fsig * Fsig)

      Fsig.destroy
      Fexp.destroy
      alpha.destroy
      Fc.destroy

      k_pts.create(n_unique,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      cutoff = TOL(10) / .n_shell_pairs

      C = ZERO

      parallel do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

         if (sh.skip_ft(cutoff)) then
           sh.destroy_ptr_part
           cycle
         end

         ft_ab.create([1,n_refl],[fa,la],[fb,lb])
         ft_ab_eq.create(n_unique,na,nb)
         .make_ft_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
         .crystal.sum_unique_sf_ints(ft_ab,ft_ab_eq)
         ft_ab_eq.destroy

         do i = fa,la
           do j = fb,min(lb,i)
             C(i,j) = sum(RE(fac_times_alpha(:)*ft_ab(:,i,j)))  
           end
         end

         ft_ab.destroy
         sh.destroy_ptr_part

      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(C)
      else
        C.symmetric_reflect

      end

      k_pts.destroy
      fac_times_alpha.destroy

   end

   reset_for_next_lambda
   ! Reset the iteration counters for the next lambda iteration.
   ! Also reset the fock matrices on disk.
      .get_overlap_matrix
      .scfdata.reset_for_next_lambda
   end

!  ============
!  Embedded SCF
!  ============

!   embedded_scf ::: leaky
!   ! Do an SCF calculation for a molecular fragment embedded in a crystal
!   ! generated cluster. The .molecular_orbitals and .orbital_energies are
!   ! obtained for the embedded fragment. The .density_matrix is obtained for the
!   ! whole cluster. There must be a pre-existing cluster, and self must be the
!   ! same as this cluster. Also, there must be a .saved molecule representing
!   ! the embedded fragment whose orbitals are obtained.
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.cluster.created,"no cluster")
!   ENSURE(.saved.created,"no saved fragment molecule")
!   ENSURE(.saved.molecular_orbitals.created,"no saved molecular orbitals")
!     .initialise_scf
!     .put_scf_results
!     do
!       if (.scfdata.scf_done) exit
!       .add_cluster_projector(.fock_matrix,.molecular_orbitals)
!       .accelerate_fock_matrix
!       ! Get back the fragment MO's
!       .unarchive_molecular_orbitals
!       .update_molecular_orbitals
!       ! Symmetry transform the occupied MO's around the crystal cluster.
!       ! This stuffs up the fragment MO's.
!       .transform_embedded_orbitals(.molecular_orbitals,do_virtual=FALSE)
!       ! This is the cluster density matrix
!       .make_scf_density_matrix(n_a=.saved.n_a*.cluster.n_fragment_symop) 
!       ! This is the cluster fock matrix
!       .make_fock_matrix
!       ! Now make the fragment density matrix, and update info
!       .make_scf_density_matrix(n_a=.saved.n_a,damp=FALSE) 
!       .update_scfdata
!       .update_scfdata_error
!       .put_scf_results
!     end
!     .archive_scf_results
!     .cleanup_scf
!   end
!
!   initialise_embedded_scf ::: leaky
!   ! Initialise the embedded SCF procedure
!   ENSURE(.scfdata.created,"no scfdata")
!   ENSURE(.saved.created,"no saved molecule")
!   ENSURE(.cluster.created,"no cluster")
!   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
!   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
!      .initialise_DFT_grids
!      ! Initialise and archive the MO's
!      .initialise_embedded_orbitals
!      .transform_embedded_orbitals(.molecular_orbitals,do_virtual=TRUE)
!      .archive(.molecular_orbitals,"molecular_orbitals",with_lambda=TRUE)
!      ! This is the cluster density matrix
!      .make_scf_density_matrix(n_a=.saved.n_a*.cluster.n_fragment_symop,damp=FALSE) 
!      ! This is the cluster fock matrix
!      .make_fock_matrix        
!      ! Now we have back the fragment density matrix
!      .make_scf_density_matrix(n_a=.saved.n_a,damp=FALSE) 
!      .initialise_scfdata
!      .initialise_scfdata_error
!      .scfdata.diis.cleanup
!   end
!
!   initialise_embedded_orbitals ::: leaky
!   ! Initialise the embedded cluster .molecular orbitals from those in the
!   ! .saved fragment. This does not do any symmetry transformation.
!   ENSURE(.scfdata.created,"no scfdata")
!   ENSURE(.saved.created,"no saved molecule")
!   ENSURE(.cluster.created,"no cluster")
!   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
!   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
!      nsb,nso,nsv,no,nv :: INT
!      nsb = .saved.n_bf
!      nso = .saved.n_a
!      nsv = nsb - nso
!      no  = nso*.cluster.n_fragment_symop
!      nv  = nsv*.cluster.n_fragment_symop
!      select case (.scfdata.scf_kind)
!         case ("embedded_rhf","crystal_rhf")
!            .molecular_orbitals.destroy("restricted")
!            .molecular_orbitals.restricted.create(.n_bf,.n_bf)
!            .molecular_orbitals.restricted = ZERO
!            .molecular_orbitals.restricted(1:nsb,1:nso) = .saved.molecular_orbitals.restricted(:,1:nso)
!            .molecular_orbitals.restricted(1:nsb,no+1:no+nsv) = .saved.molecular_orbitals.restricted(:,nso+1:nso+nsv)
!            .orbital_energies.create(genre=.scfdata.orbital_energies_kind)
!         case default
!            DIE("unknown or unimplemented SCF kind, "//trim(.scfdata.scf_kind))
!      end
!   end
!
!   transform_embedded_orbitals(MO,do_virtual)
!   ! Transform the (.saved) embedded molecular orbitals "MO" into the crystal
!   ! orbitals over the cluster (i.e. this molecule) using crystal symmetry
!   ! operations.
!      MO :: OPMATRIX*
!      do_virtual :: BIN, optional
!   ENSURE(.scfdata.created,"no scfdata")
!   ENSURE(.saved.created,"no scfdata")
!      select case (.scfdata.scf_kind)
!         case ("embedded_rhf","crystal_rhf")
!            .transform_embedded_orbitals_r(MO.restricted,do_virtual)
!         case default
!            DIE("unknown or unimplemented SCF kind, "//trim(.scfdata.scf_kind))
!      end
!   end
!
!   transform_embedded_orbitals_r(MO,do_virtual) 
!   ! Transform the (.saved) embedded molecular orbitals "MO" into the crystal
!   ! orbitals over the cluster (i.e. this molecule) using crystal symmetry
!   ! operations.
!      MO :: MAT{REAL}*
!      do_virtual :: BIN, optional
!   ENSURE(MO.is_square,"MO is not square")
!   ENSURE(MO.dim1==.n_bf,"wrong size for MO")
!   ENSURE(.saved.created,"no saved molecule")
!   ENSURE(.cluster.created,"no cluster")
!   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
!   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
!      seitz :: MAT3{REAL}*
!      tr :: VEC{MAT3_{REAL}}*
!      nso,nsv,no,nv,q,op,fo,lo,fv,lv,s,a,fs,ls,sf,sl,p,fp,fa,L :: INT
!      do_virt :: BIN
!      do_virt = FALSE
!      if (present(do_virtual)) do_virt = do_virtual
!      seitz => .crystal.xyz_seitz_matrices
!      tr.make_gaussian_xyz_matrices(seitz)
!      nso = .saved.n_a
!      nsv = .saved.n_bf - nso
!      no  = nso*.cluster.n_fragment_symop
!      nv  = nsv*.cluster.n_fragment_symop
!      ! Assume the occupied neighbouring orbitals occur as the end columns (due
!      ! to the use of a projection operator of high energy)
!    ! MO(:,no+1:no+nv) = MO(:,nso+1:nso+nv)
!      MO(:,nso+1:no) = ZERO                    ! to be defined below
!      if (do_virt) MO(:,no+nsv+1:no+nv) = ZERO ! to be defined below
!      lo = nso
!      lv = no+nsv
!      do q = 2,.cluster.n_fragment_symop                  ! Loop over generating cluster symops 
!         op  = .cluster.fragment_symop(1,q)               ! The seitz op for the cluster symop
!         fo = lo + 1
!         lo = lo + nso 
!         fv = lv + 1
!         lv = lv + nsv 
!         do s = 1,.n_shell                                ! Loops over shells s in the row i.e. ao's.
!            a = .atom_for_shell(s)                        ! The atom for shell s
!            p  = .cluster.fragment_parents_for_atom(a,q)  ! Which atom (not necesarily fragment) did "a" come from?
!            if (p==0) cycle                               ! No parent? then cycle
!            fs = .first_basis_fn_for_shell(s)
!            ls = .last_basis_fn_for_shell(s)
!            fa = .first_basis_fn_for_atom(a)
!            fp = .first_basis_fn_for_atom(p)
!            sf = fp + fs - fa                             ! first function for embedded shell
!            sl = fp + ls - fa                             ! last  function for embedded shell
!            L  = .angular_moment_for_shell(s)
!            MO(fs:ls,fo:lo).to_product_of(tr(L)[:,:,op],MO(sf:sl,1:nso))
!            if (do_virt) &
!            MO(fs:ls,fv:lv).to_product_of(tr(L)[:,:,op],MO(sf:sl,no+1:no+nsv))
!         end
!      end
!      tr.destroy
!      seitz.destroy
!   end
!
!   collapse_crystal_orbitals_r(MO) ::: leaky
!   ! Collapse the crystal orbitals back into the (.saved) embedded fragment
!   ! orbitals.
!      MO :: MAT{REAL}*
!   ENSURE(MO.dim1==.n_bf,"wrong dim1 for MO")
!   ENSURE(MO.dim2==.n_bf,"wrong dim1 for MO")
!      nso,nsv,no,nv :: INT
!      nso = .saved.n_a
!      nsv = .saved.n_bf - nso
!      no  = nso*.cluster.n_fragment_symop
!      nv  = nsv*.cluster.n_fragment_symop
!      MO(:,nso+1:nso+nsv) = MO(:,no +1:no+nsv) 
!      MO.shrink_columns(nso+nsv) 
!   end
!
!   add_cluster_projector(F,MO)
!   ! Add the cluster projector to the fock matrix "F" using the molecular
!   ! orbitals "MO. This ensures that the occupied orbitals are orthogonal to the
!   ! occupied orbitals of neighbouring molecules.
!     F,MO :: OPMATRIX*
!   ENSURE(.scfdata.created,"no scfdata")
!   ENSURE(F.created,"no Fock matrix")
!   ENSURE(F.any_created,"no Fock matrix")
!   ENSURE(F.spinorbital_kind==.scfdata.spinorbital_kind,"incompatible Fock matrix")
!     P,S :: MAT{REAL}*
!     k,l :: INT
!     scf_kind :: STR
!     scf_kind = .scfdata.scf_kind
!     select case (scf_kind)
!        case ("rhf","xray_rhf","embedded_rhf","crystal_rhf")
!           k = .saved.n_a + 1
!           l = .saved.n_a*.cluster.n_fragment_symop
!           P.create(.n_bf,.n_bf)
!           S.create(.n_bf,.n_bf); .make_overlap_matrix(S)
!           P.to_product_of(MO.restricted(:,k:l),MO.restricted(:,k:l),transpose_b=TRUE)
!           P.change_basis_using(S)
!           .fock_matrix.restricted = .fock_matrix.restricted + .scfdata.kappa*P
!           S.destroy
!           P.destroy
!        case default
!           DIE("unknown or unimplemented SCF kind, "//trim(scf_kind))
!     end
!   end

!   transform_embedded_orbitals(MO)
!   ! Transform the embedded orbitals "MO".
!      MO :: MAT{REAL}
!      seitz :: MAT3{REAL}*
!      tr :: VEC{MAT3_{REAL}}*
!      n_embedded_bf,n_embedded_shell :: INT
!      i,ai,fi,li,if,il,j,aj,fj,lj,jf,jl, q,u,f,p,fa,fp,L :: INT
!      n_embedded_bf = .saved.n_bf
!      n_embedded_shell = .saved.n_shell
!      seitz => .crystal.xyz_seitz_matrices
!      tr.make_gaussian_xyz_matrices(seitz)
!      do i = n_embedded_shell+1,.n_shell                  ! Loop over group i of shells (orbitals) in column
!         ai = .atom_for_shell(i)                          ! The atom that the orbitals in group i belong to 
!         q  = .cluster.fragment_symop_for_atom(ai)        ! Which symop generated these shells? 
!     !   u  = .cluster.unit_cell_atom_for_atom(ai)
!     !   f  = .crystal.frag_cell_for_unit_cell_atom(u)
!     !   p  = .crystal.frag_atom_for_frag_cell_atom(f)    ! Which fragment atom did "ai" come from?
!         p  = .cluster.fragment_parents_for_atom(ai,q)    ! Which fragment atom did "ai" come from?
!         fi = .first_basis_fn_for_shell(i)
!         li = .last_basis_fn_for_shell(i)
!         fa = .first_basis_fn_for_atom(ai)
!         fp = .saved.first_basis_fn_for_atom(p)
!         if = fp + fi - fa                                ! first function for embedded shell
!         il = fp + li - fa                                ! last  function for embedded shell
!     !      stdout.text("======================================") 
!     !      stdout.show("shell i                  =",i) 
!     !      stdout.show("atom ai for shell i      =",ai) 
!     !      stdout.show("parent p for atom a      =",p) 
!     !      stdout.show("clust symop q for atom a =",q) 
!     !      stdout.show("first fn for shell i, fi =",fi) 
!     !      stdout.show("last  fn for shell i, li =",li) 
!     !      stdout.show("first fn for atom a,  fa =",fa) 
!     !      stdout.show("first fn for atom p,  fp =",fp) 
!     !      stdout.show("first embedded fn,    if =",if) 
!     !      stdout.show("last  embedded fn,    il =",il) 
!         do j = 1,.n_shell                                ! Loops over shells s in the row i.e. ao's.
!            aj = .atom_for_shell(j)                       ! The atom for shells s
!            p  = .cluster.fragment_parents_for_atom(aj,q) ! Which atom (not necesarily fragment) did "a" come from?
!            if (p==0) cycle
!            fj = .first_basis_fn_for_shell(j)
!            lj = .last_basis_fn_for_shell(j)
!            fa = .first_basis_fn_for_atom(aj)
!            fp = .first_basis_fn_for_atom(p)
!            jf = fp + fj - fa                             ! first function for embedded shell
!            jl = fp + lj - fa                             ! last  function for embedded shell
!            L  = .angular_moment_for_shell(j)
!     !      stdout.flush
!     !      stdout.show("shell j                  =",j) 
!     !      stdout.show("atom aj for shell j      =",aj) 
!     !      stdout.show("parent p for atom a      =",p) 
!     !      stdout.show("clust symop q for atom a =",q) 
!     !      stdout.show("first fn for shell j, fj =",fj) 
!     !      stdout.show("last  fn for shell j, lj =",lj) 
!     !      stdout.show("first fn for atom a,  fa =",fa) 
!     !      stdout.show("first fn for atom p,  fp =",fp) 
!     !      stdout.show("first embedded fn,    jf =",jf) 
!     !      stdout.show("last  embedded fn,    jl =",jl) 
!     !      stdout.flush
!            MO(fj:lj,fi:li).to_product_of(tr(L)[:,:,q],MO(jf:jl,if:il))
!         end
!      end
!      tr.destroy
!      seitz.destroy
!   end

!  ===========
!  Crystal SCF
!  ===========
!
!   crystal_scf ::: leaky
!   ! Do an SCF calculation for a molecular fragment embedded in a crystal
!   ! generated cluster. The .molecular_orbitals and .orbital_energies are
!   ! obtained for the embedded fragment. The .density_matrix is obtained for the
!   ! whole cluster. There must be a pre-existing cluster, and self must be the
!   ! same as this cluster. Also, there must be a .saved molecule representing the
!   ! embedded fragment whose orbitals are obtained.
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.cluster.created,"no cluster")
!   ENSURE(.saved.created,"no saved fragment molecule")
!   ENSURE(.saved.molecular_orbitals.created,"no saved molecular orbitals")
!     .initialise_scf
!     .put_scf_results
!     do
!       if (.scfdata.scf_done) exit
!       .add_cluster_projector(.fock_matrix,.molecular_orbitals)
!       .accelerate_fock_matrix
!       ! Get back the fragment MO's
!       .unarchive_molecular_orbitals
!       .update_molecular_orbitals
!       ! Symmetry transform the occupied MO's around the crystal cluster.
!       ! This stuffs up the fragment MO's.
!       .transform_embedded_orbitals(.molecular_orbitals,do_virtual=FALSE)
!       ! This is the cluster density matrix
!       .make_scf_density_matrix(n_a=.saved.n_a*.cluster.n_fragment_symop) 
!       ! This is the cluster fock matrix
!       .make_fock_matrix
!       ! Now make the fragment density matrix, and update info
!       .make_scf_density_matrix(n_a=.saved.n_a,damp=FALSE) 
!       .update_scfdata
!       .update_scfdata_error
!       .put_scf_results
!     end
!     .archive_scf_results
!     .cleanup_scf
!   end
!
!   initialise_crystal_scf ::: leaky
!   ! Initialise the crystal SCF procedure
!   ENSURE(.scfdata.created,"no scfdata")
!   ENSURE(.saved.created,"no saved molecule")
!   ENSURE(.cluster.created,"no cluster")
!   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
!   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
!      ! Initialise and archive the MO's
!      .initialise_embedded_orbitals
!      .transform_embedded_orbitals(.molecular_orbitals,do_virtual=TRUE)
!      .archive(.molecular_orbitals,"molecular_orbitals",with_lambda=TRUE)
!      ! This is the cluster density matrix
!      .make_scf_density_matrix(n_a=.saved.n_a*.cluster.n_fragment_symop,damp=FALSE) 
!      ! This is the cluster fock matrix
!      .make_fock_matrix        
!      ! Now we have back the fragment density matrix
!      .make_scf_density_matrix(n_a=.saved.n_a,damp=FALSE) 
!      .initialise_scfdata
!      .initialise_scfdata_error
!      .scfdata.diis.cleanup
!   end
! 
!   set_crystal_scf_occupations
!   ! Set the SCF occupation numbers for the natural orbitals
!   ENSURE(.saved.created,"no saved molecule fragment")
!      NO_kind :: STR
!      n_a,n_b,n_e :: INT
!      n_a = .saved.n_a
!      n_b = .saved.n_b
!      n_e = .saved.n_e
!      NO_kind = .natural_orbitals.spinorbital_kind
!      select case (NO_kind)
!         case ("restricted")
!            .occupation_numbers.restricted(1:n_a) = TWO
!         case ("unrestricted")
!            .occupation_numbers.alpha(1:n_a) = ONE
!            .occupation_numbers.beta(1:n_b) = ONE
!         case ("general")
!            .occupation_numbers.general(1:n_e) = ONE
!         case ("restricted_complex")
!            .occupation_numbers.restricted(1:n_a) = TWO
!         case ("unrestricted_complex")
!            .occupation_numbers.alpha(1:n_a) = ONE
!            .occupation_numbers.beta(1:n_b) = ONE
!         case ("general_complex")
!            .occupation_numbers.general(1:n_e) = ONE
!      end
!   end
!
!   make_effective_charges(charges,positions)
!   ! Make a list of effective point charges that accurately represents the total
!   ! charge of the unit cell.  Includes contributions from electrons and nuclei.
!   ! NOTE: this is normally called on a .saved fragment
!     charges :: VEC{REAL}, target
!     positions :: MAT{REAL}, target
!   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.n_atom,"charges has wrong size")
!   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
!   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
!   ENSURE(.atom.created,"Need a list of atoms")
!   ENSURE(.dftgrid.created,"no DFT grid")
!     ch,wt,rho,deficit :: VEC{REAL}*
!     pt :: MAT{REAL}*
!     shift,pos3 :: VEC{REAL}(3)
!     n_pt,n,i,f,l,ff,ll :: INT
!     Z,val :: REAL
!     ! Make the effective electronic charges "ch" and positions "pt"
!     n_pt = .dftgrid.n_pts*.n_atom
!     ch.create(n_pt); pt.create(n_pt,3)
!     wt.create(n_pt); rho.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(rho,pt)
!     ch = -rho*wt
!     rho.destroy; wt.destroy
!   ! stdout.set_real_style("e")
!   ! stdout.text("charges:")
!   ! stdout.put(ch)
!   ! stdout.text("pt:")
!   ! stdout.put(pt)
!     ! First get the atomic charges, which are assigned to balance the
!     ! electronic charge in case the DFT integration grid is poor.
!     deficit.create(.n_atom)
!     n_pt = .dftgrid.n_pts
!     l = 0
!     do n = 1,.n_atom
!        f = l + 1
!        l = l + n_pt
!        Z = ZERO
!        do i = f,l
!           Z = Z + ch(i)
!        end
!        deficit(n) = -Z
!     end
!     ! Now set the full "charges" and "positions" arrays, including the
!     ! (corrected) atomic charges, at the end of the list
!     l = 0
!     ll = 0
!     do n = 1,.n_atom
!        f  = l  + 1
!        l  = l  + n_pt
!        ff = ll + 1
!        ll = ll + n_pt
!        charges(f:l) = ch(ff:ll)
!        positions(:,f:l) = transpose(pt(ff:ll,:))
!        l = l + 1
!        charges(l) = deficit(n)  
!        deficit(n) = .atom(n).atomic_number - deficit(n)
!        positions(:,l) = .atom(n).position
!     end
!     stdout.set_real_style("e")
!     stdout.flush
!     stdout.text("Deficit charges:")
!     stdout.put(deficit)
!     stdout.show("sum of deficit charges =",sum(deficit))
!     stdout.show("sum of charges         =",sum(charges))
!     deficit.destroy
!   ! stdout.flush
!   ! stdout.text("Charges:")
!   ! stdout.flush
!   ! stdout.put(charges)
!   ! stdout.flush
!   ! stdout.text("Positions:")
!   ! stdout.flush
!   ! stdout.put(positions,"transpose")
!     stdout.set_real_style("f")
!     pt.destroy; ch.destroy
!   end

!   make_uc_effective_charges(charges,positions)
!   ! Make a list of effective point charges that accurately represents the total
!   ! charge of the unit cell.  Includes contributions from electrons and nuclei.
!     charges :: VEC{REAL}, target
!     positions :: MAT{REAL}, target
!   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.n_atom,"charges has wrong size")
!   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
!   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
!   ENSURE(.atom.created,"Need a list of atoms")
!   ENSURE(.saved.dftgrid.created,"no DFT grid")
!     ch,wt,rho,deficit :: VEC{REAL}*
!     pt :: MAT{REAL}*
!     shift,pos3 :: VEC{REAL}(3)
!     n_pt,n,i,f,l,ff,ll :: INT
!     ZZ,val :: REAL
!
!     pos,new_pos :: MAT{REAL}*
!     Z,n_ch,n_pt,n,f,l,s :: INT
!
!     stdout.text("making saved dft grid")
!     n_ch = .saved.dftgrid.n_pts
!     n_pt = .saved.dftgrid.n_pts
!     ch.create(n_pt)
!     pos.create(3,n_pt)
!     .saved.dftgrid.make_grid(pos,wt,.saved.atom)
!     ! Change fragment positions into fractionals
!     .crystal.unit_cell.change_into_fractional(pos)
!     new_pos.create(pos.dim1,pos.dim2)
!     ! Use symmetry to generate the effective charges and their positions in the
!     ! whole unit cell. This assumes that the fragment cell is generated from
!     ! the *whole* fragment by .crystal.Z symops.
!     l = 0
!     do n = 1,Z
!        f = l + 1
!        l = l + n_ch
!        .charges(f:l) = .fragment_charges
!        new_pos = pos
!        s = .crystal.symop_for_frag_cell_atom(1+(n-1)*.crystal.n_fragment_atoms)
!        .crystal.transform_geometry(new_pos,op=s)
!        .crystal.put_to_unit_cell(new_pos)
!        .positions(:,f:l) = new_pos ! in cartesians
!     end
!     new_pos.destroy; pos.destroy
!
!     do n = 1,.n_atoms          ! Loop over atoms in whole cluster
!     do q = 1,.n_fragment_symop ! Loop over fragment symops
!        child = .geometry(:,n)  ! Get the image of the parent p under the fragment symop s
!        op = int(.fragment_symop(1,q))
!        tr = .fragment_symop(2:4,q)
!        .crystal.transform_position(child,op,tr)
!        if (NOT .geometry.has_column(child,col=c)) cycle
!        .fragment_parents_for_atom(c,q) = n
!     end
!     end
!
!     ! Make the effective electronic charges "ch" and positions "pt"
!     Z = .n_atom/.saved.n_atom
!     n_pt = .saved.dftgrid.n_pts*Z
!     stdout.show("n_pt =",n_pt)
!     ch.create(n_pt); pt.create(n_pt,3)
!     wt.create(n_pt); rho.create(n_pt)
!
!     stdout.text("made dft grid")
!     stdout.text("making density grid")
!     .make_density_grid(rho,pt)
!     stdout.text("made density grid")
!     ch = -rho*wt
!     rho.destroy; wt.destroy
!     stdout.set_real_style("e")
!     stdout.text("charges:")
!     stdout.put(ch)
!     stdout.text("pt:")
!     stdout.put(pt)
!     ! First get the atomic charges, which are assigned to balance the
!     ! electronic charge in case the DFT integration grid is poor.
!     deficit.create(.n_atom)
!     n_pt = .dftgrid.n_pts
!     l = 0
!     do n = 1,.n_atom
!        f = l + 1
!        l = l + n_pt
!        ZZ = ZERO
!        do i = f,l
!           ZZ = ZZ + ch(i)
!        end
!        deficit(n) = -ZZ
!     end
!     ! Now set the full "charges" and "positions" arrays, including the
!     ! (corrected) atomic charges, at the end of the list
!     l = 0
!     ll = 0
!     do n = 1,.n_atom
!        f  = l  + 1
!        l  = l  + n_pt
!        ff = ll + 1
!        ll = ll + n_pt
!        charges(f:l) = ch(ff:ll)
!        positions(:,f:l) = transpose(pt(ff:ll,:))
!        l = l + 1
!        charges(l) = deficit(n)  
!        deficit(n) = .atom(n).atomic_number - deficit(n)
!        positions(:,l) = .atom(n).position
!     end
!     stdout.set_real_style("e")
!     stdout.flush
!     stdout.text("Deficit charges:")
!     stdout.put(deficit)
!     stdout.show("sum of deficit charges =",sum(deficit))
!     stdout.show("sum of charges         =",sum(charges))
!     deficit.destroy
!   ! stdout.flush
!   ! stdout.text("Charges:")
!   ! stdout.flush
!   ! stdout.put(charges")
!   ! stdout.flush
!   ! stdout.text("Positions:")
!   ! stdout.flush
!   ! stdout.put(positions,"transpose")
!     stdout.set_real_style("f")
!     pt.destroy; ch.destroy
!   end

!   make_unit_cell_point_charges(charges,positions)
!   ! Make a list of point charges that accurately represents the total charge of
!   ! the unit cell.  Includes contributions from electrons and nuclei.
!   ! NOTE: this is normally called on a .saved fragment
!     charges :: VEC{REAL}, target
!     positions :: MAT{REAL}, target
!   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
!   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
!   ENSURE(.atom.created,"Need a list of atoms")
!   ENSURE(.dftgrid.created,"no DFT grid")
!   ENSURE(.crystal.created,"no crystal data")
!   ENSURE(.crystal.Z.is_int(TOL(3)), "must have an integer number of fragments in the unit cell")
!   ENSURE(.crystal.frag_atom_for_frag_cell_atom.created,"fragment cell map not created")
!   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.crystal.n_unit_cell_atoms,"charges has wrong size")
!     ch,wt,rho,deficit :: VEC{REAL}*
!     pos,pt,uc_pos :: MAT{REAL}*
!     shift,pos3 :: VEC{REAL}(3)
!     n_pt,Z,n,f,l,s :: INT
!     e_sum,n_sum :: REAL
!     ! Make the effective electronic charges for the fragment.
!     n_pt = .dftgrid.n_pts*.n_atom
!     deficit.create(.n_atom)
!     ch.create(n_pt); pos.create(3,n_pt)
!     wt.create(n_pt); pt.create(n_pt,3); rho.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(rho,pt)
!     ch = -rho*wt
!     pos = transpose(pt)
!     ! Work out the deficit charge for each atom, which is the charge that can
!     ! be ascribed to the dft integration grid point at the atomic nucleus. It
!     ! should normally be negative because near the nucleus the density should
!     ! be evaluated in the midpoint of the region but it is evaluated closer to
!     ! the nucleus and hence is larger than it should be (?). Thats my
!     ! explanation anyhow === dylan
!     Z = .crystal.Z
!     n_pt = .dftgrid.n_pts
!     l = 0
!     do n = 1,.n_atom
!        f = l + 1
!        l = l + n_pt
!        deficit(n) = .atom(n).atomic_number + sum(ch(f:l))
!     end
!     stdout.flush
!     stdout.text("Deficit charges:")
!     stdout.put(deficit)
!     stdout.show("sum of deficit charges =",sum(deficit))
!     stdout.show("Z times sum of deficit =",Z*sum(deficit))
!     rho.destroy; pt.destroy; wt.destroy
!     ! When added to any fractional position, "shift" will convert that
!     ! position to be such that the centre of the fragment molecule is at the
!     ! centre of the unit cell. 
!     shift = .centre_of_atoms ! The fragment molecule centre
!     .crystal.unit_cell.change_into_fractional(shift)
!     shift = [HALF,HALF,HALF] - shift
!     ! Use symmetry to generate the effective electronic charges and their
!     ! positions in the whole unit cell. This assumes that the fragment cell is
!     ! generated from the *whole* fragment by .crystal.Z symops.
!     .crystal.unit_cell.change_into_fractional(pos)
!     n_pt = .dftgrid.n_pts*.n_atom
!     l = 0
!     do n = 1,Z
!        f = l + 1
!        l = l + n_pt
!        charges(f:l) = ch
!        positions(:,f:l) = pos
!        s = .crystal.symop_for_frag_cell_atom(1+(n-1)*Z)
!        .crystal.transform_geometry(positions(:,f:l),op=s)
!        ! Shift the positions so that they are relative to the fragment molecule
!        ! centre before changing to the unit cell -- so the unit cell surrounds
!        ! the central fragment molecule.
!        positions(:,f:l) = positions(:,f:l) + spread(shift,dim=2,ncopies=n_pt)
!        .crystal.put_to_unit_cell(positions(:,f:l))
!        positions(:,f:l) = positions(:,f:l) - spread(shift,dim=2,ncopies=n_pt)
!        .crystal.unit_cell.change_from_fractional(positions(:,f:l))
!     end
!     pos.destroy; ch.destroy
!     ! Sum electron charges
!     n_pt = n_pt*Z
!     e_sum = sum(charges(1:n_pt))
!     stdout.show("sum of electrn charges =",e_sum)
!     ! Add the nuclear charges to the list. Don't forget to add the deficit
!     ! charges.
!     do n = 1,.crystal.n_unit_cell_atoms
!        f = .crystal.frag_atom_for_unit_cell_atom(n)
!        charges(n_pt+n) = .atom(f).atomic_number - deficit(f)
!        pos3 = .atom(f).position
!        .crystal.unit_cell.change_into_fractional(pos3)
!        pos3 = pos3 + shift
!        .crystal.put_to_unit_cell(pos3)
!        pos3 = pos3 - shift
!        .crystal.unit_cell.change_from_fractional(pos3)
!        positions(:,n_pt+n) = pos3
!     end
!     deficit.destroy
!     n_sum = sum(charges(n_pt+1:))
!     stdout.show("sum of nuclear charges =",n_sum)
!   end

!  ================================
!  Orbital update/cleaning routines
!  ================================

   schmidt_orthonormalise_MOs
   ! Schmidt orthonormalise the ".molecular_orbitals" and archive
      .schmidt_orthonormalise(.molecular_orbitals)
   end

   schmidt_orthonormalise(MO,scale)
   ! Schmidt orthonormalise the molecular orbitals, "MO"
      MO :: OPMATRIX
      scale :: REAL, optional
      .get_overlap_matrix
      MO.schmidt_orthonormalise(.overlap_matrix,scale)
   end

   symmetrically_orthonormalise(MO) ::: leaky
   ! Symmetrically orthonormalise the molecular orbitals, "MO"
      MO :: OPMATRIX
      .get_overlap_matrix
      MO.symmetrically_orthonormalise(.overlap_matrix)
   end

   update_molecular_orbitals
   ! Solve for the molecular orbitals.  Requires a set of old molecular
   ! orbitals.
   ENSURE(.scfdata.created,"no scfdata")

      if      (.scfdata.using_MO_gradient_update) then; .MO_gradient_update
    ! else if (.scfdata.using_exponential_update) then; .MO_exponential_update
      else;                                             .MO_eigen_update
      end

   end

   MO_eigen_update
   ! Solve for the molecular orbitals.  Requires a set of old molecular orbitals.
   ! The new molecular orbitals "cU" are found from the old MOs "c" by solving :
   ! (c^T F c)U = c^T S c U E ... where U is an orthogonal matrix, F fock matrix.
   ENSURE(.molecular_orbitals.created,"no old MO's")
   ENSURE(.molecular_orbitals.any_created,"no old MO's")

      scf_kind :: STR

      ! Update the MO's
      scf_kind = .scfdata.scf_kind
      select case (scf_kind)
        case ("rhf","rks","rohf","xray_rhf","xray_rks", &
              "embedded_rhf","embedded_rks","embedded_rohf", &
              "embedded_xray_rhf","embedded_xray_rks", &
              "crystal_rhf", "noninteracting-group-rhf")
           .MO_r_eigen_update(.orbital_energies.restricted, &
                              .molecular_orbitals.restricted, &
                              .fock_matrix.restricted)
        case ("uhf","uks","xray_uhf","xray_uks", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           .MO_r_eigen_update(.orbital_energies.alpha, &
                              .molecular_orbitals.alpha, &
                              .fock_matrix.alpha)
           .MO_r_eigen_update(.orbital_energies.beta, &
                              .molecular_orbitals.beta, &
                              .fock_matrix.beta)
        case ("gchf")
           .MO_gc_eigen_update(.orbital_energies.general, &
                               .molecular_orbitals.general_complex, &
                               .fock_matrix.general_complex)
        case default
           DIE("unknown scf kind, "//scf_kind.trim)
      end

   end

   MO_r_eigen_update(MO_energies,MO,F)
   ! Solve for the new molecular orbital energies "MO_energies" and the new
   ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
   ! matrix "F".  The new molecular orbitals "MO*U" are found from the old MOs
   ! "MO" by solving : (c^T F c)U = c^T S c U E ...... where U is an orthogonal
   ! matrix.
      MO_energies :: VEC{REAL}, OUT
      MO :: MAT{REAL}, INOUT
      F :: MAT{REAL}, IN

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.overlap_matrix.created,"no overlap_matrix")
   ENSURE(.overlap_eigenvectors.created,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.created,"no overlap_eigenvalues")

      G,U :: MAT{REAL}*
      i :: INT

      ! Copy F ==> G
      G.create(.n_bf,.n_bf)
      G = F
      .put_debug(G,"MO_r_eigen_update: Fock matrix before shifting dependence")

!      ! Remove linear depepndence
!      .shift_dependence_from_r(G)
!      .put_debug(G,"MO_r_eigen_update: Fock matrix after shifting dependence")
!

      ! Change F into old MO basis, G
      G.change_basis_using(MO)
      .put_debug(G,"MO_r_eigen_update: Fock matrix in the old MO basis")

      ! Level shift in old MO basis
      if (.scfdata.apply_level_shifting) then
       do i = .n_a + 1, .n_bf
         G(i,i) = .scfdata.level_shift + G(i,i)
       end
      end

      ! Get rotation U from old to new MO's
      U.create(.n_bf,.n_bf)
      G.solve_eigenproblem(MO_energies,U)
    ! G.diagonalise_by_jacobi(MO_energies,U)
      .put_debug(MO_energies,"MO_r_eigen_update: MO energies after update")

      ! Lock orbitals in place, if requested
      if (.scfdata.using_orbital_locking) U.make_diagonally_dominant

      ! Update orbitals
      G.to_product_of(MO,U)
      .put_debug(G,"MO_r_eigen_update: MO's after update")

!      ! Project linear dependence
!      .left_project_dependence_r(G)
!      .put_debug(G,"MO_r_eigen_update: MO's after removing linear dependence")

      ! Finished
      MO = G

      ! Overlap matrix in MO basis
      if (.debugging("MO_r_eigen_update: Overlap matrix in the projected MO basis")) then
         .overlap_matrix.change_basis_to(G,MO)
         .put_debug(G,"MO_r_eigen_update: Overlap matrix in the projected MO basis")
      end

      ! Clean up
      U.destroy
      G.destroy

   end

   shift_dependence_from_r(F)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors "evec" with small eigenvalue "eval".
   ! WARNING: this routine assumes eval's are ordered 
   ! smallest to largest.
      F :: MAT{REAL}

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.overlap_eigenvectors.created,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.created,"no overlap_eigenvalues")
   ENSURE(F.dim1==.n_bf,"wrong size, F")

      n :: INT
      tol,shift :: REAL

      ! Get no of vectors smaller than "tol"
      tol = .scfdata.linear_dependence_tol
      n   = .overlap_eigenvalues.index_of_first_greater_than(tol) - 1

      ! Decouple and shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      MOLECULE:decouple_and_shift_r(F,.overlap_eigenvectors,n,shift)

   end

   decouple_and_shift_r(F,evec,n,shift) ::: selfless
   ! In "F", decouple the first "n" eigenvectors "evec" and shift them
   ! to eigenvalue "shift". NOTE: ensure "evec" is orthonormal.
      F :: MAT{REAL}
      evec :: MAT{REAL}, IN
      n :: INT, IN
      shift  :: REAL, IN

      ! Return if no vectores to shift/decouple
      if (n==1) return

      ! Change to the eigenvector basis
      F.change_basis_using(evec)

      ! Decouple the vectors
      F(:n,n+1:) = ZERO
      F(n+1:,:n) = ZERO

      ! Shift the first n eigenvectors
      F(:n,:n).set_diagonal_to(shift)

      ! Revert from the eigenvector basis
      F.back_transform_using(evec)

   end

!   left_project_dependence_r(MO)
!   ! Left project the linear dependence from an "MO" like matrix
!   ! WARNING: this routine assumed overlap_eigenvalues are ordered 
!   ! smallest to largest.
!      MO :: MAT{REAL}
!
!   ENSURE(.scfdata.created,"no scfdata")
!   ENSURE(.overlap_matrix.created,"no overlap_matrix")
!   ENSURE(.overlap_eigenvectors.created,"no overlap_eigenvectors")
!   ENSURE(.overlap_eigenvalues.created,"no overlap_eigenvalues")
!   ENSURE(MO.is_square,"MO not square")
!   ENSURE(MO.dim1==.n_bf,"wrong size, MO")
!
!      P,W :: MAT{REAL}*
!      n,i :: INT
!      tol :: REAL
!
!      ! Return if all overlap matrix eigenvalues are big enough
!      tol = .scfdata.linear_dependence_tol
!      n   = .overlap_eigenvalues.index_of_first_greater_than(tol)
!      if (n==1) return
!
!      ! Set the projector
!      P.create(.n_bf,.n_bf)
!      P.to_unit_matrix
!      do i = 1,n-1
!         P.plus_outer_product_of(.overlap_eigenvectors(:,i),-ONE) 
!      end
!
!      ! Project it now
!      W.create(.n_bf,.n_bf)
!      W = MO
!      MO.to_product_of(P,W)
!
!      ! Clean up
!      W.destroy
!      P.destroy
!
!   end

   shift_linear_dependence_in_ngcm_from(F,Fnew)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors with small eigenvalue; place the result into "Fnew"
   ! WARNING: this routine assumed overlap_eigenvalues are ordered 
   ! smallest to largest.
      F,Fnew :: MAT{REAL}
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(F.is_square,"F not square")
   ENSURE(Fnew.is_square,"Fnew not square")
   ENSURE(F.is_same_shape_as(Fnew),"F and Fnew incompatible")

      n :: INT
      tol,shift :: REAL
      n_gcm :: INT
      m_out :: MAT{INT}*
      R,S,evec :: MAT{REAL}*
      eval :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .make_ready_da_gcm_tr2(m_out,n_gcm) 
      ENSURE(F.dim1==n_gcm,"wrong size, F is not in n_gcm space")

      R.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      .get_da_gcm_now(R,S,m_out)  
      m_out.destroy
      R.destroy

      evec.create(n_gcm,n_gcm)
      eval.create(n_gcm)

      S.solve_eigenproblem(eval,evec)
      S.destroy

      ! Return if all overlap matrix eigenvalues are big enough
      tol = .scfdata.linear_dependence_tol
      n   = eval.index_of_first_greater_than(tol)
      eval.destroy
      if (n==1) then
         Fnew = F
         return
      end

      ! Change to the eigenvector basis
      F.change_basis_to(Fnew,evec)

      ! Decouple the linear dependencies
      Fnew(:n-1,n:) = ZERO
      Fnew(n:,:n-1) = ZERO

      ! Shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      !  Fnew.increment_diagonal_by(shift)
      Fnew(:n-1,:n-1).increment_diagonal_by(shift)

      ! Revert from the eigenvector basis
      Fnew.back_transform_using(evec)
      evec.destroy

   end

   shift_linear_dependence_in_ngcm_from(F)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors with small eigenvalue.
   ! WARNING: this routine assumed overlap_eigenvalues are ordered 
   ! smallest to largest.
      F :: MAT{REAL}
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(F.is_square,"F not square")

      n :: INT
      tol,shift :: REAL
      n_gcm :: INT
      m_out :: MAT{INT}*
      R,S,evec :: MAT{REAL}*
      eval :: VEC{REAL}*

      m_out.create(.n_prim,.n_prim)
      .make_ready_da_gcm_tr2(m_out,n_gcm) 
      ENSURE(F.dim1==n_gcm,"wrong size, F is not in n_gcm space")

      R.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      .get_da_gcm_now(R,S,m_out)  
      m_out.destroy
      R.destroy

      evec.create(n_gcm,n_gcm)
      eval.create(n_gcm)

      S.solve_eigenproblem(eval,evec)
      S.destroy

      ! Return if all overlap matrix eigenvalues are big enough
      tol = .scfdata.linear_dependence_tol
      n   = eval.index_of_first_greater_than(tol)
      eval.destroy
      if (n==1) return

      ! Change to the eigenvector basis
      F.change_basis_using(evec)

      ! Decouple the linear dependencies
      F(:n-1,n:) = ZERO
      F(n:,:n-1) = ZERO

      ! Shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      ! F.increment_diagonal_by(shift)
      F(:n-1,:n-1).increment_diagonal_by(shift)

      ! Revert from the eigenvector basis
      F.back_transform_using(evec)
      evec.destroy

   end

   MO_gc_eigen_update(MO_energies,MO,F)
   ! Solve for the new molecular orbital energies "MO_energies" and the new
   ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
   ! matrix "F".
   ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by
   ! solving (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
      MO_energies :: VEC{REAL}
      MO,F :: MAT{CPX}

      G,U :: MAT{CPX}*
      i :: INT

      ! Change F into old MO basis, G
      G.create(2*.n_bf,2*.n_bf)
      F.change_basis_to(G,MO)
      .put_debug(G,"MO_gc_eigen_update: G matrix in MO basis")

      ! Level shift in old MO basis
      if (.scfdata.apply_level_shifting) then
       do i = .n_e + 1, 2*.n_bf
         G(i,i) = .scfdata.level_shift + G(i,i)
       end
      end
      .put_debug(G,"MO_gc_eigen_update: G matrix in MO basis after shift")

      ! Get rotation U from old to new MO's
      U.create(2*.n_bf,2*.n_bf)
   ! G.solve_eigenproblem(MO_energies,U)
      G.diagonalise_by_jacobi(MO_energies,U)
      if (.debugging("MO_gc_eigen_update: G matrix in MO basis after shift")) then
        G.change_basis_using(U)
        stdout.text("MO_gc_eigen_update: G matrix in MO basis after shift")
        stdout.put(G)
        stdout.put(MO_energies)
      end

      ! Lock orbitals in place, if requested
      if (.scfdata.using_orbital_locking) U.make_diagonally_dominant

      ! Update orbitals
      G.to_product_of(MO,U)
      MO = G

      ! Clean up
      U.destroy
      G.destroy

   end

   MO_gc_reorder(MO_energies,MO)
   ! Reorder the GC molecular orbitals so that the alpha orbitals come
   ! first, then the beta. This assumes that the alph and betra
   ! orbitals are nearly degenerate.
      MO_energies :: VEC{REAL}
      MO :: MAT{CPX}

      e :: VEC{REAL}*
      W :: MAT{CPX}*
      i,k :: INT

      e.create(2*.n_bf)
      W.create(2*.n_bf,2*.n_bf)

      k = 0
      do i = 1,2*.n_b-1,2
        k = k + 1
        e(k)   = MO_energies(i)
        W(:,k) = MO(:,i)
      end

      do i = 2,2*.n_b,2
        k = k + 1
        e(k)   = MO_energies(i)
        W(:,k) = MO(:,i)
      end

      do i = 2*.n_b+1,.n_e
        k = k + 1
        e(k)   = MO_energies(i)
        W(:,k) = MO(:,i)
      end

      do i = .n_e+1,2*.n_bf
        k = k + 1
        e(k)   = MO_energies(i)
        W(:,k) = MO(:,i)
      end

      MO_energies = e
      MO = W

      W.destroy
      e.destroy
   end

   MO_gradient_update
   ! Update the molecular orbitals using the gradient. Requires a set of old
   ! molecular orbitals. The new molecular orbitals "c" are found by
   ! incrementing a little along the gradient: (FDS - SDFDS)c and then
   ! reorthogonalising c.  NOTE: the normal Fock matrix DIIS update is turned
   ! off if this routine executes.
   ENSURE(.scfdata.using_MO_gradient_update,"not allowed")
   ENSURE(.fock_matrix.created,"no fock_matrix")
   ENSURE(.fock_matrix.any_created,"no fock_matrix")
   ENSURE(.density_matrix.created,"no density_matrix")
   ENSURE(.density_matrix.any_created,"no density_matrix")
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.any_created,"no MO's")

      orb_kind :: STR
      g,h,MO,F,P :: MAT{REAL}*
      f1,f2,scale :: REAL
      step :: REAL = ONE

      orb_kind = .scfdata.scf_kind

      select case (orb_kind)

        case ("rhf","rks","xray_rhf","xray_rks", &
              "embedded_rhf","embedded_rks", &
              "embedded_xray_rhf","embedded_xray_rks", &
              "crystal_rhf", "noninteracting-group-rhf")

           g.create(.n_bf,.n_bf)
           F  => .fock_matrix.restricted
           P  => .density_matrix.restricted
           MO => .molecular_orbitals.restricted
           .make_MO_r_gradient(g,F,P,MO)
           f1 = g.trace_product_with(transpose(g))
           MO = MO - (TOL(2)/sqrt(f1))*g
           .schmidt_orthonormalise(.molecular_orbitals,scale)
           scale = ONE/scale
           .make_scf_density_matrix
           .make_fock_matrix
           h.create(.n_bf,.n_bf)
           .make_MO_r_gradient(h,F,P,MO)
           h = (scale*h-g)/TOL(2)
           f2 = h.trace_product_with(transpose(h))
           h.destroy
           step = f1/f2
           step = min(.scfdata.max_update_stepsize,step)
           MO = MO - (step + TOL(2)/sqrt(f1))*g
           g.destroy

        case default
           DIE("SCF kind "//trim(orb_kind)//" not implemented")

      end

      .scfdata.set_diis_error(f1)

   end

   make_MO_r_gradient(g,F,P,c)
   ! Make the real gradient "g" of the molecular orbitals,
   ! g = (FPS - (1/2)SPFPS)c
      g,F,P,c :: MAT{REAL}

      S,W :: MAT{REAL}*

      .get_overlap_matrix
      S.create(.n_bf,.n_bf)
      W.create(.n_bf,.n_bf)
      W.to_product_of(P,.overlap_matrix)
      S.to_product_of(F,W)
      g =       S ! = FPS
      W = -HALF*W ! = -PS ... 1/2 is for double occupancy in P
      S.plus_product_of(W,g,transpose_a=TRUE)
      W.destroy
      g.to_product_of(S,c)
      S.destroy

   end

!   MO_exponential_update
!   ! Update the molecular orbitals using an antisymmetric first-order
!   ! update.
!   ENSURE(.scfdata.using_MO_gradient_update,"not allowed")
!   ENSURE(.fock_matrix.created,"no fock_matrix")
!   ENSURE(.fock_matrix.any_created,"no fock_matrix")
!   ENSURE(.density_matrix.created,"no density_matrix")
!   ENSURE(.density_matrix.any_created,"no density_matrix")
!   ENSURE(.molecular_orbitals.created,"no MO's")
!   ENSURE(.molecular_orbitals.any_created,"no MO's")
!
!      orb_kind :: STR
!      g,h,MO,F,P :: MAT{REAL}*
!      f1,f2,scale :: REAL
!      step :: REAL = ONE
!
!      orb_kind = .scfdata.scf_kind
!
!      select case (orb_kind)
!
!        case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")
!
!           g.create(.n_bf,.n_bf)
!           F  => .fock_matrix.restricted
!           MO => .molecular_orbitals.restricted
!           g = F
!           g.change_basis(MO)
!           g(1     :.n_a,1     :.n_a) = ZERO
!           g(.n_a+1:    ,.n_a+1:    ) = ZERO
!           g(1     :.n_a,.n_a+1:    ) = ZERO
!           g.make_antisymmetric
!           .make_MO_r_gradient(g,F,P,MO)
!           f1 = g.trace_product_with(transpose(g))
!           MO = MO - (TOL(2)/sqrt(f1))*g
!           .schmidt_orthonormalise(.molecular_orbitals,scale)
!           scale = ONE/scale
!           .make_scf_density_matrix
!           .make_fock_matrix
!           h.create(.n_bf,.n_bf)
!           .make_MO_r_gradient(h,F,P,MO)
!           h = (scale*h-g)/TOL(2)
!           f2 = h.trace_product_with(transpose(h))
!           h.destroy
!           step = f1/f2
!           step = min(.scfdata.max_update_stepsize,step)
!           MO = MO - (step + TOL(2)/sqrt(f1))*g
!           g.destroy
!
!        case default
!           DIE("SCF kind "//trim(orb_kind)//" not implemented")
!
!      end
!      .scfdata.set_diis_error(f1)
!      .archive(.molecular_orbitals,"molecular_orbitals")
!   end

! ==========================
! Energy evaluation routines
! ==========================

   put_scf_energy
   ! Output the scf energy.
      stdout.show("The SCF energy is ", .scf_energy)
      stdout.show("The kinetic energy is ", .kinetic_energy)
      if (.scfdata.is_DFT_calculation) &
      stdout.show("The Kohn-Sham DFT XC energy is ", .scfdata.dft_energy_correction)
   end

   kinetic_energy result (res)
   ! Evaluates the SCF kinetic energy as a trace of ".density_matrix"
   ! with the ".kinetic matrix".
      res :: REAL

   ENSURE(.scfdata.created,           "no scfdata")
   ENSURE(.density_matrix.created,    "no density matrix")
   ENSURE(.density_matrix.any_created,"no density matrix")

      scf_kind :: STR
      H :: MAT{REAL}*
      HH :: MAT{CPX}*

      res = ZERO

      scf_kind = .scfdata.scf_kind

      select case (scf_kind)

        case ("rhf","rks","xray_rhf","xray_rks", &
              "embedded_rhf","crystal_rhf","noninteracting-group-rhf")
           H.create(.n_bf,.n_bf)
           .make_kinetic_energy_mx(H)
           res = .density_matrix.restricted.trace_product_with(H)
           H.destroy

        case ("uhf","uks","xray_uhf","xray_uks","rohf", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           H.create(.n_bf,.n_bf)
           .make_kinetic_energy_mx(H)
           res = .density_matrix.alpha.trace_product_with(H)
           res = .density_matrix.beta.trace_product_with(H) + res
           H.destroy

        case ("gchf")
           HH.create(2*.n_bf,2*.n_bf); HH=ZERO
           H.create(.n_bf,.n_bf)
           .make_kinetic_energy_mx(H)
           HH.alpha_alpha_set_to(H)
           HH.beta_beta_set_to(H)
           H.destroy
           res = RE(.density_matrix.general_complex.trace_product_with(HH))
           HH.destroy

        case default
           DIE("unknown scf kind, "//trim(scf_kind))

      end

   end

   nuclear_attraction_energy result (res)
   ! Evaluates the SCF nuclear attraction energy as a trace of ".density_matrix"
   ! with the ".kinetic matrix".
      res :: REAL

   ENSURE(.scfdata.created,           "no scfdata")
   ENSURE(.density_matrix.created,    "no density matrix")
   ENSURE(.density_matrix.any_created,"no density matrix")

      scf_kind :: STR
      H :: MAT{REAL}*
      HH :: MAT{CPX}*

      res = ZERO

      scf_kind = .scfdata.scf_kind

      select case (scf_kind)

        case ("rhf","rks","xray_rhf","xray_rks", &
              "embedded_rhf","crystal_rhf","noninteracting-group-rhf")
           H.create(.n_bf,.n_bf)
           .make_nuclear_attraction_mx(H)
           res = .density_matrix.restricted.trace_product_with(H)
           H.destroy

        case ("uhf","uks","xray_uhf","xray_uks","rohf", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           H.create(.n_bf,.n_bf)
           .make_nuclear_attraction_mx(H)
           res = .density_matrix.alpha.trace_product_with(H)
           res = .density_matrix.beta.trace_product_with(H) + res
           H.destroy

        case ("gchf")
           HH.create(2*.n_bf,2*.n_bf); HH = ZERO
           H.create(.n_bf,.n_bf)
           .make_nuclear_attraction_mx(H)
           HH.alpha_alpha_set_to(H)
           HH.beta_beta_set_to(H)
           H.destroy
           res = RE(.density_matrix.general_complex.trace_product_with(HH))
           HH.destroy

        case default
           DIE("unknown scf kind, "//trim(scf_kind))

      end

   end

   charge_attraction_energy result (res)
   ! Evaluates the point-charge attraction energy as a trace of
   ! ".density_matrix" with the ".kinetic matrix".
      res :: REAL

   ENSURE(.scfdata.created,           "no scfdata")
   ENSURE(.density_matrix.created,    "no density matrix")
   ENSURE(.density_matrix.any_created,"no density matrix")

      scf_kind :: STR
      H,T :: MAT{REAL}*
      HH :: MAT{CPX}*

      ! Make sure .core_matrix is there
      .get_core_matrix

      res = ZERO

      scf_kind = .scfdata.scf_kind

      select case (scf_kind)

        case ("rhf","rks","xray_rhf","xray_rks", &
              "embedded_rhf","crystal_rhf","noninteracting-group-rhf")
           H.create(.n_bf,.n_bf)
           T.create(.n_bf,.n_bf)
           .make_nuclear_attraction_mx(H)
           .make_kinetic_energy_mx(T)
           H = .core_matrix.restricted - H - T
           res = .density_matrix.restricted.trace_product_with(H)
           T.destroy
           H.destroy

        case ("uhf","uks","xray_uhf","xray_uks","rohf", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           H.create(.n_bf,.n_bf)
           T.create(.n_bf,.n_bf)
           .make_nuclear_attraction_mx(H)
           .make_kinetic_energy_mx(T)
           H = .core_matrix.alpha - H - T
           res = .density_matrix.alpha.trace_product_with(H)
           res = .density_matrix.beta.trace_product_with(H) + res
           T.destroy
           H.destroy

        case ("gchf")
           HH.create(2*.n_bf,2*.n_bf); HH = ZERO
           H.create(.n_bf,.n_bf)
           T.create(.n_bf,.n_bf)
           .make_nuclear_attraction_mx(H)
           .make_kinetic_energy_mx(T)
           HH.alpha_alpha_set_to(H+T)
           HH.beta_beta_set_to(H+T)
           HH = .core_matrix.general_complex - HH
           T.destroy
           H.destroy
           res = RE(.density_matrix.general_complex.trace_product_with(HH))
           HH.destroy

        case default
           DIE("unknown scf kind, "//trim(scf_kind))

      end

   end

   scf_energy result (res)
   ! Evaluates the total SCF energy (including nuclear) as a trace of
   ! ".density_matrix" with the ".fock matrix".
      res :: REAL
   ENSURE(.density_matrix.created,    "no density matrix")
   ENSURE(.density_matrix.any_created,"no density matrix")
   ENSURE(.fock_matrix.created,    "no fock matrix")
   ENSURE(.fock_matrix.any_created,"no fock matrix")
      res = .scf_energy(.density_matrix,.fock_matrix)
   end

   scf_energy(P,F) result (res)
   ! Evaluates the total SCF energy (including nuclear) as a trace of
   ! "P" with the fock matrix "F".
      P,F :: OPMATRIX
      res :: REAL

   ENSURE(.scfdata.created, "no scf data")
   ENSURE(.atom.created, "no atoms")

      g,a :: INT
      I0 :: VEC{REAL}*
      I1 :: MAT{REAL}*

      res = ZERO

      select case  (.scfdata.scf_kind)

        case ("noninteracting-group-rhf")
           res = .scf_electronic_energy(P,F)
           do g = 1,.atom_group.dim
              res = res + .atom(.atom_group(g).atom_index).nuclear_repulsion_energy
           end

        case default
           res = .scf_electronic_energy(P,F) + .nuclear_repulsion_energy

      end

      ! Add finite field
      if (NOT .E_field.is_zero) &
         res = res - dot_product(.nuclear_dipole_moment,.E_field)

      ! Add finite local Lorentz fields
      ! Only dipole contributions are done
      ! The charge-charge terms are missing
      if (.scfdata.using_SC_Lorentz_fields) then
         I0.create(.n_atom)
         I1.create(3,.n_atom)
         .make_Lorentz_interactions(I0,I1)
         do a = 1,.n_atom
            res = res - .atom(a).charge*I0(a)
            res = res - dot_product(.atom(a).dipole,I1(:,a))
         end
         I1.destroy
         I0.destroy
      end

   end

   scf_electronic_energy(P,core) result (res)
   ! Evaluates the SCF electronic energy as a trace of density "P"
   ! with ".fock_matrix". If "core" is present and FALSE, the core
   ! contribution is not added.
      P :: OPMATRIX
      core :: BIN, optional
      res :: REAL

   ENSURE(.fock_matrix.created,    "no fock matrix")
   ENSURE(.fock_matrix.any_created,"no fock matrix")

      res = .scf_electronic_energy(P,.fock_matrix,core)

   end

   scf_electronic_energy(P,F,core) result (res)
   ! Evaluates the SCF electronic energy as a trace of density "P"
   ! with fock matrix "F". If "core" is present and FALSE, the core
   ! contribution is not added.  NOTE: this includes the DFT
   ! electronic energies, and it assumes that these energy
   ! contributions were calculated at the time of the formation of "F"
   ! from "P", and that they were stored in .scfdata.
      P,F :: OPMATRIX
      core :: BIN, optional
      res :: REAL

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.core_matrix.created(.scfdata.spinorbital_kind),"appropriate core_matrix missing")

      add_core :: BIN
      W :: OPMATRIX*

      add_core = TRUE
      if (present(core)) add_core = core

      W.create_copy(F)

      res = ZERO

      select case (.scfdata.scf_kind)

        case ("rhf","xray_rhf","embedded_rhf","crystal_rhf","noninteracting-group-rhf")
           if (add_core) W.plus(.core_matrix)
           res = HALF * P.restricted.trace_product_with(W.restricted)

        case ("rks","xray_rks")
           if (add_core) W.plus(.core_matrix)
           res = HALF * P.restricted.trace_product_with(W.restricted) &
               + .scfdata.dft_energy_correction

        case ("uhf","xray_uhf","rohf","pnd_uhf","xray_pnd_uhf")
           if (add_core) W.plus(.core_matrix)
           res = HALF * P.alpha.trace_product_with(W.alpha) &
               + HALF * P.beta.trace_product_with(W.beta)

        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
           if (add_core) W.plus(.core_matrix)
           res = HALF * P.alpha.trace_product_with(W.alpha) &
               + HALF * P.beta.trace_product_with(W.beta) &
               + .scfdata.dft_alpha_energy_correction &
               + .scfdata.dft_beta_energy_correction

        case ("gchf")
           if (add_core) W.plus(.core_matrix)
           res = HALF * RE(P.general_complex.trace_product_with(W.general_complex))

        case default
           DIE("unknown scf kind, "//trim(.scfdata.scf_kind))

      end

      ! Clean
      W.destroy

   end

   scf_electronic_energies result (res) ::: leaky
   ! Evaluates the SCF electronic energies as a trace of density "P" with
   ! fock matrix "F". In the case of UHF the energies are the E^alpha and E^beta
   ! energies. NOTE: this includes the DFT energy contributions.
      res :: VEC{REAL}*
      res => .scf_electronic_energies(.density_matrix,.fock_matrix)
   end

   scf_electronic_energies(P,F) result (res) ::: leaky
   ! Evaluates the SCF electronic energies as a trace of density "P" with
   ! fock matrix "F". In the case of UHF the energies are the E^alpha and E^beta
   ! energies. NOTE: this includes the DFT electronic energies, and it assumes
   ! that these energy contributions were calculated at the time of the
   ! formation of "F" from "P", and that they were stored in .scfdata.
      P,F :: OPMATRIX
      res :: VEC{REAL}*
   ENSURE(.scfdata.created,"no scfdata")

      W :: OPMATRIX*

      .get_core_matrix

      W.create_copy(F)

      select case (.scfdata.scf_kind)
        case ("rhf","xray_rhf","embedded_rhf","crystal_rhf","noninteracting-group-rhf")
           res.create(1)
           W.plus(.core_matrix)
           res(1) = HALF * P.restricted.trace_product_with(W.restricted)
        case ("rks","xray_rks")
           res.create(1)
           W.plus(.core_matrix)
           res(1) = HALF * P.restricted.trace_product_with(W.restricted) + .scfdata.dft_energy_correction
        case ("uhf","xray_uhf","rohf","pnd_uhf","xray_pnd_uhf")
           res.create(2)
           W.plus(.core_matrix)
           res(1) = HALF * P.alpha.trace_product_with(W.alpha)
           res(2) = HALF * P.beta.trace_product_with(W.beta)
        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
           res.create(2)
           W.plus(.core_matrix)
           res(1) = HALF * P.alpha.trace_product_with(W.alpha) + .scfdata.dft_alpha_energy_correction
           res(2) = HALF * P.beta.trace_product_with(W.beta)   + .scfdata.dft_beta_energy_correction
        case ("gchf")
           res.create(1)
           W.plus(.core_matrix)
           res(1) = HALF * RE(P.general_complex.trace_product_with(W.general_complex))
        case default
           DIE("unknown or unimplemented scf kind, "//trim(.scfdata.scf_kind))
      end

      W.destroy

   end

   expectation(X) result (res)
   ! Evaluates the expectation value of the matrix of the operator X
   ! with the current density matrix
      X :: MAT{REAL}
      res :: REAL

   ENSURE(X.is_square,"X operator matrix is not square")

      orb_kind :: STR

      res = ZERO

      orb_kind = .density_matrix.spinorbital_kind

      select case (orb_kind)

        case ("restricted")
           ENSURE(X.dim1==.n_bf,"wrong size, X")
           res = .density_matrix.restricted.trace_product_with(X)

        case ("unrestricted")
           ENSURE(X.dim1==.n_bf,"wrong size, X")
           res = .density_matrix.alpha.trace_product_with(X)
           res = .density_matrix.beta.trace_product_with(X) + res

        case ("general_complex")
           ENSURE(X.dim1==2*.n_bf,"wrong size, X")
           res = MAT{REAL}:trace_product_with(RE(.density_matrix.general_complex),X)

        case default
           DIE("unimplemented kind, "//trim(orb_kind))
      
      end

   end

! ==================
! Archiving routines
! ==================

   archive(opmatrix,archive_name,genre,with_lambda)
   ! Save "opmatrix" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      opmatrix :: OPMATRIX
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(opmatrix,genre)

      if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(opmatrix,genre)
        end
        end
      end

   end

   archive(opvector,archive_name,genre,with_lambda)
   ! Save "opvector" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      opvector :: OPVECTOR
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN
      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(opvector,genre)
      if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(opvector,genre)
        end
        end
      end
   end

   archive(item,archive_name,genre,with_lambda)
   ! Save "item" to an archive on disk with name "archive_name". 
      item :: REAL
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN
      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(item,genre)
      if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(item,genre)
        end
        end
      end
   end

   archive_scf_results
   ! Save the SCF results in various archives on disk

   ENSURE(.scfdata.created,"no scfdata")

      if (.scfdata.delete_all_archives) return

      .archive(.molecular_orbitals,"molecular_orbitals",with_lambda=TRUE)
      .archive(.orbital_energies,"orbital_energies",with_lambda=TRUE)
      .archive(.density_matrix,"density_matrix")

   end

   unarchive(opmatrix,archive_name,genre) ::: leaky
   ! Recover the "opmatrix" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opmatrix".
      opmatrix :: OPMATRIX*
      archive_name :: STR
      genre :: STR, optional
   ENSURE(opmatrix.any_created,"no opmatrix genre created")
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(opmatrix,genre)
   end

   unarchive(opvector,archive_name,genre) ::: leaky
   ! Recover the "opvector" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opvector".
      opvector :: OPVECTOR
      archive_name :: STR
      genre :: STR, optional
   ENSURE(opvector.any_created,"no opvector genre created")
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(opvector,genre)
   end

   unarchive(item,archive_name,genre) ::: leaky
   ! Recover the "item" from an archive on disk with name "archive_name".
      item :: REAL
      archive_name :: STR
      genre :: STR, optional
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(item,genre)
   end

   unarchive(archive_name,genre) ::: template
   ! Recover the object from an archive on disk
      archive_name,genre :: STR, optional
   ENSURE(.basis_info_made,"no basis set info")
      name :: STR
      name = "NAME"
      if (present(archive_name)) name = archive_name
      if (.NAME.destroyed) then
        ENSURE(present(genre),"missing genre")
        .NAME.create(.n_bf,genre)
      end
      .unarchive(.NAME,name,genre)
   end

   archive_exists(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      archive_name,genre :: STR
      res :: BIN
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name,genre)
      res = archive.exists
   end

   archive_doesnt_exist(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      archive_name,genre :: STR
      res :: BIN
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name,genre)
      res = NOT archive.exists
   end

! ====================
! SCF cleanup routines
! ====================

   cleanup_scf ::: leaky
   ! Clean up the SCF files produced. 
   ! Keep only MOs and density matrix

      .delete_tmp_scf_archives
      .delete_tmp_scf_matrices

      if (.scfdata.created) then

         .scfdata.diis.reset_iteration_defaults

         if (.scfdata.delete_scf_archives) then
            .delete_scf_archives(keep_MOs=TRUE,keep_DM=TRUE)
            .delete_scf_integrals
         end

      end

      ! Clean
      .scfdata.table_info.destroy
      .scfdata.table.destroy
      .max_I.destroy 

   end

   destroy_scf_results(keep_MOs,keep_DM) ::: leaky
   ! Destroy the SCF results in memory
      keep_MOs,keep_DM :: BIN, optional

      delete_MOs,delete_DM :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs
      delete_DM = TRUE
      if (present(keep_DM))  delete_DM  = NOT keep_DM

      if (delete_MOs) .molecular_orbitals.destroy
      if (delete_DM)  .density_matrix.destroy

      .orbital_energies.destroy
      .fock_matrix.destroy

   end

   delete_scf_archives(keep_MOs,keep_DM) ::: recursive
   ! Delete any matrices stored on disk.
      keep_MOs,keep_DM :: BIN, optional

      archive :: ARCHIVE
      delete_MOs,delete_DM :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      delete_DM = TRUE
      if (present(keep_DM))  delete_DM  = NOT keep_DM

      archive.set_defaults

      if (delete_MOs) then
      archive.set(.name,"molecular_orbitals");          archive.delete_all_genres
      archive.set(.name,"orbital_energies");            archive.delete_all_genres
      end

      if (delete_DM) then
      archive.set(.name,"density_matrix");              archive.delete_all_genres
      end

      archive.set(.name,"fock_matrix");                 archive.delete_all_genres
      archive.set(.name,"natural_orbitals");            archive.delete_all_genres
      archive.set(.name,"occupation_numbers");          archive.delete_all_genres
      archive.set(.name,"energy");                      archive.delete_all_genres

      archive.set(.name,"promolecule_density_matrix");  archive.delete_all_genres
      archive.set(.name,"progroup_density_matrix");     archive.delete_all_genres
      archive.set(.name,"progroup_molecular_orbitals"); archive.delete_all_genres

      archive.set(.name,"U_electric_dipole");           archive.delete_all_genres

      ! WARNING: These two below are recursive
      .delete_atom_scf_archives 
      .delete_group_scf_archives 

      .delete_lambda_scf_archives(keep_MOs)

   end

   delete_lambda_scf_archives(keep_MOs)
   ! Delete any lambda type archives stored on disk.
      keep_MOs :: BIN, optional

      l,l_max :: REAL
      l_str :: STR(len=5)
      archive :: ARCHIVE
      delete_MOs :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      if (NOT delete_MOs) then
         return
      end
      if (.scfdata.destroyed) then
         return
      end
      if (NOT .scfdata.is_constrained_scf) then
         return
      end

      archive.set_defaults
      l = .scfdata.initial_lambda
      l_max = .scfdata.lambda_max + l
      do 
         if (l>l_max) exit
         l_str = trim(l.to_str("f5.3"))
         archive.set(.name,"molecular_orbitals,lambda="//trim(l_str)); archive.delete_all_genres
         archive.set(.name,"orbital_energies,lambda="//trim(l_str));   archive.delete_all_genres
         l = l + .scfdata.lambda_step
      end

   end

   delete_atom_scf_archives ::: recursive, leaky
   ! Delete the atom SCF archives, if they exist.

      a :: INT
      mol :: MOLECULE*

      if (.n_atom_kind<=0) return

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Delete
         mol.create
         mol.name = .atom(a).chemical_symbol
         mol.delete_scf_archives  
         mol.destroy

      end

   end

   delete_group_scf_archives ::: recursive
   ! Delete any group type SCF archives.
      g :: INT

      if (.atom_group.destroyed) return

      do g = 1,.atom_group.dim
         if (.atom_group(g).mol.destroyed) cycle
         .atom_group(g).mol.delete_scf_archives
      end

   end

   delete_tmp_scf_archives
   ! Delete any temporary SCF archives.
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,"j_matrix");               archive.delete_all_genres
      archive.set(.name,"constraint_matrix");      archive.delete_all_genres
   end

   delete_scf_MO_archive
   ! Delete the SCF MO archives
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,"molecular_orbitals"); archive.delete_all_genres
      archive.set(.name,"orbital_energies");   archive.delete_all_genres
   end

   delete_scf_integrals ::: leaky
   ! Delete all integral files. This is required whenever the geometry is
   ! changed.
      archive :: ARCHIVE

      ! Delete integral archives
      archive.set_defaults
      archive.set(.name,"eri_integrals");     archive.delete_all_genres
      archive.set(.name,"eri_index");         archive.delete_all_genres

      ! Delete in-core integrals (leaky)
      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .core_matrix.destroy

   end

   delete_archive(name)
   ! Delete the archive called "name"
      name :: STR, IN
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,name); archive.delete_all_genres
   end

   delete_tmp_scf_matrices
   ! Delete any temporary matrices stored in memory.
      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy
   end

! =========================
! Canonicalisation routines
! =========================

   canonicalize_MOs
   ! Generate the Fock matrix from the molecular orbitals and diagonalise it
   ! on the occupied-occupied block to get the canonical molecular orbitals.
   ENSURE(.molecular_orbitals.created,"need old MOs!")
   ENSURE(.orbital_energies.created,"need old energies")
      scf_kind :: STR
      .make_scf_density_matrix
      .make_fock_matrix
      scf_kind = .scfdata.scf_kind
      select case (scf_kind)
        case ("rhf","rks","rohf","xray_rhf","xray_rks","noninteracting-group-rhf")
           .orbital_energies.destroy
           .orbital_energies.create(.n_bf,"restricted")
           .canonicalize_r_MO(.orbital_energies.restricted, &
                              .molecular_orbitals.restricted, &
                              .fock_matrix.restricted,.n_e/2)
           stdout.flush
           stdout.text("Canonicalized MO energies:")
           stdout.put(.orbital_energies.restricted)
        case ("uhf","uks","xray_uhf","xray_uks")
           .orbital_energies.destroy
           .orbital_energies.create(.n_bf,"unrestricted")
           .canonicalize_r_MO(.orbital_energies.alpha, &
                              .molecular_orbitals.alpha, &
                              .fock_matrix.alpha,.n_a)
           .canonicalize_r_MO(.orbital_energies.beta, &
                              .molecular_orbitals.beta, &
                              .fock_matrix.beta,.n_b)
           stdout.flush
           stdout.text("Canonicalized alpha MO energies:")
           stdout.put(.orbital_energies.alpha(1:.n_a))
           stdout.flush
           stdout.text("Canonicalized beta MO energies:")
           stdout.put(.orbital_energies.beta(1:.n_b))
        case default
           DIE("unknown scf kind, "//trim(scf_kind))
      end
   end

   canonicalize_r_MO(MO_energies,MO,F,n)
   ! Digaonalise the Fock matrix "F" in the occupied-occupied and
   ! virtual-virtual block of the molecular orbitals "MO", and reset the
   ! occupied "MO_energies".
      MO_energies :: VEC{REAL}
      MO,F :: MAT{REAL}
      n :: INT

      G,U,MO_old :: MAT{REAL}*
      v :: INT

     ! Canonicalise the occ-occ block
     G.create(n,n)
     U.create(n,n)
     MO_old.create(.n_bf,n)
     MO_old = MO(:,1:n)
     F.change_basis_to(G,MO_old)
     G.solve_eigenproblem(MO_energies(1:n),U)
     MO(:,1:n).to_product_of(MO_old,U)
     MO_old.destroy
     U.destroy
     G.destroy

     ! Canonicalise the vir-vir block
     v = .n_bf - n
     G.create(v,v)
     U.create(v,v)
     MO_old.create(.n_bf,v)
     MO_old = MO(:,n+1:)
     F.change_basis_to(G,MO_old)
     G.solve_eigenproblem(MO_energies(n+1:),U)
     MO(:,n+1:).to_product_of(MO_old,U)
     MO_old.destroy
     U.destroy
     G.destroy

   end

! ==============================
! Initial orbital guess routines
! ==============================

   get_initial_guess ::: leaky, recursive
   ! Get the initial guess for the ".density_matrix" and
   ! ".molecular_orbitals" If .scfdata.initial_mos is set, it overides
   ! .initial_density.
   ENSURE(.scfdata.created,"no scfdata")
      select case(.scfdata.initial_mos)
         case("--using density--"); .get_initial_density
         case default;              .get_initial_MOs
      end
   end

   get_initial_MOs ::: leaky
   ! Get the initial guess for the .molecular_orbitals
   ! Convert the .molecular_orbitals, if neccesary.
      select case (.scfdata.initial_mos)
         case("existing            "); ENSURE(.molecular_orbitals.created(.scfdata.molecular_orbital_kind),"no molecular orbitals")
         case("restricted          "); .read_old_MOs_guess
         case("unrestricted        "); .read_old_MOs_guess
         case("general             "); .read_old_MOs_guess
         case("restricted_complex  "); .read_old_MOs_guess
         case("complex_unrestricted"); .read_old_MOs_guess
         case("unrestricted_complex"); .read_old_MOs_guess
         case("general_complex     "); .read_old_MOs_guess
         case("complex_general     "); .read_old_MOs_guess
         case default;   UNKNOWN(.scfdata.initial_mos)
      end
   end

   read_old_MOs_guess ::: leaky
   ! Get the initial guess for the .molecular_orbitals by reading an old archive
   ! of .molecular_orbitals, and then make the SCF density matrix as well.
   ! Convert the .molecular_orbitals, if neccesary.
      arch :: ARCHIVE
      .molecular_orbitals.destroy
      .molecular_orbitals.create(.n_bf,.scfdata.initial_mos)
      arch.set(.name,"molecular_orbitals",genre=.scfdata.initial_mos)
      arch.read(.molecular_orbitals)
      .molecular_orbitals.convert_to(.scfdata.molecular_orbital_kind,.n_a,.n_b, &
                                     .scfdata.quantization_axis)
      ! Re-orthonormalise ?
    ! if (.scfdata.created) then
    ! if (.scfdata.initial_mos=="restricted") then
    ! .symorthonormalise_occupied_MOs 
    ! end
    ! end

      .make_scf_density_matrix
      .orbital_energies.destroy
      .orbital_energies.create(.n_bf,genre=.scfdata.orbital_energies_kind)

   end

   make_atom_MOs_guess ::: leaky
   ! Get the initial guess for the .molecular_orbitals by getting the highest
   ! occupied restricted natural orbitals from the sum of atomic densities guess
   ! for the density matrix. Convert these .molecular_orbitals, if neccesary.
   ! Also make the SCF .density_matrix from these .molecular_orbitals.
      orb_kind :: STR
      arch :: ARCHIVE

      .make_promolecule_density

      if (.density_matrix.spinorbital_kind/="restricted") then
         arch.set(.name,"promolecule_density_matrix", genre="restricted")
         .density_matrix.destroy("restricted")
         arch.read(.density_matrix)
      end

      .make_natural_orbitals
      .put_natural_orbitals
      .assign_MOs_to_NOs

      orb_kind = .scfdata.molecular_orbital_kind
      .molecular_orbitals.convert_to(orb_kind,.n_a,.n_b,.scfdata.quantization_axis)
      .make_scf_density_matrix

      .orbital_energies.create(genre=.scfdata.orbital_energies_kind)

   end

   get_initial_density ::: leaky, recursive
   ! Get the initial guess for the ".density_matrix"

   ENSURE(.scfdata.created,"no scfdata")

      .scfdata.set_is_guess(TRUE)

      select case (.scfdata.initial_density)

         case("core                "); .make_core_guess
         case("fock                "); .make_fock_guess
         case("promolecule         "); .make_promolecule_guess
         case("progroup            "); .make_progroup_guess

         case("restricted          "); .make_density_guess
         case("unrestricted        "); .make_density_guess
         case("general             "); .make_density_guess
         case("restricted_complex  "); .make_density_guess
         case("complex_unrestricted"); .make_density_guess
         case("unrestricted_complex"); .make_density_guess
         case("general_complex     "); .make_density_guess
         case("complex_general     "); .make_density_guess

         case default;  DIE("unknown density, "//trim(.scfdata.initial_density))

      end

      .scfdata.set_is_guess(FALSE)

   end

   make_density_guess ::: leaky
   ! Read an old .density_matrix of type "initial_guess" and use it to
   ! make initial .molecular_orbitals to start an scf calculation.
   ! Convert the .density_matrix, if neccesary.
      arch :: ARCHIVE

      .density_matrix.destroy
      .density_matrix.create(.n_bf,.scfdata.initial_density)

      arch.set(.name,"density_matrix")
      arch.read(.density_matrix,genre=.scfdata.initial_density)

      .density_matrix.convert_to(newkind = .scfdata.spinorbital_kind)

      .make_fock_matrix  ! Make a fock matrix

      .make_fock_guess   ! Get a reasonable set of starting MO's

   end

   make_core_guess ::: leaky
   ! Do a core scf for the ".density_matrix", ".molecular_orbitals" and
   ! ".orbital_energies". Also makes the restricted ".core_matrix".
   ENSURE(.scfdata.created,"no scfdata")

      orb_kind :: STR

      ! Create and initialise
      .orbital_energies.destroy
      .orbital_energies.create(.n_bf,"restricted")
      .molecular_orbitals.destroy
      .molecular_orbitals.create(.n_bf,"restricted")

      ! Get restricted core and overlap matrices
      .get_r_core_matrix
      .get_overlap_matrix

      ! Get the guess orbitals
      .make_r_guess_from(.core_matrix.restricted, &
                         .orbital_energies.restricted, &
                         .molecular_orbitals.restricted)
      .put_debug(.molecular_orbitals.restricted,"make_r_core_guess: molecular_orbitals")
      .put_debug(.orbital_energies.restricted,"make_r_core_guess: orbital_energies")

      ! Convert the orbitals to the right kind
      orb_kind = .scfdata.orbital_energies_kind
      .orbital_energies.convert_to(orb_kind)
      orb_kind = .scfdata.molecular_orbital_kind
      .molecular_orbitals.convert_to(orb_kind,.n_a,.n_b,.scfdata.quantization_axis)

      ! Delete unnecessary core matrix
      if (.scfdata.spinorbital_kind/="restricted") .core_matrix.destroy("restricted")

      ! Make the orbitals
      .make_scf_density_matrix
      .make_fock_matrix  ! Make a fock matrix (only to get MO's)
      .make_fock_guess   ! Get a reasonable set of starting MO's

   end

   make_r_guess_from(fock_matrix,MO_energies,MO) ::: private
   ! Make initial "MO's" and "MO_energies" from a given "fock_matrix"
   ! ... for cartesian basis functions
      fock_matrix :: MAT{REAL}, IN
      MO :: MAT{REAL}, OUT
      MO_energies :: VEC{REAL}, OUT

 ! ENSURE(fock_matrix.is_square,"non-square fock matrix")
 ! ENSURE(fock_matrix.dim1==.n_bf,"fock matrix not n_bf sized")

      F,R :: MAT{REAL}* DEFAULT_NULL

      !  H~ = S^-1/2 H S^-1/2
      F.create(.n_bf,.n_bf)
      R.create(.n_bf,.n_bf) 
      .make_overlap_inverse_sqrt(R)
      fock_matrix.change_basis_to(F,R)

      if (.scfdata.created) &
      .shift_dependence_from_r(F)

      !  Solve for c~
      F.solve_eigenproblem(MO_energies,MO)
      .put_debug(MO_energies,"make_r_cart_guess_from: MO_energies")

      !  c  = S^-1/2 c~
      F.to_product_of(R,MO)
      MO = F

      ! Clean
      R.destroy
      F.destroy

   end

   make_gc_guess_from(fock_matrix,MO_energies,MO) ::: private
   ! Make initial "MO's" and "MO_energies" from a given "fock_matrix"
   ! ... for cartesian basis functions
      fock_matrix :: MAT{REAL}, IN
      MO :: MAT{REAL}, OUT
      MO_energies :: VEC{REAL}, OUT

      F,R :: MAT{REAL}* DEFAULT_NULL
      n :: INT

      n = 2*.n_bf

      !  H~ = S^-1/2 H S^-1/2
      F.create(n,n)
      R.create(n,n) 
      .make_overlap_inverse_sqrt(R)
      fock_matrix.change_basis_to(F,R)

      if (.scfdata.created) &
      .shift_dependence_from_r(F)

      !  Solve for c~
      F.solve_eigenproblem(MO_energies,MO)
      .put_debug(MO_energies,"make_gc_guess_from: MO_energies")

      !  c  = S^-1/2 c~
      F.to_product_of(R,MO)
      MO = F

      ! Clean
      R.destroy
      F.destroy

   end

   make_promolecule_guess ::: leaky
   ! Make a ".density matrix" and fock matrix from the sum of atomic densities.
   ! Then get initial orbitals from this fock matrix, and make the density
   ! corresponding to these initial orbitals.
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.scfdata.scf_kind/="rohf","promolecule guess not available for ROHF")
      .make_promolecule_density
      .make_fock_matrix       ! Make a fock matrix (only to get MO's)
      .make_fock_guess        ! Get a reasonable set of starting MO's
   end

   make_promolecule_density ::: leaky
   ! Make the ANO densities and add them together.
      .make_ANO_data
      .make_ANO_interpolators
      .add_ANO_densities
      .density_matrix.convert_to(.scfdata.spinorbital_kind,factor=HALF)
      .put_debug(.density_matrix,"make_promolecule_density: density matrix")
   end

   add_ANO_densities ::: leaky
   ! Add the ANO densities to make the total density matrix
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom(1).ANO_data_made,"no ANO data")

      asym :: REAL
      k,a,b,f,l :: INT
      atom_a,atom_b :: ATOM*
      D,DD :: MAT{REAL}*

      ! Recreate the density
      .density_matrix.destroy
      .density_matrix.create(.n_bf,"restricted")

      ! Set to zero
      D => .density_matrix.restricted      
      D = ZERO

      ! Add 'em up
      do a = 1,.n_atom

        atom_a => .atom(a)

        ! Unique atom?
        if (NOT atom_a.is_unique_kind) cycle
        k = atom_a.kind

        ! Unique atom DM
        DD => atom_a.density_matrix.restricted

        ! Transfer non-unique atoms
        do b = a,.n_atom

           atom_b => .atom(b)

           if (atom_b.kind/=k) cycle

           f = .first_basis_fn_for_atom(b)
           l =  .last_basis_fn_for_atom(b)
           D(f:l,f:l) =  DD

        end

      end

      ! Check for asymmetry
      if (NOT D.is_symmetric) then
        asym = maxval(abs(D-transpose(D)))
        WARN("promolecule density is not symmetric")
        WARN("Maximum asymmetry = "//trim(asym.to_str("e10.3")))
      end      
      D.symmetric_reflect

   end

   make_progroup_guess ::: leaky
   ! Make a .density matrix and .fock_matrix from the sum of noninteracting
   ! atom_group densities. Then get initial orbitals from this fock matrix,
   ! and make the density corresponding to these initial orbitals.
   ENSURE(.scfdata.scf_kind/="rohf","atom guess not available for ROHF")
      .get_progroup_density
      .make_fock_matrix       ! Make a fock matrix (only to get MO's)
      .make_fock_guess        ! Get a reasonable set of starting MO's
   end

   get_progroup_density ::: leaky
   ! Reads .density_matrix from the archive, otherwise makes it and
   ! writes to the arch.
      arch :: ARCHIVE

      arch.set(.name,"progroup_density_matrix", genre="restricted")

      if (arch.exists) then
         .density_matrix.destroy
         .density_matrix.create(.n_bf,"restricted")
         arch.read(.density_matrix)
      else
         .make_progroup_density
      end

      .density_matrix.convert_to(.scfdata.spinorbital_kind,factor=HALF)

   end

   make_progroup_density(MOs,output) ::: leaky
   ! Make a ".density matrix" from the sum of atom_group densities.
   ! If "MOs" is present and true, make ".molecular_orbitals" which
   ! are the columns of orbitals from each group and also make the
   ! ".occupation_numbers" vector set to 2 for the occupied group MO's.
   ! If output is present and FALSE the density matrix is not archived
      MOs :: BIN, optional
      output :: BIN, optional

   ENSURE(.atom_group.created,"no atom_group info")
   ENSURE(.scfdata.created,"no scfdata")

      do_output,do_MOs :: BIN
      g,a,b,aa,bb,faa,laa,fbb,lbb,fa,la,fb,lb, ms,mf, no :: INT
      mol :: MOLECULE*
      arch :: ARCHIVE
      genre :: STR

      ! Optional switches
      do_output=TRUE
      if (present(output)) do_output=output

      do_MOs=FALSE
      if (present(MOs)) do_MOs=MOs

      ! Destroy this density matrix
      DIE_IF(.scfdata.spinorbital_kind/="restricted","only for restricted densities so far")
      .density_matrix.destroy
      .density_matrix.create(.n_bf,.scfdata.spinorbital_kind)
      .density_matrix.restricted = ZERO

      ! Destroy the MO's if requested
      if (do_MOs) then
      .molecular_orbitals.destroy
      .molecular_orbitals.create(.n_bf,"restricted")
      .molecular_orbitals.restricted = ZERO
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"restricted")
      .occupation_numbers.restricted = ZERO
      end

      ! Make the ANO data: atom groups need it
      .make_ANO_data

      mf = 0

      ! Loop over atom group "g"
      do g = 1,.atom_group.dim 

         ! Set up a molecule for this group of atoms
         mol => .atom_group(g).mol
         DIE_IF(mol.destroyed,"molecule group "//trim(g.to_str)//" not defined!")

         ! Skip SCF for atoms without electrons
         if (mol.no_of_electrons < 1) cycle

         ! Set SCF options
         if (.atom_group(g).n_atoms>1) then
            genre = mol.scfdata.spinorbital_kind
            if (mol.archive_exists("molecular_orbitals",genre)) then;
               mol.scfdata.set_initial_MOs(genre)
            else
               mol.scfdata.set_initial_density("promolecule")
            end
         end

         ! Do the SCF
         mol.scf

         ! Make the AO density matrix for this group
         if (.atom_group(g).n_MOs>0) then; 
            stdout.show("using fewer MOs =",.atom_group(g).n_MOs)
            stdout.text("normal P:")
            mol.make_ao_density_matrix
            stdout.put(mol.density_matrix.restricted)
            stdout.text("reduced P:")
            mol.make_scf_density_matrix(method="progroup",n_a=.atom_group(g).n_MOs)
            stdout.put(mol.density_matrix.restricted)
         else;                             
            mol.make_ao_density_matrix
         end

         ! Copy this group density matrix
         do a = 1,.atom_group(g).n_atoms
         do b = 1,.atom_group(g).n_atoms
            aa  = .atom_group(g).atom_index(a)
            bb  = .atom_group(g).atom_index(b)
            faa = .first_basis_fn_for_atom(aa)
            fbb = .first_basis_fn_for_atom(bb)
            laa = .last_basis_fn_for_atom(aa)
            lbb = .last_basis_fn_for_atom(bb)
            fa  = mol.first_basis_fn_for_atom(a)
            fb  = mol.first_basis_fn_for_atom(b)
            la  = mol.last_basis_fn_for_atom(a)
            lb  = mol.last_basis_fn_for_atom(b)
            .density_matrix.restricted(faa:laa,fbb:lbb) = &
            .density_matrix.restricted(faa:laa,fbb:lbb) &
            + mol.density_matrix.restricted(fa:la,fb:lb)
         end
         end

         if (.debugging("make_progroup_density")) then
            stdout.flush
            stdout.text("Group "//trim(g.to_str)//" density_matrix:")
            stdout.put(mol.density_matrix.restricted)
         end

         ! Copy this group's MO's and occupations
         if (do_MOs) then

            DIE_IF(mol.molecular_orbitals.destroyed,"no MOs")
            DIE_IF(mol.molecular_orbitals.restricted.destroyed,"no restricted MOs")

            ms = mf + 1
            mf = mf + mol.n_bf
            do a = 1,.atom_group(g).n_atoms
               aa  = .atom_group(g).atom_index(a)
               faa = .first_basis_fn_for_atom(aa)
               laa = .last_basis_fn_for_atom(aa)
               fa  = mol.first_basis_fn_for_atom(a)
               la  = mol.last_basis_fn_for_atom(a)
               .molecular_orbitals.restricted(faa:laa,ms:mf) = &
               .molecular_orbitals.restricted(faa:laa,ms:mf) &
               + mol.molecular_orbitals.restricted(fa:la,:)
            end
            no = mol.n_e/2
            .occupation_numbers.restricted(ms:ms+no-1) = TWO

            if (.debugging("make_progroup_density")) then
               stdout.flush
               stdout.text("Group "//trim(g.to_str)//" MO's:")
               stdout.put(mol.molecular_orbitals.restricted)
            end

         end

         ! Clean up files
         mol.cleanup_scf

      end

      if (do_output) then
         arch.set(.name,"progroup_density_matrix", genre="restricted")
         arch.write(.density_matrix, genre="restricted")
         if (.debugging("make_progroup_density")) then
            stdout.flush
            stdout.text("progroup density:")
            stdout.put(.density_matrix.restricted)
         end
      end

      if (do_output AND do_MOs) then
         arch.set(.name,"progroup_molecular_orbitals", genre="restricted")
         arch.write(.molecular_orbitals, genre="restricted")
         if (.debugging("make_progroup_density")) then
            stdout.flush
            stdout.text("progroup occupations:")
            stdout.put(.occupation_numbers.restricted)
            stdout.flush
            stdout.text("progroup MO's:")
            stdout.put(.molecular_orbitals.restricted)
         end
      end

   end

   make_group_energies(g,E_SCF,E_T,E_Z,E_C,E_K,fac)
   ! Assuming group densities exist (see .make_progroup_density), then
   ! for group number "g" make the group SCF energy "E_SCF", the group
   ! kinetic energy "E_T", the group nuclear attraction energy "E_Z",
   ! the group coulomb energy "E_C", and the group exchange energy
   ! "E_K". If "fac" is present, multiply all the energy values by
   ! this factor.
      g :: INT
      E_SCF,E_T,E_Z,E_C,E_K :: REAL
      fac :: REAL, optional

   ENSURE(.atom_group.created,"no atom_group info")
   ENSURE(g<=.atom_group.dim,"group out of range")
   ENSURE(.atom_group(g).mol.created,"no atom_group molecule")
   ENSURE(.atom_group(g).mol.scfdata.created,"no atom_group molecule scfdata")
   ENSURE(.atom_group(g).mol.spin_multiplicity==1,"only singlets allowed for now")

      mol :: MOLECULE*
      P,C,K :: MAT{REAL}*

      ! Get the molecule from group "g"
      mol => .atom_group(g).mol

      E_SCF = ZERO
      E_T = ZERO
      E_Z = ZERO
      E_C = ZERO
      E_K = ZERO

      if (mol.no_of_electrons >= 1) then

         ! Get the SCF energy
         E_SCF = .atom_group(g).mol.scfdata.energy

         ! Get the kinetic energy
         E_T = .atom_group(g).mol.scfdata.kinetic_energy

         ! Get the nuclear attraction energy
         E_Z = .atom_group(g).mol.scfdata.nuclear_attraction_energy

         ! Get the Coulomb/exchange energy
         P => .atom_group(g).mol.density_matrix.restricted
         C.create(mol.n_bf,mol.n_bf)
         K.create(mol.n_bf,mol.n_bf)
         mol.make_r_JK_nosym(C,K,P)
         E_C = HALF*C.trace_product_with(P)
         E_K = -QUARTER*K.trace_product_with(P)
         K.destroy
         C.destroy

         ! Clean up disk
         mol.delete_scf_integrals

      end

      if (present(fac)) then
        E_SCF = fac*E_SCF
        E_T   = fac*E_T
        E_Z   = fac*E_Z
        E_C   = fac*E_C
        E_K   = fac*E_K
      end

   end

   make_fock_guess ::: leaky
   ! From an initial .fock_matrix make the .molecular_orbitals, and
   ! .orbital_energies.  Then make the .density_matrix from these orbitals.
   ! Destroy .fock_matrix afterwards
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.fock_matrix.created(.scfdata.spinorbital_kind),"need an initial fock matrix")

      orb_kind :: STR
      e :: VEC{REAL}*
      MO,F :: MAT{REAL}*
      MOc,Fc :: MAT{CPX}*

      ! Clean
      .molecular_orbitals.destroy
      .orbital_energies.destroy

      ! Get core and overlap
      .get_overlap_matrix

      !  F~ = S^-1/2 F S^-1/2
      !  c  = S^-1/2 c~

      orb_kind = .scfdata.scf_kind

      select case (orb_kind)

        case ("rhf","rks","rohf","xray_rhf","xray_rks","noninteracting-group-rhf")
           .orbital_energies.create(.n_bf,"restricted")
           .molecular_orbitals.create(.n_bf,"restricted")
           e  => .orbital_energies.restricted
           MO => .molecular_orbitals.restricted
           F  => .fock_matrix.restricted
           .make_r_guess_from(F,e,MO)
           .put_debug(e, "make_fock_guess: e")
           .put_debug(MO,"make_fock_guess: MO")

        case ("uhf","uks","xray_uhf","xray_uks", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           .orbital_energies.create(.n_bf,"unrestricted")
           .molecular_orbitals.create(.n_bf,"unrestricted")
           e  => .orbital_energies.alpha
           MO => .molecular_orbitals.alpha
           F  => .fock_matrix.alpha
           .make_r_guess_from(F,e,MO)
           .put_debug(e, "make_fock_guess: ea")
           .put_debug(MO,"make_fock_guess: MOa")
           e  => .orbital_energies.beta
           MO => .molecular_orbitals.beta
           F  => .fock_matrix.beta
           .make_r_guess_from(F,e,MO)
           .put_debug(e, "make_fock_guess: eb")
           .put_debug(MO,"make_fock_guess: MOb")

        case ("gchf")
           .orbital_energies.create(.n_bf,"general")
           .molecular_orbitals.create(.n_bf,"general_complex")
           e   => .orbital_energies.general
           MOc => .molecular_orbitals.general_complex
           Fc  => .fock_matrix.general_complex
           .make_gc_fock_guess(e,MOc,Fc)
           .put_debug(e,  "make_fock_guess: gchf guess eigenvalues before reorder")
           .put_debug(MOc,"make_fock_guess: gchf guess complex MOs before reorder")
           .MO_gc_reorder(e,MOc)
           .put_debug(e,  "make_fock_guess: gchf guess eigenvalues after reorder")
           .put_debug(MOc,"make_fock_guess: gchf guess complex MOs after reorder")

        case default;  DIE("unknown kind, "//trim(orb_kind))

      end

      orb_kind = .scfdata.spinorbital_kind
      .fock_matrix.destroy(orb_kind)

      .make_scf_density_matrix

      .put_debug(orb_kind,"make_fock_guess: orb_kind")
      if (.density_matrix.restricted.created) then
      .put_debug(.density_matrix.restricted,"make_fock_guess: restricted density_matrix")
      end

   end

   make_gc_fock_guess(MO_energies,MO,fock_matrix)
   ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
   ! a given complex general "fock_matrix".
      MO_energies :: VEC{REAL}
      MO,fock_matrix :: MAT{CPX}

   ENSURE(.overlap_matrix.created,"no overlap matrix")

      S,R :: MAT{REAL}*
      H :: MAT{CPX}*

      R.create(2*.n_bf,2*.n_bf)
      S.create(.n_bf,.n_bf)

      ! S = S^-1/2, R = big inverse S
      .make_overlap_inverse_sqrt(S)

      ! R = big inverse S
      R = ZERO
      R.alpha_alpha_set_to(S)
      R.beta_beta_set_to(S)
      S.destroy

      ! H = Fock matrix
      H.create(2*.n_bf,2*.n_bf)
      H = fock_matrix

      ! H = S^-1/2 F S^-1/2
      H.change_basis_using(R)
      .put_debug(H,"make_gc_fock_guess: H matrix in orthonormalised AO basis")
      H.diagonalise_by_jacobi(MO_energies,MO)
      if (.debugging("make_gc_fock_guess: H diagonalisation check")) then
        H.change_basis_using(MO)
        stdout.text("make_gc_fock_guess: H diagonalisation check:")
        stdout.put(H)
        stdout.put(MO_energies)
      end

      !  c  = S^-1/2 c~
      H.to_product_of(R,MO)
      MO = H

      H.destroy
      R.destroy
   end

! ==========================
! DIIS/Orbital extrapolation
! ==========================

   make_diis_error_length(length)
   ! Make the SCF error vector from the current fock_matrix and
   ! density_matrix, and return the error "length".  Useful for reporting the
   ! error length.
      length :: REAL

   ENSURE(.fock_matrix.created,"no fock matrix")
   ENSURE(.fock_matrix.any_created,"no fock matrix")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.any_created,"no density matrix")

      .get_overlap_matrix
      length = MOLECULE::diis_error_length(.fock_matrix,.density_matrix,.overlap_matrix)
      .scfdata.diis.set_error_length(length)
      .scfdata.set_diis_error(length)

   end

   extrapolate_fock_matrix
   ! Extrapolate the fock matrix, currently only using DIIS.

   ENSURE(.scfdata.created,"no scf data")
   ENSURE(.fock_matrix.created,"no fock matrix")
   ENSURE(.density_matrix.created,"no density matrix")

      spinorbital_kind,scf_kind :: STR
      error :: REAL
      C :: OPMATRIX*
      dim :: INT

      if (NOT .scfdata.using_diis) return

      .scfdata.set_diis_error(ZERO)

      if (NOT .fock_matrix.any_created) return

      ! Get overlap if not there
      .get_overlap_matrix

      ! Spinorbital kind before compression
      spinorbital_kind = .fock_matrix.spinorbital_kind

      ! Make commutator
      C.create(.fock_matrix.n_bf,spinorbital_kind)
      MOLECULE:make_diis_commutator(C,.fock_matrix,.density_matrix,.overlap_matrix)

      ! Compress
      C.compress
      .fock_matrix.compress

      ! Extrapolate compressed entities
      scf_kind = .scfdata.scf_kind
      select case (scf_kind)

         case ("rhf","rks","embedded_rhf","crystal_rhf","noninteracting-group-rhf")
            dim = C.triangle.dim
            .scfdata.diis.extrapolate(.fock_matrix.triangle,C.triangle,dim)
            error = C.triangle.norm

         case ("xray_rhf","xray_rks")
            dim = C.triangle.dim
            .scfdata.diis.extrapolate(.fock_matrix.triangle,C.triangle,dim)
            error = C.triangle.norm

         case ("rohf")
            dim = C.triangle.dim
            .scfdata.diis.extrapolate(.fock_matrix.triangle,C.triangle,dim)
            error = C.triangle.norm

         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
            dim = C.triangle.dim
            .scfdata.diis.extrapolate(.fock_matrix.triangle,C.triangle,dim)
            error = C.triangle.norm

         case ("gchf")
            dim = C.square.dim
            .scfdata.diis.extrapolate(.fock_matrix.square,C.square,dim)
            error = C.square.norm

         case default 
            DIE("unknown SCF kind, "//trim(scf_kind))

      end

      ! Set the error
      .scfdata.set_diis_error(error)

      ! Clean
      C.destroy

      ! Uncompress
      .fock_matrix.uncompress

   end

! ======================
! Setting the DIIS error
! ======================

   diis_error_length(F,D,S) result (res) ::: selfless
   ! Make the real DIIS commutator matrix, C = FDS - SDF and set the diis
   ! .error_length to be sqrt(C-.C). The minus sign is because C is
   ! antisymmetric.
      F,D :: OPMATRIX*
      S :: MAT{REAL}*
      res :: REAL

   ENSURE(F.created,"no Fock matrix")
   ENSURE(F.any_created,"no Fock matrix")
   ENSURE(D.created,"no density matrix")
   ENSURE(D.any_created,"no density matrix")
   ENSURE(S.created,"no overlap matrix")
   ENSURE(F.n_bf==S.dim1,"Incompatible F and S")
   ENSURE(D.n_bf==S.dim1,"Incompatible D and S")

      C :: OPMATRIX*
      spinorbital_kind :: STR

      ! Kind
      spinorbital_kind = F.spinorbital_kind

      ! Make commutator
      C.create(F.n_bf,spinorbital_kind)
      MOLECULE:make_diis_commutator(C,F,D,S)
      C.compress

      ! Set error length
      res = ZERO
      select case (spinorbital_kind)
         case("restricted");      res = C.triangle.norm
         case("unrestricted");    res = C.triangle.norm
         case("general_complex"); res = C.square.norm
         case default;            UNKNOWN(spinorbital_kind)
      end

      ! Clean
      C.destroy

   end

   make_diis_commutator(C,F,D,S) ::: selfless
   ! Make the DIIS commutator opmatrix, C = FDS - SDF.
      C :: OPMATRIX
      F,D :: OPMATRIX, IN
      S :: MAT{REAL}, IN

   ENSURE(C.n_bf==S.dim1,"Incompatible C and S")
   ENSURE(F.n_bf==S.dim1,"Incompatible F and S")
   ENSURE(D.n_bf==S.dim1,"Incompatible D and S")

      select case (F.spinorbital_kind)

         case("restricted")
            MOLECULE:make_diis_commutator(C.restricted,F.restricted,D.restricted,S)

         case("unrestricted")
            MOLECULE:make_diis_commutator(C.alpha,F.alpha,D.alpha,S)
            MOLECULE:make_diis_commutator(C.beta,F.beta,D.beta,S)
            C.alpha = C.alpha + C.beta

         case("general_complex")
            MOLECULE:make_diis_commutator(C.general_complex,F.general_complex,D.general_complex,S)

         case default
            DIE("unimplemented")

      end

   end

   make_diis_commutator(C,F,D,S) ::: selfless
   ! Make the real DIIS commutator matrix, C = FDS - SDF.
      C :: MAT{REAL}
      F,D,S :: MAT{REAL}, IN
      W :: MAT{REAL}*

      W.create(F.dim1,F.dim1)
      W.to_product_of(D,S)
      C.to_product_of(F,W)
      W.destroy
      C.antisymmetric_fold
      C.antisymmetric_reflect

   end

   make_diis_commutator(C,F,D,S) ::: selfless
   ! Make the complex DIIS commutator matrix, C = FDS - SDF.
      C :: MAT{CPX}
      F,D :: MAT{CPX}, IN
      S :: MAT{REAL}, IN
      O,W :: MAT{CPX}*

      W.create(F.dim1,F.dim1)

      ! Make the overlap matrix
      O.create(F.dim1,F.dim1)
      O = ZERO
      O.alpha_alpha_set_to(S)
      O.beta_beta_set_to(S)

      ! D x S
      W.to_product_of(D,O)
      O.destroy

      ! F x D x S
      C.to_product_of(F,W)
      W.destroy

      ! Make FDS - SDF
      C.antihermitian_fold
      C.antihermitian_reflect

   end

! ====================
! Fock matrix routines
! ====================

   make_fock_matrix(core,r12) ::: leaky
   ! If r12  is present and FALSE, the r12 part is not computed.
      core,r12 :: BIN, optional

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.created(.scfdata.spinorbital_kind),"incompatible density")

      dF :: OPMATRIX*
      delta_build,add_core :: BIN

      ! Use a delta fock matrix build?
      delta_build = .scfdata.do_delta_build &
                AND .delta_density_matrix.created &
                AND .fock_2e_matrix.created

      ! Make the 2e fock matrix from density
      if (NOT delta_build) then         

         .fock_2e_matrix.destroy
         .fock_2e_matrix.create(.n_bf)
         .make_fock_matrix(.density_matrix,.fock_2e_matrix,core=FALSE,r12=r12,xc=FALSE)

      ! Make the 2e fock matrix from delta density
      else

        ! Uncompress 2e fock matrix
        .fock_2e_matrix.uncompress

        ! Make delta fock. Skip exchange correlation part.
        dF.create(.n_bf)              
        .make_fock_matrix(.delta_density_matrix,dF,core=FALSE,r12=r12,xc=FALSE)

        ! Add delta to previous 2e fock matrix 
        .fock_2e_matrix.plus(dF)

        ! Clean
        dF.destroy

      end

      ! Set fock matrix & save space
      .fock_matrix.destroy
      .fock_matrix.create_copy(.fock_2e_matrix)
      .fock_2e_matrix.compress

      ! Now do the XC part if needed
      if (.scfdata.is_DFT_calculation) then        
        .add_XC_matrix(.fock_matrix)
      end

      ! Force update of 1e hamiltonian if required
      if (.scfdata.using_SC_cluster_charges OR .scfdata.using_SC_Lorentz_fields) then
         .core_matrix.destroy
         .Hirshfeld_atom_info_made = FALSE
      end

      ! Add one electron part?
      add_core = TRUE
      if (present(core)) add_core = core

      if (add_core) then
         .get_core_matrix
         .add_core_hamiltonian(.fock_matrix)
      end

      ! Debug: fock matrix
      .put_debug(.fock_matrix,"make_fock_matrix: fock matrix")

   end

   make_fock_matrix(P,F,core,r12,xc) ::: leaky
   ! For the quicker ERI method.
   ! If r12  is present and FALSE, the r12 part is not computed
      P,F :: OPMATRIX*
      core,r12,xc :: BIN, optional
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(P.created,"no density matrix")
   ENSURE(P.created(.scfdata.spinorbital_kind),"incompatible density")
      direct :: BIN
      direct = .scfdata.using_direct_scf
      if (NOT direct) .get_ERI_integrals
      .scfdata.dft_energy_correction       = ZERO ! Set these to zero since
      .scfdata.dft_alpha_energy_correction = ZERO ! they may be calculated
      .scfdata.dft_beta_energy_correction  = ZERO

      select case (.scfdata.scf_kind)

        case ("rhf","xray_rhf","embedded_rhf")

           .make_r_fock(P,F,direct,core,r12)

        case ("rks","xray_rks")

           .make_r_KS_fock(P,F,direct,core,r12,xc)

      !  case ("crystal_rhf")

      !     .make_r_crystal_fock(P,F,direct,core,r12)

        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")

           .make_u_KS_fock(P,F,core,r12,xc)

        case ("rohf")

           .make_ro_fock(P,F,direct,core,r12)

        case ("uhf","xray_uhf","pnd_uhf","xray_pnd_uhf")

           .make_u_fock(P,F,direct,core,r12)

        case ("gchf")

           .make_gc_fock(P,F,direct,core,r12)
           .add_gc_so_fock(P,F)

        case default

           DIE("unknown SCF kind, "//trim(.scfdata.scf_kind))

      end

   end

   add_core_hamiltonian(F)
   ! Add the core hamiltonain to "F"
      F :: OPMATRIX

   ENSURE(.scfdata.created,"no scfdata")

      genre :: STR

      genre = .scfdata.spinorbital_kind

      select case (genre)

         case ("restricted")

            F.restricted = F.restricted + .core_matrix.restricted

         case ("unrestricted")

            F.alpha = F.alpha + .core_matrix.alpha
            F.beta  = F.beta  + .core_matrix.beta

         case ("general_complex")

            F.general_complex = F.general_complex + .core_matrix.general_complex

         case default

            DIE("unimplemented")

      end

   end

   make_r_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new restricted Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      direct,core,r12 :: BIN, optional
      P,F :: OPMATRIX*

   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.restricted.created, "no density matrix")

      J,K :: MAT{REAL}*
      do_direct,add_core,add_r12 :: BIN

      F.destroy("restricted")
      F.create("restricted")

      do_direct= FALSE
      add_core = TRUE
      add_r12  = TRUE
      if (present(direct)) do_direct = direct
      if (present(core))   add_core = core
      if (present(r12))    add_r12  = r12

      if (add_r12) then
        J.create(.n_bf,.n_bf)
        K.create(.n_bf,.n_bf)
        if (do_direct) then
          if(.use_spherical_basis) then; .make_r_JK_direct(J,K,P.restricted)
          else;                          .make_r_JK_direct2(J,K,P.restricted)
          end  
        else;                            .make_r_JK_disk(J,K,P.restricted)
        end
        F.restricted = J - HALF*K
        K.destroy
        J.destroy
        .put_debug(F.restricted,"make_r_fock: 2e F")
      else
        F.restricted = ZERO
      end


      if (add_core) then
        .get_core_matrix
        .add_core_hamiltonian(F)
        .put_debug(F.restricted,"make_r_fock: F")
      end

!     if (.scfdata.created) .shift_dependence_from_r(F.restricted)

   end

   make_r_KS_fock(P,F,direct,core,r12,xc) ::: leaky
   ! Make a new restricted Kohn-Sham Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
   ! If present and FALSE, "xc"  removes the exchange correlation part
      direct,core,r12,xc :: BIN, optional
      P,F :: OPMATRIX*
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.restricted.created, "no density matrix")
      J :: MAT{REAL}*
      do_direct,add_core,add_r12,add_xc :: BIN

      F.destroy("restricted")
      F.create("restricted")

      do_direct= FALSE
      add_core = TRUE
      add_r12  = TRUE
      add_xc   = TRUE
      if (present(direct)) do_direct = direct
      if (present(core))   add_core  = core
      if (present(r12))    add_r12   = r12
      if (present(xc))     add_xc    = xc

      if (add_r12) then
        J => F.restricted
        if (do_direct) then; .make_r_J_direct(J,P.restricted)
        else;                .make_r_J_disk(J,P.restricted)
        end
        if (add_xc) .add_XC_matrix(F) ! Exchange correlation matrix
      else
        F.restricted = ZERO
      end

      if (add_core) then
        .get_core_matrix
        .add_core_hamiltonian(F)
      end

   end

   make_u_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new unrestricted Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      P,F :: OPMATRIX*
      direct,core,r12 :: BIN, optional
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(P.alpha.created,"no density matrix")
   ENSURE(P.beta.created, "no density matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
      J,K :: OPMATRIX*
      do_direct,add_core,add_r12 :: BIN

      F.destroy("unrestricted")
      F.create("unrestricted")

      do_direct= FALSE
      add_core = TRUE
      add_r12  = TRUE
      if (present(direct)) do_direct = direct
      if (present(core))   add_core = core
      if (present(r12))    add_r12  = r12

      J.create(.n_bf,"unrestricted")
      K.create(.n_bf,"unrestricted")

      if (add_r12) then
        if (do_direct) then
          if(.use_spherical_basis) then
            .make_u_JK_direct(J,K,P)
          else
            .make_u_JK_direct2(J,K,P)
          end  
        else;                DIE("disk UHF not implemented")
        end
        F.alpha = J.alpha + J.beta - K.alpha
        F.beta  = J.alpha + J.beta - K.beta
      else
        F.alpha = ZERO
        F.beta  = ZERO
      end

      ! Clean
      K.destroy
      J.destroy

      if (add_core) then
        .get_core_matrix
        .add_core_hamiltonian(F)
      end

   end

   make_u_KS_fock(P,F,core,r12,xc) ::: leaky
   ! Make a new restricted Kohn-Sham Fock matrix "F" from the density matrix "P".
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
   ! If present and FALSE, "xc" removes the texchange correlation
      core,r12,xc :: BIN, optional
      P,F :: OPMATRIX*

   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.alpha.created, "no density matrix")
   ENSURE(P.beta.created, "no density matrix")

      J,Pab :: MAT{REAL}*
      add_core,add_r12,add_xc :: BIN

      F.destroy("unrestricted")
      F.create("unrestricted")

      add_core = TRUE
      add_r12  = TRUE
      add_xc   = TRUE
      if (present(core))   add_core = core
      if (present(r12))    add_r12  = r12
      if (present(xc))     add_xc   = xc

      J.create(.n_bf,.n_bf)

      if (add_r12) then
        Pab.create(.n_bf,.n_bf)
        Pab = P.alpha + P.beta
        .make_r_J_direct(J,Pab)
        Pab.destroy
        F.alpha = J
        F.beta = J
        if (add_xc) .add_XC_matrix(F)
      else
        F.alpha = ZERO
        F.beta  = ZERO
      end

      ! Clean
      J.destroy

      if (add_core) then
        .get_core_matrix
        .add_core_hamiltonian(F)
      end

   end

   make_ro_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new restricted open shell Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      F,P :: OPMATRIX*
      direct,core,r12 :: BIN, optional
   ENSURE(.molecular_orbitals.restricted.created,"no orbitals")
      Fr,Fa,Fb,W :: MAT{REAL}*

      F.destroy("restricted")
      F.create("restricted")

      .make_u_fock(P,F,direct,core,r12)

      Fr => F.restricted

      Fa.create(.n_bf,.n_bf); Fa = F.alpha
      Fb.create(.n_bf,.n_bf); Fb = F.beta
      Fa.change_basis_using(.molecular_orbitals.restricted)
      Fb.change_basis_using(.molecular_orbitals.restricted)

      Fr = HALF*(Fa+Fb)
      Fr(.n_b+1:.n_a,     1:.n_b) = Fb(.n_b+1:.n_a,     1:.n_b)
      Fr(     1:.n_b,.n_b+1:.n_a) = Fb(     1:.n_b,.n_b+1:.n_a)
      Fr(.n_a+1:    ,.n_b+1:.n_a) = Fa(.n_a+1:    ,.n_b+1:.n_a)
      Fr(.n_b+1:.n_a,.n_a+1:    ) = Fa(.n_b+1:.n_a,.n_a+1:    )

      ! Change Fr to AO basis
      .get_overlap_matrix
      W => Fa
      W.to_product_of(.molecular_orbitals.restricted,.overlap_matrix,transpose_a=TRUE)
      Fr.change_basis_using(W) ! change to AO basis

      Fb.destroy
      Fa.destroy

   end

   make_gc_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new complex general Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
      direct,core,r12 :: BIN, optional
      P,F :: OPMATRIX*

   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(P.general_complex.created, "no density matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")

      Ka,Kb,Kba,Pa,Pb,Pba,Fgc :: MAT{CPX}*
      J, Pab :: MAT{REAL}*
      do_direct,add_core,add_r12 :: BIN

      F.destroy("general_complex")
      F.create("general_complex")

      do_direct= FALSE
      add_core = TRUE
      add_r12  = TRUE
      if (present(direct)) do_direct = direct
      if (present(core)) add_core = core
      if (present(r12))  add_r12  = r12

      Fgc => F.general_complex
      if (add_r12) then
        J.create(.n_bf,.n_bf)
        Ka.create(.n_bf,.n_bf)
        Kb.create(.n_bf,.n_bf)
        Kba.create(.n_bf,.n_bf)
        Pa.create(.n_bf,.n_bf);  P.general_complex.alpha_alpha_put_to(Pa)
        Pb.create(.n_bf,.n_bf);  P.general_complex.beta_beta_put_to(Pb)
        Pba.create(.n_bf,.n_bf); P.general_complex.beta_alpha_put_to(Pba)
        Pab.create(.n_bf,.n_bf)
        Pab  = RE(Pa) + RE(Pb)
        if (do_direct) then; .make_gc_JK_direct(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
        else;                .make_gc_JK_disk(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
        end
        Pab.destroy
        Pba.destroy
        Pb.destroy
        Pa.destroy
        Ka = J - Ka; Fgc.alpha_alpha_set_to(Ka)
        Kb = J - Kb; Fgc.beta_beta_set_to(Kb)
        Kba = -Kba;  Fgc.beta_alpha_set_to(Kba)
        Kba.destroy
        Kb.destroy
        Ka.destroy
        J.destroy
      else
        Fgc = ZERO
      end
      Fgc.make_hermitian

      if (add_core) then
        .get_core_matrix 
        .add_core_hamiltonian(F)
      end

   end

   add_gc_so_fock(P,F,direct) ::: leaky
   ! Make the general complex two electron spin orbit contribution to the Fock
   ! matrix.
      P,F :: OPMATRIX*
      direct :: BIN, optional
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(P.general_complex.created, "no density matrix")
   ENSURE(F.general_complex.created, "no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
      JS,KS,JO,KO :: MAT5{CPX}*
      Pgc :: MAT4{CPX}*
      Faa,Fbb,Fba :: MAT{CPX}*
      I :: CPX
      fac :: REAL
      a,b,x,y,z :: INT
      do_direct :: BIN

      do_direct= FALSE
      if (present(direct)) do_direct = direct

      if (.scfdata.using_2e_sl_term) then
       .get_spin_orbit_integrals
       Faa.create(.n_bf,.n_bf)
       Fbb.create(.n_bf,.n_bf)
       Fba.create(.n_bf,.n_bf)
       JS.create(.n_bf,.n_bf,2,2,3); KS.create(.n_bf,.n_bf,2,2,3)
       JO.create(.n_bf,.n_bf,2,2,3); KO.create(.n_bf,.n_bf,2,2,3)
       Pgc.create(.n_bf,.n_bf,2,2)
       P.general_complex.alpha_alpha_put_to(Pgc(:,:,1,1))
       P.general_complex.beta_alpha_put_to(Pgc(:,:,2,1))
       P.general_complex.alpha_beta_put_to(Pgc(:,:,1,2))
       P.general_complex.beta_beta_put_to(Pgc(:,:,2,2))
       if (do_direct) then
       .make_gc_so_JK_direct(JS,KS,JO,KO,Pgc)
       else
       .make_gc_so_JK_disk(JS(:,:,:,:,1),KS(:,:,:,:,1),JO(:,:,:,:,1),KO(:,:,:,:,1),Pgc,"x")
       .make_gc_so_JK_disk(JS(:,:,:,:,2),KS(:,:,:,:,2),JO(:,:,:,:,2),KO(:,:,:,:,2),Pgc,"y")
       .make_gc_so_JK_disk(JS(:,:,:,:,3),KS(:,:,:,:,3),JO(:,:,:,:,3),KO(:,:,:,:,3),Pgc,"z")
       end
       Pgc.destroy
       I = (ZERO,ONE)
       a = 1; b = 2; x = 1; y = 2; z = 3
       Faa =  THREE*JO(:,:,a,a,z) +       JO(:,:,b,b,z) + THREE*JS(:,:,a,a,z) -   JS(:,:,b,b,z) &
           +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
           +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
           -    TWO*KO(:,:,b,a,x) -       KO(:,:,a,b,x) -   TWO*KS(:,:,a,b,x) -   KS(:,:,b,a,x) &
           +  I*TWO*KO(:,:,b,a,y) -     I*KO(:,:,a,b,y) - I*TWO*KS(:,:,a,b,y) + I*KS(:,:,b,a,y) &
           -  THREE*KO(:,:,a,a,z) - THREE*KS(:,:,a,a,z)
       Fbb = -THREE*JO(:,:,b,b,z) -       JO(:,:,a,a,z) - THREE*JS(:,:,b,b,z) +   JS(:,:,a,a,z) &
           +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
           +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
           -    TWO*KO(:,:,a,b,x) -       KO(:,:,b,a,x) -   TWO*KS(:,:,b,a,x) -   KS(:,:,a,b,x) &
           -  I*TWO*KO(:,:,a,b,y) + I*KO(:,:,b,a,y)     + I*TWO*KS(:,:,b,a,y) - I*KS(:,:,a,b,y) &
           +  THREE*KO(:,:,b,b,z) + THREE*KS(:,:,b,b,z)
       Fba =    TWO*JO(:,:,a,a,x) +   TWO*JO(:,:,b,b,x) +       JS(:,:,a,a,x) +   JS(:,:,b,b,x) &
           +  I*TWO*JO(:,:,a,a,y) + I*TWO*JO(:,:,b,b,y) +     I*JS(:,:,a,a,y) + I*JS(:,:,b,b,y) &
           -    TWO*KO(:,:,a,a,x) -       KO(:,:,b,b,x) -   TWO*KS(:,:,b,b,x) -   KS(:,:,a,a,x) &
           -  I*TWO*KO(:,:,a,a,y) -     I*KO(:,:,b,b,y) - I*TWO*KS(:,:,b,b,y) - I*KS(:,:,a,a,y) &
           +        KO(:,:,b,a,z) -       KS(:,:,b,a,z)
       KO.destroy; JO.destroy; KS.destroy; JS.destroy

       fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
       fac = fac * .scfdata.sl_2e_factor
       F.general_complex.alpha_alpha_plus(Faa,I*fac)
       F.general_complex.beta_beta_plus(Fbb,I*fac)
       F.general_complex.beta_alpha_plus(Fba,I*fac)
       Fbb = conjg(transpose(Fba))
       F.general_complex.alpha_beta_plus(Fbb,-I*fac)
       Fba.destroy; Fbb.destroy; Faa.destroy
      end

   end

! =====================
! J & K matrix routines
! =====================

   in_same_atom_group(atom_a,atom_b,group) result (res)
   ! Return TRUE if the atoms are all in the same atom_group
   ! If present, "group" is set to the common group index.
      atom_a,atom_b :: INT
      group :: INT, optional
      res :: BIN

   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(atom_a<=.atom.dim,"atom_a out of range")
   ENSURE(atom_b<=.atom.dim,"atom_b out of range")

      n,n_group :: INT
      found :: BIN

      n_group = size(.atom_group)
      res = TRUE
      found = FALSE
      do n = 1,n_group
         if (any(atom_a==.atom_group(n).atom_index)) then
            found = TRUE
            if (NOT any(atom_b==.atom_group(n).atom_index)) res = FALSE
            exit
         end
      end

      DIE_IF(NOT found,"atom_a was not found in any atom_group")

      if (present(group)) then
         if (res) then; group = n
         else;          group = 0
         end
      end

   end

   in_same_atom_group(atom_a,atom_b,atom_c,atom_d) result (res)
   ! Return TRUE if the atoms are all in the same atom_group
      atom_a,atom_b,atom_c,atom_d :: INT
      res :: BIN

   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(atom_a<=.atom.dim,"atom_a out of range")
   ENSURE(atom_b<=.atom.dim,"atom_b out of range")
   ENSURE(atom_c<=.atom.dim,"atom_c out of range")
   ENSURE(atom_d<=.atom.dim,"atom_d out of range")

      n,n_group :: INT
      found :: BIN

      n_group = size(.atom_group)
      res = TRUE
      found = FALSE
      do n = 1,n_group
         if (any(atom_a==.atom_group(n).atom_index)) then
            found = TRUE
            if (NOT any(atom_b==.atom_group(n).atom_index)) res = FALSE
            if (NOT any(atom_c==.atom_group(n).atom_index)) res = FALSE
            if (NOT any(atom_d==.atom_group(n).atom_index)) res = FALSE
            exit
         end
      end

      DIE_IF(NOT found,"atom_a was not found in any atom_group")

   end


   schwarz_inequality_test(cutoff,ab,cd,a,b,c,d,P_max,I_max) result(skip) ::: selfless
   ! Return "skip", a logical variable which is TRUE if the maximum contribution
   ! to the restricted Fock matrix (based on the schwarz inequality test) from a
   ! shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd" is
   ! smaller than a preset "cutoff". "P_max" is the maximum density matrix
   ! elements for each shell pair "ab", and "I_max(ab)" is maximum value of the
   ! square root of the integral (ab|ab) for the shell pair with index "ab".
      skip :: BIN
      cutoff :: REAL
      ab,cd, a,b,c,d :: INT
      P_max,I_max :: VEC{REAL}

      Pmax :: REAL
      ac,ad,bc,bd,k,l,m,n :: INT

      ! Indices for (ab|cd) < sqrt(ab|ab) * sqrt(cd|cd) test.
      k = max(b,c); l = min(b,c)
      m = max(b,d); n = min(b,d)
      ac = ((a-1)*a)/2 + c          
      ad = ac - c + d
      bc = ((k-1)*k)/2 + l
      bd = ((m-1)*m)/2 + n

      Pmax = max(P_max(ab),P_max(cd),P_max(ac),P_max(ad),P_max(bc),P_max(bd))

      if (Pmax < TOL(20)) then
        skip = TRUE
      else
        if (Pmax*I_max(ab)*I_max(cd) > cutoff) then; skip = FALSE
        else;                                        skip = TRUE
        end
      end

   end

   schwarz_test(skip_J,skip_K,cutoff,JP_cut,KP_cut,ab,cd,a,b,c,d,P_max,I_max) ::: selfless, private
   ! contribution to the J and K matrices (based on the schwarz inequality test)
   ! from a shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd"
   ! is smaller than a preset "cutoff". "P_max(ab)" is the maximum density
   ! matrix elements for each shell pair "ab", and "I_max(ab)" is maximum value
   ! of the square root of the integral (ab|ab) for the shell pair with index "ab".
      skip_J,skip_K :: BIN, OUT
      cutoff,JP_cut,KP_cut :: REAL, IN
      ab,cd, a,b,c,d :: INT, IN
      P_max,I_max :: VEC{REAL}, IN

      JP_max,KP_max :: REAL
      ac,ad,bc,bd,k,l,m,n :: INT

      ! Indices for (ab|cd) < sqrt(ab|ab) * sqrt(cd|cd) test.
      k = max(b,c); l = min(b,c)
      m = max(b,d); n = min(b,d)
      ac = (a-1)*a/2 + c          
      ad = ac - c + d
      bc = (k-1)*k/2 + l
      bd = (m-1)*m/2 + n

      JP_max = max(P_max(ab),P_max(cd))
      KP_max = max(P_max(ac),P_max(ad),P_max(bc),P_max(bd))

      skip_J = FALSE
      if      (JP_max < JP_cut) then;                     skip_J = TRUE
      else if (JP_max*I_max(ab)*I_max(cd) < cutoff) then; skip_J = TRUE
      end

      skip_K = FALSE
      if      (KP_max < KP_cut) then;                     skip_K = TRUE
      else if (KP_max*I_max(ab)*I_max(cd) < cutoff) then; skip_K = TRUE
      end

   end

!   schwarz_test(skip_J,skip_K,cutoff,JP_cut,KP_cut,S_cut,ab,cd,a,b,c,d,P_max,I_max,S_max)
!   ! Return "skip_J" and "skip_K", logical variables are TRUE if the maximum
!   ! contribution to the J and K matrices (based on the schwarz inequality test)
!   ! from a shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd"
!   ! is smaller than a preset "cutoff". "P_max(ab)" is the maximum density
!   ! matrix elements for each shell pair "ab", and "I_max(ab)" is maximum value
!   ! of the square root of the integral (ab|ab) for the shell pair with index "ab".
!     skip_J,skip_K :: BIN, OUT
!     cutoff,JP_cut,KP_cut,S_cut :: REAL, IN
!     ab,cd, a,b,c,d :: INT, IN
!     P_max,I_max,S_max :: VEC{REAL}, IN
!
!     JP_max,KP_max,JS_max,KS_max :: REAL
!     ac,ad,bc,bd,k,l,m,n :: INT
!
!     ! Indices for (ab|cd) < sqrt(ab|ab) * sqrt(cd|cd) test.
!     k = max(b,c); l = min(b,c)
!     m = max(b,d); n = min(b,d)
!     ac = (a-1)*a/2 + c          
!     ad = ac - c + d
!     bc = (k-1)*k/2 + l
!     bd = (m-1)*m/2 + n
!
!     JP_max = max(P_max(ab),P_max(cd))
!     KP_max = max(P_max(ac),P_max(ad),P_max(bc),P_max(bd))
!
!     JS_max = max(S_max(ab),S_max(cd))
!     KS_max = max(S_max(ac),S_max(ad),S_max(bc),S_max(bd))
!
!     skip_J = FALSE
!     if      (JP_max < JP_cut) then;                     skip_J = TRUE
!     else if (JS_max <  S_cut) then;                     skip_J = TRUE
!     else if (JP_max*I_max(ab)*I_max(cd) < cutoff) then; skip_J = TRUE
!     end
!
!     skip_K = FALSE
!     if      (KP_max < KP_cut) then;                     skip_K = TRUE
!     else if (KS_max <  S_cut) then;                     skip_K = TRUE
!     else if (KP_max*I_max(ab)*I_max(cd) < cutoff) then; skip_K = TRUE
!     end
!
!   end

   schwarz_J_test(skip_J,cutoff,ab,cd,P_max,I_max) ::: selfless, private
   ! Return "skip_J" which is set TRUE if the maximum contribution to the J
   ! matrix (based on the schwarz inequality test) from a shell of ERI integrals
   ! (ab|cd) with shell pair indices "ab" and "cd" is smaller than a preset
   ! "cutoff". "P_max(ab)" is the maximum density matrix elements for each shell
   ! pair "ab", and "I_max(ab)" is maximum value of the square root of the
   ! integral (ab|ab) for the shell pair with index "ab".
      skip_J :: BIN, OUT
      cutoff :: REAL, IN
      ab,cd :: INT, IN
      P_max,I_max :: VEC{REAL}, IN

      Jmax :: REAL

      Jmax = max(P_max(ab),P_max(cd))

      skip_J = FALSE
      if      (Jmax < TOL(20)) then;                    skip_J = TRUE
      else if (Jmax*I_max(ab)*I_max(cd) < cutoff) then; skip_J = TRUE
      end

   end

   schwarz_K_test(skip_K,cutoff,ab,cd,a,b,c,d,P_max,I_max) ::: selfless, private
   ! Return "skip_K", logical variables are TRUE if the maximum
   ! contribution to the K matrices (based on the schwarz inequality test)
   ! from a shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd"
   ! is smaller than a preset "cutoff". "P_max(ab)" is the maximum density
   ! matrix elements for each shell pair "ab", and "I_max(ab)" is maximum value
   ! of the square root of the integral (ab|ab) for the shell pair with index "ab".
      skip_K :: BIN, OUT
      cutoff :: REAL, IN
      ab,cd, a,b,c,d :: INT, IN
      P_max,I_max :: VEC{REAL}, IN

      Kmax :: REAL
      ac,ad,bc,bd,k,l,m,n :: INT

      k = max(b,c); l = min(b,c)
      m = max(b,d); n = min(b,d)

      ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
      ac = (a-1)*a/2 + c          
      ad = ac - c + d
      bc = (k-1)*k/2 + l
      bd = (m-1)*m/2 + n

      Kmax = max(P_max(ac),P_max(ad),P_max(bc),P_max(bd))

      skip_K = FALSE
      if      (Kmax < TOL(20)) then;                    skip_K = TRUE
      else if (Kmax*I_max(ab)*I_max(cd) < cutoff) then; skip_K = TRUE
      end

   end

   make_max_density_elements(P_max,P)
   ! Make "P_max", the maximum of the (a,b) density elements of "P" over each
   ! shell pair, for use in the schwarz test.
      P_max :: VEC{REAL}
      P :: MAT{REAL}

   ENSURE(size(P_max)==.n_shell_pairs,"wrong size, P_max")
   ENSURE(P.is_square,"wrong shape, P")
   ENSURE(P.dim1==.n_bf,"wrong size, P")

      ab,aa,bb,fa,fb,la,lb,na,nb, a,b :: INT
      Pmax :: REAL

      ! Store the largest integral for each shell pair ab|ab
      do ab = 1, .n_shell_pairs
         .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb)
         Pmax = ZERO
         do a = fa,la
         do b = fb,lb
            Pmax = max(abs(P(a,b)),Pmax)
         end
         end
         P_max(ab) = Pmax
      end

   end

   make_max_density_elements(P_max,Pa,Pb)
   ! Make "P_max", the maximum of the (a,b) density elements of "Pa"
   ! and "Pb" over each shell pair, for use in the schwarz test.
      P_max :: VEC{REAL}
      Pa,Pb :: MAT{REAL}

   ENSURE(size(P_max)==.n_shell_pairs,"wrong size, P_max")
   ENSURE(Pa.is_square,"wrong shape, Pa")
   ENSURE(Pb.is_square,"wrong shape, Pb")
   ENSURE(Pa.dim1==.n_bf,"wrong size, Pa")
   ENSURE(Pb.dim1==.n_bf,"wrong size, Pb")

      ab,aa,bb,fa,fb,la,lb,na,nb, a,b :: INT
      Pmax :: REAL

      ! Store the largest integral for each shell pair ab|ab
      do ab = 1, .n_shell_pairs
         .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb)
         Pmax = ZERO
         do a = fa,la
         do b = fb,lb
            Pmax = max(abs(Pa(a,b)),abs(Pb(a,b)),Pmax)
         end
         end
         P_max(ab) = Pmax
      end

   end

   make_max_abab_integrals(I_max)
   ! Make "I_max", the square root of the maximum of the (ab|ab) ERI integrals.
      I_max :: VEC{REAL}
   ENSURE(size(I_max)==.n_shell_pairs,"wrong size, I_max")
      ab,sa,sb,fa,fb,la,lb,na,nb, a,b :: INT
      sh4q :: SHELL1QUARTET
      Iabab :: MAT4{REAL}*
      Imax :: REAL

      do ab = 1, .n_shell_pairs

         .get_shell_pair_indices(ab,sa,sb,fa,la,na,fb,lb,nb)

         .set_new_shell_quartet_ab(sh4q,sa,sb,skip=FALSE) ! (ab|ab} shell
         .set_new_shell_quartet_cd(sh4q,sa,sb,skip=FALSE)

         Iabab.create(na,nb,na,nb)
         SHELL1QUARTET::make_ERI(sh4q,Iabab)

         sh4q.destroy_ptr_part

         Imax = ZERO
         do a = 1,na
         do b = 1,nb
            Imax = max(abs(Iabab(a,b,a,b)),Imax)
         end
         end

         I_max(ab) = sqrt(Imax)
         Iabab.destroy

      end

   end

   make_max_abab_so_integrals(I_max)
   ! Make "I_max", the square root of the maximum of the all (ab|ab) spin orbit
   ! integrals.
      I_max :: VEC{REAL}
   ENSURE(size(I_max)==.n_shell_pairs,"wrong size, I_max")
      ab,sa,sb,fa,fb,la,lb,na,nb, a,b :: INT
      sh4 :: SHELL4
      S,O :: MAT5{REAL}*
      Imax :: REAL

      sh4.set_spherical(.use_spherical_basis)

      ! Store the largest integral for each shell pair ab|ab
      do ab = 1, .n_shell_pairs           ! Store the largest integral for each

         .get_shell_pair_indices(ab,sa,sb,fa,la,na,fb,lb,nb)

         .copy_shell_quartet_ab(sh4,sa,sb)
         .copy_shell_quartet_cd(sh4,sa,sb)

         S.create(na,nb,na,nb,3)
         O.create(na,nb,na,nb,3)
         sh4.make_spin_orbit_ints(S,O)

         sh4.destroy_ptr_part

         Imax = ZERO
         do a = 1,na
         do b = 1,nb
            Imax = max(abs(S(a,b,a,b,1)),abs(S(a,b,a,b,2)),abs(S(a,b,a,b,3)), &
                       abs(O(a,b,a,b,1)),abs(O(a,b,a,b,2)),abs(O(a,b,a,b,3)),Imax)
         end
         end

         I_max(ab) = sqrt(Imax)
         O.destroy
         S.destroy

      end

   end

   make_max_S_integrals(S_max)
   ! Make "S_max", the maximum of the overlap integrals between basis
   ! functions in all pairs of shells.
      S_max :: VEC{REAL}
   ENSURE(S_max.dim==.n_shell_pairs,"wrong size, S_max")

      ab,sa,sb,fa,la,fb,lb,na,nb :: INT

      do ab = 1,.n_shell_pairs
         .get_shell_pair_indices(ab,sa,sb,fa,la,na,fb,lb,nb)
         S_max(ab) = maxval(abs(.overlap_matrix(fa:la,fb:lb)))
      end

   end

   reverse_transfer(P,PV) ::: leaky
   ! Apply the reverse horizontal recursion relation (i.e. the reverse
   ! transfer relation) to matrix "P" to produce the shell pair vector
   ! "PV" which has to be multipled by the (es|fs) source integrals to
   ! give the J-matrix. 
      P :: MAT{REAL}
      PV :: VEC{VEC_{REAL}}*

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")

      R :: VEC{REAL}(3)
      R1,R2,R3,T1,T2,T3,fx,fy,fz,P_ab :: REAL
      Rx,Ry,Rz,ab :: VEC{REAL}*
      ax,ay,az,bx,by,bz,binx,biny,binz :: VEC{INT}*
      q,fa,la,na,fb,lb,nb,atom_a,atom_b,aa,bb,af,al,bf,bl,f :: INT
      i,k,a,b,x,y,z,xa,ya,za,xb,yb,zb,xx,yy,zz :: INT
      new_atom_pair,same_atoms,a_gt_b,a_lt_b :: BIN
      sh :: SHELL2

      Rx.create(.basis_l_max+1)
      Ry.create(.basis_l_max+1)
      Rz.create(.basis_l_max+1)
      PV.create(.n_shell_pairs)                                ! leaky

      a_gt_b = TRUE
      a_lt_b = TRUE
      aa = 0
      bb = 0

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)

         PV(q).element.create(sh.n_gaussian)                   ! leaky
         ab => PV(q).element

         if      (sh.l_sum==0) then                            ! SS case
            ab(1) = P(fa,fb)
         else if (sh.a.l==0) then                              ! XS case
            fb = fb - 1
            if (sh.l_max<2) then                               ! No normalisers
               do b = 1,sh.b.n_comp
                  ab(b) = P(fa,fb+b)
               end
            else                                               ! Include normalisers
               do b = 1,sh.b.n_comp
                  ab(b) = P(fa,fb+b)
               end
            end
         else if (sh.b.l==0) then                              ! SX case
            fa = fa - 1
            if (sh.l_max<2) then                               ! No normalisers
               do a = 1,sh.a.n_comp
                  ab(a) = P(fa+a,fb)
               end
            else                                               ! Include normalisers
               do a = 1,sh.a.n_comp
                  ab(a) = P(fa+a,fb)
               end
            end
         else                                                  ! General case
            ab = ZERO
            af =  GAUSSIAN_DATA:n_comp_up_to(sh.a.l-1) + 1; al = af + sh.a.n_comp - 1
            bf =  GAUSSIAN_DATA:n_comp_up_to(sh.b.l-1) + 1; bl = bf + sh.b.n_comp - 1
            ax => GAUSSIAN_DATA::nx(af:al)
            ay => GAUSSIAN_DATA::ny(af:al)
            az => GAUSSIAN_DATA::nz(af:al)
            bx => GAUSSIAN_DATA::nx(bf:bl)
            by => GAUSSIAN_DATA::ny(bf:bl)
            bz => GAUSSIAN_DATA::nz(bf:bl)
            af = af - 1
            bf = bf - 1
            fa = fa - 1
            fb = fb - 1
            new_atom_pair = atom_a/=aa OR atom_b/=bb
            same_atoms = atom_a==atom_b
            aa = atom_a; bb = atom_b
            if (same_atoms) then                               ! No transfer
               if (sh.a.l > sh.b.l) then; f = af
               else;                      f = bf
               end
               if (sh.l_max<2) then                            ! No normalising factors
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        xx = xa + xb - 1
                        yy = ya + yb - 1
                        zz = za + zb - 1
                        i = GAUSSIAN_DATA::index_of(xx,yy,zz) - f
                        ab(i) = ab(i) + P_ab
                     end
                  end
               else                                            ! Include normalisers
                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        k = k + 1
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        xx = xa + xb - 1
                        yy = ya + yb - 1
                        zz = za + zb - 1
                        i = index_of(xx,yy,zz) - f
                        ab(i) = ab(i) + P_ab
                     end
                  end
               end
            else if (sh.a.l > sh.b.l) then                     ! Transfer to a
               if (new_atom_pair OR a_lt_b) then
                  a_gt_b = TRUE; a_lt_b = FALSE
                  R = sh.a.position - sh.b.position
                  R1 = R(1);   R2 = R(2);   R3 = R(3)
                  T1 = R1;     T2 = R2;     T3 = R3
                  Rx(1) = ONE; Ry(1) = ONE; Rz(1) = ONE
                  do i = 2,sh.l_max+1
                     Rx(i) = T1; T1 = R1*T1
                     Ry(i) = T2; T2 = R2*T2
                     Rz(i) = T3; T3 = R3*T3
                  end
               end
               if (sh.l_max<2) then                            ! No normalisers
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     binx => GAUSSIAN_DATA::binomial_p1(xb)%element
                     biny => GAUSSIAN_DATA::binomial_p1(yb)%element
                     binz => GAUSSIAN_DATA::binomial_p1(zb)%element
                     do a = 1,sh.a.n_comp
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        do x = 1,xb 
                           xx = xa + x - 1
                           fx = binx(x)*Rx(xb-x+1)*P_ab
                           do y = 1,yb 
                              yy = ya + y - 1
                              fy = biny(y)*Ry(yb-y+1)
                              do z = 1,zb 
                                 zz = za + z - 1
                                 fz = binz(z)*Rz(zb-z+1)
                                 i = index_of(xx,yy,zz) - af
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               else                                            ! Include normalisers
                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     binx => GAUSSIAN_DATA::binomial_p1(xb)%element
                     biny => GAUSSIAN_DATA::binomial_p1(yb)%element
                     binz => GAUSSIAN_DATA::binomial_p1(zb)%element
                     do a = 1,sh.a.n_comp
                        k = k + 1
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        do x = 1,xb 
                           xx = xa + x - 1
                           fx = binx(x)*Rx(xb-x+1)*P_ab
                           do y = 1,yb 
                              yy = ya + y - 1
                              fy = biny(y)*Ry(yb-y+1)
                              do z = 1,zb 
                                 zz = za + z - 1
                                 fz = binz(z)*Rz(zb-z+1)
                                 i = index_of(xx,yy,zz) - af
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               end
            else                                              ! Transfer to b
               if (new_atom_pair OR a_gt_b) then
                  a_gt_b = FALSE; a_lt_b = TRUE
                  R = sh.b.position - sh.a.position
                  R1 = R(1);   R2 = R(2);   R3 = R(3)
                  T1 = R1;     T2 = R2;     T3 = R3
                  Rx(1) = ONE; Ry(1) = ONE; Rz(1) = ONE
                  do i = 2,sh.l_max+1
                     Rx(i) = T1; T1 = R1*T1
                     Ry(i) = T2; T2 = R2*T2
                     Rz(i) = T3; T3 = R3*T3
                  end
               end
               if (sh.l_max<2) then                           ! No normalisers
                  do a = 1,sh.a.n_comp
                     xa = ax(a); ya = ay(a); za = az(a)
                     binx => GAUSSIAN_DATA::binomial_p1(xa)%element
                     biny => GAUSSIAN_DATA::binomial_p1(ya)%element
                     binz => GAUSSIAN_DATA::binomial_p1(za)%element
                     do b = 1,sh.b.n_comp
                        P_ab = P(fa+a,fb+b)
                        xb = bx(b); yb = by(b); zb = bz(b)
                        do x = 1,xa 
                           xx = xb + x - 1
                           fx = binx(x)*Rx(xa-x+1)*P_ab
                           do y = 1,ya 
                              yy = yb + y - 1
                              fy = biny(y)*Ry(ya-y+1)
                              do z = 1,za 
                                 zz = zb + z - 1
                                 fz = binz(z)*Rz(za-z+1)
                                 i = index_of(xx,yy,zz) - bf
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               else                                           ! Include normalisers
                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        xa = ax(a); ya = ay(a); za = az(a)
                        binx => GAUSSIAN_DATA::binomial_p1(xa)%element
                        biny => GAUSSIAN_DATA::binomial_p1(ya)%element
                        binz => GAUSSIAN_DATA::binomial_p1(za)%element
                        k = k + 1
                        P_ab = P(fa+a,fb+b)
                        do x = 1,xa 
                           xx = xb + x - 1
                           fx = binx(x)*Rx(xa-x+1)*P_ab
                           do y = 1,ya 
                              yy = yb + y - 1
                              fy = biny(y)*Ry(ya-y+1)
                              do z = 1,za 
                                 zz = zb + z - 1
                                 fz = binz(z)*Rz(za-z+1)
                                 i = index_of(xx,yy,zz) - bf
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               end
            end  ! Trasfer to b
         end     ! general case

         sh.destroy_ptr_part

      end        ! loop over shell pairs

      Rz.destroy
      Ry.destroy
      Rx.destroy

   end

   forward_transfer(JJ,J) ::: leaky
   ! Apply the horizontal recursion relation (i.e. the transfer
   ! relation) to shellpair vector "JJ" to produce the matrix "J".
   ! This is a post-processing operation to shift momentum from\
   ! center a -> b.
      JJ :: VEC{VEC_{REAL}}
      J :: MAT{REAL}
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(JJ.dim==.n_shell_pairs,"wrong size, JJ")
   ENSURE(J.dim1==.n_bf,"wrong size, J")
   ENSURE(J.is_square,"wrong shape, J")

      q,fa,la,na,fb,lb,nb :: INT
      ab :: VEC{REAL}*
      W  :: MAT{REAL}*
      sh :: SHELL2

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         ab => JJ(q).element
         W.create(sh.a.n_comp,sh.b.n_comp)
         sh.transfer(ab,W)
         J(fa:la,fb:lb) = W
         W.destroy

         sh.destroy_ptr_part

      end 

   end

   create_transfer(JJ) ::: leaky
   ! Create space for the transfer vector "JJ". It is a shellpair vector of
   ! flattened es-type componenets from which ab components can be formed by the
   ! transfer relation.
      JJ :: VEC{VEC_{REAL}}*
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")

      q,fa,la,na,fb,lb,nb :: INT
      sh :: SHELL2
      JJ.create(.n_shell_pairs)                        ! leaky
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
         JJ(q).element.create(sh.n_gaussian)           ! leaky
         JJ(q).element = ZERO
         sh.destroy_ptr_part
      end 
   end

   make_r_JK_direct(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
   ! symmetric density matrix "P" directly.
      J,K,P :: MAT{REAL}

   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")

      I,max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld,na,nb,nc,nd :: INT
      atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
      factor,cutoff,P_max,IP_max,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J = ZERO
      K = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff
      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .initialise_max_I
      max_P.create(.n_shell_pairs)

      .make_max_density_elements(max_P,P)
      P_max = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      parallel do ab = 1,.n_shell_pairs

         if (.max_I(ab)*IP_max < cutoff) cycle

         .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)
         ab_same = atom_a==atom_b
         .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

         do cd = 1,ab

            if (.max_I(ab)*.max_I(cd)*P_max < cutoff) cycle
            .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d) 
            cd_same = atom_c==atom_d

            skip = MOLECULE::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle

            factor = ONE
            if (aa==bb) factor = HALF
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor

            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d 
            if (any_same) then
               .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd
            else
               .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd
            end

            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = factor * I(abcd)
               J(a,b) = J(a,b) + I_abcd*P(d,c)
               J(c,d) = J(c,d) + I_abcd*P(b,a)
               K(a,c) = K(a,c) + I_abcd*P(d,b)
               K(a,d) = K(a,d) + I_abcd*P(c,b)
               K(b,c) = K(b,c) + I_abcd*P(d,a)
               K(b,d) = K(b,d) + I_abcd*P(c,a)
            end
            end
            end
            end

            I.destroy

         end

         sh4n.destroy_ab
         sh4s.destroy_ab
      end

      max_P.destroy
      if (no_max_I) .max_I.destroy
      .weight_diagonal_blocks(J,TWO)
      .blockwise_symmetric_fold(K)
      J = TWO*J
      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
        PARALLEL_SYMMETRIC_SUM(K)
      else
        J.symmetric_reflect
        K.symmetric_reflect
      end

      .put_debug(J,"make_r_JK_direct: J")
      .put_debug(K,"make_r_JK_direct: K")

   end

   make_r_JK_direct2(J,K,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
      J,K,P :: MAT{REAL}

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")

      PP,JJ :: VEC{VEC_{REAL}}*
      max_P,Jab,Jcd,Pab,Pcd :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,JP_cut,KP_cut,P_max,IP_max :: REAL
      skip_J,skip_K,ab_same,cd_same,any_same,no_max_I,ab_eq_cd :: BIN

      ! Prepare for J-matrix engine
      .reverse_transfer(P,PP)
      .create_transfer(JJ)

      ! Schwarz test and density test cutoffs
      cutoff = .scfdata.eri_schwarz_cutoff
      JP_cut = .scfdata.eri_J_density_cutoff
      KP_cut = .scfdata.eri_K_density_cutoff

      ! Get Schwarz test integrals and densities
      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .initialise_max_I
      max_P.create(.n_shell_pairs); .make_max_density_elements(max_P,P)
      P_max = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      ! Initialise J, K
      J = ZERO
      K = ZERO

      ! Loop over (ab| basis function pairs
      parallel do ab = 1,.n_shell_pairs

       if (.max_I(ab)*IP_max < cutoff)  cycle 

       .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

       ab_same = atom_a==atom_b

       ! Set primitive-pair skipped and non-skipped quartets
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

       ! Set up (ab| J/P matrix vectors
       Jab => JJ(ab).element
       Pab => PP(ab).element

       ! Loop over |cd) basis function pairs
       do cd = 1,ab

         if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 

         .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d) 

         cd_same = atom_c==atom_d

         MOLECULE::schwarz_test(skip_J,skip_K,cutoff,JP_cut,KP_cut,ab,cd,aa,bb,cc,dd,max_P,.max_I)

         if (skip_J AND skip_K) cycle

         ! Set up |cd) J/P matrix vectors
         Jcd => JJ(cd).element
         Pcd => PP(cd).element

         ! Integral (ab|cd) permutation factor
         ab_eq_cd = FALSE
         if (aa==bb) then; factor = HALF 
         else;             factor = ONE
         end
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) then
            ab_eq_cd = TRUE
            factor = HALF * factor
         end

         ! Make the J/K matrix contributions
         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            sh4n.make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            sh4s.make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
            sh4s.destroy_cd
         end

       end

       ! Clean (ab| quartet info
       sh4n.destroy_ab
       sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      ! Do the J matrix forward transfer
      .forward_transfer(JJ,J)

      ! Add in diagonal block factors
      .weight_diagonal_blocks(J,TWO)
      .blockwise_symmetric_fold(K)
      J = TWO*J

      ! Parallel sums, if reqd.
      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
        PARALLEL_SYMMETRIC_SUM(K)
      else
        J.symmetric_reflect
        K.symmetric_reflect
      end

      JJ.destroy; PP.destroy
      .put_debug(J,"make_r_JK_direct2: J")
      .put_debug(K,"make_r_JK_direct2: K")

   end

   make_r_J_direct(J,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
      J,P :: MAT{REAL}

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")

      PP,JJ :: VEC{VEC_{REAL}}*
      max_P,Jab,Jcd,Pab,Pcd :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,P_max,IP_max :: REAL
      skip,ab_same,cd_same,any_same,no_max_I,ab_eq_cd :: BIN

      .reverse_transfer(P,PP)
      .create_transfer(JJ)

      J = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff
      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .initialise_max_I
      max_P.create(.n_shell_pairs)
      .make_max_density_elements(max_P,P)
      P_max = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      parallel do ab = 1,.n_shell_pairs

       if (.max_I(ab)*IP_max < cutoff)  cycle 

       .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

       ab_same = atom_a==atom_b
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

       Jab => JJ(ab).element
       Pab => PP(ab).element

       do cd = 1,ab

         if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 

         .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d) 

         cd_same = atom_c==atom_d
         MOLECULE::schwarz_J_test(skip,cutoff,ab,cd,max_P,.max_I)

         if (skip) cycle

         Jcd => JJ(cd).element
         Pcd => PP(cd).element

         ab_eq_cd = FALSE
         if (aa==bb) then; factor = HALF 
         else;             factor = ONE
         end
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) then
            ab_eq_cd = TRUE
            factor = HALF * factor
         end

         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            sh4n.make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,ab_eq_cd)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            sh4s.make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,ab_eq_cd)
            sh4s.destroy_cd
         end
       end

       sh4n.destroy_ab
       sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .forward_transfer(JJ,J)

      .weight_diagonal_blocks(J,TWO)
      J = TWO*J

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
      else
        J.symmetric_reflect
      end

      JJ.destroy
      PP.destroy

   end

!   make_r_J_direct(J,P)
!   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
!   ! directly.
!     J,P :: MAT{REAL}
!     max_I,max_P :: VEC{REAL}*
!     sh4 :: SHELL4
!     ab,cd,aa,bb,cc,dd :: INT
!     fa,fb,fc,fd,la,lb,lc,ld :: INT
!     factor,cutoff,P_max,IP_max :: REAL
!     skip :: BIN
!     J = ZERO
!     cutoff = .scfdata.eri_schwarz_cutoff
!     max_I.create(.n_shell_pairs)
!     max_P.create(.n_shell_pairs)
!     .make_max_abab_integrals(max_I)
!     .make_max_density_elements(max_P,P)
!     P_max = maxval(max_P)
!     IP_max = maxval(max_I) * P_max
!     parallel do ab = 1,.n_shell_pairs
!       if (max_I(ab)*IP_max < cutoff)  cycle   ! Rough version of Schwarz test, but quick.
!       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb) ! a & b shell indices.
!       .copy_shell_quartet_ab(sh4,aa,bb)
!       do cd = 1,ab
!         if (max_I(ab)*max_I(cd)*P_max < cutoff)  cycle ! Rough version of Schwarz test, but quick.
!         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld)  ! c & d shell indices.
!                                        ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,max_I)
!         if (skip) cycle
!
!         .copy_shell_quartet_cd(sh4,cc,dd)
!         if (aa==bb) then                   ! Evaluate the integrals'
!           factor = HALF                    ! coincidence factors
!         else
!           factor = ONE
!         end
!         if (cc==dd) factor = HALF * factor
!         if (aa==cc AND bb==dd) factor = HALF * factor
!         sh4.make_r_J(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!         sh4.destroy_cd
!       end
!       sh4.destroy_ab
!     end
!     max_P.destroy
!     max_I.destroy
!     .weight_diagonal_blocks(J,TWO)
!     if (DO_IN_PARALLEL) then
!        PARALLEL_SYMMETRIC_SUM(J)
!     else
!        J.symmetric_reflect
!     end
!     J = TWO*J
!   end

   make_r_K_direct(K,P)
   ! Make the real exchange matrix "K" from a symmetric density matrix "P"
   ! directly.
      K,P :: MAT{REAL}

      I,max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld,na,nb,nc,nd :: INT
      atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
      factor,cutoff,P_max,IP_max,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      K = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff
      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .initialise_max_I
      max_P.create(.n_shell_pairs)
      .make_max_density_elements(max_P,P)
      P_max = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      parallel do ab = 1,.n_shell_pairs

       if (.max_I(ab)*IP_max < cutoff)  cycle 

       .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

       ab_same = atom_a==atom_b

       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

       do cd = 1,ab

         if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 

         .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d) 

         cd_same = atom_c==atom_d

         MOLECULE::schwarz_K_test(skip,cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
         if (skip) cycle

         if (aa==bb) then                   ! Evaluate the integrals'
           factor = HALF                    ! coincidence factors
         else
           factor = ONE
         end
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) factor = HALF * factor

         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
            SHELL1QUARTET::make_ERI(sh4n,I)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
            SHELL1QUARTET::make_ERI(sh4s,I)
            sh4s.destroy_cd
         end

         abcd = 0
         do d = fd,ld
         do c = fc,lc
         do b = fb,lb
         do a = fa,la
            abcd = abcd + 1
            I_abcd = factor * I(abcd)
            K(a,c) = K(a,c) + I_abcd*P(d,b)
            K(a,d) = K(a,d) + I_abcd*P(c,b)
            K(b,c) = K(b,c) + I_abcd*P(d,a)
            K(b,d) = K(b,d) + I_abcd*P(c,a)
         end
         end
         end
         end

         I.destroy

       end

       sh4n.destroy_ab
       sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .blockwise_symmetric_fold(K)

      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(K)
      else
        K.symmetric_reflect
      end

   end

   make_r_JK_disk(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
   ! symmetric density matrix "P" from disk integral archive "eri_integrals"
      J,K,P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      eri_archive,ind_archive :: ARCHIVE
      I :: MAT4{REAL}*
      q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
      I_abcd,P_dc,P_db,P_cb :: REAL

      eri_archive.set(.name,"eri_integrals")
      ind_archive.set(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open(for="read-only")
      ind_archive.open(for="read-only")

      J = ZERO
      K = ZERO
      n_quartets = .n_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         I.create(fa,la,fb,lb,fc,lc,fd,ld)

         eri_archive.Bfile.read(I)

         do d = fd,ld
           do c = fc,lc
             P_dc = P(d,c)
             do b = fb,lb
               P_db = P(d,b)
               P_cb = P(c,b)
               do a = fa,la
                  I_abcd = I(a,b,c,d)
                  J(a,b) = J(a,b) + I_abcd*P_dc
                  J(c,d) = J(c,d) + I_abcd*P(b,a)
                  K(a,c) = K(a,c) + I_abcd*P_db
                  K(a,d) = K(a,d) + I_abcd*P_cb
                  K(b,c) = K(b,c) + I_abcd*P(d,a)
                  K(b,d) = K(b,d) + I_abcd*P(c,a)
               end
             end
           end
         end

         I.destroy

      end

      ind_archive.close
      eri_archive.close

      .weight_diagonal_blocks(J,TWO)
      .blockwise_symmetric_fold(K)

      J.symmetric_reflect
      K.symmetric_reflect

      J = TWO*J

   end

   make_r_J_disk(J,P)
   ! Make the real coulomb matrix "J" from a
   ! symmetric density matrix "P" from disk integral archive "eri_integrals"
      J,P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      eri_archive,ind_archive :: ARCHIVE
      I :: MAT4{REAL}*
      q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
      I_abcd,P_dc :: REAL

      eri_archive.set(.name,"eri_integrals")
      ind_archive.set(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open(for="read-only")
      ind_archive.open(for="read-only")

      J = ZERO
      n_quartets = .n_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         I.create(fa,la,fb,lb,fc,lc,fd,ld)

         eri_archive.Bfile.read(I)

         do d = fd,ld
           do c = fc,lc
             P_dc = P(d,c)
             do b = fb,lb
               do a = fa,la
                  I_abcd = I(a,b,c,d)
                  J(a,b) = J(a,b) + I_abcd*P_dc
                  J(c,d) = J(c,d) + I_abcd*P(b,a)
               end
             end
           end
         end

         I.destroy

      end

      ind_archive.close
      eri_archive.close

      .weight_diagonal_blocks(J,TWO)
      J.symmetric_reflect
      J = TWO*J

   end

   make_r_K_disk(K,P)
   ! Make the real exchange matrix "K" from a symmetric density matrix "P" from
   ! disk integral archive "eri_integrals"
      K,P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      eri_archive,ind_archive :: ARCHIVE
      I :: MAT4{REAL}*
      q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
      I_abcd,P_db,P_cb :: REAL

      eri_archive.set(.name,"eri_integrals")
      ind_archive.set(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open(for="read-only")
      ind_archive.open(for="read-only")

      K = ZERO

      n_quartets = .n_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         I.create(fa,la,fb,lb,fc,lc,fd,ld)

         eri_archive.Bfile.read(I)

         do d = fd,ld
           do c = fc,lc
             do b = fb,lb
               P_db = P(d,b)
               P_cb = P(c,b)
               do a = fa,la
                  I_abcd = I(a,b,c,d)
                  K(a,c) = K(a,c) + I_abcd*P_db
                  K(a,d) = K(a,d) + I_abcd*P_cb
                  K(b,c) = K(b,c) + I_abcd*P(d,a)
                  K(b,d) = K(b,d) + I_abcd*P(c,a)
               end
             end
           end
         end

         I.destroy

      end

      ind_archive.close
      eri_archive.close

      .blockwise_symmetric_fold(K)
      K.symmetric_reflect

   end

   make_r_JK_nosym(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the
   ! density matrix "P" which has no permutational symmetry.
      J,K,P :: MAT{REAL}
      I :: VEC{REAL}*
      max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd :: INT
      a,b,c,d,abcd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,P_max,IP_max,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J = ZERO
      K = ZERO

      cutoff = SCFDATA_ERI_DISK_CUTOFF
      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .initialise_max_I
      max_P.create(.n_shell_pairs)
      .make_max_density_elements(max_P,P)
      P_max = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      do ab = 1,.n_shell_pairs

        if (.max_I(ab)*IP_max < cutoff)  cycle  

        .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

        ab_same = atom_a==atom_b
        .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
        .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

        do cd = 1,ab

           if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 

           .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d) 

           cd_same = atom_c==atom_d

           skip = MOLECULE::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
           if (skip) cycle

           if (aa==bb) then; factor = HALF      ! coincidence factors
           else;             factor = ONE
           end
           if (cc==dd) factor = HALF * factor
           if (aa==cc AND bb==dd) factor = HALF * factor

           any_same = ab_same OR cd_same OR &
                      atom_a==atom_c OR atom_a==atom_d OR &
                      atom_b==atom_c OR atom_b==atom_d 
           if (any_same) then
              .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
              I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
              SHELL1QUARTET::make_ERI(sh4n,I)
              sh4n.destroy_cd
           else
              .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
              I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
              SHELL1QUARTET::make_ERI(sh4s,I)
              sh4s.destroy_cd
           end

           abcd = 0

           do d = fd,ld
           do c = fc,lc
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              J(a,b) = J(a,b) + I_abcd*P(d,c) ! These are symmetric
              J(a,b) = J(a,b) + I_abcd*P(c,d)
              J(b,a) = J(b,a) + I_abcd*P(d,c)
              J(b,a) = J(b,a) + I_abcd*P(c,d)
              J(c,d) = J(c,d) + I_abcd*P(b,a)
              J(c,d) = J(c,d) + I_abcd*P(a,b)
              J(d,c) = J(d,c) + I_abcd*P(b,a)
              J(d,c) = J(d,c) + I_abcd*P(a,b)
              K(a,d) = K(a,d) + I_abcd*P(b,c) ! These are asymmetric
              K(a,c) = K(a,c) + I_abcd*P(b,d)
              K(b,c) = K(b,c) + I_abcd*P(a,d)
              K(b,d) = K(b,d) + I_abcd*P(a,c)
              K(d,a) = K(d,a) + I_abcd*P(c,b)
              K(c,a) = K(c,a) + I_abcd*P(d,b)
              K(c,b) = K(c,b) + I_abcd*P(d,a)
              K(d,b) = K(d,b) + I_abcd*P(c,a)
           end
           end
           end
           end

           I.destroy

        end

        sh4n.destroy_ab
        sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

   end

!   make_r_JK_nosym(J,K,P)
!   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the
!   ! density matrix "P" which has no permutational symmetry.
!     J,K,P :: MAT{REAL}
!     I :: MAT4{REAL}*
!     max_P :: VEC{REAL}*
!     sh4 :: SHELL4
!     ab,cd,i_a,i_b,i_c,i_d :: INT
!     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     I_abcd,factor,cutoff :: REAL
!     skip :: BIN
!     J = ZERO
!     K = ZERO
!     cutoff = SCFDATA_ERI_DISK_CUTOFF
!     if (.max_I.destroyed) .initialise_max_I
!     max_P.create(.n_shell_pairs)
!     .make_max_density_elements(max_P,P)
!     do ab = 1, .n_shell_pairs
!       .get_shell_pair_indices(ab,i_a,i_b)    ! a & b shell indices.
!       fa = .first_basis_fn_for_shell(i_a)
!       fb = .first_basis_fn_for_shell(i_b)
!       la = .last_basis_fn_for_shell(i_a)
!       lb = .last_basis_fn_for_shell(i_b)
!       .copy_shell_quartet_ab(sh4,i_a,i_b)
!       do cd = 1,ab
!         .get_shell_pair_indices(cd,i_c,i_d)  ! c & d shell indices.
!         fc = .first_basis_fn_for_shell(i_c)
!         fd = .first_basis_fn_for_shell(i_d)
!         lc = .last_basis_fn_for_shell(i_c)
!         ld = .last_basis_fn_for_shell(i_d)
!                                        ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,i_a,i_b,i_c,i_d,max_P,.max_I)
!         if (skip) cycle
!                                              ! calculate ab|cd
!         .copy_shell_quartet_cd(sh4,i_c,i_d)
!         factor = ONE                         ! Evaluate the integrals'
!         if (i_a==i_b) factor = HALF          ! coincidence factors
!         if (i_c==i_d) factor = HALF * factor
!         if (i_a==i_c AND i_b==i_d) factor = HALF * factor
!         I.create(fa,la,fb,lb,fc,lc,fd,ld)
!         sh4.get_ERI(I)
!           do d = fd,ld
!           do c = fc,lc
!           do b = fb,lb
!           do a = fa,la
!            I_abcd = factor * I(a,b,c,d)
!            J(a,b) = J(a,b) + I_abcd*P(d,c) ! These are symmetric
!            J(a,b) = J(a,b) + I_abcd*P(c,d)
!            J(b,a) = J(b,a) + I_abcd*P(d,c)
!            J(b,a) = J(b,a) + I_abcd*P(c,d)
!            J(c,d) = J(c,d) + I_abcd*P(b,a)
!            J(c,d) = J(c,d) + I_abcd*P(a,b)
!            J(d,c) = J(d,c) + I_abcd*P(b,a)
!            J(d,c) = J(d,c) + I_abcd*P(a,b)
!            K(a,d) = K(a,d) + I_abcd*P(b,c) ! These are asymmetric
!            K(a,c) = K(a,c) + I_abcd*P(b,d)
!            K(b,c) = K(b,c) + I_abcd*P(a,d)
!            K(b,d) = K(b,d) + I_abcd*P(a,c)
!            K(d,a) = K(d,a) + I_abcd*P(c,b)
!            K(c,a) = K(c,a) + I_abcd*P(d,b)
!            K(c,b) = K(c,b) + I_abcd*P(d,a)
!            K(d,b) = K(d,b) + I_abcd*P(c,a)
!           end
!           end
!           end
!           end
!         I.destroy
!         sh4.destroy_cd
!       end
!       sh4.destroy_ab
!     end
!     max_P.destroy
!   end

   make_u_JK_direct(J,K,P)
   ! Make the unrestricted coulomb matrices "J" and exchange matrices "K" matrix
   ! from density matrix "P".
      J,K,P :: OPMATRIX*

   ENSURE(J.created("unrestricted"),"unrestricted J not created")
   ENSURE(K.created("unrestricted"),"unrestricted K not created")
   ENSURE(P.created("unrestricted"),"unrestricted P not created")

      PP :: MAT{REAL}*
      I,max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld,na,nb,nc,nd :: INT
      atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
      factor,cutoff,I_abcd :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J.set_to_zero
      K.set_to_zero

      cutoff = .scfdata.eri_schwarz_cutoff
      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .initialise_max_I
      max_P.create(.n_shell_pairs)
      PP.create(.n_bf,.n_bf)
      PP = P.alpha + P.beta
      .make_max_density_elements(max_P,PP)
      PP.destroy


      do ab = 1, .n_shell_pairs
         .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)
         ab_same = atom_a==atom_b
         .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
         .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
         do cd = 1,ab
            .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d) 
            cd_same = atom_c==atom_d
                                                 ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
            skip = MOLECULE::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
            if (skip) cycle
                                                 ! calculate ab|cd
            factor = ONE                         ! Evaluate the integrals'
            if (aa==bb) factor = HALF            ! coincidence factors
            if (cc==dd) factor = HALF * factor
            if (aa==cc AND bb==dd) factor = HALF * factor
            any_same = ab_same OR cd_same OR &
                       atom_a==atom_c OR atom_a==atom_d OR &
                       atom_b==atom_c OR atom_b==atom_d 
            if (any_same) then
               .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
               I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4n,I)
               sh4n.destroy_cd
            else
               .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
               I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
               SHELL1QUARTET::make_ERI(sh4s,I)
               sh4s.destroy_cd
            end
            abcd = 0
            do d = fd,ld
            do c = fc,lc
            do b = fb,lb
            do a = fa,la
               abcd = abcd + 1
               I_abcd = factor * I(abcd)
               J.alpha(a,b) = J.alpha(a,b) + I_abcd*P.alpha(d,c)
               J.alpha(c,d) = J.alpha(c,d) + I_abcd*P.alpha(b,a)
               K.alpha(a,c) = K.alpha(a,c) + I_abcd*P.alpha(d,b)
               K.alpha(a,d) = K.alpha(a,d) + I_abcd*P.alpha(c,b)
               K.alpha(b,c) = K.alpha(b,c) + I_abcd*P.alpha(d,a)
               K.alpha(b,d) = K.alpha(b,d) + I_abcd*P.alpha(c,a)
               J.beta(a,b) = J.beta(a,b) + I_abcd*P.beta(d,c)
               J.beta(c,d) = J.beta(c,d) + I_abcd*P.beta(b,a)
               K.beta(a,c) = K.beta(a,c) + I_abcd*P.beta(d,b)
               K.beta(a,d) = K.beta(a,d) + I_abcd*P.beta(c,b)
               K.beta(b,c) = K.beta(b,c) + I_abcd*P.beta(d,a)
               K.beta(b,d) = K.beta(b,d) + I_abcd*P.beta(c,a)
            end
            end
            end
            end
            I.destroy
         end
         sh4n.destroy_ab
         sh4s.destroy_ab
      end
      max_P.destroy
      if (no_max_I) .max_I.destroy
      .weight_diagonal_blocks(J.alpha,TWO)
      .weight_diagonal_blocks(J.beta,TWO)
      .blockwise_symmetric_fold(K.alpha)
      .blockwise_symmetric_fold(K.beta)
      J.alpha.symmetric_reflect
      J.beta.symmetric_reflect
      K.alpha.symmetric_reflect
      K.beta.symmetric_reflect
      J.alpha = TWO*J.alpha
      J.beta  = TWO*J.beta
   end

   make_u_JK_direct2(J,K,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
      J,K,P :: OPMATRIX*

   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")
   ENSURE(J.created("unrestricted"),"unrestricted J not created")
   ENSURE(K.created("unrestricted"),"unrestricted K not created")
   ENSURE(P.created("unrestricted"),"unrestricted P not created")

      PA,PB,JA,JB :: VEC{VEC_{REAL}}*
      max_P,JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      factor,cutoff,JP_cut,KP_cut,P_max,IP_max :: REAL
      skip_J,skip_K,ab_same,cd_same,any_same,no_max_I,ab_eq_cd :: BIN

      ! Prepare for J-matrix engine
      .reverse_transfer(P.alpha,PA)
      .reverse_transfer( P.beta,PB)
      .create_transfer(JA)
      .create_transfer(JB)

      ! Schwarz test and density test cutoffs
      cutoff = .scfdata.eri_schwarz_cutoff
      JP_cut = .scfdata.eri_J_density_cutoff
      KP_cut = .scfdata.eri_K_density_cutoff

      ! Get Schwarz test integrals and densities
      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .initialise_max_I
      max_P.create(.n_shell_pairs); .make_max_density_elements(max_P,P.alpha,P.beta)
      P_max = maxval(max_P)
      IP_max = maxval(.max_I) * P_max

      ! Initialise J, K
      J.alpha = ZERO; J.beta = ZERO
      K.alpha = ZERO; K.beta = ZERO

      ! Loop over (ab| basis function pairs
      parallel do ab = 1,.n_shell_pairs

       if (.max_I(ab)*IP_max < cutoff)  cycle 

       .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

       ab_same = atom_a==atom_b

       ! Set primitive-pair skipped and non-skipped quartets
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

       ! Set up (ab| J/P matrix vectors
       JAab => JA(ab).element; JBab => JB(ab).element
       PAab => PA(ab).element; PBab => PB(ab).element

       ! Loop over |cd) basis function pairs
       do cd = 1,ab

         if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 

         .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d) 

         cd_same = atom_c==atom_d

         MOLECULE::schwarz_test(skip_J,skip_K,cutoff,JP_cut,KP_cut,ab,cd,aa,bb,cc,dd,max_P,.max_I)

         if (skip_J AND skip_K) cycle

         ! Set up |cd) J/P matrix vectors
         JAcd => JA(cd).element; JBcd => JA(cd).element
         PAcd => PA(cd).element; PBcd => PB(cd).element

         ! Integral (ab|cd) permutation factor
         ab_eq_cd = FALSE
         if (aa==bb) then; factor = HALF 
         else;             factor = ONE
         end
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) then
            ab_eq_cd = TRUE
            factor = HALF * factor
         end

         ! Make the J/K matrix contributions
         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            sh4n.make_r_JK_engine(JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd,K.alpha,K.beta,P.alpha,P.beta & 
                                 ,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            sh4s.make_r_JK_engine(JAab,JBab,JAcd,JBcd,PAab,PBab,PAcd,PBcd,K.alpha,K.beta,P.alpha,P.beta & 
                                 ,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
            sh4s.destroy_cd
         end

       end

       ! Clean (ab| quartet info
       sh4n.destroy_ab
       sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      ! Do the J matrix forward transfer
      .forward_transfer(JA,J.alpha)
      .forward_transfer(JB, J.beta)

      ! Add in diagonal block factors
      .weight_diagonal_blocks(J.alpha,TWO)
      .weight_diagonal_blocks( J.beta,TWO)
      .blockwise_symmetric_fold(K.alpha)
      .blockwise_symmetric_fold(K.beta)
      J.alpha = TWO*J.alpha
      J.beta  = TWO*J.beta

      ! Parallel sums, if reqd.
      if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J.alpha)
        PARALLEL_SYMMETRIC_SUM(J.beta)
        PARALLEL_SYMMETRIC_SUM(K.alpha)
        PARALLEL_SYMMETRIC_SUM(K.beta)
      else
        J.alpha.symmetric_reflect
         J.beta.symmetric_reflect
        K.alpha.symmetric_reflect
         K.beta.symmetric_reflect
      end

      ! Clean up transfer arrays
      JB.destroy; JA.destroy
      PB.destroy; PA.destroy

   end

!   make_u_JK_direct(J,Ka,Kb,P,Pa,Pb)
!   ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
!   ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
!     J,Ka,Kb,P,Pa,Pb :: MAT{REAL},target
!     I :: MAT4{REAL}*
!     max_P :: VEC{REAL}*
!     sh4 :: SHELL4
!!     sh4q :: SHELL1QUARTET
!     ab,cd, aa,bb,cc,dd :: INT
!     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     I_abcd,factor,Pa_db,Pa_cb,Pb_db,Pb_cb,cutoff :: REAL
!     P_dc,Jcd,Ka_bc,Ka_bd,Kb_bc,Kb_bd :: REAL
!     skip :: BIN
!     J  = ZERO
!     Ka = ZERO
!     Kb = ZERO
!     cutoff = .scfdata.eri_schwarz_cutoff
!     max_P.create(.n_shell_pairs)
!     .make_max_density_elements(max_P,P)
!     if (.max_I.destroyed) .initialise_max_I
!     do ab = 1, .n_shell_pairs
!       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb)   ! a & b shell indices.
!!       .set_precomp_shell_quartet_ab(sh4q,aa,bb)
!       .copy_shell_quartet_ab(sh4,aa,bb)
!       do cd = 1,ab
!         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld) ! c & d shell indices.
!                                              ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
!         if (skip) cycle
!                                              ! calculate ab|cd
!         .copy_shell_quartet_cd(sh4,cc,dd)
!!         .set_precomp_shell_quartet_cd(sh4q,cc,dd)
!         factor = ONE                         ! Evaluate the integrals'
!         if (aa==bb) factor = HALF            ! coincidence factors
!         if (cc==dd) factor = HALF * factor
!         if (aa==cc AND bb==dd) factor = HALF * factor
!         I.create(fa,la,fb,lb,fc,lc,fd,ld)
!         sh4.get_ERI(I)
!!         sh4q.get_ERI(I)
!         do d = fd,ld
!           do c = fc,lc
!             P_dc = P(d,c)
!             Jcd = ZERO
!             do b = fb,lb
!               Pa_db = Pa(d,b)
!               Pb_db = Pb(d,b)
!               Pa_cb = Pa(c,b)
!               Pb_cb = Pb(c,b)
!               Ka_bc = ZERO
!               Kb_bc = ZERO
!               Ka_bd = ZERO
!               Kb_bd = ZERO
!               do a = fa,la
!                 I_abcd  = factor  * I(a,b,c,d)
!                 J(a,b)  = J(a,b)  + I_abcd*P_dc
!                 Jcd     = Jcd     + I_abcd*P(b,a)
!                 Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
!                 Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
!                 Ka_bc   = Ka_bc   + I_abcd*Pa(d,a)
!                 Ka_bd   = Ka_bd   + I_abcd*Pa(c,a)
!                 Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
!                 Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
!                 Kb_bc   = Kb_bc   + I_abcd*Pb(d,a)
!                 Kb_bd   = Kb_bd   + I_abcd*Pb(c,a)
!               end
!               Ka(b,c) = Ka(b,c) + Ka_bc
!               Ka(b,d) = Ka(b,d) + Ka_bd
!               Kb(b,c) = Kb(b,c) + Kb_bc
!               Kb(b,d) = Kb(b,d) + Kb_bd
!             end
!             J(c,d) = J(c,d) + Jcd
!           end
!         end
!         I.destroy
!         sh4.destroy_cd
!!         sh4q.destroy_cd
!       end
!       sh4.destroy_ab
!!       sh4q.destroy_ab
!     end
!     max_P.destroy
!     .weight_diagonal_blocks(J,TWO)
!     .blockwise_symmetric_fold(Ka)
!     .blockwise_symmetric_fold(Kb)
!     J.symmetric_reflect
!     Ka.symmetric_reflect
!     Kb.symmetric_reflect
!     J = TWO*J
!   end

   make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
   ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
   ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
      J,Ka,Kb,P,Pa,Pb :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      I :: MAT4{REAL}*
      eri_archive,ind_archive :: ARCHIVE*
      q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
      I_abcd,P_dc,Pa_db,Pa_cb,Pb_db,Pb_cb :: REAL

      eri_archive.create(.name,"eri_integrals")
      ind_archive.create(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open(for="read-only")
      ind_archive.open(for="read-only")

      J  = ZERO
      Ka = ZERO
      Kb = ZERO

      n_quartets = .n_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

         I.create(fa,la,fb,lb,fc,lc,fd,ld)

         eri_archive.Bfile.read(I)

         do d = fd,ld
           do c = fc,lc
             P_dc = P(d,c)
             do b = fb,lb
               Pa_db = Pa(d,b)
               Pb_db = Pb(d,b)
               Pa_cb = Pa(c,b)
               Pb_cb = Pb(c,b)
               do a = fa,la
                  I_abcd = I(a,b,c,d)
                  J(a,b) = J(a,b) + I_abcd*P_dc
                  J(c,d) = J(c,d) + I_abcd*P(b,a)
                  Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
                  Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
                  Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
                  Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
                  Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
                  Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
                  Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
                  Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
               end
             end
           end
         end

         I.destroy

      end

      ind_archive.destroy
      eri_archive.destroy

      .weight_diagonal_blocks(J,TWO)
      .blockwise_symmetric_fold(Ka)
      .blockwise_symmetric_fold(Kb)

      J.symmetric_reflect
      Ka.symmetric_reflect
      Kb.symmetric_reflect

      J = TWO*J

   end

   make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
   ! Make the general complex matrices "J" and exchange matrices
   ! "Ka", "Kb" and "Kba" from a density matrices "P", "Pa", "Pb" and "Pba"
   ! directly from the integrals.
      J,P :: MAT{REAL}
      Ka,Kb,Kba,Pa,Pb,Pba :: MAT{CPX}
      I :: VEC{REAL}*
      abs_P :: MAT{REAL}*
      max_P :: VEC{REAL}*
      sh4s,sh4n :: SHELL1QUARTET
      ab,cd,aa,bb,cc,dd :: INT
      a,b,c,d,abcd,fa,fb,fc,fd,la,lb,lc,ld :: INT
      na,nb,nc,nd,atom_a,atom_b,atom_c,atom_d :: INT
      I_abcd,factor,cutoff :: REAL
      skip,ab_same,cd_same,any_same,no_max_I :: BIN

      J   = ZERO
      Ka  = ZERO
      Kb  = ZERO
      Kba = ZERO

      cutoff = .scfdata.eri_schwarz_cutoff
      no_max_I = FALSE
      if (.max_I.destroyed) no_max_I = TRUE
      if (no_max_I) .initialise_max_I
      max_P.create(.n_shell_pairs)
      abs_P.create(.n_bf,.n_bf)
      abs_P = max(abs(P),abs(Pa),abs(Pb),abs(Pba))
      .make_max_density_elements(max_P,abs_P)
      abs_P.destroy

      do ab = 1,.n_shell_pairs

       .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb,atom_a,atom_b)

       ab_same = atom_a==atom_b
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)

       do cd = 1,ab

         .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd,atom_c,atom_d) 

         cd_same = atom_c==atom_d

         skip = MOLECULE::schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
         if (skip) cycle

         factor = ONE                             ! Evaluate the integrals
         if (aa==bb) factor = HALF                ! Coincidence factors
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) factor = HALF * factor

         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            I.create(sh4n.ab_n_bf_pairs*sh4n.cd_n_bf_pairs)
            SHELL1QUARTET::make_ERI(sh4n,I)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            I.create(sh4s.ab_n_bf_pairs*sh4s.cd_n_bf_pairs)
            SHELL1QUARTET::make_ERI(sh4s,I)
            sh4s.destroy_cd
         end

         I = factor * I

         abcd = 0
         do d = fd,ld
         do c = fc,lc
         do b = fb,lb
         do a = fa,la
            abcd = abcd + 1
            I_abcd = I(abcd)
            J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
            J(c,d)   = J(c,d)   + I_abcd*P(b,a)
            Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric
            Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  ! but must be folded
            Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
            Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
            Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric
            Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  ! but must be folded
            Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
            Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
            Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
            Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
            Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
            Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
            Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
            Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
            Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
            Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
         end
         end
         end
         end

         I.destroy

       end

       sh4n.destroy_ab
       sh4s.destroy_ab

      end

      max_P.destroy
      if (no_max_I) .max_I.destroy

      .weight_diagonal_blocks(J,TWO)
      .blockwise_hermitian_fold(Ka)
      .blockwise_hermitian_fold(Kb)
      J.symmetric_reflect
      Ka.make_hermitian
      Kb.make_hermitian
      J = TWO*J

   end

   make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
   ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
   ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
      J,P :: MAT{REAL}
      Ka,Kb,Kba,Pa,Pb,Pba :: MAT{CPX}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      I :: MAT4{REAL}*
      eri_archive,ind_archive :: ARCHIVE*
      q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
      I_abcd :: REAL

      eri_archive.create(.name,"eri_integrals")
      ind_archive.create(.name,"eri_index")

      ENSURE(eri_archive.exists, "no integral file")
      ENSURE(ind_archive.exists, "no integral index file")

      eri_archive.open(for="read-only")
      ind_archive.open(for="read-only")

      J   = ZERO
      Ka  = ZERO
      Kb  = ZERO
      Kba = ZERO

      n_quartets = .n_shell_quartets

      do

         ind_archive.Bfile.read(q)

         if (q > n_quartets) exit

         .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)

       ! I.create(fa,la,fb,lb,fc,lc,fd,ld)
         allocate(I(fa:la,fb:lb,fc:lc,fd:ld))

         eri_archive.Bfile.read(I)

         do d = fd,ld
         do c = fc,lc
         do b = fb,lb
         do a = fa,la
             I_abcd = I(a,b,c,d)
             J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
             J(c,d)   = J(c,d)   + I_abcd*P(b,a)
             Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric but must be folded
             Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)
             Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
             Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
             Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric but must be folded
             Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)
             Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
             Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
             Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
             Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
             Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
             Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
             Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
             Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
             Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
             Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
         end
         end
         end
         end

       ! I.destroy
         deallocate(I)

      end

      ind_archive.destroy
      eri_archive.destroy

      .weight_diagonal_blocks(J,TWO)
      .blockwise_hermitian_fold(Ka)
      .blockwise_hermitian_fold(Kb)

      J.symmetric_reflect
      Ka.make_hermitian
      Kb.make_hermitian

      J = TWO*J

   end

   make_gc_so_JK_direct(JS,KS,JO,KO,P)
   ! Make the general complex spin orbit Classical and Exchange matrices.
   ! Make them directly from integrals on the fly.
      JS,KS,JO,KO :: MAT5{CPX}
      P :: MAT4{CPX}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      S,O :: MAT5{REAL}*
      ab,cd,aa,bb,cc,dd,na,nb,nc,nd :: INT
      a,b,c,d,k,fa,fb,fc,fd,la,lb,lc,ld,m,n :: INT
      S_abcd,O_abcd,factor :: REAL
      sh4 :: SHELL4*
      JS = ZERO; KS = ZERO; JO = ZERO; KO = ZERO
      sh4.create
      do ab = 1,.n_shell_pairs
       .get_shell_pair_indices(ab,aa,bb,fa,la,na,fb,lb,nb)
       do cd = 1,ab
         .get_shell_pair_indices(cd,cc,dd,fc,lc,nc,fd,ld,nd)
         .copy_shell_quartet(sh4,aa,bb,cc,dd)
         if (sh4.skip_ERI) then ! ??????
           sh4.destroy_ptr_part
           cycle
         end
         allocate(S(fa:la,fb:lb,fc:lc,fd:ld,3))
         allocate(O(fa:la,fb:lb,fc:lc,fd:ld,3))
         sh4.make_spin_orbit_ints(S,O)
         factor = ONE                                   ! Evaluate the integrals
         if (aa==bb) factor = HALF                      ! Coincidence factors
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) factor = HALF * factor
         S = factor * S
         O = factor * O
         do k = 1,3
         do a = fa,la
         do b = fb,lb
         do c = fc,lc
         do d = fd,ld
            S_abcd = S(a,b,c,d,k)
            O_abcd = O(a,b,c,d,k)
            do m = 1,2
            do n = 1,2
               !
               JS(a,b, m,n,k) = JS(a,b, m,n,k) + S_abcd*P(d,c, m,n)
               JS(a,b, m,n,k) = JS(a,b, m,n,k) + S_abcd*P(c,d, m,n)
               JS(b,a, m,n,k) = JS(b,a, m,n,k) - S_abcd*P(d,c, m,n)
               JS(b,a, m,n,k) = JS(b,a, m,n,k) - S_abcd*P(c,d, m,n)
               JS(c,d, m,n,k) = JS(c,d, m,n,k) + O_abcd*P(b,a, m,n)
               JS(c,d, m,n,k) = JS(c,d, m,n,k) + O_abcd*P(a,b, m,n)
               JS(d,c, m,n,k) = JS(d,c, m,n,k) - O_abcd*P(b,a, m,n)
               JS(d,c, m,n,k) = JS(d,c, m,n,k) - O_abcd*P(a,b, m,n)
               !
               JO(a,b, m,n,k) = JO(a,b, m,n,k) + O_abcd*P(d,c, m,n)
               JO(a,b, m,n,k) = JO(a,b, m,n,k) - O_abcd*P(c,d, m,n)
               JO(b,a, m,n,k) = JO(b,a, m,n,k) + O_abcd*P(d,c, m,n)
               JO(b,a, m,n,k) = JO(b,a, m,n,k) - O_abcd*P(c,d, m,n)
               JO(c,d, m,n,k) = JO(c,d, m,n,k) + S_abcd*P(b,a, m,n)
               JO(c,d, m,n,k) = JO(c,d, m,n,k) - S_abcd*P(a,b, m,n)
               JO(d,c, m,n,k) = JO(d,c, m,n,k) + S_abcd*P(b,a, m,n)
               JO(d,c, m,n,k) = JO(d,c, m,n,k) - S_abcd*P(a,b, m,n)
               !
               KS(a,d, m,n,k) = KS(a,d, m,n,k) + S_abcd*P(b,c, m,n)
               KS(a,c, m,n,k) = KS(a,c, m,n,k) + S_abcd*P(b,d, m,n)
               KS(b,d, m,n,k) = KS(b,d, m,n,k) - S_abcd*P(a,c, m,n)
               KS(b,c, m,n,k) = KS(b,c, m,n,k) - S_abcd*P(a,d, m,n)
               KS(c,b, m,n,k) = KS(c,b, m,n,k) + O_abcd*P(d,a, m,n)
               KS(c,a, m,n,k) = KS(c,a, m,n,k) + O_abcd*P(d,b, m,n)
               KS(d,b, m,n,k) = KS(d,b, m,n,k) - O_abcd*P(c,a, m,n)
               KS(d,a, m,n,k) = KS(d,a, m,n,k) - O_abcd*P(c,b, m,n)
               !
               KO(a,d, m,n,k) = KO(a,d, m,n,k) + O_abcd*P(b,c, m,n)
               KO(a,c, m,n,k) = KO(a,c, m,n,k) - O_abcd*P(b,d, m,n)
               KO(b,d, m,n,k) = KO(b,d, m,n,k) + O_abcd*P(a,c, m,n)
               KO(b,c, m,n,k) = KO(b,c, m,n,k) - O_abcd*P(a,d, m,n)
               KO(c,b, m,n,k) = KO(c,b, m,n,k) + S_abcd*P(d,a, m,n)
               KO(c,a, m,n,k) = KO(c,a, m,n,k) - S_abcd*P(d,b, m,n)
               KO(d,b, m,n,k) = KO(d,b, m,n,k) + S_abcd*P(c,a, m,n)
               KO(d,a, m,n,k) = KO(d,a, m,n,k) - S_abcd*P(c,b, m,n)
            end
            end
         end
         end
         end
         end
         end
         deallocate(O)
         deallocate(S)
         sh4.destroy_ptr_part
       end
      end
      sh4.destroy
   end

   make_gc_so_JK_disk(JS,KS,JO,KO,P,component)
   ! Make the general complex spin orbit Classical and Exchange matrices
   ! for a particular "component", either "x", "y" or "z".
      JS,KS,JO,KO,P :: MAT4{CPX}
      component :: STR(1)

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      S,O :: MAT4{REAL}*
      SO_archive,ind_archive :: ARCHIVE
      q,n_quartets :: INT
      a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,m,n :: INT
      S_abcd,O_abcd :: REAL

      SO_archive.set(.name,"SO"//component//"_integrals")
      ind_archive.set(.name,"SO_indices")

      ENSURE(SO_archive.exists,  "no spin orbit integral file!")
      ENSURE(ind_archive.exists, "no spin orbit integral index file")

      SO_archive.open(for="read-only")
      ind_archive.open(for="read-only")

      JS = ZERO
      KS = ZERO
      JO = ZERO
      KO = ZERO

      n_quartets = .n_shell_quartets

      do

         ind_archive.Bfile.read(q)
 
         if (q > n_quartets) exit
 
         .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
 
         S.create(fa,la,fb,lb,fc,lc,fd,ld)
         O.create(fa,la,fb,lb,fc,lc,fd,ld)
 
         SO_archive.Bfile.read(S)
         SO_archive.Bfile.read(O)
 
         do a = fa,la
         do b = fb,lb
         do c = fc,lc
         do d = fd,ld
 
            S_abcd = S(a,b,c,d)
            O_abcd = O(a,b,c,d)
 
            do m = 1,2
            do n = 1,2
               !
               JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(d,c, m,n)
               JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(c,d, m,n)
               JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(d,c, m,n)
               JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(c,d, m,n)
               JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(b,a, m,n)
               JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(a,b, m,n)
               JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(b,a, m,n)
               JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(a,b, m,n)
               !
               JO(a,b, m,n) = JO(a,b, m,n) + O_abcd*P(d,c, m,n)
               JO(a,b, m,n) = JO(a,b, m,n) - O_abcd*P(c,d, m,n)
               JO(b,a, m,n) = JO(b,a, m,n) + O_abcd*P(d,c, m,n)
               JO(b,a, m,n) = JO(b,a, m,n) - O_abcd*P(c,d, m,n)
               JO(c,d, m,n) = JO(c,d, m,n) + S_abcd*P(b,a, m,n)
               JO(c,d, m,n) = JO(c,d, m,n) - S_abcd*P(a,b, m,n)
               JO(d,c, m,n) = JO(d,c, m,n) + S_abcd*P(b,a, m,n)
               JO(d,c, m,n) = JO(d,c, m,n) - S_abcd*P(a,b, m,n)
               !
               KS(a,d, m,n) = KS(a,d, m,n) + S_abcd*P(b,c, m,n)
               KS(a,c, m,n) = KS(a,c, m,n) + S_abcd*P(b,d, m,n)
               KS(b,d, m,n) = KS(b,d, m,n) - S_abcd*P(a,c, m,n)
               KS(b,c, m,n) = KS(b,c, m,n) - S_abcd*P(a,d, m,n)
               KS(c,b, m,n) = KS(c,b, m,n) + O_abcd*P(d,a, m,n)
               KS(c,a, m,n) = KS(c,a, m,n) + O_abcd*P(d,b, m,n)
               KS(d,b, m,n) = KS(d,b, m,n) - O_abcd*P(c,a, m,n)
               KS(d,a, m,n) = KS(d,a, m,n) - O_abcd*P(c,b, m,n)
               !
               KO(a,d, m,n) = KO(a,d, m,n) + O_abcd*P(b,c, m,n)
               KO(a,c, m,n) = KO(a,c, m,n) - O_abcd*P(b,d, m,n)
               KO(b,d, m,n) = KO(b,d, m,n) + O_abcd*P(a,c, m,n)
               KO(b,c, m,n) = KO(b,c, m,n) - O_abcd*P(a,d, m,n)
               KO(c,b, m,n) = KO(c,b, m,n) + S_abcd*P(d,a, m,n)
               KO(c,a, m,n) = KO(c,a, m,n) - S_abcd*P(d,b, m,n)
               KO(d,b, m,n) = KO(d,b, m,n) + S_abcd*P(c,a, m,n)
               KO(d,a, m,n) = KO(d,a, m,n) - S_abcd*P(c,b, m,n)
            end
            end
         end
         end
         end
         end
 
         O.destroy
         S.destroy

      end

      SO_archive.close
      ind_archive.close

   end

   weight_diagonal_blocks(X,fac) ::: pure
   ! Weight the diagonal blocks of matrix "X" by "fac"
      self :: IN
      X :: MAT{REAL}, INOUT
      fac :: REAL, IN

      n,f,l :: INT

      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac*X(f:l,f:l)
      end

   end

   weight_diagonal_blocks(X,fac) ::: pure
   ! Weight the diagonal blocks of matrix "X" by "fac"
      self :: IN
      X :: MAT{CPX}, INOUT
      fac :: REAL, IN

      n,f,l :: INT

      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac*X(f:l,f:l)
      end

   end

   set_diagonal_blocks(X,fac) ::: pure
   ! Set the diagonal blocks of matrix "X" to "fac"
      self :: IN
      X :: MAT{REAL}, INOUT
      fac :: REAL, IN

      n,f,l :: INT

      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac
      end

   end

   blockwise_symmetric_fold(X)
   ! Symmetrically fold the matrix "X" blockwise
      X :: MAT{REAL}

      a,fa,la,b,fb,lb :: INT

      do a = 1,.n_shell
      do b = 1,a
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)
         X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(X(fb:lb,fa:la))
      end
      end

   end

   blockwise_hermitian_fold(X)
   ! Hermitian fold the matrix "X" blockwise
      X :: MAT{CPX}

      a,fa,la,b,fb,lb :: INT

      do a = 1,.n_shell
      do b = 1,a
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)
         X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(conjg(X(fb:lb,fa:la)))
      end
      end

   end

!  ==============
!  Restricted DFT
!  ==============

   add_XC_matrix(K) ::: leaky
   ! Add the DFT exchange correlation matrix to "K".
      K :: OPMATRIX*

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.scfdata.is_DFT_calculation,"this is not a DFT calculation")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(K.created,"K not created")
   ENSURE(K.created(.scfdata.spinorbital_kind),"appropriate part of K not created")
      ! Get core and overlap
      genre :: STR

      ! Ensure the NO's exist so we can calculate the density for the XC part
      genre = .scfdata.spinorbital_kind
      if (.molecular_orbitals.all_destroyed) then; .make_natural_orbitals(genre) !  leaky
      else;                                        .assign_NOs_to_MOs
      end

      ! Now add the contribution
      select case (.scfdata.scf_kind)
        case ("rks","xray_rks")
           .add_XC_matrix(K.restricted)
        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
           .add_XC_matrix(K.alpha,K.beta)
        case default
           DIE("unknown DFT SCF kind, "//trim(.scfdata.scf_kind))
      end

   end

   add_XC_matrix(K)
   ! Calculate the exchange correlation matrix numerically.
      K :: MAT{REAL}

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.scfdata.is_DFT_calculation,"this is not a DFT calculation")

      E :: REAL

      if (.scfdata.using_GGA_functional) then
         if (.debugging("use_add_GGA_XC_matrix_old")) then
            .add_GGA_XC_matrix_old(K,E)
         else
            .add_GGA_XC_matrix(K,E)
         end
      else
         if (.debugging("use_add_LDA_XC_matrix_old")) then
            .add_LDA_XC_matrix_old(K,E)
         else
            .add_LDA_XC_matrix(K,E)
         end
      end

      .scfdata.dft_energy_correction = E

   end


   add_LDA_XC_matrix(K,E) ::: leaky
   ! Add the exchange and correlation matrices to K. This routine supports
   ! local functional only, either exchange or correlation.
      K :: MAT{REAL}
      E :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")

      wt, N0,V0,E0 :: VEC{REAL}*
      V,D, pt  :: MAT{REAL}*
      bf_skip  :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      n_pt, c  :: INT

      ! Main temporaries
      E = ZERO
      V.create(.n_bf,.n_bf); V = ZERO

      ! Make the AO density matrix
      D => .density_matrix.restricted

      ! Set up grids, atomic densities, overlapping_atoms -- leaky
    ! .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Make electron density on the Becke-grid for atom "c"
         .make_rho_becke_atom_grid(N0,pt,wt,bf_skip,bf_grid0,c,D)

         ! Make XC potential, energy grids: V0, E0
         pt.destroy
         n_pt = wt.dim
         E0.create(n_pt) ! The energy density
         V0.create(n_pt) ! local potential grids
         .new_set_r_XC_potentials(V0,N0) 
         .new_set_r_XC_energy_density(E0,N0)

         ! Incorporate grid & partition weights
         E0 = wt*E0
         V0 = wt*V0

         ! Clean
         N0.destroy
         wt.destroy

         ! Add the XC matrix elements into V, energy to E 
         ! for atom "c" Becke-grid
         .add_LDA_XC_matrix(V,E,V0,E0,bf_skip,bf_grid0,c,D)

         ! Clean up
         V0.destroy; E0.destroy
         bf_grid0.destroy; bf_skip.destroy

      end ! -- integration atom c

      ! Add the XC contribution to K
      K = K + V
      K.symmetric_reflect

      ! Get DFT energy correction
      V.symmetric_reflect
      E = E - HALF*V.trace_product_with(D)

      ! Clean
      V.destroy

   end

   add_LDA_XC_matrix(V,E,V0,E0,bf_skip,bf_grid0,c,D)
   ! Add XC potential matrix elements to "V", the XC energy to "E".
   ! "V0" is XC potential density on the becke grid for atom "c",
   ! weighted by the partition function for that atom. Likewise, "E0"
   ! is the (partition-weighted) XC energy density of the grid.
   ! "bf_skip" and "bf_grid0 are basis function grids.  "D" is the
   ! density matrix.  This routine supports local functional only.
      V :: MAT{REAL}, target
      E :: REAL
      V0,E0 :: VEC{REAL}, IN
      bf_skip :: VEC{VEC_{BIN}}, IN
      bf_grid0 :: VEC{MAT_{REAL}}, IN
      c :: INT, IN
      D :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")

      ga0,gb0 :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipab, skipa,skipb :: VEC{BIN}*
      VV,DD :: MAT{REAL}*
      grida0,gridb0 :: MAT{REAL}*
      Dab, fac,val,wal, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, a,b,p,i,j,n :: INT

      ! Skip array for ab shell
      n_pt = V0.dim
      skipab.create(n_pt)

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)

         ! Loop shells on atom a
         do sa = fsa,lsa

            if (bf_skip(sa).element.destroyed) cycle

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set the "sb" basis function grid
            skipa  => bf_skip(sa).element 
            grida0 => bf_grid0(sa).element 

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  VV => V(fa:la,fb:lb)
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     val = ZERO
                     wal = ZERO
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga  = ga0(i)
                        gb  = gb0(j)
                        gab = ga*gb
                        val = val + V0(n)*gab 
                        wal = wal + E0(n)*gab
                     end
                     VV(1,1) = VV(1,1) + val
                     E       = E       + wal*Dab

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           val = ZERO
                           wal = ZERO
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              val = val + V0(n)*gab
                              wal = wal + E0(n)*gab
                           end
                           VV(a,b) = VV(a,b) + val
                           E       = E       + wal*Dab
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy

   end

   make_rho_becke_atom_grid(N0,pt,wt,bf_skip,bf_grid0,c,D) ::: leaky
   ! Make the density "N0" on the Becke grid ("pt","wt") for atom
   ! "c" given AO density matrix "D". Also return the "bf_skip" arrays
   ! and the "bf_grid0" array used for evaluating the rho (or other
   ! density functionals) on the grid.
      N0 :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DD :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,c,overlapping_atom) 
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt)
      N0 = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
      gridc0.destroy

   end


   add_LDA_XC_matrix_old(K,E)
   ! Add the exchange and correlation matrices to K. This routine supports
   ! local functional only, either exchange or correlation.
      K :: MAT{REAL}
      E :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")

      pt,a0,b0,V,W :: MAT{REAL}*
      wt,rho0,V0,E0,ab0 :: VEC{REAL}*
      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb :: INT
      atom_a,atom_b :: INT
      same_atoms :: BIN
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      V_ab :: REAL

      W.create(.n_bf,.n_bf)
      V.create(.n_bf,.n_bf)                     ! Use temporary V for parallelisation
      V = ZERO

      nullify(a0)
      nullify(b0)

      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2
         end                                    ! Make the grid points and weights
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)

         n_pt = pt.dim1                         ! Keep the weight_is_0 array
         V0.create(n_pt)                        ! local potential grids
         E0.create(n_pt)                        ! The energy density
         ab0.create(n_pt)
         .becke_grid.make_bf_grids(a0,b0,ma,mb,pt,atoms)

         rho0.create(n_pt)                      ! The density grids
         .make_density_grid_r_B(rho0,pt,atoms,a0,b0) 

         .new_set_r_XC_potentials(V0,rho0)          ! Evaluation the XC potentials
         .new_set_r_XC_energy_density(E0,rho0)
         rho0.destroy

  ! stdout.show("q =",q)
  ! stdout.text("V0a:")
  ! stdout.put(V0)
  ! stdout.text("V0b:")
  ! stdout.put(V0)
  ! stdout.text("E:")
  ! stdout.put(E0)
         V0 = wt*V0
         E0 = wt*E0

         wt.destroy; pt.destroy

  ! stdout.text("V0a:")
  ! stdout.put(V0)
  ! stdout.text("V0b:")
  ! stdout.put(V0)
  ! stdout.text("E:")
  ! stdout.put(E0)

         ! Make the exchange correlation matrix
         do a = 1,na
         do b = 1,nb
            ab0 = a0(:,a)*b0(:,b)
            V_ab = sum(V0*ab0) 
            aa = fa + a
            bb = fb + b
            V(aa,bb) = V_ab                    
            W(aa,bb) = -HALF*V_ab + sum(E0*ab0) ! Make the DFT energy correction matrix
  ! stdout.show("Va =",V_ab)
  ! stdout.show("Vb =",V_ab)
  ! stdout.show("e  =",sum(E0*ab0))
         end
         end

  ! stdout.text("Va:")
  ! stdout.put(V(fa+1:la,fb+1:lb))
  ! stdout.text("Vb:")
  ! stdout.put(V(fa+1:la,fb+1:lb))
  ! stdout.text("W:")
  ! stdout.put(W(fa+1:la,fb+1:lb))
         ab0.destroy; E0.destroy; V0.destroy
         if (same_atoms) then
            a0.destroy
            nullify(b0)
         else
            b0.destroy
            a0.destroy
         end

      end

      .put_debug(V,"add_LDA_XC_matrix: V")
      .put_debug(W,"add_LDA_XC_matrix: W")

      K = K + V
      V.destroy
      K.symmetric_reflect

      W.symmetric_reflect
      E = W.trace_product_with(.density_matrix.restricted)
      W.destroy

   end

   make_density_grid_r_B(rho0,pt,atoms,a0,b0)
   ! Evaluate the density grid "rho0" at the grid points "pt", for use in matrix
   ! elements needed by DFT grid integration.  "atoms" is a list of indices of
   ! the atoms whose grid points are to be used in DFT integrations.  "a0" and
   ! "b0" are the basis function grids for the atoms listed in "atoms".  These
   ! are the grids for the atoms whose matrix elements are to be evaluated. We
   ! don't have to calculate the density contributions for any atoms which do
   ! not have basis functions which overlap with those in "atoms", because the
   ! orbital density from those atoms evaluated at those in the "atoms" list
   ! will be negligible. NOTE: this routine depends on having the
   ! .overlapping_atoms array defined. NOTE: it depends on having the natural
   ! orbitals defined, and it may take much more memory than version A above,
   ! but it may be quicker.
      rho0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a0,b0 :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho0.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no restrictd occupation numbers")

      sh :: SHELL1
      g0,sh_grid0,NO :: MAT{REAL}*
      n_pt,n_occ,a,s,f,l,fs,ls,ns,n :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .occupation_numbers.no_of_occupied("restricted")

      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      g0.create(n_pt,n_occ)
      g0 = ZERO
      do a = 1,.n_atom
         if (any(a==atoms)) then                                ! Use the supplied grids
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NO => .natural_orbitals.restricted(f:l,:n_occ)      ! Multiply by all orbitals
            if (a==atoms(1)) then; g0 = g0 + matmul(a0,NO)      ! Re-use a0
            else;                  g0 = g0 + matmul(b0,NO)      ! Re-use b0
            end
         else if (.is_overlapping_atom(a,atoms)) then           ! Do only overlapping atoms
            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
               .get_shell(sh,s,fs,ls,ns)
               sh_grid0.create(n_pt,ns)
               sh.make_grid(sh_grid0,pt)                        ! Call this as little as possible
               NO => .natural_orbitals.restricted(fs:ls,:n_occ) ! Multiply by all orbitals
               g0 = g0 + matmul(sh_grid0,NO)
               sh_grid0.destroy
               sh.destroy_ptr_part
            end
         end
      end

      ! Now square up each natural orbital. We can't skip any NO's
      ! since they could be all delocalised.
      rho0 = ZERO
      do n = 1,n_occ
         occ = .occupation_numbers.restricted(n)
         rho0 = rho0 + occ*g0(:,n)*g0(:,n)
      end
      g0.destroy

   end


   add_GGA_XC_matrix(K,E) ::: leaky
   ! Add the exchange and correlation matrices to K. This routine
   ! supports non-local functionals, either exchange or correlation.
      K :: MAT{REAL}
      E :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")

      wt, N0,Nx,Ny,Nz, V0,Vx,Vy,Vz, E0 :: VEC{REAL}*
      V,D, pt  :: MAT{REAL}*
      bf_skip  :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      n_pt, c  :: INT

      ! Main temporaries
      E = ZERO
      V.create(.n_bf,.n_bf); V = ZERO

      ! Make the AO density matrix
      D => .density_matrix.restricted

      ! Set up grids, atomic densities, overlapping_atoms -- leaky
    ! .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Make electron density on the Becke-grid for atom "c"
         .make_rho_becke_atom_grid(N0,Nx,Ny,Nz,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,D)

         ! Make XC potential, energy grids: V0, E0
         pt.destroy
         n_pt = wt.dim
         E0.create(n_pt)                                                    ! The energy density
         V0.create(n_pt); Vx.create(n_pt); Vy.create(n_pt); Vz.create(n_pt) ! local potential grids
         .new_set_r_XC_potentials(V0,N0,Vx,Vy,Vz,Nx,Ny,Nz) 
         .new_set_r_XC_energy_density(E0,N0,Nx,Ny,Nz)

         ! Incorporate grid & partition weights
         E0 = wt*E0
         V0 = wt*V0; Vx = wt*Vx; Vy = wt*Vy; Vz = wt*Vz

         ! Clean
         Nz.destroy; Ny.destroy; Nx.destroy; N0.destroy
         wt.destroy

         ! Add the XC matrix elements into V, energy to E 
         ! for atom "c" Becke-grid
         .add_GGA_XC_matrix(V,E,V0,Vx,Vy,Vz,E0,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,D)

         ! Clean up
         Vz.destroy; Vy.destroy; Vx.destroy; V0.destroy; E0.destroy
         bf_gridz.destroy; bf_gridy.destroy; bf_gridx.destroy; bf_grid0.destroy
         bf_skip.destroy

      end ! -- integration atom c

      ! Add the XC contribution to K
      K = K + V
      K.symmetric_reflect

      ! Get DFT energy correction
      V.symmetric_reflect
      E = E - HALF*V.trace_product_with(D)

      ! Clean
      V.destroy

   end

   add_GGA_XC_matrix(V,E,V0,Vx,Vy,Vz,E0,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,D)
   ! Add XC potential matrix elements to "V", the XC energy to "E".
   ! "V0" is XC potential density on the becke grid for atom "c",
   ! weighted by the partition function for that atom. "Vx", "Vy",
   ! "Vz" are XC potential gradients. Likewise, "E0" is the
   ! (partition-weighted) XC energy density of the grid.  "bf_skip",
   ! "bf_grid0", "bf_gridx", "bf_gridy", "bf_gridz" are basis function
   ! grids and their derivatives.  "D" is the density matrix.  This
   ! routine supports non-local functionals.
      V :: MAT{REAL}, target
      E :: REAL
      V0,Vx,Vy,Vz,E0 :: VEC{REAL}, IN
      bf_skip :: VEC{VEC_{BIN}}, IN
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}, IN
      c :: INT, IN
      D :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      VV,DD :: MAT{REAL}*
      Dab, fac,val,wal, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, a,b,p,i,j,n :: INT

      ! Skip array for ab shell
      n_pt = V0.dim
      skipab.create(n_pt)

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)

         ! Loop shells on atom a
         do sa = fsa,lsa

            if (bf_skip(sa).element.destroyed) cycle

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set the "sb" basis function grid
            skipa  => bf_skip(sa).element 
            grida0 => bf_grid0(sa).element 
            gridax => bf_gridx(sa).element 
            griday => bf_gridy(sa).element 
            gridaz => bf_gridz(sa).element 

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 
                  gridbx => bf_gridx(sb).element 
                  gridby => bf_gridy(sb).element 
                  gridbz => bf_gridz(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  VV => V(fa:la,fb:lb)
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     val = ZERO
                     wal = ZERO
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga  = ga0(i)
                        gb  = gb0(j)
                        gab = ga*gb
                        val = val + V0(n)* gab                  &
                                  + Vx(n)*(gax(i)*gb+ga*gbx(j)) &
                                  + Vy(n)*(gay(i)*gb+ga*gby(j)) &
                                  + Vz(n)*(gaz(i)*gb+ga*gbz(j))
                        wal = wal + E0(n)*gab
                     end
                     VV(1,1) = VV(1,1) + val
                     E       = E       + wal*Dab

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Dab = fac*DD(a,b)
                           val = ZERO
                           wal = ZERO
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              val = val + V0(n)* gab                  &
                                        + Vx(n)*(gax(i)*gb+ga*gbx(j)) &
                                        + Vy(n)*(gay(i)*gb+ga*gby(j)) &
                                        + Vz(n)*(gaz(i)*gb+ga*gbz(j))
                              wal = wal + E0(n)*gab
                           end
                           VV(a,b) = VV(a,b) + val
                           E       = E       + wal*Dab
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy

   end

   make_rho_becke_atom_grid(N0,Nx,Ny,Nz,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,D) ::: leaky
   ! Make the density "N0" and its derivatives "Nx", "Ny", "Nz", on
   ! the Becke grid ("pt","wt") for atom "c" given AO density matrix
   ! "D". Also return the "bf_skip" array, and the basis function and
   ! basis function derivative arrays "bf_grid0", "bf_gridx",
   ! "bf_gridy", "bf_gridz" used for evaluating the density
   ! functionals on the grid.
      N0,Nx,Ny,Nz :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2 :: VEC{REAL}*
      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      DD :: MAT{REAL}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      gridc0,gridcx,gridcy,gridcz :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Dab, fac, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba,offset, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,gridcx,gridcy,gridcz,c,overlapping_atom) 
      n_pt = pt.dim1

      ! Create N0
      N0.create(n_pt); N0 = ZERO
      Nx.create(n_pt); Nx = ZERO
      Ny.create(n_pt); Ny = ZERO
      Nz.create(n_pt); Nz = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)
      bf_gridx.create(.n_shell)
      bf_gridy.create(.n_shell)
      bf_gridz.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            gridax.create(n_keep,na)
            griday.create(n_keep,na)
            gridaz.create(n_keep,na)
            if (oa==c) then
               offset = fa-fba
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+offset)
                     gridax(i,a) = gridcx(n,a+offset)
                     griday(i,a) = gridcy(n,a+offset)
                     gridaz(i,a) = gridcz(n,a+offset)
                  end
               end
            else
               sha.make_skip_nabla_grid(gridax,griday,gridaz,grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0
            bf_gridx(sa).element => gridax
            bf_gridy(sa).element => griday
            bf_gridz(sa).element => gridaz

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 
                  gridbx => bf_gridx(sb).element 
                  gridby => bf_gridy(sb).element 
                  gridbz => bf_gridz(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        N0(n) = N0(n) + Dab* ga*gb
                        Nx(n) = Nx(n) + Dab*(gax(i)*gb + ga*gbx(j))
                        Ny(n) = Ny(n) + Dab*(gay(i)*gb + ga*gby(j))
                        Nz(n) = Nz(n) + Dab*(gaz(i)*gb + ga*gbz(j))
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              N0(n) = N0(n) + Dab* ga*gb
                              Nx(n) = Nx(n) + Dab*(gax(i)*gb + ga*gbx(j))
                              Ny(n) = Ny(n) + Dab*(gay(i)*gb + ga*gby(j))
                              Nz(n) = Nz(n) + Dab*(gaz(i)*gb + ga*gbz(j))
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
      gridcz.destroy; gridcy.destroy; gridcx.destroy; gridc0.destroy

   end


   add_GGA_XC_matrix_old(K,E)
   ! Add the exchange and correlation matrices to K. This routine
   ! supports non-local functionals, either exchange or correlation.
      K :: MAT{REAL}
      E :: REAL
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")

      a1,b1 :: MAT3{REAL}*
      pt,rho1,V1,a0,b0,V :: MAT{REAL}*
      wt,rho0,V0,E0,ab0 :: VEC{REAL}*
      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb,n_occ :: INT
      atom_a,atom_b,i :: INT
      same_atoms :: BIN
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      V_ab,E_ab,fac :: REAL

      ! No. of occupied NO's
      n_occ = .occupation_numbers.no_of_occupied("restricted")

      ! Basis function grids and gradients
      nullify(a0); nullify(a1)
      nullify(b0); nullify(b1)

      ! The exchange correlation matrix
      V.create(.n_bf,.n_bf)                     

      ! The exchange correlation energy
      E = ZERO

      do q = 1,.no_of_atom_pairs

         if (NOT .overlapping_atoms(q)) cycle

         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)

         ! Which "atoms" to be integrated?
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
         end                                    

         ! Make pair integration grid. Keep the weight_is_0 array
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)

         ! Local/non-local potential grids, energy densities
         n_pt = pt.dim1                         
         V0.create(n_pt); V1.create(n_pt,3)     
         E0.create(n_pt)    
         ab0.create(n_pt) ! temporary 

         ! Make the atomic basis function grids a0, b0, etc. 
         ! Uses the becke_grid.weight_is_0_array
         .becke_grid.make_bf_grids(a0,a1,b0,b1,ma,mb,pt,atoms)

         ! Make the density/nabla density grids. Re-use a0, b0 grids
         rho0.create(n_pt); rho1.create(n_pt,3) 
         .make_nabla_density_grid_r_B(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,n_occ,.becke_grid.basis_function_cutoff)

         ! Evaluate XC potentials and energy density.
         V0 = ZERO                              
         V1 = ZERO                              
         .new_set_r_XC_potentials(V0,rho0 &
            ,V1(:,1),V1(:,2),V1(:,3) &
            ,rho1(:,1),rho1(:,2),rho1(:,3)) ! Evaluation the XC potentials
         .new_set_r_XC_energy_density(E0,rho0 &
            ,rho1(:,1),rho1(:,2),rho1(:,3)) ! Evaluation the XC potentials
         rho1.destroy; rho0.destroy

         ! Incorporate weights into XC potential
         V0 = wt*V0
         E0 = wt*E0
         forall (i=1:3) V1(:,i) = wt*V1(:,i)
         wt.destroy; pt.destroy

         ! Make V, the exchange correlation matrix
         ! Make E, the exchange correlation energy
         do a = 1,na
         do b = 1,nb
            ab0 = a0(:,a)*b0(:,b)
            V_ab = sum(V0*ab0) &
                 + sum(V1(:,1)*(a1(:,a,1)*b0(:,b)+a0(:,a)*b1(:,b,1))) &
                 + sum(V1(:,2)*(a1(:,a,2)*b0(:,b)+a0(:,a)*b1(:,b,2))) &
                 + sum(V1(:,3)*(a1(:,a,3)*b0(:,b)+a0(:,a)*b1(:,b,3)))
            E_ab = sum(E0*ab0) 
            aa = fa + a
            bb = fb + b
            V(aa,bb) = V_ab                     
            E = E + fac*E_ab*.density_matrix.restricted(aa,bb)
         end
         end
         ab0.destroy; E0.destroy
         V1.destroy; V0.destroy

       ! stdout.text("V:")
       ! stdout.put(V(fa+1:la,fb+1:lb))
       ! stop

         ! Clean up
         if (same_atoms) then
            a1.destroy; a0.destroy
            nullify(b1); nullify(b0)
         else
            b1.destroy; b0.destroy
            a1.destroy; a0.destroy
         end

      end

      ! Add the contribution to "K" matrix
      V.symmetric_reflect
      K = K + V
      E = E - HALF*.density_matrix.restricted.trace_product_with(V)
      V.destroy

   end

   make_nabla_density_grid_r_B(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,n_occ,bf_cutoff)
   ! Evaluate the nabla density grid "rho1" as well as the density grid
   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
   ! the basis function grids for the atoms listed in "atoms". These are the
   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
   ! to calculate the density contributions for any atoms which do not have
   ! basis functions which overlap with those in "atoms", because the orbital
   ! density from those atoms evaluated at those in the "atoms" list will be
   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
   ! array defined. NOTE: it depends on having the natural orbitals defined, and
   ! it may take much more memory than version A above, but it may be quicker.
      rho1 :: MAT{REAL}, OUT
      rho0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a1,b1 :: MAT3{REAL}
      a0,b0 :: MAT{REAL}
      ma,mb :: INT, IN
      n_occ :: INT, IN
      bf_cutoff :: REAL, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
   ENSURE(pt.dim1==(ma+mb),"pt, inconsistent 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")

      sh :: SHELL1
      shell :: VEC{SHELL}*
      pos :: VEC{REAL}(3) 
      skip :: VEC{BIN}*
      list :: VEC{INT}*
      x,y,z,r2 :: VEC{REAL}*
      g1,gg1,sh_grid1 :: MAT3{REAL}*
      g0,gg0,sh_grid0,NO :: MAT{REAL}*
      n_pt,n_cut,aa,a,s,f,l,fs,ls,n, i,k :: INT
      cut,occ,val :: REAL
      do_a,do_b :: BIN

      ! Basis function cutoff for orbitals
      cut = bf_cutoff

      ! Orbital, and orbital gradient arrays
      n_pt = pt.dim1
      g1.create(n_pt,n_occ,3); g1 = ZERO
      g0.create(n_pt,n_occ);   g0 = ZERO

      ! List of atoms which overlap "atoms" basis functions
      list => .overlapping_atoms_for(atoms)

      ! Loop only over the overlapping atoms
      do aa = 1,list.dim

         a = list(aa)

         ! Atom "a" is one where basis functions are centered.
         ! Use the supplied (precalculated) basis function grids.
         if (any(a==atoms)) then                               

            ! Multiply by all orbitals
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NO => .natural_orbitals.restricted(f:l,:n_occ)     

            if (a==atoms(1)) then
               g1(:,:,1) = g1(:,:,1) + matmul(a1(:,:,1),NO)
               g1(:,:,2) = g1(:,:,2) + matmul(a1(:,:,2),NO)
               g1(:,:,3) = g1(:,:,3) + matmul(a1(:,:,3),NO)
               g0        = g0        + matmul(a0,NO)
            else
               g1(:,:,1) = g1(:,:,1) + matmul(b1(:,:,1),NO)
               g1(:,:,2) = g1(:,:,2) + matmul(b1(:,:,2),NO)
               g1(:,:,3) = g1(:,:,3) + matmul(b1(:,:,3),NO)
               g0        = g0        + matmul(b0,NO)
            end

         ! Atom "a" is NOT one where basis functions are centered.
         else                                                  

            ! Do both atoms overlap?
            do_a = .is_overlapping_atom(a,atoms(1))
            if (atoms.dim==1) then; do_b = TRUE
            else;                   do_b = .is_overlapping_atom(a,atoms(2))
            end

            pos = .atom(a).position
            shell => .atom(a).basis.shell
            ls = .first_basis_fn_for_atom(a) - 1

            ! Both atoms overlap (or only one in "atoms")
            if (do_a AND do_b) then                            

               do s = 1,shell.dim

                  sh.set(shell(s),pos)

                  sh.make_significant_points(x,y,z,r2,skip,pt,cut)

                  if (x.destroyed) cycle

                  ! Call this as little as possible
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)   

                  ! Multiply by all orbitals
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ) 
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)

                  k = 0
                  do i = 1,n_pt
                     if (skip(i)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end

                  gg0.destroy; gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
               end

            ! Only the first overlaps
            else if (do_a) then                               

               do s = 1,shell.dim

                  sh.set(shell(s),pos)

                  sh.make_significant_points(x,y,z,r2,skip,pt(:ma,:),cut)

                  if (x.destroyed) cycle

                  ! Call this as little as possible
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)    

                  ! Multiply by all orbitals
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ)  
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)

                  k = 0
                  do i = 1,ma
                     if (skip(i)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end

                  gg0.destroy; gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
               end

            ! Only the second overlaps
            else if (atoms.dim==2 AND do_b) then               

               do s = 1,shell.dim

                  sh.set(shell(s),pos)

                  sh.make_significant_points(x,y,z,r2,skip,pt(ma+1:,:),cut)

                  if (x.destroyed) cycle

                  ! Call this as little as possible
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)   

                  ! Multiply by all orbitals
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ) 
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)
                  k = 0
                  do i = ma+1,n_pt
                     if (skip(i-ma)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end

                  gg0.destroy; gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
               end

            end
         end
      end

      ! Now square up each natural orbital. We can't skip any NO's
      ! since they could be all delocalised.
      cut = cut/sqrt(REALIFY(n_occ))
      rho1 = ZERO
      rho0 = ZERO
      do n = 1,n_occ
         occ = .occupation_numbers.restricted(n)
         do i = 1,n_pt
            val = g0(i,n)
            if (abs(val)<cut) cycle
            rho1(i,1) = rho1(i,1) + occ*val*g1(i,n,1)
            rho1(i,2) = rho1(i,2) + occ*val*g1(i,n,2)
            rho1(i,3) = rho1(i,3) + occ*val*g1(i,n,3)
            rho0(i)   = rho0(i)   + occ*val*val
         end
      end
      g0.destroy; g1.destroy; list.destroy
      rho1 = TWO*rho1

   end


   new_set_r_XC_energy_density(E,N0,Nx,Ny,Nz)
   ! Set the *restricted* exchange correlation energy density "E", for
   ! given densities "N0" and gradient densities "Nn".
      E  :: VEC{REAL}, OUT
      N0 :: VEC{REAL}, IN
      Nx,Ny,Nz :: VEC{REAL}, IN, optional

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.becke_grid.created,"no becke_grid")

      exch,corr :: STR
      add :: DFT_FUNCTIONAL

      if (NOT .scfdata.is_DFT_calculation) then
         return
      end

      add.set_defaults
      add.set_rho_cutoff(.becke_grid.rho_cutoff)

      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional

      E = ZERO ! <<< set to zero

      if (exch/="none") add.new_r_energy_density(exch,E,N0,Nx,Ny,Nz)
      if (corr/="none") add.new_r_energy_density(corr,E,N0,Nx,Ny,Nz)

   end

   new_set_r_XC_potentials(V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)
   ! For given densities "N0" and gradient densities "Nn", return
   ! "V0" and "Vn", the local and non_local terms necessary to
   ! calculate the matrix elements of the *restricted* exchange
   ! correlation potential. 
      V0 :: VEC{REAL}, INOUT
      N0 :: VEC{REAL}, IN
      Vx,Vy,Vz :: VEC{REAL}, INOUT, optional
      Nx,Ny,Nz :: VEC{REAL}, IN, optional

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.becke_grid.created,"no becke_grid")

      exch,corr :: STR
      add :: DFT_FUNCTIONAL

      if (NOT .scfdata.is_DFT_calculation) then
         return
      end

      add.set_defaults
      add.set_rho_cutoff(.becke_grid.rho_cutoff)

      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional

      V0 = ZERO ! <<< set to zero
      if (present(Vx)) then
         Vx = ZERO; Vy = ZERO; Vz = ZERO
      end

      if (exch/="none") add.new_r_potential(exch,V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)
      if (corr/="none") add.new_r_potential(corr,V0,N0,Vx,Vy,Vz,Nx,Ny,Nz)

   end


!  ================
!  Unrestricted DFT
!  ================

   add_XC_matrix(Ka,Kb)
   ! Calculate the exchange correlation matrix numerically.
      Ka,Kb :: MAT{REAL}
      E,Ea,Eb :: REAL
      if (.scfdata.using_GGA_functional) then
         if (.debugging("use_add_GGA_XC_matrix_old")) then
            .add_GGA_XC_matrix_old(Ka,Kb,E,Ea,Eb)
         else
            .add_GGA_XC_matrix(Ka,Kb,E,Ea,Eb)
         end
      else
         if (.debugging("use_add_LDA_XC_matrix_old")) then
            .add_LDA_XC_matrix_old(Ka,Kb,E,Ea,Eb)
         else
            .add_LDA_XC_matrix(Ka,Kb,E,Ea,Eb)
         end
      end
      .scfdata.dft_energy_correction = E
      .scfdata.dft_alpha_energy_correction = Ea
      .scfdata.dft_beta_energy_correction = Eb
   end


   add_LDA_XC_matrix(Ka,Kb,E,Ea,Eb) ::: leaky
   ! Add the exchange and correlation matrices to "Ka", "Kb". Return
   ! the DFT energy corrections "Ea", "Eb" and the total "E". This
   ! routine supports local functional only, either exchange or
   ! correlation.
      Ka,Kb :: MAT{REAL}
      E,Ea,Eb :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.alpha.created,"no alpha density matrix")
   ENSURE(.density_matrix.beta.created,"no alpha density matrix")

      wt, N0a,N0b,V0a,V0b,E0 :: VEC{REAL}*
      Va,Vb,Da,Db, pt  :: MAT{REAL}*
      bf_skip  :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      n_pt, c  :: INT

      ! Main temporaries
      Ea = ZERO; Eb = ZERO
      Va.create(.n_bf,.n_bf); Va = ZERO
      Vb.create(.n_bf,.n_bf); Vb = ZERO

      ! Set the AO density matrices
      Da => .density_matrix.alpha
      Db => .density_matrix.beta

      ! Set up grids, atomic densities, overlapping_atoms -- leaky
    ! .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Make electron density on the Becke-grid for atom "c"
         .make_rho_becke_atom_grid(N0a,N0b,pt,wt,bf_skip,bf_grid0,c,Da,Db)

         ! Make XC potential, energy grids: V0, E0
         pt.destroy
         n_pt = wt.dim
         E0.create(n_pt)  ! The energy density
         V0a.create(n_pt) ! local potential grid
         V0b.create(n_pt) 
         .new_set_u_XC_potentials(V0a,V0b,N0a,N0b)
         .new_set_u_XC_energy_density(E0,N0a,N0b)

         ! Incorporate grid & partition weights
         E0  = wt*E0
         V0a = wt*V0a
         V0b = wt*V0b

         ! Clean
         N0b.destroy; N0a.destroy
         wt.destroy

         ! Add the XC matrix elements into V, energy to E 
         ! for atom "c" Becke-grid
         .add_LDA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,E0,bf_skip,bf_grid0,c,Da,Db)

         ! Clean up
         V0b.destroy; V0a.destroy; E0.destroy
         bf_grid0.destroy; bf_skip.destroy

      end ! -- integration atom c

      ! Add the XC contribution to K
      Ka = Ka + Va
      Kb = Kb + Vb
      Ka.symmetric_reflect
      Kb.symmetric_reflect

      ! Get DFT energy correction
      Va.symmetric_reflect
      Vb.symmetric_reflect
      Ea = Ea - HALF*Va.trace_product_with(Da)
      Eb = Eb - HALF*Vb.trace_product_with(Db)
      E  = Ea + Eb

      ! Clean
      Vb.destroy; Va.destroy

   end

   add_LDA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,E0,bf_skip,bf_grid0,c,Da,Db)
   ! Add XC potential matrix elements to "Va", "Vb", the XC energy
   ! corrections to "Ea", "Eb". "V0a", "V0b" are the XC potential
   ! densities on the becke grid for atom "c", weighted by the
   ! partition function for that atom. Likewise, "E0" is the
   ! (partition-weighted) XC energy density of the grid.  "bf_skip"
   ! and "bf_grid0 are basis function grids.  "Da", "Db" are the
   ! density matrices.  This routine supports local functional only.
      Va,Vb :: MAT{REAL}, target
      Ea,Eb :: REAL
      V0a,V0b,E0 :: VEC{REAL}, IN
      bf_skip :: VEC{VEC_{BIN}}, IN
      bf_grid0 :: VEC{MAT_{REAL}}, IN
      c :: INT, IN
      Da,Db :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      ga0,gb0 :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipab, skipa,skipb :: VEC{BIN}*
      VVa,VVb,DDa,DDb :: MAT{REAL}*
      grida0,gridb0 :: MAT{REAL}*
      Da_ab,Db_ab, fac,vala,valb,wal, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, a,b,p,i,j,n :: INT

      ! Skip array for ab shell
      n_pt = V0a.dim
      skipab.create(n_pt)

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)

         ! Loop shells on atom a
         do sa = fsa,lsa

            if (bf_skip(sa).element.destroyed) cycle

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set the "sb" basis function grid
            skipa  => bf_skip(sa).element 
            grida0 => bf_grid0(sa).element 

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  VVa => Va(fa:la,fb:lb)
                  VVb => Vb(fa:la,fb:lb)
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     vala = ZERO; valb = ZERO
                     wal = ZERO
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga  = ga0(i)
                        gb  = gb0(j)
                        gab = ga*gb
                        vala = vala + V0a(n)*gab 
                        valb = valb + V0b(n)*gab 
                        wal  = wal  + E0(n) *gab
                     end
                     VVa(1,1) = VVa(1,1) + vala
                     VVb(1,1) = VVb(1,1) + valb
                     Ea       = Ea       + wal*Da_ab
                     Eb       = Eb       + wal*Db_ab

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           vala = ZERO; valb = ZERO
                           wal = ZERO
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              vala = vala + V0a(n)*gab
                              valb = valb + V0b(n)*gab
                              wal  = wal  + E0(n)*gab
                           end
                           VVa(a,b) = VVa(a,b) + vala
                           VVb(a,b) = VVb(a,b) + valb
                           Ea       = Ea       + wal*Da_ab
                           Eb       = Eb       + wal*Db_ab
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy

   end

   make_rho_becke_atom_grid(N0a,N0b,pt,wt,bf_skip,bf_grid0,c,Da,Db) ::: leaky
   ! Make the alpha and beta densities "N0a", "N0b" on the Becke grid
   ! ("pt","wt") for atom "c" given AO density matrices "Da", "Db".
   ! Also return the "bf_skip" arrays and the "bf_grid0" array used
   ! for evaluating the density (or density functionals) on the grid.
      N0a,N0b :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      Da,Db  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0,gridc0, DDa,DDb :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Da_ab,Db_ab, fac, ga,gb,gab :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,c,overlapping_atom) 
      n_pt = pt.dim1

      ! Create N0a, N0b
      N0a.create(n_pt); N0a = ZERO
      N0b.create(n_pt); N0b = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            if (oa==c) then
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+fa-fba)
                  end
               end
            else
               sha.make_skip_grid(grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        gab = ga*gb
                        N0a(n) = N0a(n) + Da_ab*gab
                        N0b(n) = N0b(n) + Db_ab*gab
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              gab = ga*gb
                              N0a(n) = N0a(n) + Da_ab*gab
                              N0b(n) = N0b(n) + Db_ab*gab
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
      gridc0.destroy

   end


   add_LDA_XC_matrix_old(Ka,Kb,E,Ea,Eb)
   ! Add the exchange and correlation matrices to K. This routine supports
   ! local functional only, either exchange or correlation.
      Ka,Kb :: MAT{REAL}
      E,Ea,Eb :: REAL
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")
      pt,a0,b0,Vb,Va,W :: MAT{REAL}*
      wt,rho0a,rho0b,V0a,V0b,E0,ab0 :: VEC{REAL}*
      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt,ma,mb :: INT
      atom_a,atom_b :: INT
      same_atoms :: BIN
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      Va_ab,Vb_ab,E_ab,Da_ab,Db_ab,fac :: REAL
      W.create(.n_bf,.n_bf)
      Va.create(.n_bf,.n_bf)                    ! Use temporary V for parallelisation
      Vb.create(.n_bf,.n_bf)
      nullify(a0); nullify(b0)
    ! E = ZERO
      Ea = ZERO
      Eb = ZERO
      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
         end                                                ! Make the grid points and weights
       ! .becke_grid.make_grid(pt,wt,atoms,compress=FALSE)
       ! .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=FALSE)
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                                     ! Keep the weight_is_0 array
         V0a.create(n_pt); V0b.create(n_pt)                 ! local potential grids
         E0.create(n_pt)                                    ! The energy density
         ab0.create(n_pt)             
         .becke_grid.make_bf_grids(a0,b0,ma,mb,pt,atoms)
         rho0a.create(n_pt)                                 ! The density grids
         rho0b.create(n_pt)
         .make_density_grid_u_B(rho0a,rho0b,pt,atoms,a0,b0) ! re-use a0, b0 grids
         .new_set_u_XC_potentials(V0a,V0b,rho0a,rho0b)      ! Evaluation the XC potentials
         .new_set_u_XC_energy_density(E0,rho0a,rho0b)
         rho0b.destroy; rho0a.destroy
  ! stdout.show("q =",q)
  ! stdout.text("V0a:")
  ! stdout.put(V0a)
  ! stdout.text("V0b:")
  ! stdout.put(V0a)
  ! stdout.text("E:")
  ! stdout.put(E0)
         V0a = wt*V0a
         V0b = wt*V0b
         E0  = wt*E0
  ! stdout.text("V0a:")
  ! stdout.put(V0a)
  ! stdout.text("V0b:")
  ! stdout.put(V0a)
  ! stdout.text("E:")
  ! stdout.put(E0)
         wt.destroy; pt.destroy
         ! Make the exchange correlation matrix
         do a = 1,na
         do b = 1,nb
            ab0 = a0(:,a)*b0(:,b)
            Va_ab = sum(V0a*ab0) 
            Vb_ab = sum(V0b*ab0) 
            E_ab  = fac*sum(E0 *ab0)
            aa = fa + a
            bb = fb + b
            Va(aa,bb) = Va_ab                     
            Vb(aa,bb) = Vb_ab                     
          ! W(aa,bb)  = -HALF*(Va_ab+Vb_ab) + sum(E0*ab0)  ! Make the DFT energy correction matrix
          ! W(aa,bb)  = sum(E0*ab0)  ! Make the DFT energy correction matrix
            Da_ab = .density_matrix.alpha(aa,bb)
            Db_ab = .density_matrix.beta(aa,bb)
          ! E = E + fac*E_ab*(Da_ab+Db_ab)
            Ea = Ea + E_ab*Da_ab
            Eb = Eb + E_ab*Db_ab
  ! stdout.show("Va =",Va_ab)
  ! stdout.show("Vb =",Vb_ab)
  ! stdout.show("e  =",sum(E0*ab0))
         end
         end
  ! stdout.text("Va:")
  ! stdout.put(Va(fa+1:la,fb+1:lb))
  ! stdout.text("Vb:")
  ! stdout.put(Vb(fa+1:la,fb+1:lb))
  ! stdout.text("W:")
  ! stdout.put(W(fa+1:la,fb+1:lb))
         ab0.destroy; E0.destroy; V0b.destroy; V0a.destroy
         if (same_atoms) then
            a0.destroy
            nullify(b0)
         else
            b0.destroy
            a0.destroy
         end
      end
      Va.symmetric_reflect
      Vb.symmetric_reflect
      Ka = Ka + Va
      Kb = Kb + Vb
      Ea = Ea - HALF*.density_matrix.alpha.trace_product_with(Va)
      Eb = Eb - HALF*.density_matrix.beta.trace_product_with(Vb)
      E  = Ea + Eb
      Vb.destroy; Va.destroy
      W.destroy
   end

   make_density_grid_u_B(rho0a,rho0b,pt,atoms,a0,b0)
   ! Evaluate the alpha and beta density grids "rho0a" and "rho0b" at the grid
   ! points "pt", for use in matrix elements needed by DFT grid integration.
   ! "atoms" is a list of indices of the atoms whose grid points are to be used
   ! in DFT integrations.  "a0" and "b0" are the basis function grids for the
   ! atoms listed in "atoms".  These are the grids for the atoms whose matrix
   ! elements are to be evaluated. We don't have to calculate the density
   ! contributions for any atoms which do not have basis functions which overlap
   ! with those in "atoms", because the orbital density from those atoms
   ! evaluated at those in the "atoms" list will be negligible. NOTE: this
   ! routine depends on having the .overlapping_atoms array defined. NOTE: it
   ! depends on having the natural orbitals defined, and it may take much more
   ! memory than version A above, but it may be quicker.
      rho0a,rho0b :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a0,b0 :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(rho0b.dim==pt.dim1,"rho0b has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("unrestricted"), "no unrestricted NO's")
   ENSURE(.occupation_numbers.created("unrestricted"),"no unrestrictd occupation numbers")

      sh :: SHELL1
      g0a,g0b,sh_grid0,NOa,NOb :: MAT{REAL}*
      n_pt,na,nb,a,s,f,l,fs,ls,ns,n :: INT
      occ :: REAL

      n_pt = pt.dim1
      na = .occupation_numbers.no_of_occupied("alpha")
      nb = .occupation_numbers.no_of_occupied("beta")

      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      g0a.create(n_pt,na)
      g0b.create(n_pt,nb)
      g0a = ZERO
      g0b = ZERO
      do a = 1,.n_atom
         if (any(a==atoms)) then                                ! Use the supplied grids
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NOa => .natural_orbitals.alpha(f:l,:na)             ! Multiply by all orbitals
            NOb => .natural_orbitals.beta(f:l,:nb)     
            if (a==atoms(1)) then
               g0a = g0a + matmul(a0,NOa)                       ! Re-use a0
               g0b = g0b + matmul(a0,NOb)
            else
               g0a = g0a + matmul(b0,NOa)                       ! Re-use b0
               g0b = g0b + matmul(b0,NOb)
            end
         else if (.is_overlapping_atom(a,atoms)) then           ! Do only overlapping atoms
            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
               .get_shell(sh,s,fs,ls,ns)
               sh_grid0.create(n_pt,ns)
               sh.make_grid(sh_grid0,pt)                        ! Call this as little as possible
               NOa => .natural_orbitals.alpha(fs:ls,:na)        ! Multiply by all orbitals
               NOb => .natural_orbitals.beta(fs:ls,:nb)     
               g0a = g0a + matmul(sh_grid0,NOa)
               g0b = g0b + matmul(sh_grid0,NOb)
               sh_grid0.destroy
               sh.destroy_ptr_part
            end
         end
      end

      ! Now square up each natural orbital. We can't skip any NO's since they
      ! could be all delocalised.
      rho0a = ZERO
      rho0b = ZERO
      do n = 1,na
         occ = .occupation_numbers.alpha(n)
         rho0a = rho0a + occ*g0a(:,n)*g0a(:,n)
      end
      do n = 1,nb
         occ = .occupation_numbers.beta(n)
         rho0b = rho0b + occ*g0b(:,n)*g0b(:,n)
      end
      g0b.destroy
      g0a.destroy

   end


   add_GGA_XC_matrix(Ka,Kb,E,Ea,Eb) ::: leaky
   ! Add the exchange and correlation matrices to "Ka", "Kb". Return
   ! the DFT energy coorections "Ea", "Eb" and total "E". This routine
   ! supports non-local functionals, either exchange or correlation.
      Ka,Kb :: MAT{REAL}
      E,Ea,Eb :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.alpha.created,"no alpha density matrix")
   ENSURE(.density_matrix.beta.created,"no alpha density matrix")

      wt, E0 :: VEC{REAL}*
      N0a,Nxa,Nya,Nza, V0a,Vxa,Vya,Vza :: VEC{REAL}*
      N0b,Nxb,Nyb,Nzb, V0b,Vxb,Vyb,Vzb :: VEC{REAL}*
      Va,Vb,Da,Db, pt  :: MAT{REAL}*
      bf_skip  :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      n_pt, c  :: INT

      ! Main temporaries
      Ea = ZERO; Eb = ZERO
      Va.create(.n_bf,.n_bf); Va = ZERO
      Vb.create(.n_bf,.n_bf); Vb = ZERO

      ! Make the AO density matrices
      Da => .density_matrix.alpha
      Db => .density_matrix.beta

      ! Set up grids, atomic densities, overlapping_atoms -- leaky
    ! .set_up_Hirshfeld_info(skip_NOs=TRUE) 

      ! Loop over integration atoms "c"
      do c = 1,.n_atom

         ! Make electron density on the Becke-grid for atom "c"
         .make_rho_becke_atom_grid(N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,Da,Db)

         ! Make XC potential, energy grids: V0, E0
         pt.destroy
         n_pt = wt.dim
         E0.create(n_pt)                                                        ! The energy density
         V0a.create(n_pt); Vxa.create(n_pt); Vya.create(n_pt); Vza.create(n_pt) ! local potential grids
         V0b.create(n_pt); Vxb.create(n_pt); Vyb.create(n_pt); Vzb.create(n_pt) ! local potential grids
         .new_set_u_XC_potentials(V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
         .new_set_u_XC_energy_density(E0,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)

         ! Incorporate grid & partition weights
         E0  = wt*E0
         V0a = wt*V0a; Vxa = wt*Vxa; Vya = wt*Vya; Vza = wt*Vza
         V0b = wt*V0b; Vxb = wt*Vxb; Vyb = wt*Vyb; Vzb = wt*Vzb

         ! Clean
         Nzb.destroy; Nyb.destroy; Nxb.destroy; N0b.destroy
         Nza.destroy; Nya.destroy; Nxa.destroy; N0a.destroy
         wt.destroy

         ! Add the XC matrix elements into V, energy to E 
         ! for atom "c" Becke-grid
         .add_GGA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,E0,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,Da,Db)

         ! Clean up
         Vzb.destroy; Vyb.destroy; Vxb.destroy; V0b.destroy
         Vza.destroy; Vya.destroy; Vxa.destroy; V0a.destroy
         E0.destroy
         bf_gridz.destroy; bf_gridy.destroy; bf_gridx.destroy; bf_grid0.destroy
         bf_skip.destroy

      end ! -- integration atom c

      ! Add the XC contribution to K
      Ka = Ka + Va
      Kb = Kb + Vb
      Ka.symmetric_reflect
      Kb.symmetric_reflect

      ! Get DFT energy correction
      Va.symmetric_reflect
      Vb.symmetric_reflect
      Ea = Ea - HALF*Va.trace_product_with(Da)
      Eb = Eb - HALF*Vb.trace_product_with(Db)
      E  = Ea + Eb

      ! Clean
      Vb.destroy; Va.destroy

   end

   add_GGA_XC_matrix(Va,Vb,Ea,Eb,V0a,V0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,E0,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,Da,Db)
   ! Add XC potential matrix elements to "Va", "Vb", the XC energy
   ! corrections to "Ea", "Eb". "V0a", "V0b", "Vxa" ... "Vzb" are the
   ! XC potential densities and their derivatives on the becke grid
   ! for atom "c", weighted by the
   ! partition function for that atom. Likewise, "E0" is the
   ! (partition-weighted) XC energy density of the grid.  "bf_skip"
   ! and "bf_grid0" ... "bf_gridz" are basis function (derivative)
   ! grids.  "Da", "Db" are the density matrices.  This routine
   ! supports non-local functionals.
      Va,Vb :: MAT{REAL}, target
      Ea,Eb :: REAL
      V0a,V0b, E0 :: VEC{REAL}, IN
      Vxa,Vya,Vza :: VEC{REAL}, IN
      Vxb,Vyb,Vzb :: VEC{REAL}, IN
      bf_skip :: VEC{VEC_{BIN}}, IN
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}, IN
      c :: INT, IN
      Da,Db :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      VVa,VVb,DDa,DDb :: MAT{REAL}*
      Da_ab,Db_ab, fac,vala,valb,wal, ga,gb,gab,gx,gy,gz :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na, sb,fb,lb,nb, a,b,p,i,j,n :: INT

      ! Skip array for ab shell
      n_pt = V0a.dim
      skipab.create(n_pt)

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)

         ! Loop shells on atom a
         do sa = fsa,lsa

            if (bf_skip(sa).element.destroyed) cycle

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1

            ! Set the "sb" basis function grid
            skipa  => bf_skip(sa).element 
            grida0 => bf_grid0(sa).element 
            gridax => bf_gridx(sa).element 
            griday => bf_gridy(sa).element 
            gridaz => bf_gridz(sa).element 

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 
                  gridbx => bf_gridx(sb).element 
                  gridby => bf_gridy(sb).element 
                  gridbz => bf_gridz(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  VVa => Va(fa:la,fb:lb)
                  VVb => Vb(fa:la,fb:lb)
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     vala = ZERO; valb = ZERO
                     wal = ZERO
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga  = ga0(i)
                        gb  = gb0(j)
                        gab = ga*gb
                        gx  = gax(i)*gb+ga*gbx(j)
                        gy  = gay(i)*gb+ga*gby(j)
                        gz  = gaz(i)*gb+ga*gbz(j)
                        vala = vala + V0a(n)*gab + Vxa(n)*gx + Vya(n)*gy + Vza(n)*gz
                        valb = valb + V0b(n)*gab + Vxb(n)*gx + Vyb(n)*gy + Vzb(n)*gz
                        wal  = wal  + E0(n) *gab
                     end
                     VVa(1,1) = VVa(1,1) + vala
                     VVb(1,1) = VVb(1,1) + valb
                     Ea       = Ea       + wal*Da_ab
                     Eb       = Eb       + wal*Db_ab

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           vala = ZERO; valb = ZERO
                           wal = ZERO
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              gx  = gax(i)*gb+ga*gbx(j)
                              gy  = gay(i)*gb+ga*gby(j)
                              gz  = gaz(i)*gb+ga*gbz(j)
                              vala = vala + V0a(n)*gab + Vxa(n)*gx + Vya(n)*gy + Vza(n)*gz
                              valb = valb + V0b(n)*gab + Vxb(n)*gx + Vyb(n)*gy + Vzb(n)*gz
                              wal  = wal  + E0(n) *gab
                           end
                           VVa(a,b) = VVa(a,b) + vala
                           VVb(a,b) = VVb(a,b) + valb
                           Ea       = Ea       + wal*Da_ab
                           Eb       = Eb       + wal*Db_ab
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy

   end

   make_rho_becke_atom_grid(N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb,pt,wt,bf_skip,bf_grid0,bf_gridx,bf_gridy,bf_gridz,c,Da,Db) ::: leaky
   ! Make the densities "N0a", "N0b" and their alpha/beta derivatives
   ! "Nxa", "Nya", "Nza", "Nxb", "Nyb", "Nzb", on the Becke grid
   ! ("pt","wt") for atom "c" given AO density matrices "Da", "Db".
   ! Also return the "bf_skip" array, and the basis function and basis
   ! function derivative arrays "bf_grid0", "bf_gridx", "bf_gridy",
   ! "bf_gridz" for evaluating the density functionals on the grid.
      N0a,N0b :: VEC{REAL}*
      Nxa,Nya,Nza :: VEC{REAL}*
      Nxb,Nyb,Nzb :: VEC{REAL}*
      pt :: MAT{REAL}*
      wt :: VEC{REAL}*
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0,bf_gridx,bf_gridy,bf_gridz :: VEC{MAT_{REAL}}*
      c  :: INT, IN
      Da,Db :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2 :: VEC{REAL}*
      ga0,gax,gay,gaz :: VEC{REAL}*
      gb0,gbx,gby,gbz :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      DDa,DDb :: MAT{REAL}*
      grida0,gridax,griday,gridaz :: MAT{REAL}*
      gridb0,gridbx,gridby,gridbz :: MAT{REAL}*
      gridc0,gridcx,gridcy,gridcz :: MAT{REAL}*
      sha :: SHELL1
      cutoff, Da_ab,Db_ab, fac, ga,gb,gab,gx,gy,gz :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa,fba,offset, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Get the Becke grid for atom "c"
      .becke_grid.make_SS_grid(pt,wt,gridc0,gridcx,gridcy,gridcz,c,overlapping_atom) 
      n_pt = pt.dim1

      ! Create N0 arrays
      N0a.create(n_pt); Nxa.create(n_pt); Nya.create(n_pt); Nza.create(n_pt)
      N0b.create(n_pt); Nxb.create(n_pt); Nyb.create(n_pt); Nzb.create(n_pt)
      N0a = ZERO; Nxa = ZERO; Nya = ZERO; Nza = ZERO
      N0b = ZERO; Nxb = ZERO; Nyb = ZERO; Nzb = ZERO

      ! Basis function cutoff
      cutoff = .becke_grid.basis_function_cutoff

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)
      bf_gridx.create(.n_shell)
      bf_gridy.create(.n_shell)
      bf_gridz.create(.n_shell)

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         fba = .first_basis_fn_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            gridax.create(n_keep,na)
            griday.create(n_keep,na)
            gridaz.create(n_keep,na)
            if (oa==c) then
               offset = fa-fba
               do a = 1,na
                  i = 0
                  do n = 1,n_pt
                     if (skipa(n)) cycle
                     i = i + 1
                     grida0(i,a) = gridc0(n,a+offset)
                     gridax(i,a) = gridcx(n,a+offset)
                     griday(i,a) = gridcy(n,a+offset)
                     gridaz(i,a) = gridcz(n,a+offset)
                  end
               end
            else
               sha.make_skip_nabla_grid(gridax,griday,gridaz,grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            end
            bf_grid0(sa).element => grida0
            bf_gridx(sa).element => gridax
            bf_gridy(sa).element => griday
            bf_gridz(sa).element => gridaz

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 
                  gridbx => bf_gridx(sb).element 
                  gridby => bf_gridy(sb).element 
                  gridbz => bf_gridz(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DDa => Da(fa:la,fb:lb)
                  DDb => Db(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     gax => gridax(:,1); gay => griday(:,1); gaz => gridaz(:,1)
                     gbx => gridbx(:,1); gby => gridby(:,1); gbz => gridbz(:,1)
                     Da_ab = fac*DDa(1,1)
                     Db_ab = fac*DDb(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        gab = ga*gb
                        gx  = gax(i)*gb+ga*gbx(j)
                        gy  = gay(i)*gb+ga*gby(j)
                        gz  = gaz(i)*gb+ga*gbz(j)
                        N0a(n) = N0a(n) + Da_ab*gab
                        Nxa(n) = Nxa(n) + Da_ab*gx
                        Nya(n) = Nya(n) + Da_ab*gy
                        Nza(n) = Nza(n) + Da_ab*gz
                        N0b(n) = N0b(n) + Db_ab*gab
                        Nxb(n) = Nxb(n) + Db_ab*gx
                        Nyb(n) = Nyb(n) + Db_ab*gy
                        Nzb(n) = Nzb(n) + Db_ab*gz
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        gax => gridax(:,a); gay => griday(:,a); gaz => gridaz(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           gbx => gridbx(:,b); gby => gridby(:,b); gbz => gridbz(:,b)
                           Da_ab = fac*DDa(a,b)
                           Db_ab = fac*DDb(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga  = ga0(i)
                              gb  = gb0(j)
                              gab = ga*gb
                              gx  = gax(i)*gb+ga*gbx(j)
                              gy  = gay(i)*gb+ga*gby(j)
                              gz  = gaz(i)*gb+ga*gbz(j)
                              N0a(n) = N0a(n) + Da_ab*gab
                              Nxa(n) = Nxa(n) + Da_ab*gx
                              Nya(n) = Nya(n) + Da_ab*gy
                              Nza(n) = Nza(n) + Da_ab*gz
                              N0b(n) = N0b(n) + Db_ab*gab
                              Nxb(n) = Nxb(n) + Db_ab*gx
                              Nyb(n) = Nyb(n) + Db_ab*gy
                              Nzb(n) = Nzb(n) + Db_ab*gz
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Clean up
      skipab.destroy; skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy
      gridcz.destroy; gridcy.destroy; gridcx.destroy; gridc0.destroy

   end


   add_GGA_XC_matrix_old(Ka,Kb,E,Ea,Eb)
   ! Add the exchange and correlation matrices to K. This routine supports
   ! local functional only, either exchange or correlation.
      Ka,Kb :: MAT{REAL}
      E,Ea,Eb :: REAL

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")

      a1,b1 :: MAT3{REAL}*
      pt,rho1a,rho1b,a0,b0,V1a,V1b,Vb,Va :: MAT{REAL}*
      wt,rho0a,rho0b,V0a,V0b,E0,ab0 :: VEC{REAL}*
      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb :: INT
      atom_a,atom_b,i :: INT
      same_atoms :: BIN
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      Va_ab,Vb_ab,E_ab,Da_ab,Db_ab,fac :: REAL

      Va.create(.n_bf,.n_bf)                    ! Use temporary V for parallelisation
      Vb.create(.n_bf,.n_bf)
      nullify(a0); nullify(b0)

    ! E = ZERO
      Ea = ZERO
      Eb = ZERO

      do q = 1,.no_of_atom_pairs

         if (NOT .overlapping_atoms(q)) cycle

         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)

         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
         end                                                
         
         ! Make the grid points and weights
         ! Keep the weight_is_0 array
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)

         ! Potential grids
         n_pt = pt.dim1                                     
         V0a.create(n_pt); V0b.create(n_pt)                 ! local potential grids
         V1a.create(n_pt,3); V1b.create(n_pt,3)             ! non-local potential grids
         E0.create(n_pt)                                    ! The energy density
         ab0.create(n_pt)             
         .becke_grid.make_bf_grids(a0,a1,b0,b1,ma,mb,pt,atoms)

         ! The density grids
         rho0a.create(n_pt); rho0b.create(n_pt)             
         rho1a.create(n_pt,3); rho1b.create(n_pt,3)
         .make_nabla_density_grid_u_A(rho1a,rho1b,rho0a,rho0b,pt,atoms, &
             a1,a0,b1,b0,.becke_grid.rho_cutoff) ! re-use a0, b0 grids

         ! Evaluation the XC potentials
         .new_set_u_XC_potentials(V0a,V0b,rho0a,rho0b &
            ,V1a(:,1),V1a(:,2),V1a(:,3),V1b(:,1),V1b(:,2),V1b(:,3) &
            ,rho1a(:,1),rho1a(:,2),rho1a(:,3),rho1b(:,1),rho1b(:,2),rho1b(:,3)) 
         .new_set_u_XC_energy_density(E0,rho0a,rho0b &
            ,rho1a(:,1),rho1a(:,2),rho1a(:,3),rho1b(:,1),rho1b(:,2),rho1b(:,3)) 

  ! stdout.show("q =",q)
  ! stdout.text("pt:")
  ! stdout.put(pt)
  ! stdout.text("wt:")
  ! stdout.put(wt)
  ! stdout.text("rho0a:")
  ! stdout.put(rho0a)
  ! stdout.text("rho1a:")
  ! stdout.put(rho1a)
  ! stdout.text("V0a:")
  ! stdout.put(V0a)
  ! stdout.text("V0b:")
  ! stdout.put(V0a)
  ! stdout.text("V1a:")
  ! stdout.put(V1a)
  ! stdout.text("V1b:")
  ! stdout.put(V1a)
  ! stdout.text("E:")
  ! stdout.put(E0)

         rho1b.destroy; rho1a.destroy
         rho0b.destroy; rho0a.destroy

         V0a = wt*V0a
         V0b = wt*V0b
         E0  = wt*E0
         forall (i=1:3) 
            V1a(:,i) = wt*V1a(:,i)
            V1b(:,i) = wt*V1b(:,i)
         end

         wt.destroy; pt.destroy

  ! stdout.text("V0a:")
  ! stdout.put(V0a)
  ! stdout.text("V0b:")
  ! stdout.put(V0a)
  ! stdout.text("V1a:")
  ! stdout.put(V1a)
  ! stdout.text("V1b:")
  ! stdout.put(V1a)
  ! stdout.text("E:")
  ! stdout.put(E0)

         ! Make the exchange correlation matrix
         do a = 1,na
         do b = 1,nb
            ab0 = a0(:,a)*b0(:,b)
            Va_ab = sum(V0a*ab0) 
            Vb_ab = sum(V0b*ab0) 
            E_ab  = fac*sum(E0 *ab0)  ! Make the DFT energy correction matrix
            do i = 1,3
               ab0 = a1(:,a,i)*b0(:,b) + a0(:,a)*b1(:,b,i)
               Va_ab = Va_ab + sum(V1a(:,i)*ab0)
               Vb_ab = Vb_ab + sum(V1b(:,i)*ab0)
            end
            aa = fa + a
            bb = fb + b
            Va(aa,bb) = Va_ab                     
            Vb(aa,bb) = Vb_ab                     
            Da_ab = .density_matrix.alpha(aa,bb)
            Db_ab = .density_matrix.beta(aa,bb)
          ! E = E + fac*E_ab*(Da_ab+Db_ab)
            Ea = Ea + E_ab*Da_ab
            Eb = Eb + E_ab*Db_ab
  ! stdout.show("Va =",Va_ab)
  ! stdout.show("Vb =",Vb_ab)
  ! stdout.show("E  =",E)
  ! stdout.show("E   =",E)
  ! stdout.show("E_ab=",E_ab)
         end
         end

  ! stdout.text("Va:")
  ! stdout.put(Va(fa+1:la,fb+1:lb))
  ! stdout.text("Vb:")
  ! stdout.put(Vb(fa+1:la,fb+1:lb))
  ! stop
         ab0.destroy; E0.destroy
         V1b.destroy; V1a.destroy
         V0b.destroy; V0a.destroy
         if (same_atoms) then
            a1.destroy; a0.destroy
            nullify(b1); nullify(b0)
         else
            b1.destroy; b0.destroy
            a1.destroy; a0.destroy
         end

      end

      Va.symmetric_reflect
      Vb.symmetric_reflect

      Ka = Ka + Va
      Kb = Kb + Vb
      Ea = Ea - HALF*.density_matrix.alpha.trace_product_with(Va) 
      Eb = Eb - HALF* .density_matrix.beta.trace_product_with(Vb) 
      E  = Ea + Eb
    ! E = E - HALF*.density_matrix.alpha.trace_product_with(Va) &
    !       - HALF* .density_matrix.beta.trace_product_with(Vb)

      Vb.destroy; Va.destroy

   end

   make_nabla_density_grid_u_A(rho1a,rho1b,rho0a,rho0b,pt,atoms,aa1,aa0,bb1,bb0,cutoff)
   ! See below.
      rho1a,rho1b :: MAT{REAL}, OUT
      rho0a,rho0b :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      aa1,bb1 :: MAT3{REAL}
      aa0,bb0 :: MAT{REAL}
    ! ma,mb :: INT, IN
      cutoff :: REAL, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
 ! ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
 ! ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")

      sha,shb :: SHELL1
      list :: VEC{INT}*
      skipa,skipb :: VEC{BIN}*
      xa,ya,za,ra2,xb,yb,zb,rb2 :: VEC{REAL}*
      a1 :: MAT3{REAL}*
      a0,b0,a0Pa,a0Pb,b0Pa,b0Pb,Pa,Pb :: MAT{REAL}*
      n_pt,a_pt,b_pt,aa,a,sa,fa,la,na,bb,b,sb,fb,lb,nb, i,k,l :: INT
      fac :: REAL
      rho1a = ZERO; rho1b = ZERO
      rho0a = ZERO; rho0b = ZERO
      n_pt = pt.dim1
      list => .overlapping_atoms_for(atoms)
      do aa = 1,list.dim
         a = list(aa)
         .atom(a).make_significant_points(xa,ya,za,ra2,skipa,pt,cutoff)
         if (xa.destroyed) cycle
         a_pt = xa.dim
         do sa = .first_shell_for_atom(a),.last_shell_for_atom(a)
            .get_shell(sha,sa,fa,la)
            a1.create(a_pt,sha.n_comp,3)
            a0.create(a_pt,sha.n_comp)
            sha.make_nabla_grid(a1,a0,xa,ya,za,ra2,cutoff) ! Call this as little as possible
            do bb = 1,list.dim
               b = list(bb)
               if (any(a==atoms) AND any(b==atoms)) cycle  ! Do with saved grids -- below
               .atom(b).make_significant_points(xb,yb,zb,rb2,skipb,pt,skipa,cutoff)
               if (xb.destroyed) cycle
               b_pt = xb.dim
               b0Pa.create(b_pt,sha.n_comp); b0Pa = ZERO
               b0Pb.create(b_pt,sha.n_comp); b0Pb = ZERO
               do sb = .first_shell_for_atom(b),.last_shell_for_atom(b)
                  .get_shell(shb,sb,fb,lb)
                  b0.create(b_pt,shb.n_comp)
                  shb.make_grid(b0,xb,yb,zb,rb2,cutoff) ! Call this as little as possible
                  Pa => .density_matrix.alpha(fb:lb,fa:la)
                  Pb => .density_matrix.beta(fb:lb,fa:la)
                  b0Pa = b0Pa + matmul(b0,Pa)
                  b0Pb = b0Pb + matmul(b0,Pb)
                  b0.destroy
                  shb.destroy_ptr_part
               end
               k = 0
               l = 0
               do i = 1,n_pt
                  if (skipa(i)) cycle
                  l = l + 1
                  if (skipb(i)) cycle
                  k = k + 1
                  rho1a(i,1) = rho1a(i,1) + sum(a1(l,:,1)*b0Pa(k,:))
                  rho1a(i,2) = rho1a(i,2) + sum(a1(l,:,2)*b0Pa(k,:))
                  rho1a(i,3) = rho1a(i,3) + sum(a1(l,:,3)*b0Pa(k,:))
                  rho1b(i,1) = rho1b(i,1) + sum(a1(l,:,1)*b0Pb(k,:))
                  rho1b(i,2) = rho1b(i,2) + sum(a1(l,:,2)*b0Pb(k,:))
                  rho1b(i,3) = rho1b(i,3) + sum(a1(l,:,3)*b0Pb(k,:))
               end
               if (bb<=aa) then
               if (aa==bb) then; fac = ONE
               else;             fac = TWO
               end
               k = 0
               l = 0
               do i = 1,n_pt
                  if (skipa(i)) cycle
                  l = l + 1
                  if (skipb(i)) cycle
                  k = k + 1
                  rho0a(i)   = rho0a(i)   + fac*sum(a0(l,:)  *b0Pa(k,:))
                  rho0b(i)   = rho0b(i)   + fac*sum(a0(l,:)  *b0Pb(k,:))
               end
               end
               b0Pb.destroy; b0Pa.destroy
               xb.destroy; yb.destroy; zb.destroy; rb2.destroy; skipb.destroy
            end
            a0.destroy; a1.destroy
            sha.destroy_ptr_part
         end
         xa.destroy; ya.destroy; za.destroy; ra2.destroy; skipa.destroy
      end
      list.destroy
      ! Now re-use the given grid data
      if (atoms.dim==1) then
         b = atoms(1)
         fb = .first_basis_fn_for_atom(b)
         lb =  .last_basis_fn_for_atom(b)
         nb = lb - fb + 1
         fa = fb
         la = lb
         na = nb
         b0Pa.create(n_pt,na)
         b0Pb.create(n_pt,na)
         Pa => .density_matrix.alpha(fb:lb,fa:la)
         Pb => .density_matrix.beta(fb:lb,fa:la)
         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + sum(aa0(:,:)  *b0Pa,dim=2)
         rho0b      = rho0b      + sum(aa0(:,:)  *b0Pb,dim=2)
         b0Pb.destroy; b0Pa.destroy
      else
         a = atoms(1)
         b = atoms(2)
         fa = .first_basis_fn_for_atom(a)
         fb = .first_basis_fn_for_atom(b)
         la =  .last_basis_fn_for_atom(a)
         lb =  .last_basis_fn_for_atom(b)
         na = la - fa + 1
         nb = lb - fb + 1
         b0Pa.create(n_pt,na)
         b0Pb.create(n_pt,na)
         Pa => .density_matrix.alpha(fb:lb,fa:la)
         Pb => .density_matrix.beta(fb:lb,fa:la)
         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + TWO*sum(aa0(:,:)*b0Pa,dim=2)
         rho0b      = rho0b      + TWO*sum(aa0(:,:)*b0Pb,dim=2)
         b0Pb.destroy; b0Pa.destroy
         a0Pa.create(n_pt,nb)
         a0Pb.create(n_pt,nb)
         Pa => .density_matrix.alpha(fa:la,fb:lb)
         Pb => .density_matrix.beta(fa:la,fb:lb)
         a0Pa = matmul(aa0,Pa)
         a0Pb = matmul(aa0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*a0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*a0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*a0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*a0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*a0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*a0Pb,dim=2)
         a0Pb.destroy; a0Pa.destroy
         a0Pa.create(n_pt,na)
         a0Pb.create(n_pt,na)
         Pa => .density_matrix.alpha(fa:la,fa:la)
         Pb => .density_matrix.beta(fa:la,fa:la)
         a0Pa = matmul(aa0,Pa)
         a0Pb = matmul(aa0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*a0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*a0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*a0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*a0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*a0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*a0Pb,dim=2)
         rho0a      = rho0a      + sum(aa0(:,:)  *a0Pa,dim=2)
         rho0b      = rho0b      + sum(aa0(:,:)  *a0Pb,dim=2)
         a0Pb.destroy; a0Pa.destroy
         b0Pa.create(n_pt,nb)
         b0Pb.create(n_pt,nb)
         Pa => .density_matrix.alpha(fb:lb,fb:lb)
         Pb => .density_matrix.beta(fb:lb,fb:lb)
         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + sum(bb0(:,:)  *b0Pa,dim=2)
         rho0b      = rho0b      + sum(bb0(:,:)  *b0Pb,dim=2)
         b0Pb.destroy; b0Pa.destroy
      end
      rho1a = TWO*rho1a
      rho1b = TWO*rho1b
   end


   new_set_u_XC_energy_density(E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
   ! Return the *unrestricted* exchange correlation energy density "E", for
   ! given alpha and beta densities "rho0a", "rho0b" and for the alpha and beta
   ! gradient densities "rho1a", "rho1b".
      E :: VEC{REAL}, OUT
      N0a,N0b :: VEC{REAL}, IN
      Nxa,Nya,Nza,Nxb,Nyb,Nzb :: VEC{REAL}, IN, optional

   ENSURE(.scfdata.created,"no scfdata")

      exch,corr :: STR
      add :: DFT_FUNCTIONAL

      if (NOT .scfdata.is_DFT_calculation) then
         return
      end
      add.set_defaults
      add.set_rho_cutoff(.becke_grid.rho_cutoff)

      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional

      E = ZERO ! <<< set to zero

      if (exch/="none") add.new_u_energy_density(exch,E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
      if (corr/="none") add.new_u_energy_density(corr,E,N0a,N0b,Nxa,Nya,Nza,Nxb,Nyb,Nzb)

   end

   new_set_u_XC_potentials(V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
   ! For given alpha and beta densities "N0a", "N0b" and gradient
   ! densities "Nxa", ..., "Nzb" return the alpha and beta local
   ! potentials, "V0a" and "V0b", and the non local potentails "Vxa",
   ! ... , "Vzb" needed to calculate the matrix elements of the
   ! *unrestricted* exchange correlation potentials. 
      V0a,V0b :: VEC{REAL}, INOUT
      N0a,N0b :: VEC{REAL}, IN
      Vxa,Vya,Vza,Vxb,Vyb,Vzb :: VEC{REAL}, OUT, optional
      Nxa,Nya,Nza,Nxb,Nyb,Nzb :: VEC{REAL}, IN, optional

   ENSURE(.scfdata.created,"no scfdata")

      exch,corr :: STR
      add :: DFT_FUNCTIONAL

      if (NOT .scfdata.is_DFT_calculation) then
         return
      end

      add.set_defaults
      add.set_rho_cutoff(.becke_grid.rho_cutoff)

      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional

      V0a = ZERO; V0b = ZERO ! <<< set to zero
      if (present(Vxa)) then
         Vxa = ZERO; Vya = ZERO; Vza = ZERO
         Vxb = ZERO; Vyb = ZERO; Vzb = ZERO
      end

      if (exch/="none") add.new_u_potential(exch,V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)
      if (corr/="none") add.new_u_potential(corr,V0a,V0b,N0a,N0b,Vxa,Vya,Vza,Vxb,Vyb,Vzb,Nxa,Nya,Nza,Nxb,Nyb,Nzb)

   end

! Numerical J matrix -- calculated two ways

!   make_numerical_J_matrix_v1(J)
!   ! Evaluate the coulomb matrix "J" using numerical evaluation of the potential
!   ! on a DFT integration grid.
!     J :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(.dftgrid.created, "need to specify dftgrid")
!     pt :: MAT{REAL}*
!     wt,p :: VEC{REAL}*
!     n_pt :: INT
!     n_pt = .dftgrid.n_pts*.n_atom
!     p.create(n_pt)
!     pt.create(n_pt,3)
!     wt.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(p,pt)
!     p = wt*p ! Now we have the effective charges
!     wt.destroy
!     .make_nuclear_attraction_mx(J,charges=p,points=pt)
!     pt.destroy
!     p.destroy
!   end

!   make_numerical_J_matrix_v2(J)
!   ! Evaluate the coulomb matrix "J" using numerical evaluation of the potential
!   ! on a DFT integration grid.
!     J :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(.dftgrid.created, "need to specify dftgrid")
!     JJ,pt :: MAT{REAL}*
!     wt,q :: VEC{REAL}*
!     n_pt, p,fa,la,fb,lb,atom_a,atom_b :: INT
!     sh :: SHELL2
!     atom :: VEC{ATOM}*
!     n_pt = .dftgrid.n_pts*.n_atom
!     q.create(n_pt)
!     pt.create(n_pt,3)
!     wt.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(q,pt)
!     q = wt*q ! Now we have the effective charges
!     wt.destroy
!     J = ZERO
!     do p = 1,.n_shell_pairs
!        .get_precomputed_shell_pair(sh,p,fa,la,fb,lb,atom_a,atom_b)
!        if (atom_a==atom_b) then
!           atom.create(1)
!           atom(1) = .atom(atom_a)
!        else
!           atom.create(2)
!           atom(1) = .atom(atom_a)
!           atom(2) = .atom(atom_b)
!        end
!        JJ.create(sh.a.n_comp,sh.b.n_comp)
!        .dftgrid.make_potential_MEs_of(MOLECULE::electric_potential,q,pt,sh,atom,JJ)
!        atom.nullify_ptr_part; atom.destroy
!        J(fa:la,fb:lb) = J(fa:la,fb:lb) - JJ
!        JJ.destroy
!        sh.destroy_ptr_part
!     end
!     J.symmetric_reflect
!     pt.destroy
!     q.destroy
!   end

!  ======================
!  Two electron integrals
!  ======================

   get_ERI_integrals
   ! Get the electron repulsion integrals on disk. If the integral
   ! file is already there, do nothing.

      eri_archive,ind_archive :: ARCHIVE

      eri_archive.set(.name,"eri_integrals")
      ind_archive.set(.name,"eri_index")

      if ((NOT eri_archive.exists) OR (NOT ind_archive.exists)) then

         eri_archive.open(for="write-only")
         ind_archive.open(for="write-only")

         .make_eri_integrals(eri_archive,ind_archive)

         ind_archive.close
         eri_archive.close

      end

   end

   make_eri_integrals(eri_archive,eri_index)
   ! Calculate the electron repulsion integrals (ERI's) over all basis
   ! functions Outputs to archive "eri_archive". 
   ! NOTE: that index coincidence factors are included.
   ! NOTE: Replace SHELL4 in here with SHELL1QUARTET
      eri_archive,eri_index :: ARCHIVE

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sh4 :: SHELL4
      ERI :: MAT4{REAL}*
      q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d :: INT
      factor :: REAL

      skipped = 0

      if (.scfdata.output) then

         stdout.set_real_style("e")
         stdout.show("Skipping electron repulsion integrals less than ",.scfdata.eri_disk_cutoff)
         stdout.set_real_style("f")

      end

      if (.scfdata.using_NDDO) then

         do q = 1, .n_shell_quartets
 
            .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
 
            if (atom_a==atom_b AND atom_c==atom_d) then
               .copy_shell_quartet(sh4,q,a,b,c,d)
            else
               skipped = skipped + 1
               cycle
            end
 
            if (sh4.skip_ERI) then
               skipped = skipped + 1
               sh4.destroy_ptr_part
               cycle
            end
 
            ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
            sh4.get_ERI(ERI)
 
            ! Coincidence factors
            factor = ONE
            if (a==b)          factor = HALF                    
            if (c==d)          factor = HALF * factor
            if (a==c AND b==d) factor = HALF * factor
            ERI = factor * ERI
 
            eri_archive.Bfile.write(ERI)
            eri_index.Bfile.write(q)
 
            ERI.destroy
            sh4.destroy_ptr_part
 
         end

      else if (.scfdata.using_NUDO) then

         do q = 1, .n_shell_quartets
 
            .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
  
            if (.atom.bonded(atom_a,atom_b) AND .atom.bonded(atom_c,atom_d)) then
               .copy_shell_quartet(sh4,q,a,b,c,d)
            else
               skipped = skipped + 1
               cycle
            end
  
            if (sh4.skip_ERI) then
               skipped = skipped + 1
               sh4.destroy_ptr_part
               cycle
            end
  
            ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
            sh4.get_ERI(ERI)
  
            ! Coincidence factors
            factor = ONE
            if (a==b)          factor = HALF                    
            if (c==d)          factor = HALF * factor
            if (a==c AND b==d) factor = HALF * factor
            ERI = factor * ERI
  
            eri_archive.Bfile.write(ERI)
            eri_index.Bfile.write(q)
  
            ERI.destroy
            sh4.destroy_ptr_part
 
         end

      else

         do q = 1, .n_shell_quartets
 
            .copy_shell_quartet(sh4,q,a,b,c,d)
 
            if (sh4.skip_ERI(.scfdata.eri_disk_cutoff)) then
              skipped = skipped + 1
              sh4.destroy_ptr_part
              cycle
            end
 
            ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
            sh4.get_ERI(ERI)
  
            ! Coincidence factors
            factor = ONE
            if (a==b)          factor = HALF                    
            if (c==d)          factor = HALF * factor
            if (a==c AND b==d) factor = HALF * factor
            ERI = factor * ERI
 
            eri_archive.Bfile.write(ERI)
            eri_index.Bfile.write(q)
 
            ERI.destroy
            sh4.destroy_ptr_part
 
         end

      end

      if (.scfdata.output) then
         a = .n_shell_quartets
         stdout.text("Skipped "//skipped.to_str.trim//" out of "//a.to_str.trim//" blocks.")
      end

      eri_index.Bfile.write(.n_shell_quartets+1)

   end

   get_spin_orbit_integrals
   ! Get the spin orbit integrals on disk. If the integral files are
   ! file is already there, do nothing.

      SOx_archive,SOy_archive,SOz_archive,ind_archive :: ARCHIVE

      SOx_archive.set(.name,"SOx_integrals")
      SOy_archive.set(.name,"SOy_integrals")
      SOz_archive.set(.name,"SOz_integrals")
      ind_archive.set(.name,"SO_indices")

      if (NOT SOx_archive.exists) then

         SOx_archive.open(for="write-only")
         SOy_archive.open(for="write-only")
         SOz_archive.open(for="write-only")
         ind_archive.open(for="write-only")

         .make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)

         SOx_archive.close
         SOy_archive.close
         SOz_archive.close
         ind_archive.close

      end

   end

   make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
   ! Calculate the spin orbit integrals. Outputs the spin same-orbit integrals
   ! to for each component i to "SOi_archive". The shell quartet index for
   ! these integrals are put in "ind_archive". Note that index coincidence
   ! factors are included.
      SOx_archive,SOy_archive,SOz_archive,ind_archive :: ARCHIVE

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sh4 :: SHELL4
      Sx,Sy,Sz,Ox,Oy,Oz :: MAT4{REAL}*
      q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d,na,nb,nc,nd :: INT
      factor :: REAL
      cutoff :: STR

      cutoff.from_real(SHELL4_ERI_CUTOFF)
      if (.scfdata.output) then
         stdout.text("Skipping electron repulsion integrals less than "//trim(cutoff)//".")
      end

      skipped = 0

      do q = 1,.n_shell_quartets

         if (.scfdata.using_NDDO) then

            .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
            if (atom_a==atom_b AND atom_c==atom_d) then
               .copy_shell_quartet(sh4,q,a,b,c,d)
            else
               skipped = skipped + 1
               cycle
            end

         else if (.scfdata.using_NUDO) then

            .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
            if (.atom.bonded(atom_a,atom_b) AND .atom.bonded(atom_c,atom_d)) then
               .copy_shell_quartet(sh4,q,a,b,c,d)
            else
               skipped = skipped + 1
               cycle
            end

         else

            .copy_shell_quartet(sh4,q,a,b,c,d)

         end

         if (sh4.skip_ERI) then
            skipped = skipped + 1
            sh4.destroy_ptr_part
            cycle
         end

         na = sh4.a.n_comp; nb = sh4.b.n_comp
         nc = sh4.c.n_comp; nd = sh4.d.n_comp
         Sx.create(na,nb,nc,nd); Sy.create(na,nb,nc,nd); Sz.create(na,nb,nc,nd)
         Ox.create(na,nb,nc,nd); Oy.create(na,nb,nc,nd); Oz.create(na,nb,nc,nd)

         sh4.make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)

         ! Coincidence factors
         factor = ONE
         if (a==b)          factor = HALF                    
         if (c==d)          factor = HALF * factor
         if (a==c AND b==d) factor = HALF * factor
         Sx = factor*Sx; Sy = factor*Sy; Sz = factor*Sz
         Ox = factor*Ox; Oy = factor*Oy; Oz = factor*Oz

         SOx_archive.Bfile.write(Sx); SOx_archive.Bfile.write(Ox)
         SOy_archive.Bfile.write(Sy); SOy_archive.Bfile.write(Oy)
         SOz_archive.Bfile.write(Sz); SOz_archive.Bfile.write(Oz)
         ind_archive.Bfile.write(q)

         Oz.destroy; Oy.destroy; Ox.destroy
         Sz.destroy; Sy.destroy; Sx.destroy
         sh4.destroy_ptr_part

      end

      if (.scfdata.output) then
         a = .n_shell_quartets
         stdout.text("Skipped "//skipped.to_str.trim//" out of "//a.to_str.trim//" blocks.")
      end

      ind_archive.Bfile.write(.n_shell_quartets+1)

   end

!  ===================
!  Pairwise SCF energy
!  ===================

   put_scf_energy_in_mo_pairs
   ! Analyse the SCF energy into MO pairs
      Di :: OPMATRIX*
      core_energy :: VEC{REAL}*
      pair_energy :: MAT{REAL}*
      i,j :: INT
      energy :: REAL
      direct :: BIN

      core_energy.create(.n_a)
      pair_energy.create(.n_a,.n_a)

      core_energy = ZERO
      pair_energy = ZERO

      Di.create(.n_bf)

      direct = .scfdata.using_direct_scf
      .scfdata.set_using_direct_scf(TRUE)

      do i = 1,.n_a
         .make_scf_density_matrix(i)
         Di.set_to(.density_matrix)
         .make_fock_matrix(.density_matrix,.fock_matrix,core=TRUE,r12=FALSE)
         core_energy(i) = .scf_electronic_energy(Di,core=TRUE)
         do j = 1,i
            .make_scf_density_matrix(j)
            .make_fock_matrix(.density_matrix,.fock_matrix,core=FALSE,r12=TRUE)
            if (i==j) then ! fac = ONE
              pair_energy(i,j) = .scf_electronic_energy(Di,core=FALSE)
            else           ! fac = TWO
              pair_energy(i,j) = TWO*.scf_electronic_energy(Di,core=FALSE)
            end
         end
      end
      Di.destroy

      .scfdata.set_using_direct_scf(direct)

      stdout.flush
      stdout.text("SCF MO pair energy decomposition:")
      energy = sum(core_energy)+sum(transfer(pair_energy,(/ONE/)))+.nuclear_repulsion_energy
      stdout.show("SCF energy =",energy)
      stdout.text("Core energies:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("Core energy")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      do i = 1,.n_a
         stdout.put(i)
         stdout.put(core_energy(i))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=1)
      stdout.flush
      stdout.text("Orbital pair energies:")
      stdout.dash(int_fields=2,real_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("MO_j",int_width=TRUE)
      stdout.put("Pair energy")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=1)
      do i = 1,.n_a
      do j = 1,i
         stdout.put(i)
         stdout.put(j)
         stdout.put(pair_energy(i,j))
         stdout.flush
      end
      end
      stdout.dash(int_fields=2,real_fields=1)
      stdout.flush
   end

!  ========================
!  SCF Energy decomposition
!  ========================

   put_AO_energy_partition
   ! Put out the AO energy partition
      Y :: MAT{REAL}*
      Y.create(.n_bf,.n_bf)
      Y.to_unit_matrix
      .put_energy_partition(Y)
      Y.destroy
   end

   put_SAO_energy_partition
   ! Put out the symmetric AO energy partition
      Smh :: MAT{REAL}*
      .get_overlap_matrix
      Smh.create(.n_bf,.n_bf)
      .make_overlap_inverse_sqrt(Smh)
      .put_energy_partition(Smh)
      Smh.destroy
   end

   put_MO_energy_partition
   ! Put out the MO energy partition. NOTE: the MO's must be ordered
   ! contiguously, first group 1 then group 2 MO's, AND the atoms in each group
   ! must be contiguous in the .atom list, first group 1 then group 2. This is
   ! because the atom_group_AO_subspace_set routine is used, and by abuse of its
   ! function with the above cobstraints, it will do the right thing and copy
   ! quadrants.
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
      .put_energy_partition(.molecular_orbitals.restricted)
   end

   put_energy_partition(Y)
   ! Put out the energy decomposition specified in the .atom_group array.
   ! The inverse of matrix "Y" is used to back transform the density matrix
   ! (which is taken from disk). The back transformed density matrix is then
   ! partitioned, and transformed back in order to evaluate the interaction
   ! energies between the partitioned systems.
      Y :: MAT{REAL}

   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(size(.atom_group)==2,"must have only 2 groups")
   ENSURE(Y.dim1==.n_bf,"incorrect size for Y array")

      X, T,Z,ZZ,C,K,P,PP,W,E_T,E_Z, EE :: MAT{REAL}*
      E_ZZ :: MAT3{REAL}*
      E_C,E_K :: MAT4{REAL}*
      n_group,g,h,i,j :: INT
      fac :: REAL
      unit :: STR
      arch :: ARCHIVE
      kinetic_energy,nuclear_attraction,nuclear_repulsion :: REAL
      coulomb_repulsion,net_coulomb,bicentric_exchange :: REAL
      exchange_attraction,total_interaction :: REAL

      arch.set(.name,"density_matrix,restricted")
      ENSURE(arch.exists,"no density matrix saved on disk")

      P.create(.n_bf,.n_bf)
      PP.create(.n_bf,.n_bf)
      arch.read(P)

      W.create(.n_bf,.n_bf)
      T.create(.n_bf,.n_bf); .make_kinetic_energy_mx(T)
      Z.create(.n_bf,.n_bf); .make_nuclear_attraction_mx(Z)
      X.create(.n_bf,.n_bf); X.to_inverse_of(Y)

      n_group = size(.atom_group)
      E_T.create(n_group,n_group); E_T = ZERO
      E_Z.create(n_group,n_group); E_Z = ZERO
      E_C.create(n_group,n_group,n_group,n_group); E_C = ZERO
      E_K.create(n_group,n_group,n_group,n_group); E_K = ZERO
      E_ZZ.create(n_group,n_group,n_group); E_ZZ = ZERO
      ZZ.create(.n_bf,.n_bf)

      PP = P
      PP.back_transform_using(X)
      X.destroy
         do i = 1,n_group
         do j = 1,i
            W = ZERO
            .atom_group_AO_subspace_set(W,PP,i,j)
            if (i/=j) &
            .atom_group_AO_subspace_set(W,PP,j,i)
            W.back_transform_using(Y)
            E_T(i,j) = T.trace_product_with(W)
            E_Z(i,j) = Z.trace_product_with(W)
            do g = 1,n_group
               .make_nuclear_attraction_mx(ZZ,.atom_group(g).atom_index)
               E_ZZ(i,j,g) = ZZ.trace_product_with(W)
            end
         end
         end
      ZZ.destroy

      C.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      do g = 1,n_group
      do h = 1,g
         W = ZERO
         .atom_group_AO_subspace_set(W,PP,g,h)
         if (g/=h) &
         .atom_group_AO_subspace_set(W,PP,h,g)
         W.back_transform_using(Y)
         .make_r_JK_nosym(C,K,W)
         do i = 1,n_group
         do j = 1,i
            W = ZERO
            .atom_group_AO_subspace_set(W,PP,i,j)
            if (i/=j) &
            .atom_group_AO_subspace_set(W,PP,j,i)
            W.back_transform_using(Y)
            E_C(i,j,g,h) =  C.trace_product_with(W)
            E_K(i,j,g,h) = -K.trace_product_with(W)
         end
         end
      end
      end
      K.destroy
      C.destroy

      E_C = HALF*E_C
      E_K = HALF*HALF*E_K
      EE.create(n_group,n_group)
      !
      stdout.text(" ")
      stdout.text("Energies obtained with the current density matrix:")
      stdout.text(" ")
      fac = sum(E_T+E_Z) + sum(E_C+E_K)
      stdout.show("SCF electronic energy =",fac)
      stdout.show("SCF energy            =",fac+.nuclear_repulsion_energy)
      stdout.show("Kinetic energy        =",sum(E_T))
      !
      unit = "kcal/mol"
      fac = unit.conversion_factor
      E_T = fac*E_T
      E_Z = fac*E_Z
      E_C = fac*E_C
      E_K = fac*E_K
      E_ZZ = fac*E_ZZ
      stdout.text(" ")
      stdout.text("Energy decomposition in kcal/mol ...")
      stdout.text(" ")
      stdout.text("Kinetic interaction terms")
      stdout.put(E_T)
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms")
      stdout.put(E_Z)
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
      stdout.put(E_ZZ(:,:,1))
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
      stdout.put(E_ZZ(:,:,2))
      EE(1,1) = fac*.atom(.atom_group(1).atom_index).nuclear_repulsion_energy
      EE(2,2) = fac*.atom(.atom_group(2).atom_index).nuclear_repulsion_energy
      nuclear_repulsion = fac*.nuclear_repulsion_energy - EE(1,1) - EE(2,2)
      EE(2,1) = nuclear_repulsion
      EE(1,2) = ZERO
      stdout.text(" ")
      stdout.text("Nuclear nuclear repulsion")
      stdout.put(EE)
      EE(1,1) = E_C(1,1,1,1)
      EE(2,1) = E_C(2,2,1,1)
      EE(1,2) = E_C(1,1,2,2)
      EE(2,2) = E_C(2,2,2,2)
      stdout.text(" ")
      stdout.text("Diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      EE(1,1) = E_C(1,2,1,1)
      EE(2,1) = E_C(2,1,1,1)
      EE(1,2) = E_C(1,2,2,2)
      EE(2,2) = E_C(2,1,2,2)
      stdout.text(" ")
      stdout.text("Semi diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      EE(1,1) = E_C(1,2,1,2)
      EE(2,1) = E_C(2,1,1,2)
      EE(1,2) = E_C(1,2,2,1)
      EE(2,2) = E_C(2,1,2,1)
      stdout.text(" ")
      stdout.text("Off diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      stdout.text(" ")
      stdout.text("All Coulomb repulsion interaction terms")
      stdout.put(E_C)
      EE(1,1) = E_K(1,1,1,1)
      EE(2,1) = E_K(2,2,1,1)
      EE(1,2) = E_K(1,1,2,2)
      EE(2,2) = E_K(2,2,2,2)
      stdout.text(" ")
      stdout.text("Diagonal exchange interaction terms")
      stdout.put(EE)
      EE(1,1) = E_K(1,2,1,1)
      EE(2,1) = E_K(2,1,1,1)
      EE(1,2) = E_K(1,2,2,2)
      EE(2,2) = E_K(2,1,2,2)
      stdout.text(" ")
      stdout.text("Semi diagonal exchange interaction terms")
      stdout.put(EE)
      EE(1,1) = E_K(1,2,1,2)
      EE(2,1) = E_K(2,1,1,2)
      EE(1,2) = E_K(1,2,2,1)
      EE(2,2) = E_K(2,1,2,1)
      stdout.text(" ")
      stdout.text("Off diagonal exchange interaction terms")
      stdout.put(EE)
      stdout.text(" ")
      stdout.text("All exchange interaction terms")
      stdout.put(E_K)

      kinetic_energy = E_T(2,1)
      nuclear_attraction = sum(E_Z) - E_ZZ(1,1,1) - E_ZZ(2,2,2)
      coulomb_repulsion = sum(E_C) - E_C(1,1,1,1) - E_C(2,2,2,2)
      net_coulomb = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
      bicentric_exchange = E_K(1,1,2,2) + E_K(2,2,1,1)
      exchange_attraction = sum(E_K) - E_K(1,1,1,1) - E_K(2,2,2,2)
      total_interaction = kinetic_energy + net_coulomb + exchange_attraction
      stdout.text(" ")
      stdout.show("Electron-nuclear attraction =",nuclear_attraction)
      stdout.show("Nuclear-nuclear repulsion   =",nuclear_repulsion)
      stdout.show("Electron coulomb repulsion  =",coulomb_repulsion)
      stdout.text(" ")
      stdout.text("Interaction energies for "//trim(.name)//":")
      stdout.text(" ")
      stdout.show("Kinetic energy              =",kinetic_energy)
      stdout.show("Exchange energy             =",exchange_attraction)
      stdout.show("Kinetic + Exhange           =",kinetic_energy+exchange_attraction)
      stdout.show("Bicentric Exchange          =",bicentric_exchange)
      stdout.show("Net Coulomb energy          =",net_coulomb)
      stdout.show("Net electronic en           =",nuclear_attraction+coulomb_repulsion)
      stdout.show("Total int. energy           =",total_interaction)

      kinetic_energy = E_T(1,1)
      exchange_attraction = E_K(1,1,1,1)
      net_coulomb = E_ZZ(1,1,1) + fac*.atom(.atom_group(1).atom_index).nuclear_repulsion_energy + E_C(1,1,1,1)
      total_interaction = kinetic_energy + net_coulomb + exchange_attraction
      stdout.text(" ")
      stdout.text("Monomer 1 energies:")
      stdout.text(" ")
      stdout.show("Kinetic energy 1            =",kinetic_energy)
      stdout.show("Exchange energy 1           =",exchange_attraction)
      stdout.show("Kinetic+Exhange 1           =",kinetic_energy+exchange_attraction)
      stdout.show("Net Coulomb 1               =",net_coulomb)
      stdout.show("Total 1                     =",total_interaction)

      kinetic_energy = E_T(2,2)
      exchange_attraction = E_K(2,2,2,2)
      net_coulomb = E_ZZ(2,2,2) + fac*.atom(.atom_group(2).atom_index).nuclear_repulsion_energy + E_C(2,2,2,2)
      total_interaction = kinetic_energy + net_coulomb + exchange_attraction
      stdout.text(" ")
      stdout.text("Monomer 2 energies:")
      stdout.text(" ")
      stdout.show("Kinetic energy 2            =",kinetic_energy)
      stdout.show("Exchange energy 2           =",exchange_attraction)
      stdout.show("Kinetic+Exhange 2           =",kinetic_energy+exchange_attraction)
      stdout.show("Net Coulomb 2               =",net_coulomb)
      stdout.show("Total 2                     =",total_interaction)

      EE.destroy
      E_ZZ.destroy
      E_K.destroy
      E_C.destroy
      E_Z.destroy
      E_T.destroy
      Z.destroy
      T.destroy
      W.destroy
      PP.destroy
      P.destroy

   end

!   put_roby_energy_partition
!   ! Put out the energy decomposition specified in the .atom_group array.
!   ! The inverse of matrix "Y" is used to back transform the density matrix
!   ! (which is taken from disk). The back transformed density matrix is then
!   ! partitioned, and transformed back in order to evaluate the interaction
!   ! energies between the partitioned systems.
!      unit :: STR
!      arch :: ARCHIVE
!      E_T,E_T_A,E_T_B, E_Z,E_Z_A,E_Z_B :: REAL
!      E_C,E_C_A,E_C_B, E_K,E_K_A,E_K_B, E_N,E_N_A,E_N_B :: REAL
!      kinetic_energy,nuclear_attraction,nuclear_repulsion :: REAL
!      coulomb_repulsion,net_coulomb :: REAL
!      exchange_attraction,total_interaction :: REAL
!      energy, promotion_energy, fac :: REAL
!      P,P_A,P_B,MO,OM,Q,T,Z,C,K :: MAT{REAL}*
!      n,f,l :: INT
!      ENSURE(.atom_group.created,"no atom group information")
!      ENSURE(size(.atom_group)==2,"must have only 2 groups")
!      arch.set(.name,"density_matrix,restricted")
!      ENSURE(arch.exists,"no density matrix")
!      P.create(.n_bf,.n_bf)
!      arch.read(P) ! Read the density from disk
!      !
!      .make_progroup_density(MOs=TRUE)
!  ! stdout.text(" ")
!  ! stdout.text("WARING, no symorthonormilsation")
!      .symorthonormalise_occupied_MOs
!      !
!      P_A.create(.n_bf,.n_bf)
!      P_B.create(.n_bf,.n_bf)
!      MO.create(.n_bf,.n_bf)
!      OM.create(.n_bf,.n_bf)
!      Q.create(.n_bf,.n_bf)
!      MO = .molecular_orbitals.restricted
!      OM.to_inverse_of(MO)
!      P.back_transform_to(Q,OM)
!      n = .occupation_numbers.restricted(1:).index_of_first_zero_value - 1
!    stdout.text(" ")
!    stdout.show("n =",n)
!      P_A = ZERO
!      P_A(1:n,1:n) = Q(1:n,1:n)
!    stdout.text("P_A :")
!    stdout.put(P_A)
!      P_A.back_transform_using(MO)
!      f = .occupation_numbers.restricted(n+1:).index_of_first_nonzero_value
!      f = n + f
!      l = .occupation_numbers.restricted(f:).index_of_first_zero_value - 1
!      l = f + l - 1
!    stdout.show("f =",f)
!    stdout.show("l =",l)
!      P_B = ZERO
!      P_B(f:l,f:l) = Q(f:l,f:l)
!    stdout.text("P_B :")
!    stdout.put(P_B)
!      P_B.back_transform_using(MO)
!    stdout.text("Q :")
!    stdout.put(Q)
!      Q.destroy
!      OM.destroy
!      MO.destroy
!      !
!      unit = "kcal/mol"
!      fac = unit.conversion_factor
!      !
!      T.create(.n_bf,.n_bf)
!      .make_kinetic_energy_mx(T)
!      E_T   = T.trace_product_with(P)*fac
!      E_T_A = T.trace_product_with(P_A)*fac
!      E_T_B = T.trace_product_with(P_B)*fac
!      T.destroy
!      !
!      Z.create(.n_bf,.n_bf)
!      .make_nuclear_attraction_mx(Z)
!      E_Z   = Z.trace_product_with(P)*fac
!      .make_nuclear_attraction_mx(Z,.atom_group(1).element)
!      E_Z_A = Z.trace_product_with(P_A)*fac
!      .make_nuclear_attraction_mx(Z,.atom_group(2).element)
!      E_Z_B = Z.trace_product_with(P_B)*fac
!      Z.destroy
!      !
!      C.create(.n_bf,.n_bf)
!      K.create(.n_bf,.n_bf)
!      .make_r_JK_nosym(C,K,P)
!      E_C   = HALF*C.trace_product_with(P)*fac
!      E_K   = -QUARTER*K.trace_product_with(P)*fac
!      .make_r_JK_nosym(C,K,P_A)
!      E_C_A = HALF*C.trace_product_with(P_A)*fac
!      E_K_A = -QUARTER*K.trace_product_with(P_A)*fac
!      .make_r_JK_nosym(C,K,P_B)
!      E_C_B = HALF*C.trace_product_with(P_B)*fac
!      E_K_B = -QUARTER*K.trace_product_with(P_B)*fac
!      K.destroy
!      C.destroy
!      P_B.destroy
!      P_A.destroy
!      P.destroy
!      !
!      E_N   = .nuclear_repulsion_energy*fac
!      E_N_A = .atom(.atom_group(1).element).nuclear_repulsion_energy*fac
!      E_N_B = .atom(.atom_group(2).element).nuclear_repulsion_energy*fac
!      stdout.text(" ")
!      !
!      energy              = E_T + E_Z + E_C + E_K
!      kinetic_energy      = E_T - E_T_A - E_T_B
!      nuclear_attraction  = E_Z - E_Z_A - E_Z_B
!      nuclear_repulsion   = E_N - E_N_A - E_N_B
!      coulomb_repulsion   = E_C - E_C_A - E_C_B
!      net_coulomb         = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
!      exchange_attraction = E_K - E_K_A - E_K_B
!      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction
!      !
!      stdout.text(" ")
!      stdout.show("SCF electronic energy =",(energy/fac))
!      stdout.show("SCF energy !      =",(energy/fac)+.nuclear_repulsion_energy)
!      stdout.show("Kinetic energy        =",(E_T/fac))
!      stdout.text(" ")
!      stdout.text("Roby energy decomposition in kcal/mol ...")
!      stdout.text(" ")
!      stdout.text("Interaction energies for "//trim(.name)//":")
!      stdout.text(" ")
!      stdout.show("Energy             =",energy)
!      stdout.show("Kinetic energy     =",kinetic_energy)
!      stdout.show("Exchange energy    =",exchange_attraction)
!      stdout.show("Kinetic + Exhange  =",kinetic_energy+exchange_attraction)
!      stdout.show("Net Coulomb energy =",net_coulomb)
!      stdout.show("Total int. energy  =",total_interaction)
!      !
!      kinetic_energy      = E_T_A
!      exchange_attraction = E_K_A
!      net_coulomb         = E_Z_A + E_N_A + E_C_A
!      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction
!      promotion_energy    = total_interaction - .atom_group_energy(1)*fac
!      stdout.text(" ")
!      stdout.text("Monomer 1 energies:")
!      stdout.text(" ")
!      stdout.show("Kinetic energy 1   =",kinetic_energy)
!      stdout.show("Exchange energy 1  =",exchange_attraction)
!      stdout.show("Kinetic+Exhange 1  =",kinetic_energy+exchange_attraction)
!      stdout.show("Net Coulomb 1      =",net_coulomb)
!      stdout.show("Total 1            =",total_interaction)
!      stdout.show("Promotion 1        =",promotion_energy)
!      !
!      kinetic_energy      = E_T_B
!      exchange_attraction = E_K_B
!      net_coulomb         = E_Z_B + E_N_B + E_C_B
!      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction
!      promotion_energy    = total_interaction - .atom_group_energy(2)*fac
!      stdout.text(" ")
!      stdout.text("Monomer 2 energies:")
!      stdout.text(" ")
!      stdout.show("Kinetic energy 2   =",kinetic_energy)
!      stdout.show("Exchange energy 2  =",exchange_attraction)
!      stdout.show("Kinetic+Exhange 2  =",kinetic_energy+exchange_attraction)
!      stdout.show("Net Coulomb 2      =",net_coulomb)
!      stdout.show("Total 2            =",total_interaction)
!      stdout.show("Promotion 2        =",promotion_energy)
!   end

   put_roby_smo_energy_partition
   ! Put out the roby energy decomposition specified in the .atom_group array
   ! based on symmetrically orthonormalised monomer molecular (SOMMO) fragments.
   ! A supermolecue density matrix must exist on disk.
      .put_roby_energy_partition(symorthonormalise=TRUE)
   end

   put_roby_mmo_energy_partition
   ! Put out the roby energy decomposition specified in the .atom_group array
   ! based on monomer molecular (MMO) fragments.  A supermolecue density matrix
   ! must exist on disk.
      .put_roby_energy_partition(symorthonormalise=FALSE)
   end

   put_roby_energy_partition(symorthonormalise) ::: leaky
   ! Calculate and put out the roby energy decomposition using groups
   ! specified in the .atom_group array.  If "symorthonormalise" is
   ! TRUE, then the occupied monomer molecular orbitals are
   ! symmetrically orthonormalised in order to define the fragments.
   ! NOTE: The density matrix defining the supermolecule is read in
   ! from the disk, so an SCF calculation or a "make_group_density_matrix"
   ! calculation must be done before this routine is called.
      symorthonormalise :: BIN

   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(size(.atom_group)==2,"must have only 2 groups")
   ENSURE(.atom_group(1).mol.created,"No group 1 molecule")
   ENSURE(.atom_group(2).mol.created,"No group 2 molecule")
   ENSURE(.atom_group(1).mol.scfdata.created,"No group 1 scfdata")
   ENSURE(.atom_group(2).mol.scfdata.created,"No group 2 scfdata")

      unit :: STR
      arch :: ARCHIVE
      E_T,E_T_A,E_T_B, E_Z,E_Z_A,E_Z_B :: REAL
      E0_A,E0_B, E0_T_A,E0_T_B, E0_Z_A,E0_Z_B :: REAL
      E_C,E_C_A,E_C_B, E_K,E_K_A,E_K_B, E_N,E_N_A,E_N_B :: REAL
      E0_C_A,E0_C_B, E0_K_A,E0_K_B :: REAL
      E_kin,E_att,E_rep,E_coul,E_net_coul,E_ex,E_int,E_prom,energy, fac :: REAL
      P,P_A,P_B,MO,D,T,Z,C,K :: MAT{REAL}*
      n,f,l :: INT

      ! Units
      unit = "kcal/mol"
      fac = unit.conversion_factor

      ! Make sure ANO data etc. is up-to-date
      .update_atom_group_info

      ! Density matrix exists?
      arch.set(.name,"density_matrix,restricted")
      ENSURE(arch.exists,"no density matrix")

      ! Read density from disk
      P.create(.n_bf,.n_bf)
      arch.read(P)

      ! Make the monomer density and MO's
      .make_progroup_density(MOs=TRUE)

      ! Make the group energies
      .make_group_energies(1,E0_A,E0_T_A,E0_Z_A,E0_C_A,E0_K_A,fac)
      .make_group_energies(2,E0_B,E0_T_B,E0_Z_B,E0_C_B,E0_K_B,fac)

      ! Symorthonormalise the occupied monomer MO's
      if (symorthonormalise) then
         .symorthonormalise_occupied_MOs
      else
         stdout.text(" ")
         stdout.text("WARNING: no symorthonormalisation of occupied MO's")
      end

      ! Do the energy decomposition
      P_A.create(.n_bf,.n_bf)
      P_B.create(.n_bf,.n_bf)
      D.create(.n_bf,.n_bf)

      .get_overlap_matrix

      P.change_basis_to(P_A,.overlap_matrix)
      P_B = P_A
      n = .occupation_numbers.restricted(1:).index_of_first_zero_value - 1
      MO => .molecular_orbitals.restricted(:,1:n)
      D.to_product_of(MO,MO,transpose_b=TRUE)
      P_A.change_basis_using(D)
      f = .occupation_numbers.restricted(n+1:).index_of_first_nonzero_value
      f = n + f
      l = .occupation_numbers.restricted(f:).index_of_first_zero_value - 1
      l = f + l - 1
      MO => .molecular_orbitals.restricted(:,f:l)
      D.to_product_of(MO,MO,transpose_b=TRUE)
      P_B.change_basis_using(D)
      D.destroy
      !
      T.create(.n_bf,.n_bf)
      .make_kinetic_energy_mx(T)
      E_T   = T.trace_product_with(P)*fac
      E_T_A = T.trace_product_with(P_A)*fac
      E_T_B = T.trace_product_with(P_B)*fac
      T.destroy
      !
      Z.create(.n_bf,.n_bf)
      .make_nuclear_attraction_mx(Z)
      E_Z   = Z.trace_product_with(P)*fac
      .make_nuclear_attraction_mx(Z,.atom_group(1).atom_index)
      E_Z_A = Z.trace_product_with(P_A)*fac
      .make_nuclear_attraction_mx(Z,.atom_group(2).atom_index)
      E_Z_B = Z.trace_product_with(P_B)*fac
      Z.destroy
      !
      C.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      .make_r_JK_nosym(C,K,P)
      E_C   = HALF*C.trace_product_with(P)*fac
      E_K   = -QUARTER*K.trace_product_with(P)*fac
      .make_r_JK_nosym(C,K,P_A)
      E_C_A = HALF*C.trace_product_with(P_A)*fac
      E_K_A = -QUARTER*K.trace_product_with(P_A)*fac
      .make_r_JK_nosym(C,K,P_B)
      E_C_B = HALF*C.trace_product_with(P_B)*fac
      E_K_B = -QUARTER*K.trace_product_with(P_B)*fac
      K.destroy
      C.destroy
      P_B.destroy
      P_A.destroy
      P.destroy
      !
      E_N   = .nuclear_repulsion_energy*fac
      E_N_A = .atom(.atom_group(1).atom_index).nuclear_repulsion_energy*fac
      E_N_B = .atom(.atom_group(2).atom_index).nuclear_repulsion_energy*fac
      stdout.text(" ")
      !
      stdout.text(" ")
      stdout.text("Supermolecule energies:")
      stdout.text(" ")
      energy     = E_T + E_Z + E_C + E_K
      stdout.show("SCF electronic energy =",(energy/fac))
      stdout.show("... in kcal/mol       =",energy)
      stdout.show("SCF energy =",(energy/fac)+.nuclear_repulsion_energy)
      stdout.show("... in kcal/mol =",energy+fac*.nuclear_repulsion_energy)
      stdout.show("Kinetic energy        =",E_T)
      stdout.show("... in kcal/mol       =",(E_T/fac))
      stdout.text(" ")
      stdout.text("Roby interaction energy decomposition (kcal/mol):")
      E_kin      = E_T - E_T_A - E_T_B
      E_ex       = E_K - E_K_A - E_K_B
      E_att      = E_Z - E_Z_A - E_Z_B
      E_rep      = E_N - E_N_A - E_N_B
      E_coul     = E_C - E_C_A - E_C_B
      E_net_coul = E_att + E_rep + E_coul
      E_int      = E_kin + E_net_coul + E_ex
      MOLECULE::put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_int)
      !
      stdout.text(" ")
      stdout.text("Interacting Monomer 1 energies (kcal/mol):")
      stdout.text(" ")
      E_int      = E_T_A + (E_Z_A + E_N_A + E_C_A) + E_K_A
      E_prom     = E_int - .atom_group(1).mol.scfdata.energy*fac
      MOLECULE::put_roby_energy_parts(E_T_A,E_K_A,E_C_A,E_Z_A,E_N_A,E_int,E_prom)
      !
      stdout.text(" ")
      stdout.text("Isolated Monomer 1 energies (kcal/mol):")
      stdout.text(" ")
      stdout.show("Monomer 1 energy   =",.atom_group(1).mol.scfdata.energy)
      stdout.show("... in k/cal mol   =",.atom_group(1).mol.scfdata.energy*fac)
      stdout.text(" ")
      MOLECULE::put_roby_energy_parts(E0_T_A,E0_K_A,E0_C_A,E0_Z_A,E_N_A)
      !
      stdout.text(" ")
      stdout.text("Changes in monomer 1 energy contributions (kcal/mol):")
      E_kin      = E_T_A - E0_T_A
      E_ex       = E_K_A - E0_K_A
      E_coul     = E_C_A - E0_C_A
      E_att      = E_Z_A - E0_Z_A            ! nuclear attraction
      E_rep      = ZERO                      ! change in nuclear repulsion is zero
      E_net_coul = E_att + E_rep + E_coul
      E_prom     = E_kin + E_net_coul + E_ex
      MOLECULE::put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_prom=E_prom)
      !
      stdout.text(" ")
      stdout.text("Interacting Monomer 2 energies (kcal/mol):")
      stdout.text(" ")
      E_int      = E_T_B + (E_Z_B + E_N_B + E_C_B) + E_K_B
      E_prom     = E_int - .atom_group(2).mol.scfdata.energy*fac
      MOLECULE::put_roby_energy_parts(E_T_B,E_K_B,E_C_B,E_Z_B,E_N_B,E_int,E_prom)
      !
      stdout.text(" ")
      stdout.text("Isolated Monomer 2 energies (kcal/mol):")
      stdout.text(" ")
      stdout.show("Monomer 2 energy   =",.atom_group(2).mol.scfdata.energy)
      stdout.show("... in k/cal mol   =",.atom_group(2).mol.scfdata.energy*fac)
      stdout.text(" ")
      MOLECULE::put_roby_energy_parts(E0_T_B,E0_K_B,E0_C_B,E0_Z_B,E_N_B)
      !
      stdout.text(" ")
      stdout.text("Changes in monomer 2 energy contributions (kcal/mol):")
      E_kin      = E_T_B - E0_T_B
      E_ex       = E_K_B - E0_K_B
      E_coul     = E_C_B - E0_C_B
      E_att      = E_Z_B - E0_Z_B            ! nuclear attraction
      E_rep      = ZERO                      ! change in nuclear repulsion is zero
      E_net_coul = E_att + E_rep + E_coul
      E_prom     = E_kin + E_net_coul + E_ex
      MOLECULE::put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_prom=E_prom)

   end

   put_roby_energy_parts(E_T,E_K,E_C,E_Z,E_N,E_int,E_prom) ::: selfless, private
   ! Put of the Roby energy parts
      E_T,E_K,E_C,E_Z,E_N :: REAL
      E_int,E_prom :: REAL, optional

      stdout.flush
      stdout.show("Kinetic energy       =",E_T)
      stdout.show("Exchange energy      =",E_K)
      stdout.show("Kinetic + Exhange    =",E_T+E_K)
      stdout.show("Nuclear attraction   =",E_Z)
      stdout.show("Nuclear repulsion    =",E_N)
      stdout.show("Electronic repulsion =",E_C)
      stdout.show("Net coulomb energy   =",E_Z+E_N+E_C)

      if (present(E_int)) &
      stdout.show("Total int. energy    =",E_int)
      if (present(E_prom)) &
      stdout.show("Promotion energy     =",E_prom)

   end

!  ==================
!  Atom group setting
!  ==================

   atom_group_AO_subspace_set(P,Q,row_group,col_group)
   ! Set P=Q only for the block whose rows correspond to basis functions
   ! on the atoms in the atom group "row_group" and whose columns are
   ! on the atoms in the atom group "col_group", as given in the
   ! .atom_group array vector.
      P,Q :: MAT{REAL}
      row_group,col_group :: INT

   ENSURE(P.dim1==.n_bf,"wrong size for P")
   ENSURE(P.dim2==.n_bf,"wrong size for P")
   ENSURE(Q.dim1==.n_bf,"wrong size for Q")
   ENSURE(Q.dim2==.n_bf,"wrong size for Q")
   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(row_group<=size(.atom_group),"no such row group")
   ENSURE(col_group<=size(.atom_group),"no such column group")
   ENSURE(row_group>0,"row group index must be positive")
   ENSURE(col_group>0,"column group index must be positive")

      i_a,i_b,a,b,fa,fb,la,lb :: INT

      do i_a = 1,size(.atom_group(row_group).atom_index)
      do i_b = 1,size(.atom_group(col_group).atom_index)
         a = .atom_group(row_group).atom_index(i_a)
         b = .atom_group(col_group).atom_index(i_b)
         fa = .first_basis_fn_for_atom(a)
         fb = .first_basis_fn_for_atom(b)
         la = .last_basis_fn_for_atom(a)
         lb = .last_basis_fn_for_atom(b)
         P(fa:la,fb:lb) = Q(fa:la,fb:lb)
      end
      end

   end

   AO_subspace_set(A,B,row_atom,col_atom) ::: private
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom
   ! indices in "row_atom" and "col_atom". If either is missing, then copy
   ! the entire row or col, i.e.  A(small) = B(row_atom,col_atom)
      A,B :: MAT{REAL}
      row_atom,col_atom :: VEC{INT}, optional
   ENSURE(B.dim1==.n_bf,"B has wrong shape")
   ENSURE(B.dim2==.n_bf,"B has wrong shape")
      n_row_atoms,n_col_atoms, a1,a2 :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      if (present(row_atom) AND present(col_atom)) then
         n_row_atoms = size(row_atom)
         n_col_atoms = size(col_atom)
         a1 = .atom(row_atom).n_bf
         a2 = .atom(col_atom).n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = .atom(col_atom(j)).n_bf
               A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
               b_j = b_j + n_j
            end
            b_i = b_i + n_i
         end
      else if (present(row_atom)) then
         n_row_atoms = size(row_atom)
         a1 = .atom(row_atom).n_bf
         a2 = .n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i));
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
            b_i = b_i + n_i
         end
      else if (present(col_atom)) then
         n_col_atoms = size(col_atom)
         a1 = .n_bf
         a2 = .atom(col_atom).n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")
         b_j = 0
         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j));
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = .atom(col_atom(j)).n_bf
            A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)
            b_j = b_j + n_j
         end
      end
   end

   AO_subspace_zero(B,row_atom,col_atom) ::: private
   ! Zero out the AO subspace blocks of "B" specified by the atom
   ! indices in "row_atom" and "col_atom". If either is missing, then zero
   ! the entire row or col, i.e.  B(row_atom,col_atom) = 0
      B :: MAT{REAL}
      row_atom,col_atom :: VEC{INT}, optional
   ENSURE(B.dim1==.n_bf,"B has wrong shape")
   ENSURE(B.dim2==.n_bf,"B has wrong shape")
      n_row_atoms,n_col_atoms :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      if (present(row_atom) AND present(col_atom)) then
         n_row_atoms = size(row_atom)
         n_col_atoms = size(col_atom)
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = .atom(col_atom(j)).n_bf
               B(f_i:l_i,f_j:l_j) = ZERO
               b_j = b_j + n_j
            end
            b_i = b_i + n_i
         end
      else if (present(row_atom)) then
         n_row_atoms = size(row_atom)
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i));
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            B(f_i:l_i,:) = ZERO
            b_i = b_i + n_i
         end
      else if (present(col_atom)) then
         n_col_atoms = size(col_atom)
         b_j = 0
         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j));
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = .atom(col_atom(j)).n_bf
            B(:,f_j:l_j) = ZERO
            b_j = b_j + n_j
         end
      end
   end

   AO_subspace_put(B,A,row_atom,col_atom) ::: private
   ! Set the AO subspace blocks of "A" specified by the atom indices in
   ! "row_atom" and "col_atom" equal to "B". If either is missing then copy
   ! the entire row or column, i.e.  A(row_atom,col_atom) = A() + B(small)
   ! WARNING ==== This adds into A, and uncopied blocks are NOT set to zero.
      A,B :: MAT{REAL}
      row_atom,col_atom :: VEC{INT}, optional
   ENSURE(A.dim1==.n_bf,"A has wrong shape")
   ENSURE(A.dim2==.n_bf,"A has wrong shape")
      n_row_atoms,n_col_atoms,b1,b2 :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      if (present(row_atom) AND present(col_atom)) then
         n_row_atoms = size(row_atom)
         n_col_atoms = size(col_atom)
         b1 = .atom(row_atom).n_bf
         b2 = .atom(col_atom).n_bf
         ENSURE(B.dim1==b1,"B has wrong shape")
         ENSURE(B.dim2==b2,"B has wrong shape")
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = .atom(col_atom(j)).n_bf
               A(f_i:l_i,f_j:l_j) = A(f_i:l_i,f_j:l_j) + B(b_i+1:b_i+n_i,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end
            b_i = b_i + n_i
         end
      else if (present(row_atom)) then
         n_row_atoms = size(row_atom)
         b1 = .atom(row_atom).n_bf
         b2 = .n_bf
         ENSURE(B.dim1==b1,"B has wrong shape")
         ENSURE(B.dim2==b2,"B has wrong shape")
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i));
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            A(f_i:l_i,:) = A(f_i:l_i,:) + B(b_i+1:b_i+n_i,:)
            b_i = b_i + n_i
         end
      else if (present(col_atom)) then
         n_col_atoms = size(col_atom)
         b1 = .atom(col_atom).n_bf
         b2 = .n_bf
         ENSURE(B.dim1==b1,"B has wrong shape")
         ENSURE(B.dim2==b2,"B has wrong shape")
         b_j = 0
         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j));
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = .atom(col_atom(j)).n_bf
            A(:,f_j:l_j) = A(:,f_j:l_j) + B(:,b_j+1:b_j+n_j)
            b_j = b_j + n_j
         end
      end
   end

!  ===========
!  Monomer MOs
!  ===========

   make_monomer_MOs ::: leaky
   ! Make the monomer molecular orbital matrix from symmetrically orthonormalised
   ! group (monomer) molecular orbitals. The promolecule orbitals are ordered by group.
   ! The orbitals and the corresponding promolecule density are *not* archived.
   ! This will destroy any existing restricted density matrix and MOs.
    ! S :: MAT{REAL}*
      .make_progroup_density(MOs=TRUE,output=FALSE)
    ! S.create(.n_bf,.n_bf)
    ! .get_overlap_matrix
    ! .overlap_matrix.change_basis_to(S,.molecular_orbitals.restricted)
    ! stdout.text("S in the monomer basis:")
    ! stdout.put(S)
    ! S.destroy
   end

   make_promol_MOs ::: leaky
   ! Make the promolecule molecular orbital matrix from symmetrically orthonormalised
   ! group (monomer) molecular orbitals. The promolecule orbitals are ordered by group.
   ! The orbitals and the corresponding density are *not* archived.
   ! This will destroy any existing restricted density matrix and MOs.
    ! S :: MAT{REAL}*
      .make_progroup_density(MOs=TRUE,output=FALSE)
      .symorthonormalise_occupied_MOs
    ! S.create(.n_bf,.n_bf)
    ! .get_overlap_matrix
    ! .overlap_matrix.change_basis_to(S,.molecular_orbitals.restricted)
    ! stdout.text("S in the promolecule monomer basis:")
    ! stdout.put(S)
    ! S.destroy
   end

! =========================
! Electron density routines
! =========================

   make_density_grid(density_grid,pt,sgn)
   ! Work out the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector. If "sgn" is present and equal to -1, the
   ! spin density is produced (provided alpha and beta natural orbitals are
   ! present).
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
      sgn :: INT, IN, optional

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      relativity,okind :: STR

      okind = .natural_orbitals.spinorbital_kind

      relativity = "none"
      if (.scfdata.created) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if   

      select case (relativity)

         case ("douglas-kroll-hess","dkh")
            select case (okind)
               case ("restricted");       .make_DKH_density_grid(density_grid,pt)
               case ("unrestricted");     .make_DKH_density_grid(density_grid,pt,sgn)
               case ("general_complex");  .make_DKH_density_grid(density_grid,pt)
               case default; WARN("Unimplemented orbital kind! Sorry :(")
            end

         case ("iotc")
            select case (okind)
               case ("restricted");       .make_IOTC_density_grid(density_grid,pt)
               case ("unrestricted");     .make_IOTC_density_grid(density_grid,pt,sgn)
               case ("general_complex");  .make_IOTC_density_grid(density_grid,pt)
               case default; WARN("Unimplemented orbital kind! Sorry :(")
            end

         case ("none")
            select case (okind)
               case ("restricted");       .make_density_grid_r(density_grid,pt)
               case ("unrestricted");     .make_density_grid_u(density_grid,pt,sgn)
               case ("general_complex");  .make_density_grid_gc(density_grid,pt)
               case default;   DIE("unimplemented")
            end

         case default; DIE("unimplemented")

      end

   end

   make_density_grid(p_a,p_b,pt)
   ! Make the alpha and beta density grids, "p_a" and "p_b" respectively, from
   ! the unrestricted natural orbitals.
      p_a,p_b :: VEC{REAL}
      pt :: MAT{REAL}, IN
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("unrestricted"),"no natural orbitals")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
      nat :: MAT{REAL}*
      occ :: VEC{REAL}*
      nat => .natural_orbitals.restricted ! backup pointers
      occ => .occupation_numbers.restricted
      .natural_orbitals.restricted => .natural_orbitals.alpha
      .occupation_numbers.restricted => .occupation_numbers.alpha
      .make_density_grid(p_a,pt)
      .natural_orbitals.restricted => .natural_orbitals.beta
      .occupation_numbers.restricted => .occupation_numbers.beta
      .make_density_grid(p_b,pt)
      .natural_orbitals.restricted => nat ! restore backups
      .occupation_numbers.restricted => occ
   end

   make_density_grid_r(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation numbers")
      NO :: VEC{REAL}*
      n_occ,n :: INT

      n_occ = .no_of_occupied_NOs
      NO.create(pt.dim1)

      density_grid = ZERO
      parallel do n = 1,n_occ
       .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n), pt)
       density_grid = density_grid + .occupation_numbers.restricted(n)*NO*NO
      end

      if (DO_IN_PARALLEL) then
        PARALLEL_SUM(density_grid)
      end

      NO.destroy

   end

   make_density_grid_u(density_grid,pt,sgn)
   ! Make the "density_grid" for the supplied points "pt" from unrestricted real
   ! natural orbitals. If present "sgn" is used to determine whether the total
   ! density or spin density is to be calculated: sgn=1 means sum the alpha and
   ! beta densities to form the total density, sgn=-1 means to subtract, forming
   ! the Sz spin density.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
      sgn :: INT, IN, optional
   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.natural_orbitals.created("unrestricted"), "no unrestricted NO's")
   ENSURE(.occupation_numbers.alpha.created, "no alpha occupation numbers")
   ENSURE(.occupation_numbers.beta.created, "no beta occupation numbers")
      NO :: VEC{REAL}*
      fac,na,nb,n :: INT
      if (present(sgn)) then; fac = sgn
      else;                   fac = 1
      end
      NO.create(pt.dim1)
      na = .no_of_occupied_NOs("alpha")
      nb = .no_of_occupied_NOs("beta")
      density_grid = ZERO
      do n = 1,na
       .make_orbital_grid_r(NO,.natural_orbitals.alpha(:,n),pt)
       density_grid = density_grid + .occupation_numbers.alpha(n)*NO*NO
      end
      do n = 1,nb
       .make_orbital_grid_r(NO,.natural_orbitals.beta(:,n),pt)
       density_grid = density_grid + fac*.occupation_numbers.beta(n)*NO*NO
      end
      NO.destroy
   end

   make_density_grid_c(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.created("restricted_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.restricted.created, "no occupation numbers")

      NO :: VEC{CPX}*
      n_occ,n :: INT

      density_grid = ZERO

      NO.create(pt.dim1)

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n), pt)
         density_grid = density_grid + .occupation_numbers.restricted(n) * RE(conjg(NO(:))*NO(:))
      end

      NO.destroy

   end

   make_density_grid_gc(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.created("general_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.created("general"), "no occupation numbers")

      gd,gu,ggg :: VEC{CPX}*
      n_occ,n :: INT
      on :: REAL

      density_grid = ZERO

      gu.create(pt.dim1)
      gd.create(pt.dim1)
      ggg.create(pt.dim1)

      ggg= ZERO
      gu= ZERO
      gd= ZERO

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
        on= .occupation_numbers.general(n) 
         .make_orbital_grid_gc(gu,gd,.natural_orbitals.general_complex(:,n),pt)
         ggg(:) = ggg(:) &
                +  on*conjg(gd(:))*gd(:) + on*conjg(gu(:))*gu(:)    
      end

      density_grid(:)= RE(ggg(:))

      gd.destroy
      gu.destroy
      ggg.destroy

   end

   make_density_grid_r(density_grid,pt,NO,occ)
   ! Make the "density_grid" for the supplied points "pt" from the
   ! natural orbitals "NO" and occupuation numbers "occ".
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      NO  :: MAT{REAL}
      occ :: VEC{REAL}
   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
      NOn  :: VEC{REAL}*
      n  :: INT
      NOn.create(pt.dim1)
      density_grid = ZERO
      do n = 1,NO.dim2
        if (occ(n)==ZERO) cycle
       .make_orbital_grid_r(NOn,NO(:,n),pt)
       density_grid = density_grid + occ(n)*NOn*NOn
      end
      NOn.destroy
   end

! ===================================
! Efficient electron density routines
! ===================================

   make_rho_grid(N0,pt,D) ::: leaky
   ! Make the density "N0" on an arbitrary grid "pt" skipping as many
   ! points as possible. This routine will probably have to be batched
   ! over *spatially localised* points to reduce memory requirements.
      N0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(N0.dim==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      bf_lgval :: VEC{VEC_{INT}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      ra :: VEC{REAL}(3)
      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      overlapping_atom, lga,lgb, sp :: VEC{INT}*
      grida0,gridb0, DD :: MAT{REAL}*
      sha :: SHELL1
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n  :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT

      ! Basis function cutoff 
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)
   
         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt) 
   
         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom => .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)
            if (atom_b>atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Loop shells on atom a
            do sa = fsa,lsa
      
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
      
               ! Set shell for index "sa"
               bs           = .basis_shell_for_shell(sa)
               sha          = .precomputed_basis_shellpair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grida0 and lga values
               grida0.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(grida0,n_pt,na,xa,ya,za,a2,lga)
   
               ! Save the values
               bf_grid0(sa).element => grida0
               bf_lgval(sa).element => lga

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)
   
                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1
   
                  ! Get the "sb" basis function grid
                  lgb    => bf_lgval(sb).element 
                  gridb0 => bf_grid0(sb).element 
   
                  ! How many points in common?
                  n_keep = count(lga+lgb>=cutoff)
                  if (n_keep==0) cycle
   
                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=lga+lgb>=cutoff)
   
                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE
   
                  ! Density block
                  DD => D(fa:la,fb:lb)
   
                  if (na*nb==1) then
   
                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     do p = 1,n_keep
                        n = sp(p)
                        ga = ga0(n)
                        gb = gb0(n)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end
   
                  else
   
                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              n = sp(p)
                              ga = ga0(n)
                              gb = gb0(n)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end
   
                     ! Clean up
   
                  end ! if ss or not ss
               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

   end

   make_derivative_rho_grid(N0,pt,D) ::: leaky
   ! Make the field "N0" on an arbitrary grid "pt" skipping as many
   ! points as possible. This routine will probably have to be batched
   ! over *spatially localised* points to reduce memory requirements.
      N0 :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
      D  :: MAT3{REAL}, target, IN

   ENSURE(N0.dim1==pt.dim1,"N0 and pt: incompatible sizes")
   ENSURE(N0.dim2== D.dim3,"N0 and D: incompatible sizes")
   ENSURE(3     ==pt.dim2,"pt: wrong dim2")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      bf_lgval :: VEC{VEC_{INT}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      ra :: VEC{REAL}(3)
      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      overlapping_atom, lga,lgb, sp :: VEC{INT}*
      grida0,gridb0 :: MAT{REAL}*
      DD :: MAT3{REAL}*
      sha :: SHELL1
      Dab, fac,val, ga,gb :: REAL
      atom_o,cutoff,n_pt,n_keep, bs, p,n, q,n_dens :: INT
      atom_a,fsa,lsa,sa,fa,la,na,a :: INT
      atom_b,fsb,lsb,sb,fb,lb,nb,b :: INT

      ! No of densities
      n_dens = D.dim3

      ! Basis function cutoff 
      cutoff = floor(log10(.becke_grid.basis_function_cutoff))

      ! Saved basis function grid and skip list
      bf_lgval.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Atom "a" displaced points and skip switches
      n_pt = pt.dim1
      xa.create(n_pt)
      ya.create(n_pt)
      za.create(n_pt)
      a2.create(n_pt)
      sp.create(n_pt)

      ! Create N0
      N0 = ZERO

      ! Loop atom_a
      do atom_a = 1,.n_atom

         fsa = .first_shell_for_atom(atom_a)
         lsa =  .last_shell_for_atom(atom_a)
   
         ! Make shell atom displaced points
         .atom(atom_a).make_displaced_pts(xa,ya,za,a2,pt,n_pt) 
   
         ! Atom a position
         ra = .atom(atom_a).position

         ! Loop overlapping atom_b
         overlapping_atom => .overlapping_atoms_for_atom(atom_a).element
         do atom_o = 1,overlapping_atom.dim

            atom_b = overlapping_atom(atom_o)
            if (atom_b>atom_a) cycle

            fsb = .first_shell_for_atom(atom_b)
            lsb = min(.last_shell_for_atom(atom_b),lsa)

            ! Loop shells on atom a
            do sa = fsa,lsa
      
               fa = .first_basis_fn_for_shell(sa)
               la =  .last_basis_fn_for_shell(sa)
               na = la - fa + 1
      
               ! Set shell for index "sa"
               bs           = .basis_shell_for_shell(sa)
               sha          = .precomputed_basis_shellpair(bs,1).a
               sha.position = ra

               ! Make shell "sa" basis function grida0 and lga values
               grida0.create(n_pt,na)
               lga.create(n_pt)
               sha.make_grid(grida0,n_pt,na,xa,ya,za,a2,lga)
   
               ! Save the values
               bf_grid0(sa).element => grida0
               bf_lgval(sa).element => lga

             ! if (.debugging("make_rho_grid:sa")) then
             !    stdout.text("grid0:")
             !    stdout.put(grida0,auto_width=TRUE)
             !    stdout.text("lga:")
             !    stdout.put(lga,by_column=TRUE,auto_width=TRUE)
             ! end

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)
   
                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1
   
                  ! Get the "sb" basis function grid
                  gridb0 => bf_grid0(sb).element 
                  lgb    => bf_lgval(sb).element 
   
                  ! How many points in common?
                  n_keep = count((lga+lgb)>=cutoff)
                  if (n_keep==0) cycle
   
                  ! Make significant points
                  sp(1:n_keep) = pack([(n,n=1,n_pt)],mask=(lga+lgb)>=cutoff)

                ! if (.debugging("make_rho_grid:sb")) then
                !    stdout.show("n_keep =",n_keep)
                !    stdout.text("sp:")
                !    stdout.put(sp(1:n_keep),by_column=TRUE,auto_width=TRUE)
                ! end
   
                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE
   
                  ! Density block
                  DD => D(fa:la,fb:lb,:)
   
                  if (na*nb==1) then
   
                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     do q = 1,n_dens
                        Dab = fac*DD(1,1,q)
                        do p = 1,n_keep
                           n = sp(p)
                           ga = ga0(n)
                           gb = gb0(n)
                           val = ga*gb*Dab
                           N0(n,q) = N0(n,q) + val
                        end
                     end
   
                  else
   
                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           do q = 1,n_dens
                              Dab = fac*DD(a,b,q)
                              do p = 1,n_keep
                                 n = sp(p)
                                 ga = ga0(n)
                                 gb = gb0(n)
                                 val = ga*gb*Dab
                                 N0(n,q) = N0(n,q) + val
                              end
                           end
                        end
                     end
   
                     ! Clean up
   
                  end ! if ss or not ss
               end    ! -- loop sb
            end       ! -- loop sa
         end          ! -- atom_b
      end             ! -- atom_a

      ! Clean up
      sp.destroy
      a2.destroy
      za.destroy
      ya.destroy
      xa.destroy
      bf_grid0.destroy
      bf_lgval.destroy

      if (.debugging("make_rho_grid:n0")) then
         stdout.text("N0:")
         stdout.put(N0,auto_width=TRUE)
      end

   end

!   make_nabla_density_grid_r_A(grid1,grid0,pt,atoms,ex)
!   ! Evaluate the nabla density grid "grid1" and density grid "grid0" on a set
!   ! of grid points "pt", for use in matrix elements needed by DFT grid
!   ! integration. "atoms" lists the atoms whose grid points are to be used in
!   ! DFT matrix element integration.  Normally they will be the atom-pair
!   ! corresponding to the basis function pair in the matrix element. We don't
!   ! have to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it does not depend on having the natural orbitals
!   ! defined.
!      grid1 :: MAT{REAL}, OUT
!      grid0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      ex :: VEC{REAL}, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
!   ENSURE(grid1.dim1==pt.dim1,"grid1 has wrong 1st dimension")
!   ENSURE(grid1.dim2==3,"grid1 has wrong 2nd dimension")
!   ENSURE(grid0.dim==pt.dim1,"grid0 has wrong 1st dimension")
!   ENSURE(ex.dim==pt.dim1,"ex has wrong dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!      xa,ya,za,aa,xb,yb,zb,bb :: VEC{REAL}*
!      keep  :: VEC{BIN}*
!      sha,shb :: SHELL1
!      a0,a1,a2,a3,b0,bP :: MAT{REAL}*
!      atom_a,sa,fsa,lsa,fa,la,atom_b,sb,fsb,lsb,fb,lb, n_pt,na,nb,i,j :: INT
!      cutoff,val,ea,eb,fac :: REAL
!      cutoff = -log(.becke_grid.rho_cutoff)              ! Cutoff
!      keep.create(pt.dim1)
!      sha.nullify_ptr_part
!      shb.nullify_ptr_part
!      grid1 = ZERO
!      grid0 = ZERO
!      ! Loop over density basis functions "a" and "b". Keep only significant
!      ! points at each stage using a density cutoff not basis function cutoff.
!      do atom_a = 1,.n_atom                                 
!         if (NOT .is_overlapping_atom(atom_a,atoms)) cycle  
!         fsa = .first_shell_for_atom(atom_a)
!         lsa = .last_shell_for_atom(atom_a)
!         .atom(atom_a).make_displaced_points(xa,ya,za,aa,pt,create=TRUE)
!         do atom_b = 1,atom_a
!            if (NOT .is_overlapping_atom(atom_b,atoms)) cycle
!            if (NOT .is_overlapping_atom(atom_a,atom_b)) cycle     ! Only atom pairs which overlap
!            fsb = .first_shell_for_atom(atom_b)
!            lsb = .last_shell_for_atom(atom_b)
!            .atom(atom_b).make_displaced_points(xb,yb,zb,bb,pt,create=TRUE)
!            do sa = fsa,lsa
!               .get_shell(sha,sa,fa,la)
!               na = sha.n_comp
!               ea = minval(sha.ex)
!               do sb = fsb,min(sa,lsb)
!                  .get_shell(shb,sb,fb,lb)
!                  nb = shb.n_comp
!                  eb = minval(shb.ex)
!                  keep = ea*aa+eb*bb<=cutoff
!                  keep = TRUE
!                  n_pt = count(keep)                                   ! # of significant points
!    ! stdout.text("============")
!    ! stdout.show("atom_a=",atom_a)
!    ! stdout.show("atom_b=",atom_b)
!    ! stdout.show("sa=",sa)
!    ! stdout.show("sb=",sb)
!    ! stdout.show("cutoff=",cutoff)
!    ! stdout.show("n_pt0 =",n_pt)
!    ! stdout.text("============")
!                  if (n_pt>0) then
!                     fac = TWO
!                     if (sa==sb) fac = ONE
!                     a0.create(n_pt,na)
!                     a1.create(n_pt,na); a2.create(n_pt,na); a3.create(n_pt,na)
!                     sha.make_nabla_grid(a1,a2,a3,a0,xa,ya,za,aa,keep) 
!                     bP.create(n_pt,na)
!                     b0.create(n_pt,nb)
!                     shb.make_grid(b0,xb,yb,zb,bb,keep)
!                     bP = matmul(b0,.density_matrix.restricted(fb:lb,fa:la))
!                     b0.destroy
!                     do j = 1,na
!                     do i = 1,n_pt
!                        val = fac*bP(i,j)
!                        grid0(i)   = grid0(i)   + a0(i,j)*val
!                        grid1(i,1) = grid1(i,1) + a1(i,j)*val
!                        grid1(i,2) = grid1(i,2) + a2(i,j)*val
!                        grid1(i,3) = grid1(i,3) + a3(i,j)*val
!                     end
!                     end
!                     bP.destroy
!                     a0.destroy; a3.destroy; a2.destroy; a1.destroy
!                  end
!                  shb.destroy_ptr_part
!               end
!               sha.destroy_ptr_part
!            end
!            .atom(atom_b).tidy_displaced_points(xb,yb,zb,bb)
!         end
!         .atom(atom_a).tidy_displaced_points(xa,ya,za,aa)
!      end
!      keep.destroy
!      grid1 = TWO*grid1
!   end

!   make_nabla_density_grid_r_A(grid1,grid0,pt,atoms)
!   ! Evaluate the nabla density grid "grid1" as well as the density grid "grid0"
!   ! on a set of grid points "pt", for use in matrix elements needed by DFT grid
!   ! integration. "atoms" lists the atoms whose grid points are to be used in
!   ! DFT matrix element integration.  Normally they will be the atom-pair
!   ! corresponding to the basis function pair in the matrix element. We don't
!   ! have to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it does not depend on having the natural orbitals
!   ! defined.
!      grid1 :: MAT{REAL}, OUT
!      grid0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
!   ENSURE(grid1.dim1==pt.dim1,"grid1 has wrong 1st dimension")
!   ENSURE(grid1.dim2==3,"grid1 has wrong 2nd dimension")
!   ENSURE(grid0.dim==pt.dim1,"grid0 has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!      sha,shb :: SHELL1
!      a1 :: MAT3{REAL}*
!      a0,b0,bP :: MAT{REAL}*
!      n_pt,a,sa,fa,la,b,sb,fb,lb :: INT
!      fac :: REAL
!      grid1 = ZERO
!      grid0 = ZERO
!      n_pt = pt.dim1
!      do a = 1,.n_atom
!         if (NOT .is_overlapping_atom(a,atoms)) cycle
!         do sa = .first_shell_for_atom(a),.last_shell_for_atom(a)
!            .get_shell(sha,sa,fa,la)
!            a1.create(n_pt,sha.n_comp,3)
!            a0.create(n_pt,sha.n_comp)
!            sha.make_nabla_grid(a1,a0,pt)         ! Call this as little as possible
!            do b = 1,.n_atom
!               if (NOT .is_overlapping_atom(b,atoms)) cycle
!               do sb = .first_shell_for_atom(b),.last_shell_for_atom(b)
!                  .get_shell(shb,sb,fb,lb)
!                  bP.create(n_pt,sha.n_comp)
!                  b0.create(n_pt,shb.n_comp)
!                  shb.make_grid(b0,pt)            ! Call this as little as possible
!                  bP = matmul(b0,.density_matrix.restricted(fb:lb,fa:la))
!                  b0.destroy
!                  grid0      = grid0      + sum(a0*bP,dim=2)
!                  grid1(:,1) = grid1(:,1) + sum(a1(:,:,1)*bP,dim=2)
!                  grid1(:,2) = grid1(:,2) + sum(a1(:,:,2)*bP,dim=2)
!                  grid1(:,3) = grid1(:,3) + sum(a1(:,:,3)*bP,dim=2)
!                  bP.destroy
!                  shb.destroy_ptr_part
!               end
!            end
!            a0.destroy; a1.destroy
!            sha.destroy_ptr_part
!         end
!      end
!      grid1 = TWO*grid1
!   end

! ========================
! Orbital density routines
! ========================

   make_orbital_density_grid
   ! Work out the orbital on ".plot_grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      gc :: VEC{CPX}*
      orb :: INT
      relativity,okind :: STR

      ! Restricted or general complex?
      okind = .natural_orbitals.spinorbital_kind

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Orbital density here
      gr.create(.plot_grid.n_pt)

      ! Kind of relativity to use
      relativity = "none"
      if (.scfdata.created) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if   

      select case (relativity)

         case ("douglas-kroll-hess","dkh")

            select case (okind)
               case("restricted") 
                  .make_DKH_orbital_grid_r(gr,orb,pt,square=TRUE)
               case("general_complex") 
                  gc.create(.plot_grid.n_pt)
                  .make_DKH_orb_dens_grid_gc(gc,orb,pt)
                  gr = RE(gc)
                  gc.destroy
               case default
                  DIE("unimplemented")
            end

         case ("iotc")

            select case (okind)
               case("restricted") 
                  .make_IOTC_orbital_grid_r(gr,orb,pt,square=TRUE)
               case("general_complex") 
                  gc.create(.plot_grid.n_pt)
                  .make_IOTC_orb_dens_grid_gc(gc,orb,pt)
                  gr = RE(gc)
                  gc.destroy
               case default
                  DIE("unimplemented")
            end

         case ("none")

            select case (okind)
               case("restricted") 
                  .make_orbital_grid_r(gr,.natural_orbitals.restricted(:,orb),pt,square=TRUE)
               case("general_complex") 
                  gc.create(.plot_grid.n_pt)
                  .make_orbital_grid_gc(gc,.molecular_orbitals.general_complex(:,orb),pt)
                  gr = RE(gc)
                  gc.destroy
               case default
                  DIE("unimplemented")
            end

         case default

            DIE("Unimplemented")

      end

      .dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_density_grid")

      gr.destroy
      pt.destroy

   end

   make_orbital_grid
   ! Work out the orbital on ".plot_grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      arch :: ARCHIVE
      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      gcu,gcd :: VEC{CPX}*
      orb :: INT
      relativity,okind :: STR

      ! Restricted or general complex?
      okind = .natural_orbitals.spinorbital_kind

      ! Orbital to be plotted
      orb = .plot_grid.orbital

      ! Points to plot
      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      ! Kind of relativity to use
      relativity = "none"
      if (.scfdata.created) then
         relativity = .scfdata.relativity_kind
         if (NOT .scfdata.PCE_CORR) relativity = "none"
      end if   

      select case (relativity)

         case ("douglas-kroll-hess","dkh")

            select case (okind)
               case("restricted") 
                  WARN("NOTE: You will loose the phase of the ploted orbitals! :(")
                  WARN("to obtain the phase (signs) switch use_PCE_corr off!!")
                  gr.create(.plot_grid.n_pt)
                  .make_DKH_orbital_grid_r(gr,orb,pt,square=FALSE)
                  .dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy
               case default
                  DIE("unimplemented")
            end

         case ("iotc")

            select case (okind)
               case("restricted") 
                  WARN("NOTE: You will loose the phase of the ploted orbitals! :(")
                  WARN("to obtain the phase (signs) switch use_PCE_corr off!!")
                  gr.create(.plot_grid.n_pt)
                  .make_IOTC_orbital_grid_r(gr,orb,pt,square=FALSE)
                  .dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy
               case default
                  DIE("unimplemented")
            end

         case ("none")

            select case (okind)
               case("restricted") 
                  gr.create(.plot_grid.n_pt)
                  .make_orbital_grid_r(gr,.natural_orbitals.restricted(:,orb),pt)
                  .dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
                  gr.destroy
               case("general_complex") 
                  gcu.create(.plot_grid.n_pt)
                  gcd.create(.plot_grid.n_pt)
                  .make_orbital_grid_gc(gcu,gcd,.natural_orbitals.general_complex(:,orb),pt)
                  arch.set(.name,"orbital_"//trim(orb.to_str)//"_grid",format="ascii")
                  arch.write_orbital(gcu,gcd,.plot_grid.n_pt)
                  gcu.destroy
                  gcd.destroy
               case default
                  DIE("unimplemented")
            end

         case default

            DIE("Unimplemented")

      end

      pt.destroy

   end

   make_orbital_grid_r(g,orb,pt,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt"
      g :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,a,fa,la,na :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1

      g = ZERO

      do a = 1,.n_shell
         .get_shell(sh,a,fa,la,na)
         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)
         g = g + matmul(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end

      if (sq) g = g*g

   end

   make_orbital_grid_c(g,orb,pt,square)
   ! Evaluate the orbital density for *one* AO-basis orbital coefficient vector
   ! "orb" on a set of grid points "pt"
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sq :: BIN
      sh :: SHELL1*
      sh_grid :: MAT{REAL}*
      n_pt,a,fa,la,na :: INT

      sq = FALSE
      if (present(square)) sq = square

      n_pt = pt.dim1
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la,na)
         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)
         g = g + matmul(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy

      if (sq) g = conjg(g)*g

   end

   make_orbital_grid_gc(g,orb,pt)
   ! Evaluate the orbital density for *one* AO-basis orbital coefficient vector
   ! "orb" on a set of grid points "pt"
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sh :: SHELL1*
      sh_grid :: MAT{REAL}*
      gu,gd :: VEC{CPX}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      g = ZERO
      sh.create
      gu.create(n_pt)
      gd.create(n_pt)
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la,na)
         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)
         gu = gu + matmul(sh_grid,orb(fa:la)) ! aa or ba
         gd = gd + matmul(sh_grid,orb(fa+.n_prim:la+.n_prim)) !ab or bb
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy

      g = conjg(gu)*gu + conjg(gd)*gd 

      gu.destroy
      gd.destroy

   end

   make_orbital_grid_gc(gu,gd,orb,pt)
   ! Evaluate the orbital density for *one* AO-basis orbital coefficient vector
   ! "orb" on a set of grid points "pt"
      gu,gd :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      sh :: SHELL1*
      sh_grid :: MAT{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1

      gu = ZERO
      gd = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la,na)
         sh_grid.create(n_pt,na)
         sh.make_grid(sh_grid,pt)
         gu = gu + matmul(sh_grid,orb(fa:la)) ! aa or ba
         gd = gd + matmul(sh_grid,orb(fa+.n_prim:la+.n_prim)) !ab or bb
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy

   end

! ===========================
! Nabla density grid routines
! ===========================

!   make_nabla_density_grid_fdm_r(nabla_grid,pts)
!   ! Work out the nabla density on ".plot_grid" using ".natural orbitals" and the
!   ! ".occupation" number vector.
!   ! This method uses the finite difference method to calculate the gradient
!   ! from the density.  It is much slower, but useful for checking.
!     nabla_grid, pts :: MAT{REAL}
!   ENSURE(pts.dim2==3,  "wrong dimension for points array")
!   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
!     orb :: VEC{REAL}*
!     dens_1,dens_2,nabla_orb,comp :: VEC{REAL}*
!     pt1 :: MAT{REAL}*
!     alpha :: REAL
!     n_occ,n,n_pts,i :: INT
!     alpha = TOL(6)
!     n_pts = size(pts,1)
!     pt1.create(n_pts,3)
!     nabla_grid = ZERO
!     orb.create(n_pts)
!     dens_1.create(n_pts)
!     dens_2.create(n_pts)
!     nabla_orb.create(n_pts)
!     n_occ = .no_of_occupied_NOs
!     do n = 1,n_occ
!        do i = 1,3
!          comp => pt1(:,i)
!          pt1 = pts;    comp = comp + alpha
!          .make_orbital_grid_r(dens_1,.natural_orbitals.restricted(:,n),pt1,square=TRUE)
!          pt1 = pts;    comp = comp - alpha
!          .make_orbital_grid_r(dens_2,.natural_orbitals.restricted(:,n),pt1,square=TRUE)
!          nabla_orb = HALF/alpha * (dens_1 - dens_2)
!          .make_orbital_grid_r(orb,.natural_orbitals.restricted(:,n), pts)
!          nabla_grid(:,i) = nabla_grid(:,i) + .occupation_numbers.restricted(n)*orb(:)*nabla_orb
!        end
!     end
!     nabla_grid = TWO*nabla_grid
!     nabla_orb.destroy
!     dens_2.destroy
!     dens_1.destroy
!     orb.destroy
!     pt1.destroy
!   end

   make_nabla_density_grid(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid" on the set of point "pts".
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (trim(.natural_orbitals.number_kind)=="real") then
         .make_nabla_density_grid_r(nabla_grid,pts)
      else
         DIE("not implemented")
      end

   end

   make_nabla_density_grid(nabla_grid,grid,pts)
   ! Work nabla of the density, "nabla_grid", and the density, "grid, evaluated
   ! on the set of points "pts".
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN

      if (trim(.natural_orbitals.number_kind)=="real") then
         .make_nabla_density_grid_r(nabla_grid,grid,pts)
      else
         DIE("not implemented")
      end

   end

   make_nabla_density_grid_r(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid", on the grid "pts" using
   ! ".natural_orbitals" and the ".occupation" number vector.
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN
   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT
      n_pts = size(pts,1)
      nabla_grid = ZERO
      orb.create(n_pts)
      nabla_orb.create(n_pts,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
      end
      nabla_grid = TWO*nabla_grid
      orb.destroy
      nabla_orb.destroy
   end

   make_nabla_density_grid_r(nabla_grid,grid,pts)
   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
   ! using the grid "pts" and the ".natural_orbitals" and the ".occupation"
   ! number vector.
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN
   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
      orb :: VEC{REAL}*
      nabla_orb :: MAT{REAL}*
      occ :: REAL
      n_occ,n,n_pts :: INT
      n_pts = size(pts,1)
      nabla_grid = ZERO
      grid = ZERO
      orb.create(n_pts)
      nabla_orb.create(n_pts,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
       grid(:) = grid(:) + occ*orb(:)*orb(:)
      end
      nabla_grid = TWO*nabla_grid
      orb.destroy
      nabla_orb.destroy
   end

   make_nabla_orbital_grid_r(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{REAL}
      h :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")

      orb_a :: VEC{REAL}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1
      g = ZERO
      h = ZERO

      do a = 1,.n_shell
         .get_shell(sh,a,fa,la,na)
         sh_grid.create(n_pt,na,3)
         sh_grid0.create(n_pt,na)
         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         orb_a => orb(fa:la)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h = h + matmul(sh_grid0,orb_a)
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end

   end

   make_nabla_orbital_grid_c(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{CPX}
      h :: VEC{CPX}
      orb :: VEC{CPX}, IN, target
      pt :: MAT{REAL}, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")
      orb_a :: VEC{CPX}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la,na)
         sh_grid.create(n_pt,na,3)
         sh_grid0.create(n_pt,na)
         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         orb_a => orb(fa:la)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h = h + matmul(sh_grid0,orb_a)
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end

   end

! ===============================
! Laplacian density grid routines
! ===============================

   make_laplacian_orbital_grid_r(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{REAL}
      i :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid,sh_grid1 :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      orb_a :: VEC{REAL}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      i = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la,na)
         sh_grid.create(n_pt,na,3)
         sh_grid1.create(n_pt,na,3)
         sh_grid0.create(n_pt,na)
         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)
         orb_a => orb(fa:la)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h(:,1) = h(:,1) + matmul(sh_grid1(:,:,1),orb_a)
         h(:,2) = h(:,2) + matmul(sh_grid1(:,:,2),orb_a)
         h(:,3) = h(:,3) + matmul(sh_grid1(:,:,3),orb_a)
         i = i + matmul(sh_grid0,orb_a)
         sh_grid1.destroy
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end

   end

   make_laplacian_orbital_grid_c(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{CPX}
      i :: VEC{CPX}
      orb :: VEC{CPX}, IN, target
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")

      sh :: SHELL1
      sh_grid,sh_grid1 :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      orb_a :: VEC{CPX}*
      n_pt,fa,la,na,a :: INT

      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      i = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la,na)
         sh_grid.create(n_pt,na,3)
         sh_grid1.create(n_pt,na,3)
         sh_grid0.create(n_pt,na)
         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)
         orb_a => orb(fa:la)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h(:,1) = h(:,1) + matmul(sh_grid1(:,:,1),orb_a)
         h(:,2) = h(:,2) + matmul(sh_grid1(:,:,2),orb_a)
         h(:,3) = h(:,3) + matmul(sh_grid1(:,:,3),orb_a)
         i = i + matmul(sh_grid0,orb_a)
         sh_grid1.destroy
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end

   end


! ================
! Plotting methods
! ================

   plot ::: leaky
   ! Do one of the many kinds of plot calculations
   ENSURE(.plot_grid.created, "no grid")

      ! Make the becke grids & overlapping atoms
      .set_up_becke_grid_info

      ! Set interpolators for stockholder or promolecule plots
      .set_interpolator_info(.plot_grid.plot_kind)

      ! Set atom plot info for deformation densities
      .set_atom_plot_info(.plot_grid.plot_kind)

      ! Assign natural orbitals
      if (.natural_orbitals.destroyed) then
      if (.molecular_orbitals.created) then
         .assign_NOs_to_MOs
      end
      end

      ! Use unit cell as bbox if requested
      if (.plot_grid.use_unit_cell_as_bbox) then
         WARN("resetting plot axes, plot widths from unit cell")
         ENSURE(.crystal.created,"no crystal or unit cell for plot!")
         .plot_grid.set_bbox_from_unit_cell(.crystal.unit_cell)
      end

      ! See plot_grid parameters
      .plot_grid.put

      ! Do the plot
      .do_plot

   end

   do_plot ::: leaky
   ! Do one of the many kinds of plot calculations
   ENSURE(.plot_grid.created, "no grid")

      select case (.plot_grid.plot_kind)
         case("b_field                             "); .make_B_field_grid
         case("b_l_field                           "); .make_B_L_field_grid
         case("b_s_field                           "); .make_B_S_field_grid
         case("bond_weight                         "); .make_bond_weight_grid
         case("crystal_error_map                   "); .make_crystal_error_map
         case("current_density                     "); .make_j_grid
         case("deformation_bond_density            "); .make_def_bond_density_grid
         case("deformation_density                 "); .make_deformation_density_grid
         case("deformation_dft_eff_potential       "); .make_def_dft_eff_pot_grid
         case("deformation_dft_energy              "); .make_def_dft_energy_grid
         case("deformation_dft_xc_potential        "); .make_def_dft_xc_pot_grid
         case("deformation_electric_potential      "); .make_def_e_pot_grid
         case("deformation_g_kinetic_energy        "); .make_def_G_kinetic_grid
         case("deformation_g_kirzhnits             "); .make_def_G_Kirzhnits_grid
         case("deformation_h_dft_energy            "); .make_def_H_dft_energy_grid
         case("deformation_h_from_virial           "); .make_def_H_from_virial_grid
         case("deformation_h_kirzhnits             "); .make_def_H_Kirzhnits_grid
         case("deformation_k_kinetic_energy        "); .make_def_K_kinetic_grid
         case("deformation_laplacian               "); .make_def_laplacian_grid
         case("deformation_v_from_virial           "); .make_def_V_from_virial_grid
         case("deformation_v_kirzhnits             "); .make_def_V_Kirzhnits_grid
         case("deformation_reduced_g_kinetic_energy"); .make_def_rG_kinetic_grid
         case("deformation_reduced_h_from_virial   "); .make_def_rH_from_virial_grid
         case("deformation_reduced_k_kinetic_energy"); .make_def_rK_kinetic_grid
         case("deformation_reduced_v_from_virial   "); .make_def_rV_from_virial_grid
         case("dft_eff_potential                   "); .make_dft_eff_pot_grid
         case("dft_energy                          "); .make_dft_energy_grid
         case("dft_xc_potential                    "); .make_dft_xc_pot_grid
         case("div_jp                              "); .make_div_jp_grid
         case("electric_potential                  "); .make_electric_potential_grid
         case("electric_polarisation_density       "); .make_e_polarization_grid
         case("electric_polarization_density       "); .make_e_polarization_grid
         case("electron_density                    "); .make_electron_density_grid
         case("elf                                 "); .make_ELF_grid
         case("e_hf_density_from_rho               "); .make_E_hf_dens_from_rho_grid
         case("eli_d                               "); .make_ELI_D_grid
       ! case("energy_density_from_rho             "); .make_deformation_density_grid
         case("fermi_mobility                      "); .make_fermi_mobility_grid
         case("g_kinetic_energy                    "); .make_G_kinetic_energy_grid
         case("g_kirzhnits                         "); .make_G_Kirzhnits_grid
         case("grad_rho_on_rho                     "); .make_grad_rho_on_rho_grid
         case("h_dft_energy                        "); .make_H_dft_energy_grid
         case("h_kirzhnits                         "); .make_H_Kirzhnits_grid
         case("h_from_virial                       "); .make_H_from_virial_grid
         case("hirshfeld_atom_grid                 "); .make_Hirshfeld_atom_grid
         case("hirshfeld_density                   "); .make_Hirshfeld_density_grid
         case("hirshfeld_weight                    "); .make_Hirshfeld_density_grid
         case("j                                   "); .make_j_grid
         case("jd                                  "); .make_jd_grid
         case("jp                                  "); .make_jp_grid
         case("k_kinetic_energy                    "); .make_K_kinetic_energy_grid
         case("laplacian                           "); .make_laplacian_grid
         case("local_ionisation_energy             "); .make_local_ionisation_grid
         case("local_virial_ratio                  "); .make_local_virial_ratio_grid
         case("negative_laplacian                  "); .make_neg_laplacian_grid
       ! case("orbital_current_density             "); .make_orbital_j_grid
         case("orbital_density                     "); .make_orbital_density_grid
         case("orbital                             "); .make_orbital_grid
         case("oscillator_orbital                  "); .make_oscillator_orbital_grid
         case("promolecule_density                 "); .make_promolecule_density_grid
         case("reduced_g_kinetic_energy            "); .make_rG_kinetic_energy_grid
         case("reduced_h_from_virial               "); .make_rH_from_virial_grid
         case("reduced_k_kinetic_energy            "); .make_rK_kinetic_energy_grid
         case("reduced_v_from_virial               "); .make_rV_from_virial_grid
         case("solenoidal_jp                       "); .make_solenoidal_jp_grid
       ! case("spin_current_density                "); .make_spin_j_grid
         case("spin_density                        "); .make_spin_density_grid
         case("spherical_atom_density              "); .make_spherical_atom_grid
         case("stockholder_density                 "); .make_stockholder_density_grid
         case("stockholder_weight                  "); .make_Hirshfeld_density_grid
         case("true_fermi_mobility                 "); .make_true_fermi_mobility_grid
         case("tsirelson_elf                       "); .make_Tsirelson_ELF_grid
         case("v_kirzhnits                         "); .make_V_Kirzhnits_grid
         case("v_from_virial                       "); .make_V_from_virial_grid
         case default;                UNKNOWN(.plot_grid.plot_kind)
      end

   end

   bounding_cube_width result(width)
   ! Return "width", the width of a cube in which the molecule nicely sits.
   ! Suitable for generating plot widths.
      width :: REAL
      width = .atom.bounding_cube_width
   end

! ======================================
! Crystal structure factor residual maps
! ======================================

   make_crystal_error_map ::: leaky
   ! Work out the crystal_error map on ".plot_grid". A Gnuplot ascii file is
   ! generated.
   ENSURE(.plot_grid.created, "no grid")
      map :: VEC{REAL}*
      map.create(.plot_grid.n_pt)
      .make_crystal_error_map(map)
      .dump_plot_grid(map,"crystal_error_map")
      map.destroy
   end

   make_crystal_error_map(map)
   ! Make the crystal error "map".
      map :: VEC{REAL}
   ENSURE(.plot_grid.created, "no grid")
      pt :: MAT{REAL}*
      n_pt :: INT
      map = ZERO
      n_pt = .plot_grid.n_pt
      pt.create(n_pt,3); .plot_grid.make_points(pt)
      .crystal.make_residual_error_map(map,pt)
      pt.destroy
   end

! ===============================
! Boys/Angyan oscillator orbitals
! ===============================

   make_oscillator_orbital_grid
   ! Work out the oscillator orbital on ".plot_grid" using ".natural orbitals" for
   ! orbital "orb". 

   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
   ENSURE(.localiser.created, "no localiser orbject created")

      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      orb :: INT

      orb = .plot_grid.orbital
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)

      if (trim(.natural_orbitals.number_kind)=="real") then
         gr.create(.plot_grid.n_pt)
         .make_oscillator_orbital_grid_r(gr,orb,pt)
         .dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
         gr.destroy
      else
         DIE("complex case not yet implemented")
      end

      pt.destroy

   end

   make_oscillator_orbital_grid_r(g,ind,pt,square)
   ! Evaluate the oscillator orbital density grid "g" for the localised orbital
   ! with index "ind" on a set of grid points "pt". You must supply on the input
   ! line the angular momentum "l" and component "n" of the oscillator orbital,
   ! which is an awful hack for the moment.
      g :: VEC{REAL}, OUT
      ind :: INT
      pt :: MAT{REAL}, IN
      square :: BIN, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.localiser.created, "no localiser orbject created")
      os :: VEC{REAL}*
      c  :: VEC{REAL}(3)
      l,n :: INT
      sh :: SHELL1
      os.create(pt.dim1)
      c = .localiser.dipole(ind,ind,:)
      stdin.read(l)
      stdin.read(n)
      sh.make_oscillator_orbital_mask(os,c,l,n,pt)
      .make_orbital_grid_r(g,.localiser.MO(:,ind),pt,square)
      g = g*os
      os.destroy
   end

   make_p_oscillator_orb_grid_r(g,ind,pt,square)
   ! Evaluate the oscillator orbital density grid "g" for the projected
   ! localised orbital with index "ind" on a set of grid points "pt". You must
   ! supply on the input line the angular momentum "l" and component "n" of the
   ! oscillator orbital, which is an awful hack for the moment.
      g :: VEC{REAL}, OUT
      ind :: INT
      pt :: MAT{REAL}, IN
      square :: BIN, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.localiser.created, "no localiser orbject created")

      gg,os :: VEC{REAL}*
      c  :: VEC{REAL}(3)
      maxl,l,n,ln, i,j :: INT
      coeff :: REAL
      sh :: SHELL1

      gg.create(pt.dim1)
      os.create(pt.dim1)
      c = .localiser.dipole(ind,ind,:)
      stdin.read(maxl)
      stdin.read(l)
      stdin.read(n)
      ln = GAUSSIAN_DATA:n_comp_up_to(l-1)*.n_a + (ind-1)*GAUSSIAN_DATA:n_comp(l) + n
      .make_orbital_grid_r(gg,.localiser.MO(:,ind),pt,square)
      g = ZERO
      i = 0
      do l = 0,maxl
      do n = 1,GAUSSIAN_DATA:n_comp(l)
      do j = 1,.n_a
         i = i + 1
         coeff = .localiser.TM(i,ln)
         if (coeff.is_zero) cycle
         sh.make_oscillator_orbital_mask(os,c,l,n,pt)
         g = g + coeff*gg*os
      end
      end
      end
      os.destroy; gg.destroy

   end

! =========
! Templates
! =========

   density_grid ::: template
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
      grid :: VEC{REAL}*
      pt :: MAT{REAL}*

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the grid values
      MAKE_GRID(grid,pt)

      ! Print out
      .dump_plot_grid(grid,LABEL)

      ! Clean up
      pt.destroy
      grid.destroy

   end

   deformation_grid(grid,pt) ::: template
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.natural_orbitals.created,"no natural orbitals")
   ENSURE(.occupation_numbers.created,"no natural orbitals")

      promolecule_grid :: VEC{REAL}*

      ! Make the normal grid values
      MAKE_GRID(grid,pt)

      ! Make the reference grid values
      promolecule_grid.create(grid.dim)
      MAKE_PRO_GRID(promolecule_grid,pt)

      ! Subtract to form deformation grid
      grid = grid - promolecule_grid

      ! Clean up
      promolecule_grid.destroy

   end

   pro_grid(density_grid,pt) ::: template
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")

      grid :: VEC{REAL}*
      a :: INT

      ! Create space for an atom's grid values
      grid.create(density_grid.dim)

      ! Sum up the atom grid values
      density_grid = ZERO
      parallel do a = 1,.n_atom
        .atom(a).MAKE_GRID(grid,pt)
        density_grid = density_grid + grid
      end
      if (DO_IN_PARALLEL) then
        PARALLEL_SUM(density_grid)
      end

      ! Clean up
      grid.destroy

   end

   pro_dft_grid(density_grid,pt) ::: template
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")

      grid :: VEC{REAL}*
      a :: INT

      ! Create
      grid.create(density_grid.dim)

      ! Make the grid of values
      density_grid = ZERO
      do a = 1,.n_atom
        .atom(a).MAKE_GRID(grid,pt,.scfdata.dft_exchange_functional,.scfdata.dft_correlation_functional)
        density_grid = density_grid + grid
      end

      ! Clean
      grid.destroy

   end

   dump_plot_grid(grid,name)
   ! Dump out the plot "grid" to an appropriate with with "name", in various
   ! formats. If present, "factor" is a conversion factor to apply.

      grid :: VEC{REAL}
      name :: STR

   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.atom.created, "no atoms")

      math_pos :: MAT{REAL}*
      valid :: VEC{INT}*
      bonds :: VEC{VEC_{INT}}*
      arch :: ARCHIVE
      fac,z_range :: REAL

      if (.plot_grid.plot_units/=" ") then
         fac = .plot_grid.plot_units.conversion_factor
         grid = fac*grid
      end

      if (.plot_grid.use_plot_max) then
         where (grid>.plot_grid.plot_max) grid = .plot_grid.plot_max
      end

      if (.plot_grid.use_plot_min) then
         where (grid<.plot_grid.plot_min) grid = .plot_grid.plot_min
      end

      ! Dump all formats if none specified
      if (.plot_grid.plot_format=="all") then   

         arch.set(.name,name,format="contour")
         arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)
         arch.set(.name,name,format="drishti.raw")
         arch.write_drishti(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
         arch.set(.name,name,format="gnuplot")
         arch.write_gnuplot(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
         arch.set(.name,name,format="gaussian.cube")
         arch.write_gaussian_cube(grid,.plot_grid,.atom,name)
         arch.set(.name,name,format="mathematica")
         arch.write_mathematica(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
         arch.set(.name,name,format="vapor.raw")
         arch.write_vapor(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
         arch.set(.name,name,format="vtk")
         arch.write_vtk(grid,.plot_grid,name)
         arch.set(.name,name,format="xdgraph")
         arch.write_a_la_xdgraph(grid,.plot_grid,.atom)
         arch.set(.name,name,format="xcrysden.xsf")
         arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)

         if (.plot_grid.n_z==1) then
            arch.set(.name,name,format="mathematica")
            nullify(math_pos)
            nullify(valid)
            nullify(bonds)
            z_range = ONE
            .plot_grid.get_rotoranged_atom_positions(math_pos,z_range,valid)
            .atom(valid).make_connection_table(bonds)
            arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),math_pos,bonds)
            bonds.destroy
            math_pos.destroy
            valid.destroy
         end

      ! Dump specified format
      else

         select case (.plot_grid.plot_format)

            case ("contour")

               arch.set(.name,name,format="contour")
               arch.write_contour_a_la_nancy(grid,.plot_grid,.atom)

            case ("cube")

               arch.set(.name,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

            case ("drishti")

               arch.set(.name,name,format="drishti.raw")
               arch.write_drishti(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            case ("gnuplot")

               arch.set(.name,name,format="gnuplot")
               arch.write_gnuplot(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            case ("gaussian")

               arch.set(.name,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

            case ("gaussian.cube")

               arch.set(.name,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.plot_grid,.atom,name)

            case ("mathematica")

               arch.set(.name,name,format="mathematica")
               arch.write_mathematica(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

               if (.plot_grid.n_z==1) then
                  arch.set(.name,name,format="mathematica")
                  nullify(math_pos)
                  nullify(valid)
                  nullify(bonds)
                  z_range = ONE
                  .plot_grid.get_rotoranged_atom_positions(math_pos,z_range,valid)
                  .atom(valid).make_connection_table(bonds)
                  arch.write_mathematica(grid,.plot_grid,.plot_grid.atom(valid),math_pos,bonds)
                  bonds.destroy
                  math_pos.destroy
                  valid.destroy
               end

            case ("vapor")

               arch.set(.name,name,format="vapor.raw")
               arch.write_vapor(grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)

            case ("vtk")

               arch.set(.name,name,format="vtk")
               arch.write_vtk(grid,.plot_grid,name)

            case ("xcrysden")

               arch.set(.name,name,format="xcrysden.xsf")
               arch.write_xcrysden_xsf(grid,.plot_grid,.atom,name)
            
            case ("xdgraph")

               arch.set(.name,name,format="xdgraph")
               arch.write_a_la_xdgraph(grid,.plot_grid,.atom)

            case default

               UNKNOWN(.plot_grid.plot_format)

         end

      end

   end

   delete_plot_grid(name)
   ! Delete the plot grid called "name".

      name :: STR
      arch :: ARCHIVE

      arch.set(.name,name,format="gnuplot");        arch.delete_all_genres
      arch.set(.name,name,format="mathematica");    arch.delete_all_genres
      arch.set(.name,name,format="contour");        arch.delete_all_genres
      arch.set(.name,name,format="gaussian.cube");  arch.delete_all_genres
      arch.set(.name,name,format="xdgraph");        arch.delete_all_genres

   end

   delete_plot_grid
   ! Delete the plot grid whose name is specified on the input line

   DIE_IF(stdin.buffer.n_items/=2,"must specify grid to delete in input")
   DIE_IF(stdin.buffer.item_index==2,"must be on the last item")

      name :: STR
      arch :: ARCHIVE

      stdin.read(name)

      arch.set(.name,name,format="gnuplot");        arch.delete_all_genres
      arch.set(.name,name,format="mathematica");    arch.delete_all_genres
      arch.set(.name,name,format="contour");        arch.delete_all_genres
      arch.set(.name,name,format="gaussian.cube");  arch.delete_all_genres
      arch.set(.name,name,format="xdgraph");        arch.delete_all_genres

   end

! ======================
! Electron density grids
! ======================

   make_electron_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_density_grid, LABEL=>"electron_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_deformation_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_deformation_density_grid, LABEL=>"deformation_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_deformation_density_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_density_grid, MAKE_PRO_GRID=>.make_promolecule_density_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_spin_density_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
      pt :: MAT{REAL}*
      grid :: VEC{REAL}*
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
      .make_density_grid(grid,pt,sgn=-1)
      .dump_plot_grid(grid,"spin_density_grid")
      pt.destroy
      grid.destroy
   end

! ==================
! Bond density grids
! ==================

   make_def_bond_density_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.bond_density_atom.created, "no grid bond density atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .make_def_bond_density_grid(grid,pt,.plot_grid.bond_density_atom)

      ! Make the plot label
      label = "deformation_bond_("
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str) // ","
      label = trim(label) // trim(.plot_grid.bond_density_atom(2).to_str) 
      if (.plot_grid.bond_density_atom.dim==3) &
      label = trim(label) // ":" // trim(.plot_grid.bond_density_atom(3).to_str) 
      label = trim(label) // ")_density_grid" 

      ! Print out
      .dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_def_bond_density_grid(density_grid,pt,bond_density_atom)
   ! Make the bond deformation "density_grid" for the points "pt". 
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*

   ENSURE(.atom.created,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! Make the deformation density
      .make_deformation_density_grid(density_grid,pt)

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z))
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = density_grid(n)*exp(-(x*x+y*y+z*z))/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

   make_def_bond_density_grid(density_grid,pt,bond_density_atom,def_density_grid)
   ! Make the bond deformation "density_grid" for the points "pt". 
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*
      def_density_grid :: VEC{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z,r_inv :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        r_inv = ONE/r_ab.norm
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z)*r_inv)
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           r_inv = ONE/r_ab.norm
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = def_density_grid(n)*exp(-(x*x+y*y+z*z)*r_inv)/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

!   make_def_bond_density_grid(density_grid,pt,bond_density_atom,def_density_grid)
!   ! Make the bond deformation "density_grid" for the points "pt". 
!   ! If there are two atoms in .plot_grid.bond_atom then the whole
!   ! bond density is made; if there are three then the third atom
!     self :: IN
!     density_grid :: VEC{REAL}, OUT
!     pt :: MAT{REAL}, IN
!     bond_density_atom :: VEC{INT}*
!     def_density_grid :: VEC{REAL}, IN
!
!   ENSURE(.atom.created,"no atoms")
!
!     n_atoms,n_pt,a,b,c,n :: INT
!     x,y,z :: REAL
!     r_ab :: VEC{REAL}(3)
!     rho_pr,rho_a,rho_b :: VEC{REAL}*
!
!     ! No of bond density atoms
!     n_atoms = bond_density_atom.dim
!
!     ! No of grid points
!     n_pt = density_grid.dim
!
!     ! Create space for pair density
!     rho_pr.create(n_pt)
!
!     ! Get the atom pair density for whole molecule
!     rho_pr = ZERO
!     do a = 2,.n_atom
!     do b = 1,a-1
!        if (NOT .atom.bonded(a,b)) cycle
!        r_ab = HALF*(.atom(a).position + .atom(b).position)
!        do n = 1,n_pt
!           x  = pt(n,1) - r_ab(1)
!           y  = pt(n,2) - r_ab(2)
!           z  = pt(n,3) - r_ab(3)
!           rho_pr(n) = rho_pr(n) + exp(-(x*x + y*y + z*z))
!        end
!     end
!     end
!
!     ! Indices of bonded pair
!     a = bond_density_atom(1)
!     b = bond_density_atom(2)
!
!     ! Make the deformation bond pair density
!     r_ab = HALF*(.atom(a).position + .atom(b).position)
!     do n = 1,n_pt
!        if (rho_pr(n)>epsilon(ONE)) then
!           x  = pt(n,1) - r_ab(1)
!           y  = pt(n,2) - r_ab(2)
!           z  = pt(n,3) - r_ab(3)
!           density_grid(n) = def_density_grid(n)*exp(-(x*x+y*y+z*z))/rho_pr(n)
!        else
!           density_grid(n) = ZERO
!        end
!     end
!
!     ! Make the atom contribution === if required
!     if (n_atoms==3) then
!
!        rho_a.create(n_pt)
!        rho_b.create(n_pt)
!
!        .atom(a).make_density_grid(rho_a,pt)
!        .atom(b).make_density_grid(rho_b,pt)
!
!        rho_pr = rho_a + rho_b
!
!        c = bond_density_atom(3)
!        if (c==a) then
!           where (rho_pr>epsilon(ONE)); density_grid = (rho_a/rho_pr)*density_grid
!           elsewhere;                   density_grid = ZERO
!           end
!        else if (c==b) then
!           where (rho_pr>epsilon(ONE)); density_grid = (rho_b/rho_pr)*density_grid
!           elsewhere;                   density_grid = ZERO
!           end
!        else
!           DIE("atom is not one of those in the bond")
!        end
!        
!        rho_b.destroy
!        rho_a.destroy
!
!     end
!
!     ! Clean up
!     rho_pr.destroy
!
!   end

   make_bond_weight_grid
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.bond_density_atom.created, "no grid bond density atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .make_bond_weight_grid(grid,pt,.plot_grid.bond_density_atom)

      ! Make the plot label
      label = "bond_("
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str) // ","
      label = trim(label) // trim(.plot_grid.bond_density_atom(2).to_str) 
      if (.plot_grid.bond_density_atom.dim==3) &
      label = trim(label) // ":" // trim(.plot_grid.bond_density_atom(3).to_str) 
      label = trim(label) // ")_weight_grid" 

      ! Print out
      .dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_bond_weight_grid(density_grid,pt,bond_density_atom)
   ! Make the bond deformation "density_grid" for the points "pt". 
   ! If there are two atoms then the whole bond density is made; if
   ! there are three atoms then the third atom specifies which of the
   ! Hirshfeld-split bond density is produced.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      bond_density_atom :: VEC{INT}*

   ENSURE(.atom.created,"no atoms")
   ENSURE(.n_atom>1,"must have at least two atoms")

      n_atoms,n_pt,a,b,c,n :: INT
      x,y,z :: REAL
      r_ab :: VEC{REAL}(3)
      rho,rho_a,rho_b :: VEC{REAL}*

      ! No of bond density atoms
      n_atoms = bond_density_atom.dim

      ! No of grid points
      n_pt = density_grid.dim

      ! Create space for pair density
      rho.create(n_pt)
      rho = ZERO

      ! Get the atom pair density for whole molecule
      r_ab = ZERO
      do a = 2,.n_atom
      do b = 1,a-1
        if (NOT .atom.bonded(a,b)) cycle
        r_ab = HALF*(.atom(a).position + .atom(b).position)
        do n = 1,n_pt
           x  = pt(n,1) - r_ab(1)
           y  = pt(n,2) - r_ab(2)
           z  = pt(n,3) - r_ab(3)
           rho(n) = rho(n) + exp(-(x*x + y*y + z*z))
        end
      end
      end

      ! Make the density grid

      select case (n_atoms)

        case (2:3) ! Two or three atoms in the list

           ! Indices of bonded pair
           a = bond_density_atom(1)
           b = bond_density_atom(2)

           ! Make the deformation bond pair density
           r_ab = HALF*(.atom(a).position + .atom(b).position)
           do n = 1,n_pt
              if (rho(n)>epsilon(ONE)) then
                 x  = pt(n,1) - r_ab(1)
                 y  = pt(n,2) - r_ab(2)
                 z  = pt(n,3) - r_ab(3)
                 density_grid(n) = exp(-(x*x+y*y+z*z))/rho(n)
              else
                 density_grid(n) = ZERO
              end
           end

           ! Make the (third) atom contribution === if required
           if (n_atoms==3) then

              rho_a.create(n_pt)
              rho_b.create(n_pt)

              .atom(a).make_density_grid(rho_a,pt)
              .atom(b).make_density_grid(rho_b,pt)

              rho = rho_a + rho_b

              c = bond_density_atom(3)
              if (c==a) then
                 where (rho>epsilon(ONE)); density_grid = (rho_a/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else if (c==b) then
                 where (rho>epsilon(ONE)); density_grid = (rho_b/rho)*density_grid
                 elsewhere;                density_grid = ZERO
                 end
              else
                 DIE("atom is not one of those in the bond")
              end

              rho_b.destroy
              rho_a.destroy

           end

        case default

           DIE("must specify two or three bond density atoms")

      end

      ! Clean up
      rho.destroy

   end

   make_bond_density_atom_grid
   ! Work out the bond density atom on ".plot_grid"
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.bond_density_atom.created, "no grid bond density atoms")

      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the density
      .make_bond_density_atom_grid(grid,pt,.plot_grid.bond_density_atom(1))

      ! Make the plot label
      label = "bond_density_atom_"
      label = trim(label) // trim(.plot_grid.bond_density_atom(1).to_str)
      label = trim(label) // "_grid" 

      ! Print out
      .dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_bond_density_atom_grid(density_grid,pt,a)
   ! Make the bond density atom grid "density_grid" for the points
   ! "pt" for atom with index "a". 
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      a :: INT

   ENSURE(.atom.created,"no atoms")

      n_pt,i :: INT
      rho_bond,def_density_grid :: VEC{REAL}*
      bond_density_atom :: VEC{INT}*

      ! No of grid points
      n_pt = density_grid.dim

      ! Do only the spherical part if a<0
      if (a<0) then 

        .atom(-a).make_density_grid(density_grid,pt)

      ! Do the whole BDA 
      else

        ! Allocate
        def_density_grid.create(n_pt)
        rho_bond.create(n_pt)

        ! Space for bond density atoms
        bond_density_atom.create(3)
        bond_density_atom(1) = a
        bond_density_atom(3) = a

        ! Make the deformation density
        .make_deformation_density_grid(def_density_grid,pt)

        ! Add spherical part
        .atom(a).make_density_grid(density_grid,pt)

        ! Get bond density contributions
        do i = 1,.n_atom
           if (i==a) cycle
           if (NOT .atom.bonded(i,a)) cycle
           bond_density_atom(2) = i
           .make_def_bond_density_grid(rho_bond,pt,bond_density_atom,def_density_grid)
           density_grid = density_grid + rho_bond
        end

        ! Clean up
        bond_density_atom.destroy
        rho_bond.destroy
        def_density_grid.destroy

      end

   end

! ============================
! Local ionisation energy grid
! ============================

   make_local_ionisation_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_local_ionisation_grid, LABEL=>"local_ionisation_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_local_ionisation_grid(grid,pt)
   ! Work out Politzer's local ionisation energy "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")

      if (trim(.molecular_orbitals.number_kind)=="real") then
        .make_local_ionisation_grid_r(grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_local_ionisation_grid_r(grid,pt)
   ! Work out Politzer's local ionisation energy "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.molecular_orbitals.created("restricted"), "no restricted MO's")
   ENSURE(.orbital_energies.created("restricted"), "no restricted orbital energies")

      rho,MO :: VEC{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      n_occ = .no_of_occupied_NOs

      rho.create(n_pt)
      MO.create(n_pt)

      rho  = ZERO
      grid = ZERO
      parallel do n = 1,n_occ
        .make_orbital_grid_r(MO,.molecular_orbitals.restricted(:,n),pt,square=TRUE)
        rho  = rho  + MO
        grid = grid - MO*.orbital_energies.restricted(n)
      end
      MO.destroy

      PARALLEL_SUM(rho)
      PARALLEL_SUM(grid)

      grid = grid/rho

      rho.destroy

   end

! =======================
! Local virial ratio grid
! =======================

   make_local_virial_ratio_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_local_virial_ratio_grid, LABEL=>"local_virial_ratio_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_local_virial_ratio_grid(grid,pt)
   ! Work out local virial ratio "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")

      if (trim(.molecular_orbitals.number_kind)=="real") then
        .make_local_virial_ratio_grid_r(grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_local_virial_ratio_grid_r(grid,pt)
   ! Work out local virial ratio  "grid" using points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")

      L, G :: VEC{REAL}*
      n_pt :: INT

      n_pt = pt.dim1

      L.create(n_pt)
      G.create(n_pt)

      .make_laplacian_grid_r(L,pt)
      .make_G_kinetic_density_grid_r(G,pt)

      grid = TWO - QUARTER*L/G  

      G.destroy
      L.destroy

   end

! ==========================
! Laplacian density routines
! ==========================

   make_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_laplacian_grid, LABEL=>"laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)=="real") then
        .make_laplacian_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_laplacian_grid_r(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      n_pt = pt.dim1
      n_occ = .no_of_occupied_NOs

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      laplacian_grid = ZERO

      parallel do n = 1,n_occ

         .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)

         occ = .occupation_numbers.restricted(n)
         laplacian_grid = laplacian_grid &
            + occ * (NO*(D(:,1)+D(:,2)+D(:,3)) &
                  + P(:,1)*P(:,1)+P(:,2)*P(:,2)+P(:,3)*P(:,3))

      end
      PARALLEL_SUM(laplacian_grid)

      laplacian_grid = TWO*laplacian_grid

      D.destroy
      P.destroy
      NO.destroy

   end

   make_def_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_laplacian_grid, LABEL=>"deformation_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_laplacian_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_laplacian_grid, MAKE_PRO_GRID=>.make_pro_laplacian_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_laplacian_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_laplacian_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_neg_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_neg_laplacian_grid, LABEL=>"negative_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_neg_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)=="real") then
        .make_laplacian_grid_r(laplacian_grid,pt)
        laplacian_grid = -laplacian_grid
      else
        DIE("code not written yet")
      end

   end


   make_rL_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rL_grid, LABEL=>"reduced_laplacian_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rL_grid(laplacian_grid,pt)
   ! Work out the reduced "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
        .make_rL_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end

   end

   make_rL_grid_r(laplacian_grid,pt)
   ! Make the reduced "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      rho,NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL
      n_pt = pt.dim1
      laplacian_grid = ZERO
      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       laplacian_grid = laplacian_grid +  occ * ( &
          NO * (D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3)))
       rho = rho + occ*NO*NO
      end
      laplacian_grid = TWO*laplacian_grid/rho
      D.destroy
      P.destroy
      NO.destroy
      rho.destroy
   end

! ===============================
! K-type kinetic density routines
! ===============================

   make_K_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_K_kinetic_energy_grid, LABEL=>"K_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_K_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type kinetic energy density (using the nabla^2) on "pt" using
   ! ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_K_kinetic_density_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_K_kinetic_density_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      n_pt = pt.dim1
      K_grid = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       K_grid(:) = K_grid(:) &
                 + .occupation_numbers.restricted(n) * NO * (D(:,1)+D(:,2)+D(:,3)) 
      end
      K_grid(:) = -HALF*K_grid(:)
      D.destroy
      P.destroy
      NO.destroy
   end

   make_def_K_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_K_kinetic_grid, LABEL=>"deformation_K_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_K_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_K_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_K_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_K_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_K_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rK_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rK_kinetic_energy_grid, LABEL=>"reduced_K_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rK_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type reduced kinetic energy density (using the nabla^2) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_rK_kinetic_density_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rK_kinetic_density_grid_r(K_grid,pt)
   ! Make the K-type reduced kinetic energy density "K_grid" for the supplied
   ! points "pt" from restricted real natural orbitals
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      NO,rho :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL
      n_pt = pt.dim1
      K_grid = ZERO
      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       K_grid = K_grid + occ*NO*(D(:,1)+D(:,2)+D(:,3)) 
       rho = rho + occ*NO*NO
      end
      K_grid = -HALF*K_grid/rho
      D.destroy
      P.destroy
      NO.destroy
      rho.destroy
   end

   make_def_rK_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rK_kinetic_grid, LABEL=>"deformation_reduced_K_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rK_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rK_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_rK_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_rK_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rK_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! ===============================
! G-type kinetic density routines
! ===============================

   make_G_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_G_kinetic_energy_grid, LABEL=>"G_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_G_kinetic_energy_grid(G_grid,pt)
   ! Work out the G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_G_kinetic_density_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_G_kinetic_density_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      NO.create(n_pt)
      P.create(n_pt,3)

      G_grid = ZERO
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
        .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
        G_grid(:) = G_grid(:) &
                  + .occupation_numbers.restricted(n) &
                  * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
      end

      G_grid(:) = HALF*G_grid(:)

      P.destroy
      NO.destroy

   end


   make_G_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_G_Kirzhnits_grid, LABEL=>"G_Kirzhnits_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_G_Kirzhnits_grid(G_grid,pt)
   ! Work out the G-type Kirzhnits kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_G_Kirzhnits_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_G_Kirzhnits_grid_r(G_grid,pt)
   ! Make the G-type Kirzhnits kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO,rho,nab_ro2,lap_rho :: VEC{REAL}*
      G,L,nab_rho :: MAT{REAL}*
      lambda,k2,fac,occ,occ2 :: REAL
      n_occ,n,n_pt :: INT

      n_pt = pt.dim1
      rho.create(n_pt);       rho = ZERO
      lap_rho.create(n_pt);   lap_rho = ZERO 
      nab_ro2.create(n_pt)
      nab_rho.create(n_pt,3); nab_rho = ZERO 
      NO.create(n_pt)
      G.create(n_pt,3)
      L.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_laplacian_orbital_grid_r(L,G,NO,.natural_orbitals.restricted(:,n), pt)
         occ  = .occupation_numbers.restricted(n)
         occ2 = TWO*occ
         rho  = rho + occ *NO*NO
         nab_rho(:,1) = nab_rho(:,1) + occ2*NO*G(:,1)
         nab_rho(:,2) = nab_rho(:,2) + occ2*NO*G(:,2)
         nab_rho(:,3) = nab_rho(:,3) + occ2*NO*G(:,3)
         lap_rho = lap_rho + occ2*(NO*(L(:,1)+L(:,2)+L(:,3)) + (G(:,1)*G(:,1) + G(:,2)*G(:,2) + G(:,3)*G(:,3)))
      end

      L.destroy; G.destroy; NO.destroy

      nab_ro2 = nab_rho(:,1)*nab_rho(:,1) + nab_rho(:,2)*nab_rho(:,2) + nab_rho(:,3)*nab_rho(:,3)
      nab_rho.destroy

      lambda = ONE/72.0d0
      k2 = HALF/SIX
      fac = 0.3d0*(THREE*PI*PI)**(TWOTHIRDS)
      G_grid = fac*rho**(FIVE/THREE) + lambda*nab_ro2/rho + k2*lap_rho

      nab_ro2.destroy; lap_rho.destroy; rho.destroy

   end


   make_def_G_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_G_kinetic_grid, LABEL=>"deformation_G_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_G_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_G_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_G_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_G_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_G_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_def_G_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_G_Kirzhnits_grid, LABEL=>"deformation_G_Kirzhnits_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_G_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_G_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_G_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_G_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_G_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rG_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rG_kinetic_energy_grid, LABEL=>"reduced_G_kinetic_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rG_kinetic_energy_grid(G_grid,pt)
   ! Work out the reduced G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_rG_kinetic_density_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rG_kinetic_density_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
      rho,NO :: VEC{REAL}*
      P :: MAT{REAL}*
      n_occ,n,n_pt :: INT
      occ :: REAL
      n_pt = pt.dim1
      G_grid = ZERO
      rho.create(n_pt); rho = ZERO
      NO.create(n_pt)
      P.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
       rho = rho + occ*NO*NO
      end
      G_grid = HALF*G_grid/rho
      P.destroy
      NO.destroy
      rho.destroy
   end

   make_def_rG_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rG_kinetic_grid, LABEL=>"deformation_reduced_G_kinetic_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rG_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rG_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_rG_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_rG_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rG_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! ===============================
! G and K-type kinetic densities
! ===============================

   make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
   ! Work out the G and K-type kinetic energy density on "pt" using
   ! ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid,K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_G_and_K_kinetic_grids_r(G_grid,K_grid,pt)
   ! Make the G and K-type kinetic energy grids for the supplied points
   ! "pt" from restricted real natural orbitals
      G_grid,K_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")

      NO :: VEC{REAL}*
      P,D :: MAT{REAL}*
      n_occ,n,n_pt :: INT

      G_grid = ZERO
      K_grid = ZERO

      n_occ = .no_of_occupied_NOs
      n_pt = pt.dim1

      NO.create(n_pt)
      P.create(n_pt,3)
      D.create(n_pt,3)

      do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       G_grid = G_grid &
              + .occupation_numbers.restricted(n) &
              * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
       K_grid = K_grid &
              + .occupation_numbers.restricted(n) &
              * NO * (D(:,1)+D(:,2)+D(:,3)) 
      end
      G_grid =  HALF*G_grid
      K_grid = -HALF*K_grid
      D.destroy
      P.destroy
      NO.destroy
   end

! =============================
! Energy density from rho grids
! =============================

   make_E_hf_dens_from_rho_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_E_hf_dens_from_rho_grid, LABEL=>"E_hf_density_from_rho_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_E_hf_dens_from_rho_grid(E_grid,pt)
   ! Work out the energy density as the scaled electron density.
      E_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scfdata") 
   ENSURE(.scfdata.scf_kind.is_one_of(["rhf","uhf"]),"scf kind is not Hartree-Fock") 
      fac :: REAL
      .make_density_grid(E_grid,pt)
      fac = .scfdata.energy/.n_e
      E_grid = fac*E_grid
   end

   make_def_E_hf_from_rho_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_E_hf_dens_from_rho_grid, MAKE_PRO_GRID=>.make_E_hf_dens_from_rho_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

! ========================================================
! H-type total energy density obtained from virial theorem
! ========================================================

   make_H_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_from_virial_grid, LABEL=>"H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_from_virial_grid(H_grid,pt)
   ! Work out the energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(.plot_grid.n_pt)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_def_H_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_from_virial_grid, LABEL=>"deformation_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_from_virial_grid, MAKE_PRO_GRID=>.make_pro_H_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_H_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_H_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_H_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_Kirzhnits_grid, LABEL=>"H_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_Kirzhnits_grid(H_grid,pt)
   ! Work out the energy density using the Kirzhnits relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(.plot_grid.n_pt)
      .make_G_Kirzhnits_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_def_H_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_Kirzhnits_grid, LABEL=>"deformation_H_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_H_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_H_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_H_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rH_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rH_from_virial_grid, LABEL=>"reduced_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rH_from_virial_grid(H_grid,pt)
   ! Work out the reduced energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(.plot_grid.n_pt)
      .make_rG_kinetic_energy_grid(G_grid,pt)
      .make_rL_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_def_rH_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rH_from_virial_grid, LABEL=>"deformation_reduced_H_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rH_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rH_from_virial_grid, MAKE_PRO_GRID=>.make_pro_rH_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_rH_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rH_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! =====================================================
! Potential energy density obtained from virial theorem
! =====================================================

   make_V_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_V_from_virial_grid, LABEL=>"V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_V_from_virial_grid(V,pt)
   ! Work out the energy density from usiang the virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(.plot_grid.n_pt)
      .make_G_kinetic_energy_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

   make_def_V_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_V_from_virial_grid, LABEL=>"deformation_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_V_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_V_from_virial_grid, MAKE_PRO_GRID=>.make_pro_V_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_V_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_V_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_V_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_V_Kirzhnits_grid, LABEL=>"V_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_V_Kirzhnits_grid(V,pt)
   ! Work out the energy density from usiang the Kirzhnits theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(.plot_grid.n_pt)
      .make_G_Kirzhnits_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

   make_def_V_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_V_Kirzhnits_grid, LABEL=>"deformation_V_Kirzhnits_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_V_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_V_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_V_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_V_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_V_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rV_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rV_from_virial_grid, LABEL=>"reduced_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rV_from_virial_grid(V,pt)
   ! Work out the energy density from usiang the virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(.plot_grid.n_pt)
      .make_rG_kinetic_energy_grid(G,pt)
      .make_rL_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

   make_def_rV_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rV_from_virial_grid, LABEL=>"deformation_reduced_V_from_virial_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rV_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rV_from_virial_grid, MAKE_PRO_GRID=>.make_pro_rV_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_rV_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rV_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! ==================
! Electric potential
! ==================

   make_electric_potential_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_electric_potential_grid, LABEL=>"electric_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

!   make_electric_potential_grid
!   ! Make the electric potential "pot_grid" on ".plot_grid"
!   ENSURE(.plot_grid.created,  "no grid")
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.any_created, "no density matrix")
!     pot_grid :: VEC{REAL}*
!     pt :: MAT{REAL}*
!     pot_grid.create(.plot_grid.n_pt)
!     pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
!     .make_electric_potential_grid(pot_grid,pt)
!     pt.destroy
!     .dump_plot_grid(pot_grid,"electric_potential_grid")
!     pot_grid.destroy
!   end

   make_electric_potential_grid(pot_grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      .make_ao_density_matrix
      if (trim(.density_matrix.number_kind)=="real") then
         .make_electric_potential_grid_r(pot_grid,pt,.density_matrix.restricted)
      else
         .make_electric_potential_grid_c(pot_grid,pt,.density_matrix.restricted_complex)
      end

   end

   make_electric_potential_grid_r(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}
      elec_grid :: VEC{REAL}*
      .nuclear_potential(pot_grid,pt)
      elec_grid.create(size(pot_grid))
      .make_electronic_pot_grid_r(elec_grid,pt,dens)
      pot_grid = pot_grid + elec_grid
      elec_grid.destroy
   end

   make_electric_potential_grid_c(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{CPX}
      elec_grid :: VEC{REAL}*
      .nuclear_potential(pot_grid,pt)
      elec_grid.create(size(pot_grid))
      .make_electronic_pot_grid_c(elec_grid,pt,dens)
      pot_grid = pot_grid + elec_grid
      elec_grid.destroy
   end

   make_electronic_pot_grid(pot_grid,pt)
   ! Make the electronic potential "pot_grid" on a series of points "pt"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      .make_ao_density_matrix
      if (trim(.density_matrix.number_kind)=="real") then
         .make_electronic_pot_grid_r(pot_grid,pt,.density_matrix.restricted)
      else
         .make_electronic_pot_grid_c(pot_grid,pt,.density_matrix.restricted_complex)
      end

   end

   make_electronic_pot_grid_r(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}, target
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      Vab,Dba :: MAT{REAL}*
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      pot_grid = ZERO

      parallel do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Dba => dens(fa:la,fb:lb)
         Vab.create(na,nb)
         if (fa/=fb) then
           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*Dba)
           end
         else
           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             pot_grid(k) = pot_grid(k) - sum(Vab*Dba)
           end
         end
         Vab.destroy

         if (DO_IN_PARALLEL) then
            PARALLEL_SUM(pot_grid)
         end

         sh.destroy_ptr_part

      end

   end

   make_electronic_pot_grid_c(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Vab :: MAT{REAL}*
      Dba :: MAT{CPX}*
      n_pt,q,fa,fb,la,lb,na,nb,k :: INT
      sh :: SHELL2

      n_pt = pt.dim1

      pot_grid = ZERO

      do q = 1,.n_shell_pairs

         .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

         Dba => dens(fa:la,fb:lb)
         Vab.create(na,nb)
         if (fa/=fb) then
           do k = 1,n_pt
             sh.make_nuclear_attraction_ints(Vab,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*RE(Dba))
           end
         else
           do k = 1,n_pt
             sh.make_nuclear_attraction_ints(Vab,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*RE(Dba))
           end
         end
         Vab.destroy

         sh.destroy_ptr_part

      end

   end

   make_def_e_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_e_pot_grid, LABEL=>"deformation_electric_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_e_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_electric_potential_grid, MAKE_PRO_GRID=>.make_pro_e_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_e_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_electric_potential_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! ================
! DFT xc potential
! ================

   make_dft_xc_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_xc_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_xc_pot_grid(V,pt)
   ! Work out the DFT potential on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      V :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      V = ZERO
      dft.set_defaults
      dft.new_r_potential(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_potential(.scfdata.dft_correlation_functional,V,rho)
      rho.destroy
   end

   make_def_dft_xc_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_xc_pot_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_xc_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_xc_pot_grid, MAKE_PRO_GRID=>.make_pro_dft_xc_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_dft_xc_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_xc_pot_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

! =======================
! DFT effective potential
! =======================

! The effective potential includes the classical electrostatic potential

   make_dft_eff_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_eff_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_eff_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_eff_pot_grid(V,pt)
   ! Work out the Slater DFT potential "V" (i.e. the Slater potential plus the
   ! classical electric potential) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
   ENSURE(NOT .scfdata.using_GGA_functional,"so far, must not be a GGA functional")
      rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL
      .make_electric_potential_grid(V,pt)
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.set_defaults
      dft.new_r_potential(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_potential(.scfdata.dft_correlation_functional,V,rho)
      rho.destroy
   end

   make_def_dft_eff_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_eff_pot_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_eff_potential_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_eff_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_eff_pot_grid, MAKE_PRO_GRID=>.make_pro_dft_eff_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_dft_eff_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_eff_pot_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

! ==================
! DFT energy density
! ==================

! The energy density includes the classical electrostatic potential, but no
! kinetic energy density terms

   make_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_energy_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_energy_grid(V,pt)
   ! Work out the Slater DFT energy "V" (i.e. the Slater potential times the
   ! density plus the classical electric energy) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
      Ve,rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL
      .nuclear_potential(V,pt)
      Ve.create(V.dim)
      .make_electronic_pot_grid(Ve,pt)
      V = -V - HALF*Ve
      Ve.destroy
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.set_defaults
      dft.new_r_energy_density(.scfdata.dft_exchange_functional,V,rho)
      dft.new_r_energy_density(.scfdata.dft_correlation_functional,V,rho)
      V = V*rho
      rho.destroy
   end

   make_def_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_energy_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_energy_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_energy_grid, MAKE_PRO_GRID=>.make_pro_dft_energy_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_dft_energy_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_energy_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

! =========================
! H-type DFT energy density
! =========================

! H = G + V(DFT)

   make_H_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_dft_energy_grid, LABEL=>"H_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_dft_energy_grid(H_grid,pt)
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"must be a DFT calculation")
      G_grid :: VEC{REAL}*
      G_grid.create(.plot_grid.n_pt)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_dft_energy_grid(H_grid,pt)
      H_grid = H_grid + G_grid
      G_grid.destroy
   end

   make_def_H_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_dft_energy_grid, LABEL=>"deformation_H_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_dft_energy_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_dft_energy_grid, MAKE_PRO_GRID=>.make_pro_H_dft_energy_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
      grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   end

   make_pro_H_dft_energy_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_H_dft_energy_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

! =======================
! Hirshfeld (slater) grid
! =======================

   make_Hirshfeld_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_Hirshfeld_density_grid, LABEL=>"stockholder_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_Hirshfeld_density_grid(density_grid,pt)
   ! WARNING: this version calls directly the interpolated slaterbasis routine.
   ! Make the Hirshfeld stockholder "density_grid" for the supplied
   ! points "pt". The promolecule electron density used to define the
   ! Hirshfeld surface is calculated using a tabulated slater basis
   ! set. 
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

!  ENSURE(.saved.created, "no saved molecule")
!  ENSURE(.saved.cluster.created, "no saved cluster data")
!  ENSURE(.saved.cluster.info_made, "no saved cluster info")
!  ENSURE(.saved.cluster.radius>ZERO, "saved cluster radius is zero")
!  ENSURE(.saved.cluster.n_atoms==.atom.dim,"inconsistent saved cluster and atom list")
!  ENSURE(.atom.created,"no atoms")
!  ENSURE(.atom.has_all_density_data,"no atomic orbitals")

      rho_fragment :: VEC{REAL}*
      is_fragment_atom :: VEC{BIN}*
      n_atoms,n_pt,a :: INT

      n_pt = density_grid.dim
      rho_fragment.create(n_pt)
      rho_fragment = ZERO

      n_atoms = .atom.dim
      is_fragment_atom => .saved.cluster.is_fragment_atom

      if (NOT .atom.has_disorder) then

        do a = 1,n_atoms
           if (NOT is_fragment_atom(a)) cycle
           .atom(a).slaterbasis.add_density_grid(rho_fragment,pt,.atom(a).position)
        end
        density_grid = rho_fragment

        do a = 1,n_atoms
           if (is_fragment_atom(a)) cycle
           .atom(a).slaterbasis.add_density_grid(density_grid,pt,.atom(a).position)
        end

      else

        do a = 1,n_atoms
           if (NOT is_fragment_atom(a)) cycle
           .atom(a).slaterbasis.add_density_grid(rho_fragment,pt,.atom(a).position,.atom(a).site_occupancy)
        end
        density_grid = rho_fragment

        do a = 1,n_atoms
           if (is_fragment_atom(a)) cycle
           .atom(a).slaterbasis.add_density_grid(density_grid,pt,.atom(a).position,.atom(a).site_occupancy)
        end

      end

      where (density_grid>ZERO)
        density_grid = rho_fragment/density_grid
      elsewhere
        density_grid = ZERO
      end

      rho_fragment.destroy

   end

! ===========
! Stockholder
! ===========

   make_stockholder_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_stockholder_density_grid, LABEL=>"stockholder_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_stockholder_density_grid(density_grid,pt)
   ! Make the Hirschfeld stockholder "density_grid" for the supplied points
   ! "pt". The promolecule electron density used to define the Hirshfeld surface
   ! is calculated as follows: if a slater basis set is available, then that is
   ! used to calculate the promolecule electron density; if a coppens basis set
   ! is available, then that is used to get the promolecule density; otherwise,
   ! if restricted real natural orbitals are available for all atoms (in terms
   ! of gaussian basis functions), then those are used to calculate the
   ! promolecule densisties. In principle, we can caculate Hirshfeld surfaces
   ! for *molecular* fragment densities, rather than promolecule densities as
   ! done here. That would require a different keyword and different code.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.saved.created, "no saved molecule")
   ENSURE(.saved.cluster.created, "no saved cluster data")
   ENSURE(.saved.cluster.info_made, "no saved cluster info")
   ENSURE(.saved.cluster.radius>ZERO, "saved cluster radius is zero")
   ENSURE(.saved.cluster.n_atoms==.atom.dim,"inconsistent saved cluster and atom list")
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")

      rho_fragment :: VEC{REAL}*
      is_fragment_atom :: VEC{BIN}*
      n_atoms,n_pt,a :: INT

      ! No. of fragment atoms
      n_atoms = .atom.dim

      ! Locate fragment atoms in cluster
      is_fragment_atom => .saved.cluster.is_fragment_atom

      ! Fragment density grid
      n_pt = density_grid.dim
      rho_fragment.create(n_pt)
      rho_fragment = ZERO

      ! Make fragment density
      do a = 1,n_atoms
        if (NOT is_fragment_atom(a)) cycle
        .atom(a).add_density_grid(rho_fragment,pt)
      end

      density_grid = rho_fragment
      do a = 1,n_atoms
        if (is_fragment_atom(a)) cycle
        .atom(a).add_density_grid(density_grid,pt)
      end

      ! density_grid = rho_fragment/density_grid
      do a = 1,size(density_grid)
       if (density_grid(a)>epsilon(ONE)) then
         density_grid(a) = rho_fragment(a)/density_grid(a)
       else
         density_grid(a) = ZERO
       end
      end

      ! Clean up
      rho_fragment.destroy

   end

!   make_stockholder_weight_d_grid(w0,w1,w2,pt)
!   ! Make the Hirschfeld stockholder derivative density grid "d1_grid"
!   ! for the supplied points "pt". The promolecule electron density
!   ! used to define the Hirshfeld surface is calculated as follows: if
!   ! a slater basis set is available, then that is used to calculate
!   ! the promolecule electron density; if a coppens basis set is
!   ! available, then that is used to get the promolecule density;
!   ! otherwise, if restricted real natural orbitals are available for
!   ! all atoms (in terms of gaussian basis functions), then those are
!   ! used to calculate the promolecule densisties. In principle, we
!   ! can caculate Hirshfeld surfaces for *molecular* fragment
!   ! densities, rather than promolecule densities as done here. That
!   ! would require a different keyword and different code.
!     self :: IN
!     w0 :: VEC{REAL}, OUT
!     w1 :: MAT{REAL}, OUT
!     w2 :: MAT3{REAL}, OUT
!     pt :: MAT{REAL}, IN
!   ENSURE(w1.dim1==3, "wrong size w1")
!   ENSURE(w2.dim1==3, "wrong size w2")
!   ENSURE(w2.dim2==3, "wrong size w2")
!   ENSURE(w0.dim1==w1.dim2, "incompatible w0 and w1")
!   ENSURE(w0.dim1==w2.dim3, "incompatible w0 and w2")
!   ENSURE(.cluster.created, "no cluster data")
!   ENSURE(.cluster.info_made, "no cluster info")
!   ENSURE(.cluster.radius>ZERO, "cluster radius is zero")
!   ENSURE(.atom.created,"no atoms")
!   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
!     d0,rho0f,rho0a :: VEC{REAL}*
!     d1,rho1f,rho1a :: MAT{REAL}*
!     d2,rho2f,rho2a :: MAT3{REAL}*
!     f1,a1 :: VEC{REAL}(3)
!     f0,bot,bot2,bot3,fac :: REAL
!     n_pt,a,b,i :: INT
!   ! w  = (sum_IN rho_IN) /(sum_ALL rho_ALL)
!   ! w' = (sum_IN rho'_IN)/(sum_ALL rho_ALL)
!   !    - (sum_IN rho_IN)(sum_ALL rho'_ALL)/(sum_ALL rho_ALL)^2
!   ! w^ab = (sum_IN rho^ab_IN)/(sum_ALL rho_ALL)
!   !      - (sum_IN rho^a_IN)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho^b_IN)(sum_ALL rho^a_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho_IN)(sum_ALL rho^ab_ALL)/(sum_ALL rho_ALL)^2
!   !    + 2 (sum_IN rho_IN)(sum_ALL rho^a_ALL)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^3
!     n_pt = w0.dim1
!     d0.create(n_pt);     rho0f.create(n_pt);     rho0a.create(n_pt)
!     d1.create(3,n_pt);   rho1f.create(3,n_pt);   rho1a.create(3,n_pt)
!     d2.create(3,3,n_pt); rho2f.create(3,3,n_pt); rho2a.create(3,3,n_pt)
!     rho0f = ZERO; rho0a = ZERO
!     rho1f = ZERO; rho1a = ZERO
!     rho2f = ZERO; rho2a = ZERO
!     do a = 1,.cluster.n_atoms
!        if (NOT .cluster.is_fragment_atom(a)) cycle
!        .atom(a).make_d_density_grid(d0,d1,d2,pt) ! this incorporates a skip step
!        rho0f = rho0f + d0
!        rho1f = rho1f + d1
!        rho2f = rho2f + d2
!     end
!     rho0a = rho0f
!     rho1a = rho1f
!     rho2a = rho2f
!     do a = 1,.cluster.n_atoms
!        if (.cluster.is_fragment_atom(a)) cycle
!        .atom(a).make_d_density_grid(d0,d1,d2,pt) ! this incorporates a skip step
!        rho0a = rho0a + d0
!        rho1a = rho1a + d1
!        rho2a = rho2a + d2
!     end
!   ! w  = (sum_IN rho_IN) /(sum_ALL rho_ALL)
!   ! w' = (sum_IN rho'_IN)/(sum_ALL rho_ALL)
!   !    - (sum_IN rho_IN)(sum_ALL rho'_ALL)/(sum_ALL rho_ALL)^2
!   ! w^ab = (sum_IN rho^ab_IN)/(sum_ALL rho_ALL)
!   !      - (sum_IN rho^a_IN)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho^b_IN)(sum_ALL rho^a_ALL)/(sum_ALL rho_ALL)^2
!   !      - (sum_IN rho_IN)(sum_ALL rho^ab_ALL)/(sum_ALL rho_ALL)^2
!   !    + 2 (sum_IN rho_IN)(sum_ALL rho^a_ALL)(sum_ALL rho^b_ALL)/(sum_ALL rho_ALL)^3
!     do i = 1,rho0a.dim
!       if (rho0a(a)>epsilon(ONE)) then
!         bot = ONE/rho0a(i)
!         bot2 = bot*bot
!         bot3 = TWO*bot2*bot
!         f0   = rho0f(i)
!         w0(i) = f0*bot
!         f1 = rho1f(:,i)
!         a1 = rho1a(:,i)
!         fac = f0*bot2
!         w1(:,i) = f1*bot - a1*fac
!         do a = 1,3
!         do b = 1,a
!            w2(a,b,i) = rho2f(a,b,i)*bot &
!                      - (f1(a)*a1(b)+f1(b)*a1(a))*bot2 &
!                      - f0*rho2a(a,b,i)*bot2 &
!                      + f0*a1(a)*a1(b)*bot3 
!            if (a==b) cycle
!            w2(b,a,i) = w2(a,b,i)
!         end
!         end
!       else
!         w0(i) = ZERO
!         w1(:,i) = ZERO
!         w2(:,:,i) = ZERO
!       end
!     end
!     rho2a.destroy; rho2f.destroy; d2.destroy
!     rho1a.destroy; rho1f.destroy; d1.destroy
!     rho0a.destroy; rho0f.destroy; d0.destroy
!   end

! ===================
! Hirshfeld atom grid
! ===================

   make_Hirshfeld_atom_grid
   ! Work out the Hirshfeld atom density density on ".plot_grid" 
   ENSURE(.plot_grid.created, "no grid")
   ENSURE(.plot_grid.centre_atom>0, "no centre_atom to plot")
   ENSURE(.density_matrix.created("restricted"), "no restricted density matrix")

      grid :: VEC{REAL}*
      pt,D :: MAT{REAL}*
      label :: STR

      ! Make space for grid values and grid points
      grid.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the hirshfeld atom density
      D => .density_matrix.restricted
      .make_Hirshfeld_atom_grid(grid,pt,.plot_grid.centre_atom,D)

      ! Make the plot label
      label = "hirshfeld_atom_"
      label = trim(label) // trim(.plot_grid.centre_atom.to_str) 
      label = trim(label) // "_density_grid" 

      ! Print out
      .dump_plot_grid(grid,trim(label))

      ! Clean up
      pt.destroy
      grid.destroy

   end

   make_Hirshfeld_atom_grid(N0,pt,c,D)
   ! Make the hirshfeld atom density grid "N0" for the grid "pt" for
   ! atom "c" given AO density matrix "D". Density "N0" weighted by
   ! Hirshfeld partition weight for atom "c". 
      N0 :: VEC{REAL}
      pt :: MAT{REAL}
      c  :: INT, IN
      D  :: MAT{REAL}, target, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.overlapping_atoms_for_atom.created,"no overlapping_atoms_for_atom")

      xa,ya,za,a2, ga0,gb0 :: VEC{REAL}*
      ra :: VEC{REAL}(3)
      overlapping_atom, pi,pj,pn :: VEC{INT}*
      skipa0,skipab, skipa,skipb :: VEC{BIN}*
      grida0,gridb0, DD :: MAT{REAL}*
      sha :: SHELL1
      bf_skip :: VEC{VEC_{BIN}}*
      bf_grid0 :: VEC{MAT_{REAL}}*
      cutoff, Dab, fac,val, ga,gb :: REAL
      n_pt,n_keep, ca,cb, oa,fsa,lsa, ob,fsb,lsb :: INT
      sa,fa,la,na,ba, sb,fb,lb,nb, a,b,i,j,p,n :: INT

      ! Overlapping atoms
      overlapping_atom => .overlapping_atoms_for_atom(c).element

      ! Grid size
      n_pt = pt.dim1

      ! Initialise N0
      N0 = ZERO

      ! Basis function cutoff
      cutoff = BECKE_GRID_BASIS_FUNCTION_CUTOFF

      ! Atom "a" displaced points (from "c") and skip switches
      xa.create(n_pt); ya.create(n_pt); za.create(n_pt); a2.create(n_pt)
      skipa0.create(n_pt); skipab.create(n_pt)

      ! Basis function grid and skip list
      bf_skip.create(.n_shell)
      bf_grid0.create(.n_shell)

      ! Loop c-overlapping atoms "oa"
      do ca = 1,overlapping_atom.dim

         oa  = overlapping_atom(ca)
         fsa = .first_shell_for_atom(oa)
         lsa =  .last_shell_for_atom(oa)
         ra  = .atom(oa).position

         ! Make the displaced points for atom "oa" 
         .atom(oa).make_displaced_skip_pts(xa,ya,za,a2,skipa0,pt,n_pt,cutoff) 

         ! Loop shells on atom a
         do sa = fsa,lsa

            fa = .first_basis_fn_for_shell(sa)
            la =  .last_basis_fn_for_shell(sa)
            na = la - fa + 1
            ba = .basis_shell_for_shell(sa)

            ! Set shell "sa"
            sha = .precomputed_basis_shellpair(ba,1).a
            sha.position = ra

            ! Make shell "sa" skipa list
            skipa.create(n_pt)
            sha.make_skip_list(skipa,n_keep,a2,skipa0,n_pt,cutoff) 

            ! Next shell "sa" if no sig. points
            if (n_keep==0) then
               skipa.destroy
               cycle
            end

            ! Assign the "sa" skipa list
            bf_skip(sa).element => skipa

            ! Make/copy the "sa" basis function grida0
            ! This must be copied since skipa could be TRUE
            grida0.create(n_keep,na)
            sha.make_skip_grid(grida0,n_keep,na,xa,ya,za,a2,skipa,n_pt)
            bf_grid0(sa).element => grida0

            ! Loop c-overlapping atoms b
            do cb = 1,ca

               ob  = overlapping_atom(cb)
               fsb = .first_shell_for_atom(ob) 
               lsb =  .last_shell_for_atom(ob)

               ! Loop shells on atom b
               do sb = fsb,min(lsb,sa)

                  if (bf_skip(sb).element.destroyed) cycle

                  fb = .first_basis_fn_for_shell(sb)
                  lb = .last_basis_fn_for_shell(sb)
                  nb = lb - fb + 1

                  ! Set the "sb" basis function grid
                  skipb  => bf_skip(sb).element 
                  gridb0 => bf_grid0(sb).element 

                  ! How many points in common?
                  skipab(1:n_pt) = skipa OR skipb
                  n_keep = count(NOT skipab(1:n_pt))
                  if (n_keep==0) cycle

                  ! Factor
                  fac = TWO
                  if (sa==sb) fac = ONE

                  ! Density block
                  DD => D(fa:la,fb:lb)

                  if (na*nb==1) then

                     ga0 => grida0(:,1)
                     gb0 => gridb0(:,1)
                     Dab = fac*DD(1,1)
                     i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        ga = ga0(i)
                        gb = gb0(j)
                        val = ga*gb*Dab
                        N0(n) = N0(n) + val
                     end

                  else

                     ! Create space for gathered index info
                     pi.create(n_keep); pj.create(n_keep); pn.create(n_keep)

                     ! Make mapper arrays
                     p = 0; i = 0; j = 0
                     do n = 1,n_pt
                        if (NOT skipa(n)) i = i + 1
                        if (NOT skipb(n)) j = j + 1
                        if (skipab(n)) cycle
                        p = p + 1
                        pi(p) = i
                        pj(p) = j
                        pn(p) = n
                     end

                     ! Add density contribution to rho
                     do a = 1,na
                        ga0 => grida0(:,a)
                        do b = 1,nb
                           gb0 => gridb0(:,b)
                           Dab = fac*DD(a,b)
                           do p = 1,n_keep
                              i = pi(p)
                              j = pj(p)
                              n = pn(p)
                              ga = ga0(i)
                              gb = gb0(j)
                              val = ga*gb*Dab
                              N0(n) = N0(n) + val
                           end
                        end
                     end

                     ! Clean up
                     pn.destroy; pj.destroy; pi.destroy

                  end

               end ! -- loops sa,sb
            end
         end       ! -- lops ca,cb
      end

      ! Apply stockholder weight function for atom "c" to "N0".
      ! If using interpolatators, then overlapping_atoms 
      ! are not needed ... otherwise nothing is skipped
      .apply_stockholder_atom_weight(N0,c,pt)

      ! Clean up
      bf_grid0.destroy; bf_skip.destroy
      skipab.destroy; skipa0.destroy
      a2.destroy; za.destroy; ya.destroy; xa.destroy

   end

! =====================
! Stockholder atom grid
! =====================

   apply_stockholder_atom_weight(grid,a,pt)
   ! Apply i.e. multiply the "grid" by the stockholder weight function
   ! for the atom with index "a" using supplied points "pt". 
   ! * If .use_interpolators is TRUE then interpolators are used.
   ! * If .use_interpolators is FALSE then interpolators could still
   !   be used if explicitly set for each atom (however the
   !   overlapping_atoms array will not be used to eliminate work).
   !   More likely the density will be explicitly evaluated.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      Wa :: VEC{REAL}*
      overlapping_atom :: VEC{INT}*
      n_pt :: INT

      ! Only needed for more than one atom
      if (.n_atom>1) then

         ! Get weights
         n_pt = pt.dim1
         Wa.create(n_pt)
         if (.use_interpolators) then
            DIE_IF(.overlapping_atoms_for_atom.destroyed,"no overlapping_atoms_for_atom!")
            overlapping_atom => .overlapping_atoms_for_atom(a).element
            .make_stockholder_atom_grid_int(Wa,a,pt,overlapping_atom)
         else
            .make_stockholder_atom_grid_acc(Wa,a,pt)
         end

         ! Apply them
         grid = grid*Wa

         ! Clean
         Wa.destroy

      end

   end

   make_stockholder_atom_grid(grid,a,pt,overlapping_atom)
   ! Make the Hirshfeld stockholder density "grid" for the atom with
   ! index "a" using supplied points "pt". 
   ! * If .use_interpolators is TRUE and "overlapping_atoms" is
   !   supplised then interpolators are used.
   ! * If .use_interpolators is FALSE then interpolators could still
   !   be used if explicitly set for each atom. More likely the
   !   density will be explicitly evaluated.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
      overlapping_atom :: VEC{INT}, IN, optional

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      if (.n_atom>1) then
         
         if (.use_interpolators) then
            ENSURE(present(overlapping_atom),"no overlapping_atom")
            .make_stockholder_atom_grid_int(grid,a,pt,overlapping_atom)
         else
            .make_stockholder_atom_grid_acc(grid,a,pt)
         end

      else

         grid = ONE

      end

   end

   make_stockholder_atom_grid_acc(grid,a,pt) ::: private
   ! Make the Hirshfeld stockholder desity "grid" for the atom with
   ! index "a" using supplied points "pt". 
   ! NOTE: This DOES NOT USE an interpolated density for each atom
   ! UNLESS use_interpolators is explicitly set. In this case you
   ! should probably use the next routine which uses the
   ! overlapping_atoms.
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")
      rho_a :: VEC{REAL}*
      n_pt,i :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_density_grid(rho_a,pt)

      ! Make total density in "grid"
      grid = rho_a
      do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_density_grid(grid,pt)
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
         else;                           grid(i) = ZERO
         end
      end
      rho_a.destroy

   end

   make_stockholder_atom_grid_int(grid,a,pt,overlapping_atom) ::: private
   ! Make the Hirshfeld stockholder desity "grid" for the atom with
   ! index "a" using supplied points "pt" and given a list of
   ! "overlapping_atom". This makes use of a previously calculated
   ! interpolated density for each atom.
   ! NOTE: the CLUSTER_ATOM_DENSITY_CUTOFF must be the same as the
   ! BECKE_GRID_BASIS_FUNCTION_CUTOFF
      self :: IN
      grid :: VEC{REAL}, OUT
      a  :: INT, IN
      pt :: MAT{REAL}, IN
      overlapping_atom :: VEC{INT}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")

      rho_a :: VEC{REAL}*
      n_pt,i,j :: INT

      ! Allocate temporary densities
      n_pt = grid.dim
      rho_a.create(n_pt)

      ! Make density for atom "a"
      .atom(a).make_interpolated_density(rho_a,pt)

      ! Make total density in "grid"
      grid = rho_a
      do j = 1,overlapping_atom.dim
         i = overlapping_atom(j)
         if (i==a) cycle
         .atom(i).add_interpolated_density(grid,pt)
      end

      ! Make the stockholder weight
      do i = 1,n_pt
         if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
         else;                           grid(i) = ZERO
         end
      end
      rho_a.destroy

   end

! ================
! Promolecule grid 
! ================

   make_promolecule_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_promolecule_density_grid, LABEL=>"promolecule_density_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_promolecule_density_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_density_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_spherical_atom_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_spherical_atom_grid, LABEL=>"spherical_atom_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_spherical_atom_grid(density_grid,pt)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(.atom.created,"no atoms")
   ENSURE(.plot_grid.created,"no plot_grid")
   ENSURE(.plot_grid.centre_atom>0,"no plot_grid center atom")
      .atom(.plot_grid.centre_atom).make_density_grid(density_grid,pt)
   end

! =======================
! Grad rho on rho density
! =======================

   make_grad_rho_on_rho_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_grad_rho_on_rho_grid, LABEL=>"grad_rho_on_rho_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_grad_rho_on_rho_grid(grid,pt)
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim1==grid.dim,"array dimensions do not match")
      rho :: VEC{REAL}*
      grad_rho :: MAT{REAL}*
      n_pt,i :: INT
      grid = ZERO
      n_pt = pt.dim1
      rho.create(n_pt)
      .make_density_grid(rho,pt)
      grid=ZERO
      grad_rho.create(n_pt,3)
      .make_nabla_density_grid(grad_rho,pt)
      do i=1,n_pt
        if (rho(i)>ZERO) then
          grid(i)=sqrt(dot_product(grad_rho(i,:),grad_rho(i,:)))/rho(i)
        else
          grid(i)=ZERO
        end
      end
      grad_rho.destroy
      rho.destroy
   end

! =============
! ELI-D density
! =============

   make_ELI_D_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_ELI_D_grid, LABEL=>"ELI_D_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ELI_D_grid(ELI_grid,pt)
   ! Work out the Electron Localisation Indicator (D) (ELI) density "ELI_grid" 
   ! on a set of grid points "pt", using ".natural orbitals" and the ".occupation" 
   ! number vector.
     ELI_grid :: VEC{REAL}
     pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

     if (trim(.natural_orbitals.number_kind)=="real") then
        .make_ELI_D_grid_r(ELI_grid,pt)
     else
        DIE("no complex implementation")
     end

   end

   make_ELI_D_grid_r(ELI_grid,pt)
   ! Work out the Electron Localisation Indicator (D) grid (ELI_D) density 
   ! on a set of grid points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
   ! Reference: Wagner et al (2007), Chem Eur. J. 13, p. 5724
   ! (Look at appendix for definition of g!)
      ELI_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "natural orbitals must be restricted")

      DD :: MAT{REAL}*
      g,gx,gy,gz,rho_s,rhox,rhoy,rhoz,tau,NO :: VEC{REAL}*
      i,n_pt :: INT

      ! No of grid points
      n_pt = pt.dim1

      ! Make the density of alpha electrons
      rho_s.create(n_pt);  rho_s  = ZERO
      .make_density_grid(rho_s,pt)
      rho_s = HALF*rho_s

      ! Temporaries
      g.create(n_pt);     g     = ZERO
      tau.create(n_pt);   tau   = ZERO
      rhox.create(n_pt);  rhox  = ZERO
      rhoy.create(n_pt);  rhoy  = ZERO
      rhoz.create(n_pt);  rhoz  = ZERO

      NO.create(n_pt)
      DD.create(n_pt,3)

      ! Sum the orbital gradient and density gradient bit
      do i = 1,.no_of_occupied_NOs

         .make_nabla_orbital_grid_r(DD,NO,.natural_orbitals.restricted(:,i), pt)

         ! Orbital gradients
         gx => DD(:,1)
         gy => DD(:,2)
         gz => DD(:,3)

         ! Fermi hole curvature
         g = g + rho_s * (gx*gx + gy*gy + gz*gz) 

         ! This is only the orbital gradient part
         rhox = rhox + gx*NO
         rhoy = rhoy + gy*NO
         rhoz = rhoz + gz*NO

      end

      DD.destroy
      NO.destroy

      g = g - rhox*rhox - rhoy*rhoy - rhoz*rhoz

      ELI_grid = rho_s * (12.0d0/g)**(THREE/EIGHT)

      ! Clean up
      rhoz.destroy
      rhoy.destroy
      rhox.destroy
      tau.destroy
      g.destroy
      rho_s.destroy

   end

! ===========
! ELF density
! ===========

   make_ELF_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_ELF_grid, LABEL=>"ELF_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_ELF_grid(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density "g" on a set of
   ! grid points "pt", using ".natural orbitals" and the ".occupation" number
   ! vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .make_ELF_grid_r(ELF_grid,pt)
      else
         .make_ELF_grid_c(ELF_grid,pt)
      end
   end

   make_ELF_grid_r(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density on a set of grid
   ! points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "natural orbitals must be restricted")

      DD :: MAT{REAL}*
      mo_val,gx,gy,gz,rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s,NO :: VEC{REAL}*
      occu,factor,mo_val_n,gx_n,gy_n,gz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do i = 1,n_occ
         .make_nabla_orbital_grid_r(DD,NO,.natural_orbitals.restricted(:,i), pt)
         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)
         occu   = HALF*.occupation_numbers.restricted(i)
         do n = 1,n_pt
           mo_val_n  = mo_val(n)
           gx_n      = gx(n)
           gy_n      = gy(n)
           gz_n      = gz(n)
           occ_mo    = occu*mo_val_n
           rho_s(n)  = rho_s(n)  + occ_mo*mo_val_n
           tau(n)    = tau(n)    + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
           rho_sx(n) = rho_sx(n) + occ_mo*gx_n ! this is half grad_x rho_s
           rho_sy(n) = rho_sy(n) + occ_mo*gy_n
           rho_sz(n) = rho_sz(n) + occ_mo*gz_n
         end
      end

      DD.destroy
      NO.destroy

      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s

      rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy

      d0_s.create(n_pt)
      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)

      rho_s.destroy

      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))

      ! this could be more efficient if the d0_s*d0_s is written
      ! factor2*rho_s**(TWO+FIVE/THREE)
      d0_s.destroy; d_s.destroy

   end

   make_ELF_grid_c(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density on a set of grid
   ! points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      mo_val,gx,gy,gz,NO :: VEC{CPX}*
      DD :: MAT{CPX}*
      rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s :: VEC{REAL}*
      occu,factor :: REAL
      n_occ,n,n_pt :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_nabla_orbital_grid_c(DD,NO,.natural_orbitals.restricted_complex(:,n), pt)
         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)
         occu   = HALF*.occupation_numbers.restricted(n)
         rho_s  = rho_s  + occu * RE(conjg(mo_val)*mo_val)
         tau    = tau    + occu * RE(conjg(gx)*gx+conjg(gy)*gy+conjg(gz)*gz)
         rho_sx = rho_sx + occu * RE(conjg(gx)*mo_val) ! this is half grad_x rho_s
         rho_sy = rho_sy + occu * RE(conjg(gy)*mo_val)
         rho_sz = rho_sz + occu * RE(conjg(gz)*mo_val)
      end

      DD.destroy
      NO.destroy

      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s

      rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy

      d0_s.create(n_pt)

      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)

      rho_s.destroy

      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))

      d0_s.destroy; d_s.destroy

   end

! =====================
! Tsirelson ELF density
! =====================

   make_Tsirelson_ELF_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_Tsirelson_ELF_grid, LABEL=>"Tsirelson-Stash_ELF_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_Tsirelson_ELF_grid(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)=="real") then
         .make_Tsirelson_ELF_grid_r(ELF_grid,pt)
      else
         .make_Tsirelson_ELF_grid_c(ELF_grid,pt)
      end

   end

   make_Tsirelson_ELF_grid_r(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      DD,LL :: MAT{REAL}*
      mo_val,gx,gy,gz,lx,ly,lz,rho,rho_x,rho_y,rho_z,lap,d_p,d_0,NO :: VEC{REAL}*
      occu,factor,mo_val_n,gx_n,gy_n,gz_n,lx_n,ly_n,lz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT

      ELF_grid = ZERO

      n_pt = pt.dim1
      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do i = 1,n_occ
         .make_laplacian_orbital_grid_r(LL,DD,NO,.natural_orbitals.restricted(:,i), pt)
         mo_val => NO(:)
         gx => DD(:,1); gy => DD(:,2); gz => DD(:,3)
         lx => LL(:,1); ly => LL(:,2); lz => LL(:,3)
         occu = .occupation_numbers.restricted(i)
         do n = 1,n_pt
            mo_val_n = mo_val(n)
            gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
            lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)
            occ_mo   = occu*mo_val_n                        ! this is n_i phi_i
            rho(n)   = rho(n)   + occ_mo*mo_val_n           ! this is rho
            rho_x(n) = rho_x(n) + occ_mo*gx_n               ! this is half grad_x rho
            rho_y(n) = rho_y(n) + occ_mo*gy_n
            rho_z(n) = rho_z(n) + occ_mo*gz_n
            lap(n)   = lap(n)   + occ_mo*(lx_n+ly_n+lz_n) & ! this is half nabla^2 rho
                                + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
         end
      end

      LL.destroy
      DD.destroy
      NO.destroy

      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)

      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
                + lap/THREE

      lap.destroy

      rho_z.destroy; rho_y.destroy; rho_x.destroy
      rho.destroy

      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))

      d_p.destroy; d_0.destroy

   end

   make_Tsirelson_ELF_grid_c(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      mo_val,gx,gy,gz,lx,ly,lz,NO :: VEC{CPX}*
      DD,LL :: MAT{CPX}*
      rho,rho_x,rho_y,rho_z,lap,d_0,d_p :: VEC{REAL}*
      occu,factor :: REAL
      mo_val_n,gx_n,gy_n,gz_n,lx_n,ly_n,lz_n,occ_mo :: CPX
      n_occ,n_pt,n,i :: INT

      ELF_grid = ZERO
      n_pt = pt.dim1

      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)

      n_occ = .no_of_occupied_NOs
      do i = 1,n_occ

         .make_laplacian_orbital_grid_c(LL,DD,NO,.natural_orbitals.restricted_complex(:,i), pt)
         mo_val => NO(:)
         gx => DD(:,1); gy => DD(:,2); gz => DD(:,3)
         lx => LL(:,1); ly => LL(:,2); lz => LL(:,3)
         occu = .occupation_numbers.restricted(i)

         do n = 1,n_pt

           mo_val_n = mo_val(n)
           gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
           lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)
           occ_mo   = occu*mo_val_n                                          ! this is n_i phi_i
           rho(n)   = rho(n)   + RE(occ_mo*conjg(mo_val_n)) ! this is rho
           rho_x(n) = rho_x(n) + RE(occ_mo*conjg(gx_n))     ! this is half grad_x rho
           rho_y(n) = rho_y(n) + RE(occ_mo*conjg(gy_n))
           rho_z(n) = rho_z(n) + RE(occ_mo*conjg(gz_n))
                                                        ! this is half nabla^2 rho
           lap(n)   = lap(n) + RE(occ_mo*(conjg(lx_n)+conjg(ly_n)+conjg(lz_n))) &
                        + occu*RE(conjg(gx_n)*gx_n+conjg(gy_n)*gy_n+conjg(gz_n)*gz_n)
         end
      end

      LL.destroy
      DD.destroy
      NO.destroy

      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)

      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
                + lap/THREE

      lap.destroy
      rho_z.destroy; rho_y.destroy; rho_x.destroy
      rho.destroy

      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))

      d_p.destroy; d_0.destroy

   end

! ======================
! Fermi mobility density
! ======================

   make_fermi_mobility_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_fermi_mobility_grid, LABEL=>"fermi_mobility_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_fermi_mobility_grid(f,pt)
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
      f :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .make_fermi_mobility_grid_r(f,pt)
      else
         DIE("code not written yet")
      end

   end

   make_fermi_mobility_grid_r(f,pt)
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      del_gi :: MAT{REAL}*
      dg,gi,rho,dgx,dgy,dgz,orb :: VEC{REAL}*
      n,n_pt,i,n_occ :: INT
      delx,dely,delz,fac :: REAL

      n_pt = pt.dim1
      n_occ = .no_of_occupied_NOs
      dg.create(n_pt);    dg  = ZERO
      dgx.create(n_pt);   dgx = ZERO
      dgy.create(n_pt);   dgy = ZERO
      dgz.create(n_pt);   dgz = ZERO
      gi.create(n_pt)
      del_gi.create(n_pt,3)

      do i=1, n_occ

         orb => .natural_orbitals.restricted(:,i)

         .make_nabla_orbital_grid_r(del_gi,gi,orb,pt)

         do n=1,n_pt
            delx = del_gi(n,1)
            dely = del_gi(n,2)
            delz = del_gi(n,3)
            dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
            dgx(n) = dgx(n) + delx*gi(n)
            dgy(n) = dgy(n) + dely*gi(n)
            dgz(n) = dgz(n) + delz*gi(n)
         end

      end

      del_gi.destroy
      gi.destroy

      rho.create(n_pt)
      .make_density_grid(rho,pt)

      fac = (THREE*PI/FOUR) * HALF**TWOTHIRDS
      f = ONE/rho * (dg - TWO*(dgx*dgx + dgy*dgy + dgz*dgz)/rho) - fac * rho**TWOTHIRDS

      rho.destroy
      dgz.destroy
      dgy.destroy
      dgx.destroy
      dg.destroy

   end

! ===========================
! True Fermi mobility density
! ===========================

   make_true_fermi_mobility_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_true_fermi_mobility_grid, LABEL=>"true_fermi_mobility_grid")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_true_fermi_mobility_grid(f,pt)
   ! Work out the the true fermi mobility density "f" on a series of grid points
   ! "pt" using ".natural orbitals" and the ".occupation_numbers" vector. The
   ! true function differs from that above in that the kinetic energy density is
   ! evaluated exactly.
      f :: VEC{REAL}
      pt :: MAT{REAL}

   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")

      if (trim(.natural_orbitals.number_kind)== "real") then
         .make_true_fermi_mobil_grid_r(f,pt)
      else
         DIE("code not written yet")
      end

   end

   make_true_fermi_mobil_grid_r(f,pt)
   ! Evaluate the true Fermi hole mobility grid "f" on a set of grid points
   ! "pt".  The true function differs from that above in that the kinetic energy
   ! density is evaluated exactly.
   ! NOTE: this routine is only valid for single determinant wavefunctions.
      f :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      dg,rho,NO,K,gj,Tj :: VEC{REAL}*
      dgx,dgy,dgz,gi :: VEC{REAL}*
      n,n_pt,i,j,n_occ :: INT
      delx,dely,delz :: REAL
      del_gi,g,T :: MAT{REAL}*

      n_pt = pt.dim1
      n_occ = .no_of_occupied_NOs

      dg.create(n_pt);    dg  = ZERO
      dgx.create(n_pt);   dgx = ZERO
      dgy.create(n_pt);   dgy = ZERO
      dgz.create(n_pt);   dgz = ZERO
      g.create(n_pt,n_occ)
      del_gi.create(n_pt,3)

      ! Assemble intermediate terms
      do i=1, n_occ

         NO => .natural_orbitals.restricted(:,i)
         gi => g(:,i)
         .make_nabla_orbital_grid_r(del_gi,gi,NO,pt)

         do n=1,n_pt
            delx = del_gi(n,1)
            dely = del_gi(n,2)
            delz = del_gi(n,3)
            dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
            dgx(n) = dgx(n) + delx*gi(n)
            dgy(n) = dgy(n) + dely*gi(n)
            dgz(n) = dgz(n) + delz*gi(n)
         end

      end

      del_gi.destroy

      ! Make kinetic energy matrix part
      K.create(n_pt);    K = ZERO
      T.create(.n_bf,.n_bf)
      .make_kinetic_energy_mx(T)
      T.change_basis_using(.natural_orbitals.restricted)

      do j=1,n_occ
         gj => g(:,j)
         Tj => T(:,j)
         do i=1,n_occ
            K(:) = K(:) + g(:,i)*gj(:)*Tj(i)
         end
      end
      T.destroy

      ! Now do the final assembly
      rho.create(n_pt)
      .make_density_grid(rho,pt)
      f = ONE/rho * (dg - TWO*(dgx*dgx+dgy*dgy+dgz*dgz)/rho - TWO*K)

      ! Clean
      rho.destroy
      K.destroy
      g.destroy
      dgz.destroy
      dgy.destroy
      dgx.destroy
      dg.destroy

   end

! ===============
! Current density
! ===============

   make_j_grid
   ! Make the current density on ".plot_grid" using ".natural orbitals"
   ! and the ".occupation_numbers" vector.
   !    J(r) = J_p(r) + J_d(r)
   ENSURE(.plot_grid.created, "no grid")
      arch :: ARCHIVE
      j,jp :: MAT{REAL}*

      j.create(.plot_grid.n_pt,3);  .get_jd_density_grid(j)
      jp.create(.plot_grid.n_pt,3); .get_jp_density_grid(jp)

      j = j + jp

      jp.destroy

      arch.set(.name,"current_density")
      arch.write(j)
      arch.set(.name,"current_density",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"current_norm_density",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"current_density,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(j, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      j.destroy

   end

   get_jd_density_grid(jd)
   ! Set "jd" to the diamagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      jd :: MAT{REAL}
      arch :: ARCHIVE
      arch.set_defaults
      arch.set(.name,"jd_density_grid")
      if (NOT arch.exists) .make_jd_grid
      arch.read(jd)
   end

   make_jd_grid
   ! Work out the diamagnetic current density on ".plot_grid" using ".natural
   ! orbitals" and the ".occupation_numbers" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)
   ENSURE(.plot_grid.created, "no grid")
      arch :: ARCHIVE
      jd,r :: MAT{REAL}*
      rho :: VEC{REAL}*
      if (.B_field.norm<TOL(10)) then
         return
      end
      jd.create(.plot_grid.n_pt,3)
      rho.create(.plot_grid.n_pt)
      r.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(r)
      jd(:,1) = .B_field(2)*r(:,3) - .B_field(3)*r(:,2)
      jd(:,2) = .B_field(3)*r(:,1) - .B_field(1)*r(:,3)
      jd(:,3) = .B_field(1)*r(:,2) - .B_field(2)*r(:,1)
      .make_density_grid(rho,r)
      r.destroy
      jd(:,1) = -HALF*jd(:,1)*rho
      jd(:,2) = -HALF*jd(:,2)*rho
      jd(:,3) = -HALF*jd(:,3)*rho
      rho.destroy
      arch.set(.name,"jd_density")
      arch.write(jd)
      arch.set(.name,"jd_density",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"jd_norm_density",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"jd_density,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)
      jd.destroy
   end

   get_jp_density_grid(jp)
   ! Set "jp" to the paramagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      jp :: MAT{REAL}
      arch :: ARCHIVE
      arch.set_defaults
      arch.set(.name,"jp_density_grid")
      if (NOT arch.exists) .make_jp_grid
      arch.read(jp)
   end

   make_jp_grid
   ! Work out the paramagnetic current density on ".plot_grid" using ".natural
   ! orbitals".  A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.number_kind=="complex","natural orbitals not complex")

      arch :: ARCHIVE
      jp :: MAT{REAL}*

      ! Make NO's
      .make_ao_density_matrix
      .make_restricted_complex_NOs

      ! Make grid
      jp.create(.plot_grid.n_pt,3)
      .make_jp_grid(jp)

      ! Plot
      arch.set(.name,"jp_density_grid")
      arch.write(jp)
      arch.set(.name,"jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"jp_norm_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"jp_density_grid,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)

      ! Clean
      jp.destroy

   end

   make_jp_grid(jp)
   ! Work out the paramagnetic current density "jp" on ".plot_grid" using ".natural
   ! orbitals" .
   !    J_p(r) = - (eh/m) Re [ \sum_i n_i \phi^*_i(r) \nabla \phi^*_i(r)
      jp :: MAT{REAL}

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no density matrix")

      pt :: MAT{REAL}*
      P :: MAT{CPX}*
      D :: VEC{CPX}*
      n_occ,n,n_pt :: INT
      occ :: REAL

      ! Make plot points
      n_pt = .plot_grid.n_pt
      pt.create(n_pt,3)
      .plot_grid.make_points(pt)

      ! Temporaries
      D.create(n_pt)
      P.create(n_pt,3)
      n_occ = .no_of_occupied_NOs

      ! Initialize
      jp = ZERO

      ! Loop over NO's
      do n = 1,n_occ

         .make_nabla_orbital_grid_c(P,D,.natural_orbitals.restricted_complex(:,n), pt)

         occ = .occupation_numbers.restricted(n)

         jp(:,1) = jp(:,1) - occ*aimag(conjg(D(:))*P(:,1))
         jp(:,2) = jp(:,2) - occ*aimag(conjg(D(:))*P(:,2))
         jp(:,3) = jp(:,3) - occ*aimag(conjg(D(:))*P(:,3))

      end

      ! Clean
      P.destroy
      D.destroy
      pt.destroy

   end

   make_solenoidal_jp_grid
   ! Make the solenoidal paramagnetic current density grid "jp" on ".plot_grid"
   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
      arch :: ARCHIVE
      jp :: MAT{REAL}*
      .make_ao_density_matrix
      ENSURE(.density_matrix.created("restricted_complex"), "no density matrix")
      jp.create(.plot_grid.n_pt,3)
      .make_solenoidal_jp_grid(jp,.density_matrix.restricted_complex)
      arch.set(.name,"solenoidal_jp_density_grid")
      arch.write(jp)
      arch.set(.name,"solenoidal_jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"solenoidal_jp_norm_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"solenoidal_jp_density_grid,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)
      jp.destroy
   end

   make_solenoidal_jp_grid(jp,dens)
   ! Make the solenoidal paramagnetic current density grid "jp" on ".plot_grid"
   ! using AO density matrix "dens"
      jp :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Dba :: MAT{CPX}*
      pt,Jxab,Jyab,Jzab :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb,k :: INT
      fac :: REAL
      sh :: SHELL2

      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      jp = ZERO

      do q = 1,.n_shell_pairs

        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (fa==fb) fac=ONE

        Jxab.create(na,nb)
        Jyab.create(na,nb)
        Jzab.create(na,nb)

        do k = 1,.plot_grid.n_pt
          sh.make_solenoidal_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_product_with(aimag(Dba))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_product_with(aimag(Dba))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_product_with(aimag(Dba))
        end

        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        sh.destroy_ptr_part

      end

      pt.destroy

      jp.zero_small_values(TOL(10))

   end

   make_irrotational_jp_grid
   ! Make the irrotational paramagnetic current density grid "jp" on ".plot_grid"
   ENSURE(.plot_grid.destroyed,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
      arch :: ARCHIVE
      jp :: MAT{REAL}*
      .make_ao_density_matrix
      ENSURE(.density_matrix.created("restricted_complex"), "no density matrix")
      jp.create(.plot_grid.n_pt,3)
      .make_irrotational_jp_grid(jp,.density_matrix.restricted_complex)
      arch.set(.name,"irrotational_jp_density_grid")
      arch.write(jp)
      arch.set(.name,"irrotational_jp_density_grid",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      arch.set(.name,"irrotational_jp_norm_density_grid",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, norm=TRUE)
      arch.set(.name,"irrotational_jp_density_grid,normalized",format="ascii")
      arch.write_gnuplot(jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z, normalise=TRUE)
      jp.destroy
   end

   make_irrotational_jp_grid(jp,dens)
   ! Make the irrotational paramagnetic current density grid "jp" on ".plot_grid"
   ! using AO density matrix "dens"
      jp :: MAT{REAL}
      dens :: MAT{CPX}, target

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")

      Dba :: MAT{CPX}*
      pt,Jxab,Jyab,Jzab :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb,k :: INT
      fac :: REAL
      sh :: SHELL2

      pt.create(.plot_grid.n_pt,3)
      .plot_grid.make_points(pt)

      jp = ZERO

      do q = 1,.n_shell_pairs

        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (fa==fb) fac=ONE
        Jxab.create(na,nb)
        Jyab.create(na,nb)
        Jzab.create(na,nb)

        do k = 1,.plot_grid.n_pt
          sh.make_irrotational_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_product_with(aimag(Dba))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_product_with(aimag(Dba))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_product_with(aimag(Dba))
        end

        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        sh.destroy_ptr_part

      end

      pt.destroy

      jp.zero_small_values(TOL(10))

   end

   make_div_jp_grid
   ! Work out the divergence of the paramagnetic current density on ".plot_grid"
   ! using ".natural orbitals".  A Gnuplot ascii file is generated.

   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(trim(.natural_orbitals.number_kind)=="complex", "natural orbitals not complex")

      arch :: ARCHIVE
      div_jp :: VEC{REAL}*

      .make_ao_density_matrix
      .make_restricted_complex_NOs

      div_jp.create(.plot_grid.n_pt)
      .make_div_jp_grid(div_jp)

      arch.set(.name,"div_jp_density_grid")
      arch.write(div_jp)
      arch.set(.name,"div_jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(div_jp, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      
      div_jp.destroy

   end

   make_div_jp_grid(div_jp)
   ! Work out the divergence of the paramagnetic current density "jp" on ".plot_grid"
   ! using ".natural orbitals" .
   !  \nabla .  J_p(r) = - (eh/m) \sum_i n_i Im[ \phi^*_i(r) \nabla^2 \phi^_i(r) ]
      div_jp :: VEC{REAL}
   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no density matrix")
      pt :: MAT{REAL}*
      L :: MAT{CPX}*
      P :: MAT{CPX}*
      D :: VEC{CPX}*
      n_occ,n,n_pt :: INT
      occ :: REAL
      div_jp = ZERO
      n_pt = .plot_grid.n_pt
      pt.create(n_pt,3); .plot_grid.make_points(pt)
      D.create(n_pt)
      P.create(n_pt,3)
      L.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
       .make_laplacian_orbital_grid_c(L,P,D,.natural_orbitals.restricted_complex(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       div_jp(:) = div_jp(:) - occ*aimag(conjg(D(:))*(L(:,1)+L(:,2)+L(:,3)))
      end
      L.destroy
      P.destroy
      D.destroy
      pt.destroy
   end

! ==============
! Magnetic Field
! ==============

   make_B_field_grid 
   ! Work out the field density on ".plot_grid" and dump output
   ENSURE(.plot_grid.created, "no grid")

      B_L,B_S :: MAT{REAL}*
      fx,fy,fz,mag :: VEC{REAL}*
      pt :: MAT{REAL}*
      if(.plot_grid.points_filename/="no_made-up_points") then 
        stdout.text("=====================================")
        stdout.text("use of read-in grid to be implemented")
        stdout.text("TONTO will stop here ...")
        stdout.text("=====================================")
        stop
      else

      ! Make space for the field and grid points
      B_L.create(.plot_grid.n_pt,3)
      B_S.create(.plot_grid.n_pt,3)
      mag.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3)

        ! Make the grid of field values
  !      .make_B_field_grid(B_L,B_S,pt)
        .make_B_L_field_grid(B_L,pt)
        .make_B_S_field_grid(B_S,pt)

        ! Print B_L field components
        fx => B_L(:,1)
        fy => B_L(:,2)
        fz => B_L(:,3)
        .dump_plot_grid(fx,"B_L_field.x")
        .dump_plot_grid(fy,"B_L_field.y")
        .dump_plot_grid(fz,"B_L_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .dump_plot_grid(mag,"B_L_field.magnitude")
  
        ! Print B_S field components
        fx => B_S(:,1)
        fy => B_S(:,2)
        fz => B_S(:,3)
        .dump_plot_grid(fx,"B_S_field.x")
        .dump_plot_grid(fy,"B_S_field.y")
        .dump_plot_grid(fz,"B_S_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .dump_plot_grid(mag,"B_S_field.magnitude")
  
        ! Print B field components
        B_L = B_L + B_S
        fx => B_L(:,1)
        fy => B_L(:,2)
        fz => B_L(:,3)
        .dump_plot_grid(fx,"B_field.x")
        .dump_plot_grid(fy,"B_field.y")
        .dump_plot_grid(fz,"B_field.z")
        mag = sqrt(fx*fx+fy*fy+fz*fz)
        .dump_plot_grid(mag,"B_field.magnitude")

      end

      ! Clean up
      pt.destroy
      B_S.destroy
      B_L.destroy

   end
 
!   make_B_field_grid(B_L,B_S,pt) 
!   ! Make the magnetic field "B" field due to the linear current and
!   ! the spin current on a series of points "pt"
!      B_L,B_S :: MAT{REAL}, OUT
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.density_matrix.any_created,"no density matrix")
!
!      M :: MAT4{REAL}*
!      S :: MAT3{REAL}*
!      D,DD,S1,S2,S3,J1,J2,J3 :: MAT{REAL}*
!      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
!      fac :: REAL
!      sh :: SHELL2
!
!      ! No of grid points
!      n_pt = pt.dim1
!
!      ! The imaginary part of AO density matrix
!      D.create(.n_bf,.n_bf)
!      .make_ao_IM_density_matrix(D)
!
!      ! Make the real part of AO spin density matrix
!      S.create(.n_bf,.n_bf,3)
!      .make_ao_RE_spin_densities(S)
!
!      ! Initialize
!      B_L = ZERO
!      B_S = ZERO
!
!      ! Loop over integral blocks
!      parallel do q = 1,.n_shell_pairs
!
!        ! Get shell indices (leaky)
!        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
!
!        ! Get the density matrix
!        DD.create(nb,na); DD = D(fb:lb,fa:la)
!
!        ! Get the spin density matrix
!        S1.create(nb,na); S1 = S(fb:lb,fa:la,1)
!        S2.create(nb,na); S2 = S(fb:lb,fa:la,2)
!        S3.create(nb,na); S3 = S(fb:lb,fa:la,3)
!
!        ! Space for integrals
!        M.create(na,nb,3,3)
!        J1 => M(:,:,1,1)
!        J2 => M(:,:,2,2)
!        J3 => M(:,:,3,3)
!
!        ! Loop over points
!        do p = 1,n_pt
!
!           ! Make the B-field integrals for point k
!           sh.make_nabla_field_ints(M,pt(p,:))
!
!           ! Factor
!           fac =TWO 
!           if (fa==fb) fac = ONE
!
!           ! Sum over the spin density matrices
!           ! Factor 2 should be put here, since S ints are symmetric so it
!           ! is introduced once at the end
!           B_S(p,2) = B_S(p,2) + fac*M(:,:,2,1).trace_product_with(S1)
!           B_S(p,3) = B_S(p,3) + fac*M(:,:,3,1).trace_product_with(S1)
!           B_S(p,1) = B_S(p,1) - fac*M(:,:,2,2).trace_product_with(S1)
!           B_S(p,1) = B_S(p,1) - fac*M(:,:,3,3).trace_product_with(S1)
!
!           B_S(p,1) = B_S(p,1) + fac*M(:,:,1,2).trace_product_with(S2)
!           B_S(p,3) = B_S(p,3) + fac*M(:,:,3,2).trace_product_with(S2)
!           B_S(p,2) = B_S(p,2) - fac*M(:,:,1,1).trace_product_with(S2)
!           B_S(p,2) = B_S(p,2) - fac*M(:,:,3,3).trace_product_with(S2)
!
!           B_S(p,1) = B_S(p,1) + fac*M(:,:,1,3).trace_product_with(S3)
!           B_S(p,2) = B_S(p,2) + fac*M(:,:,2,3).trace_product_with(S3)
!           B_S(p,3) = B_S(p,3) - fac*M(:,:,1,1).trace_product_with(S3)
!           B_S(p,3) = B_S(p,3) - fac*M(:,:,2,2).trace_product_with(S3)
!
!           ! Cross product part
!           J1 = M(:,:,2,3) - M(:,:,3,2)
!           J2 = M(:,:,3,1) - M(:,:,1,3)
!           J3 = M(:,:,1,2) - M(:,:,2,1)
!
!           ! Get magnetic field contribution
!           ! Extra factor 2 needed from left derivative in M
!           ! is deferred to end.
!           B_L(p,1) = B_L(p,1) + fac*J1.trace_product_with(DD)
!           B_L(p,2) = B_L(p,2) + fac*J2.trace_product_with(DD)
!           B_L(p,3) = B_L(p,3) + fac*J3.trace_product_with(DD)
!
!        end
!
!        ! Clean
!        M.destroy
!        S3.destroy; S2.destroy; S1.destroy
!        DD.destroy
!        sh.destroy_ptr_part
!
!      end
!
!      ! Clean
!      S.destroy
!      D.destroy
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(B_S)
!         PARALLEL_SUM(B_L)
!      end
!
!      ! Minus sign not necessary? CHECK
!      fac = -ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B_L = fac*B_L
!
!      ! Spin Factor
!  !    fac = -G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!  ! minus sign is cancelled by that of the Bohr magneton, 
!  ! the 1/2 of the bohr magneton is cancelled from a factor 2
!  ! arising in simplification by symmetry of the formula
!      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B_S = fac*B_S
!
!   end

   field_grid ::: template
   ! Work out the field density on ".plot_grid" and dump output
   ENSURE(.plot_grid.created, "no grid")

      field :: MAT{REAL}*
      fx,fy,fz :: VEC{REAL}*
      pt :: MAT{REAL}*

      ! Make space for the field and grid points
      field.create(.plot_grid.n_pt,3)
      pt.create(.plot_grid.n_pt,3)

      ! Make the grid points
      .plot_grid.make_points(pt)

      ! Make the grid of field values
      .MAKE_FIELD(field,pt)

      ! Assign field components
      fx => field(:,1)
      fy => field(:,2)
      fz => field(:,3)

      ! Print out
      .dump_plot_grid(fx,LABEL//".x")
      .dump_plot_grid(fy,LABEL//".y")
      .dump_plot_grid(fz,LABEL//".z")

      ! Get the magnitude
      fx = sqrt(fx*fx+fy*fy+fz*fz)

      ! Print out
      .dump_plot_grid(fx,LABEL//".magnitude")

      ! Clean up
      pt.destroy
      field.destroy

   end

   make_B_L_field_grid ::: get_from(MOLECULE:field_grid, MAKE_FIELD=>make_B_L_field_grid, LABEL=>"B_L_field")
   ! Work out the field density on ".plot_grid" and dump output
   end
 
   make_B_L_field_grid(B,pt) 
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.any_created,"no density matrix")

      Mleft,Mright :: MAT4{REAL}*
      D,Dba,J1,J2,J3 :: MAT{REAL}*
      Dab,J4,J5,J6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! The imaginary part of AO density matrix
      D.create(.n_bf,.n_bf)
      .make_ao_IM_density_matrix(D)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the density matrix
        Dab.create(na,nb)
        Dab = D(fa:la,fb:lb)
        Dba.create(nb,na)
        Dba = D(fb:lb,fa:la)

        ! Space for integrals
        Mleft.create(nb,na,3,3)
        Mright.create(na,nb,3,3)
        J1 => Mright(:,:,1,1)
        J2 => Mright(:,:,2,2)
        J3 => Mright(:,:,3,3)
        J4 => Mleft(:,:,1,1)
        J5 => Mleft(:,:,2,2)
        J6 => Mleft(:,:,3,3)

        ! Loop over points
        do p = 1,n_pt

           if (fa==fb) then

             ! Make the B-field integrals for point k
             sh.make_nabla_field_ints(Mright,pt(p,:))
  
             ! Cross product part
             J1 = Mright(:,:,2,3) - Mright(:,:,3,2)
             J2 = Mright(:,:,3,1) - Mright(:,:,1,3)
             J3 = Mright(:,:,1,2) - Mright(:,:,2,1)
  
             ! Get magnetic field contribution
             B(p,1) = B(p,1) + J1.trace_product_with(Dba)
             B(p,2) = B(p,2) + J2.trace_product_with(Dba)
             B(p,3) = B(p,3) + J3.trace_product_with(Dba)

           else

             ! Make the B-field integrals for point k
             sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))
  
             ! Cross product part
             J1 = Mright(:,:,2,3) - Mright(:,:,3,2)
             J2 = Mright(:,:,3,1) - Mright(:,:,1,3)
             J3 = Mright(:,:,1,2) - Mright(:,:,2,1)
             J4 = Mleft(:,:,2,3) - Mleft(:,:,3,2)
             J5 = Mleft(:,:,3,1) - Mleft(:,:,1,3)
             J6 = Mleft(:,:,1,2) - Mleft(:,:,2,1)
  
             ! Get magnetic field contribution
             B(p,1) = B(p,1) + J1.trace_product_with(Dba)
             B(p,2) = B(p,2) + J2.trace_product_with(Dba)
             B(p,3) = B(p,3) + J3.trace_product_with(Dba)
             B(p,1) = B(p,1) + J4.trace_product_with(Dab)
             B(p,2) = B(p,2) + J5.trace_product_with(Dab)
             B(p,3) = B(p,3) + J6.trace_product_with(Dab)

           end

        end

        ! Clean
        Mleft.destroy
        Mright.destroy
        Dba.destroy
        Dab.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      D.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Minus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = -ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end
 
!   make_B_L_field_grid_checked(B,pt) 
!   ! Make the magnetic field "B" field due to the linear current on a
!   ! series of points "pt"
!      B :: MAT{REAL}, OUT
!      pt :: MAT{REAL}, IN
!
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.density_matrix.any_created,"no density matrix")
!
!      D :: MAT{REAL}*
!      Dba :: MAT{REAL}*
!      Jx,Jy,Jz :: MAT{REAL}*
!      q,fa,fb,la,lb,na,nb, k,n_pt :: INT
!      fac :: REAL
!      sh :: SHELL2
!
!      ! No of grid points
!      n_pt = pt.dim1
!
!      ! Make the AO density matrix
!      D.create(.n_bf,.n_bf)
!      .make_ao_IM_density_matrix(D)
!
!      ! Initialize
!      B = ZERO
!
!      ! Loop over integral blocks
!      parallel do q = 1,.n_shell_pairs
!
!        ! Get shell indices (leaky)
!        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)
!        fac = TWO
!        if (fa==fb) fac = ONE
!
!        ! Get the density matrix
!        Dba.create(nb,na)
!        Dba = D(fb:lb,fa:la)
!
!        ! Space for integrals
!        Jx.create(na,nb)
!        Jy.create(na,nb)
!        Jz.create(na,nb)
!
!        ! Loop over points
!        do k = 1,n_pt
!
!           ! Make the integrals for point k
!           sh.make_magnetic_jp_ints(Jx,Jy,Jz,pt(k,:))
!
!           ! Get magnetic field contribution
!           B(k,1) = B(k,1) + fac*Jx.trace_product_with(Dba)
!           B(k,2) = B(k,2) + fac*Jy.trace_product_with(Dba)
!           B(k,3) = B(k,3) + fac*Jz.trace_product_with(Dba)
!
!        end
!
!        ! Clean
!        Jz.destroy; Jy.destroy; Jx.destroy
!        Dba.destroy
!        sh.destroy_ptr_part
!
!      end
!
!      ! Clean
!      D.destroy
!
!      if (DO_IN_PARALLEL) then
!         PARALLEL_SUM(B)
!      end
!
!      ! Minus sign not necessary? CHECK
!      fac = -HALF/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
!      B   = fac*B
!
!   end

   make_B_S_field_grid ::: get_from(MOLECULE:field_grid, MAKE_FIELD=>make_B_S_field_grid, LABEL=>"B_S_field")
   ! Work out the field density on ".plot_grid" and dump output
   end
 
   make_B_S_field_grid(B,pt) 
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.any_created,"no density matrix")

      ! Not the most efficient, but should work ...
      if (.density_matrix.alpha.created) then; .make_B_S_field_grid_u(B,pt)
      else;                                    .make_B_S_field_grid_gc(B,pt)
      end

   end
 
   make_B_S_field_grid_u(B,pt) 
   ! Make the magnetic field "B" field due to the spin current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.density_matrix.alpha.created,"no alpha density matrix")
   ENSURE(.density_matrix.beta.created,"no beta density matrix")

      Mright,Mleft :: MAT4{REAL}*
      S,S3,S6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! Make the AO Sz density matrix
      S.create(.n_bf,.n_bf)
      .make_ao_sz_density_matrix(S)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the z spin density matrix block
        S3.create(nb,na); S3 = S(fb:lb,fa:la)
        S6.create(na,nb); S6 = S(fa:la,fb:lb)

        ! Space for integrals
        Mright.create(na,nb,3,3)
        Mleft.create(nb,na,3,3)

        ! Loop over points
        do p = 1,n_pt

          if (fa==fb) then

          ! Make the B-field integrals for point k
            sh.make_nabla_field_ints(Mright,pt(p,:))

 
            ! Sum over the spin density matrices
            B(p,1) = B(p,1) + fac*Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + fac*Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - fac*Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - fac*Mright(:,:,2,2).trace_product_with(S3)
 
          else
          ! Make the B-field integrals for point k
          !
            sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))

            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
 
            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S6)
            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S6)

          ! To add to make it work even if S is not Hermitian
          ! (useful to test a single matrix element)
          ! but then a factor HALF should be inserted

! 
!            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S6,TRUE)
!            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S6,TRUE)
! 
!           
!            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S3,TRUE)
!            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S3,TRUE)


          end
        end

        ! Clean
        Mright.destroy
        Mleft.destroy
        S3.destroy
        S6.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      S.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Spin Factor
      ! Plus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B

   end
 
   make_B_S_field_grid_gc(B,pt) 
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      B :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")

!pcc      M :: MAT4{REAL}*
      Mleft,Mright :: MAT4{REAL}*
      S :: MAT3{REAL}*
      S1,S2,S3 :: MAT{REAL}*
      S4,S5,S6 :: MAT{REAL}*
      q,fa,fb,la,lb,na,nb, p,n_pt :: INT
      fac :: REAL
      sh :: SHELL2

      ! No of grid points
      n_pt = pt.dim1

      ! Make the AO density matrix
      S.create(.n_bf,.n_bf,3)
      .make_ao_RE_spin_densities(S)

      ! Initialize
      B = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! Get shell indices (leaky)
        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Get the spin density matrix
        S1.create(nb,na); S1 = S(fb:lb,fa:la,1)
        S2.create(nb,na); S2 = S(fb:lb,fa:la,2)
        S3.create(nb,na); S3 = S(fb:lb,fa:la,3)
        S4.create(na,nb); S4 = S(fa:la,fb:lb,1)
        S5.create(na,nb); S5 = S(fa:la,fb:lb,2)
        S6.create(na,nb); S6 = S(fa:la,fb:lb,3)

        ! Space for integrals
        Mright.create(na,nb,3,3)
        Mleft.create(nb,na,3,3)

        ! Loop over points
        do p = 1,n_pt


          if (fa==fb) then

          ! Make the B-field integrals for point k
            sh.make_nabla_field_ints(Mright,pt(p,:))

 
            ! Sum over the spin density matrices
            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S1)
            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S1)
 
            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S2)
            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S2)
 
            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
 
          else
          ! Make the B-field integrals for point k
          !
            sh.make_nabla_field_ints(Mright,Mleft,pt(p,:))

            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S1)
            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S1)
            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S1)

            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S2)
            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S2)
            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S2)
 
            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S3)
            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S3)
            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S3)
 
           
            B(p,2) = B(p,2) + Mleft(:,:,2,1).trace_product_with(S4)
            B(p,3) = B(p,3) + Mleft(:,:,3,1).trace_product_with(S4)
            B(p,1) = B(p,1) - Mleft(:,:,2,2).trace_product_with(S4)
            B(p,1) = B(p,1) - Mleft(:,:,3,3).trace_product_with(S4)
 
            B(p,1) = B(p,1) + Mleft(:,:,1,2).trace_product_with(S5)
            B(p,3) = B(p,3) + Mleft(:,:,3,2).trace_product_with(S5)
            B(p,2) = B(p,2) - Mleft(:,:,1,1).trace_product_with(S5)
            B(p,2) = B(p,2) - Mleft(:,:,3,3).trace_product_with(S5)
 
            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S6)
            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S6)
            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S6)

          ! To add to make it work even if S is not Hermitian
          ! (useful to test a single matrix element)
          ! but then a factor HALF should be inserted

!            B(p,2) = B(p,2) + Mright(:,:,2,1).trace_product_with(S4,TRUE)
!            B(p,3) = B(p,3) + Mright(:,:,3,1).trace_product_with(S4,TRUE)
!            B(p,1) = B(p,1) - Mright(:,:,2,2).trace_product_with(S4,TRUE)
!            B(p,1) = B(p,1) - Mright(:,:,3,3).trace_product_with(S4,TRUE)
!
!            B(p,1) = B(p,1) + Mright(:,:,1,2).trace_product_with(S5,TRUE)
!            B(p,3) = B(p,3) + Mright(:,:,3,2).trace_product_with(S5,TRUE)
!            B(p,2) = B(p,2) - Mright(:,:,1,1).trace_product_with(S5,TRUE)
!            B(p,2) = B(p,2) - Mright(:,:,3,3).trace_product_with(S5,TRUE)
! 
!            B(p,1) = B(p,1) + Mright(:,:,1,3).trace_product_with(S6,TRUE)
!            B(p,2) = B(p,2) + Mright(:,:,2,3).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,1,1).trace_product_with(S6,TRUE)
!            B(p,3) = B(p,3) - Mright(:,:,2,2).trace_product_with(S6,TRUE)
! 
!           
!            B(p,2) = B(p,2) + Mleft(:,:,2,1).trace_product_with(S1,TRUE)
!            B(p,3) = B(p,3) + Mleft(:,:,3,1).trace_product_with(S1,TRUE)
!            B(p,1) = B(p,1) - Mleft(:,:,2,2).trace_product_with(S1,TRUE)
!            B(p,1) = B(p,1) - Mleft(:,:,3,3).trace_product_with(S1,TRUE)
! 
!            B(p,1) = B(p,1) + Mleft(:,:,1,2).trace_product_with(S2,TRUE)
!            B(p,3) = B(p,3) + Mleft(:,:,3,2).trace_product_with(S2,TRUE)
!            B(p,2) = B(p,2) - Mleft(:,:,1,1).trace_product_with(S2,TRUE)
!            B(p,2) = B(p,2) - Mleft(:,:,3,3).trace_product_with(S2,TRUE)
! 
!            B(p,1) = B(p,1) + Mleft(:,:,1,3).trace_product_with(S3,TRUE)
!            B(p,2) = B(p,2) + Mleft(:,:,2,3).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,1,1).trace_product_with(S3,TRUE)
!            B(p,3) = B(p,3) - Mleft(:,:,2,2).trace_product_with(S3,TRUE)
          end
        end
 
        ! Clean
        Mright.destroy
        Mleft.destroy
        S3.destroy; S2.destroy; S1.destroy
        S6.destroy; S5.destroy; S4.destroy
        sh.destroy_ptr_part

      end

      ! Clean
      S.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(B)
      end

      ! Spin Factor
      ! Plus sign because the nabla field ints in the code are defined as minus
      ! the I-integrals of the paper at PCCP
      fac = G_FACTOR/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      B   = fac*B
  !   stdout.text("Bs")
  !   stdout.put(B)
   end
 
   make_B_L_matrices(Bx,By,Bz,c) 
   ! Make the magnetic field "B" field due to the linear current on a
   ! series of points "pt"
      Bx,By,Bz :: MAT{REAL}, OUT
      c :: VEC{REAL}(3), IN

      q,fa,fb,la,lb,na,nb :: INT
      sh :: SHELL2

      ! Initialize
      Bx = ZERO
      By = ZERO
      Bz = ZERO

      ! Loop over integral blocks
      parallel do q = 1,.n_shell_pairs

        ! shell indices (leaky)
        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb)

        ! Make the integrals, point c
        sh.make_magnetic_jp_ints(Bx(fa:la,fb:lb),By(fa:la,fb:lb),Bz(fa:la,fb:lb),c)

        ! Clean
        sh.destroy_ptr_part

      end

      ! Symmetrize
      if (DO_IN_PARALLEL) then
         PARALLEL_SYMMETRIC_SUM(Bx)
         PARALLEL_SYMMETRIC_SUM(By)
         PARALLEL_SYMMETRIC_SUM(Bz)
      else
         Bx.symmetric_reflect
         By.symmetric_reflect
         Bz.symmetric_reflect
      end

   end

! ======================
! Polarizability density
! ======================

   make_e_polarization_grid 
   ! Work out the electric polarization grid, either along a
   ! projection or all three directions and magnitude.
   ENSURE(.plot_grid.created, "no grid")
      if (.plot_grid.projection_direction.is_zero) then
         .make_e_polarization_vgrid
      else
         .make_e_polarization_pgrid
      end
   end

   make_e_polarization_vgrid ::: get_from(MOLECULE:field_grid, MAKE_FIELD=>make_e_polarization_vgrid, LABEL=>"electric_polarization_density")
   ! Work out the field density on ".plot_grid" and dump output
   end
 
   make_e_polarization_vgrid(E,pt) 
   ! Make the (vector as opposed to projected) electric polarization
   ! density "E" on a series of grid points "pt"
      E :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.molecular_orbitals.restricted.created,"no MO's")
   ENSURE(.U_electric_dipole.created,"no U matrices: did you do a dipole_polarizability?")
   ENSURE(E.dim1==pt.dim1, "E and pt: inconsistent no. of points")
   ENSURE(E.dim2==3      , "E : wrong dim2")

      D :: MAT3{REAL}*
      MO :: MAT{REAL}*
      n_occ, i :: INT

      ! Dimensions
      n_occ = .n_a 

      ! Get derivative density matrices (restricted only)
      D.create(.n_bf,.n_bf,3)
      MO => .molecular_orbitals.restricted
      do i = 1,3 ! x,y,z electric fields
         .U_electric_dipole(:,:,1).back_transform_to(D(:,:,1),MO(:,n_occ+1:),MO(:,:n_occ))
         D(:,:,i).symmetrize              
      end
      D = FOUR*D

      ! Debug
      if (.debugging("make_e_polarization_grid")) then
         stdout.flush
         stdout.text("Derivative density matrices")
         stdout.put(D)
      end

      ! Make the derivative rho grid
      .make_derivative_rho_grid(E,pt,D)

      ! Clean
      D.destroy

   end

   make_e_polarization_pgrid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_e_polarization_pgrid, LABEL=>"electric_polarization_density.projected")
   ! Work out the property density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end
 
   make_e_polarization_pgrid(grid,pt) 
   ! Make the (vector as opposed to projected) electric polarization
   ! density "E" on a series of grid points "pt"
      grid :: VEC{REAL}
      pt :: MAT{REAL}, IN

   ENSURE(grid.dim==pt.dim1, "grid and pt: inconsistent no. of points")

      E :: MAT{REAL}*
      n_pt :: INT

      ! Dimensions
      n_pt  = pt.dim1

      ! Make electric polarization density
      E.create(n_pt,3)
      .make_e_polarization_vgrid(E,pt) 

      ! Do the projection
      grid = E(:,1)*.plot_grid.projection_direction(1) &
           + E(:,2)*.plot_grid.projection_direction(2) &
           + E(:,3)*.plot_grid.projection_direction(3)

      ! Clean
      E.destroy

   end

! =============================
! Set interpolator and ANO info 
! =============================

   set_interpolator_info(plot_kind) ::: leaky
   ! Set the interpolator info for all the atoms if the "plot_kind" is such
   ! that interpolation tables could be beneficial. This should be called just
   ! prior to doing the plot to take advantage of speed-ups.
      plot_kind :: STR

      do_interpolator :: BIN

      do_interpolator = plot_kind=="stockholder_density" &
                     OR plot_kind=="stockholder_weight"  &
                     OR plot_kind=="promolecule_density"

      if (NOT do_interpolator) return

      ENSURE(.atom.created,"no atom list")

      ! Get interpolators. 
      select case (.atom(1).basis_kind)
         case ("slater")
            ENSURE(.slaterbasis.created,"no slater bases")
            .make_slater_interpolators
         case ("coppens")
            ENSURE(.coppensbasis.created,"no coppens bases")
            .make_coppens_interpolators
         case ("gaussian")
            ENSURE(.basis.created,"no gaussian bases")
            .make_ANO_data
            .make_ANO_interpolators
      end

   end

   make_interpolator_sqrt(interpolator) ::: leaky
   ! Make a non-gaussian interpolator. These typically used for
   ! stockholder weight functions.
      interpolator :: INTERPOLATOR*

      ! Create default interpolator
      interpolator.create  

      ! Reset default table eps
      interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! If a saved cluster exists, use a table eps from that
      if (.saved.created) then
      if (.saved.cluster.created) then
      if (.saved.cluster.info_made) then
         interpolator.set_table_eps(.saved.cluster.atom_density_cutoff)
      end
      end
      end

      ! Set a linear-sqrt interpolator
      interpolator.set_interpolation_method("linear")
      interpolator.set_range_mapping("none")
      interpolator.set_domain_mapping("sqrt")
      interpolator.set_table_length(900d0)
      interpolator.set_table_spacing(0.1d0)

   end

   make_interpolator_sqrt_x1x(interpolator) ::: leaky
   ! Make a gaussian interpolator. 
      interpolator :: INTERPOLATOR*

      ! Create default interpolator
      interpolator.create  

      ! Reset default table eps
      interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! If a saved cluster exists, use a table eps from that
      if (.saved.created) then
      if (.saved.cluster.created) then
      if (.saved.cluster.info_made) then
         interpolator.set_table_eps(.saved.cluster.atom_density_cutoff)
      end
      end
      end

      ! Set a linear-sqrt interpolator
      interpolator.set_interpolation_method("cubic_spline")
      interpolator.set_range_mapping("none")
      interpolator.set_domain_mapping("sqrt(x/(1-x))*scale")
      interpolator.set_table_length(ONE) 
      interpolator.set_spacing(0.0001d0) 

   end

   make_slater_interpolators ::: leaky
   ! Make the slaterbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
   ENSURE(.slaterbasis.created,"no slaterbasis")

      template :: INTERPOLATOR*
      i :: INT

      stdout.flush
      stdout.text("Making slater interpolators ...")

      ! Make the interpolators
      if (.interpolator.created) then
         do i = 1,.slaterbasis.dim   
           .slaterbasis(i).make_interpolator(.interpolator)
         end                         
      else
         .make_interpolator_sqrt(template)
         do i = 1,.slaterbasis.dim   
           .slaterbasis(i).make_interpolator(template)
         end                         
         template.destroy
      end

      ! Set .atom to use this interpolator
      if (.atom.created) .atom.set_basis_kind("slater")

   end

   make_coppens_interpolators ::: leaky
   ! Make the coppensbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
   ! Otherwise use an atom density cutoff "tol".
   ! NOTE: any existing interpolators are destroyed first
   ENSURE(.coppensbasis.created,"no slaterbasis")


      template :: INTERPOLATOR*
      i :: INT

      stdout.flush
      stdout.text("Making coppens interpolators ...")

      ! Make the interpolators
      if (.interpolator.created) then
         do i = 1,.coppensbasis.dim  ! Make the interpolators
            .coppensbasis(i).make_interpolator(.interpolator)
         end                      
      else
         .make_interpolator_sqrt(template)
         do i = 1,.coppensbasis.dim  ! Make the interpolators
            .coppensbasis(i).make_interpolator(template)
         end                      
         template.destroy
      end

      ! Set .atom to use this interpolator
      if (.atom.created) .atom.set_basis_kind("coppens")

   end


   set_atom_plot_info(plot_kind) ::: leaky
   ! Set the ANO info for all the atoms if the "plot_kind" is such
   ! that the ANO data must be made.
      plot_kind :: STR

      if (plot_kind(1:11)=="deformation" OR plot_kind(1:4)=="e_hf") then

         ! If we get here, the ANO information will be used
         .make_ANO_data
         .make_ANO_interpolators
         .make_atom_shell_info

      else if (plot_kind(1:5)=="bond_") then

         .make_ANO_data
         .make_ANO_interpolators
         .make_atom_shell_info

       ! ! If we get here, the spherically averaged atom information will be used
       ! .get_spherical_atoms

      else if (plot_kind=="hirshfeld_atom_grid") then

         .set_up_Hirshfeld_info(skip_NOs=TRUE)

      end

   end

   set_up_becke_grid_info ::: leaky
   ! Set up the Becke grid info only for those plots which actually
   ! need it.

      do_it :: BIN

      if (.plot_grid.destroyed) return

      do_it = FALSE

      select case (.plot_grid.plot_kind)
         case("b_field                             "); do_it = FALSE
         case("b_l_field                           "); do_it = FALSE
         case("b_s_field                           "); do_it = FALSE
         case("bond_weight                         "); do_it = FALSE
         case("crystal_error_map                   "); do_it = FALSE
         case("current_density                     "); do_it = FALSE
         case("deformation_bond_density            "); do_it = TRUE
         case("deformation_density                 "); do_it = TRUE 
         case("deformation_dft_eff_potential       "); do_it = TRUE 
         case("deformation_dft_energy              "); do_it = TRUE 
         case("deformation_dft_xc_potential        "); do_it = TRUE 
         case("deformation_electric_potential      "); do_it = TRUE 
         case("deformation_g_kinetic_energy        "); do_it = TRUE 
         case("deformation_g_kirzhnits             "); do_it = TRUE 
         case("deformation_h_dft_energy            "); do_it = TRUE 
         case("deformation_h_from_virial           "); do_it = TRUE 
         case("deformation_h_kirzhnits             "); do_it = TRUE 
         case("deformation_k_kinetic_energy        "); do_it = TRUE 
         case("deformation_laplacian               "); do_it = TRUE 
         case("deformation_v_from_virial           "); do_it = TRUE 
         case("deformation_v_kirzhnits             "); do_it = TRUE 
         case("deformation_reduced_g_kinetic_energy"); do_it = TRUE 
         case("deformation_reduced_h_from_virial   "); do_it = TRUE 
         case("deformation_reduced_k_kinetic_energy"); do_it = TRUE 
         case("deformation_reduced_v_from_virial   "); do_it = TRUE 
         case("dft_eff_potential                   "); do_it = TRUE 
         case("dft_energy                          "); do_it = TRUE 
         case("dft_xc_potential                    "); do_it = TRUE 
         case("div_jp                              "); do_it = FALSE
         case("electric_potential                  "); do_it = FALSE
         case("electric_polarisation_density       "); do_it = TRUE
         case("electric_polarization_density       "); do_it = TRUE
         case("electron_density                    "); do_it = FALSE
         case("elf                                 "); do_it = FALSE
         case("e_hf_density_from_rho               "); do_it = FALSE
         case("eli_d                               "); do_it = FALSE
       ! case("energy_density_from_rho             "); do_it = TRUE 
         case("fermi_mobility                      "); do_it = FALSE
         case("g_kinetic_energy                    "); do_it = FALSE
         case("g_kirzhnits                         "); do_it = FALSE
         case("grad_rho_on_rho                     "); do_it = FALSE
         case("h_dft_energy                        "); do_it = FALSE
         case("h_kirzhnits                         "); do_it = FALSE
         case("h_from_virial                       "); do_it = FALSE
         case("hirshfeld_atom_grid                 "); do_it = FALSE
         case("hirshfeld_density                   "); do_it = FALSE
         case("hirshfeld_weight                    "); do_it = FALSE
         case("j                                   "); do_it = FALSE
         case("jd                                  "); do_it = FALSE
         case("jp                                  "); do_it = FALSE
         case("k_kinetic_energy                    "); do_it = FALSE
         case("laplacian                           "); do_it = FALSE
         case("local_ionisation_energy             "); do_it = FALSE
         case("negative_laplacian                  "); do_it = FALSE
       ! case("orbital_current_density             "); do_it = FALSE
         case("orbital_density                     "); do_it = FALSE
         case("orbital                             "); do_it = FALSE
         case("oscillator_orbital                  "); do_it = FALSE
         case("promolecule_density                 "); do_it = FALSE
         case("reduced_g_kinetic_energy            "); do_it = TRUE 
         case("reduced_h_from_virial               "); do_it = TRUE 
         case("reduced_k_kinetic_energy            "); do_it = TRUE 
         case("reduced_v_from_virial               "); do_it = TRUE 
         case("solenoidal_jp                       "); do_it = FALSE
       ! case("spin_current_density                "); do_it = FALSE
         case("spin_density                        "); do_it = FALSE
         case("spherical_atom_density              "); do_it = FALSE
         case("stockholder_density                 "); do_it = FALSE
         case("stockholder_weight                  "); do_it = FALSE
         case("true_fermi_mobility                 "); do_it = FALSE
         case("tsirelson_elf                       "); do_it = FALSE
         case("v_kirzhnits                         "); do_it = FALSE
         case("v_from_virial                       "); do_it = FALSE
         case default;                UNKNOWN(.plot_grid.plot_kind)
      end

      if (do_it) .set_up_becke_grid

   end

! ===========================
! Isosurface plotting methods
! ===========================

   isosurface_plot ::: leaky
   ! Do one of the many kinds of isosurface plot calculations
   ENSURE(.isosurface.created,"no isosurface")
      self :: target

      ! Below is required for selfless function calls
      saved_self => self ! Note this !

      ! Make the becke grids & overlapping atoms
      .set_up_becke_grid_info

      ! Set interpolators for stockholder or promolecule plots
      .set_interpolator_info(.isosurface.iso_kind)

      ! Set atom plot info for deformation densities
      .set_atom_plot_info(.isosurface.iso_kind)

      ! Assign natural orbitals
      if (.molecular_orbitals.created) .assign_NOs_to_MOs

      ! Do the plot
      .do_isosurface_plot

   end

   saved_isosurface_plot ::: leaky
   ! Do one of the many kinds of isosurface plot calculations, but using the
   ! .saved molecule information with the CURRENT .isosurface information.
   ! That is, the isosurface stored for this molecule is actually that for the
   ! .saved molecule.

   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.saved.created,"no saved molecule")

      saved_isosurface :: ISOSURFACE*

      ! Below is required for selfless function calls
      saved_self => .saved                  ! Note this !
      saved_isosurface => .saved.isosurface ! I'm not sure why this is necessary ==dylan
      .saved.isosurface => .isosurface      ! ... or this

      ! Set interpolators for stockholder or promolecule plots
      .saved.set_interpolator_info(.isosurface.iso_kind)

      ! Set atom plot info for deformation densities
      .saved.set_atom_plot_info(.isosurface.iso_kind)

      ! Assign natural orbitals
      if (.saved.molecular_orbitals.created) .saved.assign_NOs_to_MOs

      ! Do the plot
      .do_isosurface_plot

      ! Put back the saved isosurface?
      .saved.isosurface => saved_isosurface

   end

   do_isosurface_plot ::: private
   ! Do one of the many kinds of isosurface plot calculations
   ENSURE(.isosurface.created,"no isosurface")

      select case (.isosurface.iso_kind)
        case("bond_density_atom                "); .isosurface.cubify(MOLECULE::bond_density_atom_grid)
        case("bond_weight                      "); .isosurface.cubify(MOLECULE::bond_weight_grid)
        case("deformation_bond_density         "); .isosurface.cubify(MOLECULE::deformation_bond_density_grid)
        case("deformation_density              "); .isosurface.cubify(MOLECULE::deformation_density_grid)
        case("deformation_dft_eff_potential    "); .isosurface.cubify(MOLECULE::def_dft_eff_pot_grid)
        case("deformation_dft_energy           "); .isosurface.cubify(MOLECULE::def_dft_energy_grid)
        case("deformation_dft_xc_potential     "); .isosurface.cubify(MOLECULE::def_dft_xc_pot_grid)
        case("deformation_electric_potential   "); .isosurface.cubify(MOLECULE::def_e_pot_grid)
        case("deformation_g_kinetic_energy     "); .isosurface.cubify(MOLECULE::def_G_kinetic_grid)
        case("deformation_h_dft_energy         "); .isosurface.cubify(MOLECULE::def_H_dft_energy_grid)
        case("deformation_k_kinetic_energy     "); .isosurface.cubify(MOLECULE::def_K_kinetic_grid)
        case("deformation_laplacian            "); .isosurface.cubify(MOLECULE::def_laplacian_grid)
        case("dft_eff_potential                "); .isosurface.cubify(MOLECULE::dft_eff_pot_grid)
        case("dft_energy                       "); .isosurface.cubify(MOLECULE::dft_energy_grid)
        case("dft_xc_potential                 "); .isosurface.cubify(MOLECULE::dft_xc_pot_grid)
        case("electric_potential               "); .isosurface.cubify(MOLECULE::electric_potential_grid)
        case("electron_density                 "); .isosurface.cubify(MOLECULE::electron_density_grid)
        case("elf                              "); .isosurface.cubify(MOLECULE::ELF_grid)
        case("eli_d                            "); .isosurface.cubify(MOLECULE::ELI_D_grid)
        case("fermi_mobility                   "); .isosurface.cubify(MOLECULE::fermi_mobility_grid)
        case("grad_rho_on_rho                  "); .isosurface.cubify(MOLECULE::grad_rho_on_rho_grid)
        case("g_kinetic_energy                 "); .isosurface.cubify(MOLECULE::G_kinetic_energy_grid)
        case("h_dft_energy                     "); .isosurface.cubify(MOLECULE::H_dft_energy_grid)
        case("hirshfeld_density                "); .isosurface.cubify(MOLECULE::Hirshfeld_density_grid)
        case("hirshfeld_weight                 "); .isosurface.cubify(MOLECULE::Hirshfeld_density_grid)
        case("k_kinetic_energy                 "); .isosurface.cubify(MOLECULE::K_kinetic_energy_grid)
        case("laplacian                        "); .isosurface.cubify(MOLECULE::laplacian_grid)
        case("local_ionisation_energy          "); .isosurface.cubify(MOLECULE::local_ionisation_grid)
        case("orbital                          "); .isosurface.cubify(MOLECULE::orbital_grid)
        case("oscillator_orbital               "); .isosurface.cubify(MOLECULE::oscillator_orbital_grid)
        case("orbital_density                  "); .isosurface.cubify(MOLECULE::orbital_density_grid)
        case("promolecule_density              "); .isosurface.cubify(MOLECULE::promolecule_density_grid)
        case("spin_density                     "); .isosurface.cubify(MOLECULE::spin_density_grid)
        case("stockholder_density              "); .isosurface.cubify(MOLECULE::stockholder_density_grid)
        case("stockholder_weight               "); .isosurface.cubify(MOLECULE::Hirshfeld_density_grid)
        case("true_fermi_mobility              "); .isosurface.cubify(MOLECULE::true_fermi_mobility_grid)
        case("tsirelson_elf                    "); .isosurface.cubify(MOLECULE::Tsirelson_ELF_grid)
        case default;                UNKNOWN(.isosurface.iso_kind)
      end

   end


   plot_on_isosurface ::: leaky
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface===useful for mapping properties on a surface.
   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.surface_property/=" ","no isosurface surface_property specified")
      self :: target

      ! Below is required for selfless function calls
      saved_self => self ! Note this !

      ! Make the becke grids & overlapping atoms
      .set_up_becke_grid_info

      ! Set interpolators for stockholder or promolecule plots
      .set_interpolator_info(.isosurface.surface_property)

      ! Set atom plot info for deformation densities
      .set_atom_plot_info(.isosurface.surface_property)

      ! Assign NO's to MO's?
      if (.natural_orbitals.destroyed) then
      if (.molecular_orbitals.created) then
         .assign_NOs_to_MOs
      end
      end

      ! Do the plot
      .do_plot_on_isosurface

   end

   saved_plot_on_isosurface ::: leaky
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface===useful for mapping properties on a surface===but using the
   ! .saved molecule information for the density functions which are evaluated
   ! and stored on the current .isosurface.
   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.surface_property/=" ","no isosurface surface_property specified")
   ENSURE(.saved.created,"no saved molecule")
      saved_isosurface :: ISOSURFACE*

      ! Below is required for selfless function calls
      saved_self => .saved                  ! Note this !
      saved_isosurface => .saved.isosurface ! I'm not sure why this is necessary ==dylan
      .saved.isosurface => .isosurface      ! ... or this

      ! Set up preliminaries for some plots
      .saved.set_interpolator_info(.isosurface.surface_property)
      .saved.set_atom_plot_info(.isosurface.surface_property)
      if (.saved.molecular_orbitals.created) .saved.assign_NOs_to_MOs

      ! Do the plot
      .do_plot_on_isosurface

      ! Put back the saved isosurface?
      .saved.isosurface => saved_isosurface

   end

   do_plot_on_isosurface ::: private
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface===useful for mapping properties on a surface.
      select case (.isosurface.surface_property)
        case("bond_density_atom               "); .isosurface.plot_function(MOLECULE::bond_density_atom_grid)
        case("deformation_bond_density        "); .isosurface.plot_function(MOLECULE::deformation_bond_density_grid)
        case("deformation_density             "); .isosurface.plot_function(MOLECULE::deformation_density_grid)
        case("deformation_dft_eff_potential   "); .isosurface.plot_function(MOLECULE::def_dft_eff_pot_grid)
        case("deformation_dft_energy          "); .isosurface.plot_function(MOLECULE::def_dft_energy_grid)
        case("deformation_dft_xc_potential    "); .isosurface.plot_function(MOLECULE::def_dft_xc_pot_grid)
        case("deformation_electric_potential  "); .isosurface.plot_function(MOLECULE::def_e_pot_grid)
        case("deformation_g_kinetic_energy    "); .isosurface.plot_function(MOLECULE::def_G_kinetic_grid)
        case("deformation_h_dft_energy        "); .isosurface.plot_function(MOLECULE::def_H_dft_energy_grid)
        case("deformation_k_kinetic_energy    "); .isosurface.plot_function(MOLECULE::def_K_kinetic_grid)
        case("deformation_laplacian           "); .isosurface.plot_function(MOLECULE::def_laplacian_grid)
        case("dft_eff_potential               "); .isosurface.plot_function(MOLECULE::dft_eff_pot_grid)
        case("dft_energy                      "); .isosurface.plot_function(MOLECULE::dft_energy_grid)
        case("dft_xc_potential                "); .isosurface.plot_function(MOLECULE::dft_xc_pot_grid)
        case("electric_potential              "); .isosurface.plot_function(MOLECULE::electric_potential_grid)
        case("electron_density                "); .isosurface.plot_function(MOLECULE::electron_density_grid)
        case("elf                             "); .isosurface.plot_function(MOLECULE::ELF_grid)
        case("eli_d                           "); .isosurface.plot_function(MOLECULE::ELI_D_grid)
        case("fermi_mobility                  "); .isosurface.plot_function(MOLECULE::fermi_mobility_grid)
        case("g_kinetic_energy                "); .isosurface.plot_function(MOLECULE::G_kinetic_energy_grid)
        case("grad_rho_on_rho                 "); .isosurface.plot_function(MOLECULE::grad_rho_on_rho_grid)
        case("h_dft_energy                    "); .isosurface.plot_function(MOLECULE::H_dft_energy_grid)
        case("hirshfeld_density               "); .isosurface.plot_function(MOLECULE::Hirshfeld_density_grid)
        case("hirshfeld_weight                "); .isosurface.plot_function(MOLECULE::Hirshfeld_density_grid)
        case("k_kinetic_energy                "); .isosurface.plot_function(MOLECULE::K_kinetic_energy_grid)
        case("laplacian                       "); .isosurface.plot_function(MOLECULE::laplacian_grid)
        case("local_ionisation_energy         "); .isosurface.plot_function(MOLECULE::local_ionisation_grid)
        case("orbital                         "); .isosurface.plot_function(MOLECULE::orbital_grid)
        case("oscillator_orbital              "); .isosurface.plot_function(MOLECULE::oscillator_orbital_grid)
        case("orbital_density                 "); .isosurface.plot_function(MOLECULE::orbital_density_grid)
        case("promolecule_density             "); .isosurface.plot_function(MOLECULE::promolecule_density_grid)
        case("spin_density                    "); .isosurface.plot_function(MOLECULE::spin_density_grid)
        case("stockholder_density             "); .isosurface.plot_function(MOLECULE::stockholder_density_grid)
        case("stockholder_weight              "); .isosurface.plot_function(MOLECULE::Hirshfeld_density_grid)
        case("true_fermi_mobility             "); .isosurface.plot_function(MOLECULE::true_fermi_mobility_grid)
        case("tsirelson_elf                   "); .isosurface.plot_function(MOLECULE::Tsirelson_ELF_grid)
        case default;                UNKNOWN(.isosurface.surface_property)
      end
   end


   bond_density_atom_grid(g,pt) ::: selfless
   ! Work out the bond density atom grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_bond_density_atom_grid(g,pt,.isosurface.plot_grid.bond_density_atom(1))
   end

   bond_weight_grid(g,pt) ::: selfless
   ! Work out the bond weight grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_bond_weight_grid(g,pt,.isosurface.plot_grid.bond_density_atom)
   end

   deformation_bond_density_grid(g,pt) ::: selfless
   ! Work out the deformation bond density grid "g" for the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_bond_density_grid(g,pt,.isosurface.plot_grid.bond_density_atom)
   end

   deformation_density_grid(g,pt) ::: selfless
   ! Work out the electron deformation density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_deformation_density_grid(g,pt)
   end

   def_e_pot_grid(g,pt) ::: selfless
   ! Work out the deformation electric potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_e_pot_grid(g,pt)
   end

   def_H_dft_energy_grid(g,pt) ::: selfless
   ! Work out the deformation slater H energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_H_dft_energy_grid(g,pt)
   end

   def_G_kinetic_grid(g,pt) ::: selfless
   ! Work out the deformation G-type kinetic density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_G_kinetic_grid(g,pt)
   end

   def_K_kinetic_grid(g,pt) ::: selfless
   ! Work out the deformation K-type kinetic density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_K_kinetic_grid(g,pt)
   end

   def_laplacian_grid(g,pt) ::: selfless
   ! Work out the deformation laplacian density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_laplacian_grid(g,pt)
   end

   def_dft_eff_pot_grid(g,pt) ::: selfless
   ! Work out the deformation DFT effective potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_dft_eff_pot_grid(g,pt)
   end

   def_dft_xc_pot_grid(g,pt) ::: selfless
   ! Work out the deformation DFT exchange corelation density grid "g" for a the
   ! points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_dft_xc_pot_grid(g,pt)
   end

   def_dft_energy_grid(g,pt) ::: selfless
   ! Work out the deformation DFT energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_dft_energy_grid(g,pt)
   end

   electron_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_density_grid(g,pt)
   end

   spin_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals" and ".occupation_numbers" vector.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
   !  .make_ao_sz_density_matrix
   !  .make_natural_orbitals("restricted")
      .make_density_grid(g,pt,sgn=-1)
   end

   G_kinetic_energy_grid(g,pt) ::: selfless
   ! Work out the G-type kinetic energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_G_kinetic_energy_grid(g,pt)
   end

   K_kinetic_energy_grid(g,pt) ::: selfless
   ! Work out the K-type kinetic energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_K_kinetic_energy_grid(g,pt)
   end

   H_dft_energy_grid(g,pt) ::: selfless
   ! Work out the H-type DFT energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_H_dft_energy_grid(g,pt)
   end

   laplacian_grid(g,pt) ::: selfless
   ! Work out the laplacian density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_laplacian_grid(g,pt)
   end

   dft_eff_pot_grid(g,pt) ::: selfless
   ! Work out the DFT effective potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_dft_eff_pot_grid(g,pt)
   end

   dft_xc_pot_grid(g,pt) ::: selfless
   ! Work out the DFT exchange corelation density grid "g" for a the
   ! points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_dft_xc_pot_grid(g,pt)
   end

   dft_energy_grid(g,pt) ::: selfless
   ! Work out the DFT energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_dft_energy_grid(g,pt)
   end

   local_ionisation_grid(g,pt) ::: selfless
   ! Work out the local ionisation grid "g" for a series of points "pt"
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_local_ionisation_grid(g,pt)
   end

   orbital_density_grid(g,pt) ::: selfless
   ! Work out the orbital density grid "g" for a series of points "pt" for using
   ! the ".natural orbitals", for a partcular orbital .plot_grid.orbital.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      gc :: VEC{CPX}*
      n_pt,orb :: INT
      grid :: PLOT_GRID*
      self :: MOLECULE*; self => saved_self

      n_pt = pt.dim1
      grid => .isosurface.plot_grid

      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0 ) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                 orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end

      if (trim(.natural_orbitals.number_kind)== "real") then
         .make_orbital_grid_r(g,.natural_orbitals.restricted(:,orb),pt,square=TRUE)
      else
         gc.create(n_pt)
         .make_orbital_grid_c(gc,.natural_orbitals.restricted_complex(:,orb),pt,square=TRUE)
         g = RE(gc)
         gc.destroy
      end

   end

   orbital_grid(g,pt) ::: selfless
   ! Work out the orbital grid "g" for a series of points "pt" for using
   ! the ".natural orbitals", for a partcular orbital .plot_grid.orbital.
   ! NOTE: for complex orbitals, the absolute value times the sign of
   ! the complex part
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      gc :: VEC{CPX}*
      n_pt,orb :: INT
      grid :: PLOT_GRID*
      self :: MOLECULE*; self => saved_self

      n_pt = pt.dim1
      grid => .isosurface.plot_grid
      orb = grid.orbital

      if (orb==0) then
         if      (grid.HOMO_orbital/=0 ) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                 orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end

      if (trim(.natural_orbitals.number_kind)== "real") then
         .make_orbital_grid_r(g,.natural_orbitals.restricted(:,orb),pt)
      else
         gc.create(n_pt)
         .make_orbital_grid_c(gc,.natural_orbitals.restricted_complex(:,orb),pt)
         g = sign(RE(gc),IM(gc))
         gc.destroy
      end

   end

   oscillator_orbital_grid(g,pt) ::: selfless
   ! Work out the oscillator orbital grid "g" for a series of points "pt" for
   ! using the ".natural orbitals", for a partcular orbital .plot_grid.orbital.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN

   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.plot_grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.localiser.created, "no localiser orbject created")

      orb :: INT
      grid :: PLOT_GRID*
      self :: MOLECULE*; self => saved_self

      grid => .isosurface.plot_grid

      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end

      if (trim(.natural_orbitals.number_kind)== "real") then
         .make_oscillator_orbital_grid_r(g,orb,pt)
      else
         DIE("complex case not yet implemented")
      end

   end

   ELI_D_grid(g,pt) ::: selfless
   ! Work out the Electron Localisation Indicator (ELI-D) density "g" for a series
   ! of points "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_ELI_D_grid(g,pt)
   end

   ELF_grid(g,pt) ::: selfless
   ! Work out the Electron Localisation Function (ELF) density "g" for a series
   ! of points "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_ELF_grid(g,pt)
   end

   grad_rho_on_rho_grid(g,pt) ::: selfless
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_grad_rho_on_rho_grid(g,pt)
   end

   Tsirelson_ELF_grid(g,pt) ::: selfless
   ! Work out the Tsirelson-Stash version of the Electron Localisation Function
   ! (ELF) density "g" for a series of points "pt" for using the ".natural
   ! orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_Tsirelson_ELF_grid(g,pt)
   end

   fermi_mobility_grid(g,pt) ::: selfless
   ! Work out the Luken's fermi mobility density on a series of grid points "g"
   ! using ".natural orbitals" and the ".occupation_numbers" vector. A Gnuplot
   ! ascii file is generated.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_fermi_mobility_grid(g,pt)
   end

   true_fermi_mobility_grid(g,pt) ::: selfless
   ! Work out the Luken's true fermi mobility density (the one using kinetic
   ! energy matrix elements) on a series of grid points "g" using ".natural
   ! orbitals" and the ".occupation_numbers" vector. A Gnuplot ascii file is
   ! generated.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_true_fermi_mobility_grid(g,pt)
   end

   electric_potential_grid(g,pt) ::: selfless
   ! Make the electric potential grid "g" on a series of points "pt"
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_electric_potential_grid(g,pt)
   end

   stockholder_density_grid(g,pt) ::: selfless
   ! Work out the Hirshfeld stockholder density grid "g" for a series of points.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_stockholder_density_grid(g,pt)
   end

   Hirshfeld_density_grid(g,pt) ::: selfless
   ! Work out the Hirshfeld density grid "g" for a series of points.
   ! WARNING: this version cuts corners.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_Hirshfeld_density_grid(g,pt)
   end

   promolecule_density_grid(g,pt) ::: selfless
   ! Work out the promolecule density grid "g" for a series of points.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_promolecule_density_grid(g,pt)
   end

!   promolecule_d_density_grid(g,dg,d2g,pt) ::: selfless
!   ! Work out the promolecule density grid "g", its derivative "dg", and second
!   ! derivative "d2g" for a series of points "pt".
!      g   :: VEC{REAL}, OUT
!      dg  :: MAT{REAL}, OUT
!      d2g :: MAT3{REAL}, OUT
!      pt  :: MAT{REAL}, IN
!      self :: MOLECULE*; self => saved_self
!      .make_promolecule_density_grid(g,dg,d2g,pt)
!   end

! ============================
! Vibrationally averaged grids
! ============================

   get_vib_averaged_rho_grid(density_grid)
   ! Set "density_grid" to the vibrationally averaged electron density grid.
   ! If the archive file exists, read it; otherwise make it.
      density_grid :: VEC{REAL}
   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.n_atom==2,"can only do diatomics")
      arch :: ARCHIVE
      arch.set_defaults
      arch.set(.name,"vib_averaged_rho_grid")
      if (NOT arch.exists) .make_vib_averaged_rho_grid
      arch.read(density_grid)
   end

   make_vib_averaged_rho_grid
   ! Work out the averaged density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.plot_grid.created,  "no grid")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.n_atom==2,"can only do diatomics")
      arch :: ARCHIVE
      density_grid :: VEC{REAL}*
      .move_origin_to_centre_of_mass
      density_grid.create(.plot_grid.n_pt)
      .integrate_rho_grid(density_grid,-FOUR,FOUR,TOL(4))
      arch.set(.name,"vib_averaged_rho_grid")
      arch.write(density_grid)
      arch.set(.name,"vib_averaged_rho_grid",format="ascii")
      arch.write_gnuplot(density_grid, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
      density_grid.destroy
   end

   integrate_rho_grid(res,a,b,accuracy,fa0,fb0) ::: recursive
   ! Integrate the rho grid between the limits "a" and "b" using adaptive
   ! trapezoidal rule with Simpsons approximation.  If present, "accuracy"
   ! is the required accuracy of the integral. If present, "fa0" and
   ! "fb0" are the value of the rho_grid at "a" and "b" respectively.
   ! size of "res" is .plot_grid.n_pt.
      a,b :: REAL
      accuracy :: REAL, optional
      fa0,fb0 :: VEC{REAL}*, optional
      res :: VEC{REAL}*
   ENSURE(.plot_grid.created, "no grid")
      fa,fb,fm,one_trap,two_trap,left,right :: VEC{REAL}*
      n_pt :: INT
      same :: BIN
      tol,h,m :: REAL
      depth :: INT = 0
      n_pt = .plot_grid.n_pt
      depth = depth+1
      stdout.show("depth =",depth)
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h  = b-a
      m  = (a+b)/TWO
      if (present(fb0)) then; fb => fb0
      else;                   fb.create(n_pt); .make_rho_grid_at(b,fb)
      end
      if (present(fa0)) then; fa => fa0
      else;                   fa.create(n_pt); .make_rho_grid_at(a,fa)
      end
      fm.create(n_pt);    .make_rho_grid_at(m,fm)
      one_trap.create(n_pt)
      two_trap.create(n_pt)
      one_trap = h*(fa+fb)/TWO
      two_trap = h*(fa+TWO*fm+fb)/FOUR
      res = abs(one_trap-two_trap)
      same = maxval(res) < THREE*tol
      if (same AND depth>1) then
        res = (FOUR*two_trap - one_trap)/THREE
        two_trap.destroy
        one_trap.destroy
        fm.destroy
        fa.destroy
      else
        two_trap.destroy
        one_trap.destroy
        left.create(n_pt);  .integrate_rho_grid(left ,a,m,tol/TWO,fa0=fa,fb0=fm)
        right.create(n_pt); .integrate_rho_grid(right,m,b,tol/TWO,fa0=fm,fb0=fb)
        res = left + right
        right.destroy
        left.destroy
      end
      if (depth==1) fb.destroy
      depth = depth-1
   end

   make_rho_grid_at(q,rho)
   ! Work out the electron density on ".plot_grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector at nuclear separation "q", where "q" is a
   ! dimensionless normal coordinate
   ! size or "rho" is .plot_grid.n_pt.
      q :: REAL
      rho :: VEC{REAL}
      pt :: MAT{REAL}*
      re,w,mu, gamma,d,r, wt :: REAL
      n :: INT
      re = 2.0460259 ! N2
      w  = 2708      ! N2
      re = 1.3848617 ! H2
      w  = 4658      ! H2
      mu = .reduced_mass
      n = 1
      gamma = sqrt((w/WAVENUMBER_PER_HARTREE) &
                  * mu * MASS_OF_ELECTRON_PER_AMU ) ! This is gamma^(1/2)
      d = q/gamma ! d is the cartesian displacement in Bohr
      r = re + d  ! r is the actual separation of atoms in Bohr
      stdout.show("q =",q)
      stdout.show("d =",d)
      stdout.show("r =",r)
      stdout.show("g =",gamma)
      .atom(1).set_position([ZERO,ZERO,-HALF*r])
      .atom(2).set_position([ZERO,ZERO, HALF*r])
      .move_origin_to_centre_of_mass
      .delete_scf_integrals
      .scf
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
      .make_density_grid(rho,pt)
      pt.destroy
      wt = q.harmonic_vibrational_fn(n)
      wt = wt*wt
      rho = wt * rho
   end

! =====================
! Roby analysis methods
! =====================

   roby_analysis ::: leaky
   ! Do one of the many kind of Roby population analysis
   ENSURE(.roby.created,"no robydata= supplied")
   ENSURE(.density_matrix.created,"no density")

      allowed_kind :: BIN
      allowed_kind =  .density_matrix.spinorbital_kind=="restricted" &
                  OR .density_matrix.spinorbital_kind=="unrestricted"
   ENSURE(allowed_kind,"only restricted or unrestricted densities are allowed")

      .make_ANO_data

      select case (.roby.roby_kind)
         case("atom_bond_analysis     "); .roby.atom_bond_analysis      ! This is a main option
         case("atom_shared_population "); .roby.atom_shared_population
         case("atom_pair_populations  "); .roby.atom_pair_populations
         case("atom_populations       "); .roby.atom_populations
         case("group_bond_analysis    "); .roby.group_bond_analysis     ! This is a main option
         case("group_shared_population"); .roby.group_shared_population
         case("group_pair_populations "); .roby.group_pair_populations
         case("group_populations      "); .roby.group_populations
         case default;                UNKNOWN(.roby.roby_kind)
      end

   end

!  =================================================
!  ANO/interpolator/atom shell info control routines
!  =================================================

   make_ANO_data ::: leaky
   ! Get the restricted atomic natural orbitals (ANO) data for all
   ! atoms in the molecule.

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      kind,a,b :: INT
      atom_a,atom_b :: ATOM*

      .atom.set_basis_kind("gaussian")

      if (.atom(1).ANO_data_made) return

      stdout.flush
      stdout.text("Making gaussian ANO data ...")

      do a = 1,.n_atom

         atom_a => .atom(a)

         ! Unique atom?
         if (NOT atom_a.is_unique_kind) cycle

         kind = atom_a.kind
         .make_ANO_data_for_atom(a) 

         .put_debug(atom_a.density_matrix,"make_ANO_data")

         ! Set atoms of same kind
         do b = a+1,.n_atom

            atom_b => .atom(b)

            if (atom_b.kind/=kind) cycle

            atom_b.density_matrix     => atom_a.density_matrix
            atom_b.natural_orbitals   => atom_a.natural_orbitals
            atom_b.occupation_numbers => atom_a.occupation_numbers
            atom_b.atomic_orbitals    => atom_a.atomic_orbitals
            atom_b.set_energy(atom_a.energy)

         end

      end

      .atom.set_ANO_data_made(TRUE)


   end

   make_ANO_data_for_atom(a) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a".
      a :: INT

   ENSURE(.atom(a).natural_orbitals.destroyed,  "NO's exist for atom "       //trim(a.to_str))
   ENSURE(.atom(a).occupation_numbers.destroyed,"occupations exist for atom "//trim(a.to_str))
   ENSURE(.atom(a).density_matrix.destroyed,    "density exists for atom "   //trim(a.to_str))

      mol :: MOLECULE*
      atom_a :: ATOM*

      ! Create the molecule
      mol.create
      .make_molecule_from_atom(a,mol)

      ! Reset some SCF options
      mol.scfdata.set_using_direct_scf(TRUE) ! use direct scf
      mol.scfdata.set_is_guess(TRUE)         ! don't use cluster charges
      mol.scfdata.set_delete_all_archives(TRUE)

      ! Do the atomic SCF
      mol.scf

      ! Spherically average the AO density
      mol.make_ao_density_matrix
      mol.pointgroup.create("oh",.use_spherical_basis)
      mol.symmetrise(mol.density_matrix)

      ! Make the natural orbitals ... leaky
      mol.make_natural_orbitals 

      ! Clean up the SCF files
      mol.delete_scf_MO_archive
      mol.delete_scf_integrals

      ! Destroy the atoms's NO  ... leaky
      atom_a => .atom(a)
      atom_a.atomic_orbitals.destroy
      atom_a.density_matrix.destroy
      atom_a.occupation_numbers.destroy
      atom_a.natural_orbitals.destroy

      ! Copy the results
      atom_a.natural_orbitals   => mol.natural_orbitals
      atom_a.occupation_numbers => mol.occupation_numbers
      atom_a.density_matrix     => mol.density_matrix
      atom_a.atomic_orbitals    => mol.molecular_orbitals
      atom_a.set_energy(mol.scfdata.energy)

      ! Debugging
      if (.debugging("make_ANO_data_for_atom")) then
         stdout.show("atom =",a)
         stdout.text("atomic orbitals :")
         stdout.put(.atom(a).atomic_orbitals)
      end

      ! Nullify parts we just copied or can't destroy
      mol.atom.nullify_ptr_part       ! do not destroy ptr part
      nullify(mol.natural_orbitals)   ! do not destroy this
      nullify(mol.occupation_numbers) ! do not destroy this
      nullify(mol.density_matrix)     ! do not destroy this
      nullify(mol.molecular_orbitals) ! do not destroy this
      nullify(mol.basis)              ! do not destroy this
      nullify(mol.slaterbasis)        ! do not destroy this
      nullify(mol.coppensbasis)       ! do not destroy this

      ! Safe to destroy
      mol.destroy

   end

   destroy_ANO_data ::: leaky
   ! Destroy the ANO data for all atoms in the molecule.

   ENSURE(.atom.created,"no atoms")

      if (NOT .atom(1).ANO_data_made) return
      .atom.destroy_ANO_data

   end

   put_ANO_data ::: leaky
   ! Destroy the restricted atomic natural orbitals (ANO) data for
   ! all atoms in the molecule.
   ENSURE(.atom.created,"no atoms")

      k,a,b :: INT
      list :: STR

      if (NOT .atom(1).ANO_data_made) return

      if (.n_atom_kind<=0) return

      stdout.flush
      stdout.text("========")
      stdout.text("ANO data")
      stdout.text("========")

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle
         k = .atom(a).kind

         list = trim(a.to_str)
         do b = a+1,.n_atom
            if (.atom(b).kind/=k) cycle
            list = trim(list)//" "//trim(b.to_str)
         end
         list = "ANO's for atoms ... "//trim(list)

         stdout.flush
         stdout.text(repeat("=",len_trim(list)))
         stdout.text(list)
         stdout.text(repeat("=",len_trim(list)))
         .atom(a).put_ANO_data
         stdout.flush

      end

   end


   make_ANO_interpolators ::: leaky
   ! Get the gaussian ANO interpolators

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom(1).ANO_data_made,"no ANO data")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      template :: INTERPOLATOR*
      kind,a,b :: INT
      atom_a,atom_b :: ATOM*

      if (.atom(1).ANO_interpolators_made) return
      if (.atom(1).interpolators_made) return

      stdout.flush
      stdout.text("Making gaussian ANO interpolators ...")

      do a = 1,.n_atom

         atom_a => .atom(a)

         ! Unique atom?
         if (NOT atom_a.is_unique_kind) cycle

         kind = atom_a.kind

         ! Make the interpolator
         if (.interpolator.created) then 
            atom_a.make_interpolator(.interpolator)
         else
            .make_interpolator_sqrt_x1x(template)
            atom_a.make_interpolator(template)
            template.destroy
         end

        ! Copy to the other atoms
        do b = a+1,.n_atom

           atom_b => .atom(b)

           if (atom_b.kind/=kind) cycle

           atom_b.interpolator => atom_a.interpolator

        end

      end

      .atom.set_ANO_interpolators_made(TRUE)

   end

   destroy_ANO_interpolators ::: leaky
   ! Destroy the ANO interpolators 

   ENSURE(.atom.created,"no atoms")

      if (NOT .atom(1).ANO_interpolators_made) return
      .atom.destroy_ANO_interpolators

   end

   destroy_interpolators ::: leaky
   ! Destroy the interpolators (not ANO interpolators)

   ENSURE(.atom.created,"no atoms")

      if (NOT .atom(1).interpolators_made) return
      .atom.destroy_interpolators

   end


   make_atom_shell_info ::: leaky
   ! Get the atom shell info for all atoms in the molecule. We make it
   ! only for the unique atoms and pointer copy to the non-unique
   ! atoms, just like for ANO atom information.
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.basis.created,"no basis set")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      kind,a,b :: INT
      atom_a,atom_b :: ATOM*

      if (.atom(1).shell_info_made) return

      ! Destroy ...  in case .ANO_data_made 
      ! was deliberately set FALSE
      .destroy_atom_shell_info

      do a = 1,.n_atom

         atom_a => .atom(a)

         ! Unique atom?
         if (NOT atom_a.is_unique_kind) cycle

         kind = atom_a.kind
         atom_a.make_shell_info
 
         ! Copy it to nonunique atoms
         do b = a+1,.n_atom

            atom_b => .atom(b)

            if (atom_b.kind/=kind) cycle

            atom_b.first_basis_fn_for_shell    => atom_a.first_basis_fn_for_shell
            atom_b.last_basis_fn_for_shell     => atom_a.last_basis_fn_for_shell
            atom_b.precomputed_basis_shellpair => atom_a.precomputed_basis_shellpair

         end

      end

      .atom.set_shell_info_made(TRUE)

   end

   destroy_atom_shell_info ::: leaky
   ! Destroy the atom precomputed shellpair info.

   ENSURE(.atom.created,"no atoms")

      if (NOT .atom(1).shell_info_made) return
      .atom.destroy_shell_info

   end

!  =============================================
!  Spherically average atoms in existing density
!  =============================================

   get_spherical_atoms ::: leaky
   ! Get the spherical atom natural orbitals (ANO) data for all
   ! atoms in the molecule.

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_matrix.created,"no density_matrix")
   ENSURE(.density_matrix.any_created,"no density_matrix")

      D :: OPMATRIX*
      genre :: STR
      a :: INT

      if (.atom(1).spherical_atom_data_made) return

      if (.atom(1).ANO_data_made) .destroy_ANO_data

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .molecular_orbitals.spinorbital_kind
      end

      ! Copy existing density matrix
      D.create(.n_bf,genre)
      D.create_copy(.density_matrix)

      ! Make the restricted density matrix
      .make_ao_density_matrix(D)


      ! Spherically average the molecule AO density
      do a = 1,.n_atom
        .spherically_average_atom(a,D.restricted)
      end
      D.destroy

      .atom.set_spherical_atom_data_made(TRUE)

   end

   spherically_average_atom(a,D) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a" from
   ! a given (real) density matrix "D".
      a :: INT
      D :: MAT{REAL}

   ENSURE(.atom(a).natural_orbitals.destroyed,"NO's exist, atom "//trim(a.to_str))
   ENSURE(.atom(a).occupation_numbers.destroyed,"occupations exist, atom "//trim(a.to_str))
   ENSURE(.atom(a).density_matrix.destroyed,"density exists, atom "//trim(a.to_str))

      f,l :: INT
      mol :: MOLECULE*

      ! Create the molecule
      mol.create
      .make_molecule_from_atom(a,mol)

      ! Get the density matrix
      mol.density_matrix.create(mol.n_bf)
      mol.density_matrix.create(genre="restricted")
      f = .first_basis_fn_for_atom(a)
      l =  .last_basis_fn_for_atom(a)
      mol.density_matrix.restricted = D(f:l,f:l)

      ! Spherically average the AO density
      mol.pointgroup.create("oh",.use_spherical_basis)
      mol.symmetrise(mol.density_matrix)

      ! Make the natural orbitals
      mol.make_natural_orbitals 

      ! Clean up the SCF files
      mol.delete_archive("natural_orbitals")
      mol.delete_archive("occupation_numbers")

      ! Destroy the atoms's NO and interpolator info
      .atom(a).interpolator.destroy
      .atom(a).density_matrix.destroy
      .atom(a).occupation_numbers.destroy
      .atom(a).natural_orbitals.destroy

      ! Copy the results
      .atom(a).natural_orbitals   => mol.natural_orbitals
      .atom(a).occupation_numbers => mol.occupation_numbers
      .atom(a).density_matrix     => mol.density_matrix

      ! Make the interpolator
      .atom(a).make_interpolator

      ! Nullify parts we just copied or can't destroy
      mol.atom.nullify_ptr_part       ! do not destroy ptr part
      nullify(mol.natural_orbitals)   ! do not destroy this
      nullify(mol.occupation_numbers) ! do not destroy this
      nullify(mol.density_matrix)     ! do not destroy this
      nullify(mol.basis)              ! do not destroy this
      nullify(mol.slaterbasis)        ! do not destroy this
      nullify(mol.coppensbasis)       ! do not destroy this

      ! Safe to destroy
      mol.destroy

   end

   destroy_spherical_atom_data ::: leaky
   ! Destroy the restricted atomic natural orbitals (ANO) data for
   ! all atoms in the molecule.

   ENSURE(.atom.created,"no atoms")

      if (NOT .atom(1).spherical_atom_data_made) return
      .atom.destroy_spherical_atom_data

   end


!  =======================
!  Core structure factors
!  =======================

   make_core_structure_factors ::: leaky
   ! Make em!

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.n_atom_kind>0,"no atom kinds")
   ENSURE(.crystal.created,"no crystal information!")
   ENSURE(.crystal.xray_data.created,"no crystal xray data!")
   ENSURE(.crystal.xray_data.reflections.created,"no crystal xray data reflection!")

      AO :: OPMATRIX*
      k_pt,D,AO_core :: MAT{REAL}*
      k1,k2,k3  :: VEC{REAL}*
      ra,diff :: VEC{REAL}(3)
      F_calc,core,phase :: VEC{CPX}*
      mol :: MOLECULE*
      II  :: CPX
      n_k,n_core,n_bf,k,a,b,n :: INT

      ! Complex i
      II = cmplx(ZERO,ONE)

      ! Make ANO data if not already there ...
      .make_ANO_data                            ! <== leaky

      ! Create space for the core reflections
      .crystal.core_reflection.destroy          ! <== leaky
      .crystal.core_reflection.create(.crystal.xray_data.reflections.dim)

      ! Space for k points
      n_k = .crystal.xray_data.reflections.dim
      k_pt.create(n_k,3)     

      ! Make k points and components k1, k2, k3 ...
      .crystal.make_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! Make space for F_calc 
      F_calc.create(n_k)
      F_calc = ZERO

      ! Make space for translation phases
      phase.create(n_k)

      ! Get core structure factors 
      ! *only for unique atoms*
      do a = 1,.n_atom

        ! Unique atom?
        if (NOT .atom(a).is_unique_kind) cycle
        k = .atom(a).kind

        ! Skip H atoms they have no core!
        if (.atom(a).atomic_number<=1) cycle

        ! No. of core orbitals
        n_core = .atom(a).n_core_electrons/2

        ! No. of basis functions for atom u
        n_bf = .atom(a).n_bf

        ! Space for the core density matrix
        D.create(n_bf,n_bf)

        ! Atomic orbitals
        AO => .atom(a).atomic_orbitals

        ! Make core density matrix
        if (AO.restricted.created) then

           ! Core atomic orbitals
           AO_core => .atom(a).atomic_orbitals.restricted(:,1:n_core)

           ! Make the core density matrix
           D.to_product_of(AO_core,AO_core,transpose_b=TRUE)

        else if (AO.alpha.created) then

           ! Alpha core part
           AO_core => .atom(a).atomic_orbitals.alpha(:,1:n_core)
           D.to_product_of(AO_core,AO_core,transpose_b=TRUE)

           ! Beta core part
           AO_core => .atom(a).atomic_orbitals.beta(:,1:n_core)
           D.plus_product_of(AO_core,AO_core,transpose_b=TRUE)

        end

        ! Make a molecule from atom a
        mol.create
        .make_molecule_from_atom(a,mol)

        ! Make the core spherical
        mol.pointgroup.create("oh",.use_spherical_basis)
        mol.symmetrise(D)

        ! Duplicate crystal information into this mol
        mol.crystal.create_copy(.crystal)

        ! Make the core structure factors
        mol.crystal.assign_xray
        mol.crystal.xray_data.optimise_scale      = FALSE
        mol.crystal.xray_data.optimise_extinction = FALSE
        mol.crystal.xray_data.correct_dispersion  = FALSE
        mol.make_x_structure_factors_h(D)
        D.destroy

        ! Make a copy of atom u's core structure factors
        core.create_copy(mol.crystal.xray_data.reflections(:).F_calc)

        ! Nullify parts we just copied or can't destroy
        mol.atom.nullify_ptr_part       ! do not destroy ptr part
        nullify(mol.basis)              ! do not destroy this
        nullify(mol.slaterbasis)        ! do not destroy this
        nullify(mol.coppensbasis)       ! do not destroy this

        ! Safe to destroy
        mol.destroy

        ! Add in the core reflections for atom u
        F_calc = F_calc + core

        ! Store atom u position
        ra = .atom(a).position

        ! Loop over other equivalent atoms; add core contributions
        do b = a+1,.n_atom

           if (.atom(b).kind/=k) cycle

           ! Difference between atom u and atom j position
           diff = .atom(b).position - ra

           ! Make the phase shifts
           do n = 1,n_k
              phase(n) = exp(II*(k1(n)*diff(1)+k2(n)*diff(2)+k3(n)*diff(3)))
           end

           ! Add the structure factors in
           F_calc = F_calc + phase*core

        end

      end

      ! Set the crystal core structure factors
      .crystal.core_reflection(:).F_calc = F_calc

      ! Clean up
      phase.destroy
      F_calc.destroy
      k_pt.destroy

   end


! ==========================================
! Roby Energy and Shared Energy calculations
! ==========================================

!   roby_energy_analysis
!   ! directs the energy analysis of a diatomic
!    roby_atom :: VEC{INT}*
!    Ep_A, Ep_B, Ep_AB, E_A, E_B, E_AB :: REAL
!    a,b :: INT
!    .read_roby_atom(roby_atom)
!    ENSURE( size(roby_atom)==2, "Must supply a diatomic...")
!    a = roby_atom(1); b=roby_atom(2)
!    .put_roby_atom_energy( (/ a /) )
!    .put_roby_atom_energy( (/ b /) )
!    .put_roby_atom_energy( roby_atom )
!    Ep_A = .roby_atom_energy( (/a/))
!    Ep_B = .roby_atom_energy( (/b/))
!    Ep_AB = .roby_atom_energy( roby_atom)
!    E_A = .roby_total_atom_energy((/ a /), nuclei=roby_atom,output=TRUE)
!    E_B = .roby_total_atom_energy((/ b /), nuclei=roby_atom,output=TRUE)
!    E_AB = .roby_total_atom_energy(roby_atom, nuclei=roby_atom,output=TRUE)
!!    E_AB = .roby_atom_energy(roby_atom)
!    stdout.show( "Binding Energy: ", HALF * (E_A + E_B - E_AB + Ep_A + Ep_B - Ep_AB) )
!    .put_roby_shared_energy(roby_atom)
!    .put_roby_ionic_energy(roby_atom)
!    stdout.show("Nuclear potential for A:", .atom.nuclear_repulsion_energy( (/ a /) ))
!    stdout.show("Nuclear potential for B:", .atom.nuclear_repulsion_energy( (/ b /) ))
!    roby_atom.destroy
!   end
!
!   get_roby_shared_energy(roby_atom) result(se) ::: leaky
!   ! returns the shared energy of the atoms given in "roby_atom"
!   ! as well as the energy of all sub-groups of atoms "en_groups"
!     roby_atom :: VEC{INT}
!     se, energy_subgroup, en_groups :: REAL
!     m,k, n_k, n_roby_atom :: INT
!     comb_mat :: MAT{INT}*
!     n_roby_atom = size(roby_atom)
!     se = 0
!     do k = 1,n_roby_atom
!       n_k = n_roby_atom.choose(k)
!       comb_mat.create(k,n_k)
!       comb_mat = roby_atom.get_combination_matrix_from(k)
!       en_groups = 0
!       do m = 1,n_k
!         energy_subgroup = .roby_total_atom_energy(comb_mat(:,m),output=FALSE)
!         en_groups = en_groups + energy_subgroup
!       end
!       comb_mat.destroy
!       se = se - ((-1)==k)*en_groups
!     end
!   end
!
!   get_roby_ionic_energy(roby_atom, roby_atom2) result(ionic_energy) ::: leaky
!   ! returns the shared energy of the atoms given in "roby_atom"
!   ! as well as the energy of all sub-groups of atoms "en_groups"
!   roby_atom, roby_atom2 :: VEC{INT}
!   ionic_energy, energy_group1, energy_group2 :: REAL
!   ground1, ground2 :: REAL
!       energy_group1 = .roby_total_atom_energy(roby_atom,output=FALSE)
!       energy_group2 = .roby_total_atom_energy(roby_atom2,output=FALSE)
!       ground1 = sum(.atom(roby_atom).energy)
!       ground2 = sum(.atom(roby_atom2).energy)
!       stdout.flush
!       stdout.dash(real_fields=3)
!       stdout.put("Ground State Energy of Atom 1"); stdout.put(ground1)
!       stdout.flush
!       stdout.put("Ground State Energy of Atom 2"); stdout.put(ground2)
!       stdout.flush
!       stdout.dash(real_fields=3)
!       stdout.flush
!       ionic_energy = energy_group1 - energy_group2
!       ionic_energy = ionic_energy - ground1 + ground2
!   end
!
!   put_roby_shared_energy(atoms) ::: leaky
!   ! Evaluate and put the Roby shared energy for a group of atoms
!      atoms :: VEC{INT}, OPTIONAL
!      shared_energy :: REAL
!      roby_atom :: VEC{INT}*
!      if (PRESENT(atoms)) then
!          roby_atom.create(size(atoms))
!          roby_atom = atoms
!      else
!          .read_roby_atom(roby_atom)
!      end
!      shared_energy = .get_roby_shared_energy(roby_atom)
!      stdout.flush
!      stdout.dash(real_fields=3)
!      stdout.show("Shared energy =",shared_energy)
!      roby_atom.destroy
!   end
!
!   put_roby_ionic_energy(atoms) ::: leaky
!   ! Evaluate and put the Roby ionic energy for a group of atoms
!      atoms :: VEC{INT}, OPTIONAL
!      n_roby_atom :: INT
!      roby_atom :: VEC{INT}*
!      if (PRESENT(atoms)) then
!          roby_atom.create(size(atoms))
!          roby_atom = atoms
!      else
!          .read_roby_atom(roby_atom)
!      end
!      n_roby_atom = size(roby_atom)
!      ENSURE(n_roby_atom==2, "current routine only for two atoms")
!      stdout.dash(real_fields=3)
!      stdout.show("Ionic Energy =", .get_roby_ionic_energy( roby_atom(1:1), roby_atom(2:2)))
!      stdout.flush
!      roby_atom.destroy
!   end
!
!   put_roby_atom_energy(atoms) ::: leaky
!   ! Evaluate and put the Roby ionic energy for a group of atoms
!      atoms :: VEC{INT}, OPTIONAL
!      n_roby_atom, i, a :: INT
!      roby_atom :: VEC{INT}*
!      E_T, E_P, E_A :: REAL
!      if (PRESENT(atoms)) then
!          roby_atom.create(size(atoms))
!          roby_atom = atoms
!      else
!          .read_roby_atom(roby_atom)
!      end
!      n_roby_atom = size(roby_atom)
!      stdout.dash(real_fields=3)
!      stdout.flush
!      stdout.text("Roby atom energy analysis:")
!      stdout.flush
!      stdout.dash(real_fields=3)
!      stdout.flush
!      stdout.text("Atoms =")
!      do i=1,n_roby_atom
!        a = roby_atom(i)
!        stdout.text(trim(.atom(a).label))
!      end
!      E_T = .roby_total_atom_energy(roby_atom)
!      E_P = .roby_atom_energy(roby_atom)
!      E_A = E_T/2 + E_P/2
!      stdout.flush
!      stdout.show("Atom Total Energy =", E_T)
!      stdout.flush
!      stdout.show("Promoted Atom Energy =", E_P)
!      stdout.flush
!      stdout.show("Partitioned Atom Energy =", E_A)
!      stdout.flush
!      stdout.dash(real_fields=3)
!      stdout.flush
!      roby_atom.destroy
!   end
!
!   roby_atom_energy(roby_atom) result(energy) ::: leaky
!   ! Return the Roby promoted atom energy for the group of atoms whose
!   ! indices are given in "roby_atom".
!      roby_atom :: VEC{INT}
!      energy :: REAL
!      D,D_save :: OPMATRIX*
!      P, Q :: MAT{REAL}*
!      D_save => .density_matrix
!      P.create(.n_bf, .n_bf)
!      if (.spin_multiplicity/=1) then
!        Q.create(.n_bf, .n_bf)
!        .make_roby_projected_density(P,roby_atom,.density_matrix.alpha)
!        .make_roby_projected_density(Q,roby_atom,.density_matrix.beta)
!        D.create(.n_bf,"unrestricted")
!        D.alpha = P        ! P is projected density
!        D.beta = Q         ! P is projected density
!        Q.destroy
!      else
!        D.create(.n_bf,"restricted")
!        .make_roby_projected_density(P,roby_atom)
!        D.restricted = P        ! P is projected density
!      end
!      .density_matrix => D
!      .make_fock_matrix(core=FALSE)
!      if (.spin_multiplicity/=1) then
!          .add_core_hamiltonian(.fock_matrix.beta, roby_atom)
!          .add_core_hamiltonian(.fock_matrix.alpha, roby_atom)
!      else
!          .add_core_hamiltonian(.fock_matrix.restricted, roby_atom)
!      end
!      energy = .scf_electronic_energy(D,roby_atom) + .atom(roby_atom).nuclear_repulsion_energy
!      .density_matrix => D_save
!      D.destroy
!      P.destroy
!   end
!
!   roby_total_atom_energy(roby_atom, nuclei, output) result(energy) ::: leaky
!   ! Return the total Roby energy for the group of atoms whose
!   ! indices are given in "roby_atom" If output is present and false energy breakdown
!   ! output is suppressed. If nuclei is given then only the nuclei specified
!   ! are used for E_N and N_N and N_E interactions, and the projected atoms specified by nuclei for the E_E
!   ! repulsions
!      roby_atom :: VEC{INT}
!      nuclei :: VEC{INT}, optional
!      output :: BIN, optional
!      do_output :: BIN
!      energy, E_k, Na_Em, Na_Ea, Ea_Nm, Ea_Em, Ea_Ea :: REAL
!      Pa, Pb, Za, Zm, T :: MAT{REAL}*
!      D, D_save :: MAT{REAL}*
!      do_output=TRUE
!      if (present(output)) do_output=output              ! puts out the energies and sub-energies and all that
!      T.create(.n_bf, .n_bf); Pa.create(.n_bf, .n_bf)
!      Za.create(.n_bf, .n_bf); Zm.create(.n_bf, .n_bf)
!      if (present(nuclei)) then
!         .make_nuclear_attraction_mx(Zm,nuclei)   ! The e->n attractions of the atoms electrons for the "nuclei"
!      else
!         .make_nuclear_attraction_mx(Zm)          ! The e->n attractions of the atoms electrons for all the nuclei
!      end
!      .make_nuclear_attraction_mx(Za,roby_atom)   ! The n->e attractions felt by the nuclei in the roby atom
!      .make_kinetic_energy_mx(T)              ! The electronic kinetic energy matrix
!      if (.spin_multiplicity/=1) then
!        Pb.create(.n_bf, .n_bf)
!        if (present(nuclei)) then          ! if we only want to look at interactions with subgroups of the molecule
!          D_save => .density_matrix.alpha  ! store the "real" density matrix of the molecule
!          D => .density_matrix.beta
!          .make_roby_projected_density(Pa,nuclei,.density_matrix.alpha)
!          .make_roby_projected_density(Pb,nuclei,.density_matrix.beta)
!          .density_matrix.alpha => Pa      ! replace the "real" density matrix with the projected "nuclei"
!          .density_matrix.beta => Pb
!          .make_fock_matrix(core=FALSE)    ! calculate e-e repulsions for all electrons in projected "nuclei"
!          !Na_Em = Za.trace_product_with(.density_matrix.alpha) + Za.trace_product_with(.density_matrix.beta)
!          Na_Em = .density_matrix.alpha.trace_product_with(Za) + .density_matrix.beta.trace_product_with(Za)
!                                           ! calculate n-e repulsions for all electrons in projected "nuclei"
!                                           ! and nuclei in "roby_atom"
!          .density_matrix.alpha => D_save  ! restore "real" density matrix
!          .density_matrix.beta => D
!        else
!          .make_fock_matrix(core=FALSE)    ! calculate e-e repulsions for all electrons in molecule
!        ! Na_Em = Za.trace_product_with(.density_matrix.alpha) + Za.trace_product_with(.density_matrix.beta)
!          Na_Em = .density_matrix.alpha.trace_product_with(Za) + .density_matrix.beta.trace_product_with(Za)
!                                           ! calculate e-e repulsions for all electrons in molecule with roby_atom
!        end
!        D_save => .density_matrix.alpha    ! save "real" density matrix
!        D => .density_matrix.beta
!        .make_roby_projected_density(Pa,roby_atom,.density_matrix.alpha)
!        .make_roby_projected_density(Pb,roby_atom,.density_matrix.beta )
!        Ea_Em = .fock_matrix.alpha.trace_product_with(Pa) + .fock_matrix.beta.trace_product_with(Pb)
!        E_k = T.trace_product_with(Pa) + T.trace_product_with(Pb)     ! calculate Kinetic Energy for "roby_atom" electrons
!        Na_Ea = Za.trace_product_with(Pa) + Za.trace_product_with(Pb) ! calculate Nuclear -> electron energy  (A->A)
!        Ea_Nm = Zm.trace_product_with(Pa) + Zm.trace_product_with(Pb) ! calculate Nuclear -> electron energy  (M->A)
!        .density_matrix.alpha => Pa        ! set "real" density matrix to be the projected atoms "roby_atom"
!        .density_matrix.beta => Pb
!        .make_fock_matrix(core=FALSE)      ! calculate repulsions within the "roby_atom"
!        Ea_Ea = .fock_matrix.alpha.trace_product_with(Pa) + .fock_matrix.beta.trace_product_with(Pb)
!        Ea_Em = Ea_Em - Ea_Ea/2            ! subtract 1/2 of the internal atom repulsions for double up
!        .density_matrix.alpha => D_save
!        .density_matrix.beta => D          ! reset "real" density matrix
!        Pb.destroy
!      else
!        if (present(nuclei)) then             ! to look at the energy of the atom in the field of only certain atoms "nuclei"
!          D_save => .density_matrix.restricted          ! save the "real" density matrix
!          .make_roby_projected_density(Pa,nuclei)   ! reset the "real" density matrix to a projected density
!          .density_matrix.restricted => Pa
!          Na_Em = Za.trace_product_with(.density_matrix.restricted)
!          .make_fock_matrix(core=FALSE)      ! no core and for the whole molecule
!          .density_matrix.restricted => D_save
!        else
!          Na_Em = Za.trace_product_with(.density_matrix.restricted)
!          .make_fock_matrix(core=FALSE)
!        end
!        D_save => .density_matrix.restricted
!        .make_roby_projected_density(Pa,roby_atom)
!        Ea_Em = .fock_matrix.restricted.trace_product_with(Pa)
!        Na_Ea = Za.trace_product_with(Pa)
!        Ea_Nm = Zm.trace_product_with(Pa)
!        E_k = T.trace_product_with(Pa)
!        .density_matrix.restricted => Pa
!        .make_fock_matrix(core=FALSE)      ! no core and for the whole molecule
!        Ea_Ea = .fock_matrix.restricted.trace_product_with(Pa)
!        Ea_Em = Ea_Em - Ea_Ea/2
!        .density_matrix.restricted => D_save
!      end
!      energy = Na_Em + E_k + Ea_Em + Ea_Nm - Na_Ea
!      if (present(nuclei)) then
!        energy = energy + .atom.nuclear_repulsion_energy(roby_atom,nuclei)
!      else
!        energy = energy + .atom.nuclear_repulsion_energy(roby_atom)
!      end
!      if (do_output) then
!       stdout.dash(real_fields=3)
!       stdout.show("N_a to E_m:",Na_Em)
!       stdout.show("N_a to E_a:",Na_Ea)
!       stdout.show("E_a to N_m:",Ea_Nm)
!       stdout.show("E_a to E_m:",Ea_Em)
!       stdout.show("N_a to N_m:", .atom.nuclear_repulsion_energy(roby_atom))
!       stdout.show("Kinetic Energy:", E_k)
!       stdout.show("Total Energy:", energy)
!       stdout.dash(real_fields=3)
!      end
!      Pa.destroy
!   end

! ======================================
! Plot covalent and ionic theta orbitals
! ======================================

!   plot_roby_orbitals
!   ! Plots the covalent and ionic orbitals to a grid
!   roby_atom, roby_atom1, roby_atom2 :: VEC{INT}*
!     .read_roby_groups(roby_atom,roby_atom1,roby_atom2)
!     .plot_cos_sin_orbitals(roby_atom, roby_atom1, roby_atom2)
!     roby_atom.destroy
!     roby_atom1.destroy
!     roby_atom2.destroy
!   end
!
!   plot_cos_sin_orbitals(roby_atom, roby_atom1, roby_atom2)
!   ! Plots the cos and sin Roby-Gould orbitals
!   ! =========================================
!      roby_atom, roby_atom1, roby_atom2 :: VEC{INT}
!      C, theta_c, S, theta_s :: MAT{REAL}*
!      cval, sval :: VEC{REAL}*
!      c_pair, s_pair, cs_pair :: VEC{INT}*
!      n_a, n_b, n_ab :: INT
!      i, j, k, kk :: INT
!      proj_COs, proj_SOs, saved_NOs :: OPMATRIX*
!      arch :: ARCHIVE
!      gr :: VEC{REAL}*
!      pi_space, blurb :: BIN
!   ! =========================================
!      blurb = TRUE
!      DIE_IF(.plot_grid.destroyed, "no grid exists")
!      DIE_IF(.spin_multiplicity/=1, "multiplicity /= 1")
!      DIE_IF(.natural_orbitals.number_kind /= "real","NOs not real")
!      n_a = .atom(roby_atom1).n_bf
!      n_b = .atom(roby_atom2).n_bf
!      n_ab = .atom(roby_atom).n_bf
!      DIE_IF(n_ab /= n_a + n_b, "n-ab /= n_a + n_b")
!      C.create(n_ab,n_ab); theta_c.create(n_ab, n_ab); cval.create(n_ab)
!      S.create(n_ab,n_ab); theta_s.create(n_ab, n_ab); sval.create(n_ab)
!      .make_shared_operator(C)
!      .make_ionic_operator(S)
!      .diagonalise_V_AB_operator(C,roby_atom,theta_c,cval)
!      .diagonalise_V_AB_operator(S,roby_atom,theta_s,sval)
!      c_pair.create(n_ab); s_pair.create(n_ab); cs_pair.create(n_ab)
!      .find_pairs(cval, sval, c_pair,s_pair,cs_pair)
!      .put_roby_eigenvalues(roby_atom1,roby_atom2,sval,cval,c_pair,s_pair,cs_pair,blurb)
!      saved_NOs => .natural_orbitals
!      gr.create(.plot_grid.n_pt)
!      proj_COs.create( .n_bf, "restricted")
!      proj_SOs.create( .n_bf, "restricted")
!      .AO_subspace_set(proj_COs.restricted, theta_c, roby_atom)
!      .AO_subspace_set(proj_SOs.restricted, theta_s, roby_atom)
!      pi_space = TRUE
!      do i = 1, n_ab
!        stdout.flush; stdout.put("i,c_pair(i),s_pair(i),cs_pair(i) = ")
!        stdout.put(i); stdout.put(c_pair(i)); stdout.put(s_pair(i)); stdout.put(cs_pair(i))
!        j = cs_pair(i)
!        if (j < 0) cycle
!        stdout.put("cs_pair(i) >= 0")
!        if (pi_space AND s_pair(j)==-1) then
!           ! sin: pi/2
!           stdout.flush; stdout.put("pi/2")
!           k = j
!           kk = i
!           .natural_orbitals => proj_SOs
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"sin_pi_grid")
!           arch.write(gr)
!           arch.set(.name,"sin_pi_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
!        end
!        if (s_pair(j) > -1) then
!           stdout.flush; stdout.put("other")
!           ! cos: +
!           k = i
!           kk = k
!           .natural_orbitals => proj_COs
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"cos_orbital_grid")
!           arch.write(gr)
!           arch.set(.name,"cos_orbital_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
!           ! cos: -
!           k = c_pair(i)
!           kk = k
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"cos_orbital_grid")
!           arch.write(gr)
!           arch.set(.name,"cos_orbital_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
!           ! sin: +
!           k = j
!           kk = i
!           .natural_orbitals => proj_SOs
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"sin_orbital_grid")
!           arch.write(gr)
!           arch.set(.name,"sin_orbital_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
!           ! sin: -
!           k = s_pair(j)
!           kk = c_pair(i)
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"sin_orbital_grid")
!           arch.write(gr)
!           arch.set(.name,"sin_orbital_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .plot_grid.n_x, .plot_grid.n_y, .plot_grid.n_z)
!        end
!      end
!      .natural_orbitals => saved_NOs
!      gr.destroy
!      proj_COs.destroy
!      proj_SOs.destroy
!      C.destroy; theta_c.destroy; cval.destroy
!      S.destroy; theta_s.destroy; sval.destroy
!      c_pair.destroy; s_pair.destroy; cs_pair.destroy
!   end

!  ===========================
!  Cluster generation routines
!  ===========================

   read_cluster ::: leaky
   ! Read in the crystal cluster data. NOTE: the .atom list must correspond to
   ! the (unpruned or pruned) asymmetric unit cell geometry of the .crystal.
   ENSURE(.atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")

      .crystal.make_fragment_data(.atom,assign_atom=TRUE) 
      DIE_IF(.crystal.asymmetric_unit_atom.destroyed,"atom list does not span asymmetric unit")

      .cluster.destroy
      .cluster.create(.crystal)
      .cluster.read_keywords

   end

   create_cluster ::: leaky
   ! Create a new "self" by generating a cluster from information
   ! stored in .cluster.  The original molecule replaced by the
   ! *cluster-fragent* and stored in .saved. The new molecule is
   ! created from the cluster geometry.
      self :: PTR
   ENSURE(.crystal.created,"no crystal data")
   ENSURE(.cluster.created,"no cluster data")
   ENSURE(.cluster.info_made,"no cluster data")

      stdout.flush
      stdout.text("Resetting molecule to cluster fragment")

   !  .destroy
   !  if (TRUE) stop

      ! Reset the .atom list to the *cluster-fragment*
      ! Make sure to resolve bases and crystal.fragment_atoms
      .atom.destroy
      .cluster.create_fragment_atom_list(.atom) 
      .set_atom_info
      .resolve_basis_info
      .crystal.make_fragment_data(.atom,assign_atom=TRUE)

      stdout.flush
      stdout.text("Saving old molecule; making new cluster")
      stdout.flush

      ! Save this molecule & get a clean new molecule
      .save 

      ! The name for the new cluster
      .name = trim(.saved.name) // "_cluster"

      ! If a CIF exists, copy that
      if (.saved.cif.created) .cif.create_copy(.saved.cif)

      ! We want the saved crystal 
      ! It should be consistent with the cluster.
      .crystal.create_copy(.saved.crystal) 

      ! Make the new atom list from saved cluster
      ! Don't make a new cluster, let the user do it.
      .saved.cluster.create_atom_list(.atom)  
      .set_atom_info

      ! Set up basis sets
      if (.atom.created) .atom.nullify_bases
      if (.saved.basis.created)               .basis.create_copy(.saved.basis)
      if (.saved.slaterbasis.created)   .slaterbasis.create_copy(.saved.slaterbasis)
      if (.saved.coppensbasis.created) .coppensbasis.create_copy(.saved.coppensbasis)
      .basis_name        = .saved.basis_name
      .slaterbasis_name  = .saved.slaterbasis_name
      .coppensbasis_name = .saved.coppensbasis_name
      .resolve_basis_info
      .set_basis_info

   end

   destroy_cluster ::: leaky
   ! Destroy a molecule created by the "create_cluster" routine, and recover
   ! the original molecule from .saved
      self :: PTR
   ENSURE(.saved.created,"no crystal data")
      .unsave
   end

!  =============
!  Miscellaneous
!  =============

!   put_sylvian_csizmadia_tensors
!   ! Put out the Sylvian-Csizmadia polarisability tensors.
!   ! This routine will read the value of the Unsold denominator.
!      Dx,Dy,Dz, P,Pi,Pj,MOi,MOj :: MAT{REAL}*
!      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}*
!      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}*
!      x,y,z, i,j :: INT
!      delta,fac :: REAL
!      alpha :: MAT{REAL}(3,3)
!      beta :: MAT3{REAL}(3,3,3)
!      alpha1 :: MAT3{REAL}*
!      alpha2 :: MAT4{REAL}*
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created, "no atom info")
!      stdout.flush
!      stdout.text("Sylvian-Csizmadia polarisability tensors")
!      stdout.flush
!      stdin.read(delta)
!      stdout.show("Unsold denominator/a.u. =",delta)
!      Dx.create(.n_bf,.n_bf); Dy.create(.n_bf,.n_bf); Dz.create(.n_bf,.n_bf)
!      Qxx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
!      Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
!      Oxxx.create(.n_bf,.n_bf); Oyyy.create(.n_bf,.n_bf); Ozzz.create(.n_bf,.n_bf)
!      Oxxy.create(.n_bf,.n_bf); Oxxz.create(.n_bf,.n_bf)
!      Oyyx.create(.n_bf,.n_bf); Oyyz.create(.n_bf,.n_bf)
!      Ozzx.create(.n_bf,.n_bf); Ozzy.create(.n_bf,.n_bf)
!      Oxyz.create(.n_bf,.n_bf)
!      .make_dipole_matrices(Dx,Dy,Dz)
!      .make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
!      .make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
!      .make_ao_density_matrix
!      x = 1; y = 2; z = 3
!      P.create(.n_bf,.n_bf)
!      P = HALF*.density_matrix.restricted
!      alpha(x,x) = P.trace_product_with(Qxx) - P.trace_product_with(Dx,P,Dx)
!      alpha(y,y) = P.trace_product_with(Qyy) - P.trace_product_with(Dy,P,Dy)
!      alpha(z,z) = P.trace_product_with(Qzz) - P.trace_product_with(Dz,P,Dz)
!      alpha(y,x) = P.trace_product_with(Qxy) - P.trace_product_with(Dy,P,Dx)
!      alpha(z,x) = P.trace_product_with(Qxz) - P.trace_product_with(Dz,P,Dx)
!      alpha(z,y) = P.trace_product_with(Qyz) - P.trace_product_with(Dz,P,Dy)
!      alpha.symmetric_reflect
!      fac = FOUR/delta
!      alpha = fac*alpha
!      stdout.flush
!      stdout.show("No. of occupiedf orbitals =",.n_a)
!      stdout.flush
!      stdout.text("Orbital eigenvalues:")
!      stdout.flush
!      stdout.put(.orbital_energies)
!      stdout.flush
!      stdout.text("First polarisability:")
!      stdout.flush
!      stdout.put(alpha)
!      ! Evaluate the orbital contributions
!      alpha1.create(3,3,.n_a); alpha1 = ZERO
!      alpha2.create(3,3,.n_a,.n_a); alpha2 = ZERO
!      Pi.create(.n_bf,.n_bf)
!      Pj.create(.n_bf,.n_bf)
!      do i = 1,.n_a
!         MOi => .molecular_orbitals.restricted(:,i:i)
!         Pi.to_product_of(MOi,MOi,transpose_b=TRUE)
!         alpha1(x,x,i) = Pi.trace_product_with(Qxx) - Pi.trace_product_with(Dx,Pi,Dx)
!         alpha1(y,y,i) = Pi.trace_product_with(Qyy) - Pi.trace_product_with(Dy,Pi,Dy)
!         alpha1(z,z,i) = Pi.trace_product_with(Qzz) - Pi.trace_product_with(Dz,Pi,Dz)
!         alpha1(y,x,i) = Pi.trace_product_with(Qxy) - Pi.trace_product_with(Dy,Pi,Dx)
!         alpha1(z,x,i) = Pi.trace_product_with(Qxz) - Pi.trace_product_with(Dz,Pi,Dx)
!         alpha1(z,y,i) = Pi.trace_product_with(Qyz) - Pi.trace_product_with(Dz,Pi,Dy)
!         alpha1(:,:,i).symmetric_reflect
!         do j = 1,(i-1)
!            MOj => .molecular_orbitals.restricted(:,j:j)
!            Pj.to_product_of(MOj,MOj,transpose_b=TRUE)
!            alpha2(x,x,i,j) = -Pi.trace_product_with(Dx,Pj,Dx)-Pj.trace_product_with(Dx,Pi,Dx)
!            alpha2(y,y,i,j) = -Pi.trace_product_with(Dy,Pj,Dy)-Pj.trace_product_with(Dy,Pi,Dy)
!            alpha2(z,z,i,j) = -Pi.trace_product_with(Dz,Pj,Dz)-Pj.trace_product_with(Dz,Pi,Dz)
!            alpha2(y,x,i,j) = -Pi.trace_product_with(Dy,Pj,Dx)-Pj.trace_product_with(Dy,Pi,Dx)
!            alpha2(z,x,i,j) = -Pi.trace_product_with(Dz,Pj,Dx)-Pj.trace_product_with(Dz,Pi,Dx)
!            alpha2(z,y,i,j) = -Pi.trace_product_with(Dz,Pj,Dy)-Pj.trace_product_with(Dz,Pi,Dy)
!            alpha2(:,:,i,j).symmetric_reflect
!         end
!      end
!      Pj.destroy
!      Pi.destroy
!      alpha1 = fac*alpha1
!      alpha2 = fac*alpha2
!      stdout.flush
!      stdout.text("First polarisability, orbital contributions:")
!      stdout.flush
!      do i = 1,.n_a
!         stdout.text("... for orbital "//i.to_str.trim)
!         stdout.put(alpha1(:,:,i))
!      end
!      stdout.flush
!      stdout.text("First polarisability, orbital pair contributions:")
!      stdout.flush
!      do i = 1,.n_a
!      do j = 1,(i-1)
!         stdout.text("... for orbitals "//i.to_str.trim//" and "//j.to_str.trim)
!         stdout.put(alpha2(:,:,i,j))
!      end
!      end
!      stdout.flush
!      stdout.text("Sum of all orbital contributions:")
!      stdout.flush
!      alpha = ZERO
!      do i = 1,.n_a
!         alpha = alpha + alpha1(:,:,i)
!         do j = 1,(i-1)
!            alpha = alpha + alpha2(:,:,i,j)
!         end
!      end
!      stdout.put(alpha)
!      alpha2.destroy
!      alpha1.destroy
!      beta(x,x,x) = P.trace_product_with(Oxxx) - THREE*P.trace_product_with(Dx,P,Qxx) &
!                  + P.trace_product_with(Dx,P,Dx,P,Dx)
!      beta(y,y,y) = P.trace_product_with(Oyyy) - THREE*P.trace_product_with(Dy,P,Qyy) &
!                  + P.trace_product_with(Dy,P,Dy,P,Dy)
!      beta(z,z,z) = P.trace_product_with(Ozzz) - THREE*P.trace_product_with(Dz,P,Qzz) &
!                  + P.trace_product_with(Dz,P,Dz,P,Dz)
!      beta(y,x,x) = P.trace_product_with(Oxxy) - TWO*P.trace_product_with(Dx,P,Qxy) &
!                  - P.trace_product_with(Dy,P,Qxx) + P.trace_product_with(Dy,P,Dx,P,Dx)
!      beta(z,x,x) = P.trace_product_with(Oxxz) - TWO*P.trace_product_with(Dx,P,Qxz) &
!                  - P.trace_product_with(Dz,P,Qxx) + P.trace_product_with(Dz,P,Dx,P,Dx)
!      beta(y,y,x) = P.trace_product_with(Oyyx) - TWO*P.trace_product_with(Dy,P,Qxy) &
!                  - P.trace_product_with(Dx,P,Qyy) + P.trace_product_with(Dy,P,Dy,P,Dx)
!      beta(z,y,x) = P.trace_product_with(Oxyz) - P.trace_product_with(Dz,P,Qxy) &
!                  - P.trace_product_with(Dy,P,Qxz) - P.trace_product_with(Dx,P,Qyz) &
!                  + P.trace_product_with(Dz,P,Dy,P,Dx)
!      beta(z,z,x) = P.trace_product_with(Ozzx) - TWO*P.trace_product_with(Dz,P,Qxz) &
!                  - P.trace_product_with(Dx,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dx)
!      beta(z,y,y) = P.trace_product_with(Oyyz) - TWO*P.trace_product_with(Dy,P,Qyz) &
!                  - P.trace_product_with(Dz,P,Qyy) + P.trace_product_with(Dz,P,Dy,P,Dy)
!      beta(z,z,y) = P.trace_product_with(Ozzy) - TWO*P.trace_product_with(Dz,P,Qyz) &
!                  - P.trace_product_with(Dy,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dy)
!      beta.make_symmetric
!      fac = 12.0d0/delta
!      beta = fac*beta
!      stdout.flush
!      stdout.text("Second polarisability:")
!      stdout.flush
!      stdout.put(beta)
!      P.destroy
!      Oxyz.destroy
!      Ozzy.destroy; Ozzx.destroy
!      Oyyz.destroy; Oyyx.destroy
!      Oxxz.destroy; Oxxy.destroy
!      Ozzz.destroy; Oyyy.destroy; Oxxx.destroy
!      Qyz.destroy; Qxz.destroy; Qxy.destroy
!      Qzz.destroy; Qyy.destroy; Qxx.destroy
!      Dz.destroy; Dy.destroy; Dx.destroy
!   end

   make_weak_force_energy_shift
   ! Make the expectation value of the parity-violating energy shift.
   ! Requires some archived molecular orbitals, general_complex kind.
   ! Reference: R. Zanasi and P. Lazzeretti, CPL 286, 240 (1998)
   ENSURE(.basis_info_made, "no basis info")

       pt :: MAT{REAL}*
       Pa,Pb :: VEC{CPX}*
       Na,Nb :: MAT{CPX}*
       PV,NN :: VEC{REAL}*
       n, x,y,z :: INT
       Gamma :: REAL
       I :: CPX
       arch :: ARCHIVE

       .molecular_orbitals.destroy_ptr_part
       arch.set(.name,"molecular_orbitals")
       arch.read(.molecular_orbitals, genre="general_complex")

       Gamma = 5.73416d-17
       PV.create(.n_atom)
       pt.create(.n_atom,3)
       .atom.put_coordinates_to(pt)

       Pa.create(.n_atom);   Pb.create(.n_atom)
       Na.create(.n_atom,3); Nb.create(.n_atom,3)
       I = (ZERO,ONE)
       stdout.set_real_style("d")
       x = 1; y = 2; z = 3
       PV = ZERO
       do n = 1,.n_e
          .make_nabla_orbital_grid_c(Na,Pa,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
          .make_nabla_orbital_grid_c(Nb,Pb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
          PV = PV &
             + RE(I*conjg(Nb(:,x))*Pa(:)) &
             + RE(I*conjg(Na(:,x))*Pb(:)) &
             - RE(I*conjg(Pb(:))*Na(:,x)) &
             - RE(I*conjg(Pa(:))*Nb(:,x)) &
             + RE(  conjg(Nb(:,y))*Pa(:)) &
             - RE(  conjg(Na(:,y))*Pb(:)) &
             + RE(  conjg(Pb(:))*Na(:,y)) &
             - RE(  conjg(Pa(:))*Nb(:,y)) &
             + RE(I*conjg(Na(:,z))*Pa(:)) &
             - RE(I*conjg(Nb(:,z))*Pb(:)) &
             - RE(I*conjg(Pa(:))*Na(:,z)) &
             + RE(I*conjg(Pb(:))*Nb(:,z))
       end
       PV = -HALF*Gamma*PV

       Nb.destroy; Na.destroy
       Pb.destroy; Pa.destroy
       pt.destroy

       NN.create(.n_atom)
       .atom.get_mean_neutron_numbers(NN)
       PV = PV*NN

       stdout.set_real_style("d")
       stdout.flush
       stdout.text("Contributions (by nucleus) to the parity-violating weak force energy shift term:")
       stdout.flush
       stdout.put(PV)
       stdout.flush
       stdout.show("Total contribution =", sum(PV) )
       stdout.flush
       stdout.text("Neutron numbers:")
       stdout.flush
       stdout.put(NN)
       stdout.set_real_style("f")

       NN.destroy
       PV.destroy

       .molecular_orbitals.destroy_ptr_part

   end

   put_g_tensor_information
   ! Put the g-tensor shift information to the output.
   ! Reference: Jayatilaka, JCP 108, 7587 (1998)
      Lx,Ly,Lz, Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, T :: MAT{REAL}*
      HH,P :: MAT{CPX}*
      Sx,Sy,Sz,SS_net, Mx,My,Mz,MM_net :: REAL
      Qx,Qy,Qz,QQ_net, Tx,Ty,Tz,TT_net :: REAL
      Sx_ppm,Sy_ppm,Sz_ppm, Mx_ppm,My_ppm,Mz_ppm :: REAL
      Qx_ppm,Qy_ppm,Qz_ppm, Tx_ppm,Ty_ppm,Tz_ppm :: REAL
      fac, fx,fy,fz, total :: REAL
      quantization_axis :: VEC{REAL}(3)
      I :: CPX
      m :: INT
      int_width :: BIN
      arch :: ARCHIVE

      .density_matrix.destroy_ptr_part
      arch.set(.name,"density_matrix")
      arch.read(.density_matrix, genre="general_complex")

      P => .density_matrix%general_complex
      HH.create(2*.n_bf,2*.n_bf)
      I = (ZERO,ONE)
      quantization_axis = .scfdata.quantization_axis

      ! Spin contribution
      .get_overlap_matrix
      fac = G_FACTOR/FOUR
      HH = ZERO
      HH.beta_alpha_plus(.overlap_matrix,fac)
      HH.alpha_beta_plus(.overlap_matrix,fac)
      Sx = RE(HH.trace_product_with(P))

      HH = ZERO
      HH.beta_alpha_plus(.overlap_matrix,fac*I)
      HH.alpha_beta_plus(.overlap_matrix,-fac*I)
      Sy = RE(HH.trace_product_with(P))

      HH = ZERO
      HH.alpha_alpha_plus(.overlap_matrix,fac)
      HH.beta_beta_plus(.overlap_matrix,-fac)
      Sz = RE(HH.trace_product_with(P))

      m = .n_a - .n_b
      fx = m*fac*quantization_axis(1)
      fy = m*fac*quantization_axis(2)
      fz = m*fac*quantization_axis(3)
      Sx_ppm = (Sx-fx)*4000000/m
      Sy_ppm = (Sy-fy)*4000000/m
      Sz_ppm = (Sz-fz)*4000000/m
      SS_net = Sx_ppm*quantization_axis(1) + Sy_ppm*quantization_axis(2) + Sz_ppm*quantization_axis(3)

      ! L contribution
      Lx.create(.n_bf,.n_bf)
      Ly.create(.n_bf,.n_bf)
      Lz.create(.n_bf,.n_bf)
      .make_L_matrices(Lx,Ly,Lz)

      fac = HALF
      HH = ZERO
      HH.alpha_alpha_plus(Lx,-fac*I)  ! -I factor for the nabla part
      HH.beta_beta_plus(Lx,-fac*I)
      Mx = RE(HH.trace_product_with(P))

      HH = ZERO
      HH.alpha_alpha_plus(Ly,-fac*I)
      HH.beta_beta_plus(Ly,-fac*I)
      My = RE(HH.trace_product_with(P))

      HH = ZERO
      HH.alpha_alpha_plus(Lz,-fac*I)
      HH.beta_beta_plus(Lz,-fac*I)
      Mz = RE(HH.trace_product_with(P))

      Lz.destroy; Ly.destroy; Lx.destroy

      Mx_ppm = Mx*4000000/m
      My_ppm = My*4000000/m
      Mz_ppm = Mz*4000000/m
      MM_net = Mx_ppm*quantization_axis(1) + My_ppm*quantization_axis(2) + Mz_ppm*quantization_axis(3)

      ! 1 electron LS gauge contribution
      Qxx.create(.n_bf,.n_bf); Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf)
      Qyx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
      Qzx.create(.n_bf,.n_bf); Qzy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
      .make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
      fac = G_FACTOR/(TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)

      HH = ZERO
      HH.beta_alpha_plus(Qyy,fac)
      HH.beta_alpha_plus(Qzz,fac)
      HH.beta_alpha_plus(Qyx,-I*fac)
      HH.alpha_alpha_plus(Qzx,-fac)
      HH.beta_beta_plus(Qzx,+fac)
      HH.make_hermitian
      Qx = RE(HH.trace_product_with(P))

      HH = ZERO
      HH.beta_alpha_plus(Qxx,I*fac)
      HH.beta_alpha_plus(Qzz,I*fac)
      HH.beta_alpha_plus(Qxy,-fac)
      HH.alpha_alpha_plus(Qzy,-fac)
      HH.beta_beta_plus(Qzy,+fac)
      HH.make_hermitian
      Qy = RE(HH.trace_product_with(P))

      HH = ZERO
      HH.alpha_alpha_plus(Qxx,fac)
      HH.alpha_alpha_plus(Qyy,fac)
      HH.beta_beta_plus(Qxx,-fac)
      HH.beta_beta_plus(Qyy,-fac)
      HH.beta_alpha_plus(Qxz,-fac)
      HH.beta_alpha_plus(Qyz,-I*fac)
      HH.make_hermitian
      Qz = RE(HH.trace_product_with(P))

      Qzz.destroy; Qzy.destroy; Qzx.destroy
      Qyz.destroy; Qyy.destroy; Qyx.destroy
      Qxz.destroy; Qxy.destroy; Qxx.destroy

      Qx_ppm = Qx*4000000/m
      Qy_ppm = Qy*4000000/m
      Qz_ppm = Qz*4000000/m
      QQ_net = Qx_ppm*quantization_axis(1) + Qy_ppm*quantization_axis(2) + Qz_ppm*quantization_axis(3)

      ! Relativistic kinetic energy contribution
      T.create(.n_bf,.n_bf)
      .make_kinetic_energy_mx(T)
      fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)

      HH = ZERO
      HH.beta_alpha_plus(T,fac)
      HH.alpha_beta_plus(T,fac)
      Tx = RE(HH.trace_product_with(P))

      HH = ZERO
      HH.beta_alpha_plus(T,I*fac)
      HH.alpha_beta_plus(T,-I*fac)
      Ty = RE(HH.trace_product_with(P))

      HH = ZERO
      HH.alpha_alpha_plus(T,fac)
      HH.beta_beta_plus(T,-fac)
      Tz = RE(HH.trace_product_with(P))

      T.destroy
      HH.destroy
      .density_matrix.destroy_ptr_part

      Tx_ppm = Tx*4000000/m
      Ty_ppm = Ty*4000000/m
      Tz_ppm = Tz*4000000/m
      TT_net = Tx_ppm*quantization_axis(1) + Ty_ppm*quantization_axis(2) + Tz_ppm*quantization_axis(3)

      stdout.set_real_style("d")
      int_width = TRUE
      stdout.flush
      stdout.text("Contribution to g-tensor shift:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=2)
      stdout.put("Term",int_width); stdout.put("<value>");
      stdout.put("shift/ppm"); stdout.flush
      stdout.dash(int_fields=1,real_fields=2)
      stdout.text("Spin term:")
      stdout.put("S_x",int_width)
      stdout.set_real_style("d"); stdout.put(Sx)
      stdout.set_real_style("f"); stdout.put(Sx_ppm); stdout.flush
      stdout.put("S_y",int_width)
      stdout.set_real_style("d"); stdout.put(Sy)
      stdout.set_real_style("f"); stdout.put(Sy_ppm); stdout.flush
      stdout.put("S_z",int_width)
      stdout.set_real_style("d"); stdout.put(Sz);
      stdout.set_real_style("f"); stdout.put(Sz_ppm); stdout.flush
      stdout.put("Net",int_width); stdout.tab(real_fields=1);
      stdout.put(SS_net); stdout.flush
      stdout.text("Angular momentum term:")
      stdout.put("L_x",int_width)
      stdout.set_real_style("d"); stdout.put(Mx);
      stdout.set_real_style("f"); stdout.put(Mx_ppm); stdout.flush
      stdout.put("L_y",int_width)
      stdout.set_real_style("d"); stdout.put(My);
      stdout.set_real_style("f"); stdout.put(My_ppm); stdout.flush
      stdout.put("L_z",int_width)
      stdout.set_real_style("d"); stdout.put(Mz);
      stdout.set_real_style("f"); stdout.put(Mz_ppm); stdout.flush
      stdout.put("Net",int_width); stdout.tab(real_fields=1);
      stdout.put(MM_net); stdout.flush
      stdout.text("1-electron L:S gauge term:")
      stdout.put("Q_x",int_width)
      stdout.set_real_style("d"); stdout.put(Qx);
      stdout.set_real_style("f"); stdout.put(Qx_ppm); stdout.flush
      stdout.put("Q_y",int_width)
      stdout.set_real_style("d"); stdout.put(Qy);
      stdout.set_real_style("f"); stdout.put(Qy_ppm); stdout.flush
      stdout.put("Q_z",int_width)
      stdout.set_real_style("d"); stdout.put(Qz);
      stdout.set_real_style("f"); stdout.put(Qz_ppm); stdout.flush
      stdout.put("Net",int_width); stdout.tab(real_fields=1);
      stdout.put(QQ_net); stdout.flush
      stdout.text("Relativistic B:S kinetic term:")
      stdout.put("T_x",int_width)
      stdout.set_real_style("d"); stdout.put(Tx)
      stdout.set_real_style("f"); stdout.put(Tx_ppm); stdout.flush
      stdout.put("T_y",int_width)
      stdout.set_real_style("d"); stdout.put(Ty);
      stdout.set_real_style("f"); stdout.put(Ty_ppm); stdout.flush
      stdout.put("T_z",int_width)
      stdout.set_real_style("d"); stdout.put(Tz);
      stdout.set_real_style("f"); stdout.put(Tz_ppm); stdout.flush
      stdout.put("Net",int_width); stdout.tab(real_fields=1);
      stdout.put(TT_net); stdout.flush
      total = SS_net + MM_net + QQ_net + TT_net
      stdout.flush
      stdout.put("Total:",int_width); stdout.tab(real_fields=1); stdout.put(total)
      stdout.flush
      stdout.dash(int_fields=1,real_fields=2)
      stdout.set_real_style("f")
   end

   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   !                    DKH stuff                     !
   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

   make_ready_da_gcm_tr(M,m_out,n_gcm)  
   ! this is a routine which finds redundant information in the primitive overlap matrix
   !  
   ! meaning of variables
   ! S the primitive overlap matrix; input
   ! m_out matrix; if a 0 is on the diagonal element m_out(i,i) then no of the previous lines
   !                in the overlap matrix is same with the i-th line     
   !               if the i-th line is the same like any previous line j ( j < i ) and  
   !                elements m_out(j,i)=1 , m_out=(j,j)=1 
   ! n_gcm the dimension of Sgcm number of non-redundant lines in the S matrix; 
   !   
      M :: MAT{REAL} 
      m_out :: MAT{INT} 
      n_gcm :: INT   
      TRE, X_def :: REAL  
      i,j,k :: INT    

     X_def=0.1d-17
     TRE=ZERO
     m_out=0
     n_gcm=.n_prim 
   do i=1,(.n_prim-1)
     if (m_out(i,i)==1) cycle
     do j=i+1,.n_prim
       if (m_out(j,j)==1) cycle
       m_out(i,j)=1
       do k=1,.n_prim 
         TRE= M(i,k) - M(j,k)
         if ( abs(TRE) > X_def ) then 
           m_out(i,j)=0
           exit 
         end 
       end do 
       if(m_out(i,j)==1)then
         m_out(j,j)=1
         n_gcm=n_gcm-1
       end 
     end 
    end 
!    M.destroy
!    m_out.destroy
   end

   make_ready_da_gcm_tr2(m_out,n_gcm) 
   ! this routine works better than the previous
   ! but worked only for one atom
   ! I (LBxxx) have edited it at 3.oct.2008 
   ! the cycle if the gaussians are at different nuclei should work 
   ! TESTED !!!! & CALLED 
   !
      m_out :: MAT{INT}
      n_gcm :: INT
      G :: GAUSSIAN2
      TRE, X_def,x,y,z,norm :: REAL
      i,j,k,nps,step :: INT
      frst,last,at,l :: VEC{INT}*
      ex :: VEC{REAL}*

      .atom.make_primitive_limits(frst,last,at,l,ex)

    X_def = 1.0d-8
    norm  = 1.0d-4
    TRE = ZERO
    m_out= 0
    n_gcm=.n_prim
    nps = .atom.no_of_primitive_shells
    do i=1,nps-1
      G.a.set_position(.atom(at(i)).position)
     if (m_out(frst(i),frst(i))==1) cycle
     do j=i+1,nps
      G.b.set_position(.atom(at(j)).position)
! the nuc cycle condition
       x = abs ( G.a.position(1) - G.b.position(1) )
       y = abs ( G.a.position(2) - G.b.position(2) )
       z = abs ( G.a.position(3) - G.b.position(3) )
       if( x > norm OR y > norm OR z > norm ) cycle 
       if( l(i) /= l(j) )cycle
       if (m_out(frst(j),frst(j))==1) cycle
         TRE= ex(i) - ex(j)
         if ( abs(TRE) < X_def ) then
           step=frst(j)-frst(i)
           do k=frst(i),last(i)
               m_out(k,k+step) = 1
               m_out(k+step,k+step) = 1
           end do
           n_gcm = n_gcm - last(i) + frst(i) - 1
         end if
       end do
     end do

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

   end

!   make_ready_da_gcm_tr3(M,ns) ::: leaky
!   ! this routine works better than the previous
!   ! but worked only for one atom
!   ! I (LBxxx) have edited it at 3.oct.2008 
!   ! the cycle if the gaussians are at different nuclei should work 
!   ! TESTED !!!! & CALLED 
!   !
!      M :: MAT{REAL}*
!      ns :: INT
!
!      map :: VEC{VEC_(INT}}*
!      Ga,Gb :: GAUSSIAN
!      frst,last,at,l :: VEC{INT}*
!      nps,a,b,i,j :: INT
!      same :: BIN
!
!      ! Make the indexing arrays
!      .atom.make_primitive_limits(frst,last,at,l,ex)
!
!      ! Find the map from unique to same gaussians
!      map.create(0)
!      ns = 0
!      do a = 1,nps
!        Ga.set_l(l(a))
!        Ga.set_position(.atom(at(a)).position)
!        Ga.set_exponent(ex(a))
!        same = FALSE
!        do b = 1,nps
!           Gb.set_l(l(b))
!           Gb.set_position(.atom(at(b)).position)
!           Gb.set_exponent(ex(b))
!           if (Gb.same_as(Ga)) cycle
!           same = TRUE
!           exit
!        end
!
!        if (same) then
!           map(b).element.append(a)
!        else
!           ns = ns + 1
!           map.expand(1)
!           map(ns).element.append(a)
!        end
!
!      end
!
!      ! Make the M matrix
!      M.create(ns,.n_prim)
!      M = ZERO
!      ns = 0
!      do i = 1,ns
!      do j = 1,map(i).element.dim
!         M(i,map(i)[j]) = ONE
!      end
!      end
!
!      ! Clean
!      map.destroy
!      l.destroy
!      ex.destroy
!      at.destroy
!      last.destroy
!      frst.destroy
!
!   end

   get_da_gcm_now(M,M_gcm,m_out)  
   ! This routine is thought for the S,T,Z,PZP primitive integrals matrices
   ! meaning of variables
   ! M any primitive matrix; input
   ! M_gcm non-redundant primitive matrix; output
   ! m_out matrix; input 

      M :: MAT{REAL}  
      M_gcm :: MAT{REAL}  
      m_out :: MAT{INT} 
      i,j,k,l :: INT    

      M_gcm=ZERO  
      k=0
      l=0
      do i=1,.n_prim

! if the line is the sme like a previous line do not copy it to do M_gcm 
        if(m_out(i,i)==1) cycle 

        k=k+1
        l=k

        do j=i,.n_prim

! if the column j is the sme like a previous column do not copy it to do M_gcm 
          if(m_out(j,j)==1) cycle

!          M_gcm(k,l)=M(i,j)
           M_gcm(l,k)=M(j,i)
          l=l+1

        end

      end
    M_gcm.symmetric_reflect
   end

   get_back_prim_now(M_gcm,M,m_out)  
   ! This routine is thought for the final DKH matrix in the non-redundant a-la general contraction
   ! primitive basis set style to get projected back to the tonto primitive often redundant basis set style 
   ! meaning of variables
   ! M_gcm any gcm matrix; input
   ! M primitive matrix; output 
   ! m_out matrix of

      M_gcm :: MAT{REAL} 
      M :: MAT{REAL} 
      m_out :: MAT{INT} 
      i,j,k,l :: INT    


! the routine has three steps
! first those lines(columns) which are non-redundant give back to the same place like they were obtained 
! in the S to S_gcm transformation
! I am not sure if this can not be written in a more effective way
      k=0
      l=0
      do i=1,.n_prim
        if(m_out(i,i)==1)cycle
        k=k+1
        l=k+1
        M(i,i)=M_gcm(k,k)
        do j=i+1,.n_prim
          if(m_out(j,j)==1)cycle
          M(i,j)=M_gcm(k,l)
          M(j,i)=M_gcm(l,k)
          l=l+1
        end
      end

  !   M.symmetric_reflect

! Second copy each line which was deleted back

      do i=1,.n_prim
        if(m_out(i,i)==1) cycle
        do j=i+1,.n_prim
          if(m_out(i,j)==1) then
          do k=1,.n_prim
                M(j,k)=M(i,k) 
              end
            end
        end
      end

! third copy each column which was deleted back

      do i=1,.n_prim
        if(m_out(i,i)==1) cycle
        do j=i+1,.n_prim
          if(m_out(i,j)==1) then
            do k=1,.n_prim
              M(k,j)=M(k,i) 
            end
          end
        end
      end

   end

   get_da_gcm_now(M,M_gcm,m_out)  
   ! This routine is thought for the S,T,Z,PZP primitive integrals matrices
   ! meaning of variables
   ! M any primitive matrix; input
   ! M_gcm non-redundant primitive matrix; output
   ! m_out matrix; input 

      M :: MAT{CPX}  
      M_gcm :: MAT{CPX}  
      m_out :: MAT{INT} 
      i,j,k,l :: INT    

      M_gcm=ZERO  
      k=0
      l=0
      do i=1,.n_prim

! if the line is the sme like a previous line do not copy it to do M_gcm 
        if(m_out(i,i)==1) cycle 

        k=k+1
        l=k

        do j=i,.n_prim

! if the column j is the sme like a previous column do not copy it to do M_gcm 
          if(m_out(j,j)==1) cycle

           M_gcm(l,k)=M(j,i)
          l=l+1

        end

      end
    M_gcm.symmetric_reflect
   end

   get_back_prim_now(M_gcm,M,m_out)  
   ! This routine is thought for the final DKH matrix in the non-redundant a-la general contraction
   ! primitive basis set style to get projected back to the tonto primitive often redundant basis set style 
   ! meaning of variables
   ! M_gcm any gcm matrix; input
   ! M primitive matrix; output 
   ! m_out matrix of

      M_gcm :: MAT{CPX} 
      M :: MAT{CPX} 
      m_out :: MAT{INT} 
      i,j,k,l :: INT    


! the routine has three steps
! first those lines(columns) which are non-redundant give back to the same place like they were obtained 
! in the S to S_gcm transformation
! I am not sure if this can not be written in a more effective way
      k=0
      l=0
      do i=1,.n_prim
        if(m_out(i,i)==1)cycle
        k=k+1
        l=k+1
        M(i,i)=M_gcm(k,k)
        do j=i+1,.n_prim
          if(m_out(j,j)==1)cycle
          M(i,j)=M_gcm(k,l)
          M(j,i)=M_gcm(l,k)
          l=l+1
        end
      end

  !   M.symmetric_reflect

! Second copy each line which was deleted back

      do i=1,.n_prim
        if(m_out(i,i)==1) cycle
        do j=i+1,.n_prim
          if(m_out(i,j)==1) then
          do k=1,.n_prim
                M(j,k)=M(i,k) 
              end
            end
        end
      end

! third copy each column which was deleted back

      do i=1,.n_prim
        if(m_out(i,i)==1) cycle
        do j=i+1,.n_prim
          if(m_out(i,j)==1) then
            do k=1,.n_prim
              M(k,j)=M(k,i) 
            end
          end
        end
      end

   end

   make_r_DKH_matrix(H)
   ! the 1electron dkh hamiltonian
   ! in the case of a scalar dkh calculation this routine should be called
   ! this routine is really long I should make it shorter using "subroutines"
   ! but I am lazy in the moment to do so (me=LBxxx)
   !
        H :: MAT{REAL}
        c :: REAL  
        i,j,n_gcm :: INT     
        SOx,SOy,SOz,R :: MAT{REAL}*
        A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
        D,WW,ppZpp :: MAT{REAL}*
        m_out :: MAT{INT}*
        sZ,sPZP :: MAT{REAL}*
        F, M,buco :: MAT{REAL}* 
        P2,E,Ap :: VEC{REAL}*

     ! Make the non-sigular primitive overlap
     ! Repeated primitives are explicitly removed
     R.create(.n_prim,.n_prim)
     .make_primitive_overlap_matrix(R)
     m_out.create(.n_prim,.n_prim) 
     .make_ready_da_gcm_tr2(m_out,n_gcm)  
     S.create(n_gcm,n_gcm)
     .get_da_gcm_now(R,S,m_out)  
     .put_debug(S,"make_r_DKH_matrix: S")

     ! Get transformation from primitive to orthonormal basis
     Y.create(n_gcm,n_gcm)
     Y.to_inverse_sqrt_of(S)

     ! Make the non-singular primitive kinetic matrix
     R=ZERO
     .make_primitive_kinetic_matrix(R) 
     T.create(n_gcm,n_gcm)
     .get_da_gcm_now(R,T,m_out)  
     .put_debug(T,"make_r_DKH_matrix: T")

     ! Change T to orthonormal basis
     A.create(n_gcm,n_gcm)
     A.to_product_of(Y,T)   
     T.to_product_of(A,Y)

     ! Solve T eigenproblem in orthonormal basis
     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     T.solve_eigenproblem(P2,U)
     P2= TWO * P2

     ! Get the non-singular nuclear potential matrix Z
     R=ZERO
     .make_primitive_nuclear_matrix(R)
     Z.create(n_gcm,n_gcm)
     .get_da_gcm_now(R,Z,m_out)  
     .put_debug(Z,"make_r_DKH_matrix: Z")

     ! Change Z to the momentum basis
     A.to_product_of(Y,Z) 
     Z.to_product_of(A,Y)             
     A.to_product_of(U,Z,transpose_a=TRUE)
     Z.to_product_of(A,U)

     ! Make the PZP matrix
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R = ZERO
     .make_primitive_DKH_matrices(R,SOx,SOy,SOz)
     SOx.destroy
     SOy.destroy
     SOz.destroy

     ! Change PZP to the momentum basis
     PZP.create(n_gcm,n_gcm)
     .get_da_gcm_now(R,PZP,m_out)  
     .put_debug(PZP,"make_r_DKH_matrix: PZP")
     A.to_product_of(Y,PZP)  
     PZP.to_product_of(A,Y)
     A.to_product_of(U,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,U)

     ! The DK3 staff
     if(.scfdata.DK3 AND .scfdata.using_ppzpp)then
        ppZpp.create(n_gcm,n_gcm)
        R=ZERO 
        .make_primitive_DK3_ppZpp_mx(R)
        .get_da_gcm_now(R,ppZpp,m_out)  
        A=ZERO
        A.to_product_of(Y,ppZpp) 
        ppZpp.to_product_of(A,Y)             ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 
        A=ZERO
        A.to_product_of(U,ppZpp,transpose_a=TRUE)
        ppZpp.to_product_of(A,U)
     end 

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU

     F.create(n_gcm,n_gcm)
     E.create(n_gcm)
     Ap.create(n_gcm)

     F=ZERO  
     E=ZERO  
     Ap=ZERO  

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c)
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       F(i,i)= E(i) - c * c

     end  

      B.create(n_gcm,n_gcm) 
      A=ZERO

     do i=1,n_gcm
       do j=1,n_gcm

        A(i,j) = Ap(i)*Z(i,j)*Ap(j)
        B(i,j) = c*c*(Ap(i)/(E(i)+c*c))*PZP(i,j)*(Ap(j)/(E(j)+c*c))                                        

       end
     end

     Z = A
     PZP = B

  if(.scfdata.DK1)then
     F = F + Z + PZP
  end

     A=ZERO  
     B=ZERO

  if(.scfdata.DK2)then
     sZ.create(n_gcm,n_gcm)
     sPZP.create(n_gcm,n_gcm)

     do i = 1,n_gcm

         B(i,i)=(c*P2(i)*c) / ( (c*c + E(i)) * (c*c + E(i)) )
         A(i,i)=ONE/B(i,i)

       do j = 1,n_gcm

         sZ(i,j)= Z(i,j) / ( E(i) + E(j) ) 
         sPZP(i,j)= PZP(i,j) / ( E(i) + E(j) ) 

       end
     end

     T= ZERO
     T=  matmul(Z, matmul(B,sZ) )
     T= T - matmul(PZP,sZ) 
     T= T - matmul(Z,sPZP) 
     T= T + matmul(PZP, matmul(A,sPZP) ) 
     T= T + matmul(sZ, matmul(B,Z) )
     T= T - matmul(sZ,PZP) 
     T= T - matmul(sPZP,Z) 
     T= T + matmul(sPZP, matmul(A,PZP) )

     if(.scfdata.using_SO_FDFF) then
       .make_SO_fdff(T)
     end if

     F=F+HALF*T

    if(.scfdata.DK3)then
    ! W1W1
      D.create(n_gcm,n_gcm)
      WW.create(n_gcm,n_gcm)
      WW=ZERO

      WW= - matmul(sZ, matmul(B,sZ) )
      WW= WW + matmul(sPZP,sZ) 
      WW= WW + matmul(sZ,sPZP) 
      WW= WW - matmul(sPZP, matmul(A,sPZP) ) 

      D=ZERO
      T=ZERO
      D=Z+PZP
      T=HALF*(matmul(WW,D)+matmul(D,WW))
      WW.destroy

      if(.scfdata.using_ppzpp)then
        D=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
             D(i,j) = Ap(i)*(c**4)/( (E(i)+c*c)**2)*ppZpp(i,j)*Ap(j)/( (E(j)+c*c)**2 ) 
!          D(i,j) = Ap(i)*(c**4)/( (E(i)+c*c)**2 )*ppZpp(i,j)*Ap(j)/( (E(j)+c*c)**2 ) 
          end
        end
        ppZpp.destroy 
        D=D+PZP
        T=T-matmul(sPZP,matmul(A,matmul(D,sZ)))
        T=T+matmul(sPZP,matmul(A, matmul(D, matmul(A,sPZP))))
        T=T+matmul(sZ,matmul(D,sZ))
        T=T-matmul(sZ,matmul(D, matmul(A,sPZP)))
      else
        T=T-matmul(sPZP,matmul(A,matmul(PZP,sZ)))
        T=T-matmul(sPZP,matmul(Z,matmul(B,sZ)))
        T=T+matmul(sPZP,matmul(A, matmul(PZP, matmul(A,sPZP))))
        T=T+matmul(sPZP,matmul(Z,sPZP))
        T=T+matmul(sZ,matmul(PZP,sZ))
        T=T+matmul(sZ,matmul(B, matmul(Z, matmul(B,sZ))))
        T=T-matmul(sZ,matmul(PZP, matmul(A,sPZP)))
        T=T-matmul(sZ,matmul(B, matmul(Z,sPZP)))
      end if
      F = F + T

      D.destroy
    end if

  end if

     Z.destroy
     PZP.destroy
     sZ.destroy
     sPZP.destroy

     Ap.destroy 
     P2.destroy
     E.destroy

     T.destroy

     A.to_product_of(S,Y)
     B.to_product_of(A,U)

     S.destroy
     Y.destroy
     U.destroy

     A.to_product_of(B,F)
     F.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .get_back_prim_now(F,R,m_out)  
     F.destroy
     m_out.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     .make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy
     A.create(.n_bf,.n_bf)
     A.to_product_of(buco,M)
     M.destroy
     buco.destroy

     H = A
     A.destroy
     .put_debug(H,"make_r_DKH_matrix: H")

   end

   make_r_DKH_matrix2(H)
   ! the 1electron dkh hamiltonian
   ! in the case of a scalar dkh calculation this routine should be called
   ! this routine is really long I should make it shorter using "subroutines"
   ! but I am lazy in the moment to do so (me=LBxxx)
   !
        H :: MAT{REAL}
        c,tol :: REAL  
        n_small,i,j :: INT     
        SOx,SOy,SOz :: MAT{REAL}*
        A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
        evec,D,WW,ppZpp :: MAT{REAL}*
        sZ,sPZP :: MAT{REAL}*
        F,M :: MAT{REAL}* 
        eval,P2,E,Ap :: VEC{REAL}*

      ! Primitive overlap matrix, S
      S.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(S)

      ! Overlap eigenvectors
      Y.create(.n_prim,.n_prim)
      T.create(.n_prim,.n_prim)
      evec.create(.n_prim,.n_prim)
      eval.create(.n_prim)
      S.solve_eigenproblem(eval,evec)

      ! Psuedo-inverse sqrt of overlap, Y
      tol = .scfdata.linear_dependence_tol
      Y.to_inverse_sqrt_of(eval,evec,tol,n_small)
      eval.destroy

      ! Kinetic energy matrix, T
      .make_primitive_kinetic_matrix(T) 

      ! Change T to orthogonal basis
      T.change_basis_using(Y)

      ! Decouple T from linear dependencies
      MOLECULE:decouple_and_shift_r(T,evec,n_small,ZERO)
      evec.destroy

      ! Momentum^2 eigenvalues in orthogonal basis
      U.create(.n_prim,.n_prim)
      P2.create(.n_prim)
      T.solve_eigenproblem(P2,U)
      P2 = TWO*P2
      P2(1:n_small) = ZERO
      .put_debug(P2,"make_r_DKH_matrix2: P2")
      .put_debug(U,"make_r_DKH_matrix2: U")
      .put_debug(matmul(transpose(U),U),"make_r_DKH_matrix2: U^T U")

      ! Electron-nucleus matrix, Z
      Z.create(.n_prim,.n_prim)
      .make_primitive_nuclear_matrix(Z)

      ! Change Z to orthogonal basis
      Z.change_basis_using(Y)
      Z.change_basis_using(U)

      ! PZP matrix
      PZP.create(.n_prim,.n_prim)
      SOx.create(.n_prim,.n_prim)
      SOy.create(.n_prim,.n_prim)
      SOz.create(.n_prim,.n_prim)
      .make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
      SOx.destroy
      SOy.destroy
      SOz.destroy

      ! Change PZP to orthogonal basis, then momentum basis
      PZP.change_basis_using(Y)
      PZP.change_basis_using(U)
      .put_debug(PZP,"make_r_DKH_matrix2: PZP")

      !!! A-O LETS GO !!!
      c = SPEED_OF_LIGHT_AU

      F.create(.n_prim,.n_prim)
      E.create(.n_prim)
      Ap.create(.n_prim)

      F  = ZERO  
      Ap = ZERO  
      do i = 1,.n_prim
         E(i)   = c * sqrt(P2(i) + c*c)
         if (i<=n_small) cycle ! skip small eigenvalues
         F(i,i) = E(i) - c*c
         Ap(i)  = sqrt( (E(i) + c*c)/(TWO*E(i)) )  
      end  

      A.create(.n_prim,.n_prim)
      B.create(.n_prim,.n_prim)
      A = ZERO
      B = ZERO
      do i = n_small+1,.n_prim
      do j = n_small+1,.n_prim
          A(i,j) = Ap(i)*Z(i,j)*Ap(j)
          B(i,j) = c*c * (Ap(i)/(E(i)+c*c)) * PZP(i,j) * (Ap(j)/(E(j)+c*c))
      end
      end

      Z   = A
      PZP = B

      if (.scfdata.DK1) then
         F = F + Z + PZP
      end

      if (.scfdata.DK2) then

         A = ZERO  
         B = ZERO
         do i = n_small+1,.n_prim ! skip small eigenvalues
            B(i,i) = (c*P2(i)*c) / ( (c*c + E(i)) * (c*c + E(i)) )
            A(i,i) = ONE/B(i,i)
         end

         sZ.create(.n_prim,.n_prim)
         sPZP.create(.n_prim,.n_prim)

         sZ = ZERO
         sPZP = ZERO
         do i = n_small+1,.n_prim
         do j = n_small+1,.n_prim
            sZ(i,j)   = Z(i,j)/(E(i)+E(j)) 
            sPZP(i,j) = PZP(i,j)/(E(i)+E(j)) 
         end
         end

         T =     matmul(Z, matmul(B,sZ) )
         T = T + matmul(sZ, matmul(B,Z) )
         T = T - matmul(PZP,sZ) 
         T = T - matmul(sZ,PZP) 
         T = T - matmul(Z,sPZP) 
         T = T - matmul(sPZP,Z) 
         T = T + matmul(PZP, matmul(A,sPZP) ) 
         T = T + matmul(sPZP, matmul(A,PZP) )

       ! if(.scfdata.using_SO_FDFF) then
       !   .make_SO_fdff(T)
       ! end if

         F = F + HALF*T

         if (.scfdata.DK3) then

            ! W1W1
            D.create(.n_prim,.n_prim)
            WW.create(.n_prim,.n_prim)
            WW =    - matmul(sZ, matmul(B,sZ) )
            WW = WW - matmul(sPZP, matmul(A,sPZP) ) 
            WW = WW + matmul(sPZP,sZ) 
            WW = WW + matmul(sZ,sPZP) 

            D = Z + PZP
            T = HALF*(matmul(WW,D)+matmul(D,WW))
            WW.destroy

            if (.scfdata.using_ppzpp) then

               ppZpp.create(.n_prim,.n_prim)
               .make_primitive_DK3_ppZpp_mx(ppZpp)
               ppZpp.change_basis_using(Y)
               ppZpp.change_basis_using(U)

               D = ZERO
               do i = n_small+1,.n_prim
               do j = n_small+1,.n_prim
                  D(i,j) = Ap(i)*(c**4)/( (E(i)+c*c)**2)*ppZpp(i,j)*Ap(j)/( (E(j)+c*c)**2 ) 
               end
               end
               ppZpp.destroy 

               D = D + PZP
               T = T - matmul(sPZP,matmul(A,matmul(D,sZ)))
               T = T - matmul(sZ,matmul(D, matmul(A,sPZP)))
               T = T + matmul(sPZP,matmul(A, matmul(D, matmul(A,sPZP))))
               T = T + matmul(sZ,matmul(D,sZ))
            else
               T = T - matmul(sPZP,matmul(A,matmul(PZP,sZ)))
               T = T - matmul(sZ,matmul(PZP, matmul(A,sPZP)))
               T = T - matmul(sPZP,matmul(Z,matmul(B,sZ)))
               T = T - matmul(sZ,matmul(B, matmul(Z,sPZP)))
               T = T + matmul(sPZP,matmul(A, matmul(PZP, matmul(A,sPZP))))
               T = T + matmul(sPZP,matmul(Z,sPZP))
               T = T + matmul(sZ,matmul(PZP,sZ))
               T = T + matmul(sZ,matmul(B, matmul(Z, matmul(B,sZ))))
            end 

            F = F + T

            D.destroy

         end ! DK3

         sPZP.destroy
         sZ.destroy

      end ! DK2

      Z.destroy
      PZP.destroy

      Ap.destroy 
      P2.destroy
      E.destroy

      T.destroy

      ! Make B = S^(1/2) . momentum eigenvectors
      A.to_product_of(S,Y)
      B.to_product_of(A,U)

      S.destroy
      Y.destroy
      U.destroy

      ! Back transform using B
      F.back_transform_using(B)

      A.destroy
      B.destroy

      ! Moving back to contracted basis sets 
      M.create(.n_prim,.n_bf)
      .make_normalised_contraction_mx(M)

      ! Change back into contracted basis
      F.change_basis_to(H,M)

      M.destroy
      F.destroy

      .put_debug(H,"make_r_DKH_matrix2: H")

   end

   make_r_DKH_matrix3(H)
   ! the 1electron dkh hamiltonian
   ! in the case of a scalar dkh calculation this routine should be called
   ! this routine is really long I should make it shorter using "subroutines"
   ! but I am lazy in the moment to do so (me=LBxxx)
   !
        H :: MAT{REAL}
        c,tol :: REAL  
        i,j,n_gcm,n_small :: INT     
        SOx,SOy,SOz,R :: MAT{REAL}*
        A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
        D,WW,ppZpp :: MAT{REAL}*
        m_out :: MAT{INT}*
        sZ,sPZP :: MAT{REAL}*
        F,M,buco,evec :: MAT{REAL}* 
        P2,E,Ap,eval :: VEC{REAL}*

!!! analysis of the primitive basis set via the overap matrix
!!! trying to lower the problem to an general contracted basis set
!!!  OVERLAP MATRIX !!!
     R.create(.n_prim,.n_prim)
    .make_primitive_overlap_matrix(R)
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm)  
!    .make_ready_da_gcm_tr(R,m_out,n_gcm)  
! put the overlap matrix into the n_gcm non-redundant space
     S.create(n_gcm,n_gcm)
     .get_da_gcm_now(R,S,m_out)  

      Y.create(n_gcm,n_gcm)
      evec.create(n_gcm,n_gcm)
      eval.create(n_gcm)
      S.solve_eigenproblem(eval,evec)

      ! Psuedo-inverse sqrt of overlap, Y
      tol = .scfdata.linear_dependence_tol
      Y.to_inverse_sqrt_of(eval,evec,tol,n_small)
      eval.destroy


    !this works prety baaaad
     A.create(n_gcm,n_gcm)
!     A.to_product_of(Y,Y)
!     S.to_inverse_of(A)

!!!  KINETIC ENERGY MATRIX !!!
     R=ZERO
     .make_primitive_kinetic_matrix(R) 
     T.create(n_gcm,n_gcm)
! put the kinetic energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,T,m_out)  
      ! Change T to orthogonal basis
      T.change_basis_using(Y)
      ! Decouple T from linear dependencies
      MOLECULE:decouple_and_shift_r(T,evec,n_small,ZERO)
      evec.destroy

     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     T.solve_eigenproblem(P2,U)
     P2= TWO * P2
      P2(1:n_small) = ZERO

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     .make_primitive_nuclear_matrix(R)
     Z.create(n_gcm,n_gcm)
! put the potential energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,Z,m_out)  

     A.to_product_of(Y,Z) 
     Z.to_product_of(A,Y)             ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 

     A.to_product_of(U,Z,transpose_a=TRUE)
     Z.to_product_of(A,U)

!!!  PZP MATRIX  !!!
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R=ZERO
         .make_primitive_DKH_matrices(R,SOx,SOy,SOz)

       SOx.destroy
       SOy.destroy
       SOz.destroy

     PZP.create(n_gcm,n_gcm)
! put the PZP matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,PZP,m_out)  
     A.to_product_of(Y,PZP)  
     PZP.to_product_of(A,Y)

     A.to_product_of(U,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,U)
! the DK3 staff
if(.scfdata.DK3 AND .scfdata.using_ppzpp)then
     ppZpp.create(n_gcm,n_gcm)
     R=ZERO 
     .make_primitive_DK3_ppZpp_mx(R)
     .get_da_gcm_now(R,ppZpp,m_out)  
     A=ZERO
     A.to_product_of(Y,ppZpp) 
     ppZpp.to_product_of(A,Y)             ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 
     A=ZERO
     A.to_product_of(U,ppZpp,transpose_a=TRUE)
     ppZpp.to_product_of(A,U)
end if 

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU

     F.create(n_gcm,n_gcm)
     E.create(n_gcm)
     Ap.create(n_gcm)

     F=ZERO  
     E=ZERO  
     Ap=ZERO  

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c)
       if (i<=n_small) cycle ! skip small eigenvalues
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       F(i,i)= E(i) - c * c

     end  

      B.create(n_gcm,n_gcm) 
      A=ZERO

     do i=1,n_gcm
       do j=1,n_gcm

        A(i,j) = Ap(i)*Z(i,j)*Ap(j)
        B(i,j) = c*c*(Ap(i)/(E(i)+c*c))*PZP(i,j)*(Ap(j)/(E(j)+c*c))                                        

       end
     end

     Z = A
     PZP = B

  if(.scfdata.DK1)then
     F = F + Z + PZP
  end

     A=ZERO  
     B=ZERO

  if(.scfdata.DK2)then
     sZ.create(n_gcm,n_gcm)
     sPZP.create(n_gcm,n_gcm)

     do i = 1,n_gcm

         B(i,i)=(c*P2(i)*c) / ( (c*c + E(i)) * (c*c + E(i)) )
         A(i,i)=ONE/B(i,i)

       do j = 1,n_gcm

         sZ(i,j)= Z(i,j) / ( E(i) + E(j) ) 
         sPZP(i,j)= PZP(i,j) / ( E(i) + E(j) ) 

       end
     end

     T= ZERO
     T=  matmul(Z, matmul(B,sZ) )
     T= T - matmul(PZP,sZ) 
     T= T - matmul(Z,sPZP) 
     T= T + matmul(PZP, matmul(A,sPZP) ) 
     T= T + matmul(sZ, matmul(B,Z) )
     T= T - matmul(sZ,PZP) 
     T= T - matmul(sPZP,Z) 
     T= T + matmul(sPZP, matmul(A,PZP) )

     if(.scfdata.using_SO_FDFF) then
       .make_SO_fdff(T)
     end if

     F=F+HALF*T

    if(.scfdata.DK3)then
    ! W1W1
      D.create(n_gcm,n_gcm)
      WW.create(n_gcm,n_gcm)
      WW=ZERO

      WW= - matmul(sZ, matmul(B,sZ) )
      WW= WW + matmul(sPZP,sZ) 
      WW= WW + matmul(sZ,sPZP) 
      WW= WW - matmul(sPZP, matmul(A,sPZP) ) 

      D=ZERO
      T=ZERO
      D=Z+PZP
      T=HALF*(matmul(WW,D)+matmul(D,WW))
      WW.destroy

      if(.scfdata.using_ppzpp)then
        D=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
             D(i,j) = Ap(i)*(c**4)/( (E(i)+c*c)**2)*ppZpp(i,j)*Ap(j)/( (E(j)+c*c)**2 ) 
!          D(i,j) = Ap(i)*(c**4)/( (E(i)+c*c)**2 )*ppZpp(i,j)*Ap(j)/( (E(j)+c*c)**2 ) 
          end
        end
        ppZpp.destroy 
        D=D+PZP
        T=T-matmul(sPZP,matmul(A,matmul(D,sZ)))
        T=T+matmul(sPZP,matmul(A, matmul(D, matmul(A,sPZP))))
        T=T+matmul(sZ,matmul(D,sZ))
        T=T-matmul(sZ,matmul(D, matmul(A,sPZP)))
      else
        T=T-matmul(sPZP,matmul(A,matmul(PZP,sZ)))
        T=T-matmul(sPZP,matmul(Z,matmul(B,sZ)))
        T=T+matmul(sPZP,matmul(A, matmul(PZP, matmul(A,sPZP))))
        T=T+matmul(sPZP,matmul(Z,sPZP))
        T=T+matmul(sZ,matmul(PZP,sZ))
        T=T+matmul(sZ,matmul(B, matmul(Z, matmul(B,sZ))))
        T=T-matmul(sZ,matmul(PZP, matmul(A,sPZP)))
        T=T-matmul(sZ,matmul(B, matmul(Z,sPZP)))
      end if
      F = F + T

      D.destroy
    end if

  end if

     Z.destroy
     PZP.destroy
     sZ.destroy
     sPZP.destroy

     Ap.destroy 
     P2.destroy
     E.destroy

     T.destroy

     A.to_product_of(S,Y)
     B.to_product_of(A,U)

     S.destroy
     Y.destroy
     U.destroy

     A.to_product_of(B,F)
     F.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .get_back_prim_now(F,R,m_out)  
     F.destroy
     m_out.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     .make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy
     A.create(.n_bf,.n_bf)
     A.to_product_of(buco,M)
     M.destroy
     buco.destroy

     H = A
     A.destroy
     .put_debug(H,"make_r_DKH_matrix: H")

   end

   make_DKH_matrices(H,Lx,Ly,Lz)
   ! the DKH with SO interaction  included
   ! only when the scf kind=gchf is involved 
        H, Lx, Ly, Lz :: MAT{REAL}
        c :: REAL  
        i,j,n_gcm :: INT     
        SOx,SOy,SOz :: MAT{REAL}*
        sSOx,sSOy,sSOz :: MAT{REAL}*
        A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
        Cx,Cy,Cz :: MAT{REAL}*
        sZ,sPZP :: MAT{REAL}*
        F, M,buco :: MAT{REAL}* 
        mmm :: MAT{INT}* 
        P2,E,Ap :: VEC{REAL}*

     !test
     mmm.create(.n_prim,.n_prim)
      .get_n_gcm(mmm,n_gcm)
     mmm.destroy 
     if( abs(.n_prim-n_gcm) > 0 )then
       DIE(" It seems you are using contracted gaussians this does not work for DKH at gchf level!")
     end if     

     S.create(.n_prim,.n_prim); .make_primitive_overlap_matrix(S)
     Y.create(.n_prim,.n_prim)
     Y.to_inverse_sqrt_of(S)
     T.create(.n_prim,.n_prim); .make_primitive_kinetic_matrix(T) 

     A.create(.n_prim,.n_prim)
     A.to_product_of(Y,T)   
     T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     U.create(.n_prim,.n_prim)
     P2.create(.n_prim)
     T.solve_eigenproblem(P2,U)
     P2= TWO * P2

     Z.create(.n_prim,.n_prim); .make_primitive_nuclear_matrix(Z)

     A.to_product_of(Y,Z) 
     Z.to_product_of(A,Y)             ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 

     A.to_product_of(U,Z,transpose_a=TRUE)
     Z.to_product_of(A,U)

     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)

         .make_primitive_DKH_matrices(A,SOx,SOy,SOz) 

! lets move the matrices A,SOx,SOy,SOz into the orthonormal basis set 
     PZP.create(.n_prim,.n_prim)
     PZP = A
     A.to_product_of(Y,PZP)  
     PZP.to_product_of(A,Y)
     A.to_product_of(Y,SOx)  
     SOx.to_product_of(A,Y)
     A.to_product_of(Y,SOy)  
     SOy.to_product_of(A,Y)
     A.to_product_of(Y,SOz)  
     SOz.to_product_of(A,Y)

! lets move to the momentum space 
     A.to_product_of(U,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,U)
     A.to_product_of(U,SOx,transpose_a=TRUE)
     SOx.to_product_of(A,U)
     A.to_product_of(U,SOy,transpose_a=TRUE)
     SOy.to_product_of(A,U)
     A.to_product_of(U,SOz,transpose_a=TRUE)
     SOz.to_product_of(A,U)

    .put_debug(SOx,"SOx matrix YU")
    .put_debug(SOy,"SOy matrix YU")
    .put_debug(SOz,"SOz matrix YU")

     c = SPEED_OF_LIGHT_AU

     F.create(.n_prim,.n_prim)
     E.create(.n_prim)
     Ap.create(.n_prim)

     F=ZERO  
     E=ZERO  
     Ap=ZERO  

     do i = 1,.n_prim

       E(i)= c * sqrt(P2(i) + c * c)
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       F(i,i)= E(i) - c * c

     end  

     B.create(.n_prim,.n_prim)
     Cx.create(.n_prim,.n_prim)
     Cy.create(.n_prim,.n_prim)
     Cz.create(.n_prim,.n_prim)
     do i=1,.n_prim
       do j=1,.n_prim

        A(i,j)  = Ap(i)*Z(i,j)*Ap(j)
        B(i,j)  = c*c*(Ap(i)/(E(i)+c*c))*PZP(i,j)*(Ap(j)/(E(j)+c*c))                                        
        Cx(i,j) = c*c*(Ap(i)/(E(i)+c*c))*SOx(i,j)*(Ap(j)/(E(j)+c*c))                                        
        Cy(i,j) = c*c*(Ap(i)/(E(i)+c*c))*SOy(i,j)*(Ap(j)/(E(j)+c*c))                                        
        Cz(i,j) = c*c*(Ap(i)/(E(i)+c*c))*SOz(i,j)*(Ap(j)/(E(j)+c*c))                                        

       end
     end

     Ap.destroy 

     Z = A
     PZP = B
     SOx = Cx
     SOy = Cy
     SOz = Cz
     F = F + Z + PZP

     A=ZERO  
     B=ZERO

     sZ.create(.n_prim,.n_prim)
     sPZP.create(.n_prim,.n_prim)
     sSOx.create(.n_prim,.n_prim)
     sSOy.create(.n_prim,.n_prim)
     sSOz.create(.n_prim,.n_prim)

     do i = 1,.n_prim

         B(i,i)=(c*P2(i)*c) / ( (c*c + E(i)) * (c*c + E(i)) )
         A(i,i)=ONE/B(i,i)

       do j = 1,.n_prim

         sZ(i,j)= Z(i,j) / ( E(i) + E(j) ) 
         sPZP(i,j)= PZP(i,j) / ( E(i) + E(j) ) 
         sSOx(i,j)= SOx(i,j) / ( E(i) + E(j) ) 
         sSOy(i,j)= SOy(i,j) / ( E(i) + E(j) ) 
         sSOz(i,j)= SOz(i,j) / ( E(i) + E(j) ) 

       end
     end

     P2.destroy
     E.destroy

     T= ZERO
     T=  matmul(Z, matmul(B,sZ) )
     T= T - matmul(PZP,sZ) 
     T= T - matmul(Z,sPZP) 
     T= T + matmul(PZP, matmul(A,sPZP) ) 
     T= T + matmul(sZ, matmul(B,Z) )
     T= T - matmul(sZ,PZP) 
     T= T - matmul(sPZP,Z) 
     T= T + matmul(sPZP, matmul(A,PZP) )
 if(.scfdata.using_SO_FDFF) then
 ! these are additional scalar terms due to presence of SO terms
 ! - (SOx*1/P2*sSOx + SOy*1/P2*sSOy + SOz*1/P2*sSOz 
 ! sSOx*1/P2*SOx + sSOy*1/P2*SOy + sSOz*1/P2*SOz) 
     T= T - matmul(SOx, matmul(A,sSOx) ) 
     T= T - matmul(SOy, matmul(A,sSOy) ) 
     T= T - matmul(SOz, matmul(A,sSOz) ) 
     T= T - matmul(sSOx, matmul(A,SOx) )
     T= T - matmul(sSOy, matmul(A,SOy) )
     T= T - matmul(sSOz, matmul(A,SOz) )
 end 
     T=  (ONE/TWO) * T
     F = F + T

  !lets build the DKH x-component SO matrix 
     T= ZERO
     T= T - matmul(SOx,sZ) 
     T= T - matmul(Z,sSOx) 
     T= T + matmul(SOx, matmul(A,sPZP) ) + matmul(PZP, matmul(A,sSOx) ) 
     T= T - matmul(sZ,SOx) 
     T= T - matmul(sSOx,Z) 
     T= T + matmul(sSOx, matmul(A,PZP) ) + matmul(sPZP, matmul(A,SOx) )
 if(.scfdata.using_SO_FDFF) then
  ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa x-component terms   
     T= T - matmul(SOy, matmul(A,sSOz) ) + matmul(SOz, matmul(A,sSOy) ) 
     T= T - matmul(sSOy, matmul(A,SOz) ) + matmul(sSOz, matmul(A,SOy) )
 end 
    T=  (ONE/TWO) * T
 !   SOx ! comes from the E1 hamiltonian counterpart of Ap*P*V*P*Ap scalar term
     Cx= T + SOx
  !lets build the DKH y-component SO matrix 
     T= ZERO
     T= T - matmul(SOy,sZ) 
     T= T - matmul(Z,sSOy) 
     T= T + matmul(SOy, matmul(A,sPZP) ) + matmul(PZP, matmul(A,sSOy) ) 
     T= T - matmul(sZ,SOy) 
     T= T - matmul(sSOy,Z) 
     T= T + matmul(sSOy, matmul(A,PZP) ) + matmul(sPZP, matmul(A,SOy) )
 if(.scfdata.using_SO_FDFF) then
  ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa y-component terms   
     T= T - matmul(SOz, matmul(A,sSOx) ) + matmul(SOx, matmul(A,sSOz) ) 
     T= T - matmul(sSOz, matmul(A,SOx) ) + matmul(sSOx, matmul(A,SOz) )
 end 
     T=  (ONE/TWO) * T
  !  SOy ! comes from the E1 hamiltonian counterpart of Ap*P*V*P*Ap scalar term
     Cy= T + SOy
  !lets build the DKH z-component SO matrix 
     T= ZERO
     T= T - matmul(SOz,sZ) 
     T= T - matmul(Z,sSOz) 
     T= T + matmul(SOz, matmul(A,sPZP) ) + matmul(PZP, matmul(A,sSOz) ) 
     T= T - matmul(sZ,SOz) 
     T= T - matmul(sSOz,Z) 
     T= T + matmul(sSOz, matmul(A,PZP) ) + matmul(sPZP, matmul(A,SOz) )
 if(.scfdata.using_SO_FDFF) then
  ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa z-component terms   
     T= T - matmul(SOx, matmul(A,sSOy) ) + matmul(SOy, matmul(A,sSOx) ) 
     T= T - matmul(sSOx, matmul(A,SOy) ) + matmul(sSOy, matmul(A,SOx) )
 end
     T=  (ONE/TWO) * T
  !  SOz ! comes from the E1 hamiltonian counterpart of Ap*P*V*P*Ap scalar term
     Cz= T + SOz
     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     sZ.destroy
     sPZP.destroy
     sSOx.destroy
     sSOy.destroy
     sSOz.destroy

     T.destroy

     A.to_product_of(S,Y)
     B.to_product_of(A,U)

     S.destroy
     Y.destroy
     U.destroy

     A= ZERO 
     A.to_product_of(B,F)
     F.to_product_of(A,B,transpose_b=TRUE)
     A= ZERO 
     A.to_product_of(B,Cx)
     Cx.to_product_of(A,B,transpose_b=TRUE)
     A= ZERO 
     A.to_product_of(B,Cy)
     Cy.to_product_of(A,B,transpose_b=TRUE)
     A= ZERO 
     A.to_product_of(B,Cz)
     Cz.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

     M.create(.n_prim,.n_bf)
     .make_normalised_contraction_mx(M)

     buco.create(.n_bf,.n_prim)
     buco=ZERO
     buco.to_product_of(M,F,transpose_a=TRUE)
     F.destroy
     A.create(.n_bf,.n_bf)
     A.to_product_of(buco,M)
     H = A

     buco=ZERO
     buco.to_product_of(M,Cx,transpose_a=TRUE)
     Cx.destroy
     A=ZERO
     A.to_product_of(buco,M)
     Lx = A

     buco=ZERO
     buco.to_product_of(M,Cy,transpose_a=TRUE)
     Cy.destroy
     A=ZERO
     A.to_product_of(buco,M)
     Ly = A

     buco=ZERO
     buco.to_product_of(M,Cz,transpose_a=TRUE)
     Cz.destroy
     A=ZERO
     A.to_product_of(buco,M)
     Lz = A

  ! is this really necessary
     .put_debug(H, "make_DKH_matrices: H")
     .put_debug(Lx,"make_DKH_matrices: Lx")
     .put_debug(Ly,"make_DKH_matrices: Ly")
     .put_debug(Lz,"make_DKH_matrices: Lz")

     M.destroy
     buco.destroy
     A.destroy

   end

   make_DKH_density_norm
   !actually this routine does not work properly
   ! it has to be called in the stdin input

     g,ga,gb,norm,norma,normb :: REAL 
     MO,MOa,MOb :: MAT{REAL}*
     D,Da,Db :: MAT{REAL}*

     select case (.scfdata.scf_kind)
       case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted
            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
           .density_DKH_norm(g,norm,D)
            stdout.flush
            stdout.text("renormalization check")
            stdout.flush
            stdout.text("summ  = ")
            stdout.put(g)
            stdout.flush
            stdout.text("norm  = ")
            stdout.put(norm)
       case ("uhf","uks","xray_uhf","xray_uks", &
             "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         ENSURE(.molecular_orbitals.created("unrestricted"),"no MO's")
            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)
           .density_DKH_norm(ga,norma,Da)
           .density_DKH_norm(gb,normb,Db)
            stdout.flush
            stdout.text("renormalization check")
            stdout.flush
            stdout.text("summ alpha  = ")
            stdout.put(ga)
            stdout.flush
            stdout.text("summ beta   = ")
            stdout.put(gb)
            stdout.flush
            stdout.text("summ total  = ")
            stdout.put(ga+gb)
            stdout.flush
            stdout.text("norm alpha  = ")
            stdout.put(norma)
            stdout.flush
            stdout.text("norm beta   = ")
            stdout.put(normb)
            stdout.flush
            stdout.text("norm total  = ")
            stdout.put(ONE/(ga+gb))
            stdout.flush
       case default
         DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))
     end
   end

   density_DKH_norm(g,norm,D)
   ! gives back g and norm the summ and the normalization
   ! constant which is false becasue the wave function is
   ! normalized to the number of electrons and not to unity
   ! in the moment it is so or so not used, but actually
   ! it might be necessary to renormalised due to the dkh transformation
   ! of the density which has to be normalised
  g,norm :: REAL 
  D :: MAT{REAL} , IN
  n_gcm,dim :: INT
  i,j :: INT
  m_out :: MAT{INT}* 
  YU,GG :: MAT{REAL}*
  P2,Ap,Ep :: VEC{REAL}*

    m_out.create(.n_prim,.n_prim)
   .get_n_gcm(m_out,n_gcm)  

    YU.create(n_gcm,n_gcm)
    Ap.create(n_gcm)
    Ep.create(n_gcm)
    P2.create(n_gcm)

   .make_DKH_mxs(YU,Ap,Ep,P2)

     select case (.scfdata.scf_kind)
       case("gchf")
       dim=2*.n_bf
       GG.create(dim,dim)
       case default
       dim=.n_bf
       GG.create(dim,dim)
      .make_DENSITY_norm(GG,YU,Ap,Ep,P2,m_out,n_gcm)
     end        

       g=ZERO

       do i=1,dim
         do j=1,dim
           g = g + D(i,j)*GG(i,j)
         end            
       end            

    norm= ONE / sqrt(g)    

    GG.destroy
    YU.destroy
    Ap.destroy
    Ep.destroy
    P2.destroy
    m_out.destroy

   end

   make_DENSITY_norm(D,YU,Ap,Ep,P2,m_out,n_gcm)
   ! correct the picture change
   ! this routine is based on the make_r_DKH_matrix(H) routine

        D :: MAT{REAL} 
        YU :: MAT{REAL} , IN
        Ap,Ep,P2 :: VEC{REAL} , IN
        m_out :: MAT{INT} , IN
        n_gcm :: INT , IN

        c :: REAL  
        i,j :: INT   
        R :: MAT{REAL}*  
        S,T,SS,Z,PZP,X :: MAT{REAL}*
        XX,WW,W2,sZ,sPZP,TX :: MAT{REAL}*
        Cx,Cy,Cz,SOx,SOy,SOz :: MAT{REAL}*
        A,B :: MAT{REAL}*
        M,buco :: MAT{REAL}* 

!!!  The density matrix S  !!!
     R.create(.n_prim,.n_prim)
     R=ZERO
! it do not exist in the moment
     .make_primitive_overlap_matrix(R)
     S.create(n_gcm,n_gcm)
     SS.create(n_gcm,n_gcm)
! put the S matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,S,m_out)  
     SS=S

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,S,transpose_a=TRUE)
     S.to_product_of(A,YU)

!!!  the (YU)+ T YU MATRIX = Half*P2 diagonal !!!

     T.create(n_gcm,n_gcm)
     T=ZERO
     do i = 1,n_gcm
!       T(i,i)=HALF*P2(i)
       T(i,i)=P2(i)
     end

     if (trim(.scfdata.scf_kind)=="gchf") then
       Cx.create(.n_prim,.n_prim)
       Cy.create(.n_prim,.n_prim)
       Cz.create(.n_prim,.n_prim)
!       .make_primitive_SO_matrices(Cx,Cy,Cz)
       SOx.create(.n_bf,.n_bf)
       .get_da_gcm_now(Cx,SOx,m_out)  
       Cx.destroy 
       SOy.create(.n_bf,.n_bf)
       .get_da_gcm_now(Cy,SOy,m_out)  
       Cy.destroy 
       SOz.create(.n_bf,.n_bf)
       .get_da_gcm_now(Cz,SOz,m_out)  
       Cz.destroy 
     end if 


!!! A-O LETS GO !!!

     B.create(n_gcm,n_gcm) 
     A=ZERO

     c = SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm
        A(i,j) = Ap(i)*S(i,j)*Ap(j)
        B(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*T(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
       end
     end
     S = A
     T = B

     if (trim(.scfdata.scf_kind)== "gchf") then
       do i=1,n_gcm
         do j=1,n_gcm
           SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
           SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
           SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
         end
       end
     end

  if(.scfdata.DK1_PCE) then
     sZ.create(n_gcm,n_gcm) 
     sPZP.create(n_gcm,n_gcm) 
    .make_DKH_mxs2(sZ,sPZP,YU)
  !   do i=1,n_gcm
  !     do j=1,n_gcm

     !   sZ(i,j) = Ap(i)*sZ(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
     !   sPZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*sPZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
     !   sPZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*sPZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )

  !     end
  !   end

     A=ZERO
     B=ZERO

     do i = 1,n_gcm
         B(i,i)=(c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
         A(i,i)=ONE/B(i,i)
     end

     X.create(n_gcm,n_gcm)
     X=ZERO
     X=  matmul(sPZP, matmul(A,T) )
     X= X - matmul(sPZP,S)
     X= X - matmul(sZ,T)
     X= X + matmul(sZ, matmul(B,S) )
     X= X + matmul(S, matmul(B,sZ) )
     X= X - matmul(T,sZ)
     X= X - matmul(S,sPZP)
     X= X + matmul(T, matmul(A,sPZP) )

  end if

   if(.scfdata.DK2_PCE)then
    !!! W1W1
      WW.create(n_gcm,n_gcm)
      WW=ZERO

      WW= - matmul(sZ, matmul(B,sZ) )
      WW= WW + matmul(sPZP,sZ) 
      WW= WW + matmul(sZ,sPZP) 
      WW= WW - matmul(sPZP, matmul(A,sPZP) ) 

      XX.create(n_gcm,n_gcm)
      XX=ZERO
      XX=S+T
      TX.create(n_gcm,n_gcm)
      TX=ZERO
      TX=HALF*(matmul(WW,XX)+matmul(XX,WW))
      WW.destroy

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      Z=ZERO
      PZP=ZERO
      !!!
      XX.destroy

        do i=1,n_gcm
          do j=1,n_gcm
            Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
            PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
          end do
        end do

        TX=TX-matmul(sPZP,matmul(A,matmul(T,sZ)))
        TX=TX-matmul(sPZP,matmul(S,matmul(B,sZ)))
        TX=TX+matmul(sPZP,matmul(A, matmul(T, matmul(A,sPZP))))
        TX=TX+matmul(sPZP, matmul(S,sPZP))
        TX=TX+matmul(sZ,matmul(T,sZ))
        TX=TX+matmul(sZ,matmul(B, matmul(S, matmul(B,sZ))))
        TX=TX-matmul(sZ,matmul(T, matmul(A,sPZP)))
        TX=TX-matmul(sZ,matmul(B, matmul(S,sPZP)))

   !!!  The [W2,X(odd,0)] terms
   !   the second derivatives are not used
        W2.create(n_gcm,n_gcm)
        W2=ZERO
        W2=   matmul( sPZP, matmul(A, matmul(PZP,A) ) )
        W2=W2+matmul( sPZP, Z )
        W2=W2-matmul( sZ, ( matmul(PZP,A) ) )
        W2=W2-matmul( sZ, ( matmul(B,Z) ) )
        W2=W2-matmul( Z,  matmul(sPZP,A)  )
        W2=W2-matmul( PZP,  matmul(sPZP,A)  )
        W2=W2+matmul( Z,  sZ  )
        W2=W2+matmul( PZP,  sZ  )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(W2,T)

        W2=ZERO
        W2=   matmul( sZ, Z )
        W2=W2+matmul( sZ, PZP )
        W2=W2-matmul( matmul(A,sPZP), Z )
        W2=W2-matmul( matmul(A,sPZP), PZP )
        W2=W2-matmul( matmul(A,PZP)  ,   sZ)
        W2=W2-matmul( matmul(Z,B)  ,   sZ)
        W2=W2+matmul( matmul(A,matmul(PZP,A)) , sPZP)
        W2=W2+matmul( Z , sPZP)
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(T,W2)

        W2=ZERO
        W2=W2-matmul( matmul(B,sZ), Z )
        W2=W2-matmul( matmul(B,sZ), PZP )
        W2=W2+matmul( sPZP  ,   Z )
        W2=W2+matmul( sPZP  , PZP )
        W2=W2+matmul( PZP   ,  sZ )
        W2=W2+matmul( matmul(B,matmul(Z,B)) , sZ)
        W2=W2-matmul( matmul(PZP,A) , sPZP )
        W2=W2-matmul( matmul(B,Z) , sPZP )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(S,W2)

        W2=ZERO
        W2=W2-matmul( sPZP  , matmul(A,PZP) )
        W2=W2-matmul( sPZP  , matmul(Z,B) )
        W2=W2+matmul( sZ    , PZP)
        W2=W2+matmul( sZ    , matmul( B, matmul(Z,B) ) )
        W2=W2+matmul( Z , sPZP  )
        W2=W2+matmul( PZP , sPZP  )
        W2=W2-matmul( Z ,  matmul(sZ,B) )
        W2=W2-matmul( PZP ,  matmul(sZ,B) )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do


        TX=TX+matmul(W2,S)

      W2.destroy
      Z.destroy
      PZP.destroy

      end if

    S = S + T
    T.destroy

    if(.scfdata.DK1_PCE)then
      S = S + X
      X.destroy
    end if   

    if(.scfdata.DK2_PCE)then
      S = S + TX
      TX.destroy
    end if

    A=ZERO
    B=ZERO
     B.to_product_of(SS,YU)

     A.to_product_of(B,S)
     S.to_product_of(A,B,transpose_b=TRUE)

     if (trim(.scfdata.scf_kind)=="gchf") then
     A.to_product_of(B,SOx)
     SOx.to_product_of(A,B,transpose_b=TRUE)
     A.to_product_of(B,SOy)
     SOy.to_product_of(A,B,transpose_b=TRUE)
     A.to_product_of(B,SOz)
     SOz.to_product_of(A,B,transpose_b=TRUE)
     end

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .get_back_prim_now(S,R,m_out)  
     S.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
    .make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     A.create(.n_bf,.n_bf)
     A.to_product_of(buco,M)

     if (trim(.scfdata.scf_kind)== "gchf") then
        D.alpha_alpha_plus(A)
        D.beta_beta_plus(A)

       .get_back_prim_now(SOx,R,m_out) 
        SOx.destroy
        buco.to_product_of(M,R,transpose_a=TRUE)
        A.to_product_of(buco,M)

       .get_back_prim_now(SOy,R,m_out)  
        SOy.destroy
        buco.to_product_of(M,R,transpose_a=TRUE)
        A.to_product_of(buco,M)

       .get_back_prim_now(SOy,R,m_out)  
        SOz.destroy
        buco.to_product_of(M,R,transpose_a=TRUE)
        A.to_product_of(buco,M)

     else
        D=A
     end

     A.destroy
     R.destroy
     M.destroy
     buco.destroy


   end

   get_n_gcm(m_out,n)
   ! routine which gains the m_out and n = n_gcm
     m_out :: MAT{INT} , OUT 
     n :: INT , OUT

    .make_ready_da_gcm_tr2(m_out,n)  

   end

   make_SO_fdff(T)
   ! add the fdff scalar correction to T
   !
      T :: MAT{REAL}
      Lx,Ly,Lz :: MAT{REAL}*
      sLx,sLy,sLz :: MAT{REAL}*
      R,SOx,SOy,SOz,A,YU :: MAT{REAL}*
      Ep,Ap,P2 :: VEC{REAL}*
      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      c :: REAL

     m_out.create(.n_prim,.n_prim)
    .get_n_gcm(m_out,n_gcm)
     YU.create(n_gcm,n_gcm)
     Ap.create(n_gcm)
     Ep.create(n_gcm)
     P2.create(n_gcm)
     .make_DKH_mxs(YU,Ap,Ep,P2)
     R.create(.n_prim,.n_prim)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
!!!  PZP and SO MATRICES  !!!
     .make_primitive_DKH_matrices(R,SOx,SOy,SOz)
     R.destroy
!     .get_da_gcm_now(R,PZP,m_out)  
!     A.to_product_of(YU,PZP,transpose_a=TRUE)
!     PZP.to_product_of(A,YU)
     A.create(n_gcm,n_gcm)
     Lx.create(n_gcm,n_gcm)
     Ly.create(n_gcm,n_gcm)
     Lz.create(n_gcm,n_gcm)
     .get_da_gcm_now(SOx,Lx,m_out)  
     A.to_product_of(YU,Lx,transpose_a=TRUE)
     Lx.to_product_of(A,YU)
     .get_da_gcm_now(SOy,Ly,m_out)  
     A.to_product_of(YU,Ly,transpose_a=TRUE)
     Ly.to_product_of(A,YU)
     .get_da_gcm_now(SOz,Lz,m_out)  
     A.to_product_of(YU,Lz,transpose_a=TRUE)
     Lz.to_product_of(A,YU)
     SOx.destroy
     SOy.destroy
     SOx.destroy

     sLx.create(n_gcm,n_gcm)
     sLy.create(n_gcm,n_gcm)
     sLz.create(n_gcm,n_gcm)
     c= SPEED_OF_LIGHT_AU
     A= ZERO

     do i=1,n_gcm

       A(i,i)=( (c*c + Ep(i)) * (c*c + Ep(i)) ) / (c*P2(i)*c)

       do j=1,n_gcm

        Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) 
        Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) 
        Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) 
        sLx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
        sLy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
        sLz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )

       end
     end

       T= T - matmul(Lx, matmul(A,sLx) ) 
       T= T - matmul(Ly, matmul(A,sLy) ) 
       T= T - matmul(Lz, matmul(A,sLz) ) 
       T= T - matmul(sLx, matmul(A,Lx) )
       T= T - matmul(sLy, matmul(A,Ly) )
       T= T - matmul(sLz, matmul(A,Lz) )

     sLx.destroy
     sLy.destroy
     sLx.destroy
     Lx.destroy
     Ly.destroy
     Lx.destroy

     YU.destroy
     Ap.destroy
     Ep.destroy
     P2.destroy
     A.destroy
     m_out.destroy
   end

   make_DKH_mxs4(PPZPP,YU)
   ! get the Z and PZP matrix 
   !  which are in the momentum space
   !
      PPZPP :: MAT{REAL}, OUT
      YU :: MAT{REAL} , IN
      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      R,A,X :: MAT{REAL}*
      c :: REAL
      Ep,P2,Ap :: VEC{REAL}*

     m_out.create(.n_prim,.n_prim)
    .get_n_gcm(m_out,n_gcm)
     R.create(.n_prim,.n_prim)
!!!  PPZPP MATRIX  !!!
     R=ZERO
     .make_primitive_DK3_ppZpp_mx(R)
     .get_da_gcm_now(R,PPZPP,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,PPZPP,transpose_a=TRUE)
     PPZPP.to_product_of(A,YU)

     X.create(n_gcm,n_gcm)
     Ap.create(n_gcm)
     Ep.create(n_gcm)
     P2.create(n_gcm)
     .make_DKH_mxs(X,Ap,Ep,P2)
     c= SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm

        PPZPP(i,j) = c**4*(Ap(i)/(Ep(i)+c*c)**2)*PPZPP(i,j)*(Ap(j)/(Ep(j)+c*c)**2) 

       end
     end

     X.destroy
     Ap.destroy
     Ep.destroy
     Ap.destroy
     R.destroy
     A.destroy
     m_out.destroy

   end

   make_DKH_mxs3(Z,PZP,Lx,Ly,Lz,YU)
   ! get the Z and PZP matrix 
   ! which are in the momentum space
   !
      Z,PZP,Lx,Ly,Lz :: MAT{REAL}
      YU :: MAT{REAL} , IN
      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      c :: REAL
      R,SOx,SOy,SOz,A,X :: MAT{REAL}*
      Ep,Ap,P2 :: VEC{REAL}*

     m_out.create(.n_prim,.n_prim)
    .get_n_gcm(m_out,n_gcm)
     R.create(.n_prim,.n_prim)
!!!  Z MATRIX  !!!
     R=ZERO
     .make_primitive_nuclear_matrix(R)
     .get_da_gcm_now(R,Z,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(A,YU)

     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R=ZERO
!!!  PZP and SO MATRICES  !!!
     .make_primitive_DKH_matrices(R,SOx,SOy,SOz) 
     .get_da_gcm_now(R,PZP,m_out)  
     A.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,YU)
     A=ZERO
     .get_da_gcm_now(SOx,Lx,m_out)  
     A.to_product_of(YU,Lx,transpose_a=TRUE)
     Lx.to_product_of(A,YU)
     A=ZERO
     .get_da_gcm_now(SOy,Ly,m_out)  
     A.to_product_of(YU,Ly,transpose_a=TRUE)
     Ly.to_product_of(A,YU)
     A=ZERO
     .get_da_gcm_now(SOz,Lz,m_out)  
     A.to_product_of(YU,Lz,transpose_a=TRUE)
     Lz.to_product_of(A,YU)

     A.destroy
     R.destroy
     SOx.destroy
     SOy.destroy
     SOx.destroy
     m_out.destroy

     c= SPEED_OF_LIGHT_AU
     X.create(n_gcm,n_gcm)
     Ap.create(n_gcm)
     Ep.create(n_gcm)
     P2.create(n_gcm)
     X=ZERO; Ap=ZERO; Ep=ZERO; P2=ZERO
     .make_DKH_mxs(X,Ap,Ep,P2)
     do i=1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
        PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
        Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
        Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
        Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )

       end
     end

     X.destroy
     Ap.destroy
     Ep.destroy
     P2.destroy

   end

   make_DKH_mxs2(Z,PZP,YU)
   ! get the Z and PZP matrix 
   ! which are in the momentum space
   !
      Z,PZP :: MAT{REAL}
      YU :: MAT{REAL} , IN
      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      R,SOx,SOy,SOz,A,X :: MAT{REAL}*
      c :: REAL
      Ep,P2,Ap :: VEC{REAL}*

     Z=ZERO; PZP=ZERO
     m_out.create(.n_prim,.n_prim)
    .get_n_gcm(m_out,n_gcm)
     R.create(.n_prim,.n_prim)
!!!  Z MATRIX  !!!
     R=ZERO
     .make_primitive_nuclear_matrix(R)
     .get_da_gcm_now(R,Z,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(A,YU)

     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R=ZERO
!!!  PZP MATRIX  !!!
     .make_primitive_DKH_matrices(R,SOx,SOy,SOz) 
     SOx.destroy
     SOy.destroy
     SOx.destroy
     .get_da_gcm_now(R,PZP,m_out) 
     A=ZERO
     A.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,YU)
     X.create(n_gcm,n_gcm)
     Ap.create(n_gcm)
     Ep.create(n_gcm)
     P2.create(n_gcm)
     .make_DKH_mxs(X,Ap,Ep,P2)
     c= SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
        PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )

       end
     end

     X.destroy
     Ap.destroy
     Ep.destroy
     P2.destroy
     R.destroy
     A.destroy
     m_out.destroy
   end

   make_DKH_mxs(YU,Ap,Ep,P2)
   ! things necessary for the DKH transformation 
   ! within the PCE and the dkh_norm staff
   !
     YU :: MAT{REAL} 
     P2,Ap,Ep :: VEC{REAL} 
     m_out :: MAT{INT}* 
     i,n_gcm :: INT
     c :: REAL
     R,S,Y,U :: MAT{REAL}*

     m_out.create(.n_prim,.n_prim)
    .get_n_gcm(m_out,n_gcm)
     YU=ZERO;Ap=ZERO;Ep=ZERO;P2=ZERO
     R.create(.n_prim,.n_prim)
!!!  OVERLAP ENERGY MATRIX  !!!
     R=ZERO
    .make_primitive_overlap_matrix(R)
     S.create(n_gcm,n_gcm)
     S=ZERO 
     .get_da_gcm_now(R,S,m_out)  
     Y.create(n_gcm,n_gcm)
     Y.to_inverse_sqrt_of(S)
!!!  KINETIC ENERGY MATRIX  !!!
     R=ZERO
     S=ZERO
     .make_primitive_kinetic_matrix(R) 
     .get_da_gcm_now(R,S,m_out)  
     m_out.destroy
     R.destroy

     U.create(n_gcm,n_gcm)
     U.to_product_of(Y,S)   
     S.to_product_of(U,Y)   
     U=ZERO
     S.solve_eigenproblem(P2,U)
     S.destroy
     P2= TWO * P2

     c = SPEED_OF_LIGHT_AU
     do i = 1,n_gcm
       Ep(i)= c * sqrt(P2(i) + c * c)
       Ap(i)= sqrt( (Ep(i) + c * c)/(TWO * Ep(i)) )  
     end  

     YU.to_product_of(Y,U)

     Y.destroy
     U.destroy
   end

   make_DKH_mxs3_2(Z,PZP,Lx,Ly,Lz,YU)
   ! get the Z and PZP matrix 
   ! which are in the momentum space
   !
      Z,PZP,Lx,Ly,Lz :: MAT{REAL}
      YU :: MAT{REAL} 
      m_out :: MAT{INT}* 
      i,j,n_gcm :: INT
      c :: REAL
      A,X :: MAT{REAL}*
      Ep,Ap,P2 :: VEC{REAL}*

     m_out.create(.n_prim,.n_prim)
    .get_n_gcm(m_out,n_gcm)
!!!  Z MATRIX  !!!
     Z=ZERO
     .make_primitive_nuclear_matrix(Z)

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(A,YU)

!!!  PZP and SO MATRICES  !!!
     .make_primitive_DKH_matrices(PZP,Lx,Ly,Lz) 
     A.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,Lx,transpose_a=TRUE)
     Lx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,Ly,transpose_a=TRUE)
     Ly.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,Lz,transpose_a=TRUE)
     Lz.to_product_of(A,YU)

     A.destroy
     m_out.destroy

     c= SPEED_OF_LIGHT_AU
     X.create(n_gcm,n_gcm)
     Ap.create(n_gcm)
     Ep.create(n_gcm)
     P2.create(n_gcm)
     X=ZERO; Ap=ZERO; Ep=ZERO; P2=ZERO
     .make_DKH_mxs(X,Ap,Ep,P2)
     do i=1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j) / ( Ep(i) + Ep(j) )
        PZP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PZP(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
        Lx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lx(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
        Ly(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Ly(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )
        Lz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*Lz(i,j)*(Ap(j)/(Ep(j)+c*c)) / ( Ep(i) + Ep(j) )

       end
     end

     X.destroy
     Ap.destroy
     Ep.destroy
     P2.destroy

   end

   make_DKH_mxs_2(YU,Ap,Ep,P2)
   ! things necessary for the DKH transformation 
   ! within the PCE and the dkh_norm staff
   !
     YU :: MAT{REAL} 
     P2,Ap,Ep :: VEC{REAL} 
     m_out :: MAT{INT}* 
     i,n_gcm :: INT
     c :: REAL
     S,Y,U :: MAT{REAL}*

     m_out.create(.n_prim,.n_prim)
    .get_n_gcm(m_out,n_gcm)
     YU=ZERO;Ap=ZERO;Ep=ZERO;P2=ZERO
     S.create(.n_prim,.n_prim)
!!!  OVERLAP ENERGY MATRIX  !!!
     S=ZERO
    .make_primitive_overlap_matrix(S)
     Y.create(n_gcm,n_gcm)
     Y.to_inverse_sqrt_of(S)
!!!  KINETIC ENERGY MATRIX  !!!
     S=ZERO
     .make_primitive_kinetic_matrix(S) 
     m_out.destroy

     U.create(n_gcm,n_gcm)
     U.to_product_of(Y,S)   
     S.to_product_of(U,Y)   
     U=ZERO
     S.solve_eigenproblem(P2,U)
     S.destroy
     P2= TWO * P2

     c = SPEED_OF_LIGHT_AU
     do i = 1,n_gcm
       Ep(i)= c * sqrt(P2(i) + c * c)
       Ap(i)= sqrt( (Ep(i) + c * c)/(TWO * Ep(i)) )  
     end  

     YU.to_product_of(Y,U)

     Y.destroy
     U.destroy
   end

   make_DKH_density_grid(density_grid,pt,sgn)
   ! this is kevin
   ! here begins the PCE correction of density
   ! welcome
     density_grid :: VEC{REAL} 
     pt :: MAT{REAL}
     sgn :: INT, IN, optional

     fac :: REAL
     MO,MOa,MOb :: MAT{REAL}*
     CMO :: MAT{CPX}*
     D,Da,Db :: MAT{REAL}*
     CD :: MAT{CPX}*
     grid_a,grid_b :: VEC{REAL}*

     select case (.scfdata.scf_kind)

        case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
           ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
           ENSURE(.spin_multiplicity==1,"this is not a singlet state")
           MO => .molecular_orbitals.restricted(:,1:.n_a)
           D  => .density_matrix.restricted
           D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
           grid_a.create(pt.dim1)
           .density_DKH(grid_a,pt,D)
           density_grid=grid_a
           grid_a.destroy
 
        case ("uhf","uks","xray_uhf","xray_uks", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           ENSURE(.molecular_orbitals.created("unrestricted"),"no MO's")
           MOa => .molecular_orbitals.alpha(:,1:.n_a)
           MOb => .molecular_orbitals.beta(:,1:.n_b)
           Da => .density_matrix.alpha
           Db => .density_matrix.beta
           Da.to_product_of(MOa,MOa,transpose_b=TRUE)
           Db.to_product_of(MOb,MOb,transpose_b=TRUE)
           grid_a.create(pt.dim1)
           grid_b.create(pt.dim1)
           .density_DKH(grid_a,pt,Da)
           .density_DKH(grid_b,pt,Db)
           if (present(sgn)) then; fac = -ONE
           else;                   fac = ONE
           end
           density_grid= grid_a 
           density_grid= density_grid + fac * grid_b 
           grid_a.destroy
           grid_b.destroy
 
        case ("gchf")
           ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")
           CD => .density_matrix.general_complex
           CMO => .molecular_orbitals.general_complex(:,1:.n_e)
           CD.to_product_of(CMO,CMO,dagger_b=TRUE)
           .density_DKH_gc(density_grid,pt,CD)
 
        case default
           DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))

     end

   end

   density_DKH(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{REAL} , OUT
    pt :: MAT{REAL} , IN
    D :: MAT{REAL} , IN
    n_gcm,n_pt :: INT
    n,i,j :: INT
    g :: REAL
    m_out :: MAT{INT}* 
    YU,GG,S,R,sZ,sPZP,PPZPP :: MAT{REAL}*
    P2,Ap,Ep :: VEC{REAL}*

    n_pt = pt.dim1


    m_out.create(.n_prim,.n_prim)
   .get_n_gcm(m_out,n_gcm)  
    R.create(.n_prim,.n_prim)
   .make_primitive_overlap_matrix(R)
    S.create(n_gcm,n_gcm)
    S=ZERO 
   .get_da_gcm_now(R,S,m_out) 
    R.destroy 

    YU.create(n_gcm,n_gcm)
    Ap.create(n_gcm)
    Ep.create(n_gcm)
    P2.create(n_gcm)

   .make_DKH_mxs(YU,Ap,Ep,P2)

    sZ.create(n_gcm,n_gcm)
    sPZP.create(n_gcm,n_gcm)
   .make_DKH_mxs2(sZ,sPZP,YU)

   if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
     WARN(" The use_ppzpp seems to give larger value of density at nucleus for very large exponents in the basis set E+08")
     PPZPP.create(n_gcm,n_gcm)
     .make_DKH_mxs4(PPZPP,YU)
   end if

    GG.create(.n_bf,.n_bf)
    do n = 1,n_pt
       GG=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to it's non-relativistic
! counter part really not effective :(
     .make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,sZ,sPZP,PPZPP)

       g=ZERO

       do i=1,.n_bf
         do j=1,.n_bf
           g = g + D(i,j)*GG(i,j)
         end            
       end            

       density_grid(n)= g
      end

    S.destroy
    sZ.destroy
    sPZP.destroy
    GG.destroy
    YU.destroy
    Ap.destroy
    Ep.destroy
    P2.destroy
    m_out.destroy

   if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
    PPZPP.destroy
   end if
   end

   density_DKH_gc_old(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{REAL} , OUT
    pt :: MAT{REAL} , IN
    D :: MAT{CPX} , IN
    n_gcm,n_pt :: INT
    n,i,j :: INT
    g :: REAL
    gc,II :: CPX
    fac :: REAL
    m_out :: MAT{INT}* 
    YU,GG,S,R,Z,PZP,PPZPP :: MAT{REAL}*
    GGx,GGy,GGz :: MAT{REAL}*
    SOx,SOy,SOz :: MAT{REAL}*
    GG22 :: MAT{CPX}*
    P2,Ap,Ep :: VEC{REAL}*

    n_pt = pt.dim1

    m_out.create(.n_prim,.n_prim)
   .get_n_gcm(m_out,n_gcm) 
   !test
     if( abs(.n_prim-n_gcm) > 0 )then
       DIE(" It seems you are using contracted gaussians this does not work for DKH at gchf level!")
     end if     
   !  
    R.create(.n_prim,.n_prim)
   .make_primitive_overlap_matrix(R)
    S.create(n_gcm,n_gcm)
    S=ZERO 
   .get_da_gcm_now(R,S,m_out) 
    R.destroy 

    YU.create(n_gcm,n_gcm)
    Ap.create(n_gcm)
    Ep.create(n_gcm)
    P2.create(n_gcm)

   .make_DKH_mxs(YU,Ap,Ep,P2)

    Z.create(n_gcm,n_gcm)
    PZP.create(n_gcm,n_gcm)
    SOx.create(n_gcm,n_gcm)
    SOy.create(n_gcm,n_gcm)
    SOz.create(n_gcm,n_gcm)
    ! actually the output matrices are the sX matrices (see DKH for the
    ! use of the s index) 
   .make_DKH_mxs3(Z,PZP,SOx,SOy,SOz,YU)

    GG22.create(2*.n_bf,2*.n_bf)
    GG.create(.n_bf,.n_bf)
    GGx.create(.n_bf,.n_bf)
    GGy.create(.n_bf,.n_bf)
    GGz.create(.n_bf,.n_bf)
    II=(ZERO,ONE)
    fac= ONE

    if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      WARN(" The use_ppzpp seems to give larger value of density at nucleus")
      PPZPP.create(n_gcm,n_gcm)
      .make_DKH_mxs4(PPZPP,YU)
    end if

    do n = 1,n_pt
       GG22=(ZERO,ZERO)
       GG=ZERO
       GGx=ZERO
       GGy=ZERO
       GGz=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to it's non-relativistic
! counter part really not effective :(
     .make_DENSITY_PCE_SO_off(GG,GGx,GGy,GGz,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,Z,PZP,SOx,SOy,SOz,PPZPP)

       gc=(ZERO,ZERO)
            GG22.alpha_alpha_plus(GG)
            GG22.beta_beta_plus(GG)
            GG22.beta_alpha_plus(GGx,fac*II)
            GG22.beta_alpha_plus(GGy,-fac)
            GG22.alpha_alpha_plus(GGz,fac*II)
            GG22.beta_beta_plus(GGz,-fac*II)
            GG22.make_hermitian

       do i=1,2*.n_bf
         do j=1,2*.n_bf
           gc = gc + D(i,j)*GG22(i,j)
         end            
       end            
       g=ZERO
       g= real(gc)      
       density_grid(n)= g
    end

    if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      PPZPP.destroy
    end if

    S.destroy
    Z.destroy
    PZP.destroy
    SOx.destroy
    SOy.destroy
    SOz.destroy
    GG22.destroy
    GG.destroy
    GGx.destroy
    GGy.destroy
    GGz.destroy
    YU.destroy
    Ap.destroy
    Ep.destroy
    P2.destroy
    m_out.destroy
   end

   density_DKH_gc(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{REAL} , OUT
    pt :: MAT{REAL} , IN
    D :: MAT{CPX} , IN
    m_out :: MAT{INT}*
    n_gcm,n_pt :: INT
    n,i,j :: INT
    g,fac :: REAL
    gc,II :: CPX
    YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
    Z2,PZP2 :: MAT{CPX}*
    SOx,SOy,SOz :: MAT{REAL}*
    GG22 :: MAT{CPX}*
    P2,Ap,Ep :: VEC{REAL}*

    n_pt = pt.dim1

    m_out.create(.n_prim,.n_prim)
   .get_n_gcm(m_out,n_gcm) 
   !test
     if( abs(.n_prim-n_gcm) > 0 AND abs(.n_prim-.n_bf) > 0 )then
       DIE(" It seems you are using contracted gaussians this does not work for DKH at gchf level!")
     end if     
   !  
    R.create(.n_prim,.n_prim)
    S.create(n_gcm,n_gcm)
    S=ZERO 
   .make_primitive_overlap_matrix(S)
!   .get_da_gcm_now(R,S,m_out) 
     R.destroy 

    YU.create(n_gcm,n_gcm)
    Ap.create(n_gcm)
    Ep.create(n_gcm)
    P2.create(n_gcm)

   .make_DKH_mxs_2(YU,Ap,Ep,P2)

    Z.create(n_gcm,n_gcm)
    PZP.create(n_gcm,n_gcm)
    SOx.create(n_gcm,n_gcm)
    SOy.create(n_gcm,n_gcm)
    SOz.create(n_gcm,n_gcm)
    ! actually the output matrices are the sX matrices (see DKH for the
    ! use of the s index) 
   .make_DKH_mxs3_2(Z,PZP,SOx,SOy,SOz,YU)
    Z2.create(2*n_gcm,2*n_gcm)
    PZP2.create(2*n_gcm,2*n_gcm)
    II=(ZERO,ONE)
    fac= ONE
    Z2=(ZERO,ZERO)
    PZP2=(ZERO,ZERO)
     Z2.alpha_alpha_plus(Z)
     Z2.beta_beta_plus(Z)
     PZP2.alpha_alpha_plus(PZP)
     PZP2.beta_beta_plus(PZP)
     PZP2.beta_alpha_plus(SOx,fac*II)
     PZP2.beta_alpha_plus(SOy,-fac)
     PZP2.alpha_alpha_plus(SOz,fac*II)
     PZP2.beta_beta_plus(SOz,-fac*II)
     PZP2.make_hermitian
       Z.destroy
       PZP.destroy
       SOx.destroy
       SOy.destroy
       SOz.destroy

    GG22.create(2*.n_bf,2*.n_bf)

    if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      WARN(" The use_ppzpp seems to give larger value of density at nucleus")
      PPZPP.create(n_gcm,n_gcm)
      .make_DKH_mxs4(PPZPP,YU)
    end if

    do n = 1,n_pt
       GG22=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to it's non-relativistic
! counter part really not effective :(
     .make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,Z2,PZP2)

       gc=(ZERO,ZERO)
 !           GG22.make_hermitian

       do i=1,2*.n_bf
         do j=1,2*.n_bf
!    density should be j,i
             gc = gc + D(j,i)*GG22(i,j)
         end            
       end            
       g=ZERO
       g= real(gc)      
       density_grid(n)= g
    end

    if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      PPZPP.destroy
    end if

    S.destroy
    Z2.destroy
    PZP2.destroy
    GG22.destroy
    YU.destroy
    Ap.destroy
    Ep.destroy
    P2.destroy
    m_out.destroy
   end

   make_PCE_off(GG,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,met,PPZPP)
   ! correct the picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_DKH_1e_matrix(H) routine

        GG :: MAT{CPX} , OUT
        YU :: MAT{REAL} , IN
        Ap,Ep,P2 :: VEC{REAL} , IN
        xx,yy,zz :: REAL , IN
        m_out :: MAT{INT} , IN
        n_gcm :: INT , IN
        S,sZ,sPZP :: MAT{REAL} , IN
        met :: INT, IN , optional
        PPZPP :: MAT{REAL} , IN , optional

        c :: REAL  
        i,j,k :: INT   
        R,D,PDP,PPDPP,Ac,T,TX,X,buco :: MAT{CPX}*  
        WW,W2 :: MAT{REAL}*
        SOx,SOy,SOz,sPZPx,sPZPy,sPZPz,ZXX,PZPXX :: MAT{REAL}*
        Rx,Ry,Rz :: MAT{REAL}*
        A,B,Z,PZP :: MAT{REAL}*
        M :: MAT{REAL}* 

!!!  the density operator X !!!
     R.create(.n_prim,.n_prim)
     R=ZERO
! it do not exist in the moment
     select case (met)
       case(1)
         .make_primitive_ft_matrix(R,xx,yy,zz)
       case default
         DIE("unknown value of method ")
     end        
     D.create(n_gcm,n_gcm)
     D=ZERO
! put the potential energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,D,m_out)  

     Ac.create(n_gcm,n_gcm)
     Ac.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(Ac,YU)

!!!  PDP MATRIX  !!!
      R=ZERO
     select case (met)
       case(1)
         .make_primitive_pftp_matrix(R,xx,yy,zz)
      ! R=ZERO
      ! WARN("pFTp=ZERO")
       case default
         DIE("unknown value of method ")
     end        

     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
! put the PDP matrix into the n_gcm non-redundant space
    .get_da_gcm_now(R,PDP,m_out)  
     Ac=ZERO
     Ac.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(Ac,YU)

   if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      R=ZERO 
      DIE("the <ppftpp> are not finished switch the use_ppzpp off")
!      .make_primitive_ppDpp_matrix(R,xx,yy,zz) 
!      PPDPP.create(n_gcm,n_gcm)
!      .get_da_gcm_now(R,PPDPP,m_out)  
!      A=ZERO
!      A.to_product_of(YU,PPDPP,transpose_a=TRUE)
!      PPDPP.to_product_of(A,YU)
  end if 

!!! A-O LETS GO !!!

     c = SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm

        D(i,j) = Ap(i)*D(i,j)*Ap(j)
        PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))                                        

       end
     end

     A.create(n_gcm,n_gcm) 
     B.create(n_gcm,n_gcm) 
     A=ZERO
     B=ZERO  

  if(.scfdata.DK1_PCE)then
     do i = 1,n_gcm
         B(i,i)=(c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
         A(i,i)=ONE/B(i,i)
     end do

    T.create(n_gcm,n_gcm)
    T=ZERO
    T= matmul(sPZP, matmul(A,PDP) )
    T= T - matmul(sPZP,D)
    T= T - matmul(sZ,PDP)
    T= T + matmul(sZ, matmul(B,D) )
    T= T + matmul(D, matmul(B,sZ) )
    T= T - matmul(PDP,sZ)
    T= T - matmul(D,sPZP)
    T= T + matmul(PDP, matmul(A,sPZP) )
     if(.scfdata.using_SO_FDFF) then
     DIE("using_SO_FDFF not to be used with PCE corr of ft ")
     ! these are additional scalar terms due to presence of SO terms
     ! - (SOx*1/P2*sSOx + SOy*1/P2*sSOy + SOz*1/P2*sSOz 
     ! sSOx*1/P2*SOx + sSOy*1/P2*SOy + sSOz*1/P2*SOz)
!!!  SO MATRICES  !!!
      Rx.create(.n_prim,.n_prim)
      Ry.create(.n_prim,.n_prim)
      Rz.create(.n_prim,.n_prim)
      Rx=ZERO; Ry=ZERO; Rz=ZERO
     .make_primitive_pDp_SO_matrix(Rx,Ry,Rz,xx,yy,zz) 

     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
! put the SO matrices into the n_gcm non-redundant space
    .get_da_gcm_now(Rx,SOx,m_out)  
    Rx.destroy
    .get_da_gcm_now(Ry,SOy,m_out)  
    Ry.destroy
    .get_da_gcm_now(Rz,SOz,m_out)  
    Rz.destroy
       ZXX.create(n_gcm,n_gcm); PZPXX.create(n_gcm,n_gcm) 
     ZXX=ZERO
     ZXX.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(ZXX,YU)
     ZXX=ZERO
     ZXX.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(ZXX,YU)
     ZXX=ZERO
     ZXX.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(ZXX,YU)
     do i=1,n_gcm
       do j=1,n_gcm
        SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
        SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
        SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
       end
     end
       sPZPx.create(n_gcm,n_gcm); sPZPy.create(n_gcm,n_gcm); sPZPz.create(n_gcm,n_gcm)
       .make_DKH_mxs3(ZXX,PZPXX,sPZPx,sPZPy,sPZPz,YU)
       ZXX.destroy; PZPXX.destroy
       T= T - matmul(SOx, matmul(A,sPZPx) ) 
       T= T - matmul(SOy, matmul(A,sPZPy) ) 
       T= T - matmul(SOz, matmul(A,sPZPz) ) 
       T= T - matmul(sPZPx, matmul(A,SOx) )
       T= T - matmul(sPZPy, matmul(A,SOy) )
       T= T - matmul(sPZPz, matmul(A,SOz) )
       SOx.destroy; SOy.destroy; SOz.destroy;
       sPZPx.destroy; sPZPy.destroy; sPZPz.destroy;
     end if

    if(.scfdata.DK2_PCE)then
    !!! W1W1
      WW.create(n_gcm,n_gcm)
      WW=ZERO

      WW= - matmul(sZ, matmul(B,sZ) )
      WW= WW + matmul(sPZP,sZ) 
      WW= WW + matmul(sZ,sPZP) 
      WW= WW - matmul(sPZP, matmul(A,sPZP) ) 

      X.create(n_gcm,n_gcm)
      X=ZERO
      X=D+PDP
      TX.create(n_gcm,n_gcm)
      TX=ZERO
      TX=HALF*(matmul(WW,X)+matmul(X,WW))
      WW.destroy

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      Z=ZERO
      PZP=ZERO
      !!!
      X=ZERO

      if(.scfdata.using_ppzpp)then
! use the second derivatives in the [W1,[W1,X(even,0)]] and [W2,X(odd,0)] terms   
        do i=1,n_gcm
          do j=1,n_gcm
            PPDPP(i,j) = Ap(i)*(c**4)/((Ep(i)+c*c)**2)*PPDPP(i,j)*Ap(j)/( (Ep(j)+c*c)**2 ) 
            Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
            PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
          end do
        end do
        X=PPDPP+PDP
        TX=TX-matmul(sPZP,matmul(A,matmul(X,sZ)))
        TX=TX+matmul(sPZP,matmul(A, matmul(X, matmul(A,sPZP))))
        TX=TX+matmul(sZ,matmul(X,sZ))
        TX=TX-matmul(sZ,matmul(X, matmul(A,sPZP)))
        PPDPP.destroy 
        X.destroy

   !!!  The -[W2,X(odd,0)] terms
        W2.create(n_gcm,n_gcm)
        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              + sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
              - sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
              - (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )*A(j,j)  & 
              + (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   
            end do
          end do
        end do
        TX=TX+matmul(W2,PDP)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              + sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              - A(i,i)*sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              - A(i,i)*(PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )  &
              + A(i,i)*(PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )  
            end do
          end do
        end do
        TX=TX+matmul(PDP,W2)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              -  B(i,i)*sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              +  sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              +  (PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   &
              -  (PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )   
            end do
          end do
        end do
        TX=TX+matmul(D,W2)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                         &
             -  sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
             +  sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
             +  (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )    &
             -  (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )*B(j,j)    
            end do
          end do
        end do
        TX=TX+matmul(W2,D)

! the second derivatives are not used in the [W1,[W1,E(even,0)]] and [W2,X(odd,0)] terms   
      else  
        X.destroy
        do i=1,n_gcm
          do j=1,n_gcm
            Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
            PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
          end do
        end do
        TX=TX-matmul(sPZP,matmul(A,matmul(PDP,sZ)))
        TX=TX-matmul(sPZP,matmul(D,matmul(B,sZ)))
        TX=TX+matmul(sPZP,matmul(A, matmul(PDP, matmul(A,sPZP))))
        TX=TX+matmul(sPZP, matmul(D,sPZP))
        TX=TX+matmul(sZ,matmul(PDP,sZ))
        TX=TX+matmul(sZ,matmul(B, matmul(D, matmul(B,sZ))))
        TX=TX-matmul(sZ,matmul(PDP, matmul(A,sPZP)))
        TX=TX-matmul(sZ,matmul(B, matmul(D,sPZP)))

   !!!  The [W2,X(odd,0)] terms
   !   the second derivatives are not used
        W2.create(n_gcm,n_gcm)
        W2=ZERO
        W2=   matmul( sPZP, matmul(A, matmul(PZP,A) ) )
        W2=W2+matmul( sPZP, Z )
        W2=W2-matmul( sZ, ( matmul(PZP,A) ) )
        W2=W2-matmul( sZ, ( matmul(B,Z) ) )
        W2=W2-matmul( Z,  matmul(sPZP,A)  )
        W2=W2-matmul( PZP,  matmul(sPZP,A)  )
        W2=W2+matmul( Z,  sZ  )
        W2=W2+matmul( PZP,  sZ  )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(W2,PDP)

        W2=ZERO
        W2=   matmul( sZ, Z )
        W2=W2+matmul( sZ, PZP )
        W2=W2-matmul( matmul(A,sPZP), Z )
        W2=W2-matmul( matmul(A,sPZP), PZP )
        W2=W2-matmul( matmul(A,PZP)  ,   sZ)
        W2=W2-matmul( matmul(Z,B)  ,   sZ)
        W2=W2+matmul( matmul(A,matmul(PZP,A)) , sPZP)
        W2=W2+matmul( Z , sPZP)
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(PDP,W2)

        W2=ZERO
        W2=W2-matmul( matmul(B,sZ), Z )
        W2=W2-matmul( matmul(B,sZ), PZP )
        W2=W2+matmul( sPZP  ,   Z )
        W2=W2+matmul( sPZP  , PZP )
        W2=W2+matmul( PZP   ,  sZ )
        W2=W2+matmul( matmul(B,matmul(Z,B)) , sZ)
        W2=W2-matmul( matmul(PZP,A) , sPZP )
        W2=W2-matmul( matmul(B,Z) , sPZP )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(D,W2)

        W2=ZERO
        W2=W2-matmul( sPZP  , matmul(A,PZP) )
        W2=W2-matmul( sPZP  , matmul(Z,B) )
        W2=W2+matmul( sZ    , PZP)
        W2=W2+matmul( sZ    , matmul( B, matmul(Z,B) ) )
        W2=W2+matmul( Z , sPZP  )
        W2=W2+matmul( PZP , sPZP  )
        W2=W2-matmul( Z ,  matmul(sZ,B) )
        W2=W2-matmul( PZP ,  matmul(sZ,B) )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do


        TX=TX+matmul(W2,D)

      end if
      W2.destroy
      Z.destroy
      PZP.destroy

      end if
    end if
    A.destroy
    B=ZERO

    D = D + PDP
    PDP.destroy
    if(.scfdata.DK1_PCE)then
      D = D + T
      T.destroy
    end if   

    if(.scfdata.DK2_PCE)then
      D = D + TX
      TX.destroy
    end if

     B.to_product_of(S,YU)

     Ac.to_product_of(B,D)
     D.to_product_of(Ac,B,transpose_b=TRUE)

     Ac.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .get_back_prim_now(D,R,m_out)  
     D.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
    .make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy

     GG.to_product_of(buco,M)

     M.destroy
     buco.destroy
   end   

   make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,PPZPP)
   ! correct the picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_matrix(H) routine

        GG :: MAT{REAL} , OUT
        YU :: MAT{REAL} , IN
        Ap,Ep,P2 :: VEC{REAL} , IN
        xx,yy,zz :: REAL , IN
        m_out :: MAT{INT} , IN
        n_gcm :: INT , IN
        S,sZ,sPZP :: MAT{REAL} , IN
        PPZPP :: MAT{REAL} , IN , optional

        c :: REAL  
        i,j,k :: INT   
        R :: MAT{REAL}*  
        D,PDP,PPDPP,T,WW,W2,X,TX :: MAT{REAL}*
        SOx,SOy,SOz,sPZPx,sPZPy,sPZPz,ZXX,PZPXX :: MAT{REAL}*
        Rx,Ry,Rz :: MAT{REAL}*
        A,B,Z,PZP :: MAT{REAL}*
        M,buco :: MAT{REAL}* 

!!!  the density operator X !!!
     R.create(.n_prim,.n_prim)
     R=ZERO
! it do not exist in the moment
     .make_primitive_density_matrix(R,xx,yy,zz)
     D.create(n_gcm,n_gcm)
     D=ZERO
! put the potential energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,D,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)

!!!  PDP MATRIX  !!!
      R=ZERO
     .make_primitive_pDp_matrix(R,xx,yy,zz) 

     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
! put the PDP matrix into the n_gcm non-redundant space
    .get_da_gcm_now(R,PDP,m_out)  
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)

   if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      R=ZERO 
      .make_primitive_ppDpp_matrix(R,xx,yy,zz) 
      PPDPP.create(n_gcm,n_gcm)
      .get_da_gcm_now(R,PPDPP,m_out)  
      A=ZERO
      A.to_product_of(YU,PPDPP,transpose_a=TRUE)
      PPDPP.to_product_of(A,YU)
  end if 

!!! A-O LETS GO !!!

     c = SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm

        D(i,j) = Ap(i)*D(i,j)*Ap(j)
        PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))                                        

       end
     end

     B.create(n_gcm,n_gcm) 
     A=ZERO
     B=ZERO  

  if(.scfdata.DK1_PCE)then
     do i = 1,n_gcm
         B(i,i)=(c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
         A(i,i)=ONE/B(i,i)
     end do

    T.create(n_gcm,n_gcm)
    T=ZERO
    T= matmul(sPZP, matmul(A,PDP) )
    T= T - matmul(sPZP,D)
    T= T - matmul(sZ,PDP)
    T= T + matmul(sZ, matmul(B,D) )
    T= T + matmul(D, matmul(B,sZ) )
    T= T - matmul(PDP,sZ)
    T= T - matmul(D,sPZP)
    T= T + matmul(PDP, matmul(A,sPZP) )
     if(.scfdata.using_SO_FDFF) then
     ! these are additional scalar terms due to presence of SO terms
     ! - (SOx*1/P2*sSOx + SOy*1/P2*sSOy + SOz*1/P2*sSOz 
     ! sSOx*1/P2*SOx + sSOy*1/P2*SOy + sSOz*1/P2*SOz)
!!!  SO MATRICES  !!!
      Rx.create(.n_prim,.n_prim)
      Ry.create(.n_prim,.n_prim)
      Rz.create(.n_prim,.n_prim)
      Rx=ZERO; Ry=ZERO; Rz=ZERO
     .make_primitive_pDp_SO_matrix(Rx,Ry,Rz,xx,yy,zz) 

     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
! put the SO matrices into the n_gcm non-redundant space
    .get_da_gcm_now(Rx,SOx,m_out)  
    Rx.destroy
    .get_da_gcm_now(Ry,SOy,m_out)  
    Ry.destroy
    .get_da_gcm_now(Rz,SOz,m_out)  
    Rz.destroy
       ZXX.create(n_gcm,n_gcm); PZPXX.create(n_gcm,n_gcm) 
     ZXX=ZERO
     ZXX.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(ZXX,YU)
     ZXX=ZERO
     ZXX.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(ZXX,YU)
     ZXX=ZERO
     ZXX.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(ZXX,YU)
     do i=1,n_gcm
       do j=1,n_gcm
        SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
        SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
        SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
       end
     end
       sPZPx.create(n_gcm,n_gcm); sPZPy.create(n_gcm,n_gcm); sPZPz.create(n_gcm,n_gcm)
       .make_DKH_mxs3(ZXX,PZPXX,sPZPx,sPZPy,sPZPz,YU)
       ZXX.destroy; PZPXX.destroy
       T= T - matmul(SOx, matmul(A,sPZPx) ) 
       T= T - matmul(SOy, matmul(A,sPZPy) ) 
       T= T - matmul(SOz, matmul(A,sPZPz) ) 
       T= T - matmul(sPZPx, matmul(A,SOx) )
       T= T - matmul(sPZPy, matmul(A,SOy) )
       T= T - matmul(sPZPz, matmul(A,SOz) )
       SOx.destroy; SOy.destroy; SOz.destroy;
       sPZPx.destroy; sPZPy.destroy; sPZPz.destroy;
     end if

    if(.scfdata.DK2_PCE)then
    !!! W1W1
      WW.create(n_gcm,n_gcm)
      WW=ZERO

      WW= - matmul(sZ, matmul(B,sZ) )
      WW= WW + matmul(sPZP,sZ) 
      WW= WW + matmul(sZ,sPZP) 
      WW= WW - matmul(sPZP, matmul(A,sPZP) ) 

      X.create(n_gcm,n_gcm)
      X=ZERO
      X=D+PDP
      TX.create(n_gcm,n_gcm)
      TX=ZERO
      TX=HALF*(matmul(WW,X)+matmul(X,WW))
      WW.destroy

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      Z=ZERO
      PZP=ZERO
      !!!
      X=ZERO

      if(.scfdata.using_ppzpp)then
! use the second derivatives in the [W1,[W1,X(even,0)]] and [W2,X(odd,0)] terms   
        do i=1,n_gcm
          do j=1,n_gcm
            PPDPP(i,j) = Ap(i)*(c**4)/((Ep(i)+c*c)**2)*PPDPP(i,j)*Ap(j)/( (Ep(j)+c*c)**2 ) 
            Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
            PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
          end do
        end do
        X=PPDPP+PDP
        TX=TX-matmul(sPZP,matmul(A,matmul(X,sZ)))
        TX=TX+matmul(sPZP,matmul(A, matmul(X, matmul(A,sPZP))))
        TX=TX+matmul(sZ,matmul(X,sZ))
        TX=TX-matmul(sZ,matmul(X, matmul(A,sPZP)))
        PPDPP.destroy 
        X.destroy

   !!!  The -[W2,X(odd,0)] terms
        W2.create(n_gcm,n_gcm)
        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              + sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
              - sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
              - (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )*A(j,j)  & 
              + (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   
            end do
          end do
        end do
        TX=TX+matmul(W2,PDP)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              + sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              - A(i,i)*sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              - A(i,i)*(PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )  &
              + A(i,i)*(PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )  
            end do
          end do
        end do
        TX=TX+matmul(PDP,W2)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              -  B(i,i)*sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              +  sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              +  (PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   &
              -  (PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )   
            end do
          end do
        end do
        TX=TX+matmul(D,W2)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                         &
             -  sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
             +  sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
             +  (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )    &
             -  (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )*B(j,j)    
            end do
          end do
        end do
        TX=TX+matmul(W2,D)

! the second derivatives are not used in the [W1,[W1,E(even,0)]] and [W2,X(odd,0)] terms   
      else  
        X.destroy
        do i=1,n_gcm
          do j=1,n_gcm
            Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
            PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
          end do
        end do
        TX=TX-matmul(sPZP,matmul(A,matmul(PDP,sZ)))
        TX=TX-matmul(sPZP,matmul(D,matmul(B,sZ)))
        TX=TX+matmul(sPZP,matmul(A, matmul(PDP, matmul(A,sPZP))))
        TX=TX+matmul(sPZP, matmul(D,sPZP))
        TX=TX+matmul(sZ,matmul(PDP,sZ))
        TX=TX+matmul(sZ,matmul(B, matmul(D, matmul(B,sZ))))
        TX=TX-matmul(sZ,matmul(PDP, matmul(A,sPZP)))
        TX=TX-matmul(sZ,matmul(B, matmul(D,sPZP)))

   !!!  The [W2,X(odd,0)] terms
   !   the second derivatives are not used
        W2.create(n_gcm,n_gcm)
        W2=ZERO
        W2=   matmul( sPZP, matmul(A, matmul(PZP,A) ) )
        W2=W2+matmul( sPZP, Z )
        W2=W2-matmul( sZ, ( matmul(PZP,A) ) )
        W2=W2-matmul( sZ, ( matmul(B,Z) ) )
        W2=W2-matmul( Z,  matmul(sPZP,A)  )
        W2=W2-matmul( PZP,  matmul(sPZP,A)  )
        W2=W2+matmul( Z,  sZ  )
        W2=W2+matmul( PZP,  sZ  )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(W2,PDP)

        W2=ZERO
        W2=   matmul( sZ, Z )
        W2=W2+matmul( sZ, PZP )
        W2=W2-matmul( matmul(A,sPZP), Z )
        W2=W2-matmul( matmul(A,sPZP), PZP )
        W2=W2-matmul( matmul(A,PZP)  ,   sZ)
        W2=W2-matmul( matmul(Z,B)  ,   sZ)
        W2=W2+matmul( matmul(A,matmul(PZP,A)) , sPZP)
        W2=W2+matmul( Z , sPZP)
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(PDP,W2)

        W2=ZERO
        W2=W2-matmul( matmul(B,sZ), Z )
        W2=W2-matmul( matmul(B,sZ), PZP )
        W2=W2+matmul( sPZP  ,   Z )
        W2=W2+matmul( sPZP  , PZP )
        W2=W2+matmul( PZP   ,  sZ )
        W2=W2+matmul( matmul(B,matmul(Z,B)) , sZ)
        W2=W2-matmul( matmul(PZP,A) , sPZP )
        W2=W2-matmul( matmul(B,Z) , sPZP )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(D,W2)

        W2=ZERO
        W2=W2-matmul( sPZP  , matmul(A,PZP) )
        W2=W2-matmul( sPZP  , matmul(Z,B) )
        W2=W2+matmul( sZ    , PZP)
        W2=W2+matmul( sZ    , matmul( B, matmul(Z,B) ) )
        W2=W2+matmul( Z , sPZP  )
        W2=W2+matmul( PZP , sPZP  )
        W2=W2-matmul( Z ,  matmul(sZ,B) )
        W2=W2-matmul( PZP ,  matmul(sZ,B) )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do


        TX=TX+matmul(W2,D)

      end if
      W2.destroy
      Z.destroy
      PZP.destroy

      end if
    end if
    A=ZERO
    B=ZERO

    D = D + PDP
    PDP.destroy
    if(.scfdata.DK1_PCE)then
      D = D + T
      T.destroy
    end if   

    if(.scfdata.DK2_PCE)then
      D = D + TX
      TX.destroy
    end if

     B.to_product_of(S,YU)

     A.to_product_of(B,D)
     D.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .get_back_prim_now(D,R,m_out)  
     D.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
    .make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy

     GG.to_product_of(buco,M)

     M.destroy
     buco.destroy
   end   

   make_DENSITY_PCE_SO_off(GG,GGx,GGy,GGz,YU,Ap,Ep,P2,xx,yy,zz,m_out,n_gcm,S,sZ,sPZP,sPZPx,sPZPy,sPZPz,PPZPP)
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_matrix(H) routine

        GG,GGx,GGy,GGz :: MAT{REAL} , OUT
        YU :: MAT{REAL} , IN
        Ap,Ep,P2 :: VEC{REAL} , IN
        xx,yy,zz :: REAL , IN
        m_out :: MAT{INT}
        n_gcm :: INT , IN
        S,sZ,sPZP :: MAT{REAL} , IN
        sPZPx,sPZPy,sPZPz :: MAT{REAL} , IN
        PPZPP :: MAT{REAL} , IN , optional

        c :: REAL  
        i,j,k :: INT   
        R,Rx,Ry,Rz :: MAT{REAL}*  
        D,PDP,SOx,SOy,SOz,PPDPP :: MAT{REAL}*  
        WW,W2,TX,Z,PZP,X,Cx,Cy,Cz :: MAT{REAL}*  
        T :: MAT{REAL}*
        A,B :: MAT{REAL}*
        M,buco :: MAT{REAL}* 

!!!  the density X operator !!!
     R.create(.n_prim,.n_prim)
     R=ZERO
     D.create(n_gcm,n_gcm)
     D=ZERO
     .make_primitive_density_matrix(D,xx,yy,zz)
     A.create(n_gcm,n_gcm)
     A=ZERO
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)
!!!  the density PXP operator !!!
     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
     .make_primitive_pDp_matrix(PDP,xx,yy,zz) 
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)
!!!  SO MATRICES  !!!
     Rx.create(n_gcm,n_gcm)
     Ry.create(n_gcm,n_gcm)
     Rz.create(n_gcm,n_gcm)
      Rx=ZERO; Ry=ZERO; Rz=ZERO
     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
     SOx=ZERO; SOy=ZERO; SOz=ZERO
     .make_primitive_pDp_SO_matrix(SOx,SOy,SOz,xx,yy,zz) 
! put the SO matrices into the n_gcm non-redundant space
     A=ZERO
     A.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(A,YU)

!!! A-O LETS GO !!!

     B.create(n_gcm,n_gcm) 
     A=ZERO
     B=ZERO  

     c = SPEED_OF_LIGHT_AU
     do i=1,n_gcm
       do j=1,n_gcm

        D(i,j) = Ap(i)*D(i,j)*Ap(j)                                        
        PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
        SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
        SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
        SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))                                        

       end
     end

     if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
       PPDPP.create(n_gcm,n_gcm)
       PPDPP=ZERO
       .make_primitive_ppDpp_matrix(PPDPP,xx,yy,zz) 
       A=ZERO
       A.to_product_of(YU,PPDPP,transpose_a=TRUE)
       PPDPP.to_product_of(A,YU)
     end if 

  if(.scfdata.DK1_PCE)then

  A=ZERO  
  B=ZERO  

     do i = 1,n_gcm
         B(i,i)=(c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
         A(i,i)=ONE/B(i,i)
     end
     ! SO part comes first 
     ! fdff am not sure if it is implemented, seems not
     T.create(n_gcm,n_gcm)
     T= T + matmul(SOx, matmul(A,sPZP) ) + matmul(sPZP, matmul(A,SOx) ) 
     T= T + matmul(PDP, matmul(A,sPZPx) ) + matmul(sPZPx, matmul(A,PDP) ) 
     T= T - matmul(sPZPx,D) 
     T= T - matmul(D,sPZPx) 
     T= T - matmul(SOx,sZ) 
     T= T - matmul(sZ,SOx)
     if(.scfdata.using_SO_FDFF) then
     ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa x-component terms   
       T= T - matmul(SOy, matmul(A,sPZPz) ) + matmul(SOz, matmul(A,sPZPy) ) 
       T= T - matmul(sPZPy, matmul(A,SOz) ) + matmul(sPZPz, matmul(A,SOy) )
     end 
     Cx.create(n_gcm,n_gcm)
     Cx= SOx + T
     T=ZERO
     T= T + matmul(SOy, matmul(A,sPZP) ) + matmul(sPZP, matmul(A,SOy) ) 
     T= T + matmul(PDP, matmul(A,sPZPy) ) + matmul(sPZPy, matmul(A,PDP) ) 
     T= T - matmul(sPZPy,D) 
     T= T - matmul(D,sPZPy) 
     T= T - matmul(SOy,sZ) 
     T= T - matmul(sZ,SOy)
     if(.scfdata.using_SO_FDFF) then
     ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa y-component terms   
       T= T - matmul(SOz, matmul(A,sPZPx) ) + matmul(SOx, matmul(A,sPZPz) ) 
       T= T - matmul(sPZPz, matmul(A,SOx) ) + matmul(sPZPx, matmul(A,SOz) )
     end 
     Cy.create(n_gcm,n_gcm)
     Cy= SOy + T
     T=ZERO
     T= T + matmul(SOz, matmul(A,sPZP) ) + matmul(sPZP, matmul(A,SOz) ) 
     T= T + matmul(PDP, matmul(A,sPZPz) ) + matmul(sPZPz, matmul(A,PDP) ) 
     T= T - matmul(sPZPz,D) 
     T= T - matmul(D,sPZPz) 
     T= T - matmul(SOz,sZ) 
     T= T - matmul(sZ,SOz)
     if(.scfdata.using_SO_FDFF) then
     ! the (PZP + sigma PZP)*(sPZP + sigma sPZP) and vice versa z-component terms   
       T= T - matmul(SOx, matmul(A,sPZPy) ) + matmul(SOy, matmul(A,sPZPx) ) 
       T= T - matmul(sPZPx, matmul(A,SOy) ) + matmul(sPZPy, matmul(A,SOx) )
     end
     Cz.create(n_gcm,n_gcm)
     Cz= SOz + T
     ! scalar part at the end
      T= matmul(sPZP, matmul(A,PDP) )
      T= T - matmul(sPZP,D)
      T= T - matmul(sZ,PDP)
      T= T + matmul(sZ, matmul(B,D) )
      T= T + matmul(D, matmul(B,sZ) )
      T= T - matmul(PDP,sZ)
      T= T - matmul(D,sPZP)
      T= T + matmul(PDP, matmul(A,sPZP) )
      if(.scfdata.using_SO_FDFF) then
      ! these are additional scalar terms due to presence of SO terms
      ! - (SOx*1/P2*sSOx + SOy*1/P2*sSOy + SOz*1/P2*sSOz 
      ! sSOx*1/P2*SOx + sSOy*1/P2*SOy + sSOz*1/P2*SOz) 
        T= T - matmul(SOx, matmul(A,sPZPx) ) 
        T= T - matmul(SOy, matmul(A,sPZPy) ) 
        T= T - matmul(SOz, matmul(A,sPZPz) ) 
        T= T - matmul(sPZPx, matmul(A,SOx) )
        T= T - matmul(sPZPy, matmul(A,SOy) )
        T= T - matmul(sPZPz, matmul(A,SOz) )
      end 
    SOx=Cx; SOy=Cy; SOz=Cz
    Cx.destroy; Cy.destroy; Cz.destroy

    ! only the scalar second order correction
    if(.scfdata.DK2_PCE)then
    !!! W1W1
      WW.create(n_gcm,n_gcm)
      WW=ZERO

      WW= - matmul(sZ, matmul(B,sZ) )
      WW= WW + matmul(sPZP,sZ) 
      WW= WW + matmul(sZ,sPZP) 
      WW= WW - matmul(sPZP, matmul(A,sPZP) ) 

      X.create(n_gcm,n_gcm)
      X=ZERO
      X=D+PDP
      TX.create(n_gcm,n_gcm)
      TX=ZERO
      TX=HALF*(matmul(WW,X)+matmul(X,WW))
      WW.destroy

      Z.create(n_gcm,n_gcm)
      PZP.create(n_gcm,n_gcm)
      Z=ZERO
      PZP=ZERO
      !!!
      X=ZERO

      if(.scfdata.using_ppzpp)then
! use the second derivatives in the [W1,[W1,X(even,0)]] and [W2,X(odd,0)] terms   
        do i=1,n_gcm
          do j=1,n_gcm
            PPDPP(i,j) = Ap(i)*(c**4)/((Ep(i)+c*c)**2)*PPDPP(i,j)*Ap(j)/( (Ep(j)+c*c)**2 ) 
            Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
            PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
          end do
        end do
        X=PPDPP+PDP
        TX=TX-matmul(sPZP,matmul(A,matmul(X,sZ)))
        TX=TX+matmul(sPZP,matmul(A, matmul(X, matmul(A,sPZP))))
        TX=TX+matmul(sZ,matmul(X,sZ))
        TX=TX-matmul(sZ,matmul(X, matmul(A,sPZP)))
        PPDPP.destroy 
        X.destroy

   !!!  The [W2,X(odd,0)] terms
        W2.create(n_gcm,n_gcm)
        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              + sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
              - sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )*A(j,j) &
              + (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   &
              - (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )*A(j,j)   
            end do
          end do
        end do
        TX=TX+matmul(W2,PDP)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              + sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              - A(i,i)*sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              - A(i,i)*(PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )  &
              + A(i,i)*(PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )  
            end do
          end do
        end do
        TX=TX+matmul(PDP,W2)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                        &
              -  B(i,i)*sZ(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              +  sPZP(i,k)*(Z(k,j)+PZP(k,j))/( Ep(i)+Ep(j) )   &
              +  (PZP(i,k)+PPZPP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )   &
              -  (PZP(i,k)+PPZPP(i,k))*A(k,k)*sPZP(k,j)/( Ep(i)+Ep(j) )   
            end do
          end do
        end do
        TX=TX+matmul(D,W2)

        W2=ZERO
        do i=1,n_gcm
          do j=1,n_gcm
            do k=1,n_gcm
              W2(i,j) = W2(i,j)                         &
             -  sPZP(i,k)*A(k,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
             +  sZ(i,k)*(PZP(k,j)+PPZPP(k,j))/( Ep(i)+Ep(j) )    &
             +  (Z(i,k)+PZP(i,k))*sPZP(k,j)/( Ep(i)+Ep(j) )    &
             -  (Z(i,k)+PZP(i,k))*sZ(k,j)/( Ep(i)+Ep(j) )*B(j,j)    
            end do
          end do
        end do
        TX=TX+matmul(W2,D)

! the second derivatives are not used in the [W1,[W1,E(even,0)]] and [W2,X(odd,0)] terms   
      else 
        X.destroy
        do i=1,n_gcm
          do j=1,n_gcm
            Z(i,j)=sZ(i,j)*(Ep(i)+Ep(j))
            PZP(i,j)=sPZP(i,j)*(Ep(i)+Ep(j))
          end do
        end do
        TX=TX-matmul(sPZP,matmul(A,matmul(PDP,sZ)))
        TX=TX-matmul(sPZP,matmul(D,matmul(B,sZ)))
        TX=TX+matmul(sPZP,matmul(A, matmul(PDP, matmul(A,sPZP))))
        TX=TX+matmul(sPZP, matmul(D,sPZP))
        TX=TX+matmul(sZ,matmul(PDP,sZ))
        TX=TX+matmul(sZ,matmul(B, matmul(D, matmul(B,sZ))))
        TX=TX-matmul(sZ,matmul(PDP, matmul(A,sPZP)))
        TX=TX-matmul(sZ,matmul(B, matmul(D,sPZP)))

   !!!  The [W2,X(odd,0)] terms
   !   the second derivatives are not used
        W2.create(n_gcm,n_gcm)
        W2=ZERO
        W2=   matmul( sPZP, matmul(A, matmul(PZP,A) ) )
        W2=W2+matmul( sPZP, Z )
        W2=W2-matmul( sZ, ( matmul(PZP,A) ) )
        W2=W2-matmul( sZ, ( matmul(B,Z) ) )
        W2=W2-matmul( Z,  matmul(sPZP,A)  )
        W2=W2-matmul( PZP,  matmul(sPZP,A)  )
        W2=W2+matmul( Z,  sZ  )
        W2=W2+matmul( PZP,  sZ  )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(W2,PDP)

        W2=ZERO
        W2=   matmul( sZ, Z )
        W2=W2+matmul( sZ, PZP )
        W2=W2-matmul( matmul(A,sPZP), Z )
        W2=W2-matmul( matmul(A,sPZP), PZP )
        W2=W2-matmul( matmul(A,PZP)  ,   sZ)
        W2=W2-matmul( matmul(Z,B)  ,   sZ)
        W2=W2+matmul( matmul(A,matmul(PZP,A)) , sPZP)
        W2=W2+matmul( Z , sPZP)
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(PDP,W2)

        W2=ZERO
        W2=W2-matmul( matmul(B,sZ), Z )
        W2=W2-matmul( matmul(B,sZ), PZP )
        W2=W2+matmul( sPZP  ,   Z )
        W2=W2+matmul( sPZP  , PZP )
        W2=W2+matmul( PZP   ,  sZ )
        W2=W2+matmul( matmul(B,matmul(Z,B)) , sZ)
        W2=W2-matmul( matmul(PZP,A) , sPZP )
        W2=W2-matmul( matmul(B,Z) , sPZP )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(D,W2)

        W2=ZERO
        W2=W2-matmul( sPZP  , matmul(A,PZP) )
        W2=W2-matmul( sPZP  , matmul(Z,B) )
        W2=W2+matmul( sZ    , PZP)
        W2=W2+matmul( sZ    , matmul( B, matmul(Z,B) ) )
        W2=W2+matmul( Z , sPZP  )
        W2=W2+matmul( PZP , sPZP  )
        W2=W2-matmul( Z ,  matmul(sZ,B) )
        W2=W2-matmul( PZP ,  matmul(sZ,B) )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
          end do
        end do


        TX=TX+matmul(W2,D)

      end if
     W2.destroy 
     Z.destroy
     PZP.destroy
     end if 
    end if
     A=ZERO
     B=ZERO

    D=D+PDP
    PDP.destroy
    if(.scfdata.DK1_PCE)then
      D=D+T
      T.destroy
    end if
    if(.scfdata.DK2_PCE)then
      D=D+TX
      TX.destroy
    end if

! back to cartesian basis set
     B.to_product_of(S,YU)

     A.to_product_of(B,D)
     D.to_product_of(A,B,transpose_b=TRUE)
     A=ZERO
     A.to_product_of(B,SOx)
     SOx.to_product_of(A,B,transpose_b=TRUE)
     A=ZERO
     A.to_product_of(B,SOy)
     SOy.to_product_of(A,B,transpose_b=TRUE)
     A=ZERO
     A.to_product_of(B,SOz)
     SOz.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
     Rx=ZERO
     Ry=ZERO
     Rz=ZERO
! put the Fock matrix back to the space .n_prim space
     .get_back_prim_now(D,R,m_out)  
     .get_back_prim_now(SOx,Rx,m_out)  
     .get_back_prim_now(SOy,Ry,m_out)  
     .get_back_prim_now(SOz,Rz,m_out) 
     D.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
    .make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)

     buco=ZERO
     buco.to_product_of(M,R,transpose_a=TRUE)
     GG.to_product_of(buco,M)
     R.destroy

     buco=ZERO
     buco.to_product_of(M,Rx,transpose_a=TRUE)
     GGx.to_product_of(buco,M)
     Rx.destroy

     buco=ZERO
     buco.to_product_of(M,Ry,transpose_a=TRUE)
     GGy.to_product_of(buco,M)
     Ry.destroy

     buco=ZERO
     buco.to_product_of(M,Rz,transpose_a=TRUE)
     GGz.to_product_of(buco,M)
     Rz.destroy

     M.destroy
     buco.destroy
   end   

   make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,xx,yy,zz,n_gcm,S,sZ2,sPZP2)
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_matrix(H) routine

        GG22 :: MAT{CPX} , OUT
        YU :: MAT{REAL} , IN
        Ap,Ep,P2 :: VEC{REAL} , IN
        xx,yy,zz :: REAL , IN
        n_gcm :: INT , IN
        S :: MAT{REAL} , IN
        sZ2,sPZP2 :: MAT{CPX} , IN

        c,fac :: REAL  
        i,j :: INT   
        D,PDP,SOx,SOy,SOz :: MAT{REAL}*  
        D2,PDP2 :: MAT{CPX}*  
        WW,W2,TX,Z2,PZP2,X,T,A2,B2,M2 :: MAT{CPX}*  
        A,B,M :: MAT{REAL}*
        II :: CPX

!!!  the density X operator !!!
     D.create(n_gcm,n_gcm)
     D=ZERO
     .make_primitive_density_matrix(D,xx,yy,zz)
     A.create(n_gcm,n_gcm)
     A=ZERO
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)

!!!  the density PXP operator !!!
     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
     .make_primitive_pDp_matrix(PDP,xx,yy,zz) 
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)
      SOx.create(n_gcm,n_gcm)
      SOy.create(n_gcm,n_gcm)
      SOz.create(n_gcm,n_gcm)
      SOx=ZERO; SOy=ZERO; SOz=ZERO
     .make_primitive_pDp_SO_matrix(SOx,SOy,SOz,xx,yy,zz) 

     A=ZERO
     A.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(A,YU)

!!! A-O LETS GO !!!

     A.destroy
     B.create(2*n_gcm,2*n_gcm) 
     B=ZERO  
     A.create(2*n_gcm,2*n_gcm) 
     A=ZERO  

     c = SPEED_OF_LIGHT_AU
      do i=1,n_gcm
        do j=1,n_gcm

         D(i,j) = Ap(i)*D(i,j)*Ap(j)                                        
         PDP(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*PDP(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
         SOx(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOx(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
         SOy(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOy(i,j)*(Ap(j)/(Ep(j)+c*c))                                        
         SOz(i,j) = c*c*(Ap(i)/(Ep(i)+c*c))*SOz(i,j)*(Ap(j)/(Ep(j)+c*c))                                        

        end
      end

     D2.create(2*n_gcm,2*n_gcm)
     D2=(ZERO,ZERO)

     D2.alpha_alpha_plus(D)
     D2.beta_beta_plus(D)

     II=(ZERO,ONE)
     fac=ONE

     PDP2.create(2*n_gcm,2*n_gcm)
     PDP2=(ZERO,ZERO)
      PDP2.alpha_alpha_plus(PDP)
      PDP2.beta_beta_plus(PDP)
      PDP2.beta_alpha_plus(SOx,fac*II)
      PDP2.beta_alpha_plus(SOy,-fac)
      PDP2.alpha_alpha_plus(SOz,fac*II)
      PDP2.beta_beta_plus(SOz,-fac*II)
      PDP2.make_hermitian

     D.destroy
     PDP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
  if(.scfdata.DK1_PCE)then
  A=ZERO  
  B=ZERO  

     do i = 1,n_gcm
         B(i,i)=(c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
         A(i,i)=ONE/B(i,i)
         B(i+n_gcm,i+n_gcm)=(c*P2(i)*c) / ( (c*c + Ep(i)) * (c*c + Ep(i)) )
         A(i+n_gcm,i+n_gcm)=ONE/B(i,i)
     end
     ! SO part comes first 
     ! fdff am not sure if it is implemented, seems not
     T.create(2*n_gcm,2*n_gcm)
     T=(ZERO,ZERO)
      T= matmul(sPZP2, matmul(A,PDP2) )
      T= T - matmul(sPZP2,D2)
      T= T - matmul(sZ2,PDP2)
      T= T + matmul(sZ2, matmul(B,D2) )
      T= T + matmul(D2, matmul(B,sZ2) )
      T= T - matmul(PDP2,sZ2)
      T= T - matmul(D2,sPZP2)
      T= T + matmul(PDP2, matmul(A,sPZP2) )
    ! only the scalar second order correction
    if(.scfdata.DK2_PCE)then
    !!! W1W1
      WW.create(2*n_gcm,2*n_gcm)
      WW=(ZERO,ZERO)

      WW= - matmul(sZ2, matmul(B,sZ2) )
      WW= WW + matmul(sPZP2,sZ2) 
      WW= WW + matmul(sZ2,sPZP2) 
      WW= WW - matmul(sPZP2, matmul(A,sPZP2) ) 

      X.create(2*n_gcm,2*n_gcm)
      X=(ZERO,ZERO)
      X=D2+PDP2
      TX.create(2*n_gcm,2*n_gcm)
      TX=(ZERO,ZERO)
      TX=HALF*(matmul(WW,X)+matmul(X,WW))
      WW.destroy
      X.destroy

      Z2.create(2*n_gcm,2*n_gcm)
      PZP2.create(2*n_gcm,2*n_gcm)
      Z2=(ZERO,ZERO)
      PZP2=(ZERO,ZERO)
        do i=1,n_gcm
          do j=1,n_gcm
            Z2(i,j)=sZ2(i,j)*(Ep(i)+Ep(j))
            Z2(i+n_gcm,j+n_gcm)=sZ2(i+n_gcm,j+n_gcm)*(Ep(i)+Ep(j))
            PZP2(i,j)=sPZP2(i,j)*(Ep(i)+Ep(j))
            PZP2(i+n_gcm,j+n_gcm)=sPZP2(i+n_gcm,j+n_gcm)*(Ep(i)+Ep(j))
            PZP2(i,j+n_gcm)=sPZP2(i,j+n_gcm)*(Ep(i)+Ep(j))
            PZP2(i+n_gcm,j)=sPZP2(i+n_gcm,j)*(Ep(i)+Ep(j))
          end do
        end do

        TX=TX-matmul(sPZP2,matmul(A,matmul(PDP2,sZ2)))
        TX=TX-matmul(sPZP2,matmul(D2,matmul(B,sZ2)))
        TX=TX+matmul(sPZP2,matmul(A, matmul(PDP2, matmul(A,sPZP2))))
        TX=TX+matmul(sPZP2, matmul(D2,sPZP2))
        TX=TX+matmul(sZ2,matmul(PDP2,sZ2))
        TX=TX+matmul(sZ2,matmul(B, matmul(D2, matmul(B,sZ2))))
        TX=TX-matmul(sZ2,matmul(PDP2, matmul(A,sPZP2)))
        TX=TX-matmul(sZ2,matmul(B, matmul(D2,sPZP2)))

   !!!  The [W2,X(odd,0)] terms
   !   the second derivatives are not used
        W2.create(2*n_gcm,2*n_gcm)
        W2=(ZERO,ZERO)

        W2=   matmul( sPZP2, matmul(A, matmul(PZP2,A) ) )
        W2=W2+matmul( sPZP2, Z2 )
        W2=W2-matmul( sZ2, ( matmul(PZP2,A) ) )
        W2=W2-matmul( sZ2, ( matmul(B,Z2) ) )
        W2=W2-matmul( Z2,  matmul(sPZP2,A)  )
        W2=W2-matmul( PZP2,  matmul(sPZP2,A)  )
        W2=W2+matmul( Z2,  sZ2  )
        W2=W2+matmul( PZP2,  sZ2  )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
            W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) ) 
            W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) ) 
            W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(W2,PDP2)

        W2=(ZERO,ZERO)
        W2=   matmul( sZ2, Z2 )
        W2=W2+matmul( sZ2, PZP2 )
        W2=W2-matmul( matmul(A,sPZP2), Z2 )
        W2=W2-matmul( matmul(A,sPZP2), PZP2 )
        W2=W2-matmul( matmul(A,PZP2)  ,   sZ2)
        W2=W2-matmul( matmul(Z2,B)  ,   sZ2)
        W2=W2+matmul( matmul(A,matmul(PZP2,A)) , sPZP2)
        W2=W2+matmul( Z2 , sPZP2)
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
            W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) ) 
            W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) ) 
            W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(PDP2,W2)

        W2=(ZERO,ZERO)
        W2=W2-matmul( matmul(B,sZ2), Z2 )
        W2=W2-matmul( matmul(B,sZ2), PZP2 )
        W2=W2+matmul( sPZP2  ,   Z2 )
        W2=W2+matmul( sPZP2  , PZP2 )
        W2=W2+matmul( PZP2   ,  sZ2 )
        W2=W2+matmul( matmul(B,matmul(Z2,B)) , sZ2)
        W2=W2-matmul( matmul(PZP2,A) , sPZP2 )
        W2=W2-matmul( matmul(B,Z2) , sPZP2 )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
            W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) ) 
            W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) ) 
            W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) ) 
          end do
        end do

        TX=TX+matmul(D2,W2)

        W2=(ZERO,ZERO)
        W2=W2-matmul( sPZP2  , matmul(A,PZP2) )
        W2=W2-matmul( sPZP2  , matmul(Z2,B) )
        W2=W2+matmul( sZ2    , PZP2)
        W2=W2+matmul( sZ2    , matmul( B, matmul(Z2,B) ) )
        W2=W2+matmul( Z2 , sPZP2  )
        W2=W2+matmul( PZP2 , sPZP2  )
        W2=W2-matmul( Z2 ,  matmul(sZ2,B) )
        W2=W2-matmul( PZP2 ,  matmul(sZ2,B) )
        do i=1,n_gcm
          do j=1,n_gcm
            W2(i,j) = W2(i,j)/( Ep(i)+Ep(j) ) 
            W2(i+n_gcm,j) = W2(i+n_gcm,j)/( Ep(i)+Ep(j) ) 
            W2(i,j+n_gcm) = W2(i,j+n_gcm)/( Ep(i)+Ep(j) ) 
            W2(i+n_gcm,j+n_gcm) = W2(i+n_gcm,j+n_gcm)/( Ep(i)+Ep(j) ) 
          end do
        end do


        TX=TX+matmul(W2,D2)

     W2.destroy 
     Z2.destroy
     PZP2.destroy
    end if
    end if

    D2=D2+PDP2
    PDP2.destroy
    if(.scfdata.DK1_PCE)then
      D2=D2+T
      T.destroy
    end if
    if(.scfdata.DK2_PCE)then
      D2=D2+TX
      TX.destroy
    end if

! back to cartesian basis set
     A.destroy
     B.destroy
     B.create(n_gcm,n_gcm) 
     B.to_product_of(S,YU)
     B2.create(2*n_gcm,2*n_gcm)
     B2=(ZERO,ZERO)
     B2.alpha_alpha_plus(B)
     B2.beta_beta_plus(B)
     B.destroy
     A2.create(2*n_gcm,2*n_gcm)
     A2=(ZERO,ZERO)
     A2.to_product_of(B2,D2)
     D2.to_product_of(A2,B2,dagger_b=TRUE)

     B2.destroy

     A2=(ZERO,ZERO)

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_prim)
     M=ZERO
     .make_normalised_contraction_mx(M)
    .put_debug(M,"M matrix")
!     M2.create(2*.n_prim,2*.n_bf)
     M2.create(2*.n_prim,2*.n_prim)
     M2=(ZERO,ZERO)
     M2.alpha_alpha_plus(M)
     M2.beta_beta_plus(M)
     M.destroy
    .put_debug(M2,"M2 matrix")
     A2.to_product_of(M2,D2,dagger_a=TRUE)
     D2.to_product_of(A2,M2)
    .put_debug(D2,"MU+YODOYUM matrix")
     M2.destroy
     A2.destroy

     GG22 = D2
     D2.destroy
     .put_debug(GG22,"GG22 matrix")
   end   

   make_DKH_orbital_grid_r(density_grid,orb,pt,square)
   ! 
     ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
     density_grid :: VEC{REAL}, OUT 
     orb :: INT, IN
     pt :: MAT{REAL}, IN
     square :: BIN, IN, optional
     MO :: MAT{REAL}*

        MO => .molecular_orbitals.restricted(:,1:.n_a)

        .density_DKH_orb_r(density_grid,pt,MO(:,orb),square)

   end

   make_DKH_orb_dens_grid_gc(density_grid,orb,pt)
   ! 
  ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")
  density_grid :: VEC{CPX}, OUT 
  orb :: INT, IN
  pt :: MAT{REAL}, IN
  CMO :: MAT{CPX}*
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)
           .density_DKH_orb_gc(density_grid,pt,CMO(:,orb))
   end

   density_DKH_orb_gc_old(density,pt,MO)
   ! 
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
   !
       density :: VEC{CPX} , OUT
       pt :: MAT{REAL} , IN
       MO :: VEC{CPX} , IN
       n_gcm,n_pt :: INT
       n,i,j :: INT
       II,gc :: CPX
       fac :: REAL
       m_out :: MAT{INT}* 
       YU,GG,S,R,Z,PZP,PPZPP :: MAT{REAL}*
       P2,Ap,Ep :: VEC{REAL}*
       SOx,SOy,SOz :: MAT{REAL}*
       GGx,GGy,GGz :: MAT{REAL}*
       GG22 :: MAT{CPX}*

       n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .get_n_gcm(m_out,n_gcm)  
      R.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      S=ZERO 
      .get_da_gcm_now(R,S,m_out) 
      R.destroy 

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

     .make_DKH_mxs(YU,Ap,Ep,P2)

     Z.create(n_gcm,n_gcm)
     PZP.create(n_gcm,n_gcm)
     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
     .make_DKH_mxs3(Z,PZP,SOx,SOy,SOz,YU)

    if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      PPZPP.create(n_gcm,n_gcm)
      .make_DKH_mxs4(PPZPP,YU)
      WARN(" The use_ppzpp seems to give larger value of density at nucleus")
    end if

    II=(ZERO,ONE)
    fac= ONE
     GG.create(.n_bf,.n_bf)
     GG22.create(2*.n_bf,2*.n_bf)
     GGx.create(.n_bf,.n_bf)
     GGy.create(.n_bf,.n_bf)
     GGz.create(.n_bf,.n_bf)
     do n = 1,n_pt
         GG=ZERO
       GG22=(ZERO,ZERO)
       GGx=ZERO
       GGy=ZERO
       GGz=ZERO
   ! here it comes babes
   ! point for point the density will be on and on calculated
   ! I am sincerely sorry, but the code comparing to its non-relativistic
   ! counterpart is really not effective :(
     .make_DENSITY_PCE_SO_off(GG,GGx,GGy,GGz,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,Z,PZP,SOx,SOy,SOz,PPZPP)
        gc=(ZERO,ZERO)
            GG22.alpha_alpha_plus(GG)
            GG22.beta_beta_plus(GG)
            GG22.beta_alpha_plus(GGx,fac*II)
            GG22.beta_alpha_plus(GGy,-fac)
            GG22.alpha_alpha_plus(GGz,fac*II)
            GG22.beta_beta_plus(GGz,-fac*II)
            GG22.make_hermitian

        do i=1,2*.n_bf
           do j=1,2*.n_bf
              gc = gc + conjg(MO(i))*GG22(i,j)*MO(j)
           end            
        end       
       density(n)=gc
      end

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp) PPZPP.destroy

       S.destroy
       Z.destroy
       PZP.destroy
       SOx.destroy
       SOy.destroy
       SOz.destroy
       GG.destroy
       GG22.destroy
       GGx.destroy
       GGy.destroy
       GGz.destroy
       YU.destroy
       Ap.destroy
       Ep.destroy
       P2.destroy
       m_out.destroy

   end

   density_DKH_orb_gc(density,pt,MO)
   ! 
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
   !
       density :: VEC{CPX} , OUT
       pt :: MAT{REAL} , IN
       MO :: VEC{CPX} , IN
       n_gcm,n_pt :: INT
       n,i,j :: INT
       II,gc :: CPX
       fac :: REAL
       m_out :: MAT{INT}* 
       YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
       P2,Ap,Ep :: VEC{REAL}*
       SOx,SOy,SOz :: MAT{REAL}*
       GG22,Z2,PZP2 :: MAT{CPX}*

       n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .get_n_gcm(m_out,n_gcm)  
      R.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      S=ZERO 
      .get_da_gcm_now(R,S,m_out) 
      R.destroy 

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

     .make_DKH_mxs_2(YU,Ap,Ep,P2)

     Z.create(n_gcm,n_gcm)
     PZP.create(n_gcm,n_gcm)
     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
     .make_DKH_mxs3_2(Z,PZP,SOx,SOy,SOz,YU)

    if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      PPZPP.create(n_gcm,n_gcm)
      .make_DKH_mxs4(PPZPP,YU)
      WARN(" The use_ppzpp seems to give larger value of density at nucleus")
    end if

    II=(ZERO,ONE)
    fac= ONE
     GG22.create(2*.n_bf,2*.n_bf)
     Z2.create(2*.n_bf,2*.n_bf)
     PZP2.create(2*.n_bf,2*.n_bf)
     Z2=(ZERO,ZERO)
     PZP2=(ZERO,ZERO)
       Z2.alpha_alpha_plus(Z)
       Z2.beta_beta_plus(Z)
       PZP2.alpha_alpha_plus(PZP)
       PZP2.beta_beta_plus(PZP)
       PZP2.beta_alpha_plus(SOx,fac*II)
       PZP2.beta_alpha_plus(SOy,-fac)
       PZP2.alpha_alpha_plus(SOz,fac*II)
       PZP2.beta_beta_plus(SOz,-fac*II)
       PZP2.make_hermitian
       Z.destroy
       PZP.destroy
       SOx.destroy
       SOy.destroy
       SOz.destroy

     do n = 1,n_pt
       GG22=(ZERO,ZERO)
   ! here it comes babes
   ! point for point the density will be on and on calculated
   ! I am sincerely sorry, but the code comparing to its non-relativistic
   ! counterpart is really not effective :(
     .make_DENSITY_PCE_SO_off_v2(GG22,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),n_gcm,S,Z2,PZP2)

         gc=(ZERO,ZERO)
         do i=1,2*.n_bf
           do j=1,2*.n_bf
             gc = gc + conjg(MO(i))*GG22(i,j)*MO(j)
           end            
         end      

         density(n)=gc

      end

      if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp) PPZPP.destroy

       S.destroy
       Z2.destroy
       PZP2.destroy
       GG22.destroy
       YU.destroy
       Ap.destroy
       Ep.destroy
       P2.destroy
       m_out.destroy

   end

   make_DKH_orbital_grid_gc(gcu,gcd,orb,pt)
   ! dead code does not work is not called
    ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")
    gcu,gcd :: VEC{CPX}, OUT 
    orb :: INT, IN
    pt :: MAT{REAL}, IN
    CMO :: MAT{CPX}*
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)
           .orbital_DKH_orb_gc(gcu,gcd,pt,CMO(:,orb))
   end

   orbital_DKH_orb_gc(gcu,gcd,pt,MO)
   ! dead code does not work is not called

       ! the density_grid will be filled with the values of density
       ! given by the coordinates in the pt matrix
       !
       gcu,gcd :: VEC{CPX} , OUT
       pt :: MAT{REAL} , IN
       MO :: VEC{CPX} , IN
       n_gcm,n_pt :: INT
       n,i,j :: INT
       g,fac :: REAL
       gc, II :: CPX
       m_out :: MAT{INT}* 
       YU,GG,S,R,Z,PZP :: MAT{REAL}*
       P2,Ap,Ep :: VEC{REAL}*
       GGx,GGy,GGz :: MAT{REAL}*
       SOx,SOy,SOz :: MAT{REAL}*
       GG22,D :: MAT{CPX}*

       n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .get_n_gcm(m_out,n_gcm)  
      R.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      S=ZERO 
      .get_da_gcm_now(R,S,m_out) 
      R.destroy 

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

     .make_DKH_mxs(YU,Ap,Ep,P2)

     Z.create(n_gcm,n_gcm)
     PZP.create(n_gcm,n_gcm)
     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
     .make_DKH_mxs3(Z,PZP,SOx,SOy,SOz,YU)

     D.create(2*.n_bf,2*.n_bf) 
     D=ZERO
        do i=1,.n_bf
           do j=1,.n_bf
               D(i,j) =  MO(i)*conjg(MO(j))
               D(i+.n_bf,j+.n_bf)= MO(i+.n_bf)*conjg(MO(j+.n_bf))
           end            
        end       
    II=(ZERO,ONE)
    fac= ONE
     GG.create(.n_bf,.n_bf)
     GG22.create(2*.n_bf,2*.n_bf)
     GGx.create(.n_bf,.n_bf)
     GGy.create(.n_bf,.n_bf)
     GGz.create(.n_bf,.n_bf)
     do n = 1,n_pt
         GG=ZERO
       GG22=ZERO
       GGx=ZERO
       GGy=ZERO
       GGz=ZERO
   ! here it comes babes
   ! point for point the density will be on and on calculated
   ! I am sincerely sorry, but the code comparing to its non-relativistic
   ! counterpart is really not effective :(
!     .make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,Z,PZP)
     .make_DENSITY_PCE_SO_off(GG,GGx,GGy,GGz,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,Z,PZP,SOx,SOy,SOz)
        gc=ZERO
            GG22.alpha_alpha_plus(GG)
            GG22.beta_beta_plus(GG)
            GG22.beta_alpha_plus(GGx,fac*II)
            GG22.beta_alpha_plus(GGy,-fac)
            GG22.alpha_alpha_plus(GGz,fac*II)
            GG22.beta_beta_plus(GGz,-fac*II)
            GG22.make_hermitian

        do i=1,2*.n_bf
           do j=1,2*.n_bf
               gc = gc + D(i,j)*GG22(i,j)
           end            
        end       

      g = real(gc)

       ! unfortunatelly the PCE corrected orbitals lose phase :(
       ! this is absolutelly wrong (rubbish^2)
      g=sqrt(g)

         gcu=g
         gcd=(ZERO,ZERO)

      end

       D.destroy
       S.destroy
       Z.destroy
       PZP.destroy
       SOx.destroy
       SOy.destroy
       SOz.destroy
       GG.destroy
       GG22.destroy
       GGx.destroy
       GGy.destroy
       GGz.destroy
       YU.destroy
       Ap.destroy
       Ep.destroy
       P2.destroy
       m_out.destroy

   end

   density_DKH_orb_r(density_grid,pt,MO,square)
   ! 
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
   !
       density_grid :: VEC{REAL} , OUT
       pt :: MAT{REAL} , IN
       MO :: VEC{REAL} , IN
       square :: BIN , IN, optional
       n_gcm,n_pt :: INT
       n,i,j :: INT
       g :: REAL
       m_out :: MAT{INT}* 
       YU,GG,S,R,Z,PZP,PPZPP :: MAT{REAL}*
       P2,Ap,Ep :: VEC{REAL}*

       n_pt = pt.dim1

      m_out.create(.n_prim,.n_prim)
      .get_n_gcm(m_out,n_gcm)  
      R.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      S=ZERO 
      .get_da_gcm_now(R,S,m_out) 
      R.destroy 

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

     .make_DKH_mxs(YU,Ap,Ep,P2)

     Z.create(n_gcm,n_gcm)
     PZP.create(n_gcm,n_gcm)
     .make_DKH_mxs2(Z,PZP,YU)

     if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      WARN(" The use_ppzpp seems to give larger value of density at nucleus")
       PPZPP.create(n_gcm,n_gcm)
       .make_DKH_mxs4(PPZPP,YU)
     end if

     GG.create(.n_bf,.n_bf)
     do n = 1,n_pt
         GG=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to its non-relativistic
! counterpart is really not effective :(
        .make_DENSITY_PCE_off(GG,YU,Ap,Ep,P2,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,Z,PZP,PPZPP)

        g=ZERO

        do i=1,.n_bf
           do j=1,.n_bf
               g = g + MO(i)*GG(i,j)*MO(j)
           end            
        end            

       ! unfortunatelly the PCE corrected orbitals lose phase :(
      if( NOT square) g=sqrt(g)

         density_grid(n)= g

      end
     if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
       PPZPP.destroy
     end if

       S.destroy
       Z.destroy
       PZP.destroy
       GG.destroy
       YU.destroy
       Ap.destroy
       Ep.destroy
       P2.destroy
       m_out.destroy

   end

   make_primitive_density_matrix(D,x,y,z)
   ! Calculate the primitive density matrix "D" at x,y,z coors
     D :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.is_square, "S must be square")
   ENSURE(D.dim1==.n_prim, "wrong size, S")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Sb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_density_gg(D(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     D.symmetric_reflect
   end

   make_primitive_pDp_matrix(T,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
     T :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_pDp_gg(T(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     T.symmetric_reflect
     .put_debug(T,"make_primitive_pDp_matrix: T")

   end

   make_primitive_ppDpp_matrix(T,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
     T :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(T.is_square, "T must be square")
   ENSURE(T.dim1==.n_prim, "wrong size, T")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_ppDpp_gg(T(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     T.symmetric_reflect
     .put_debug(T,"make_primitive_ppDpp_matrix: T")

   end

   make_primitive_pDp_SO_matrix(Dx,Dy,Dz,x,y,z)
   ! Calculate the primitive pDp (or pGGp) matrix "T" at x,y,z coors
     Dx,Dy,Dz :: MAT{REAL}, OUT
     x,y,z :: REAL, IN
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(Dx.is_square, "density SOx must be square")
   ENSURE(Dx.dim1==.n_prim, "wrong size, density SOx")
   ENSURE(Dy.is_square, "density SOy must be square")
   ENSURE(Dy.dim1==.n_prim, "wrong size, density SOy")
   ENSURE(Dz.is_square, "density SOz must be square")
   ENSURE(Dz.dim1==.n_prim, "wrong size, density SOz")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
   ! ccm,Tb :: MAT{REAL}*

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

     ! Calculate the primitive integrals
     nps = frst.dim
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)
           G.make_normalised_pDp_SO_gg(Dx(fa:la,fb:lb),Dy(fa:la,fb:lb),Dz(fa:la,fb:lb),x,y,z,.use_spherical_basis)
        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
     Dx.antisymmetric_reflect
     Dy.antisymmetric_reflect
     Dz.antisymmetric_reflect
     .put_debug(Dx,"make_primitive_pDp_SO_matrix: Dx")
     .put_debug(Dy,"make_primitive_pDp_SO_matrix: Dy")
     .put_debug(Dz,"make_primitive_pDp_SO_matrix: Dz")

   end

!! development

   get_x_structure_factors_test   !::: private
   ! Make the structure factors for this molecule.
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
!   ENSURE(.density_matrix.created, "no density matrix")

      sf_eq,Fc :: VEC{CPX}*
      k_pts :: MAT{REAL}*

      Fc.create(.crystal.n_refl)
      Fc=(ZERO,ZERO)
      k_pts.create(.crystal.n_unique_SF_k_pts,3)

      .crystal.assign_xray
      .crystal.make_unique_SF_k_pts(k_pts)
      .make_ao_density_matrix

      sf_eq.create(k_pts.dim1)
      sf_eq=(ZERO,ZERO)
        .make_ft_test(sf_eq,.density_matrix.restricted,k_pts)
        if (.scfdata.created) then
        if (.scfdata.spinorbital_kind=="unrestricted") then
           .density_matrix.destroy("restricted")
        end
        end
       k_pts.destroy

     .crystal.sum_unique_sf(Fc,sf_eq)
     if (.crystal.correct_dispersion) then
       k_pts.create(.crystal.n_refl,3)
      .crystal.make_k_pts(k_pts)
      .add_dispersion_correction(Fc,k_pts)
       k_pts.destroy
     end

     .crystal.set_F_calc(Fc)

     .crystal.make_F_predicted
     .crystal.put_reflection_data
      sf_eq.destroy
      Fc.destroy

   end

   get_x_structure_factors_dkh    !::: private
   ! Make the structure factors for this molecule.
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
!   ENSURE(.density_matrix.created, "no density matrix")

      sf_eq,Fc :: VEC{CPX}*
      k_pts :: MAT{REAL}*

      Fc.create(.crystal.n_refl)
      k_pts.create(.crystal.n_unique_SF_k_pts,3)

      .crystal.assign_xray
      .crystal.make_unique_SF_k_pts(k_pts)
      .make_ao_density_matrix

      sf_eq.create(k_pts.dim1)
      sf_eq=(ZERO,ZERO)
        .make_ft_DKH(sf_eq,.density_matrix.restricted,k_pts)
        if (.scfdata.created) then
        if (.scfdata.spinorbital_kind=="unrestricted") then
           .density_matrix.destroy("restricted")
        end
        end
       k_pts.destroy

     .crystal.sum_unique_sf(Fc,sf_eq)
     if (.crystal.correct_dispersion) then
       k_pts.create(.crystal.n_refl,3)
      .crystal.make_k_pts(k_pts)
      .add_dispersion_correction(Fc,k_pts)
       k_pts.destroy
     end

     .crystal.set_F_calc(Fc)

     .crystal.make_F_predicted
     .crystal.put_reflection_data
      sf_eq.destroy
      Fc.destroy

   end

   make_ft_test(sf,D,k_pts)
   ! make the PCE corrected structure factors 
   ! 
       sf :: VEC{CPX}
    !   D :: MAT{REAL}, target
       D :: MAT{REAL}, IN
       k_pts :: MAT{REAL}, IN
       n_gcm :: INT
       n,i,j,k_max :: INT
       g :: CPX
       m_out :: MAT{INT}* 
       GG,ft_hkl,buco :: MAT{CPX}*
       MM,YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
       P2,Ap,Ep :: VEC{REAL}*

      k_max = size(k_pts,1)

      m_out.create(.n_prim,.n_prim)
      .get_n_gcm(m_out,n_gcm)  
      R.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      S=ZERO 
      .get_da_gcm_now(R,S,m_out) 
      R.destroy 

     MM.create(.n_prim,.n_bf)
     .make_normalised_contraction_mx(MM)

     ft_hkl.create(.n_bf,.n_bf)
     GG.create(.n_prim,.n_prim)
     buco.create(.n_bf,.n_prim)
     do n = 1,k_max
        ft_hkl=(ZERO,ZERO)
        GG=(ZERO,ZERO)
        buco=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to its non-relativistic
! counterpart is really not effective :(
       .make_primitive_ft_matrix(GG,k_pts(n,1),k_pts(n,2),k_pts(n,3))
       buco.to_product_of(MM,GG,transpose_a=TRUE)

       ft_hkl.to_product_of(buco,MM)

       .make_part_and_therm_smear(ft_hkl,k_pts(n,:))

        g=(ZERO,ZERO) !???

        do i=1,.n_bf
           do j=1,.n_bf
               g = g + D(i,j)*ft_hkl(i,j)  !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
           end do           
        end do           

            stdout.flush
            stdout.put(n)
            stdout.put(k_pts(n,1))
            stdout.put(k_pts(n,2))
            stdout.put(k_pts(n,3))
            stdout.put(g)

        sf(n)=g

     end do
     MM.destroy
     buco.destroy
       ! unfortunatelly the PCE corrected orbitals lose phase :(
     if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
       PPZPP.destroy
     end if

     .put_debug(ft_hkl,"ft_hkl mx")

       S.destroy
       Z.destroy
       PZP.destroy
       GG.destroy
       YU.destroy
       Ap.destroy
       Ep.destroy
       P2.destroy
       m_out.destroy
       ft_hkl.destroy

   end

   make_ft_DKH(sf,D,k_pts)
   ! make the PCE corrected structure factors 
   ! 
       sf :: VEC{CPX}
       D :: MAT{REAL}, IN
       k_pts :: MAT{REAL}, IN
       n_gcm,met :: INT
       n,i,j,k_max :: INT
       g :: CPX
       m_out :: MAT{INT}* 
       GG,ft_hkl :: MAT{CPX}*
       YU,S,R,Z,PZP,PPZPP :: MAT{REAL}*
       P2,Ap,Ep :: VEC{REAL}*

      k_max = size(k_pts,1)
      ! the method is for the PCE corr is sfs
      met=1

      m_out.create(.n_prim,.n_prim)
      .get_n_gcm(m_out,n_gcm)  
      R.create(.n_prim,.n_prim)
      .make_primitive_overlap_matrix(R)
      S.create(n_gcm,n_gcm)
      S=ZERO 
      .get_da_gcm_now(R,S,m_out) 
      R.destroy 

      YU.create(n_gcm,n_gcm)
      Ap.create(n_gcm)
      Ep.create(n_gcm)
      P2.create(n_gcm)

     .make_DKH_mxs(YU,Ap,Ep,P2)

     Z.create(n_gcm,n_gcm)
     PZP.create(n_gcm,n_gcm)
     .make_DKH_mxs2(Z,PZP,YU)

     if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
      WARN(" The use_ppzpp seems to give larger value of density at nucleus")
       PPZPP.create(n_gcm,n_gcm)
       .make_DKH_mxs4(PPZPP,YU)
     end if

     ft_hkl.create(.n_bf,.n_bf)
     do n = 1,k_max
        ft_hkl=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to its non-relativistic
! counterpart is really not effective :(
       .make_PCE_off(ft_hkl,YU,Ap,Ep,P2,k_pts(n,1),k_pts(n,2),k_pts(n,3),m_out,n_gcm,S,Z,PZP,met,PPZPP)    

       .make_part_and_therm_smear(ft_hkl,k_pts(n,:))

        g=(ZERO,ZERO) !???

        do i=1,.n_bf
           do j=1,.n_bf
               g = g + D(i,j)*ft_hkl(i,j)  !????? cmpx matrix ??? perhaps the cpx parts is not needed BUT!!!!
           end do           
        end do           

            stdout.flush
            stdout.put(n)
            stdout.put(k_pts(n,1))
            stdout.put(k_pts(n,2))
            stdout.put(k_pts(n,3))
            stdout.put(real(g))

        sf(n)=g
     end do
       ! unfortunatelly the PCE corrected orbitals lose phase :(
     if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
       PPZPP.destroy
     end if

       ft_hkl.destroy
       S.destroy
       Z.destroy
       PZP.destroy
       GG.destroy
       YU.destroy
       Ap.destroy
       Ep.destroy
       P2.destroy
       m_out.destroy

   end

   make_primitive_ft_matrix(ft,h1,h2,h3)
   ! Calculate the primitive ft matrix for a given hkl
      ft :: MAT{CPX}
      h1,h2,h3 :: REAL, IN 
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(.basis_info_made, "no basis info")
   ENSURE(ft.is_square, "ft must be square")
   ENSURE(ft.dim1==.n_prim, "wrong size, ft")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     ft_ab :: MAT{CPX}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
     p,t :: REAL 
     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

  !    p.create(sh.a.n_cc,sh.b.n_cc)
  !    .make_partition_factors(p,sh,atom_a,atom_b,is_zero)
  !    t.create(k_max,sh.a.n_cc,sh.b.n_cc)
  !    .thermal_smearing_correction(t,k_pts,atom_a,atom_b,sh)
  !    ! sh.make_ft_fast(ft_ab,k_pts,t,p)
  !      sh.make_ft(ft_ab,k_pts,t,p)
  !   ! Calculate the primitive integrals
     nps = frst.dim
  !   ft = ZERO
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)

 !         partitioning and thermal smearing
           p=ONE
           t=ONE

            ft_ab.create(la-fa+1,lb-fb+1)
            ft_ab=(ZERO,ZERO)

            if ( (fa-la)==0 AND (fb-lb)==0 ) then 
              G.make_normalised_ft_00(ft_ab,h1,h2,h3)
            else                             
              G.make_normalised_ft_v2(ft_ab,h1,h2,h3,.use_spherical_basis) ! cleaner newer version
            end if

            !perhaps the thermal smearing should come after building
            !the whole sf-matrix
            ft(fa:la,fb:lb)=ft_ab*p*t

            ft_ab.destroy

        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
      ft.symmetric_reflect
!    do a = 1,nps
!      p=real(ft(a,a))
!      ft(a,a)=(ZERO,ZERO)
!      ft(a,a)=p
!    end do 

     ! Make a hermitian matrix
 !     ft.make_hermitian

     ! Debug, turn on with debug_on "key"
     .put_debug(ft,  "make_primitive_ft_matrix: ft")

     ! Test
   ! .make_fd_DKH_matrix(T,SOx,SOy,SOz)

   end

   make_primitive_pftp_matrix(ft,h1,h2,h3)
   ! Calculate the primitive ft matrix for a given hkl
      ft :: MAT{CPX}
      h1,h2,h3 :: REAL, IN 
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(.basis_info_made, "no basis info")
   ENSURE(ft.is_square, "ft must be square")
   ENSURE(ft.dim1==.n_prim, "wrong size, ft")

     frst,last,at,l :: VEC{INT}*
     ex :: VEC{REAL}*
     ft_ab :: MAT{CPX}*
     nps,a,b,fa,la,fb,lb :: INT
     G :: GAUSSIAN2
     p,t :: REAL 

     ! Make the indexing arrays
     .atom.make_primitive_limits(frst,last,at,l,ex)

  !    p.create(sh.a.n_cc,sh.b.n_cc)
  !    .make_partition_factors(p,sh,atom_a,atom_b,is_zero)
  !    t.create(k_max,sh.a.n_cc,sh.b.n_cc)
  !    .thermal_smearing_correction(t,k_pts,atom_a,atom_b,sh)
  !    ! sh.make_ft_fast(ft_ab,k_pts,t,p)
  !      sh.make_ft(ft_ab,k_pts,t,p)
  !   ! Calculate the primitive integrals
     nps = frst.dim
  !   ft = ZERO
     do a = 1,nps
        G.a.set_l(l(a))
        G.a.set_position(.atom(at(a)).position)
        G.a.set_exponent(ex(a))
        fa = frst(a); la = last(a)
        do b = 1,a
           G.b.set_l(l(b))
           G.b.set_position(.atom(at(b)).position)
           G.b.set_exponent(ex(b))
           fb = frst(b); lb = last(b)

 !         partitioning and thermal smearing
           p=ONE
           t=ONE

            ft_ab.create(la-fa+1,lb-fb+1)
            ft_ab=(ZERO,ZERO)

!           if ( (fa-la)==0 AND (fb-lb)==0 ) then 
!             G.make_normalised_ft_00(ft_ab,h1,h2,h3)
!           else                             
              G.make_normalised_pftp_v2(ft_ab,h1,h2,h3,.use_spherical_basis) ! cleaner newer version
!           end if

            !perhaps the thermal smearing should come after building
            !the whole sf-matrix
            ft(fa:la,fb:lb)=ft_ab*p*t

            ft_ab.destroy

        end
     end

     ! Clean up indexing arrays
     ex.destroy; l.destroy; at.destroy
     last.destroy; frst.destroy

     ! Make a symmetric matrix
      ft.symmetric_reflect
     ! Make a hermitian matrix
     ! ft.make_hermitian

     ! Debug, turn on with debug_on "key"
     .put_debug(ft,  "make_primitive_pftp_matrix: ft")

     ! Test
   ! .make_fd_DKH_matrix(T,SOx,SOy,SOz)

   end

   make_part_and_therm_smear(ft,k_vec) 
   ! Calculate the primitive ft matrix for a given hkl
      ft :: MAT{CPX}
      k_vec :: VEC{REAL}

  ! ENSURE(NOT .use_spherical_basis,"not yet implemented")

      q,fa,la,na,fb,lb,nb,atom_a,atom_b,ag,bg :: INT
      sh :: SHELL2
      is_zero :: BIN
      t :: MAT{REAL}*
      p :: MAT{REAL}*

      do q = 1,.n_shell_pairs
        .get_precomputed_shell_pair(sh,q,fa,la,na,fb,lb,nb,atom_a,atom_b)
         p.create(la-fa+1,lb-fb+1)
         p=ZERO
        .make_partition_factors(p,sh,atom_a,atom_b,is_zero)

          t.create(la-fa+1,lb-fb+1)
          t=ZERO
         .thermal_smearing_correction_pce(t,k_vec,atom_a,atom_b)

            do bg=1,lb-fb+1
              do ag=1,la-fa+1
                ft(fa-1+ag,fb-1+bg)=ft(fa-1+ag,fb-1+bg)*p(ag,bg)*t(ag,bg)
              end do  
            end do

           t.destroy
           p.destroy
         sh.destroy_ptr_part
      end do

      ft.symmetric_reflect 

   end

   thermal_smearing_correction_pce(res,k_vec,a,b)
   ! Makes the thermal smearing correction term.  Note that res
   ! is done over the contraction coefficients.
   ! Dimensions of "res" are [.a.n_cc,.b.n_cc].
      res :: MAT{REAL}
      k_vec :: VEC{REAL}
      a,b :: INT

      Ua,Ub,Uab :: MAT{REAL}(3,3)
      S,US :: VEC{REAL}(3)
      separation,bondlength,Ta,Tb,g :: REAL
      diff :: VEC{REAL}(3)

      select case (trim(.crystal.thermal_smearing_model))

       case (" ","none")
         res = ONE

       case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
         Ua = -HALF * .atom(a).ADP_tensor
         Ub = -HALF * .atom(b).ADP_tensor
            S = k_vec(:)
            US = matmul(Ua,S)
            Ta = dot_product(S,US)
            US = matmul(Ub,S)
            Tb = dot_product(S,US)
            res(:,:) = HALF*(exp(Ta)+exp(Tb))

       case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4]
         bondlength=2.5
         Ua = .atom(a).ADP_tensor
         Ub = .atom(b).ADP_tensor
         Uab = Ua + Ub
         diff = .atom(a).position-.atom(b).position
         separation = diff.norm
         g=HALF
         if (separation > bondlength) g=QUARTER
         Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
            S = k_vec(:)
            US = matmul(Uab,S)
            Ta = dot_product(S,US)
            res(:,:) = exp(Ta)

       case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
         DIE(" tanaka model not yet implemented for PCE corrected structure factors ")

       case default
         DIE("unknown model, "//trim(.crystal.thermal_smearing_model))

      end

   end

!!! IOTC

   test_IOTC
   ! Calculate the primitive ft matrix for a given hkl
   S,SOx,SOy,SOz :: MAT{REAL}*
   J,K,P :: MAT{REAL}*
   M,B :: MAT{REAL}*
      UU  :: VEC{MAT_{REAL}}*
      U :: MAT{REAL}*
   n,nb :: INT

 !  H.create(.n_bf,.n_bf)
 !  .make_r_IOTC_matrix(H)
 !  H.destroy

      UU => GAUSSIAN_DATA::spherical_harmonics_for

  stdout.flush
  stdout.text("the cart 2 sph mxs")
      do n=0,.basis_l_max
         U => UU(n).element
         stdout.flush
         stdout.put(n)
         stdout.flush
         stdout.put(U)
      end

      ! No of basis functions
      n = .n_bf

  S.create(n,n)
  .make_overlap_matrix(S)
  stdout.flush
  stdout.text("overlap mx S")
  stdout.put(S)
  S.destroy

  S.create(n,n)
  .make_kinetic_energy_mx(S)
  stdout.flush
  stdout.text("kinetic mx T")
  stdout.put(S)
  S.destroy

  S.create(n,n)
  .make_nuclear_attraction_mx(S)
  stdout.flush
  stdout.text("nuclear mx V")
  stdout.put(S)
  S.destroy

       n  = .n_prim
       nb = .n_bf

  B.create(nb,nb)
  M.create(n,nb)
  M=ZERO
  .make_normalised_contraction_mx(M)
  stdout.flush
  stdout.text("contraction matrix M")
  stdout.put(M)

  S.create(n,n)
  .make_primitive_overlap_matrix(S)
  stdout.flush
  stdout.text("primitive overlap mx S")
  stdout.put(S)
  B=ZERO
  S.change_basis_to(B,M)
  stdout.flush
  stdout.text("contracted overlap mx S")
  stdout.put(B)
  S.destroy

  S.create(n,n)
  .make_primitive_kinetic_matrix(S)
  stdout.flush
  stdout.text("primitive kinetic mx T")
  stdout.put(S)
  B=ZERO
  S.change_basis_to(B,M)
  stdout.flush
  stdout.text("contracted kinetic mx T")
  stdout.put(B)
  S.destroy

  S.create(n,n)
  .make_primitive_nuclear_matrix(S)
  stdout.flush
  stdout.text("primitive nuclear mx V")
  stdout.put(S)
  B=ZERO
  S.change_basis_to(B,M)
  stdout.flush
  stdout.text("contracted nuclear mx V")
  stdout.put(B)
  S.destroy

  S.create(n,n)
  SOx.create(n,n)
  SOy.create(n,n)
  SOz.create(n,n)
  .make_primitive_DKH_matrices(S,SOx,SOy,SOz)
  stdout.flush
  stdout.text("primitive PVP mx ")
  stdout.put(S)
  S.destroy
  SOx.destroy
  SOy.destroy
  SOz.destroy

  J.create(nb,nb)
  K.create(nb,nb)
  P.create(nb,nb)
  P=ONE
  .make_r_JK_direct(J,K,P)
  stdout.flush
  stdout.text("primitive J mx ")
  stdout.put(J)
  stdout.flush
  stdout.text("primitive K mx ")
  stdout.put(K)
  stdout.flush
  stdout.text("TRALALA 1")
  J.destroy
  K.destroy
  P.destroy

  M.destroy
  B.destroy
  stdout.flush
  stdout.text("TRALALA 2")

   end

   make_r_IOTC_matrix(H)
   ! the 1electron IOTC hamiltonian
   !
        H :: MAT{REAL}
        c,alpha,alpha2 :: REAL  
        i,j,k,n_gcm :: INT     
        SOx,SOy,SOz,R :: MAT{REAL}*
        A,B,S,Y,T,U,Z,PZP :: MAT{REAL}*
        ppZpp,O :: MAT{REAL}*
        m_out :: MAT{INT}*
        F,Yr,M,buco :: MAT{REAL}* 
        P2,p,ep,bp,E,Ap :: VEC{REAL}*

!!! analysis of the primitive basis set via the overap matrix
!!! trying to lower the problem to an general contracted basis set
!!!  OVERLAP MATRIX !!!
     R.create(.n_prim,.n_prim)
    .make_primitive_overlap_matrix(R)
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm)  
     S.create(n_gcm,n_gcm)
     .get_da_gcm_now(R,S,m_out)  

     Y.create(n_gcm,n_gcm)
     Y.to_inverse_sqrt_of(S)

!!!  KINETIC ENERGY MATRIX !!!
     R=ZERO
     .make_primitive_kinetic_matrix(R) 
     T.create(n_gcm,n_gcm)
! put the kinetic energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,T,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(Y,T)   
     T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     T.solve_eigenproblem(P2,U)
     P2= TWO * P2
     T.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     .make_primitive_nuclear_matrix(R)
     Z.create(n_gcm,n_gcm)
! put the potential energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,Z,m_out)  

     A.to_product_of(Y,Z) 
     Z.to_product_of(A,Y)             ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 

     A.to_product_of(U,Z,transpose_a=TRUE)
     Z.to_product_of(A,U)

!!!  PZP MATRIX  !!!
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R=ZERO
         .make_primitive_DKH_matrices(R,SOx,SOy,SOz)
       SOx.destroy
       SOy.destroy
       SOz.destroy

     PZP.create(n_gcm,n_gcm)
! put the PZP matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,PZP,m_out)  
     A.to_product_of(Y,PZP)  
     PZP.to_product_of(A,Y)

     A.to_product_of(U,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,U)
! the DK3 staff
   if( .scfdata.using_ppzpp)then
     ppZpp.create(n_gcm,n_gcm)
     R=ZERO 
     .make_primitive_DK3_ppZpp_mx(R)
     .get_da_gcm_now(R,ppZpp,m_out)  
     A=ZERO
     A.to_product_of(Y,ppZpp) 
     ppZpp.to_product_of(A,Y)             ! Z=YZY the electron-nuclei interaction energy in orthonormal basis set 
     A=ZERO
     A.to_product_of(U,ppZpp,transpose_a=TRUE)
     ppZpp.to_product_of(A,U)
   end if 

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(n_gcm)
     Ap.create(n_gcm)
     ep.create(n_gcm)
     p.create(n_gcm)
     bp.create(n_gcm)

     E=ZERO 
     p=ZERO
     ep=ZERO
     Ap=ZERO
     bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE)

     end  

     do i=1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
!        PZP(i,j) = c*c*(Ap(i)/(E(i)+c*c))*PZP(i,j)*(Ap(j)/(E(j)+c*c))                                        

       end
     end

     if( .scfdata.using_ppzpp)then
       do i=1,n_gcm
         do j=1,n_gcm

          ppZpp(i,j) = Ap(i)*ppZpp(i,j)*Ap(j)

         end do
       end do
     end if
! lets find the transforation matrix
     Yr.create(n_gcm,n_gcm)

    .find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
    .put_debug(Yr,"make_r_IOTC_matrix: Yr")

     O.create(n_gcm,n_gcm)
     O=ZERO
     do i=1,n_gcm
       O(i,i)=ONE
       do j=1,n_gcm
         do k=1,n_gcm
           O(i,j)=O(i,j)+Yr(k,i)*Yr(k,j)
         end do
       end do
     end do

     A.to_inverse_sqrt_of(O)
     O=A
     A=ZERO

     F.create(n_gcm,n_gcm)
     F=ZERO
     if( .scfdata.using_ppzpp)then
       .build_da_IOTC_F(F,Yr,PZP,Z,p,bp,E,n_gcm,ppZpp)
     else  
       .build_da_IOTC_F(F,Yr,PZP,Z,p,bp,E,n_gcm)
     end if 

    .put_debug(F,"make_r_IOTC_matrix: F")

     ! normalization<F2>
     A=matmul(O,matmul(F,O))
     O.destroy
     Yr.destroy
     F=A
     .put_debug(F,"make_r_IOTC_matrix: OFO matrix")
     A=ZERO

     Z.destroy
     PZP.destroy
     if( .scfdata.using_ppzpp)then
       ppZpp.destroy
     end if

     Ap.destroy 
     P2.destroy
     E.destroy
     p.destroy
     bp.destroy
     ep.destroy

     B.create(n_gcm,n_gcm) 
     A.to_product_of(S,Y)
     B.to_product_of(A,U)

     S.destroy
     Y.destroy
     U.destroy

     A=ZERO
     A.to_product_of(B,F)
     F.to_product_of(A,B,transpose_b=TRUE)
    .put_debug(F,"U+YOFOYU matrix")

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .get_back_prim_now(F,R,m_out)  
     F.destroy
     m_out.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     .make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy
     A.create(.n_bf,.n_bf)
     A.to_product_of(buco,M)
    .put_debug(A,"MU+YOFOYUM matrix")
     M.destroy
     buco.destroy

     H = A
     A.destroy
     .put_debug(H,"core matrix")

   end

   make_gc_IOTC_matrix(H)
   ! the 1electron IOTC hamiltonian  2C
   !  
        H :: MAT{CPX}

        c,alpha,alpha2,fac,eps :: REAL  
        i,j,n_gcm :: INT     
        Yr,F,buco,A,B2,M2,O :: MAT{CPX}*
        O1,O2 :: MAT{CPX}*
        A2,PAP,ppApp :: MAT{CPX}*
        SOx,SOy,SOz,R :: MAT{REAL}*
        YU :: MAT{REAL}*
        B,S,Y,U,Z,PZP,ppZpp :: MAT{REAL}*
        m_out,mmm :: MAT{INT}*
        M,Y0 :: MAT{REAL}* 
        P2,p,ep,bp,E,Ap,UN :: VEC{REAL}*
        II :: CPX

     !test
     mmm.create(.n_prim,.n_prim)
      .get_n_gcm(mmm,n_gcm)
     mmm.destroy 
     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
       DIE(" It seems you are using contracted gaussians this does not work for IOTC at gchf level!")
     end if    

  !!! n_gcm = .n_prim = .n_bf

! this is actually not needed but I am also using n_gcm 
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm) 
     R.create(.n_prim,.n_prim)
     S.create(n_gcm,n_gcm)
     Y.create(n_gcm,n_gcm)
!!!  OVERLAP MATRIX + Y MX !!!
     .make_S_Y(S,Y)

!!!  KINETIC ENERGY MATRIX -> U & P2!!!
     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     .make_U_P2(U,P2,Y)
     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     Y.destroy
     U.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     Z.create(n_gcm,n_gcm)
    .make_primitive_nuclear_matrix(Z)
! put the potential energy matrix into the YU space
!    .make_R_to_YU(R,Z,YU)
     R.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(R,YU)
     R=ZERO

!!!  PZP MATRIX  !!!
     PZP.create(n_gcm,n_gcm)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
         .make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
    .put_debug(PZP,"PZP matrix")
    .put_debug(SOx,"SOx matrix")
    .put_debug(SOy,"SOy matrix")
    .put_debug(SOz,"SOz matrix")

     R.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(R,YU)
     R=ZERO

! the DK3 staff
   if( .scfdata.using_ppzpp)then
     ppZpp.create(n_gcm,n_gcm)
     ppZpp=ZERO
    .make_primitive_DK3_ppZpp_mx(ppZpp)
    .put_debug(ppZpp,"ppZpp matrix")
     R.to_product_of(YU,ppZpp,transpose_a=TRUE)
     ppZpp.to_product_of(R,YU)
   end if

    .put_debug(PZP,"PZP matrix YU")
    .put_debug(SOx,"SOx matrix YU")
    .put_debug(SOy,"SOy matrix YU")
    .put_debug(SOz,"SOz matrix YU")
    .put_debug(ppZpp,"ppZpp matrix YU")

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
     Ap.create(n_gcm)

     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)

     end  

     do i=1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

       end
     end

     if( .scfdata.using_ppzpp)then
       do i=1,n_gcm
         do j=1,n_gcm

          ppZpp(i,j) = Ap(i)*ppZpp(i,j)*Ap(j)

         end do
       end do
     end if
    .put_debug(PZP,"PZP matrix YUAp")
    .put_debug(ppZpp,"ppZpp matrix YUAp")
    .put_debug(SOx,"SOx matrix YUAp")
    .put_debug(SOy,"SOy matrix YUAp")
    .put_debug(SOz,"SOz matrix YUAp")

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(Z)
     A2.beta_beta_plus(Z)
!   A.make_hermitian   
    .put_debug(A2,"make_gc_IOTC_matrix: A2")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PZP)
     PAP.beta_beta_plus(PZP)
     II = (ZERO,ONE)
     fac= ONE
      PAP.beta_alpha_plus(SOx,fac*II)
      PAP.beta_alpha_plus(SOy,-fac)
      PAP.alpha_alpha_plus(SOz,fac*II)
      PAP.beta_beta_plus(SOz,-fac*II)
   PAP.make_hermitian   
    .put_debug(PAP,"make_gc_IOTC_matrix: PAP matrix")
   if( .scfdata.using_ppzpp)then
   ppApp.create(2*n_gcm,2*n_gcm)
   ppApp=(ZERO,ZERO)
     ppApp.alpha_alpha_plus(ppZpp)
     ppApp.beta_beta_plus(ppZpp)
!  ppApp.make_hermitian   
    .put_debug(ppApp,"make_gc_IOTC_matrix: ppApp matrix")
     ppZpp.destroy
   end if
! lets try to start the 
     Y0.create(n_gcm,n_gcm)
     Y0=ZERO
    .find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)
     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy

! lets find the transforation matrix
     Yr.create(2*n_gcm,2*n_gcm)
     Yr=(ZERO,ZERO)
     Yr.alpha_alpha_plus(Y0)
     Yr.beta_beta_plus(Y0)
     Y0.destroy

    .find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
    .put_debug(Yr,"make_gc_IOTC_matrix: Yr matrix")

     A.create(2*n_gcm,2*n_gcm)
     A=(ZERO,ZERO)

     O1.create(2*n_gcm,2*n_gcm); O1=(ZERO,ZERO)
     O.create(2*n_gcm,2*n_gcm); O=(ZERO,ZERO)

     do i=1,2*n_gcm
       O1(i,i)=(ONE,ZERO)
     end do
     O.to_product_of(Yr,Yr,dagger_a=TRUE)
     O1=O1+O
     O=(ZERO,ZERO)

    UN.create(2*n_gcm)
    UN=ZERO

    ! make ready the preconditioning
    do i=1,2*n_gcm
      UN(i)=ONE/sqrt(real(O1(i,i)))
    end 

    do i=1,2*n_gcm
      do j=1,2*n_gcm
        O1(i,j)=O1(i,j)*UN(i)*UN(j)
      end
    end  
    .put_debug(O1,"O1 matrix")

     A=O1 
     eps=TOL(15)
     O.to_power_series_inv_sqrt_of(O1,eps)
     O1=A
     O2.create(2*n_gcm,2*n_gcm); O2=(ZERO,ZERO)

     ! normalization because the inverse power series needs it
     A.to_product_of(O1,O)
     O2.to_product_of(O,A,dagger_a=TRUE)
     A.to_unit_matrix
     A=A-O2
    .put_debug(A,"AAA matrix")
    .put_debug(O2,"O2 matrix")

     O2.destroy

   !  print*,"O1 test=",maxval(abs(O1-conjg(transpose(O1))))
    .put_debug(O,"O matrix")
   ENSURE(O1.is_hermitian(eps),"1+YY is not hermitian")
   ENSURE(O.is_hermitian(eps),"inv_sqrt(1+YY) is not hermitian")
     O1.destroy

     F.create(2*n_gcm,2*n_gcm)
     F=(ZERO,ZERO)
! the hamiltonian is gonna be built
     if( .scfdata.using_ppzpp)then
       .build_da_IOTC_F(F,Yr,PAP,A2,p,bp,E,ppApp)
     else  
       .build_da_IOTC_F(F,Yr,PAP,A2,p,bp,E)
     end if 
    .put_debug(F,"make_gc_IOTC_matrix: F matrix")
!    ENSURE(F.is_hermitian,"F is not hermitian")

     A2.destroy
     PAP.destroy
     if( .scfdata.using_ppzpp)then
       ppApp.destroy
     end if 

     ! normalization because the inverse power series needs it
     do i=1,2*n_gcm
     do j=1,2*n_gcm
        F(i,j)=F(i,j)*UN(j)*UN(i)
     end
     end
     UN.destroy
     A=(ZERO,ZERO)
     A.to_product_of(F,O)
     ! I am pretty not sure whether to dagger O or not :(
     ! especially because of the inverse power series
     F.to_product_of(O,A,dagger_a=TRUE)
!    F.to_product_of(O,A)  
    .put_debug(F,"make_gc_IOTC_matrix: OFO matrix")
!   ENSURE(F.is_hermitian,"OFO is not hermitian")
     O.destroy
     Yr.destroy

     Ap.destroy 
     P2.destroy
     E.destroy
     p.destroy
     bp.destroy
     ep.destroy

     B.create(n_gcm,n_gcm) 
     B.to_product_of(S,YU)
     S.destroy
     YU.destroy
     B2.create(2*n_gcm,2*n_gcm)
     B2=(ZERO,ZERO)
     B2.alpha_alpha_plus(B)
     B2.beta_beta_plus(B)
     B.destroy

     A=(ZERO,ZERO)
     A.to_product_of(B2,F)
     F.to_product_of(A,B2,dagger_b=TRUE)
    .put_debug(F,"make_gc_IOTC_matrix: U+YOFOYU matrix")

     B2.destroy

     m_out.destroy
     A=(ZERO,ZERO)

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     M=ZERO
     .make_normalised_contraction_mx(M)
    .put_debug(M,"M matrix")
     M2.create(2*.n_prim,2*.n_prim)
     M2=(ZERO,ZERO)
     M2.alpha_alpha_plus(M)
     M2.beta_beta_plus(M)
    .put_debug(M2,"M2 matrix")
     buco.create(2*.n_prim,2*.n_prim)
     buco=(ZERO,ZERO)
     buco.to_product_of(M2,F,dagger_a=TRUE)
     A.to_product_of(buco,M2)
    .put_debug(A,"MU+YOFOYUM matrix")
     M.destroy
     F.destroy
     M2.destroy
     buco.destroy

     H = A
     A.destroy
     .put_debug(H,"core matrix")

   end

   make_gc_IOTC_matrix_cheated_norm(H)
   ! the 1electron IOTC hamiltonian  2C
   ! in this version the normalisation is done
   ! only for the real part of (1+Y+Y)-1/2
        H :: MAT{CPX}

        c,alpha,alpha2,fac :: REAL  
        i,j,n_gcm :: INT     
        Yr,F,buco,A,B2,M2,O :: MAT{CPX}*
        O1,Ox1 :: MAT{REAL}*
        A2,PAP,ppApp :: MAT{CPX}*
        SOx,SOy,SOz,R :: MAT{REAL}*
        YU :: MAT{REAL}*
        B,S,Y,U,Z,PZP,ppZpp :: MAT{REAL}*
        m_out,mmm :: MAT{INT}*
        M :: MAT{REAL}* 
        P2,p,ep,bp,E,Ap :: VEC{REAL}*
        II :: CPX

     !test
     mmm.create(.n_prim,.n_prim)
      .get_n_gcm(mmm,n_gcm)
     mmm.destroy 
     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
       DIE(" It seems you are using contracted gaussians this does not work for IOTC at gchf level!")
     end if    

! this is actually not needed but I am also using n_gcm 
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm) 
     R.create(.n_prim,.n_prim)
     S.create(n_gcm,n_gcm)
     Y.create(n_gcm,n_gcm)
!!!  OVERLAP MATRIX + Y MX !!!
     .make_S_Y(S,Y)

!!!  KINETIC ENERGY MATRIX -> U & P2!!!
     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     .make_U_P2(U,P2,Y)
     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     Y.destroy
     U.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     Z.create(n_gcm,n_gcm)
    .make_primitive_nuclear_matrix(Z)
! put the potential energy matrix into the YU space
     R.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(R,YU)
     R=ZERO

!!!  PZP MATRIX  !!!
     PZP.create(n_gcm,n_gcm)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
         .make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
    .put_debug(PZP,"PZP matrix")
    .put_debug(SOx,"SOx matrix")
    .put_debug(SOy,"SOy matrix")
    .put_debug(SOz,"SOz matrix")

     R.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(R,YU)
     R=ZERO

! the DK3 staff
   if( .scfdata.using_ppzpp)then
     ppZpp.create(n_gcm,n_gcm)
     ppZpp=ZERO
    .make_primitive_DK3_ppZpp_mx(ppZpp)
    .put_debug(ppZpp,"ppZpp matrix")
     R.to_product_of(YU,ppZpp,transpose_a=TRUE)
     ppZpp.to_product_of(R,YU)
   end if

    .put_debug(PZP,"PZP matrix YU")
    .put_debug(SOx,"SOx matrix YU")
    .put_debug(SOy,"SOy matrix YU")
    .put_debug(SOz,"SOz matrix YU")
    .put_debug(ppZpp,"ppZpp matrix YU")

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
     Ap.create(n_gcm)

     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)

     end  

     do i=1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

       end
     end

     if( .scfdata.using_ppzpp)then
       do i=1,n_gcm
         do j=1,n_gcm

          ppZpp(i,j) = Ap(i)*ppZpp(i,j)*Ap(j)

         end do
       end do
     end if
    .put_debug(PZP,"PZP matrix YUAp")
    .put_debug(ppZpp,"ppZpp matrix YUAp")
    .put_debug(SOx,"SOx matrix YUAp")
    .put_debug(SOy,"SOy matrix YUAp")
    .put_debug(SOz,"SOz matrix YUAp")

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(Z)
     A2.beta_beta_plus(Z)
!   A.make_hermitian   
    .put_debug(A2,"make_gc_IOTC_matrix: A2")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PZP)
     PAP.beta_beta_plus(PZP)
     II = (ZERO,ONE)
     fac= ONE
      PAP.beta_alpha_plus(SOx,fac*II)
      PAP.beta_alpha_plus(SOy,-fac)
      PAP.alpha_alpha_plus(SOz,fac*II)
      PAP.beta_beta_plus(SOz,-fac*II)
   PAP.make_hermitian   
    .put_debug(PAP,"make_gc_IOTC_matrix: PAP matrix")
   if( .scfdata.using_ppzpp)then
   ppApp.create(2*n_gcm,2*n_gcm)
   ppApp=(ZERO,ZERO)
     ppApp.alpha_alpha_plus(ppZpp)
     ppApp.beta_beta_plus(ppZpp)
!  ppApp.make_hermitian   
    .put_debug(ppApp,"make_gc_IOTC_matrix: ppApp matrix")
     ppZpp.destroy
   end if
! lets try to start the 
     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy

! lets find the transforation matrix
     Yr.create(2*n_gcm,2*n_gcm)
     Yr=(ZERO,ZERO)

    .find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
    .put_debug(Yr,"make_gc_IOTC_matrix: Yr matrix")

     A.create(2*n_gcm,2*n_gcm)
     A=(ZERO,ZERO)
     O1.create(2*n_gcm,2*n_gcm); O1=ZERO
     Ox1.create(2*n_gcm,2*n_gcm); Ox1=ZERO
     O.create(2*n_gcm,2*n_gcm); O=(ZERO,ZERO)
     do i=1,2*n_gcm
       Ox1(i,i)=ONE
     end do
!LBxxx     test ??? the renormalization is switched off
     O.to_product_of(Yr,Yr,dagger_a=TRUE)
     Ox1=Ox1+real(O)
     O.destroy
     O1=ZERO
    .put_debug(Ox1,"Ox matrix")

     O1.to_inverse_sqrt_of(Ox1)
     Ox1.destroy
    .put_debug(O1,"O matrix")

     F.create(2*n_gcm,2*n_gcm)
     F=(ZERO,ZERO)
! the hamiltonian is gonna be built
     if( .scfdata.using_ppzpp)then
       .build_da_IOTC_F(F,Yr,PAP,A2,p,bp,E,ppApp)
     else  
       .build_da_IOTC_F(F,Yr,PAP,A2,p,bp,E)
     end if 
    .put_debug(F,"make_gc_IOTC_matrix: F matrix")
   ENSURE(F.is_hermitian,"F is not hermitian")

     A2.destroy
     PAP.destroy
     if( .scfdata.using_ppzpp)then
       ppApp.destroy
     end if 

     A=(ZERO,ZERO)
     ! normalization
     A.to_product_of(F,O1)
     F.to_product_of(O1,A)   ! I am pretty not sure whether to dagger O
!or not :(
    .put_debug(F,"make_gc_IOTC_matrix: OFO matrix")
   ENSURE(F.is_hermitian,"OFO is not hermitian")
     O1.destroy
     Yr.destroy

     Ap.destroy 
     P2.destroy
     E.destroy
     p.destroy
     bp.destroy
     ep.destroy

     B.create(n_gcm,n_gcm) 
     B.to_product_of(S,YU)
     S.destroy
     YU.destroy
     B2.create(2*n_gcm,2*n_gcm)
     B2=(ZERO,ZERO)
     B2.alpha_alpha_plus(B)
     B2.beta_beta_plus(B)
     B.destroy

     A=(ZERO,ZERO)
     A.to_product_of(B2,F)
     F.to_product_of(A,B2,dagger_b=TRUE)
    .put_debug(F,"make_gc_IOTC_matrix: U+YOFOYU matrix")

     B2.destroy

     m_out.destroy
     A=(ZERO,ZERO)

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     M=ZERO
     .make_normalised_contraction_mx(M)
    .put_debug(M,"M matrix")
!     M2.create(2*.n_prim,2*.n_bf)
     M2.create(2*.n_prim,2*.n_prim)
     M2=(ZERO,ZERO)
     M2.alpha_alpha_plus(M)
     M2.beta_beta_plus(M)
    .put_debug(M2,"M2 matrix")
     buco.create(2*.n_prim,2*.n_prim)
     buco=(ZERO,ZERO)
!     buco.to_product_of(M2,F,transpose_a=TRUE)
     buco.to_product_of(M2,F,dagger_a=TRUE)
     A.to_product_of(buco,M2)
    .put_debug(A,"MU+YOFOYUM matrix")
     M.destroy
     F.destroy
     M2.destroy
     buco.destroy

!      stdout.flush
!      stdout.text("seems the IOTC H(1e) is build ")
!      stdout.flush

     H = A
     A.destroy
     .put_debug(H,"core matrix")

   end

   make_IOTC_density_grid(density_grid,pt,sgn)
   ! this is kevin
   ! here begins the PCE correction of density
   ! welcome
   !
     density_grid :: VEC{REAL} 
     pt :: MAT{REAL}
     sgn :: INT, IN, optional

     fac :: REAL
     MO,MOa,MOb :: MAT{REAL}*
     CMO :: MAT{CPX}*
     D,Da,Db :: MAT{REAL}*
     CD :: MAT{CPX}*
     grid_a,grid_b :: VEC{REAL}*

     select case (.scfdata.scf_kind)

        case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
           ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
           ENSURE(.spin_multiplicity==1,"this is not a singlet state")
             MO => .molecular_orbitals.restricted(:,1:.n_a)
             D  => .density_matrix.restricted
             D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
             grid_a.create(pt.dim1)
            .density_IOTC(grid_a,pt,D)
            density_grid=grid_a
             grid_a.destroy
 
        case ("uhf","uks","xray_uhf","xray_uks", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           ENSURE(.molecular_orbitals.created("unrestricted"),"no MO's")
             MOa => .molecular_orbitals.alpha(:,1:.n_a)
             MOb => .molecular_orbitals.beta(:,1:.n_b)
             Da => .density_matrix.alpha
             Db => .density_matrix.beta
             Da.to_product_of(MOa,MOa,transpose_b=TRUE)
             Db.to_product_of(MOb,MOb,transpose_b=TRUE)
             grid_a.create(pt.dim1)
             grid_b.create(pt.dim1)
            .density_IOTC(grid_a,pt,Da)
            .density_IOTC(grid_b,pt,Db)
              if (present(sgn)) then; fac = -ONE
              else;                   fac = ONE
              end
             density_grid= grid_a 
             density_grid= density_grid + fac * grid_b 
             grid_a.destroy
             grid_b.destroy
 
        case ("gchf")
         ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")
         CD => .density_matrix.general_complex
         CMO => .molecular_orbitals.general_complex(:,1:.n_e)
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)
         .density_IOTC_gc(density_grid,pt,CD)
 
        case default
           DIE("unknown or not implemented SCF kind, "//trim(.scfdata.scf_kind))

     end
   end

   make_IOTC_orbital_grid_r(density_grid,orb,pt,square)
   ! 
     ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
     density_grid :: VEC{REAL}, OUT 
     orb :: INT, IN
     pt :: MAT{REAL}, IN
     square :: BIN, IN, optional
     MO :: MAT{REAL}*

        MO => .molecular_orbitals.restricted(:,1:.n_a)

        .density_IOTC_orb_r(density_grid,pt,MO(:,orb),square)

   end

   make_IOTC_orb_dens_grid_gc(density_grid,orb,pt)
   ! 
   ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")
   density_grid :: VEC{CPX}, OUT 
   orb :: INT, IN
   pt :: MAT{REAL}, IN
   CMO :: MAT{CPX}*
            CMO => .molecular_orbitals.general_complex(:,1:.n_e)
           .density_IOTC_orb_gc(density_grid,pt,CMO(:,orb))
   end

   find_da_Y_iterative(Y,PZP,Z,p,b,ep,eps)
   ! the iterative solution of the Y matrix for IOTC
   Y :: MAT{REAL}
   PZP,Z :: MAT{REAL}
   p,b,ep :: VEC{REAL}
   eps :: REAL, optional

   i,j,n_gcm,n :: INT
   fine :: BIN
   THRESH,THRESH2,XXX,XXXa,val :: REAL
   Y0,dY :: MAT{REAL}*
   m_out :: MAT{INT}*

    fine=FALSE
    THRESH  = 1.0000000000d-09
    THRESH2 = 1.0000000000d-05
    if(present(eps))then
      THRESH  = eps
      THRESH2 = eps/1.0d2
    end  
    n=0
    m_out.create(.n_prim,.n_prim) 
   .make_ready_da_gcm_tr2(m_out,n_gcm)  
    m_out.destroy
    Y0.create(n_gcm,n_gcm) 
    Y0=ZERO
    dY.create(n_gcm,n_gcm) 
    dY=ZERO

    do
      if (fine) exit
      MOLECULE::build_da_Y(Y,Y0,PZP,Z,p,b,ep,n_gcm)
      dY=Y-Y0
      Y0=Y
    ! convergence check  
      XXX=ZERO
      XXXa=ZERO
      do i = 1,n_gcm
        do j = 1,n_gcm
          if (abs( Y0(i,j) ) < 1.0d-12) cycle
          val=(dY(i,j))/Y0(i,j) 
          if( abs( val ) >XXX ) XXX=abs ( val )
          if( abs( val ) >XXX ) XXXa= Y0(i,j)
     !     if(abs(dY(i,j))>XXX) XXX=abs(dY(i,j))
        end do
      end do
        stdout.flush
        stdout.put(n)
        stdout.put(XXXa)
        stdout.put(XXX)
   ! output if so    
      if(XXX<THRESH)then
        fine=TRUE
        stdout.flush
        stdout.text("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX") 
        stdout.flush
        stdout.text("The Y has converged") 
        stdout.flush
        stdout.text("The largest change in the element of the Y matrix=")
        stdout.put(XXX)
        stdout.flush
        stdout.text("The number of iteration=")
        stdout.put(n)
        stdout.flush
      end if  

      if(n>80 AND XXX < THRESH2)then
        fine=TRUE
        stdout.text("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX") 
        stdout.flush
        stdout.text("The Y has converged only to THRESH2 see the find_da_Y_iterative in molecule.foo") 
        stdout.flush
        stdout.text("The largest change in the element of the Y matrix=")
        stdout.put(XXX)
        stdout.flush
        stdout.text("The number of iteration=")
        stdout.put(n)
        stdout.flush
      end if  

      if(n>80 AND XXX > THRESH2)then
        stdout.text("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX") 
        stdout.flush
        stdout.text("The Y has not converged see the find_da_Y_iterative in molecule.foo") 
        stdout.flush
      DIE("Exceeded the number of iterations (n_max=200) uuups !!!")
      end if

      n=n+1

    end do

    Y0.destroy
    dY.destroy

   end

   find_da_Y_iterative(Y,PZP,Z,p,b,ep)
   ! the iterative solution of the Y matrix for IOTC
   Y :: MAT{CPX}
   PZP,Z :: MAT{CPX}
   p,b,ep :: VEC{REAL}
   i,j,n_gcm,n :: INT
   fine :: BIN
   THRESH,THRESH2,XXX,YYY,val,XXXa,YYYa :: REAL
   Y0,dY :: MAT{CPX}*
   m_out :: MAT{INT}*

    fine=FALSE
    THRESH=1.0d-8
    THRESH2=1.0d-5
    n=0
    m_out.create(.n_prim,.n_prim) 
   .make_ready_da_gcm_tr2(m_out,n_gcm)  
    m_out.destroy
    Y0.create(2*n_gcm,2*n_gcm)
    Y0=(ZERO,ZERO)
    Y0=Y
    dY.create(2*n_gcm,2*n_gcm) 
    dY=(ZERO,ZERO)

    do
      if (fine) exit
      MOLECULE::build_da_Y_2(Y,Y0,PZP,Z,p,b,ep,n_gcm)
      dY=Y-Y0
      Y0=Y
    ! convergence check  
      XXX=ZERO
      YYY=ZERO
      do i = 1,2*n_gcm
        do j = 1,2*n_gcm
!        rcdY=sqrt*( real(dY(i,j))*real(dY(i,j))+cmplx(dY(i,j))*cmplx(dY(i,j)) )
!        if(rcdY>XXX) XXX=rcdY
          if (abs( real(Y0(i,j)) ) > 1.0d-12 )then 
            val=real(dY(i,j))/real(Y0(i,j)) 
            if( abs( val ) >XXX )then
               XXX=abs ( val )
               XXXa=abs(real(dY(i,j)))
            end if   
          end if   
          if ( abs(aimag(Y0(i,j)) ) > 1.0d-13) then
!          if( abs(  real(dY(i,j))) >XXX ) XXX=abs ( real (dY(i,j) ) )
             val=aimag(dY(i,j))/aimag(Y0(i,j)) 
             if( abs( val ) >YYY ) then 
                YYY=abs ( val )
                YYYa=abs(aimag(dY(i,j)))
              end if
          end if
!         if( abs( aimag(dY(i,j))) >YYY ) YYY=abs ( aimag (dY(i,j) ) ) 
          !
     !     if( abs(  real(Y0(i,j)+Y0(j,i))) >XXX ) XXX=abs ( real(Y0(i,j)+Y0(j,i) ) )
     !     if( abs(  aimag(Y0(i,j)+Y0(j,i))) >YYY ) YYY=abs ( aimag(Y0(i,j)+Y0(j,i) ) )

        end do
      end do

        stdout.flush
        stdout.put(n)
        stdout.put(XXXa)
        stdout.put(YYYa)
        stdout.put(XXX)
        stdout.put(YYY)

      if(XXX<THRESH AND YYY<THRESH)then
        fine=TRUE
        stdout.flush
        stdout.text("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX") 
        stdout.flush
        stdout.text("The Y has converged") 
        stdout.flush
        stdout.text("The number of iteration=")
        stdout.put(n)
        stdout.flush
        stdout.text("The largest relative change in the element of the real Y matrix=")
        stdout.put(XXX)
        stdout.flush
        stdout.text("The largest relative change in the element of the imaginary Y matrix=")
        stdout.put(YYY)
        stdout.flush
      end if  

      if(n>80 AND XXX < THRESH2 AND YYY < THRESH2 )then
        fine=TRUE
        stdout.flush
        stdout.text("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX") 
        stdout.flush
        stdout.text("The Y has converged only to THRESH2 see the find_da_Y_iterative in molecule.foo") 
        stdout.flush
        stdout.text("The number of iteration=")
        stdout.put(n)
        stdout.flush
        stdout.text("The largest relative change in the element of the real Y matrix=")
        stdout.put(XXX)
        stdout.flush
        stdout.text("The largest relative change in the element of the imaginary Y matrix=")
        stdout.put(YYY)
        stdout.flush
      end if  

      if(n>80 AND ( (XXX > THRESH2)OR(YYY>THRESH2) ) )then
        stdout.flush
        stdout.text("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX") 
        stdout.flush
        stdout.text("The Y has not converged see the find_da_Y_iterative in molecule.foo") 
        stdout.flush
      DIE("Exceeded the number of iterations (n_max=200) uuups !!!")
      end if

      n=n+1

    end do

    Y0.destroy
    dY.destroy

   end

   build_da_Y(Y,Yr0,PZP,Z,p,b,ep,n_gcm) ::: selfless, private
   ! build the IOTC Y matrix 
   Y :: MAT{REAL}
   Yr0,PZP,Z :: MAT{REAL}
   p,b,ep :: VEC{REAL}
   n_gcm :: INT
   i,j :: INT
   c,alpha,alpha2,alpha3,alpha4 :: REAL
   Y1L,Y1R,Y2 :: MAT{REAL}*

   Y=ZERO
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha
     alpha3= alpha2*alpha
     alpha4= alpha3*alpha

     Y1L.create(n_gcm,n_gcm);Y1R.create(n_gcm,n_gcm);Y2.create(n_gcm,n_gcm)

     do i = 1,n_gcm
       do j = 1,n_gcm
         Y(i,j)   =  alpha3*( p(i)*b(i)*Z(i,j) - PZP(i,j)/p(i)*b(j) )  
         Y1L(i,j) = -alpha2* Z(i,j) -alpha4* b(i)*PZP(i,j)*b(j) 
         Y1R(i,j) =  alpha2* PZP(i,j)/p(i)/p(j) + alpha4*p(i)*b(i)*Z(i,j)*b(j)*p(j) 
         Y2(i,j)  =  alpha3*( b(i)*PZP(i,j)/p(j) - Z(i,j)*b(j)*p(j) )
        end do
     end do

     Y=Y+matmul(Yr0,Y1L)+matmul(Y1R,Yr0)+matmul(Yr0,matmul(Y2,Yr0))

     do i = 1,n_gcm
       do j = 1,n_gcm

         Y(i,j) = Y(i,j) / ( ep(i)+ep(j) )

       end do
     end do

     Y1L.destroy;Y1R.destroy;Y2.destroy

   end

   build_da_Y_2(Y,Yr0,PAP,A,p,b,ep,n_gcm) ::: selfless, private
   ! build the IOTC Y matrix 
   Y :: MAT{CPX}
   Yr0,PAP,A :: MAT{CPX}
   p,b,ep :: VEC{REAL}
   n_gcm :: INT
   i,j,dim :: INT
   c,alpha,alpha2,alpha3,alpha4 :: REAL
   Y1L,Y1R,Y2 :: MAT{CPX}*

     Y = (ZERO,ZERO)
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha
     alpha3= alpha2*alpha
     alpha4= alpha3*alpha

     dim=2*n_gcm

     Y1L.create(dim,dim);Y1R.create(dim,dim);Y2.create(dim,dim)

     do i = 1,dim
       do j = 1,dim
         Y(i,j)   =  alpha3*( p(i)*b(i)*A(i,j) - PAP(i,j)/p(i)*b(j) )  
         Y1L(i,j) = -alpha2* A(i,j) - alpha4*b(i)*PAP(i,j)*b(j) 
         Y1R(i,j) =  alpha2* PAP(i,j)/p(i)/p(j) + alpha4*p(i)*b(i)*A(i,j)*b(j)*p(j)
         Y2(i,j)  =  alpha3*( b(i)*PAP(i,j)/p(j) - A(i,j)*b(j)*p(j) )
        end do
     end do

     Y=Y+matmul(Yr0,Y1L)+matmul(Y1R,Yr0)+matmul(Yr0,matmul(Y2,Yr0))

     do i = 1,dim
       do j = 1,dim

         Y(i,j) = Y(i,j) / ( ep(i)+ep(j) )

       end do
     end do

     Y1L.destroy;Y1R.destroy;Y2.destroy

   end

   build_da_IOTC_F(F,Yr,PAP,A,p,bp,E,n_gcm,ppApp)
   ! build the IOTC Y matrix 
   F :: MAT{REAL}
   Yr,PAP,A :: MAT{REAL}
   p,bp,E :: VEC{REAL}
   n_gcm :: INT
   ppApp :: MAT{REAL}, optional
   i,j :: INT
   c,alpha,alpha2 :: REAL
   F1L,F1R,F2,AAA :: MAT{REAL}*

     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     F1L.create(n_gcm,n_gcm);F1R.create(n_gcm,n_gcm);F2.create(n_gcm,n_gcm)
     AAA.create(n_gcm,n_gcm)
     F=ZERO;F2=ZERO

     if( .scfdata.using_ppzpp)then
       do i = 1,n_gcm
       do j = 1,n_gcm
         AAA(i,j)=alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
       end do
       end do
     else
       do i = 1,n_gcm
       do j = 1,n_gcm
         AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
       end do
       end do
     end

     do i = 1,n_gcm
       F(i,i)  =  E(i)-c*c 
       F2(i,i) = -E(i)-c*c  
       do j = 1,n_gcm
         F(i,j)   =  F(i,j) + A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
         F2(i,j)  =  F2(i,j)+ PAP(i,j)/p(j)/p(i) + AAA(i,j)
        end do
     end do

     F=F+matmul(transpose(Yr),F1L) 
     F=F+matmul(F1R,Yr)
     F=F+matmul(transpose(Yr),matmul(F2,Yr))

     AAA.destroy     
     F1L.destroy;F1R.destroy;F2.destroy

   end

   build_da_IOTC_F(F,Yr,PAP,A,p,bp,E,ppApp)
   ! build the IOTC Y matrix 
   F :: MAT{CPX}
   Yr,PAP,A :: MAT{CPX}
   p,bp,E :: VEC{REAL}
   ppApp :: MAT{CPX}, optional
   i,j,n_gcm,dim :: INT
   c,alpha,alpha2 :: REAL
   AAA,F1R,F1L,F2 :: MAT{CPX}*

   n_gcm=.n_prim
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     dim=2*n_gcm

     F1L.create(dim,dim);F1R.create(dim,dim);F2.create(dim,dim)
     AAA.create(dim,dim)
     F=ZERO;F2=ZERO

     if( .scfdata.using_ppzpp)then
       do i = 1,dim
       do j = 1,dim
         AAA(i,j)=alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
       end do
       end do
     else
       do i = 1,dim
       do j = 1,dim
         AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
       end do
       end do
     end

     do i = 1,dim
       F(i,i)  =  E(i)-c*c     
       F2(i,i) = -E(i)-c*c     
       do j = 1,dim
         F(i,j)   =  F(i,j) + A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
         F2(i,j)  =  F2(i,j)+ PAP(i,j)/p(j)/p(i) + AAA(i,j)
        end do
     end do

     AAA.to_product_of(Yr,F1L,dagger_a=TRUE)
     F=F+AAA+matmul(F1R,Yr)
     AAA.to_product_of(Yr,F2,dagger_a=TRUE)
     F=F+matmul(AAA,Yr)

     AAA.destroy     
     F1L.destroy;F1R.destroy;F2.destroy

   end

   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,E,n_gcm,ppApp)
   ! build the IOTC Y matrix 
   F :: MAT{REAL}
   Yr,PAP,A :: MAT{REAL}
   p,bp,E :: VEC{REAL}
   n_gcm :: INT
   ppApp :: MAT{REAL}, optional
   i,j :: INT
   c,alpha,alpha2 :: REAL
   AAA,F1R,F1L,F2 :: MAT{REAL}*

     E = E

     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     F1L.create(n_gcm,n_gcm);F1R.create(n_gcm,n_gcm);F2.create(n_gcm,n_gcm)
     AAA.create(n_gcm,n_gcm)

     if( .scfdata.using_ppzpp)then
       do i = 1,n_gcm
       do j = 1,n_gcm
         AAA(i,j)=alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
       end do
       end do
     else
       do i = 1,n_gcm
       do j = 1,n_gcm
         AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
       end do
       end do
     end

     do i = 1,n_gcm
       do j = 1,n_gcm
         F(i,j)   =  A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
         F2(i,j)  =  PAP(i,j)/p(j)/p(i) + AAA(i,j)
        end do
     end do

     F=F+matmul(transpose(Yr),F1L) 
     F=F+matmul(F1R,Yr)
     F=F+matmul(transpose(Yr),matmul(F2,Yr))

     AAA.destroy     
     F1L.destroy;F1R.destroy;F2.destroy

   end

   build_da_IOTC_dens(F,Yr,PAP,A,p,bp,E,ppApp)
   ! build the IOTC Y matrix 
   F :: MAT{CPX}
   Yr,PAP,A :: MAT{CPX}
   p,bp,E :: VEC{REAL}
   ppApp :: MAT{CPX}, optional
   i,j,n_gcm,dim :: INT
   c,alpha,alpha2 :: REAL
   AAA,F1R,F1L,F2 :: MAT{CPX}*

   E = E

   n_gcm=.n_prim
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     dim=2*n_gcm

     F1L.create(dim,dim);F1R.create(dim,dim);F2.create(dim,dim)
     AAA.create(dim,dim)

     if( .scfdata.using_ppzpp)then
       do i = 1,dim
       do j = 1,dim
         AAA(i,j)=alpha2*bp(i)/p(i)*ppApp(i,j)*bp(j)/p(j)
       end do
       end do
     else
       do i = 1,dim
       do j = 1,dim
         AAA(i,j)=alpha2*p(i)*bp(i)*A(i,j)*bp(j)*p(j)
       end do
       end do
     end

     do i = 1,dim
       do j = 1,dim
         F(i,j)   =  A(i,j) + alpha2*bp(i)*PAP(i,j)*bp(j)
         F1L(i,j) =  alpha * ( bp(i)*p(i)*A(i,j)-PAP(i,j)/p(i)*bp(j) )         
         F1R(i,j) =  alpha * ( A(i,j)*bp(j)*p(j)-bp(i)*PAP(i,j)/p(j) )
         F2(i,j)  =  PAP(i,j)/p(j)/p(i) + AAA(i,j)
        end do
     end do

     AAA.to_product_of(Yr,F1L,dagger_a=TRUE)
     F=F+AAA+matmul(F1R,Yr)
     AAA.to_product_of(Yr,F2,dagger_a=TRUE)
     F=F+matmul(AAA,Yr)

     AAA.destroy     
     F1L.destroy;F1R.destroy;F2.destroy

   end

!   build_da_IOTC_dens_old(F,Yr,PAP,A,p,bp,E,ppApp)
!   ! build the IOTC Y matrix 
!   F :: MAT{CPX}
!   Yr,PAP,A :: MAT{CPX}
!   p,bp,E :: VEC{REAL}
!   ppApp :: MAT{CPX}, optional
!   i,j,k,l,n_gcm :: INT
!   c,alpha,alpha2 :: REAL
!
!     E = E
!
!   n_gcm=.n_prim
!     c = SPEED_OF_LIGHT_AU
!     alpha = ONE/c
!     alpha2= alpha*alpha
!
!
!     do i = 1,2*n_gcm
!
!       do j = 1,2*n_gcm
!
!         F(i,j)=F(i,j)+A(i,j)+alpha2*bp(i)*PAP(i,j)*bp(j)
!
!          do k = 1,2*n_gcm  
!            F(i,j) = F(i,j) + alpha* ( A(i,k)*bp(k)*p(k)-bp(i)*PAP(i,k)/p(k) )*Yr(k,j)         &
!                            + alpha*conjg(Yr(k,i))* ( bp(k)*p(k)*A(k,j)-PAP(k,j)/p(k)*bp(j) )         
!            do l = 1,2*n_gcm
!              if( .scfdata.using_ppzpp)then
!                F(i,j) = F(i,j) + conjg(Yr(k,i))* ( PAP(k,l)/p(l)/p(k)         &
!                                           + alpha2*bp(k)/p(k)*ppApp(k,l)*bp(l)/p(l) ) *Yr(l,j)  
!              else
!                F(i,j) = F(i,j) + conjg(Yr(k,i))* ( PAP(k,l)/p(l)/p(k)         &
!                                           + alpha2*p(k)*bp(k)*A(k,l)*bp(l)*p(l) ) *Yr(l,j)  
!              end if
!            end do
!          end do
!
!       end do
!     end do
!
!   end

   density_IOTC(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{REAL} , OUT
    pt :: MAT{REAL} , IN
    D :: MAT{REAL} , IN
    n_gcm,n_pt :: INT
    n,i,j,k :: INT
    g,c,alpha,alpha2 :: REAL
    m_out :: MAT{INT}*
    R,Y,U,A,T,O :: MAT{REAL}*
    SOx,SOy,SOz,Yr :: MAT{REAL}*
    YU,GG,S,Z,PZP :: MAT{REAL}*
    P2,Ap,E,p,ep,bp :: VEC{REAL}*

    n_pt = pt.dim1
!!! analysis of the primitive basis set via the overap matrix
!!! trying to lower the problem to an general contracted basis set
!!!  OVERLAP MATRIX !!!
     R.create(.n_prim,.n_prim)
    .make_primitive_overlap_matrix(R)
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm)  
!    .make_ready_da_gcm_tr(R,m_out,n_gcm)  
! put the overlap matrix into the n_gcm non-redundant space
     S.create(n_gcm,n_gcm)
     .get_da_gcm_now(R,S,m_out)  

     Y.create(n_gcm,n_gcm)
     Y.to_inverse_sqrt_of(S)

!!!  KINETIC ENERGY MATRIX !!!
     R=ZERO
     .make_primitive_kinetic_matrix(R) 
     T.create(n_gcm,n_gcm)
! put the kinetic energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,T,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(Y,T)   
     T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     T.solve_eigenproblem(P2,U)
     P2= TWO * P2
     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     T.destroy
     Y.destroy
     U.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     .make_primitive_nuclear_matrix(R)
     Z.create(n_gcm,n_gcm)
! put the potential energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,Z,m_out)  

     A.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(A,YU)

!!!  PZP MATRIX  !!!
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R=ZERO
         .make_primitive_DKH_matrices(R,SOx,SOy,SOz)
       SOx.destroy
       SOy.destroy
       SOz.destroy

     PZP.create(n_gcm,n_gcm)
! put the PZP matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,PZP,m_out) 

     A.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,YU)
     R.destroy

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(n_gcm)
     p.create(n_gcm)
     ep.create(n_gcm)
     Ap.create(n_gcm)
     bp.create(n_gcm)

     E=ZERO 
     p=ZERO
     ep=ZERO
     Ap=ZERO
     bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE)

     end  
    P2.destroy

     do i=1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)

       end
     end

!     if( .scfdata.using_ppzpp)then
!       do i=1,n_gcm
!         do j=1,n_gcm
!
 !         ppZpp(i,j) = Ap(i)*ppZpp(i,j)*Ap(j)
 !   
!         end do
!       end do
!     end if
! lets find the transforation matrix
     Yr.create(n_gcm,n_gcm)

    .find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
    .put_debug(Yr,"Y matrix")

! lets make ready the normalzation matrix
     O.create(n_gcm,n_gcm)
     O=ZERO
     do i=1,n_gcm
       O(i,i)=ONE
       do j=1,n_gcm
         do k=1,n_gcm
           O(i,j)=O(i,j)+Yr(k,i)*Yr(k,j)
         end do
       end do
     end do

     A.to_inverse_sqrt_of(O)
     O=A
     Z.destroy
     PZP.destroy
 !  if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
 !   ppZpp.destroy
 !  end if
     A.destroy

    GG.create(.n_bf,.n_bf)
    do n = 1,n_pt
     GG=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to it's non-relativistic
! counter part really not effective :(
     .make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,E,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)

       g=ZERO

       do i=1,.n_bf
         do j=1,.n_bf
           g = g + D(i,j)*GG(i,j)
         end            
       end            

       density_grid(n)= g
      end

    S.destroy
    O.destroy
    GG.destroy
    YU.destroy
    Yr.destroy
    Ap.destroy
    E.destroy
    p.destroy
    bp.destroy
    ep.destroy
    m_out.destroy

   end

   density_IOTC_orb_r(density_grid,pt,MO,square)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{REAL} , OUT
    pt :: MAT{REAL} , IN
    MO :: VEC{REAL} , IN
    square :: BIN , IN, optional
    n_gcm,n_pt :: INT
    n,i,j,k :: INT
    g,c,alpha,alpha2 :: REAL
    m_out :: MAT{INT}*
    R,Y,U,A,T,O :: MAT{REAL}*
    SOx,SOy,SOz,Yr :: MAT{REAL}*
    YU,GG,S,Z,PZP :: MAT{REAL}*
    P2,Ap,E,p,ep,bp :: VEC{REAL}*

    n_pt = pt.dim1
!!! analysis of the primitive basis set via the overap matrix
!!! trying to lower the problem to an general contracted basis set
!!!  OVERLAP MATRIX !!!
     R.create(.n_prim,.n_prim)
    .make_primitive_overlap_matrix(R)
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm)  
!    .make_ready_da_gcm_tr(R,m_out,n_gcm)  
! put the overlap matrix into the n_gcm non-redundant space
     S.create(n_gcm,n_gcm)
     .get_da_gcm_now(R,S,m_out)  

     Y.create(n_gcm,n_gcm)
     Y.to_inverse_sqrt_of(S)

!!!  KINETIC ENERGY MATRIX !!!
     R=ZERO
     .make_primitive_kinetic_matrix(R) 
     T.create(n_gcm,n_gcm)
! put the kinetic energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,T,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(Y,T)   
     T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     U.create(n_gcm,n_gcm)
     P2.create(n_gcm)
     T.solve_eigenproblem(P2,U)
     P2= TWO * P2
     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     T.destroy
     Y.destroy
     U.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     .make_primitive_nuclear_matrix(R)
     Z.create(n_gcm,n_gcm)
! put the potential energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,Z,m_out)  

     A.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(A,YU)

!!!  PZP MATRIX  !!!
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
     R=ZERO
         .make_primitive_DKH_matrices(R,SOx,SOy,SOz)
       SOx.destroy
       SOy.destroy
       SOz.destroy

     PZP.create(n_gcm,n_gcm)
! put the PZP matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,PZP,m_out) 

     A.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(A,YU)

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(n_gcm)
     p.create(n_gcm)
     ep.create(n_gcm)
     Ap.create(n_gcm)
     bp.create(n_gcm)

     E=ZERO 
     p=ZERO
     ep=ZERO
     Ap=ZERO
     bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE)

     end  
    P2.destroy

     do i=1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)

       end
     end

!     if( .scfdata.using_ppzpp)then
!       do i=1,n_gcm
!         do j=1,n_gcm
!
 !         ppZpp(i,j) = Ap(i)*ppZpp(i,j)*Ap(j)
 !   
!         end do
!       end do
!     end if
! lets find the transforation matrix
     Yr.create(n_gcm,n_gcm)

    .find_da_Y_iterative(Yr,PZP,Z,p,bp,ep)
    .put_debug(Yr,"Y matrix")

! lets make ready the normalzation matrix
     O.create(n_gcm,n_gcm)
     O=ZERO
     do i=1,n_gcm
       O(i,i)=ONE
       do j=1,n_gcm
         do k=1,n_gcm
           O(i,j)=O(i,j)+Yr(k,i)*Yr(k,j)
         end do
       end do
     end do

     A.to_inverse_sqrt_of(O)
     O=A
     Z.destroy
     PZP.destroy
 !  if(.scfdata.DK2_PCE AND .scfdata.using_ppzpp)then
 !   ppZpp.destroy
 !  end if
     A.destroy

    GG.create(.n_bf,.n_bf)
    do n = 1,n_pt
      GG=ZERO
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to it's non-relativistic
! counter part really not effective :(
      .make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,E,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)

       g=ZERO

       do i=1,.n_bf
         do j=1,.n_bf
            g = g + MO(i)*GG(i,j)*MO(j)
         end            
       end           

       ! unfortunatelly the PCE corrected orbitals lose phase :(
       if( NOT square) g=sqrt(g)

       density_grid(n)= g

     end

    R.destroy
    S.destroy
    O.destroy
    GG.destroy
    YU.destroy
    Yr.destroy
    Ap.destroy
    E.destroy
    p.destroy
    bp.destroy
    ep.destroy
    m_out.destroy

   end

   make_DENSITY_IOTC_PCE_off(GG,Yr,YU,Ap,E,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O)
   ! correct the picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_matrix(H) routine
        GG :: MAT{REAL} , OUT
        Yr,YU :: MAT{REAL} , IN
        Ap,E,bp,p :: VEC{REAL} , IN
        ep :: VEC{REAL}
        xx,yy,zz :: REAL , IN
        m_out :: MAT{INT} , IN
        n_gcm :: INT , IN
        S,O :: MAT{REAL} , IN

        i,j :: INT   
        R :: MAT{REAL}*  
        D,PDP,PPDPP :: MAT{REAL}*
        A,B :: MAT{REAL}*
        M,buco :: MAT{REAL}* 

     ep = ep

!!!  the density operator X !!!
     R.create(.n_prim,.n_prim)
     R=ZERO
! it do not exist in the moment
     .make_primitive_density_matrix(R,xx,yy,zz)
     D.create(n_gcm,n_gcm)
     D=ZERO
! put the potential energy matrix into the n_gcm non-redundant space
     .get_da_gcm_now(R,D,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)

!!!  PDP MATRIX  !!!
      R=ZERO
     .make_primitive_pDp_matrix(R,xx,yy,zz) 

     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
! put the PDP matrix into the n_gcm non-redundant space
    .get_da_gcm_now(R,PDP,m_out)  
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)

   if( .scfdata.using_ppzpp)then
      R=ZERO 
      .make_primitive_ppDpp_matrix(R,xx,yy,zz) 
      PPDPP.create(n_gcm,n_gcm)
      .get_da_gcm_now(R,PPDPP,m_out)  
      A=ZERO
      A.to_product_of(YU,PPDPP,transpose_a=TRUE)
      PPDPP.to_product_of(A,YU)
  end if 

!!! A-O LETS GO !!!

     do i=1,n_gcm
       do j=1,n_gcm

        D(i,j) = Ap(i)*D(i,j)*Ap(j)
        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)                                        

       end
     end

      if(.scfdata.using_ppzpp)then
! use the second derivatives in the [W1,[W1,X(even,0)]] and [W2,X(odd,0)] terms   
        do i=1,n_gcm
          do j=1,n_gcm
            PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j) 
          end do
        end do
      end if  

     B.create(n_gcm,n_gcm) 
     B=ZERO  
     if(.scfdata.using_ppzpp)then
       .build_da_IOTC_dens(B,Yr,PDP,D,p,bp,E,n_gcm,PPDPP)
     else
       .build_da_IOTC_dens(B,Yr,PDP,D,p,bp,E,n_gcm)
     end if  

     D=ZERO
     D=matmul(O,matmul(B,O))

    PDP.destroy
    if(.scfdata.using_ppzpp)then
     PPDPP.destroy
    end if 

     B=ZERO
     B.to_product_of(S,YU)

     A=ZERO
     A.to_product_of(B,D)
     D.to_product_of(A,B,transpose_b=TRUE)

     A.destroy
     B.destroy

!!! moving back to tonto style primitive basis sets 
     R=ZERO
! put the Fock matrix back to the space .n_prim space
     .get_back_prim_now(D,R,m_out)  
     D.destroy

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     .make_normalised_contraction_mx(M)
     buco.create(.n_bf,.n_prim)
     buco.to_product_of(M,R,transpose_a=TRUE)
     R.destroy

     GG.to_product_of(buco,M)

     M.destroy
     buco.destroy
   end   

   density_IOTC_gc(density_grid,pt,D)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{REAL} , OUT
    pt :: MAT{REAL} , IN
    D :: MAT{CPX} , IN

    n_gcm,n_pt :: INT
    n,i,j :: INT
    g,fac,c,alpha,alpha2,eps :: REAL
    gc,II :: CPX
    m_out,mmm :: MAT{INT}* 
    Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
    GG22 :: MAT{CPX}*
    SOx,SOy,SOz :: MAT{REAL}*
    A2,PAP,O,Ox,Yr :: MAT{CPX}*
    Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*

    n_pt = pt.dim1
     !test
     mmm.create(.n_prim,.n_prim)
      .get_n_gcm(mmm,n_gcm)
     mmm.destroy 
     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
       DIE(" It seems you are using contracted gaussians this does not work for IOTC at gchf level!")
     end if    

  !!! n_gcm = .n_prim = .n_bf

! this is actually not needed but I am also using n_gcm 
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm) 
     R.create(.n_prim,.n_prim)
     S.create(n_gcm,n_gcm)
     Y.create(n_gcm,n_gcm)
     S=ZERO; Y=ZERO
!!!  OVERLAP MATRIX + Y MX !!!
    .make_primitive_overlap_matrix(S)
     Y.to_inverse_sqrt_of(S)
   !  .make_S_Y(S,Y)  !  ???

!!!  KINETIC ENERGY MATRIX -> U & P2!!!
     T.create(n_gcm,n_gcm)
     T=ZERO
     .make_primitive_kinetic_matrix(T)
     R=ZERO
     R.to_product_of(Y,T)   
     T.to_product_of(R,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     P2.create(n_gcm)
     U.create(n_gcm,n_gcm)
     P2=ZERO;U=ZERO
     T.solve_eigenproblem(P2,U)
     ! the momentum squared instead of kinetic energy
     P2= TWO * P2

     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     Y.destroy
     U.destroy
     T.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     Z.create(n_gcm,n_gcm)
    .make_primitive_nuclear_matrix(Z)
! put the potential energy matrix into the YU space
     R.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(R,YU)
     R=ZERO

!!!  PZP MATRIX  !!!
     PZP.create(n_gcm,n_gcm)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
         .make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
    .put_debug(PZP,"PZP matrix")
    .put_debug(SOx,"SOx matrix")
    .put_debug(SOy,"SOy matrix")
    .put_debug(SOz,"SOz matrix")

     R.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(R,YU)
     R=ZERO
     R.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(R,YU)
     R=ZERO

    .put_debug(PZP,"PZP matrix YU")
    .put_debug(SOx,"SOx matrix YU")
    .put_debug(SOy,"SOy matrix YU")
    .put_debug(SOz,"SOz matrix YU")
!    .put_debug(ppZpp,"ppZpp matrix YU")

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
     Ap.create(n_gcm)

     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)
     end do

     P2.destroy

     do i = 1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

       end
     end

    .put_debug(PZP,"PZP matrix YUAp")
    .put_debug(SOx,"SOx matrix YUAp")
    .put_debug(SOy,"SOy matrix YUAp")
    .put_debug(SOz,"SOz matrix YUAp")

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(Z)
     A2.beta_beta_plus(Z)
!   A.make_hermitian   
    .put_debug(A2,"A matrix")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PZP)
     PAP.beta_beta_plus(PZP)
     II = (ZERO,ONE)
     fac= ONE
      PAP.beta_alpha_plus(SOx,fac*II)
      PAP.beta_alpha_plus(SOy,-fac)
      PAP.alpha_alpha_plus(SOz,fac*II)
      PAP.beta_beta_plus(SOz,-fac*II)
   PAP.make_hermitian   
    .put_debug(PAP,"PAP matrix")
     Y0.create(n_gcm,n_gcm)
     Y0=ZERO
    .find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)
     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy

! lets find the transforation matrix
     Yr.create(2*n_gcm,2*n_gcm)
     Yr=(ZERO,ZERO)
     Yr.alpha_alpha_plus(Y0)
     Yr.beta_beta_plus(Y0)
     Y0.destroy

!    .find_da_Y_iterative(Yr,PZP,SOx,SOy,SOz,Z,p,bp,ep)
    .find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
    .put_debug(Yr,"Y matrix")

    PAP.destroy
    A2.destroy

     O.create(2*n_gcm,2*n_gcm)
     Ox.create(2*n_gcm,2*n_gcm)
     O=(ZERO,ZERO)
!     A=(ZERO,ZERO)
     Ox=(ZERO,ZERO)
     do i=1,2*n_gcm
       Ox(i,i)=ONE
     end do
     O.to_product_of(Yr,Yr,dagger_a=TRUE)
     Ox=Ox+O
     O=(ZERO,ZERO)
    UN.create(2*n_gcm)
    UN=ZERO

    ! make ready the preconditioning
    do i=1,2*n_gcm
      UN(i)=ONE/sqrt(real(Ox(i,i)))
    end 

    do i=1,2*n_gcm
      do j=1,2*n_gcm
        Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
      end
    end  
    .put_debug(Ox,"Ox matrix")
     eps=TOL(15)
     O.to_power_series_inv_sqrt_of(Ox,eps)
    do i=1,2*n_gcm
      do j=1,2*n_gcm
        O(i,j)=O(i,j)*UN(j)
      end
    end  
    UN.destroy
    Ox.destroy

    .put_debug(O,"O matrix")

    GG22.create(2*n_gcm,2*n_gcm)
    do n = 1,n_pt
       GG22=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code is comparing to it's non-relativistic
! counter part really not effective :(
     .make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,E,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)

       gc=(ZERO,ZERO)

       do i=1,2*.n_bf
         do j=1,2*.n_bf
             gc = gc + D(j,i)*GG22(i,j)
         end            
       end            
       g=ZERO
       g= real(gc)      
       density_grid(n)= g
    end

    S.destroy
    O.destroy
    Yr.destroy
    GG22.destroy
    YU.destroy
    Ap.destroy
    E.destroy
    bp.destroy
    ep.destroy
    p.destroy
    m_out.destroy
   end

   density_IOTC_orb_gc(density_grid,pt,MO)
   ! the density_grid will be filled with the values of density
   ! given by the coordinates in the pt matrix
    density_grid :: VEC{CPX} 
    pt :: MAT{REAL} , IN
    MO :: VEC{CPX} , IN

    n_gcm,n_pt :: INT
    n,i,j :: INT
    g,fac,c,alpha,alpha2,eps :: REAL
    gc,II :: CPX
    m_out,mmm :: MAT{INT}* 
    Y,U,YU,S,T,R,Z,PZP,Y0 :: MAT{REAL}*
    GG22 :: MAT{CPX}*
    SOx,SOy,SOz :: MAT{REAL}*
    A2,PAP,O,Ox,Yr :: MAT{CPX}*
    Ap,E,bp,p,P2,ep,UN :: VEC{REAL}*

    n_pt = pt.dim1
     !test
     mmm.create(.n_prim,.n_prim)
      .get_n_gcm(mmm,n_gcm)
     mmm.destroy 
     if( abs(.n_prim-n_gcm) > 0 OR abs(.n_prim-.n_bf) > 0 )then
       DIE(" It seems you are using contracted gaussians this does not work for IOTC at gchf level!")
     end if    

  !!! n_gcm = .n_prim = .n_bf

! this is actually not needed but I am also using n_gcm 
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm) 
     R.create(.n_prim,.n_prim)
     S.create(n_gcm,n_gcm)
     Y.create(n_gcm,n_gcm)
     S=ZERO; Y=ZERO
!!!  OVERLAP MATRIX + Y MX !!!
    .make_primitive_overlap_matrix(S)
     Y.to_inverse_sqrt_of(S)
   !  .make_S_Y(S,Y)  !  ???

!!!  KINETIC ENERGY MATRIX -> U & P2!!!
     T.create(n_gcm,n_gcm)
     T=ZERO
     .make_primitive_kinetic_matrix(T)
     R=ZERO
     R.to_product_of(Y,T)   
     T.to_product_of(R,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     P2.create(n_gcm)
     U.create(n_gcm,n_gcm)
     P2=ZERO;U=ZERO
     T.solve_eigenproblem(P2,U)
     ! the momentum squared instead of kinetic energy
     P2= TWO * P2

     YU.create(n_gcm,n_gcm)
     YU.to_product_of(Y,U)
     Y.destroy
     U.destroy
     T.destroy

!!!  POTENTIAL ENERGY MATRIX (electron-nucleus) !!!
     R=ZERO
     Z.create(n_gcm,n_gcm)
    .make_primitive_nuclear_matrix(Z)
! put the potential energy matrix into the YU space
!    .make_R_to_YU(R,Z,YU)
     R.to_product_of(YU,Z,transpose_a=TRUE)
     Z.to_product_of(R,YU)
     R=ZERO

!!!  PZP MATRIX  !!!
     PZP.create(n_gcm,n_gcm)
     SOx.create(.n_prim,.n_prim)
     SOy.create(.n_prim,.n_prim)
     SOz.create(.n_prim,.n_prim)
         .make_primitive_DKH_matrices(PZP,SOx,SOy,SOz)
    .put_debug(PZP,"PZP matrix")
    .put_debug(SOx,"SOx matrix")
    .put_debug(SOy,"SOy matrix")
    .put_debug(SOz,"SOz matrix")

     R.to_product_of(YU,PZP,transpose_a=TRUE)
     PZP.to_product_of(R,YU)
     R=ZERO

     R.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(R,YU)
     R=ZERO

     R.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(R,YU)
     R=ZERO

     R.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(R,YU)
     R=ZERO

    .put_debug(PZP,"PZP matrix YU")
    .put_debug(SOx,"SOx matrix YU")
    .put_debug(SOy,"SOy matrix YU")
    .put_debug(SOz,"SOz matrix YU")
!    .put_debug(ppZpp,"ppZpp matrix YU")

!!! A-O LETS GO !!!
     c = SPEED_OF_LIGHT_AU
     alpha = ONE/c
     alpha2= alpha*alpha

     E.create(2*n_gcm);ep.create(2*n_gcm);p.create(2*n_gcm);bp.create(2*n_gcm)
     Ap.create(n_gcm)

     E=ZERO;p=ZERO;ep=ZERO;Ap=ZERO;bp=ZERO

     do i = 1,n_gcm

       E(i)= c * sqrt(P2(i) + c * c); E(i+n_gcm)= c * sqrt(P2(i) + c * c)
       p(i)=sqrt(P2(i)); p(i+n_gcm)=sqrt(P2(i))
       ep(i)=sqrt(ONE+P2(i)*alpha2); ep(i+n_gcm)=sqrt(ONE+P2(i)*alpha2) 
       Ap(i)= sqrt( (E(i) + c * c)/(TWO * E(i)) )  
       bp(i)=ONE/(ep(i)+ONE); bp(i+n_gcm)=ONE/(ep(i)+ONE)
     end do

     P2.destroy

     do i = 1,n_gcm
       do j=1,n_gcm

        Z(i,j) = Ap(i)*Z(i,j)*Ap(j)
        PZP(i,j) = Ap(i)*PZP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

       end
     end

    .put_debug(PZP,"PZP matrix YUAp")
    .put_debug(SOx,"SOx matrix YUAp")
    .put_debug(SOy,"SOy matrix YUAp")
    .put_debug(SOz,"SOz matrix YUAp")

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(Z)
     A2.beta_beta_plus(Z)
!   A.make_hermitian   
    .put_debug(A2,"A matrix")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PZP)
     PAP.beta_beta_plus(PZP)
     II = (ZERO,ONE)
     fac= ONE
      PAP.beta_alpha_plus(SOx,fac*II)
      PAP.beta_alpha_plus(SOy,-fac)
      PAP.alpha_alpha_plus(SOz,fac*II)
      PAP.beta_beta_plus(SOz,-fac*II)
   PAP.make_hermitian   
    .put_debug(PAP,"PAP matrix")
     Y0.create(n_gcm,n_gcm)
     Y0=ZERO
    .find_da_Y_iterative(Y0,PZP,Z,p,bp,ep)
     Z.destroy
     PZP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy

! lets find the transforation matrix
     Yr.create(2*n_gcm,2*n_gcm)
     Yr=(ZERO,ZERO)
     Yr.alpha_alpha_plus(Y0)
     Yr.beta_beta_plus(Y0)
     Y0.destroy

    .find_da_Y_iterative(Yr,PAP,A2,p,bp,ep)
    .put_debug(Yr,"Y matrix")

    PAP.destroy
    A2.destroy

     O.create(2*n_gcm,2*n_gcm)
     Ox.create(2*n_gcm,2*n_gcm)
     O=(ZERO,ZERO)
!     A=(ZERO,ZERO)
     Ox=(ZERO,ZERO)
     do i=1,2*n_gcm
       Ox(i,i)=ONE
     end do
     O.to_product_of(Yr,Yr,dagger_a=TRUE)
     Ox=Ox+O
     O=(ZERO,ZERO)
    .put_debug(Ox,"Ox matrix")
    UN.create(2*n_gcm)
    UN=ZERO

    ! make ready the preconditioning
    do i=1,2*n_gcm
      UN(i)=ONE/sqrt(real(Ox(i,i)))
    end 

    do i=1,2*n_gcm
      do j=1,2*n_gcm
        Ox(i,j)=Ox(i,j)*UN(i)*UN(j)
      end
    end  
    .put_debug(Ox,"Ox matrix")
     eps=TOL(15)
     O.to_power_series_inv_sqrt_of(Ox,eps)
    do i=1,2*n_gcm
      do j=1,2*n_gcm
        O(i,j)=O(i,j)*UN(j)
      end
    end  
    UN.destroy
    Ox.destroy

    GG22.create(2*n_gcm,2*n_gcm)
    do n = 1,n_pt
       GG22=(ZERO,ZERO)
! here it comes babes
! point for point the density will be on and on calculated
! I am sincerely sorry, but the code comparing to it's non-relativistic
! counter part really not effective :(
     .make_DENSITY_IOTC_PCE_SO_off(GG22,Yr,YU,Ap,E,bp,p,ep,pt(n,1),pt(n,2),pt(n,3),m_out,n_gcm,S,O)

       gc=(ZERO,ZERO)

       do i=1,2*.n_bf
         do j=1,2*.n_bf
              gc = gc + conjg(MO(i))*GG22(i,j)*MO(j)
         end            
       end            
       g=ZERO
       g= real(gc)      
       density_grid(n)= g
    end

    S.destroy
    O.destroy
    Yr.destroy
    GG22.destroy
    YU.destroy
    Ap.destroy
    E.destroy
    bp.destroy
    ep.destroy
    p.destroy
    m_out.destroy
   end

   make_DENSITY_IOTC_PCE_SO_off(GG,Yr,YU,Ap,E,bp,p,ep,xx,yy,zz,m_out,n_gcm,S,O)
   ! correct the  picture change
   ! g is the electron density in a given point with coordinates x=xx, y=yy, z=zz
   ! this routine is based on the make_r_DKH_matrix(H) routine

        GG,Yr :: MAT{CPX} 
        YU :: MAT{REAL} , IN
        Ap,E,bp,p :: VEC{REAL} , IN
        ep :: VEC{REAL} 
        xx,yy,zz :: REAL , IN
        m_out :: MAT{INT} , IN
        n_gcm :: INT , IN
        S :: MAT{REAL} , IN
        O :: MAT{CPX} 

        II :: CPX
        fac :: REAL  
        i,j :: INT  
        F,A2,B2,M2,buco,PAP,ppApp :: MAT{CPX}*
        R :: MAT{REAL}*  
        D,PDP,SOx,SOy,SOz,PPDPP :: MAT{REAL}*  
        A,B,M :: MAT{REAL}*

     ep = ep

!!!  the density X operator !!!
     R.create(.n_prim,.n_prim)
     R=ZERO
     D.create(n_gcm,n_gcm)
     D=ZERO
     .make_primitive_density_matrix(D,xx,yy,zz)
     A.create(n_gcm,n_gcm)
     A=ZERO
     A.to_product_of(YU,D,transpose_a=TRUE)
     D.to_product_of(A,YU)
!!!  the density PXP operator !!!
     PDP.create(n_gcm,n_gcm)
     PDP=ZERO
     .make_primitive_pDp_matrix(PDP,xx,yy,zz) 
     A=ZERO
     A.to_product_of(YU,PDP,transpose_a=TRUE)
     PDP.to_product_of(A,YU)
!!!  SO MATRICES  !!!
     SOx.create(n_gcm,n_gcm)
     SOy.create(n_gcm,n_gcm)
     SOz.create(n_gcm,n_gcm)
      SOx=ZERO; SOy=ZERO; SOz=ZERO
     .make_primitive_pDp_SO_matrix(SOx,SOy,SOz,xx,yy,zz) 
     A=ZERO
     A.to_product_of(YU,SOx,transpose_a=TRUE)
     SOx.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOy,transpose_a=TRUE)
     SOy.to_product_of(A,YU)
     A=ZERO
     A.to_product_of(YU,SOz,transpose_a=TRUE)
     SOz.to_product_of(A,YU)

!!! A-O LETS GO !!!

     A=ZERO

     do i=1,n_gcm
       do j=1,n_gcm

        D(i,j) = Ap(i)*D(i,j)*Ap(j)                                        
        PDP(i,j) = Ap(i)*PDP(i,j)*Ap(j)
        SOx(i,j) = Ap(i)*SOx(i,j)*Ap(j)
        SOy(i,j) = Ap(i)*SOy(i,j)*Ap(j)
        SOz(i,j) = Ap(i)*SOz(i,j)*Ap(j)

       end
     end

     if(.scfdata.using_ppzpp)then
       PPDPP.create(n_gcm,n_gcm)
       PPDPP=ZERO
       .make_primitive_ppDpp_matrix(PPDPP,xx,yy,zz) 
       .get_da_gcm_now(R,PPDPP,m_out)  
       A=ZERO
       A.to_product_of(YU,PPDPP,transpose_a=TRUE)
       PPDPP.to_product_of(A,YU)

        do i=1,n_gcm
          do j=1,n_gcm
            PPDPP(i,j) = Ap(i)*PPDPP(i,j)*Ap(j)
          end do
        end do
      end if  
    A.destroy

   A2.create(2*n_gcm,2*n_gcm)
   A2=(ZERO,ZERO)
     A2.alpha_alpha_plus(D)
     A2.beta_beta_plus(D)
!   A.make_hermitian   
    .put_debug(A2,"A matrix")
   PAP.create(2*n_gcm,2*n_gcm)
   PAP=(ZERO,ZERO)
     PAP.alpha_alpha_plus(PDP)
     PAP.beta_beta_plus(PDP)
     II = (ZERO,ONE)
     fac= ONE
      PAP.beta_alpha_plus(SOx,fac*II)
      PAP.beta_alpha_plus(SOy,-fac)
      PAP.alpha_alpha_plus(SOz,fac*II)
      PAP.beta_beta_plus(SOz,-fac*II)
   PAP.make_hermitian   
    .put_debug(PAP,"PAP matrix")
   if( .scfdata.using_ppzpp)then
   ppApp.create(2*n_gcm,2*n_gcm)
   ppApp=(ZERO,ZERO)
     ppApp.alpha_alpha_plus(PPDPP)
     ppApp.beta_beta_plus(PPDPP)
!  ppApp.make_hermitian   
    .put_debug(ppApp,"ppApp matrix")
     PPDPP.destroy
   end if
     D.destroy
     PDP.destroy
     SOx.destroy
     SOy.destroy
     SOz.destroy
     R.destroy

     F.create(2*n_gcm,2*n_gcm)
     F=(ZERO,ZERO)
! the hamiltonian is gonna be built
     if( .scfdata.using_ppzpp)then
       .build_da_IOTC_dens(F,Yr,PAP,A2,p,bp,E,ppApp)
     else  
       .build_da_IOTC_dens(F,Yr,PAP,A2,p,bp,E)
     end if 
    .put_debug(F,"F matrix")

     PAP.destroy
     if( .scfdata.using_ppzpp)then
       ppApp.destroy
     end if 

     A2=(ZERO,ZERO)
     ! normalization
     A2.to_product_of(F,O)
     F.to_product_of(O,A2,dagger_a=TRUE)

! back to cartesian basis set
     B.create(n_gcm,n_gcm) 
     B.to_product_of(S,YU)
     B2.create(2*n_gcm,2*n_gcm)
     B2=(ZERO,ZERO)
     B2.alpha_alpha_plus(B)
     B2.beta_beta_plus(B)
     B.destroy

     A2=(ZERO,ZERO)
     A2.to_product_of(B2,F)
     F.to_product_of(A2,B2,dagger_b=TRUE)
    .put_debug(F,"U+YOFOYU matrix")

     B2.destroy

     A2=(ZERO,ZERO)

!!! moving back to contracted basis sets 
     M.create(.n_prim,.n_bf)
     M=ZERO
     .make_normalised_contraction_mx(M)
    .put_debug(M,"M matrix")
!     M2.create(2*.n_prim,2*.n_bf)
     M2.create(2*.n_prim,2*.n_prim)
     M2=(ZERO,ZERO)
     M2.alpha_alpha_plus(M)
     M2.beta_beta_plus(M)
    .put_debug(M2,"M2 matrix")
     buco.create(2*.n_prim,2*.n_prim)
     buco=(ZERO,ZERO)
!     buco.to_product_of(M2,F,transpose_a=TRUE)
     buco.to_product_of(M2,F,dagger_a=TRUE)
     A2.to_product_of(buco,M2)
    .put_debug(A2,"MU+YOFOYUM matrix")
     M.destroy
     F.destroy
     M2.destroy
     buco.destroy

!      stdout.flush
!      stdout.text("seems the IOTC H(1e) is build ")
!      stdout.flush

     GG = A2
     A2.destroy
     .put_debug(GG,"GG matrix")

   end   

   make_S_Y(S,Y)
   ! Calculate the primitive ft matrix for a given hkl
   S,Y :: MAT{REAL}, OUT
   R :: MAT{REAL}*
   m_out :: MAT{INT}*
   n_gcm :: INT

     R.create(.n_prim,.n_prim)
    .make_primitive_overlap_matrix(R)
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm) 
!    .make_ready_da_gcm_tr(R,m_out,n_gcm)  
! put the overlap matrix into the n_gcm non-redundant space
    .get_da_gcm_now(R,S,m_out)  
     Y.to_inverse_sqrt_of(S)

     m_out.destroy
     R.destroy

   end

   make_U_P2(U,P2,Y)
   ! Calculate the primitive ft matrix for a given hkl
   U :: MAT{REAL}, OUT
   P2 :: VEC{REAL}, OUT
   Y :: MAT{REAL}, IN
   R,T,A :: MAT{REAL}*
   m_out :: MAT{INT}*
   n_gcm :: INT

     R.create(.n_prim,.n_prim)
    .make_primitive_kinetic_matrix(R) 
     m_out.create(.n_prim,.n_prim) 
    .make_ready_da_gcm_tr2(m_out,n_gcm) 
!    .make_ready_da_gcm_tr(R,m_out,n_gcm)  
     T.create(n_gcm,n_gcm)
! put the kinetic energy matrix into the n_gcm non-redundant space
    .get_da_gcm_now(R,T,m_out)  

     A.create(n_gcm,n_gcm)
     A.to_product_of(Y,T)   
     T.to_product_of(A,Y)              ! T=YTY  kinetic energy in an orthogonal basis
     T.solve_eigenproblem(P2,U)
     ! the momentum squared instead of kinetic energy
     P2= TWO * P2

     A.destroy
     T.destroy
     m_out.destroy
     R.destroy

   end

!   make_R_to_YU(R,XXX,YU)
!   ! Calculate the primitive ft matrix for a given hkl
!   R :: MAT{REAL}
!   XXX :: MAT{REAL}
!   YU :: MAT{REAL}
!   A,B :: MAT{REAL}*
!   m_out :: MAT{INT}*
!   n_gcm :: INT
!
!   XXX=ZERO
!     m_out.create(.n_prim,.n_prim) 
!    .make_ready_da_gcm_tr2(m_out,n_gcm) 
!!    .make_ready_da_gcm_tr(R,m_out,n_gcm)  
!     A.create(n_gcm,n_gcm)
!     A=ZERO
!     B.create(n_gcm,n_gcm)
!     B=ZERO
!!    .get_da_gcm_now(R,A,m_out)  
!
!     B.to_product_of(YU,A,transpose_a=TRUE)
!     XXX.to_product_of(B,YU)
!
!     A.destroy
!     B.destroy
!     m_out.destroy
!
!   end

end
