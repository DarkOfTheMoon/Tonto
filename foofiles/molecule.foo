!-------------------------------------------------------------------------------
!
! MOLECULE: An object representation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module MOLECULE

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

   saved_self :: MOLECULE*, private

   debug :: VEC{STR}*, private  DEFAULT_NULL

contains

!  **************************
!  Create and destroy methods
!  **************************

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, recursive
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the molecule
      nullify(.atom)
      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)
      nullify(.grid)
      nullify(.isosurface)
      nullify(.dftgrid)
      nullify(.becke_grid)
      nullify(.crystal)
      nullify(.cluster)
      nullify(.cif)
      nullify(.pointgroup)
      nullify(.atom_for_shell)
      nullify(.atom_shell_for_shell)
      nullify(.first_shell_for_atom)
      nullify(.last_shell_for_atom)
      nullify(.basis_shell_for_shell)
      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.angular_moment_for_shell)
      nullify(.first_basis_fn_for_atom)
      nullify(.last_basis_fn_for_atom)
      nullify(.precomputed_basis_shellpair)
      nullify(.max_I)
      nullify(.atom_kind)
      nullify(.unique_atom)
      nullify(.overlapping_atoms)
      nullify(.scfdata)
      nullify(.orbital_energies)
      nullify(.molecular_orbitals)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation_numbers)
      nullify(.overlap_matrix)
      nullify(.core_matrix)
      nullify(.fock_matrix)
      nullify(.constraint_matrix)
      nullify(.old_molecular_orbitals)
      nullify(.old_density_matrix)
      nullify(.old_fock_matrix)
      nullify(.old_constraint_matrix)
      nullify(.atom_group)
      nullify(.atom_group_energy)
      nullify(.group_charges)
      nullify(.mos_per_group)
      nullify(.roby)
      nullify(.saved)
      nullify(.dipole_polarisability)
      nullify(.localiser)
   end

   destroy_ptr_part ::: recursive, leaky
   ! Destroy the pointer parts of a molecule object
      .saved.destroy
      if (.atom.created) then
         .atom.nullify_basis_part ! nullify this !
         .atom.nullify_slaterbasis_part
         .atom.nullify_coppensbasis_part
         .destroy_ANO_data        ! In case .roby or promolecule densities used
         .destroy_atom_shell_info ! In case promolecule densities used
      end
      .atom.destroy
      .basis.destroy
      .slaterbasis.destroy
      .coppensbasis.destroy
      .grid.destroy
      .isosurface.destroy
      .dftgrid.destroy
      .becke_grid.destroy
      .crystal.destroy
      .cluster.destroy
      .cif.destroy
      .pointgroup.destroy
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .basis_shell_for_shell.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .precomputed_basis_shellpair.destroy
      .max_I.destroy
      .atom_kind.destroy
      .unique_atom.destroy
      .overlapping_atoms.destroy
      .scfdata.destroy
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
      .overlap_matrix.destroy
      .core_matrix.destroy
      .fock_matrix.destroy
      .constraint_matrix.destroy
      .old_molecular_orbitals.destroy
      .old_density_matrix.destroy
      .old_fock_matrix.destroy
      .old_constraint_matrix.destroy
      .atom_group.destroy
      .atom_group_energy.destroy
      .group_charges.destroy
      .mos_per_group.destroy
      .roby.destroy
      .dipole_polarisability.destroy
      .localiser.destroy
   end

   destroy_matrices ::: leaky
   ! Destroy the matrices of a molecule object
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
      .overlap_matrix.destroy
      .core_matrix.destroy
      .fock_matrix.destroy
      .old_molecular_orbitals.destroy
      .old_density_matrix.destroy
      .old_fock_matrix.destroy
      .old_constraint_matrix.destroy
      .constraint_matrix.destroy
      .atom_group.destroy
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   save ::: leaky
   ! Save everything about "self" in ".saved".
      self :: PTR
      saved :: MOLECULE*
      saved => self
      .create
      .saved => saved
   end

   unsave ::: leaky
   ! Revert back to a previously saved molecule stored in .saved, and
   ! destroy everything about the current molecule in "self".
   ! WARNING: be careful when setting up self, make sure none of its pointer
   ! parts refer to .saved information.
      self :: PTR
   ENSURE(.saved.created,"no previous settings")
      saved :: MOLECULE*
      saved => .saved
      nullify(.saved) ! don't destroy this
      .destroy        ! careful no .saved information is destroyed
      self => saved   ! restore
   end

   create_copy(mol) ::: leaky
   ! Create a copy of "mol"
      self :: PTR
      mol :: MOLECULE, IN
      .create
      .copy(mol)
   end

   copy(mol) ::: leaky
   ! Set self to be a copy of "mol"
      mol :: MOLECULE, IN
      ! Copy all non-pointer fields
      self = mol
      .nullify_ptr_part
      ! Create a copy of all pointer fields
      if (mol.atom.created) &
         .atom.create_copy(mol.atom)
      if (mol.basis.created) &
         .basis.create_copy(mol.basis)
      if (mol.slaterbasis.created) &
         .slaterbasis.create_copy(mol.slaterbasis)
      if (mol.coppensbasis.created) &
         .coppensbasis.create_copy(mol.coppensbasis)
      if (mol.grid.created) &
         .grid.create_copy(mol.grid)
      if (mol.dftgrid.created) &
         .dftgrid.create_copy(mol.dftgrid)
      if (mol.becke_grid.created) &
         .becke_grid.create_copy(mol.becke_grid)
      if (mol.crystal.created) &
         .crystal.create_copy(mol.crystal)
      if (mol.cluster.created) &
         .cluster.create_copy(mol.cluster)
      if (mol.cif.created) &
         .cif.create_copy(mol.cif)
      if (mol.pointgroup.created) &
         .pointgroup.create_copy(mol.pointgroup)
      if (mol.saved.created) &
         .saved.create_copy(mol.saved)
      if (mol.atom_for_shell.created) &
         .atom_for_shell.create_copy(mol.atom_for_shell)
      if (mol.atom_shell_for_shell.created) &
         .atom_shell_for_shell.create_copy(mol.atom_shell_for_shell)
      if (mol.first_shell_for_atom.created) &
         .first_shell_for_atom.create_copy(mol.first_shell_for_atom)
      if (mol.last_shell_for_atom.created) &
         .last_shell_for_atom.create_copy(mol.last_shell_for_atom)
      if (mol.first_basis_fn_for_shell.created) &
         .first_basis_fn_for_shell.create_copy(mol.first_basis_fn_for_shell)
      if (mol.last_basis_fn_for_shell.created) &
         .last_basis_fn_for_shell.create_copy(mol.last_basis_fn_for_shell)
      if (mol.angular_moment_for_shell.created) &
         .angular_moment_for_shell.create_copy(mol.angular_moment_for_shell)
      if (mol.atom_kind.created) &
         .atom_kind.create_copy(mol.atom_kind)
      if (mol.unique_atom.created) &
         .unique_atom.create_copy(mol.unique_atom)
      if (mol.overlapping_atoms.created) &
         .overlapping_atoms.create_copy(mol.overlapping_atoms)
      if (mol.first_basis_fn_for_atom.created) &
         .first_basis_fn_for_atom.create_copy(mol.first_basis_fn_for_atom)
      if (mol.last_basis_fn_for_atom.created) &
         .last_basis_fn_for_atom.create_copy(mol.last_basis_fn_for_atom)
      if (mol.scfdata.created) &
         .scfdata.create_copy(mol.scfdata)
      if (mol.orbital_energies.created) &
         .orbital_energies.create_copy(mol.orbital_energies)
      if (mol.molecular_orbitals.created) &
         .molecular_orbitals.create_copy(mol.molecular_orbitals)
      if (mol.density_matrix.created) &
         .density_matrix.create_copy(mol.density_matrix)
      if (mol.natural_orbitals.created) &
         .natural_orbitals.create_copy(mol.natural_orbitals)
      if (mol.occupation_numbers.created) &
         .occupation_numbers.create_copy(mol.occupation_numbers)
      if (mol.overlap_matrix.created) &
         .overlap_matrix.create_copy(mol.overlap_matrix)
      if (mol.core_matrix.created) &
         .core_matrix.create_copy(mol.core_matrix)
      if (mol.fock_matrix.created) &
         .fock_matrix.create_copy(mol.fock_matrix)
      if (mol.old_molecular_orbitals.created) &
         .old_molecular_orbitals.create_copy(mol.old_molecular_orbitals)
      if (mol.old_density_matrix.created) &
         .old_density_matrix.create_copy(mol.old_density_matrix)
      if (mol.old_fock_matrix.created) &
         .old_fock_matrix.create_copy(mol.old_fock_matrix)
      if (mol.constraint_matrix.created) &
         .constraint_matrix.create_copy(mol.constraint_matrix)
      if (mol.old_constraint_matrix.created) &
         .old_constraint_matrix.create_copy(mol.old_constraint_matrix)
      if (mol.atom_group.created) &
         .atom_group.create_copy(mol.atom_group)
      if (mol.group_charges.created) &
         .group_charges.create_copy(mol.group_charges)
      if (mol.mos_per_group.created) &
         .mos_per_group.create_copy(mol.mos_per_group)
   end

   set_defaults ::: leaky
   ! Set up a default molecule
      .name = "unknown"
      .E_field = ZERO
      .B_field = ZERO
      .gauge_origin = ZERO
      .charge = 0
      .mult = 1
      .optimise_thermals = FALSE
      .n_bf = 0
      .basis_set_kind = " "
      .basis_info_made = FALSE
    ! .CIF_file_name = " "
    ! .CIF_data_block_name = " "
      .CX_file_name = " "
      if (.atom.created) then
        .name = .chemical_formula
        .mult = .default_multiplicity
        .set_atom_info
      end
   end

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self
   end

   set_atom_info ::: leaky
   ! Set the associated atom information, including the number of alpha and beta
   ! electrons. NOTE: The multiplicity must be right for this to work.  The
   ! routine tries to reassign the multiplicity so that it will be consistent
   ! with the charge.
   ENSURE(.atom.created,"no atom info")
      .n_atom = size(.atom)
      if (NOT .has_valid_no_of_beta_electrons) then
         WARN("Inconsistent charge and multiplicity")
         WARN("Reassigning the multiplicity")
         .mult = .default_multiplicity
      end
      .n_e = .no_of_electrons
      .n_a = .no_of_alpha_electrons
      .n_b = .no_of_beta_electrons
      .atom_kind.destroy
      .atom_kind.create(.n_atom)
      .atom.make_atom_kind_list(.atom_kind,.n_atom_kind)
      .unique_atom.destroy
      .unique_atom.create(.n_atom_kind)
      .atom.make_unique_atom_list(.unique_atom)
      if (.atom.groups_defined) .make_atom_groups
   end

   resolve_basis_info ::: leaky
   ! Match the basis set labels for every atom with the actual atomic basis set.
   ! Also perform any finalization procedures to fully define all objects.
   ! This version is supposed to work for multiple bases.
      do_slaterbasis,do_coppensbasis,do_gaussianbasis :: BIN
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library_bf_kind :: STR
      if (.atom.destroyed) return
      if (.n_atom <1) return
      library_bf_kind = .basis_function_kind
      if (any(.atom.atomic_number>54) AND library_bf_kind=="slater") then
         ! This is a hack for Crystal Explorer
         WARN("high Z atoms are present, changing to Coppens style bases")
         .set_basis_set_kind("Coppens")
      end
      ! Renormalise basis sets in case we are going to add bases from the library
      ! (The library basis sets are in normalised form)
      if (.slaterbasis.created)  .slaterbasis.renormalise
      if (.coppensbasis.created) .coppensbasis.renormalise
      if (.basis.created)        .basis.renormalise
      ! Now, add all *library* bases; this may scramble atom.basis ptr's.
      ! NOTE: a blank library_bf_kind indicates a non-library basis set
      select case (library_bf_kind)
         case ("slater")
            library_basis_labels => .atom.library_basis_labels(.basis_set_kind)
            .slaterbasis.read_library_data(.basis_set_library,library_basis_labels,n_unique)
            stdout.text("Added "//n_unique.to_str.trim//" bases from library: "//.basis_set_kind.trim)
            library_basis_labels.destroy
         case ("coppens")
            library_basis_labels => .atom.library_basis_labels(.basis_set_kind)
            .coppensbasis.read_library_data(.basis_set_library,library_basis_labels,n_unique)
            stdout.text("Added "//n_unique.to_str.trim//" bases from library: "//.basis_set_kind.trim)
            library_basis_labels.destroy
         case ("gaussian")
            library_basis_labels => .atom.library_basis_labels(.basis_set_kind)
            .basis.read_library_data(.basis_set_library,library_basis_labels,n_unique)
            stdout.text("Added "//n_unique.to_str.trim//" bases from library: "//.basis_set_kind.trim)
            library_basis_labels.destroy
      end
      ! Now try to resolve atom bases afresh, and fix up atom.basis pointers.
      ! If library .basis_set_kind is non-blank then library bases are used to
      ! resolve the atom bases. If it is blank, then we use the .atom.basis_label.
      if (.slaterbasis.created) then
         .atom.resolve_bases(.slaterbasis,.basis_set_kind)
         if (.atom.slaterbases_are_resolved) then; stdout.text("Slater bases all resolved")
         else;                                     WARN("not all Slater bases were resolved")
         end
         .atom.basis_kind = "slater"
      end
      if (.coppensbasis.created) then
         .atom.resolve_bases(.coppensbasis,.basis_set_kind)
         if (.atom.coppensbases_are_resolved) then; stdout.text("Coppens bases all resolved")
         else;                                      WARN("not all Coppens bases were resolved")
         end
         .atom.basis_kind = "coppens"
      end
      if (.basis.created) then
         .atom.resolve_bases(.basis,.basis_set_kind)
         if (.atom.bases_are_resolved) then; stdout.text("Gaussian bases all resolved")
         else;                               WARN("not all Gaussian bases were resolved")
         end
         .atom.basis_kind = "gaussian"
      end
      ! Unnormalise if completely done
      if (.slaterbasis.created) then
         .slaterbasis.unnormalise    ! NOTE this
      end
      if (.coppensbasis.created) then
         .coppensbasis.unnormalise   ! NOTE this
      end
      if (.basis.created) then
         .basis.unnormalise          ! NOTE this
         .set_basis_info             ! This finalisation is just for gaussians, so far ...
      end
   end

   basis_set_library result (res)
   ! Return a string giving the basis set library
      res :: STR
   ENSURE(.basis_set_kind/=" ","no basis_set_kind specified")
      basis :: VEC{BASIS}*
      res = basis.library_directory(.basis_set_kind)
   end

   resolve_axis_system
   ! Change the axis system to crystal coordinates, if required.
      if (.crystal.destroyed) return
      if (.atom.destroyed) return
      .atom.resolve_axis_system(.crystal)
   end

   set_basis_info ::: leaky
   ! Set the molecule basis set information; the atom list must exist.
   ENSURE(.atom.created,"no atom info")
   ENSURE(.atom.bases_are_resolved,"gaussian bases not all resolved")
      if (.basis.destroyed) return
      .basis_info_made = TRUE
      .n_basis = size(.basis)
      .n_bf = .atom.n_bf
      .n_prim = .atom.n_prim
      .n_shell = .atom.n_shell
      .n_shell_pairs = .no_of_shell_pairs
      .make_shell_info
    ! This may cause problems
    ! .molecular_orbitals.destroy
    ! .molecular_orbitals.create(.n_bf)
    ! .orbital_energies.destroy
    ! .orbital_energies.create(.n_bf)
    ! .density_matrix.destroy
    ! .density_matrix.create(.n_bf)
    ! .natural_orbitals.destroy
    ! .natural_orbitals.create(.n_bf)
    ! .occupation_numbers.destroy
    ! .occupation_numbers.create(.n_bf)
    ! .fock_matrix.destroy
    ! .fock_matrix.create(.n_bf)
   end

   set_basis_set_kind(kind) ::: leaky
   ! Set the *library* basis set kind
      kind :: STR
      last,bf_kind,bf_last :: STR
      last = .basis_set_kind
      if (last=="Coppens" AND kind=="Clementi-Roetti") then
         WARN("basis_set_kind was already Coppens, cannot change to Clementi-Roetti")
      else 
         .basis_set_kind = kind
       ! bf_kind = .basis_function_kind(kind)
       ! bf_last = .basis_function_kind(last)
       ! if (bf_kind/=bf_last) then                ! Basis function kind has changed
            if (.atom.created) .atom.nullify_bases ! Destroy previous bases
            .basis.destroy
            .slaterbasis.destroy
            .coppensbasis.destroy
       ! end
         .resolve_basis_info                       ! <-- this bit might be leaky
      end
   end

   basis_function_kind(basis_set_kind) result (res)
   ! Return the kind of basis function used given the "basis_set_kind"..
      basis_set_kind :: STR, optional
      res :: STR
      bs_kind :: STR
      bs_kind = .basis_set_kind
      if (present(basis_set_kind)) bs_kind = basis_set_kind
      bs_kind.to_lower_case
      select case (bs_kind)
         case (" ");                         res = " "
         case ("thakkar","clementi-roetti"); res = "slater"
         case ("coppens");                   res = "coppens"
         case default;                       res = "gaussian"
      end
   end

   assign_NOs_to_MOs ::: leaky
   ! Assign the natural orbitals to be the molecular_orbitals
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")
      NO_kind :: STR
      .natural_orbitals.destroy
      .natural_orbitals.create_copy(.molecular_orbitals)
      NO_kind = .natural_orbitals.spinorbital_kind
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,NO_kind)
      .occupation_numbers.set_to_zero
      .set_scf_occupations(NO_kind)
   end

   assign_MOs_to_NOs ::: leaky
   ! Assign the MOs to be the same as the natural orbitals
      NO_kind :: STR
      .molecular_orbitals.destroy
      .molecular_orbitals.create_copy(.natural_orbitals)
      NO_kind = .natural_orbitals.spinorbital_kind
      .occupation_numbers.destroy
      .occupation_numbers.create(NO_kind)
      .occupation_numbers.set_to_zero
      .set_scf_occupations(NO_kind)
   end

   set_scf_occupations(NO_kind)
   ! Set the SCF occupation numbers for the natural orbitals
      NO_kind :: STR
      select case (NO_kind)
         case ("restricted")
            .occupation_numbers.restricted(1:.n_a) = TWO
         case ("unrestricted")
            .occupation_numbers.alpha(1:.n_a) = ONE
            .occupation_numbers.beta(1:.n_b) = ONE
         case ("general")
            .occupation_numbers.general(1:.n_e) = ONE
         case ("restricted_complex")
            .occupation_numbers.restricted(1:.n_a) = TWO
         case ("unrestricted_complex")
            .occupation_numbers.alpha(1:.n_a) = ONE
            .occupation_numbers.beta(1:.n_b) = ONE
         case ("general_complex")
            .occupation_numbers.general(1:.n_e) = ONE
      end
   end

!  ***************************
!  VEC{ATOM} information methods
!  ***************************

   default_multiplicity result(res)
   ! Return the default multiplicity for a molecule.
     self :: IN
     res :: REAL
   ENSURE(.atom.created,"no atom info")
     n_e :: INT
     n_e = .no_of_electrons
     if (size(.atom)==1) then
        res = .atom(1).ground_state_multiplicity(n_e)
     else
        res = mod(n_e,2) + 1
     end
   end

   nuclear_energy result(res)
   ! Return the nuclear repulsion energy
      res :: REAL
   ENSURE(.atom.created,"atom list required")
      i :: INT
      scf_kind :: STR
      scf_kind = "unknown"
      if (.scfdata.created) scf_kind = .scfdata.scf_kind
      select case (scf_kind)
         case ("embedded_rhf"); res = .atom.nuclear_energy([(i,i=1,.saved.n_atom)])
!         case ("embedded_rhf"); res = .saved.atom.nuclear_energy  !  why not this?
         case ("crystal_rhf "); res = .atom.nuclear_energy([(i,i=1,.saved.n_atom)])
         case default;          res = .atom.nuclear_energy
      end
   end

   chemical_formula result(res)
   ! Return the chemical formula for the molecule, as a string, in alphabetical
   ! order of elements
      res :: STR
   ENSURE(.atom.created,"atom list required")
      res = .atom.chemical_formula
   end

   centre_of_mass result(centre)
   ! Return the centre of mass
      centre :: VEC{REAL}(3)
   ENSURE(.atom.created,"atom list required")
      centre = .atom.centre_of_mass
   end

   move_origin_to_centre_of_mass
   ! Move the origin to the centre of mass
   ENSURE(.atom.created,"atom list required")
      .atom.move_origin_to_centre_of_mass
   end

   change_to_principal_axes
   ! Move the origin to the centre of mass and change to the principal axis
   ! coordinate system
   ENSURE(.atom.created,"atom list required")
      .atom.change_to_principal_axes
   end

   change_to_principal_top_axes
   ! Move the origin to the centre of mass and change to the principal axis
   ! coordinate system, where the symmetric top axis is the z axis and where the
   ! determinant of the axes transformation is 1.
   ENSURE(.atom.created,"atom list required")
      .atom.change_to_principal_top_axes
   end

   molecular_weight result(res)
   ! Return the molceular weight
      res :: REAL
   ENSURE(.atom.created,"atom list required")
      res = .atom.molecular_weight
   end

   reduced_mass result(res)
   ! Return the reduced mass
      res :: REAL
   ENSURE(.atom.created,"atom list required")
      res = .atom.reduced_mass
   end

   centre_of_atoms result(centre)
   ! Return the centroid of the atom positions
      centre :: VEC{REAL}(3)
   ENSURE(.atom.created,"atom list required")
      centre = .atom.centre_of_atoms
   end

   move_origin_to_centre_of_atoms
   ! Move the origin to the centre of atoms
   ENSURE(.atom.created,"atom list required")
      .atom.move_origin_to_centre_of_atoms
   end

   atom_index_from_pos(pos) result(res)
   ! Return the index of atom from its position "pos"
      pos :: VEC{REAL}(3)
      res :: INT
   ENSURE(.atom.created,"atom list required")
      res = .atom.atom_index_from_pos(pos)
   end

   get_geometry(g)
   ! Return the geometry "g" in a matrix
       g :: MAT{REAL}
   ENSURE(.atom.created,"no atom list")
      .atom.get_geometry(g)
   end

   get_crystal_geometry(g)
   ! Return the crystal (fractional coordinate) geometry "g" in a matrix
       g :: MAT{REAL}
       n :: INT
      .get_geometry(g)
      if (size(g,1)==3) then
         do n = 1,.n_atom
            .crystal.unit_cell.inverse_matrix.rotate(g(:,n))
         end
      else if (size(g,2)==3) then
         do n = 1,.n_atom
            .crystal.unit_cell.inverse_matrix.rotate(g(n,:))
         end
      end
   end

!  ********************************
!  VEC{ATOM} shell extraction methods
!  ********************************

   get_shell(shell,index) ::: leaky
   ! Get basis set "shell" corresponding to "index"
      index :: INT, IN
      shell :: SHELL, OUT
      aa,sa :: INT
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(.atom(aa).basis.shell(sa) )
   end

   get_shell(shell,index) ::: leaky
   ! Update the shell1 "shell".
      index :: INT, IN
      shell :: SHELL1, OUT
      aa,sa :: INT
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(shell=.atom(aa).basis.shell(sa),pos=.atom(aa).pos)
   end

   get_shell(shell,index,fa,la) ::: leaky
   ! Update the shell1 "shell".
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la :: INT, OUT
      aa,sa :: INT
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      shell.copy(shell=.atom(aa).basis.shell(sa),pos=.atom(aa).pos)
   end

!  *****************
!  Atom pair indices
!  *****************

!   get_atom_pair_indices(index,a,b)
!   ! Return the atom indicies "a" and "b" which map to an atom-pair "index"
!     index :: INT, IN
!     a,b :: INT, OUT
!     a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
!     b  = index - a*(a-1)/2
!   end

   get_atom_pair_indices(index,a,b,fa,la,na,fb,lb,nb) 
   ! Return the atom indicies "a" and "b" which map to an atom-pair "index".
   ! Also get "fa", "la" and "fb", "lb", the indices of first and last basis
   ! functions for atoms "a" and "b", and "na" and "nb", the number of basis
   ! functions on those atoms, respectively. NOTE: "fa" and "fb" are actually
   ! the first basis functions for atoms "a" and "b" *minus 1*.  
     index :: INT, IN
     a,b,fa,la,na,fb,lb,nb :: INT, OUT
     a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
     b  = index - a*(a-1)/2
     fa = .first_basis_fn_for_atom(a) - 1
     la =  .last_basis_fn_for_atom(a)
     na = la - fa
     fb = .first_basis_fn_for_atom(b) - 1
     lb =  .last_basis_fn_for_atom(b)
     nb = lb - fb
   end

   get_atom_pair_indices(index,a,b,old_a,old_b,fa,la,na,fb,lb,nb) 
   ! Return the atom indicies "a" and "b" which map to an atom-pair "index".
   ! Also get "fa", "la" and "fb", "lb", the indices of first and last basis
   ! functions for atoms "a" and "b", and "na" and "nb", the number of basis
   ! functions on those atoms, respectively. NOTE: "fa" and "fb" are actually
   ! the first basis functions for atoms "a" and "b" *minus 1*.  NOTE: the input
   ! values of "a" and "b" are compared to "old_a" and "old_b", respectively,
   ! to check if we really need to reset the indices. These should be set to the
   ! previous values of "a" and "b", or zero if there are no previous values.
     index,old_a,old_b :: INT, IN
     a,b,fa,la,na,fb,lb,nb :: INT, OUT
     a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
     b  = index - a*(a-1)/2
     ! Get the indices if we need to.
     if (a/=old_a) then
        fa = .first_basis_fn_for_atom(a) - 1
        la =  .last_basis_fn_for_atom(a)
        na = la - fa
     end
     if (b/=old_b) then
        fb = .first_basis_fn_for_atom(b) - 1
        lb =  .last_basis_fn_for_atom(b)
        nb = lb - fb
     end
   end

   set_atom_pair_grid_info(a,b,n_pt) ::: leaky
   ! For atoms "a" and "b", precalculate the DFT integration grid data and
   ! return the number of points "n_pt" for the atom-pair grid information.  
     a,b :: INT, IN
     n_pt :: INT, OUT
     atom1 :: VEC{ATOM}(1), target
     atom2 :: VEC{ATOM}(2), target
     atoms :: VEC{ATOM}*
     if (a==b) then; atom1 = .atom([a]);   atoms => atom1
     else;           atom2 = .atom([a,b]); atoms => atom2
     end
     .becke_grid.set_atoms_and_positions(atoms.atomic_number,atoms.transposed_coordinates) ! leaky
     n_pt = .becke_grid.no_of_points
   end

!   set_atom_pair_grid_info(a,b,n_pt,a_pt,b_pt) ::: leaky
!   ! For atoms "a" and "b", precalculate the DFT integration grid data and
!   ! return the number of points "n_pt" for the atom-pair grid information.  
!     a,b :: INT, IN
!     n_pt,a_pt,b_pt :: INT, OUT
!     atom1 :: VEC{ATOM}(1), target
!     atom2 :: VEC{ATOM}(2), target
!     atoms :: VEC{ATOM}*
!     if (a==b) then; atom1 = .atom([a]);   atoms => atom1
!     else;           atom2 = .atom([a,b]); atoms => atom2
!     end
!     .becke_grid.set_atoms_and_positions(atoms.atomic_number,atoms.transposed_coordinates) ! leaky
!     n_pt = .becke_grid.no_of_points
!     a_pt = .becke_grid.no_of_points_for_atom(1)
!     b_pt = a_pt + 1
!   end

!   get_atom_pair_grids(a,b,last_a,last_b,na,nb,pt,ga,gb) ::: leaky
!   ! For atoms "a" and "b", return the corresponding atom basis function grids
!   ! "ga" and "gb" which are comprised of "na" and "nb" basis functions
!   ! evaluated on the grid points "pt". NOTE: the input values of "a" and "b"
!   ! are compared to "last_a" and "last_b", respectively, to check if we really
!   ! need to make the grids (if the atom indices are unchanged, no grids will be
!   ! made). "last_a" and "last_b" should be set to the previous values of "a"
!   ! and "b", or zero if there are no previous values.
!     a,b,last_a,last_b,na,nb :: INT, IN
!     pt :: MAT{REAL}, IN
!     ga,gb :: MAT{REAL}*
!   ENSURE(pt.dim2==3,"wrong size, pt")
!     n_pt :: INT
!     n_pt = pt.dim1
!   ! if (a/=last_a) then
!        ga.destroy; ga.create(n_pt,na) ! leaky here
!        .atom(a).make_bf_grid(ga,pt) 
!   ! end
!   ! if (b/=last_b) then
!        gb.destroy; gb.create(n_pt,nb) ! leaky here
!        .atom(b).make_bf_grid(gb,pt) 
!   ! end
!   end

   is_overlapping_atom(a,b) result (res)
   ! Return TRUE if atoms "a" and "b" overlap.
      a,b :: INT, IN
      res :: BIN
   ENSURE(.overlapping_atoms.created,"no .overlapping_atoms")
      aa,bb,ab :: INT
      if (a==b) then
         res = TRUE
      else
         aa = max(a,b)
         bb = min(a,b)
         ab = HALF*aa*(aa-1) + bb
         res = .overlapping_atoms(ab)
      end
   end

   is_overlapping_atom(a,list) result (res)
   ! Return TRUE if atom "a" overlaps with *any* atoms in the "list".
      a :: INT, IN
      list :: VEC{INT}, IN
      res :: BIN
   ENSURE(.overlapping_atoms.created,"no .overlapping_atoms")
      i,b,aa,bb,ab :: INT
      res = FALSE
      do i = 1,list.dim
         b = list(i)
         if (a==b) then
            res = TRUE
            exit
         else
            aa = max(a,b)
            bb = min(a,b)
            ab = HALF*aa*(aa-1) + bb
            if (.overlapping_atoms(ab)) then
               res = TRUE
               exit
            end
         end
      end
   end

   overlapping_atoms_for(list) result (res) ::: leaky
   ! Return the list of atoms which overlaps with those in "list".
      list :: VEC{INT}, IN
      res :: VEC{INT}*
      a,k :: INT
      res.create(.n_atom)
      k = 0
      do a = 1,.n_atom
         if (NOT .is_overlapping_atom(a,list)) cycle
         k = k + 1
         res(k) = a
      end
      res.shrink(k)
   end

   make_overlapping_atoms2 ::: leaky
   ! Make the list of overlapping atoms
   ENSURE(.basis_info_made,"no basis set")
   ENSURE(.scfdata.created,"no scfdata")
      S_max :: VEC{REAL}*
      n_atom_pairs :: INT
      n_atom_pairs = .no_of_atom_pairs
      .overlapping_atoms.destroy
      .overlapping_atoms.create(n_atom_pairs)
      S_max.create(n_atom_pairs)
      .make_S_max_for_atom_pairs(S_max)
      .overlapping_atoms = S_max>.scfdata.atom_overlap_cutoff
      S_max.destroy
   end

   make_S_max_for_atom_pairs(S_max)
   ! Make "S_max", the maximum of the overlap integrals between *pairs of atoms*
     S_max :: VEC{REAL}
   ENSURE(S_max.dim==.no_of_atom_pairs,"wrong size, S_max")
     ab,a,b,fa,fb,la,lb :: INT
     S :: MAT{REAL}*
     S.create(.n_bf,.n_bf)
     .get_overlap_matrix(S)
     do ab = 1, .no_of_atom_pairs
       a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
       b = ab - a*(a-1)/2
       fa = .first_basis_fn_for_atom(a)
       la = .last_basis_fn_for_atom(a)
       fb = .first_basis_fn_for_atom(b)
       lb = .last_basis_fn_for_atom(b)
       S_max(ab) = maxval(S(fa:la,fb:lb))
     end
     S.destroy
   end

! Below does not work ... but it does with lower cutoff

   make_overlapping_atoms ::: leaky
   ! Make the list of overlapping atoms
   ENSURE(.basis_info_made,"no basis set")
   ENSURE(.becke_grid.created,"no becke_grid")
      r_max :: VEC{REAL}*
      d :: VEC{REAL}(3)
      r :: REAL
      a,b,ab,n_atom_pairs :: INT
      n_atom_pairs = .no_of_atom_pairs
      .overlapping_atoms.destroy
      .overlapping_atoms.create(n_atom_pairs)
      r_max.create(.n_atom)
      do a = 1,.n_atom
         ! sqrt because we are dealing with overlaps
         r_max(a) = .atom(a).r_max(sqrt(.becke_grid.rho_cutoff))
       ! stdout.show("r_max "//a.to_str.trim//"=",r_max(a))
      end 
      do ab = 1,n_atom_pairs
         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2
         d = .atom(a).pos - .atom(b).pos
         r = sqrt(dot_product(d,d))
         if (r>(r_max(a)+r_max(b))) then; .overlapping_atoms(ab) = FALSE
         else;                            .overlapping_atoms(ab) = TRUE
         end
      end
      r_max.destroy
   end

!  ******************
!  Shell pair indices
!  ******************

   get_shell_pair_indices(index,a,b)
   ! Return the actual shell indicies "a" and "b" which map to "index"
     index :: INT, IN
     a,b :: INT, OUT
     a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
     b  = index - a*(a-1)/2
   end

   get_shell_pair_indices(index,a,b,fa,la,fb,lb)
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      a,b,fa,la,fb,lb :: INT, OUT
      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
   end

   get_shell_pair_indices(index,a,b,fa,la,fb,lb,atom_a,atom_b)
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
   ! Also return the atom indices "atom_a" and "atom_b" for each shell.
      index :: INT, IN
      a,b,fa,la,fb,lb,atom_a,atom_b :: INT, OUT
      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
   end

!  ***********
!  Shell pairs
!  ***********
!
!   get_shell_pair(shell,index,fa,la,fb,lb) ::: leaky
!   ! Get the SHELL2 object "shell" correponding to the pair index "index"
!   ! Also return the basis function start indices "fa", "la", etc ...
!      index :: INT, IN
!      shell :: SHELL2, OUT
!      fa,la,fb,lb :: INT, OUT
!      a,b,aa,sa,bb,sb :: INT
!      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
!      b  = index - a*(a-1)/2
!      fa = .first_basis_fn_for_shell(a)
!      fb = .first_basis_fn_for_shell(b)
!      la = .last_basis_fn_for_shell(a)
!      lb = .last_basis_fn_for_shell(b)
!      aa = .atom_for_shell(a)
!      bb = .atom_for_shell(b)
!      sa = .atom_shell_for_shell(a)
!      sb = .atom_shell_for_shell(b)
!      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
!                 .atom(aa).pos, .atom(bb).pos )
!   end
!
!   get_shell_pair(shell,index,fa,la,fb,lb,atom_a,atom_b) ::: leaky
!   ! Get the SHELL2 object "shell" correponding to the pair index "index"
!   ! Also return the basis function start indices "fa", "la", etc ...
!   ! Plus the atoms the shells are located on, "atom_a" and "atom_b".
!     index :: INT, IN
!     shell :: SHELL2, OUT
!     fa,la,fb,lb,atom_a,atom_b :: INT, OUT
!     a,b,sa,sb :: INT
!     a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
!     b  = index - a*(a-1)/2
!     fa = .first_basis_fn_for_shell(a)
!     fb = .first_basis_fn_for_shell(b)
!     la = .last_basis_fn_for_shell(a)
!     lb = .last_basis_fn_for_shell(b)
!     atom_a = .atom_for_shell(a)
!     atom_b = .atom_for_shell(b)
!     sa = .atom_shell_for_shell(a)
!     sb = .atom_shell_for_shell(b)
!     shell.copy(.atom(atom_a).basis.shell(sa), .atom(atom_b).basis.shell(sb), &
!                .atom(atom_a).pos, .atom(atom_b).pos )
!   end

   get_precomputed_shell_pair(shell,index,fa,la,fb,lb) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      fa,la,fb,lb :: INT, OUT
      a,b,aa,sa,bb,sb :: INT
      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)
      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb),.atom(aa).pos,.atom(bb).pos,aa==bb,FALSE)
      .put_debug(shell,"precomputed shell pair")
   end

   get_precomputed_shell_pair(shell,index,fa,la,fb,lb,atom_a,atom_b) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      fa,la,fb,lb,atom_a,atom_b :: INT, OUT
      a,b,sa,sb :: INT
      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)
      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb),.atom(atom_a).pos,.atom(atom_b).pos,atom_a==atom_b,FALSE)
   end

!  *********************
!  Shell quartet indices
!  *********************

!   get_shell_quartet_indices(index,a,b,c,d)
!   ! Get the indexes a,b,c,d of the quartet from the "index".
!   ! Note that "index" will die at 361 shells for integer(4).
!     index :: INT, IN
!     a,b,c,d :: INT, OUT
!     ab,cd :: INT
!     ab = (1+sqrt(8.0d0*index-7.0d0))/2
!     cd = index - ab*(ab-1)/2
!     a  = (1+sqrt(8.0d0*ab-7.0d0))/2
!     b  = ab - a*(a-1)/2
!     c  = (1+sqrt(8.0d0*cd-7.0d0))/2
!     d  = cd - c*(c-1)/2
!   end
!
   get_shell_quartet_indices(index,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky
   ! For the quartet index "index" return the shell indicies "a", "b",
   ! "c" and "d" which map to "index". Also return the basis function
   ! start indices "fa", "la", etc ...
      index :: INT, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, OUT
      a,b,c,d :: INT
      ab,cd :: INT
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   get_shell_quartet_indexes(index,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
   ! For the quartet index "index" return the shell indicies "a", "b", "c" and
   ! "d" which map to "index" and the corresponding atom centers. Note different
   ! spelling for this routine and the one above to avoid overload problems.
      index :: INT, IN
      a,b,c,d,atom_a,atom_b,atom_c,atom_d :: INT, OUT
      ab,cd :: INT
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)
   end

!  **************
!  Shell quartets
!  **************

   copy_shell_quartet(shell,a,b,c,d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the indicies "a", "b", "c"
   ! and "d".
      shell :: SHELL4, OUT
      a,b,c,d :: INT, IN
      aa,sa,bb,sb,cc,sc,dd,sd :: INT
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).pos, .atom(bb).pos, .atom(cc).pos, .atom(dd).pos )
   end

   copy_shell_quartet(shell,index,a,b,c,d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d :: INT, OUT
      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                  .atom(aa).pos, .atom(bb).pos, .atom(cc).pos, .atom(dd).pos )
   end

   copy_shell_quartet(shell,index,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld :: INT, OUT
      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                  .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                  .atom(aa).pos, .atom(bb).pos, .atom(cc).pos, .atom(dd).pos )
      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)
   end

   copy_shell_quartet(shell,index,a,b,c,d,atom_a,atom_b,atom_c,atom_d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Plus the atoms which the shells are on.
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d,atom_a,atom_b,atom_c,atom_d :: INT, OUT
      ab,cd,sa,sb,sc,sd :: INT
      ab = (1+sqrt(8.0d0*index-7.0d0))/2
      cd = index - ab*(ab-1)/2
      a  = (1+sqrt(8.0d0*ab-7.0d0))/2
      b  = ab - a*(a-1)/2
      c  = (1+sqrt(8.0d0*cd-7.0d0))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      atom_b = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      atom_c = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      atom_d = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(atom_a).basis.shell(sa), .atom(atom_b).basis.shell(sb), &
                 .atom(atom_c).basis.shell(sc), .atom(atom_d).basis.shell(sd), &
                 .atom(atom_a).pos, .atom(atom_b).pos, &
                 .atom(atom_c).pos, .atom(atom_d).pos )
   end

   copy_shell_quartet_ab(shell,a,b) ::: leaky
   ! Set the a and b parts of the "shell" SHELL4 object.
     shell :: SHELL4, INOUT
     a,b :: INT, IN
     aa,sa,bb,sb :: INT
     aa = .atom_for_shell(a)
     sa = .atom_shell_for_shell(a)
     bb = .atom_for_shell(b)
     sb = .atom_shell_for_shell(b)
     shell.copy_ab(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(aa).pos, .atom(bb).pos)
   end

   copy_shell_quartet_cd(shell,c,d) ::: leaky
   ! Set the c and d parts of the "shell" SHELL4 object.
     shell :: SHELL4, INOUT
     c,d :: INT, IN
     cc,sc,dd,sd :: INT
     cc = .atom_for_shell(c)
     sc = .atom_shell_for_shell(c)
     dd = .atom_for_shell(d)
     sd = .atom_shell_for_shell(d)
     shell.copy_cd(.atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(cc).pos, .atom(dd).pos)
   end


   set_new_shell_quartet_ab(shell,a,b,skip) ::: leaky
   ! Set the "a" and "b" parts of the "shell" SHELL4 object. If "skip" is TRUE
   ! then some primitive pairs are ignored, if too small (this should not be set
   ! if any atoms in the qurtet are the same; if in doubt set skip=FALSE).
     shell :: SHELL1QUARTET, INOUT
     a,b :: INT, IN
     skip :: BIN
     aa,sa,bb,sb :: INT
     aa = .atom_for_shell(a)         !which atom.
     bb = .atom_for_shell(b)
     sa = .basis_shell_for_shell(a)  !which shell.
     sb = .basis_shell_for_shell(b)
     shell.set_ab_new(.precomputed_basis_shellpair(sa,sb),.atom(aa).pos,.atom(bb).pos,aa==bb,skip)
   end

   set_new_shell_quartet_cd(shell,c,d,skip) ::: leaky
   ! Set the "c" and "d" parts of the "shell" SHELL4 object. If "skip" is TRUE
   ! then some primitive pairs are ignored, if too small (this should not be set
   ! if any atoms in the qurtet are the same; if in doubt set skip=FALSE).
     shell :: SHELL1QUARTET, INOUT
     c,d :: INT, IN
     skip :: BIN
     cc,sc,dd,sd :: INT
     cc = .atom_for_shell(c)         !which atom.
     dd = .atom_for_shell(d)
     sc = .basis_shell_for_shell(c)  !which shell.
     sd = .basis_shell_for_shell(d)
     shell.set_cd_new(.precomputed_basis_shellpair(sc,sd),.atom(cc).pos,.atom(dd).pos,cc==dd,skip)
   end

!   set_precomp_shell_quartet_ab(shell,a,b) ::: leaky
!   ! Set the a and b parts of the "shell" SHELL4 object.
!     shell :: SHELL1QUARTET, INOUT
!     a,b :: INT, IN
!     aa,sa,bb,sb :: INT
!     aa = .atom_for_shell(a)         !which atom.
!     bb = .atom_for_shell(b)
!     sa = .basis_shell_for_shell(a)  !which shell.
!     sb = .basis_shell_for_shell(b)
!     shell.set_ab_from(.precomputed_basis_shellpair(sa,sb),.atom(aa).pos,.atom(bb).pos,aa==bb)
!   end

!   set_precomp_shell_quartet_cd(shell,c,d) ::: leaky
!   ! Set the c and d parts of the "shell" SHELL4 object.
!     shell :: SHELL1QUARTET, INOUT
!     c,d :: INT, IN
!     cc,sc,dd,sd :: INT
!     cc = .atom_for_shell(c)         !which atom.
!     dd = .atom_for_shell(d)
!     sc = .basis_shell_for_shell(c)  !which shell.
!     sd = .basis_shell_for_shell(d)
!     shell.set_cd_from(.precomputed_basis_shellpair(sc,sd),.atom(cc).pos,.atom(dd).pos,cc==dd)
!   end

!  ************************
!  Contraction Coefficients
!  ************************

   make_contraction_matrix(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      cc_mat :: MAT{REAL}, OUT
   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")
      a, bf_count, prim_count,a_prim,a_bf :: INT
      bf_count = 1
      prim_count = 1
      cc_mat = ZERO
      do a = 1, .n_atom
         a_prim = .atom(a).basis.n_prim
         a_bf = .atom(a).basis.n_bf
         cc_mat(prim_count : prim_count + a_prim - 1, bf_count : bf_count + a_bf - 1) &
                  = .atom(a).basis.contraction_matrix
         prim_count = prim_count + a_prim
         bf_count = bf_count + a_bf
      end
   end

!  **********************
!  Make shell information
!  **********************

   make_shell_info ::: leaky
   ! Define a vector of atom numbers corresponding to the molecule
   ! basis set shell numbers; also define a vector of atom shell numbers
   ! corresponding to the molecule basis set shell number
   ENSURE(.atom.created,"no atom information")
   ENSURE(.n_atom>0,"no atoms")
   ENSURE(.basis.created,"no basis set")
     .basis_l_max = .basis.maximum_basis_set_l_value
     GAUSSIAN_DATA:set_indices(.basis_l_max) ! do this before anything else
     .atom_for_shell.destroy
     .atom_for_shell       => .atom.atom_for_shell
     .atom_shell_for_shell.destroy
     .atom_shell_for_shell => .atom.atom_shell_for_shell
     .first_shell_for_atom.destroy
     .first_shell_for_atom.create(.n_atom)
     .last_shell_for_atom.destroy
     .last_shell_for_atom.create(.n_atom)
     .atom.make_shell_for_atom_limits(.first_shell_for_atom,.last_shell_for_atom)
     .first_basis_fn_for_shell.destroy
     .last_basis_fn_for_shell.destroy
     .angular_moment_for_shell.destroy
     .atom.make_shell_limits(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)
     .first_basis_fn_for_atom.destroy
     .last_basis_fn_for_atom.destroy
     .atom.make_atom_basis_fn_limits(.first_basis_fn_for_atom,.last_basis_fn_for_atom)
     .make_basis_shell_for_shell
     .make_precomputed_shellpairs
   end

   make_precomputed_shellpairs ::: leaky
   ! Make a SHELLPAIR vector "shellpair" which includes precomputed data for the
   ! basis set.
   ! NOTE for later: n_unique_shells should be a basisvec routine.
   ! NOTE for later: precomputed_basis_shellpair should be a MAT{REAL} type
   ENSURE(.basis.created,"no basis set")
     i,j,k,a,b,p,q :: INT
     .n_unique_shells = .basis.no_of_shells
     .precomputed_basis_shellpair.destroy
     .precomputed_basis_shellpair.create(.n_unique_shells,.n_unique_shells)
     p = 0
     do i = 1,.basis.dim    ! Loop over bases
     do a = 1,.basis(i).n_shell
        p = p + 1
        q = 0
        do j = 1,.basis.dim ! Loop over bases
        do b = 1,.basis(j).n_shell
           q = q + 1
           .precomputed_basis_shellpair(p,q).copy_a(.basis(i).shell(a))
           .precomputed_basis_shellpair(p,q).copy_b(.basis(j).shell(b))
           .precomputed_basis_shellpair(p,q).make_precalculated_data
        end
        end
     end
     end
   end

   first_basis_shell_for_atom(atom) result(res)
   ! Return the index of the first shell in .basis (treating .basis as a
   ! flattened list of shells) which has the same basis label as "atom".
   ! NOTE for later: this should be a basisvec routine.
     atom :: INT, IN
     res :: INT
     i,j :: INT
     i=1
     do j=1,size(.basis) ! Loop over bases
       if (.basis(j).label==.atom(atom).basis.label) then
         res=i
         exit
       else
         i = i + .basis(j).n_shell
       end
     end
   end

   make_basis_shell_for_shell ::: leaky
   ! Return the index of the first shell in .basis (treating .basis as a
   ! flattened list of shells) for a given shell index in the molecular basis set
   ! (i.e. the flattened list of shells in the .atom list).
   ! NOTE for later: this should be a basisvec routine.
   ENSURE(.basis.created,"no basis set")
     sh,at,atom_shell,ind :: INT
     .basis_shell_for_shell.destroy
     .basis_shell_for_shell.create(.n_shell)
     do sh=1,.n_shell
       at = .atom_for_shell(sh)                 ! which atom
       atom_shell = .atom_shell_for_shell(sh)   ! which shell for this atom
       ind = .first_basis_shell_for_atom(at)    ! first shell for this atom in
                                                ! the basis set
       .basis_shell_for_shell(sh) = ind + atom_shell - 1
     end
   end

!  **********************
!  Density matrix methods
!  **********************

   make_scf_density_matrix(damp,n_a,method) ::: leaky
   ! Make the density matrix from the molecular orbitals. If "damp" is present
   ! use it to damp the updated density matrix. If "n_a" is present it is used
   ! as the number of alpha electrons in embedded scf calculations. If
   ! "method" is present it is used as the kind of density matrix to make.
   ! NOTE: the final computed density matrix is written to an archive
   ! NOTE: if any old density matrix exists, it is saved in an old archive.
     damp :: BIN, optional
     n_a :: INT, optional
     method :: STR, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")
     T :: REAL
     damping,embedded,crystal,do_archive,do_delta_archive,use_pFON :: BIN
     D_old,P_old :: OPMATRIX*
     MO,MOS,D,MOa,MOb,Da,Db,F,Fa,Fb :: MAT{REAL}*
     CMO,CD,CMOa,CMOb,CDa,CDb :: MAT{CPX}*
     scf_method,genre :: STR
     archive :: ARCHIVE
     ! Determine (or guess) the kind of SCF method to be used.
     if      (present(method))  then; scf_method = method
     else if (.scfdata.created) then; scf_method = .scfdata.scf_kind
     else;                            scf_method = .molecular_orbitals.guess_scf_kind
     end
     ! Determine (or guess) the genre of density matrix to be made
     if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
     else;                       genre = .molecular_orbitals.spinorbital_kind
     end
     ! Is this an embeded SCF? If so performs some checks.
     embedded = scf_method.includes("embedded_",at_start=TRUE)
     crystal  = scf_method.includes("crystal_",at_start=TRUE)
     if (embedded OR crystal) then
        DIE_IF(NOT present(n_a),"n_a must be given for embedded/crystal SCF calculations")
        DIE_IF(.saved.destroyed,".saved must exist for embedded/crystal SCF calculations")
        DIE_IF(.cluster.destroyed,".cluster must exist for embedded/crystal SCF calculations")
        DIE_IF(.cluster.n_fragment_symop==0,".cluster has no fragment symops")
     end
     ! Determine whether to archive the density matrix: because in embedded or
     ! crystal calculations we don't want to archive the fragment density
     ! matrix. We know it is a fragment when n_a==.saved.n_a.
     if      (NOT embedded AND NOT crystal) then;              do_archive = TRUE
     else if (n_a==.saved.n_a*.cluster.n_fragment_symop) then; do_archive = TRUE
     else;                                                     do_archive = FALSE
     end
     ! Determine whether to archive the delta density matrix
     archive.set(.name,"density_matrix",genre)
     do_delta_archive = do_archive AND archive.exists
     if (.scfdata.created) do_delta_archive = do_delta_archive AND .scfdata.do_delta_build
     ! Determine if density matrix damping is to be used
     damping = do_archive AND archive.exists
     if      (present(damp)) then;    damping = damping AND damp
     else if (.scfdata.created) then; damping = damping AND .scfdata.apply_damping
     end
     ! Determine if pFON should be used
     use_pFON = FALSE
     if (.scfdata.created AND .fock_matrix.created(genre)) use_pFON = .scfdata.apply_pFON
     ! Create the density matrix
     if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
     .density_matrix.destroy(genre)
     .density_matrix.create(genre)
     ! Create/read the previous density matrix from disk ... needed for embedded
     ! or crystal SCF calculations where the current density matrix may not be
     ! the correct one.
     nullify(D_old)
     if (do_delta_archive OR damping) then
        D_old.create(.n_bf)
        archive.read(D_old)
     end
     ! Do it: make the density matrix
     select case (scf_method)
       case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.mult==1,"this is not a singlet state")
         if (use_pFON) then
            D  => .density_matrix.restricted
            MO => .molecular_orbitals.restricted
            F  => .fock_matrix.restricted
            T = .scfdata.temperature_for_pFON
            .make_finite_T_density_matrix(D,MO,F,T,.n_a)
            D = TWO*D
         else
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted
            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
         end
       case ("progroup")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.mult==1,"this is not a singlet state")
         ENSURE(present(n_a),"n_a must be specified")
         MO => .molecular_orbitals.restricted(:,1:n_a)
         D  => .density_matrix.restricted
         D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
       case ("embedded_rhf","embedded_rks","embedded_xray_rks","embedded_xray_rhf","crystal_rhf")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.mult==1,"this is not a singlet state")
         ENSURE(.saved.created,"no saved molecule")
         ENSURE(.cluster.created,"no cluster")
         ENSURE(.cluster.n_fragment_symop>0,"no fragment symops")
         ENSURE(present(n_a),"the number of occupied orbitals is not given")
         MO => .molecular_orbitals.restricted(:,1:n_a)
         D  => .density_matrix.restricted
      ! stdout.text("In make_scf, MO:")
      ! stdout.put(MO)
      ! stdout.text("In make_scf, D:")
      ! stdout.put(D)
         D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
      ! stdout.text("In make_scf, D:")
      ! stdout.put(D)
       case ("rohf")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         MOa => .molecular_orbitals.restricted(:,1:.n_a)
         MOb => .molecular_orbitals.restricted(:,1:.n_b)
         Da => .density_matrix.alpha
         Db => .density_matrix.beta
         Da.to_product_of(MOa,MOa,transpose_b=TRUE)
         Db.to_product_of(MOb,MOb,transpose_b=TRUE)
       case ("uhf","uks","xray_uhf","xray_uks", &
             "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         ENSURE(.molecular_orbitals.created("unrestricted"),"no MO's")
         if (use_pFON) then
            MOa => .molecular_orbitals.alpha
            MOb => .molecular_orbitals.beta
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Fa => .fock_matrix.alpha
            Fb => .fock_matrix.beta
            T = .scfdata.temperature_for_pFON
            .make_finite_T_density_matrix(Da,MOa,Fa,T,.n_a)
            .make_finite_T_density_matrix(Db,MOb,Fb,T,.n_b)
         else
            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)
         end
       case ("ghf")
         ENSURE(.molecular_orbitals.created("general"),"no MO's")
         ENSURE(.mult==1,"this is not a singlet state")
         MO => .molecular_orbitals.general(:,1:.n_e)
         D =>  .density_matrix.general
         D.to_product_of(MO,MO,transpose_b=TRUE)
       case ("rchf")
         ENSURE(.molecular_orbitals.created("restricted_complex"),"no MO's")
         CMO => .molecular_orbitals.restricted_complex(:,1:.n_a)
         CD  => .density_matrix.restricted_complex
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)
         CD = TWO*CD
       case ("uchf")
         ENSURE(.molecular_orbitals.created("unrestricted_complex"),"no MO's")
         CMOa => .molecular_orbitals.alpha_complex(:,1:.n_a)
         CMOb => .molecular_orbitals.beta_complex(:,1:.n_b)
         CDa => .density_matrix.alpha_complex
         CDb => .density_matrix.beta_complex
         CDa.to_product_of(CMOa,CMOa,dagger_b=TRUE)
         CDb.to_product_of(CMOb,CMOb,dagger_b=TRUE)
       case ("gchf")
         ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")
         CMO => .molecular_orbitals.general_complex(:,1:.n_e)
         CD =>  .density_matrix.general_complex
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)
       case default
         DIE("unknown SCF kind, "//trim(scf_method))
     end
     ! Damp the density matrix if required
     if (damping)    .density_matrix.damp(D_old,.scfdata.damp_factor)
     ! Save the density matrix if needed later for DAMPING
     if (do_archive) .archive_density_matrix
     ! Save the delta density matrix if needed later for incremental Fock build
     if (do_delta_archive) then
        D_old.to_scaled(D_old,-ONE)
        D_old.plus(.density_matrix)
        .archive(D_old,"delta_density_matrix")
     end
     D_old.destroy
   end

   make_finite_T_density_matrix(D,MO,F,T,n_e) ::: leaky
   ! Make the finite temperature density matrix "D" from molecular orbitals "MO"
   ! according to the pFON method with temperature "T" and number of electrons
   ! "n_e" *for a given spin*, as in Rabuck and Scuseria, JCP 110, 695 (1999).
   ! There must exist a current fock_matrix "F" made from "D" which is used to
   ! get the eigenvalues for the Fermi-Dirac distribution.
     D,MO :: MAT{REAL}
     F :: MAT{REAL}*
     T :: REAL
     n_e :: INT
   ENSURE(F.created,"no molecular orbitals")
   ENSURE(F.is_square,"F must be square")
   ENSURE(F.is_same_shape_as(MO),"incompatible F and MO")
   ENSURE(n_e<MO.dim2,"fewer MO's than electrons")
   ENSURE(T>=ZERO,"T must be positive")
     W :: MAT{REAL}*
     occ :: VEC{REAL}*
     ind :: VEC{INT}*
     e_i,beta,e_homo,e_lumo,e_fermi,homo_lumo_gap :: REAL
     n_orb,i,j,n_frac :: INT
     n_orb  = F.dim1
     occ.create(n_orb)     ! Make the occupation numbers
     ind.create(n_orb)
     W.create(n_orb,n_orb)
     W.to_product_of(F,MO)
     do i = 1,n_orb        ! These are energies
        occ(i) = dot_product(MO(:,i),W(:,i))
     end
     occ.quick_sort(ind)   ! "ind" has the energies sorted
 ! stdout.text("F:")
 ! stdout.put(F)
 ! stdout.text("MO:")
 ! stdout.put(MO)
 ! stdout.text("ind:")
 ! stdout.put(ind,"column")
 ! stdout.text("unsorted eig:")
 ! stdout.put(occ,"column")
 ! stdout.text("eig:")
 ! stdout.put(occ(ind),"column")
     W.destroy
     beta = KELVIN_PER_HARTREE/T
     e_homo = occ(ind(n_e))
     e_lumo = occ(ind(n_e+1))
     e_fermi = HALF*(e_homo + e_lumo)
     homo_lumo_gap = e_lumo - e_homo
 ! stdout.show("n_e    = ",n_e)
 ! stdout.show("e_homo = ",e_homo)
 ! stdout.show("e_lumo = ",e_lumo)
   stdout.show("e_fermi= ",e_fermi)
   stdout.show("gap    = ",homo_lumo_gap)
   stdout.show("T      = ",T)
 ! print *,"beta   = ",beta
     do j = 1,n_orb        ! These are the occupation numbers
        i = ind(j)
   print *,"eig          = ",occ(i)
   print *,"delta        = ",(occ(i)-e_fermi)
   print *,"beta delta   = ",beta*(occ(i)-e_fermi)
        occ(i) = ONE/(ONE+exp(beta*(occ(i)-e_fermi)))
     end                   ! The number of fractional orbitals
 ! stdout.text("occ:")
 ! stdout.put(occ(ind),"column")
     if      (homo_lumo_gap>0.135d0) then; n_frac = 5
     else if (homo_lumo_gap<0.090d0) then; n_frac = 3
     else;                                 n_frac = 4
     end
     do j = 1,n_orb        ! Reset the fractional occupancies
        i = ind(j)
        if      (j<=n_e-n_frac) then; occ(i) = ONE
        else if (j >n_e+n_frac) then; occ(i) = ZERO
        end
     end
 ! stdout.show("n_frac = ",n_frac)
 ! stdout.text("occ reset:")
 ! stdout.put(occ(ind),"column")
     occ = n_e*occ/sum(occ)
 ! stdout.text("occ renormalised:")
 ! stdout.put(occ(ind),"column")
     D = ZERO
     do j = 1,n_e+n_frac   ! Form the temperature broadended density
        i = ind(j)
        D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ(i),transpose_b=TRUE)
     end
     ind.destroy
     occ.destroy
   end

   make_ao_density_matrix ::: leaky
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix. The result is placed in the "restricted" part of the density
   ! matrix. NOTE: The density matrix is archived.
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
      genre :: STR
      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      select case (genre)
         case ("restricted")
            ! do nothing
         case ("unrestricted")
            .density_matrix.destroy("restricted")
            .density_matrix.create("restricted")
            .density_matrix.restricted = .density_matrix.alpha + .density_matrix.beta
         case ("general")
            .density_matrix.destroy("restricted")
            .density_matrix.create("restricted")
            .density_matrix.restricted = .density_matrix.general.alpha_alpha &
                                       + .density_matrix.general.beta_beta
         case ("restricted_complex")
            ! do nothing
         case ("unrestricted_complex")
            .density_matrix.destroy("restricted_complex")
            .density_matrix.create("restricted_complex")
            .density_matrix.restricted_complex = .density_matrix.alpha_complex &
                                               + .density_matrix.beta_complex
         case ("general_complex")
            .density_matrix.destroy("restricted_complex")
            .density_matrix.create("restricted_complex")
            .density_matrix.restricted_complex = .density_matrix.general_complex.alpha_alpha &
                                               + .density_matrix.general_complex.beta_beta
         case default;    DIE("unknown kind, "//trim(genre))
      end
      .archive_density_matrix
   end

   make_ao_sz_density_matrix ::: leaky
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix. The result is placed in the "restricted" part of the density matrix
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
      genre :: STR
      genre = .density_matrix.spinorbital_kind
      if (genre=="restricted") return
      if (genre.includes("complex")) then
         .density_matrix.destroy("restricted_complex")
         .density_matrix.create("restricted_complex")
      else
         .density_matrix.destroy("restricted")
         .density_matrix.create("restricted")
      end
      select case (genre)
         case ("unrestricted")
            .density_matrix.restricted = .density_matrix.alpha - .density_matrix.beta
         case ("general")
            .density_matrix.restricted = .density_matrix.general.alpha_alpha &
                                       - .density_matrix.general.beta_beta
         case ("unrestricted_complex")
            .density_matrix.restricted_complex = .density_matrix.alpha_complex &
                                               - .density_matrix.beta_complex
         case ("general_complex")
            .density_matrix.restricted_complex = .density_matrix.general_complex.alpha_alpha &
                                               - .density_matrix.general_complex.beta_beta
         case default;   DIE("unknown kind, "//trim(genre))
      end
   end

   make_scf_density_matrix(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals.
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      n :: INT, IN
      nb :: INT, IN, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
      MO,D,MOa,MOb,Da,Db :: MAT{REAL}*
      CMO,CD,CMOa,CMOb,CDa,CDb :: MAT{CPX}*
      genre :: STR
      arch :: ARCHIVE
      m :: INT
      uhf :: BIN
      uhf = .scfdata.scf_kind.includes("unrestricted")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")
      m = n
      if (present(nb)) m = nb
      genre = .scfdata.spinorbital_kind
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)
      arch.set(.name,"density_matrix",genre)
      select case (.scfdata.scf_kind)
         case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")
            ENSURE(.mult==1,"this is not a singlet state")
            D  => .density_matrix.restricted
            if (n>0 AND n<=.n_a) then
               MO => .molecular_orbitals.restricted(:,n:n)
               D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            else
               D = ZERO
            end
         case ("rohf")
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            if (n>0 AND n<=.n_b) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               MOb => .molecular_orbitals.restricted(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
               Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            else if (n>nb AND n<=.n_a) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
               Db = ZERO
            else
               Da = ZERO
               Db = ZERO
            end
         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
            Da => .density_matrix.alpha
            Db => .density_matrix.beta
            if (n>0 AND n<=.n_a) then
               MOa => .molecular_orbitals.alpha(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            else
               Da = ZERO
            end
            if (m>0 AND m<=.n_b) then
               MOb => .molecular_orbitals.beta(:,m:m)
               Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            else
               Db = ZERO
            end
         case ("ghf")
            ENSURE(.mult==1,"this is not a singlet state")
            D =>  .density_matrix.general
            if (n>0 AND n<=.n_e) then
               MO => .molecular_orbitals.general(:,n:n)
               D.to_product_of(MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end
         case ("rchf")
            CD  => .density_matrix.restricted_complex
            if (n>0 AND n<=.n_a) then
               CMO => .molecular_orbitals.restricted_complex(:,n:n)
               CD.to_scaled_product_of(CMO,CMO,fac=TWO,dagger_b=TRUE)
            else
               CD = ZERO
            end
         case ("uchf")
            CDa => .density_matrix.alpha_complex
            CDb => .density_matrix.beta_complex
            if (n>0 AND n<=.n_a) then
               CMOa => .molecular_orbitals.alpha_complex(:,n:n)
               CDa.to_product_of(CMOa,CMOa,dagger_b=TRUE)
            else
               CDa = ZERO
            end
            if (m>0 AND m<=.n_b) then
               CMOb => .molecular_orbitals.beta_complex(:,m:m)
               CDb.to_product_of(CMOb,CMOb,dagger_b=TRUE)
            else
               CDb = ZERO
            end
         case ("gchf")
            CD =>  .density_matrix.general_complex
            if (n>0 AND n<=.n_e) then
               CMO => .molecular_orbitals.general_complex(:,n:n)
               CD.to_product_of(CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end
         case default;
            DIE("unknown kind, "//trim(.scfdata.scf_kind))
      end
      arch.write(.density_matrix)
   end

   make_progroup_density_matrix
   ! Make the density matrix which is a sum of density matrices for
   ! each group specified in the molecule in the atom_group array.
   ! This will destroy any existing restricted density matrix archive.
      archive :: ARCHIVE
      P :: OPMATRIX*
      .make_progroup_density
      P.create(.n_bf)
      archive.set(.name,"group_density_matrix", genre="restricted")
      archive.read(P, genre="restricted")
      archive.set(.name,"density_matrix", genre="restricted")
      archive.write(P, genre="restricted")
      P.destroy
   end

   make_group_density_matrix ::: leaky
   ! Make the promolecule density matrix from *symmetrically orthonormalised*
   ! group (monomer) molecular orbitals. Do not confuse this with the progroup
   ! density matrix, made with .make_progroup_density_matrix. The symmetrically
   ! orthonormalised molecular orbitals are made and are ordered by group.  This
   ! will destroy any existing restricted density matrix and MOs.
   ENSURE(.molecular_orbitals.created,"no MO's")
      .make_progroup_density(MOs=TRUE)
      .symorthonormalise_occupied_MOs
      .natural_orbitals => .molecular_orbitals
      .make_density_matrix
      nullify(.natural_orbitals)
   end

   symorthonormalise_occupied_MOs
   ! Symmetrically orthonormalise the occupied MO's. The occupied orbitals
   ! are defined by the .occupation_numbers vector. The virtual orbitals are
   ! schmidt orthonormalised to the occupied MOs. Only works for restricted
   ! at the moment.
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no rhf MO's")
      occ,vir,all :: VEC{INT}*
      S,MO :: MAT{REAL}*
      i,no,nv :: INT
      no = count(.occupation_numbers.restricted >0.1); occ.create(no)
      nv = count(.occupation_numbers.restricted<=0.1); vir.create(nv)
      ENSURE((no+nv)==.n_bf,"error determining no and nv")
      stdout.flush
      stdout.show("No. of occupied MO's =",no)
      stdout.show("No. of virtual  MO's =",nv)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      occ = pack([(i,i=1,.n_bf)],.occupation_numbers.restricted> 0.1)
      vir = pack([(i,i=1,.n_bf)],.occupation_numbers.restricted<=0.1)
      ! Symmetric orthonormalise the occupied
      MO.create(.n_bf,no)
      MO = .molecular_orbitals.restricted(:,occ)
   !  stdout.flush
   !  stdout.text("Occupied molecular orbitals before symmetrisation:")
   !  stdout.put(MO)
      MO.symmetrically_orthonormalise(S)
   !  stdout.flush
   !  stdout.text("Occupied molecular orbitals after symmetrisation:")
   !  stdout.put(MO)
      .molecular_orbitals.restricted(:,occ) = MO
      MO.destroy
      ! Schmidt orthonormalise the virtuals
      all => occ.join(vir)
      MO.create(.n_bf,.n_bf)
      MO = .molecular_orbitals.restricted(:,all)
      MO.schmidt_orthonormalise(S)
      .molecular_orbitals.restricted(:,all) = MO
   !  stdout.flush
   !  stdout.text("Occupied & virtual molecular orbitals after Schmidt:")
   !  stdout.put(MO)
      all.destroy
      ! Clean up
      MO.destroy
      S.destroy
      vir.destroy
      occ.destroy
   end

   make_density_matrix ::: leaky
   ! Make the .density_matrix from the .natural_orbitals and the
   ! .occupation_numbers vector. Only restricted so far.
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
     NO,D :: MAT{REAL}*
     occ :: VEC{REAL}*
     genre :: STR
     arch :: ARCHIVE
     genre = .natural_orbitals.spinorbital_kind
     .density_matrix.destroy(genre)
     .density_matrix.create(genre)
     arch.set(.name,"density_matrix",genre)
     select case (genre)
       case ("restricted")
         ENSURE(.natural_orbitals.created("restricted"),"no NO's")
         occ.create(.n_bf)
         occ = sqrt(.occupation_numbers.restricted)
         NO.create(.n_bf,.n_bf)
         NO.to_product_with_diagonal(.natural_orbitals.restricted,occ)
         D  => .density_matrix.restricted
         D.to_product_of(NO,NO,transpose_b=TRUE)
         NO.destroy
         occ.destroy
       case default
         DIE("unknown SCF kind, "//trim(genre))
     end
     arch.write(.density_matrix)
   end

!  ***************
!  Inquiry methods
!  ***************

   no_of_electrons result(res)
   ! Work out and return the number of electrons in the molecule.
      res :: INT
   ENSURE(.atom.created,  "no atom list")
      res = .atom.n_e - .charge
   end

   no_of_alpha_electrons result(res)
   ! Work out and return the number of alpha electrons in the molecule.
      res :: INT
      res = .no_of_electrons - .no_of_beta_electrons
   end

   no_of_beta_electrons result(res)
   ! Work out and return the number of beta electrons in the molecule
      res :: INT
      tmp :: INT
      tmp = .no_of_electrons - .no_of_unpaired_electrons
      res = tmp/2
      ENSURE(tmp.is_even,"Inconsistent multiplicity, non integer # of beta electrons")
   end

   has_valid_no_of_beta_electrons result(res)
   ! Return TRUE if the number of beta electrons is valid based on the assigned
   ! charge and multiplicity i.e. it must come out integral.
      res :: BIN
      tmp :: INT
      tmp = .no_of_electrons - .no_of_unpaired_electrons
      res = tmp.is_even
   end

   no_of_unpaired_electrons result(res)
   ! Work out and return the number of unpaired electrons in the molecule
      res :: INT
      res = .mult - 1
      ENSURE(res<=.no_of_electrons,"Wrong multiplicity, not enough electrons")
   end

   no_of_atom_pairs result(res)
   ! Return the number of atom pairs in the molecule
      res :: INT
   ENSURE(.atom.created,"no atom list")
      res = .n_atom*(.n_atom+1)/2
   end

   no_of_shell_pairs result(res)
   ! Return the number of shell pairs in the basis set for the molecule
      res :: INT
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      n_shell :: INT
      n_shell = .atom.n_shell
      res = n_shell*(n_shell+1)/2
   end

   n_shell_quartets result (res)
   ! Return the number of shell quartets in the basis set for the molecule
   ! Note, "res" will die at 22 shells for integer(2).
   !       "res" will die at 361 shells for integer(4).
   !       "res" will die at 92681 shells for integer(8).
      res :: INT
      n_shell_pair :: INT
      n_shell_pair = .no_of_shell_pairs
      if (n_shell_pair/sqrt(TWO) <= (huge(n_shell_pair))**HALF) then
         res = n_shell_pair*(n_shell_pair+1)/2
      else
         WARN("too many shells")
         res = 0
      end
   end

   no_of_occupied_NOs(genre,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      genre :: STR, optional
      tol :: REAL, optional
      res :: INT
   ENSURE(.occupation_numbers.created,"no occupation numbers")
      res = .occupation_numbers.no_of_occupied(genre,tol)
   end

!  ****************
!  Natural orbitals
!  ****************

   make_natural_orbitals(genre) ::: leaky
   ! Make the natural orbitals from the density matrix
      genre :: STR, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
      orb_kind :: STR
      if (present(genre)) then; orb_kind = genre
      else;                     orb_kind = .density_matrix.spinorbital_kind
      end
      if (.natural_orbitals.created) .natural_orbitals.destroy_ptr_part
      select case (orb_kind)
         case ("restricted        "); .make_restricted_NOs
         case ("unrestricted      "); .make_unrestricted_NOs
!        case ("general           "); .make_general_NOs
         case ("restricted_complex"); .make_restricted_complex_NOs
         case ("general_complex   "); .make_general_complex_NOs
         case default;                UNKNOWN(orb_kind)
      end
      .archive_natural_orbitals
      .archive_occupation_numbers
   end

   make_restricted_NOs ::: leaky
   ! Make the restricted natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no density matrix")
      if (.natural_orbitals.created) .natural_orbitals.destroy("restricted")
      .natural_orbitals.create(.n_bf,"restricted")
      if (.occupation_numbers.created) .occupation_numbers.destroy("restricted")
      .occupation_numbers.create(.n_bf,"restricted")
      .make_r_NOs(.natural_orbitals.restricted, &
                  .occupation_numbers.restricted, &
                  .density_matrix.restricted)
   end

   make_unrestricted_NOs ::: leaky
   ! Make the unrestricted natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.alpha.created, "no density matrix")
   ENSURE(.density_matrix.beta.created, "no density matrix")
      if (.natural_orbitals.created) .natural_orbitals.destroy("unrestricted")
      .natural_orbitals.create(.n_bf,"unrestricted")
      if (.occupation_numbers.created) .occupation_numbers.destroy("unrestricted")
      .occupation_numbers.create(.n_bf,"unrestricted")
      .make_r_NOs(.natural_orbitals.alpha, &
                  .occupation_numbers.alpha, &
                  .density_matrix.alpha)
      .make_r_NOs(.natural_orbitals.beta, &
                  .occupation_numbers.beta, &
                  .density_matrix.beta)
   end

   make_r_NOs(NO,occupation,P)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      NO,P :: MAT{REAL}
      occupation :: VEC{REAL}
      V,X,S :: MAT{REAL}*
      V.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      V.to_sqrt_of(S)
      S.destroy
      X.create(.n_bf,.n_bf)
      X = P
      X.change_basis_using(V)
      X.solve_eigenproblem(occupation,V)
      S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
      X.to_inverse_sqrt_of(S)
      S.destroy
      NO.to_product_of(X,V)
      X.destroy
      V.destroy
      occupation = occupation(.n_bf:1:-1)
      occupation.zero_small_values(TOL(10))
      NO = NO(:,.n_bf:1:-1)
   end

   make_restricted_complex_NOs ::: leaky
   ! Make the restricted complex natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted_complex.created, "no density matrix")
     V,X :: MAT{CPX}*
     S,O :: MAT{REAL}*
     if (.natural_orbitals.created) .natural_orbitals.destroy("restricted_complex")
     if (.occupation_numbers.created) .occupation_numbers.destroy("restricted")
     .natural_orbitals.create(.n_bf,"restricted_complex")
     .occupation_numbers.create(.n_bf,"restricted")
     V.create(.n_bf,.n_bf)
     X.create(.n_bf,.n_bf)
     O.create(.n_bf,.n_bf)
     S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
     O.to_sqrt_of(S)
     S.destroy
     V = O
     X = .density_matrix.restricted_complex
     X.change_basis_using(V)
     X.solve_eigenproblem(.occupation_numbers.restricted,V)
     S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
     O.to_inverse_sqrt_of(S)
     S.destroy
     X = O
     O.destroy
     .natural_orbitals.restricted_complex.to_product_of(X,V)
     X.destroy
     V.destroy
     .occupation_numbers.restricted = .occupation_numbers.restricted(.n_bf:1:-1)
     .occupation_numbers.restricted.zero_small_values(TOL(10))
     .natural_orbitals.restricted_complex = .natural_orbitals.restricted_complex(:,.n_bf:1:-1)
   end

   make_general_complex_NOs ::: leaky
   ! Make the general natural orbitals and occupations from the complex density
   ! matrix.
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.general_complex.created,"no density matrix")
     S,R :: MAT{REAL}*
     V,X :: MAT{CPX}*
     if (.natural_orbitals.created) .natural_orbitals.destroy("general_complex")
     if (.occupation_numbers.created) .occupation_numbers.create(.n_bf,"general_complex")
     .natural_orbitals.create(.n_bf,"general_complex")
     .occupation_numbers.create(.n_bf,"general")
     V.create(2*.n_bf,2*.n_bf)
     R.create(.n_bf,.n_bf)
     S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
     R.to_sqrt_of(S)
     S.destroy
     V.alpha_alpha_set_to(R)
     V.beta_beta_set_to(R)
     R.destroy
     X.create(2*.n_bf,2*.n_bf)
     X = .density_matrix.general_complex
     X.change_basis_using(V)
     X.solve_eigenproblem(.occupation_numbers.general,V)
     R.create(.n_bf,.n_bf)
     S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
     R.to_inverse_sqrt_of(S)
     S.destroy
     X.alpha_alpha_set_to(R)
     X.beta_beta_set_to(R)
     R.destroy
     .natural_orbitals.general_complex.to_product_of(X,V)
     .occupation_numbers.general = .occupation_numbers.general(2*.n_bf:1:-1)
     .occupation_numbers.general.zero_small_values(TOL(10))
     .natural_orbitals.general = .natural_orbitals.general(:,2*.n_bf:1:-1)
     X.destroy
     V.destroy
   end

!  ***************************
!  Population Analysis Methods
!  ***************************

   put_mulliken_populations
   ! sets the mulliken population matrix and the outputs it.
      mulliken_matrix, S :: MAT{REAL}*
      diagonals :: VEC{REAL}*
      S.create(.n_bf, .n_bf)
      mulliken_matrix.create(.n_bf, .n_bf)
      diagonals.create(.n_bf)
      .get_overlap_matrix(S)
      mulliken_matrix = matmul(.density_matrix.restricted, S)
      mulliken_matrix.put_diagonal_to(diagonals)
      .put_mulliken_populations(mulliken_matrix, diagonals)
      S.destroy
      mulliken_matrix.destroy
      diagonals.destroy
   end

   put_mulliken_populations(mulliken_matrix, diagonals)
   ! outputs the mulliken populations to the output file
      mulliken_matrix :: MAT{REAL}
      diagonals :: VEC{REAL}
      atom_pop :: VEC{REAL}*
      pop :: REAL
      o_count, a, b, c :: INT
      stdout.flush
      stdout.text("Mulliken population analysis: ")
      stdout.dash(int_fields=2,real_fields=1)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Type", int_width = TRUE)
      stdout.put("Population")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=1)
      o_count = 1
      atom_pop.create(.n_atom)
      atom_pop = ZERO
      do a = 1, .n_atom
         do b = 1, .atom.n_shell_for_atom(a)
            do c = 1, .atom(a).basis.shell(b).n_comp
               stdout.put(.atom(a).label, int_width = TRUE)
               stdout.put(.atom(a).basis.shell(b).l_chr, int_width = TRUE)
               pop = diagonals(c + o_count - 1)
               stdout.put(pop)
               atom_pop(a) = atom_pop(a) + pop
               stdout.flush
            end
            o_count = o_count + .atom(a).basis.shell(b).n_comp
         end
      end
      stdout.dash(int_fields=2,real_fields=1)
      stdout.flush
      stdout.show("Trace of the Mulliken matrix = ",mulliken_matrix.trace)
      stdout.flush
      stdout.text("Atomic Populations: ")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=2)
      stdout.put("Atom", int_width = TRUE)
      stdout.put("Population")
      stdout.put("Charge")
      stdout.flush
      stdout.dash(int_fields=1, real_fields=2)
      do a = 1, .n_atom
         stdout.put(.atom(a).label, int_width = TRUE)
         stdout.put(atom_pop(a))
         stdout.put(.atom(a).atomic_number-atom_pop(a))
         stdout.flush
      end
      stdout.dash(int_fields=1, real_fields=2)
      atom_pop.destroy
      stdout.flush
      stdout.text("Mulliken matrix:")
      stdout.put(mulliken_matrix)
   end

!  **************
!  Debug printing
!  **************

   read_debug_on
   ! Read a debug descriptor and add it to the list.
     name :: STR
     stdin.read(name)
     debug.append(name)
   end

   read_debug_off
   ! Read a debug descriptor and remove it from the list.
     name :: STR
     stdin.read(name)
     debug.prune(name)
   end

   debugging(name) result (res)
   ! Return TRUE if the debug switch "name" has been set.
     name :: STR
     res :: BIN
     res = FALSE
     if (debug.destroyed) return
     res = name.is_included_in_any(debug) 
   end

   put_debug(X,name) ::: template
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
     X :: TYPE
     name :: STR
     if (NOT .debugging(name)) return
     stdout.show(trim(name)//" = ",X)
   end

   put_debug(X,name) ::: get_from(MOLECULE, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: template
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
     X :: TYPE
     name :: STR
     if (NOT .debugging(name)) return
     stdout.text(trim(name)//":")
     stdout.put(X)
   end

   put_debug(X,name) ::: get_from(MOLECULE, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: template
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
     X :: TYPE
     name :: STR
     if (NOT .debugging(name)) return
     stdout.text(trim(name)//":")
     X.put
   end

   put_debug(X,name) ::: get_from(MOLECULE, TYPE=>SHELL2)
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

!  ************************
!  Overlap matrix formation
!  ************************

   get_overlap_matrix(S)
   ! Set "S" to the overlap matrix.
   ! If the archive file exists, read it; otherwise make it.
      S :: MAT{REAL}
    ! U :: MAT{REAL}*
      col :: INT
      archive :: ARCHIVE
      archive.set(.name,"overlap_matrix")
      if (.scfdata.destroyed) then
         .make_overlap_matrix(S)
         archive.write(S)
      else if (NOT .scfdata.using_direct_scf AND archive.exists) then
         archive.read(S)
      else
         if (.scfdata.scf_kind=="noninteracting-group-rhf") then; .make_group_overlap_matrix(S)
         else;                                                    .make_overlap_matrix(S)
         end
         if (NOT .scfdata.using_direct_scf) archive.write(S)
      end
    ! U.create(.n_bf,.n_bf); U.to_unit_matrix
    ! if (U.is_linearly_dependent(S,tol=TOL(6),col=col)) then
    !    DIE("column "//trim(col.to_str)//" is linearly dependent")
    ! end
    ! U.destroy
   end

   make_overlap_matrix(S)
   ! Calculate the overlap matrix "S"
     S :: MAT{REAL}, target
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
     q,fa,la,fb,lb :: INT
     sh :: SHELL2
     if (DO_IN_PARALLEL) S = ZERO
     parallel do q = 1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       sh.make_overlap(S(fa:la,fb:lb))
       sh.destroy_ptr_part
     end
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(S)
     else
        S.symmetric_reflect
     end
     .put_debug(S,"overlap matrix")
   end

!   make_rxhf_overlap_matrix(S)
!   ! Calculate the overlap matrix "S" for a restricted crystal Hartree-Fock
!   ! calculation.
!     S :: MAT{REAL}, target
!   ENSURE(.atom.created,  "no fragment atom list")
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.crystal.created,"no crystal data")
!   ENSURE(.cluster.created,"no cluster data")
!   ENSURE(.cluster.atom.created,"no cluster atom data")
!   ENSURE(.cluster.info_made,"no cluster data")
!   ENSURE(S.is_square,"S is not square")
!   ENSURE(S.dim1==.cluster.atom.no_of_basis_functions,"S has wrong shape")
!     n_shell_pairs,q,fa,la,fb,lb,start,step :: INT
!     sh :: SHELL2
!     stdout.text("here")
!     n_shell_pairs = .cluster.atom.n_shell_pairs
!     stdout.show("n_shell_pairs = ",n_shell_pairs)
!     do q = start,n_shell_pairs,step
!       .cluster.atom.get_shell_pair(sh,q,fa,la,fb,lb)
!       sh.make_overlap(S(fa:la,fb:lb))
!       sh.destroy_ptr_part
!     end
!     stdout.text("here2")
!     S.symmetric_reflect
!   end

   make_group_overlap_matrix(S)
   ! Calculate the noninteracting group overlap matrix "S"
     S :: MAT{REAL}, target
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.atom_group.created,"no atom_group info")
     q,fa,la,fb,lb, atom_a,atom_b :: INT
     sh :: SHELL2
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (.in_same_atom_group(atom_a,atom_b)) sh.make_overlap(S(fa:la,fb:lb))
       sh.destroy_ptr_part
     end
     S.symmetric_reflect
   end

!  ****************************
!  Other one electron integrals
!  ****************************

   get_kinetic_matrix(T)
   ! Set "T" to the kinetic matrix
   ! If the archive file exists, read it; otherwise make it.
      T :: MAT{REAL}
      archive :: ARCHIVE
      archive.set(.name,"kinetic_matrix")
      if (.scfdata.destroyed) then
         .make_kinetic_matrix(T)
         archive.write(T)
      else if (NOT .scfdata.using_direct_scf AND archive.exists) then
         archive.read(T)
      else
         if      (.scfdata.using_NDDO) then; .make_NDDO_kinetic_matrix(T)
         else if (.scfdata.using_NUDO) then; .make_NUDO_kinetic_matrix(T)
         else if (.scfdata.group)      then; .make_group_kinetic_matrix(T)
         else;                               .make_kinetic_matrix(T)
         end
         if (NOT .scfdata.using_direct_scf) archive.write(T)
      end
     .put_debug(T,"kinetic matrix")
   end

!   get_kinetic_matrix(T)
!   ! Set "T" to the kinetic matrix
!   ! If the archive file exists, read it; otherwise make it.
!      T :: MAT{REAL}
!      arch :: ARCHIVE
!      write_archive,calc_it :: BIN
!      arch.set(.name,"kinetic_matrix")
!   print *,"here"
!      calc_it = .scfdata.using_direct_scf
!      write_archive = NOT .scfdata.using_direct_scf
!      if (NOT calc_it) then
!        if (arch.exists) then
!          arch.read(T)
!          calc_it = FALSE
!          write_archive = FALSE
!        else
!          calc_it = TRUE
!        end
!      end
!   print *,"calc_it=",calc_it
!   print *,"nddo         =",.scfdata.using_NDDO
!   print *,"nudo         =",.scfdata.using_NUDO
!   print *,"scfdata group=",.scfdata.group
!      if (calc_it) then
!         if      (.scfdata.using_NDDO) then; .make_NDDO_kinetic_matrix(T)
!         else if (.scfdata.using_NUDO) then; .make_NUDO_kinetic_matrix(T)
!         else if (.scfdata.group)      then; .make_group_kinetic_matrix(T)
!         else;                               .make_kinetic_matrix(T)
!         end
!      end
!      if (write_archive) arch.write(T)
!   end

   make_kinetic_matrix(T)
   ! Calculate the kinetic energy matrix "T".
     T :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     q,fa,la,fb,lb :: INT
     sh :: SHELL2
     if (DO_IN_PARALLEL) T = ZERO
     parallel do q = 1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       sh.get_kei(T(fa:la,fb:lb))
       sh.destroy_ptr_part
     end
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(T)
     else
        T.symmetric_reflect
     end
     .put_debug(T,"kinetic matrix")
   end

   make_NDDO_kinetic_matrix(T)
   ! Calculate the NDDO kinetic energy matrix "T".
     T :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     q,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (atom_a==atom_b) then; sh.get_kei(T(fa:la,fb:lb))
       else;                     T(fa:la,fb:lb) = ZERO
       end
       sh.destroy_ptr_part
     end
     T.symmetric_reflect
   end

   make_NUDO_kinetic_matrix(T)
   ! Calculate the NUDO kinetic energy matrix "T". NUDO = neglect of unconnected
   ! differential overlap.
     T :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     q,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (.atom.bonded(atom_a,atom_b)) then; sh.get_kei(T(fa:la,fb:lb))
       else;                                  T(fa:la,fb:lb) = ZERO
       end
       sh.destroy_ptr_part
     end
     T.symmetric_reflect
   end

   make_group_kinetic_matrix(T)
   ! Calculate the noninteracting group  kinetic energy matrix "T".
     T :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.atom_group.created,"no atom_group info")
     q,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     do q = 1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (.in_same_atom_group(atom_a,atom_b)) then; sh.get_kei(T(fa:la,fb:lb))
       else;                                         T(fa:la,fb:lb) = ZERO
       end
       sh.destroy_ptr_part
     end
     T.symmetric_reflect
   end

   get_kinetic_overlap(T,S)
   ! Set "S" to the overlap matrix and "T" to the kinetic matrix
   ! If both archives exists, read them; otherwise make them both!
      T,S :: MAT{REAL}
      write_archive,calc_it :: BIN
      T_archive,S_archive :: ARCHIVE
      S_archive.set(.name,"overlap_matrix")
      T_archive.set(.name,"kinetic_matrix")
      calc_it = .scfdata.using_direct_scf
      write_archive = NOT .scfdata.using_direct_scf
      if (NOT calc_it) then
        if ((S_archive.exists) AND (T_archive.exists)) then
          S_archive.read(S)
          T_archive.read(T)
          calc_it = FALSE
          write_archive = FALSE
        else
          calc_it = TRUE
        end
      end
      if (calc_it) then
         if      (.scfdata.using_NDDO) then; .make_NDDO_kinetic_overlap(T,S)
         else if (.scfdata.using_NUDO) then; .make_NUDO_kinetic_overlap(T,S)
         else if (.scfdata.group) then;      .make_group_kinetic_overlap(T,S)
         else;                               .make_kinetic_overlap(T,S)
         end
      end
      if (write_archive) then
        S_archive.write(S)
        T_archive.write(T)
      end
   end

   make_kinetic_overlap(T,S)
   ! Calculate the kinetic energy matrix "T" and overlap integral matrix "S"
     T,S :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     q,fa,la,fb,lb :: INT
     sh :: SHELL2
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       sh.get_kei(T(fa:la,fb:lb), S(fa:la,fb:lb))
       sh.destroy_ptr_part
     end
     S.symmetric_reflect
     T.symmetric_reflect
     .put_debug(S,"overlap matrix")
     .put_debug(T,"kinetic matrix")
   end

   make_NDDO_kinetic_overlap(T,S)
   ! Calculate the NDDO kinetic energy matrix "T" and overlap integral matrix
   ! "S"
     T,S :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     q,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (atom_a==atom_b) then; sh.get_kei(T(fa:la,fb:lb),S(fa:la,fb:lb))
       else;                     T(fa:la,fb:lb) = ZERO; S(fa:la,fb:lb) = ZERO
       end
       sh.destroy_ptr_part
     end
     S.symmetric_reflect
     T.symmetric_reflect
   end

   make_NUDO_kinetic_overlap(T,S)
   ! Calculate the NUDO kinetic energy matrix "T" and overlap integral matrix
   ! "S"
     T,S :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     q,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (.atom.bonded(atom_a,atom_b)) then; sh.get_kei(T(fa:la,fb:lb),S(fa:la,fb:lb))
       else;                                  T(fa:la,fb:lb) = ZERO; S(fa:la,fb:lb) = ZERO
       end
       sh.destroy_ptr_part
     end
     S.symmetric_reflect
     T.symmetric_reflect
   end

   make_group_kinetic_overlap(T,S)
   ! Calculate the noninteracting group kinetic energy matrix "T" and overlap
   ! integral matrix "S"
     T,S :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.atom_group.created,"no atom_group info")
     q,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     arch :: ARCHIVE
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (.in_same_atom_group(atom_a,atom_b)) then; sh.get_kei(T(fa:la,fb:lb),S(fa:la,fb:lb))
       else;                                         T(fa:la,fb:lb) = ZERO; S(fa:la,fb:lb) = ZERO
       end
       sh.destroy_ptr_part
     end
     S.symmetric_reflect
     T.symmetric_reflect
     arch.set(.name,"kinetic_matrix")
     arch.write(T)
     arch.set(.name,"overlap_matrix")
     arch.write(S)
   end

   get_nuclear_matrix(Z)
   ! Set "Z" to the nuclear attraction matrix.
   ! If the archive file exists, read it; otherwise make it.
      Z :: MAT{REAL}
      archive :: ARCHIVE
      archive.set(.name,"nuclear_matrix")
      if (.scfdata.destroyed) then
         .make_nuclear_matrix(Z)
         archive.write(Z)
      else if (NOT .scfdata.using_direct_scf AND archive.exists) then
         archive.read(Z)
      else
         if      (.scfdata.using_NDDO)  then; .make_NDDO_nuclear_matrix(Z)
         else if (.scfdata.using_NUDO)  then; .make_NUDO_nuclear_matrix(Z)
         else if (.scfdata.using_PIE)   then; .make_PIE_nuclear_matrix(Z)
         else if (.scfdata.group)       then; .make_group_nuclear_matrix(Z)
         else;                                .make_nuclear_matrix(Z)
         end
         if (NOT .scfdata.using_direct_scf) archive.write(Z)
      end
   end

!   get_nuclear_matrix(Z)
!   ! Set "Z" to the nuclear attraction matrix.
!   ! If the archive file exists, read it; otherwise make it.
!      Z :: MAT{REAL}
!      arch :: ARCHIVE
!      write_archive,calc_it :: BIN
!      arch.set(.name,"nuclear_matrix")
!      calc_it = .scfdata.using_direct_scf
!      write_archive = NOT .scfdata.using_direct_scf
!      if (NOT calc_it) then
!        if (arch.exists) then
!          arch.read(Z)
!          calc_it = FALSE
!          write_archive = FALSE
!        else
!          calc_it = TRUE
!        end
!      end
!      if (calc_it) then
!         if      (.scfdata.using_NDDO)  then; .make_NDDO_nuclear_matrix(Z)
!         else if (.scfdata.using_NUDO)  then; .make_NUDO_nuclear_matrix(Z)
!         else if (.scfdata.using_PIE)   then; .make_PIE_nuclear_matrix(Z)
!         else if (.scfdata.group)       then; .make_group_nuclear_matrix(Z)
!         else;                                .make_nuclear_matrix(Z)
!         end
!      end
!      if (write_archive) arch.write(Z)
!   end

   make_nuclear_matrix(Z)
   ! Calculate the nuclear attraction matrix "Z".
     Z :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     atom1 :: ATOM*
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb :: INT
     sh :: SHELL2
     Z = ZERO
     parallel do q = 1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       Z_c.create(sh.a.n_comp,sh.b.n_comp)
       do c = 1,.n_atom
         atom1 => .atom(c)
         sh.get_nuc(Z_c, atom1.mass,atom1.pos)
         Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom1.atomic_number * Z_c
       end
       Z_c.destroy
       sh.destroy_ptr_part
     end
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(Z)
     else
        Z.symmetric_reflect
     end
     .put_debug(Z,"nuclear attraction matrix")
   end

   make_nuclear_matrix(Z,nuclei)
   ! Calculate the nuclear attraction matrix "Z" only for a specified
   ! list of "nuclei".
     Z :: MAT{REAL}
     nuclei :: VEC{INT}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     atom_c :: ATOM*
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb :: INT
     sh :: SHELL2
     Z = ZERO
     do q = 1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       Z_c.create(sh.a.n_comp,sh.b.n_comp)
       do c = 1,size(nuclei)
         atom_c => .atom(nuclei(c))
         sh.get_nuc(Z_c, atom_c.mass,atom_c.pos)
         Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom_c.atomic_number * Z_c
       end
       Z_c.destroy
       sh.destroy_ptr_part
     end
     Z.symmetric_reflect
   end

   make_NDDO_nuclear_matrix(Z)
   ! Calculate the NDDO nuclear attraction matrix "Z"
     Z :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     atom_c :: ATOM*
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     Z = ZERO
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       if (atom_a==atom_b) then
         Z_c.create(sh.a.n_comp,sh.b.n_comp)
         do c=1,.n_atom
           atom_c=>.atom(c)
           sh.get_nuc(Z_c, atom_c.mass,atom_c.pos)
           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom_c.atomic_number * Z_c
         end
         Z_c.destroy
       end
       sh.destroy_ptr_part
     end
     Z.symmetric_reflect
   end

   make_NDDO_nuclear_matrix(Z,nuclei)
   ! Calculate the NDDO nuclear attraction matrix "Z" only for a
   ! specified list of nuclei.
     Z :: MAT{REAL}
     nuclei :: VEC{INT}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     atom_c :: ATOM*
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     Z = ZERO
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       if (atom_a==atom_b) then
         Z_c.create(sh.a.n_comp,sh.b.n_comp)
         do c=1,size(nuclei)
           atom_c=>.atom(nuclei(c))
           sh.get_nuc(Z_c, atom_c.mass,atom_c.pos)
           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom_c.atomic_number * Z_c
         end
         Z_c.destroy
       end
       sh.destroy_ptr_part
     end
     Z.symmetric_reflect
   end

   make_NUDO_nuclear_matrix(Z)
   ! Calculate the NUDO nuclear attraction matrix "Z"
     Z :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     atom_c :: ATOM*
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     Z = ZERO
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       if (.atom.bonded(atom_a,atom_b)) then
         Z_c.create(sh.a.n_comp,sh.b.n_comp)
         do c=1,.n_atom
           atom_c=>.atom(c)
           sh.get_nuc(Z_c, atom_c.mass,atom_c.pos)
           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom_c.atomic_number * Z_c
         end
         Z_c.destroy
       end
       sh.destroy_ptr_part
     end
     Z.symmetric_reflect
   end

   make_NUDO_nuclear_matrix(Z,nuclei)
   ! Calculate the NUDO nuclear attraction matrix "Z" only for a specified
   ! list of "nuclei".
     Z :: MAT{REAL}
     nuclei :: VEC{INT}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     atom_c :: ATOM*
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     Z = ZERO
     do q = 1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       if (.atom.bonded(atom_a,atom_b)) then
         Z_c.create(sh.a.n_comp,sh.b.n_comp)
         do c = 1,size(nuclei)
           atom_c => .atom(nuclei(c))
           sh.get_nuc(Z_c, atom_c.mass,atom_c.pos)
           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom_c.atomic_number * Z_c
         end
         Z_c.destroy
       end
       sh.destroy_ptr_part
     end
     Z.symmetric_reflect
   end

   make_group_nuclear_matrix(Z)
   ! Calculate the noninteracting group nuclear attraction matrix "Z"
     Z :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.atom_group.created,"no atom_group info")
     atom_c :: ATOM*
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb, atom_a,atom_b, n,g :: INT
     sh :: SHELL2
     Z = ZERO
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       if (.in_same_atom_group(atom_a,atom_b,g)) then
         Z_c.create(sh.a.n_comp,sh.b.n_comp)
         do n = 1,size(.atom_group(g).element)
           c = .atom_group(g).element(n)
           atom_c=>.atom(c)
           sh.get_nuc(Z_c, atom_c.mass,atom_c.pos)
           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom_c.atomic_number * Z_c
         end
         Z_c.destroy
       end
       sh.destroy_ptr_part
     end
     Z.symmetric_reflect
   end

   make_group_nuclear_matrix(Z,nuclei)
   ! Calculate the noninteracting group nuclear attraction matrix "Z"
   ! only for a specified list of "nuclei".
     Z :: MAT{REAL}
     nuclei :: VEC{INT}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.atom_group.created,"no atom_group info")
     atom_c :: ATOM*
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb, atom_a,atom_b, n,g :: INT
     sh :: SHELL2
     Z = ZERO
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       if (.in_same_atom_group(atom_a,atom_b,g)) then
         Z_c.create(sh.a.n_comp,sh.b.n_comp)
         do n = 1,size(.atom_group(g).element)
           c = .atom_group(g).element(n)
           if (all(nuclei/=c)) cycle
           atom_c=>.atom(c)
           sh.get_nuc(Z_c, atom_c.mass,atom_c.pos)
           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom_c.atomic_number * Z_c
         end
         Z_c.destroy
       end
       sh.destroy_ptr_part
     end
     Z.symmetric_reflect
   end

   make_PIE_nuclear_matrix(Z)
   ! Calculate the PIE nuclear attraction matrix "Z". In this scheme the three
   ! center nuclear attraction integrals are approximated by a diatom projective
   ! scheme. See Mayer, CPL 332, 381 (2000).
     Z :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     Z_c,S,S_a_c,S_inv,S_sub :: MAT{REAL}*
     a,c,na,nc,nac,fc,lc :: INT
     ac :: VEC{INT}(2)
     S.create(.n_bf,.n_bf)
     .get_overlap_matrix(S)
     Z = ZERO
     do c = 1,.n_atom ! loop over nuclear attraction centres
     do a = 1,.n_atom ! loop over bra
        na  = .atom(a).n_bf
        nc  = .atom(c).n_bf
        nac = na + nc
        Z_c.create(nac,nac)
        ac = [a,c]
        .atom(ac).make_nuclear_matrix(Z_c,nuclei=[2])
        S_inv.create(nac,nac)
        S_a_c.create(nac,nac)
        .AO_subspace_set(S_a_c,S,ac,ac)
        S_inv.to_inverse_of(S_a_c)
        S_a_c.destroy
        S_sub.create(.n_bf,nac)
        .AO_subspace_set(S_sub,S,col_atom=ac)
        S_inv = matmul(S_inv,Z_c)
        fc = .first_basis_fn_for_atom(c)
        lc =  .last_basis_fn_for_atom(c)
        Z(:,fc:lc) = Z(:,fc:lc) + matmul(S_sub,S_inv)
        S_inv.destroy; S_sub.destroy;
        Z_c.destroy
     end
     end
     Z.symmetrize
     S.destroy
   end

   make_nuclear_matrix(Z,charges,points)
   ! Calculate the nuclear attraction matrix "Z" given a set of "charges" at a
   ! set of "points".
     Z,points :: MAT{REAL}
     charges :: VEC{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(charges.dim==points.dim1,"inconsistent charges and points arrays")
   ENSURE(points.dim2==3,"wrong 2nd dimension, points array")
     Z_c :: MAT{REAL}*
     q,c,fa,la,fb,lb :: INT
     sh :: SHELL2
     Z = ZERO
     parallel do q = 1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
       Z_c.create(sh.a.n_comp,sh.b.n_comp)
       do c = 1,charges.dim
         sh.get_nuc(Z_c,ZERO,points(c,:))
         Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - charges(c) * Z_c
       end
       Z_c.destroy
       sh.destroy_ptr_part
     end
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(Z)
     else
        Z.symmetric_reflect
     end
   end

   get_core_matrix(H,nuclei)
   ! Get the core hamiltonian matrix. If already in memory, do nothing. Else if
   ! the archive file exists, read it. Otherwise make it.
   ! If the nuclei are given make it regardless, since the stored one is
   ! likely to be different
      H :: MAT{REAL}
      nuclei :: VEC{INT}, optional
      arch :: ARCHIVE
      write_archive,calc_it :: BIN
      arch.set(.name,"core_matrix")
      calc_it = .scfdata.using_direct_scf OR present(nuclei)
      write_archive = NOT .scfdata.using_direct_scf
      if (NOT calc_it) then
        if (arch.exists) then
          arch.read(H)
          calc_it = FALSE
          write_archive = FALSE
        else
          calc_it = TRUE
        end
      end
      if (calc_it) .make_core_matrix(H,nuclei)
      if (write_archive) arch.write(H)
   end

   make_core_matrix(H,nuclei)
   ! Make the core hamiltonian matrix "H".
      H :: MAT{REAL}
      nuclei :: VEC{INT}, optional
      Z,Dx,Dy,Dz :: MAT{REAL}*
      .make_kinetic_matrix(H)
      Z.create(.n_bf, .n_bf)
      if (present(nuclei)) then; .make_nuclear_matrix(Z,nuclei)
      else;                      .make_nuclear_matrix(Z)
      end
      if (NOT .E_field.is_zero) then
         Dx.create(.n_bf,.n_bf)
         Dy.create(.n_bf,.n_bf)
         Dz.create(.n_bf,.n_bf)
         .get_dipole_matrices(Dx,Dy,Dz)
         Z = Z + Dx*.E_field(1) + Dy*.E_field(2) + Dz*.E_field(3)
         Dz.destroy; Dy.destroy; Dx.destroy
      end
      H = H + Z
      Z.destroy
     .put_debug(H,"core matrix")
   end

   get_dipole_matrices(Dx,Dy,Dz)
   ! Set "Di" to the dipole moment integral matrices.
   ! If archives exist, read them; otherwise make them.
      Dx,Dy,Dz :: MAT{REAL}
      x_archive,y_archive,z_archive :: ARCHIVE
      x_archive.set(.name,"dipole_x_matrix")
      y_archive.set(.name,"dipole_y_matrix")
      z_archive.set(.name,"dipole_z_matrix")
      if (x_archive.exists) then
         x_archive.read(Dx); y_archive.read(Dy); z_archive.read(Dz)
      else
         .make_dipole_matrices(Dx,Dy,Dz)
      end
   end

   make_dipole_matrices(Dx,Dy,Dz)
   ! Make "Di", the dipole moment integral matrices.
      Dx,Dy,Dz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      DDx,DDy,DDz :: MAT{REAL}*
      q,fa,la,fb,lb :: INT
      sh :: SHELL2
      arch :: ARCHIVE
      n_a,n_b :: INT
      Dx = ZERO; Dy = ZERO; Dz = ZERO
      do q=1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         n_a = sh.a.n_comp; n_b = sh.b.n_comp
         DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
         sh.make_dipole_ints(DDx,DDy,DDz, .gauge_origin)
         Dx(fa:la,fb:lb) = Dx(fa:la,fb:lb) + DDx
         Dy(fa:la,fb:lb) = Dy(fa:la,fb:lb) + DDy
         Dz(fa:la,fb:lb) = Dz(fa:la,fb:lb) + DDz
         sh.destroy_ptr_part
         DDz.destroy; DDy.destroy; DDx.destroy
      end
      Dx.symmetric_reflect; Dy.symmetric_reflect; Dz.symmetric_reflect
      arch.set(.name,"dipole_x_matrix"); arch.write(Dx)
      arch.set(.name,"dipole_y_matrix"); arch.write(Dy)
      arch.set(.name,"dipole_z_matrix"); arch.write(Dz)
   end

   electronic_dipole_moment result (res)
   ! Return the electronic dipole moment
      res :: VEC{REAL}(3)
      Dx,Dy,Dz :: MAT{REAL}*
      Dx.create(.n_bf,.n_bf)
      Dy.create(.n_bf,.n_bf)
      Dz.create(.n_bf,.n_bf)
      .get_dipole_matrices(Dx,Dy,Dz)
      res(1) = -.expectation(Dx) ! Minus sign for electron charge
      res(2) = -.expectation(Dy)
      res(3) = -.expectation(Dz)
      Dz.destroy; Dy.destroy; Dx.destroy
   end

   nuclear_dipole_moment result (res)
   ! Return the nuclear dipole moment
      res :: VEC{REAL}(3)
      res = .atom.nuclear_dipole_moment
   end

   get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
   ! Set "Qij" to the quadrupole moment integral matrices.
   ! If archives exist, read them; otherwise make them.
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}
      xx_archive,yy_archive,zz_archive :: ARCHIVE
      xy_archive,xz_archive,yz_archive :: ARCHIVE
      xx_archive.set(.name,"quadrupole_xx_matrix")
      yy_archive.set(.name,"quadrupole_yy_matrix")
      zz_archive.set(.name,"quadrupole_zz_matrix")
      xy_archive.set(.name,"quadrupole_xy_matrix")
      xz_archive.set(.name,"quadrupole_xz_matrix")
      yz_archive.set(.name,"quadrupole_yz_matrix")
      if (xx_archive.exists) then
         xx_archive.read(Qxx); yy_archive.read(Qyy); zz_archive.read(Qzz)
         xy_archive.read(Qxy); xz_archive.read(Qxz); yz_archive.read(Qyz)
      else
         .make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
      end
   end

   make_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
   ! Make "Qij", the quadrupole moment integral matrices.
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      QQxx,QQyy,QQzz,QQxy,QQxz,QQyz :: MAT{REAL}*
      q,fa,la,fb,lb :: INT
      sh :: SHELL2
      arch :: ARCHIVE
      n_a,n_b :: INT
      Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
      Qxy = ZERO; Qxz = ZERO; Qyz = ZERO
      do q=1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         n_a = sh.a.n_comp; n_b = sh.b.n_comp
         QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
         QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)
         sh.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz, .gauge_origin)
         Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) + QQxx
         Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) + QQyy
         Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) + QQzz
         Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) + QQxy
         Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) + QQxz
         Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) + QQyz
         sh.destroy_ptr_part
         QQyz.destroy; QQxz.destroy; QQxy.destroy
         QQzz.destroy; QQyy.destroy; QQxx.destroy
      end
      Qxx.symmetric_reflect; Qyy.symmetric_reflect; Qzz.symmetric_reflect
      Qxy.symmetric_reflect; Qxz.symmetric_reflect; Qyz.symmetric_reflect
      arch.set(.name,"quadrupole_xx_matrix"); arch.write(Qxx)
      arch.set(.name,"quadrupole_yy_matrix"); arch.write(Qyy)
      arch.set(.name,"quadrupole_zz_matrix"); arch.write(Qzz)
      arch.set(.name,"quadrupole_xy_matrix"); arch.write(Qxy)
      arch.set(.name,"quadrupole_xz_matrix"); arch.write(Qxz)
      arch.set(.name,"quadrupole_yz_matrix"); arch.write(Qyz)
   end

   electronic_quadrupole_moment result (res)
   ! Return the electronic quadrupole moments as a vectors in the
   ! order: xx, yy, zz, xy, xz, yz
      res :: VEC{REAL}(6)
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}*
      Qxx.create(.n_bf,.n_bf)
      Qyy.create(.n_bf,.n_bf)
      Qzz.create(.n_bf,.n_bf)
      Qxy.create(.n_bf,.n_bf)
      Qxz.create(.n_bf,.n_bf)
      Qyz.create(.n_bf,.n_bf)
      .get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
      res(1) = -.expectation(Qxx) ! Minus sign for electron charge
      res(2) = -.expectation(Qyy)
      res(3) = -.expectation(Qzz)
      res(4) = -.expectation(Qxy)
      res(5) = -.expectation(Qxz)
      res(6) = -.expectation(Qyz)
      Qyz.destroy; Qxz.destroy; Qxy.destroy
      Qzz.destroy; Qyy.destroy; Qxx.destroy
   end

   nuclear_quadrupole_moment result (res)
   ! Return the nuclear quadrupole moment
      res :: VEC{REAL}(6)
      res = .atom.nuclear_quadrupole_moment
   end

   get_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
   ! Set "Oijk" to the quadrupole moment integral matrices.
   ! If archives exist, read them; otherwise make them.
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}
      xxx,yyy,zzz,xxy,xxz,yyx,yyz,zzx,zzy,xyz :: ARCHIVE
      xxx.set(.name,"octupole_xxx_matrix")
      yyy.set(.name,"octupole_yyy_matrix")
      zzz.set(.name,"octupole_zzz_matrix")
      xxy.set(.name,"octupole_xxy_matrix")
      xxz.set(.name,"octupole_xxz_matrix")
      yyx.set(.name,"octupole_yyx_matrix")
      yyz.set(.name,"octupole_yyz_matrix")
      zzx.set(.name,"octupole_zzx_matrix")
      zzy.set(.name,"octupole_zzy_matrix")
      xyz.set(.name,"octupole_xyz_matrix")
      if (xxx.exists) then
         xxx.read(Oxxx); yyy.read(Oyyy); zzz.read(Ozzz)
         xxy.read(Oxxy); xxz.read(Oxxz)
         yyx.read(Oyyx); yyz.read(Oyyz)
         zzx.read(Ozzx); zzy.read(Ozzy)
         xyz.read(Oxyz)
      else
         .make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
      end
   end

   make_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
   ! Make "Oijk", the octupole moment integral matrices.
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz :: MAT{REAL}*
      q,fa,la,fb,lb :: INT
      sh :: SHELL2
      arch :: ARCHIVE
      n_a,n_b :: INT
      Oxxx = ZERO; Oyyy = ZERO; Ozzz = ZERO
      Oxxy = ZERO; Oxxz = ZERO
      Oyyx = ZERO; Oyyz = ZERO
      Ozzx = ZERO; Ozzy = ZERO
      Oxyz = ZERO
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         n_a = sh.a.n_comp; n_b = sh.b.n_comp
         OOxxx.create(n_a,n_b); OOyyy.create(n_a,n_b); OOzzz.create(n_a,n_b)
         OOxxy.create(n_a,n_b); OOxxz.create(n_a,n_b)
         OOyyx.create(n_a,n_b); OOyyz.create(n_a,n_b)
         OOzzx.create(n_a,n_b); OOzzy.create(n_a,n_b)
         OOxyz.create(n_a,n_b)
         sh.make_octupole_ints(OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz,.gauge_origin)
         Oxxx(fa:la,fb:lb) = Oxxx(fa:la,fb:lb) + OOxxx
         Oyyy(fa:la,fb:lb) = Oyyy(fa:la,fb:lb) + OOyyy
         Ozzz(fa:la,fb:lb) = Ozzz(fa:la,fb:lb) + OOzzz
         Oxxy(fa:la,fb:lb) = Oxxy(fa:la,fb:lb) + OOxxy
         Oxxz(fa:la,fb:lb) = Oxxz(fa:la,fb:lb) + OOxxz
         Oyyx(fa:la,fb:lb) = Oyyx(fa:la,fb:lb) + OOyyx
         Oyyz(fa:la,fb:lb) = Oyyz(fa:la,fb:lb) + OOyyz
         Ozzx(fa:la,fb:lb) = Ozzx(fa:la,fb:lb) + OOzzx
         Ozzy(fa:la,fb:lb) = Ozzy(fa:la,fb:lb) + OOzzy
         Oxyz(fa:la,fb:lb) = Oxyz(fa:la,fb:lb) + OOxyz
         sh.destroy_ptr_part
         OOxyz.destroy
         OOzzy.destroy; OOzzx.destroy
         OOyyz.destroy; OOyyx.destroy
         OOxxz.destroy; OOxxy.destroy
         OOzzz.destroy; OOyyy.destroy; OOxxx.destroy
      end
      Oxxx.symmetric_reflect; Oyyy.symmetric_reflect; Ozzz.symmetric_reflect
      Oxxy.symmetric_reflect; Oxxz.symmetric_reflect
      Oyyx.symmetric_reflect; Oyyz.symmetric_reflect
      Ozzx.symmetric_reflect; Ozzy.symmetric_reflect
      Oxyz.symmetric_reflect
      arch.set(.name,"octupole_xxx_matrix"); arch.write(Oxxx)
      arch.set(.name,"octupole_yyy_matrix"); arch.write(Oyyy)
      arch.set(.name,"octupole_zzz_matrix"); arch.write(Ozzz)
      arch.set(.name,"octupole_xxy_matrix"); arch.write(Oxxy)
      arch.set(.name,"octupole_xxz_matrix"); arch.write(Oxxz)
      arch.set(.name,"octupole_yyx_matrix"); arch.write(Oyyx)
      arch.set(.name,"octupole_yyz_matrix"); arch.write(Oyyz)
      arch.set(.name,"octupole_zzx_matrix"); arch.write(Ozzx)
      arch.set(.name,"octupole_zzy_matrix"); arch.write(Ozzy)
      arch.set(.name,"octupole_xyz_matrix"); arch.write(Oxyz)
   end

   electronic_octupole_moment result (res)
   ! Return the electronic octupole moments as a vectors in the
   ! order: xxx, yyy, zzz, xxy, xxz, yyx, yyz, zzx, zzy, xyz
      res :: VEC{REAL}(10)
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}*
      Oxxx.create(.n_bf,.n_bf)
      Oyyy.create(.n_bf,.n_bf)
      Ozzz.create(.n_bf,.n_bf)
      Oxxy.create(.n_bf,.n_bf)
      Oxxz.create(.n_bf,.n_bf)
      Oyyx.create(.n_bf,.n_bf)
      Oyyz.create(.n_bf,.n_bf)
      Ozzx.create(.n_bf,.n_bf)
      Ozzy.create(.n_bf,.n_bf)
      Oxyz.create(.n_bf,.n_bf)
      .get_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
      res(1)  = -.expectation(Oxxx) ! Minus sign for electron charge
      res(2)  = -.expectation(Oyyy)
      res(3)  = -.expectation(Ozzz)
      res(4)  = -.expectation(Oxxy)
      res(5)  = -.expectation(Oxxz)
      res(6)  = -.expectation(Oyyx)
      res(7)  = -.expectation(Oyyz)
      res(8)  = -.expectation(Ozzx)
      res(9)  = -.expectation(Ozzy)
      res(10) = -.expectation(Oxyz)
      Oxyz.destroy
      Ozzy.destroy; Ozzx.destroy
      Oyyz.destroy; Oyyx.destroy
      Oxxz.destroy; Oxxy.destroy
      Ozzz.destroy; Oyyy.destroy; Oxxx.destroy
   end

   nuclear_octupole_moment result (res)
   ! Return the nuclear octupole moment
      res :: VEC{REAL}(10)
      res = .atom.nuclear_octupole_moment
   end

   make_electric_field_matrices(Ex,Ey,Ez,c)
   ! Make "Ei", the electric fields integral matrices evaluated at
   ! position "c".
      Ex,Ey,Ez :: MAT{REAL}
       c :: VEC{REAL}(3)
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      EEx,EEy,EEz :: MAT{REAL}*
      q,fa,la,fb,lb :: INT
      sh :: SHELL2
      n_a,n_b :: INT
      Ex = ZERO; Ey = ZERO; Ez = ZERO
      do q=1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         n_a = sh.a.n_comp; n_b = sh.b.n_comp
         EEx.create(n_a,n_b); EEy.create(n_a,n_b); EEz.create(n_a,n_b)
         sh.make_E_field_ints(EEx,EEy,EEz,c)
         Ex(fa:la,fb:lb) = Ex(fa:la,fb:lb) + EEx
         Ey(fa:la,fb:lb) = Ey(fa:la,fb:lb) + EEy
         Ez(fa:la,fb:lb) = Ez(fa:la,fb:lb) + EEz
         sh.destroy_ptr_part
         EEz.destroy; EEy.destroy; EEx.destroy
      end
      Ex.symmetric_reflect; Ey.symmetric_reflect; Ez.symmetric_reflect
   end

   electronic_E_field_at_nuclei result (res)
   ! Return the electronic contribution to the electric fields
   ! at the nuclei as a (3 x .n_atom) array
      res :: MAT{REAL}(3,.n_atom)
      Ex,Ey,Ez :: MAT{REAL}*
       a :: INT
      Ex.create(.n_bf,.n_bf)
      Ey.create(.n_bf,.n_bf)
      Ez.create(.n_bf,.n_bf)
      do a = 1,.n_atom
         .make_electric_field_matrices(Ex,Ey,Ez,.atom(a).pos)
         res(1,a) = -.expectation(Ex)
         res(2,a) = -.expectation(Ey)
         res(3,a) = -.expectation(Ez)
      end
      Ez.destroy; Ey.destroy; Ex.destroy
   end

   nuclear_E_field_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields
   ! at the nuclei as a (3 x .n_atom) array
      res :: MAT{REAL}(3,.n_atom)
      res = .atom.nuclear_E_field_at_nuclei
   end

   make_EFG_matrices(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)
   ! Make "Eij", the electric field gradient (EFG) integral matrices evaluated
   ! at point "c".
      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}
       c :: VEC{REAL}(3)
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      EExx,EEyy,EEzz,EExy,EExz,EEyz :: MAT{REAL}*
      q,fa,la,fb,lb :: INT
      sh :: SHELL2
      n_a,n_b :: INT
      Exx = ZERO; Eyy = ZERO; Ezz = ZERO
      Exy = ZERO; Exz = ZERO; Eyz = ZERO
      do q=1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         n_a = sh.a.n_comp; n_b = sh.b.n_comp
         EExx.create(n_a,n_b); EEyy.create(n_a,n_b); EEzz.create(n_a,n_b)
         EExy.create(n_a,n_b); EExz.create(n_a,n_b); EEyz.create(n_a,n_b)
         sh.make_E_gradient_ints(EExx,EEyy,EEzz,EExy,EExz,EEyz,c)
         Exx(fa:la,fb:lb) = Exx(fa:la,fb:lb) + EExx
         Eyy(fa:la,fb:lb) = Eyy(fa:la,fb:lb) + EEyy
         Ezz(fa:la,fb:lb) = Ezz(fa:la,fb:lb) + EEzz
         Exy(fa:la,fb:lb) = Exy(fa:la,fb:lb) + EExy
         Exz(fa:la,fb:lb) = Exz(fa:la,fb:lb) + EExz
         Eyz(fa:la,fb:lb) = Eyz(fa:la,fb:lb) + EEyz
         sh.destroy_ptr_part
         EEyz.destroy; EExz.destroy; EExy.destroy
         EEzz.destroy; EEyy.destroy; EExx.destroy
      end
      Exx.symmetric_reflect; Eyy.symmetric_reflect; Ezz.symmetric_reflect
      Exy.symmetric_reflect; Exz.symmetric_reflect; Eyz.symmetric_reflect
   end

   electronic_EFG_at_nuclei result (res)
   ! Return the electronic contribution to the electric field gradient
   ! (EFG) at the nuclei as a (6 x .n_atom) array. The order of the
   ! electric field gradient elements is: xx, yy, zz, xy, xz, yz
      res :: MAT{REAL}(6,.n_atom)
      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}*
       a :: INT
      Exx.create(.n_bf,.n_bf)
      Eyy.create(.n_bf,.n_bf)
      Ezz.create(.n_bf,.n_bf)
      Exy.create(.n_bf,.n_bf)
      Exz.create(.n_bf,.n_bf)
      Eyz.create(.n_bf,.n_bf)
      do a = 1,.n_atom
         .make_EFG_matrices(Exx,Eyy,Ezz,Exy,Exz,Eyz,.atom(a).pos)
         res(1,a) = -.expectation(Exx)
         res(2,a) = -.expectation(Eyy)
         res(3,a) = -.expectation(Ezz)
         res(4,a) = -.expectation(Exy)
         res(5,a) = -.expectation(Exz)
         res(6,a) = -.expectation(Eyz)
      end
      Eyz.destroy; Exz.destroy; Exy.destroy
      Ezz.destroy; Eyy.destroy; Exx.destroy
   end

   nuclear_EFG_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields gradient (EFG)
   ! at the nuclei as a (6 x .n_atom) array
      res :: MAT{REAL}(6,.n_atom)
      res = .atom.nuclear_EFG_at_nuclei
   end

   get_spin_orbit_matrices(SOx,SOy,SOz)
   ! Set "SOx", "SOy", and "SOz" to the one electron spin orbit matrices.
   ! If archives exist, read them; otherwise make them.
      SOx,SOy,SOz :: MAT{REAL}
      SOx_archive,SOy_archive,SOz_archive :: ARCHIVE
      SOx_archive.set(.name,"SOx_matrix")
      SOy_archive.set(.name,"SOy_matrix")
      SOz_archive.set(.name,"SOz_matrix")
      if (SOx_archive.exists AND SOy_archive.exists AND SOz_archive.exists) then
         SOx_archive.read(SOx)
         SOy_archive.read(SOy)
         SOz_archive.read(SOz)
      else
         .make_spin_orbit_matrices(SOx,SOy,SOz)
      end
   end

   make_spin_orbit_matrices(SOx,SOy,SOz)
   ! Calculate the spin orbit matrices "SOx" "SOy" and "SOz"
      SOx,SOy,SOz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      SOx_c,SOy_c,SOz_c :: MAT{REAL}*
      q,c,fa,la,fb,lb :: INT
       Z :: REAL
      sh :: SHELL2
      arch :: ARCHIVE
      SOx = ZERO; SOy = ZERO; SOz = ZERO
      do q=1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         SOx_c.create(sh.a.n_comp,sh.b.n_comp)
         SOy_c.create(sh.a.n_comp,sh.b.n_comp)
         SOz_c.create(sh.a.n_comp,sh.b.n_comp)
         do c = 1,.n_atom
            Z = .atom(c).atomic_number
            sh.make_spin_orbit_ints(SOx_c,SOy_c,SOz_c, .atom(c).pos)
            SOx(fa:la,fb:lb) = SOx(fa:la,fb:lb) + Z*SOx_c
            SOy(fa:la,fb:lb) = SOy(fa:la,fb:lb) + Z*SOy_c
            SOz(fa:la,fb:lb) = SOz(fa:la,fb:lb) + Z*SOz_c
         end
         sh.destroy_ptr_part
         SOz_c.destroy; SOy_c.destroy; SOx_c.destroy
      end
      SOx.antisymmetric_reflect
      SOy.antisymmetric_reflect
      SOz.antisymmetric_reflect
      arch.set(.name,"SOx_matrix"); arch.write(SOx)
      arch.set(.name,"SOy_matrix"); arch.write(SOy)
      arch.set(.name,"SOz_matrix"); arch.write(SOz)
   end

   get_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
   ! Set "SOBi" to the gauge modified (B field) one electron spin orbit
   ! matrices.  If archives exist, read them; otherwise make them.
      SOBx,SOBy,SOBz :: MAT{REAL}
      x_archive,y_archive,z_archive :: ARCHIVE
      x_archive.set(.name,"SOBx_matrix")
      y_archive.set(.name,"SOBy_matrix")
      z_archive.set(.name,"SOBz_matrix")
      if (x_archive.exists) then
         x_archive.read(SOBx); y_archive.read(SOBy); z_archive.read(SOBz)
      else
         .make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
      end
   end

   make_spin_orbit_B_matrices(SOBx,SOBy,SOBz)
   ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy"
   ! and "SOBz"
      SOBx,SOBy,SOBz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}*
      n_bf :: INT
      arch :: ARCHIVE
      n_bf = .n_bf
      Qxx.create(n_bf,n_bf); Qxy.create(n_bf,n_bf); Qxz.create(n_bf,n_bf)
      Qyx.create(n_bf,n_bf); Qyy.create(n_bf,n_bf); Qyz.create(n_bf,n_bf)
      Qzx.create(n_bf,n_bf); Qzy.create(n_bf,n_bf); Qzz.create(n_bf,n_bf)
      .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
      SOBx = (Qyy + Qzz)*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
      SOBy = (Qxx + Qzz)*.B_field(2) - Qyx*.B_field(1) - Qyz*.B_field(3)
      SOBz = (Qxx + Qyy)*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2)
      Qzz.destroy; Qzy.destroy; Qzx.destroy
      Qyz.destroy; Qyy.destroy; Qyx.destroy
      Qxz.destroy; Qxy.destroy; Qxx.destroy
      SOBx.symmetric_reflect
      SOBy.symmetric_reflect
      SOBz.symmetric_reflect
      arch.set(.name,"SOBx_matrix"); arch.write(SOBx)
      arch.set(.name,"SOBy_matrix"); arch.write(SOBy)
      arch.set(.name,"SOBz_matrix"); arch.write(SOBz)
   end

   get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
   ! Set "Qij" the gauge modified (B field) spin orbit quadrupole matrices.
   ! If archives exist, read them; otherwise make them.
      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}
      xx_archive,xy_archive,xz_archive :: ARCHIVE
      yx_archive,yy_archive,yz_archive :: ARCHIVE
      zx_archive,zy_archive,zz_archive :: ARCHIVE
      xx_archive.set(.name,"SO_Qxx_matrix")
      xy_archive.set(.name,"SO_Qxy_matrix")
      xz_archive.set(.name,"SO_Qxz_matrix")
      yx_archive.set(.name,"SO_Qyx_matrix")
      yy_archive.set(.name,"SO_Qyy_matrix")
      yz_archive.set(.name,"SO_Qyz_matrix")
      zx_archive.set(.name,"SO_Qzx_matrix")
      zy_archive.set(.name,"SO_Qzy_matrix")
      zz_archive.set(.name,"SO_Qzz_matrix")
      if (xx_archive.exists ) then
         xx_archive.read(Qxx); xy_archive.read(Qxy); xz_archive.read(Qxz)
         yx_archive.read(Qyx); yy_archive.read(Qyy); yz_archive.read(Qyz)
         zx_archive.read(Qzx); zy_archive.read(Qzy); zz_archive.read(Qzz)
      else
         .make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
      end
   end

   make_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
   ! Calculate the gauge modified (B field) spin orbit quadrupole matrices
   ! "Qij".
      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      xx,xy,xz,yx,yy,yz,zx,zy,zz :: MAT{REAL}*
      q,c,fa,la,fb,lb :: INT
       Z :: REAL
      sh :: SHELL2
      arch :: ARCHIVE
      n_a,n_b :: INT
      Qxx = ZERO; Qxy = ZERO; Qxz = ZERO
      Qyx = ZERO; Qyy = ZERO; Qyz = ZERO
      Qzx = ZERO; Qzy = ZERO; Qzz = ZERO
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         n_a = sh.a.n_comp; n_b = sh.b.n_comp
         xx.create(n_a,n_b); xy.create(n_a,n_b); xz.create(n_a,n_b)
         yx.create(n_a,n_b); yy.create(n_a,n_b); yz.create(n_a,n_b)
         zx.create(n_a,n_b); zy.create(n_a,n_b); zz.create(n_a,n_b)
         do c = 1,.n_atom
            Z = .atom(c).atomic_number
            sh.make_spin_orbit_B_ints(xx,xy,xz,yx,yy,yz,zx,zy,zz, &
                                    .atom(c).pos, .gauge_origin)
            ! minus due to r-c, not c-r in the electric field part
            ! this comment should go in gaussian2?
            Qxx(fa:la,fb:lb) = Qxx(fa:la,fb:lb) - Z*xx
            Qxy(fa:la,fb:lb) = Qxy(fa:la,fb:lb) - Z*xy
            Qxz(fa:la,fb:lb) = Qxz(fa:la,fb:lb) - Z*xz
            Qyx(fa:la,fb:lb) = Qyx(fa:la,fb:lb) - Z*yx
            Qyy(fa:la,fb:lb) = Qyy(fa:la,fb:lb) - Z*yy
            Qyz(fa:la,fb:lb) = Qyz(fa:la,fb:lb) - Z*yz
            Qzx(fa:la,fb:lb) = Qzx(fa:la,fb:lb) - Z*zx
            Qzy(fa:la,fb:lb) = Qzy(fa:la,fb:lb) - Z*zy
            Qzz(fa:la,fb:lb) = Qzz(fa:la,fb:lb) - Z*zz
         end
         sh.destroy_ptr_part
         zz.destroy; zy.destroy; zx.destroy
         yz.destroy; yy.destroy; yx.destroy
         xz.destroy; xy.destroy; xx.destroy
      end
      Qxx.symmetric_reflect; Qxy.symmetric_reflect; Qxz.symmetric_reflect
      Qyx.symmetric_reflect; Qyy.symmetric_reflect; Qyz.symmetric_reflect
      Qzx.symmetric_reflect; Qzy.symmetric_reflect; Qzz.symmetric_reflect
      arch.set(.name,"SO_Qxx_matrix"); arch.write(Qxx)
      arch.set(.name,"SO_Qxy_matrix"); arch.write(Qxy)
      arch.set(.name,"SO_Qxz_matrix"); arch.write(Qxz)
      arch.set(.name,"SO_Qyx_matrix"); arch.write(Qyx)
      arch.set(.name,"SO_Qyy_matrix"); arch.write(Qyy)
      arch.set(.name,"SO_Qyz_matrix"); arch.write(Qyz)
      arch.set(.name,"SO_Qzx_matrix"); arch.write(Qzx)
      arch.set(.name,"SO_Qzy_matrix"); arch.write(Qzy)
      arch.set(.name,"SO_Qzz_matrix"); arch.write(Qzz)
   end

   nuclear_potential(values,pts)
   ! Calculate the nuclear potential "values" of a given set of "pts".
   ! This is useful for numerical integration of nuclear attraction integrals.
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN
      n_pts,n,i :: INT
      Z_n,r :: REAL
      pos :: VEC{REAL}(3)
      n_pts = size(pts,1)
      values = ZERO
      do n = 1,.n_atom
         Z_n = .atom(n).atomic_number
         pos = .atom(n).pos
         do i = 1,n_pts
            r = pos.distance_to(pts(i,:))
            if (r>tiny(r)) then
              values(i) = values(i) + Z_n / r
            else
            ! values(i) = values(i) + TEN**6
              values(i) = values(i) + huge(ONE)
            end
         end
      end
   end

   electric_potential(values,grid,charges,positions) ::: selfless
   ! Calculate the electric potential "values" at a set of "grid" points, coming
   ! from a given set "charges" located at "positions".  This is useful for
   ! numerical integration of the potential.
      values,charges :: VEC{REAL}
      grid,positions :: MAT{REAL}
   ENSURE(charges.dim==positions.dim1,"inconsistent charges and positions arrays")
   ENSURE(positions.dim2==3,"wrong 2nd dimension, positions array")
   ENSURE(values.dim==grid.dim1,"inconsistent values and grid array")
      n_pts,n,i :: INT
      q,r :: REAL
      pos :: VEC{REAL}(3)
      values = ZERO
      do n = 1,charges.dim
         q = charges(n)
         pos = positions(n,:)
         do i = 1,grid.dim1
            r = pos.distance_to(grid(i,:))
            if (r>tiny(r)) then
              values(i) = values(i) + q / r
            else
              values(i) = values(i) + TEN**6 ! something very large
            end
         end
      end
   end

   ZORA_potential(values,pts)
   ! Calculate the one electron ZORA potential "values" of a given set of "pts".
   ! This is useful for numerical integration.
      values :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN
      fac :: REAL
      .nuclear_potential(values,pts)
      fac    = ONE/(SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      values = ONE/(TWO + fac*values)
   end

   get_1e_ZORA_matrices(T,SOx,SOy,SOz)
   ! Set "SOx", "SOy", and "SOz" to the one electron ZORA spin orbit matrices.
   ! If archives exist, read them; otherwise make them.
      T,SOx,SOy,SOz :: MAT{REAL}
      T_archive,SOx_archive,SOy_archive,SOz_archive :: ARCHIVE
      T_archive.set(.name,"ZORA_kinetic_matrix")
      SOx_archive.set(.name,"ZORA_SOx_matrix")
      SOy_archive.set(.name,"ZORA_SOy_matrix")
      SOz_archive.set(.name,"ZORA_SOz_matrix")
      if (SOx_archive.exists AND SOy_archive.exists AND SOz_archive.exists) then
         T_archive.read(T)
         SOx_archive.read(SOx)
         SOy_archive.read(SOy)
         SOz_archive.read(SOz)
      else
         .make_1e_ZORA_matrices(T,SOx,SOy,SOz)
      end
   end

   make_1e_ZORA_matrices(T,Zx,Zy,Zz)
   ! Calculate the one-electron ZORA spin orbit matrices numerically.
   ! This includes the relativitically modified kinetic energy integrals.
     T, Zx,Zy,Zz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.overlapping_atoms.created,"no overlapping_atoms")
      ZORA  :: MAT4{REAL}*
      a1,b1 :: MAT3{REAL}*
      pt    :: MAT{REAL}*
      wt,V0 :: VEC{REAL}*
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      arch  :: ARCHIVE
      q,atom_a,atom_b,n_pt,fa,la,na,fb,lb,nb,k,l,a,b,aa,bb,ma,mb :: INT
      same_atoms :: BIN
      ZORA.create(.n_bf,.n_bf,3,3)
      ! Make the lower half of the ZORA spin orbit integrals
      nullify(a1); nullify(b1)
      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2
         end                                    ! Make the grid points and weights
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                         ! Keep the weight_is_0 array
         V0.create(n_pt)                        ! local potential grids
         .ZORA_potential(V0,pt)
         .becke_grid.make_bf_grids(a1,b1,ma,mb,pt,atoms)
         V0 = wt*V0
         wt.destroy; pt.destroy
         do k = 1,3
         do l = 1,3
         do a = 1,na
         do b = 1,nb
            aa = fa + a
            bb = fb + b
            ZORA(aa,bb,k,l) = sum(V0*a1(:,a,k)*b1(:,b,l))
         end
         end
         end
         end
         V0.destroy
         if (same_atoms) then; a1.destroy; nullify(b1)
         else;                 b1.destroy; a1.destroy
         end
      end
      ! Make the upper half of the ZORA spin orbit integrals
      do k = 1,3
      do l = 1,3
      do a = 1,.n_bf
      do b = 1,a-1
         ZORA(b,a,l,k) = ZORA(a,b,k,l)
      end
      end
      end
      end
      ! Assemble the ZORA contribution to the 1 electron hamiltonian
      ! Scalar kinetic energy contribution
      T = ZORA(:,:,1,1) + ZORA(:,:,2,2) + ZORA(:,:,3,3)
      ! Spin-dependent spin-orbit contribution
      Zx = ZORA(:,:,2,3) - ZORA(:,:,3,2)
      Zy = ZORA(:,:,3,1) - ZORA(:,:,1,3)
      Zz = ZORA(:,:,1,2) - ZORA(:,:,2,1)
      ZORA.destroy
      arch.set(.name,"ZORA_kinetic_matrix"); arch.write(T)
      arch.set(.name,"ZORA_SOx_matrix");     arch.write(Zx)
      arch.set(.name,"ZORA_SOy_matrix");     arch.write(Zy)
      arch.set(.name,"ZORA_SOz_matrix");     arch.write(Zz)
   end

   make_ENA_matrix(Z)
   ! Calculate the one-electron electron nuclear attraction matrix numerically.
      Z :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created,"no becke_grid")
      pt,a0,b0 :: MAT{REAL}*
      wt,V0 :: VEC{REAL}*
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      arch  :: ARCHIVE
      q,atom_a,atom_b,n_pt,fa,la,na,fb,lb,nb,a,b,aa,bb,ma,mb :: INT
      same_atoms :: BIN
      nullify(a0); nullify(b0)
      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2
         end                                    ! Make the grid points and weights
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                         ! Keep the weight_is_0 array
         V0.create(n_pt)                        ! local potential grids
         .nuclear_potential(V0,pt)
         .becke_grid.make_bf_grids(a0,b0,ma,mb,pt,atoms)
         V0 = wt*V0
         wt.destroy; pt.destroy
         do a = 1,na
         do b = 1,nb
            aa = fa + a
            bb = fb + b
            Z(aa,bb) = sum(V0*a0(:,a)*b0(:,b))
         end
         end
         V0.destroy
         if (same_atoms) then; a0.destroy; nullify(b0)
         else;                 b0.destroy; a0.destroy
         end
      end
      Z.symmetric_reflect
      arch.set(.name,"ENA_matrix"); arch.write(Z)
   end

   get_L_matrices(Lx,Ly,Lz)
   ! Set "Lx", "Ly", and "Lz" to the angular momentum matrices.
   ! If archives exist, read them; otherwise make them.
      Lx,Ly,Lz :: MAT{REAL}
      Lx_archive,Ly_archive,Lz_archive :: ARCHIVE
      Lx_archive.set(.name,"Lx_matrix")
      Ly_archive.set(.name,"Ly_matrix")
      Lz_archive.set(.name,"Lz_matrix")
      if (Lx_archive.exists AND Ly_archive.exists AND Lz_archive.exists) then
         Lx_archive.read(Lx)
         Ly_archive.read(Ly)
         Lz_archive.read(Lz)
      else
         .make_L_matrices(Lx,Ly,Lz)
      end
   end

   make_L_matrices(Lx,Ly,Lz)
   ! Make the angular momentum matrices  "Lx", "Ly", and "Lz".
      Lx,Ly,Lz :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      q,fa,la,fb,lb :: INT
      sh :: SHELL2
      arch :: ARCHIVE
      do q=1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         sh.make_L_ints(Lx(fa:la,fb:lb),Ly(fa:la,fb:lb),Lz(fa:la,fb:lb), .gauge_origin)
         sh.destroy_ptr_part
      end
      Lx.antisymmetric_reflect
      Ly.antisymmetric_reflect
      Lz.antisymmetric_reflect
      arch.set(.name,"Lx_matrix"); arch.write(Lx)
      arch.set(.name,"Ly_matrix"); arch.write(Ly)
      arch.set(.name,"Lz_matrix"); arch.write(Lz)
   end

!  **************************
!  Crystal structure routines
!  **************************

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)]
      dens :: MAT{REAL}, target
      k_pts :: MAT{REAL}, IN
      res :: VEC{CPX}, OUT
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      k_max,k,fa,fb,la,lb,q,atom_a,atom_b :: INT
      sh :: SHELL2
      ft_ab :: MAT3{CPX}*
      dens_ba :: MAT{REAL}*
      cutoff :: REAL
      k_max = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs
      res = ZERO
      parallel do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
         if (sh.skip_ft(cutoff)) then
           sh.destroy_ptr_part
           cycle
         end
         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp)
         .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)
!         dens_ba => dens(fb:lb,fa:la) ! P^dagger
         dens_ba => dens(fa:la,fb:lb)
         if (fa/=fb) then ! count off-diagonals twice.
           do k = 1,k_max
!              res(k) = res(k) + TWO*ft_ab(k,:,:).trace_product_with(dens_ba)
              res(k) = res(k) + TWO*sum(ft_ab(k,:,:)*dens_ba(:,:))
           end
         else
           do k = 1,k_max
!              res(k) = res(k) + ft_ab(k,:,:).trace_product_with(dens_ba)
              res(k) = res(k) + sum(ft_ab(k,:,:)*dens_ba(:,:))
           end
         end
         ft_ab.destroy
         sh.destroy_ptr_part
      end
      PARALLEL_SUM(res)
   end

   make_ft(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [size(k_pts,1)].
      dens :: MAT{CPX}, target
      k_pts :: MAT{REAL}
      res :: VEC{CPX}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      k_max,q,k,fa,la,fb,lb,atom_a,atom_b :: INT
      sh :: SHELL2
      ft_ab :: MAT3{CPX}*
      dens_ba :: MAT{CPX}*
      cutoff :: REAL
      k_max = size(k_pts,1)
      cutoff = TOL(10) / .n_shell_pairs
      res = ZERO
      parallel do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
         if (sh.skip_ft(cutoff)) then
           sh.destroy_ptr_part
           cycle
         end
         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp)
         .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)
         dens_ba => dens(fb:lb,fa:la)
         if (fa/=fb) then ! count off-diagonals twice.
           do k = 1,k_max
              res(k) = res(k) + TWO*ft_ab(k,:,:).trace_product_with(dens_ba)
           end
         else
           do k = 1,k_max
              res(k) = res(k) + ft_ab(k,:,:).trace_product_with(dens_ba)
           end
         end
         ft_ab.destroy
         sh.destroy_ptr_part
      end
      PARALLEL_SUM(res)
   end

   make_ft_deriv_U(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [k_max,n_atom*6]
     dens :: MAT{REAL}, target
     k_pts :: MAT{REAL}, IN
     res :: MAT{CPX}, target
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     ft_ab2,tmp1,tmp2,tmpa1,tmpa2,tmpa3,tmpa4,tmpa5,tmpa6 :: CPX
     k_max,k,fa,fb,la,lb,q,atom_a,atom_b,basea,baseb :: INT
     delta,g,separation,x,y,z,z2 :: REAL
     diff :: VEC{REAL}(3)
     sh :: SHELL2
     ft_ab :: MAT3{CPX}*
     dens_ba :: MAT{REAL}*
     cutoff :: REAL
     k_max = size(k_pts,1)
     cutoff = TOL(10) / .n_shell_pairs
     res = ZERO
     parallel do q = 1, .n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (sh.skip_ft(cutoff)) then
         sh.destroy_ptr_part
         cycle
       end
       ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp)
       .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)
       dens_ba => dens(fb:lb,fa:la)
       if (fa/=fb) ft_ab = TWO * ft_ab ! count off-diagonals twice.
       diff = .atom(atom_a).pos-.atom(atom_b).pos
       separation = diff.norm
       g=HALF
       if (separation > 2.5d0) g=QUARTER
       g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

       basea = (atom_a-1) * 6
       if (atom_a == atom_b) then
         delta = TWO * g
         do k = 1,k_max
           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * delta
           x = k_pts(k,1)           ! SBh_x
           y = k_pts(k,2)           ! SBh_y
           z = k_pts(k,3)           ! SBh_z
           tmp1 = ft_ab2 * x
           tmp2 = ft_ab2 * y
           z2 = TWO * z
           res(basea+1,k) = res(basea+1,k) + tmp1 * x
           res(basea+2,k) = res(basea+2,k) + tmp1 * y * TWO
           res(basea+3,k) = res(basea+3,k) + tmp1 * z2
           res(basea+4,k) = res(basea+4,k) + tmp2 * y
           res(basea+5,k) = res(basea+5,k) + tmp2 * z2
           res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
         end
       else
         baseb = (atom_b-1) * 6
         do k = 1,k_max
           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * g
           x = k_pts(k,1)           ! SBh_x
           y = k_pts(k,2)           ! SBh_y
           z = k_pts(k,3)           ! SBh_z
           tmp1 = ft_ab2 * x
           tmp2 = ft_ab2 * y
           z2 = TWO * z
           tmpa1 = tmp1 * x
           tmpa2 = tmp1 * y * TWO
           tmpa3 = tmp1 * z2
           tmpa4 = tmp2 * y
           tmpa5 = tmp2 * z2
           tmpa6 = ft_ab2 * z * z
           res(basea+1,k) = res(basea+1,k) + tmpa1
           res(basea+2,k) = res(basea+2,k) + tmpa2
           res(basea+3,k) = res(basea+3,k) + tmpa3
           res(basea+4,k) = res(basea+4,k) + tmpa4
           res(basea+5,k) = res(basea+5,k) + tmpa5
           res(basea+6,k) = res(basea+6,k) + tmpa6
           res(baseb+1,k) = res(baseb+1,k) + tmpa1
           res(baseb+2,k) = res(baseb+2,k) + tmpa2
           res(baseb+3,k) = res(baseb+3,k) + tmpa3
           res(baseb+4,k) = res(baseb+4,k) + tmpa4
           res(baseb+5,k) = res(baseb+5,k) + tmpa5
           res(baseb+6,k) = res(baseb+6,k) + tmpa6
         end
       end
       ft_ab.destroy
       sh.destroy_ptr_part
     end
     PARALLEL_SUM(res)
   end

   make_ft_deriv_U(res,dens,k_pts)
   ! Fourier transform of a density described by AO density matrix dens
   ! evaluated at a series of reciprocal space points k_pts
   ! Size of res is [k_max,n_atom*6]
     dens :: MAT{CPX}, target
     k_pts :: MAT{REAL}, IN
     res :: MAT{CPX}, target
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     ft_ab2,tmp1,tmp2 :: CPX
     k_max,k,fa,fb,la,lb,q,atom_a,atom_b,basea,baseb :: INT
     delta,g,separation,x,y,z :: REAL
     diff :: VEC{REAL}(3)
     sh :: SHELL2
     ft_ab :: MAT3{CPX}*
     dens_ba :: MAT{CPX}*
     cutoff :: REAL
     k_max = size(k_pts,1)
     cutoff = TOL(10) / .n_shell_pairs
     res = ZERO
     parallel do q = 1, .n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (sh.skip_ft(cutoff)) then
         sh.destroy_ptr_part
         cycle
       end
       ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp)
       .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)
       dens_ba => dens(fb:lb,fa:la)
       if (fa/=fb) ft_ab = TWO * ft_ab ! count off-diagonals twice.

       diff = .atom(atom_a).pos-.atom(atom_b).pos
       separation = diff.norm
       g=HALF
       if (separation > 2.5d0) g=QUARTER
       g = g * (-HALF) ! k_pts is 2pi * Bh so formula was divided by 4pi^2.

       basea = (atom_a-1) * 6
       if (atom_a == atom_b) then
         delta = TWO * g
         do k = 1,k_max
           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * delta
           x = k_pts(k,1)           ! SBh_x
           y = k_pts(k,2)           ! SBh_y
           z = k_pts(k,3)           ! SBh_z
           tmp1 = ft_ab2 * x
           tmp2 = ft_ab2 * y
           res(basea+1,k) = res(basea+1,k) + tmp1 * x
           res(basea+2,k) = res(basea+2,k) + tmp1 * y
           res(basea+3,k) = res(basea+3,k) + tmp1 * z
           res(basea+4,k) = res(basea+4,k) + tmp2 * y
           res(basea+5,k) = res(basea+5,k) + tmp2 * z
           res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
         end
       else
         baseb = (atom_b-1) * 6
         do k = 1,k_max
           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * g
           x = k_pts(k,1)           ! SBh_x
           y = k_pts(k,2)           ! SBh_y
           z = k_pts(k,3)           ! SBh_z
           tmp1 = ft_ab2 * x
           tmp2 = ft_ab2 * y
           res(basea+1,k) = res(basea+1,k) + tmp1 * x
           res(basea+2,k) = res(basea+2,k) + tmp1 * y
           res(basea+3,k) = res(basea+3,k) + tmp1 * z
           res(basea+4,k) = res(basea+4,k) + tmp2 * y
           res(basea+5,k) = res(basea+5,k) + tmp2 * z
           res(basea+6,k) = res(basea+6,k) + ft_ab2 * z * z
           res(baseb+1,k) = res(baseb+1,k) + tmp1 * x
           res(baseb+2,k) = res(baseb+2,k) + tmp1 * y
           res(baseb+3,k) = res(baseb+3,k) + tmp1 * z
           res(baseb+4,k) = res(baseb+4,k) + tmp2 * y
           res(baseb+5,k) = res(baseb+5,k) + tmp2 * z
           res(baseb+6,k) = res(baseb+6,k) + ft_ab2 * z * z
         end
       end
       ft_ab.destroy
       sh.destroy_ptr_part
     end
     PARALLEL_SUM(res)
   end

   make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)
   ! Make_ft for one pair of gaussians.
   ! Includes partitioning and thermal smearing.
      ft_ab :: MAT3{CPX}
      k_pts :: MAT{REAL}, IN
      sh :: SHELL2, IN
      atom_a,atom_b :: INT, IN
   ENSURE(.crystal.created,"no crystal data")
      is_zero :: BIN
       t :: MAT3{REAL}*
       p :: MAT{REAL}*
      k_max :: INT
      k_max = size(k_pts,1)
      p.create(sh.a.n_cc,sh.b.n_cc)
      .make_partition_factors(p,sh,atom_a,atom_b,is_zero)
      if (NOT is_zero) then
        t.create(k_max,sh.a.n_cc,sh.b.n_cc)
        .thermal_smearing_correction(t,k_pts,atom_a,atom_b,sh)
        sh.make_ft_fast(ft_ab,k_pts,t,p)
      ! sh.make_ft(ft_ab,k_pts)
        t.destroy
      else
        ft_ab = ZERO
      end
      p.destroy
   end

   make_partition_factors(p,sh,atom_a,atom_b,is_zero)
   ! Make the partitition factors "p" for a particular thermal smearing "model",
   ! for a given "sh" pair with atom centres "atom_a" and "atom_b".
       p :: MAT{REAL}
      sh :: SHELL2, IN
      atom_a,atom_b :: INT, IN
      is_zero :: BIN, OUT, optional
   ENSURE(.crystal.created,"no crystal data")
      ra,rb,fa,fb :: REAL
      ra = .crystal.repetition_factor(atom_a)
      rb = .crystal.repetition_factor(atom_b)
      if (present(is_zero)) then
        if (ra<1 AND rb<1) then
          is_zero = TRUE
          return
        else
          is_zero = FALSE
        end
      end
      if (ra<1) then; fa = ZERO
      else;           fa = ONE/ra
      end
      if (rb<1) then; fb = ZERO
      else;           fb = ONE/rb
      end
      select case (trim(.crystal.partition_model))
         case (" ","none")
            p = ONE
         case ("mulliken")
            p = HALF * (fa + fb)
         case ("gaussian")
            sh.make_gaussian_partition(p,fa,fb)
         case default
            DIE("unknown model, "//trim(.crystal.partition_model))
      end
   end

   thermal_smearing_correction(res,k_pts,a,b,sh)
   ! Makes the thermal smearing correction term.  Note that res
   ! is done over the contraction coefficients.
   ! Dimensions of "res" are [k_max,.a.n_cc,.b.n_cc].
     res :: MAT3{REAL}, OUT
     k_pts :: MAT{REAL}, IN
     a,b :: INT, IN
     sh :: SHELL2, IN
     Ua,Ub,Uab :: MAT{REAL}(3,3)
     S,US :: VEC{REAL}(3)
     k_max,k :: INT
     separation,bondlength,Ta,Tb,g :: REAL
     diff :: VEC{REAL}(3)
     k_max = size(k_pts,1)
     select case (trim(.crystal.thermal_smearing_model))
       case (" ","none")
         res = ONE
       case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
         Ua = -HALF * .atom(a).thermal_tensor
         Ub = -HALF * .atom(b).thermal_tensor
         do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(Ua,S)
            Ta = dot_product(S,US)
            US = matmul(Ub,S)
            Tb = dot_product(S,US)
            res(k,:,:) = HALF*(exp(Ta)+exp(Tb))
         end
       case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4]
         bondlength=2.5
         Ua = .atom(a).thermal_tensor
         Ub = .atom(b).thermal_tensor
         Uab = Ua + Ub
         diff = .atom(a).pos-.atom(b).pos
         separation = diff.norm
         g=HALF
         if (separation > bondlength) g=QUARTER
         Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
         do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(Uab,S)
            Ta = dot_product(S,US)
            res(k,:,:) = exp(Ta)
         end
       case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
         Ua = .atom(a).thermal_tensor
         Ub = .atom(b).thermal_tensor
         sh.make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)
       case default
         DIE("unknown model, "//trim(.crystal.thermal_smearing_model))
     end
   end

   ft_thermally_smear(ft_ab,k_pts,a,b)
   ! Thermally smear the fourier transform integrals "ft_ab" evaluated
   ! on "k_pts" for shell pair (ab) centered on atoms "a" and "b" .
     a,b :: INT
     k_pts :: MAT{REAL}
     ft_ab :: MAT3{CPX}
     Ua,Ub,Uab :: MAT{REAL}(3,3)
     S,US,diff :: VEC{REAL}(3)
     separation,bondlength,Ta,Tb,g :: REAL
     k,k_max :: INT
     k_max = size(k_pts,1)
     select case (trim(.crystal.thermal_smearing_model))
       case (" ","none")
       case ("coppens") ! tf=HALF[exp(-(1/2)S(Ua)S)+exp(-(1/2)S(Ub)S)]
         Ua = -HALF * .atom(a).thermal_tensor
         Ub = -HALF * .atom(b).thermal_tensor
         do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(Ua,S)
            Ta = dot_product(S,US)
            US = matmul(Ub,S)
            Tb = dot_product(S,US)
            ft_ab(k,:,:) = ft_ab(k,:,:) * HALF*(exp(Ta)+exp(Tb))
         end
       case ("stewart") ! tf=exp[-HALF Sg(Ua+Ub)S], g=1/2,1/4
         bondlength=2.5
         Ua = .atom(a).thermal_tensor
         Ub = .atom(b).thermal_tensor
         Uab = Ua + Ub
         diff = .atom(a).pos-.atom(b).pos
         separation = diff.norm
         g=HALF
         if (separation > bondlength) g=QUARTER
         Uab = -HALF * g * Uab     ! -HALF g (Ua+Ub)
         do k = 1,k_max
            S = k_pts(k,:)
            US = matmul(Uab,S)
            Ta = dot_product(S,US)
            ft_ab(k,:,:) = exp(Ta)*ft_ab(k,:,:)
         end
       case ("tanaka") ! tf=exp[-HALF S (Ua*alpha + Ub*beta)/gamma S]
         DIE("cannot thermally smear at contracted level.")
       case default
         DIE("unknown thermal smearing model, "//trim(.crystal.thermal_smearing_model))
     end
   end

   add_dispersion_correction(ft,k_pts)
   ! Adds the dispersion correction to "ft".
     k_pts :: MAT{REAL}
     ft :: VEC{CPX}
   ENSURE(.crystal.created,"no crystal")
     disp,phase :: CPX
     pos :: VEC{REAL}(3)
     U,seitz :: MAT{REAL}(3,3)
     Bh,UBh :: VEC{REAL}(3)
     phases :: VEC{CPX}*
     x,y,z,T :: REAL
     a,symop,n,k,k_max :: INT

     !stdout.text("wavelength", flush=1)
     !stdout.put(.crystal.wavelength, flush=1)
     if (.crystal.correct_dispersion) then
       select case (trim(.crystal.thermal_smearing_model))
         case (" ","none")
           phases.create(size(k_pts))
           do n = 1,.crystal.n_fragment_cell_atoms
             a = .crystal.frag_atom_for_frag_cell_atom(n)
             disp = .atom(a).dispersion_correction(.crystal.wavelength)
             pos = .crystal.fragment_cell_geometry(:,n)
             .crystal.unit_cell.change_from_fractional(pos)
             x = pos(1); y = pos(2); z = pos(3)
             phases = disp * exp(cmplx(ZERO,k_pts(:,1)*x + k_pts(:,2)*y + k_pts(:,3)*z,kind=CPX_KIND))
             ft(:) = ft(:) + phases
           end
           phases.destroy

         case default ! thermal smearing methods collapse to be the same
                      ! when dealing with one atom.

           k_max = size(k_pts,1)
           do n = 1,.crystal.n_fragment_cell_atoms
             a = .crystal.frag_atom_for_frag_cell_atom(n)
             symop = .crystal.symop_for_unit_cell_atom(n)
             seitz = .crystal.spacegroup.seitz(1:3,1:3,symop)

             U = .atom(a).thermal_tensor
             ! to crystal coordinates
             U.change_basis_using(.crystal.unit_cell.reciprocal_U_matrix)
             ! apply seitz operation
             U.change_basis_using(transpose(seitz))
             ! to cartesian coordinates
             U.change_basis_using(.crystal.unit_cell.direct_U_matrix)

             disp = .atom(a).dispersion_correction(.crystal.wavelength)
             U = -HALF * U
             pos = .crystal.fragment_cell_geometry(:,n)
             .crystal.unit_cell.change_from_fractional(pos)
             x = pos(1); y = pos(2); z = pos(3)

             do k = 1,k_max
               Bh = k_pts(k,:)
               UBh = matmul(U,Bh)
               T = (dot_product(Bh,UBh))
               phase = exp(cmplx(T,Bh(1)*x + Bh(2)*y + Bh(3)*z,kind=CPX_KIND))
               ft(k) = ft(k) + disp * phase
             end
           end
       end
     end
   end

   check_dispersion_correction
   ! Adds dispersion correction to the F_exp, to compare
   ! with other experimental structure factors that have the 
   ! dispersion correction made to them.
   ENSURE(.crystal.created,"no crystal")
     k_pts :: MAT{REAL}*
     ft :: VEC{CPX}*
     ft.create(.crystal.n_refl)
     ft= .crystal.data.F_pred
     k_pts.create(.crystal.n_refl,3)
     .crystal.make_k_pts(k_pts)
     .add_dispersion_correction(ft,k_pts)
     k_pts.destroy
     .crystal.set_F_calc(ft)
     .crystal.make_F_predicted
     ft.destroy
     stdout.text("Dispersion corrected F_exp", flush=1)
     .crystal.data.reflections.put_structure_factor_data
   end

   get_ft_ints
   ! Get the fourier transform of the overlap integrals.
   ! If the archive file exists, read it; otherwise make it.
      arch :: ARCHIVE
      arch.set(.name,"ft_ints")
      if (NOT arch.exists) .make_ft_ints
   end

   make_ft_ints
   ! Make the fourier transform of the overlap integrals on an archive file
   ENSURE(.crystal.created, "no crystal")
      arch :: ARCHIVE
      k_pts :: MAT{REAL}*
      q,fa,la,fb,lb,atom_a,atom_b :: INT
      sh :: SHELL2*
      ft_ab_eq,ft_ab :: MAT3{CPX}*
      arch.set(.name,"ft_ints")
      arch.open(for="write-only",buffered=TRUE,type="cpx")
      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      sh.create
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp)
         ft_ab.create(.crystal.n_refl,sh.a.n_comp,sh.b.n_comp)
         .make_ft_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
         .crystal.sum_ft_ints(ft_ab,ft_ab_eq)
         arch.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      k_pts.destroy
      arch.close
   end

   make_x_structure_factors
   ! Make the X-ray structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.density_matrix.created, "no density matrix")
      .crystal.assign_xray
      .make_x_structure_factors_p
   end

   make_xf_structure_factors
   ! Make the free X-ray structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.xray_r_free_data.created, "no x-ray R-free reflection data")
   ENSURE(.density_matrix.created, "no density matrix")
      .crystal.assign_xray_r_free
      .make_x_structure_factors_p
   end

   make_x_structure_factors_p ::: private
   ! Make the structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.density_matrix.created, "no density matrix")
      sf_eq,Fc :: VEC{CPX}*
      k_pts :: MAT{REAL}*
      genre :: STR
      Fc.create(.crystal.n_refl)
      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_density_matrix
      genre = .density_matrix.spinorbital_kind
      if (genre.includes("complex")) then
        .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts)
      else
        .make_ft(sf_eq,.density_matrix.restricted,k_pts)
        if (.scfdata.created) then
        if (.scfdata.spinorbital_kind=="unrestricted") then
           .density_matrix.destroy("restricted")
        end
        end
      end
      k_pts.destroy
      .crystal.sum_unique_sf(Fc,sf_eq)
      if (.crystal.correct_dispersion) then
        k_pts.create(.crystal.n_refl,3)
        .crystal.make_k_pts(k_pts)
        .add_dispersion_correction(Fc,k_pts)
        k_pts.destroy
      end
      sf_eq.destroy
      .crystal.set_F_calc(Fc)
      Fc.destroy
      .crystal.make_F_predicted
     ! stdout.text("X-ray structure factor data", flush=1)
     ! .crystal.data.reflections.put_structure_factor_data
   end

   make_n_structure_factors
   ! Make the PND structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
      .crystal.assign_pnd  ! <------------ Assign PND data here
      .make_n_structure_factors_p
   end

   make_nf_structure_factors
   ! Make the free PND structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
      .crystal.assign_pnd_r_free
      .make_n_structure_factors_p
   end

   make_n_structure_factors_p ::: private
   ! Make the structure factors for this molecule.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
   ENSURE(.crystal.spacegroup.centrosymmetric, "must be a centrosymmetric crystal")
      sf_eq,Fc :: VEC{CPX}*
      k_pts :: MAT{REAL}*
      arch :: ARCHIVE
      genre :: STR
      complx :: BIN
      Fc.create(.crystal.n_refl)
      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      sf_eq.create(size(k_pts,1))
      .make_ao_sz_density_matrix ! make S_z density matrix
      genre = .density_matrix.spinorbital_kind
      complx = genre.includes("complex")
      if (complx) then; .make_ft(sf_eq,.density_matrix.restricted_complex,k_pts)
      else;             .make_ft(sf_eq,.density_matrix.restricted,k_pts)
      end
      .crystal.sum_unique_sf(Fc,sf_eq)
      ! Now destroy the S_z density matrix
      if (complx) then; .density_matrix.destroy("restricted_complex")
      else;             .density_matrix.destroy("restricted")
      end
      sf_eq.destroy
      k_pts.destroy
      .crystal.set_F_calc(Fc)
      .crystal.make_F_predicted
      !stdout.text("PND structure factor data")
      !stdout.flush
      !.crystal.data.reflections.put_structure_factor_data
      !arch.set(.name,"sz_structure_factors")
      !arch.write(Fc)
      Fc.destroy
   end

   make_PND_scalar_magnetic_sf
   ! Make the PND scalar magnetic structure factors and assign them
   ! To the crystal objects structure factors for analysis
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
      FM_s, FM_l, FM_r, Fc :: VEC{CPX}*
      n_refl :: INT
      arch :: ARCHIVE
      .crystal.assign_pnd
      n_refl = .crystal.n_refl
      Fc.create(n_refl)
      ! Spin contribution
      .make_PND_spin_sf
      FM_s.create(n_refl)
      arch.set(.name,"PND_spin_sf")
      arch.read(FM_s)
      ! Orbital contribution
    ! .make_PND_nabla_sf
    ! FM_l.create(n_refl)
    ! arch.set(.name,"PND_nabla_sf")
    ! arch.read(FM_l)
      ! Diamagnetic contribution
    ! .make_PND_r_sf
    ! FM_r.create(n_refl)
    ! arch.set(.name,"PND_r_sf")
    ! arch.read(FM_r)
      ! Make F_calc
      Fc = FM_s ! + FM_l ! + FM_r
      arch.set(.name,"PND_scalar_magnetic_sf")
      arch.write(Fc)
      .crystal.set_F_calc(Fc)
      .crystal.make_F_predicted
    ! FM_r.destroy
    ! FM_l.destroy
      FM_s.destroy
      Fc.destroy
   end

   make_PND_spin_sf
   ! Make the PND structure factors
   ENSURE(.density_matrix.created, "no density")
      genre :: STR
      genre = .density_matrix.spinorbital_kind
      select case (genre)
         case ("unrestricted");    .make_u_PND_spin_sf
         case ("general_complex"); .make_gc_PND_spin_sf
         case default
            DIE("not implemented for "//trim(genre))
      end
   end

   make_u_PND_spin_sf
   ! Make the scalar spin magnetic structure factors assuming an applied field
   ! in the z direction, and assuming an unrestricted density matrix exists.
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.density_matrix.created, "no density")
   ENSURE(.density_matrix.alpha.created, "no density")
      arch :: ARCHIVE
      fac,ans :: REAL
      d_aa,d_bb :: MAT{REAL}*
      ft_ab :: MAT4{CPX}*
      FM :: VEC{CPX}*
      sh :: SHELL2*
      k_max,i,q,fa,la,fb,lb :: INT
      arch.set(.name,"PND_ft_spin_ints")
      if (NOT arch.exists) .make_PND_ft_spin_ints
      arch.open(for="read-only",type="real")
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      sh.create
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
         arch.file.read(ft_ab)
         d_aa => .density_matrix.alpha(fb:lb,fa:la)
         d_bb => .density_matrix.beta( fb:lb,fa:la)
         fac = TWO
         if (fa==fb) fac=ONE
         do i = 1,k_max
            ans = ans +    ft_ab(i,:,:,3).trace_product_with(d_aa)
            ans = ans -    ft_ab(i,:,:,3).trace_product_with(d_bb)
            FM(i) = FM(i) + fac*ans
         end
         ft_ab.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      arch.close
      arch.set(.name,"PND_spin_sf")
      arch.write(FM)
      FM.destroy
   end

   make_gc_PND_spin_sf
   ! Make the scalar spin magnetic structure factors assuming an applied field
   ! in the z direction, and assuming a general complex denisty matrix exists
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.density_matrix.created, "no density")
   ENSURE(.density_matrix.general_complex.created, "no density")
      arch :: ARCHIVE
      fac,ans :: REAL
      d_aa,d_bb,d_ba :: MAT{CPX}*
      ft_ab :: MAT4{CPX}*
      FM :: VEC{CPX}*
      ci :: CPX
      sh :: SHELL2*
      k_max,i,q,fa,la,fb,lb :: INT
      arch.set(.name,"PND_ft_spin_ints")
      if (NOT arch.exists) .make_PND_ft_spin_ints
      arch.open(for="read-only",type="real")
      ci = (ZERO,ONE)
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      sh.create
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
         arch.file.read(ft_ab)
         d_aa => .density_matrix.general_complex(      fb:      lb,      fa:      la)
         d_bb => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         d_ba => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,      fa:      la)
         fac = TWO
         if (fa==fb) fac=ONE
         do i = 1,k_max
            ans =          ft_ab(i,:,:,1).trace_product_with(d_ba)
            ans = ans - ci*ft_ab(i,:,:,2).trace_product_with(d_ba)
            ans = ans +    ft_ab(i,:,:,3).trace_product_with(d_aa)
            ans = ans -    ft_ab(i,:,:,3).trace_product_with(d_bb)
            FM(i) = FM(i) + fac*ans
         end
         ft_ab.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      arch.close
      arch.set(.name,"PND_spin_sf")
      arch.write(FM)
      FM.destroy
   end

   get_PND_ft_spin_ints
   ! Get the PND ft spin integrals on disk if they don't already exist
      arch :: ARCHIVE
      arch.set(.name,"PND_ft_spin_ints")
      if (NOT arch.exists) .make_PND_ft_spin_ints
   end

   make_PND_ft_spin_ints
   ! Make the fourier transform of the PND spin integrals on the archive
   ENSURE(.crystal.created, "no crystal")
      arch :: ARCHIVE
      k_pts :: MAT{REAL}*
      sh :: SHELL2*
      ft_ab_eq :: MAT3{CPX}*
      ft_ab :: MAT4{CPX}*
      q,fa,la,fb,lb,atom_a,atom_b :: INT
      arch.set(.name,"PND_ft_spin_ints")
      arch.open(for="write-only",type="cpx")
      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      sh.create
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp)
         .make_ft_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
         ft_ab.create(.crystal.n_refl,sh.a.n_comp,sh.b.n_comp,3)
         .crystal.sum_PND_spin_ints(ft_ab,ft_ab_eq)
         arch.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      k_pts.destroy
      arch.close
   end

   make_PND_nabla_sf
   ! Make PND nabla structure factors
   ENSURE(.density_matrix.created, "no density")
      genre :: STR
      genre = .density_matrix.spinorbital_kind
      select case (genre)
         case ("general_complex"); .make_gc_PND_nabla_sf
         case default
            DIE("not implemented for "//trim(genre))
      end
   end

   make_gc_PND_nabla_sf
   ! Make the scalar nabla magnetic structure factors assuming an applied field
   ! in the z direction, and assuming a general complex density exists
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.density_matrix.created, "no density")
   ENSURE(.density_matrix.general_complex.created, "no density")
      arch :: ARCHIVE
      fac :: REAL
      dens :: MAT{CPX}*
      ft_ab_z :: MAT3{CPX}*
      FM :: VEC{CPX}*
      sh :: SHELL2*
      k_max,i,q,fa,la,fb,lb :: INT
      arch.set(.name,"PND_ft_nabla_ints")
      if (NOT arch.exists) .make_PND_ft_nabla_ints
      arch.open(for="read-only",type="real")
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      sh.create
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         ft_ab_z.create(k_max,sh.a.n_comp,sh.b.n_comp)
         arch.file.read(ft_ab_z)
         dens.create(sh.b.n_comp,sh.a.n_comp)
         dens =        .density_matrix.general_complex(      fb:      lb,      fa:      la)
         dens = dens + .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         fac = TWO
         if (fa==fb) fac=ONE
         do i = 1,k_max
            FM(i) = FM(i) + fac*ft_ab_z(i,:,:).trace_product_with(dens)
         end
         dens.destroy
         ft_ab_z.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      arch.close
      arch.set(.name,"PND_nabla_sf")
      arch.write(FM)
      FM.destroy
   end

   get_PND_ft_nabla_ints
   ! Get the PND ft nabla integrals on disk if they don't already exist
      arch :: ARCHIVE
      arch.set(.name,"PND_ft_nabla_ints")
      if (NOT arch.exists) .make_PND_ft_nabla_ints
   end

   make_PND_ft_nabla_ints
   ! Make the fourier transform of the nabla integrals on the archive
   ENSURE(.crystal.created, "no crystal")
      arch :: ARCHIVE
      k_pts :: MAT{REAL}*
      sh :: SHELL2*
      ft_ab_eq :: MAT4{CPX}*
      ft_ab_z :: MAT3{CPX}*
      q,fa,la,fb,lb,atom_a,atom_b :: INT
      arch.set(.name,"PND_ft_nabla_ints")
      arch.open(for="write-only",type="cpx")
      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      sh.create
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp,3)
         .make_ft_nabla_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
       ! sh.make_ft_nabla(ft_ab_eq,k_pts)
       ! .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
       ! .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
       ! .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
         ft_ab_z.create(.crystal.n_refl,sh.a.n_comp,sh.b.n_comp)
         .crystal.sum_PND_nabla_ints(ft_ab_z,ft_ab_eq)
         arch.file.write(ft_ab_z)
         ft_ab_z.destroy
         ft_ab_eq.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      k_pts.destroy
      arch.close
   end

   make_ft_nabla_pair(ft_ab,k_pts,sh,atom_a,atom_b)
   ! Make_ft for one pair of gaussians.
   ! Includes partitioning, dispersion and thermal smearing.
      ft_ab :: MAT4{CPX}
      k_pts :: MAT{REAL}, IN
      sh :: SHELL2, IN
      atom_a,atom_b :: INT, IN
   ENSURE(.crystal.created,"no crystal data")
       t :: MAT3{REAL}*
       p :: MAT{REAL}*
      k_max :: INT
      k_max = size(k_pts,1)
      t.create(k_max,sh.a.n_cc,sh.b.n_cc)
      .thermal_smearing_correction(t,k_pts,atom_a,atom_b,sh)
      p.create(sh.a.n_cc,sh.b.n_cc)
      .make_partition_factors(p,sh,atom_a,atom_b)
      sh.make_ft_nabla(ft_ab,k_pts,t,p)
      p.destroy
      t.destroy
   end

   make_PND_r_sf
   ! Make the scalar dipole magnetic structure factors assuming an applied field
   ! in the z direction
   ENSURE(.crystal.created, "no crystal")
      arch :: ARCHIVE
      fac,ans :: REAL
      d_aa,d_bb :: MAT{CPX}*
      ft_ab :: MAT4{CPX}*
      FM :: VEC{CPX}*
      sh :: SHELL2*
      k_max,i,q,fa,la,fb,lb :: INT
      arch.set(.name,"PND_ft_r_ints")
      if (NOT arch.exists) .make_PND_ft_r_ints
      arch.open(for="read-only",type="real")
      k_max = .crystal.n_refl
      FM.create(k_max)
      FM = ZERO
      sh.create
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp,3)
         arch.file.read(ft_ab)
         d_aa => .density_matrix.general_complex(      fb:      lb,      fa:      la)
         d_bb => .density_matrix.general_complex(.n_bf+fb:.n_bf+lb,.n_bf+fa:.n_bf+la)
         fac = TWO
         if (fa==fb) fac=ONE
         do i = 1,k_max
            ans =       fac*ft_ab(i,:,:,3).trace_product_with(d_aa)
            ans = ans + fac*ft_ab(i,:,:,3).trace_product_with(d_bb)
            FM(i) = FM(i) + ans
         end
         ft_ab.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      arch.close
      arch.set(.name,"PND_r_sf")
      arch.write(FM)
      FM.destroy
   end

   get_PND_ft_r_ints
   ! Get the PND ft r integrals on disk if they don't already exist
      arch :: ARCHIVE
      arch.set(.name,"PND_ft_r_ints")
      if (NOT arch.exists) .make_PND_ft_r_ints
   end

   make_PND_ft_r_ints
   ! Make the fourier transform of the dipole "r" integrals on the archive
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.reflection_data_exists, "no structure factor data")
      arch :: ARCHIVE
      k_pts :: MAT{REAL}*
      sh :: SHELL2*
      ft_ab_eq, ft_ab :: MAT4{CPX}*
      q,fa,la,fb,lb,atom_a,atom_b,n_refl :: INT
      n_refl = .crystal.n_refl
      arch.set(.name,"PND_ft_r_ints")
      arch.open(for="write-only",type="cpx")
      k_pts.create(.crystal.n_unique_SF_k_pts,3)
      .crystal.make_unique_SF_k_pts(k_pts)
      sh.create
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
         ft_ab_eq.create(size(k_pts,1),sh.a.n_comp,sh.b.n_comp,3)
         sh.make_ft_r(ft_ab_eq,k_pts)
         .ft_thermally_smear(ft_ab_eq(:,:,:,1),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,2),k_pts,atom_a,atom_b)
         .ft_thermally_smear(ft_ab_eq(:,:,:,3),k_pts,atom_a,atom_b)
         ft_ab.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
         .crystal.sum_ft_r_ints(ft_ab,ft_ab_eq,.B_field)
         arch.file.write(ft_ab)
         ft_ab.destroy
         ft_ab_eq.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      k_pts.destroy
      arch.close
   end

   make_PND_fit_ints(ints,lambda)
   ! Make the PND constraint integrals on the archive
      ints :: MAT{CPX}, target
      lambda :: REAL
      spin_archive,nabla_archive :: ARCHIVE
      Fc,F_exp,F_sigma :: VEC{REAL}*
      ints_aa,ints_bb,ints_ba :: MAT{CPX}*
      nabla_z :: MAT3{CPX}*
      spin :: MAT4{CPX}*
      sh :: SHELL2*
      ci :: CPX
      fac,fac1 :: REAL
      i,q,fa,la,fb,lb,n_bf,n_refl :: INT
      .get_PND_ft_spin_ints
      .get_PND_ft_nabla_ints
      .get_PND_ft_r_ints
      spin_archive.set(.name,"PND_ft_spin_ints")
      nabla_archive.set(.name,"PND_ft_nabla_ints")
    ! r_archive.set(.name,"PND_ft_r_ints")
      spin_archive.open(for="read-only",type="real")
    ! r_archive.open(for="read-only",type="real")
      ci = (ZERO,ONE)
      n_bf   =  .n_bf
      n_refl =  .crystal.n_refl
      Fc.create(n_refl)
      F_exp.create(n_refl)
      F_sigma.create(n_refl)
      Fc = abs(.crystal.F_calc)
      F_exp  = .crystal.F_exp
      F_sigma  = .crystal.F_sigma
      ints = ZERO
      sh.create
      fac1 = TWO*lambda/n_refl
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         spin.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
         spin_archive.file.read(spin)
         ints_aa => ints(     fa:     la,     fb:     lb)
         ints_bb => ints(n_bf+fa:n_bf+la,n_bf+fb:n_bf+lb)
         ints_ba => ints(n_bf+fa:n_bf+la,     fb:     lb)
         do i = 1,n_refl
            fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i))
            ints_ba = ints_ba +    fac*spin(i,:,:,1)
            ints_ba = ints_ba + ci*fac*spin(i,:,:,2)
            ints_aa = ints_aa +    fac*spin(i,:,:,3)
            ints_bb = ints_bb -    fac*spin(i,:,:,3)
         end
         spin.destroy
         nabla_z.create(n_refl,sh.a.n_comp,sh.b.n_comp)
         nabla_archive.file.read(nabla_z)
         do i = 1,n_refl
            fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i))
            ints_aa = ints_aa + fac*nabla_z(i,:,:)
            ints_bb = ints_bb + fac*nabla_z(i,:,:)
         end
         nabla_z.destroy
       ! r.create(n_refl,sh.a.n_comp,sh.b.n_comp,3)
       ! r_archive.file.read(r)
       ! do i = 1,n_refl
       !    fac = fac1*(Fc(i) - F_exp(i))/(F_sigma(i)*F_sigma(i)*)
       !    ints_aa = ints_aa + fac*r(i,:,:,3)
       !    ints_bb = ints_bb + fac*r(i,:,:,3)
       ! end
       ! r.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      ints.make_hermitian
    ! r_archive.close
      nabla_archive.close
      spin_archive.close
      F_sigma.destroy
      F_exp.destroy
      Fc.destroy
   end

!  ****************
!  Symmetry methods
!  ****************

   symmetrise(mat,orb_kind)
   ! Symmetrise an opmatrix matrix "mat" of spinorbital_kind "orb_kind" (if
   ! specified)
      mat :: OPMATRIX
      orb_kind :: STR, optional
      itemkind :: STR
      itemkind = mat.spinorbital_kind
      if (present(orb_kind)) itemkind = orb_kind
      select case (itemkind)
         case ("restricted");           .symmetrise_r(mat.restricted)
         case ("unrestricted");         .symmetrise_r(mat.alpha)
                                        .symmetrise_r(mat.beta)
         case ("general");              .symmetrise_r(mat.general.alpha_alpha)
                                        .symmetrise_r(mat.general.beta_beta)
                                        .symmetrise_r(mat.general.alpha_beta)
                                        .symmetrise_r(mat.general.beta_alpha)
         case ("restricted_complex");   .symmetrise_c(mat.restricted_complex)
         case ("unrestricted_complex"); .symmetrise_c(mat.alpha_complex)
                                        .symmetrise_c(mat.beta_complex)
         case ("general_complex");      .symmetrise_c(mat.general_complex.alpha_alpha)
                                        .symmetrise_c(mat.general_complex.beta_beta)
                                        .symmetrise_c(mat.general_complex.alpha_beta)
                                        .symmetrise_c(mat.general_complex.beta_alpha)
         case default;   DIE("unknown kind, "//trim(orb_kind))
      end
   end

   symmetrise_r(mat)
   ! Symmetrise a real restricted basis kind matrix
      mat :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")
      sym,w,tra,trb :: MAT{REAL}*
      sh :: SHELL*
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      first,last :: VEC{INT}*
      image :: MAT{INT}*
      first => .first_basis_fn_for_shell
      last  => .last_basis_fn_for_shell
      image.create(.n_shell, .pointgroup.order)
      .make_image_of_shell(image)
      sym.create(.n_bf,.n_bf)
      sym = ZERO
      sh.create
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            .get_shell(sh,a); na = sh.n_comp; la = sh.l; sh.destroy_ptr_part
            tra => .pointgroup.xyz_matrix(n,la)
            i = image(a,n)
            fa = first(a);  la = last(a); fi = first(i);  li = last(i)
            do b = 1,.n_shell
               .get_shell(sh,b); nb = sh.n_comp; lb = sh.l; sh.destroy_ptr_part
               trb => .pointgroup.xyz_matrix(n,lb)
               j = image(b,n)
               fb = first(b);  lb = last(b); fj = first(j);  lj = last(j)
               w.create(na,nb)
               w = matmul(tra, mat(fa:la,fb:lb) )
               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + matmul(w,transpose(trb))
               w.destroy
               trb.destroy
            end
            tra.destroy
         end
      end
      sh.destroy
      mat = sym/.pointgroup.order
      sym.destroy
      image.destroy
   end

   symmetrise_c(mat)
   ! Symmetrise a complex restricted basis kind matrix
      mat :: MAT{CPX}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")
      sym,w :: MAT{CPX}*
      tra,trb :: MAT{REAL}*
      sh :: SHELL*
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      first,last :: VEC{INT}*
      image :: MAT{INT}*
      first => .first_basis_fn_for_shell
      last  => .last_basis_fn_for_shell
      image.create(.n_shell, .pointgroup.order)
      .make_image_of_shell(image)
      sym.create(.n_bf,.n_bf)
      sym = ZERO
      sh.create
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            .get_shell(sh,a); na = sh.n_comp; la = sh.l; sh.destroy_ptr_part
            tra => .pointgroup.xyz_matrix(n,la)
            i = image(a,n)
            fa = first(a);  la = last(a); fi = first(i);  li = last(i)
            do b = 1,.n_shell
               .get_shell(sh,b); nb = sh.n_comp; lb = sh.l; sh.destroy_ptr_part
               trb => .pointgroup.xyz_matrix(n,lb)
               j = image(b,n)
               fb = first(b);  lb = last(b); fj = first(j);  lj = last(j)
               w.create(na,nb)
               w = matmul(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj) = sym(fi:li,fj:lj) + matmul(w,transpose(trb))
               w.destroy
               trb.destroy
            end
            tra.destroy
         end
      end
      sh.destroy
      mat = sym/.pointgroup.order
      sym.destroy
      image.destroy
   end

   make_image_of_shell(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under pointgroup
   ! operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      res :: MAT{INT}, OUT
   ENSURE(res.dim1==.n_shell, "dimension of matrix incorrect")
   ENSURE(res.dim2==.pointgroup.order, "dimension of matrix incorrect")
      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT
      do n = 1,.pointgroup.order
         do a = 1,.n_shell
            aa = .atom_for_shell(a)
            as = .atom_shell_for_shell(a)
            new_pos = matmul(.pointgroup.mat(:,:,n), .atom(aa).pos)
            new_atom = .atom_index_from_pos(new_pos)
            fs = .first_shell_for_atom(new_atom)
            res(a,n) = fs+as-1
         end
      end
   end

!  ************
!  I/O routines
!  ************

   read_name
   ! Read in the name of the molecule. This must always be
   ! the first keyword inputted.
      stdin.read(.name)
   end

   read_multiplicity
   ! Read in the spin multiplicity
      stdin.read(.mult)
   ENSURE(.mult/=0,"cannot have zero multiplicity")
   end

   read_charge
   ! Read in the total molecular charge
      stdin.read(.charge)
   end

   read_E_field
   ! Read in the applied electric E field
      stdin.read(.E_field)
   end

   read_gauge_origin
   ! Read in the gauge origin vector for an applied external magnetic field
      stdin.read(.gauge_origin)
      .delete_gauge_integrals
   end

   read_B_field
   ! Read in the applied magnetic B field
      stdin.read(.B_field)
   end

   read_optimise_thermals
   ! Read in whether to optimise thermal tensor parameters
      stdin.read(.optimise_thermals)
   end

   delete_gauge_integrals
   ! Delete all integral files which depend on the gauge origin.
   ! This is required whenever the gauge origin is changed.
      arch :: ARCHIVE
      arch.set(.name,"Lx_matrix"); arch.delete
      arch.set(.name,"Ly_matrix"); arch.delete
      arch.set(.name,"Lz_matrix"); arch.delete
   end

   read_plotgrid ::: leaky
   ! Read in the plot grid data
      .grid.destroy
      .grid.create(.atom)
      .grid.read_keywords
   end

   read_isosurface ::: leaky
   ! Read in the isosurface data. NOTE: the isosurface has its own plotgrid,
   ! different from that used in normal density plots.
      .isosurface.destroy
      .isosurface.create(.atom)
      !!!!!!!!!!!!!!!!!!!!!!!!!
      .isosurface.read_keywords
      !!!!!!!!!!!!!!!!!!!!!!!!!
   end

   read_CX_isosurface ::: leaky
   ! Read in special crystalexplorer isosurface data. This only works if a
   ! previous cluster has ben defined. This CX isosurface differs from a normal
   ! isosurface in that the default box sizes for the isosurface are set from
   ! the cluster fragment (as opposed to the .atom list for normal isosurfaces),
   ! and there is a default isosurface kind, which is the "stockholder_density".
   ! The default is also that interpolators are used, and the interpolator table
   ! length may be taken from the cluster radius, if the cluster was generated
   ! with the hirshfeld surface option.  NOTE: the isosurface has its own
   ! plotgrid, different from that used in normal density plots. 
   ENSURE(.cluster.created,"no cluster data, use cluster= keyword")
   ENSURE(.cluster.asymmetric_cell_atom.created,"no cluster asymmetric cell atoms")
   ENSURE(.cluster.crystal.created,"no cluster crystal")
   ENSURE(.atom.created,"no atom list")
      fragment_atom :: VEC{ATOM}*
      .isosurface.destroy
      .isosurface.create(.atom)
      ! This should be created within the cluster !
      ! ... should a .saved molecule exist?
      ! ... does the .saved molecule has the same fragment atom list?
      ! ... was the .saved molecule used as the fragment? then we can eliminate
      ! the leak
      .cluster.create_fragment_atom_list(fragment_atom) ! <-- bad leak here
      .isosurface.grid.set_defaults(fragment_atom,destroy_atom=TRUE) ! Make Hirshfeld for fragment
      .isosurface.grid.n_x = 2**ISOSURFACE_MINIMUM_SCAN_LEVEL + 1
      .isosurface.grid.set_points_widths_origin
      .isosurface.iso_kind = "stockholder_weight"  ! WARNING: The above will leak
    ! .isosurface.interpolator.destroy             ! Creating this interpolator
    ! .isosurface.interpolator.create              ! implies it will always be used 
    ! if (.cluster.generation_method=="for_hirshfeld_surface") then
    !    .isosurface.interpolator.set_table_length(.cluster.radius)
    ! end             ! The settings in this interpolator may be overridden by user
      !!!!!!!!!!!!!!!!!!!!!!!!!
      .isosurface.read_keywords
      !!!!!!!!!!!!!!!!!!!!!!!!!
   end

   read_dftgrid ::: leaky
   ! Read in the DFT grid data
      if (.dftgrid.destroyed) .dftgrid.create
      .dftgrid.read_keywords
      .dftgrid.archive.set_root_name(.name)
   end

   read_becke_grid ::: leaky
   ! Read in the Becke integration grid data
   ENSURE(.atom.created,"input atom information before becke_grid information")
      if (.becke_grid.destroyed) .becke_grid.create
      .becke_grid.read_keywords
      .becke_grid.set_atom_info(.atom.atomic_number &
                               ,.atom.transposed_coordinates &
                               ,.atom.minimum_basis_exponents &
                               ,.atom) ! leaky
      .becke_grid.set_grid_data
   end

   read_crystal ::: leaky
   ! Read in the crystal data. If the ".atom" list data is available, its
   ! coordinates will be resolved into cartesians at this point. IMPOIRTANT
   ! NOTE: normally the crystal information will be inputted from a CIF file.
   ! However, if the crystal information is inputted explicitly, and the
   ! asymmetric unit is not specified, then the symmetry unique atoms in the
   ! ".atom" list are used to define the crystal asymmetric unit. Once defined,
   ! the asymmetric unit in the crystal is never destroyed. Thus, in this case,
   ! you must ensure that your atom list has enough atoms to generate the entire
   ! crystal; for co-crystals this may be a problem. Use the CIF file method for
   ! input in this case, or be careful.
      WARN_IF(.crystal.created,"crystal data already defined!")
      if (.crystal.destroyed) .crystal.create
      .crystal.read_keywords
      .crystal.update
      if (associated(.atom)) then
         .resolve_axis_system
         .crystal.make_fragment_data(.atom)
      end
   end

   read_pointgroup ::: leaky
   ! Read in the pointgroup data
      if (.pointgroup.destroyed) .pointgroup.create
      .pointgroup.read_keywords
   end

   read_scfdata ::: leaky
   ! Read in the scf data
      if (.scfdata.destroyed) .scfdata.create
      .scfdata.read_keywords
      .scfdata.finalize
      if (.scfdata.using_diis) then
      .scfdata.diis.set_archive_root_name(.name)
      end
   end

   read_robydata ::: leaky
   ! Read in the Roby data. NOTE: this keyword must appear after a basis set
   ! has been defined
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
      S :: MAT{REAL}*
      if (.roby.created) then
         .roby.destroy
      end
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      .roby.create(self,S)
      .roby.read_keywords
      .roby.finalize
   end

   read_atoms ::: leaky
   ! Read in the atom list information
      WARN_IF(.atom.created,"atom list already defined!")
    ! if (.atom.created) then
    !    .atom.nullify_bases
    !    .atom.destroy
    ! end
      .atom.read_list_keywords
      .set_atom_info
      .resolve_basis_info
      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_fragment_data(.atom)
      end
   end

   read_basis_set_kind ::: leaky
   ! Read in a suffix string representing the basis type to be used
   ! for the atoms.
      last,this :: STR
      last = .basis_set_kind
      stdin.read(this)
      .set_basis_set_kind(this)
   end

   read_saved_basis_set_kind ::: leaky
   ! Read in a suffix string representing the basis type to be used
   ! for the atoms in the *saved* molecule.
   ENSURE(.saved.created,"there is no saved molecule")
      last,this :: STR
      last = .saved.basis_set_kind
      stdin.read(this)
      .saved.set_basis_set_kind(this)
   end

   read_basis_sets ::: leaky
   ! Read in a list of atomic basis sets for the molecule
      WARN_IF(.basis.created,"basis sets already defined!")
      .basis.read_list_keywords
      if (.basis.created) .basis.unnormalise ! NOTE this
      .resolve_basis_info
   end

   read_slaterbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      WARN_IF(.slaterbasis.created,"slaterbasis sets already defined!")
      .slaterbasis.read_list_keywords
      if (.slaterbasis.created) .slaterbasis.unnormalise
      .resolve_basis_info
   end

   read_coppensbasis_sets ::: leaky
   ! Read in a list of atomic Coppens basis sets for the molecule
      WARN_IF(.coppensbasis.created,"coppensbasis sets already defined!")
      .coppensbasis.read_list_keywords
      if (.coppensbasis.created) .coppensbasis.unnormalise
      .resolve_basis_info
   end

   read_atom_groups ::: leaky
   ! Read in the .atom_group array
   ENSURE(.atom.created,"no atom list")
   ENSURE(stdin.next_item=="{","Expecting open bracket symbol: {")
   ENSURE(.atom_group.destroyed,"groups already defined")
   ENSURE(NOT .atom.groups_defined,"groups already defined")
   !  n,n_group,i,length,line,item :: INT
   !  atoms,chg :: VEC{INT}*
      n :: INT
      range :: VEC{INT}(2)
      word :: STR
      stdin.read(word)
   !  line = stdin.line_number
   !  item = stdin.next_line_item
   !  n = 0
   !  do                             ! Loop over keywords
   !     nullify(atoms)
   !     stdin.read(word)
   !     word.to_lower_case
   !     select case (word)
   !        case("}             "); exit
   !        case("atom_group=   "); stdin.read_intvec_ptr(atoms); n = n+1
   !        case("atom_range=   "); stdin.read_intvec(range);     n = n+1
   !        case("group_charges="); stdin.read_intvec_ptr(chg);   n = n+1
   !        case default;           UNKNOWN(word)
   !     end
   !     if (atoms.created) atoms.destroy
   !     if (chg.created)   chg.destroy
   !  end
   !  !
   !  stdin.move_to_line(line)
   !  stdin.move_to_line_item(item)
   !  n_group = n
   !  .atom_group.create(n)
      nullify(.atom_group)
      n = 0
      do                             ! Loop over keywords
         stdin.read(word)
         word.to_lower_case
         select case (word)
            case("atom_group=")
               n = n+1
               .atom_group.expand(n)
               stdin.read_intvec_ptr(.atom_group(n).element)
               ENSURE(all(.atom_group(n).element>0),       "non-positive atom indices")
               ENSURE(all(.atom_group(n).element<=.n_atom),"index too large")
   !        case("atom_range=")
   !           n = n+1
   !           .atom_group.expand(n)
   !           stdin.read_intvec(range)
   !           length = range(2) - range(1) + 1
   !           ENSURE(length>=1,"non-positive atom group range!")
   !           .atom_group(n).element.create(length)
   !           .atom_group(n).element = [ (i, i=range(1),range(2)) ]
            case("group_charges=")
               stdin.read_intvec_ptr(.group_charges)
            case("mos_per_group=")
               stdin.read_intvec_ptr(.mos_per_group)
            case("}")
               exit
         end
      end
      if (.group_charges.created) then
         ENSURE(.group_charges.dim==.atom_group.dim,"wrong size, group_charges")
      end
      if (.mos_per_group.created) then
         ENSURE(.mos_per_group.dim==.atom_group.dim,"wrong size, mos_per_group")
      end
      .put_atom_groups
   end

   read_group_charges
   ! Read in the .group_charges array
   ENSURE(.group_charges.destroyed,"charges already exist")
      stdin.read_intvec_ptr(.group_charges)
      if (.atom_group.created) then
        ENSURE(.group_charges.dim==.atom_group.dim,"wrong size, group_charges")
      end
   end

   read_mos_per_group
   ! Read in the .mos_per_group array
   ENSURE(.mos_per_group.destroyed,"mos_per_group already exist")
      stdin.read_intvec_ptr(.mos_per_group)
      if (.atom_group.created) then
        ENSURE(.mos_per_group.dim==.atom_group.dim,"wrong size, mos_per_group")
      end
   end

   make_atom_groups ::: leaky
   ! Make the .atom_group array from the .atom(:).group information
   ENSURE(.atom.groups_defined,"no group info supplied in atoms=")
      .atom_group.destroy
      .atom.make_atom_group_lists(.atom_group)
      .put_atom_groups ! This is not quite the same as the .atom version
      if (.group_charges.created) then
         ENSURE(.group_charges.dim==.atom_group.dim,"wrong size, atom_groups")
      end
   end

   read_archive ::: leaky
   ! Read the archive called "name". Must also specify a basis "orb_kind", e.g.
   ! "restricted".  For use with TONTO generated archives.
   ENSURE(stdin.n_line_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")
      name,orb_kind :: STR
      arch :: ARCHIVE
      stdin.read(name)
      stdin.read(orb_kind)
      stdout.text("reading archive : " // trim(name))
      arch.set(.name,name,genre=orb_kind)
      select case (name)
         case ("molecular_orbitals")
           if (.molecular_orbitals.destroyed) .molecular_orbitals.create(.n_bf)
           arch.read(.molecular_orbitals)
         case ("density_matrix    ")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix)
         case ("MP2_density_matrix")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix)
         case ("MP3_density_matrix")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix)
         case ("fock_matrix       ")
           if (.fock_matrix.destroyed) .fock_matrix.create(.n_bf)
           arch.read(.fock_matrix)
         case ("orbital_energies  ")
           if (.orbital_energies.destroyed) .orbital_energies.create(.n_bf)
           arch.read(.orbital_energies)
         case ("natural_orbitals  ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals)
         case ("occupation_numbers")
           if (.occupation_numbers.destroyed) .occupation_numbers.create(.n_bf)
           arch.read(.occupation_numbers)
         case ("covalent_orbitals ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals)
         case ("ionic_orbitals    ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals)
         case default;                UNKNOWN(name)
      end
      arch.close
   end

   read_ascii_archive ::: leaky
   ! Read the archive called "name". Must also specify a basis "orb_kind", e.g.
   ! "restricted".
   ! If required, the input order may be specified as "by_row" (default) or
   ! "by_column".
   ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")
      name,orb_kind,order :: STR
      arch :: ARCHIVE
      stdin.read(name)
      stdin.read(orb_kind)
      order = "by_row"
      if (NOT stdin.buffer_exhausted) stdin.read(order)
      arch.set(.name,name,genre=orb_kind,format="ascii")
      select case (name)
         case ("molecular_orbitals")
           if (.molecular_orbitals.destroyed) .molecular_orbitals.create(.n_bf)
           arch.read(.molecular_orbitals,order=order)
         case ("density_matrix    ")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix,order=order)
         case ("MP2_density_matrix")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix,order=order)
         case ("MP3_density_matrix")
           if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
           arch.read(.density_matrix,order=order)
         case ("orbital_energies  ")
           if (.orbital_energies.destroyed) .orbital_energies.create(.n_bf)
           arch.read(.orbital_energies)
         case ("natural_orbitals  ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals,order=order)
         case ("occupation_numbers")
           if (.occupation_numbers.destroyed) .occupation_numbers.create(.n_bf)
           arch.read(.occupation_numbers)
         case ("covalent_orbitals ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals,order=order)
         case ("ionic_orbitals    ")
           if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
           arch.read(.natural_orbitals,order=order)
         case ("fock_matrix       ")
           if (.fock_matrix.destroyed) .fock_matrix.create(.n_bf)
           arch.read(.fock_matrix,order=order)
         case default;                UNKNOWN(name)
      end
      arch.close
   end

   read_g94_checkpoint_file(name) ::: leaky
   ! Read a g94 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional
      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l, nps, shell_to_atom, e_atom :: VEC{INT}*
      tmp_nps, tmp_sta, tmp_shells :: VEC{INT}*
      tmp_pe, tmp_cc :: VEC{REAL}*
      pe, cc, extra_cc, temp_vec :: VEC{REAL}*
      temp_mat :: MAT{REAL}*
      temp_spin, temp_total, D :: OPMATRIX*
      basis1 :: BASIS*
      c, t, a, s, u, m1, m2, i,n_basis :: INT
      n_shell, n_comp, n_cc, nps_c, n_independent :: INT
      same :: BIN
      arch :: ARCHIVE
      if (.basis.created) .basis.destroy
      if (.atom.created)  .atom.destroy
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end
      .scfdata.create

      ! Read in basic stuff.
      chkfile.create(fchk)
      chkfile.open(for="read")
      chkfile.read(.name)
      chkfile.look_for("Number of atoms")
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)
      chkfile.look_for("Charge")
      chkfile.move_to_line_item(3); chkfile.read(.charge)
      chkfile.look_for("Multiplicity")
      chkfile.move_to_line_item(3); chkfile.read(.mult)
      chkfile.look_for("Number of electrons")
      chkfile.move_to_line_item(5); chkfile.read(.n_e)
      chkfile.look_for("Number of alpha electrons")
      chkfile.move_to_line_item(6); chkfile.read(.n_a)
      chkfile.look_for("Number of beta electrons")
      chkfile.move_to_line_item(6); chkfile.read(.n_b)
      chkfile.look_for("Number of basis functions")
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)
      n_independent = .n_bf
      chkfile.look_for("Number of independant functions")
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      chkfile.look_for("Number of contracted shells")
      chkfile.move_to_line_item(6); chkfile.read(.n_shell)
      chkfile.look_for("Number of primitive shells")
      chkfile.move_to_line_item(6); chkfile.read(.n_prim)
      chkfile.look_for("Total Energy")
      chkfile.move_to_line_item(4)
      chkfile.read_real(.scfdata.energy )
      chkfile.look_for("Atomic numbers"); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1, .n_atom
         chkfile.read(.atom(a).atomic_number )
         .atom(a).label = trim(.atom(a).chemical_symbol)
      end
      chkfile.look_for("Current cartesian coordinates")
      chkfile.read_line
      do a = 1, .n_atom
         chkfile.read(.atom(a).pos)
      end

      ! Shell info.
      chkfile.look_for("Shell types"); chkfile.read_line
      tmp_shells.create(.n_shell); tmp_nps.create(.n_shell)
      tmp_sta.create(.n_shell); tmp_pe.create(.n_prim)
      tmp_cc.create(.n_prim)
      chkfile.read(tmp_shells)
      chkfile.look_for("Number of primitives per shell")
      chkfile.read_line; chkfile.read(tmp_nps)
      chkfile.look_for("Shell to atom map"); chkfile.read_line
      chkfile.read(tmp_sta)
      chkfile.look_for("Primitive exponents"); chkfile.read_line
      chkfile.read(tmp_pe)
      chkfile.look_for("Contraction coefficients"); chkfile.read_line
      chkfile.read(tmp_cc)
      e_atom.create(.n_atom); e_atom = ZERO
      extra_cc.create(.n_prim)
      if (any(tmp_shells == (-1) )) then
        do a = 1, .n_shell
           if (tmp_shells(a) == (-1)) then
              e_atom(tmp_sta(a)) = e_atom(tmp_sta(a)) + 1
              .n_prim = .n_prim + tmp_nps(a)
           end
        end
        chkfile.look_for("P(S=P)"); chkfile.read_line
        chkfile.read(extra_cc)
      end
      s = .n_shell + sum(e_atom)
      shell_l.create(s); nps.create(s)
      pe.create(.n_prim); cc.create(.n_prim)
      shell_to_atom.create(s)
      a = 0
      m1 = 1; m2 = 1
      do c = 1, .n_shell
        a = a + 1
        nps_c = tmp_nps(c)
        if (tmp_shells(c) == (-1)) then
           shell_l(a) = 0
           nps(a) = nps_c
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+nps_c-1) = tmp_pe(m2:m2+nps_c-1)
           cc(m1:m1+nps_c-1) = tmp_cc(m2:m2+nps_c-1)
           a = a+1; m1=m1+nps_c
           shell_l(a) = 1
           nps(a) = nps_c
           shell_to_atom(a) = tmp_sta(c)
           pe(m1:m1+nps_c-1) = tmp_pe(m2:m2+nps_c-1)
           cc(m1:m1+nps_c-1) = extra_cc(m2:m2+nps_c-1)
        else
           pe(m1:m1+nps_c-1) = tmp_pe(m2:m2+nps_c-1)
           cc(m1:m1+nps_c-1) = tmp_cc(m2:m2+nps_c-1)
         ! shell_l(a) = tmp_shells(c)
           shell_l(a) = abs(tmp_shells(c)) ! WARNING: sometimes this can be -2
           nps(a) = nps_c
           shell_to_atom(a) = tmp_sta(c)
        end
        m1 = m1 + nps_c; m2 = m2 + nps_c
      end
      extra_cc.destroy
      tmp_shells.destroy; tmp_sta.destroy
      tmp_nps.destroy; tmp_pe.destroy; tmp_cc.destroy
      .n_shell = s
      c = 0      ! for recording number of primitives read
      t = 0      ! for recording number of shells read
      n_basis = 0
      .basis.create(n_basis)
      do a = 1, .n_atom
         basis1.create
         basis1.label = trim(.atom(a).label) // ":gaussian"
         n_shell = count(shell_to_atom==a)
         basis1.n_shell = n_shell
         basis1.shell.create(n_shell)
         basis1.shell.nullify_ptr_part
         do s = 1, n_shell
          ! n_comp = shell_l(t+s).n_comp
            n_cc = nps(t+s)
            basis1.shell(s).set_l(shell_l(t+s))
            basis1.shell(s).set_n_comp
            basis1.shell(s).n_cc = n_cc
            basis1.shell(s).ex.create(n_cc )
            basis1.shell(s).cc.create(n_cc )
            basis1.shell(s).ex = pe(c+1 : c+n_cc )
            basis1.shell(s).cc = cc(c+1 : c+n_cc )
            c = c + n_cc
         end
         basis1.n_bf = basis1.no_of_basis_functions
         basis1.n_prim = basis1.no_of_primitives
         basis1.unnormalise ! Note this
         t = t + n_shell
         same = FALSE
         do i = 1,n_basis
            if (.basis(i).same_as(basis1)) then
               same = TRUE
               exit
            end
         end
       ! .atom(a).basis.create
         if (same) then
       !    .atom(a).basis.label = .basis(i).label
            .atom(a).basis_label = .basis(i).label
         else
       !    .atom(a).basis.label = basis1.label
            .atom(a).basis_label = basis1.label
            n_basis = n_basis + 1
            .basis.expand(n_basis)
            .basis(n_basis).copy(basis1)
         end
         basis1.destroy
      end
      pe.destroy; cc.destroy
      shell_to_atom.destroy; nps.destroy; e_atom.destroy
      shell_l.destroy
      m1 = .n_bf
      ! .basis.unnormalise ! NOTE this
      .set_atom_info
      .basis_set_kind = " "
      .resolve_basis_info
      ENSURE(m1==.n_bf,"No. of basis functions inconsistent with basis set, did you use 6d/10f?")

      ! Read in orbital energies.
      temp_vec.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies")
      chkfile.read_line; chkfile.read(temp_vec)
      .orbital_energies.destroy
      if (chkfile.next_str == "Beta") then
         u = 1
         .scfdata.scf_kind = "uhf"
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = temp_vec
         chkfile.read_line; chkfile.read(temp_vec)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = temp_vec
         temp_vec.destroy
      else
         u = 0
         .scfdata.scf_kind = "rhf"
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = temp_vec
         temp_vec.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(n_independent,.n_bf)
      chkfile.look_for("Alpha MO")
      chkfile.read_line; chkfile.read(temp_mat)
      .molecular_orbitals.destroy
      if (chkfile.next_str == "Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .swap_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .swap_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .density_matrix.destroy
      if (u==0) then
         .density_matrix.create(.n_bf, "restricted")
         .density_matrix.triangle.create(.density_matrix.l_compress("restricted"))
         chkfile.look_for("Total SCF Density"); chkfile.read_line
         chkfile.read(.density_matrix.triangle)
         .density_matrix.uncompress
         .swap_g94_orbital_order(.density_matrix.restricted,"row")
         .swap_g94_orbital_order(.density_matrix.restricted,"column")
      else
         temp_total.create(.n_bf, "restricted")
         temp_spin.create(.n_bf, "restricted")
         temp_total.triangle.create(temp_total.l_compress("restricted"))
         chkfile.look_for("Total SCF Density"); chkfile.read_line
         chkfile.read(temp_total.triangle)
         temp_total.uncompress
         temp_spin.triangle.create(temp_spin.l_compress("restricted"))
         chkfile.look_for("Spin SCF Density"); chkfile.read_line
         chkfile.read(temp_spin.triangle)
         temp_spin.uncompress
         .density_matrix.create(.n_bf,"unrestricted")
         .density_matrix.beta = (temp_total.restricted - temp_spin.restricted)/2
         .density_matrix.alpha = (temp_spin.restricted + temp_total.restricted)/2
         temp_spin.destroy
         temp_total.destroy
         .swap_g94_orbital_order(.density_matrix.alpha,"row")
         .swap_g94_orbital_order(.density_matrix.alpha,"column")
         .swap_g94_orbital_order(.density_matrix.beta, "row")
         .swap_g94_orbital_order(.density_matrix.beta, "column")
      end

      ! Extract MP2 density matrix to file.  UHF untested
      if (chkfile.has_string("MP2 Density")) then
        if (u==0) then
           D.create(.n_bf, "restricted")
           D.triangle.create(D.l_compress("restricted"))
           chkfile.look_for("Total MP2 Density"); chkfile.read_line
           chkfile.read(D.triangle)
           D.uncompress
           .swap_g94_orbital_order(D.restricted,"row")
           .swap_g94_orbital_order(D.restricted,"column")
           arch.set(.name,"MP2_density_matrix")
           arch.write(D)
           D.destroy
        else
           temp_total.create(.n_bf, "restricted")
           temp_spin.create(.n_bf, "restricted")
           temp_total.triangle.create(temp_total.l_compress("restricted"))
           chkfile.look_for("Total MP2 Density"); chkfile.read_line
           chkfile.read(temp_total.triangle)
           temp_total.uncompress
           temp_spin.triangle.create(temp_spin.l_compress("restricted"))
           chkfile.look_for("Spin MP2 Density"); chkfile.read_line
           chkfile.read(temp_spin.triangle)
           temp_spin.uncompress
           D.create(.n_bf,"unrestricted")
           D.beta = (temp_total.restricted - temp_spin.restricted)/2
           D.alpha = (temp_spin.restricted + temp_total.restricted)/2
           temp_spin.destroy
           temp_total.destroy
           .swap_g94_orbital_order(D.alpha,"row")
           .swap_g94_orbital_order(D.alpha,"column")
           .swap_g94_orbital_order(D.beta, "row")
           .swap_g94_orbital_order(D.beta, "column")
           arch.set(.name,"MP2_density_matrix")
           arch.write(D)
           D.destroy
        end
      end

      ! Extract MP3 density matrix to file.  UHF untested
      if (chkfile.has_string("MP3 Density")) then
        if (u==0) then
           D.create(.n_bf, "restricted")
           D.triangle.create(D.l_compress("restricted"))
           chkfile.look_for("Total MP3 Density"); chkfile.read_line
           chkfile.read(D.triangle)
           D.uncompress
           .swap_g94_orbital_order(D.restricted,"row")
           .swap_g94_orbital_order(D.restricted,"column")
           arch.set(.name,"MP3_density_matrix")
           arch.write(D)
           D.destroy
        else
           temp_total.create(.n_bf, "restricted")
           temp_spin.create(.n_bf, "restricted")
           temp_total.triangle.create(temp_total.l_compress("restricted"))
           chkfile.look_for("Total MP3 Density"); chkfile.read_line
           chkfile.read(temp_total.triangle)
           temp_total.uncompress
           temp_spin.triangle.create(temp_spin.l_compress("restricted"))
           chkfile.look_for("Spin MP3 Density"); chkfile.read_line
           chkfile.read(temp_spin.triangle)
           temp_spin.uncompress
           D.create(.n_bf,"unrestricted")
           D.beta = (temp_total.restricted - temp_spin.restricted)/2
           D.alpha = (temp_spin.restricted + temp_total.restricted)/2
           temp_spin.destroy
           temp_total.destroy
           .swap_g94_orbital_order(D.alpha,"row")
           .swap_g94_orbital_order(D.alpha,"column")
           .swap_g94_orbital_order(D.beta, "row")
           .swap_g94_orbital_order(D.beta, "column")
           arch.set(.name,"MP3_density_matrix")
           arch.write(D)
           D.destroy
        end
      end

      chkfile.close; chkfile.destroy

      ! Save data in archive files
      arch.set(.name,"density_matrix")
      arch.write(.density_matrix)
      arch.set(.name,"molecular_orbitals")
      arch.write(.molecular_orbitals)
      arch.set(.name,"orbital_energies")
      arch.write(.orbital_energies)

      if (associated(.crystal)) then
         .resolve_axis_system
         .crystal.make_fragment_data(.atom)
      end
   end

   swap_g94_orbital_order(X,swap)
   ! Swap the order of f orbitals on matrix "X" after reading a g94 checkpoint
   ! file, for "swap" equal to "row" or "1", or "coloumn" or "2".
       X :: MAT{REAL}
      swap :: STR
      n,f,l :: INT
      ff :: VEC{INT}(10) = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 /)
      select case (swap)
         case("row","1")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               ENSURE((l-f)<=9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
            end
         case("column","2")
            do n = 1,.n_shell
               f = .first_basis_fn_for_shell(n)
               l = .last_basis_fn_for_shell(n)
               ENSURE((l-f)<=9,"cannot yet convert order for g shells")
               if ((l-f)==9) then ! f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
            end
         case default
            DIE("unknown swap kind, "//trim(swap))
      end
   end

   write_wfn_file ::: leaky
   ! writes a .wfn file for input to morphy98
   ENSURE(.occupation_numbers.created("restricted"), "No occupation numbers")
   ENSURE(.orbital_energies.created("restricted"), "No orbital energies")
   ENSURE(.molecular_orbitals.created("restricted"), "No orbitals")
      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}*
      evec :: VEC{REAL}*
      dmatrix, cc :: MAT{REAL}*
      sh :: SHELL*
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
!      title_format :: STR, parameter = "(A80)"
      n_vars_format :: STR, parameter = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"
      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)
      wfnfile.create(name)
      wfnfile.open(for="write")
      if (mod(.n_e, 2) == 0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end
      write(unit = wfnfile.unit, fmt = '(a)') trim(name) // " computed by TONTO"
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).pos, real(.atom(i).atomic_number,kind=REAL_KIND) , i = 1, .n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )
      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atomn  = .atom_for_shell(a)
        shelln = .atom_shell_for_shell(a)
        sh => .atom(atomn).basis.shell(shelln)
        l = sh.l.n_comp_sum - sh.n_comp
        do j = 1, sh.n_cc
          if (sh.l == 3) then
            lvec(pcount  ) = l + 1
            lvec(pcount+1) = l + 2
            lvec(pcount+2) = l + 3
            lvec(pcount+3) = l + 4
            lvec(pcount+4) = l + 5
            lvec(pcount+5) = l + 7
            lvec(pcount+6) = l + 6
            lvec(pcount+7) = l + 8
            lvec(pcount+8) = l + 9
            lvec(pcount+9) = l + 10
            do i = 1, sh.n_comp
              evec(pcount) = sh.ex(j)
              pcount = pcount + 1
            end
          else
            do i = 1, sh.n_comp
              evec(pcount) = sh.ex(j)
              lvec(pcount) = l + i
              pcount = pcount + 1
            end
          end
        end
      end
      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec
      lvec.destroy
      evec.destroy
      dmatrix.create(.n_prim, .n_bf)
      dmatrix = ZERO
      cc.create(.n_prim, .n_bf);    .make_contraction_matrix(cc)

      dmatrix.to_product_of(cc,.molecular_orbitals.restricted)
      do i = 1, n_orbitals
         write(unit = wfnfile.unit, fmt = mol_title_format) &
            "MO  ", i, &
            "OCC NO = ", .occupation_numbers.restricted(i), &
            " ORB. ENERGY = ", .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end
      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy
   end

   write_archive
   ! Write the archive called "name". The kind is defined by the object to be
   ! written.
      name :: STR
      arch :: ARCHIVE
      stdin.read(name)
      arch.set(.name,name)
      select case (name)
         case ("molecular_orbitals"); arch.write(.molecular_orbitals)
         case ("density_matrix    "); arch.write(.density_matrix)
         case ("natural_orbitals  "); arch.write(.natural_orbitals)
         case ("occupation_numbers"); arch.write(.occupation_numbers)
         case ("fock_matrix       "); arch.write(.fock_matrix)
         case ("orbital_energies  "); arch.write(.orbital_energies)
         case default;    UNKNOWN(name)
      end
      arch.close
   end

   write_ascii_archive
   ! Write the archive called "name". The kind is defined by the object to be
   ! written. If required, the output order may be specified as
   ! "by_row" (default) or "by_column".
      name,order :: STR
      arch :: ARCHIVE
      stdin.read(name)
      order = "by_row"
      if (NOT stdin.buffer_exhausted) stdin.read(order)
      arch.set(.name,name,format="ascii")
      select case (name)
         case ("molecular_orbitals"); arch.write(.molecular_orbitals,order=order)
         case ("density_matrix    "); arch.write(.density_matrix,order=order)
         case ("natural_orbitals  "); arch.write(.natural_orbitals,order=order)
         case ("occupation_numbers"); arch.write(.occupation_numbers,order=order)
         case ("fock_matrix       "); arch.write(.fock_matrix,order=order)
         case ("orbital_energies  "); arch.write(.orbital_energies,order=order)
         case default;     UNKNOWN(name)
      end
      arch.close
   end

!  **************
!  Output methods
!  **************

   put
   ! Put all the available molecule information on file "out"
     stdout.flush
     stdout.text("Molecule information:")
     stdout.flush
     stdout.show("Name                   =",.name)
     stdout.show("Charge                 =",.charge)
     stdout.show("Multiplicity           =",.mult)
     stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
     stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
     stdout.show("B field Gauge origin   =",.gauge_origin)
     if (.atom.created)        .put_atoms
     if (.atom_group.created)  .put_atom_groups
     if (.pointgroup.created)  .put_pointgroup
     if (.crystal.created)     .put_crystal
     if (.cluster.created)     .put_cluster
!    if (.grid.created)        .put_grid
     if (.dftgrid.created)     .put_dftgrid
     if (.becke_grid.created)  .put_becke_grid
     if (.overlapping_atoms.created AND .atom.created) .put_overlapping_atoms
   end

   put_atoms
   ! Output the atom coordinate and basis set information
   ENSURE(.atom.created,"no atom list")
      stdout.flush
      stdout.text("Molecule atom information:")
      stdout.flush
      stdout.show("Chemical Formula       =",trim(.chemical_formula))
      stdout.show("No of atoms            =",.n_atom)
      stdout.show("No of electrons        =",.n_e)
      stdout.show("No of alpha electrons  =",.n_a)
      stdout.show("No of beta  electrons  =",.n_b)
      .atom.put_coord_info
      if (.basis.created)        .put_bases
      if (.coppensbasis.created) .put_coppensbases
      if (.slaterbasis.created)  .put_slaterbases
      .put_atom_thermal_tensors
   end

   put_principal_axes
   ! Output the atom principal axes
   ENSURE(.atom.created,"no atom list")
      .atom.put_principal_axes
   end

   put_all_bonds
   ! Put all the bond length info out
      .atom.put_coord_info(all=TRUE)
   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.
   ENSURE(.atom.created,"no atom list")
   ENSURE(.basis.created,"no basis set list")
      if (NOT .atom.bases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom basis set information:")
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.n_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      .basis.renormalise
      .basis.put
      .basis.unnormalise
   end

   put_slaterbases
   ! Output the molecule slaterbasis set information, if the bases are all
   ! resolved.
   ENSURE(.atom.created,"no atom list")
   ENSURE(.slaterbasis.created,"no basis set list")
      if (NOT .atom.slaterbases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom slaterbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.slaterbasis.dim)
      .slaterbasis.put
   end

   put_coppensbases
   ! Output the molecule coppensbasis set information, if the bases are all
   ! resolved.
   ENSURE(.atom.created,"no atom list")
   ENSURE(.coppensbasis.created,"no basis set list")
      if (NOT .atom.coppensbases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom coppensbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.coppensbasis.dim)
      stdout.show("Maximum N value   =",.coppensbasis.maximum_basis_n_value)
      stdout.show("No. of orbitals   =",.coppensbasis.no_of_orbitals)
      stdout.show("No. of primitives =",.coppensbasis.no_of_primitives)
      .coppensbasis.put
   end

   put_atom_thermal_tensors
   ! Output the thermal tensors if they exist.
   ENSURE(.atom.created,"no atom info")
     xmodel,nmodel :: STR
     xmodel = "none"
     nmodel = "none"
     if (.crystal.created) then
        if (.crystal.xray_data.created) xmodel = .crystal.xray_data.thermal_smearing_model
        if (.crystal.pnd_data.created)  nmodel = .crystal.pnd_data.thermal_smearing_model
     end
     stdout.flush
     stdout.show("X-ray thermal smearing model =",xmodel)
     stdout.show("PND   thermal smearing model =",nmodel)
     stdout.flush
     if (.atom.has_thermal_factors) then
       stdout.flush
       stdout.put("Atomic Displacement Parameter (ADP) information:")
       stdout.flush
       .atom.put_thermal_tensors(.crystal)
     end  
   end

   put_atom_groups
   ! Out out the .atom_group info array
   ENSURE(.atom_group.created,"no atom group information")
      n,i :: INT
      stdout.save
      stdout.set_int_width(3)
      stdout.set_n_fields(25)
      stdout.set_use_labels(FALSE)
      stdout.text(" ")
      stdout.text("Atom group information")
      stdout.text(" ")
      stdout.show("n_groups =",.atom_group.dim)
      do n = 1,.atom_group.dim
         stdout.put_text("group "// trim(n.to_str) //"  =")
         do i = 1,.atom_group(n).element.dim
            stdout.put(.atom_group(n).element(i))
         end
         stdout.flush
      end
      if (.group_charges.created) then
         stdout.put_text("group charges =")
         do i = 1,.group_charges.dim
            stdout.put(.group_charges(i))
         end
      end
      if (.mos_per_group.created) then
         stdout.put_text("mos_per_group =")
         do i = 1,.mos_per_group.dim
            stdout.put(.mos_per_group(i))
         end
      end
      stdout.unsave
   end

   put_overlapping_atoms
   ! Out out the .atom_group info array
   ENSURE(.overlapping_atoms.created,"no overlapping_atoms")
   ENSURE(.atom.created,"no atoms")
      i,j,k :: INT
      stdout.save
      stdout.set_int_width(4)
      stdout.set_n_fields(25)
      stdout.set_use_labels(FALSE)
      stdout.text(" ")
      stdout.text("Overlapping atoms:")
      stdout.text(" ")
      do i = 1,.atom.dim
         k = 1
         stdout.put(i)
         do j = 1,.atom.dim
            if (NOT .is_overlapping_atom(i,j)) cycle
            k = k + 1
            stdout.put(j)
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end
      stdout.unsave
   end

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put
   end

   put_plotgrid
   ! Output the current grid.
   ENSURE(.grid.created,"no plot grid to output")
     .grid.put
   end

   put_dftgrid
   ! Output the current DFT grid.
   ENSURE(.dftgrid.created,"no DFT grid to output")
     .dftgrid.put
   end

   put_becke_grid
   ! Output the current DFT grid.
   ENSURE(.becke_grid.created,"no Becke integration grid to output")
     .becke_grid.put
   end

   put_crystal
   ! Output the current crystal
      if (.atom.created) then; .crystal.put(.atom)
      else;                    .crystal.put
      end
   end

   put_cluster
   ! Put out the cluster information
   ENSURE(.cluster.created,"no cluster data")
      .cluster.put
   end

   put_crystal_reflection_data
   ! Output the current crystal
      .crystal.put_reflection_data
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_mos_and_energies
   ! Output the current associated molecular orbitals and their energies
      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.orbital_energies, format="column")
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put(.occupation_numbers, format="column")
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix
   ENSURE(.density_matrix.created,"no density matrix")
      stdout.flush
      stdout.text("Density matrix:")
      stdout.put(.density_matrix)
   end

   put_fock_matrix
   ! Output the current associated fock matrix
   ENSURE(.fock_matrix.created,"no fock matrix")
      stdout.flush
      stdout.text("Fock matrix:")
      stdout.put(.fock_matrix)
   end

   put_PND_sf
   ! Output the magnetic structure factors
      .crystal.put_PND_sf(.name)
   end

   put_current_time(timer)
   ! Output the current time
      timer :: TIME
      stdout.text(timer.current_time)
   end

   put_time_taken(timer)
   ! Output the time taken as given by the "timer" object
      timer :: TIME
      stdout.text(timer.time_taken)
   end

   put_total_time
   ! Output the total time
      stdout.text(std_time.time_taken)
   end

   put_vrml
   ! Output a VRML file for the coordinate geometry
   ENSURE(.atom.created,"no atom list!")
     out :: TEXTFILE*
     out.create(trim(.name)//achar(46)//"wrl")
     out.open(for="write")
     stdout.text("Generating VRML molecule")
     out.text("#VRML V2.0 utf8")
     out.text("NavigationInfo { type " // achar(34) // "EXAMINE" // achar(34) // " }")
     out.text("Viewpoint { ")
     out.text("position 0 0 10")
     out.text("fieldOfView 1")
     out.text("orientation 0 0 1 0")
     out.text('description "camera z"')
     out.text("}")
     out.text("DirectionalLight {")
     out.text("  color 1 1 1")
     out.text("  direction 1 0 0")
     out.text("  intensity 0.4")
     out.text("}")
     .atom.put_vrml(out)
     if (.isosurface.created) .isosurface.put_vrml(out)
     stdout.text("done VRML molecule")
   end

   put_1e_properties
   ! Put all the available one elctron properties
   ENSURE(.density_matrix.created,"no density")
   ENSURE(.atom.created,"no atoms")
   ENSURE(.basis.created,"no basis sets specified")
      .put_mulliken_populations
      .put_dipole
      .put_quadrupole
      .put_octupole
      .put_E_field_at_nuclei
      .put_EFG_at_nuclei
   end

   put_dipole
   ! Put out the dipole to stdout
      electronic,nuclear,total :: VEC{REAL}(3)
      dmag :: REAL
      axis :: VEC{STR}(3)
      i :: INT
      axis = [ "x", "y", "z" ]
      electronic = .electronic_dipole_moment
      nuclear    = .nuclear_dipole_moment
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Dipole moments:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.put("/Debye")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,3
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye"))
         stdout.put(nuclear(i).to_units("debye"))
         stdout.put(total(i).to_units("debye"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)
      stdout.flush
      dmag = sqrt(dot_product(total,total))
      stdout.show("Dipole magnitude/au    =",dmag)
      stdout.show("Dipole magnitude/Debye =",dmag.to_units("debye"))
   end

   put_quadrupole
   ! Put out the quadrupole to stdout
      electronic,nuclear,total :: VEC{REAL}(6)
      axis :: VEC{STR}(6)
      i :: INT
      axis = [ "xx","yy","zz","xy","xz","yz" ]
      electronic = .electronic_quadrupole_moment
      nuclear    = .nuclear_quadrupole_moment
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Quadrupole moments:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye-A")
      stdout.put("/Debye-A")
      stdout.put("/Debye-A")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,6
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye-angstrom"))
         stdout.put(nuclear(i).to_units("debye-angstrom"))
         stdout.put(total(i).to_units("debye-angstrom"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)
   end

   put_octupole
   ! Put out the octupole to stdout
      electronic,nuclear,total :: VEC{REAL}(10)
      axis :: VEC{STR}(10)
      i :: INT
      axis = [ "xxx","yyy","zzz","xxy","xxz","yyx","yyz","zzx","zzy","xyz" ]
      electronic = .electronic_octupole_moment
      nuclear    = .nuclear_octupole_moment
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Octupole moments:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      stdout.tab(int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Component",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/Debye-A2")
      stdout.put("/Debye-A2")
      stdout.put("/Debye-A2")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=6)
      do i = 1,10
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i))
         stdout.put(nuclear(i))
         stdout.put(total(i))
         stdout.put(electronic(i).to_units("debye-angstrom^2"))
         stdout.put(nuclear(i).to_units("debye-angstrom^2"))
         stdout.put(total(i).to_units("debye-angstrom^2"))
         stdout.flush
      end
      stdout.dash(int_fields=1,real_fields=6)
   end

   put_E_field_at_nuclei
   ! Put out the electric field at every nuclear position
      electronic,nuclear,total :: MAT{REAL}*
      axis :: VEC{STR}(3)
      symbol :: VEC{STR}*
      a,i :: INT
      axis = [ "x", "y", "z" ]
      symbol => .numbered_chemical_symbols
      electronic.create(3,.n_atom)
      nuclear.create(3,.n_atom)
      total.create(3,.n_atom)
      electronic = .electronic_E_field_at_nuclei
      nuclear    = .nuclear_E_field_at_nuclei
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Electric fields at nuclei:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.tab(real_fields=1,int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Atom")
      stdout.put("E_i",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_atom
      do i = 1,3
         if (i==1) then; stdout.put(symbol(a))
         else;           stdout.tab(real_fields=1)
         end
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i,a))
         stdout.put(nuclear(i,a))
         stdout.put(total(i,a))
         stdout.flush
      end
      end
      stdout.dash(int_fields=1,real_fields=4)
      total.destroy
      nuclear.destroy
      electronic.destroy
      symbol.destroy
   end

   put_EFG_at_nuclei
   ! Put out the electric field gradient at every nuclear position
      electronic,nuclear,total :: MAT{REAL}*
      axis :: VEC{STR}(6)
      symbol :: VEC{STR}*
      a,i :: INT
      axis = [ "xx","yy","zz","xy","xz","yz" ]
      symbol => .numbered_chemical_symbols
      electronic.create(6,.n_atom)
      nuclear.create(6,.n_atom)
      total.create(6,.n_atom)
      electronic = .electronic_EFG_at_nuclei
      nuclear    = .nuclear_EFG_at_nuclei
      total      = electronic + nuclear
      stdout.flush
      stdout.text("Electric field gradient at nuclei:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      stdout.tab(real_fields=1,int_fields=1)
      stdout.put("Electronic")
      stdout.put("Nuclear")
      stdout.put("Total")
      stdout.flush
      stdout.put("Atom")
      stdout.put("E_ij",int_width=TRUE)
      stdout.put("/au")
      stdout.put("/au")
      stdout.put("/au")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=4)
      do a = 1,.n_atom
      do i = 1,6
         if (i==1) then; stdout.put(symbol(a))
         else;           stdout.tab(real_fields=1)
         end
         stdout.put(axis(i),int_width=TRUE)
         stdout.put(electronic(i,a))
         stdout.put(nuclear(i,a))
         stdout.put(total(i,a))
         stdout.flush
      end
      end
      stdout.dash(int_fields=1,real_fields=4)
      total.destroy
      nuclear.destroy
      electronic.destroy
      symbol.destroy
   end

   numbered_chemical_symbols result (res) ::: leaky
   ! Return a list of numbered chemical symbols
      res :: VEC{STR}*
   ENSURE(.atom.created,"no atom list")
      res.create(.atom.dim)
      res = .atom(:).numbered_chemical_symbols
   end

!  ***********
!  SCF methods
!  ***********

   set_scf_defaults(use_ks) ::: leaky
   ! Set up scf defaults for molecule
   ! If present and TRUE, "use_ks" tells to use a Kohn-Sham calculation not HF
      use_ks :: BIN, optional
      ks :: BIN
      ks = FALSE
      if (present(use_ks)) ks = use_ks
      if (.scfdata.destroyed) then; .scfdata.create
      else;                         .scfdata.set_defaults
      end
      if (ks) then
         if (.mult==1) .scfdata.scf_kind = "rks"
         if (.mult/=1) .scfdata.scf_kind = "uks"
      else
         if (.mult==1) .scfdata.scf_kind = "rhf"
         if (.mult/=1) .scfdata.scf_kind = "uhf"
      end
      .scfdata.using_fock_diis = TRUE
      .scfdata.using_MO_diis = FALSE
      .scfdata.using_direct_scf = TRUE
      .scfdata.diis.set_archive_root_name(.name)
      .initialise_DFT_grids
   end

   make_molecule_from_atom(n,mol,use_ks) ::: leaky
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
   ! The new molecule is ready for an SCF calculation.
      n :: INT
      mol :: MOLECULE
      use_ks :: BIN, optional
   ENSURE(n<=.n_atom,"atom number n too big")
      mol.nullify_ptr_part
      mol.name = .atom(n).chemical_symbol
      mol.atom.create(1)
      mol.atom = .atom(n)   ! WARNING: dont destroy ptr parts of mol.atom !
      mol.atom(1).group = 0 ! does not belong to a group
      mol.atom(1).pos = (/ZERO,ZERO,ZERO/)
      mol.set_defaults
      mol.basis => .basis ! WARNING: dont destroy basis of mol !
      mol.slaterbasis => .slaterbasis
      mol.coppensbasis => .coppensbasis
      mol.set_basis_info
      mol.set_scf_defaults(use_ks)
      if (.scfdata.created) then
         mol.scfdata.output = .scfdata.guess_output ! assume this is a guess
         mol.scfdata.convergence = .scfdata.convergence
         mol.scfdata.diis.convergence_tolerance = .scfdata.diis.convergence_tolerance
         mol.scfdata.using_rough_convergence = .scfdata.using_rough_convergence
      end
   end

   make_molecule_from_atom_group(n,mol) ::: leaky
   ! Make a fully fledged molecule "mol" from group "n" of atoms
   ! specified in .atom_group(n).element(:), ready fro an SCF calculation.
      n :: INT
      mol :: MOLECULE
   ENSURE(.atom_group.created,"no atom_group info")
   ENSURE(n<=size(.atom_group),"group number n too big")
      mol.nullify_ptr_part
      mol.atom.create(size(.atom_group(n).element))
      mol.atom = .atom(.atom_group(n).element) ! WARNING: dont destroy ptr parts of mol.atom !
      mol.set_defaults
      if (.group_charges.created) mol.charge = .group_charges(n)
      mol.mult = mol.default_multiplicity
      mol.set_atom_info
      mol.name  =  trim(.name) // "_group_" // trim(n.to_str)
      mol.basis => .basis ! WARNING: dont destroy basis of mol !
      mol.slaterbasis => .slaterbasis
      mol.coppensbasis => .coppensbasis
      mol.set_basis_info
      mol.set_scf_defaults
      if (.scfdata.created) then
         mol.scfdata.output = .scfdata.guess_output ! assume this is a guess
         mol.scfdata.convergence = .scfdata.convergence
         mol.scfdata.diis.convergence_tolerance = .scfdata.diis.convergence_tolerance
         mol.scfdata.using_rough_convergence = .scfdata.using_rough_convergence
      end
   end

!  ************
!  SCF routines
!  ************

   scf ::: recursive, leaky
   ! Do an SCF calculation. The following :
   !   .molecular_orbitals, .orbital_energies, .density_matrix
   ! are produced as results.
   ENSURE(.scfdata.created,"no scfdata provided")
     select case (.scfdata.scf_kind)
       case ("embedded_rhf")
         .embedded_scf
       case ("crystal_rhf")
         .crystal_scf
       case ("xray_rhf","xray_rks","xray_uhf","xray_uks", &
             "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         .constrained_scf
       case default
         .usual_scf
     end
   end

   usual_scf ::: recursive, leaky
   ! Do an SCF calculation. The following :
   !   .molecular_orbitals, .orbital_energies, .density_matrix
   ! are produced as results.
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     .initialise_scf
     .put_scf_results
     do
       if (.scfdata.scf_done) exit
       .accelerate_fock_matrix
       .update_molecular_orbitals
     ! .schmidt_orthonormalise_MOs
       .make_scf_density_matrix
       .make_fock_matrix
       .update_scfdata
       .update_scfdata_error
       .put_scf_results
     ! if (.scfdata.diis.iteration==2) .test_average_energy
     end
     .archive_scf_results
     .cleanup_scf
   end

   put_scf_results
   ! Put out the SCF results
     if (.scfdata.iteration==0 AND .scfdata.lambda_iteration==0) then
        .scfdata.put_banner
        if (.scfdata.fitting) then
           if (.crystal.xray_data.created AND .scfdata.scf_kind.includes("xray")) then
              .crystal.assign_xray
              stdout.flush
              stdout.text("X-ray correction data:")
              .crystal.put_correction_data
           end
           if (.crystal.pnd_data.created AND .scfdata.scf_kind.includes("pnd")) then
              .crystal.assign_pnd
              stdout.flush
              stdout.text("PND correction data:")
              .crystal.put_correction_data
           end
        end
     end
     .scfdata.put_results
   end

   initialise_scfdata
   ! Initialise the scf data, including iteration counters
   ENSURE(.scfdata.created,"no scfdata")
     .scfdata.reset                         ! Reset everything (except DFT parts)
     .scfdata.nuclear_energy = .nuclear_energy
     .scfdata.kinetic_energy = .kinetic_energy
     .scfdata.set_energy(.scf_energy,.crystal)
   end

   update_scfdata
   ! Update the scf iteration count, scf energy and property data. The energy
   ! differences are used to test for convergence in the SCF procedure.
   ENSURE(.scfdata.created,"no scfdata")
     .scfdata.update_iteration
     .scfdata.kinetic_energy = .kinetic_energy
     .scfdata.update_energy(.scf_energy,.crystal)
   end

   initialise_scfdata_error
   ! Reset the scfdata gradient of the SCF energy with respect to orbital
   ! rotations, otherwise known as the "diis error". This is used to check for
   ! SCF convergence.
     diis_error :: REAL
     .make_diis_error_length(diis_error)
     .scfdata.set_diis_error(diis_error)
   end

   update_scfdata_error
   ! Update the scfdata gradient of the SCF energy with respect to orbital
   ! rotations, otherwise known as the "diis error". This is used to check for
   ! SCF convergence.
     diis_error :: REAL
     .make_diis_error_length(diis_error)
     .scfdata.set_diis_error(diis_error)
   end

   initialise_max_I ::: leaky
   ! Initialise Schwarz inequality test integrals
     .max_I.destroy
     .max_I.create(.n_shell_pairs)
     .make_max_abab_integrals(.max_I)
   end

   initialise_scf ::: leaky
   ! Initialise the SCF procedure
   ENSURE(.scfdata.created,"no scfdata provided")
     scf_kind :: STR
     scf_kind = .scfdata.scf_kind
     select case (scf_kind)
       case ("embedded_rhf")
         .initialise_embedded_scf
       case ("crystal_rhf")
         .initialise_crystal_scf
       case ("xray_rhf","xray_rks","xray_uhf","xray_uks", &
             "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
         .initialise_constrained_scf
       case default;
         .initialise_usual_scf
     end
     ! Do Schwarz inequality test integrals
     .initialise_max_I ! leaky
   end

   initialise_usual_scf ::: leaky
   ! Initialise the usual SCF procedure
     .initialise_DFT_grids
     .get_initial_guess
     .make_fock_matrix
     .initialise_scfdata
     .initialise_scfdata_error
     .scfdata.diis.cleanup
   end

   initialise_constrained_scf ::: leaky
   ! Initialise the constrained SCF procedure
     .initialise_DFT_grids
   ! .scfdata.using_rough_convergence = FALSE
     .get_initial_guess
     .make_fock_matrix
     .make_constraint_data
     .initialise_scfdata
     .add_constraint_to_fock_matrix
     .initialise_scfdata_error
     .scfdata.diis.cleanup
   end

   initialise_DFT_grids ::: leaky
   ! Initialise DFT grids, if not already done so.
     if (NOT .scfdata.is_DFT_calculation) return
     if (.becke_grid.destroyed) then
       .becke_grid.create
       .becke_grid.set_defaults
       .becke_grid.set_atom_info(.atom.atomic_number &
                                ,.atom.transposed_coordinates &
                                ,.atom.minimum_basis_exponents &
                                ,.atom) ! leaky
       .becke_grid.set_grid_data
     end
     .make_overlapping_atoms
   ! .becke_grid.put
   ! .becke_grid.put_atom_info
   ! .becke_grid.put_radial_angular_grids
   ! .becke_grid.put_unique_atom_grids
   end

!   test_average_energy
!   ! Test the avergae energy for UEDIIS
!     D,F,C,W :: OPMATRIX*
!     if (.name/="h2o-") return
!       F.create(.n_bf,"unrestricted")
!       D.create(.n_bf,"unrestricted")
!       W.create(.n_bf,"unrestricted")
!       C.create(.n_bf,"unrestricted")
!       D.set_to_zero
!       .unarchive(W,"DIIS,density_matrix,1")
!     ! D.plus_scaled(W,fac=0.3d0)
!       D.alpha = D.alpha + 0.3d0*W.alpha
!       D.beta  = D.beta  + 0.4d0*W.beta 
!       .unarchive(W,"DIIS,density_matrix,2")
!     ! D.plus_scaled(W,fac=0.7d0)
!       D.alpha = D.alpha + 0.7d0*W.alpha
!       D.beta  = D.beta  + 0.6d0*W.beta 
!       F.set_to_zero
!       .unarchive(W,"DIIS,fock_matrix,1")
!       .unarchive(C,"DIIS,fock_matrix,1")
!     ! F.plus_scaled(W,fac=0.3d0)
!       F.alpha = F.alpha + 0.3d0*(W.alpha-C.beta) + 0.4d0*C.beta
!       F.beta  = F.beta  + 0.4d0*(W.beta 
!       .unarchive(W,"DIIS,fock_matrix,2")
!     ! F.plus_scaled(W,fac=0.7d0)
!       F.alpha = F.alpha + 0.7d0*W.alpha
!       F.beta  = F.beta  + 0.6d0*W.beta 
!       stdout.text("===in MOLECULE, averaged energy:")
!       stdout.put(.scf_electronic_energy(D,F))
!       stdout.flush
!       stdout.put(.scf_electronic_energies(D,F))
!       stdout.flush
!       W.destroy
!       D.destroy
!       F.destroy
!!!       F.create(.n_bf,"restricted")
!!!       D.create(.n_bf,"restricted")
!!!       W.create(.n_bf,"restricted")
!!!       D.set_to_zero
!!!       .unarchive(W,"DIIS,density_matrix,1")
!!!       D.plus_scaled(W,fac=0.3d0)
!!!       .unarchive(W,"DIIS,density_matrix,2")
!!!       D.plus_scaled(W,fac=0.7d0)
!!!       F.set_to_zero
!!!       .unarchive(W,"DIIS,fock_matrix,1")
!!!       F.plus_scaled(W,fac=0.3d0)
!!!       .unarchive(W,"DIIS,fock_matrix,2")
!!!       F.plus_scaled(W,fac=0.7d0)
!!!       stdout.text("===averaged energy:")
!!!       stdout.put(.scf_electronic_energy(D,F))
!!!       stdout.flush
!!!       W.destroy
!!!       D.destroy
!!!       F.destroy
!   end

!  ************
!  Embedded SCF
!  ************

   embedded_scf ::: leaky
   ! Do an SCF calculation for a molecular fragment embedded in a crystal
   ! generated cluster. The .molecular_orbitals and .orbital_energies are
   ! obtained for the embedded fragment. The .density_matrix is obtained for the
   ! whole cluster. There must be a pre-existing cluster, and self must be the
   ! same as this cluster. Also, there must be a .saved molecule representing
   ! the embedded fragment whose orbitals are obtained.
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.cluster.created,"no cluster")
   ENSURE(.saved.created,"no saved fragment molecule")
   ENSURE(.saved.molecular_orbitals.created,"no saved molecular orbitals")
     .initialise_scf
     .put_scf_results
     do
       if (.scfdata.scf_done) exit
   !  stderr.show("iteration =",.scfdata.iteration)
       .add_cluster_projector(.fock_matrix,.molecular_orbitals)
       .accelerate_fock_matrix
       ! Get back the fragment MO's
   !  stderr.text("unarchive and update MOs:")
       .unarchive_molecular_orbitals
       .update_molecular_orbitals
   !  stderr.text("Molecular orbital energies:")
   !  stderr.put(.orbital_energies, format="column")
       ! Symmetry transform the occupied MO's around the crystal cluster.
       ! This stuffs up the fragment MO's.
   !  stderr.text("transform embedded MOs:")
       .transform_embedded_orbitals(.molecular_orbitals,do_virtual=FALSE)
       ! This is the cluster density matrix
   !  stderr.text("Make cluster density:")
       .make_scf_density_matrix(n_a=.saved.n_a*.cluster.n_fragment_symop) 
       ! This is the cluster fock matrix
   !  stderr.text("Make cluster fock:")
       .make_fock_matrix
       ! Now make the fragment density matrix, and update info
       .make_scf_density_matrix(n_a=.saved.n_a,damp=FALSE) 
       .update_scfdata
       .update_scfdata_error
       .put_scf_results
     end
     .archive_scf_results
     .cleanup_scf
   end

   initialise_embedded_scf ::: leaky
   ! Initialise the embedded SCF procedure
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.saved.created,"no saved molecule")
   ENSURE(.cluster.created,"no cluster")
   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
      .initialise_DFT_grids
      ! Initialise and archive the MO's
      .initialise_embedded_orbitals
      .transform_embedded_orbitals(.molecular_orbitals,do_virtual=TRUE)
      .archive_molecular_orbitals
      ! This is the cluster density matrix
      .make_scf_density_matrix(n_a=.saved.n_a*.cluster.n_fragment_symop,damp=FALSE) 
      ! This is the cluster fock matrix
      .make_fock_matrix        
      ! Now we have back the fragment density matrix
      .make_scf_density_matrix(n_a=.saved.n_a,damp=FALSE) 
      .initialise_scfdata
      .initialise_scfdata_error
      .scfdata.diis.cleanup
   end

   initialise_embedded_orbitals ::: leaky
   ! Initialise the embedded cluster .molecular orbitals from those in the
   ! .saved fragment. This does not do any symmetry transformation.
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.saved.created,"no saved molecule")
   ENSURE(.cluster.created,"no cluster")
   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
      nsb,nso,nsv,no,nv :: INT
      nsb = .saved.n_bf
      nso = .saved.n_a
      nsv = nsb - nso
      no  = nso*.cluster.n_fragment_symop
      nv  = nsv*.cluster.n_fragment_symop
      select case (.scfdata.scf_kind)
         case ("embedded_rhf","crystal_rhf")
            .molecular_orbitals.destroy("restricted")
            .molecular_orbitals.restricted.create(.n_bf,.n_bf)
            .molecular_orbitals.restricted = ZERO
            .molecular_orbitals.restricted(1:nsb,1:nso) = .saved.molecular_orbitals.restricted(:,1:nso)
            .molecular_orbitals.restricted(1:nsb,no+1:no+nsv) = .saved.molecular_orbitals.restricted(:,nso+1:nso+nsv)
            .orbital_energies.create(genre=.scfdata.orbital_energies_kind)
         case default
            DIE("unknown or unimplemented SCF kind, "//trim(.scfdata.scf_kind))
      end
   end

   transform_embedded_orbitals(MO,do_virtual)
   ! Transform the (.saved) embedded molecular orbitals "MO" into the crystal
   ! orbitals over the cluster (i.e. this molecule) using crystal symmetry
   ! operations.
      MO :: OPMATRIX*
      do_virtual :: BIN, optional
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.saved.created,"no scfdata")
      select case (.scfdata.scf_kind)
         case ("embedded_rhf","crystal_rhf")
            .transform_embedded_orbitals_r(MO.restricted,do_virtual)
         case default
            DIE("unknown or unimplemented SCF kind, "//trim(.scfdata.scf_kind))
      end
   end

   transform_embedded_orbitals_r(MO,do_virtual) 
   ! Transform the (.saved) embedded molecular orbitals "MO" into the crystal
   ! orbitals over the cluster (i.e. this molecule) using crystal symmetry
   ! operations.
      MO :: MAT{REAL}*
      do_virtual :: BIN, optional
   ENSURE(MO.is_square,"MO is not square")
   ENSURE(MO.dim1==.n_bf,"wrong size for MO")
   ENSURE(.saved.created,"no saved molecule")
   ENSURE(.cluster.created,"no cluster")
   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
      seitz :: MAT3{REAL}*
      tr :: VEC{MAT3_{REAL}}*
      nso,nsv,no,nv,q,op,fo,lo,fv,lv,s,a,fs,ls,sf,sl,p,fp,fa,L :: INT
      do_virt :: BIN
      do_virt = FALSE
      if (present(do_virtual)) do_virt = do_virtual
      seitz => .crystal.xyz_seitz_matrices
      tr.make_gaussian_xyz_matrices(seitz)
      nso = .saved.n_a
      nsv = .saved.n_bf - nso
      no  = nso*.cluster.n_fragment_symop
      nv  = nsv*.cluster.n_fragment_symop
      ! Assume the occupied neighbouring orbitals occur as the end columns (due
      ! to the use of a projection operator of high energy)
    ! MO(:,no+1:no+nv) = MO(:,nso+1:nso+nv)
      MO(:,nso+1:no) = ZERO                    ! to be defined below
      if (do_virt) MO(:,no+nsv+1:no+nv) = ZERO ! to be defined below
      lo = nso
      lv = no+nsv
      do q = 2,.cluster.n_fragment_symop                  ! Loop over generating cluster symops 
         op  = .cluster.fragment_symop(1,q)               ! The seitz op for the cluster symop
         fo = lo + 1
         lo = lo + nso 
         fv = lv + 1
         lv = lv + nsv 
         do s = 1,.n_shell                                ! Loops over shells s in the row i.e. ao's.
            a = .atom_for_shell(s)                        ! The atom for shell s
            p  = .cluster.fragment_parents_for_atom(a,q)  ! Which atom (not necesarily fragment) did "a" come from?
            if (p==0) cycle                               ! No parent? then cycle
            fs = .first_basis_fn_for_shell(s)
            ls = .last_basis_fn_for_shell(s)
            fa = .first_basis_fn_for_atom(a)
            fp = .first_basis_fn_for_atom(p)
            sf = fp + fs - fa                             ! first function for embedded shell
            sl = fp + ls - fa                             ! last  function for embedded shell
            L  = .angular_moment_for_shell(s)
            MO(fs:ls,fo:lo).to_product_of(tr(L)[:,:,op],MO(sf:sl,1:nso))
            if (do_virt) &
            MO(fs:ls,fv:lv).to_product_of(tr(L)[:,:,op],MO(sf:sl,no+1:no+nsv))
         end
      end
      tr.destroy
      seitz.destroy
   end

   collapse_crystal_orbitals_r(MO) ::: leaky
   ! Collapse the crystal orbitals back into the (.saved) embedded fragment
   ! orbitals.
      MO :: MAT{REAL}*
   ENSURE(MO.dim1==.n_bf,"wrong dim1 for MO")
   ENSURE(MO.dim2==.n_bf,"wrong dim1 for MO")
      nso,nsv,no,nv :: INT
      nso = .saved.n_a
      nsv = .saved.n_bf - nso
      no  = nso*.cluster.n_fragment_symop
      nv  = nsv*.cluster.n_fragment_symop
      MO(:,nso+1:nso+nsv) = MO(:,no +1:no+nsv) 
      MO.shrink_columns(nso+nsv) 
   end

   add_cluster_projector(F,MO)
   ! Add the cluster projector to the fock matrix "F" using the molecular
   ! orbitals "MO. This ensures that the occupied orbitals are orthogonal to the
   ! occupied orbitals of neighbouring molecules.
     F,MO :: OPMATRIX*
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(F.created,"no Fock matrix")
   ENSURE(F.any_created,"no Fock matrix")
   ENSURE(F.spinorbital_kind==.scfdata.spinorbital_kind,"incompatible Fock matrix")
     P,S :: MAT{REAL}*
     k,l :: INT
     scf_kind :: STR
     scf_kind = .scfdata.scf_kind
     select case (scf_kind)
        case ("rhf","xray_rhf","embedded_rhf","crystal_rhf")
           k = .saved.n_a + 1
           l = .saved.n_a*.cluster.n_fragment_symop
           P.create(.n_bf,.n_bf)
           S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
           P.to_product_of(MO.restricted(:,k:l),MO.restricted(:,k:l),transpose_b=TRUE)
           P.change_basis_using(S)
           .fock_matrix.restricted = .fock_matrix.restricted + .scfdata.kappa*P
           S.destroy
           P.destroy
        case default
           DIE("unknown or unimplemented SCF kind, "//trim(scf_kind))
     end
   end

!   transform_embedded_orbitals(MO)
!   ! Transform the embedded orbitals "MO".
!      MO :: MAT{REAL}
!      seitz :: MAT3{REAL}*
!      tr :: VEC{MAT3_{REAL}}*
!      n_embedded_bf,n_embedded_shell :: INT
!      i,ai,fi,li,if,il,j,aj,fj,lj,jf,jl, q,u,f,p,fa,fp,L :: INT
!      n_embedded_bf = .saved.n_bf
!      n_embedded_shell = .saved.n_shell
!      seitz => .crystal.xyz_seitz_matrices
!      tr.make_gaussian_xyz_matrices(seitz)
!      do i = n_embedded_shell+1,.n_shell                  ! Loop over group i of shells (orbitals) in column
!         ai = .atom_for_shell(i)                          ! The atom that the orbitals in group i belong to 
!         q  = .cluster.fragment_symop_for_atom(ai)        ! Which symop generated these shells? 
!     !   u  = .cluster.unit_cell_atom_for_atom(ai)
!     !   f  = .crystal.frag_cell_for_unit_cell_atom(u)
!     !   p  = .crystal.frag_atom_for_frag_cell_atom(f)    ! Which fragment atom did "ai" come from?
!         p  = .cluster.fragment_parents_for_atom(ai,q)    ! Which fragment atom did "ai" come from?
!         fi = .first_basis_fn_for_shell(i)
!         li = .last_basis_fn_for_shell(i)
!         fa = .first_basis_fn_for_atom(ai)
!         fp = .saved.first_basis_fn_for_atom(p)
!         if = fp + fi - fa                                ! first function for embedded shell
!         il = fp + li - fa                                ! last  function for embedded shell
!     !      stdout.text("======================================") 
!     !      stdout.show("shell i                  = ",i) 
!     !      stdout.show("atom ai for shell i      = ",ai) 
!     !      stdout.show("parent p for atom a      = ",p) 
!     !      stdout.show("clust symop q for atom a = ",q) 
!     !      stdout.show("first fn for shell i, fi = ",fi) 
!     !      stdout.show("last  fn for shell i, li = ",li) 
!     !      stdout.show("first fn for atom a,  fa = ",fa) 
!     !      stdout.show("first fn for atom p,  fp = ",fp) 
!     !      stdout.show("first embedded fn,    if = ",if) 
!     !      stdout.show("last  embedded fn,    il = ",il) 
!         do j = 1,.n_shell                                ! Loops over shells s in the row i.e. ao's.
!            aj = .atom_for_shell(j)                       ! The atom for shells s
!            p  = .cluster.fragment_parents_for_atom(aj,q) ! Which atom (not necesarily fragment) did "a" come from?
!            if (p==0) cycle
!            fj = .first_basis_fn_for_shell(j)
!            lj = .last_basis_fn_for_shell(j)
!            fa = .first_basis_fn_for_atom(aj)
!            fp = .first_basis_fn_for_atom(p)
!            jf = fp + fj - fa                             ! first function for embedded shell
!            jl = fp + lj - fa                             ! last  function for embedded shell
!            L  = .angular_moment_for_shell(j)
!     !      stdout.flush
!     !      stdout.show("shell j                  = ",j) 
!     !      stdout.show("atom aj for shell j      = ",aj) 
!     !      stdout.show("parent p for atom a      = ",p) 
!     !      stdout.show("clust symop q for atom a = ",q) 
!     !      stdout.show("first fn for shell j, fj = ",fj) 
!     !      stdout.show("last  fn for shell j, lj = ",lj) 
!     !      stdout.show("first fn for atom a,  fa = ",fa) 
!     !      stdout.show("first fn for atom p,  fp = ",fp) 
!     !      stdout.show("first embedded fn,    jf = ",jf) 
!     !      stdout.show("last  embedded fn,    jl = ",jl) 
!     !      stdout.flush
!            MO(fj:lj,fi:li).to_product_of(tr(L)[:,:,q],MO(jf:jl,if:il))
!         end
!      end
!      tr.destroy
!      seitz.destroy
!   end

!  ***********
!  Crystal SCF
!  ***********

   crystal_scf ::: leaky
   ! Do an SCF calculation for a molecular fragment embedded in a crystal
   ! generated cluster. The .molecular_orbitals and .orbital_energies are
   ! obtained for the embedded fragment. The .density_matrix is obtained for the
   ! whole cluster. There must be a pre-existing cluster, and self must be the
   ! same as this cluster. Also, there must be a .saved molecule representing the
   ! embedded fragment whose orbitals are obtained.
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.cluster.created,"no cluster")
   ENSURE(.saved.created,"no saved fragment molecule")
   ENSURE(.saved.molecular_orbitals.created,"no saved molecular orbitals")
     .initialise_scf
     .put_scf_results
     do
       if (.scfdata.scf_done) exit
   !  stderr.show("iteration =",.scfdata.iteration)
       .add_cluster_projector(.fock_matrix,.molecular_orbitals)
       .accelerate_fock_matrix
       ! Get back the fragment MO's
   !  stderr.text("unarchive and update MOs:")
       .unarchive_molecular_orbitals
       .update_molecular_orbitals
   !  stderr.text("Molecular orbital energies:")
   !  stderr.put(.orbital_energies, format="column")
       ! Symmetry transform the occupied MO's around the crystal cluster.
       ! This stuffs up the fragment MO's.
   !  stderr.text("transform embedded MOs:")
       .transform_embedded_orbitals(.molecular_orbitals,do_virtual=FALSE)
       ! This is the cluster density matrix
   !  stderr.text("Make cluster density:")
       .make_scf_density_matrix(n_a=.saved.n_a*.cluster.n_fragment_symop) 
       ! This is the cluster fock matrix
   !  stderr.text("Make cluster fock:")
       .make_fock_matrix
       ! Now make the fragment density matrix, and update info
       .make_scf_density_matrix(n_a=.saved.n_a,damp=FALSE) 
       .update_scfdata
       .update_scfdata_error
       .put_scf_results
     end
     .archive_scf_results
     .cleanup_scf
   end

   initialise_crystal_scf ::: leaky
   ! Initialise the crystal SCF procedure
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.saved.created,"no saved molecule")
   ENSURE(.cluster.created,"no cluster")
   ENSURE(.cluster.n_fragment_symop>0,"no cluster fragment symops")
   ENSURE(.n_bf==.saved.n_bf*.cluster.n_fragment_symop,"cluster is not a whole multiple of the fragment")
      ! Initialise and archive the MO's
      .initialise_embedded_orbitals
      .transform_embedded_orbitals(.molecular_orbitals,do_virtual=TRUE)
      .archive_molecular_orbitals
      ! This is the cluster density matrix
      .make_scf_density_matrix(n_a=.saved.n_a*.cluster.n_fragment_symop,damp=FALSE) 
      ! This is the cluster fock matrix
      .make_fock_matrix        
      ! Now we have back the fragment density matrix
      .make_scf_density_matrix(n_a=.saved.n_a,damp=FALSE) 
      .initialise_scfdata
      .initialise_scfdata_error
      .scfdata.diis.cleanup
   end
 
   make_periodic_fmm_levels ::: leaky
   ! Make a multipole representation of the entire crystal, from the charge
   ! density of the unit cell.
      self :: target
   ENSURE(.atom.created,"Need a list of atoms")
   ENSURE(.crystal.created,"no crystal data")
   ENSURE(.dftgrid.created,"Need saved DFT grid")
   ENSURE(.molecular_orbitals.created,"Need saved molecular orbitals")
      fmm :: PERIODIC_FMM_LEVEL*
      values,charges :: VEC{REAL}*
      positions :: MAT{REAL}*
      level_max,l_max,n_pts,n_charges :: INT
      ! Get the level the depth, from the crystallite size
      fmm.create(self)
      level_max = fmm.level_max
      fmm.destroy
      ! Assign the natural orbitals ready to evaluate charges, then make the
      ! effective charges
      .assign_NOs_to_MOs
      .set_crystal_scf_occupations
      n_charges = (.dftgrid.n_pts+1)*.n_atom
      values.create(n_charges)
      charges.create(n_charges)
      positions.create(3,n_charges)
      .make_effective_charges(charges,positions)
      ! Create the hierarchy of crystal multipoles and determine the maximum
      ! multipole order l_max
      .periodic_fmm_level.create(0,level_max,self,charges,positions)
      .periodic_fmm_level.make_positions_and_charges
      .periodic_fmm_level.make_box_charges
      .periodic_fmm_level.set_l_max
      l_max = maxval(.periodic_fmm_level(:).l_max)
    ! .periodic_fmm_level.put
      ! Now make the multipoles
      .periodic_fmm_level.make_box_multipoles(l_max)
    ! .periodic_fmm_level.put
    ! .periodic_fmm_level.make_potential(values)
   end

   set_crystal_scf_occupations
   ! Set the SCF occupation numbers for the natural orbitals
   ENSURE(.saved.created,"no saved molecule fragment")
      NO_kind :: STR
      n_a,n_b,n_e :: INT
      n_a = .saved.n_a
      n_b = .saved.n_b
      n_e = .saved.n_e
      NO_kind = .natural_orbitals.spinorbital_kind
      select case (NO_kind)
         case ("restricted")
            .occupation_numbers.restricted(1:n_a) = TWO
         case ("unrestricted")
            .occupation_numbers.alpha(1:n_a) = ONE
            .occupation_numbers.beta(1:n_b) = ONE
         case ("general")
            .occupation_numbers.general(1:n_e) = ONE
         case ("restricted_complex")
            .occupation_numbers.restricted(1:n_a) = TWO
         case ("unrestricted_complex")
            .occupation_numbers.alpha(1:n_a) = ONE
            .occupation_numbers.beta(1:n_b) = ONE
         case ("general_complex")
            .occupation_numbers.general(1:n_e) = ONE
      end
   end

   make_effective_charges(charges,positions)
   ! Make a list of effective point charges that accurately represents the total
   ! charge of the unit cell.  Includes contributions from electrons and nuclei.
   ! NOTE: this is normally called on a .saved fragment
     charges :: VEC{REAL}, target
     positions :: MAT{REAL}, target
   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.n_atom,"charges has wrong size")
   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
   ENSURE(.atom.created,"Need a list of atoms")
   ENSURE(.dftgrid.created,"no DFT grid")
     ch,wt,rho,deficit :: VEC{REAL}*
     pt :: MAT{REAL}*
     shift,pos3 :: VEC{REAL}(3)
     n_pt,n,i,f,l,ff,ll :: INT
     Z,val :: REAL
     ! Make the effective electronic charges "ch" and positions "pt"
     n_pt = .dftgrid.n_pts*.n_atom
     ch.create(n_pt); pt.create(n_pt,3)
     wt.create(n_pt); rho.create(n_pt)
     .dftgrid.make_grid(pt,wt,.atom)
     .make_density_grid(rho,pt)
     ch = -rho*wt
     rho.destroy; wt.destroy
   ! stdout.set_real_style("e")
   ! stdout.text("charges:")
   ! stdout.put(ch,"column")
   ! stdout.text("pt:")
   ! stdout.put(pt)
     ! First get the atomic charges, which are assigned to balance the
     ! electronic charge in case the DFT integration grid is poor.
     deficit.create(.n_atom)
     n_pt = .dftgrid.n_pts
     l = 0
     do n = 1,.n_atom
        f = l + 1
        l = l + n_pt
        Z = ZERO
        do i = f,l
           Z = Z + ch(i)
        end
        deficit(n) = -Z
     end
     ! Now set the full "charges" and "positions" arrays, including the
     ! (corrected) atomic charges, at the end of the list
     l = 0
     ll = 0
     do n = 1,.n_atom
        f  = l  + 1
        l  = l  + n_pt
        ff = ll + 1
        ll = ll + n_pt
        charges(f:l) = ch(ff:ll)
        positions(:,f:l) = transpose(pt(ff:ll,:))
        l = l + 1
        charges(l) = deficit(n)  
        deficit(n) = .atom(n).atomic_number - deficit(n)
        positions(:,l) = .atom(n).pos
     end
     stdout.set_real_style("e")
     stdout.flush
     stdout.text("Deficit charges:")
     stdout.put(deficit,"column")
     stdout.show("sum of deficit charges =",sum(deficit))
     stdout.show("sum of charges         =",sum(charges))
     deficit.destroy
   ! stdout.flush
   ! stdout.text("Charges:")
   ! stdout.flush
   ! stdout.put(charges,"column")
   ! stdout.flush
   ! stdout.text("Positions:")
   ! stdout.flush
   ! stdout.put(positions,"transpose")
     stdout.set_real_style("f")
     pt.destroy; ch.destroy
   end

!   make_uc_effective_charges(charges,positions)
!   ! Make a list of effective point charges that accurately represents the total
!   ! charge of the unit cell.  Includes contributions from electrons and nuclei.
!     charges :: VEC{REAL}, target
!     positions :: MAT{REAL}, target
!   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.n_atom,"charges has wrong size")
!   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
!   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
!   ENSURE(.atom.created,"Need a list of atoms")
!   ENSURE(.saved.dftgrid.created,"no DFT grid")
!     ch,wt,rho,deficit :: VEC{REAL}*
!     pt :: MAT{REAL}*
!     shift,pos3 :: VEC{REAL}(3)
!     n_pt,n,i,f,l,ff,ll :: INT
!     ZZ,val :: REAL
!
!     pos,new_pos :: MAT{REAL}*
!     Z,n_ch,n_pt,n,f,l,s :: INT
!
!     stdout.text("making saved dft grid")
!     n_ch = .saved.dftgrid.n_pts
!     n_pt = .saved.dftgrid.n_pts
!     ch.create(n_pt)
!     pos.create(3,n_pt)
!     .saved.dftgrid.make_grid(pos,wt,.saved.atom)
!     ! Change fragment positions into fractionals
!     .crystal.unit_cell.change_into_fractional(pos)
!     new_pos.create(pos.dim1,pos.dim2)
!     ! Use symmetry to generate the effective charges and their positions in the
!     ! whole unit cell. This assumes that the fragment cell is generated from
!     ! the *whole* fragment by .crystal.Z symops.
!     l = 0
!     do n = 1,Z
!        f = l + 1
!        l = l + n_ch
!        .charges(f:l) = .fragment_charges
!        new_pos = pos
!        s = .crystal.symop_for_frag_cell_atom(1+(n-1)*.crystal.n_fragment_atoms)
!        .crystal.transform_geometry(new_pos,op=s)
!        .crystal.put_to_unit_cell(new_pos)
!        .positions(:,f:l) = new_pos ! in cartesians
!     end
!     new_pos.destroy; pos.destroy
!
!     do n = 1,.n_atoms          ! Loop over atoms in whole cluster
!     do q = 1,.n_fragment_symop ! Loop over fragment symops
!        child = .geometry(:,n)  ! Get the image of the parent p under the fragment symop s
!        op = int(.fragment_symop(1,q))
!        tr = .fragment_symop(2:4,q)
!        .crystal.transform_position(child,op,tr)
!        if (NOT .geometry.has_column(child,col=c)) cycle
!        .fragment_parents_for_atom(c,q) = n
!     end
!     end
!
!     ! Make the effective electronic charges "ch" and positions "pt"
!     Z = .n_atom/.saved.n_atom
!     n_pt = .saved.dftgrid.n_pts*Z
!     stdout.show("n_pt =",n_pt)
!     ch.create(n_pt); pt.create(n_pt,3)
!     wt.create(n_pt); rho.create(n_pt)
!
!     stdout.text("made dft grid")
!     stdout.text("making density grid")
!     .make_density_grid(rho,pt)
!     stdout.text("made density grid")
!     ch = -rho*wt
!     rho.destroy; wt.destroy
!     stdout.set_real_style("e")
!     stdout.text("charges:")
!     stdout.put(ch,"column")
!     stdout.text("pt:")
!     stdout.put(pt)
!     ! First get the atomic charges, which are assigned to balance the
!     ! electronic charge in case the DFT integration grid is poor.
!     deficit.create(.n_atom)
!     n_pt = .dftgrid.n_pts
!     l = 0
!     do n = 1,.n_atom
!        f = l + 1
!        l = l + n_pt
!        ZZ = ZERO
!        do i = f,l
!           ZZ = ZZ + ch(i)
!        end
!        deficit(n) = -ZZ
!     end
!     ! Now set the full "charges" and "positions" arrays, including the
!     ! (corrected) atomic charges, at the end of the list
!     l = 0
!     ll = 0
!     do n = 1,.n_atom
!        f  = l  + 1
!        l  = l  + n_pt
!        ff = ll + 1
!        ll = ll + n_pt
!        charges(f:l) = ch(ff:ll)
!        positions(:,f:l) = transpose(pt(ff:ll,:))
!        l = l + 1
!        charges(l) = deficit(n)  
!        deficit(n) = .atom(n).atomic_number - deficit(n)
!        positions(:,l) = .atom(n).pos
!     end
!     stdout.set_real_style("e")
!     stdout.flush
!     stdout.text("Deficit charges:")
!     stdout.put(deficit,"column")
!     stdout.show("sum of deficit charges =",sum(deficit))
!     stdout.show("sum of charges         =",sum(charges))
!     deficit.destroy
!   ! stdout.flush
!   ! stdout.text("Charges:")
!   ! stdout.flush
!   ! stdout.put(charges,"column")
!   ! stdout.flush
!   ! stdout.text("Positions:")
!   ! stdout.flush
!   ! stdout.put(positions,"transpose")
!     stdout.set_real_style("f")
!     pt.destroy; ch.destroy
!   end

!   make_unit_cell_point_charges(charges,positions)
!   ! Make a list of point charges that accurately represents the total charge of
!   ! the unit cell.  Includes contributions from electrons and nuclei.
!   ! NOTE: this is normally called on a .saved fragment
!     charges :: VEC{REAL}, target
!     positions :: MAT{REAL}, target
!   ENSURE(charges.dim==positions.dim2,"position and charges arrays are incorrect")
!   ENSURE(positions.dim1==3,"dimensions of position array are incorrect")
!   ENSURE(.atom.created,"Need a list of atoms")
!   ENSURE(.dftgrid.created,"no DFT grid")
!   ENSURE(.crystal.created,"no crystal data")
!   ENSURE(.crystal.Z.is_int(TOL(3)), "must have an integer number of fragments in the unit cell")
!   ENSURE(.crystal.frag_atom_for_frag_cell_atom.created,"fragment cell map not created")
!   ENSURE(charges.dim==(.dftgrid.n_pts+1)*.crystal.n_unit_cell_atoms,"charges has wrong size")
!     ch,wt,rho,deficit :: VEC{REAL}*
!     pos,pt,uc_pos :: MAT{REAL}*
!     shift,pos3 :: VEC{REAL}(3)
!     n_pt,Z,n,f,l,s :: INT
!     e_sum,n_sum :: REAL
!     ! Make the effective electronic charges for the fragment.
!     n_pt = .dftgrid.n_pts*.n_atom
!     deficit.create(.n_atom)
!     ch.create(n_pt); pos.create(3,n_pt)
!     wt.create(n_pt); pt.create(n_pt,3); rho.create(n_pt)
!     .dftgrid.make_grid(pt,wt,.atom)
!     .make_density_grid(rho,pt)
!     ch = -rho*wt
!     pos = transpose(pt)
!     ! Work out the deficit charge for each atom, which is the charge that can
!     ! be ascribed to the dft integration grid point at the atomic nucleus. It
!     ! should normally be negative because near the nucleus the density should
!     ! be evaluated in the midpoint of the region but it is evaluated closer to
!     ! the nucleus and hence is larger than it should be (?). Thats my
!     ! explanation anyhow --- dylan
!     Z = .crystal.Z
!     n_pt = .dftgrid.n_pts
!     l = 0
!     do n = 1,.n_atom
!        f = l + 1
!        l = l + n_pt
!        deficit(n) = .atom(n).atomic_number + sum(ch(f:l))
!     end
!     stdout.flush
!     stdout.text("Deficit charges:")
!     stdout.put(deficit,"column")
!     stdout.show("sum of deficit charges =",sum(deficit))
!     stdout.show("Z times sum of deficit =",Z*sum(deficit))
!     rho.destroy; pt.destroy; wt.destroy
!     ! When added to any fractional position, "shift" will convert that
!     ! position to be such that the centre of the fragment molecule is at the
!     ! centre of the unit cell. 
!     shift = .centre_of_atoms ! The fragment molecule centre
!     .crystal.unit_cell.change_into_fractional(shift)
!     shift = [HALF,HALF,HALF] - shift
!     ! Use symmetry to generate the effective electronic charges and their
!     ! positions in the whole unit cell. This assumes that the fragment cell is
!     ! generated from the *whole* fragment by .crystal.Z symops.
!     .crystal.unit_cell.change_into_fractional(pos)
!     n_pt = .dftgrid.n_pts*.n_atom
!     l = 0
!     do n = 1,Z
!        f = l + 1
!        l = l + n_pt
!        charges(f:l) = ch
!        positions(:,f:l) = pos
!        s = .crystal.symop_for_frag_cell_atom(1+(n-1)*Z)
!        .crystal.transform_geometry(positions(:,f:l),op=s)
!        ! Shift the positions so that they are relative to the fragment molecule
!        ! centre before changing to the unit cell -- so the unit cell surrounds
!        ! the central fragment molecule.
!        positions(:,f:l) = positions(:,f:l) + spread(shift,dim=2,ncopies=n_pt)
!        .crystal.put_to_unit_cell(positions(:,f:l))
!        positions(:,f:l) = positions(:,f:l) - spread(shift,dim=2,ncopies=n_pt)
!        .crystal.unit_cell.change_from_fractional(positions(:,f:l))
!     end
!     pos.destroy; ch.destroy
!     ! Sum electron charges
!     n_pt = n_pt*Z
!     e_sum = sum(charges(1:n_pt))
!     stdout.show("sum of electrn charges =",e_sum)
!     ! Add the nuclear charges to the list. Don't forget to add the deficit
!     ! charges.
!     do n = 1,.crystal.n_unit_cell_atoms
!        f = .crystal.frag_atom_for_unit_cell_atom(n)
!        charges(n_pt+n) = .atom(f).atomic_number - deficit(f)
!        pos3 = .atom(f).pos
!        .crystal.unit_cell.change_into_fractional(pos3)
!        pos3 = pos3 + shift
!        .crystal.put_to_unit_cell(pos3)
!        pos3 = pos3 - shift
!        .crystal.unit_cell.change_from_fractional(pos3)
!        positions(:,n_pt+n) = pos3
!     end
!     deficit.destroy
!     n_sum = sum(charges(n_pt+1:))
!     stdout.show("sum of nuclear charges =",n_sum)
!   end

   make_periodic_fmm_J_matrix(J)
   ! Calculate the periodic fmm J matrix
      J :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.dftgrid.created, "need to specify dftgrid for ZORA")
   ENSURE(.periodic_fmm_level.created, "need to define periodic_fmm_level")
    ! V  :: VEC{REAL}*
      S,JJ :: MAT{REAL}*
      sh :: SHELL2
      q,fa,la,fb,lb :: INT
    ! V.create(.dftgrid.n_pts*.n_atom)
    ! .periodic_fmm_level.make_potential(V)
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      J = ZERO
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         if (maxval(S(fa:la,fb:lb))<TOL(5)) cycle
         JJ.create(sh.a.n_comp,sh.b.n_comp)
         .dftgrid.make_matrix_elements_of(MOLECULE::periodic_fmm_potential,self,sh,JJ)
         J(fa:la,fb:lb) = J(fa:la,fb:lb) + JJ
         JJ.destroy
         sh.destroy_ptr_part
      end
      J.symmetric_reflect
      S.destroy
    ! V.destroy
   end

   periodic_fmm_potential(values,positions)
   ! Make the the "values" of the potential at the positions of the effective
   ! charges describing the initial fragment. If "adjust_surface_dipoles" is
   ! present and TRUE, most of the dipoles on the surface of the outer level are
   ! reversed, to simulate the neutralisation of the surface charge, in order to
   ! get a potential close to the Ewald potential.
      values :: VEC{REAL}
      positions :: MAT{REAL}
      .periodic_fmm_level.make_potential(values,positions)
   end

!  ******************
!  Constraint methods
!  ******************

   constrained_scf ::: leaky
   ! Do a constrained SCF calculation.
   ! The following objects are produced as results:
   !   .molecular_orbitals, .orbital_energies, .density_matrix
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     .initialise_scf
     do
       .put_scf_results        ! Banner and 0th iteration results
       do
         .accelerate_fock_matrix
         .update_molecular_orbitals
       ! .schmidt_orthonormalise_MOs
         .make_scf_density_matrix
         .make_fock_matrix
         .make_constraint_data
         .update_scfdata       ! Add constraint after so we don't stuff energies
         .add_constraint_to_fock_matrix
         .update_scfdata_error
         .put_scf_results
         if (.scfdata.scf_done) exit
       end
       .scfdata.update_lambda
       if (.scfdata.exceeded_lambda_max) exit
       .reset_for_next_lambda
     ! .scfdata.reset_for_next_lambda(.fock_matrix)
       .update_scfdata_error
     ! .scfdata.reset_iteration_count
     end
     .cleanup_scf
     .crystal.put_reflection_data
   end

   make_constraint_data
   ! Make the predicted constraint data, e.g. X-ray structure factors or
   ! PND structure factors, or whatever data are to be used in the constrained
   ! wavefunction procedure
   ENSURE(.scfdata.created,"no scfdata")
      scf_kind :: STR
      scf_kind = .scfdata.scf_kind
      select case (scf_kind)
         case ("xray_rhf","xray_rks","xray_uhf","xray_uks"); .make_x_structure_factors
                      if (.crystal.xray_r_free_data.created) .make_xf_structure_factors
         case ("pnd_uhf","pnd_uks");                         .make_n_structure_factors
                      if (.crystal.pnd_r_free_data.created)  .make_xf_structure_factors
         case ("xray_pnd_uhf","xray_pnd_uks");               .make_x_structure_factors
                                                             .make_n_structure_factors
                      if (.crystal.xray_r_free_data.created) .make_xf_structure_factors
                      if (.crystal.pnd_r_free_data.created)  .make_xf_structure_factors
         case default
            DIE("unknown wavefunction fitting kind, "//scf_kind.trim)
      end
   end

   add_constraint_to_fock_matrix
   ! Make the constraint matrix for wavefunction fitting and add it to the fock
   ! matrix to obtain the effective fock matrix.
     ENSURE(.scfdata.created,"no scf data")
     ENSURE(.fock_matrix.created,"no fock matrix")
     ENSURE(.fock_matrix.any_created,"no fock matrix")
     C :: OPMATRIX*
     C.create(.n_bf,.scfdata.spinorbital_kind)
     .make_constraint(C)
     ! Now add in the contribution
     .fock_matrix.plus_scaled(C,.scfdata.lambda)
     ! Save the constraint matrix for acceleration of multiple fits
     .archive(C,"constraint_matrix")
     C.destroy
   end

   make_constraint(C)
   !Make constraint matrix for restricted or unrestricted SCF cases
      C :: OPMATRIX, INOUT
   ENSURE(any(.scfdata.spinorbital_kind==["restricted  ","unrestricted"]),"can only do restricted or unrestricted cases")
   ENSURE(.crystal.created,  "no crystal info")
   ENSURE(.crystal.reflection_data_exists, "no reflection data")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      tmp :: OPMATRIX*
      select case (.scfdata.scf_kind)
         case ("xray_rhf","xray_rks")
            .crystal.assign_xray
            .make_r_constraint(C.restricted)
         case ("xray_uhf","xray_uks")
            .crystal.assign_xray
            .make_r_constraint(C.alpha)
            C.beta = C.alpha
         case ("pnd_uhf","pnd_uks")
            .crystal.assign_pnd
            .make_pnd_constraint(C.alpha)
            C.beta = -C.alpha
         case ("xray_pnd_uhf","xray_pnd_uks")
            .crystal.assign_xray
            tmp.create(.n_bf,.scfdata.spinorbital_kind)
            .make_r_constraint(tmp.alpha)
            tmp.beta = tmp.alpha
            C.to_scaled(tmp,ONE/.crystal.F_chi2)
            .crystal.assign_pnd
            .make_pnd_constraint(tmp.alpha)
            tmp.beta = -tmp.alpha
            C.plus_scaled(tmp,ONE/.crystal.F_chi2)
            tmp.destroy
      end 
   end  
   
   make_r_constraint(C)
   ! Make the constraint matrix "C" for restricted wavefunction fitting.
     C :: MAT{REAL}, INOUT
     k_pts :: MAT{REAL}*
     ft_ab_eq,ft_ab :: MAT3{CPX}*
     Fc,fac_times_alpha,Fconjg :: VEC{CPX}*
     Fm,Fexp,Fsig,alpha :: VEC{REAL}*
     sh :: SHELL2
     fac,cutoff :: REAL
     q,fa,la,fb,lb,i,j,n_refl,n_unique,atom_a,atom_b :: INT
     n_unique = .crystal.n_unique_SF_k_pts
     n_refl = .crystal.n_refl
     fac = TWO/max(n_refl - .crystal.n_param,1)
     fac_times_alpha.create(n_refl)
     Fc.create(n_refl);    Fc = .crystal.F_calc
     alpha.create(n_refl)
     alpha = .crystal.extinction_correction
     Fexp.create(n_refl);  Fexp = .crystal.F_exp
     Fsig.create(n_refl);  Fsig = .crystal.F_sigma
     Fm.create(n_refl);    Fm = max(abs(Fc),TOL(10))
     fac_times_alpha = fac * alpha * (alpha * Fm - Fexp) / (Fsig * Fsig * Fm)
 !   fac_times_alpha = fac * alpha * (alpha - Fexp/Fm) / (Fsig * Fsig)
     Fm.destroy
     Fsig.destroy
     Fexp.destroy
     alpha.destroy
     Fconjg.create(n_refl)
     Fconjg=conjg(Fc)
     k_pts.create(n_unique,3)
     .crystal.make_unique_SF_k_pts(k_pts)
     cutoff = TOL(10) / .n_shell_pairs
     C = ZERO
     parallel do q = 1, .n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (sh.skip_ft(cutoff)) then
         sh.destroy_ptr_part
         cycle
       end
       ft_ab.create([1,n_refl],[fa,la],[fb,lb])
       ft_ab_eq.create(n_unique,sh.a.n_comp,sh.b.n_comp)
       .make_ft_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
       .crystal.sum_ft_ints(ft_ab,ft_ab_eq)
       ft_ab_eq.destroy
       do i = fa,la
         do j = fb,min(lb,i)
 !         C(i,j) = sum(fac_times_alpha(:) * real(ft_ab(:,i,j) * Fconjg(:)))
           C(i,j) = sum(fac_times_alpha(:) &
                            * (real(ft_ab(:,i,j)) * real(Fconjg(:)) &
                            -  aimag(ft_ab(:,i,j)) * aimag(Fconjg(:))))
           ! real(a*b) = real(a)*real(b)-aimag(a)*aimag(b)

         end
       end
       ft_ab.destroy
       sh.destroy_ptr_part
     end
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(C)
     else
        C.symmetric_reflect
     end
     Fconjg.destroy
     k_pts.destroy
     Fc.destroy
     fac_times_alpha.destroy
   end
   
   make_pnd_constraint(C)
   ! Make the constraint matrix "C" for restricted wavefunction fitting.
     C :: MAT{REAL}, INOUT
     k_pts :: MAT{REAL}*
     ft_ab_eq,ft_ab :: MAT3{CPX}*
     Fc,fac_times_alpha :: VEC{CPX}*
     Fexp,Fsig,alpha :: VEC{REAL}*
     sh :: SHELL2
     fac,cutoff :: REAL
     q,fa,la,fb,lb,i,j,n_refl,n_unique,atom_a,atom_b :: INT
     n_unique = .crystal.n_unique_SF_k_pts
     n_refl = .crystal.n_refl
     fac = -G_FACTOR/(TWO*max(n_refl - .crystal.n_param,1))
     fac_times_alpha.create(n_refl)
     Fc.create(n_refl);    Fc = .crystal.F_calc
     alpha.create(n_refl)
     alpha = .crystal.extinction_correction
     Fexp.create(n_refl);  Fexp = .crystal.F_exp
     Fsig.create(n_refl);  Fsig = .crystal.F_sigma
     fac_times_alpha = fac * alpha * (alpha * Fc - Fexp) / (Fsig * Fsig)
     Fsig.destroy
     Fexp.destroy
     alpha.destroy
     Fc.destroy
     k_pts.create(n_unique,3)
     .crystal.make_unique_SF_k_pts(k_pts)
     cutoff = TOL(10) / .n_shell_pairs
     C = ZERO
     parallel do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if (sh.skip_ft(cutoff)) then
         sh.destroy_ptr_part
         cycle
       end
       ft_ab.create([1,n_refl],[fa,la],[fb,lb])
       ft_ab_eq.create(n_unique,sh.a.n_comp,sh.b.n_comp)
       .make_ft_pair(ft_ab_eq,k_pts,sh,atom_a,atom_b)
       .crystal.sum_ft_ints(ft_ab,ft_ab_eq)
       ft_ab_eq.destroy
       do i = fa,la
         do j = fb,min(lb,i)
           C(i,j) = sum(fac_times_alpha(:)*ft_ab(:,i,j))  
         end
       end
       ft_ab.destroy
       sh.destroy_ptr_part
     end
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(C)
     else
        C.symmetric_reflect
     end
     k_pts.destroy
     fac_times_alpha.destroy
   end

!   save_constraint_for_diis
!   ! ?
!     arch :: ARCHIVE
!     C_tri :: VEC{REAL}*
!     if (NOT .scfdata.apply_fock_diis) return
!
!     ! Read in the matrix from disk
!     arch.set(.name,"constraint_matrix")
!     C_tri.create(.density_matrix.l_compress(.scfdata.spinorbital_kind))
!     arch.read(C_tri)
!     arch.close
!     arch.delete
!
!     ! Save the constraint matrix to disk with a different name
!     .scfdata.diis.save_item(C_tri,"constraint",.scfdata.diis.new)
!     C_tri.destroy
!
!     ! Save the density matrix to disk with a different name
!     .scfdata.diis.save_item(.density_matrix,"density_matrix",.scfdata.diis.new)
!   end

!   reset_constraint_stuff
!   ! Recalculates the Fock and error matrices so they apply to the new value of
!   ! lambda, ".scfdata.lambda_step". This can be done if at each iteration the
!   ! density matrix and the constraint are saved to disk.
!     arch :: ARCHIVE
!     i :: INT
!     error,density_matrix,F,C :: OPMATRIX*
!     C_tri,Fa,Fb,ea,eb :: VEC{REAL}*
!     !F,C :: MAT{REAL}*
!     scf_kind :: STR
!     if (NOT .scfdata.apply_fock_diis) return
!     F.create(.n_bf,.scfdata.spinorbital_kind)
!     density_matrix.create(.n_bf,.scfdata.spinorbital_kind)
!     error.create(.n_bf,.scfdata.spinorbital_kind)
!     C_tri.create(density_matrix.l_compress)
!     F.compress
!     select case (.scfdata.scf_kind)
!       case ("xray_uhf","xray_uks","pnd_uhf","xray_pnd_uhf")
!         do i = 1,.scfdata.diis.dimension-1
!         ! Read in the constraint
!         .scfdata.diis.get_item(C_tri,"constraint",i)
!         ! Read in the Fock
!         Fa => F.triangle.alpha
!         Fb => F.triangle.alpha
!         .scfdata.diis.get_item(Fa,"fock_matrix,alpha",i)
!         .scfdata.diis.get_item(Fb, "fock_matrix,beta", i)
!         ! Read in the density matrix
!         .scfdata.diis.get_item(density_matrix,"density_matrix",i)
!         ! Scale the Fock matrix to the new lambda
!         F.triangle = F.triangle + .scfdata.lambda_step*C_tri
!         F.uncompress
!         .make_diis_error(error,F,density_matrix)
!         error.compress
!         F.compress
!         ea => error.triangle.alpha
!         eb => error.triangle.beta
!         .scfdata.diis.save_item(ea,"fock_error,alpha",i)
!         .scfdata.diis.save_item(eb, "fock_error,beta", i)
!         error.uncompress
!         end
!       case ("rhf","rks")
!         do i=1,.scfdata.diis.dimension-1
!         ! Read in the constraint
!         .scfdata.diis.get_item(C_tri,"constraint",i)
!         ! Read in the Fock
!         .scfdata.diis.get_item(F.triangle,"fock_matrix",i)
!         ! Read in the density matrix
!         .scfdata.diis.get_item(density_matrix,"density_matrix",i)
!         ! Scale the Fock matrix to the new lambda
!         F.triangle = F.triangle + .scfdata.lambda_step*C_tri
!         F.uncompress
!         .make_diis_error(error,F,density_matrix)
!         error.compress
!         F.compress
!         .scfdata.diis.save_item(error.triangle,"fock_error",i)
!         error.uncompress
!         end
!       case default; DIE(.scfdata.scf_kind.trim//" not implemented")
!     end  
!     .scfdata.diis.remake_diis_lhs(error.triangle,F.triangle)
!     error.destroy
!     density_matrix.destroy
!     .unarchive_density_matrix
!     F.destroy
!     C_tri.destroy
!     C.create(.n_bf,.scfdata.spinorbital_kind)
!     ! The current Fock matrix is for the old lambda, so let's make it for the
!     ! new lambda.
!     C.compress
!     arch.set(.name,"constraint_matrix")
!     arch.read(C.triangle)
!   !stdout.text("resetconstraint",flush=1)  
!   !stdout.put(C.triangle)  
!     C.uncompress
!     .fock_matrix.plus_scaled(C,.scfdata.lambda_step)
!     C.destroy
!   end

   reset_for_next_lambda
   ! Reset the iteration counters for the next lambda iteration.
   ! Also reset the fock matrices on disk.
      S :: MAT{REAL}*
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      .scfdata.reset_for_next_lambda(.fock_matrix,S)
      S.destroy
   end

!  ********************************
!  Orbital update/cleaning routines
!  ********************************

   schmidt_orthonormalise_MOs
   ! Schmidt orthonormalise the ".molecular_orbitals" and archive
      .schmidt_orthonormalise(.molecular_orbitals)
      .archive_molecular_orbitals
      .archive_orbital_energies
   end

   schmidt_orthonormalise(MO,scale)
   ! Schmidt orthonormalise the molecular orbitals, "MO"
      MO :: OPMATRIX
      scale :: REAL, optional
       S :: MAT{REAL}*
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      MO.schmidt_orthonormalise(S,scale)
      S.destroy
   end

   symmetrically_orthonormalise(MO)
   ! Symmetrically orthonormalise the molecular orbitals, "MO"
      MO :: OPMATRIX
       S :: MAT{REAL}*
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      MO.symmetrically_orthonormalise(S)
      S.destroy
   end

   update_molecular_orbitals
   ! Solve for the molecular orbitals.  Requires a set of old molecular
   ! orbitals.
     if (.scfdata.using_MO_gradient_update) then; .MO_gradient_update
     else;                                        .MO_eigen_update
     end
   end

   MO_eigen_update
   ! Solve for the molecular orbitals.  Requires a set of old molecular
   ! orbitals.
   ! The new molecular orbitals "cU" are found from the old MOs "c" by solving :
   ! (c^T F c)U = c^T S c U E ... where U is an orthogonal matrix, F fock
   ! matrix.
   ENSURE(.molecular_orbitals.created,"no old MO's")
   ENSURE(.molecular_orbitals.any_created,"no old MO's")
     scf_kind :: STR
     e :: VEC{REAL}*
     MO,F :: MAT{REAL}*
     MOc,Fc :: MAT{CPX}*
!     .archive_molecular_orbitals(archive_name="old_molecular_orbitals")
     scf_kind = .scfdata.scf_kind
     select case (scf_kind)
        case ("rhf","rks","rohf","xray_rhf","xray_rks", &
              "embedded_rhf","embedded_rks","embedded_rohf", &
              "embedded_xray_rhf","embedded_xray_rks", &
              "crystal_rhf", "noninteracting-group-rhf")
           e   => .orbital_energies.restricted
           MO  => .molecular_orbitals.restricted
           F   => .fock_matrix.restricted
           .MO_r_eigen_update(e,MO,F)
        case ("uhf","uks","xray_uhf","xray_uks", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           e   => .orbital_energies.alpha
           MO  => .molecular_orbitals.alpha
           F   => .fock_matrix.alpha
           .MO_r_eigen_update(e,MO,F)
           e   => .orbital_energies.beta
           MO  => .molecular_orbitals.beta
           F   => .fock_matrix.beta
           .MO_r_eigen_update(e,MO,F)
        case ("gchf","cghf")
           e   => .orbital_energies.general
           MOc => .molecular_orbitals.general_complex
           Fc  => .fock_matrix.general_complex
           .MO_gc_eigen_update(e,MOc,Fc)
        case default
           DIE("unknown scf kind, "//scf_kind.trim)
     end
     .archive_molecular_orbitals
     .archive_orbital_energies
   end

   MO_r_eigen_update(MO_energies,MO,F)
   ! Solve for the new molecular orbital energies "MO_energies" and the new
   ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
   ! matrix "F".  The new molecular orbitals "MO*U" are found from the old MOs
   ! "MO" by solving : (c^T F c)U = c^T S c U E ...... where U is an orthogonal
   ! matrix.
     MO_energies :: VEC{REAL}
     MO,F :: MAT{REAL}
     G,U,X,S :: MAT{REAL}*
     i :: INT

     G.create(.n_bf,.n_bf)
     G = F

     G.change_basis_using(MO)

     ! Level shifting in old MO basis
     if (.scfdata.apply_level_shifting) then
       do i = .n_a + 1, .n_bf
         G(i,i) = .scfdata.level_shift + G(i,i)
       end
     end

     ! Symmetric orthogonalise MO's
     X.create(.n_bf,.n_bf)
     S.create(.n_bf,.n_bf)
     .get_overlap_matrix(S)
     S.change_basis_using(MO)
   ! X.to_power_product_inv_sqrt_of(S)
     X.to_inverse_sqrt_of(S)
     G.change_basis_using(X)
     S.to_product_of(MO,X)
     MO = S
     S.destroy
     X.destroy

     U.create(.n_bf,.n_bf)
     G.solve_eigenproblem(MO_energies,U)
   ! U.make_diagonally_dominant
     ! MO.to_product_of(X,U)
     G.to_product_of(MO,U)
     MO = G
     U.destroy
     ! X.destroy
     G.destroy
   end

   MO_gc_eigen_update(MO_energies,MO,F)
   ! Solve for the new molecular orbital energies "MO_energies" and the new
   ! molecular orbitals "MO", given an initial old set (in "MO") and a fock
   ! matrix "F".
   ! The new molecular orbitals "MO*U" are found from the old MOs "MO" by
   ! solving (c^T F c)U = c^T S c U E ...... where U is an orthogonal matrix.
     MO_energies :: VEC{REAL}
     MO,F :: MAT{CPX}
     G,U :: MAT{CPX}*
      i :: INT
     G.create(2*.n_bf,2*.n_bf)
     U.create(2*.n_bf,2*.n_bf)
     G = F
     G.change_basis_using(MO)
     ! Level shifting
     if (.scfdata.apply_level_shifting) then
       do i = .n_e + 1, 2*.n_bf
         G(i,i) = .scfdata.level_shift + G(i,i)
       end
     end
     G.solve_eigenproblem(MO_energies,U)
     G.to_product_of(MO,U)
     MO = G
     U.destroy
     G.destroy
   end

   MO_gradient_update
   ! Update the molecular orbitals using the gradient. Requires a set of old
   ! molecular orbitals. The new molecular orbitals "c" are found by
   ! incrementing a little along the gradient: (FDS - SDFDS)c and then
   ! reorthogonalising c.  NOTE: the normal Fock matrix DIIS update is turned
   ! off if this routine executes.
   ENSURE(.scfdata.using_MO_gradient_update,"not allowed")
   ENSURE(.fock_matrix.created,"no fock_matrix")
   ENSURE(.fock_matrix.any_created,"no fock_matrix")
   ENSURE(.density_matrix.created,"no density_matrix")
   ENSURE(.density_matrix.any_created,"no density_matrix")
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.any_created,"no MO's")
     orb_kind :: STR
     g,h,MO,F,P :: MAT{REAL}*
     f1,f2,scale :: REAL
     step :: REAL = ONE
!     .archive_molecular_orbitals(archive_name="old_molecular_orbitals")
     orb_kind = .scfdata.scf_kind
     select case (orb_kind)
        case ("rhf","rks","xray_rhf","xray_rks", &
              "embedded_rhf","embedded_rks", &
              "embedded_xray_rhf","embedded_xray_rks", &
              "crystal_rhf", "noninteracting-group-rhf")
           g.create(.n_bf,.n_bf)
           F  => .fock_matrix.restricted
           P  => .density_matrix.restricted
           MO => .molecular_orbitals.restricted
           .make_MO_r_gradient(g,F,P,MO)
           f1 = g.trace_product_with(transpose(g))
           MO = MO - (TOL(2)/sqrt(f1))*g
           .schmidt_orthonormalise(.molecular_orbitals,scale)
           scale = ONE/scale
           .make_scf_density_matrix
           .make_fock_matrix
           h.create(.n_bf,.n_bf)
           .make_MO_r_gradient(h,F,P,MO)
           h = (scale*h-g)/TOL(2)
           f2 = h.trace_product_with(transpose(h))
           h.destroy
           step = f1/f2
           step = min(.scfdata.max_update_stepsize,step)
           write(*,*) "f1 = ",f1
           write(*,*) "f2 = ",f2
           write(*,*) "s  = ",step
           MO = MO - (step + TOL(2)/sqrt(f1))*g
       !   if (.scfdata.apply_MO_diis) .scfdata.diis.extrapolate(MO(:,1:.n_a),g(:,1:.n_a))
       !   if (NOT .scfdata.diis_used) then ! only do this the first time
       !      if (.scfdata.difference>ZERO) step = 0.70d0*step
       !      if (.scfdata.difference<ZERO) step = 1.10d0*step
       !      MO = MO - step*(.scfdata.MO_gradient_stepsize)*g
       !   end
           g.destroy
        case default
           DIE("SCF kind "//trim(orb_kind)//" not implemented")
     end
     .scfdata.set_diis_error(f1)
     .archive_molecular_orbitals
   end

   make_MO_r_gradient(g,F,P,c)
   ! Make the real gradient "g" of the moleculard orbitals,
   ! g = (FPS - (1/2)SPFPS)c
      g,F,P,c :: MAT{REAL}
      S,W :: MAT{REAL}*
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      W.create(.n_bf,.n_bf)
      W.to_product_of(P,S)
      S.to_product_of(F,W)
      g =       S ! = FPS
      W = -HALF*W ! = -PS ... 1/2 is for double occupancy in P
      S.plus_product_of(W,g,transpose_a=TRUE)
      W.destroy
      g.to_product_of(S,c)
      S.destroy
   end

! **************************
! Energy evaluation routines
! **************************

   put_scf_energy
   ! Output the scf energy.
     stdout.show("The SCF energy is ", .scf_energy)
     stdout.show("The kinetic energy is ", .kinetic_energy)
     if (.scfdata.is_DFT_calculation) &
     stdout.show("The Kohn-Sham DFT XC energy is ", .scfdata.dft_energy_correction)
   end

   kinetic_energy result (res)
   ! Evaluates the SCF kinetic energy as a trace of ".density_matrix" with the
   ! ".kinetic matrix".
     res :: REAL
   ENSURE(.density_matrix.created,    "no density matrix")
   ENSURE(.density_matrix.any_created,"no density matrix")
     scf_kind :: STR
     H :: MAT{REAL}*
     HH :: MAT{CPX}*
     scf_kind = .scfdata.scf_kind
     select case (scf_kind)
        case ("rhf","rks","xray_rhf","xray_rks", &
              "embedded_rhf","crystal_rhf","noninteracting-group-rhf")
           H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
           res = .density_matrix.restricted.trace_product_with(H)
           H.destroy
        case ("uhf","uks","xray_uhf","xray_uks","rohf", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           H.create(.n_bf,.n_bf); .get_kinetic_matrix(H)
           res = .density_matrix.alpha.trace_product_with(H)
           res = .density_matrix.beta.trace_product_with(H) + res
           H.destroy
        case ("gchf")
           HH.create(2*.n_bf,2*.n_bf); HH=ZERO
           H.create(.n_bf,.n_bf)
           .get_kinetic_matrix(H)
           HH.alpha_alpha_set_to(H)
           HH.beta_beta_set_to(H)
           H.destroy
           res = .density_matrix.general_complex.trace_product_with(HH)
           HH.destroy
        case default; DIE("unknown scf kind, "//trim(scf_kind))
     end
   end

   scf_energy result (res)
   ! Evaluates the total SCF energy (including nuclear) as a trace of
   ! ".density_matrix" with the ".fock matrix".
     res :: REAL
   ENSURE(.density_matrix.created,    "no density matrix")
   ENSURE(.density_matrix.any_created,"no density matrix")
   ENSURE(.fock_matrix.created,    "no fock matrix")
   ENSURE(.fock_matrix.any_created,"no fock matrix")
     res = .scf_energy(.density_matrix,.fock_matrix)
   end

   scf_energy(P,F) result (res)
   ! Evaluates the total SCF energy (including nuclear) as a trace of
   ! "P" with the fock matrix "F".
     P,F :: OPMATRIX
     res :: REAL
   ENSURE(.scfdata.created, "no scf data")
     g :: INT
     scf_kind :: STR
     scf_kind = .scfdata.scf_kind
     select case (scf_kind)
        case ("noninteracting-group-rhf")
           res = .scf_electronic_energy(P,F)
           do g = 1,size(.atom_group)
              res = res + .atom(.atom_group(g).element).nuclear_energy
           end
        case default
           res = .scf_electronic_energy(P,F) + .nuclear_energy
     end
   end

   scf_electronic_energy(P,core) result (res)
   ! Evaluates the SCF electronic energy as a trace of density "P" with
   ! ".fock_matrix". If "core" is present and FALSE, the core contribution
   ! is not added.
     P :: OPMATRIX
     core :: BIN, optional
     res :: REAL
   ENSURE(.fock_matrix.created,    "no fock matrix")
   ENSURE(.fock_matrix.any_created,"no fock matrix")
     res = .scf_electronic_energy(P,.fock_matrix,core)
   end

   scf_electronic_energy(P,F,core) result (res)
   ! Evaluates the SCF electronic energy as a trace of density "P" with
   ! fock matrix "F". If "core" is present and FALSE, the core contribution is
   ! not added.  NOTE: this includes the DFT electronic energies, and it assumes
   ! that these energy contributions were calculated at the time of the
   ! formation of "F" from "P", and that they were stored in .scfdata.
     P,F :: OPMATRIX
     core :: BIN, optional
     res :: REAL
   ENSURE(.scfdata.created,"no scfdata")
     add_core :: BIN
     Fr :: MAT{REAL}*
     Fc :: MAT{CPX}*
     add_core = TRUE
     if (present(core)) add_core = core
     select case (.scfdata.scf_kind)
        case ("rhf","xray_rhf","embedded_rhf","crystal_rhf","noninteracting-group-rhf")
           Fr.create(.n_bf,.n_bf)
           Fr = F.restricted
           if (add_core) .add_core_hamiltonian(Fr)
           res = HALF * P.restricted.trace_product_with(Fr)
           Fr.destroy
        case ("rks","xray_rks")
           Fr.create(.n_bf,.n_bf)
           Fr = F.restricted
           if (add_core) .add_core_hamiltonian(Fr)
           res = HALF * P.restricted.trace_product_with(Fr) 
           res = res + .scfdata.dft_energy_correction
           Fr.destroy
        case ("uhf","xray_uhf","rohf","pnd_uhf","xray_pnd_uhf")
           Fr.create(.n_bf,.n_bf);
           Fr = F.alpha 
           if (add_core) .add_core_hamiltonian(Fr)
           res = HALF * P.alpha.trace_product_with(Fr)
           Fr = F.beta 
           if (add_core) .add_core_hamiltonian(Fr)
           res = res + HALF * P.beta.trace_product_with(Fr)
           Fr.destroy
        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
           Fr.create(.n_bf,.n_bf);
           Fr = F.alpha 
           if (add_core) .add_core_hamiltonian(Fr)
           res = HALF * P.alpha.trace_product_with(Fr) &
               + .scfdata.dft_alpha_energy_correction
           Fr = F.beta 
           if (add_core) .add_core_hamiltonian(Fr)
           res = res + HALF * P.beta.trace_product_with(Fr) &
                     + .scfdata.dft_beta_energy_correction
           Fr.destroy
        case ("gchf")
           Fc.create(2*.n_bf,2*.n_bf);
           Fc = F.general_complex
           if (add_core) .add_core_hamiltonian(Fc)
           res = HALF * P.general_complex.trace_product_with(Fc)
           Fc.destroy
        case default
           DIE("unknown scf kind, "//trim(.scfdata.scf_kind))
     end
   end

   scf_electronic_energy(P,nuclei) result (res)
   ! Evaluates the SCF electronic energy as a trace of "D" with the
   ! ".fock_matrix".  "nuclei" lists the nuclei to be used for obtaining n->e
   ! attractions.
     P :: OPMATRIX, target
     nuclei :: VEC{INT}
     res :: REAL
     add_core :: BIN
     scf_kind :: STR
     F :: MAT{REAL}*
     FF :: MAT{CPX}*
     scf_kind = .scfdata.scf_kind
     ENSURE(.fock_matrix.created,    "no fock matrix")
     ENSURE(.fock_matrix.any_created,"no fock matrix")
     ENSURE(.density_matrix.created,    "no density matrix")
     ENSURE(.density_matrix.any_created,"no density matrix")
     add_core = TRUE
     select case (scf_kind)
        case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")
           F.create(.n_bf,.n_bf)
           F = .fock_matrix.restricted
           .add_core_hamiltonian(F,nuclei)
           res = HALF * P.restricted.trace_product_with(F)
           F.destroy
!        case ("xray_rks","rks")
!           F.create(.n_bf,.n_bf)
!           F = .fock_matrix.restricted
!           .add_core_hamiltonian(F,nuclei)
!           res = HALF * P.restricted.trace_product_with(F)
!           res = res + .ex_corr_energy_term
!           F.destroy
        case ("uhf","uks","xray_uhf","xray_uks","rohf", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           F.create(.n_bf,.n_bf);
           F = .fock_matrix.alpha
           .add_core_hamiltonian(F,nuclei)
           res = HALF * P.alpha.trace_product_with(F)
           F = .fock_matrix.beta
           .add_core_hamiltonian(F,nuclei)
           res = HALF * P.beta.trace_product_with(F) + res
           F.destroy
        case ("gchf")
           FF.create(2*.n_bf,2*.n_bf);
           FF = .fock_matrix.general_complex
           .add_core_hamiltonian(FF,nuclei)
           res = HALF * P.general_complex.trace_product_with(FF)
           FF.destroy
        case default
           DIE("unknown scf kind, "//trim(scf_kind))
     end
   end

   scf_electronic_energies result (res) ::: leaky
   ! Evaluates the SCF electronic energies as a trace of density "P" with
   ! fock matrix "F". In the case of UHF the energies are the E^alpha and E^beta
   ! energies. NOTE: this includes the DFT energy contributions.
     res :: VEC{REAL}*
     res => .scf_electronic_energies(.density_matrix,.fock_matrix)
   end

   scf_electronic_energies(P,F) result (res) ::: leaky
   ! Evaluates the SCF electronic energies as a trace of density "P" with
   ! fock matrix "F". In the case of UHF the energies are the E^alpha and E^beta
   ! energies. NOTE: this includes the DFT electronic energies, and it assumes
   ! that these energy contributions were calculated at the time of the
   ! formation of "F" from "P", and that they were stored in .scfdata.
     P,F :: OPMATRIX
     res :: VEC{REAL}*
   ENSURE(.scfdata.created,"no scfdata")
     Fr :: MAT{REAL}*
     select case (.scfdata.scf_kind)
        case ("rhf","xray_rhf","embedded_rhf","crystal_rhf","noninteracting-group-rhf")
           res.create(1)
           Fr.create(.n_bf,.n_bf)
           Fr = F.restricted; .add_core_hamiltonian(Fr)
           res(1) = HALF * P.restricted.trace_product_with(Fr)
           Fr.destroy
        case ("rks","xray_rks")
           res.create(1)
           Fr.create(.n_bf,.n_bf)
           Fr = F.restricted; .add_core_hamiltonian(Fr)
           res(1) = HALF * P.restricted.trace_product_with(Fr) &
                  + .scfdata.dft_energy_correction
           Fr.destroy
        case ("uhf","xray_uhf","rohf","pnd_uhf","xray_pnd_uhf")
           res.create(2)
           Fr.create(.n_bf,.n_bf);
           Fr = F.alpha; .add_core_hamiltonian(Fr)
           res(1) = HALF * P.alpha.trace_product_with(Fr)
           Fr = F.beta; .add_core_hamiltonian(Fr)
           res(2) = HALF * P.beta.trace_product_with(Fr)
           Fr.destroy
        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
           res.create(2)
           Fr.create(.n_bf,.n_bf);
           Fr = F.alpha; .add_core_hamiltonian(Fr)
           res(1) = HALF * P.alpha.trace_product_with(Fr) &
                  + .scfdata.dft_alpha_energy_correction
           Fr = F.beta; .add_core_hamiltonian(Fr)
           res(2) = HALF * P.beta.trace_product_with(Fr) &
                  + .scfdata.dft_beta_energy_correction
           Fr.destroy
        case default
           DIE("unknown or unimplemented scf kind, "//trim(.scfdata.scf_kind))
     end
   end

   expectation(X) result (res)
   ! Evaluates the expectation value of the matrix of the operator X
   ! with the current density matrix
     X :: MAT{REAL}
     res :: REAL
   ENSURE(X.is_square,"X operator matrix is not square")
     orb_kind :: STR
     orb_kind = .density_matrix.spinorbital_kind
     select case (orb_kind)
        case ("restricted")
           ENSURE(X.dim1==.n_bf,"wrong size, X")
           res = .density_matrix.restricted.trace_product_with(X)
        case ("unrestricted")
           ENSURE(X.dim1==.n_bf,"wrong size, X")
           res = .density_matrix.alpha.trace_product_with(X)
           res = .density_matrix.beta.trace_product_with(X) + res
        case ("general_complex")
           ENSURE(X.dim1==2*.n_bf,"wrong size, X")
           res = .density_matrix.general_complex.trace_product_with(X)
        case default
           DIE("unimplemented kind, "//trim(orb_kind))
     end
   end

! ******************
! Archiving routines
! ******************

   archive(opmatrix,archive_name,genre,with_lambda)
   ! Save "opmatrix" to an archive on disk with name "archive_name". The genre
   ! is guessed from "opmatrix" unless "genre" is present.
     opmatrix :: OPMATRIX
     archive_name :: STR
     genre :: STR, optional
     with_lambda :: BIN, optional
     archive :: ARCHIVE
     avec_lambda :: BIN
     avec_lambda = FALSE
     if (present(with_lambda)) avec_lambda = with_lambda
     archive.set(.name,archive_name)
     archive.write(opmatrix,genre)
     if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(opmatrix,genre)
        end
        end
     end
   end

   archive(opvector,archive_name,genre,with_lambda)
   ! Save "opvector" to an archive on disk with name "archive_name". The genre
   ! is guessed from "opvector" unless "genre" is present.
     opvector :: OPVECTOR
     archive_name :: STR
     genre :: STR, optional
     with_lambda :: BIN, optional
     archive :: ARCHIVE
     avec_lambda :: BIN
     avec_lambda = FALSE
     if (present(with_lambda)) avec_lambda = with_lambda
     archive.set(.name,archive_name)
     archive.write(opvector,genre)
     if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(opvector,genre)
        end
        end
     end
   end

   archive(item,archive_name,genre,with_lambda)
   ! Save "item" to an archive on disk with name "archive_name". 
     item :: REAL
     archive_name :: STR
     genre :: STR, optional
     with_lambda :: BIN, optional
     archive :: ARCHIVE
     avec_lambda :: BIN
     avec_lambda = FALSE
     if (present(with_lambda)) avec_lambda = with_lambda
     archive.set(.name,archive_name)
     archive.write(item,genre)
     if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(item,genre)
        end
        end
     end
   end

   archive_scf_results
   ! Save the SCF results in various archives on disk
      .archive_density_matrix
      .archive_molecular_orbitals
      .archive_orbital_energies
      .archive_fock_matrix
   end

   archive_density_matrix(archive_name)
   ! Save the density matrix in an archive on disk
     archive_name :: STR, optional
     name :: STR
     archive :: ARCHIVE
     name = "density_matrix"
     if (present(archive_name)) name = archive_name
     .archive(.density_matrix,name,with_lambda=TRUE)
   end

   archive_molecular_orbitals(archive_name)
   ! Save the molecular orbitals and energies in an archive on disk
     archive_name :: STR, optional
     name :: STR
     archive :: ARCHIVE
     name = "molecular_orbitals"
     if (present(archive_name)) name = archive_name
     .archive(.molecular_orbitals,name,with_lambda=TRUE)
   end

   archive_orbital_energies(archive_name)
   ! Save the orbitals energies in an archive on disk
     archive_name :: STR, optional
     name :: STR
     archive :: ARCHIVE
     name = "orbital_energies"
     if (present(archive_name)) name = archive_name
     .archive(.orbital_energies,name,with_lambda=TRUE)
   end

   archive_fock_matrix(archive_name)
   ! Save the fock matrix in an archive on disk
     archive_name :: STR, optional
     name :: STR
     archive :: ARCHIVE
     name = "fock_matrix"
     if (present(archive_name)) name = archive_name
     .archive(.fock_matrix,name)
   end

   archive_natural_orbitals(archive_name)
   ! Save the natural_orbitals in an archive on disk
     archive_name :: STR, optional
   ENSURE(.natural_orbitals.created,"no natural orbitals")
     name :: STR
     archive :: ARCHIVE
     name = "natural_orbitals"
     if (present(archive_name)) name = archive_name
     .archive(.natural_orbitals,name)
   end

   archive_occupation_numbers(archive_name)
   ! Save the natural occupation numbers in an archive on disk
     archive_name :: STR, optional
   ENSURE(.occupation_numbers.created,"no natural occupation numbers")
     name :: STR
     archive :: ARCHIVE
     name = "occupation_numbers"
     if (present(archive_name)) name = archive_name
     .archive(.occupation_numbers,name)
   end

   archive_energy(archive_name,genre)
   ! Save the density matrix in an archive on disk
     archive_name :: STR, optional
     genre :: STR, optional
   ENSURE(.scfdata.created,"no scf data")
     name :: STR
     archive :: ARCHIVE
     name = "energy"
     if (present(archive_name)) name = archive_name
     .archive(.scfdata.energy,name,genre,with_lambda=TRUE)
   end

   get_scf_results ::: leaky
   ! Get the SCF results in from archives. Do not get the density matrix,
   ! because it can/should be generated from the orbitals, depending on the kind
   ! of SCF.
     a_kind :: STR
     a_kind = .scfdata.molecular_orbital_kind
     .unarchive_molecular_orbitals(genre=a_kind)
     a_kind = .scfdata.orbital_energies_kind
     .unarchive_orbital_energies(genre=a_kind)
   end

   unarchive(opmatrix,archive_name,genre) ::: leaky
   ! Recover the "opmatrix" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opmatrix".
     opmatrix :: OPMATRIX*
     archive_name :: STR
     genre :: STR, optional
   ENSURE(opmatrix.any_created,"no opmatrix genre created")
     archive :: ARCHIVE
     archive.set(.name,archive_name)
     archive.read(opmatrix,genre)
   end

   unarchive(opvector,archive_name,genre) ::: leaky
   ! Recover the "opvector" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opvector".
     opvector :: OPVECTOR
     archive_name :: STR
     genre :: STR, optional
   ENSURE(opvector.any_created,"no opvector genre created")
     archive :: ARCHIVE
     archive.set(.name,archive_name)
     archive.read(opvector,genre)
   end

   unarchive(item,archive_name,genre) ::: leaky
   ! Recover the "item" from an archive on disk with name "archive_name".
     item :: REAL
     archive_name :: STR
     genre :: STR, optional
     archive :: ARCHIVE
     archive.set(.name,archive_name)
     archive.read(item,genre)
   end

   unarchive_object(archive_name,genre) ::: template
   ! Recover the object from an archive on disk
     archive_name,genre :: STR, optional
   ENSURE(.basis_info_made,"no basis set info")
     name :: STR
     name = "NAME"
     if (present(archive_name)) name = archive_name
     if (.NAME.destroyed) then
        ENSURE(present(genre),"missing genre")
        .NAME.create(.n_bf,genre)
     end
     .unarchive(.NAME,name,genre)
   end

   unarchive_density_matrix(archive_name,genre) ::: get_from(MOLECULE:unarchive_object, NAME=>density_matrix), leaky
   ! Recover the object from an archive on disk
   end

   unarchive_molecular_orbitals(archive_name,genre) ::: get_from(MOLECULE:unarchive_object, NAME=>molecular_orbitals), leaky
   ! Recover the object from an archive on disk
   end

   unarchive_orbital_energies(archive_name,genre) ::: get_from(MOLECULE:unarchive_object, NAME=>orbital_energies), leaky
   ! Recover the object from an archive on disk
   end

   unarchive_fock_matrix(archive_name,genre) ::: get_from(MOLECULE:unarchive_object, NAME=>fock_matrix), leaky
   ! Recover the object from an archive on disk
   end

   unarchive_natural_orbitals(archive_name,genre) ::: get_from(MOLECULE:unarchive_object, NAME=>natural_orbitals), leaky
   ! Recover the object from an archive on disk
   end

   unarchive_occupation_numbers(archive_name,genre) ::: get_from(MOLECULE:unarchive_object, NAME=>occupation_numbers), leaky
   ! Recover the object from an archive on disk
   end

   archive_exists(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
     archive_name,genre :: STR
     res :: BIN
     archive :: ARCHIVE
     archive.set(.name,archive_name,genre)
     res = archive.exists
   end

   archive_doesnt_exist(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
     archive_name,genre :: STR
     res :: BIN
     archive :: ARCHIVE
     archive.set(.name,archive_name,genre)
     res = NOT archive.exists
   end

! ********************
! SCF cleanup routines
! ********************

   destroy_scf_results ::: leaky
   ! Destroy the SCF results in memory
     .density_matrix.destroy
     .molecular_orbitals.destroy
     .orbital_energies.destroy
   end

   delete_scf_archives
   ! Delete any matrices stored on disk.
      archive :: ARCHIVE
      archive.set(.name,"fock_matrix");          archive.delete_all_genres
      archive.set(.name,"density_matrix");       archive.delete_all_genres
      archive.set(.name,"molecular_orbitals");   archive.delete_all_genres
      archive.set(.name,"orbital_energies");     archive.delete_all_genres
      archive.set(.name,"natural_orbitals");     archive.delete_all_genres
      archive.set(.name,"occupation_numbers");   archive.delete_all_genres
      archive.set(.name,"J_matrix");             archive.delete_all_genres
      archive.set(.name,"K_matrix");             archive.delete_all_genres
      .delete_tmp_scf_archives
      .delete_old_scf_archives
   end

   cleanup_scf ::: leaky
   ! Clean up the SCF files produced. NOTE: Does not delete integral files
     .delete_tmp_scf_archives
     .delete_old_scf_archives
     .delete_old_scf_matrices
     .scfdata.diis.reset_iteration_defaults
     .max_I.destroy ! leaky
   end

   delete_tmp_scf_archives
   ! Delete any temporary SCF archives.
      archive :: ARCHIVE
      archive.set(.name,"hartree_matrix");         archive.delete_all_genres
      archive.set(.name,"delta_density_matrix");   archive.delete_all_genres
      archive.set(.name,"constraint_matrix");      archive.delete_all_genres
      if (.scfdata.created) .scfdata.diis.cleanup
   end

   delete_scf_density_archive
   ! Delete the SCF density matrix archives
      archive :: ARCHIVE
      archive.set(.name,"density_matrix"); archive.delete_all_genres
   end

   delete_scf_MO_archive
   ! Delete the SCF MO archives
      archive :: ARCHIVE
      archive.set(.name,"molecular_orbitals"); archive.delete_all_genres
      archive.set(.name,"orbital_energies");   archive.delete_all_genres
   end

   delete_scf_fock_archive
   ! Delete the SCF fock matrix archives
      archive :: ARCHIVE
      archive.set(.name,"fock_matrix");        archive.delete_all_genres
   end

   delete_old_scf_archives
   ! Delete any old matrices stored on disk.
      archive :: ARCHIVE
      archive.set(.name,"old_fock_matrix");        archive.delete_all_genres
      archive.set(.name,"old_density_matrix");     archive.delete_all_genres
      archive.set(.name,"old_molecular_orbitals"); archive.delete_all_genres
      archive.set(.name,"old_orbital_energies");   archive.delete_all_genres
   end

   delete_old_scf_matrices
   ! Delete any old matrices stored in memory.
     .old_density_matrix.destroy
     .old_fock_matrix.destroy
   end

   delete_scf_integrals
   ! Delete all integral files. This is required whenever the geometry is
   ! changed.
      archive :: ARCHIVE
      archive.set(.name,"overlap_matrix");    archive.delete_all_genres
      archive.set(.name,"kinetic_matrix");    archive.delete_all_genres
      archive.set(.name,"nuclear_matrix");    archive.delete_all_genres
      archive.set(.name,"core_matrix");       archive.delete_all_genres
      archive.set(.name,"fock_matrix");       archive.delete_all_genres
      archive.set(.name,"constraint_matrix"); archive.delete_all_genres
      archive.set(.name,"eri_integrals");     archive.delete_all_genres
      archive.set(.name,"eri_index");         archive.delete_all_genres
      archive.set(.name,"ft_ints");           archive.delete_all_genres
      archive.set(.name,"dipole_x_matrix");   archive.delete_all_genres
      archive.set(.name,"dipole_y_matrix");   archive.delete_all_genres
      archive.set(.name,"dipole_z_matrix");   archive.delete_all_genres
      archive.set(.name,"quadrupole_xx_matrix"); archive.delete_all_genres
      archive.set(.name,"quadrupole_yy_matrix"); archive.delete_all_genres
      archive.set(.name,"quadrupole_zz_matrix"); archive.delete_all_genres
      archive.set(.name,"quadrupole_xy_matrix"); archive.delete_all_genres
      archive.set(.name,"quadrupole_xz_matrix"); archive.delete_all_genres
      archive.set(.name,"quadrupole_yz_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_xxx_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_yyy_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_zzz_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_xxy_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_xxz_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_yyx_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_yyz_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_zzx_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_zzy_matrix"); archive.delete_all_genres
      archive.set(.name,"octupole_xyz_matrix"); archive.delete_all_genres
   end

! *************************
! Canonicalisation routines
! *************************

   canonicalize_MOs
   ! Generate the Fock matrix from the molecular orbitals and diagonalise it
   ! on the occupied-occupied block to get the canonical molecular orbitals.
   ENSURE(.molecular_orbitals.created,"need old MOs!")
   ENSURE(.orbital_energies.created,"need old energies")
     scf_kind :: STR
     .make_scf_density_matrix
     .make_fock_matrix
     scf_kind = .scfdata.scf_kind
     select case (scf_kind)
        case ("rhf","rks","rohf","xray_rhf","xray_rks","noninteracting-group-rhf")
           .orbital_energies.destroy
           .orbital_energies.create(.n_bf,"restricted")
           .canonicalize_r_MO(.orbital_energies.restricted, &
                              .molecular_orbitals.restricted, &
                              .fock_matrix.restricted)
           stdout.flush
           stdout.text("Canonicalized molecular orbital energies:")
           stdout.put(.orbital_energies.restricted(1:.n_e/2), format="column")
        case default
           DIE("unknown scf kind, "//trim(scf_kind))
     end
   end

   canonicalize_r_MO(MO_energies,MO,F)
   ! Digaonalise the Fock matrix "F" in the occupied-occupied block of the
   ! molecular orbitals "MO", and reset the occupied "MO_energies".
     MO_energies :: VEC{REAL}
     MO,F :: MAT{REAL}
     G,U,MO_old :: MAT{REAL}*
     n :: INT
     n = .n_e/2
     G.create(n,n)
     U.create(n,n)
     MO_old.create(.n_bf,n)
     MO_old = MO(:,1:n)
     F.change_basis_to(G,MO_old)
     MO_energies = ZERO
     G.solve_eigenproblem(MO_energies,U)
     MO(:,1:n).to_product_of(MO_old,U)
     MO_old.destroy
     U.destroy
     G.destroy
   end

! ******************************
! Initial orbital guess routines
! ******************************

   get_initial_guess ::: leaky
   ! Get the initial guess for the ".density_matrix" and ".molecular_orbitals"
   ! If .scfdata.initial_mos is set, it overides .initial_density.
      initial_mos :: STR
      initial_mos = .scfdata.initial_mos
      if (initial_mos/=" ") then; .get_initial_MOs
      else;                       .get_initial_density
      end
   end

   get_initial_MOs ::: leaky
   ! Get the initial guess for the .molecular_orbitals
   ! Convert the .molecular_orbitals, if neccesary.
      initial_mos :: STR
      initial_mos = .scfdata.initial_mos
      select case (initial_mos)
         case("existing            ") ; ENSURE(.molecular_orbitals.created(.scfdata.molecular_orbital_kind),"no molecular orbitals")
         case("restricted          ") ; .read_old_MOs_guess
         case("unrestricted        ") ; .read_old_MOs_guess
         case("general             ") ; .read_old_MOs_guess
         case("restricted_complex  ") ; .read_old_MOs_guess
         case("complex_unrestricted") ; .read_old_MOs_guess
         case("unrestricted_complex") ; .read_old_MOs_guess
         case("general_complex     ") ; .read_old_MOs_guess
         case("complex_general     ") ; .read_old_MOs_guess
         case default;   UNKNOWN(initial_mos)
      end
   end

   read_old_MOs_guess ::: leaky
   ! Get the initial guess for the .molecular_orbitals by reading an old archive
   ! of .molecular_orbitals, and then make the SCF density matrix as well.
   ! Convert the .molecular_orbitals, if neccesary.
      arch :: ARCHIVE
      .molecular_orbitals.destroy
      .molecular_orbitals.create(.n_bf,.scfdata.initial_mos)
      arch.set(.name,"molecular_orbitals",genre=.scfdata.initial_mos)
      arch.read(.molecular_orbitals)
      .molecular_orbitals.convert_to(.scfdata.molecular_orbital_kind,.n_a,.n_b, &
                                     .scfdata.quantization_axis)
      .make_scf_density_matrix
      .orbital_energies.destroy
      .orbital_energies.create(.n_bf,genre=.scfdata.orbital_energies_kind)
   end

   make_atom_MOs_guess ::: leaky
   ! Get the initial guess for the .molecular_orbitals by getting the highest
   ! occupied restricted natural orbitals from the sum of atomic densities guess
   ! for the density matrix. Convert these .molecular_orbitals, if neccesary.
   ! Also make the SCF .density_matrix from these .molecular_orbitals.
      orb_kind :: STR
      arch :: ARCHIVE
      .get_promolecule_density
      if (.density_matrix.spinorbital_kind/="restricted") then
         arch.set(.name,"atom_density_matrix", genre="restricted")
         .density_matrix.destroy("restricted")
         arch.read(.density_matrix)
      end
      .make_natural_orbitals
      .put_natural_orbitals
      .assign_MOs_to_NOs
      orb_kind = .scfdata.molecular_orbital_kind
      .molecular_orbitals.convert_to(orb_kind,.n_a,.n_b,.scfdata.quantization_axis)
      .make_scf_density_matrix
      .orbital_energies.create(genre=.scfdata.orbital_energies_kind)
   end

   get_initial_density ::: leaky
   ! Get the initial guess for the ".density_matrix"
      initial_density :: STR
      initial_density = .scfdata.initial_density
      select case (initial_density)
         case("core                ") ; .make_core_guess
         case("fock                ") ; .make_fock_guess
         case("promolecule         ") ; .make_promolecule_guess
         case("progroup            ") ; .make_progroup_guess
         case("restricted          ") ; .make_density_guess
         case("unrestricted        ") ; .make_density_guess
         case("general             ") ; .make_density_guess
         case("restricted_complex  ") ; .make_density_guess
         case("complex_unrestricted") ; .make_density_guess
         case("unrestricted_complex") ; .make_density_guess
         case("general_complex     ") ; .make_density_guess
         case("complex_general     ") ; .make_density_guess
         case default;  DIE("unknown density, "//trim(initial_density))
      end
   end

   make_density_guess ::: leaky
   ! Read an old .density_matrix of type "initial_guess" and use it to
   ! make initial .molecular_orbitals to start an scf calculation.
   ! Convert the .density_matrix, if neccesary.
      arch :: ARCHIVE
      .density_matrix.destroy
      .density_matrix.create(.n_bf,.scfdata.initial_density)
      arch.set(.name,"density_matrix")
      arch.read(.density_matrix,genre=.scfdata.initial_density)
      .density_matrix.convert_to(newkind = .scfdata.spinorbital_kind)
      .make_fock_matrix  ! Make a fock matrix
      .make_fock_guess   ! Get a reasonable set of starting MO's
   end

   make_core_guess ::: leaky
   ! Do a core scf for the ".density_matrix", ".molecular_orbitals" and
   ! ".orbital_energies"
     orb_kind :: STR
     .destroy_scf_results
     .orbital_energies.destroy
     .orbital_energies.create(.n_bf,"restricted")
     .molecular_orbitals.destroy
     .molecular_orbitals.create(.n_bf,"restricted")
     .make_r_core_guess(.orbital_energies.restricted,.molecular_orbitals.restricted)
     orb_kind = .scfdata.orbital_energies_kind
     .orbital_energies.convert_to(orb_kind)
     orb_kind = .scfdata.molecular_orbital_kind
     .molecular_orbitals.convert_to(orb_kind,.n_a,.n_b,.scfdata.quantization_axis)
     .make_scf_density_matrix
     .make_fock_matrix  ! Make a fock matrix (only to get MO's)
     .make_fock_guess   ! Get a reasonable set of starting MO's
   end

   make_r_core_guess(MO_energies,MO)
   ! Do a real core scf for the molecular orbital energies  "MO_energies"
   ! and the molecular_orbitals "MO"
     MO_energies :: VEC{REAL}
     MO :: MAT{REAL}
     S,R,H :: MAT{REAL}* DEFAULT_NULL
     !  H~ = S^-1/2 H S^-1/2
     !  c  = S^-1/2 c~
     S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
     R.create(.n_bf,.n_bf); R.to_inverse_sqrt_of(S)
     H.create(.n_bf,.n_bf); .get_core_matrix(H)
     S.to_product_of(R,H)
     H.to_product_of(S,R)
     H.solve_eigenproblem(MO_energies,MO)
     H.to_product_of(R,MO)
     MO = H
     H.destroy
     R.destroy
     S.destroy
   end

   make_promolecule_guess ::: leaky
   ! Make a ".density matrix" and fock matrix from the sum of atomic densities.
   ! Then get initial orbitals from this fock matrix, and make the density
   ! corresponding to these initial orbitals.
   ENSURE(.scfdata.scf_kind/="rohf","atom guess not available for ROHF")
      .get_promolecule_density
      .make_fock_matrix       ! Make a fock matrix (only to get MO's)
      .make_fock_guess        ! Get a reasonable set of starting MO's
   end

   get_promolecule_density ::: leaky
   ! Reads ".density_matrix" from the archive, otherwise makes it and
   ! writes to the arch.
      archive :: ARCHIVE
      archive.set(.name,"atom_density_matrix",genre="restricted")
      if (.scfdata.destroyed) then
         .make_promolecule_density
         archive.write(.density_matrix)
      else if (NOT .scfdata.using_direct_scf AND archive.exists) then
         .density_matrix.destroy
         .density_matrix.create(.n_bf,"restricted")
         archive.read(.density_matrix)
      else
         .make_promolecule_density
         if (NOT .scfdata.using_direct_scf) archive.write(.density_matrix)
      end
     .density_matrix.convert_to(.scfdata.spinorbital_kind,factor=HALF)
   end

   make_promolecule_density ::: leaky
   ! Make a ".density matrix" from the sum of atomic densities
   ! if output is present and FALSE the density matrix is not archived
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.basis.created,"no basis info")
   ENSURE(.atom.created,"no atom info")
     k,l,kl,a,b :: INT
     mol :: MOLECULE*
     first,last :: VEC{INT}*
     atom_kind :: VEC{VEC_{INT}}*
     archive :: ARCHIVE
     .density_matrix.destroy
     .density_matrix.create(.n_bf,"restricted")
     .density_matrix.restricted = ZERO
     .atom.make_atom_basis_fn_limits(first,last)
     .atom.make_atom_kind_list(atom_kind)
     do k = 1,size(atom_kind) ! Do an SCF for every different kind of atom
       mol.create
       l = atom_kind(k).element(1)
       .make_molecule_from_atom(l,mol)
       if (mol.no_of_electrons >= 1) then
         archive.set(mol.name)
         if (archive.exists) then
            archive.read(.density_matrix,genre=.scfdata.spinorbital_kind)
         else
          ! mol.scfdata.output = FALSE
          ! mol.scfdata.output = TRUE
          ! mol.scfdata.using_fock_diis = TRUE
          ! mol.scfdata.diis.set_genre("ediis")
            mol.scfdata.using_fock_diis = TRUE
          ! mol.scfdata.using_MO_diis = FALSE
            mol.scfdata.using_rough_convergence = FALSE
            mol.scfdata.using_direct_scf = TRUE
            mol.scf                             ! <<<<<<< SCF <<<<<<
         end
         mol.make_ao_density_matrix
         mol.pointgroup.create("oh")
         mol.symmetrise(mol.density_matrix)
         do l = 1,size(atom_kind(k).element) ! Copy this atom density to every
           kl = atom_kind(k).element(l)      ! atom of this kind
           a = first(kl); b = last(kl)
          .density_matrix.restricted(a:b,a:b) = &
          .density_matrix.restricted(a:b,a:b) &
          + mol.density_matrix.restricted
         end
       end
       mol.atom.nullify_ptr_part ! do not destroy these
       nullify(mol.basis)        ! do not destroy this
       nullify(mol.slaterbasis)  ! do not destroy this
       nullify(mol.coppensbasis) ! do not destroy this
       mol.delete_scf_integrals
       mol.delete_scf_archives
       mol.destroy
     end
     .density_matrix.restricted.symmetric_reflect
     atom_kind.destroy
     last.destroy
     first.destroy
   end

   make_progroup_guess ::: leaky
   ! Make a ".density matrix" and fock matrix from the sum of noninteracting
   ! atom_group densities. Then get initial orbitals from this fock matrix,
   ! and make the density corresponding to these initial orbitals.
   ENSURE(.scfdata.scf_kind/="rohf","atom guess not available for ROHF")
      .get_progroup_density
      .make_fock_matrix       ! Make a fock matrix (only to get MO's)
      .make_fock_guess        ! Get a reasonable set of starting MO's
   end

   get_progroup_density ::: leaky
   ! Reads ".density_matrix" from the archive, otherwise makes it and
   ! writes to the arch.
     arch :: ARCHIVE
     arch.set(.name,"group_density_matrix", genre="restricted")
     if (arch.exists) then
        .density_matrix.destroy
        .density_matrix.create(.n_bf,"restricted")
        arch.read(.density_matrix)
     else
        .make_progroup_density
     end
     .density_matrix.convert_to(.scfdata.spinorbital_kind,factor=HALF)
   end

   make_progroup_density(MOs,output) ::: leaky
   ! Make a ".density matrix" from the sum of atom_group densities.
   ! If "MOs" is present and true, make ".molecular_orbitals" which
   ! are the columns of orbitals from each group and also make the
   ! ".occupation_numbers" vector set to 2 for the occupied group MO's.
   ! If output is present and FALSE the density matrix is not archived
     MOs :: BIN, optional
     output :: BIN, optional
   ENSURE(.atom_group.created,"no atom_group info")
     do_output,do_MOs :: BIN
     g,n_g,a,b,aa,bb,faa,laa,fbb,lbb,fa,la,fb,lb, ms,mf, no :: INT
     mol :: MOLECULE*
     arch :: ARCHIVE
     do_output=TRUE
     if (present(output)) do_output=output
     do_MOs=FALSE
     if (present(MOs)) do_MOs=MOs
     .density_matrix.destroy
     .density_matrix.create(.n_bf,"restricted")
     .density_matrix.restricted = ZERO
     if (do_MOs) then
     .molecular_orbitals.destroy
     .molecular_orbitals.create(.n_bf,"restricted")
     .molecular_orbitals.restricted = ZERO
     .occupation_numbers.destroy
     .occupation_numbers.create(.n_bf,"restricted")
     .occupation_numbers.restricted = ZERO
     end
     n_g = size(.atom_group)
     .atom_group_energy.destroy
     .atom_group_energy.create(n_g)
     .atom_group_energy = ZERO
     mf = 0
     do g = 1,n_g ! Do an SCF for every atom group
       mol.create
       .make_molecule_from_atom_group(g,mol)
       if (mol.no_of_electrons >= 1) then
       ! mol.scfdata.output = TRUE
         mol.scfdata.using_direct_scf = TRUE
         mol.scfdata.using_rough_convergence = FALSE
         mol.scfdata.using_fock_diis = TRUE
         if (.atom_group(g).element.dim>1) &
           mol.scfdata.initial_density = "promolecule"
         mol.scf
         .atom_group_energy(g) = mol.scfdata.energy
         if (.mos_per_group.created) then; 
            stdout.show("using fewer MOs = ",.mos_per_group(g))
            stdout.text("normal P:")
            mol.make_ao_density_matrix
            stdout.put(mol.density_matrix.restricted)
            stdout.text("reduced P:")
            mol.make_scf_density_matrix(method="progroup",n_a=.mos_per_group(g))
            stdout.put(mol.density_matrix.restricted)
         else;                             
            mol.make_ao_density_matrix
         end
         do a = 1,size(.atom_group(g).element) ! Copy this atom density
         do b = 1,size(.atom_group(g).element)
            aa  = .atom_group(g).element(a)
            bb  = .atom_group(g).element(b)
            faa = .first_basis_fn_for_atom(aa)
            fbb = .first_basis_fn_for_atom(bb)
            laa = .last_basis_fn_for_atom(aa)
            lbb = .last_basis_fn_for_atom(bb)
            fa  = mol.first_basis_fn_for_atom(a)
            fb  = mol.first_basis_fn_for_atom(b)
            la  = mol.last_basis_fn_for_atom(a)
            lb  = mol.last_basis_fn_for_atom(b)
            .density_matrix.restricted(faa:laa,fbb:lbb) = &
            .density_matrix.restricted(faa:laa,fbb:lbb) &
            + mol.density_matrix.restricted(fa:la,fb:lb)
         end
         end
         if (do_MOs) then
         ms = mf + 1
         mf = mf + mol.n_bf
         do a = 1,size(.atom_group(g).element)
            aa  = .atom_group(g).element(a)
            faa = .first_basis_fn_for_atom(aa)
            laa = .last_basis_fn_for_atom(aa)
            fa  = mol.first_basis_fn_for_atom(a)
            la  = mol.last_basis_fn_for_atom(a)
            .molecular_orbitals.restricted(faa:laa,ms:mf) = &
            .molecular_orbitals.restricted(faa:laa,ms:mf) &
            + mol.molecular_orbitals.restricted(fa:la,:)
         end
         no = mol.n_e/2
         .occupation_numbers.restricted(ms:ms+no-1) = TWO
         end
       end
       mol.atom.nullify_ptr_part ! do not destroy these
       nullify(mol.basis)        ! do not destroy this
       nullify(mol.slaterbasis)  ! do not destroy this
       nullify(mol.coppensbasis) ! do not destroy this
       mol.delete_scf_integrals
     ! mol.delete_scf_archives   ! keep group density matrices, etc ...
       mol.delete_old_scf_archives
       mol.destroy
     end
     if (do_output) then
       arch.set(.name,"group_density_matrix", genre="restricted")
       arch.write(.density_matrix, genre="restricted")
     end
     if (do_output AND do_MOs) then
       arch.set(.name,"group_molecular_orbitals", genre="restricted")
       arch.write(.molecular_orbitals, genre="restricted")
     end
   end

   make_group_energies(g,E_SCF,E_T,E_Z,E_C,E_K,fac)
   ! Assuming group densities exist (see .make_progroup_density), then for group
   ! number "g" make the group SCF energy "E_SCF", the group kinetic energy
   ! "E_T", the group nuclear attraction energy "E_Z", the group coulomb energy
   ! "E_C", and the group exchange energy "E_K". If "fac" is present, multiply
   ! all the energy values by this factor.
     g :: INT
     E_SCF,E_T,E_Z,E_C,E_K :: REAL
     fac :: REAL, optional
   ENSURE(.atom_group.created,"no atom_group info")
     mol :: MOLECULE*
     archive :: ARCHIVE
     P,T,Z,C,K :: MAT{REAL}*
     mol.create
     .make_molecule_from_atom_group(g,mol)
     E_SCF = ZERO
     E_T = ZERO
     E_Z = ZERO
     E_C = ZERO
     E_K = ZERO
     if (mol.no_of_electrons >= 1) then
        archive.set(mol.name,"density_matrix","restricted")
        P.create(mol.n_bf,mol.n_bf)
        archive.read(P)
        E_SCF = .atom_group_energy(g)
        T.create(mol.n_bf,mol.n_bf)
        mol.get_kinetic_matrix(T)
        E_T = T.trace_product_with(P)
        T.destroy
        Z.create(mol.n_bf,mol.n_bf)
        mol.get_nuclear_matrix(Z)
        E_Z = Z.trace_product_with(P)
        mol.make_nuclear_matrix(Z)
        Z.destroy
        !
        C.create(mol.n_bf,mol.n_bf)
        K.create(mol.n_bf,mol.n_bf)
        mol.make_r_JK_nosym(C,K,P)
        E_C = HALF*C.trace_product_with(P)
        E_K = -QUARTER*K.trace_product_with(P)
        K.destroy
        C.destroy
        P.destroy
     end
     mol.atom.nullify_ptr_part ! do not destroy these
     nullify(mol.basis)        ! do not destroy this
     nullify(mol.slaterbasis)  ! do not destroy this
     nullify(mol.coppensbasis) ! do not destroy this
     mol.delete_scf_integrals
   ! mol.delete_scf_archives   ! keep group density matrices, etc ...
     mol.delete_old_scf_archives
     mol.destroy
     if (present(fac)) then
        E_SCF = fac*E_SCF
        E_T   = fac*E_T
        E_Z   = fac*E_Z
        E_C   = fac*E_C
        E_K   = fac*E_K
     end
   end

   make_fock_guess ::: leaky
   ! From an initial .fock_matrix make the .molecular_orbitals, and
   ! .orbital_energies.  Then make the .density_matrix from these orbitals.
   ! Destroy .fock_matrix afterwards
     orb_kind :: STR
     e :: VEC{REAL}*
     MO,F :: MAT{REAL}*
     MOc,Fc :: MAT{CPX}*
     orb_kind = .scfdata.spinorbital_kind
   ENSURE(.fock_matrix.created(orb_kind),"need an initial fock matrix")
     .destroy_scf_results
     orb_kind = .scfdata.scf_kind
     select case (orb_kind)
     !  F~ = S^-1/2 F S^-1/2
     !  c  = S^-1/2 c~
        case ("rhf","rks","rohf","xray_rhf","xray_rks","noninteracting-group-rhf")
           .orbital_energies.create(.n_bf,"restricted")
           .molecular_orbitals.create(.n_bf,"restricted")
           e  => .orbital_energies.restricted
           MO => .molecular_orbitals.restricted
           F  => .fock_matrix.restricted
           .make_r_fock_guess(e,MO,F)
        case ("uhf","uks","xray_uhf","xray_uks", &
              "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
           .orbital_energies.create(.n_bf,"unrestricted")
           .molecular_orbitals.create(.n_bf,"unrestricted")
           e  => .orbital_energies.alpha
           MO => .molecular_orbitals.alpha
           F  => .fock_matrix.alpha
           .make_r_fock_guess(e,MO,F)
           e  => .orbital_energies.beta
           MO => .molecular_orbitals.beta
           F  => .fock_matrix.beta
           .make_r_fock_guess(e,MO,F)
        case ("gchf")
           .orbital_energies.create(.n_bf,"general")
           .molecular_orbitals.create(.n_bf,"general_complex")
           e   => .orbital_energies.general
           MOc => .molecular_orbitals.general_complex
           Fc  => .fock_matrix.general_complex
           .make_gc_fock_guess(e,MOc,Fc)
        case default;  DIE("unknown kind, "//trim(orb_kind))
     end
     orb_kind = .scfdata.spinorbital_kind
     .fock_matrix.destroy(orb_kind)
     .make_scf_density_matrix
   end

   make_r_fock_guess(MO_energies,MO,fock_matrix)
   ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
   ! a given real restricted "fock_matrix".
     MO_energies :: VEC{REAL}
     MO, fock_matrix :: MAT{REAL}
     S,R,H :: MAT{REAL}*
     !  F~ = S^-1/2 F S^-1/2
     !  c  = S^-1/2 c~
     S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
     R.create(.n_bf,.n_bf); R.to_inverse_sqrt_of(S)
     H.create(.n_bf,.n_bf); H = fock_matrix
     S.to_product_of(R,H)
     H.to_product_of(S,R)
     H.solve_eigenproblem(MO_energies,MO)
     H.to_product_of(R,MO)
     MO = H
     H.destroy
     R.destroy
     S.destroy
   end

   make_gc_fock_guess(MO_energies,MO,fock_matrix)
   ! Make/guess the orbital energies "MO_energies" and orbitals "MO" from
   ! a given complex general "fock_matrix".
     MO_energies :: VEC{REAL}
     MO, fock_matrix :: MAT{CPX}
     S,R :: MAT{REAL}*
     H,W :: MAT{CPX}*
     !  F~ = S^-1/2 F S^-1/2
     !  c  = S^-1/2 c~
     S.create(.n_bf,.n_bf)
     R.create(.n_bf,.n_bf)
     .get_overlap_matrix(R)
     S.to_inverse_sqrt_of(R)
     R.destroy
     R.create(2*.n_bf,2*.n_bf); R=ZERO
     R.alpha_alpha_set_to(S)
     R.beta_beta_set_to(S)
     S.destroy
     H.create(2*.n_bf,2*.n_bf); H = fock_matrix
     W.create(2*.n_bf,2*.n_bf)
     W = matmul(R,H)
     H = matmul(W,R)
     W.destroy
     H.solve_eigenproblem(MO_energies,MO)
     H = matmul(R,MO)
     MO = H
     H.destroy
     R.destroy
   end

! **************************
! DIIS/Orbital extrapolation
! **************************

   make_diis_error_length(length)
   ! Make the SCF error vector from the current fock_matrix and
   ! density_matrix, and return the error "length".  Useful for reporting the
   ! error length.
      length :: REAL
   ENSURE(.fock_matrix.created,"no fock matrix")
   ENSURE(.fock_matrix.any_created,"no fock matrix")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.any_created,"no density matrix")
      S :: MAT{REAL}*
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      .scfdata.diis.set_diis_error_length(.fock_matrix,.density_matrix,S)
      length = .scfdata.diis.error_length
 ! stdout.show("diis error =",length)
 ! write(*,*) "diis error =",length
      S.destroy
   end

!   make_diis_error(error,F,D)
!   ! Make the SCF "error" vector from the current fock_matrix and
!   ! density_matrix.
!      error :: OPMATRIX*
!      F,D :: OPMATRIX*, optional
!      fock_matrix,density_matrix :: OPMATRIX*
!      fock_matrix => .fock_matrix
!      if (present(F)) fock_matrix => F
!      density_matrix => .density_matrix
!      if (present(D)) density_matrix => D
!      select case (.scfdata.scf_kind)
!         case ("rhf","rks","xray_rhf","xray_rks","embedded_rhf","crystal_rhf","noninteracting-group-rhf")
!            .make_r_diis_error(error.restricted,fock_matrix.restricted,density_matrix.restricted)
!         case ("rohf")
!            .make_r_diis_error(error.restricted,fock_matrix.restricted,density_matrix.alpha)
!         case ("uhf","uks","xray_uhf","xray_uks","pnd_uhf","xray_pnd_uhf")
!            .make_r_diis_error(error.alpha,fock_matrix.alpha,density_matrix.alpha)
!            .make_r_diis_error(error.beta, fock_matrix.beta, density_matrix.beta)
!         case ("gchf")
!            .make_gc_diis_error(error.general_complex,fock_matrix.general_complex,density_matrix.general_complex)
!         case default;  DIE("unknown kind, "//trim(.scfdata.scf_kind))
!      end
!   end

   accelerate_fock_matrix
   ! Accelerate the convergence of the fock matrix, currently only using DIIS.
   ENSURE(.scfdata.created,"no scf data")
   ENSURE(.fock_matrix.created,"no fock matrix")
   ENSURE(.density_matrix.created,"no density matrix")
     scf_kind :: STR
     S :: MAT{REAL}*
     J,C :: OPMATRIX*
     energy :: VEC{REAL}*
     if (NOT .scfdata.using_fock_diis) return
     ! Reset DIIS if convergence criteria altered
     if (.scfdata.eri_cutoff_altered) .scfdata.diis.kept = 0
     S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
     energy => .scf_electronic_energies
     scf_kind = .scfdata.scf_kind
     select case (scf_kind)
       case ("rhf","rks","xray_rhf","xray_rks", &
             "embedded_rhf","crystal_rhf","noninteracting-group-rhf")
          .scfdata.diis.accelerate(.fock_matrix,.density_matrix,S,energy)
       case ("rohf")
          .scfdata.diis.accelerate(.fock_matrix,.density_matrix,S,energy)
       case ("uhf","uks","xray_uhf","xray_uks", &
             "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")
          J.create(.n_bf,"unrestricted")
          .unarchive(J,"J_matrix",genre="unrestricted")
     ! stdout.put(energy,"column")
     ! stdout.text("J.alpha:")
     ! stdout.put(J.alpha)
     ! stdout.text("J.beta:")
     ! stdout.put(J.beta)
          .scfdata.diis.accelerate(.fock_matrix,.density_matrix,S,energy,J)
          J.destroy
       case ("gchf")
        DIE("not yet implemented")
        ! error.create(.n_bf,"general_complex")
        ! Fc  => .fock_matrix.general_complex
        ! Pc  => .density_matrix.general_complex
        ! .make_gc_diis_error(error.general_complex,Fc,Pc)
        ! error.compress
        ! err_len = error.square.norm
        ! .fock_matrix.compress
        ! .scfdata.diis.extrapolate_fock(.fock_matrix.square,error.square)
        ! .fock_matrix.uncompress
       case default;          DIE("unknown SCF kind, "//trim(scf_kind))
     end
     energy.destroy
     S.destroy
   ! .scfdata.diis.nullify_matrices
     .scfdata.set_diis_error(.scfdata.diis.error_length)
     ! Save the constraint matrix for acceleration of multiple fits
     if (.scfdata.scf_kind.includes("xray_")) then
        C.create(.n_bf,.scfdata.spinorbital_kind)
        .unarchive(C,"constraint_matrix")
        .scfdata.diis.save_current_item(C,"constraint_matrix")
        C.destroy
     end
   end

   make_r_diis_error(error,F,P)
   ! Make the real DIIS error matrix, error = FPS - SPF
      error,F,P :: MAT{REAL}
      S,W :: MAT{REAL}*
      W.create(.n_bf, .n_bf)
      S.create(.n_bf, .n_bf); .get_overlap_matrix(S)
      W.to_product_of(P,S)
      S.destroy
      error.to_product_of(F,W)
      W.destroy
      error.antisymmetric_fold
      error.antisymmetric_reflect
   end

   make_gc_diis_error(error,F,P)
   ! Make the complex general DIIS error matrix, error = FPS - SPF
      error,F,P :: MAT{CPX}
       R :: MAT{REAL}*
      S,W :: MAT{CPX}*
      W.create(2*.n_bf, 2*.n_bf)
      S.create(2*.n_bf,2*.n_bf); S=ZERO
      R.create(.n_bf,.n_bf)
      .get_overlap_matrix(R)
      S.alpha_alpha_set_to(R)
      S.beta_beta_set_to(R)
      R.destroy
      W.to_product_of(P,S)
      S.destroy
      error.to_product_of(F,W)
      W.destroy
      error.antihermitian_fold
      error.make_antihermitian
   end

! ********************
! Fock matrix routines
! ********************

   get_fock_matrix ::: leaky
   ! Get the Fock matrix.
   ! If the archive file exists, read it. Otherwise make it.
   ENSURE(.scfdata.created,"no scfdata")
      archive :: ARCHIVE
      orb_kind :: STR
      orb_kind = .scfdata.spinorbital_kind
      archive.set(.name,"fock_matrix",orb_kind)
      if (archive.exists) then; archive.read(.fock_matrix)
      else;                     .make_fock_matrix
      end
   end

   make_fock_matrix(core,r12) ::: leaky
   ! If r12  is present and FALSE, the r12 part is not computed.
   ! NOTE: The computed fock matrix is immediately archived to disk.
     core,r12 :: BIN, optional
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.created(.scfdata.spinorbital_kind),"incompatible density")
     dP,dF :: OPMATRIX*
     genre :: STR
     do_delta_build,DFT_calculation :: BIN
     delta_archive,archive :: ARCHIVE
     .fock_matrix.destroy
     .fock_matrix.create(.n_bf)
     ! Determine whether to use a delta fock matrix build
     genre = .density_matrix.spinorbital_kind
     delta_archive.set(.name,"delta_density_matrix",genre)
     DFT_calculation = .scfdata.is_DFT_calculation
     if (DFT_calculation) then; archive.set(.name,"hartree_matrix",genre)
     else;                      archive.set(.name,"fock_matrix",genre)   
     end
     do_delta_build = .scfdata.do_delta_build AND delta_archive.exists AND archive.exists
     if (do_delta_build) then         ! DO NOT do exchange correlation part
        dF.create(.n_bf)              ! It does not work with delta build
        dP.create(.n_bf)
        delta_archive.read(dP)
        .make_fock_matrix(dP,dF,core=FALSE,r12=r12,xc=FALSE)
        dP.destroy
        archive.read(.fock_matrix)
        .fock_matrix.plus(dF)
        dF.destroy
     else
        .make_fock_matrix(.density_matrix,.fock_matrix,core,r12,xc=FALSE)
     end
     if (DFT_calculation) then        ! Now explicitly do the XC part if needed
        if (.scfdata.using_delta_build) archive.write(.fock_matrix) ! Archive for delta build
        .add_XC_matrix(.fock_matrix)
     end
     .archive_fock_matrix
   end

   make_fock_matrix(P,F,core,r12,xc) ::: leaky
   ! For the quicker ERI method.
   ! If r12  is present and FALSE, the r12 part is not computed
     P,F :: OPMATRIX*
     core,r12,xc :: BIN, optional
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(P.created,"no density matrix")
   ENSURE(P.created(.scfdata.spinorbital_kind),"incompatible density")
     direct :: BIN
     direct = .scfdata.using_direct_scf
     if (NOT direct) .get_ERI_integrals
     .scfdata.dft_energy_correction       = ZERO ! Set these to zero since
     .scfdata.dft_alpha_energy_correction = ZERO ! they may be calculated
     .scfdata.dft_beta_energy_correction  = ZERO
     select case (.scfdata.scf_kind)
        case ("rhf","xray_rhf","embedded_rhf")
           .make_r_fock(P,F,direct,core,r12)
        case ("rks","xray_rks")
           .make_r_KS_fock(P,F,direct,core,r12,xc)
        case ("crystal_rhf")
           .make_r_crystal_fock(P,F,direct,core,r12)
        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
           .make_u_KS_fock(P,F,direct,core,r12,xc)
        case ("noninteracting-group-rhf")
           .make_r_group_fock(P,F,direct,core,r12)
        case ("rohf")
           .make_ro_fock(P,F,direct,core,r12)
        case ("uhf","xray_uhf","pnd_uhf","xray_pnd_uhf")
           .make_u_fock(P,F,direct,core,r12)
        case ("gchf","cghf")
           .make_gc_fock(P,F,direct,core,r12)
           .add_gc_so_fock(P,F)
        case default;  DIE("unknown SCF kind, "//trim(.scfdata.scf_kind))
     end
   end

   add_core_hamiltonian(F,nuclei)
   ! Add the core hamiltonain to "F"
   ! if "nuclei" is present then the core_matrix is calculated using
   ! only the nuclei specified
      F :: MAT{REAL}
      nuclei :: VEC{INT}, optional
      H :: MAT{REAL}*
      H.create(.n_bf, .n_bf)
      .get_core_matrix(H,nuclei)
      F = F + H
      H.destroy
   end

   add_core_hamiltonian(Fa,Fb)
   ! Add the core hamiltonain to "Fa" and "Fb"
      Fa,Fb :: MAT{REAL}
      H :: MAT{REAL}*
      H.create(.n_bf, .n_bf)
      .get_core_matrix(H)
      Fa = Fa + H
      Fb = Fb + H
      H.destroy
   end

   add_core_hamiltonian(F,nuclei)
   ! Add the core hamiltonain to a general complex "F"
      F :: MAT{CPX}
      nuclei :: VEC{INT}, optional
      HH :: MAT{CPX}*
      H,S,T,xx,yy,zz,xy,xz,yz,Lx,Ly,Lz :: MAT{REAL}*
      BB :: MAT{REAL}(3,3)
      k,l :: INT
      fac :: REAL
      I :: CPX
      HH.create(2*.n_bf, 2*.n_bf); HH = ZERO
      H.create(.n_bf, .n_bf)
      .get_core_matrix(H,nuclei)
      HH.alpha_alpha_plus(H)
      HH.beta_beta_plus(H)
      H.destroy
      I = (ZERO,ONE)
      if (.scfdata.using_1e_sl_term) then
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .get_spin_orbit_matrices(Lx,Ly,Lz)
            fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
            fac = fac * .scfdata.sl_1e_factor
            HH.beta_alpha_plus(Lx,factor=-fac*I)
            HH.beta_alpha_plus(Ly,factor=fac)
            HH.alpha_alpha_plus(Lz,factor=-fac*I)
            HH.beta_beta_plus(Lz,factor=fac*I)
            Lz.destroy; Ly.destroy; Lx.destroy
      else if (.scfdata.using_1e_zora_term) then
            T.create(.n_bf,.n_bf)
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .get_1e_ZORA_matrices(T,Lx,Ly,Lz)
            HH.alpha_alpha_plus(T)
            HH.beta_beta_plus(T)
            .get_kinetic_matrix(T) ! remove normal kinetic energy
            HH.alpha_alpha_plus(T,factor=-ONE)
            HH.beta_beta_plus(T,factor=-ONE)
            fac = G_FACTOR/TWO
            fac = fac * .scfdata.sl_1e_factor
            HH.beta_alpha_plus(Lx,factor=-fac*I)
            HH.beta_alpha_plus(Ly,factor=fac)
            HH.alpha_alpha_plus(Lz,factor=-fac*I)
            HH.beta_beta_plus(Lz,factor=fac*I)
            T.destroy
            Lz.destroy; Ly.destroy; Lx.destroy
      end
      if (NOT .B_field.is_zero) then
         if (.scfdata.using_bs_term) then
            S.create(.n_bf,.n_bf)
            .get_overlap_matrix(S)
            fac = G_FACTOR/FOUR
            HH.alpha_alpha_plus(S,factor=fac*.B_field(3))
            HH.beta_beta_plus(S,factor=-fac*.B_field(3))
            HH.beta_alpha_plus(S,factor=fac*.B_field(1))
            HH.beta_alpha_plus(S,factor=fac*.B_field(2)*I)
            S.destroy
         end
         if (.scfdata.using_bs_t_term) then
            T.create(.n_bf,.n_bf)
            .get_kinetic_matrix(T)
            fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU**2)
            HH.alpha_alpha_plus(T,factor=fac*.B_field(3))
            HH.beta_beta_plus(T,factor=-fac*.B_field(3))
            HH.beta_alpha_plus(T,factor=fac*.B_field(1))
            HH.beta_alpha_plus(T,factor=fac*.B_field(2)*I)
            T.destroy
         end
         if (.scfdata.using_bl_term) then
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .get_L_matrices(Lx,Ly,Lz)
            Lx = Lx*.B_field(1) + Ly*.B_field(2) + Lz*.B_field(3)
            fac = HALF
            HH.alpha_alpha_plus(Lx,factor=fac*I)
            HH.beta_beta_plus(Lx,factor=fac*I)
            Lz.destroy; Ly.destroy; Lx.destroy
         end
         if (.scfdata.using_aa_term) then
           xx.create(.n_bf,.n_bf); yy.create(.n_bf,.n_bf); zz.create(.n_bf,.n_bf)
           xy.create(.n_bf,.n_bf); xz.create(.n_bf,.n_bf); yz.create(.n_bf,.n_bf)
           .get_quadrupole_matrices(xx,yy,zz,xy,xz,yz)
           fac = ONE/EIGHT
           do k = 1,3
              BB(k,k) = fac*(sum(.B_field*.B_field) - .B_field(k)*.B_field(k))
           end
           do k = 1,3
           do l = k+1,3
              BB(k,l) = -TWO*fac*.B_field(k)*.B_field(l)
           end
           end
           xx =      BB(1,1)*xx; xx = xx + BB(2,2)*yy; xx = xx + BB(3,3)*zz
           xx = xx + BB(1,2)*xy; xx = xx + BB(1,3)*xz; xx = xx + BB(2,3)*yz
           HH.alpha_alpha_plus(xx)
           HH.beta_beta_plus(xx)
           yz.destroy; xz.destroy; xy.destroy
           zz.destroy; yy.destroy; xx.destroy
         end
         if (.scfdata.using_1e_srxa_term) then
            Lx.create(.n_bf,.n_bf)
            Ly.create(.n_bf,.n_bf)
            Lz.create(.n_bf,.n_bf)
            .get_spin_orbit_B_matrices(Lx,Ly,Lz)
            fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
            HH.beta_alpha_plus(Lx,factor=fac)
            HH.beta_alpha_plus(Ly,factor=fac*I)
            HH.alpha_alpha_plus(Lz,factor=fac)
            HH.beta_beta_plus(Lz,factor=-fac)
            Lz.destroy; Ly.destroy; Lx.destroy
         end
      end
      HH.make_hermitian
      F = HH + F
      HH.destroy
   end

   make_r_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new restricted Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
     direct,core,r12 :: BIN, optional
     P,F :: OPMATRIX*
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.restricted.created, "no density matrix")
     J,K :: MAT{REAL}*
     do_direct,add_core,add_r12 :: BIN
     F.destroy("restricted")
     F.create("restricted")
     do_direct= FALSE
     add_core = TRUE
     add_r12  = TRUE
     if (present(direct)) do_direct = direct
     if (present(core))   add_core = core
     if (present(r12))    add_r12  = r12
     if (add_r12) then
        J.create(.n_bf,.n_bf)
        K.create(.n_bf,.n_bf)
        if (do_direct) then; .make_r_JK_direct2(J,K,P.restricted)
        else;                .make_r_JK_disk(J,K,P.restricted)
        end
        F.restricted = J - HALF*K
        K.destroy
        J.destroy
     else
        F.restricted = ZERO
     end
     if (add_core) .add_core_hamiltonian(F.restricted)
   end

   make_r_KS_fock(P,F,direct,core,r12,xc) ::: leaky
   ! Make a new restricted Kohn-Sham Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
   ! If present and FALSE, "xc"  removes the exchange correlation part
     direct,core,r12,xc :: BIN, optional
     P,F :: OPMATRIX*
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.restricted.created, "no density matrix")
     J :: MAT{REAL}*
     do_direct,add_core,add_r12,add_xc :: BIN
     F.destroy("restricted")
     F.create("restricted")
     do_direct= FALSE
     add_core = TRUE
     add_r12  = TRUE
     add_xc   = TRUE
     if (present(direct)) do_direct = direct
     if (present(core))   add_core  = core
     if (present(r12))    add_r12   = r12
     if (present(xc))     add_xc    = xc
     if (add_r12) then
        J => F.restricted
        if (do_direct) then; .make_r_J_direct(J,P.restricted)
        else;                .make_r_J_disk(J,P.restricted)
        end
      ! .archive(F,"J_matrix")        ! Archive for delta build
        if (add_xc) .add_XC_matrix(F) ! Exchange correlation matrix
     else
        F.restricted = ZERO
     end
     if (add_core) .add_core_hamiltonian(F.restricted)
   end

   make_r_crystal_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new restricted crystal Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
     direct,core,r12 :: BIN, optional
     P,F :: OPMATRIX*
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.restricted.created, "no density matrix")
   ENSURE(.saved.created, "no saved fragment molecule")
     J,K :: MAT{REAL}*
     do_direct,add_core,add_r12 :: BIN
     n_bf :: INT
     F.destroy("restricted")
     F.create("restricted")
     do_direct= FALSE
     add_core = TRUE
     add_r12  = TRUE
     if (present(direct)) do_direct = direct
     if (present(core))   add_core = core
     if (present(r12))    add_r12  = r12
     F.restricted = ZERO
     if (add_r12) then
        DIE_IF(NOT do_direct,"must use direct method")
        n_bf = .saved.n_bf
        J.create(n_bf,n_bf)   ! J part
        .saved.make_r_J_direct(J,P.restricted(1:n_bf,1:n_bf))
        F.restricted(1:n_bf,1:n_bf) = J
        J.destroy
        K.create(.n_bf,.n_bf) ! K part
        .make_r_K_direct(K,P.restricted)
        F.restricted = F.restricted - HALF*K
        K.destroy
     end
     if (add_core) .saved.add_core_hamiltonian(F.restricted(1:n_bf,1:n_bf))
   stdout.text("F :")
   stdout.put(F.restricted)
     .make_periodic_fmm_levels
     .make_periodic_fmm_J_matrix(J)
   stdout.text("F, after fmm :")
   stdout.put(F.restricted)
     .periodic_fmm_level.destroy
     stop
   end

   make_r_group_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new restricted Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
     direct,core,r12 :: BIN, optional
     P,F :: OPMATRIX*
   ENSURE(.atom_group.created,"no atom_group info")
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(F.n_bf == .n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf == .n_bf, "Density matrix dimensions wrong")
   ENSURE(P.restricted.created, "no density matrix")
     J,K :: MAT{REAL}*
     do_direct,add_core,add_r12 :: BIN
     F.destroy("restricted")
     F.create("restricted")
     do_direct= FALSE
     add_core = TRUE
     add_r12  = TRUE
     if (present(direct)) do_direct = direct
     if (present(core))   add_core = core
     if (present(r12))    add_r12  = r12
     do_direct = TRUE
     if (add_r12) then
        J.create(.n_bf,.n_bf)
        K.create(.n_bf,.n_bf)
        if (do_direct) .make_r_group_JK(J,K,P.restricted)
        F.restricted = J - HALF*K
        K.destroy
        J.destroy
     else
        F.restricted = ZERO
     end
     if (add_core) .add_core_hamiltonian(F.restricted)
   end

   make_u_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new unrestricted Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
     P,F :: OPMATRIX*
     direct,core,r12 :: BIN, optional
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(P.alpha.created,"no density matrix")
   ENSURE(P.beta.created, "no density matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
     J,K :: OPMATRIX*
     h :: MAT{REAL}*
     archive :: ARCHIVE
     do_direct,add_core,add_r12 :: BIN
     F.destroy("unrestricted")
     F.create("unrestricted")
     J.create(.n_bf,"unrestricted")
     K.create(.n_bf,"unrestricted")
     do_direct= FALSE
     add_core = TRUE
     add_r12  = TRUE
     if (present(direct)) do_direct = direct
     if (present(core))   add_core = core
     if (present(r12))    add_r12  = r12
     if (add_r12) then
        if (do_direct) then; .make_u_JK_direct(J,K,P)
        else;                DIE("disk UHF not implemented")
        end
        F.alpha = J.alpha + J.beta - K.alpha
        F.beta  = J.alpha + J.beta - K.beta
     else
        F.alpha = ZERO
        F.beta  = ZERO
     end
     if (add_core) .add_core_hamiltonian(F.alpha,F.beta)
     ! WARNING: Archive for DIIS ... maybe
     if (.scfdata.using_fock_diis) then
        archive.set(.name,"J_matrix")
        if (.scfdata.do_delta_build AND archive.exists) then
           archive.read(K) ! Read old one
           J.plus(K)       ! Add delta J
        end
        archive.write(J) 
     end
     K.destroy
     J.destroy
   end

   make_u_KS_fock(P,F,direct,core,r12,xc) ::: leaky
   ! Make a new restricted Kohn-Sham Fock matrix "F" from the density matrix "P".
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
   ! If present and FALSE, "xc" removes the texchange correlation
     direct,core,r12,xc :: BIN, optional
     P,F :: OPMATRIX*
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
   ENSURE(P.alpha.created, "no density matrix")
   ENSURE(P.beta.created, "no density matrix")
     J,Pab :: MAT{REAL}*
     W :: OPMATRIX*
     archive :: ARCHIVE
     do_direct,add_core,add_r12,add_xc :: BIN
     F.destroy("unrestricted")
     F.create("unrestricted")
     do_direct= FALSE
     add_core = TRUE
     add_r12  = TRUE
     add_xc   = TRUE
     if (present(direct)) do_direct = direct
     if (present(core))   add_core = core
     if (present(r12))    add_r12  = r12
     if (present(xc))     add_xc   = xc
     nullify(J)
     if (add_r12) then
        J.create(.n_bf,.n_bf)
        Pab.create(.n_bf,.n_bf)
        Pab = P.alpha + P.beta
        .make_r_J_direct(J,Pab)
        Pab.destroy
        F.alpha = J
        F.beta = J
        if (add_xc) .add_XC_matrix(F)
     else
        F.alpha = ZERO
        F.beta  = ZERO
     end
     if (add_core) .add_core_hamiltonian(F.alpha,F.beta)
     ! WARNING: Archive for DIIS ... maybe
     if (.scfdata.using_fock_diis) then
        archive.set(.name,"J_matrix")
        if (.scfdata.do_delta_build AND archive.exists) then
           W.create(.n_bf,"unrestricted")
           archive.read(W)       ! Read old one
           W.alpha = W.alpha + J ! Add delta J
           W.beta  = W.beta  + J
           archive.write(W) 
           W.destroy
        else
           archive.write(F) 
        end
     end
     J.destroy
   end

   make_ro_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new restricted open shell Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
     F,P :: OPMATRIX*
     direct,core,r12 :: BIN, optional
   ENSURE(.molecular_orbitals.restricted.created,"no orbitals")
     Fr,Fa,Fb,S,W :: MAT{REAL}*
     F.destroy("restricted")
     F.create("restricted")
     .make_u_fock(P,F,direct,core,r12)
     Fr => F.restricted
     Fa.create(.n_bf,.n_bf); Fa = F.alpha
     Fb.create(.n_bf,.n_bf); Fb = F.beta
     Fa.change_basis_using(.molecular_orbitals.restricted)
     Fb.change_basis_using(.molecular_orbitals.restricted)
     Fr = HALF*(Fa+Fb)
     Fr(.n_b+1:.n_a,     1:.n_b) = Fb(.n_b+1:.n_a,     1:.n_b)
     Fr(     1:.n_b,.n_b+1:.n_a) = Fb(     1:.n_b,.n_b+1:.n_a)
     Fr(.n_a+1:    ,.n_b+1:.n_a) = Fa(.n_a+1:    ,.n_b+1:.n_a)
     Fr(.n_b+1:.n_a,.n_a+1:    ) = Fa(.n_b+1:.n_a,.n_a+1:    )
     S => Fb; .get_overlap_matrix(S)
     W => Fa; W.to_product_of(.molecular_orbitals.restricted,S,transpose_a=TRUE)
     Fr.change_basis_using(W) ! change to AO basis
     Fb.destroy
     Fa.destroy
   end

   make_gc_fock(P,F,direct,core,r12) ::: leaky
   ! Make a new complex general Fock matrix.
   ! If present and TRUE , "direct" means calculate integrals on the fly
   ! If present and FALSE, "core" removes the core matrix contribution
   ! If present and FALSE, "r12"  removes the two electron contribution
     direct,core,r12 :: BIN, optional
     P,F :: OPMATRIX*
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(P.general_complex.created, "no density matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
     Ka,Kb,Kba,Pa,Pb,Pba,Fgc :: MAT{CPX}*
     J, Pab :: MAT{REAL}*
     do_direct,add_core,add_r12 :: BIN
     F.destroy("general_complex")
     F.create("general_complex")
     do_direct= FALSE
     add_core = TRUE
     add_r12  = TRUE
     if (present(direct)) do_direct = direct
     if (present(core)) add_core = core
     if (present(r12))  add_r12  = r12
     Fgc => F.general_complex
     if (add_r12) then
        J.create(.n_bf,.n_bf)
        Ka.create(.n_bf,.n_bf)
        Kb.create(.n_bf,.n_bf)
        Kba.create(.n_bf,.n_bf)
        Pa.create(.n_bf,.n_bf);  P.general_complex.alpha_alpha_put_to(Pa)
        Pb.create(.n_bf,.n_bf);  P.general_complex.beta_beta_put_to(Pb)
        Pba.create(.n_bf,.n_bf); P.general_complex.beta_alpha_put_to(Pba)
        Pab.create(.n_bf,.n_bf)
        Pab  = Pa + Pb
        if (do_direct) then; .make_gc_JK_direct(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
        else;                .make_gc_JK_disk(J,Ka,Kb,Kba,Pab,Pa,Pb,Pba)
        end
        Pab.destroy
        Pba.destroy
        Pb.destroy
        Pa.destroy
        Ka = J - Ka; Fgc.alpha_alpha_set_to(Ka)
        Kb = J - Kb; Fgc.beta_beta_set_to(Kb)
        Kba = -Kba;  Fgc.beta_alpha_set_to(Kba)
        Kba.destroy
        Kb.destroy
        Ka.destroy
        J.destroy
     else
        Fgc = ZERO
     end
     Fgc.make_hermitian
     if (add_core) .add_core_hamiltonian(Fgc)
   end

   add_gc_so_fock(P,F,direct) ::: leaky
   ! Make the general complex two electron spin orbit contribution to the Fock
   ! matrix.
     P,F :: OPMATRIX*
     direct :: BIN, optional
   ENSURE(P.created,"no density matrix")
   ENSURE(F.created,"no fock matrix")
   ENSURE(P.general_complex.created, "no density matrix")
   ENSURE(F.general_complex.created, "no fock matrix")
   ENSURE(F.n_bf==.n_bf, "Fock matrix dimensions wrong")
   ENSURE(P.n_bf==.n_bf, "Density matrix dimensions wrong")
     JS,KS,JO,KO :: MAT5{CPX}*
     Pgc :: MAT4{CPX}*
     Faa,Fbb,Fba :: MAT{CPX}*
     I :: CPX
     fac :: REAL
     a,b,x,y,z :: INT
     do_direct :: BIN
     do_direct= FALSE
     if (present(direct)) do_direct = direct
     if (.scfdata.using_2e_sl_term) then
       .get_spin_orbit_integrals
       Faa.create(.n_bf,.n_bf)
       Fbb.create(.n_bf,.n_bf)
       Fba.create(.n_bf,.n_bf)
       JS.create(.n_bf,.n_bf,2,2,3); KS.create(.n_bf,.n_bf,2,2,3)
       JO.create(.n_bf,.n_bf,2,2,3); KO.create(.n_bf,.n_bf,2,2,3)
       Pgc.create(.n_bf,.n_bf,2,2)
       P.general_complex.alpha_alpha_put_to(Pgc(:,:,1,1))
       P.general_complex.beta_alpha_put_to(Pgc(:,:,2,1))
       P.general_complex.alpha_beta_put_to(Pgc(:,:,1,2))
       P.general_complex.beta_beta_put_to(Pgc(:,:,2,2))
       if (do_direct) then
       .make_gc_so_JK_direct(JS,KS,JO,KO,Pgc)
       else
       .make_gc_so_JK_disk(JS(:,:,:,:,1),KS(:,:,:,:,1),JO(:,:,:,:,1),KO(:,:,:,:,1),Pgc,"x")
       .make_gc_so_JK_disk(JS(:,:,:,:,2),KS(:,:,:,:,2),JO(:,:,:,:,2),KO(:,:,:,:,2),Pgc,"y")
       .make_gc_so_JK_disk(JS(:,:,:,:,3),KS(:,:,:,:,3),JO(:,:,:,:,3),KO(:,:,:,:,3),Pgc,"z")
       end
       Pgc.destroy
       I = (ZERO,ONE)
       a = 1; b = 2; x = 1; y = 2; z = 3
       Faa =  THREE*JO(:,:,a,a,z) +       JO(:,:,b,b,z) + THREE*JS(:,:,a,a,z) -   JS(:,:,b,b,z) &
           +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
           +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
           -    TWO*KO(:,:,b,a,x) -       KO(:,:,a,b,x) -   TWO*KS(:,:,a,b,x) -   KS(:,:,b,a,x) &
           +  I*TWO*KO(:,:,b,a,y) -     I*KO(:,:,a,b,y) - I*TWO*KS(:,:,a,b,y) + I*KS(:,:,b,a,y) &
           -  THREE*KO(:,:,a,a,z) - THREE*KS(:,:,a,a,z)
       Fbb = -THREE*JO(:,:,b,b,z) -       JO(:,:,a,a,z) - THREE*JS(:,:,b,b,z) +   JS(:,:,a,a,z) &
           +    TWO*JS(:,:,a,b,x) +   TWO*JS(:,:,b,a,x) +       JO(:,:,a,b,x) +   JO(:,:,b,a,x) &
           +  I*TWO*JS(:,:,a,b,y) - I*TWO*JS(:,:,b,a,y) +     I*JO(:,:,a,b,y) - I*JO(:,:,b,a,y) &
           -    TWO*KO(:,:,a,b,x) -       KO(:,:,b,a,x) -   TWO*KS(:,:,b,a,x) -   KS(:,:,a,b,x) &
           -  I*TWO*KO(:,:,a,b,y) + I*KO(:,:,b,a,y)     + I*TWO*KS(:,:,b,a,y) - I*KS(:,:,a,b,y) &
           +  THREE*KO(:,:,b,b,z) + THREE*KS(:,:,b,b,z)
       Fba =    TWO*JO(:,:,a,a,x) +   TWO*JO(:,:,b,b,x) +       JS(:,:,a,a,x) +   JS(:,:,b,b,x) &
           +  I*TWO*JO(:,:,a,a,y) + I*TWO*JO(:,:,b,b,y) +     I*JS(:,:,a,a,y) + I*JS(:,:,b,b,y) &
           -    TWO*KO(:,:,a,a,x) -       KO(:,:,b,b,x) -   TWO*KS(:,:,b,b,x) -   KS(:,:,a,a,x) &
           -  I*TWO*KO(:,:,a,a,y) -     I*KO(:,:,b,b,y) - I*TWO*KS(:,:,b,b,y) - I*KS(:,:,a,a,y) &
           +        KO(:,:,b,a,z) -       KS(:,:,b,a,z)
       KO.destroy; JO.destroy; KS.destroy; JS.destroy

       fac = G_FACTOR/(EIGHT*SPEED_OF_LIGHT_AU**2)
       fac = fac * .scfdata.sl_2e_factor
       F.general_complex.alpha_alpha_plus(Faa,factor=I*fac)
       F.general_complex.beta_beta_plus(Fbb,factor=I*fac)
       F.general_complex.beta_alpha_plus(Fba,factor=I*fac)
       Fbb = conjg(transpose(Fba))
       F.general_complex.alpha_beta_plus(Fbb,factor=-I*fac)
       Fba.destroy; Fbb.destroy; Faa.destroy
     end
   end

!**********************
! J & K matrix routines
!**********************

   in_same_atom_group(atom_a,atom_b,group) result (res)
   ! Return TRUE if the atoms are all in the same atom_group
   ! If present, "group" is set to the common group index.
     atom_a,atom_b :: INT
     group :: INT, optional
     res :: BIN
   ENSURE(.atom_group.created,"no atom group information")
     n,n_group :: INT
     n_group = size(.atom_group)
     res = TRUE
     do n = 1,n_group
        if (any(atom_a==.atom_group(n).element)) then
          if (NOT any(atom_b==.atom_group(n).element)) res = FALSE
          exit
        end
     end
     if (present(group)) then
        if (res) then; group = n
        else;          group = 0
        end
     end
   end

   in_same_atom_group(atom_a,atom_b,atom_c,atom_d) result (res)
   ! Return TRUE if the atoms are all in the same atom_group
     atom_a,atom_b,atom_c,atom_d :: INT
     res :: BIN
   ENSURE(.atom_group.created,"no atom group information")
     n,n_group :: INT
     n_group = size(.atom_group)
     res = TRUE
     do n = 1,n_group
        if (any(atom_a==.atom_group(n).element)) then
          if (NOT any(atom_b==.atom_group(n).element)) res = FALSE
          if (NOT any(atom_c==.atom_group(n).element)) res = FALSE
          if (NOT any(atom_d==.atom_group(n).element)) res = FALSE
          exit
        end
     end
   end

   schwarz_inequality_test(cutoff,ab,cd,a,b,c,d,P_max,I_max) result(skip)
   ! Return "skip", a logical variable which is TRUE if the maximum contribution
   ! to the restricted Fock matrix (based on the schwarz inequality test) from a
   ! shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd" is
   ! smaller than a preset "cutoff". "P_max" is the maximum density matrix
   ! elements for each shell pair "ab", and "I_max(ab)" is maximum value of the
   ! square root of the integral (ab|ab) for the shell pair with index "ab".
     skip :: BIN
     cutoff :: REAL
     ab,cd, a,b,c,d :: INT
     P_max,I_max :: VEC{REAL}
     Pmax :: REAL
     ac,ad,bc,bd,k,l,m,n :: INT
     k = max(b,c); l = min(b,c)
     m = max(b,d); n = min(b,d)
     ac = ((a-1)*a)/2 + c          ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
     ad = ac - c + d
     bc = ((k-1)*k)/2 + l
     bd = ((m-1)*m)/2 + n
     Pmax = max(P_max(ab),P_max(cd),P_max(ac),P_max(ad),P_max(bc),P_max(bd))
     if (Pmax < TOL(20)) then
       skip = TRUE
     else
        if (Pmax*I_max(ab)*I_max(cd) > cutoff) then; skip = FALSE
        else;                                        skip = TRUE
        end
     end
   end

   schwarz_test(skip_J,skip_K,cutoff,ab,cd,a,b,c,d,P_max,I_max)
   ! Return "skip_J" and "skip_K", logical variables are TRUE if the maximum
   ! contribution to the J and K matrices (based on the schwarz inequality test)
   ! from a shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd"
   ! is smaller than a preset "cutoff". "P_max(ab)" is the maximum density
   ! matrix elements for each shell pair "ab", and "I_max(ab)" is maximum value
   ! of the square root of the integral (ab|ab) for the shell pair with index "ab".
     skip_J,skip_K :: BIN, OUT
     cutoff :: REAL, IN
     ab,cd, a,b,c,d :: INT, IN
     P_max,I_max :: VEC{REAL}, IN
     Jmax,Kmax :: REAL
     ac,ad,bc,bd,k,l,m,n :: INT
     k = max(b,c); l = min(b,c)
     m = max(b,d); n = min(b,d)
     ac = (a-1)*a/2 + c          ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
     ad = ac - c + d
     bc = (k-1)*k/2 + l
     bd = (m-1)*m/2 + n
     Jmax = max(P_max(ab),P_max(cd))
     Kmax = max(P_max(ac),P_max(ad),P_max(bc),P_max(bd))
     skip_J = FALSE
     if      (Jmax < TOL(20)) then;                    skip_J = TRUE
     else if (Jmax*I_max(ab)*I_max(cd) < cutoff) then; skip_J = TRUE
     end
     skip_K = FALSE
     if      (Kmax < TOL(20)) then;                    skip_K = TRUE
     else if (Kmax*I_max(ab)*I_max(cd) < cutoff) then; skip_K = TRUE
     end
   end

   schwarz_J_test(skip_J,cutoff,ab,cd,a,b,c,d,P_max,I_max)
   ! Return "skip_J" which is set TRUE if the maximum contribution to the J
   ! matrix (based on the schwarz inequality test) from a shell of ERI integrals
   ! (ab|cd) with shell pair indices "ab" and "cd" is smaller than a preset
   ! "cutoff". "P_max(ab)" is the maximum density matrix elements for each shell
   ! pair "ab", and "I_max(ab)" is maximum value of the square root of the
   ! integral (ab|ab) for the shell pair with index "ab".
     skip_J :: BIN, OUT
     cutoff :: REAL, IN
     ab,cd, a,b,c,d :: INT, IN
     P_max,I_max :: VEC{REAL}, IN
     Jmax,Kmax :: REAL
     ac,ad,bc,bd,k,l,m,n :: INT
     k = max(b,c); l = min(b,c)
     m = max(b,d); n = min(b,d)
     ac = (a-1)*a/2 + c          ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
     ad = ac - c + d
     bc = (k-1)*k/2 + l
     bd = (m-1)*m/2 + n
     Jmax = max(P_max(ab),P_max(cd))
     Kmax = max(P_max(ac),P_max(ad),P_max(bc),P_max(bd))
     skip_J = FALSE
     if      (Jmax < TOL(20)) then;                    skip_J = TRUE
     else if (Jmax*I_max(ab)*I_max(cd) < cutoff) then; skip_J = TRUE
     end
   end

   schwarz_K_test(skip_K,cutoff,ab,cd,a,b,c,d,P_max,I_max)
   ! Return "skip_K", logical variables are TRUE if the maximum
   ! contribution to the K matrices (based on the schwarz inequality test)
   ! from a shell of ERI integrals (ab|cd) with shell pair indices "ab" and "cd"
   ! is smaller than a preset "cutoff". "P_max(ab)" is the maximum density
   ! matrix elements for each shell pair "ab", and "I_max(ab)" is maximum value
   ! of the square root of the integral (ab|ab) for the shell pair with index "ab".
     skip_K :: BIN, OUT
     cutoff :: REAL, IN
     ab,cd, a,b,c,d :: INT, IN
     P_max,I_max :: VEC{REAL}, IN
     Kmax :: REAL
     ac,ad,bc,bd,k,l,m,n :: INT
     k = max(b,c); l = min(b,c)
     m = max(b,d); n = min(b,d)
     ac = (a-1)*a/2 + c          ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
     ad = ac - c + d
     bc = (k-1)*k/2 + l
     bd = (m-1)*m/2 + n
     Kmax = max(P_max(ac),P_max(ad),P_max(bc),P_max(bd))
     skip_K = FALSE
     if      (Kmax < TOL(20)) then;                    skip_K = TRUE
     else if (Kmax*I_max(ab)*I_max(cd) < cutoff) then; skip_K = TRUE
     end
   end

   make_max_density_elements(P_max,P)
   ! Make "P_max", the maximum of the (a,b) density elements of "P" over each
   ! shell pair, for use in the schwarz test.
     P_max :: VEC{REAL}
     P :: MAT{REAL}
   ENSURE(size(P_max)==.n_shell_pairs,"wrong size, P_max")
   ENSURE(P.is_square,"wrong shape, P")
   ENSURE(P.dim1==.n_bf,"wrong size, P")
     ab,fa,fb,la,lb,aa,bb, a,b :: INT
     Pmax :: REAL
     ! Store the largest integral for each shell pair ab|ab
     do ab = 1, .n_shell_pairs
       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb)
       Pmax = ZERO
       do a = fa,la
       do b = fb,lb
          Pmax = max(abs(P(a,b)),Pmax)
       end
       end
       P_max(ab) = Pmax
     end
   end

   make_max_abab_integrals(I_max)
   ! Make "I_max", the square root of the maximum of the (ab|ab) ERI integrals.
     I_max :: VEC{REAL}
   ENSURE(size(I_max)==.n_shell_pairs,"wrong size, I_max")
     ab,fa,fb,la,lb,sa,sb,na,nb, a,b :: INT
     sh4q :: SHELL1QUARTET
     Iabab :: MAT4{REAL}*
     Imax :: REAL
     ! Store the largest integral for each shell pair ab|ab
     do ab = 1, .n_shell_pairs
       .get_shell_pair_indices(ab,sa,sb,fa,la,fb,lb)
       na = la-fa+1
       nb = lb-fb+1
       .set_new_shell_quartet_ab(sh4q,sa,sb,skip=FALSE) ! (ab|ab} shell
       .set_new_shell_quartet_cd(sh4q,sa,sb,skip=FALSE)
       Iabab.create(na,nb,na,nb)
       SHELL1QUARTET::make_ERI(sh4q,Iabab)
       sh4q.destroy_ptr_part
       Imax = ZERO
       do a=1,na
       do b=1,nb
          Imax = max(abs(Iabab(a,b,a,b)),Imax)
       end
       end
       I_max(ab) = sqrt(Imax)
       Iabab.destroy
     end
   end

   make_max_abab_so_integrals(I_max)
   ! Make "I_max", the square root of the maximum of the all (ab|ab) spin orbit
   ! integrals.
     I_max :: VEC{REAL}
   ENSURE(size(I_max)==.n_shell_pairs,"wrong size, I_max")
     ab,fa,fb,la,lb,sa,sb,na,nb, a,b :: INT
     sh4 :: SHELL4
     S,O :: MAT5{REAL}*
     Imax :: REAL
     ! Store the largest integral for each shell pair ab|ab
     do ab = 1, .n_shell_pairs           ! Store the largest integral for each
       .get_shell_pair_indices(ab,sa,sb,fa,la,fb,lb)
       na = la-fa+1
       nb = lb-fb+1
       .copy_shell_quartet_ab(sh4,sa,sb)
       .copy_shell_quartet_cd(sh4,sa,sb)
       S.create(na,nb,na,nb,3)
       O.create(na,nb,na,nb,3)
       sh4.make_spin_orbit_ints(S,O)
       sh4.destroy_ptr_part
       Imax = ZERO
       do a=1,na
       do b=1,nb
          Imax = max(abs(S(a,b,a,b,1)),abs(S(a,b,a,b,2)),abs(S(a,b,a,b,3)), &
                     abs(O(a,b,a,b,1)),abs(O(a,b,a,b,2)),abs(O(a,b,a,b,3)),Imax)
       end
       end
       I_max(ab) = sqrt(Imax)
       O.destroy
       S.destroy
     end
   end

   reverse_transfer(P,PP) ::: leaky
   ! Apply the reverse horizontal recursion relation (i.e. the reverse transfer
   ! relation) to matrix "P" to produce the shell pair vector "PP" which has to
   ! be multipled by the (es|fs) source integrals to give the J-matrix.
   ! Normalisation factors for the integrals are included.
      P :: MAT{REAL}
      PP :: VEC{VEC_{REAL}}*
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")
      R :: VEC{REAL}(3)
      R1,R2,R3,T1,T2,T3,fx,fy,fz,P_ab :: REAL
      Rx,Ry,Rz,ab :: VEC{REAL}*
      ax,ay,az,bx,by,bz,binx,biny,binz :: VEC{INT}*
      q,fa,la,fb,lb,atom_a,atom_b,aa,bb,af,al,bf,bl,f :: INT
      i,k,a,b,x,y,z,xa,ya,za,xb,yb,zb,xx,yy,zz :: INT
      new_atom_pair,same_atoms,a_gt_b,a_lt_b :: BIN
      sh :: SHELL2
      Rx.create(.basis_l_max+1)
      Ry.create(.basis_l_max+1)
      Rz.create(.basis_l_max+1)
      PP.create(.n_shell_pairs)                                ! leaky
      a_gt_b = TRUE
      a_lt_b = TRUE
      aa = 0
      bb = 0
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
         PP(q).element.create(sh.n_gaussian)                   ! leaky
         ab => PP(q).element
         if      (sh.l_sum==0) then                            ! SS case
            ab(1) = P(fa,fb)
         else if (sh.a.l==0) then                              ! XS case
            fb = fb - 1
            if (sh.l_max<2) then                               ! No normalisers
               do b = 1,sh.b.n_comp
                  ab(b) = P(fa,fb+b)
               end
            else                                               ! Include normalisers
               do b = 1,sh.b.n_comp
                  ab(b) = P(fa,fb+b)*sh.normalising_factors(b)
               end
            end
         else if (sh.b.l==0) then                              ! SX case
            fa = fa - 1
            if (sh.l_max<2) then                               ! No normalisers
               do a = 1,sh.a.n_comp
                  ab(a) = P(fa+a,fb)
               end
            else                                               ! Include normalisers
               do a = 1,sh.a.n_comp
                  ab(a) = P(fa+a,fb)*sh.normalising_factors(a)
               end
            end
         else                                                  ! General case
            ab = ZERO
            af = MOLECULE:n_comp_up_to(sh.a.l-1) + 1; al = af + sh.a.n_comp - 1
            bf = MOLECULE:n_comp_up_to(sh.b.l-1) + 1; bl = bf + sh.b.n_comp - 1
            ax => GAUSSIAN_DATA::nx(af:al)
            ay => GAUSSIAN_DATA::ny(af:al)
            az => GAUSSIAN_DATA::nz(af:al)
            bx => GAUSSIAN_DATA::nx(bf:bl)
            by => GAUSSIAN_DATA::ny(bf:bl)
            bz => GAUSSIAN_DATA::nz(bf:bl)
            af = af - 1
            bf = bf - 1
            fa = fa - 1
            fb = fb - 1
            new_atom_pair = atom_a/=aa OR atom_b/=bb
            same_atoms = atom_a==atom_b
            aa = atom_a; bb = atom_b
            if (same_atoms) then                               ! No transfer
               if (sh.a.l > sh.b.l) then; f = af
               else;                      f = bf
               end
               if (sh.l_max<2) then                            ! No normalising factors
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        xx = xa + xb - 1
                        yy = ya + yb - 1
                        zz = za + zb - 1
                        i = GAUSSIAN_DATA::index_of(xx,yy,zz) - f
                        ab(i) = ab(i) + P_ab
                     end
                  end
               else                                            ! Include normalisers
                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        k = k + 1
                        P_ab = P(fa+a,fb+b)*sh.normalising_factors(k)
                        xa = ax(a); ya = ay(a); za = az(a)
                        xx = xa + xb - 1
                        yy = ya + yb - 1
                        zz = za + zb - 1
                        i = index_of(xx,yy,zz) - f
                        ab(i) = ab(i) + P_ab
                     end
                  end
               end
            else if (sh.a.l > sh.b.l) then                     ! Transfer to a
               if (new_atom_pair OR a_lt_b) then
                  a_gt_b = TRUE; a_lt_b = FALSE
                  R = sh.a.pos - sh.b.pos
                  R1 = R(1);   R2 = R(2);   R3 = R(3)
                  T1 = R1;     T2 = R2;     T3 = R3
                  Rx(1) = ONE; Ry(1) = ONE; Rz(1) = ONE
                  do i = 2,sh.l_max+1
                     Rx(i) = T1; T1 = R1*T1
                     Ry(i) = T2; T2 = R2*T2
                     Rz(i) = T3; T3 = R3*T3
                  end
               end
               if (sh.l_max<2) then                            ! No normalisers
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     binx => GAUSSIAN_DATA::binomial_p1(xb)%element
                     biny => GAUSSIAN_DATA::binomial_p1(yb)%element
                     binz => GAUSSIAN_DATA::binomial_p1(zb)%element
                     do a = 1,sh.a.n_comp
                        P_ab = P(fa+a,fb+b)
                        xa = ax(a); ya = ay(a); za = az(a)
                        do x = 1,xb 
                           xx = xa + x - 1
                           fx = binx(x)*Rx(xb-x+1)*P_ab
                           do y = 1,yb 
                              yy = ya + y - 1
                              fy = biny(y)*Ry(yb-y+1)
                              do z = 1,zb 
                                 zz = za + z - 1
                                 fz = binz(z)*Rz(zb-z+1)
                                 i = index_of(xx,yy,zz) - af
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               else                                            ! Include normalisers
                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     binx => GAUSSIAN_DATA::binomial_p1(xb)%element
                     biny => GAUSSIAN_DATA::binomial_p1(yb)%element
                     binz => GAUSSIAN_DATA::binomial_p1(zb)%element
                     do a = 1,sh.a.n_comp
                        k = k + 1
                        P_ab = P(fa+a,fb+b)*sh.normalising_factors(k)
                        xa = ax(a); ya = ay(a); za = az(a)
                        do x = 1,xb 
                           xx = xa + x - 1
                           fx = binx(x)*Rx(xb-x+1)*P_ab
                           do y = 1,yb 
                              yy = ya + y - 1
                              fy = biny(y)*Ry(yb-y+1)
                              do z = 1,zb 
                                 zz = za + z - 1
                                 fz = binz(z)*Rz(zb-z+1)
                                 i = index_of(xx,yy,zz) - af
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               end
            else                                              ! Transfer to b
               if (new_atom_pair OR a_gt_b) then
                  a_gt_b = FALSE; a_lt_b = TRUE
                  R = sh.b.pos - sh.a.pos
                  R1 = R(1);   R2 = R(2);   R3 = R(3)
                  T1 = R1;     T2 = R2;     T3 = R3
                  Rx(1) = ONE; Ry(1) = ONE; Rz(1) = ONE
                  do i = 2,sh.l_max+1
                     Rx(i) = T1; T1 = R1*T1
                     Ry(i) = T2; T2 = R2*T2
                     Rz(i) = T3; T3 = R3*T3
                  end
               end
               if (sh.l_max<2) then                           ! No normalisers
                  do a = 1,sh.a.n_comp
                     xa = ax(a); ya = ay(a); za = az(a)
                     binx => GAUSSIAN_DATA::binomial_p1(xa)%element
                     biny => GAUSSIAN_DATA::binomial_p1(ya)%element
                     binz => GAUSSIAN_DATA::binomial_p1(za)%element
                     do b = 1,sh.b.n_comp
                        P_ab = P(fa+a,fb+b)
                        xb = bx(b); yb = by(b); zb = bz(b)
                        do x = 1,xa 
                           xx = xb + x - 1
                           fx = binx(x)*Rx(xa-x+1)*P_ab
                           do y = 1,ya 
                              yy = yb + y - 1
                              fy = biny(y)*Ry(ya-y+1)
                              do z = 1,za 
                                 zz = zb + z - 1
                                 fz = binz(z)*Rz(za-z+1)
                                 i = index_of(xx,yy,zz) - bf
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               else                                           ! Include normalisers
                  k = 0
                  do b = 1,sh.b.n_comp
                     xb = bx(b); yb = by(b); zb = bz(b)
                     do a = 1,sh.a.n_comp
                        xa = ax(a); ya = ay(a); za = az(a)
                        binx => GAUSSIAN_DATA::binomial_p1(xa)%element
                        biny => GAUSSIAN_DATA::binomial_p1(ya)%element
                        binz => GAUSSIAN_DATA::binomial_p1(za)%element
                        k = k + 1
                        P_ab = P(fa+a,fb+b)*sh.normalising_factors(k)
                        do x = 1,xa 
                           xx = xb + x - 1
                           fx = binx(x)*Rx(xa-x+1)*P_ab
                           do y = 1,ya 
                              yy = yb + y - 1
                              fy = biny(y)*Ry(ya-y+1)
                              do z = 1,za 
                                 zz = zb + z - 1
                                 fz = binz(z)*Rz(za-z+1)
                                 i = index_of(xx,yy,zz) - bf
                                 ab(i) = ab(i) + fx*fy*fz
                              end
                           end
                        end
                     end
                  end
               end
            end  ! Trasfer to b
         end     ! general case
         sh.destroy_ptr_part
      end        ! loop over shell pairs
      Rz.destroy
      Ry.destroy
      Rx.destroy
   end

   forward_transfer(JJ,J) ::: leaky
   ! Apply the horizontal recursion relation (i.e. the transfer
   ! relation) to shellpair vector "JJ" to produce the matrix "J".
   ! This is a post-processing operation to shift momentum from\
   ! center a -> b.
      JJ :: VEC{VEC_{REAL}}
      J :: MAT{REAL}
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(JJ.dim==.n_shell_pairs,"wrong size, JJ")
   ENSURE(J.dim1==.n_bf,"wrong size, J")
   ENSURE(J.is_square,"wrong shape, J")
      q,fa,la,fb,lb :: INT
      ab :: VEC{REAL}*
      W  :: MAT{REAL}*
      sh :: SHELL2
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         ab => JJ(q).element
         W.create(sh.a.n_comp,sh.b.n_comp)
         sh.transfer(ab,W)
         sh.normalise(W)
         J(fa:la,fb:lb) = W
         W.destroy
         sh.destroy_ptr_part
      end 
   end

   create_transfer(JJ) ::: leaky
   ! Create space for the transfer vector "JJ". It is a shellpair vector of
   ! flattened es-type componenets from which ab components can be formed by the
   ! transfer relation.
      JJ :: VEC{VEC_{REAL}}*
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")
      q,fa,la,fb,lb :: INT
      sh :: SHELL2
      JJ.create(.n_shell_pairs)                        ! leaky
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         JJ(q).element.create(sh.n_gaussian)           ! leaky
         JJ(q).element = ZERO
         sh.destroy_ptr_part
      end 
   end

   n_comp_up_to(l) result(res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
   end

!   make_r_JK_direct_old(J,K,P)
!   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
!   ! symmetric density matrix "P" directly.
!     J,K,P :: MAT{REAL}
!   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")
!   ! PP,JJ :: VEC{VEC_{REAL}}*
!   ! max_P,Jab,Jcd,Pab,Pcd :: VEC{REAL}*
!     max_P :: VEC{REAL}*
!     sh4q :: SHELL1QUARTET
!     ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld,atom_a,atom_b,atom_c,atom_d :: INT
!     factor,cutoff,P_max,IP_max :: REAL
!     skip,skip_J,skip_K :: BIN
!   ! .reverse_transfer(P,PP)
!   ! .create_transfer(JJ)
!     J = ZERO
!     K = ZERO
!     cutoff = .scfdata.eri_cutoff
!     if (.max_I.destroyed) .initialise_max_I
!     max_P.create(.n_shell_pairs)
!     .make_max_density_elements(max_P,P)
!     P_max = maxval(max_P)
!     IP_max = maxval(.max_I) * P_max
!     parallel do ab = 1,.n_shell_pairs
!       if (.max_I(ab)*IP_max < cutoff) cycle
!       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
!       .set_precomp_shell_quartet_ab(sh4q,aa,bb)
!   !   Jab => JJ(ab).element
!   !   Pab => PP(ab).element
!       do cd = 1,ab
!         if (.max_I(ab)*.max_I(cd)*P_max < cutoff) cycle
!         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
!         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
!   !     .schwarz_test(skip_J,skip_K,cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
!   !     skip = skip_J AND skip_K
!         if (skip) cycle
!         .set_precomp_shell_quartet_cd(sh4q,cc,dd)
!   !     Jcd => JJ(cd).element
!   !     Pcd => PP(cd).element
!         if (aa==bb) then                   ! Evaluate the integrals'
!           factor = HALF                    ! coincidence factors
!         else
!           factor = ONE
!         end
!         if (cc==dd) factor = HALF * factor
!         if (aa==cc AND bb==dd) factor = HALF * factor
!         sh4q.make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!   !     ! The two lines below do not work except when skip_K is set TRUE 
!   !     ! and the K term is evaluated by a different routine.
!   !     skip_K = FALSE
!   !     sh4q.make_r_JK_engine(skip_J,skip_K,Jab,Jcd,Pab,Pcd,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!   !     ! The line below works (of course)
!   !     sh4q.make_r_J(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!   !     ! The line below works
!   !     sh4q.make_r_J(J,Pab,Pcd,factor,fa,la,fb,lb,fc,lc,fd,ld)
!   !     ! The line below works
!   !     sh4q.make_r_J_engine(Jab,Jcd,Pab,Pcd,factor)
!   !     sh4q.make_r_K(K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!         sh4q.destroy_cd
!       end
!       sh4q.destroy_ab
!     end
!     max_P.destroy
!   ! .forward_transfer(JJ,J)
!     .weight_diagonal_blocks(J,TWO)
!     .blockwise_symmetric_fold(K)
!     J = TWO*J
!     if (DO_IN_PARALLEL) then
!        PARALLEL_SYMMETRIC_SUM(J)
!        PARALLEL_SYMMETRIC_SUM(K)
!     else
!        J.symmetric_reflect
!        K.symmetric_reflect
!     end
!   ! JJ.destroy
!   ! PP.destroy
!   end

!   make_r_JK_direct_old2(J,K,P)
!   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
!   ! symmetric density matrix "P" directly.
!     J,K,P :: MAT{REAL}
!   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")
!   ! PP,JJ :: VEC{VEC_{REAL}}*
!   ! max_P,Jab,Jcd,Pab,Pcd :: VEC{REAL}*
!     max_P :: VEC{REAL}*
! !   sh4q :: SHELL1QUARTET
!     sh4s,sh4n :: SHELL1QUARTET
!     ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     atom_a,atom_b,atom_c,atom_d :: INT
!     factor,cutoff,P_max,IP_max :: REAL
!     skip,skip_J,skip_K,ab_same,cd_same,any_same,no_max_I :: BIN
!   ! .reverse_transfer(P,PP)
!   ! .create_transfer(JJ)
!     J = ZERO
!     K = ZERO
!     cutoff = .scfdata.eri_cutoff
!     no_max_I = FALSE
!     if (.max_I.destroyed) no_max_I = TRUE
!     if (no_max_I) .initialise_max_I
!     max_P.create(.n_shell_pairs)
!     .make_max_density_elements(max_P,P)
!     P_max = maxval(max_P)
!     IP_max = maxval(.max_I) * P_max
!     parallel do ab = 1,.n_shell_pairs
!       if (.max_I(ab)*IP_max < cutoff) cycle
!       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
!       ab_same = atom_a==atom_b
! !     .set_precomp_shell_quartet_ab(sh4q,aa,bb)
!       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
!       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
!   !   Jab => JJ(ab).element
!   !   Pab => PP(ab).element
!       do cd = 1,ab
!         if (.max_I(ab)*.max_I(cd)*P_max < cutoff) cycle
!         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
!         cd_same = atom_c==atom_d
!         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
!   !     .schwarz_test(skip_J,skip_K,cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
!   !     skip = skip_J AND skip_K
!         if (skip) cycle
! !       .set_precomp_shell_quartet_cd(sh4q,cc,dd)
!   !     Jcd => JJ(cd).element
!   !     Pcd => PP(cd).element
!         if (aa==bb) then; factor = HALF
!         else;             factor = ONE
!         end
!         if (cc==dd) factor = HALF * factor
!         if (aa==cc AND bb==dd) factor = HALF * factor
! !       sh4q.make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!         any_same = ab_same OR cd_same OR &
!                    atom_a==atom_c OR atom_a==atom_d OR &
!                    atom_b==atom_c OR atom_b==atom_d 
!         if (any_same) then
!            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
!            sh4n.make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!            sh4n.destroy_cd
!         else
!            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
!            sh4s.make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!            sh4s.destroy_cd
!         end
!   !     ! The two lines below do not work except when skip_K is set TRUE 
!   !     ! and the K term is evaluated by a different routine.
!   !     skip_K = FALSE
!   !     sh4q.make_r_JK_engine(skip_J,skip_K,Jab,Jcd,Pab,Pcd,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!   !     ! The line below works (of course)
!   !     sh4q.make_r_J(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!   !     ! The line below works
!   !     sh4q.make_r_J(J,Pab,Pcd,factor,fa,la,fb,lb,fc,lc,fd,ld)
!   !     ! The line below works
!   !     sh4q.make_r_J_engine(Jab,Jcd,Pab,Pcd,factor)
!   !     sh4q.make_r_K(K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
! !       sh4q.destroy_cd
!       end
!  !    sh4q.destroy_ab
!       sh4n.destroy_ab
!       sh4s.destroy_ab
!     end
!     max_P.destroy
!     if (no_max_I) .max_I.destroy
!   ! .forward_transfer(JJ,J)
!     .weight_diagonal_blocks(J,TWO)
!     .blockwise_symmetric_fold(K)
!     J = TWO*J
!     if (DO_IN_PARALLEL) then
!        PARALLEL_SYMMETRIC_SUM(J)
!        PARALLEL_SYMMETRIC_SUM(K)
!     else
!        J.symmetric_reflect
!        K.symmetric_reflect
!     end
!   ! JJ.destroy
!   ! PP.destroy
!     .put_debug(J,"direct j matrix")
!     .put_debug(K,"direct k matrix")
!   end

   make_r_JK_direct(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
   ! symmetric density matrix "P" directly.
     J,K,P :: MAT{REAL}
   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")
     I,max_P :: VEC{REAL}*
     sh4s,sh4n :: SHELL1QUARTET
     ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
     atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
     factor,cutoff,P_max,IP_max,I_abcd :: REAL
     skip,ab_same,cd_same,any_same,no_max_I :: BIN
     J = ZERO
     K = ZERO
     cutoff = .scfdata.eri_cutoff
     no_max_I = FALSE
     if (.max_I.destroyed) no_max_I = TRUE
     if (no_max_I) .initialise_max_I
     max_P.create(.n_shell_pairs)
     .make_max_density_elements(max_P,P)
     P_max = maxval(max_P)
     IP_max = maxval(.max_I) * P_max
     parallel do ab = 1,.n_shell_pairs
       if (.max_I(ab)*IP_max < cutoff) cycle
       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
       ab_same = atom_a==atom_b
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
       do cd = 1,ab
         if (.max_I(ab)*.max_I(cd)*P_max < cutoff) cycle
         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
         cd_same = atom_c==atom_d
         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
         if (skip) cycle
         factor = ONE
         if (aa==bb) factor = HALF
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) factor = HALF * factor
         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            I.create(sh4n.ab_n_comp_pairs*sh4n.cd_n_comp_pairs)
            SHELL1QUARTET::make_ERI(sh4n,I)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            I.create(sh4s.ab_n_comp_pairs*sh4s.cd_n_comp_pairs)
            SHELL1QUARTET::make_ERI(sh4s,I)
            sh4s.destroy_cd
         end
         abcd = 0
         do d = fd,ld
         do c = fc,lc
         do b = fb,lb
         do a = fa,la
            abcd = abcd + 1
            I_abcd = factor * I(abcd)
            J(a,b) = J(a,b) + I_abcd*P(d,c)
            J(c,d) = J(c,d) + I_abcd*P(b,a)
            K(a,c) = K(a,c) + I_abcd*P(d,b)
            K(a,d) = K(a,d) + I_abcd*P(c,b)
            K(b,c) = K(b,c) + I_abcd*P(d,a)
            K(b,d) = K(b,d) + I_abcd*P(c,a)
         end
         end
         end
         end
         I.destroy
       end
       sh4n.destroy_ab
       sh4s.destroy_ab
     end
     max_P.destroy
     if (no_max_I) .max_I.destroy
     .weight_diagonal_blocks(J,TWO)
     .blockwise_symmetric_fold(K)
     J = TWO*J
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
        PARALLEL_SYMMETRIC_SUM(K)
     else
        J.symmetric_reflect
        K.symmetric_reflect
     end
     .put_debug(J,"direct j matrix")
     .put_debug(K,"direct k matrix")
   end

   make_r_JK_direct2(J,K,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
     J,K,P :: MAT{REAL}
   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")
     PP,JJ :: VEC{VEC_{REAL}}*
     max_P,Jab,Jcd,Pab,Pcd :: VEC{REAL}*
     sh4s,sh4n :: SHELL1QUARTET
     ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
     atom_a,atom_b,atom_c,atom_d :: INT
     factor,cutoff,P_max,IP_max :: REAL
     skip_J,skip_K,ab_same,cd_same,any_same,no_max_I,ab_eq_cd :: BIN
     .reverse_transfer(P,PP)
     .create_transfer(JJ)
     J = ZERO
     K = ZERO
     cutoff = .scfdata.eri_cutoff
     no_max_I = FALSE
     if (.max_I.destroyed) no_max_I = TRUE
     if (no_max_I) .initialise_max_I
     max_P.create(.n_shell_pairs)
     .make_max_density_elements(max_P,P)
     P_max = maxval(max_P)
     IP_max = maxval(.max_I) * P_max
     parallel do ab = 1,.n_shell_pairs
       if (.max_I(ab)*IP_max < cutoff)  cycle 
       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
       ab_same = atom_a==atom_b
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
       Jab => JJ(ab).element
       Pab => PP(ab).element
       do cd = 1,ab
         if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 
         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
         cd_same = atom_c==atom_d
         .schwarz_test(skip_J,skip_K,cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
         if (skip_J AND skip_K) cycle
         Jcd => JJ(cd).element
         Pcd => PP(cd).element
         ab_eq_cd = FALSE
         if (aa==bb) then; factor = HALF 
         else;             factor = ONE
         end
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) then
            ab_eq_cd = TRUE
            factor = HALF * factor
         end
         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            sh4n.make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            sh4s.make_r_JK_engine(Jab,Jcd,Pab,Pcd,K,P,skip_J,skip_K,ab_eq_cd,factor,fa,la,fb,lb,fc,lc,fd,ld)
            sh4s.destroy_cd
         end
       end
       sh4n.destroy_ab
       sh4s.destroy_ab
     end
     max_P.destroy
     if (no_max_I) .max_I.destroy
     .forward_transfer(JJ,J)
     .weight_diagonal_blocks(J,TWO)
     .blockwise_symmetric_fold(K)
     J = TWO*J
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
        PARALLEL_SYMMETRIC_SUM(K)
     else
        J.symmetric_reflect
        K.symmetric_reflect
     end
     JJ.destroy
     PP.destroy
     .put_debug(J,"direct j matrix 2")
     .put_debug(K,"direct k matrix 2")
   end

   make_r_J_direct(J,P)
   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
   ! directly. This uses the J matrix engine, but it can be easily disabled.
     J,P :: MAT{REAL}
   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")
     PP,JJ :: VEC{VEC_{REAL}}*
     max_P,Jab,Jcd,Pab,Pcd :: VEC{REAL}*
     sh4s,sh4n :: SHELL1QUARTET
     ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
     atom_a,atom_b,atom_c,atom_d :: INT
     factor,cutoff,P_max,IP_max :: REAL
     skip,ab_same,cd_same,any_same,no_max_I,ab_eq_cd :: BIN
     .reverse_transfer(P,PP)
     .create_transfer(JJ)
     J = ZERO
     cutoff = .scfdata.eri_cutoff
     no_max_I = FALSE
     if (.max_I.destroyed) no_max_I = TRUE
     if (no_max_I) .initialise_max_I
     max_P.create(.n_shell_pairs)
     .make_max_density_elements(max_P,P)
     P_max = maxval(max_P)
     IP_max = maxval(.max_I) * P_max
     parallel do ab = 1,.n_shell_pairs
       if (.max_I(ab)*IP_max < cutoff)  cycle 
       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
       ab_same = atom_a==atom_b
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
       Jab => JJ(ab).element
       Pab => PP(ab).element
       do cd = 1,ab
         if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 
         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
         cd_same = atom_c==atom_d
         .schwarz_J_test(skip,cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
         if (skip) cycle
         Jcd => JJ(cd).element
         Pcd => PP(cd).element
         ab_eq_cd = FALSE
         if (aa==bb) then; factor = HALF 
         else;             factor = ONE
         end
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) then
            ab_eq_cd = TRUE
            factor = HALF * factor
         end
         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            sh4n.make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,ab_eq_cd)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            sh4s.make_r_J_engine(Jab,Jcd,Pab,Pcd,factor,ab_eq_cd)
            sh4s.destroy_cd
         end
   ! stdout.text("Jab:")
   ! stdout.put(Jab,"column")
   ! stdout.put(JJ(ab).element,"column")
   ! stdout.text("Jcd:")
   ! stdout.put(Jcd,"column")
   ! stdout.put(JJ(cd).element,"column")
   ! stdout.text("Pab:")
   ! stdout.put(Pab,"column")
   ! stdout.put(PP(ab).element,"column")
   ! stdout.text("Pcd:")
   ! stdout.put(Pcd,"column")
   ! stdout.put(PP(cd).element,"column")
   ! stop
       end
       sh4n.destroy_ab
       sh4s.destroy_ab
     end
     max_P.destroy
     if (no_max_I) .max_I.destroy
     .forward_transfer(JJ,J)
     .weight_diagonal_blocks(J,TWO)
     J = TWO*J
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(J)
     else
        J.symmetric_reflect
     end
     JJ.destroy
     PP.destroy
   end

!   make_r_J_direct(J,P)
!   ! Make the real coulomb matrix "J" from a symmetric density matrix "P"
!   ! directly.
!     J,P :: MAT{REAL}
!     max_I,max_P :: VEC{REAL}*
!     sh4 :: SHELL4
!     ab,cd,aa,bb,cc,dd :: INT
!     fa,fb,fc,fd,la,lb,lc,ld :: INT
!     factor,cutoff,P_max,IP_max :: REAL
!     skip :: BIN
!     J = ZERO
!     cutoff = .scfdata.eri_cutoff
!     max_I.create(.n_shell_pairs)
!     max_P.create(.n_shell_pairs)
!     .make_max_abab_integrals(max_I)
!     .make_max_density_elements(max_P,P)
!     P_max = maxval(max_P)
!     IP_max = maxval(max_I) * P_max
!     parallel do ab = 1,.n_shell_pairs
!       if (max_I(ab)*IP_max < cutoff)  cycle   ! Rough version of Schwarz test, but quick.
!       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb) ! a & b shell indices.
!       .copy_shell_quartet_ab(sh4,aa,bb)
!       do cd = 1,ab
!         if (max_I(ab)*max_I(cd)*P_max < cutoff)  cycle ! Rough version of Schwarz test, but quick.
!         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld)  ! c & d shell indices.
!                                        ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,max_I)
!         if (skip) cycle
!
!         .copy_shell_quartet_cd(sh4,cc,dd)
!         if (aa==bb) then                   ! Evaluate the integrals'
!           factor = HALF                    ! coincidence factors
!         else
!           factor = ONE
!         end
!         if (cc==dd) factor = HALF * factor
!         if (aa==cc AND bb==dd) factor = HALF * factor
!         sh4.make_r_J(J,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!         sh4.destroy_cd
!       end
!       sh4.destroy_ab
!     end
!     max_P.destroy
!     max_I.destroy
!     .weight_diagonal_blocks(J,TWO)
!     if (DO_IN_PARALLEL) then
!        PARALLEL_SYMMETRIC_SUM(J)
!     else
!        J.symmetric_reflect
!     end
!     J = TWO*J
!   end

   make_r_K_direct(K,P)
   ! Make the real exchange matrix "K" from a symmetric density matrix "P"
   ! directly.
     K,P :: MAT{REAL}
     I,max_P :: VEC{REAL}*
     sh4s,sh4n :: SHELL1QUARTET
     ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
     atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
     factor,cutoff,P_max,IP_max,I_abcd :: REAL
     skip,ab_same,cd_same,any_same,no_max_I :: BIN
     K = ZERO
     cutoff = .scfdata.eri_cutoff
     no_max_I = FALSE
     if (.max_I.destroyed) no_max_I = TRUE
     if (no_max_I) .initialise_max_I
     max_P.create(.n_shell_pairs)
     .make_max_density_elements(max_P,P)
     P_max = maxval(max_P)
     IP_max = maxval(.max_I) * P_max
     parallel do ab = 1,.n_shell_pairs
       if (.max_I(ab)*IP_max < cutoff)  cycle 
       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
       ab_same = atom_a==atom_b
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
       do cd = 1,ab
         if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 
         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
         cd_same = atom_c==atom_d
         .schwarz_K_test(skip,cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
         if (skip) cycle
         if (aa==bb) then                   ! Evaluate the integrals'
           factor = HALF                    ! coincidence factors
         else
           factor = ONE
         end
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) factor = HALF * factor
         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            I.create(sh4n.ab_n_comp_pairs*sh4n.cd_n_comp_pairs)
            SHELL1QUARTET::make_ERI(sh4n,I)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            I.create(sh4s.ab_n_comp_pairs*sh4s.cd_n_comp_pairs)
            SHELL1QUARTET::make_ERI(sh4s,I)
            sh4s.destroy_cd
         end
         abcd = 0
         do d = fd,ld
         do c = fc,lc
         do b = fb,lb
         do a = fa,la
            abcd = abcd + 1
            I_abcd = factor * I(abcd)
            K(a,c) = K(a,c) + I_abcd*P(d,b)
            K(a,d) = K(a,d) + I_abcd*P(c,b)
            K(b,c) = K(b,c) + I_abcd*P(d,a)
            K(b,d) = K(b,d) + I_abcd*P(c,a)
         end
         end
         end
         end
         I.destroy
       end
       sh4n.destroy_ab
       sh4s.destroy_ab
     end
     max_P.destroy
     if (no_max_I) .max_I.destroy
     .blockwise_symmetric_fold(K)
     if (DO_IN_PARALLEL) then
        PARALLEL_SYMMETRIC_SUM(K)
     else
        K.symmetric_reflect
     end
   end

   make_r_JK_disk(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
   ! symmetric density matrix "P" from disk integral archive "eri_integrals"
     J,K,P :: MAT{REAL}
     eri_archive,ind_archive :: ARCHIVE
     I :: MAT4{REAL}*
     q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
     I_abcd,P_dc,P_db,P_cb :: REAL
     eri_archive.set(.name,"eri_integrals")
     ind_archive.set(.name,"eri_index")
     ENSURE(.basis_info_made, "no basis info")
     ENSURE(.atom.created,  "no atom list")
     ENSURE(eri_archive.exists, "no integral file")
     ENSURE(ind_archive.exists, "no integral index file")
     eri_archive.open(for="read-only",buffered=TRUE,type="real")
     ind_archive.open(for="read-only",buffered=TRUE,type="int")
     J = ZERO
     K = ZERO
     n_quartets = .n_shell_quartets
     do
       ind_archive.file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       eri_archive.file.read(I)
       do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             do a = fa,la
                I_abcd = I(a,b,c,d)
                J(a,b) = J(a,b) + I_abcd*P_dc
                J(c,d) = J(c,d) + I_abcd*P(b,a)
                K(a,c) = K(a,c) + I_abcd*P_db
                K(a,d) = K(a,d) + I_abcd*P_cb
                K(b,c) = K(b,c) + I_abcd*P(d,a)
                K(b,d) = K(b,d) + I_abcd*P(c,a)
             end
           end
         end
       end
       I.destroy
     end
     ind_archive.close
     eri_archive.close
     .weight_diagonal_blocks(J,TWO)
     .blockwise_symmetric_fold(K)
     J.symmetric_reflect
     K.symmetric_reflect
     J = TWO*J
   end

   make_r_J_disk(J,P)
   ! Make the real coulomb matrix "J" from a
   ! symmetric density matrix "P" from disk integral archive "eri_integrals"
     J,P :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     eri_archive,ind_archive :: ARCHIVE
     I :: MAT4{REAL}*
     q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
     I_abcd,P_dc,P_db,P_cb :: REAL
     eri_archive.set(.name,"eri_integrals")
     ind_archive.set(.name,"eri_index")
   ENSURE(eri_archive.exists, "no integral file")
   ENSURE(ind_archive.exists, "no integral index file")
     eri_archive.open(for="read-only",buffered=TRUE,type="real")
     ind_archive.open(for="read-only",buffered=TRUE,type="int")
     J = ZERO
     n_quartets = .n_shell_quartets
     do
       ind_archive.file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       eri_archive.file.read(I)
       do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             do a = fa,la
                I_abcd = I(a,b,c,d)
                J(a,b) = J(a,b) + I_abcd*P_dc
                J(c,d) = J(c,d) + I_abcd*P(b,a)
             end
           end
         end
       end
       I.destroy
     end
     ind_archive.close
     eri_archive.close
     .weight_diagonal_blocks(J,TWO)
     J.symmetric_reflect
     J = TWO*J
   end

   make_r_K_disk(K,P)
   ! Make the real exchange matrix "K" from a symmetric density matrix "P" from
   ! disk integral archive "eri_integrals"
     K,P :: MAT{REAL}
     eri_archive,ind_archive :: ARCHIVE
     I :: MAT4{REAL}*
     q,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,n_quartets :: INT
     I_abcd,P_dc,P_db,P_cb :: REAL
     eri_archive.set(.name,"eri_integrals")
     ind_archive.set(.name,"eri_index")
     ENSURE(.basis_info_made, "no basis info")
     ENSURE(.atom.created,  "no atom list")
     ENSURE(eri_archive.exists, "no integral file")
     ENSURE(ind_archive.exists, "no integral index file")
     eri_archive.open(for="read-only",buffered=TRUE,type="real")
     ind_archive.open(for="read-only",buffered=TRUE,type="int")
     K = ZERO
     n_quartets = .n_shell_quartets
     do
       ind_archive.file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       eri_archive.file.read(I)
       do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             do a = fa,la
                I_abcd = I(a,b,c,d)
                K(a,c) = K(a,c) + I_abcd*P_db
                K(a,d) = K(a,d) + I_abcd*P_cb
                K(b,c) = K(b,c) + I_abcd*P(d,a)
                K(b,d) = K(b,d) + I_abcd*P(c,a)
             end
           end
         end
       end
       I.destroy
     end
     ind_archive.close
     eri_archive.close
     .blockwise_symmetric_fold(K)
     K.symmetric_reflect
   end

   make_r_group_JK(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the
   ! density matrix "P" only for basis functions which occur in the same
   ! atom_group.
     J,K,P :: MAT{REAL}
     I,max_P :: VEC{REAL}*
     sh4s,sh4n :: SHELL1QUARTET
     ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
     atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
     factor,cutoff,P_max,IP_max,I_abcd :: REAL
     skip,ab_same,cd_same,any_same,no_max_I :: BIN
     J = ZERO
     K = ZERO
     cutoff = .scfdata.eri_cutoff
     no_max_I = FALSE
     if (.max_I.destroyed) no_max_I = TRUE
     if (no_max_I) .initialise_max_I
     max_P.create(.n_shell_pairs)
     .make_max_density_elements(max_P,P)
     P_max = maxval(max_P)
     IP_max = maxval(.max_I) * P_max
     do ab = 1, .n_shell_pairs
        if (.max_I(ab)*IP_max < cutoff)  cycle  
        .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
        ab_same = atom_a==atom_b
        .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
        .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
        do cd = 1,ab
           if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle
           .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d)
           cd_same = atom_c==atom_d
           if (NOT .in_same_atom_group(atom_a,atom_b,atom_c,atom_d)) cycle
           skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
           if (skip) cycle
           factor = ONE                         ! Evaluate the integrals'
           if (aa==bb) factor = HALF            ! coincidence factors
           if (cc==dd) factor = HALF * factor
           if (aa==cc AND bb==dd) factor = HALF * factor
           any_same = ab_same OR cd_same OR &
                      atom_a==atom_c OR atom_a==atom_d OR &
                      atom_b==atom_c OR atom_b==atom_d 
           if (any_same) then
              .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
              I.create(sh4n.ab_n_comp_pairs*sh4n.cd_n_comp_pairs)
              SHELL1QUARTET::make_ERI(sh4n,I)
              sh4n.destroy_cd
           else
              .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
              I.create(sh4s.ab_n_comp_pairs*sh4s.cd_n_comp_pairs)
              SHELL1QUARTET::make_ERI(sh4s,I)
              sh4s.destroy_cd
           end
           abcd = 0
           do d = fd,ld
           do c = fc,lc
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              J(a,b) = J(a,b) + I_abcd*P(d,c)
              J(c,d) = J(c,d) + I_abcd*P(b,a)
              K(a,c) = K(a,c) + I_abcd*P(d,b)
              K(a,d) = K(a,d) + I_abcd*P(c,b)
              K(b,c) = K(b,c) + I_abcd*P(d,a)
              K(b,d) = K(b,d) + I_abcd*P(c,a)
           end
           end
           end
           end
           I.destroy
        end
        sh4n.destroy_ab
        sh4s.destroy_ab
     end
     max_P.destroy
     if (no_max_I) .max_I.destroy
     .weight_diagonal_blocks(J,TWO)
     .blockwise_symmetric_fold(K)
     J.symmetric_reflect
     K.symmetric_reflect
     J = TWO*J
   end

!   make_r_group_JK(J,K,P)
!   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the
!   ! density matrix "P" only for basis functions which occur in the same
!   ! atom_group.
!     J,K,P :: MAT{REAL}
!     max_P :: VEC{REAL}*
!     sh4 :: SHELL4
!     ab,cd, aa,bb,cc,dd :: INT
!     fa,fb,fc,fd,la,lb,lc,ld :: INT
!     atom_a,atom_b,atom_c,atom_d :: INT
!     factor,cutoff,P_max,IP_max :: REAL
!     skip :: BIN
!     J = ZERO
!     K = ZERO
!     cutoff = .scfdata.eri_cutoff
!     if (.max_I.destroyed) .initialise_max_I
!     max_P.create(.n_shell_pairs)
!     .make_max_density_elements(max_P,P)
!     P_max = maxval(max_P)
!     IP_max = maxval(.max_I) * P_max
!     do ab = 1, .n_shell_pairs
!       if (.max_I(ab)*IP_max < cutoff)  cycle   ! Rough version of Schwarz test, but quick.
!       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)    ! a & b shell indices.
!       .copy_shell_quartet_ab(sh4,aa,bb)
!       do cd = 1,ab
!         if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle ! Rough version of Schwarz test, but quick.
!         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d)  ! c & d shell indices.
!         if (NOT .in_same_atom_group(atom_a,atom_b,atom_c,atom_d)) cycle
!                                        ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
!         if (skip) cycle
!                                              ! calculate ab|cd
!         .copy_shell_quartet_cd(sh4,cc,dd)
!         factor = ONE                         ! Evaluate the integrals'
!         if (aa==bb) factor = HALF          ! coincidence factors
!         if (cc==dd) factor = HALF * factor
!         if (aa==cc AND bb==dd) factor = HALF * factor
!         sh4.make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
!         sh4.destroy_cd
!       end
!       sh4.destroy_ab
!     end
!     max_P.destroy
!     .weight_diagonal_blocks(J,TWO)
!     .blockwise_symmetric_fold(K)
!     J.symmetric_reflect
!     K.symmetric_reflect
!     J = TWO*J
!   end

   make_r_JK_nosym(J,K,P)
   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the
   ! density matrix "P" which has no permutational symmetry.
     J,K,P :: MAT{REAL}
     I :: VEC{REAL}*
     max_P :: VEC{REAL}*
     sh4s,sh4n :: SHELL1QUARTET
     ab,cd,aa,bb,cc,dd :: INT
     a,b,c,d,abcd,fa,fb,fc,fd,la,lb,lc,ld :: INT
     atom_a,atom_b,atom_c,atom_d :: INT
     factor,cutoff,P_max,IP_max,I_abcd :: REAL
     skip,ab_same,cd_same,any_same,no_max_I :: BIN
     J = ZERO
     K = ZERO
     cutoff = SCFDATA_ERI_LIMIT
     no_max_I = FALSE
     if (.max_I.destroyed) no_max_I = TRUE
     if (no_max_I) .initialise_max_I
     max_P.create(.n_shell_pairs)
     .make_max_density_elements(max_P,P)
     P_max = maxval(max_P)
     IP_max = maxval(.max_I) * P_max
     do ab = 1,.n_shell_pairs
        if (.max_I(ab)*IP_max < cutoff)  cycle  
        .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
        ab_same = atom_a==atom_b
        .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
        .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
        do cd = 1,ab
           if (.max_I(ab)*.max_I(cd)*P_max < cutoff)  cycle 
           .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
           cd_same = atom_c==atom_d
           skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
           if (skip) cycle
           if (aa==bb) then; factor = HALF      ! coincidence factors
           else;             factor = ONE
           end
           if (cc==dd) factor = HALF * factor
           if (aa==cc AND bb==dd) factor = HALF * factor
           any_same = ab_same OR cd_same OR &
                      atom_a==atom_c OR atom_a==atom_d OR &
                      atom_b==atom_c OR atom_b==atom_d 
           if (any_same) then
              .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
              I.create(sh4n.ab_n_comp_pairs*sh4n.cd_n_comp_pairs)
              SHELL1QUARTET::make_ERI(sh4n,I)
              sh4n.destroy_cd
           else
              .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
              I.create(sh4s.ab_n_comp_pairs*sh4s.cd_n_comp_pairs)
              SHELL1QUARTET::make_ERI(sh4s,I)
              sh4s.destroy_cd
           end
           abcd = 0
           do d = fd,ld
           do c = fc,lc
           do b = fb,lb
           do a = fa,la
              abcd = abcd + 1
              I_abcd = factor * I(abcd)
              J(a,b) = J(a,b) + I_abcd*P(d,c) ! These are symmetric
              J(a,b) = J(a,b) + I_abcd*P(c,d)
              J(b,a) = J(b,a) + I_abcd*P(d,c)
              J(b,a) = J(b,a) + I_abcd*P(c,d)
              J(c,d) = J(c,d) + I_abcd*P(b,a)
              J(c,d) = J(c,d) + I_abcd*P(a,b)
              J(d,c) = J(d,c) + I_abcd*P(b,a)
              J(d,c) = J(d,c) + I_abcd*P(a,b)
              K(a,d) = K(a,d) + I_abcd*P(b,c) ! These are asymmetric
              K(a,c) = K(a,c) + I_abcd*P(b,d)
              K(b,c) = K(b,c) + I_abcd*P(a,d)
              K(b,d) = K(b,d) + I_abcd*P(a,c)
              K(d,a) = K(d,a) + I_abcd*P(c,b)
              K(c,a) = K(c,a) + I_abcd*P(d,b)
              K(c,b) = K(c,b) + I_abcd*P(d,a)
              K(d,b) = K(d,b) + I_abcd*P(c,a)
           end
           end
           end
           end
           I.destroy
        end
        sh4n.destroy_ab
        sh4s.destroy_ab
     end
     max_P.destroy
     if (no_max_I) .max_I.destroy
   end

!   make_r_JK_nosym(J,K,P)
!   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the
!   ! density matrix "P" which has no permutational symmetry.
!     J,K,P :: MAT{REAL}
!     I :: MAT4{REAL}*
!     max_P :: VEC{REAL}*
!     sh4 :: SHELL4
!     ab,cd,i_a,i_b,i_c,i_d :: INT
!     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     I_abcd,factor,cutoff :: REAL
!     skip :: BIN
!     J = ZERO
!     K = ZERO
!     cutoff = SCFDATA_ERI_LIMIT
!     if (.max_I.destroyed) .initialise_max_I
!     max_P.create(.n_shell_pairs)
!     .make_max_density_elements(max_P,P)
!     do ab = 1, .n_shell_pairs
!       .get_shell_pair_indices(ab,i_a,i_b)    ! a & b shell indices.
!       fa = .first_basis_fn_for_shell(i_a)
!       fb = .first_basis_fn_for_shell(i_b)
!       la = .last_basis_fn_for_shell(i_a)
!       lb = .last_basis_fn_for_shell(i_b)
!       .copy_shell_quartet_ab(sh4,i_a,i_b)
!       do cd = 1,ab
!         .get_shell_pair_indices(cd,i_c,i_d)  ! c & d shell indices.
!         fc = .first_basis_fn_for_shell(i_c)
!         fd = .first_basis_fn_for_shell(i_d)
!         lc = .last_basis_fn_for_shell(i_c)
!         ld = .last_basis_fn_for_shell(i_d)
!                                        ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,i_a,i_b,i_c,i_d,max_P,.max_I)
!         if (skip) cycle
!                                              ! calculate ab|cd
!         .copy_shell_quartet_cd(sh4,i_c,i_d)
!         factor = ONE                         ! Evaluate the integrals'
!         if (i_a==i_b) factor = HALF          ! coincidence factors
!         if (i_c==i_d) factor = HALF * factor
!         if (i_a==i_c AND i_b==i_d) factor = HALF * factor
!         I.create(fa,la,fb,lb,fc,lc,fd,ld)
!         sh4.get_ERI(I)
!           do d = fd,ld
!           do c = fc,lc
!           do b = fb,lb
!           do a = fa,la
!            I_abcd = factor * I(a,b,c,d)
!            J(a,b) = J(a,b) + I_abcd*P(d,c) ! These are symmetric
!            J(a,b) = J(a,b) + I_abcd*P(c,d)
!            J(b,a) = J(b,a) + I_abcd*P(d,c)
!            J(b,a) = J(b,a) + I_abcd*P(c,d)
!            J(c,d) = J(c,d) + I_abcd*P(b,a)
!            J(c,d) = J(c,d) + I_abcd*P(a,b)
!            J(d,c) = J(d,c) + I_abcd*P(b,a)
!            J(d,c) = J(d,c) + I_abcd*P(a,b)
!            K(a,d) = K(a,d) + I_abcd*P(b,c) ! These are asymmetric
!            K(a,c) = K(a,c) + I_abcd*P(b,d)
!            K(b,c) = K(b,c) + I_abcd*P(a,d)
!            K(b,d) = K(b,d) + I_abcd*P(a,c)
!            K(d,a) = K(d,a) + I_abcd*P(c,b)
!            K(c,a) = K(c,a) + I_abcd*P(d,b)
!            K(c,b) = K(c,b) + I_abcd*P(d,a)
!            K(d,b) = K(d,b) + I_abcd*P(c,a)
!           end
!           end
!           end
!           end
!         I.destroy
!         sh4.destroy_cd
!       end
!       sh4.destroy_ab
!     end
!     max_P.destroy
!   end

   make_u_JK_direct(J,K,P)
   ! Make the unrestricted coulomb matrices "J" and exchange matrices "K" matrix
   ! from density matrix "P".
     J,K,P :: OPMATRIX*
   ENSURE(J.created("unrestricted"),"unrestricted J not created")
   ENSURE(K.created("unrestricted"),"unrestricted K not created")
   ENSURE(P.created("unrestricted"),"unrestricted P not created")
     PP :: MAT{REAL}*
     I,max_P :: VEC{REAL}*
     sh4s,sh4n :: SHELL1QUARTET
     ab,cd,aa,bb,cc,dd,fa,fb,fc,fd,la,lb,lc,ld :: INT
     atom_a,atom_b,atom_c,atom_d,a,b,c,d,abcd :: INT
     factor,cutoff,I_abcd :: REAL
     skip,ab_same,cd_same,any_same,no_max_I :: BIN
     J.set_to_zero
     K.set_to_zero
     cutoff = .scfdata.eri_cutoff
     no_max_I = FALSE
     if (.max_I.destroyed) no_max_I = TRUE
     if (no_max_I) .initialise_max_I
     max_P.create(.n_shell_pairs)
     PP.create(.n_bf,.n_bf)
     PP = P.alpha + P.beta
     .make_max_density_elements(max_P,PP)
     PP.destroy
     do ab = 1, .n_shell_pairs
       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
       ab_same = atom_a==atom_b
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
       do cd = 1,ab
         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
         cd_same = atom_c==atom_d
                                              ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
         if (skip) cycle
                                              ! calculate ab|cd
         factor = ONE                         ! Evaluate the integrals'
         if (aa==bb) factor = HALF            ! coincidence factors
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) factor = HALF * factor
         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            I.create(sh4n.ab_n_comp_pairs*sh4n.cd_n_comp_pairs)
            SHELL1QUARTET::make_ERI(sh4n,I)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            I.create(sh4s.ab_n_comp_pairs*sh4s.cd_n_comp_pairs)
            SHELL1QUARTET::make_ERI(sh4s,I)
            sh4s.destroy_cd
         end
         abcd = 0
         do d = fd,ld
         do c = fc,lc
         do b = fb,lb
         do a = fa,la
            abcd = abcd + 1
            I_abcd = factor * I(abcd)
            J.alpha(a,b) = J.alpha(a,b) + I_abcd*P.alpha(d,c)
            J.alpha(c,d) = J.alpha(c,d) + I_abcd*P.alpha(b,a)
            K.alpha(a,c) = K.alpha(a,c) + I_abcd*P.alpha(d,b)
            K.alpha(a,d) = K.alpha(a,d) + I_abcd*P.alpha(c,b)
            K.alpha(b,c) = K.alpha(b,c) + I_abcd*P.alpha(d,a)
            K.alpha(b,d) = K.alpha(b,d) + I_abcd*P.alpha(c,a)
            J.beta(a,b) = J.beta(a,b) + I_abcd*P.beta(d,c)
            J.beta(c,d) = J.beta(c,d) + I_abcd*P.beta(b,a)
            K.beta(a,c) = K.beta(a,c) + I_abcd*P.beta(d,b)
            K.beta(a,d) = K.beta(a,d) + I_abcd*P.beta(c,b)
            K.beta(b,c) = K.beta(b,c) + I_abcd*P.beta(d,a)
            K.beta(b,d) = K.beta(b,d) + I_abcd*P.beta(c,a)
         end
         end
         end
         end
         I.destroy
       end
       sh4n.destroy_ab
       sh4s.destroy_ab
     end
     max_P.destroy
     if (no_max_I) .max_I.destroy
     .weight_diagonal_blocks(J.alpha,TWO)
     .weight_diagonal_blocks(J.beta,TWO)
     .blockwise_symmetric_fold(K.alpha)
     .blockwise_symmetric_fold(K.beta)
     J.alpha.symmetric_reflect
     J.beta.symmetric_reflect
     K.alpha.symmetric_reflect
     K.beta.symmetric_reflect
     J.alpha = TWO*J.alpha
     J.beta  = TWO*J.beta
   end

!   make_u_JK_direct(J,Ka,Kb,P,Pa,Pb)
!   ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
!   ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
!     J,Ka,Kb,P,Pa,Pb :: MAT{REAL},target
!     I :: MAT4{REAL}*
!     max_P :: VEC{REAL}*
!     sh4 :: SHELL4
!!     sh4q :: SHELL1QUARTET
!     ab,cd, aa,bb,cc,dd :: INT
!     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     I_abcd,factor,Pa_db,Pa_cb,Pb_db,Pb_cb,cutoff :: REAL
!     P_dc,Jcd,Ka_bc,Ka_bd,Kb_bc,Kb_bd :: REAL
!     skip :: BIN
!     J  = ZERO
!     Ka = ZERO
!     Kb = ZERO
!     cutoff = .scfdata.eri_cutoff
!     max_P.create(.n_shell_pairs)
!     .make_max_density_elements(max_P,P)
!     if (.max_I.destroyed) .initialise_max_I
!     do ab = 1, .n_shell_pairs
!       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb)   ! a & b shell indices.
!!       .set_precomp_shell_quartet_ab(sh4q,aa,bb)
!       .copy_shell_quartet_ab(sh4,aa,bb)
!       do cd = 1,ab
!         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld) ! c & d shell indices.
!                                              ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
!         if (skip) cycle
!                                              ! calculate ab|cd
!         .copy_shell_quartet_cd(sh4,cc,dd)
!!         .set_precomp_shell_quartet_cd(sh4q,cc,dd)
!         factor = ONE                         ! Evaluate the integrals'
!         if (aa==bb) factor = HALF            ! coincidence factors
!         if (cc==dd) factor = HALF * factor
!         if (aa==cc AND bb==dd) factor = HALF * factor
!         I.create(fa,la,fb,lb,fc,lc,fd,ld)
!         sh4.get_ERI(I)
!!         sh4q.get_ERI(I)
!         do d = fd,ld
!           do c = fc,lc
!             P_dc = P(d,c)
!             Jcd = ZERO
!             do b = fb,lb
!               Pa_db = Pa(d,b)
!               Pb_db = Pb(d,b)
!               Pa_cb = Pa(c,b)
!               Pb_cb = Pb(c,b)
!               Ka_bc = ZERO
!               Kb_bc = ZERO
!               Ka_bd = ZERO
!               Kb_bd = ZERO
!               do a = fa,la
!                 I_abcd  = factor  * I(a,b,c,d)
!                 J(a,b)  = J(a,b)  + I_abcd*P_dc
!                 Jcd     = Jcd     + I_abcd*P(b,a)
!                 Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
!                 Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
!                 Ka_bc   = Ka_bc   + I_abcd*Pa(d,a)
!                 Ka_bd   = Ka_bd   + I_abcd*Pa(c,a)
!                 Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
!                 Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
!                 Kb_bc   = Kb_bc   + I_abcd*Pb(d,a)
!                 Kb_bd   = Kb_bd   + I_abcd*Pb(c,a)
!               end
!               Ka(b,c) = Ka(b,c) + Ka_bc
!               Ka(b,d) = Ka(b,d) + Ka_bd
!               Kb(b,c) = Kb(b,c) + Kb_bc
!               Kb(b,d) = Kb(b,d) + Kb_bd
!             end
!             J(c,d) = J(c,d) + Jcd
!           end
!         end
!         I.destroy
!         sh4.destroy_cd
!!         sh4q.destroy_cd
!       end
!       sh4.destroy_ab
!!       sh4q.destroy_ab
!     end
!     max_P.destroy
!     .weight_diagonal_blocks(J,TWO)
!     .blockwise_symmetric_fold(Ka)
!     .blockwise_symmetric_fold(Kb)
!     J.symmetric_reflect
!     Ka.symmetric_reflect
!     Kb.symmetric_reflect
!     J = TWO*J
!   end

   make_u_JK_disk(J,Ka,Kb,P,Pa,Pb)
   ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
   ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
     J,Ka,Kb,P,Pa,Pb :: MAT{REAL}
     eri_archive,ind_archive :: ARCHIVE*
     I :: MAT4{REAL}*
     q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
     I_abcd,P_dc,Pa_db,Pa_cb,Pb_db,Pb_cb :: REAL
     eri_archive.create(.name,"eri_integrals")
     ind_archive.create(.name,"eri_index")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(eri_archive.exists, "no integral file")
   ENSURE(ind_archive.exists, "no integral index file")
     eri_archive.open(for="read-only",buffered=TRUE,type="real")
     ind_archive.open(for="read-only",buffered=TRUE,type="int")
     J  = ZERO
     Ka = ZERO
     Kb = ZERO
     n_quartets = .n_shell_quartets
     do
       ind_archive.file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
       I.create(fa,la,fb,lb,fc,lc,fd,ld)
       eri_archive.file.read(I)
       do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           do b = fb,lb
             Pa_db = Pa(d,b)
             Pb_db = Pb(d,b)
             Pa_cb = Pa(c,b)
             Pb_cb = Pb(c,b)
             do a = fa,la
                I_abcd = I(a,b,c,d)
                J(a,b) = J(a,b) + I_abcd*P_dc
                J(c,d) = J(c,d) + I_abcd*P(b,a)
                Ka(a,c) = Ka(a,c) + I_abcd*Pa_db
                Ka(a,d) = Ka(a,d) + I_abcd*Pa_cb
                Ka(b,c) = Ka(b,c) + I_abcd*Pa(d,a)
                Ka(b,d) = Ka(b,d) + I_abcd*Pa(c,a)
                Kb(a,c) = Kb(a,c) + I_abcd*Pb_db
                Kb(a,d) = Kb(a,d) + I_abcd*Pb_cb
                Kb(b,c) = Kb(b,c) + I_abcd*Pb(d,a)
                Kb(b,d) = Kb(b,d) + I_abcd*Pb(c,a)
             end
           end
         end
       end
       I.destroy
     end
     ind_archive.destroy
     eri_archive.destroy
     .weight_diagonal_blocks(J,TWO)
     .blockwise_symmetric_fold(Ka)
     .blockwise_symmetric_fold(Kb)
     J.symmetric_reflect
     Ka.symmetric_reflect
     Kb.symmetric_reflect
     J = TWO*J
   end

   make_gc_JK_direct(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
   ! Make the general complex matrices "J" and exchange matrices
   ! "Ka", "Kb" and "Kba" from a density matrices "P", "Pa", "Pb" and "Pba"
   ! directly from the integrals.
     J,P :: MAT{REAL}
     Ka,Kb,Kba,Pa,Pb,Pba :: MAT{CPX}
     I :: VEC{REAL}*
     abs_P :: MAT{REAL}*
     max_P :: VEC{REAL}*
     sh4s,sh4n :: SHELL1QUARTET
     ab,cd,aa,bb,cc,dd :: INT
     a,b,c,d,abcd,fa,fb,fc,fd,la,lb,lc,ld :: INT
     atom_a,atom_b,atom_c,atom_d :: INT
     I_abcd,factor,cutoff :: REAL
     skip,ab_same,cd_same,any_same,no_max_I :: BIN
     J   = ZERO
     Ka  = ZERO
     Kb  = ZERO
     Kba = ZERO
     cutoff = .scfdata.eri_cutoff
     no_max_I = FALSE
     if (.max_I.destroyed) no_max_I = TRUE
     if (no_max_I) .initialise_max_I
     max_P.create(.n_shell_pairs)
     abs_P.create(.n_bf,.n_bf)
     abs_P = max(abs(P),abs(Pa),abs(Pb),abs(Pba))
     .make_max_density_elements(max_P,abs_P)
     abs_P.destroy
     do ab = 1,.n_shell_pairs
       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb,atom_a,atom_b)
       ab_same = atom_a==atom_b
       .set_new_shell_quartet_ab(sh4s,aa,bb,skip=TRUE)
       .set_new_shell_quartet_ab(sh4n,aa,bb,skip=FALSE)
       do cd = 1,ab
         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld,atom_c,atom_d) 
         cd_same = atom_c==atom_d
         skip = .schwarz_inequality_test(cutoff,ab,cd,aa,bb,cc,dd,max_P,.max_I)
         if (skip) cycle
         factor = ONE                             ! Evaluate the integrals
         if (aa==bb) factor = HALF                ! Coincidence factors
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) factor = HALF * factor
         any_same = ab_same OR cd_same OR &
                    atom_a==atom_c OR atom_a==atom_d OR &
                    atom_b==atom_c OR atom_b==atom_d 
         if (any_same) then
            .set_new_shell_quartet_cd(sh4n,cc,dd,skip=FALSE)
            I.create(sh4n.ab_n_comp_pairs*sh4n.cd_n_comp_pairs)
            SHELL1QUARTET::make_ERI(sh4n,I)
            sh4n.destroy_cd
         else
            .set_new_shell_quartet_cd(sh4s,cc,dd,skip=TRUE)
            I.create(sh4s.ab_n_comp_pairs*sh4s.cd_n_comp_pairs)
            SHELL1QUARTET::make_ERI(sh4s,I)
            sh4s.destroy_cd
         end
         I = factor * I
         abcd = 0
         do d = fd,ld
         do c = fc,lc
         do b = fb,lb
         do a = fa,la
            abcd = abcd + 1
            I_abcd = I(abcd)
            J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
            J(c,d)   = J(c,d)   + I_abcd*P(b,a)
            Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric
            Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)  ! but must be folded
            Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
            Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
            Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric
            Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)  ! but must be folded
            Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
            Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
            Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
            Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
            Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
            Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
            Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
            Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
            Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
            Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
         end
         end
         end
         end
         I.destroy
       end
       sh4n.destroy_ab
       sh4s.destroy_ab
     end
     max_P.destroy
     if (no_max_I) .max_I.destroy
     .weight_diagonal_blocks(J,TWO)
     .blockwise_hermitian_fold(Ka)
     .blockwise_hermitian_fold(Kb)
     J.symmetric_reflect
     Ka.make_hermitian
     Kb.make_hermitian
     J = TWO*J
   end

   make_gc_JK_disk(J,Ka,Kb,Kba,P,Pa,Pb,Pba)
   ! Make the real coulomb matrices "J" and exchange matrices "Ka" and "Kb"
   ! matrix from a symmetric density matrices "P", "Pa", and "Pb" directly.
     J,P :: MAT{REAL}
     Ka,Kb,Kba,Pa,Pb,Pba :: MAT{CPX}
     eri_archive,ind_archive :: ARCHIVE*
     I :: MAT4{REAL}*
     q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
     I_abcd :: REAL
     eri_archive.create(.name,"eri_integrals")
     ind_archive.create(.name,"eri_index")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(eri_archive.exists, "no integral file")
   ENSURE(ind_archive.exists, "no integral index file")
     eri_archive.open(for="read-only",buffered=TRUE,type="real")
     ind_archive.open(for="read-only",buffered=TRUE,type="int")
     J   = ZERO
     Ka  = ZERO
     Kb  = ZERO
     Kba = ZERO
     n_quartets = .n_shell_quartets
     do
       ind_archive.file.read(q)
       if (q > n_quartets) exit
       .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
     ! I.create(fa,la,fb,lb,fc,lc,fd,ld)
       allocate(I(fa:la,fb:lb,fc:lc,fd:ld))
       eri_archive.file.read(I)
       do d = fd,ld
       do c = fc,lc
       do b = fb,lb
       do a = fa,la
           I_abcd = I(a,b,c,d)
           J(a,b)   = J(a,b)   + I_abcd*P(d,c)   ! These are symmetric
           J(c,d)   = J(c,d)   + I_abcd*P(b,a)
           Ka(a,d)  = Ka(a,d)  + I_abcd*Pa(b,c)  ! These are symmetric but must be folded
           Ka(a,c)  = Ka(a,c)  + I_abcd*Pa(b,d)
           Ka(b,c)  = Ka(b,c)  + I_abcd*Pa(a,d)
           Ka(b,d)  = Ka(b,d)  + I_abcd*Pa(a,c)
           Kb(a,d)  = Kb(a,d)  + I_abcd*Pb(b,c)  ! These are symmetric but must be folded
           Kb(a,c)  = Kb(a,c)  + I_abcd*Pb(b,d)
           Kb(b,c)  = Kb(b,c)  + I_abcd*Pb(a,d)
           Kb(b,d)  = Kb(b,d)  + I_abcd*Pb(a,c)
           Kba(a,d) = Kba(a,d) + I_abcd*Pba(b,c) ! These are asymmetric
           Kba(a,c) = Kba(a,c) + I_abcd*Pba(b,d)
           Kba(b,c) = Kba(b,c) + I_abcd*Pba(a,d)
           Kba(b,d) = Kba(b,d) + I_abcd*Pba(a,c)
           Kba(d,a) = Kba(d,a) + I_abcd*Pba(c,b)
           Kba(c,a) = Kba(c,a) + I_abcd*Pba(d,b)
           Kba(c,b) = Kba(c,b) + I_abcd*Pba(d,a)
           Kba(d,b) = Kba(d,b) + I_abcd*Pba(c,a)
       end
       end
       end
       end
     ! I.destroy
       deallocate(I)
     end
     ind_archive.destroy
     eri_archive.destroy
     .weight_diagonal_blocks(J,TWO)
     .blockwise_hermitian_fold(Ka)
     .blockwise_hermitian_fold(Kb)
     J.symmetric_reflect
     Ka.make_hermitian
     Kb.make_hermitian
     J = TWO*J
   end

   make_gc_so_JK_direct(JS,KS,JO,KO,P)
   ! Make the general complex spin orbit Classical and Exchange matrices.
   ! Make them directly from integrals on the fly.
     JS,KS,JO,KO :: MAT5{CPX}
     P :: MAT4{CPX}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     S,O :: MAT5{REAL}*
     ab,cd,aa,bb,cc,dd :: INT
     a,b,c,d,k,fa,fb,fc,fd,la,lb,lc,ld,m,n :: INT
     S_abcd,O_abcd,factor :: REAL
     sh4 :: SHELL4*
     JS = ZERO; KS = ZERO; JO = ZERO; KO = ZERO
     sh4.create
     do ab = 1,.n_shell_pairs
       .get_shell_pair_indices(ab,aa,bb,fa,la,fb,lb)
       do cd = 1,ab
         .get_shell_pair_indices(cd,cc,dd,fc,lc,fd,ld)
         .copy_shell_quartet(sh4,aa,bb,cc,dd)
         if (sh4.skip_ERI) then ! ??????
           sh4.destroy_ptr_part
           cycle
         end
         allocate(S(fa:la,fb:lb,fc:lc,fd:ld,3))
         allocate(O(fa:la,fb:lb,fc:lc,fd:ld,3))
         sh4.make_spin_orbit_ints(S,O)
         factor = ONE                                   ! Evaluate the integrals
         if (aa==bb) factor = HALF                      ! Coincidence factors
         if (cc==dd) factor = HALF * factor
         if (aa==cc AND bb==dd) factor = HALF * factor
         S = factor * S
         O = factor * O
         do k = 1,3
         do a = fa,la
         do b = fb,lb
         do c = fc,lc
         do d = fd,ld
            S_abcd = S(a,b,c,d,k)
            O_abcd = O(a,b,c,d,k)
            do m = 1,2
            do n = 1,2
               !
               JS(a,b, m,n,k) = JS(a,b, m,n,k) + S_abcd*P(d,c, m,n)
               JS(a,b, m,n,k) = JS(a,b, m,n,k) + S_abcd*P(c,d, m,n)
               JS(b,a, m,n,k) = JS(b,a, m,n,k) - S_abcd*P(d,c, m,n)
               JS(b,a, m,n,k) = JS(b,a, m,n,k) - S_abcd*P(c,d, m,n)
               JS(c,d, m,n,k) = JS(c,d, m,n,k) + O_abcd*P(b,a, m,n)
               JS(c,d, m,n,k) = JS(c,d, m,n,k) + O_abcd*P(a,b, m,n)
               JS(d,c, m,n,k) = JS(d,c, m,n,k) - O_abcd*P(b,a, m,n)
               JS(d,c, m,n,k) = JS(d,c, m,n,k) - O_abcd*P(a,b, m,n)
               !
               JO(a,b, m,n,k) = JO(a,b, m,n,k) + O_abcd*P(d,c, m,n)
               JO(a,b, m,n,k) = JO(a,b, m,n,k) - O_abcd*P(c,d, m,n)
               JO(b,a, m,n,k) = JO(b,a, m,n,k) + O_abcd*P(d,c, m,n)
               JO(b,a, m,n,k) = JO(b,a, m,n,k) - O_abcd*P(c,d, m,n)
               JO(c,d, m,n,k) = JO(c,d, m,n,k) + S_abcd*P(b,a, m,n)
               JO(c,d, m,n,k) = JO(c,d, m,n,k) - S_abcd*P(a,b, m,n)
               JO(d,c, m,n,k) = JO(d,c, m,n,k) + S_abcd*P(b,a, m,n)
               JO(d,c, m,n,k) = JO(d,c, m,n,k) - S_abcd*P(a,b, m,n)
               !
               KS(a,d, m,n,k) = KS(a,d, m,n,k) + S_abcd*P(b,c, m,n)
               KS(a,c, m,n,k) = KS(a,c, m,n,k) + S_abcd*P(b,d, m,n)
               KS(b,d, m,n,k) = KS(b,d, m,n,k) - S_abcd*P(a,c, m,n)
               KS(b,c, m,n,k) = KS(b,c, m,n,k) - S_abcd*P(a,d, m,n)
               KS(c,b, m,n,k) = KS(c,b, m,n,k) + O_abcd*P(d,a, m,n)
               KS(c,a, m,n,k) = KS(c,a, m,n,k) + O_abcd*P(d,b, m,n)
               KS(d,b, m,n,k) = KS(d,b, m,n,k) - O_abcd*P(c,a, m,n)
               KS(d,a, m,n,k) = KS(d,a, m,n,k) - O_abcd*P(c,b, m,n)
               !
               KO(a,d, m,n,k) = KO(a,d, m,n,k) + O_abcd*P(b,c, m,n)
               KO(a,c, m,n,k) = KO(a,c, m,n,k) - O_abcd*P(b,d, m,n)
               KO(b,d, m,n,k) = KO(b,d, m,n,k) + O_abcd*P(a,c, m,n)
               KO(b,c, m,n,k) = KO(b,c, m,n,k) - O_abcd*P(a,d, m,n)
               KO(c,b, m,n,k) = KO(c,b, m,n,k) + S_abcd*P(d,a, m,n)
               KO(c,a, m,n,k) = KO(c,a, m,n,k) - S_abcd*P(d,b, m,n)
               KO(d,b, m,n,k) = KO(d,b, m,n,k) + S_abcd*P(c,a, m,n)
               KO(d,a, m,n,k) = KO(d,a, m,n,k) - S_abcd*P(c,b, m,n)
            end
            end
         end
         end
         end
         end
         end
         deallocate(O)
         deallocate(S)
         sh4.destroy_ptr_part
       end
     end
     sh4.destroy
   end

   make_gc_so_JK_disk(JS,KS,JO,KO,P,component)
   ! Make the general complex spin orbit Classical and Exchange matrices
   ! for a particular "component", either "x", "y" or "z".
     JS,KS,JO,KO,P :: MAT4{CPX}
     component :: STR(1)
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     SO_archive,ind_archive :: ARCHIVE
     S,O :: MAT4{REAL}*
     q,n_quartets :: INT
     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld,m,n :: INT
     S_abcd,O_abcd :: REAL
     SO_archive.set(.name,"SO"//component//"_integrals")
     ind_archive.set(.name,"SO_indices")
   ENSURE(SO_archive.exists,  "no spin orbit integral file!")
   ENSURE(ind_archive.exists, "no spin orbit integral index file")
     SO_archive.open(for="read-only",buffered=TRUE,type="real")
     ind_archive.open(for="read-only",buffered=TRUE,type="int")
     JS = ZERO; KS = ZERO; JO = ZERO; KO = ZERO
     n_quartets = .n_shell_quartets
     do
        ind_archive.file.read(q)
        if (q > n_quartets) exit
        .get_shell_quartet_indices(q,fa,la,fb,lb,fc,lc,fd,ld)
        S.create(fa,la,fb,lb,fc,lc,fd,ld)
        O.create(fa,la,fb,lb,fc,lc,fd,ld)
        SO_archive.file.read(S)
        SO_archive.file.read(O)
        do a = fa,la
        do b = fb,lb
        do c = fc,lc
        do d = fd,ld
           S_abcd = S(a,b,c,d)
           O_abcd = O(a,b,c,d)
           do m = 1,2
           do n = 1,2
              !
              JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(d,c, m,n)
              JS(a,b, m,n) = JS(a,b, m,n) + S_abcd*P(c,d, m,n)
              JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(d,c, m,n)
              JS(b,a, m,n) = JS(b,a, m,n) - S_abcd*P(c,d, m,n)
              JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(b,a, m,n)
              JS(c,d, m,n) = JS(c,d, m,n) + O_abcd*P(a,b, m,n)
              JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(b,a, m,n)
              JS(d,c, m,n) = JS(d,c, m,n) - O_abcd*P(a,b, m,n)
              !
              JO(a,b, m,n) = JO(a,b, m,n) + O_abcd*P(d,c, m,n)
              JO(a,b, m,n) = JO(a,b, m,n) - O_abcd*P(c,d, m,n)
              JO(b,a, m,n) = JO(b,a, m,n) + O_abcd*P(d,c, m,n)
              JO(b,a, m,n) = JO(b,a, m,n) - O_abcd*P(c,d, m,n)
              JO(c,d, m,n) = JO(c,d, m,n) + S_abcd*P(b,a, m,n)
              JO(c,d, m,n) = JO(c,d, m,n) - S_abcd*P(a,b, m,n)
              JO(d,c, m,n) = JO(d,c, m,n) + S_abcd*P(b,a, m,n)
              JO(d,c, m,n) = JO(d,c, m,n) - S_abcd*P(a,b, m,n)
              !
              KS(a,d, m,n) = KS(a,d, m,n) + S_abcd*P(b,c, m,n)
              KS(a,c, m,n) = KS(a,c, m,n) + S_abcd*P(b,d, m,n)
              KS(b,d, m,n) = KS(b,d, m,n) - S_abcd*P(a,c, m,n)
              KS(b,c, m,n) = KS(b,c, m,n) - S_abcd*P(a,d, m,n)
              KS(c,b, m,n) = KS(c,b, m,n) + O_abcd*P(d,a, m,n)
              KS(c,a, m,n) = KS(c,a, m,n) + O_abcd*P(d,b, m,n)
              KS(d,b, m,n) = KS(d,b, m,n) - O_abcd*P(c,a, m,n)
              KS(d,a, m,n) = KS(d,a, m,n) - O_abcd*P(c,b, m,n)
              !
              KO(a,d, m,n) = KO(a,d, m,n) + O_abcd*P(b,c, m,n)
              KO(a,c, m,n) = KO(a,c, m,n) - O_abcd*P(b,d, m,n)
              KO(b,d, m,n) = KO(b,d, m,n) + O_abcd*P(a,c, m,n)
              KO(b,c, m,n) = KO(b,c, m,n) - O_abcd*P(a,d, m,n)
              KO(c,b, m,n) = KO(c,b, m,n) + S_abcd*P(d,a, m,n)
              KO(c,a, m,n) = KO(c,a, m,n) - S_abcd*P(d,b, m,n)
              KO(d,b, m,n) = KO(d,b, m,n) + S_abcd*P(c,a, m,n)
              KO(d,a, m,n) = KO(d,a, m,n) - S_abcd*P(c,b, m,n)
           end
           end
        end
        end
        end
        end
        O.destroy; S.destroy
     end
     SO_archive.close
     ind_archive.close
   end

   weight_diagonal_blocks(X,fac) ::: pure
   ! Weight the diagonal blocks of matrix "X" by "fac"
      self :: IN
      X :: MAT{REAL}, INOUT
      fac :: REAL, IN
      n,f,l :: INT
      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac*X(f:l,f:l)
      end
   end

   weight_diagonal_blocks(X,fac) ::: pure
   ! Weight the diagonal blocks of matrix "X" by "fac"
      self :: IN
      X :: MAT{CPX}, INOUT
      fac :: REAL, IN
      n,f,l :: INT
      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac*X(f:l,f:l)
      end
   end

   set_diagonal_blocks(X,fac) ::: pure
   ! Set the diagonal blocks of matrix "X" to "fac"
      self :: IN
      X :: MAT{REAL}, INOUT
      fac :: REAL, IN
      n,f,l :: INT
      do n = 1,.n_shell
         f = .first_basis_fn_for_shell(n)
         l = .last_basis_fn_for_shell(n)
         X(f:l,f:l) = fac
      end
   end

   blockwise_symmetric_fold(X)
   ! Symmetrically fold the matrix "X" blockwise
      X :: MAT{REAL}
      a,fa,la,b,fb,lb :: INT
      do a = 1,.n_shell
      do b = 1,a
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)
         X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(X(fb:lb,fa:la))
      end
      end
   end

   blockwise_hermitian_fold(X)
   ! Hermitian fold the matrix "X" blockwise
      X :: MAT{CPX}
      a,fa,la,b,fb,lb :: INT
      do a = 1,.n_shell
      do b = 1,a
         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)
         X(fa:la,fb:lb) = X(fa:la,fb:lb) + transpose(conjg(X(fb:lb,fa:la)))
      end
      end
   end

!*******************************************************************************
!  Restricted DFT
!*******************************************************************************

   add_XC_matrix(K) ::: leaky
   ! Add the DFT exchange correlation matrix to "K".
      K :: OPMATRIX*
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.scfdata.is_DFT_calculation,"this is not a DFT calculation")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(K.created,"K not created")
   ENSURE(K.created(.scfdata.spinorbital_kind),"appropriate part of K not created")
      saved_becke_grid :: BECKE_GRID*
      apply_rough,do_rough :: BIN
      roughly_converged :: BIN, save
      genre :: STR
      ! Adjust grid accuracy lower if required
      if (.scfdata.iteration==0) roughly_converged = FALSE
      if (.scfdata.roughly_converged) roughly_converged = TRUE
      do_rough = .scfdata.apply_rough_convergence AND NOT roughly_converged
      if (do_rough) then
         saved_becke_grid => .becke_grid
      end
      ! Ensure the NO's exist so we can calculate the density for the XC part
      genre = .scfdata.spinorbital_kind
      if (.molecular_orbitals.all_destroyed) then; .make_natural_orbitals(genre) !  leaky
      else;                                        .assign_NOs_to_MOs
      end
      ! Now add the contribution
      select case (.scfdata.scf_kind)
        case ("rks","xray_rks")
           .add_XC_matrix(K.restricted)
        case ("uks","xray_uks","pnd_uks","xray_pnd_uks")
           .add_XC_matrix(K.alpha,K.beta)
        case default
           DIE("unknown DFT SCF kind, "//trim(.scfdata.scf_kind))
      end
      ! Put back accurate grid, if required
      if (do_rough) .becke_grid => saved_becke_grid
   end

   add_XC_matrix(K)
   ! Calculate the exchange correlation matrix numerically.
      K :: MAT{REAL}
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.scfdata.is_DFT_calculation,"this is not a DFT calculation")
      E :: REAL
      if (.scfdata.using_GGA_functional) then; .add_GGA_XC_matrix(K,E)
      else;                                    .add_LDA_XC_matrix(K,E)
      end
      .scfdata.dft_energy_correction = E
      .put_debug(E,"restricted XC energy")
   end

   add_LDA_XC_matrix(K,E)
   ! Add the exchange and correlation matrices to K. This routine supports
   ! local functional only, either exchange or correlation.
      K :: MAT{REAL}, target
      E :: REAL
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")
      pt,a0,b0,V,W :: MAT{REAL}*
      wt,rho0,V0,E0,ab0 :: VEC{REAL}*
      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb :: INT
      atom_a,atom_b,i :: INT
      same_atoms :: BIN
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      V_ab :: REAL
      W.create(.n_bf,.n_bf)
      V.create(.n_bf,.n_bf)                     ! Use temporary V for parallelisation
      nullify(a0)
      nullify(b0)
      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2
         end                                    ! Make the grid points and weights
       ! .becke_grid.make_grid(pt,wt,atoms,compress=FALSE)
       ! .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=FALSE)
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                         ! Keep the weight_is_0 array
         V0.create(n_pt)                        ! local potential grids
         E0.create(n_pt)                        ! The energy density
         ab0.create(n_pt)
         .becke_grid.make_bf_grids(a0,b0,ma,mb,pt,atoms)
         rho0.create(n_pt)                      ! The density grids
         .make_density_grid_r_B(rho0,pt,atoms,a0,b0) 
         V0 = ZERO                              ! re-use a0, b0 grids
         .add_r_XC_potentials(V0,rho0)          ! Evaluation the XC potentials
         .set_r_XC_energy_density(E0,rho0)
         rho0.destroy
  ! stdout.show("q =",q)
  ! stdout.text("V0a:")
  ! stdout.put(V0)
  ! stdout.text("V0b:")
  ! stdout.put(V0)
  ! stdout.text("E:")
  ! stdout.put(E0)
         V0 = wt*V0
         E0 = wt*E0
  ! stdout.text("V0a:")
  ! stdout.put(V0)
  ! stdout.text("V0b:")
  ! stdout.put(V0)
  ! stdout.text("E:")
  ! stdout.put(E0)
         wt.destroy; pt.destroy
         ! Make the exchange correlation matrix
         do a = 1,na
         do b = 1,nb
            ab0 = a0(:,a)*b0(:,b)
            V_ab = sum(V0*ab0) 
            aa = fa + a
            bb = fb + b
            V(aa,bb) = V_ab                    
            W(aa,bb) = -HALF*V_ab + sum(E0*ab0) ! Make the DFT energy correction matrix
  ! stdout.show("Va =",V_ab)
  ! stdout.show("Vb =",V_ab)
  ! stdout.show("e  =",sum(E0*ab0))
         end
         end
  ! stdout.text("Va:")
  ! stdout.put(V(fa+1:la,fb+1:lb))
  ! stdout.text("Vb:")
  ! stdout.put(V(fa+1:la,fb+1:lb))
  ! stdout.text("W:")
  ! stdout.put(W(fa+1:la,fb+1:lb))
         ab0.destroy; E0.destroy; V0.destroy
         if (same_atoms) then
            a0.destroy
            nullify(b0)
         else
            b0.destroy
            a0.destroy
         end
      end
      K = K + V
      V.destroy
      K.symmetric_reflect
      W.symmetric_reflect
      E = W.trace_of_product_with(.density_matrix.restricted)
      W.destroy
   end

   add_GGA_XC_matrix(K,E)
   ! Add the exchange and correlation matrices to K. This routine supports
   ! non-local functionals, either exchange or correlation.
      K :: MAT{REAL}, target
      E :: REAL
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")
      a1,b1 :: MAT3{REAL}*
      pt,rho1,V1,a0,b0,V :: MAT{REAL}*
      wt,rho0,V0,E0,ab0 :: VEC{REAL}*
      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb :: INT
      atom_a,atom_b,i :: INT
      same_atoms :: BIN
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      V_ab,E_ab,fac :: REAL
      V.create(.n_bf,.n_bf)                     ! Use temporary V for parallelisation
      nullify(a0); nullify(a1)
      nullify(b0); nullify(b1)
      E = ZERO
      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
         end                                    ! Make the grid points and weights
       ! .becke_grid.make_grid(pt,wt,atoms,compress=FALSE)
       ! .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=FALSE)
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                         ! Keep the weight_is_0 array
         V0.create(n_pt); V1.create(n_pt,3)     ! local/non-local potential grids
         E0.create(n_pt)                        ! The energy density
         ab0.create(n_pt)              
         .becke_grid.make_bf_grids(a0,a1,b0,b1,ma,mb,pt,atoms)
         rho0.create(n_pt); rho1.create(n_pt,3) ! The density/nabla density grids
         .make_nabla_density_grid_r_B(rho1,rho0,pt,atoms, &
            a1,a0,b1,b0,ma,mb,.becke_grid.rho_cutoff) 
       ! .make_nabla_density_grid_r_C(rho1,rho0,pt,atoms, &
       !    a1,a0,b1,b0,ma,mb,.becke_grid.rho_cutoff) 
         V0 = ZERO                              ! re-use a0, b0 grids
         V1 = ZERO                              
         .add_r_XC_potentials(V0,rho0,V1,rho1)  ! Evaluation the XC potentials
         .set_r_XC_energy_density(E0,rho0,rho1)
         rho1.destroy; rho0.destroy
         V0 = wt*V0
         E0 = wt*E0
         forall (i=1:3) V1(:,i) = wt*V1(:,i)
         wt.destroy; pt.destroy
         ! Make the exchange correlation matrix
         do a = 1,na
         do b = 1,nb
            ab0 = a0(:,a)*b0(:,b)
            V_ab = sum(V0*ab0) &
                 + sum(V1(:,1)*(a1(:,a,1)*b0(:,b)+a0(:,a)*b1(:,b,1))) &
                 + sum(V1(:,2)*(a1(:,a,2)*b0(:,b)+a0(:,a)*b1(:,b,2))) &
                 + sum(V1(:,3)*(a1(:,a,3)*b0(:,b)+a0(:,a)*b1(:,b,3)))
            E_ab = sum(E0*ab0) 
            aa = fa + a
            bb = fb + b
            V(aa,bb) = V_ab                     
            E = E + fac*E_ab*.density_matrix.restricted(aa,bb)
         end
         end
         ab0.destroy; E0.destroy
         V1.destroy; V0.destroy
         if (same_atoms) then
            a1.destroy; a0.destroy
            nullify(b1); nullify(b0)
         else
            b1.destroy; b0.destroy
            a1.destroy; a0.destroy
         end
      end
      V.symmetric_reflect
      K = K + V
      E = E - HALF*.density_matrix.restricted.trace_product_with(V)
      V.destroy
   end

!   add_GGA_XC_matrix_new(K,E)
!   ! Add the exchange and correlation matrices to K. This routine supports
!   ! non-local functionals, either exchange or correlation.
!      K :: MAT{REAL}, target
!      E :: REAL
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")
!      pt0,pt,rho1,V1,a0,a1,a2,a3,b0,b1,b2,b3,V :: MAT{REAL}*
!      wt0,wt,rho0,V0,E0,ab0 :: VEC{REAL}*
!      xa,ya,za,aa,xb,yb,zb,bb,ex,ee :: VEC{REAL}*
!      atom_a,atom_b,a,sa,fsa,lsa,na,fa,la,b,sb,fsb,lsb,nb,fb,lb,n_pt0,n_pt,i,n :: INT
!      sha,shb :: SHELL1
!      same_atoms :: BIN
!      keep  :: VEC{BIN}*
!      atom1 :: VEC{INT}(1), target
!      atom2 :: VEC{INT}(2), target
!      atoms :: VEC{INT}*
!      V_ab,E_ab,fac,cutoff,ea,eb :: REAL
!      V.create(.n_bf,.n_bf)                              ! Use temporary V for parallelisation
!      cutoff = -log(.becke_grid.rho_cutoff)              ! Cutoff
!      E = ZERO
!      do atom_a = 1,.n_atom                              ! Loop over atom pairs   
!         fsa = .first_shell_for_atom(atom_a)
!         lsa = .last_shell_for_atom(atom_a)
!         do atom_b = 1,atom_a
!            if (NOT .is_overlapping_atom(atom_a,atom_b)) cycle 
!            fsb = .first_shell_for_atom(atom_b)          ! Only atom pairs which overlap
!            lsb = .last_shell_for_atom(atom_b)
!            if (atom_a==atom_b) then                     ! One or two atoms in grid?
!               atom1 = [atom_a]; atoms => atom1
!            else;
!               atom2 = [atom_a,atom_b]; atoms => atom2
!            end                                          ! Make unreduced grid and weights
!            .becke_grid.make_grid(pt0,wt0,atoms)
!            .atom(atom_a).make_displaced_points(xa,ya,za,aa,pt0,create=TRUE)
!            .atom(atom_b).make_displaced_points(xb,yb,zb,bb,pt0,create=TRUE)
!            n_pt0 = pt0.dim1                 
!    ! stdout.show("atom_a=",atom_a)
!    ! stdout.show("atom_b=",atom_b)
!    ! stdout.show("n_pt0 =",n_pt0)
!    ! stdout.text("pt0:"); stdout.put(pt0)
!    ! stdout.text("wt0:"); stdout.put(wt0)
!    ! stdout.text("aa:");  stdout.put(aa)
!    ! stdout.text("bb:");  stdout.put(bb)
!            ex.create(n_pt0)
!            keep.create(n_pt0)
!            do sa = fsa,lsa                              ! Loop over shell pairs
!               .get_shell(sha,sa,fa,la); fa = fa - 1
!               na = sha.n_comp
!               ea = minval(sha.ex)
!               do sb = fsb,min(sa,lsb)
!                  .get_shell(shb,sb,fb,lb); fb = fb - 1
!                  nb = shb.n_comp
!                  eb = minval(shb.ex)
!                  ex = ea*aa+eb*bb
!                  keep = ex<=cutoff
!                  n_pt = count(keep)                     ! # of significant points
!    ! stdout.show("sa=",sa)
!    ! stdout.show("sb=",sb)
!    ! stdout.show("cutoff=",cutoff)
!    ! stdout.show("n_pt  =",n_pt)
!    ! stdout.text("ex:"); stdout.put(ex)
!    ! stdout.text("kp:"); stdout.put(keep)
!                  if (n_pt>0) then                       ! <<< cycle if no sig.  points
!                     fac = TWO
!                     if (sa==sb) fac = ONE
!                     a0.create(n_pt,na)                     ! Make reduced "a" basis fn. grid
!                     a1.create(n_pt,na); a2.create(n_pt,na); a3.create(n_pt,na)
!                     sha.make_nabla_grid(a1,a2,a3,a0,xa,ya,za,aa,keep) 
!                     if (sa==sb) then
!                        b0 => a0
!                        b1 => a1; b2 => a2; b3=> a3
!                     else                                   ! Make "b" grid only if needed
!                        b0.create(n_pt,nb)
!                        b1.create(n_pt,nb); b2.create(n_pt,nb); b3.create(n_pt,nb)
!                        shb.make_nabla_grid(b1,b2,b3,b0,xb,yb,zb,bb,keep) 
!                     end
!       ! stdout.text("a0:"); stdout.put(a0)
!       ! stdout.text("a1:"); stdout.put(a1)
!       ! stdout.text("a2:"); stdout.put(a2)
!       ! stdout.text("a3:"); stdout.put(a3)
!       ! stdout.text("b0:"); stdout.put(b0)
!       ! stdout.text("b1:"); stdout.put(b1)
!       ! stdout.text("b2:"); stdout.put(b2)
!       ! stdout.text("b3:"); stdout.put(b3)
!                     V0.create(n_pt); V1.create(n_pt,3)     ! local/non-local potential grids
!                     E0.create(n_pt)                        ! The energy density
!                     ab0.create(n_pt)              
!                     wt.create(n_pt)
!                     rho0.create(n_pt); rho1.create(n_pt,3) ! The density/nabla density grids
!                     pt.create(n_pt,3); ee.create(n_pt)
!                     i = 0
!                     do n = 1,n_pt0                         ! Make reduced points and weights
!                        if (NOT keep(n)) cycle
!                        i = i + 1
!                        pt(i,1) = pt0(n,1)
!                        pt(i,2) = pt0(n,2)
!                        pt(i,3) = pt0(n,3)
!                        wt(i)   = wt0(n)
!                        ee(i)   = ex(n)
!                     end                                    ! <<< Make the density grid
!       ! stdout.text("pt:"); stdout.put(pt)
!       ! stdout.text("wt:"); stdout.put(wt)
!                     .make_nabla_density_grid_r_A(rho1,rho0,pt,atoms,ee)
!                     ee.destroy; pt.destroy
!                     V0 = ZERO                              ! Re-use a0, b0 grids?
!                     V1 = ZERO                              
!                     .add_r_XC_potentials(V0,rho0,V1,rho1)  ! Evaluation the XC potentials
!                     .set_r_XC_energy_density(E0,rho0,rho1)
!       ! stdout.text("rho0:"); stdout.put(rho0)
!       ! stdout.text("rho1:"); stdout.put(rho1)
!       ! stdout.text("E0:"); stdout.put(E0)
!       ! stdout.text("V0:"); stdout.put(V0)
!       ! stdout.text("V1:"); stdout.put(V1)
!                     rho1.destroy; rho0.destroy
!                     V0 = wt*V0
!                     E0 = wt*E0
!                     forall (i=1:3) V1(:,i) = wt*V1(:,i)
!                     wt.destroy
!                     do b = 1,nb
!                        lb = fb + b
!                        do a = 1,na                         ! <<< Make the XC matrix
!                           la = fa + a
!                           ab0 = a0(:,a)*b0(:,b)
!                           V_ab = sum(V0*ab0) &
!                                + sum(V1(:,1)*(a1(:,a)*b0(:,b)+a0(:,a)*b1(:,b))) &
!                                + sum(V1(:,2)*(a2(:,a)*b0(:,b)+a0(:,a)*b2(:,b))) &
!                                + sum(V1(:,3)*(a3(:,a)*b0(:,b)+a0(:,a)*b3(:,b)))
!                           E_ab = sum(E0*ab0) 
!                           V(la,lb) = V_ab                     
!                           E = E + fac*E_ab*.density_matrix.restricted(la,lb)
!                        end
!                     end
!       ! stdout.show("E =",E)
!                     ab0.destroy; E0.destroy
!                     V1.destroy; V0.destroy
!                     if (sa==sb) then
!                        nullify(b3); nullify(b2); nullify(b1); nullify(b0)
!                        a3.destroy; a2.destroy; a1.destroy; a0.destroy
!                     else
!                        b3.destroy; b2.destroy; b1.destroy; b0.destroy
!                        a3.destroy; a2.destroy; a1.destroy; a0.destroy
!                     end
!                  end
!                  shb.destroy_ptr_part
!               end
!               sha.destroy_ptr_part
!            end
!            keep.destroy; ex.destroy
!            .atom(atom_b).tidy_displaced_points(xb,yb,zb,bb)
!            .atom(atom_a).tidy_displaced_points(xa,ya,za,aa)
!            wt0.destroy; pt0.destroy
!         end
!      end
!      V.symmetric_reflect
!      K = K + V
!      E = E - HALF*.density_matrix.restricted.trace_product_with(V)
!      V.destroy
!   end

   add_r_XC_functionals(E,rho0,rho1)
   ! Return the *restricted* exchange correlation functional "E", for given
   ! densities "rho0" and gradient densities "rho1".
      E    :: VEC{REAL}, OUT
      rho0 :: VEC{REAL}, IN
      rho1 :: MAT{REAL}, IN, optional
   ENSURE(.scfdata.created,"no scfdata")
      exch,corr :: STR
      add :: DFT_FUNCTIONAL
      if (NOT .scfdata.is_DFT_calculation) return
      add.set_rho_cutoff(.becke_grid.rho_cutoff)
      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional
      if (exch/="none") add.r_functional(exch,E,rho0,rho1)
      if (corr/="none") add.r_functional(corr,E,rho0,rho1)
   end

   set_r_XC_energy_density(E,rho0,rho1)
   ! Set the *restricted* exchange correlation energy density "E", for given
   ! densities "rho0" and gradient densities "rho1".
      E    :: VEC{REAL}, OUT
      rho0 :: VEC{REAL}, IN
      rho1 :: MAT{REAL}, IN, optional
   ENSURE(.scfdata.created,"no scfdata")
      exch,corr :: STR
      add :: DFT_FUNCTIONAL
      if (NOT .scfdata.is_DFT_calculation) return
      add.set_rho_cutoff(.becke_grid.rho_cutoff)
      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional
      E = ZERO ! <<< set to zero
      if (exch/="none") add.r_energy_density(exch,E,rho0,rho1)
      if (corr/="none") add.r_energy_density(corr,E,rho0,rho1)
   end

   add_r_XC_potentials(V0,rho0,V1,rho1)
   ! For given densities "rho0" and gradient densities "rho1", return "V0" and
   ! "V1", the local and non_local terms necessary to calculate the matrix
   ! elements of the *restricted* exchange correlation potential. 
      V0   :: VEC{REAL}, OUT
      rho0 :: VEC{REAL}, IN
      V1   :: MAT{REAL}, OUT, optional
      rho1 :: MAT{REAL}, IN, optional
   ENSURE(.scfdata.created,"no scfdata")
      exch,corr :: STR
      add :: DFT_FUNCTIONAL
      if (NOT .scfdata.is_DFT_calculation) return
      add.set_rho_cutoff(.becke_grid.rho_cutoff)
      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional
      if (exch/="none") add.r_potential(exch,V0,rho0,V1,rho1)
      if (corr/="none") add.r_potential(corr,V0,rho0,V1,rho1)
   end

!*******************************************************************************
!  Unrestricted DFT
!*******************************************************************************

   add_XC_matrix(Ka,Kb)
   ! Calculate the exchange correlation matrix numerically.
      Ka,Kb :: MAT{REAL}
      E,Ea,Eb :: REAL
      if (.scfdata.using_GGA_functional) then; .add_GGA_XC_matrix(Ka,Kb,E,Ea,Eb)
      else;                                    .add_LDA_XC_matrix(Ka,Kb,E,Ea,Eb)
      end
      .scfdata.dft_energy_correction = E
      .scfdata.dft_alpha_energy_correction = Ea
      .scfdata.dft_beta_energy_correction = Eb
   end

   add_LDA_XC_matrix(Ka,Kb,E,Ea,Eb)
   ! Add the exchange and correlation matrices to K. This routine supports
   ! local functional only, either exchange or correlation.
      Ka,Kb :: MAT{REAL}, target
      E,Ea,Eb :: REAL
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")
      pt,a0,b0,Vb,Va,W :: MAT{REAL}*
      wt,rho0a,rho0b,V0a,V0b,E0,ab0 :: VEC{REAL}*
      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt,ma,mb :: INT
      atom_a,atom_b,i :: INT
      same_atoms :: BIN
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      Va_ab,Vb_ab,E_ab,Da_ab,Db_ab,fac :: REAL
      W.create(.n_bf,.n_bf)
      Va.create(.n_bf,.n_bf)                    ! Use temporary V for parallelisation
      Vb.create(.n_bf,.n_bf)
      nullify(a0); nullify(b0)
    ! E = ZERO
      Ea = ZERO
      Eb = ZERO
      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
         end                                                ! Make the grid points and weights
       ! .becke_grid.make_grid(pt,wt,atoms,compress=FALSE)
       ! .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=FALSE)
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                                     ! Keep the weight_is_0 array
         V0a.create(n_pt); V0b.create(n_pt)                 ! local potential grids
         E0.create(n_pt)                                    ! The energy density
         ab0.create(n_pt)             
         .becke_grid.make_bf_grids(a0,b0,ma,mb,pt,atoms)
         rho0a.create(n_pt)                                 ! The density grids
         rho0b.create(n_pt)
         .make_density_grid_u_B(rho0a,rho0b,pt,atoms,a0,b0) ! re-use a0, b0 grids
         V0a = ZERO; V0b = ZERO                    
         .add_u_XC_potentials(V0a,V0b,rho0a,rho0b)          ! Evaluation the XC potentials
         .set_u_XC_energy_density(E0,rho0a,rho0b)
         rho0b.destroy; rho0a.destroy
  ! stdout.show("q =",q)
  ! stdout.text("V0a:")
  ! stdout.put(V0a)
  ! stdout.text("V0b:")
  ! stdout.put(V0a)
  ! stdout.text("E:")
  ! stdout.put(E0)
         V0a = wt*V0a
         V0b = wt*V0b
         E0  = wt*E0
  ! stdout.text("V0a:")
  ! stdout.put(V0a)
  ! stdout.text("V0b:")
  ! stdout.put(V0a)
  ! stdout.text("E:")
  ! stdout.put(E0)
         wt.destroy; pt.destroy
         ! Make the exchange correlation matrix
         do a = 1,na
         do b = 1,nb
            ab0 = a0(:,a)*b0(:,b)
            Va_ab = sum(V0a*ab0) 
            Vb_ab = sum(V0b*ab0) 
            E_ab  = fac*sum(E0 *ab0)
            aa = fa + a
            bb = fb + b
            Va(aa,bb) = Va_ab                     
            Vb(aa,bb) = Vb_ab                     
          ! W(aa,bb)  = -HALF*(Va_ab+Vb_ab) + sum(E0*ab0)  ! Make the DFT energy correction matrix
          ! W(aa,bb)  = sum(E0*ab0)  ! Make the DFT energy correction matrix
            Da_ab = .density_matrix.alpha(aa,bb)
            Db_ab = .density_matrix.beta(aa,bb)
          ! E = E + fac*E_ab*(Da_ab+Db_ab)
            Ea = Ea + E_ab*Da_ab
            Eb = Eb + E_ab*Db_ab
  ! stdout.show("Va =",Va_ab)
  ! stdout.show("Vb =",Vb_ab)
  ! stdout.show("e  =",sum(E0*ab0))
         end
         end
  ! stdout.text("Va:")
  ! stdout.put(Va(fa+1:la,fb+1:lb))
  ! stdout.text("Vb:")
  ! stdout.put(Vb(fa+1:la,fb+1:lb))
  ! stdout.text("W:")
  ! stdout.put(W(fa+1:la,fb+1:lb))
         ab0.destroy; E0.destroy; V0b.destroy; V0a.destroy
         if (same_atoms) then
            a0.destroy
            nullify(b0)
         else
            b0.destroy
            a0.destroy
         end
      end
      Va.symmetric_reflect
      Vb.symmetric_reflect
      Ka = Ka + Va
      Kb = Kb + Vb
      Ea = Ea - HALF*.density_matrix.alpha.trace_of_product_with(Va)
      Eb = Eb - HALF* .density_matrix.beta.trace_of_product_with(Vb)
      E  = Ea + Eb
      Vb.destroy; Va.destroy
      W.destroy
   end

   add_GGA_XC_matrix(Ka,Kb,E,Ea,Eb)
   ! Add the exchange and correlation matrices to K. This routine supports
   ! local functional only, either exchange or correlation.
      Ka,Kb :: MAT{REAL}, target
      E,Ea,Eb :: REAL
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.becke_grid.created, "need to specify becke_grid for DFT integrations")
      a1,b1 :: MAT3{REAL}*
      pt,rho1a,rho1b,a0,b0,V1a,V1b,Vb,Va,W :: MAT{REAL}*
      wt,rho0a,rho0b,V0a,V0b,E0,ab0 :: VEC{REAL}*
      q,a,b,aa,bb,fa,la,na,fb,lb,nb,n_pt, ma,mb :: INT
      atom_a,atom_b,i :: INT
      same_atoms :: BIN
      atom1 :: VEC{INT}(1), target
      atom2 :: VEC{INT}(2), target
      atoms :: VEC{INT}*
      Va_ab,Vb_ab,E_ab,Da_ab,Db_ab,fac :: REAL
      W.create(.n_bf,.n_bf)
      Va.create(.n_bf,.n_bf)                    ! Use temporary V for parallelisation
      Vb.create(.n_bf,.n_bf)
      nullify(a0); nullify(b0)
    ! E = ZERO
      Ea = ZERO
      Eb = ZERO
      do q = 1,.no_of_atom_pairs
         if (NOT .overlapping_atoms(q)) cycle
         .get_atom_pair_indices(q,atom_a,atom_b,fa,la,na,fb,lb,nb)
         same_atoms = atom_a==atom_b
         if (same_atoms) then; atom1 = [atom_a];        atoms => atom1; fac = ONE
         else;                 atom2 = [atom_a,atom_b]; atoms => atom2; fac = TWO
         end                                                ! Make the grid points and weights
         .becke_grid.make_grid(pt,wt,atoms,compress=TRUE,weight_is_0=TRUE)
         n_pt = pt.dim1                                     ! Keep the weight_is_0 array
         V0a.create(n_pt); V0b.create(n_pt)                 ! local potential grids
         V1a.create(n_pt,3); V1b.create(n_pt,3)             ! non-local potential grids
         E0.create(n_pt)                                    ! The energy density
         ab0.create(n_pt)             
         .becke_grid.make_bf_grids(a0,a1,b0,b1,ma,mb,pt,atoms)
         rho0a.create(n_pt); rho0b.create(n_pt)             ! The density grids
         rho1a.create(n_pt,3); rho1b.create(n_pt,3)
       ! .make_nabla_density_grid_u_B(rho1a,rho1b,rho0a,rho0b,pt,atoms, &
       !     a1,a0,b1,b0,ma,mb,.becke_grid.rho_cutoff) ! re-use a0, b0 grids
         .make_nabla_density_grid_u_A(rho1a,rho1b,rho0a,rho0b,pt,atoms, &
             a1,a0,b1,b0,.becke_grid.rho_cutoff) ! re-use a0, b0 grids
         V0a = ZERO; V0b = ZERO                    
         V1a = ZERO; V1b = ZERO                    
         .add_u_XC_potentials(V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b) ! Evaluation the XC potentials
         .set_u_XC_energy_density(E0,rho0a,rho0b,rho1a,rho1b)
  ! stdout.show("q =",q)
  ! stdout.text("pt:")
  ! stdout.put(pt)
  ! stdout.text("wt:")
  ! stdout.put(wt)
  ! stdout.text("rho0a:")
  ! stdout.put(rho0a)
  ! stdout.text("rho1a:")
  ! stdout.put(rho1a)
  ! stdout.text("V0a:")
  ! stdout.put(V0a)
  ! stdout.text("V0b:")
  ! stdout.put(V0a)
  ! stdout.text("V1a:")
  ! stdout.put(V1a)
  ! stdout.text("V1b:")
  ! stdout.put(V1a)
  ! stdout.text("E:")
  ! stdout.put(E0)
         rho1b.destroy; rho1a.destroy
         rho0b.destroy; rho0a.destroy
         V0a = wt*V0a
         V0b = wt*V0b
         E0  = wt*E0
         forall (i=1:3) 
            V1a(:,i) = wt*V1a(:,i)
            V1b(:,i) = wt*V1b(:,i)
         end
  ! stdout.text("V0a:")
  ! stdout.put(V0a)
  ! stdout.text("V0b:")
  ! stdout.put(V0a)
  ! stdout.text("V1a:")
  ! stdout.put(V1a)
  ! stdout.text("V1b:")
  ! stdout.put(V1a)
  ! stdout.text("E:")
  ! stdout.put(E0)
         wt.destroy; pt.destroy
         ! Make the exchange correlation matrix
         do a = 1,na
         do b = 1,nb
            ab0 = a0(:,a)*b0(:,b)
            Va_ab = sum(V0a*ab0) 
            Vb_ab = sum(V0b*ab0) 
            E_ab  = fac*sum(E0 *ab0)  ! Make the DFT energy correction matrix
            do i = 1,3
               ab0 = a1(:,a,i)*b0(:,b) + a0(:,a)*b1(:,b,i)
               Va_ab = Va_ab + sum(V1a(:,i)*ab0)
               Vb_ab = Vb_ab + sum(V1b(:,i)*ab0)
            end
            aa = fa + a
            bb = fb + b
            Va(aa,bb) = Va_ab                     
            Vb(aa,bb) = Vb_ab                     
            Da_ab = .density_matrix.alpha(aa,bb)
            Db_ab = .density_matrix.beta(aa,bb)
          ! E = E + fac*E_ab*(Da_ab+Db_ab)
            Ea = Ea + E_ab*Da_ab
            Eb = Eb + E_ab*Db_ab
  ! stdout.show("Va =",Va_ab)
  ! stdout.show("Vb =",Vb_ab)
  ! stdout.show("E  =",E)
  ! stdout.show("E   =",E)
  ! stdout.show("E_ab=",E_ab)
         end
         end
  ! stdout.text("Va:")
  ! stdout.put(Va(fa+1:la,fb+1:lb))
  ! stdout.text("Vb:")
  ! stdout.put(Vb(fa+1:la,fb+1:lb))
  ! stdout.text("W:")
  ! stdout.put(W(fa+1:la,fb+1:lb))
         ab0.destroy; E0.destroy
         V1b.destroy; V1a.destroy
         V0b.destroy; V0a.destroy
         if (same_atoms) then
            a1.destroy; a0.destroy
            nullify(b1); nullify(b0)
         else
            b1.destroy; b0.destroy
            a1.destroy; a0.destroy
         end
      end
      Va.symmetric_reflect
      Vb.symmetric_reflect
      Ka = Ka + Va
      Kb = Kb + Vb
      Ea = Ea - HALF*.density_matrix.alpha.trace_of_product_with(Va) 
      Eb = Eb - HALF* .density_matrix.beta.trace_of_product_with(Vb) 
      E  = Ea + Eb
    ! E = E - HALF*.density_matrix.alpha.trace_of_product_with(Va) &
    !       - HALF* .density_matrix.beta.trace_of_product_with(Vb)
      Vb.destroy; Va.destroy
      W.destroy
   end

   add_u_XC_functionals(E,rho0a,rho0b,rho1a,rho1b)
   ! Return the *unrestricted* exchange correlation functional "E", for given
   ! alpha and beta densities "rho0a", "rho0b" and for the alpha and beta
   ! gradient densities "rho1a", "rho1b".
      E :: VEC{REAL}, OUT
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN, optional
   ENSURE(.scfdata.created,"no scfdata")
      exch,corr :: STR
      add :: DFT_FUNCTIONAL
      if (NOT .scfdata.is_DFT_calculation) return
      add.set_rho_cutoff(.becke_grid.rho_cutoff)
      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional
      if (exch/="none") add.u_functional(exch,E,rho0a,rho0b,rho1a,rho1b)
      if (corr/="none") add.u_functional(corr,E,rho0a,rho0b,rho1a,rho1b)
   end

   set_u_XC_energy_density(E,rho0a,rho0b,rho1a,rho1b)
   ! Return the *unrestricted* exchange correlation energy density "E", for
   ! given alpha and beta densities "rho0a", "rho0b" and for the alpha and beta
   ! gradient densities "rho1a", "rho1b".
      E :: VEC{REAL}, OUT
      rho0a,rho0b :: VEC{REAL}, IN
      rho1a,rho1b :: MAT{REAL}, IN, optional
   ENSURE(.scfdata.created,"no scfdata")
      exch,corr :: STR
      add :: DFT_FUNCTIONAL
      if (NOT .scfdata.is_DFT_calculation) return
      add.set_rho_cutoff(.becke_grid.rho_cutoff)
      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional
      E = ZERO ! <<< set to zero
      if (exch/="none") add.u_energy_density(exch,E,rho0a,rho0b,rho1a,rho1b)
      if (corr/="none") add.u_energy_density(corr,E,rho0a,rho0b,rho1a,rho1b)
   end

   add_u_XC_potentials(V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
   ! For given alpha and beta densities "rho0a", "rho0b" and gradient densities
   ! "rho1a", "rho1b" return the alpha and beta local potentials, "V0a" and
   ! "V0b", and the non local potentails "V1a", "V1b" needed to calculate the
   ! matrix elements of the *unrestricted* exchange correlation potentials. 
      V0a,V0b     :: VEC{REAL}, OUT
      rho0a,rho0b :: VEC{REAL}, IN
      V1a,V1b     :: MAT{REAL}, OUT, optional
      rho1a,rho1b :: MAT{REAL}, IN, optional
   ENSURE(.scfdata.created,"no scfdata")
      exch,corr :: STR
      add :: DFT_FUNCTIONAL
      if (NOT .scfdata.is_DFT_calculation) return
      add.set_rho_cutoff(.becke_grid.rho_cutoff)
      exch = .scfdata.dft_exchange_functional
      corr = .scfdata.dft_correlation_functional
      if (exch/="none") add.u_potential(exch,V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
      if (corr/="none") add.u_potential(corr,V0a,V0b,rho0a,rho0b,V1a,V1b,rho1a,rho1b)
   end

! Numerical J matrix -- calculated two ways

   make_numerical_J_matrix_v1(J)
   ! Evaluate the coulomb matrix "J" using numerical evaluation of the potential
   ! on a DFT integration grid.
     J :: MAT{REAL}, target
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.dftgrid.created, "need to specify dftgrid")
     pt :: MAT{REAL}*
     wt,p :: VEC{REAL}*
     n_pt :: INT
     n_pt = .dftgrid.n_pts*.n_atom
     p.create(n_pt)
     pt.create(n_pt,3)
     wt.create(n_pt)
     .dftgrid.make_grid(pt,wt,.atom)
     .make_density_grid(p,pt)
     p = wt*p ! Now we have the effective charges
     wt.destroy
     .make_nuclear_matrix(J,charges=p,points=pt)
     pt.destroy
     p.destroy
   end

   make_numerical_J_matrix_v2(J)
   ! Evaluate the coulomb matrix "J" using numerical evaluation of the potential
   ! on a DFT integration grid.
     J :: MAT{REAL}, target
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.dftgrid.created, "need to specify dftgrid")
     JJ,pt :: MAT{REAL}*
     wt,q :: VEC{REAL}*
     n_pt, p,fa,la,fb,lb,atom_a,atom_b :: INT
     sh :: SHELL2
     atom :: VEC{ATOM}*
     n_pt = .dftgrid.n_pts*.n_atom
     q.create(n_pt)
     pt.create(n_pt,3)
     wt.create(n_pt)
     .dftgrid.make_grid(pt,wt,.atom)
     .make_density_grid(q,pt)
     q = wt*q ! Now we have the effective charges
     wt.destroy
     J = ZERO
     do p = 1,.n_shell_pairs
        .get_precomputed_shell_pair(sh,p,fa,la,fb,lb,atom_a,atom_b)
        if (atom_a==atom_b) then
           atom.create(1)
           atom(1) = .atom(atom_a)
        else
           atom.create(2)
           atom(1) = .atom(atom_a)
           atom(2) = .atom(atom_b)
        end
        JJ.create(sh.a.n_comp,sh.b.n_comp)
        .dftgrid.make_potential_MEs_of(MOLECULE::electric_potential,q,pt,sh,atom,JJ)
        atom.nullify_ptr_part; atom.destroy
        J(fa:la,fb:lb) = J(fa:la,fb:lb) - JJ
        JJ.destroy
        sh.destroy_ptr_part
     end
     J.symmetric_reflect
     pt.destroy
     q.destroy
   end

!  **********************
!  Two electron integrals
!  **********************

   get_ERI_integrals
   ! Get the electron repulsion integrals on disk. If the integral
   ! file is already there, do nothing.
     eri_archive,ind_archive :: ARCHIVE
     eri_archive.set(.name,"eri_integrals")
     ind_archive.set(.name,"eri_index")
     if ((NOT eri_archive.exists) OR (NOT ind_archive.exists)) then
        eri_archive.open(for="write-only",buffered=TRUE,type="real")
        ind_archive.open(for="write-only",buffered=TRUE,type="int")
        .make_eri_integrals(eri_archive,ind_archive)
        ind_archive.close
        eri_archive.close
     end
   end

   make_eri_integrals(eri_archive,eri_index)
   ! Calculate the electron repulsion integrals (ERI's) over all basis functions
   ! Outputs to archive "eri_archive".  Note that index coincidence factors are
   ! included.
   ! NOTE: Replace SHELL4 in here with SHELL1QUARTET
     eri_archive,eri_index :: ARCHIVE
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     sh4 :: SHELL4
     ERI :: MAT4{REAL}*
     q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d :: INT
     factor :: REAL
     skipped = 0
     if (.scfdata.output) then
       stdout.set_real_style("e")
       stdout.show("Skipping electron repulsion integrals less than ",.scfdata.eri_limit)
       stdout.set_real_style("f")
     end
     if (.scfdata.using_NDDO) then
        do q = 1, .n_shell_quartets
          .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
          if (atom_a==atom_b AND atom_c==atom_d) then
            .copy_shell_quartet(sh4,q,a,b,c,d)
          else
            skipped = skipped + 1
            cycle
          end
          if (sh4.skip_ERI) then
            skipped = skipped + 1
            sh4.destroy_ptr_part
            cycle
          end
          ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
          sh4.get_ERI(ERI)
          factor = ONE
          if (a==b) factor = HALF                    ! Coincidence factors
          if (c==d) factor = HALF * factor
          if (a==c AND b==d) factor = HALF * factor
          ERI = factor * ERI
          eri_archive.file.write(ERI)
          eri_index.file.write(q)
          ERI.destroy
          sh4.destroy_ptr_part
        end
     else if (.scfdata.using_NUDO) then
        do q = 1, .n_shell_quartets
          .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
          if (.atom.bonded(atom_a,atom_b) AND .atom.bonded(atom_c,atom_d)) then
            .copy_shell_quartet(sh4,q,a,b,c,d)
          else
            skipped = skipped + 1
            cycle
          end
          if (sh4.skip_ERI) then
            skipped = skipped + 1
            sh4.destroy_ptr_part
            cycle
          end
          ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
          sh4.get_ERI(ERI)
          factor = ONE
          if (a==b) factor = HALF                    ! Coincidence factors
          if (c==d) factor = HALF * factor
          if (a==c AND b==d) factor = HALF * factor
          ERI = factor * ERI
          eri_archive.file.write(ERI)
          eri_index.file.write(q)
          ERI.destroy
          sh4.destroy_ptr_part
        end
     else
        do q = 1, .n_shell_quartets
          .copy_shell_quartet(sh4,q,a,b,c,d)
          if (sh4.skip_ERI(.scfdata.eri_limit)) then
            skipped = skipped + 1
            sh4.destroy_ptr_part
            cycle
          end
          ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
          sh4.get_ERI(ERI)
          factor=ONE
          if (a==b) factor = HALF                    ! Coincidence factors
          if (c==d) factor = HALF * factor
          if (a==c AND b==d) factor = HALF * factor
          ERI = factor * ERI
          eri_archive.file.write(ERI)
          eri_index.file.write(q)
          ERI.destroy
          sh4.destroy_ptr_part
        end
     end
     if (.scfdata.output) then
       a = .n_shell_quartets
       stdout.text("Skipped "//skipped.to_str.trim//" out of "//a.to_str.trim//" blocks.")
     end
     eri_index.file.write(.n_shell_quartets + 1 )
   end

   get_spin_orbit_integrals
   ! Get the spin orbit integrals on disk. If the integral files are
   ! file is already there, do nothing.
     SOx_archive,SOy_archive,SOz_archive,ind_archive :: ARCHIVE
     SOx_archive.set(.name,"SOx_integrals")
     SOy_archive.set(.name,"SOy_integrals")
     SOz_archive.set(.name,"SOz_integrals")
     ind_archive.set(.name,"SO_indices")
     if (NOT SOx_archive.exists) then
        SOx_archive.open(for="write-only",buffered=TRUE,type="real")
        SOy_archive.open(for="write-only",buffered=TRUE,type="real")
        SOz_archive.open(for="write-only",buffered=TRUE,type="real")
        ind_archive.open(for="write-only",buffered=TRUE,type="int")
        .make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
        SOx_archive.close
        SOy_archive.close
        SOz_archive.close
        ind_archive.close
     end
   end

   make_spin_orbit_integrals(SOx_archive,SOy_archive,SOz_archive,ind_archive)
   ! Calculate the spin orbit integrals. Outputs the spin same-orbit integrals
   ! to for each component i to "SOi_archive". The shell quartet index for
   ! these integrals are put in "ind_archive". Note that index coincidence
   ! factors are included.
     SOx_archive,SOy_archive,SOz_archive,ind_archive :: ARCHIVE
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
     sh4 :: SHELL4
     Sx,Sy,Sz,Ox,Oy,Oz :: MAT4{REAL}*
     q,a,b,c,d,skipped,atom_a,atom_b,atom_c,atom_d,na,nb,nc,nd :: INT
     factor :: REAL
     cutoff :: STR
     cutoff.from_real(SHELL4_ERI_CUTOFF)
     skipped = 0
     if (.scfdata.output) then
       stdout.text("Skipping electron repulsion integrals less than " // trim(cutoff) // ".")
     end
     do q = 1, .n_shell_quartets
       if (.scfdata.using_NDDO) then
         .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (atom_a==atom_b AND atom_c==atom_d) then
           .copy_shell_quartet(sh4,q,a,b,c,d)
         else
           skipped = skipped + 1
           cycle
         end
       else if (.scfdata.using_NUDO) then
         .get_shell_quartet_indexes(q,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
         if (.atom.bonded(atom_a,atom_b) AND .atom.bonded(atom_c,atom_d)) then
           .copy_shell_quartet(sh4,q,a,b,c,d)
         else
           skipped = skipped + 1
           cycle
         end
       else
         .copy_shell_quartet(sh4,q,a,b,c,d)
       end
       if (sh4.skip_ERI) then
         skipped = skipped + 1
         sh4.destroy_ptr_part
         cycle
       end
       na = sh4.a.n_comp; nb = sh4.b.n_comp
       nc = sh4.c.n_comp; nd = sh4.d.n_comp
       Sx.create(na,nb,nc,nd); Sy.create(na,nb,nc,nd); Sz.create(na,nb,nc,nd)
       Ox.create(na,nb,nc,nd); Oy.create(na,nb,nc,nd); Oz.create(na,nb,nc,nd)
       sh4.make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
       factor = ONE
       if (a==b) factor = HALF                    ! Coincidence factors
       if (c==d) factor = HALF * factor
       if (a==c AND b==d) factor = HALF * factor
       Sx = factor*Sx; Sy = factor*Sy; Sz = factor*Sz
       Ox = factor*Ox; Oy = factor*Oy; Oz = factor*Oz
       SOx_archive.file.write(Sx); SOx_archive.file.write(Ox)
       SOy_archive.file.write(Sy); SOy_archive.file.write(Oy)
       SOz_archive.file.write(Sz); SOz_archive.file.write(Oz)
       ind_archive.file.write(q)
       Oz.destroy; Oy.destroy; Ox.destroy
       Sz.destroy; Sy.destroy; Sx.destroy
       sh4.destroy_ptr_part
     end
     if (.scfdata.output) then
       a = .n_shell_quartets
       stdout.text("Skipped "//skipped.to_str.trim//" out of "//a.to_str.trim//" blocks.")
     end
     ind_archive.file.write(.n_shell_quartets + 1 )
   end

!   make_r_PIE_JK_direct(J,K,P)
!   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from a
!   ! symmetric density matrix "P" directly, using the projective integral
!   ! expansions (PIE) method. See Mayer, CPL 332, p. 381-388 (2000), eqn (12).
!   ! (c) Dylan Jayatilaka, Budapest September 2002.
!     J,K,P :: MAT{REAL}
!     S,SS,S_nxn,S_inv,ERI,JJ,KK :: MAT{REAL}*
!     XBXD :: MAT4{REAL}*
!     D,Q :: VEC{MAT_{REAL}}*
!     DD  :: MAT{MAT_{REAL}}*
!     sh4 :: SHELL4
!     a,b,c,d,sa,sb,sc,sd,n,n1,n2,i,j :: INT
!     at_b,at_d,atom_a,atom_b,atom_c,atom_d :: INT
!     fa,la,fb,lb,fc,lc,fd,ld,fsa,lsa,fsc,lsc,ffa,lfa,ffc,lfc :: INT
!     diatom,n_diatom,fs_diatom,ls_diatom,ff_diatom,lf_diatom :: VEC{INT}(2)
!     S.create(.n_bf,.n_bf)
!     .get_overlap_matrix(S)
!     D1.create(2)
!     D2.create(2,2)
!     nullify(S_inv); nullify(S_nxn); nullify(SS)
!     atom_b = 0; atom_d = 0
!     J = ZERO
!     K = ZERO
!     do sb = 1,.n_shell
!     do sd = 1,.n_shell
!        if (sb==sd) cycle ! diagonal case below ?
!        fb  = .first_basis_fn_for_shell(sb); lb = .last_basis_fn_for_shell(sb)
!        fd  = .first_basis_fn_for_shell(sd); ld = .last_basis_fn_for_shell(sd)
!        at_b = .atom_for_shell(sb)
!        at_d = .atom_for_shell(sd)
!        ! Make the projectors Q(*), only if needed
!        if (at_b/=atom_b OR at_d/=atom_d) then
!           atom_b = at_b; n1 = .atom(atom_b).n_bf
!           atom_d = at_d; n2 = .atom(atom_d).n_bf
!           diatom = [atom_b,atom_d]
!           n_diatom = [n1,n2]
!           n = n1 + n2
!           DD.destroy_ptr_part; D.destroy_ptr_part; Q.destroy_ptr_part
!           Q(1).element.create(.n_bf,n1); Q(2).element.create(.n_bf,n2)
!           S_inv.create(n,n)
!           S_nxn.create(n,n)
!           .AO_subspace_set(S_nxn,S,diatom,diatom)
!           S_inv.to_inverse_of(S_nxn)
!           S_nxn.destroy
!           SS.create(.n_bf,n)
!           .AO_subspace_set(SS,S,col_atom=diatom)
!           Q(1).element = matmul(SS,S_inv(:,   1:n1))
!           Q(2).element = matmul(SS,S_inv(:,n2+1:  ))
!           SS.destroy
!           S_inv.destroy
!           do i = 1,2
!              D(i).element.create(.n_bf,n_diatom(i))
!              D(i).element = matmul(P,Q(i).element)
!           end
!           do i = 1,2
!           do j = 1,2
!              DD(i,j).element.create(n_diatom(i),n_diatom(j))
!              DD(i,j).element = matmul(transpose(Q(i).element),D(j).element)
!           end
!           end
!           do i = 1,2
!              fs_diatom(i) = .first_shell_for_atom(diatom(i))
!              ls_diatom(i) =  .last_shell_for_atom(diatom(i))
!              ff_diatom(i) = .first_basis_fn_for_atom(diatom(i))
!              lf_diatom(i) =  .last_basis_fn_for_atom(diatom(i))
!           end
!        end
!        ! Loop over diatom subspaces on centers A & C
!        do atom_a = 1,2
!        do atom_c = 1,2
!           fsa = fs_diatom(atom_a); lsa = ls_diatom(atom_a)
!           fsc = fs_diatom(atom_c); lsc = ls_diatom(atom_c)
!           ffa = ff_diatom(atom_a); lfa = lf_diatom(atom_a)
!           ffc = ff_diatom(atom_c); lfc = lf_diatom(atom_c)
!           JJ.create(ffa:lfa,fb:lb);   JJ = ZERO
!           KK.create(ffa:lfa,ffc:lfc); KK = ZERO
!           do sa = fsa,lsa
!           do sc = fsc,lsc
!              .copy_shell_quartet(sh4,sa,sb,sc,sd) ! B B B D
!              XBXD.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
!              sh4.get_ERI(XBXD)
!              sh4.destroy_ptr_part
!              fa = .first_basis_fn_for_shell(sa); la = .last_basis_fn_for_shell(sa)
!              fc = .first_basis_fn_for_shell(sc); lc = .last_basis_fn_for_shell(sc)
!              JJ = ZERO
!              do a = fa,la
!              do b = fb,lb
!                 ERI => XBXD(a,b,:,:)
!                 JJ(a,b) = JJ(a,b) + ERI.trace_product_with(D1(atom_c).element(fd:ld,ffc:lfc))
!              end
!              end
!              J = J + matmul(Q(atom_a).element,JJ)
!              KK = ZERO
!              do a = fa,la
!              do c = fc,lc
!                 ERI => XBXD(a,:,c,:)
!                 KK(a,c) = KK(a,c) + ERI.trace_product_with(P(fd:ld,fb:lb))
!              end
!              end
!              K = K + matmul(Q(atom_a).element,matmul(KK,transpose(Q(atom_c).element)))
!              do b = fb,lb
!              do d = fd,ld
!                 ERI => XBXD(:,b,:,d)
!                 K(b,d) = K(b,d) + &
!                    ERI.trace_product_with(DD(atom_c,atom_a).element(ffc:lfc,ffa:lfa))
!              end
!              end
!              XBXD.destroy
!           end
!           end
!           KK.destroy
!           JJ.destroy
!        end
!        end
!     end
!     end
!     D2.destroy; D1.destroy
!     S.destroy
!     J.symmetrize
!     K = HALF*K
!   end

!   make_2_center_diatom_ERI_array(v,shell_b,shell_d)
!   ! Calculate the 4 dimensional diatom electron repulsion integral array "v".
!   ! v(a,b,c,d) = [ab|cd] is a restricted set of the two electron integrals,
!   ! with "b" and "d" being the indices of basis functions belonging to shells
!   ! "shell_b" and "shell_d" respectively, while "a" and "c" the indices of
!   ! basis functions belonging to *all* shells on either atom B or D, which are
!   ! the atoms on which shells "shell_b" and "shell_d" are found.
!     v :: MAT4{REAL}
!     shell_b,shell_d :: INT
!     a,aa,c,cc,fa,la,fb,lb,fc,lc,fd,ld :: INT
!     sh :: SHELL2
!     shell_atom :: VEC{INT}(2)
!     sh4 :: SHELL4
!     ERI :: MAT4{REAL}*
!   ENSURE(.bases_are_all_resolved, "no basis set")
!   ENSURE(v.dim2==.atom(.atom_for_shell(shell_b)).n_bf,"wrong dim 3 for v")
!   ENSURE(v.dim4==.atom(.atom_for_shell(shell_d)).n_bf,"wrong dim 4 for v")
!     sb = shell_b; b = .atom_for_shell(sb)
!     sd = shell_d; d = .atom_for_shell(sd)
!     shell_atom(1:2) = [b,d]
!     fb = .first_shell_for_atom(b)
!     lb =  .last_shell_for_atom(b)
!     fd = .first_shell_for_atom(d)
!     ld =  .last_shell_for_atom(d)
!     v = ZERO
!     do aa = 1,2
!        a = shell_atom(aa)
!        fa = .first_shell_for_atom(a)
!        la =  .last_shell_for_atom(a)
!        do sa = fa,la
!           do cc = 1,2
!              c = shell_atom(cc)
!              fc = .first_shell_for_atom(c)
!              lc =  .last_shell_for_atom(c)
!              do sc = fb,lb
!                 .copy_shell_quartet(sh4,sa,sb,sc,sd)
!                 if (sh4.skip_ERI(.scfdata.eri_limit)) then
!                    sh4.destroy_ptr_part
!                    cycle
!                 end
!                 ERI.create(sh4.a.n_comp,sh4.b.n_comp,sh4.c.n_comp,sh4.d.n_comp)
!                 sh4.get_ERI(ERI)
!                 v(fa:la,fb:lb,fc:lc,fd:ld) = ERI
!              end
!           end
!        end
!     end
!   end

!  *******************
!  Pairwise SCF energy
!  *******************

   put_scf_energy_in_mo_pairs
   ! Analyse the SCF energy into MO pairs
      Di :: OPMATRIX*
      core_energy :: VEC{REAL}*
      pair_energy :: MAT{REAL}*
      i,j :: INT
      energy :: REAL
      direct :: BIN
      core_energy.create(.n_a)
      pair_energy.create(.n_a,.n_a)
      core_energy = ZERO
      pair_energy = ZERO
      Di.create(.n_bf)
      direct = .scfdata.using_direct_scf
      .scfdata.using_direct_scf = TRUE
      do i = 1,.n_a
         .make_scf_density_matrix(i)
         Di.set_to(.density_matrix)
         .make_fock_matrix(.density_matrix,.fock_matrix,core=TRUE,r12=FALSE)
         core_energy(i) = .scf_electronic_energy(Di,core=TRUE)
         do j = 1,i
            .make_scf_density_matrix(j)
            .make_fock_matrix(.density_matrix,.fock_matrix,core=FALSE,r12=TRUE)
            if (i==j) then ! fac = ONE
              pair_energy(i,j) = .scf_electronic_energy(Di,core=FALSE)
            else           ! fac = TWO
              pair_energy(i,j) = TWO*.scf_electronic_energy(Di,core=FALSE)
            end
         end
      end
      Di.destroy
      .scfdata.using_direct_scf = direct
      stdout.flush
      stdout.text("SCF MO pair energy decomposition:",flush=1)
      energy = sum(core_energy)+sum(transfer(pair_energy,(/ONE/)))+.nuclear_energy
      stdout.show("SCF energy =",energy)
      stdout.text("Core energies:",flush=1)
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("Core energy")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      do i = 1,.n_a
         stdout.put(i)
         stdout.put(core_energy(i),flush=1)
      end
      stdout.dash(int_fields=1,real_fields=1)
      stdout.flush
      stdout.text("Orbital pair energies:",flush=1)
      stdout.dash(int_fields=2,real_fields=1)
      stdout.put("MO_i",int_width=TRUE)
      stdout.put("MO_j",int_width=TRUE)
      stdout.put("Pair energy",flush=1)
      stdout.dash(int_fields=2,real_fields=1)
      do i = 1,.n_a
      do j = 1,i
         stdout.put(i)
         stdout.put(j)
         stdout.put(pair_energy(i,j),flush=1)
      end
      end
      stdout.dash(int_fields=2,real_fields=1)
      stdout.flush
   end

!  ************************
!  SCF Energy decomposition
!  ************************

   put_AO_energy_partition
   ! Put out the AO energy partition
      Y :: MAT{REAL}*
      Y.create(.n_bf,.n_bf)
      Y.to_unit_matrix
      .put_energy_partition(Y)
      Y.destroy
   end

   put_SAO_energy_partition
   ! Put out the symmetric AO energy partition
      S,Smh :: MAT{REAL}*
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      Smh.create(.n_bf,.n_bf); Smh.to_inverse_sqrt_of(S)
      .put_energy_partition(Smh)
      Smh.destroy
      S.destroy
   end

   put_MO_energy_partition
   ! Put out the MO energy partition. NOTE: the MO's must be ordered
   ! contiguously, first group 1 then group 2 MO's, AND the atoms in each group
   ! must be contiguous in the .atom list, first group 1 then group 2. This is
   ! because the atom_group_AO_subspace_set routine is used, and by abuse of its
   ! function with the above cobstraints, it will do the right thing and copy
   ! quadrants.
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
      .put_energy_partition(.molecular_orbitals.restricted)
   end

   put_energy_partition(Y)
   ! Put out the energy decomposition specified in the .atom_group array.
   ! The inverse of matrix "Y" is used to back transform the density matrix
   ! (which is taken from disk). The back transformed density matrix is then
   ! partitioned, and transformed back in order to evaluate the interaction
   ! energies between the partitioned systems.
      Y :: MAT{REAL}
   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(size(.atom_group)==2,"must have only 2 groups")
   ENSURE(Y.dim1==.n_bf,"incorrect size for Y array")
      X, T,Z,ZZ,C,K,P,PP,W,E_T,E_Z, EE :: MAT{REAL}*
      E_ZZ :: MAT3{REAL}*
      E_C,E_K :: MAT4{REAL}*
      n_group,g,h,i,j :: INT
      fac :: REAL
      unit :: STR
      arch :: ARCHIVE
      kinetic_energy,nuclear_attraction,nuclear_repulsion :: REAL
      coulomb_repulsion,net_coulomb,bicentric_exchange :: REAL
      exchange_attraction,total_interaction :: REAL
      arch.set(.name,"density_matrix,restricted")
   ENSURE(arch.exists,"no density matrix saved on disk")
      P.create(.n_bf,.n_bf)
      PP.create(.n_bf,.n_bf)
      arch.read(P)
      W.create(.n_bf,.n_bf)
      T.create(.n_bf,.n_bf); .get_kinetic_matrix(T)
      Z.create(.n_bf,.n_bf); .get_nuclear_matrix(Z)
      X.create(.n_bf,.n_bf); X.to_inverse_of(Y)
      n_group = size(.atom_group)
      E_T.create(n_group,n_group); E_T = ZERO
      E_Z.create(n_group,n_group); E_Z = ZERO
      E_C.create(n_group,n_group,n_group,n_group); E_C = ZERO
      E_K.create(n_group,n_group,n_group,n_group); E_K = ZERO
      E_ZZ.create(n_group,n_group,n_group); E_ZZ = ZERO
      ZZ.create(.n_bf,.n_bf)
      PP = P
      PP.back_transform_using(X)
      X.destroy
         do i = 1,n_group
         do j = 1,i
            W = ZERO
            .atom_group_AO_subspace_set(W,PP,i,j)
            if (i/=j) &
            .atom_group_AO_subspace_set(W,PP,j,i)
            W.back_transform_using(Y)
            E_T(i,j) = T.trace_product_with(W)
            E_Z(i,j) = Z.trace_product_with(W)
            do g = 1,n_group
               .make_nuclear_matrix(ZZ,.atom_group(g).element)
               E_ZZ(i,j,g) = ZZ.trace_product_with(W)
            end
         end
         end
      ZZ.destroy
      C.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      do g = 1,n_group
      do h = 1,g
         W = ZERO
         .atom_group_AO_subspace_set(W,PP,g,h)
         if (g/=h) &
         .atom_group_AO_subspace_set(W,PP,h,g)
         W.back_transform_using(Y)
         .make_r_JK_nosym(C,K,W)
         do i = 1,n_group
         do j = 1,i
            W = ZERO
            .atom_group_AO_subspace_set(W,PP,i,j)
            if (i/=j) &
            .atom_group_AO_subspace_set(W,PP,j,i)
            W.back_transform_using(Y)
            E_C(i,j,g,h) =  C.trace_product_with(W)
            E_K(i,j,g,h) = -K.trace_product_with(W)
         end
         end
      end
      end
      K.destroy
      C.destroy
      E_C = HALF*E_C
      E_K = HALF*HALF*E_K
      EE.create(n_group,n_group)
      !
      stdout.text(" ")
      stdout.text("Energies obtained with the current density matrix:")
      stdout.text(" ")
      fac = sum(E_T+E_Z) + sum(E_C+E_K)
      stdout.show("SCF electronic energy =",fac)
      stdout.show("SCF energy            =",fac+.nuclear_energy)
      stdout.show("Kinetic energy        =",sum(E_T))
      !
      unit = "kcal/mol"
      fac = unit.conversion_factor
      E_T = fac*E_T
      E_Z = fac*E_Z
      E_C = fac*E_C
      E_K = fac*E_K
      E_ZZ = fac*E_ZZ
      stdout.text(" ")
      stdout.text("Energy decomposition in kcal/mol ...")
      stdout.text(" ")
      stdout.text("Kinetic interaction terms")
      stdout.put(E_T)
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms")
      stdout.put(E_Z)
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
      stdout.put(E_ZZ(:,:,1))
      stdout.text(" ")
      stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
      stdout.put(E_ZZ(:,:,2))
      EE(1,1) = fac*.atom(.atom_group(1).element).nuclear_energy
      EE(2,2) = fac*.atom(.atom_group(2).element).nuclear_energy
      nuclear_repulsion = fac*.nuclear_energy - EE(1,1) - EE(2,2)
      EE(2,1) = nuclear_repulsion
      EE(1,2) = ZERO
      stdout.text(" ")
      stdout.text("Nuclear nuclear repulsion")
      stdout.put(EE)
      EE(1,1) = E_C(1,1,1,1)
      EE(2,1) = E_C(2,2,1,1)
      EE(1,2) = E_C(1,1,2,2)
      EE(2,2) = E_C(2,2,2,2)
      stdout.text(" ")
      stdout.text("Diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      EE(1,1) = E_C(1,2,1,1)
      EE(2,1) = E_C(2,1,1,1)
      EE(1,2) = E_C(1,2,2,2)
      EE(2,2) = E_C(2,1,2,2)
      stdout.text(" ")
      stdout.text("Semi diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      EE(1,1) = E_C(1,2,1,2)
      EE(2,1) = E_C(2,1,1,2)
      EE(1,2) = E_C(1,2,2,1)
      EE(2,2) = E_C(2,1,2,1)
      stdout.text(" ")
      stdout.text("Off diagonal Coulomb repulsion interaction terms")
      stdout.put(EE)
      stdout.text(" ")
      stdout.text("All Coulomb repulsion interaction terms")
      stdout.put(E_C)
      EE(1,1) = E_K(1,1,1,1)
      EE(2,1) = E_K(2,2,1,1)
      EE(1,2) = E_K(1,1,2,2)
      EE(2,2) = E_K(2,2,2,2)
      stdout.text(" ")
      stdout.text("Diagonal exchange interaction terms")
      stdout.put(EE)
      EE(1,1) = E_K(1,2,1,1)
      EE(2,1) = E_K(2,1,1,1)
      EE(1,2) = E_K(1,2,2,2)
      EE(2,2) = E_K(2,1,2,2)
      stdout.text(" ")
      stdout.text("Semi diagonal exchange interaction terms")
      stdout.put(EE)
      EE(1,1) = E_K(1,2,1,2)
      EE(2,1) = E_K(2,1,1,2)
      EE(1,2) = E_K(1,2,2,1)
      EE(2,2) = E_K(2,1,2,1)
      stdout.text(" ")
      stdout.text("Off diagonal exchange interaction terms")
      stdout.put(EE)
      stdout.text(" ")
      stdout.text("All exchange interaction terms")
      stdout.put(E_K)

      kinetic_energy = E_T(2,1)
      nuclear_attraction = sum(E_Z) - E_ZZ(1,1,1) - E_ZZ(2,2,2)
      coulomb_repulsion = sum(E_C) - E_C(1,1,1,1) - E_C(2,2,2,2)
      net_coulomb = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
      bicentric_exchange = E_K(1,1,2,2) + E_K(2,2,1,1)
      exchange_attraction = sum(E_K) - E_K(1,1,1,1) - E_K(2,2,2,2)
      total_interaction = kinetic_energy + net_coulomb + exchange_attraction
      stdout.text(" ")
      stdout.show("Electron-nuclear attraction =",nuclear_attraction)
      stdout.show("Nuclear-nuclear repulsion   =",nuclear_repulsion)
      stdout.show("Electron coulomb repulsion  =",coulomb_repulsion)
      stdout.text(" ")
      stdout.text("Interaction energies for "//trim(.name)//":")
      stdout.text(" ")
      stdout.show("Kinetic energy     =",kinetic_energy)
      stdout.show("Exchange energy    =",exchange_attraction)
      stdout.show("Kinetic + Exhange  =",kinetic_energy+exchange_attraction)
      stdout.show("Bicentric Exchange =",bicentric_exchange)
      stdout.show("Net Coulomb energy =",net_coulomb)
      stdout.show("Net electronic en  =",nuclear_attraction+coulomb_repulsion)
      stdout.show("Total int. energy  =",total_interaction)

      kinetic_energy = E_T(1,1)
      exchange_attraction = E_K(1,1,1,1)
      net_coulomb = E_ZZ(1,1,1) + fac*.atom(.atom_group(1).element).nuclear_energy + E_C(1,1,1,1)
      total_interaction = kinetic_energy + net_coulomb + exchange_attraction
      stdout.text(" ")
      stdout.text("Monomer 1 energies:")
      stdout.text(" ")
      stdout.show("Kinetic energy 1   =",kinetic_energy)
      stdout.show("Exchange energy 1  =",exchange_attraction)
      stdout.show("Kinetic+Exhange 1  =",kinetic_energy+exchange_attraction)
      stdout.show("Net Coulomb 1      =",net_coulomb)
      stdout.show("Total 1            =",total_interaction)

      kinetic_energy = E_T(2,2)
      exchange_attraction = E_K(2,2,2,2)
      net_coulomb = E_ZZ(2,2,2) + fac*.atom(.atom_group(2).element).nuclear_energy + E_C(2,2,2,2)
      total_interaction = kinetic_energy + net_coulomb + exchange_attraction
      stdout.text(" ")
      stdout.text("Monomer 2 energies:")
      stdout.text(" ")
      stdout.show("Kinetic energy 2   =",kinetic_energy)
      stdout.show("Exchange energy 2  =",exchange_attraction)
      stdout.show("Kinetic+Exhange 2  =",kinetic_energy+exchange_attraction)
      stdout.show("Net Coulomb 2      =",net_coulomb)
      stdout.show("Total 2            =",total_interaction)

      EE.destroy
      E_ZZ.destroy
      E_K.destroy
      E_C.destroy
      E_Z.destroy
      E_T.destroy
      Z.destroy
      T.destroy
      W.destroy
      PP.destroy
      P.destroy
   end

!   put_roby_energy_partition
!   ! Put out the energy decomposition specified in the .atom_group array.
!   ! The inverse of matrix "Y" is used to back transform the density matrix
!   ! (which is taken from disk). The back transformed density matrix is then
!   ! partitioned, and transformed back in order to evaluate the interaction
!   ! energies between the partitioned systems.
!      unit :: STR
!      arch :: ARCHIVE
!      E_T,E_T_A,E_T_B, E_Z,E_Z_A,E_Z_B :: REAL
!      E_C,E_C_A,E_C_B, E_K,E_K_A,E_K_B, E_N,E_N_A,E_N_B :: REAL
!      kinetic_energy,nuclear_attraction,nuclear_repulsion :: REAL
!      coulomb_repulsion,net_coulomb :: REAL
!      exchange_attraction,total_interaction :: REAL
!      energy, promotion_energy, fac :: REAL
!      P,P_A,P_B,MO,OM,Q,T,Z,C,K :: MAT{REAL}*
!      n,f,l :: INT
!      ENSURE(.atom_group.created,"no atom group information")
!      ENSURE(size(.atom_group)==2,"must have only 2 groups")
!      arch.set(.name,"density_matrix,restricted")
!      ENSURE(arch.exists,"no density matrix")
!      P.create(.n_bf,.n_bf)
!      arch.read(P) ! Read the density from disk
!      !
!      .make_progroup_density(MOs=TRUE)
!  ! stdout.text(" ")
!  ! stdout.text("WARING, no symorthonormilsation")
!      .symorthonormalise_occupied_MOs
!      !
!      P_A.create(.n_bf,.n_bf)
!      P_B.create(.n_bf,.n_bf)
!      MO.create(.n_bf,.n_bf)
!      OM.create(.n_bf,.n_bf)
!      Q.create(.n_bf,.n_bf)
!      MO = .molecular_orbitals.restricted
!      OM.to_inverse_of(MO)
!      P.back_transform_to(Q,OM)
!      n = .occupation_numbers.restricted(1:).index_of_first_zero_value - 1
!    stdout.text(" ")
!    stdout.show("n = ",n)
!      P_A = ZERO
!      P_A(1:n,1:n) = Q(1:n,1:n)
!    stdout.text("P_A :")
!    stdout.put(P_A)
!      P_A.back_transform_using(MO)
!      f = .occupation_numbers.restricted(n+1:).index_of_first_nonzero_value
!      f = n + f
!      l = .occupation_numbers.restricted(f:).index_of_first_zero_value - 1
!      l = f + l - 1
!    stdout.show("f = ",f)
!    stdout.show("l = ",l)
!      P_B = ZERO
!      P_B(f:l,f:l) = Q(f:l,f:l)
!    stdout.text("P_B :")
!    stdout.put(P_B)
!      P_B.back_transform_using(MO)
!    stdout.text("Q :")
!    stdout.put(Q)
!      Q.destroy
!      OM.destroy
!      MO.destroy
!      !
!      unit = "kcal/mol"
!      fac = unit.conversion_factor
!      !
!      T.create(.n_bf,.n_bf)
!      .get_kinetic_matrix(T)
!      E_T   = T.trace_product_with(P)*fac
!      E_T_A = T.trace_product_with(P_A)*fac
!      E_T_B = T.trace_product_with(P_B)*fac
!      T.destroy
!      !
!      Z.create(.n_bf,.n_bf)
!      .get_nuclear_matrix(Z)
!      E_Z   = Z.trace_product_with(P)*fac
!      .make_nuclear_matrix(Z,.atom_group(1).element)
!      E_Z_A = Z.trace_product_with(P_A)*fac
!      .make_nuclear_matrix(Z,.atom_group(2).element)
!      E_Z_B = Z.trace_product_with(P_B)*fac
!      Z.destroy
!      !
!      C.create(.n_bf,.n_bf)
!      K.create(.n_bf,.n_bf)
!      .make_r_JK_nosym(C,K,P)
!      E_C   = HALF*C.trace_product_with(P)*fac
!      E_K   = -QUARTER*K.trace_product_with(P)*fac
!      .make_r_JK_nosym(C,K,P_A)
!      E_C_A = HALF*C.trace_product_with(P_A)*fac
!      E_K_A = -QUARTER*K.trace_product_with(P_A)*fac
!      .make_r_JK_nosym(C,K,P_B)
!      E_C_B = HALF*C.trace_product_with(P_B)*fac
!      E_K_B = -QUARTER*K.trace_product_with(P_B)*fac
!      K.destroy
!      C.destroy
!      P_B.destroy
!      P_A.destroy
!      P.destroy
!      !
!      E_N   = .nuclear_energy*fac
!      E_N_A = .atom(.atom_group(1).element).nuclear_energy*fac
!      E_N_B = .atom(.atom_group(2).element).nuclear_energy*fac
!      stdout.text(" ")
!      !
!      energy              = E_T + E_Z + E_C + E_K
!      kinetic_energy      = E_T - E_T_A - E_T_B
!      nuclear_attraction  = E_Z - E_Z_A - E_Z_B
!      nuclear_repulsion   = E_N - E_N_A - E_N_B
!      coulomb_repulsion   = E_C - E_C_A - E_C_B
!      net_coulomb         = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
!      exchange_attraction = E_K - E_K_A - E_K_B
!      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction
!      !
!      stdout.text(" ")
!      stdout.show("SCF electronic energy =",(energy/fac))
!      stdout.show("SCF energy            =",(energy/fac)+.nuclear_energy)
!      stdout.show("Kinetic energy        =",(E_T/fac))
!      stdout.text(" ")
!      stdout.text("Roby energy decomposition in kcal/mol ...")
!      stdout.text(" ")
!      stdout.text("Interaction energies for "//trim(.name)//":")
!      stdout.text(" ")
!      stdout.show("Energy             =",energy)
!      stdout.show("Kinetic energy     =",kinetic_energy)
!      stdout.show("Exchange energy    =",exchange_attraction)
!      stdout.show("Kinetic + Exhange  =",kinetic_energy+exchange_attraction)
!      stdout.show("Net Coulomb energy =",net_coulomb)
!      stdout.show("Total int. energy  =",total_interaction)
!      !
!      kinetic_energy      = E_T_A
!      exchange_attraction = E_K_A
!      net_coulomb         = E_Z_A + E_N_A + E_C_A
!      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction
!      promotion_energy    = total_interaction - .atom_group_energy(1)*fac
!      stdout.text(" ")
!      stdout.text("Monomer 1 energies:")
!      stdout.text(" ")
!      stdout.show("Kinetic energy 1   =",kinetic_energy)
!      stdout.show("Exchange energy 1  =",exchange_attraction)
!      stdout.show("Kinetic+Exhange 1  =",kinetic_energy+exchange_attraction)
!      stdout.show("Net Coulomb 1      =",net_coulomb)
!      stdout.show("Total 1            =",total_interaction)
!      stdout.show("Promotion 1        =",promotion_energy)
!      !
!      kinetic_energy      = E_T_B
!      exchange_attraction = E_K_B
!      net_coulomb         = E_Z_B + E_N_B + E_C_B
!      total_interaction   = kinetic_energy + net_coulomb + exchange_attraction
!      promotion_energy    = total_interaction - .atom_group_energy(2)*fac
!      stdout.text(" ")
!      stdout.text("Monomer 2 energies:")
!      stdout.text(" ")
!      stdout.show("Kinetic energy 2   =",kinetic_energy)
!      stdout.show("Exchange energy 2  =",exchange_attraction)
!      stdout.show("Kinetic+Exhange 2  =",kinetic_energy+exchange_attraction)
!      stdout.show("Net Coulomb 2      =",net_coulomb)
!      stdout.show("Total 2            =",total_interaction)
!      stdout.show("Promotion 2        =",promotion_energy)
!   end

   put_roby_smo_energy_partition
   ! Put out the roby energy decomposition specified in the .atom_group array
   ! based on symmetrically orthonormalised monomer molecular (SOMMO) fragments.
   ! A supermolecue density matrix must exist on disk.
      .put_roby_energy_partition(symorthonormalise=TRUE)
   end

   put_roby_mmo_energy_partition
   ! Put out the roby energy decomposition specified in the .atom_group array
   ! based on monomer molecular (MMO) fragments.  A supermolecue density matrix
   ! must exist on disk.
      .put_roby_energy_partition(symorthonormalise=FALSE)
   end

   put_roby_energy_partition(symorthonormalise)
   ! Calculate and put out the roby energy decomposition specified in the
   ! .atom_group array.  If "symorthonormalise" is TRUE, then the occupied
   ! monomer molecular orbitals are symmetrically orthonormalised in order to
   ! define the fragments. The density matrix defining the supermolecule is read
   ! in from the disk, so an SCF calculation or a "make_group_density_matrix"
   ! calculation must be done before this routine is called.
      symorthonormalise :: BIN
   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(size(.atom_group)==2,"must have only 2 groups")
      unit :: STR
      arch :: ARCHIVE
      E_T,E_T_A,E_T_B, E_Z,E_Z_A,E_Z_B :: REAL
      E0_A,E0_B, E0_T_A,E0_T_B, E0_Z_A,E0_Z_B :: REAL
      E_C,E_C_A,E_C_B, E_K,E_K_A,E_K_B, E_N,E_N_A,E_N_B :: REAL
      E0_C_A,E0_C_B, E0_K_A,E0_K_B :: REAL
      E_kin,E_att,E_rep,E_coul,E_net_coul,E_ex,E_int,E_prom,energy, fac :: REAL
      P,P_A,P_B,MO,D,S,T,Z,C,K :: MAT{REAL}*
      n,f,l :: INT
      arch.set(.name,"density_matrix,restricted")
   ENSURE(arch.exists,"no density matrix")
      unit = "kcal/mol"
      fac = unit.conversion_factor
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      P.create(.n_bf,.n_bf)
      arch.read(P)                      ! *** Read the density from disk
      .make_progroup_density(MOs=TRUE)  ! *** Make the monomer molecular orbitals
      .make_group_energies(1,E0_A,E0_T_A,E0_Z_A,E0_C_A,E0_K_A,fac)
      .make_group_energies(2,E0_B,E0_T_B,E0_Z_B,E0_C_B,E0_K_B,fac)
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      if (symorthonormalise) then
         stdout.text(" ")
         stdout.text("performing symorthonormalisation")
         .symorthonormalise_occupied_MOs
      else
         stdout.text(" ")
         stdout.text("WARNING: no symorthonormalisation")
      end
      P_A.create(.n_bf,.n_bf)
      P_B.create(.n_bf,.n_bf)
      D.create(.n_bf,.n_bf)
      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
      P.change_basis_to(P_A,S)
      S.destroy
      P_B = P_A
      n = .occupation_numbers.restricted(1:).index_of_first_zero_value - 1
      MO => .molecular_orbitals.restricted(:,1:n)
    stdout.text(" ")
    stdout.show("n = ",n)
      D.to_product_of(MO,MO,transpose_b=TRUE)
      P_A.change_basis_using(D)
      f = .occupation_numbers.restricted(n+1:).index_of_first_nonzero_value
      f = n + f
      l = .occupation_numbers.restricted(f:).index_of_first_zero_value - 1
      l = f + l - 1
    stdout.show("f = ",f)
    stdout.show("l = ",l)
      MO => .molecular_orbitals.restricted(:,f:l)
      D.to_product_of(MO,MO,transpose_b=TRUE)
      P_B.change_basis_using(D)
      D.destroy
      !
      T.create(.n_bf,.n_bf)
      .get_kinetic_matrix(T)
      E_T   = T.trace_product_with(P)*fac
      E_T_A = T.trace_product_with(P_A)*fac
      E_T_B = T.trace_product_with(P_B)*fac
      T.destroy
      !
      Z.create(.n_bf,.n_bf)
      .get_nuclear_matrix(Z)
      E_Z   = Z.trace_product_with(P)*fac
      .make_nuclear_matrix(Z,.atom_group(1).element)
      E_Z_A = Z.trace_product_with(P_A)*fac
      .make_nuclear_matrix(Z,.atom_group(2).element)
      E_Z_B = Z.trace_product_with(P_B)*fac
      Z.destroy
      !
      C.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      .make_r_JK_nosym(C,K,P)
      E_C   = HALF*C.trace_product_with(P)*fac
      E_K   = -QUARTER*K.trace_product_with(P)*fac
      .make_r_JK_nosym(C,K,P_A)
      E_C_A = HALF*C.trace_product_with(P_A)*fac
      E_K_A = -QUARTER*K.trace_product_with(P_A)*fac
      .make_r_JK_nosym(C,K,P_B)
      E_C_B = HALF*C.trace_product_with(P_B)*fac
      E_K_B = -QUARTER*K.trace_product_with(P_B)*fac
      K.destroy
      C.destroy
      P_B.destroy
      P_A.destroy
      P.destroy
      !
      E_N   = .nuclear_energy*fac
      E_N_A = .atom(.atom_group(1).element).nuclear_energy*fac
      E_N_B = .atom(.atom_group(2).element).nuclear_energy*fac
      stdout.text(" ")
      !
      stdout.text(" ")
      stdout.text("Supermolecule energies:")
      stdout.text(" ")
      energy     = E_T + E_Z + E_C + E_K
      stdout.show("SCF electronic energy =",(energy/fac))
      stdout.show("... in kcal/mol       =",energy)
      stdout.show("SCF energy            =",(energy/fac)+.nuclear_energy)
      stdout.show("... in kcal/mol       =",energy+fac*.nuclear_energy)
      stdout.show("Kinetic energy        =",E_T)
      stdout.show("... in kcal/mol       =",(E_T/fac))
      stdout.text(" ")
      stdout.text("Roby interaction energy decomposition (kcal/mol):")
      E_kin      = E_T - E_T_A - E_T_B
      E_ex       = E_K - E_K_A - E_K_B
      E_att      = E_Z - E_Z_A - E_Z_B
      E_rep      = E_N - E_N_A - E_N_B
      E_coul     = E_C - E_C_A - E_C_B
      E_net_coul = E_att + E_rep + E_coul
      E_int      = E_kin + E_net_coul + E_ex
      .put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_int)
      !
      stdout.text(" ")
      stdout.text("Interacting Monomer 1 energies (kcal/mol):")
      stdout.text(" ")
      E_int      = E_T_A + (E_Z_A + E_N_A + E_C_A) + E_K_A
      E_prom     = E_int - .atom_group_energy(1)*fac
      .put_roby_energy_parts(E_T_A,E_K_A,E_C_A,E_Z_A,E_N_A,E_int,E_prom)
      !
      stdout.text(" ")
      stdout.text("Isolated Monomer 1 energies (kcal/mol):")
      stdout.text(" ")
      stdout.show("Monomer 1 energy   =",.atom_group_energy(1))
      stdout.show("... in k/cal mol   =",.atom_group_energy(1)*fac)
      stdout.text(" ")
      .put_roby_energy_parts(E0_T_A,E0_K_A,E0_C_A,E0_Z_A,E_N_A)
      !
      stdout.text(" ")
      stdout.text("Changes in monomer 1 energy contributions (kcal/mol):")
      E_kin      = E_T_A - E0_T_A
      E_ex       = E_K_A - E0_K_A
      E_coul     = E_C_A - E0_C_A
      E_att      = E_Z_A - E0_Z_A            ! nuclear attraction
      E_rep      = ZERO                      ! change in nuclear repulsion is zero
      E_net_coul = E_att + E_rep + E_coul
      E_prom     = E_kin + E_net_coul + E_ex
      .put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_prom=E_prom)
      !
      stdout.text(" ")
      stdout.text("Interacting Monomer 2 energies (kcal/mol):")
      stdout.text(" ")
      E_int      = E_T_B + (E_Z_B + E_N_B + E_C_B) + E_K_B
      E_prom     = E_int - .atom_group_energy(2)*fac
      .put_roby_energy_parts(E_T_B,E_K_B,E_C_B,E_Z_B,E_N_B,E_int,E_prom)
      !
      stdout.text(" ")
      stdout.text("Isolated Monomer 2 energies (kcal/mol):")
      stdout.text(" ")
      stdout.show("Monomer 2 energy   =",.atom_group_energy(2))
      stdout.show("... in k/cal mol   =",.atom_group_energy(2)*fac)
      stdout.text(" ")
      .put_roby_energy_parts(E0_T_B,E0_K_B,E0_C_B,E0_Z_B,E_N_B)
      !
      stdout.text(" ")
      stdout.text("Changes in monomer 2 energy contributions (kcal/mol):")
      E_kin      = E_T_B - E0_T_B
      E_ex       = E_K_B - E0_K_B
      E_coul     = E_C_B - E0_C_B
      E_att      = E_Z_B - E0_Z_B            ! nuclear attraction
      E_rep      = ZERO                      ! change in nuclear repulsion is zero
      E_net_coul = E_att + E_rep + E_coul
      E_prom     = E_kin + E_net_coul + E_ex
      .put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_prom=E_prom)
   end

!   put_roby_energy_partition(symorthonormalise)
!   ! Calculate and put out the roby energy decomposition specified in the
!   ! .atom_group array.  If "symorthonormalise" is TRUE, then the occupied
!   ! monomer molecular orbitals are symmetrically orthonormalised in order to
!   ! define the fragments. The density matrix defining the supermolecule is read
!   ! in from the disk, so an SCF calculation or a "make_group_density_matrix"
!   ! calculation must be done before this routine is called.
!      symorthonormalise :: BIN
!   ENSURE(.atom_group.created,"no atom group information")
!   ENSURE(size(.atom_group)==2,"must have only 2 groups")
!      unit :: STR
!      arch :: ARCHIVE
!      E_T,E_T_A,E_T_B, E_Z,E_Z_A,E_Z_B :: REAL
!      E0_A,E0_B, E0_T_A,E0_T_B, E0_Z_A,E0_Z_B :: REAL
!      E_C,E_C_A,E_C_B, E_K,E_K_A,E_K_B, E_N,E_N_A,E_N_B :: REAL
!      E0_C_A,E0_C_B, E0_K_A,E0_K_B :: REAL
!      E_kin,E_att,E_rep,E_coul,E_net_coul,E_ex,E_int,E_prom,energy, fac :: REAL
!      P,P_A,P_B,MO,OM,Q,T,Z,C,K :: MAT{REAL}*
!      n,f,l :: INT
!      arch.set(.name,"density_matrix,restricted")
!   ENSURE(arch.exists,"no density matrix")
!      unit = "kcal/mol"
!      fac = unit.conversion_factor
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      P.create(.n_bf,.n_bf)
!      arch.read(P)                      ! *** Read the density from disk
!      .make_progroup_density(MOs=TRUE)  ! *** Make the monomer molecular orbitals
!      .make_group_energies(1,E0_A,E0_T_A,E0_Z_A,E0_C_A,E0_K_A,fac)
!      .make_group_energies(2,E0_B,E0_T_B,E0_Z_B,E0_C_B,E0_K_B,fac)
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      if (symorthonormalise) then
!         stdout.text(" ")
!         stdout.text("performing symorthonormalisation")
!         .symorthonormalise_occupied_MOs
!      else
!         stdout.text(" ")
!         stdout.text("WARNING: no symorthonormalisation")
!      end
!      P_A.create(.n_bf,.n_bf)
!      P_B.create(.n_bf,.n_bf)
!      MO.create(.n_bf,.n_bf)
!      OM.create(.n_bf,.n_bf)
!      Q.create(.n_bf,.n_bf)
!      MO = .molecular_orbitals.restricted
!      OM.to_inverse_of(MO)
!      P.back_transform_to(Q,OM)
!      n = .occupation_numbers.restricted(1:).index_of_first_zero_value - 1
!    stdout.text(" ")
!    stdout.show("n = ",n)
!      P_A = ZERO
!      P_A(1:n,1:n) = Q(1:n,1:n)
!    stdout.text("P_A :")
!    stdout.put(P_A(1:n,1:n))
!      P_A.back_transform_using(MO)
!      f = .occupation_numbers.restricted(n+1:).index_of_first_nonzero_value
!      f = n + f
!      l = .occupation_numbers.restricted(f:).index_of_first_zero_value - 1
!      l = f + l - 1
!    stdout.show("f = ",f)
!    stdout.show("l = ",l)
!      P_B = ZERO
!      P_B(f:l,f:l) = Q(f:l,f:l)
!    stdout.text("P_B :")
!    stdout.put(P_B(f:l,f:l))
!    stdout.text("Q :")
!    stdout.put(Q)
!      P_B.back_transform_using(MO)
!      Q.destroy
!      OM.destroy
!      MO.destroy
!      !
!      T.create(.n_bf,.n_bf)
!      .get_kinetic_matrix(T)
!      E_T   = T.trace_product_with(P)*fac
!      E_T_A = T.trace_product_with(P_A)*fac
!      E_T_B = T.trace_product_with(P_B)*fac
!      T.destroy
!      !
!      Z.create(.n_bf,.n_bf)
!      .get_nuclear_matrix(Z)
!      E_Z   = Z.trace_product_with(P)*fac
!      .make_nuclear_matrix(Z,.atom_group(1).element)
!      E_Z_A = Z.trace_product_with(P_A)*fac
!      .make_nuclear_matrix(Z,.atom_group(2).element)
!      E_Z_B = Z.trace_product_with(P_B)*fac
!      Z.destroy
!      !
!      C.create(.n_bf,.n_bf)
!      K.create(.n_bf,.n_bf)
!      .make_r_JK_nosym(C,K,P)
!      E_C   = HALF*C.trace_product_with(P)*fac
!      E_K   = -QUARTER*K.trace_product_with(P)*fac
!      .make_r_JK_nosym(C,K,P_A)
!      E_C_A = HALF*C.trace_product_with(P_A)*fac
!      E_K_A = -QUARTER*K.trace_product_with(P_A)*fac
!      .make_r_JK_nosym(C,K,P_B)
!      E_C_B = HALF*C.trace_product_with(P_B)*fac
!      E_K_B = -QUARTER*K.trace_product_with(P_B)*fac
!      K.destroy
!      C.destroy
!      P_B.destroy
!      P_A.destroy
!      P.destroy
!      !
!      E_N   = .nuclear_energy*fac
!      E_N_A = .atom(.atom_group(1).element).nuclear_energy*fac
!      E_N_B = .atom(.atom_group(2).element).nuclear_energy*fac
!      stdout.text(" ")
!      !
!      stdout.text(" ")
!      stdout.text("Supermolecule energies:")
!      stdout.text(" ")
!      energy     = E_T + E_Z + E_C + E_K
!      stdout.show("SCF electronic energy =",(energy/fac))
!      stdout.show("... in kcal/mol       =",energy)
!      stdout.show("SCF energy            =",(energy/fac)+.nuclear_energy)
!      stdout.show("... in kcal/mol       =",energy+fac*.nuclear_energy)
!      stdout.show("Kinetic energy        =",E_T)
!      stdout.show("... in kcal/mol       =",(E_T/fac))
!      stdout.text(" ")
!      stdout.text("Roby interaction energy decomposition (kcal/mol):")
!      E_kin      = E_T - E_T_A - E_T_B
!      E_ex       = E_K - E_K_A - E_K_B
!      E_att      = E_Z - E_Z_A - E_Z_B
!      E_rep      = E_N - E_N_A - E_N_B
!      E_coul     = E_C - E_C_A - E_C_B
!      E_net_coul = E_att + E_rep + E_coul
!      E_int      = E_kin + E_net_coul + E_ex
!      .put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_int)
!      !
!      stdout.text(" ")
!      stdout.text("Interacting Monomer 1 energies (kcal/mol):")
!      stdout.text(" ")
!      E_int      = E_T_A + (E_Z_A + E_N_A + E_C_A) + E_K_A
!      E_prom     = E_int - .atom_group_energy(1)*fac
!      .put_roby_energy_parts(E_T_A,E_K_A,E_C_A,E_Z_A,E_N_A,E_int,E_prom)
!      !
!      stdout.text(" ")
!      stdout.text("Isolated Monomer 1 energies (kcal/mol):")
!      stdout.text(" ")
!      stdout.show("Monomer 1 energy   =",.atom_group_energy(1))
!      stdout.show("... in k/cal mol   =",.atom_group_energy(1)*fac)
!      stdout.text(" ")
!      .put_roby_energy_parts(E0_T_A,E0_K_A,E0_C_A,E0_Z_A,E_N_A)
!      !
!      stdout.text(" ")
!      stdout.text("Changes in monomer 1 energy contributions (kcal/mol):")
!      E_kin      = E_T_A - E0_T_A
!      E_ex       = E_K_A - E0_K_A
!      E_coul     = E_C_A - E0_C_A
!      E_att      = E_Z_A - E0_Z_A            ! nuclear attraction
!      E_rep      = ZERO                      ! change in nuclear repulsion is zero
!      E_net_coul = E_att + E_rep + E_coul
!      E_prom     = E_kin + E_net_coul + E_ex
!      .put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_prom=E_prom)
!      !
!      stdout.text(" ")
!      stdout.text("Interacting Monomer 2 energies (kcal/mol):")
!      stdout.text(" ")
!      E_int      = E_T_B + (E_Z_B + E_N_B + E_C_B) + E_K_B
!      E_prom     = E_int - .atom_group_energy(2)*fac
!      .put_roby_energy_parts(E_T_B,E_K_B,E_C_B,E_Z_B,E_N_B,E_int,E_prom)
!      !
!      stdout.text(" ")
!      stdout.text("Isolated Monomer 2 energies (kcal/mol):")
!      stdout.text(" ")
!      stdout.show("Monomer 2 energy   =",.atom_group_energy(2))
!      stdout.show("... in k/cal mol   =",.atom_group_energy(2)*fac)
!      stdout.text(" ")
!      .put_roby_energy_parts(E0_T_B,E0_K_B,E0_C_B,E0_Z_B,E_N_B)
!      !
!      stdout.text(" ")
!      stdout.text("Changes in monomer 2 energy contributions (kcal/mol):")
!      E_kin      = E_T_B - E0_T_B
!      E_ex       = E_K_B - E0_K_B
!      E_coul     = E_C_B - E0_C_B
!      E_att      = E_Z_B - E0_Z_B            ! nuclear attraction
!      E_rep      = ZERO                      ! change in nuclear repulsion is zero
!      E_net_coul = E_att + E_rep + E_coul
!      E_prom     = E_kin + E_net_coul + E_ex
!      .put_roby_energy_parts(E_kin,E_ex,E_coul,E_att,E_rep,E_prom=E_prom)
!   end

   put_roby_energy_parts(E_T,E_K,E_C,E_Z,E_N,E_int,E_prom) ::: private
   ! Put of the Roby energy parts
      E_T,E_K,E_C,E_Z,E_N :: REAL
      E_int,E_prom :: REAL, optional
      stdout.text(" ")
      stdout.show("Kinetic energy       =",E_T)
      stdout.show("Exchange energy      =",E_K)
      stdout.show("Kinetic + Exhange    =",E_T+E_K)
      stdout.show("Nuclear attraction   =",E_Z)
      stdout.show("Nuclear repulsion    =",E_N)
      stdout.show("Electronic repulsion =",E_C)
      stdout.show("Net coulomb energy   =",E_Z+E_N+E_C)
      if (present(E_int)) &
      stdout.show("Total int. energy    =",E_int)
      if (present(E_prom)) &
      stdout.show("Promotion energy     =",E_prom)
   end

   atom_group_AO_subspace_set(P,Q,row_group,col_group)
   ! Set P=Q only for the block whose rows correspond to basis functions
   ! on the atoms in the atom group "row_group" and whose columns are
   ! on the atoms in the atom group "col_group", as given in the
   ! .atom_group array vector.
     P,Q :: MAT{REAL}
     row_group,col_group :: INT
   ENSURE(P.dim1==.n_bf,"wrong size for P")
   ENSURE(P.dim2==.n_bf,"wrong size for P")
   ENSURE(Q.dim1==.n_bf,"wrong size for Q")
   ENSURE(Q.dim2==.n_bf,"wrong size for Q")
   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(row_group<=size(.atom_group),"no such row group")
   ENSURE(col_group<=size(.atom_group),"no such column group")
   ENSURE(row_group>0,"row group index must be positive")
   ENSURE(col_group>0,"column group index must be positive")
     i_a,i_b,a,b,fa,fb,la,lb :: INT
     do i_a = 1,size(.atom_group(row_group).element)
     do i_b = 1,size(.atom_group(col_group).element)
       a = .atom_group(row_group).element(i_a)
       b = .atom_group(col_group).element(i_b)
       fa = .first_basis_fn_for_atom(a)
       fb = .first_basis_fn_for_atom(b)
       la = .last_basis_fn_for_atom(a)
       lb = .last_basis_fn_for_atom(b)
       P(fa:la,fb:lb) = Q(fa:la,fb:lb)
     end
     end
   end

   AO_subspace_set(A,B,row_atom,col_atom) ::: private
   ! Set "A" equal to the AO subspace blocks of "B" specified by the atom
   ! indices in "row_atom" and "col_atom". If either is missing, then copy
   ! the entire row or col, i.e.  A(small) = B(row_atom,col_atom)
      A,B :: MAT{REAL}
      row_atom,col_atom :: VEC{INT}, optional
   ENSURE(B.dim1==.n_bf,"B has wrong shape")
   ENSURE(B.dim2==.n_bf,"B has wrong shape")
      n_row_atoms,n_col_atoms, a1,a2 :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      if (present(row_atom) AND present(col_atom)) then
         n_row_atoms = size(row_atom)
         n_col_atoms = size(col_atom)
         a1 = .atom(row_atom).n_bf
         a2 = .atom(col_atom).n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = .atom(col_atom(j)).n_bf
               A(b_i+1:b_i+n_i,b_j+1:b_j+n_j) = B(f_i:l_i,f_j:l_j)
               b_j = b_j + n_j
            end
            b_i = b_i + n_i
         end
      else if (present(row_atom)) then
         n_row_atoms = size(row_atom)
         a1 = .atom(row_atom).n_bf
         a2 = .n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i));
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            A(b_i+1:b_i+n_i,:) = B(f_i:l_i,:)
            b_i = b_i + n_i
         end
      else if (present(col_atom)) then
         n_col_atoms = size(col_atom)
         a1 = .n_bf
         a2 = .atom(col_atom).n_bf
         ENSURE(A.dim1==a1,"A has wrong shape")
         ENSURE(A.dim2==a2,"A has wrong shape")
         b_j = 0
         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j));
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = .atom(col_atom(j)).n_bf
            A(:,b_j+1:b_j+n_j) = B(:,f_j:l_j)
            b_j = b_j + n_j
         end
      end
   end

   AO_subspace_zero(B,row_atom,col_atom) ::: private
   ! Zero out the AO subspace blocks of "B" specified by the atom
   ! indices in "row_atom" and "col_atom". If either is missing, then zero
   ! the entire row or col, i.e.  B(row_atom,col_atom) = 0
      B :: MAT{REAL}
      row_atom,col_atom :: VEC{INT}, optional
   ENSURE(B.dim1==.n_bf,"B has wrong shape")
   ENSURE(B.dim2==.n_bf,"B has wrong shape")
      n_row_atoms,n_col_atoms,a1,a2 :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      if (present(row_atom) AND present(col_atom)) then
         n_row_atoms = size(row_atom)
         n_col_atoms = size(col_atom)
         a1 = .atom(row_atom).n_bf
         a2 = .atom(col_atom).n_bf
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = .atom(col_atom(j)).n_bf
               B(f_i:l_i,f_j:l_j) = ZERO
               b_j = b_j + n_j
            end
            b_i = b_i + n_i
         end
      else if (present(row_atom)) then
         n_row_atoms = size(row_atom)
         a1 = .atom(row_atom).n_bf
         a2 = .n_bf
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i));
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            B(f_i:l_i,:) = ZERO
            b_i = b_i + n_i
         end
      else if (present(col_atom)) then
         n_col_atoms = size(col_atom)
         a1 = .n_bf
         a2 = .atom(col_atom).n_bf
         b_j = 0
         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j));
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = .atom(col_atom(j)).n_bf
            B(:,f_j:l_j) = ZERO
            b_j = b_j + n_j
         end
      end
   end

   AO_subspace_put(B,A,row_atom,col_atom) ::: private
   ! Set the AO subspace blocks of "A" specified by the atom indices in
   ! "row_atom" and "col_atom" equal to "B". If either is missing then copy
   ! the entire row or column, i.e.  A(row_atom,col_atom) = A() + B(small)
   ! WARNING **** This adds into A, and uncopied blocks are NOT set to zero.
      A,B :: MAT{REAL}
      row_atom,col_atom :: VEC{INT}, optional
   ENSURE(A.dim1==.n_bf,"A has wrong shape")
   ENSURE(A.dim2==.n_bf,"A has wrong shape")
      n_row_atoms,n_col_atoms,b1,b2 :: INT
      i,b_i,f_i,l_i,n_i, j,b_j,f_j,l_j,n_j :: INT
      if (present(row_atom) AND present(col_atom)) then
         n_row_atoms = size(row_atom)
         n_col_atoms = size(col_atom)
         b1 = .atom(row_atom).n_bf
         b2 = .atom(col_atom).n_bf
         ENSURE(B.dim1==b1,"B has wrong shape")
         ENSURE(B.dim2==b2,"B has wrong shape")
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i))
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            b_j = 0
            do j = 1,n_col_atoms
               f_j = .first_basis_fn_for_atom(col_atom(j))
               l_j = .last_basis_fn_for_atom( col_atom(j))
               n_j = .atom(col_atom(j)).n_bf
               A(f_i:l_i,f_j:l_j) = A(f_i:l_i,f_j:l_j) + B(b_i+1:b_i+n_i,b_j+1:b_j+n_j)
               b_j = b_j + n_j
            end
            b_i = b_i + n_i
         end
      else if (present(row_atom)) then
         n_row_atoms = size(row_atom)
         b1 = .atom(row_atom).n_bf
         b2 = .n_bf
         ENSURE(B.dim1==b1,"B has wrong shape")
         ENSURE(B.dim2==b2,"B has wrong shape")
         b_i = 0
         do i = 1,n_row_atoms
            f_i = .first_basis_fn_for_atom(row_atom(i));
            l_i = .last_basis_fn_for_atom( row_atom(i))
            n_i = .atom(row_atom(i)).n_bf
            A(f_i:l_i,:) = A(f_i:l_i,:) + B(b_i+1:b_i+n_i,:)
            b_i = b_i + n_i
         end
      else if (present(col_atom)) then
         n_col_atoms = size(col_atom)
         b1 = .atom(col_atom).n_bf
         b2 = .n_bf
         ENSURE(B.dim1==b1,"B has wrong shape")
         ENSURE(B.dim2==b2,"B has wrong shape")
         b_j = 0
         do j = 1,n_col_atoms
            f_j = .first_basis_fn_for_atom(col_atom(j));
            l_j = .last_basis_fn_for_atom( col_atom(j))
            n_j = .atom(col_atom(j)).n_bf
            A(:,f_j:l_j) = A(:,f_j:l_j) + B(:,b_j+1:b_j+n_j)
            b_j = b_j + n_j
         end
      end
   end

   make_monomer_MOs ::: leaky
   ! Make the monomer molecular orbital matrix from symmetrically orthonormalised
   ! group (monomer) molecular orbitals. The promolecule orbitals are ordered by group.
   ! The orbitals and the corresponding promolecule density are *not* archived.
   ! This will destroy any existing restricted density matrix and MOs.
    ! S :: MAT{REAL}*
      .make_progroup_density(MOs=TRUE,output=FALSE)
    ! S.create(.n_bf,.n_bf)
    ! .get_overlap_matrix(S)
    ! S.change_basis_using(.molecular_orbitals.restricted)
    ! stdout.text("S in the monomer basis:")
    ! stdout.put(S)
    ! S.destroy
   end

   make_promol_MOs ::: leaky
   ! Make the promolecule molecular orbital matrix from symmetrically orthonormalised
   ! group (monomer) molecular orbitals. The promolecule orbitals are ordered by group.
   ! The orbitals and the corresponding density are *not* archived.
   ! This will destroy any existing restricted density matrix and MOs.
    ! S :: MAT{REAL}*
      .make_progroup_density(MOs=TRUE,output=FALSE)
      .symorthonormalise_occupied_MOs
    ! S.create(.n_bf,.n_bf)
    ! .get_overlap_matrix(S)
    ! S.change_basis_using(.molecular_orbitals.restricted)
    ! stdout.text("S in the promolecule monomer basis:")
    ! stdout.put(S)
    ! S.destroy
   end

! *************************
! Electron density routines
! *************************

   make_density_grid(density_grid,pt,sgn)
   ! Work out the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector. If "sgn" is present and equal to -1, the
   ! spin density is produced (provided alpha and beta natural orbitals are
   ! present).
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
      sgn :: INT, IN, optional
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      nkind,okind :: STR
      nkind = .natural_orbitals.number_kind
      okind = .natural_orbitals.spinorbital_kind
      if (nkind == "real") then
         if (okind=="restricted") then; .make_density_grid_r(density_grid,pt)
         else;                          .make_density_grid_u(density_grid,pt,sgn)
         end
      else
         .make_density_grid_c(density_grid,pt)
      end
   end

   make_density_grid(p_a,p_b,pt)
   ! Make the alpha and beta density grids, "p_a" and "p_b" respectively, from
   ! the unrestricted natural orbitals.
     p_a,p_b :: VEC{REAL}
     pt :: MAT{REAL}, IN
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("unrestricted"),"no natural orbitals")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
     nat :: MAT{REAL}*
     occ :: VEC{REAL}*
     nat => .natural_orbitals.restricted ! backup pointers
     occ => .occupation_numbers.restricted
     .natural_orbitals.restricted => .natural_orbitals.alpha
     .occupation_numbers.restricted => .occupation_numbers.alpha
     .make_density_grid(p_a,pt)
     .natural_orbitals.restricted => .natural_orbitals.beta
     .occupation_numbers.restricted => .occupation_numbers.beta
     .make_density_grid(p_b,pt)
     .natural_orbitals.restricted => nat ! restore backups
     .occupation_numbers.restricted => occ
   end

   make_density_grid_r(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
     density_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation numbers")
     NO :: VEC{REAL}*
     n_occ,n :: INT
     density_grid = ZERO
     NO.create(pt.dim1)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n), pt)
       density_grid = density_grid + .occupation_numbers.restricted(n)*NO*NO
     end
     NO.destroy
   end

   make_density_grid_u(density_grid,pt,sgn)
   ! Make the "density_grid" for the supplied points "pt" from unrestricted real
   ! natural orbitals. If present "sgn" is used to determine whether the total
   ! density or spin density is to be calculated: sgn=1 means sum the alpha and
   ! beta densities to form the total density, sgn=-1 means to subtract, forming
   ! the Sz spin density.
     density_grid :: VEC{REAL}
     pt :: MAT{REAL}
     sgn :: INT, IN, optional
   ENSURE(pt.dim2==3,  "wrong dimension for points array")
   ENSURE(.natural_orbitals.created("unrestricted"), "no unrestricted NO's")
   ENSURE(.occupation_numbers.alpha.created, "no alpha occupation numbers")
   ENSURE(.occupation_numbers.beta.created, "no beta occupation numbers")
     NO :: VEC{REAL}*
     fac,na,nb,n :: INT
     if (present(sgn)) then; fac = sgn
     else;                   fac = 1
     end
     NO.create(pt.dim1)
     na = .no_of_occupied_NOs("alpha")
     nb = .no_of_occupied_NOs("beta")
     density_grid = ZERO
     do n = 1,na
       .make_orbital_grid_r(NO,.natural_orbitals.alpha(:,n),pt)
       density_grid = density_grid + .occupation_numbers.alpha(n)*NO*NO
     end
     do n = 1,nb
       .make_orbital_grid_r(NO,.natural_orbitals.beta(:,n),pt)
       density_grid = density_grid + fac*.occupation_numbers.beta(n)*NO*NO
     end
     NO.destroy
   end

   make_density_grid_c(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3,  "incorrect dimension for points array")
   ENSURE(.natural_orbitals.created("restricted_complex"), "no natural orbitals")
   ENSURE(.occupation_numbers.restricted.created, "no occupation numbers")
      NO :: VEC{CPX}*
      n_occ,n :: INT
      density_grid = ZERO
      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n), pt)
         density_grid(:) = density_grid(:) + .occupation_numbers.restricted(n)*conjg(NO(:))*NO(:)
      end
      NO.destroy
   end

! ************************
! Orbital density routines
! ************************

   make_orbital_density_grid
   ! Work out the orbital on ".grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
   ENSURE(.grid.created, "no grid")
   ENSURE(.grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      gc :: VEC{CPX}*
      orb :: INT
      orb = .grid.orbital
      pt.create(.grid.n_pt,3); .grid.make_points(pt)
      gr.create(.grid.n_pt)
      if (.natural_orbitals.number_kind == "real") then
        .make_orbital_grid_r(gr,.natural_orbitals.restricted(:,orb),pt,square=TRUE)
      else
        gc.create(.grid.n_pt)
        .make_orbital_grid_c(gc,.natural_orbitals.restricted_complex(:,orb),pt,square=TRUE)
        gr = gc
        gc.destroy
      end
      .dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_density_grid")
      gr.destroy
      pt.destroy
   end

   make_orbital_grid
   ! Work out the orbital on ".grid" using ".natural orbitals" for orbital "orb"
   ! A Gnuplot ascii file is generated.
   ENSURE(.grid.created, "no grid")
   ENSURE(.grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      arch :: ARCHIVE
      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      gc :: VEC{CPX}*
      orb :: INT
      orb = .grid.orbital
      pt.create(.grid.n_pt,3); .grid.make_points(pt)
      if (.natural_orbitals.number_kind == "real") then
         gr.create(.grid.n_pt)
         .make_orbital_grid_r(gr,.natural_orbitals.restricted(:,orb),pt)
         .dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
         gr.destroy
      else
         gc.create(.grid.n_pt)
         .make_orbital_grid_c(gc,.natural_orbitals.restricted_complex(:,orb),pt)
         arch.set(.name,"orbital_"//trim(orb.to_str)//"_grid")
         arch.write(gc)
         arch.set(.name,"orbital_"//trim(orb.to_str)//"_grid",format="ascii")
         ! arch.write_gnuplot(gc, .grid.n_x, .grid.n_y, .grid.n_z)
         gc.destroy
      end
      pt.destroy
   end

   make_orbital_grid_r(g,orb,pt,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt"
      g :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      square :: BIN, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,fa,la,a :: INT
      sq = FALSE
      if (present(square)) sq = square
      n_pt = pt.dim1
      g = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g = g + matmul(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      if (sq) g = g*g
   end

   make_orbital_grid_c(g,orb,pt,square)
   ! Evaluate the orbital density for *one* AO-basis orbital coefficient vector
   ! "orb" on a set of grid points "pt"
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN, target
      pt :: MAT{REAL}, IN
      square :: BIN, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      sq :: BIN
      sh :: SHELL1*
      sh_grid :: MAT{REAL}*
      n_pt,fa,la,a :: INT
      sq = FALSE
      if (present(square)) sq = square
      n_pt = pt.dim1
      g = ZERO
      sh.create
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g = g + matmul(sh_grid,orb(fa:la))
         sh_grid.destroy
         sh.destroy_ptr_part
      end
      sh.destroy
      if (sq) g = conjg(g)*g
   end

! ***************************
! Nabla density grid routines
! ***************************

!   make_nabla_density_grid_fdm_r(nabla_grid,pts)
!   ! Work out the nabla density on ".grid" using ".natural orbitals" and the
!   ! ".occupation" number vector.
!   ! This method uses the finite difference method to calculate the gradient
!   ! from the density.  It is much slower, but useful for checking.
!     nabla_grid, pts :: MAT{REAL}
!   ENSURE(pts.dim2==3,  "wrong dimension for points array")
!   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
!     orb :: VEC{REAL}*
!     dens_1,dens_2,nabla_orb,comp :: VEC{REAL}*
!     pt1 :: MAT{REAL}*
!     alpha :: REAL
!     n_occ,n,n_pts,i :: INT
!     alpha = TOL(6)
!     n_pts = size(pts,1)
!     pt1.create(n_pts,3)
!     nabla_grid = ZERO
!     orb.create(n_pts)
!     dens_1.create(n_pts)
!     dens_2.create(n_pts)
!     nabla_orb.create(n_pts)
!     n_occ = .no_of_occupied_NOs
!     do n = 1,n_occ
!        do i = 1,3
!          comp => pt1(:,i)
!          pt1 = pts;    comp = comp + alpha
!          .make_orbital_grid_r(dens_1,.natural_orbitals.restricted(:,n),pt1,square=TRUE)
!          pt1 = pts;    comp = comp - alpha
!          .make_orbital_grid_r(dens_2,.natural_orbitals.restricted(:,n),pt1,square=TRUE)
!          nabla_orb = HALF/alpha * (dens_1 - dens_2)
!          .make_orbital_grid_r(orb,.natural_orbitals.restricted(:,n), pts)
!          nabla_grid(:,i) = nabla_grid(:,i) + .occupation_numbers.restricted(n)*orb(:)*nabla_orb
!        end
!     end
!     nabla_grid = TWO*nabla_grid
!     nabla_orb.destroy
!     dens_2.destroy
!     dens_1.destroy
!     orb.destroy
!     pt1.destroy
!   end

   make_nabla_density_grid(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid" on the set of point "pts".
      nabla_grid :: MAT{REAL}, OUT
      pts :: MAT{REAL}, IN
      if (.natural_orbitals.number_kind == "real") then
         .make_nabla_density_grid_r(nabla_grid,pts)
      !else
      !   .make_nabla_density_grid_c(nabla_grid,pts)
      end
   end

   make_nabla_density_grid(nabla_grid,grid,pts)
   ! Work nabla of the density, "nabla_grid", and the density, "grid, evaluated
   ! on the set of points "pts".
      nabla_grid :: MAT{REAL}, OUT
      grid :: VEC{REAL}, OUT
      pts :: MAT{REAL}, IN
      if (.natural_orbitals.number_kind == "real") then
         .make_nabla_density_grid_r(nabla_grid,grid,pts)
      !else
      !   .make_nabla_density_grid_c(nabla_grid,pts)
      end
   end

   make_nabla_density_grid_r(nabla_grid,pts)
   ! Work out nabla of the density, "nabla_grid", on the grid "pts" using
   ! ".natural_orbitals" and the ".occupation" number vector.
     nabla_grid :: MAT{REAL}, OUT
     pts :: MAT{REAL}, IN
   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
     orb :: VEC{REAL}*
     nabla_orb :: MAT{REAL}*
     occ :: REAL
     n_occ,n,n_pts :: INT
     n_pts = size(pts,1)
     nabla_grid = ZERO
     orb.create(n_pts)
     nabla_orb.create(n_pts,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
     end
     nabla_grid = TWO*nabla_grid
     orb.destroy
     nabla_orb.destroy
   end

   make_nabla_density_grid_r(nabla_grid,grid,pts)
   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
   ! using the grid "pts" and the ".natural_orbitals" and the ".occupation"
   ! number vector.
     nabla_grid :: MAT{REAL}, OUT
     grid :: VEC{REAL}, OUT
     pts :: MAT{REAL}, IN
   ENSURE(pts.dim2==3,  "wrong dimension for points array")
   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
     orb :: VEC{REAL}*
     nabla_orb :: MAT{REAL}*
     occ :: REAL
     n_occ,n,n_pts :: INT
     n_pts = size(pts,1)
     nabla_grid = ZERO
     grid = ZERO
     orb.create(n_pts)
     nabla_orb.create(n_pts,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
       occ = .occupation_numbers.restricted(n)
       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
       grid(:) = grid(:) + occ*orb(:)*orb(:)
     end
     nabla_grid = TWO*nabla_grid
     orb.destroy
     nabla_orb.destroy
   end

   make_nabla_orbital_grid_r(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{REAL}
      h :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")
      orb_a :: VEC{REAL}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_pt,fa,la,a :: INT
      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         orb_a => orb(fa:la)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h = h + matmul(sh_grid0,orb_a)
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_nabla_orbital_grid_c(g,h,orb,pt)
   ! Evaluate the nabla orbital density grid "g" as well as the orbital grid "h"
   ! for *one* AO-basis orbital vector "orb" on a set of grid points "pt"
      g :: MAT{CPX}
      h :: VEC{CPX}
      orb :: VEC{CPX}, IN, target
      pt :: MAT{REAL}, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(g.dim1==pt.dim1,"grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,"grid array has wrong 2nd dimension")
   ENSURE(h.dim==pt.dim1,"grid array has wrong 1st dimension")
      orb_a :: VEC{CPX}*
      sh :: SHELL1
      sh_grid :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      n_pt,fa,la,a :: INT
      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_nabla_grid(sh_grid,sh_grid0,pt)
         orb_a => orb(fa:la)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h = h + matmul(sh_grid0,orb_a)
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

! *******************************
! Laplacian density grid routines
! *******************************

   make_laplacian_orbital_grid_r(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{REAL}
      i :: VEC{REAL}
      orb :: VEC{REAL}, IN, target
      pt :: MAT{REAL}, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")
      sh :: SHELL1
      sh_grid,sh_grid1 :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      orb_a :: VEC{REAL}*
      n_pt,fa,la,a :: INT
      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      i = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid1.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)
         orb_a => orb(fa:la)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h(:,1) = h(:,1) + matmul(sh_grid1(:,:,1),orb_a)
         h(:,2) = h(:,2) + matmul(sh_grid1(:,:,2),orb_a)
         h(:,3) = h(:,3) + matmul(sh_grid1(:,:,3),orb_a)
         i = i + matmul(sh_grid0,orb_a)
         sh_grid1.destroy
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

   make_laplacian_orbital_grid_c(g,h,i,orb,pt)
   ! Evaluate the laplacian orbital density grid "g", as well as the nabla
   ! orbital grid "h" and the orbital grid "i" for *one* AO-basis orbital
   ! vector "orb" on a set of grid points "pt"
      g,h :: MAT{CPX}
      i :: VEC{CPX}
      orb :: VEC{CPX}, IN, target
      pt :: MAT{REAL}, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(g.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(g.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(h.dim1==pt.dim1, "grid array has wrong 1st dimension")
   ENSURE(h.dim2==3,        "grid array has wrong 2nd dimension")
   ENSURE(i.dim==pt.dim1,  "grid array has wrong 1st dimension")
      sh :: SHELL1
      sh_grid,sh_grid1 :: MAT3{REAL}*
      sh_grid0 :: MAT{REAL}*
      orb_a :: VEC{CPX}*
      n_pt,fa,la,a :: INT
      n_pt = pt.dim1
      g = ZERO
      h = ZERO
      i = ZERO
      do a = 1,.n_shell
         .get_shell(sh,a,fa,la)
         sh_grid.create(n_pt,sh.n_comp,3)
         sh_grid1.create(n_pt,sh.n_comp,3)
         sh_grid0.create(n_pt,sh.n_comp)
         sh.make_laplacian_grid(sh_grid,sh_grid1,sh_grid0,pt)
         orb_a => orb(fa:la)
         g(:,1) = g(:,1) + matmul(sh_grid(:,:,1),orb_a)
         g(:,2) = g(:,2) + matmul(sh_grid(:,:,2),orb_a)
         g(:,3) = g(:,3) + matmul(sh_grid(:,:,3),orb_a)
         h(:,1) = h(:,1) + matmul(sh_grid1(:,:,1),orb_a)
         h(:,2) = h(:,2) + matmul(sh_grid1(:,:,2),orb_a)
         h(:,3) = h(:,3) + matmul(sh_grid1(:,:,3),orb_a)
         i = i + matmul(sh_grid0,orb_a)
         sh_grid1.destroy
         sh_grid0.destroy
         sh_grid.destroy
         sh.destroy_ptr_part
      end
   end

! ***************************************************
! Specialist DFT grid density, nabla density routines
! ***************************************************

   make_density_grid_r_B(rho0,pt,atoms,a0,b0)
   ! Evaluate the density grid "rho0" at the grid points "pt", for use in matrix
   ! elements needed by DFT grid integration.  "atoms" is a list of indices of
   ! the atoms whose grid points are to be used in DFT integrations.  "a0" and
   ! "b0" are the basis function grids for the atoms listed in "atoms".  These
   ! are the grids for the atoms whose matrix elements are to be evaluated. We
   ! don't have to calculate the density contributions for any atoms which do
   ! not have basis functions which overlap with those in "atoms", because the
   ! orbital density from those atoms evaluated at those in the "atoms" list
   ! will be negligible. NOTE: this routine depends on having the
   ! .overlapping_atoms array defined. NOTE: it depends on having the natural
   ! orbitals defined, and it may take much more memory than version A above,
   ! but it may be quicker.
      rho0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a0,b0 :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho0.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no restrictd occupation numbers")
      sh :: SHELL1
      g0,sh_grid0,NO :: MAT{REAL}*
      n_pt,n_occ,a,s,f,l,fs,ls,n :: INT
      occ :: REAL
      n_pt = pt.dim1
      n_occ = .occupation_numbers.no_of_occupied("restricted")
      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      g0.create(n_pt,n_occ)
      g0 = ZERO
      do a = 1,.n_atom
         if (any(a==atoms)) then                                ! Use the supplied grids
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NO => .natural_orbitals.restricted(f:l,:n_occ)      ! Multiply by all orbitals
            if (a==atoms(1)) then; g0 = g0 + matmul(a0,NO)      ! Re-use a0
            else;                  g0 = g0 + matmul(b0,NO)      ! Re-use b0
            end
         else if (.is_overlapping_atom(a,atoms)) then           ! Do only overlapping atoms
            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
               .get_shell(sh,s,fs,ls)
               sh_grid0.create(n_pt,sh.n_comp)
               sh.make_grid(sh_grid0,pt)                        ! Call this as little as possible
               NO => .natural_orbitals.restricted(fs:ls,:n_occ) ! Multiply by all orbitals
               g0 = g0 + matmul(sh_grid0,NO)
               sh_grid0.destroy
               sh.destroy_ptr_part
            end
         end
      end
      ! Now square up each natural orbital. We can't skip any NO's since they
      ! could be all delocalised.
      rho0 = ZERO
      do n = 1,n_occ
         occ = .occupation_numbers.restricted(n)
         rho0 = rho0 + occ*g0(:,n)*g0(:,n)
      end
      g0.destroy
   end

   make_density_grid_u_B(rho0a,rho0b,pt,atoms,a0,b0)
   ! Evaluate the alpha and beta density grids "rho0a" and "rho0b" at the grid
   ! points "pt", for use in matrix elements needed by DFT grid integration.
   ! "atoms" is a list of indices of the atoms whose grid points are to be used
   ! in DFT integrations.  "a0" and "b0" are the basis function grids for the
   ! atoms listed in "atoms".  These are the grids for the atoms whose matrix
   ! elements are to be evaluated. We don't have to calculate the density
   ! contributions for any atoms which do not have basis functions which overlap
   ! with those in "atoms", because the orbital density from those atoms
   ! evaluated at those in the "atoms" list will be negligible. NOTE: this
   ! routine depends on having the .overlapping_atoms array defined. NOTE: it
   ! depends on having the natural orbitals defined, and it may take much more
   ! memory than version A above, but it may be quicker.
      rho0a,rho0b :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a0,b0 :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(rho0b.dim==pt.dim1,"rho0b has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("unrestricted"), "no unrestricted NO's")
   ENSURE(.occupation_numbers.created("unrestricted"),"no unrestrictd occupation numbers")
      sh :: SHELL1
      g0a,g0b,sh_grid0,NOa,NOb :: MAT{REAL}*
      n_pt,na,nb,a,s,f,l,fs,ls,n :: INT
      occ :: REAL
      n_pt = pt.dim1
      na = .occupation_numbers.no_of_occupied("alpha")
      nb = .occupation_numbers.no_of_occupied("beta")
      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      g0a.create(n_pt,na)
      g0b.create(n_pt,nb)
      g0a = ZERO
      g0b = ZERO
      do a = 1,.n_atom
         if (any(a==atoms)) then                                ! Use the supplied grids
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NOa => .natural_orbitals.alpha(f:l,:na)             ! Multiply by all orbitals
            NOb => .natural_orbitals.beta(f:l,:nb)     
            if (a==atoms(1)) then
               g0a = g0a + matmul(a0,NOa)                       ! Re-use a0
               g0b = g0b + matmul(a0,NOb)
            else
               g0a = g0a + matmul(b0,NOa)                       ! Re-use b0
               g0b = g0b + matmul(b0,NOb)
            end
         else if (.is_overlapping_atom(a,atoms)) then           ! Do only overlapping atoms
            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
               .get_shell(sh,s,fs,ls)
               sh_grid0.create(n_pt,sh.n_comp)
               sh.make_grid(sh_grid0,pt)                        ! Call this as little as possible
               NOa => .natural_orbitals.alpha(fs:ls,:na)        ! Multiply by all orbitals
               NOb => .natural_orbitals.beta(fs:ls,:nb)     
               g0a = g0a + matmul(sh_grid0,NOa)
               g0b = g0b + matmul(sh_grid0,NOb)
               sh_grid0.destroy
               sh.destroy_ptr_part
            end
         end
      end
      ! Now square up each natural orbital. We can't skip any NO's since they
      ! could be all delocalised.
      rho0a = ZERO
      rho0b = ZERO
      do n = 1,na
         occ = .occupation_numbers.alpha(n)
         rho0a = rho0a + occ*g0a(:,n)*g0a(:,n)
      end
      do n = 1,nb
         occ = .occupation_numbers.beta(n)
         rho0b = rho0b + occ*g0b(:,n)*g0b(:,n)
      end
      g0b.destroy
      g0a.destroy
   end


!   make_nabla_density_grid_r(grid1,grid0,pt,atoms)
!   ! Evaluate the nabla orbital density grid "g1" as well as the orbital grid
!   ! "g0" on a set of grid points "pt", for use in matrix elements needed by DFT
!   ! grid integration. "atoms" lists the atoms whose grid points are to be used
!   ! in DFT integrations.  Normally they will be the atoms on which the basis
!   ! functions are centered.  We don't have to calculate the density
!   ! contributions for any atoms which do not have basis functions which overlap
!   ! with those in "atoms", because the orbital density from those atoms
!   ! evaluated at those in the "atoms" list will be negligible. NOTE: this
!   ! routine depends on having the .overlapping_atoms array defined. NOTE: it
!   ! does noot depend on having the natural orbitals defined.
!      grid1 :: MAT{REAL}
!      grid0 :: VEC{REAL}
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
!   ENSURE(grid1.dim1==pt.dim1,"grid1 has wrong 1st dimension")
!   ENSURE(grid1.dim2==3,"grid1 has wrong 2nd dimension")
!   ENSURE(grid0.dim==pt.dim1,"grid0 has wrong 1st dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!      sha,shb :: SHELL1
!      a1 :: MAT3{REAL}*
!      a0,b0,bP :: MAT{REAL}*
!      n_pt,a,sa,fa,la,b,sb,fb,lb :: INT
!      fac :: REAL
!      grid1 = ZERO
!      grid0 = ZERO
!      n_pt = pt.dim1
!         do sa = 1,.n_shell
!            .get_shell(sha,sa,fa,la)
!            a1.create(n_pt,sha.n_comp,3)
!            a0.create(n_pt,sha.n_comp)
!            sha.make_nabla_grid(a1,a0,pt)         ! Call this as little as possible
!               do sb = 1,.n_shell
!                  .get_shell(shb,sb,fb,lb)
!                  bP.create(n_pt,sha.n_comp)
!                  b0.create(n_pt,shb.n_comp)
!                  shb.make_grid(b0,pt)            ! Call this as little as possible
!                  bP = matmul(b0,.density_matrix.restricted(fb:lb,fa:la))
!                  b0.destroy
!                  grid0      = grid0      + sum(a0*bP,dim=2)
!                  grid1(:,1) = grid1(:,1) + sum(a1(:,:,1)*bP,dim=2)
!                  grid1(:,2) = grid1(:,2) + sum(a1(:,:,2)*bP,dim=2)
!                  grid1(:,3) = grid1(:,3) + sum(a1(:,:,3)*bP,dim=2)
!                  bP.destroy
!                  shb.destroy_ptr_part
!               end
!            a0.destroy; a1.destroy
!            sha.destroy_ptr_part
!         end
!      grid1 = TWO*grid1
!   end

!   make_nabla_density_grid_r(nabla_grid,grid,pts,atoms)
!   ! Work out nabla of the density, "nabla_grid", and the density grid, "grid",
!   ! using the grid "pts" and the ".natural_orbitals" and the ".occupation"
!   ! number vector. This version eliminates any extra work due to atoms which do
!   ! not overlap with "atoms". It is intended for use with DFT grid integration
!   ! of the exchange correlation matrix elements, where "atoms" are the atoms on
!   ! which the basis functions are centered.
!     nabla_grid :: MAT{REAL}, OUT
!     grid :: VEC{REAL}, OUT
!     pts :: MAT{REAL}, IN
!     atoms :: VEC{INT}
!   ENSURE(pts.dim2==3,  "wrong dimension for points array")
!   ENSURE(nabla_grid.dim2==3,  "wrong dimension for nabla_grid array")
!   ENSURE(nabla_grid.dim1==pts.dim1,"wrong dimension for nabla_grid array")
!   ENSURE(grid.dim==pts.dim1,"wrong dimension for grid array")
!   ENSURE(.natural_orbitals.created, "no natural orbitals")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created, "no occupation numbers")
!   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
!     orb :: VEC{REAL}*
!     nabla_orb :: MAT{REAL}*
!     occ :: REAL
!     n_occ,n,n_pts :: INT
!     n_pts = size(pts,1)
!     nabla_grid = ZERO
!     grid = ZERO
!     orb.create(n_pts)
!     nabla_orb.create(n_pts,3)
!     n_occ = .no_of_occupied_NOs
!     do n = 1,n_occ
!       .make_nabla_orbital_grid_r(nabla_orb,orb,.natural_orbitals.restricted(:,n), pts)
!       occ = .occupation_numbers.restricted(n)
!       nabla_grid(:,1) = nabla_grid(:,1) + occ*orb(:)*nabla_orb(:,1)
!       nabla_grid(:,2) = nabla_grid(:,2) + occ*orb(:)*nabla_orb(:,2)
!       nabla_grid(:,3) = nabla_grid(:,3) + occ*orb(:)*nabla_orb(:,3)
!       grid(:) = grid(:) + occ*orb(:)*orb(:)
!     end
!     nabla_grid = TWO*nabla_grid
!     orb.destroy
!     nabla_orb.destroy
!   end


!   make_nabla_density_grid_r_A(grid1,grid0,pt,atoms,ex)
!   ! Evaluate the nabla density grid "grid1" and density grid "grid0" on a set
!   ! of grid points "pt", for use in matrix elements needed by DFT grid
!   ! integration. "atoms" lists the atoms whose grid points are to be used in
!   ! DFT matrix element integration.  Normally they will be the atom-pair
!   ! corresponding to the basis function pair in the matrix element. We don't
!   ! have to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it does not depend on having the natural orbitals
!   ! defined.
!      grid1 :: MAT{REAL}, OUT
!      grid0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      ex :: VEC{REAL}, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
!   ENSURE(grid1.dim1==pt.dim1,"grid1 has wrong 1st dimension")
!   ENSURE(grid1.dim2==3,"grid1 has wrong 2nd dimension")
!   ENSURE(grid0.dim==pt.dim1,"grid0 has wrong 1st dimension")
!   ENSURE(ex.dim==pt.dim1,"ex has wrong dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!      xa,ya,za,aa,xb,yb,zb,bb :: VEC{REAL}*
!      keep  :: VEC{BIN}*
!      sha,shb :: SHELL1
!      a0,a1,a2,a3,b0,bP :: MAT{REAL}*
!      atom_a,sa,fsa,lsa,fa,la,atom_b,sb,fsb,lsb,fb,lb, n_pt,na,nb,i,j :: INT
!      cutoff,val,ea,eb,fac :: REAL
!      cutoff = -log(.becke_grid.rho_cutoff)              ! Cutoff
!      keep.create(pt.dim1)
!      sha.nullify_ptr_part
!      shb.nullify_ptr_part
!      grid1 = ZERO
!      grid0 = ZERO
!      ! Loop over density basis functions "a" and "b". Keep only significant
!      ! points at each stage using a density cutoff not basis function cutoff.
!      do atom_a = 1,.n_atom                                 
!         if (NOT .is_overlapping_atom(atom_a,atoms)) cycle  
!         fsa = .first_shell_for_atom(atom_a)
!         lsa = .last_shell_for_atom(atom_a)
!         .atom(atom_a).make_displaced_points(xa,ya,za,aa,pt,create=TRUE)
!         do atom_b = 1,atom_a
!            if (NOT .is_overlapping_atom(atom_b,atoms)) cycle
!            if (NOT .is_overlapping_atom(atom_a,atom_b)) cycle     ! Only atom pairs which overlap
!            fsb = .first_shell_for_atom(atom_b)
!            lsb = .last_shell_for_atom(atom_b)
!            .atom(atom_b).make_displaced_points(xb,yb,zb,bb,pt,create=TRUE)
!            do sa = fsa,lsa
!               .get_shell(sha,sa,fa,la)
!               na = sha.n_comp
!               ea = minval(sha.ex)
!               do sb = fsb,min(sa,lsb)
!                  .get_shell(shb,sb,fb,lb)
!                  nb = shb.n_comp
!                  eb = minval(shb.ex)
!                  keep = ea*aa+eb*bb<=cutoff
!                  keep = TRUE
!                  n_pt = count(keep)                                   ! # of significant points
!    ! stdout.text("============")
!    ! stdout.show("atom_a=",atom_a)
!    ! stdout.show("atom_b=",atom_b)
!    ! stdout.show("sa=",sa)
!    ! stdout.show("sb=",sb)
!    ! stdout.show("cutoff=",cutoff)
!    ! stdout.show("n_pt0 =",n_pt)
!    ! stdout.text("============")
!                  if (n_pt>0) then
!                     fac = TWO
!                     if (sa==sb) fac = ONE
!                     a0.create(n_pt,na)
!                     a1.create(n_pt,na); a2.create(n_pt,na); a3.create(n_pt,na)
!                     sha.make_nabla_grid(a1,a2,a3,a0,xa,ya,za,aa,keep) 
!                     bP.create(n_pt,na)
!                     b0.create(n_pt,nb)
!                     shb.make_grid(b0,xb,yb,zb,bb,keep)
!                     bP = matmul(b0,.density_matrix.restricted(fb:lb,fa:la))
!                     b0.destroy
!                     do j = 1,na
!                     do i = 1,n_pt
!                        val = fac*bP(i,j)
!                        grid0(i)   = grid0(i)   + a0(i,j)*val
!                        grid1(i,1) = grid1(i,1) + a1(i,j)*val
!                        grid1(i,2) = grid1(i,2) + a2(i,j)*val
!                        grid1(i,3) = grid1(i,3) + a3(i,j)*val
!                     end
!                     end
!                     bP.destroy
!                     a0.destroy; a3.destroy; a2.destroy; a1.destroy
!                  end
!                  shb.destroy_ptr_part
!               end
!               sha.destroy_ptr_part
!            end
!            .atom(atom_b).tidy_displaced_points(xb,yb,zb,bb)
!         end
!         .atom(atom_a).tidy_displaced_points(xa,ya,za,aa)
!      end
!      keep.destroy
!      grid1 = TWO*grid1
!   end

!   make_nabla_density_grid_r_A(grid1,grid0,pt,atoms)
!   ! Evaluate the nabla density grid "grid1" as well as the density grid "grid0"
!   ! on a set of grid points "pt", for use in matrix elements needed by DFT grid
!   ! integration. "atoms" lists the atoms whose grid points are to be used in
!   ! DFT matrix element integration.  Normally they will be the atom-pair
!   ! corresponding to the basis function pair in the matrix element. We don't
!   ! have to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it does not depend on having the natural orbitals
!   ! defined.
!      grid1 :: MAT{REAL}, OUT
!      grid0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.density_matrix.restricted.created,"no restricted density matrix")
!   ENSURE(grid1.dim1==pt.dim1,"grid1 has wrong 1st dimension")
!   ENSURE(grid1.dim2==3,"grid1 has wrong 2nd dimension")
!   ENSURE(grid0.dim==pt.dim1,"grid0 has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!      sha,shb :: SHELL1
!      a1 :: MAT3{REAL}*
!      a0,b0,bP :: MAT{REAL}*
!      n_pt,a,sa,fa,la,b,sb,fb,lb :: INT
!      fac :: REAL
!      grid1 = ZERO
!      grid0 = ZERO
!      n_pt = pt.dim1
!      do a = 1,.n_atom
!         if (NOT .is_overlapping_atom(a,atoms)) cycle
!         do sa = .first_shell_for_atom(a),.last_shell_for_atom(a)
!            .get_shell(sha,sa,fa,la)
!            a1.create(n_pt,sha.n_comp,3)
!            a0.create(n_pt,sha.n_comp)
!            sha.make_nabla_grid(a1,a0,pt)         ! Call this as little as possible
!            do b = 1,.n_atom
!               if (NOT .is_overlapping_atom(b,atoms)) cycle
!               do sb = .first_shell_for_atom(b),.last_shell_for_atom(b)
!                  .get_shell(shb,sb,fb,lb)
!                  bP.create(n_pt,sha.n_comp)
!                  b0.create(n_pt,shb.n_comp)
!                  shb.make_grid(b0,pt)            ! Call this as little as possible
!                  bP = matmul(b0,.density_matrix.restricted(fb:lb,fa:la))
!                  b0.destroy
!                  grid0      = grid0      + sum(a0*bP,dim=2)
!                  grid1(:,1) = grid1(:,1) + sum(a1(:,:,1)*bP,dim=2)
!                  grid1(:,2) = grid1(:,2) + sum(a1(:,:,2)*bP,dim=2)
!                  grid1(:,3) = grid1(:,3) + sum(a1(:,:,3)*bP,dim=2)
!                  bP.destroy
!                  shb.destroy_ptr_part
!               end
!            end
!            a0.destroy; a1.destroy
!            sha.destroy_ptr_part
!         end
!      end
!      grid1 = TWO*grid1
!   end


   make_nabla_density_grid_r_B(grid1,grid0,pt,atoms)
   ! Evaluate the nabla density grid "grid1" as well as the density grid
   ! "grid0" on a set of grid points "pt", for use in matrix elements needed by
   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
   ! points are to be used in DFT integrations.  Normally they will be the atoms
   ! on which the basis functions are centered.  We don't have to calculate the
   ! density contributions for any atoms which do not have basis functions which
   ! overlap with those in "atoms", because the orbital density from those atoms
   ! evaluated at those in the "atoms" list will be negligible. NOTE: this
   ! routine depends on having the .overlapping_atoms array defined. NOTE: it
   ! depends on having the natural orbitals defined, and it may take much more
   ! memory than the version above, but it may be quicker.
      grid1 :: MAT{REAL}, OUT
      grid0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(grid1.dim1==pt.dim1,"grid1 has wrong 1st dimension")
   ENSURE(grid1.dim2==3,"grid1 has wrong 2nd dimension")
   ENSURE(grid0.dim==pt.dim1,"grid0 has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
      sh :: SHELL1
      g1,sh_grid1 :: MAT3{REAL}*
      g0,sh_grid0,NO :: MAT{REAL}*
      n_pt,n_occ,a,s,fs,ls,n :: INT
      occ :: REAL
      n_pt = pt.dim1
      n_occ = .no_of_occupied_NOs
      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      g1.create(n_pt,n_occ,3)
      g0.create(n_pt,n_occ)
      g1 = ZERO
      g0 = ZERO
      do a = 1,.n_atom
         if (NOT .is_overlapping_atom(a,atoms)) cycle        ! Do only overlapping atoms
         do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
            .get_shell(sh,s,fs,ls)
            sh_grid1.create(n_pt,sh.n_comp,3)
            sh_grid0.create(n_pt,sh.n_comp)
            sh.make_nabla_grid(sh_grid1,sh_grid0,pt)         ! Call this as little as possible
            NO => .natural_orbitals.restricted(fs:ls,:n_occ) ! Multiply by all orbitals
            g1(:,:,1) = g1(:,:,1) + matmul(sh_grid1(:,:,1),NO)
            g1(:,:,2) = g1(:,:,2) + matmul(sh_grid1(:,:,2),NO)
            g1(:,:,3) = g1(:,:,3) + matmul(sh_grid1(:,:,3),NO)
            g0        = g0        + matmul(sh_grid0,NO)
            sh_grid0.destroy
            sh_grid1.destroy
            sh.destroy_ptr_part
         end
      end
      ! Now square up each natural orbital. We can't skip any NO's since they
      ! could be all delocalised.
      grid1 = ZERO
      grid0 = ZERO
      do n = 1,n_occ
         occ = .occupation_numbers.restricted(n)
         grid1(:,1) = grid1(:,1) + occ*g0(:,n)*g1(:,n,1)
         grid1(:,2) = grid1(:,2) + occ*g0(:,n)*g1(:,n,2)
         grid1(:,3) = grid1(:,3) + occ*g0(:,n)*g1(:,n,3)
         grid0      = grid0      + occ*g0(:,n)*g0(:,n)
      end
      g0.destroy; g1.destroy
      grid1 = TWO*grid1
   end

   make_nabla_density_grid_r_B(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)
   ! Evaluate the nabla density grid "rho1" as well as the density grid
   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
   ! the basis function grids for the atoms listed in "atoms". These are the
   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
   ! to calculate the density contributions for any atoms which do not have
   ! basis functions which overlap with those in "atoms", because the orbital
   ! density from those atoms evaluated at those in the "atoms" list will be
   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
   ! array defined. NOTE: it depends on having the natural orbitals defined, and
   ! it may take much more memory than version A above, but it may be quicker.
      rho1 :: MAT{REAL}, OUT
      rho0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a1,b1 :: MAT3{REAL}
      a0,b0 :: MAT{REAL}
      ma,mb :: INT, IN
      cutoff :: REAL, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
      sh :: SHELL1
      shell :: VEC{SHELL}*
      pos :: VEC{REAL}(3) 
      skip :: VEC{BIN}*
      list :: VEC{INT}*
      x,y,z,r2 :: VEC{REAL}*
      g1,gg1,sh_grid1 :: MAT3{REAL}*
      g0,gg0,sh_grid0,NO :: MAT{REAL}*
      n_pt,n_cut,n_occ,aa,a,s,f,l,fs,ls,n, i,k :: INT
      do_a,do_b :: BIN
      cut,occ :: REAL
      cut = cutoff
      n_pt = pt.dim1
      n_occ = .occupation_numbers.no_of_occupied("restricted")
      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      list => .overlapping_atoms_for(atoms)
      g1.create(n_pt,n_occ,3)
      g0.create(n_pt,n_occ)
      g1 = ZERO
      g0 = ZERO
      do aa = 1,list.dim
         a = list(aa)
         if (any(a==atoms)) then                               ! Use the supplied grids
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NO => .natural_orbitals.restricted(f:l,:n_occ)     ! Multiply by all orbitals
            if (a==atoms(1)) then
               g1(:,:,1) = g1(:,:,1) + matmul(a1(:,:,1),NO)
               g1(:,:,2) = g1(:,:,2) + matmul(a1(:,:,2),NO)
               g1(:,:,3) = g1(:,:,3) + matmul(a1(:,:,3),NO)
               g0        = g0        + matmul(a0,NO)
            else
               g1(:,:,1) = g1(:,:,1) + matmul(b1(:,:,1),NO)
               g1(:,:,2) = g1(:,:,2) + matmul(b1(:,:,2),NO)
               g1(:,:,3) = g1(:,:,3) + matmul(b1(:,:,3),NO)
               g0        = g0        + matmul(b0,NO)
            end
         else                                                  ! Do only overlapping atoms
            do_a = .is_overlapping_atom(a,atoms(1))
            if (atoms.dim==1) then; do_b = TRUE
            else;                   do_b = .is_overlapping_atom(a,atoms(2))
            end
            pos = .atom(a).pos
            shell => .atom(a).basis.shell
            ls = .first_basis_fn_for_atom(a) - 1
            if (do_a AND do_b) then                            ! Both overlap
               do s = 1,shell.dim
                  sh.set(shell(s),pos)
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  sh.make_significant_points(x,y,z,r2,skip,pt,cut)
                  if (x.destroyed) cycle
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)   ! Call this as little as possible
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ) ! Multiply by all orbitals
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)
                  k = 0
                  do i = 1,n_pt
                     if (skip(i)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end
                  gg0.destroy; gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
               end
            else if (do_a) then                               ! Only the first overlaps
               do s = 1,shell.dim
                  sh.set(shell(s),pos)
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  sh.make_significant_points(x,y,z,r2,skip,pt(:ma,:),cut)
                  if (x.destroyed) cycle
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)    ! Call this as little as possible
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ)  ! Multiply by all orbitals
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)
                  k = 0
                  do i = 1,ma
                     if (skip(i)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end
                  gg0.destroy; gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
               end
            else if (atoms.dim==2 AND do_b) then               ! Only the second overlaps
               do s = 1,shell.dim
                  sh.set(shell(s),pos)
                  fs = ls + 1
                  ls = ls + sh.n_comp
                  sh.make_significant_points(x,y,z,r2,skip,pt(ma+1:,:),cut)
                  if (x.destroyed) cycle
                  n_cut = x.dim
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2)   ! Call this as little as possible
                  NO => .natural_orbitals.restricted(fs:ls,:n_occ) ! Multiply by all orbitals
                  gg1.create(n_cut,n_occ,3)
                  gg0.create(n_cut,n_occ)
                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
                  gg0        = matmul(sh_grid0,NO)
                  k = 0
                  do i = ma+1,n_pt
                     if (skip(i-ma)) cycle
                     k = k + 1
                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
                     g0(i,:)   = g0(i,:)   + gg0(k,:)
                  end
                  gg0.destroy; gg1.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
               end
            end
         end
      end
      ! Now square up each natural orbital. We can't skip any NO's since they
      ! could be all delocalised.
      rho1 = ZERO
      rho0 = ZERO
      do n = 1,n_occ
         occ = .occupation_numbers.restricted(n)
         rho1(:,1) = rho1(:,1) + occ*g0(:,n)*g1(:,n,1)
         rho1(:,2) = rho1(:,2) + occ*g0(:,n)*g1(:,n,2)
         rho1(:,3) = rho1(:,3) + occ*g0(:,n)*g1(:,n,3)
         rho0      = rho0      + occ*g0(:,n)*g0(:,n)
      end
      g0.destroy; g1.destroy; list.destroy
      rho1 = TWO*rho1
   end

!   make_nabla_density_grid_r_B_good(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)
!   ! Evaluate the nabla density grid "rho1" as well as the density grid
!   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
!   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
!   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
!   ! the basis function grids for the atoms listed in "atoms". These are the
!   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
!   ! to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it depends on having the natural orbitals defined, and
!   ! it may take much more memory than version A above, but it may be quicker.
!      rho1 :: MAT{REAL}, OUT
!      rho0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      a1,b1 :: MAT3{REAL}
!      a0,b0 :: MAT{REAL}
!      ma,mb :: INT, IN
!      cutoff :: REAL, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
!   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
!   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
!      sh :: SHELL1
!      skip :: VEC{BIN}*
!      list :: VEC{INT}*
!      x,y,z,r2 :: VEC{REAL}*
!      g1,gg1,sh_grid1 :: MAT3{REAL}*
!      g0,gg0,sh_grid0,NO :: MAT{REAL}*
!      n_pt,n_cut,n_occ,aa,a,s,f,l,fs,ls,n, i,k :: INT
!      do_a,do_b :: BIN
!      occ :: REAL
!      n_pt = pt.dim1
!      n_occ = .occupation_numbers.no_of_occupied("restricted")
!      ! Evaluate *all* the natural orbitals on the grid, to save calling
!      ! make_nabla_grid too many times
!      list => .overlapping_atoms_for(atoms)
!      g1.create(n_pt,n_occ,3)
!      g0.create(n_pt,n_occ)
!      g1 = ZERO
!      g0 = ZERO
!      do aa = 1,list.dim
!         a = list(aa)
!         if (any(a==atoms)) then                               ! Use the supplied grids
!            f = .first_basis_fn_for_atom(a)
!            l =  .last_basis_fn_for_atom(a)
!            NO => .natural_orbitals.restricted(f:l,:n_occ)     ! Multiply by all orbitals
!            if (a==atoms(1)) then
!               g1(:,:,1) = g1(:,:,1) + matmul(a1(:,:,1),NO)
!               g1(:,:,2) = g1(:,:,2) + matmul(a1(:,:,2),NO)
!               g1(:,:,3) = g1(:,:,3) + matmul(a1(:,:,3),NO)
!               g0        = g0        + matmul(a0,NO)
!            else
!               g1(:,:,1) = g1(:,:,1) + matmul(b1(:,:,1),NO)
!               g1(:,:,2) = g1(:,:,2) + matmul(b1(:,:,2),NO)
!               g1(:,:,3) = g1(:,:,3) + matmul(b1(:,:,3),NO)
!               g0        = g0        + matmul(b0,NO)
!            end
!         else                                                  ! Do only overlapping atoms
!            do_a = .is_overlapping_atom(a,atoms(1))
!            if (atoms.dim==1) then; do_b = TRUE
!            else;                   do_b = .is_overlapping_atom(a,atoms(2))
!            end
!            if (do_a AND do_b) then                            ! Both overlap
!               .atom(a).make_significant_points(x,y,z,r2,skip,pt,cutoff)
!               n_cut = x.dim
!               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!                  .get_shell(sh,s,fs,ls)
!                  sh_grid1.create(n_cut,sh.n_comp,3)
!                  sh_grid0.create(n_cut,sh.n_comp)
!                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
!                  NO => .natural_orbitals.restricted(fs:ls,:n_occ)   ! Multiply by all orbitals
!                  gg1.create(n_cut,n_occ,3)
!                  gg0.create(n_cut,n_occ)
!                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
!                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
!                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
!                  gg0        = matmul(sh_grid0,NO)
!                  k = 0
!                  do i = 1,n_pt
!                     if (skip(i)) cycle
!                     k = k + 1
!                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
!                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
!                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
!                     g0(i,:)   = g0(i,:)   + gg0(k,:)
!                  end
!                  gg0.destroy; gg1.destroy
!                  sh_grid0.destroy
!                  sh_grid1.destroy
!                  sh.destroy_ptr_part
!               end
!               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
!            else if (do_a) then                               ! Only the first overlaps
!               .atom(a).make_significant_points(x,y,z,r2,skip,pt(1:ma,:),cutoff)
!               n_cut = x.dim
!               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!                  .get_shell(sh,s,fs,ls)
!                  sh_grid1.create(n_cut,sh.n_comp,3)
!                  sh_grid0.create(n_cut,sh.n_comp)
!                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
!                  NO => .natural_orbitals.restricted(fs:ls,:n_occ)   ! Multiply by all orbitals
!                  gg1.create(n_cut,n_occ,3)
!                  gg0.create(n_cut,n_occ)
!                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
!                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
!                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
!                  gg0        = matmul(sh_grid0,NO)
!                  k = 0
!                  do i = 1,ma
!                     if (skip(i)) cycle
!                     k = k + 1
!                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
!                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
!                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
!                     g0(i,:)   = g0(i,:)   + gg0(k,:)
!                  end
!                  gg0.destroy; gg1.destroy
!                  sh_grid0.destroy
!                  sh_grid1.destroy
!                  sh.destroy_ptr_part
!               end
!               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
!            else if (atoms.dim==2 AND do_b) then               ! Only the second overlaps
!               .atom(a).make_significant_points(x,y,z,r2,skip,pt(ma+1:,:),cutoff)
!               n_cut = x.dim
!               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!                  .get_shell(sh,s,fs,ls)
!                  sh_grid1.create(n_cut,sh.n_comp,3)
!                  sh_grid0.create(n_cut,sh.n_comp)
!                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
!                  NO => .natural_orbitals.restricted(fs:ls,:n_occ)   ! Multiply by all orbitals
!                  gg1.create(n_cut,n_occ,3)
!                  gg0.create(n_cut,n_occ)
!                  gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
!                  gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
!                  gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
!                  gg0        = matmul(sh_grid0,NO)
!                  k = 0
!                  do i = ma+1,n_pt
!                     if (skip(i-ma)) cycle
!                     k = k + 1
!                     g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
!                     g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
!                     g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
!                     g0(i,:)   = g0(i,:)   + gg0(k,:)
!                  end
!                  gg0.destroy; gg1.destroy
!                  sh_grid0.destroy
!                  sh_grid1.destroy
!                  sh.destroy_ptr_part
!               end
!               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
!            end
!         end
!      end
!      ! Now square up each natural orbital. We can't skip any NO's since they
!      ! could be all delocalised.
!      rho1 = ZERO
!      rho0 = ZERO
!      do n = 1,n_occ
!         occ = .occupation_numbers.restricted(n)
!         rho1(:,1) = rho1(:,1) + occ*g0(:,n)*g1(:,n,1)
!         rho1(:,2) = rho1(:,2) + occ*g0(:,n)*g1(:,n,2)
!         rho1(:,3) = rho1(:,3) + occ*g0(:,n)*g1(:,n,3)
!         rho0      = rho0      + occ*g0(:,n)*g0(:,n)
!      end
!      g0.destroy; g1.destroy; list.destroy
!      rho1 = TWO*rho1
!   end

!   make_nabla_density_grid_r_B(rho1,rho0,pt,atoms,a1,a0,b1,b0,cutoff)
!   ! Evaluate the nabla density grid "rho1" as well as the density grid
!   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
!   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
!   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
!   ! the basis function grids for the atoms listed in "atoms". These are the
!   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
!   ! to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it depends on having the natural orbitals defined, and
!   ! it may take much more memory than version A above, but it may be quicker.
!      rho1 :: MAT{REAL}, OUT
!      rho0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      a1,b1 :: MAT3{REAL}
!      a0,b0 :: MAT{REAL}
!      cutoff :: REAL, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
!   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
!   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
!      sh :: SHELL1
!      skip :: VEC{BIN}*
!      x,y,z,r2 :: VEC{REAL}*
!      g1,gg1,sh_grid1 :: MAT3{REAL}*
!      g0,gg0,sh_grid0,NO :: MAT{REAL}*
!      n_pt,n_cut,n_occ,a,s,f,l,fs,ls,n, i,k :: INT
!      occ :: REAL
!      n_pt = pt.dim1
!      n_occ = .occupation_numbers.no_of_occupied("restricted")
!      ! Evaluate *all* the natural orbitals on the grid, to save calling
!      ! make_nabla_grid too many times
!      g1.create(n_pt,n_occ,3)
!      g0.create(n_pt,n_occ)
!      g1 = ZERO
!      g0 = ZERO
!      do a = 1,.n_atom
!         if (any(a==atoms)) then                               ! Use the supplied grids
!            f = .first_basis_fn_for_atom(a)
!            l =  .last_basis_fn_for_atom(a)
!            NO => .natural_orbitals.restricted(f:l,:n_occ)     ! Multiply by all orbitals
!            if (a==atoms(1)) then
!               g1(:,:,1) = g1(:,:,1) + matmul(a1(:,:,1),NO)
!               g1(:,:,2) = g1(:,:,2) + matmul(a1(:,:,2),NO)
!               g1(:,:,3) = g1(:,:,3) + matmul(a1(:,:,3),NO)
!               g0        = g0        + matmul(a0,NO)
!            else
!               g1(:,:,1) = g1(:,:,1) + matmul(b1(:,:,1),NO)
!               g1(:,:,2) = g1(:,:,2) + matmul(b1(:,:,2),NO)
!               g1(:,:,3) = g1(:,:,3) + matmul(b1(:,:,3),NO)
!               g0        = g0        + matmul(b0,NO)
!            end
!         else if (.is_overlapping_atom(a,atoms)) then           ! Do only overlapping atoms
!            .atom(a).make_significant_points(x,y,z,r2,skip,pt,cutoff)
!            n_cut = x.dim
!            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!               .get_shell(sh,s,fs,ls)
!               sh_grid1.create(n_cut,sh.n_comp,3)
!               sh_grid0.create(n_cut,sh.n_comp)
!               sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
!               NO => .natural_orbitals.restricted(fs:ls,:n_occ)   ! Multiply by all orbitals
!               gg1.create(n_cut,n_occ,3)
!               gg0.create(n_cut,n_occ)
!               gg1(:,:,1) = matmul(sh_grid1(:,:,1),NO)
!               gg1(:,:,2) = matmul(sh_grid1(:,:,2),NO)
!               gg1(:,:,3) = matmul(sh_grid1(:,:,3),NO)
!               gg0        = matmul(sh_grid0,NO)
!               k = 0
!               do i = 1,n_pt
!                  if (skip(i)) cycle
!                  k = k + 1
!                  g1(i,:,1) = g1(i,:,1) + gg1(k,:,1)
!                  g1(i,:,2) = g1(i,:,2) + gg1(k,:,2)
!                  g1(i,:,3) = g1(i,:,3) + gg1(k,:,3)
!                  g0(i,:)   = g0(i,:)   + gg0(k,:)
!               end
!               gg0.destroy; gg1.destroy
!               sh_grid0.destroy
!               sh_grid1.destroy
!               sh.destroy_ptr_part
!            end
!            x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
!         end
!      end
!      ! Now square up each natural orbital. We can't skip any NO's since they
!      ! could be all delocalised.
!      rho1 = ZERO
!      rho0 = ZERO
!      do n = 1,n_occ
!         occ = .occupation_numbers.restricted(n)
!         rho1(:,1) = rho1(:,1) + occ*g0(:,n)*g1(:,n,1)
!         rho1(:,2) = rho1(:,2) + occ*g0(:,n)*g1(:,n,2)
!         rho1(:,3) = rho1(:,3) + occ*g0(:,n)*g1(:,n,3)
!         rho0      = rho0      + occ*g0(:,n)*g0(:,n)
!      end
!      g0.destroy; g1.destroy
!      rho1 = TWO*rho1
!   end

!   make_nabla_density_grid_r_B(rho1,rho0,pt,atoms,a1,a0,b1,b0)
!   ! Evaluate the nabla density grid "rho1" as well as the density grid
!   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
!   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
!   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
!   ! the basis function grids for the atoms listed in "atoms". These are the
!   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
!   ! to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it depends on having the natural orbitals defined, and
!   ! it may take much more memory than version A above, but it may be quicker.
!      rho1 :: MAT{REAL}, OUT
!      rho0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      a1,b1 :: MAT3{REAL}
!      a0,b0 :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
!   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
!   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
!      sh :: SHELL1
!      g1,sh_grid1 :: MAT3{REAL}*
!      g0,sh_grid0,NO :: MAT{REAL}*
!      n_pt,n_occ,a,s,f,l,fs,ls,n :: INT
!      occ :: REAL
!      n_pt = pt.dim1
!      n_occ = .occupation_numbers.no_of_occupied("restricted")
!      ! Evaluate *all* the natural orbitals on the grid, to save calling
!      ! make_nabla_grid too many times
!      g1.create(n_pt,n_occ,3)
!      g0.create(n_pt,n_occ)
!      g1 = ZERO
!      g0 = ZERO
!      do a = 1,.n_atom
!         if (any(a==atoms)) then                               ! Use the supplied grids
!            f = .first_basis_fn_for_atom(a)
!            l =  .last_basis_fn_for_atom(a)
!            NO => .natural_orbitals.restricted(f:l,:n_occ)     ! Multiply by all orbitals
!            if (a==atoms(1)) then
!               g1(:,:,1) = g1(:,:,1) + matmul(a1(:,:,1),NO)
!               g1(:,:,2) = g1(:,:,2) + matmul(a1(:,:,2),NO)
!               g1(:,:,3) = g1(:,:,3) + matmul(a1(:,:,3),NO)
!               g0        = g0        + matmul(a0,NO)
!            else
!               g1(:,:,1) = g1(:,:,1) + matmul(b1(:,:,1),NO)
!               g1(:,:,2) = g1(:,:,2) + matmul(b1(:,:,2),NO)
!               g1(:,:,3) = g1(:,:,3) + matmul(b1(:,:,3),NO)
!               g0        = g0        + matmul(b0,NO)
!            end
!         else if (.is_overlapping_atom(a,atoms)) then           ! Do only overlapping atoms
!            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!               .get_shell(sh,s,fs,ls)
!               sh_grid1.create(n_pt,sh.n_comp,3)
!               sh_grid0.create(n_pt,sh.n_comp)
!               sh.make_nabla_grid(sh_grid1,sh_grid0,pt)         ! Call this as little as possible
!               NO => .natural_orbitals.restricted(fs:ls,:n_occ) ! Multiply by all orbitals
!               g1(:,:,1) = g1(:,:,1) + matmul(sh_grid1(:,:,1),NO)
!               g1(:,:,2) = g1(:,:,2) + matmul(sh_grid1(:,:,2),NO)
!               g1(:,:,3) = g1(:,:,3) + matmul(sh_grid1(:,:,3),NO)
!               g0        = g0        + matmul(sh_grid0,NO)
!               sh_grid0.destroy
!               sh_grid1.destroy
!               sh.destroy_ptr_part
!            end
!         end
!      end
!      ! Now square up each natural orbital. We can't skip any NO's since they
!      ! could be all delocalised.
!      rho1 = ZERO
!      rho0 = ZERO
!      do n = 1,n_occ
!         occ = .occupation_numbers.restricted(n)
!         rho1(:,1) = rho1(:,1) + occ*g0(:,n)*g1(:,n,1)
!         rho1(:,2) = rho1(:,2) + occ*g0(:,n)*g1(:,n,2)
!         rho1(:,3) = rho1(:,3) + occ*g0(:,n)*g1(:,n,3)
!         rho0      = rho0      + occ*g0(:,n)*g0(:,n)
!      end
!      g0.destroy; g1.destroy
!      rho1 = TWO*rho1
!   end


!   make_nabla_density_grid_r_C(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)
!   ! Evaluate the nabla density grid "rho1" as well as the density grid
!   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
!   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
!   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
!   ! the basis function grids for the atoms listed in "atoms". These are the
!   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
!   ! to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it depends on having the natural orbitals defined, and
!   ! it may take much more memory than version A above, but it may be quicker.
!      rho1 :: MAT{REAL}, OUT
!      rho0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      a1,b1 :: MAT3{REAL}, target
!      a0,b0 :: MAT{REAL}, target
!      ma,mb :: INT, IN
!      cutoff :: REAL, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
!   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
!   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
!      sh :: SHELL1
!      shell :: VEC{SHELL}*
!      pos :: VEC{REAL}(3) 
!      list :: VEC{INT}*
!      expon :: VEC{MAT_{INT}}*
!      skipa :: VEC{VEC_{BIN}}*
!      aexpon,bexpon :: MAT{INT}*
!      aex,bex :: VEC{INT}*
!      askipa,bskipa,skip :: VEC{BIN}*
!      grid0,grid1,grid2,grid3 :: VEC{MAT_{REAL}}*
!      x,y,z,r2,ag0,ag1,ag2,ag3,bg0 :: VEC{REAL}*
!      agrid0,agrid1,agrid2,agrid3,bgrid0,g0,g1,g2,g3 :: MAT{REAL}*
!      n_list,n_pt,aa,a,na,fa,bb,b,nb,fb,s,fp,lp,f,l,i,n :: INT
!      P,val :: REAL
!      do_a,do_b :: BIN
!      ex_cutoff,ex_P :: INT
!      ex_cutoff = exponent(cutoff) - 1
!      list => .overlapping_atoms_for(atoms)
!      n_list = list.dim
!      grid0.create(n_list)
!      grid1.create(n_list)
!      grid2.create(n_list)
!      grid3.create(n_list)
!      skipa.create(n_list)
!      expon.create(n_list)
!      n_pt = pt.dim1
!      ! Make the atom-basis function grids
!      do aa = 1,n_list                     
!         a = list(aa)                      ! Loop over list of overlapping atoms
!         na = .atom(a).n_bf                ! Create bf grids/keep arrays for this atom
!         if (any(a==atoms)) then           ! Use the supplied grids
!            skipa(aa).element.create(na);      askipa => skipa(aa).element
!            expon(aa).element.create(n_pt,na); aexpon => expon(aa).element
!            askipa = FALSE                 ! <<< Do not skip any of these
!            if (a==atoms(1)) then
!               grid0(aa).element => a0     ! a is the first atom 
!               grid1(aa).element => a1(:,:,1)
!               grid2(aa).element => a1(:,:,2)
!               grid3(aa).element => a1(:,:,3)
!               aexpon = exponent(a0)
!            else
!               grid0(aa).element => b0     ! a is the second atom
!               grid1(aa).element => b1(:,:,1)
!               grid2(aa).element => b1(:,:,2)
!               grid3(aa).element => b1(:,:,3)
!               aexpon = exponent(b0)
!            end
!         else                              ! Do only overlapping atoms
!            grid0(aa).element.create(n_pt,na); agrid0 => grid0(aa).element
!            grid1(aa).element.create(n_pt,na); agrid1 => grid1(aa).element
!            grid2(aa).element.create(n_pt,na); agrid2 => grid2(aa).element
!            grid3(aa).element.create(n_pt,na); agrid3 => grid3(aa).element
!            skipa(aa).element.create(na);      askipa => skipa(aa).element
!            expon(aa).element.create(n_pt,na); aexpon => expon(aa).element
!            pos = .atom(a).pos
!            shell => .atom(a).basis.shell
!            if (atoms.dim==1) then
!               do_a = .is_overlapping_atom(a,atoms(1))
!               if (do_a) then
!                  .atom(a).make_displaced_points(x,y,z,r2,pt,create=TRUE)
!                  l = 0
!                  do s = 1,shell.dim
!                     sh.set(shell(s),pos)
!                     f = l + 1
!                     l = f + sh.n_comp - 1
!                     g0 => agrid0(:,f:l)     ! Values less than the cutoff
!                     g1 => agrid1(:,f:l)     ! are scrubbed
!                     g2 => agrid2(:,f:l)
!                     g3 => agrid3(:,f:l)
!                     skip => askipa(f:l)
!                     sh.make_nabla_grid(g1,g2,g3,g0,skip,x,y,z,r2,cutoff)
!                     aexpon(:,f:l) = exponent(g0)
!                  end
!                  .atom(a).tidy_displaced_points(x,y,z,r2)
!               end
!            else 
!               do_a = .is_overlapping_atom(a,atoms(1))
!               do_b = .is_overlapping_atom(a,atoms(2))
!               if (do_a AND do_b) then
!                  .atom(a).make_displaced_points(x,y,z,r2,pt,create=TRUE)
!                  l = 0
!                  do s = 1,shell.dim
!                     sh.set(shell(s),pos)
!                     f = l + 1
!                     l = f + sh.n_comp - 1
!                     g0 => agrid0(:,f:l)     ! Values less than the cutoff
!                     g1 => agrid1(:,f:l)     ! are scrubbed
!                     g2 => agrid2(:,f:l)
!                     g3 => agrid3(:,f:l)
!                     skip => askipa(f:l)
!                     sh.make_nabla_grid(g1,g2,g3,g0,skip,x,y,z,r2,cutoff)
!                     aexpon(:,f:l) = exponent(g0)
!                  end
!                  .atom(a).tidy_displaced_points(x,y,z,r2)
!               else if (do_a) then
!                  askipa(ma+1:,:) = TRUE       ! <<< skip b
!                  .atom(a).make_displaced_points(x,y,z,r2,pt(:ma,:),create=TRUE)
!                  l = 0
!                  do s = 1,shell.dim
!                     sh.set(shell(s),pos)
!                     f = l + 1
!                     l = f + sh.n_comp - 1
!                     g0 => agrid0(:ma,f:l)     ! Values less than the cutoff
!                     g1 => agrid1(:ma,f:l)     ! are scrubbed
!                     g2 => agrid2(:ma,f:l)
!                     g3 => agrid3(:ma,f:l)
!                     skip => askipa(f:l)
!                     sh.make_nabla_grid(g1,g2,g3,g0,skip,x,y,z,r2,cutoff)
!                     aexpon(:ma,f:l) = exponent(g0)
!                  end
!                  .atom(a).tidy_displaced_points(x,y,z,r2)
!               else if (do_b) then
!                  askipa(:ma,:) = TRUE           ! <<< skip a
!                  .atom(a).make_displaced_points(x,y,z,r2,pt(ma+1:,:),create=TRUE)
!                  l = 0
!                  do s = 1,shell.dim
!                     sh.set(shell(s),pos)
!                     f = l + 1
!                     l = f + sh.n_comp - 1
!                     g0 => agrid0(ma+1:,f:l)     ! Values less than the cutoff
!                     g1 => agrid1(ma+1:,f:l)     ! are scrubbed
!                     g2 => agrid2(ma+1:,f:l)
!                     g3 => agrid3(ma+1:,f:l)
!                     skip => askipa(f:l)
!                     sh.make_nabla_grid(g1,g2,g3,g0,skip,x,y,z,r2,cutoff)
!                     aexpon(ma+1:,f:l) = exponent(g0)
!                  end
!                  .atom(a).tidy_displaced_points(x,y,z,r2)
!               end
!            end
!         end
!      end
!      ! Now calculate the density and its gradient
!      rho0 = ZERO
!      rho1 = ZERO
!      skip.create(n_pt)
!      do aa = 1,n_list
!         agrid0 => grid0(aa).element
!         agrid1 => grid1(aa).element
!         agrid2 => grid2(aa).element
!         agrid3 => grid3(aa).element
!         askipa => skipa(aa).element
!         aexpon => expon(aa).element
!         a  = list(aa)
!         na = .atom(a).n_bf
!         fa = .first_basis_fn_for_atom(a) - 1
!         do bb = 1,n_list
!            bgrid0 => grid0(bb).element
!            bskipa => skipa(bb).element
!            bexpon => expon(bb).element
!            b  = list(bb)
!            nb = .atom(b).n_bf
!            fb = .first_basis_fn_for_atom(b) - 1
!               do a = 1,na
!                  if (askipa(a)) cycle
!                  ag0 => agrid0(:,a)
!                  ag1 => agrid1(:,a)
!                  ag2 => agrid2(:,a)
!                  ag3 => agrid3(:,a)
!                  aex => aexpon(:,a)
!                  do b = 1,nb
!                     if (bskipa(b)) cycle
!                     P = .density_matrix.restricted(fb+b,fa+a)
!                     bex => bexpon(:,b)
!                     ex_P = exponent(P)
!                     skip = aex + bex < (ex_cutoff - ex_P)
!                     n = count(NOT skip)
!                     if (n==0) cycle
!                     bg0 => bgrid0(:,b)
!                     do i = 1,n_pt
!                        if (skip(i)) cycle
!                        val = bg0(i)*P
!                        rho0(i)   = rho0(i)   + ag0(i)*val
!                        rho1(i,1) = rho1(i,1) + ag1(i)*val
!                        rho1(i,2) = rho1(i,2) + ag2(i)*val
!                        rho1(i,3) = rho1(i,3) + ag3(i)*val
!                     end
!                  end
!               end
!         end
!      end
!      rho1 = TWO*rho1
!      skip.destroy
!      expon.destroy; skipa.destroy
!      do aa = 1,n_list                     
!         a = list(aa)  
!         if (any(a==atoms)) cycle
!         nullify(grid0(aa).element)
!         nullify(grid1(aa).element)
!         nullify(grid2(aa).element)
!         nullify(grid3(aa).element)
!      end
!      grid3.destroy; grid2.destroy; grid1.destroy; grid0.destroy
!      list.destroy
!   end

!   make_nabla_density_grid_r_C(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)
!   ! Evaluate the nabla density grid "rho1" as well as the density grid
!   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
!   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
!   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
!   ! the basis function grids for the atoms listed in "atoms". These are the
!   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
!   ! to calculate the density contributions for any atoms which do not have
!   ! basis functions which overlap with those in "atoms", because the orbital
!   ! density from those atoms evaluated at those in the "atoms" list will be
!   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
!   ! array defined. NOTE: it depends on having the natural orbitals defined, and
!   ! it may take much more memory than version A above, but it may be quicker.
!      rho1 :: MAT{REAL}, OUT
!      rho0 :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      a1,b1 :: MAT3{REAL}, target
!      a0,b0 :: MAT{REAL}, target
!      ma,mb :: INT, IN
!      cutoff :: REAL, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
!   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
!   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
!      sh :: SHELL1
!      shell :: VEC{SHELL}*
!      pos :: VEC{REAL}(3) 
!      list :: VEC{INT}*
!      expon :: VEC{MAT_{INT}}*
!      skipa :: VEC{VEC_{BIN}}*
!      aexpon,bexpon :: MAT{INT}*
!      aex,bex :: VEC{INT}*
!      askipa,bskipa,skip :: VEC{BIN}*
!      grid0,grid1,grid2,grid3 :: VEC{MAT_{REAL}}*
!      x,y,z,r2,ag0,ag1,ag2,ag3,bg0 :: VEC{REAL}*
!      agrid0,agrid1,agrid2,agrid3,bgrid0,g0,g1,g2,g3 :: MAT{REAL}*
!      n_list,n_pt,aa,a,na,fa,bb,b,nb,fb,s,fp,lp,f,l,i,n :: INT
!      P,val :: REAL
!      do_a,do_b :: BIN
!      ex_cutoff,ex_P :: INT
!      ex_cutoff = exponent(cutoff) - 1
!      list => .overlapping_atoms_for(atoms)
!      n_list = list.dim
!      grid0.create(n_list)
!      grid1.create(n_list)
!      grid2.create(n_list)
!      grid3.create(n_list)
!      skipa.create(n_list)
!      expon.create(n_list)
!      n_pt = pt.dim1
!      ! Make the atom-basis function grids
!      do aa = 1,n_list                     
!         a = list(aa)                      ! Loop over list of overlapping atoms
!         na = .atom(a).n_bf                ! Create bf grids/keep arrays for this atom
!         if (any(a==atoms)) then           ! Use the supplied grids
!            skipa(aa).element.create(na);      askipa => skipa(aa).element
!            expon(aa).element.create(n_pt,na); aexpon => expon(aa).element
!            askipa = FALSE                 ! <<< Do not skip any of these
!            if (a==atoms(1)) then
!               grid0(aa).element => a0     ! a is the first atom 
!               grid1(aa).element => a1(:,:,1)
!               grid2(aa).element => a1(:,:,2)
!               grid3(aa).element => a1(:,:,3)
!               aexpon = exponent(a0)
!            else
!               grid0(aa).element => b0     ! a is the second atom
!               grid1(aa).element => b1(:,:,1)
!               grid2(aa).element => b1(:,:,2)
!               grid3(aa).element => b1(:,:,3)
!               aexpon = exponent(b0)
!            end
!         else                              ! Do only overlapping atoms
!            grid0(aa).element.create(n_pt,na); agrid0 => grid0(aa).element; agrid0 = ZERO
!            grid1(aa).element.create(n_pt,na); agrid1 => grid1(aa).element; agrid1 = ZERO
!            grid2(aa).element.create(n_pt,na); agrid2 => grid2(aa).element; agrid2 = ZERO
!            grid3(aa).element.create(n_pt,na); agrid3 => grid3(aa).element; agrid3 = ZERO
!            skipa(aa).element.create(na);      askipa => skipa(aa).element
!            expon(aa).element.create(n_pt,na); aexpon => expon(aa).element
!            do_a = .is_overlapping_atom(a,atoms(1))
!            if (atoms.dim==1) then
!               if (do_a) then; fp = 1; lp = n_pt 
!               else;           cycle
!               end
!            else                           ! Do only necessary points
!               do_b = .is_overlapping_atom(a,atoms(2))
!               if      (do_a AND do_b) then; fp =    1; lp = n_pt 
!               else if (do_a)          then; fp =    1; lp = ma
!               else if (do_b)          then; fp = ma+1; lp = n_pt
!               else;                         cycle
!               end
!            end
!            .atom(a).make_displaced_points(x,y,z,r2,pt(fp:lp,:),create=TRUE)
!            pos = .atom(a).pos
!            shell => .atom(a).basis.shell
!            l = 0
!            do s = 1,shell.dim
!               sh.set(shell(s),pos)
!               f = l + 1
!               l = f + sh.n_comp - 1
!               g0 => agrid0(fp:lp,f:l)   ! Values less than the cutoff
!               g1 => agrid1(fp:lp,f:l)   ! are scrubbed
!               g2 => agrid2(fp:lp,f:l)
!               g3 => agrid3(fp:lp,f:l)
!               skip => askipa(f:l)
!               sh.make_nabla_grid(g1,g2,g3,g0,skip,x,y,z,r2,cutoff)
!               aexpon(fp:lp,f:l) = exponent(g0)
!            end
!            .atom(a).tidy_displaced_points(x,y,z,r2)
!         end
!      end
!      ! Now calculate the density and its gradient
!      rho0 = ZERO
!      rho1 = ZERO
!      skip.create(n_pt)
!      do aa = 1,n_list
!         agrid0 => grid0(aa).element
!         agrid1 => grid1(aa).element
!         agrid2 => grid2(aa).element
!         agrid3 => grid3(aa).element
!         askipa => skipa(aa).element
!         aexpon => expon(aa).element
!         a  = list(aa)
!         na = .atom(a).n_bf
!         fa = .first_basis_fn_for_atom(a) - 1
!         do bb = 1,n_list
!            bgrid0 => grid0(bb).element
!            bskipa => skipa(bb).element
!            bexpon => expon(bb).element
!            b  = list(bb)
!            nb = .atom(b).n_bf
!            fb = .first_basis_fn_for_atom(b) - 1
!               do a = 1,na
!                  if (askipa(a)) cycle
!                  ag0 => agrid0(:,a)
!                  ag1 => agrid1(:,a)
!                  ag2 => agrid2(:,a)
!                  ag3 => agrid3(:,a)
!                  aex => aexpon(:,a)
!                  do b = 1,nb
!                     if (bskipa(b)) cycle
!                     P = .density_matrix.restricted(fb+b,fa+a)
!                     bex => bexpon(:,b)
!                     ex_P = exponent(P)
!                     skip = aex + bex < (ex_cutoff - ex_P)
!                     n = count(NOT skip)
!                     if (n==0) cycle
!                     bg0 => bgrid0(:,b)
!                     do i = 1,n_pt
!                        if (skip(i)) cycle
!                        val = bg0(i)*P
!                        rho0(i)   = rho0(i)   + ag0(i)*val
!                        rho1(i,1) = rho1(i,1) + ag1(i)*val
!                        rho1(i,2) = rho1(i,2) + ag2(i)*val
!                        rho1(i,3) = rho1(i,3) + ag3(i)*val
!                     end
!                  end
!               end
!         end
!      end
!      rho1 = TWO*rho1
!      skip.destroy
!      expon.destroy; skipa.destroy
!      do aa = 1,n_list                     
!         a = list(aa)  
!         if (all(a/=atoms)) cycle
!         nullify(grid0(aa).element)
!         nullify(grid1(aa).element)
!         nullify(grid2(aa).element)
!         nullify(grid3(aa).element)
!      end
!      grid3.destroy; grid2.destroy; grid1.destroy; grid0.destroy
!      list.destroy
!   end

   make_nabla_density_grid_r_C(rho1,rho0,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)
   ! Evaluate the nabla density grid "rho1" as well as the density grid
   ! "rho0" on a set of grid points "pt", for use in matrix elements needed by
   ! DFT grid integration. "atoms" is a list of indices of the atoms whose grid
   ! points are to be used in DFT integrations. "a1", "a0", and "b1", "b0" are
   ! the basis function grids for the atoms listed in "atoms". These are the
   ! grids for the atoms whose matrix elements are to be evaluated. We don't have
   ! to calculate the density contributions for any atoms which do not have
   ! basis functions which overlap with those in "atoms", because the orbital
   ! density from those atoms evaluated at those in the "atoms" list will be
   ! negligible. NOTE: this routine depends on having the .overlapping_atoms
   ! array defined. NOTE: it depends on having the natural orbitals defined, and
   ! it may take much more memory than version A above, but it may be quicker.
      rho1 :: MAT{REAL}, OUT
      rho0 :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a1,b1 :: MAT3{REAL}, target
      a0,b0 :: MAT{REAL}, target
      ma,mb :: INT, IN
      cutoff :: REAL, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho1.dim1==pt.dim1,"rho1 has wrong 1st dimension")
   ENSURE(rho1.dim2==3,"rho1 has wrong 2nd dimension")
   ENSURE(rho0.dim==pt.dim1,"rho0 has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
      sh :: SHELL1
      shell :: VEC{SHELL}*
      pos :: VEC{REAL}(3) 
      list :: VEC{INT}*
      expon :: VEC{MAT_{INT}}*
      skipa :: VEC{VEC_{BIN}}*
      aexpon,bexpon :: MAT{INT}*
      aex,bex :: VEC{INT}*
      askipa,bskipa,skip :: VEC{BIN}*
      grid0,grid1,grid2,grid3 :: VEC{MAT_{REAL}}*
      x,y,z,r2,ag0,ag1,ag2,ag3,bg0 :: VEC{REAL}*
      agrid0,agrid1,agrid2,agrid3,bgrid0,g0,g1,g2,g3 :: MAT{REAL}*
      n_list,n_pt,aa,a,la,ua,na,fa,bb,b,lb,ub,nb,fb,s,fp,lp,f,l,u,i,n :: INT
      P,val :: REAL
      do_a,do_b :: BIN
      ex_cutoff,ex_P :: INT
      ex_cutoff = exponent(cutoff) - 1
      list => .overlapping_atoms_for(atoms)
      n_list = list.dim
      skipa.create(n_list)
      expon.create(n_list)
      grid0.create(n_list)
      grid1.create(n_list)
      grid2.create(n_list)
      grid3.create(n_list)
      n_pt = pt.dim1
      ! Make the atom-basis function grids
      do aa = 1,n_list                     
         a = list(aa)                      ! Loop over list of overlapping atoms
         na = .atom(a).n_bf                ! Create bf grids/keep arrays for this atom
         if (any(a==atoms)) then           ! Use the supplied grids
            skipa(aa).element.create(na);      askipa => skipa(aa).element
            expon(aa).element.create(n_pt,na); aexpon => expon(aa).element
            askipa = FALSE                 ! <<< Do not skip any of these
            if (a==atoms(1)) then
               grid0(aa).element => a0     ! a is the first atom 
               grid1(aa).element => a1(:,:,1)
               grid2(aa).element => a1(:,:,2)
               grid3(aa).element => a1(:,:,3)
               aexpon = exponent(a0)
            else
               grid0(aa).element => b0     ! a is the second atom
               grid1(aa).element => b1(:,:,1)
               grid2(aa).element => b1(:,:,2)
               grid3(aa).element => b1(:,:,3)
               aexpon = exponent(b0)
            end
         else                              ! Do only overlapping atoms
            do_a = .is_overlapping_atom(a,atoms(1))
            if (atoms.dim==1) then
               if (do_a) then; fp = 1; lp = n_pt 
               else;           cycle
               end
            else                           ! Do only necessary points
               do_b = .is_overlapping_atom(a,atoms(2))
               if      (do_a AND do_b) then; fp =    1; lp = n_pt 
               else if (do_a)          then; fp =    1; lp = ma;   print *, "do_a"
               else if (do_b)          then; fp = ma+1; lp = n_pt; print *, "do_b"
               else;                         cycle
               end
            end
            skipa(aa).element.create(na);         askipa => skipa(aa).element
            expon(aa).element.create(fp,lp,1,na); aexpon => expon(aa).element
            grid0(aa).element.create(fp,lp,1,na); agrid0 => grid0(aa).element
            grid1(aa).element.create(fp,lp,1,na); agrid1 => grid1(aa).element
            grid2(aa).element.create(fp,lp,1,na); agrid2 => grid2(aa).element
            grid3(aa).element.create(fp,lp,1,na); agrid3 => grid3(aa).element
            .atom(a).make_displaced_points(x,y,z,r2,pt(fp:lp,:),create=TRUE)
            pos = .atom(a).pos
            shell => .atom(a).basis.shell
            l = 0
            do s = 1,shell.dim
               sh.set(shell(s),pos)
               f = l + 1
               l = f + sh.n_comp - 1
               g0 => agrid0(:,f:l)   ! Values less than the cutoff
               g1 => agrid1(:,f:l)   ! are scrubbed
               g2 => agrid2(:,f:l)
               g3 => agrid3(:,f:l)
               skip => askipa(f:l)
               sh.make_nabla_grid(g1,g2,g3,g0,skip,x,y,z,r2,cutoff)
               aexpon(:,f:l) = exponent(g0)
            end
            .atom(a).tidy_displaced_points(x,y,z,r2)
         end
      end
      ! Now calculate the density and its gradient
      rho0 = ZERO
      rho1 = ZERO
      skip.create(n_pt)
      do aa = 1,n_list
         agrid0 => grid0(aa).element
         agrid1 => grid1(aa).element
         agrid2 => grid2(aa).element
         agrid3 => grid3(aa).element
         askipa => skipa(aa).element
         aexpon => expon(aa).element
         la = lbound(agrid0,dim=1)
         ua = ubound(agrid0,dim=1)
         a  = list(aa)
         na = .atom(a).n_bf
         fa = .first_basis_fn_for_atom(a) - 1
         do bb = 1,n_list
            bgrid0 => grid0(bb).element
            bskipa => skipa(bb).element
            bexpon => expon(bb).element
            lb = lbound(bgrid0,dim=1)
            ub = ubound(bgrid0,dim=1)
            l  = max(la,lb)
            u  = min(ua,ub)
            if (l>u) cycle
            b  = list(bb)
            nb = .atom(b).n_bf
            fb = .first_basis_fn_for_atom(b) - 1
               do a = 1,na
                  if (askipa(a)) cycle
                  ag0 => agrid0(l:u,a)
                  ag1 => agrid1(l:u,a)
                  ag2 => agrid2(l:u,a)
                  ag3 => agrid3(l:u,a)
                  aex => aexpon(l:u,a)
                  do b = 1,nb
                     if (bskipa(b)) cycle
                     P = .density_matrix.restricted(fb+b,fa+a)
                     bex => bexpon(l:u,b)
                     ex_P = exponent(P)
                     skip(l:u) = aex + bex < (ex_cutoff - ex_P)
                     n = count(NOT skip)
                     if (n==0) cycle
                     bg0 => bgrid0(l:u,b)
                     do i = l,u
                        if (skip(i)) cycle
                        val = bg0(i)*P
                        rho0(i)   = rho0(i)   + ag0(i)*val
                        rho1(i,1) = rho1(i,1) + ag1(i)*val
                        rho1(i,2) = rho1(i,2) + ag2(i)*val
                        rho1(i,3) = rho1(i,3) + ag3(i)*val
                     end
                  end
               end
         end
      end
      rho1 = TWO*rho1
      skip.destroy
      do aa = 1,n_list                     
         a = list(aa)  
         if (all(a/=atoms)) cycle
         nullify(grid0(aa).element)
         nullify(grid1(aa).element)
         nullify(grid2(aa).element)
         nullify(grid3(aa).element)
      end
      grid3.destroy; grid2.destroy; grid1.destroy; grid0.destroy
      expon.destroy; skipa.destroy
      list.destroy
   end


   make_nabla_density_grid_u_A(rho1a,rho1b,rho0a,rho0b,pt,atoms,aa1,aa0,bb1,bb0,cutoff)
   ! See below.
      rho1a,rho1b :: MAT{REAL}, OUT
      rho0a,rho0b :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      aa1,bb1 :: MAT3{REAL}
      aa0,bb0 :: MAT{REAL}
    ! ma,mb :: INT, IN
      cutoff :: REAL, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
 ! ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
 ! ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
      sha,shb :: SHELL1
      list :: VEC{INT}*
      skipa,skipb,skipaa,skipbb :: VEC{BIN}*
      xa,ya,za,ra2,xb,yb,zb,rb2 :: VEC{REAL}*
      a1 :: MAT3{REAL}*
      a0,b0,a0Pa,a0Pb,b0Pa,b0Pb,Pa,Pb :: MAT{REAL}*
      n_pt,a_pt,b_pt,aa,a,sa,fa,la,na,bb,b,sb,fb,lb,nb, i,k,l :: INT
      fac :: REAL
      rho1a = ZERO; rho1b = ZERO
      rho0a = ZERO; rho0b = ZERO
      n_pt = pt.dim1
      list => .overlapping_atoms_for(atoms)
      do aa = 1,list.dim
         a = list(aa)
         .atom(a).make_significant_points(xa,ya,za,ra2,skipa,pt,cutoff)
         if (xa.destroyed) cycle
         a_pt = xa.dim
         do sa = .first_shell_for_atom(a),.last_shell_for_atom(a)
            .get_shell(sha,sa,fa,la)
            a1.create(a_pt,sha.n_comp,3)
            a0.create(a_pt,sha.n_comp)
            sha.make_nabla_grid(a1,a0,xa,ya,za,ra2,cutoff) ! Call this as little as possible
            do bb = 1,list.dim
               b = list(bb)
               if (any(a==atoms) AND any(b==atoms)) cycle  ! Do with saved grids -- below
               .atom(b).make_significant_points(xb,yb,zb,rb2,skipb,pt,skipa,cutoff)
               if (xb.destroyed) cycle
               b_pt = xb.dim
               b0Pa.create(b_pt,sha.n_comp); b0Pa = ZERO
               b0Pb.create(b_pt,sha.n_comp); b0Pb = ZERO
               do sb = .first_shell_for_atom(b),.last_shell_for_atom(b)
                  .get_shell(shb,sb,fb,lb)
                  b0.create(b_pt,shb.n_comp)
                  shb.make_grid(b0,xb,yb,zb,rb2,cutoff) ! Call this as little as possible
                  Pa => .density_matrix.alpha(fb:lb,fa:la)
                  Pb => .density_matrix.beta(fb:lb,fa:la)
                  b0Pa = b0Pa + matmul(b0,Pa)
                  b0Pb = b0Pb + matmul(b0,Pb)
                  b0.destroy
                  shb.destroy_ptr_part
               end
               k = 0
               l = 0
               do i = 1,n_pt
                  if (skipa(i)) cycle
                  l = l + 1
                  if (skipb(i)) cycle
                  k = k + 1
                  rho1a(i,1) = rho1a(i,1) + sum(a1(l,:,1)*b0Pa(k,:))
                  rho1a(i,2) = rho1a(i,2) + sum(a1(l,:,2)*b0Pa(k,:))
                  rho1a(i,3) = rho1a(i,3) + sum(a1(l,:,3)*b0Pa(k,:))
                  rho1b(i,1) = rho1b(i,1) + sum(a1(l,:,1)*b0Pb(k,:))
                  rho1b(i,2) = rho1b(i,2) + sum(a1(l,:,2)*b0Pb(k,:))
                  rho1b(i,3) = rho1b(i,3) + sum(a1(l,:,3)*b0Pb(k,:))
               end
               if (bb<=aa) then
               if (aa==bb) then; fac = ONE
               else;             fac = TWO
               end
               k = 0
               l = 0
               do i = 1,n_pt
                  if (skipa(i)) cycle
                  l = l + 1
                  if (skipb(i)) cycle
                  k = k + 1
                  rho0a(i)   = rho0a(i)   + fac*sum(a0(l,:)  *b0Pa(k,:))
                  rho0b(i)   = rho0b(i)   + fac*sum(a0(l,:)  *b0Pb(k,:))
               end
               end
               b0Pb.destroy; b0Pa.destroy
               xb.destroy; yb.destroy; zb.destroy; rb2.destroy; skipb.destroy
            end
            a0.destroy; a1.destroy
            sha.destroy_ptr_part
         end
         xa.destroy; ya.destroy; za.destroy; ra2.destroy; skipa.destroy
      end
      list.destroy
      ! Now re-use the given grid data
      if (atoms.dim==1) then
         b = atoms(1)
         fb = .first_basis_fn_for_atom(b)
         lb =  .last_basis_fn_for_atom(b)
         nb = lb - fb + 1
         fa = fb
         la = lb
         na = nb
         b0Pa.create(n_pt,na)
         b0Pb.create(n_pt,na)
         Pa => .density_matrix.alpha(fb:lb,fa:la)
         Pb => .density_matrix.beta(fb:lb,fa:la)
         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + sum(aa0(:,:)  *b0Pa,dim=2)
         rho0b      = rho0b      + sum(aa0(:,:)  *b0Pb,dim=2)
         b0Pb.destroy; b0Pa.destroy
      else
         a = atoms(1)
         b = atoms(2)
         fa = .first_basis_fn_for_atom(a)
         fb = .first_basis_fn_for_atom(b)
         la =  .last_basis_fn_for_atom(a)
         lb =  .last_basis_fn_for_atom(b)
         na = la - fa + 1
         nb = lb - fb + 1
         b0Pa.create(n_pt,na)
         b0Pb.create(n_pt,na)
         Pa => .density_matrix.alpha(fb:lb,fa:la)
         Pb => .density_matrix.beta(fb:lb,fa:la)
         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + TWO*sum(aa0(:,:)*b0Pa,dim=2)
         rho0b      = rho0b      + TWO*sum(aa0(:,:)*b0Pb,dim=2)
         b0Pb.destroy; b0Pa.destroy
         a0Pa.create(n_pt,nb)
         a0Pb.create(n_pt,nb)
         Pa => .density_matrix.alpha(fa:la,fb:lb)
         Pb => .density_matrix.beta(fa:la,fb:lb)
         a0Pa = matmul(aa0,Pa)
         a0Pb = matmul(aa0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*a0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*a0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*a0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*a0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*a0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*a0Pb,dim=2)
         a0Pb.destroy; a0Pa.destroy
         a0Pa.create(n_pt,na)
         a0Pb.create(n_pt,na)
         Pa => .density_matrix.alpha(fa:la,fa:la)
         Pb => .density_matrix.beta(fa:la,fa:la)
         a0Pa = matmul(aa0,Pa)
         a0Pb = matmul(aa0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*a0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*a0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*a0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*a0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*a0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*a0Pb,dim=2)
         rho0a      = rho0a      + sum(aa0(:,:)  *a0Pa,dim=2)
         rho0b      = rho0b      + sum(aa0(:,:)  *a0Pb,dim=2)
         a0Pb.destroy; a0Pa.destroy
         b0Pa.create(n_pt,nb)
         b0Pb.create(n_pt,nb)
         Pa => .density_matrix.alpha(fb:lb,fb:lb)
         Pb => .density_matrix.beta(fb:lb,fb:lb)
         b0Pa = matmul(bb0,Pa)
         b0Pb = matmul(bb0,Pb)
         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*b0Pa,dim=2)
         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*b0Pa,dim=2)
         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*b0Pa,dim=2)
         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*b0Pb,dim=2)
         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*b0Pb,dim=2)
         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*b0Pb,dim=2)
         rho0a      = rho0a      + sum(bb0(:,:)  *b0Pa,dim=2)
         rho0b      = rho0b      + sum(bb0(:,:)  *b0Pb,dim=2)
         b0Pb.destroy; b0Pa.destroy
      end
      rho1a = TWO*rho1a
      rho1b = TWO*rho1b
   end

!   make_nabla_density_grid_u_A(rho1a,rho1b,rho0a,rho0b,pt,atoms,aa1,aa0,bb1,bb0,cutoff)
!   ! See below.
!      rho1a,rho1b :: MAT{REAL}, OUT
!      rho0a,rho0b :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      aa1,bb1 :: MAT3{REAL}
!      aa0,bb0 :: MAT{REAL}
!    ! ma,mb :: INT, IN
!      cutoff :: REAL, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
!   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
!   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
!   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
!   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
! ! ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
! ! ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
!      sha,shb :: SHELL1
!      list :: VEC{INT}*
!      skipa,skipb,skipaa,skipbb :: VEC{BIN}*
!      xa,ya,za,ra2,d2,xb,yb,zb,rb2 :: VEC{REAL}*
!      a1 :: MAT3{REAL}*
!      a0,b0,a0Pa,a0Pb,b0Pa,b0Pb,Pa,Pb :: MAT{REAL}*
!      n_pt,a_pt,b_pt,aa,a,sa,fa,la,na,bb,b,sb,fb,lb,nb, i,k,l :: INT
!      fac :: REAL
!      rho1a = ZERO; rho1b = ZERO
!      rho0a = ZERO; rho0b = ZERO
!      n_pt = pt.dim1
!      list => .overlapping_atoms_for(atoms)
!      do aa = 1,list.dim
!         a = list(aa)
!         .atom(a).make_significant_points(xa,ya,za,ra2,d2,skipa,pt,cutoff)
!         if (xa.destroyed) cycle
!         a_pt = xa.dim
!         do sa = .first_shell_for_atom(a),.last_shell_for_atom(a)
!            .get_shell(sha,sa,fa,la)
!            skipaa.create(n_pt)
!            skipaa = d2>sha.r_max(cutoff*cutoff)
!            a1.create(a_pt,sha.n_comp,3)
!            a0.create(a_pt,sha.n_comp)
!            sha.make_nabla_grid(a1,a0,xa,ya,za,ra2,cutoff) ! Call this as little as possible
!            do bb = 1,list.dim
!               b = list(bb)
!               if (any(a==atoms) AND any(b==atoms)) cycle  ! Do with saved grids -- below
!               .atom(b).make_significant_points(xb,yb,zb,rb2,skipb,pt,skipaa,cutoff)
!               if (xb.destroyed) cycle
!               b_pt = xb.dim
!               b0Pa.create(b_pt,sha.n_comp); b0Pa = ZERO
!               b0Pb.create(b_pt,sha.n_comp); b0Pb = ZERO
!               do sb = .first_shell_for_atom(b),.last_shell_for_atom(b)
!                  .get_shell(shb,sb,fb,lb)
!                  b0.create(b_pt,shb.n_comp)
!                  shb.make_grid(b0,xb,yb,zb,rb2,cutoff) ! Call this as little as possible
!                  Pa => .density_matrix.alpha(fb:lb,fa:la)
!                  Pb => .density_matrix.beta(fb:lb,fa:la)
!                  b0Pa = b0Pa + matmul(b0,Pa)
!                  b0Pb = b0Pb + matmul(b0,Pb)
!                  b0.destroy
!                  shb.destroy_ptr_part
!               end
!               k = 0
!               l = 0
!               do i = 1,n_pt
!                  if (skipa(i)) cycle
!                  l = l + 1
!                  if (skipb(i)) cycle
!                  k = k + 1
!                  rho1a(i,1) = rho1a(i,1) + sum(a1(l,:,1)*b0Pa(k,:))
!                  rho1a(i,2) = rho1a(i,2) + sum(a1(l,:,2)*b0Pa(k,:))
!                  rho1a(i,3) = rho1a(i,3) + sum(a1(l,:,3)*b0Pa(k,:))
!                  rho1b(i,1) = rho1b(i,1) + sum(a1(l,:,1)*b0Pb(k,:))
!                  rho1b(i,2) = rho1b(i,2) + sum(a1(l,:,2)*b0Pb(k,:))
!                  rho1b(i,3) = rho1b(i,3) + sum(a1(l,:,3)*b0Pb(k,:))
!               end
!               if (bb<=aa) then
!               if (aa==bb) then; fac = ONE
!               else;             fac = TWO
!               end
!               k = 0
!               l = 0
!               do i = 1,n_pt
!                  if (skipa(i)) cycle
!                  l = l + 1
!                  if (skipb(i)) cycle
!                  k = k + 1
!                  rho0a(i)   = rho0a(i)   + fac*sum(a0(l,:)  *b0Pa(k,:))
!                  rho0b(i)   = rho0b(i)   + fac*sum(a0(l,:)  *b0Pb(k,:))
!               end
!               end
!               b0Pb.destroy; b0Pa.destroy
!               xb.destroy; yb.destroy; zb.destroy; rb2.destroy; skipb.destroy
!            end
!            skipaa.destroy
!            a0.destroy; a1.destroy
!            sha.destroy_ptr_part
!         end
!         xa.destroy; ya.destroy; za.destroy; ra2.destroy; d2.destroy; skipa.destroy
!      end
!      list.destroy
!      ! Now re-use the given grid data
!      if (atoms.dim==1) then
!         b = atoms(1)
!         fb = .first_basis_fn_for_atom(b)
!         lb =  .last_basis_fn_for_atom(b)
!         nb = lb - fb + 1
!         fa = fb
!         la = lb
!         na = nb
!         b0Pa.create(n_pt,na)
!         b0Pb.create(n_pt,na)
!         Pa => .density_matrix.alpha(fb:lb,fa:la)
!         Pb => .density_matrix.beta(fb:lb,fa:la)
!         b0Pa = matmul(bb0,Pa)
!         b0Pb = matmul(bb0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
!         rho0a      = rho0a      + sum(aa0(:,:)  *b0Pa,dim=2)
!         rho0b      = rho0b      + sum(aa0(:,:)  *b0Pb,dim=2)
!         b0Pb.destroy; b0Pa.destroy
!      else
!         a = atoms(1)
!         b = atoms(2)
!         fa = .first_basis_fn_for_atom(a)
!         fb = .first_basis_fn_for_atom(b)
!         la =  .last_basis_fn_for_atom(a)
!         lb =  .last_basis_fn_for_atom(b)
!         na = la - fa + 1
!         nb = lb - fb + 1
!         b0Pa.create(n_pt,na)
!         b0Pb.create(n_pt,na)
!         Pa => .density_matrix.alpha(fb:lb,fa:la)
!         Pb => .density_matrix.beta(fb:lb,fa:la)
!         b0Pa = matmul(bb0,Pa)
!         b0Pb = matmul(bb0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
!         rho0a      = rho0a      + TWO*sum(aa0(:,:)*b0Pa,dim=2)
!         rho0b      = rho0b      + TWO*sum(aa0(:,:)*b0Pb,dim=2)
!         b0Pb.destroy; b0Pa.destroy
!         a0Pa.create(n_pt,nb)
!         a0Pb.create(n_pt,nb)
!         Pa => .density_matrix.alpha(fa:la,fb:lb)
!         Pb => .density_matrix.beta(fa:la,fb:lb)
!         a0Pa = matmul(aa0,Pa)
!         a0Pb = matmul(aa0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*a0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*a0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*a0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*a0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*a0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*a0Pb,dim=2)
!         a0Pb.destroy; a0Pa.destroy
!         a0Pa.create(n_pt,na)
!         a0Pb.create(n_pt,na)
!         Pa => .density_matrix.alpha(fa:la,fa:la)
!         Pb => .density_matrix.beta(fa:la,fa:la)
!         a0Pa = matmul(aa0,Pa)
!         a0Pb = matmul(aa0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*a0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*a0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*a0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*a0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*a0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*a0Pb,dim=2)
!         rho0a      = rho0a      + sum(aa0(:,:)  *a0Pa,dim=2)
!         rho0b      = rho0b      + sum(aa0(:,:)  *a0Pb,dim=2)
!         a0Pb.destroy; a0Pa.destroy
!         b0Pa.create(n_pt,nb)
!         b0Pb.create(n_pt,nb)
!         Pa => .density_matrix.alpha(fb:lb,fb:lb)
!         Pb => .density_matrix.beta(fb:lb,fb:lb)
!         b0Pa = matmul(bb0,Pa)
!         b0Pb = matmul(bb0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*b0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*b0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*b0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*b0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*b0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*b0Pb,dim=2)
!         rho0a      = rho0a      + sum(bb0(:,:)  *b0Pa,dim=2)
!         rho0b      = rho0b      + sum(bb0(:,:)  *b0Pb,dim=2)
!         b0Pb.destroy; b0Pa.destroy
!      end
!      rho1a = TWO*rho1a
!      rho1b = TWO*rho1b
!   end

!   make_nabla_density_grid_u_A(rho1a,rho1b,rho0a,rho0b,pt,atoms,aa1,aa0,bb1,bb0,cutoff)
!   ! See below.
!      rho1a,rho1b :: MAT{REAL}, OUT
!      rho0a,rho0b :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      aa1,bb1 :: MAT3{REAL}
!      aa0,bb0 :: MAT{REAL}
!    ! ma,mb :: INT, IN
!      cutoff :: REAL, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
!   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
!   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
!   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
!   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
! ! ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
! ! ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
!      sha,shb :: SHELL1
!      list :: VEC{INT}*
!      skipa,skipb,skipaa,skipbb :: VEC{BIN}*
!      xa,ya,za,ra2,xb,yb,zb,rb2 :: VEC{REAL}*
!      a1 :: MAT3{REAL}*
!      a0,b0,a0Pa,a0Pb,b0Pa,b0Pb,Pa,Pb :: MAT{REAL}*
!      n_pt,a_pt,b_pt,aa,a,sa,fa,la,na,bb,b,sb,fb,lb,nb, i,k,l :: INT
!      fac :: REAL
!      rho1a = ZERO; rho1b = ZERO
!      rho0a = ZERO; rho0b = ZERO
!      n_pt = pt.dim1
!      list => .overlapping_atoms_for(atoms)
!      do aa = 1,list.dim
!         a = list(aa)
!         .atom(a).make_significant_points(xa,ya,za,ra2,skipa,pt,cutoff)
!         if (xa.destroyed) cycle
!         a_pt = xa.dim
!         do sa = .first_shell_for_atom(a),.last_shell_for_atom(a)
!            .get_shell(sha,sa,fa,la)
!            a1.create(a_pt,sha.n_comp,3)
!            a0.create(a_pt,sha.n_comp)
!            skipaa.create(a_pt)
!            sha.make_nabla_grid(a1,a0,skipaa,xa,ya,za,ra2,cutoff) ! Call this as little as possible
!            do bb = 1,list.dim
!               b = list(bb)
!               if (any(a==atoms) AND any(b==atoms)) cycle  ! Do with saved grids -- below
!               .atom(b).make_significant_points(xb,yb,zb,rb2,skipb,pt,skipaa,cutoff)
!               if (xb.destroyed) cycle
!               b_pt = xb.dim
!               b0Pa.create(b_pt,sha.n_comp); b0Pa = ZERO
!               b0Pb.create(b_pt,sha.n_comp); b0Pb = ZERO
!               do sb = .first_shell_for_atom(b),.last_shell_for_atom(b)
!                  .get_shell(shb,sb,fb,lb)
!                  b0.create(b_pt,shb.n_comp)
!                  skipbb.create(b_pt)
!                  shb.make_grid(b0,skipbb,xb,yb,zb,rb2,cutoff) ! Call this as little as possible
!                  Pa => .density_matrix.alpha(fb:lb,fa:la)
!                  Pb => .density_matrix.beta(fb:lb,fa:la)
!                  do i = 1,b_pt 
!                     if (skipbb(i)) cycle
!                     b0Pa(i,:) = b0Pa(i,:) + matmul(b0(i,:),Pa)
!                     b0Pb(i,:) = b0Pb(i,:) + matmul(b0(i,:),Pb)
!                  end
!                  skipbb.destroy
!                  b0.destroy
!                  shb.destroy_ptr_part
!               end
!               k = 0
!               l = 0
!               do i = 1,n_pt
!                  if (skipa(i)) cycle
!                  l = l + 1
!                  if (skipb(i)) cycle
!                  k = k + 1
!                  rho1a(i,1) = rho1a(i,1) + sum(a1(l,:,1)*b0Pa(k,:))
!                  rho1a(i,2) = rho1a(i,2) + sum(a1(l,:,2)*b0Pa(k,:))
!                  rho1a(i,3) = rho1a(i,3) + sum(a1(l,:,3)*b0Pa(k,:))
!                  rho1b(i,1) = rho1b(i,1) + sum(a1(l,:,1)*b0Pb(k,:))
!                  rho1b(i,2) = rho1b(i,2) + sum(a1(l,:,2)*b0Pb(k,:))
!                  rho1b(i,3) = rho1b(i,3) + sum(a1(l,:,3)*b0Pb(k,:))
!               end
!               if (bb<=aa) then
!               if (aa==bb) then; fac = ONE
!               else;             fac = TWO
!               end
!               k = 0
!               l = 0
!               do i = 1,n_pt
!                  if (skipa(i)) cycle
!                  l = l + 1
!                  if (skipb(i)) cycle
!                  k = k + 1
!                  rho0a(i)   = rho0a(i)   + fac*sum(a0(l,:)  *b0Pa(k,:))
!                  rho0b(i)   = rho0b(i)   + fac*sum(a0(l,:)  *b0Pb(k,:))
!               end
!               end
!               b0Pb.destroy; b0Pa.destroy
!               xb.destroy; yb.destroy; zb.destroy; rb2.destroy; skipb.destroy
!            end
!            skipaa.destroy
!            a0.destroy; a1.destroy
!            sha.destroy_ptr_part
!         end
!         xa.destroy; ya.destroy; za.destroy; ra2.destroy; skipa.destroy
!      end
!      list.destroy
!      ! Now re-use the given grid data
!      if (atoms.dim==1) then
!         b = atoms(1)
!         fb = .first_basis_fn_for_atom(b)
!         lb =  .last_basis_fn_for_atom(b)
!         nb = lb - fb + 1
!         fa = fb
!         la = lb
!         na = nb
!         b0Pa.create(n_pt,na)
!         b0Pb.create(n_pt,na)
!         Pa => .density_matrix.alpha(fb:lb,fa:la)
!         Pb => .density_matrix.beta(fb:lb,fa:la)
!         b0Pa = matmul(bb0,Pa)
!         b0Pb = matmul(bb0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
!         rho0a      = rho0a      + sum(aa0(:,:)  *b0Pa,dim=2)
!         rho0b      = rho0b      + sum(aa0(:,:)  *b0Pb,dim=2)
!         b0Pb.destroy; b0Pa.destroy
!      else
!         a = atoms(1)
!         b = atoms(2)
!         fa = .first_basis_fn_for_atom(a)
!         fb = .first_basis_fn_for_atom(b)
!         la =  .last_basis_fn_for_atom(a)
!         lb =  .last_basis_fn_for_atom(b)
!         na = la - fa + 1
!         nb = lb - fb + 1
!         b0Pa.create(n_pt,na)
!         b0Pb.create(n_pt,na)
!         Pa => .density_matrix.alpha(fb:lb,fa:la)
!         Pb => .density_matrix.beta(fb:lb,fa:la)
!         b0Pa = matmul(bb0,Pa)
!         b0Pb = matmul(bb0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*b0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*b0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*b0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*b0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*b0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*b0Pb,dim=2)
!         rho0a      = rho0a      + TWO*sum(aa0(:,:)*b0Pa,dim=2)
!         rho0b      = rho0b      + TWO*sum(aa0(:,:)*b0Pb,dim=2)
!         b0Pb.destroy; b0Pa.destroy
!         a0Pa.create(n_pt,nb)
!         a0Pb.create(n_pt,nb)
!         Pa => .density_matrix.alpha(fa:la,fb:lb)
!         Pb => .density_matrix.beta(fa:la,fb:lb)
!         a0Pa = matmul(aa0,Pa)
!         a0Pb = matmul(aa0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*a0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*a0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*a0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*a0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*a0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*a0Pb,dim=2)
!         a0Pb.destroy; a0Pa.destroy
!         a0Pa.create(n_pt,na)
!         a0Pb.create(n_pt,na)
!         Pa => .density_matrix.alpha(fa:la,fa:la)
!         Pb => .density_matrix.beta(fa:la,fa:la)
!         a0Pa = matmul(aa0,Pa)
!         a0Pb = matmul(aa0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(aa1(:,:,1)*a0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(aa1(:,:,2)*a0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(aa1(:,:,3)*a0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(aa1(:,:,1)*a0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(aa1(:,:,2)*a0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(aa1(:,:,3)*a0Pb,dim=2)
!         rho0a      = rho0a      + sum(aa0(:,:)  *a0Pa,dim=2)
!         rho0b      = rho0b      + sum(aa0(:,:)  *a0Pb,dim=2)
!         a0Pb.destroy; a0Pa.destroy
!         b0Pa.create(n_pt,nb)
!         b0Pb.create(n_pt,nb)
!         Pa => .density_matrix.alpha(fb:lb,fb:lb)
!         Pb => .density_matrix.beta(fb:lb,fb:lb)
!         b0Pa = matmul(bb0,Pa)
!         b0Pb = matmul(bb0,Pb)
!         rho1a(:,1) = rho1a(:,1) + sum(bb1(:,:,1)*b0Pa,dim=2)
!         rho1a(:,2) = rho1a(:,2) + sum(bb1(:,:,2)*b0Pa,dim=2)
!         rho1a(:,3) = rho1a(:,3) + sum(bb1(:,:,3)*b0Pa,dim=2)
!         rho1b(:,1) = rho1b(:,1) + sum(bb1(:,:,1)*b0Pb,dim=2)
!         rho1b(:,2) = rho1b(:,2) + sum(bb1(:,:,2)*b0Pb,dim=2)
!         rho1b(:,3) = rho1b(:,3) + sum(bb1(:,:,3)*b0Pb,dim=2)
!         rho0a      = rho0a      + sum(bb0(:,:)  *b0Pa,dim=2)
!         rho0b      = rho0b      + sum(bb0(:,:)  *b0Pb,dim=2)
!         b0Pb.destroy; b0Pa.destroy
!      end
!      rho1a = TWO*rho1a
!      rho1b = TWO*rho1b
!   end


   make_nabla_density_grid_u_B(rho1a,rho1b,rho0a,rho0b,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)
   ! Evaluate the alpha and beta nabla density grids "rho1a" and "rho1b" as well
   ! as the density grid "rho0a" and "rhob" on a set of grid points "pt", for
   ! use in matrix elements needed by DFT grid integration. "atoms" is a list of
   ! indices of the atoms whose grid points are to be used in DFT integrations.
   ! "a1", "a0", and "b1", "b0" are the basis function grids for the two atoms
   ! listed in "atoms". These are the grids for the atoms whose matrix elements
   ! are to be evaluated. We don't have to calculate the density contributions
   ! for any atoms which do not have basis functions which overlap with those in
   ! "atoms", because the orbital density from those atoms evaluated at those in
   ! the "atoms" list will be negligible. NOTE: this routine depends on having
   ! the .overlapping_atoms array defined. NOTE: it depends on having the
   ! natural orbitals defined, and it may take much more memory than version A
   ! above, but it may be quicker.
      rho1a,rho1b :: MAT{REAL}, OUT
      rho0a,rho0b :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      atoms :: VEC{INT}
      a1,b1 :: MAT3{REAL}
      a0,b0 :: MAT{REAL}
      ma,mb :: INT, IN
      cutoff :: REAL, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
   ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
      sh :: SHELL1
      skip :: VEC{BIN}*
      list :: VEC{INT}*
      x,y,z,r2 :: VEC{REAL}*
      g1a,g1b,gg1a,gg1b,sh_grid1 :: MAT3{REAL}*
      g0a,g0b,gg0a,gg0b,sh_grid0,NOa,NOb :: MAT{REAL}*
      n_pt,n_cut,na,nb,aa,a,s,f,l,fs,ls,n, i,j,k :: INT
      do_a,do_b :: BIN
      occ :: REAL
      n_pt = pt.dim1
      na = .occupation_numbers.no_of_occupied("alpha")
      nb = .occupation_numbers.no_of_occupied("beta")
      ! Evaluate *all* the natural orbitals on the grid, to save calling
      ! make_nabla_grid too many times
      list => .overlapping_atoms_for(atoms)
      g1a.create(n_pt,na,3); g1b.create(n_pt,nb,3)
      g0a.create(n_pt,na);   g0b.create(n_pt,nb)
      g1a = ZERO; g1b = ZERO
      g0a = ZERO; g0b = ZERO
      do aa = 1,list.dim
         a = list(aa)
         if (any(a==atoms)) then                               ! Use the supplied grids
            f = .first_basis_fn_for_atom(a)
            l =  .last_basis_fn_for_atom(a)
            NOa => .natural_orbitals.alpha(f:l,:na)            ! Multiply by all orbitals
            NOb => .natural_orbitals.beta(f:l,:nb)
            if (a==atoms(1)) then                              ! Re-use a1, a0
               g1a(:,:,1).plus_product_of(a1(:,:,1),NOa)
               g1a(:,:,2).plus_product_of(a1(:,:,2),NOa)
               g1a(:,:,3).plus_product_of(a1(:,:,3),NOa)
               g0a.plus_product_of(a0,NOa)
               g1b(:,:,1).plus_product_of(a1(:,:,1),NOb)
               g1b(:,:,2).plus_product_of(a1(:,:,2),NOb)
               g1b(:,:,3).plus_product_of(a1(:,:,3),NOb)
               g0b.plus_product_of(a0,NOb)
            else                                               ! Re-use b1, b0
               g1a(:,:,1).plus_product_of(b1(:,:,1),NOa)
               g1a(:,:,2).plus_product_of(b1(:,:,2),NOa)
               g1a(:,:,3).plus_product_of(b1(:,:,3),NOa)
               g0a.plus_product_of(b0,NOa)
               g1b(:,:,1).plus_product_of(b1(:,:,1),NOb)
               g1b(:,:,2).plus_product_of(b1(:,:,2),NOb)
               g1b(:,:,3).plus_product_of(b1(:,:,3),NOb)
               g0b.plus_product_of(b0,NOb)
            end
         else                                                  ! Do only overlapping atoms
            do_a = .is_overlapping_atom(a,atoms(1))
            if (atoms.dim==1) then; do_b = TRUE
            else;                   do_b = .is_overlapping_atom(a,atoms(2))
            end
            if (do_a AND do_b) then                            ! Both overlap
               .atom(a).make_significant_points(x,y,z,r2,skip,pt,cutoff)
               n_cut = x.dim
               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
                  .get_shell(sh,s,fs,ls)
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
                  NOa => .natural_orbitals.alpha(fs:ls,:na)       ! Multiply by all orbitals
                  NOb => .natural_orbitals.beta(fs:ls,:nb)
                  gg1a.create(n_cut,na,3); gg1b.create(n_cut,nb,3)
                  gg0a.create(n_cut,na);   gg0b.create(n_cut,nb)
                  gg1a(:,:,1).to_product_of(sh_grid1(:,:,1),NOa)
                  gg1a(:,:,2).to_product_of(sh_grid1(:,:,2),NOa)
                  gg1a(:,:,3).to_product_of(sh_grid1(:,:,3),NOa)
                  gg0a.to_product_of(sh_grid0,NOa)
                  gg1b(:,:,1).to_product_of(sh_grid1(:,:,1),NOb)
                  gg1b(:,:,2).to_product_of(sh_grid1(:,:,2),NOb)
                  gg1b(:,:,3).to_product_of(sh_grid1(:,:,3),NOb)
                  gg0b.to_product_of(sh_grid0,NOb)
                  do j = 1,na
                  k = 0
                  do i = 1,n_pt
                     if (skip(i)) cycle
                     k = k + 1
                     g1a(i,j,1) = g1a(i,j,1) + gg1a(k,j,1)
                     g1a(i,j,2) = g1a(i,j,2) + gg1a(k,j,2)
                     g1a(i,j,3) = g1a(i,j,3) + gg1a(k,j,3)
                     g0a(i,j)   = g0a(i,j)   + gg0a(k,j)
                  end
                  end
                  do j = 1,nb
                  k = 0
                  do i = 1,n_pt
                     if (skip(i)) cycle
                     k = k + 1
                     g1b(i,j,1) = g1b(i,j,1) + gg1b(k,j,1)
                     g1b(i,j,2) = g1b(i,j,2) + gg1b(k,j,2)
                     g1b(i,j,3) = g1b(i,j,3) + gg1b(k,j,3)
                     g0b(i,j)   = g0b(i,j)   + gg0b(k,j)
                  end
                  end
                  gg0b.destroy; gg0a.destroy
                  gg1b.destroy; gg1a.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  sh.destroy_ptr_part
               end
               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
            else if (do_a) then                                ! Only the first overlaps
               .atom(a).make_significant_points(x,y,z,r2,skip,pt(1:ma,:),cutoff)
               n_cut = x.dim
               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
                  .get_shell(sh,s,fs,ls)
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
                  NOa => .natural_orbitals.alpha(fs:ls,:na)       ! Multiply by all orbitals
                  NOb => .natural_orbitals.beta(fs:ls,:nb)
                  gg1a.create(n_cut,na,3); gg1b.create(n_cut,nb,3)
                  gg0a.create(n_cut,na);   gg0b.create(n_cut,nb)
                  gg1a(:,:,1).to_product_of(sh_grid1(:,:,1),NOa)
                  gg1a(:,:,2).to_product_of(sh_grid1(:,:,2),NOa)
                  gg1a(:,:,3).to_product_of(sh_grid1(:,:,3),NOa)
                  gg1b(:,:,1).to_product_of(sh_grid1(:,:,1),NOb)
                  gg1b(:,:,2).to_product_of(sh_grid1(:,:,2),NOb)
                  gg1b(:,:,3).to_product_of(sh_grid1(:,:,3),NOb)
                  gg0a.to_product_of(sh_grid0,NOa)
                  gg0b.to_product_of(sh_grid0,NOb)
                  do j = 1,na
                  k = 0
                  do i = 1,ma
                     if (skip(i)) cycle
                     k = k + 1
                     g1a(i,j,1) = g1a(i,j,1) + gg1a(k,j,1)
                     g1a(i,j,2) = g1a(i,j,2) + gg1a(k,j,2)
                     g1a(i,j,3) = g1a(i,j,3) + gg1a(k,j,3)
                     g0a(i,j)   = g0a(i,j)   + gg0a(k,j)
                  end
                  end
                  do j = 1,nb
                  k = 0
                  do i = 1,ma
                     if (skip(i)) cycle
                     k = k + 1
                     g1b(i,j,1) = g1b(i,j,1) + gg1b(k,j,1)
                     g1b(i,j,2) = g1b(i,j,2) + gg1b(k,j,2)
                     g1b(i,j,3) = g1b(i,j,3) + gg1b(k,j,3)
                     g0b(i,j)   = g0b(i,j)   + gg0b(k,j)
                  end
                  end
                  gg0b.destroy; gg0a.destroy
                  gg1b.destroy; gg1a.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  sh.destroy_ptr_part
               end
               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
            else if (atoms.dim==2 AND do_b) then               ! Only the second overlaps
               .atom(a).make_significant_points(x,y,z,r2,skip,pt(ma+1:,:),cutoff)
               n_cut = x.dim
               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
                  .get_shell(sh,s,fs,ls)
                  sh_grid1.create(n_cut,sh.n_comp,3)
                  sh_grid0.create(n_cut,sh.n_comp)
                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
                  NOa => .natural_orbitals.alpha(fs:ls,:na)       ! Multiply by all orbitals
                  NOb => .natural_orbitals.beta(fs:ls,:nb)
                  gg1a.create(n_cut,na,3); gg1b.create(n_cut,nb,3)
                  gg0a.create(n_cut,na);   gg0b.create(n_cut,nb)
                  gg1a(:,:,1).to_product_of(sh_grid1(:,:,1),NOa)
                  gg1a(:,:,2).to_product_of(sh_grid1(:,:,2),NOa)
                  gg1a(:,:,3).to_product_of(sh_grid1(:,:,3),NOa)
                  gg1b(:,:,1).to_product_of(sh_grid1(:,:,1),NOb)
                  gg1b(:,:,2).to_product_of(sh_grid1(:,:,2),NOb)
                  gg1b(:,:,3).to_product_of(sh_grid1(:,:,3),NOb)
                  gg0a.to_product_of(sh_grid0,NOa)
                  gg0b.to_product_of(sh_grid0,NOb)
                  do j = 1,na
                  k = 0
                  do i = ma+1,n_pt
                     if (skip(i-ma)) cycle
                     k = k + 1
                     g1a(i,j,1) = g1a(i,j,1) + gg1a(k,j,1)
                     g1a(i,j,2) = g1a(i,j,2) + gg1a(k,j,2)
                     g1a(i,j,3) = g1a(i,j,3) + gg1a(k,j,3)
                     g0a(i,j)   = g0a(i,j)   + gg0a(k,j)
                  end
                  end
                  do j = 1,nb
                  k = 0
                  do i = ma+1,n_pt
                     if (skip(i-ma)) cycle
                     k = k + 1
                     g1b(i,j,1) = g1b(i,j,1) + gg1b(k,j,1)
                     g1b(i,j,2) = g1b(i,j,2) + gg1b(k,j,2)
                     g1b(i,j,3) = g1b(i,j,3) + gg1b(k,j,3)
                     g0b(i,j)   = g0b(i,j)   + gg0b(k,j)
                  end
                  end
                  gg0b.destroy; gg0a.destroy
                  gg1b.destroy; gg1a.destroy
                  sh_grid0.destroy
                  sh_grid1.destroy
                  sh.destroy_ptr_part
               end
               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
            end
         end
      end
      rho1a = ZERO; rho1b = ZERO                               ! Now square up each natural orbital. 
      rho0a = ZERO; rho0b = ZERO                               ! We can't skip any NO's since they
      do n = 1,na                                              ! could be all delocalised.
         occ = .occupation_numbers.alpha(n)
         rho1a(:,1) = rho1a(:,1) + occ*g0a(:,n)*g1a(:,n,1)
         rho1a(:,2) = rho1a(:,2) + occ*g0a(:,n)*g1a(:,n,2)
         rho1a(:,3) = rho1a(:,3) + occ*g0a(:,n)*g1a(:,n,3)
         rho0a      = rho0a      + occ*g0a(:,n)*g0a(:,n)
      end
      do n = 1,nb
         occ = .occupation_numbers.beta(n)
         rho1b(:,1) = rho1b(:,1) + occ*g0b(:,n)*g1b(:,n,1)
         rho1b(:,2) = rho1b(:,2) + occ*g0b(:,n)*g1b(:,n,2)
         rho1b(:,3) = rho1b(:,3) + occ*g0b(:,n)*g1b(:,n,3)
         rho0b      = rho0b      + occ*g0b(:,n)*g0b(:,n)
      end
      g0b.destroy; g0a.destroy
      g1b.destroy; g1a.destroy
      list.destroy
      rho1a = TWO*rho1a
      rho1b = TWO*rho1b
   end

!   make_nabla_density_grid_u_B(rho1a,rho1b,rho0a,rho0b,pt,atoms,a1,a0,b1,b0,ma,mb,cutoff)
!   ! Evaluate the alpha and beta nabla density grids "rho1a" and "rho1b" as well
!   ! as the density grid "rho0a" and "rhob" on a set of grid points "pt", for
!   ! use in matrix elements needed by DFT grid integration. "atoms" is a list of
!   ! indices of the atoms whose grid points are to be used in DFT integrations.
!   ! "a1", "a0", and "b1", "b0" are the basis function grids for the two atoms
!   ! listed in "atoms". These are the grids for the atoms whose matrix elements
!   ! are to be evaluated. We don't have to calculate the density contributions
!   ! for any atoms which do not have basis functions which overlap with those in
!   ! "atoms", because the orbital density from those atoms evaluated at those in
!   ! the "atoms" list will be negligible. NOTE: this routine depends on having
!   ! the .overlapping_atoms array defined. NOTE: it depends on having the
!   ! natural orbitals defined, and it may take much more memory than version A
!   ! above, but it may be quicker.
!      rho1a,rho1b :: MAT{REAL}, OUT
!      rho0a,rho0b :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      a1,b1 :: MAT3{REAL}
!      a0,b0 :: MAT{REAL}
!      ma,mb :: INT, IN
!      cutoff :: REAL, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
!   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
!   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
!   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
!   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!   ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
!      sh :: SHELL1
!      skip :: VEC{BIN}*
!      list :: VEC{INT}*
!      x,y,z,r2 :: VEC{REAL}*
!      g1a,g1b,gg1a,gg1b,sh_grid1 :: MAT3{REAL}*
!      g0a,g0b,gg0a,gg0b,sh_grid0,NOa,NOb :: MAT{REAL}*
!      n_pt,n_cut,na,nb,aa,a,s,f,l,fs,ls,n, i,k :: INT
!      do_a,do_b :: BIN
!      occ :: REAL
!      n_pt = pt.dim1
!      na = .occupation_numbers.no_of_occupied("alpha")
!      nb = .occupation_numbers.no_of_occupied("beta")
!      ! Evaluate *all* the natural orbitals on the grid, to save calling
!      ! make_nabla_grid too many times
!      list => .overlapping_atoms_for(atoms)
!      g1a.create(n_pt,na,3); g1b.create(n_pt,nb,3)
!      g0a.create(n_pt,na);   g0b.create(n_pt,nb)
!      g1a = ZERO; g1b = ZERO
!      g0a = ZERO; g0b = ZERO
!      do aa = 1,list.dim
!         a = list(aa)
!         if (any(a==atoms)) then                               ! Use the supplied grids
!            f = .first_basis_fn_for_atom(a)
!            l =  .last_basis_fn_for_atom(a)
!            NOa => .natural_orbitals.alpha(f:l,:na)            ! Multiply by all orbitals
!            NOb => .natural_orbitals.beta(f:l,:nb)
!            if (a==atoms(1)) then                              ! Re-use a1, a0
!               g1a(:,:,1) = g1a(:,:,1) + matmul(a1(:,:,1),NOa)
!               g1a(:,:,2) = g1a(:,:,2) + matmul(a1(:,:,2),NOa)
!               g1a(:,:,3) = g1a(:,:,3) + matmul(a1(:,:,3),NOa)
!               g1b(:,:,1) = g1b(:,:,1) + matmul(a1(:,:,1),NOb)
!               g1b(:,:,2) = g1b(:,:,2) + matmul(a1(:,:,2),NOb)
!               g1b(:,:,3) = g1b(:,:,3) + matmul(a1(:,:,3),NOb)
!               g0a        = g0a        + matmul(a0,NOa)
!               g0b        = g0b        + matmul(a0,NOb)
!            else                                               ! Re-use b1, b0
!               g1a(:,:,1) = g1a(:,:,1) + matmul(b1(:,:,1),NOa)
!               g1a(:,:,2) = g1a(:,:,2) + matmul(b1(:,:,2),NOa)
!               g1a(:,:,3) = g1a(:,:,3) + matmul(b1(:,:,3),NOa)
!               g1b(:,:,1) = g1b(:,:,1) + matmul(b1(:,:,1),NOb)
!               g1b(:,:,2) = g1b(:,:,2) + matmul(b1(:,:,2),NOb)
!               g1b(:,:,3) = g1b(:,:,3) + matmul(b1(:,:,3),NOb)
!               g0a        = g0a        + matmul(b0,NOa)
!               g0b        = g0b        + matmul(b0,NOb)
!            end
!         else                                                  ! Do only overlapping atoms
!            do_a = .is_overlapping_atom(a,atoms(1))
!            if (atoms.dim==1) then; do_b = TRUE
!            else;                   do_b = .is_overlapping_atom(a,atoms(2))
!            end
!            if (do_a AND do_b) then                            ! Both overlap
!               .atom(a).make_significant_points(x,y,z,r2,skip,pt,cutoff)
!               n_cut = x.dim
!               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!                  .get_shell(sh,s,fs,ls)
!                  sh_grid1.create(n_cut,sh.n_comp,3)
!                  sh_grid0.create(n_cut,sh.n_comp)
!                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
!                  NOa => .natural_orbitals.alpha(fs:ls,:na)       ! Multiply by all orbitals
!                  NOb => .natural_orbitals.beta(fs:ls,:nb)
!                  gg1a.create(n_cut,na,3); gg1b.create(n_cut,nb,3)
!                  gg0a.create(n_cut,na);   gg0b.create(n_cut,nb)
!                  gg1a(:,:,1) = matmul(sh_grid1(:,:,1),NOa)
!                  gg1a(:,:,2) = matmul(sh_grid1(:,:,2),NOa)
!                  gg1a(:,:,3) = matmul(sh_grid1(:,:,3),NOa)
!                  gg1b(:,:,1) = matmul(sh_grid1(:,:,1),NOb)
!                  gg1b(:,:,2) = matmul(sh_grid1(:,:,2),NOb)
!                  gg1b(:,:,3) = matmul(sh_grid1(:,:,3),NOb)
!                  gg0a        = matmul(sh_grid0,NOa)
!                  gg0b        = matmul(sh_grid0,NOb)
!                  k = 0
!                  do i = 1,n_pt
!                     if (skip(i)) cycle
!                     k = k + 1
!                     g1a(i,:,1) = g1a(i,:,1) + gg1a(k,:,1)
!                     g1a(i,:,2) = g1a(i,:,2) + gg1a(k,:,2)
!                     g1a(i,:,3) = g1a(i,:,3) + gg1a(k,:,3)
!                     g1b(i,:,1) = g1b(i,:,1) + gg1b(k,:,1)
!                     g1b(i,:,2) = g1b(i,:,2) + gg1b(k,:,2)
!                     g1b(i,:,3) = g1b(i,:,3) + gg1b(k,:,3)
!                     g0a(i,:)   = g0a(i,:)   + gg0a(k,:)
!                     g0b(i,:)   = g0b(i,:)   + gg0b(k,:)
!                  end
!                  gg0b.destroy; gg0a.destroy
!                  gg1b.destroy; gg1a.destroy
!                  sh_grid0.destroy
!                  sh_grid1.destroy
!                  sh.destroy_ptr_part
!               end
!               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
!            else if (do_a) then                                ! Only the first overlaps
!               .atom(a).make_significant_points(x,y,z,r2,skip,pt(1:ma,:),cutoff)
!               n_cut = x.dim
!               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!                  .get_shell(sh,s,fs,ls)
!                  sh_grid1.create(n_cut,sh.n_comp,3)
!                  sh_grid0.create(n_cut,sh.n_comp)
!                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
!                  NOa => .natural_orbitals.alpha(fs:ls,:na)       ! Multiply by all orbitals
!                  NOb => .natural_orbitals.beta(fs:ls,:nb)
!                  gg1a.create(n_cut,na,3); gg1b.create(n_cut,nb,3)
!                  gg0a.create(n_cut,na);   gg0b.create(n_cut,nb)
!                  gg1a(:,:,1) = matmul(sh_grid1(:,:,1),NOa)
!                  gg1a(:,:,2) = matmul(sh_grid1(:,:,2),NOa)
!                  gg1a(:,:,3) = matmul(sh_grid1(:,:,3),NOa)
!                  gg1b(:,:,1) = matmul(sh_grid1(:,:,1),NOb)
!                  gg1b(:,:,2) = matmul(sh_grid1(:,:,2),NOb)
!                  gg1b(:,:,3) = matmul(sh_grid1(:,:,3),NOb)
!                  gg0a        = matmul(sh_grid0,NOa)
!                  gg0b        = matmul(sh_grid0,NOb)
!                  k = 0
!                  do i = 1,ma
!                     if (skip(i)) cycle
!                     k = k + 1
!                     g1a(i,:,1) = g1a(i,:,1) + gg1a(k,:,1)
!                     g1a(i,:,2) = g1a(i,:,2) + gg1a(k,:,2)
!                     g1a(i,:,3) = g1a(i,:,3) + gg1a(k,:,3)
!                     g1b(i,:,1) = g1b(i,:,1) + gg1b(k,:,1)
!                     g1b(i,:,2) = g1b(i,:,2) + gg1b(k,:,2)
!                     g1b(i,:,3) = g1b(i,:,3) + gg1b(k,:,3)
!                     g0a(i,:)   = g0a(i,:)   + gg0a(k,:)
!                     g0b(i,:)   = g0b(i,:)   + gg0b(k,:)
!                  end
!                  gg0b.destroy; gg0a.destroy
!                  gg1b.destroy; gg1a.destroy
!                  sh_grid0.destroy
!                  sh_grid1.destroy
!                  sh.destroy_ptr_part
!               end
!               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
!            else if (atoms.dim==2 AND do_b) then               ! Only the second overlaps
!               .atom(a).make_significant_points(x,y,z,r2,skip,pt(ma+1:,:),cutoff)
!               n_cut = x.dim
!               do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!                  .get_shell(sh,s,fs,ls)
!                  sh_grid1.create(n_cut,sh.n_comp,3)
!                  sh_grid0.create(n_cut,sh.n_comp)
!                  sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
!                  NOa => .natural_orbitals.alpha(fs:ls,:na)       ! Multiply by all orbitals
!                  NOb => .natural_orbitals.beta(fs:ls,:nb)
!                  gg1a.create(n_cut,na,3); gg1b.create(n_cut,nb,3)
!                  gg0a.create(n_cut,na);   gg0b.create(n_cut,nb)
!                  gg1a(:,:,1) = matmul(sh_grid1(:,:,1),NOa)
!                  gg1a(:,:,2) = matmul(sh_grid1(:,:,2),NOa)
!                  gg1a(:,:,3) = matmul(sh_grid1(:,:,3),NOa)
!                  gg1b(:,:,1) = matmul(sh_grid1(:,:,1),NOb)
!                  gg1b(:,:,2) = matmul(sh_grid1(:,:,2),NOb)
!                  gg1b(:,:,3) = matmul(sh_grid1(:,:,3),NOb)
!                  gg0a        = matmul(sh_grid0,NOa)
!                  gg0b        = matmul(sh_grid0,NOb)
!                  k = 0
!                  do i = ma+1,n_pt
!                     if (skip(i-ma)) cycle
!                     k = k + 1
!                     g1a(i,:,1) = g1a(i,:,1) + gg1a(k,:,1)
!                     g1a(i,:,2) = g1a(i,:,2) + gg1a(k,:,2)
!                     g1a(i,:,3) = g1a(i,:,3) + gg1a(k,:,3)
!                     g1b(i,:,1) = g1b(i,:,1) + gg1b(k,:,1)
!                     g1b(i,:,2) = g1b(i,:,2) + gg1b(k,:,2)
!                     g1b(i,:,3) = g1b(i,:,3) + gg1b(k,:,3)
!                     g0a(i,:)   = g0a(i,:)   + gg0a(k,:)
!                     g0b(i,:)   = g0b(i,:)   + gg0b(k,:)
!                  end
!                  gg0b.destroy; gg0a.destroy
!                  gg1b.destroy; gg1a.destroy
!                  sh_grid0.destroy
!                  sh_grid1.destroy
!                  sh.destroy_ptr_part
!               end
!               x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
!            end
!         end
!      end
!      rho1a = ZERO; rho1b = ZERO                               ! Now square up each natural orbital. 
!      rho0a = ZERO; rho0b = ZERO                               ! We can't skip any NO's since they
!      do n = 1,na                                              ! could be all delocalised.
!         occ = .occupation_numbers.alpha(n)
!         rho1a(:,1) = rho1a(:,1) + occ*g0a(:,n)*g1a(:,n,1)
!         rho1a(:,2) = rho1a(:,2) + occ*g0a(:,n)*g1a(:,n,2)
!         rho1a(:,3) = rho1a(:,3) + occ*g0a(:,n)*g1a(:,n,3)
!         rho0a      = rho0a      + occ*g0a(:,n)*g0a(:,n)
!      end
!      do n = 1,nb
!         occ = .occupation_numbers.beta(n)
!         rho1b(:,1) = rho1b(:,1) + occ*g0b(:,n)*g1b(:,n,1)
!         rho1b(:,2) = rho1b(:,2) + occ*g0b(:,n)*g1b(:,n,2)
!         rho1b(:,3) = rho1b(:,3) + occ*g0b(:,n)*g1b(:,n,3)
!         rho0b      = rho0b      + occ*g0b(:,n)*g0b(:,n)
!      end
!      g0b.destroy; g0a.destroy
!      g1b.destroy; g1a.destroy
!      list.destroy
!      rho1a = TWO*rho1a
!      rho1b = TWO*rho1b
!   end

!   make_nabla_density_grid_u_B(rho1a,rho1b,rho0a,rho0b,pt,atoms,a1,a0,b1,b0,cutoff)
!   ! Evaluate the alpha and beta nabla density grids "rho1a" and "rho1b" as well
!   ! as the density grid "rho0a" and "rhob" on a set of grid points "pt", for
!   ! use in matrix elements needed by DFT grid integration. "atoms" is a list of
!   ! indices of the atoms whose grid points are to be used in DFT integrations.
!   ! "a1", "a0", and "b1", "b0" are the basis function grids for the two atoms
!   ! listed in "atoms". These are the grids for the atoms whose matrix elements
!   ! are to be evaluated. We don't have to calculate the density contributions
!   ! for any atoms which do not have basis functions which overlap with those in
!   ! "atoms", because the orbital density from those atoms evaluated at those in
!   ! the "atoms" list will be negligible. NOTE: this routine depends on having
!   ! the .overlapping_atoms array defined. NOTE: it depends on having the
!   ! natural orbitals defined, and it may take much more memory than version A
!   ! above, but it may be quicker.
!      rho1a,rho1b :: MAT{REAL}, OUT
!      rho0a,rho0b :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      a1,b1 :: MAT3{REAL}
!      a0,b0 :: MAT{REAL}
!      cutoff :: REAL, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
!   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
!   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
!   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
!   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!   ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
!      sh :: SHELL1
!      skip :: VEC{BIN}*
!      x,y,z,r2 :: VEC{REAL}*
!      g1a,g1b,gg1a,gg1b,sh_grid1 :: MAT3{REAL}*
!      g0a,g0b,gg0a,gg0b,sh_grid0,NOa,NOb :: MAT{REAL}*
!      n_pt,n_cut,na,nb,a,s,f,l,fs,ls,n, i,k :: INT
!      occ :: REAL
!      n_pt = pt.dim1
!      na = .occupation_numbers.no_of_occupied("alpha")
!      nb = .occupation_numbers.no_of_occupied("beta")
!      ! Evaluate *all* the natural orbitals on the grid, to save calling
!      ! make_nabla_grid too many times
!      g1a.create(n_pt,na,3); g1b.create(n_pt,nb,3)
!      g0a.create(n_pt,na);   g0b.create(n_pt,nb)
!      g1a = ZERO; g1b = ZERO
!      g0a = ZERO; g0b = ZERO
!      do a = 1,.n_atom
!         if (any(a==atoms)) then                               ! Use the supplied grids
!            f = .first_basis_fn_for_atom(a)
!            l =  .last_basis_fn_for_atom(a)
!            NOa => .natural_orbitals.alpha(f:l,:na)            ! Multiply by all orbitals
!            NOb => .natural_orbitals.beta(f:l,:nb)
!            if (a==atoms(1)) then                              ! Re-use a1, a0
!               g1a(:,:,1) = g1a(:,:,1) + matmul(a1(:,:,1),NOa)
!               g1a(:,:,2) = g1a(:,:,2) + matmul(a1(:,:,2),NOa)
!               g1a(:,:,3) = g1a(:,:,3) + matmul(a1(:,:,3),NOa)
!               g1b(:,:,1) = g1b(:,:,1) + matmul(a1(:,:,1),NOb)
!               g1b(:,:,2) = g1b(:,:,2) + matmul(a1(:,:,2),NOb)
!               g1b(:,:,3) = g1b(:,:,3) + matmul(a1(:,:,3),NOb)
!               g0a        = g0a        + matmul(a0,NOa)
!               g0b        = g0b        + matmul(a0,NOb)
!            else                                               ! Re-use b1, b0
!               g1a(:,:,1) = g1a(:,:,1) + matmul(b1(:,:,1),NOa)
!               g1a(:,:,2) = g1a(:,:,2) + matmul(b1(:,:,2),NOa)
!               g1a(:,:,3) = g1a(:,:,3) + matmul(b1(:,:,3),NOa)
!               g1b(:,:,1) = g1b(:,:,1) + matmul(b1(:,:,1),NOb)
!               g1b(:,:,2) = g1b(:,:,2) + matmul(b1(:,:,2),NOb)
!               g1b(:,:,3) = g1b(:,:,3) + matmul(b1(:,:,3),NOb)
!               g0a        = g0a        + matmul(b0,NOa)
!               g0b        = g0b        + matmul(b0,NOb)
!            end
!         else if (.is_overlapping_atom(a,atoms)) then          ! Do only overlapping atoms
!            .atom(a).make_significant_points(x,y,z,r2,skip,pt,cutoff)
!            n_cut = x.dim
!            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!               .get_shell(sh,s,fs,ls)
!               sh_grid1.create(n_cut,sh.n_comp,3)
!               sh_grid0.create(n_cut,sh.n_comp)
!               sh.make_nabla_grid(sh_grid1,sh_grid0,x,y,z,r2,cutoff) ! Call this as little as possible
!               NOa => .natural_orbitals.alpha(fs:ls,:na)       ! Multiply by all orbitals
!               NOb => .natural_orbitals.beta(fs:ls,:nb)
!               gg1a.create(n_cut,na,3); gg1b.create(n_cut,nb,3)
!               gg0a.create(n_cut,na);   gg0b.create(n_cut,nb)
!               gg1a(:,:,1) = matmul(sh_grid1(:,:,1),NOa)
!               gg1a(:,:,2) = matmul(sh_grid1(:,:,2),NOa)
!               gg1a(:,:,3) = matmul(sh_grid1(:,:,3),NOa)
!               gg1b(:,:,1) = matmul(sh_grid1(:,:,1),NOb)
!               gg1b(:,:,2) = matmul(sh_grid1(:,:,2),NOb)
!               gg1b(:,:,3) = matmul(sh_grid1(:,:,3),NOb)
!               gg0a        = matmul(sh_grid0,NOa)
!               gg0b        = matmul(sh_grid0,NOb)
!               k = 0
!               do i = 1,n_pt
!                  if (skip(i)) cycle
!                  k = k + 1
!                  g1a(i,:,1) = g1a(i,:,1) + gg1a(k,:,1)
!                  g1a(i,:,2) = g1a(i,:,2) + gg1a(k,:,2)
!                  g1a(i,:,3) = g1a(i,:,3) + gg1a(k,:,3)
!                  g1b(i,:,1) = g1b(i,:,1) + gg1b(k,:,1)
!                  g1b(i,:,2) = g1b(i,:,2) + gg1b(k,:,2)
!                  g1b(i,:,3) = g1b(i,:,3) + gg1b(k,:,3)
!                  g0a(i,:)   = g0a(i,:)   + gg0a(k,:)
!                  g0b(i,:)   = g0b(i,:)   + gg0b(k,:)
!               end
!               gg0b.destroy; gg0a.destroy
!               gg1b.destroy; gg1a.destroy
!               sh_grid0.destroy
!               sh_grid1.destroy
!               sh.destroy_ptr_part
!            end
!            x.destroy; y.destroy; z.destroy; r2.destroy; skip.destroy
!         end
!      end
!      rho1a = ZERO; rho1b = ZERO                               ! Now square up each natural orbital. 
!      rho0a = ZERO; rho0b = ZERO                               ! We can't skip any NO's since they
!      do n = 1,na                                              ! could be all delocalised.
!         occ = .occupation_numbers.alpha(n)
!         rho1a(:,1) = rho1a(:,1) + occ*g0a(:,n)*g1a(:,n,1)
!         rho1a(:,2) = rho1a(:,2) + occ*g0a(:,n)*g1a(:,n,2)
!         rho1a(:,3) = rho1a(:,3) + occ*g0a(:,n)*g1a(:,n,3)
!         rho0a      = rho0a      + occ*g0a(:,n)*g0a(:,n)
!      end
!      do n = 1,nb
!         occ = .occupation_numbers.beta(n)
!         rho1b(:,1) = rho1b(:,1) + occ*g0b(:,n)*g1b(:,n,1)
!         rho1b(:,2) = rho1b(:,2) + occ*g0b(:,n)*g1b(:,n,2)
!         rho1b(:,3) = rho1b(:,3) + occ*g0b(:,n)*g1b(:,n,3)
!         rho0b      = rho0b      + occ*g0b(:,n)*g0b(:,n)
!      end
!      g0b.destroy; g0a.destroy
!      g1b.destroy; g1a.destroy
!      rho1a = TWO*rho1a
!      rho1b = TWO*rho1b
!   end

!   make_nabla_density_grid_u_B(rho1a,rho1b,rho0a,rho0b,pt,atoms,a1,a0,b1,b0)
!   ! Evaluate the alpha and beta nabla density grids "rho1a" and "rho1b" as well
!   ! as the density grid "rho0a" and "rhob" on a set of grid points "pt", for
!   ! use in matrix elements needed by DFT grid integration. "atoms" is a list of
!   ! indices of the atoms whose grid points are to be used in DFT integrations.
!   ! "a1", "a0", and "b1", "b0" are the basis function grids for the two atoms
!   ! listed in "atoms". These are the grids for the atoms whose matrix elements
!   ! are to be evaluated. We don't have to calculate the density contributions
!   ! for any atoms which do not have basis functions which overlap with those in
!   ! "atoms", because the orbital density from those atoms evaluated at those in
!   ! the "atoms" list will be negligible. NOTE: this routine depends on having
!   ! the .overlapping_atoms array defined. NOTE: it depends on having the
!   ! natural orbitals defined, and it may take much more memory than version A
!   ! above, but it may be quicker.
!      rho1a,rho1b :: MAT{REAL}, OUT
!      rho0a,rho0b :: VEC{REAL}, OUT
!      pt :: MAT{REAL}, IN
!      atoms :: VEC{INT}
!      a1,b1 :: MAT3{REAL}
!      a0,b0 :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(rho1a.dim1==pt.dim1,"rho1a has wrong 1st dimension")
!   ENSURE(rho1b.dim1==pt.dim1,"rho1b has wrong 1st dimension")
!   ENSURE(rho1a.dim2==3,"rho1a has wrong 2nd dimension")
!   ENSURE(rho1b.dim2==3,"rho1b has wrong 2nd dimension")
!   ENSURE(rho0a.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(rho0b.dim==pt.dim1,"rho0a has wrong 1st dimension")
!   ENSURE(pt.dim2==3,"pt has wrong 2nd dimension")
!   ENSURE(.overlapping_atoms.created,"no .overlappin_atoms")
!   ENSURE(.natural_orbitals.created("unrestricted"), "no restricted NO's")
!   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
!      sh :: SHELL1
!      g1a,g1b,sh_grid1 :: MAT3{REAL}*
!      g0a,g0b,sh_grid0,NOa,NOb :: MAT{REAL}*
!      n_pt,na,nb,a,s,f,l,fs,ls,n :: INT
!      occ :: REAL
!      n_pt = pt.dim1
!      na = .occupation_numbers.no_of_occupied("alpha")
!      nb = .occupation_numbers.no_of_occupied("beta")
!      ! Evaluate *all* the natural orbitals on the grid, to save calling
!      ! make_nabla_grid too many times
!      g1a.create(n_pt,na,3); g1b.create(n_pt,nb,3)
!      g0a.create(n_pt,na);   g0b.create(n_pt,nb)
!      g1a = ZERO; g1b = ZERO
!      g0a = ZERO; g0b = ZERO
!      do a = 1,.n_atom
!         if (any(a==atoms)) then                               ! Use the supplied grids
!            f = .first_basis_fn_for_atom(a)
!            l =  .last_basis_fn_for_atom(a)
!            NOa => .natural_orbitals.alpha(f:l,:na)            ! Multiply by all orbitals
!            NOb => .natural_orbitals.beta(f:l,:nb)
!            if (a==atoms(1)) then                              ! Re-use a1, a0
!               g1a(:,:,1) = g1a(:,:,1) + matmul(a1(:,:,1),NOa)
!               g1a(:,:,2) = g1a(:,:,2) + matmul(a1(:,:,2),NOa)
!               g1a(:,:,3) = g1a(:,:,3) + matmul(a1(:,:,3),NOa)
!               g1b(:,:,1) = g1b(:,:,1) + matmul(a1(:,:,1),NOb)
!               g1b(:,:,2) = g1b(:,:,2) + matmul(a1(:,:,2),NOb)
!               g1b(:,:,3) = g1b(:,:,3) + matmul(a1(:,:,3),NOb)
!               g0a        = g0a        + matmul(a0,NOa)
!               g0b        = g0b        + matmul(a0,NOb)
!            else                                               ! Re-use b1, b0
!               g1a(:,:,1) = g1a(:,:,1) + matmul(b1(:,:,1),NOa)
!               g1a(:,:,2) = g1a(:,:,2) + matmul(b1(:,:,2),NOa)
!               g1a(:,:,3) = g1a(:,:,3) + matmul(b1(:,:,3),NOa)
!               g1b(:,:,1) = g1b(:,:,1) + matmul(b1(:,:,1),NOb)
!               g1b(:,:,2) = g1b(:,:,2) + matmul(b1(:,:,2),NOb)
!               g1b(:,:,3) = g1b(:,:,3) + matmul(b1(:,:,3),NOb)
!               g0a        = g0a        + matmul(b0,NOa)
!               g0b        = g0b        + matmul(b0,NOb)
!            end
!         else if (.is_overlapping_atom(a,atoms)) then          ! Do only overlapping atoms
!            do s = .first_shell_for_atom(a),.last_shell_for_atom(a)
!               .get_shell(sh,s,fs,ls)
!               sh_grid1.create(n_pt,sh.n_comp,3)
!               sh_grid0.create(n_pt,sh.n_comp)
!               sh.make_nabla_grid(sh_grid1,sh_grid0,pt)        ! Call this as little as possible
!               NOa => .natural_orbitals.alpha(fs:ls,:na)       ! Multiply by all orbitals
!               NOb => .natural_orbitals.beta(fs:ls,:nb)
!               g1a(:,:,1) = g1a(:,:,1) + matmul(sh_grid1(:,:,1),NOa)
!               g1a(:,:,2) = g1a(:,:,2) + matmul(sh_grid1(:,:,2),NOa)
!               g1a(:,:,3) = g1a(:,:,3) + matmul(sh_grid1(:,:,3),NOa)
!               g1b(:,:,1) = g1b(:,:,1) + matmul(sh_grid1(:,:,1),NOb)
!               g1b(:,:,2) = g1b(:,:,2) + matmul(sh_grid1(:,:,2),NOb)
!               g1b(:,:,3) = g1b(:,:,3) + matmul(sh_grid1(:,:,3),NOb)
!               g0a        = g0a        + matmul(sh_grid0,NOa)
!               g0b        = g0b        + matmul(sh_grid0,NOb)
!               sh_grid0.destroy
!               sh_grid1.destroy
!               sh.destroy_ptr_part
!            end
!         end
!      end
!      rho1a = ZERO; rho1b = ZERO                               ! Now square up each natural orbital. 
!      rho0a = ZERO; rho0b = ZERO                               ! We can't skip any NO's since they
!      do n = 1,na                                              ! could be all delocalised.
!         occ = .occupation_numbers.alpha(n)
!         rho1a(:,1) = rho1a(:,1) + occ*g0a(:,n)*g1a(:,n,1)
!         rho1a(:,2) = rho1a(:,2) + occ*g0a(:,n)*g1a(:,n,2)
!         rho1a(:,3) = rho1a(:,3) + occ*g0a(:,n)*g1a(:,n,3)
!         rho0a      = rho0a      + occ*g0a(:,n)*g0a(:,n)
!      end
!      do n = 1,nb
!         occ = .occupation_numbers.beta(n)
!         rho1b(:,1) = rho1b(:,1) + occ*g0b(:,n)*g1b(:,n,1)
!         rho1b(:,2) = rho1b(:,2) + occ*g0b(:,n)*g1b(:,n,2)
!         rho1b(:,3) = rho1b(:,3) + occ*g0b(:,n)*g1b(:,n,3)
!         rho0b      = rho0b      + occ*g0b(:,n)*g0b(:,n)
!      end
!      g0b.destroy; g0a.destroy
!      g1b.destroy; g1a.destroy
!      rho1a = TWO*rho1a
!      rho1b = TWO*rho1b
!   end


   make_nabla_density_grid(np_a,np_b,pt)
   ! Make the alpha and beta nabla density grids, "np_a" and "np_b"
   ! respectively, from the unrestricted natural orbitals.
     np_a,np_b :: MAT{REAL}
     pt :: MAT{REAL}, IN
   ENSURE(.natural_orbitals.created("unrestricted"),"no natural orbitals")
   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
     nat :: MAT{REAL}*
     occ :: VEC{REAL}*
     nat => .natural_orbitals.restricted ! backup pointers
     occ => .occupation_numbers.restricted
     .natural_orbitals.restricted => .natural_orbitals.alpha
     .occupation_numbers.restricted => .occupation_numbers.alpha
     .make_nabla_density_grid(np_a,pt)
     .natural_orbitals.restricted => .natural_orbitals.beta
     .occupation_numbers.restricted => .occupation_numbers.beta
     .make_nabla_density_grid(np_b,pt)
     .natural_orbitals.restricted => nat ! restore backups
     .occupation_numbers.restricted => occ
   end

   make_nabla_density_grid(np_a,np_b,p_a,p_b,pt)
   ! Make the alpha and beta nabla density grids, "np_a" and "np_b"
   ! respectively, as well as the densities themselves, "pa" and "pb"
   ! respectively, on the set of grid points "pt", using the unrestricted
   ! natural orbitals.
     np_a,np_b :: MAT{REAL}, OUT
     p_a,p_b :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   ENSURE(.natural_orbitals.created("unrestricted"),"no natural orbitals")
   ENSURE(.occupation_numbers.created("unrestricted"),"no occupation numbers")
     nat :: MAT{REAL}*
     occ :: VEC{REAL}*
     nat => .natural_orbitals.restricted ! backup pointers
     occ => .occupation_numbers.restricted
     .natural_orbitals.restricted => .natural_orbitals.alpha
     .occupation_numbers.restricted => .occupation_numbers.alpha
     .make_nabla_density_grid(np_a,p_a,pt)
     .natural_orbitals.restricted => .natural_orbitals.beta
     .occupation_numbers.restricted => .occupation_numbers.beta
     .make_nabla_density_grid(np_b,p_b,pt)
     .natural_orbitals.restricted => nat ! restore backups
     .occupation_numbers.restricted => occ
   end

! ****************
! Plotting methods
! ****************

   plot ::: leaky
   ! Do one of the many kinds of plot calculations
   ENSURE(.grid.created, "no grid")
     dft :: BIN
     basis_kind :: STR
     .grid.put
     .set_ANO_info(.grid.plot_kind)
     select case (.grid.plot_kind)
        case("crystal_error_map                   "); .make_crystal_error_map
        case("current_density                     "); .make_j_grid
        case("deformation_density                 "); .make_deformation_density_grid
        case("deformation_dft_eff_potential       "); .make_def_dft_eff_pot_grid
        case("deformation_dft_energy              "); .make_def_dft_energy_grid
        case("deformation_dft_xc_potential        "); .make_def_dft_xc_pot_grid
        case("deformation_electric_potential      "); .make_def_e_pot_grid
        case("deformation_g_kinetic_energy        "); .make_def_G_kinetic_grid
        case("deformation_g_kirzhnits             "); .make_def_G_Kirzhnits_grid
        case("deformation_h_dft_energy            "); .make_def_H_dft_energy_grid
        case("deformation_h_from_virial           "); .make_def_H_from_virial_grid
        case("deformation_h_kirzhnits             "); .make_def_H_Kirzhnits_grid
        case("deformation_k_kinetic_energy        "); .make_def_K_kinetic_grid
        case("deformation_laplacian               "); .make_def_laplacian_grid
        case("deformation_v_from_virial           "); .make_def_V_from_virial_grid
        case("deformation_v_kirzhnits             "); .make_def_V_Kirzhnits_grid
        case("deformation_reduced_g_kinetic_energy"); .make_def_rG_kinetic_grid
        case("deformation_reduced_h_from_virial   "); .make_def_rH_from_virial_grid
        case("deformation_reduced_k_kinetic_energy"); .make_def_rK_kinetic_grid
        case("deformation_reduced_v_from_virial   "); .make_def_rV_from_virial_grid
        case("dft_eff_potential                   "); .make_dft_eff_pot_grid
        case("dft_energy                          "); .make_dft_energy_grid
        case("dft_xc_potential                    "); .make_dft_xc_pot_grid
        case("electric_potential                  "); .make_electric_potential_grid
        case("electron_density                    "); .make_electron_density_grid
        case("elf                                 "); .make_ELF_grid
        case("e_hf_density_from_rho               "); .make_E_hf_dens_from_rho_grid
      ! case("energy_density_from_rho             "); .make_deformation_density_grid
        case("fermi_mobility                      "); .make_fermi_mobility_grid
        case("g_kinetic_energy                    "); .make_G_kinetic_energy_grid
        case("g_kirzhnits                         "); .make_G_Kirzhnits_grid
        case("grad_rho_on_rho                     "); .make_grad_rho_on_rho_grid
        case("h_dft_energy                        "); .make_H_dft_energy_grid
        case("h_kirzhnits                         "); .make_H_Kirzhnits_grid
        case("h_from_virial                       "); .make_H_from_virial_grid
        case("j                                   "); .make_j_grid
        case("jd                                  "); .make_jd_grid
        case("jp                                  "); .make_jp_grid
        case("k_kinetic_energy                    "); .make_K_kinetic_energy_grid
        case("laplacian                           "); .make_laplacian_grid
        case("negative_laplacian                  "); .make_neg_laplacian_grid
        case("div_jp                              "); .make_div_jp_grid
        case("orbital_density                     "); .make_orbital_density_grid
        case("orbital                             "); .make_orbital_grid
        case("oscillator_orbital                  "); .make_oscillator_orbital_grid
        case("promolecule_density                 "); .make_promolecule_density_grid
        case("qq_plot                             "); .crystal.put_qq_plot
        case("reduced_g_kinetic_energy            "); .make_rG_kinetic_energy_grid
        case("reduced_h_from_virial               "); .make_rH_from_virial_grid
        case("reduced_k_kinetic_energy            "); .make_rK_kinetic_energy_grid
        case("reduced_v_from_virial               "); .make_rV_from_virial_grid
        case("solenoidal_jp                       "); .make_solenoidal_jp_grid
        case("spin_density                        "); .make_spin_density_grid
        case("stockholder_density                 "); .make_stockholder_density_grid
        case("stockholder_weight                  "); .make_stockholder_density_grid
        case("true_fermi_mobility                 "); .make_true_fermi_mobility_grid
        case("tsirelson_elf                       "); .make_Tsirelson_ELF_grid
        case("v_kirzhnits                         "); .make_V_Kirzhnits_grid
        case("v_from_virial                       "); .make_V_from_virial_grid
        case default;                UNKNOWN(.grid.plot_kind)
     end
   end

   bounding_cube_width result(width)
   ! Return "width", the width of a cube in which the molecule nicely sits.
   ! Suitable for generating plot widths.
      width :: REAL
      width = .atom.bounding_cube_width
   end

! **************************************
! Crystal structure factor residual maps
! **************************************

   make_crystal_error_map ::: leaky
   ! Work out the crystal_error map on ".grid". A Gnuplot ascii file is
   ! generated.
   ENSURE(.grid.created, "no grid")
      arch :: ARCHIVE
      map :: VEC{REAL}*
      map.create(.grid.n_pt)
      .make_crystal_error_map(map)
      .dump_plot_grid(map,"crystal_error_map")
      map.destroy
   end

   make_crystal_error_map(map)
   ! Make the crystal error "map".
      map :: VEC{REAL}
   ENSURE(.grid.created, "no grid")
      pt :: MAT{REAL}*
      n_pt :: INT
      map = ZERO
      n_pt = .grid.n_pt
      pt.create(n_pt,3); .grid.make_points(pt)
      .crystal.make_residual_error_map(map,pt)
      pt.destroy
   end

! *******************************
! Boys/Angyan oscillator orbitals
! *******************************

   make_oscillator_orbital_grid
   ! Work out the oscillator orbital on ".grid" using ".natural orbitals" for
   ! orbital "orb". 
   ENSURE(.grid.created, "no grid")
   ENSURE(.grid.orbital>=0, "non-positive grid orbital")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
   ENSURE(.localiser.created, "no localiser orbject created")
      pt :: MAT{REAL}*
      gr :: VEC{REAL}*
      sh :: SHELL1
      orb :: INT
      orb = .grid.orbital
      pt.create(.grid.n_pt,3); .grid.make_points(pt)
      if (.natural_orbitals.number_kind == "real") then
         gr.create(.grid.n_pt)
         .make_oscillator_orbital_grid_r(gr,orb,pt)
         .dump_plot_grid(gr,"orbital_"//trim(orb.to_str)//"_grid")
         gr.destroy
      else
         DIE("complex case not yet implemented")
      end
      pt.destroy
   end

   make_oscillator_orbital_grid_r(g,ind,pt,square)
   ! Evaluate the oscillator orbital density grid "g" for the localised orbital
   ! with index "ind" on a set of grid points "pt". You must supply on the input
   ! line the angular momentum "l" and component "n" of the oscillator orbital,
   ! which is an awful hack for the moment.
      g :: VEC{REAL}, OUT
      ind :: INT
      pt :: MAT{REAL}, IN
      square :: BIN, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.localiser.created, "no localiser orbject created")
      os :: VEC{REAL}*
      c  :: VEC{REAL}(3)
      l,n :: INT
      sh :: SHELL1
      os.create(pt.dim1)
      c = .localiser.dipole(ind,ind,:)
      stdin.read(l)
      stdin.read(n)
      sh.make_oscillator_orbital_mask(os,c,l,n,pt)
      .make_orbital_grid_r(g,.localiser.MO(:,ind),pt,square)
      g = g*os
      os.destroy
   end

   make_p_oscillator_orb_grid_r(g,ind,pt,square)
   ! Evaluate the oscillator orbital density grid "g" for the projected
   ! localised orbital with index "ind" on a set of grid points "pt". You must
   ! supply on the input line the angular momentum "l" and component "n" of the
   ! oscillator orbital, which is an awful hack for the moment.
      g :: VEC{REAL}, OUT
      ind :: INT
      pt :: MAT{REAL}, IN
      square :: BIN, optional
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.localiser.created, "no localiser orbject created")
      gg,os :: VEC{REAL}*
      c  :: VEC{REAL}(3)
      maxl,l,n,ln, i,j :: INT
      coeff :: REAL
      sh :: SHELL1
      gg.create(pt.dim1)
      os.create(pt.dim1)
      c = .localiser.dipole(ind,ind,:)
      stdin.read(maxl)
      stdin.read(l)
      stdin.read(n)
      ln = (l-1).n_comp_sum*.n_a + (ind-1)*l.n_comp + n
      .make_orbital_grid_r(gg,.localiser.MO(:,ind),pt,square)
      g = ZERO
      i = 0
      do l = 0,maxl
      do n = 1,l.n_comp
      do j = 1,.n_a
         i = i + 1
         coeff = .localiser.TM(i,ln)
         if (coeff.is_zero) cycle
         sh.make_oscillator_orbital_mask(os,c,l,n,pt)
         g = g + coeff*gg*os
      end
      end
      end
      os.destroy; gg.destroy
   end

! *********
! Templates
! *********

   density_grid ::: template
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.grid.created, "no grid")
      grid :: VEC{REAL}*
      pt :: MAT{REAL}*
      grid.create(.grid.n_pt)
      pt.create(.grid.n_pt,3); .grid.make_points(pt)
      MAKE_GRID(grid,pt)
      .dump_plot_grid(grid,LABEL)
      pt.destroy
      grid.destroy
   end

   deformation_grid(grid,pt) ::: template
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   ENSURE(.natural_orbitals.created,"no natural orbitals")
   ENSURE(.occupation_numbers.created,"no natural orbitals")
   ENSURE(.atom.has_all_ANO_data,"no atomic natural orbitals")
     promolecule_grid :: VEC{REAL}*
     MAKE_GRID(grid,pt)
     promolecule_grid.create(grid.dim)
     MAKE_PRO_GRID(promolecule_grid,pt)
     grid = grid - promolecule_grid
     promolecule_grid.destroy
   end

   pro_grid(density_grid,pt) ::: template
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
     self :: IN
     density_grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
     grid :: VEC{REAL}*
     a :: INT
     grid.create(density_grid.dim)
     density_grid = ZERO
     do a = 1,.n_atom
        .atom(a).MAKE_GRID(grid,pt)
        density_grid = density_grid + grid
     end
     grid.destroy
   end

   pro_dft_grid(density_grid,pt) ::: template
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
     self :: IN
     density_grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
     grid :: VEC{REAL}*
     a :: INT
     grid.create(density_grid.dim)
     density_grid = ZERO
     do a = 1,.n_atom
        .atom(a).MAKE_GRID(grid,pt,.scfdata.dft_exchange_functional,.scfdata.dft_correlation_functional)
        density_grid = density_grid + grid
     end
     grid.destroy
   end

   dump_plot_grid(grid,name)
   ! Dump out the plot "grid" to an appropriate with with "name", in various
   ! formats. If present, "factor" is a conversion factor to apply.
      grid :: VEC{REAL}
      name :: STR
   ENSURE(.grid.created, "no grid")
   ENSURE(.atom.created, "no atoms")
      arch :: ARCHIVE
      fac :: REAL
      if (.grid.plot_units/=" ") then
         fac = .grid.plot_units.conversion_factor
         grid = fac*grid
      end
      if (.grid.use_plot_max) then
         where (grid>.grid.plot_max) grid = .grid.plot_max
      end
      if (.grid.use_plot_min) then
         where (grid<.grid.plot_min) grid = .grid.plot_min
      end
      if (.grid.plot_format==" ") then   ! dump all formats
         arch.set(.name,name,format="gnuplot")
         arch.write_gnuplot(grid, .grid.n_x, .grid.n_y, .grid.n_z)
         arch.set(.name,name,format="mathematica")
         arch.write_mathematica(grid, .grid.n_x, .grid.n_y, .grid.n_z)
         arch.set(.name,name,format="contour")
         arch.write_contour_a_la_nancy(grid,.grid,.atom)
         arch.set(.name,name,format="gaussian.cube")
         arch.write_gaussian_cube(grid,.grid,.atom,name)
         arch.set(.name,name,format="xdgraph")
         arch.write_a_la_xdgraph(grid,.grid,.atom)
      else
         select case (.grid.plot_format) ! dump specified format
            case ("contour")
               arch.set(.name,name,format="contour")
               arch.write_contour_a_la_nancy(grid,.grid,.atom)
            case ("cube")
               arch.set(.name,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.grid,.atom,name)
            case ("gnuplot")
               arch.set(.name,name,format="gnuplot")
               arch.write_gnuplot(grid, .grid.n_x, .grid.n_y, .grid.n_z)
            case ("gaussian")
               arch.set(.name,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.grid,.atom,name)
            case ("gaussian.cube")
               arch.set(.name,name,format="gaussian.cube")
               arch.write_gaussian_cube(grid,.grid,.atom,name)
            case ("mathematica")
               arch.set(.name,name,format="mathematica")
               arch.write_mathematica(grid, .grid.n_x, .grid.n_y, .grid.n_z)
            case ("xdgraph")
               arch.set(.name,name,format="xdgraph")
               arch.write_a_la_xdgraph(grid,.grid,.atom)
            case default
               UNKNOWN(.grid.plot_format)
         end
      end
   end

! **********************
! Electron density grids
! **********************

   make_electron_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_density_grid, LABEL=>"electron_density_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_deformation_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_deformation_density_grid, LABEL=>"deformation_density_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_deformation_density_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_density_grid, MAKE_PRO_GRID=>.make_promolecule_density_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_spin_density_grid
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.grid.created, "no grid")
      pt :: MAT{REAL}*
      grid :: VEC{REAL}*
      grid.create(.grid.n_pt)
      pt.create(.grid.n_pt,3); .grid.make_points(pt)
      .make_density_grid(grid,pt,sgn=-1)
      .dump_plot_grid(grid,"spin_density_grid")
      pt.destroy
      grid.destroy
   end

! **************************
! Laplacian density routines
! **************************

   make_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_laplacian_grid, LABEL=>"laplacian_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind == "real") then
        .make_laplacian_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_laplacian_grid_r(laplacian_grid,pt)
   ! Make the "laplacian_grid" for the supplied points "pt" from restricted
   ! real natural orbitals
     laplacian_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
     NO :: VEC{REAL}*
     P,D :: MAT{REAL}*
     n_occ,n,n_pt :: INT
     n_pt = pt.dim1
     laplacian_grid = ZERO
     NO.create(n_pt)
     P.create(n_pt,3)
     D.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       laplacian_grid(:) = laplacian_grid(:) +  &
          .occupation_numbers.restricted(n) * ( &
          NO * (D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3)))
     end
     laplacian_grid(:) = TWO*laplacian_grid(:)
     D.destroy
     P.destroy
     NO.destroy
   end

   make_def_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_laplacian_grid, LABEL=>"deformation_laplacian_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_laplacian_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_laplacian_grid, MAKE_PRO_GRID=>.make_pro_laplacian_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_laplacian_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_laplacian_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_neg_laplacian_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_neg_laplacian_grid, LABEL=>"negative_laplacian_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_neg_laplacian_grid(laplacian_grid,pt)
   ! Work out the electron "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind == "real") then
        .make_laplacian_grid_r(laplacian_grid,pt)
        laplacian_grid = -laplacian_grid
      else
        DIE("code not written yet")
      end
   end


   make_rL_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rL_grid, LABEL=>"reduced_laplacian_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rL_grid(laplacian_grid,pt)
   ! Work out the reduced "laplacian_grid" on "pt" using ".natural orbitals"
   ! and  the ".occupation_numbers" vector.
      laplacian_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind == "real") then
        .make_rL_grid_r(laplacian_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rL_grid_r(laplacian_grid,pt)
   ! Make the reduced "laplacian_grid" for the supplied points "pt" from
   ! restricted real natural orbitals
     laplacian_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
     rho,NO :: VEC{REAL}*
     P,D :: MAT{REAL}*
     n_occ,n,n_pt :: INT
     occ :: REAL
     n_pt = pt.dim1
     laplacian_grid = ZERO
     rho.create(n_pt); rho = ZERO
     NO.create(n_pt)
     P.create(n_pt,3)
     D.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       laplacian_grid = laplacian_grid +  occ * ( &
          NO * (D(:,1)+D(:,2)+D(:,3)) + (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3)))
       rho = rho + occ*NO*NO
     end
     laplacian_grid = TWO*laplacian_grid/rho
     D.destroy
     P.destroy
     NO.destroy
     rho.destroy
   end

! *******************************
! K-type kinetic density routines
! *******************************

   make_K_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_K_kinetic_energy_grid, LABEL=>"K_kinetic_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_K_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type kinetic energy density (using the nabla^2) on "pt" using
   ! ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_K_kinetic_density_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_K_kinetic_density_grid_r(K_grid,pt)
   ! Make the K-type kinetic energy density "K_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
     K_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
     NO :: VEC{REAL}*
     P,D :: MAT{REAL}*
     n_occ,n,n_pt :: INT
     n_pt = pt.dim1
     K_grid = ZERO
     NO.create(n_pt)
     P.create(n_pt,3)
     D.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       K_grid(:) = K_grid(:) &
                 + .occupation_numbers.restricted(n) * NO * (D(:,1)+D(:,2)+D(:,3)) 
     end
     K_grid(:) = -HALF*K_grid(:)
     D.destroy
     P.destroy
     NO.destroy
   end

   make_def_K_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_K_kinetic_grid, LABEL=>"deformation_K_kinetic_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_K_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_K_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_K_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_K_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_K_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rK_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rK_kinetic_energy_grid, LABEL=>"reduced_K_kinetic_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rK_kinetic_energy_grid(K_grid,pt)
   ! Work out the K-type reduced kinetic energy density (using the nabla^2) on
   ! "pt" using ".natural orbitals" and  the ".occupation_numbers" vector.
      K_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_rK_kinetic_density_grid_r(K_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rK_kinetic_density_grid_r(K_grid,pt)
   ! Make the K-type reduced kinetic energy density "K_grid" for the supplied
   ! points "pt" from restricted real natural orbitals
     K_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
     NO,rho :: VEC{REAL}*
     P,D :: MAT{REAL}*
     n_occ,n,n_pt :: INT
     occ :: REAL
     n_pt = pt.dim1
     K_grid = ZERO
     rho.create(n_pt); rho = ZERO
     NO.create(n_pt)
     P.create(n_pt,3)
     D.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_laplacian_orbital_grid_r(D,P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       K_grid = K_grid + occ*NO*(D(:,1)+D(:,2)+D(:,3)) 
       rho = rho + occ*NO*NO
     end
     K_grid = -HALF*K_grid/rho
     D.destroy
     P.destroy
     NO.destroy
     rho.destroy
   end

   make_def_rK_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rK_kinetic_grid, LABEL=>"deformation_reduced_K_kinetic_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rK_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rK_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_rK_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_rK_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rK_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! *******************************
! G-type kinetic density routines
! *******************************

   make_G_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_G_kinetic_energy_grid, LABEL=>"G_kinetic_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_G_kinetic_energy_grid(G_grid,pt)
   ! Work out the G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_G_kinetic_density_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_G_kinetic_density_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
     G_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
     NO :: VEC{REAL}*
     P :: MAT{REAL}*
     n_occ,n,n_pt :: INT
     n_pt = pt.dim1
     G_grid = ZERO
     NO.create(n_pt)
     P.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       G_grid(:) = G_grid(:) &
                 + .occupation_numbers.restricted(n) &
                 * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
     end
     G_grid(:) = HALF*G_grid(:)
     P.destroy
     NO.destroy
   end


   make_G_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_G_Kirzhnits_grid, LABEL=>"G_Kirzhnits_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_G_Kirzhnits_grid(G_grid,pt)
   ! Work out the G-type Kirzhnits kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_G_Kirzhnits_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_G_Kirzhnits_grid_r(G_grid,pt)
   ! Make the G-type Kirzhnits kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
     G_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
     NO,rho,nab_ro2,lap_rho :: VEC{REAL}*
     G,L,nab_rho :: MAT{REAL}*
     lambda,k2,fac,occ,occ2 :: REAL
     n_occ,n,n_pt :: INT
     n_pt = pt.dim1
     rho.create(n_pt);       rho = ZERO
     lap_rho.create(n_pt);   lap_rho = ZERO 
     nab_ro2.create(n_pt)
     nab_rho.create(n_pt,3); nab_rho = ZERO 
     NO.create(n_pt)
     G.create(n_pt,3)
     L.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_laplacian_orbital_grid_r(L,G,NO,.natural_orbitals.restricted(:,n), pt)
       occ  = .occupation_numbers.restricted(n)
       occ2 = TWO*occ
       rho  = rho + occ *NO*NO
       nab_rho(:,1) = nab_rho(:,1) + occ2*NO*G(:,1)
       nab_rho(:,2) = nab_rho(:,2) + occ2*NO*G(:,2)
       nab_rho(:,3) = nab_rho(:,3) + occ2*NO*G(:,3)
       lap_rho = lap_rho + occ2*(NO*(L(:,1)+L(:,2)+L(:,3)) + (G(:,1)*G(:,1) + G(:,2)*G(:,2) + G(:,3)*G(:,3)))
     end
     L.destroy; G.destroy; NO.destroy
     nab_ro2 = nab_rho(:,1)*nab_rho(:,1) + nab_rho(:,2)*nab_rho(:,2) + nab_rho(:,3)*nab_rho(:,3)
     nab_rho.destroy
     lambda = ONE/72.0d0
     k2 = HALF/SIX
     fac = 0.3d0*(THREE*PI*PI)**(TWOTHIRDS)
     G_grid = fac*rho**(FIVE/THREE) + lambda*nab_ro2/rho + k2*lap_rho
     nab_ro2.destroy; lap_rho.destroy; rho.destroy
   end


   make_def_G_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_G_kinetic_grid, LABEL=>"deformation_G_kinetic_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_G_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_G_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_G_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_G_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_G_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_def_G_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_G_Kirzhnits_grid, LABEL=>"deformation_G_Kirzhnits_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_G_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_G_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_G_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_G_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_G_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rG_kinetic_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rG_kinetic_energy_grid, LABEL=>"reduced_G_kinetic_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rG_kinetic_energy_grid(G_grid,pt)
   ! Work out the reduced G-type kinetic density (using nabla phi.nabla phi) on "pt"
   ! using ".natural orbitals" and  the ".occupation_numbers" vector.
      G_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
      if (.natural_orbitals.number_kind=="real") then
        .make_rG_kinetic_density_grid_r(G_grid,pt)
      else
        DIE("code not written yet")
      end
   end

   make_rG_kinetic_density_grid_r(G_grid,pt)
   ! Make the G-type kinetic energy density "G_grid" for the supplied points
   ! "pt" from restricted real natural orbitals
     G_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(pt.dim2==3, "wrong dimension for pt array")
   ENSURE(.natural_orbitals.created("restricted"), "no restricted NO's")
   ENSURE(.occupation_numbers.restricted.created, "no occupation #'s")
     rho,NO :: VEC{REAL}*
     P :: MAT{REAL}*
     n_occ,n,n_pt :: INT
     occ :: REAL
     n_pt = pt.dim1
     G_grid = ZERO
     rho.create(n_pt); rho = ZERO
     NO.create(n_pt)
     P.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_nabla_orbital_grid_r(P,NO,.natural_orbitals.restricted(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       G_grid = G_grid + occ * (P(:,1)*P(:,1) + P(:,2)*P(:,2) + P(:,3)*P(:,3))
       rho = rho + occ*NO*NO
     end
     G_grid = HALF*G_grid/rho
     P.destroy
     NO.destroy
     rho.destroy
   end

   make_def_rG_kinetic_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rG_kinetic_grid, LABEL=>"deformation_reduced_G_kinetic_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rG_kinetic_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rG_kinetic_energy_grid, MAKE_PRO_GRID=>.make_pro_rG_kinetic_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_rG_kinetic_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rG_kinetic_energy_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! *****************************
! Energy density from rho grids
! *****************************

   make_E_hf_dens_from_rho_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_E_hf_dens_from_rho_grid, LABEL=>"E_hf_density_from_rho_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_E_hf_dens_from_rho_grid(E_grid,pt)
   ! Work out the energy density as the scaled electron density.
      E_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scfdata") 
   ENSURE(.scfdata.scf_kind.is_one_of(["rhf","uhf"]),"scf kind is not Hartree-Fock") 
      fac :: REAL
      .make_density_grid(E_grid,pt)
      fac = .scfdata.energy/.n_e
      E_grid = fac*E_grid
   end

   make_def_E_hf_from_rho_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_E_hf_dens_from_rho_grid, MAKE_PRO_GRID=>.make_E_hf_dens_from_rho_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

! ********************************************************
! H-type total energy density obtained from virial theorem
! ********************************************************

   make_H_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_from_virial_grid, LABEL=>"H_from_virial_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_from_virial_grid(H_grid,pt)
   ! Work out the energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(.grid.n_pt)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_def_H_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_from_virial_grid, LABEL=>"deformation_H_from_virial_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_from_virial_grid, MAKE_PRO_GRID=>.make_pro_H_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_H_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_H_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_H_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_Kirzhnits_grid, LABEL=>"H_Kirzhnits_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_Kirzhnits_grid(H_grid,pt)
   ! Work out the energy density using the Kirzhnits relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(.grid.n_pt)
      .make_G_Kirzhnits_grid(G_grid,pt)
      .make_laplacian_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_def_H_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_Kirzhnits_grid, LABEL=>"deformation_H_Kirzhnits_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_H_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_H_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_H_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rH_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rH_from_virial_grid, LABEL=>"reduced_H_from_virial_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rH_from_virial_grid(H_grid,pt)
   ! Work out the reduced energy density using the virial relationsip 2G + V = (1/4) L,
   ! or H = G + V = (1/4)L - G
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
      G_grid :: VEC{REAL}*
      G_grid.create(.grid.n_pt)
      .make_rG_kinetic_energy_grid(G_grid,pt)
      .make_rL_grid(H_grid,pt)
      H_grid = QUARTER*H_grid - G_grid
      G_grid.destroy
   end

   make_def_rH_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rH_from_virial_grid, LABEL=>"deformation_reduced_H_from_virial_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rH_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rH_from_virial_grid, MAKE_PRO_GRID=>.make_pro_rH_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_rH_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rH_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! *****************************************************
! Potential energy density obtained from virial theorem
! *****************************************************

   make_V_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_V_from_virial_grid, LABEL=>"V_from_virial_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_V_from_virial_grid(V,pt)
   ! Work out the energy density from usiang the virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(.grid.n_pt)
      .make_G_kinetic_energy_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

   make_def_V_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_V_from_virial_grid, LABEL=>"deformation_V_from_virial_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_V_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_V_from_virial_grid, MAKE_PRO_GRID=>.make_pro_V_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_V_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_V_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_V_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_V_Kirzhnits_grid, LABEL=>"V_Kirzhnits_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_V_Kirzhnits_grid(V,pt)
   ! Work out the energy density from usiang the Kirzhnits theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(.grid.n_pt)
      .make_G_Kirzhnits_grid(G,pt)
      .make_laplacian_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

   make_def_V_Kirzhnits_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_V_Kirzhnits_grid, LABEL=>"deformation_V_Kirzhnits_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_V_Kirzhnits_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_V_Kirzhnits_grid, MAKE_PRO_GRID=>.make_pro_V_Kirzhnits_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_V_Kirzhnits_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_V_Kirzhnits_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end


   make_rV_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_rV_from_virial_grid, LABEL=>"reduced_V_from_virial_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_rV_from_virial_grid(V,pt)
   ! Work out the energy density from usiang the virial theorem: V = (1/4) L - 2G
      V :: VEC{REAL}
      pt :: MAT{REAL}
      G :: VEC{REAL}*
      G.create(.grid.n_pt)
      .make_rG_kinetic_energy_grid(G,pt)
      .make_rL_grid(V,pt)
      V = QUARTER*V - TWO*G
      G.destroy
   end

   make_def_rV_from_virial_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_rV_from_virial_grid, LABEL=>"deformation_reduced_V_from_virial_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_rV_from_virial_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_rV_from_virial_grid, MAKE_PRO_GRID=>.make_pro_rV_from_virial_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_rV_from_virial_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_rV_from_virial_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! ******************
! Electric potential
! ******************

   make_electric_potential_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_electric_potential_grid, LABEL=>"electric_potential_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

!   make_electric_potential_grid
!   ! Make the electric potential "pot_grid" on ".grid"
!   ENSURE(.grid.created,  "no grid")
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.any_created, "no density matrix")
!     pot_grid :: VEC{REAL}*
!     pt :: MAT{REAL}*
!     pot_grid.create(.grid.n_pt)
!     pt.create(.grid.n_pt,3); .grid.make_points(pt)
!     .make_electric_potential_grid(pot_grid,pt)
!     pt.destroy
!     .dump_plot_grid(pot_grid,"electric_potential_grid")
!     pot_grid.destroy
!   end

   make_electric_potential_grid(pot_grid,pt)
   ! Make the electric potential "pot_grid" on a series of points "pt"
     pot_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
     .make_ao_density_matrix
     if (.density_matrix.number_kind == "real") then
       .make_electric_potential_grid_r(pot_grid,pt,.density_matrix.restricted)
     else
       .make_electric_potential_grid_c(pot_grid,pt,.density_matrix.restricted_complex)
     end
   end

   make_electric_potential_grid_r(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
     pot_grid :: VEC{REAL}
     pt :: MAT{REAL}
     dens :: MAT{REAL}, target
     elec_grid :: VEC{REAL}*
     .nuclear_potential(pot_grid,pt)
     elec_grid.create(size(pot_grid))
     .make_electronic_pot_grid_r(elec_grid,pt,dens)
     pot_grid = pot_grid + elec_grid
     elec_grid.destroy
   end

   make_electric_potential_grid_c(pot_grid,pt,dens)
   ! Make the total electric potential "pot_grid" on a series of grid points
   ! "pt" using AO density matrix "dens"
     pot_grid :: VEC{REAL}
     pt :: MAT{REAL}
     dens :: MAT{CPX}, target
     elec_grid :: VEC{REAL}*
     .nuclear_potential(pot_grid,pt)
     elec_grid.create(size(pot_grid))
     .make_electronic_pot_grid_c(elec_grid,pt,dens)
     pot_grid = pot_grid + elec_grid
     elec_grid.destroy
   end

   make_electronic_pot_grid(pot_grid,pt)
   ! Make the electronic potential "pot_grid" on a series of points "pt"
     pot_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
     .make_ao_density_matrix
     if (.density_matrix.number_kind == "real") then
       .make_electronic_pot_grid_r(pot_grid,pt,.density_matrix.restricted)
     else
       .make_electronic_pot_grid_c(pot_grid,pt,.density_matrix.restricted_complex)
     end
   end

   make_electronic_pot_grid_r(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{REAL}, target
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      Vab,Dba :: MAT{REAL}*
      n_pt,q,fa,fb,la,lb,k :: INT
      sh :: SHELL2
      n_pt = pt.dim1
      pot_grid = ZERO
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         Dba => dens(fa:la,fb:lb)
         Vab.create(sh.a.n_comp,sh.b.n_comp)
         if (fa/=fb) then
           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*Dba)
           end
         else
           do k = 1,n_pt
             sh.get_nuc(Vab,ONE,pt(k,:))
             pot_grid(k) = pot_grid(k) - sum(Vab*Dba)
           end
         end
         Vab.destroy
         sh.destroy_ptr_part
      end
   end

   make_electronic_pot_grid_c(pot_grid,pt,dens)
   ! Make the electronic potential "pot_grid" on a series of grid points "pt"
   ! using AO density matrix "dens"
      pot_grid :: VEC{REAL}
      pt :: MAT{REAL}
      dens :: MAT{CPX}, target
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      Vab :: MAT{REAL}*
      Dba :: MAT{CPX}*
      n_pt,q,fa,fb,la,lb,k :: INT
      sh :: SHELL2
      n_pt = pt.dim1
      pot_grid = ZERO
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         Dba => dens(fa:la,fb:lb)
         Vab.create(sh.a.n_comp,sh.b.n_comp)
         if (fa/=fb) then
           do k = 1,n_pt
             sh.make_nuclear_attraction_ints(Vab,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*real(Dba,kind=REAL_KIND))
           end
         else
           do k = 1,n_pt
             sh.make_nuclear_attraction_ints(Vab,pt(k,:))
             pot_grid(k) = pot_grid(k) - TWO*sum(Vab*real(Dba,kind=REAL_KIND))
           end
         end
         Vab.destroy
         sh.destroy_ptr_part
      end
   end

   make_def_e_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_e_pot_grid, LABEL=>"deformation_electric_potential_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_e_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_electric_potential_grid, MAKE_PRO_GRID=>.make_pro_e_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_e_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_electric_potential_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

! ****************
! DFT xc potential
! ****************

   make_dft_xc_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_xc_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_potential_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_xc_pot_grid(V,pt)
   ! Work out the DFT potential on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      V :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
      dft :: DFT_FUNCTIONAL
      rho :: VEC{REAL}*
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      V = ZERO
      dft.r_potential(.scfdata.dft_exchange_functional,V,rho)
      dft.r_potential(.scfdata.dft_correlation_functional,V,rho)
      rho.destroy
   end

   make_def_dft_xc_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_xc_pot_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_potential_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_xc_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_xc_pot_grid, MAKE_PRO_GRID=>.make_pro_dft_xc_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_dft_xc_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_xc_pot_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

! ***********************
! DFT effective potential
! ***********************

! The effective potential includes the classical electrostatic potential

   make_dft_eff_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_eff_pot_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_eff_potential_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_eff_pot_grid(V,pt)
   ! Work out the Slater DFT potential "V" (i.e. the Slater potential plus the
   ! classical electric potential) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
   ENSURE(NOT .scfdata.using_GGA_functional,"so far, must not be a GGA functional")
      rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL
      .make_electric_potential_grid(V,pt)
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.r_potential(.scfdata.dft_exchange_functional,V,rho)
      dft.r_potential(.scfdata.dft_correlation_functional,V,rho)
      rho.destroy
   end

   make_def_dft_eff_pot_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_eff_pot_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_eff_potential_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_eff_pot_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_eff_pot_grid, MAKE_PRO_GRID=>.make_pro_dft_eff_pot_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_dft_eff_pot_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_eff_pot_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

! ******************
! DFT energy density
! ******************

! The energy density includes the classical electrostatic potential, but no
! kinetic energy density terms

   make_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_dft_energy_grid, LABEL=>trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_dft_energy_grid(V,pt)
   ! Work out the Slater DFT energy "V" (i.e. the Slater potential times the
   ! density plus the classical electric energy) on a grid of points "pt".
      V :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"so far, must be a DFT calculation")
      Ve,rho :: VEC{REAL}*
      dft :: DFT_FUNCTIONAL
      .nuclear_potential(V,pt)
      Ve.create(V.dim)
      .make_electronic_pot_grid(Ve,pt)
      V = -V - HALF*Ve
      Ve.destroy
      rho.create(V.dim)
      .make_density_grid(rho,pt)
      dft.r_energy_density(.scfdata.dft_exchange_functional,V,rho)
      dft.r_energy_density(.scfdata.dft_correlation_functional,V,rho)
      V = V*rho
      rho.destroy
   end

   make_def_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_dft_energy_grid, LABEL=>"deformation_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_dft_energy_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_dft_energy_grid, MAKE_PRO_GRID=>.make_pro_dft_energy_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_dft_energy_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_dft_energy_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

! *************************
! H-type DFT energy density
! *************************

! H = G + V(DFT)

   make_H_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_H_dft_energy_grid, LABEL=>"H_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_H_dft_energy_grid(H_grid,pt)
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
      H_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.scfdata.created,"no scf data, for DFT functional")
   ENSURE(.scfdata.is_DFT_calculation,"must be a DFT calculation")
      G_grid :: VEC{REAL}*
      G_grid.create(.grid.n_pt)
      .make_G_kinetic_energy_grid(G_grid,pt)
      .make_dft_energy_grid(H_grid,pt)
      H_grid = H_grid + G_grid
      G_grid.destroy
   end

   make_def_H_dft_energy_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_def_H_dft_energy_grid, LABEL=>"deformation_H_"//trim(.scfdata.DFT_functional_name)//"_energy_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_def_H_dft_energy_grid(grid,pt) ::: get_from(MOLECULE:deformation_grid, MAKE_GRID=>.make_H_dft_energy_grid, MAKE_PRO_GRID=>.make_pro_H_dft_energy_grid)
   ! Make a Gnuplot ascii file containing the deformation density grid.
     grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   end

   make_pro_H_dft_energy_grid(density_grid,pt) ::: get_from(MOLECULE:pro_dft_grid, MAKE_GRID=>make_H_dft_energy_grid)
   ! Work out the promolecule DFT "density_grid" from the supplied points "pt".  
   end

! *******************************
! Stockholder/promolecule density
! *******************************

   make_stockholder_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_stockholder_density_grid, LABEL=>"stockholder_density_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

   make_stockholder_density_grid(density_grid,pt)
   ! Make the Hirschfeld stockholder "density_grid" for the supplied points
   ! "pt". The promolecule electron density used to define the Hirshfeld surface
   ! is calculated as follows: if a slater basis set is available, then that is
   ! used to calculate the promolecule electron density; if a coppens basis set
   ! is available, then that is used to get the promolecule density; otherwise,
   ! if restricted real natural orbitals are available for all atoms (in terms
   ! of gaussian basis functions), then those are used to calculate the
   ! promolecule densisties. In principle, we can caculate Hirshfeld surfaces
   ! for *molecular* fragment densities, rather than promolecule densities as
   ! done here. That would require a different keyword and different code.
     self :: IN
     density_grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   ENSURE(.cluster.created, "no cluster data")
   ENSURE(.cluster.info_made, "no cluster info")
   ENSURE(.cluster.radius>ZERO, "cluster radius is zero")
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
     grid,rho_fragment :: VEC{REAL}*
     !box :: MAT{REAL}(2,3)
     !sphere_pos,diff :: VEC{REAL}(3)
     !sphere_radius,dist,cutoff :: REAL
     !isosurface_skip :: BIN
     !min_exp :: REAL
     n_pt, a :: INT
     n_pt = density_grid.dim
     grid.create(n_pt)
     ! Make the central position and radius of the cluster
     ! pt.make_enclosing_sphere(sphere_pos,sphere_radius)
     ! Make the limits of the enclosing box
     ! pt.make_enclosing_box(box) 
     ! cutoff = TOL(30)
     ! isosurface_skip = FALSE
     ! if (.isosurface.created) then
     !    isosurface_skip = .isosurface.triangulation_method=="recursive_marching_cube" &
     !       AND .isosurface.level>=.isosurface.scan_level
     ! end
     !-------------------------------------------------------------------------
     ! As you can see, quite a lot of effort was expended to try and devise
     ! cutoff schemes that could give the HS quickly. These schemes have mostly
     ! all failed because it is difficult to give a good test which eliminates
     ! atoms from the stockholder term and which *doesn't* lead to unsmooth
     ! behaviour. This unsmooth bahevior leads to "ripples" on the HS where the
     ! effects of diferent cutoffs can be visibly seen. In the worst case, this
     ! can even lead to failure of the recursive marching cubes algorithm. AN
     ! efficient cutoff is made in the "make_density_grid" routine below which
     ! sets everything to zero outside the interpolation table range. This range
     ! should be chosen so that a given smallness is achieved for the density of
     ! *all* atoms before their contribution is set to zero.
     rho_fragment.create(n_pt)
     rho_fragment = ZERO
     do a = 1,.cluster.n_atoms
        if (NOT .cluster.is_fragment_atom(a)) cycle
        !min_exp = .atom(a).min_basis_exponent
        !if (.atom(a).atomic_number*exp(-min_exp*dist)> cutoff) then
        !if (dist>.atom(a).coppensbasis.interpolator.last_data_point) cycle
        !if (.atom(a).density_at_radius(dist)<cutoff) cycle
        !diff = .atom(a).pos - sphere_pos
        !dist = sqrt(dot_product(diff,diff)) - sphere_radius
        !if (isosurface_skip AND dist>.cluster.radius) cycle
        !if (.atom(a).skip_density_grid(pt)) cycle
        .atom(a).make_density_grid(grid,pt) ! this incorporates a skip step
        rho_fragment = rho_fragment + grid
     end
     density_grid = rho_fragment
     do a = 1,.cluster.n_atoms
        if (.cluster.is_fragment_atom(a)) cycle
        !min_exp = .atom(a).min_basis_exponent
        !if (.atom(a).atomic_number*exp(-min_exp*dist)> cutoff) then
        !if (dist>.atom(a).coppensbasis.interpolator.last_data_point) cycle
        !if (.atom(a).density_at_radius(dist)<cutoff) cycle
        !diff = .atom(a).pos - sphere_pos
        !dist = sqrt(dot_product(diff,diff)) - sphere_radius
        !if (isosurface_skip AND dist>.cluster.radius) cycle
        !if (.atom(a).skip_density_grid(pt)) cycle
        .atom(a).make_density_grid(grid,pt) ! this incorporates a skip step
        density_grid = density_grid + grid
     end
     ! density_grid = rho_fragment/density_grid
     do a = 1,size(density_grid)
       if (density_grid(a)>epsilon(ONE)) then
         density_grid(a) = rho_fragment(a)/density_grid(a)
       else
         density_grid(a) = ZERO
       end
     end
     rho_fragment.destroy
     grid.destroy
   end


   make_promolecule_density_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_promolecule_density_grid, LABEL=>"promolecule_density_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

!   make_promolecule_density_grid(density_grid,pt)
!   ! Work out the promolecule electron density function "density_grid" from the
!   ! supplied points "pt".  The density is calculated from the slater basis if
!   ! available; otherwise from the coppens basis; otherwise from the atomic
!   ! natural orbitals and the atomic gaussian basis set.
!     self :: IN
!     density_grid :: VEC{REAL}, OUT
!     pt :: MAT{REAL}, IN
!   ENSURE(.atom.created,"no atoms")
!   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
!     grid :: VEC{REAL}*
!     a :: INT
!     grid.create(density_grid.dim)
!     density_grid = ZERO
!     do a = 1,.n_atom
!        .atom(a).make_density_grid(grid,pt) ! this incorporates a skip step
!        density_grid = density_grid + grid
!     end
!     grid.destroy
!   end

   make_promolecule_density_grid(density_grid,pt) ::: get_from(MOLECULE:pro_grid, MAKE_GRID=>make_density_grid)
   ! Work out the promolecule "density_grid" from the supplied points "pt".  
   end

!   make_promolecule_density_grid(density,d_density,d2_density,pt)
!   ! Work out the promolecule electron "density" , its 1st derivative
!   ! "d_density", and 2nd derivative "d2_density" for the supplied points "pt".
!   ! The density is calculated from the slater basis if available; otherwise
!   ! from the coppens basis; otherwise from the atomic natural orbitals and the
!   ! atomic gaussian basis set.
!     self :: IN
!     density :: VEC{REAL}, OUT
!     d_density :: MAT{REAL}, OUT
!     d2_density :: MAT3{REAL}, OUT
!     pt :: MAT{REAL}, IN
!   ENSURE(.atom.created,"no atoms")
!   ENSURE(.atom.has_all_density_data,"no atomic orbitals")
!   ENSURE(density.dim==d_density.dim2,"inconsistent density grids")
!   ENSURE(density.dim==d2_density.dim3,"inconsistent density grids")
!   ENSURE(d_density.dim1==3,"wrong dim1 for d_density grid")
!   ENSURE(d2_density.dim1==3,"wrong dim1 for d2_density grid")
!   ENSURE(d2_density.dim2==3,"wrong dim2 for d2_density grid")
!     grid :: VEC{REAL}*
!     d_grid :: MAT{REAL}*
!     d2_grid :: MAT3{REAL}*
!     a :: INT
!     grid.create(density.dim)
!     d_grid.create(3,density.dim)
!     d2_grid.create(3,3,density.dim)
!     density = ZERO
!     d_density = ZERO
!     d2_density = ZERO
!     do a = 1,.n_atom
!        .atom(a).make_density_grid(grid,d_grid,d2_grid,pt) ! this incorporates a skip step
!        density = density + grid
!        d_density = d_density + d_grid
!        d2_density = d2_density + d2_grid
!     end
!     d2_grid.destroy
!     d_grid.destroy
!     grid.destroy
!   end

! ***********************
! Grad rho on rho density
! ***********************

   make_grad_rho_on_rho_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_grad_rho_on_rho_grid, LABEL=>"grad_rho_on_rho_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

!   make_grad_rho_on_rho_grid
!   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
!   ! A Gnuplot ascii file is also generated.
!   ENSURE(.grid.created, "no grid")
!      grid :: VEC{REAL}*
!      pt :: MAT{REAL}*
!      grid.create(.grid.n_pt)
!      pt.create(.grid.n_pt,3); .grid.make_points(pt)
!      .make_grad_rho_on_rho_grid(grid,pt)
!      .dump_plot_grid(grid,"grad_rho_on_rho_grid")
!      pt.destroy
!      grid.destroy
!   end

   make_grad_rho_on_rho_grid(grid,pt)
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim1==grid.dim,"array dimensions do not match")
      rho :: VEC{REAL}*
      grad_rho :: MAT{REAL}*
      n_pt,i :: INT
      grid = ZERO
      n_pt = pt.dim1
      rho.create(n_pt)
      .make_density_grid(rho,pt)
      grid=ZERO
      grad_rho.create(n_pt,3)
      .make_nabla_density_grid(grad_rho,pt)
      do i=1,n_pt
        if (rho(i)>ZERO) then
          grid(i)=sqrt(dot_product(grad_rho(i,:),grad_rho(i,:)))/rho(i)
        else
          grid(i)=ZERO
        end
      end
      grad_rho.destroy
      rho.destroy
   end

! ***********
! ELF density
! ***********

   make_ELF_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_ELF_grid, LABEL=>"ELF_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

!   make_ELF_grid
!   ! Work out the Electron Localisation Function (ELF) density on ".grid"
!   ! using ".natural orbitals" and the ".occupation_numbers" vector.
!   ! Grid, basis set, and natural orbitals are required to exist.
!   ! A Gnuplot ascii file is also generated.
!   ENSURE(.grid.created, "no grid")
!      ELF_grid :: VEC{REAL}*
!      pt :: MAT{REAL}*
!      ELF_grid.create(.grid.n_pt)
!      pt.create(.grid.n_pt,3); .grid.make_points(pt)
!      .make_ELF_grid(ELF_grid,pt)
!      .dump_plot_grid(ELF_grid,"ELF_grid")
!      pt.destroy
!      ELF_grid.destroy
!   end

   make_ELF_grid(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density "g" on a set of
   ! grid points "pt", using ".natural orbitals" and the ".occupation" number
   ! vector.
     ELF_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
     if (.natural_orbitals.number_kind == "real") then
       .make_ELF_grid_r(ELF_grid,pt)
     else
       .make_ELF_grid_c(ELF_grid,pt)
     end
   end

   make_ELF_grid_r(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density on a set of grid
   ! points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created("restricted"), "natural orbitals must be restricted")
      DD :: MAT{REAL}*
      mo_val,gx,gy,gz,rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s,NO :: VEC{REAL}*
      occu,factor,mo_val_n,gx_n,gy_n,gz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT
      ELF_grid = ZERO
      n_pt = pt.dim1
      rho_s.create(n_pt);  rho_s  = ZERO
      tau.create(n_pt);    tau    = ZERO
      rho_sx.create(n_pt); rho_sx = ZERO
      rho_sy.create(n_pt); rho_sy = ZERO
      rho_sz.create(n_pt); rho_sz = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do i = 1,n_occ
         .make_nabla_orbital_grid_r(DD,NO,.natural_orbitals.restricted(:,i), pt)
         mo_val => NO(:)
         gx     => DD(:,1)
         gy     => DD(:,2)
         gz     => DD(:,3)
         occu   = HALF*.occupation_numbers.restricted(i)
         do n = 1,n_pt
           mo_val_n  = mo_val(n)
           gx_n      = gx(n)
           gy_n      = gy(n)
           gz_n      = gz(n)
           occ_mo    = occu*mo_val_n
           rho_s(n)  = rho_s(n)  + occ_mo*mo_val_n
           tau(n)    = tau(n)    + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
           rho_sx(n) = rho_sx(n) + occ_mo*gx_n ! this is half grad_x rho_s
           rho_sy(n) = rho_sy(n) + occ_mo*gy_n
           rho_sz(n) = rho_sz(n) + occ_mo*gz_n
         end
      end
      DD.destroy
      NO.destroy
      d_s.create(n_pt)
      d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s
      rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy
      d0_s.create(n_pt)
      factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
      d0_s = factor*rho_s**(FIVE/THREE)
      rho_s.destroy
      ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))
      ! this could be more efficient if the d0_s*d0_s is written
      ! factor2*rho_s**(TWO+FIVE/THREE)
      d0_s.destroy; d_s.destroy
   end

   make_ELF_grid_c(ELF_grid,pt)
   ! Work out the Electron Localisation Function (ELF) density on a set of grid
   ! points "pt", using ".natural orbitals" and the ".occupation_numbers"
   ! vector.  Grid, basis set, and natural orbitals are required to exist.
     ELF_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
     mo_val,gx,gy,gz,NO :: VEC{CPX}*
     DD :: MAT{CPX}*
     rho_s,rho_sx,rho_sy,rho_sz,tau,d_s,d0_s :: VEC{REAL}*
     occu,factor :: REAL
     n_occ,n,n_pt :: INT
     ELF_grid = ZERO
     n_pt = pt.dim1
     rho_s.create(n_pt);  rho_s  = ZERO
     tau.create(n_pt);    tau    = ZERO
     rho_sx.create(n_pt); rho_sx = ZERO
     rho_sy.create(n_pt); rho_sy = ZERO
     rho_sz.create(n_pt); rho_sz = ZERO
     NO.create(n_pt)
     DD.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_nabla_orbital_grid_c(DD,NO,.natural_orbitals.restricted_complex(:,n), pt)
       mo_val => NO(:)
       gx     => DD(:,1)
       gy     => DD(:,2)
       gz     => DD(:,3)
       occu   = HALF*.occupation_numbers.restricted(n)
       rho_s  = rho_s  + occu*conjg(mo_val)*mo_val
       tau    = tau    + occu*(conjg(gx)*gx+conjg(gy)*gy+conjg(gz)*gz)
       rho_sx = rho_sx + occu*conjg(gx)*mo_val ! this is half grad_x rho_s
       rho_sy = rho_sy + occu*conjg(gy)*mo_val
       rho_sz = rho_sz + occu*conjg(gz)*mo_val
     end
     DD.destroy
     NO.destroy
     d_s.create(n_pt)
     d_s = tau - (rho_sx*rho_sx + rho_sy*rho_sy + rho_sz*rho_sz)/rho_s
     rho_sz.destroy; rho_sy.destroy; rho_sx.destroy; tau.destroy
     d0_s.create(n_pt)
     factor = 0.6d0*(SIX*PI*PI)**(TWO/THREE)
     d0_s = factor*rho_s**(FIVE/THREE)
     rho_s.destroy
     ELF_grid = ONE/(ONE+(d_s*d_s)/(d0_s*d0_s))
     d0_s.destroy; d_s.destroy
   end

! *********************
! Tsirelson ELF density
! *********************

   make_Tsirelson_ELF_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_Tsirelson_ELF_grid, LABEL=>"Tsirelson-Stash_ELF_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

!   make_Tsirelson_ELF_grid
!   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
!   ! on ".grid" using ".natural orbitals" and the ".occupation_numbers" vector.
!   ! Grid, basis set, and natural orbitals are required to exist.  A Gnuplot
!   ! ascii file is also generated.
!   ENSURE(.grid.created, "no grid")
!      ELF_grid :: VEC{REAL}*
!      pt :: MAT{REAL}*
!      ELF_grid.create(.grid.n_pt)
!      pt.create(.grid.n_pt,3); .grid.make_points(pt)
!      .make_Tsirelson_ELF_grid(ELF_grid,pt)
!      .dump_plot_grid(ELF_grid,"Tsirelson-Stash_ELF_grid")
!      pt.destroy
!      ELF_grid.destroy
!   end

   make_Tsirelson_ELF_grid(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
     ELF_grid :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
     if (.natural_orbitals.number_kind == "real") then
       .make_Tsirelson_ELF_grid_r(ELF_grid,pt)
     else
       .make_Tsirelson_ELF_grid_c(ELF_grid,pt)
     end
   end

   make_Tsirelson_ELF_grid_r(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
      DD,LL :: MAT{REAL}*
      mo_val,gx,gy,gz,lx,ly,lz,rho,rho_x,rho_y,rho_z,lap,d_p,d_0,NO :: VEC{REAL}*
      occu,factor,mo_val_n,gx_n,gy_n,gz_n,lx_n,ly_n,lz_n,occ_mo :: REAL
      i,n_occ,n,n_pt :: INT
      ELF_grid = ZERO
      n_pt = pt.dim1
      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do i = 1,n_occ
         .make_laplacian_orbital_grid_r(LL,DD,NO,.natural_orbitals.restricted(:,i), pt)
         mo_val => NO(:)
         gx => DD(:,1); gy => DD(:,2); gz => DD(:,3)
         lx => LL(:,1); ly => LL(:,2); lz => LL(:,3)
         occu = .occupation_numbers.restricted(i)
         do n = 1,n_pt
           mo_val_n = mo_val(n)
           gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
           lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)
           occ_mo   = occu*mo_val_n                        ! this is n_i phi_i
           rho(n)   = rho(n)   + occ_mo*mo_val_n           ! this is rho
           rho_x(n) = rho_x(n) + occ_mo*gx_n               ! this is half grad_x rho
           rho_y(n) = rho_y(n) + occ_mo*gy_n
           rho_z(n) = rho_z(n) + occ_mo*gz_n
           lap(n)   = lap(n)   + occ_mo*(lx_n+ly_n+lz_n) & ! this is half nabla^2 rho
                               + occu*(gx_n*gx_n+gy_n*gy_n+gz_n*gz_n)
         end
      end
      LL.destroy
      DD.destroy
      NO.destroy
      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)
      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
                + lap/THREE
      lap.destroy
      rho_z.destroy; rho_y.destroy; rho_x.destroy
      rho.destroy
      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))
      d_p.destroy; d_0.destroy
   end

   make_Tsirelson_ELF_grid_c(ELF_grid,pt)
   ! Work out the Tsirelson-Stash Electron Localisation Function (ELF) density
   ! on a series of grid points "pt" ".natural orbitals" and the
   ! ".occupation_numbers" vector.
      ELF_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
      mo_val,gx,gy,gz,lx,ly,lz,NO :: VEC{CPX}*
      DD,LL :: MAT{CPX}*
      rho,rho_x,rho_y,rho_z,lap,d_0,d_p :: VEC{REAL}*
      occu,factor :: REAL
      mo_val_n,gx_n,gy_n,gz_n,lx_n,ly_n,lz_n,occ_mo :: CPX
      n_occ,n_pt,n,i :: INT
      ELF_grid = ZERO
      n_pt = pt.dim1
      rho.create(n_pt);   rho   = ZERO
      rho_x.create(n_pt); rho_x = ZERO
      rho_y.create(n_pt); rho_y = ZERO
      rho_z.create(n_pt); rho_z = ZERO
      lap.create(n_pt);   lap   = ZERO
      NO.create(n_pt)
      DD.create(n_pt,3)
      LL.create(n_pt,3)
      n_occ = .no_of_occupied_NOs
      do i = 1,n_occ
         .make_laplacian_orbital_grid_c(LL,DD,NO,.natural_orbitals.restricted_complex(:,i), pt)
         mo_val => NO(:)
         gx => DD(:,1); gy => DD(:,2); gz => DD(:,3)
         lx => LL(:,1); ly => LL(:,2); lz => LL(:,3)
         occu = .occupation_numbers.restricted(i)
         do n = 1,n_pt
           mo_val_n = mo_val(n)
           gx_n = gx(n); gy_n = gy(n); gz_n = gz(n)
           lx_n = lx(n); ly_n = ly(n); lz_n = lz(n)
           occ_mo   = occu*mo_val_n                     ! this is n_i phi_i
           rho(n)   = rho(n)   + occ_mo*conjg(mo_val_n) ! this is rho
           rho_x(n) = rho_x(n) + occ_mo*conjg(gx_n)     ! this is half grad_x rho
           rho_y(n) = rho_y(n) + occ_mo*conjg(gy_n)
           rho_z(n) = rho_z(n) + occ_mo*conjg(gz_n)
                                                        ! this is half nabla^2 rho
           lap(n)   = lap(n)   + occ_mo*(conjg(lx_n)+conjg(ly_n)+conjg(lz_n)) &
                               + occu*(conjg(gx_n)*gx_n+conjg(gy_n)*gy_n+conjg(gz_n)*gz_n)
         end
      end
      LL.destroy
      DD.destroy
      NO.destroy
      d_0.create(n_pt)
      factor = 0.3d0*(THREE*PI*PI)**(TWO/THREE)
      d_0 = factor*rho**(FIVE/THREE)
      d_p.create(n_pt)
      factor = FOUR/NINE
      d_p = d_0 - factor*(rho_x*rho_x + rho_y*rho_y + rho_z*rho_z)/rho &
                + lap/THREE
      lap.destroy
      rho_z.destroy; rho_y.destroy; rho_x.destroy
      rho.destroy
      ELF_grid = ONE/(ONE+(d_p*d_p)/(d_0*d_0))
      d_p.destroy; d_0.destroy
   end

! **********************
! Fermi mobility density
! **********************

   make_fermi_mobility_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_fermi_mobility_grid, LABEL=>"fermi_mobility_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

!   make_fermi_mobility_grid
!   ! Work out the Luken's fermi mobility density on ".grid" using ".natural
!   ! orbitals" and the ".occupation_numbers" vector. A Gnuplot ascii file is
!   ! generated.
!   ENSURE(.grid.created, "no grid")
!      fermi_grid :: VEC{REAL}*
!      pt :: MAT{REAL}*
!      fermi_grid.create(.grid.n_pt)
!      pt.create(.grid.n_pt, 3 ); .grid.make_points(pt)
!      .make_fermi_mobility_grid_r(fermi_grid,pt)
!      .dump_plot_grid(fermi_grid,"fermi_mobility_grid")
!      pt.destroy
!      fermi_grid.destroy
!   end

   make_fermi_mobility_grid(f,pt)
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
     f :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
     if (.natural_orbitals.number_kind == "real") then
       .make_fermi_mobility_grid_r(f,pt)
     else
       DIE("code not written yet")
     end
   end

   make_fermi_mobility_grid_r(f,pt)
   ! Evaluate the Luken's Fermi hole mobility grid "f" on a set of grid points "pt".
     f :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
     del_gi :: MAT{REAL}*
     dg,gi,rho,dgx,dgy,dgz,orb :: VEC{REAL}*
     n,n_pt,i,n_occ :: INT
     delx,dely,delz,fac :: REAL
     n_pt = pt.dim1
     n_occ = .no_of_occupied_NOs
     dg.create(n_pt);    dg  = ZERO
     dgx.create(n_pt);   dgx = ZERO
     dgy.create(n_pt);   dgy = ZERO
     dgz.create(n_pt);   dgz = ZERO
     gi.create(n_pt)
     del_gi.create(n_pt,3)
     do i=1, n_occ
       orb => .natural_orbitals.restricted(:,i)
       .make_nabla_orbital_grid_r(del_gi,gi,orb,pt)
       do n=1,n_pt
         delx = del_gi(n,1)
         dely = del_gi(n,2)
         delz = del_gi(n,3)
         dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
         dgx(n) = dgx(n) + delx*gi(n)
         dgy(n) = dgy(n) + dely*gi(n)
         dgz(n) = dgz(n) + delz*gi(n)
       end
     end
     del_gi.destroy
     gi.destroy
     rho.create(n_pt)
     .make_density_grid(rho,pt)
     fac = (THREE*PI/FOUR) * HALF**TWOTHIRDS
     f = ONE/rho * (dg - TWO*(dgx*dgx + dgy*dgy + dgz*dgz)/rho) - fac * rho**TWOTHIRDS
     rho.destroy
     dgz.destroy
     dgy.destroy
     dgx.destroy
     dg.destroy
   end

! ***************************
! True Fermi mobility density
! ***************************

   make_true_fermi_mobility_grid ::: get_from(MOLECULE:density_grid, MAKE_GRID=>.make_true_fermi_mobility_grid, LABEL=>"true_fermi_mobility_grid")
   ! Work out the property density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   end

!   make_true_fermi_mobility_grid
!   ! Work out the the true fermi mobility density "f" on a series of grid points
!   ! "pt" using ".natural orbitals" and the ".occupation_numbers" vector. The
!   ! true function differs from that above in that the kinetic energy density is
!   ! evaluated exactly.
!   ENSURE(.grid.created, "no grid")
!      fermi_grid :: VEC{REAL}*
!      pt :: MAT{REAL}*
!      fermi_grid.create(.grid.n_pt)
!      pt.create(.grid.n_pt, 3 ); .grid.make_points(pt)
!      .make_true_fermi_mobil_grid_r(fermi_grid,pt)
!      .dump_plot_grid(fermi_grid,"true_fermi_mobility_grid")
!      pt.destroy
!      fermi_grid.destroy
!   end

   make_true_fermi_mobility_grid(f,pt)
   ! Work out the the true fermi mobility density "f" on a series of grid points
   ! "pt" using ".natural orbitals" and the ".occupation_numbers" vector. The
   ! true function differs from that above in that the kinetic energy density is
   ! evaluated exactly.
     f :: VEC{REAL}
     pt :: MAT{REAL}
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.any_created, "no natural orbitals")
     if (.natural_orbitals.number_kind == "real") then
       .make_true_fermi_mobil_grid_r(f,pt)
     else
       DIE("code not written yet")
     end
   end

   make_true_fermi_mobil_grid_r(f,pt)
   ! Evaluate the true Fermi hole mobility grid "f" on a set of grid points
   ! "pt".  The true function differs from that above in that the kinetic energy
   ! density is evaluated exactly.
   ! NOTE: this routine is only valid for single determinant wavefunctions.
     f :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
     dg,rho,NO,K,gj,Tj :: VEC{REAL}*
     dgx,dgy,dgz,gi :: VEC{REAL}*
     n,n_pt,i,j,n_occ :: INT
     delx,dely,delz :: REAL
     del_gi,g,T :: MAT{REAL}*
     n_pt = pt.dim1
     n_occ = .no_of_occupied_NOs
     dg.create(n_pt);    dg  = ZERO
     dgx.create(n_pt);   dgx = ZERO
     dgy.create(n_pt);   dgy = ZERO
     dgz.create(n_pt);   dgz = ZERO
     g.create(n_pt,n_occ)
     del_gi.create(n_pt,3)
     ! Assemble intermediate terms
     do i=1, n_occ
       NO => .natural_orbitals.restricted(:,i)
       gi => g(:,i)
       .make_nabla_orbital_grid_r(del_gi,gi,NO,pt)
       do n=1,n_pt
         delx = del_gi(n,1)
         dely = del_gi(n,2)
         delz = del_gi(n,3)
         dg(n)  = dg(n)  + delx*delx+dely*dely+delz*delz
         dgx(n) = dgx(n) + delx*gi(n)
         dgy(n) = dgy(n) + dely*gi(n)
         dgz(n) = dgz(n) + delz*gi(n)
       end
     end
     del_gi.destroy
     ! Make kinetic energy matrix part
     K.create(n_pt);    K = ZERO
     T.create(.n_bf,.n_bf)
     .get_kinetic_matrix(T)
     T.change_basis_using(.natural_orbitals.restricted)
     do j=1,n_occ
       gj => g(:,j)
       Tj => T(:,j)
       do i=1,n_occ
         K(:) = K(:) + g(:,i)*gj(:)*Tj(i)
       end
     end
     T.destroy
     ! Now do the final assembly
     rho.create(n_pt)
     .make_density_grid(rho,pt)
     f = ONE/rho * (dg - TWO*(dgx*dgx+dgy*dgy+dgz*dgz)/rho - TWO*K)
     rho.destroy
     K.destroy
     g.destroy
     dgz.destroy
     dgy.destroy
     dgx.destroy
     dg.destroy
   end

! ***************
! Current density
! ***************

   make_j_grid
   ! Make the current density on ".grid" using ".natural orbitals"
   ! and the ".occupation_numbers" vector.
   !    J(r) = J_p(r) + J_d(r)
   ENSURE(.grid.created, "no grid")
      arch :: ARCHIVE
      j,jp :: MAT{REAL}*
      j.create(.grid.n_pt,3);  .get_jd_density_grid(j)
      jp.create(.grid.n_pt,3); .get_jp_density_grid(jp)
      j = j + jp
      jp.destroy
      arch.set(.name,"current_density")
      arch.write(j)
      arch.set(.name,"current_density",format="gnuplot,ascii")
      arch.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z)
      arch.set(.name,"current_norm_density",format="gnuplot,ascii")
      arch.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      arch.set(.name,"current_density,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(j, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      j.destroy
   end

   get_jd_density_grid(jd)
   ! Set "jd" to the diamagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      jd :: MAT{REAL}
      arch :: ARCHIVE
      arch.set(.name,"jd_density_grid")
      if (NOT arch.exists) .make_jd_grid
      arch.read(jd)
   end

   make_jd_grid
   ! Work out the diamagnetic current density on ".grid" using ".natural
   ! orbitals" and the ".occupation_numbers" number vector.
   !    J_d(r) = - (e^2/2m) (B x r) rho(r)
   ENSURE(.grid.created, "no grid")
      arch :: ARCHIVE
      jd,r :: MAT{REAL}*
      rho :: VEC{REAL}*
      nullify(r)
      if (.B_field.norm<TOL(10)) return
      jd.create(.grid.n_pt,3)
      rho.create(.grid.n_pt)
      r.create(.grid.n_pt,3)
      .grid.make_points(r)
      jd(:,1) = .B_field(2)*r(:,3) - .B_field(3)*r(:,2)
      jd(:,2) = .B_field(3)*r(:,1) - .B_field(1)*r(:,3)
      jd(:,3) = .B_field(1)*r(:,2) - .B_field(2)*r(:,1)
      .make_density_grid(rho,r)
      r.destroy
      jd(:,1) = -HALF*jd(:,1)*rho
      jd(:,2) = -HALF*jd(:,2)*rho
      jd(:,3) = -HALF*jd(:,3)*rho
      rho.destroy
      arch.set(.name,"jd_density")
      arch.write(jd)
      arch.set(.name,"jd_density",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z)
      arch.set(.name,"jd_norm_density",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      arch.set(.name,"jd_density,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jd, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jd.destroy
   end

   get_jp_density_grid(jp)
   ! Set "jp" to the paramagnetic current density grid.
   ! If the archive file exists, read it; otherwise make it.
      jp :: MAT{REAL}
      arch :: ARCHIVE
      arch.set(.name,"jp_density_grid")
      if (NOT arch.exists) .make_jp_grid
      arch.read(jp)
   end

   make_jp_grid
   ! Work out the paramagnetic current density on ".grid" using ".natural
   ! orbitals".  A Gnuplot ascii file is generated.
   ENSURE(.grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
      arch :: ARCHIVE
      jp :: MAT{REAL}*
      complex :: BIN
      complex = .natural_orbitals.number_kind == "complex"
      ENSURE(complex, "natural orbitals not complex")
      .make_ao_density_matrix
      .make_restricted_complex_NOs
      jp.create(.grid.n_pt,3)
      .make_jp_grid(jp)
      arch.set(.name,"jp_density_grid")
      arch.write(jp)
      arch.set(.name,"jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
      arch.set(.name,"jp_norm_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      arch.set(.name,"jp_density_grid,normalized",format="gnuplot,ascii")
      arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jp.destroy
   end

   make_jp_grid(jp)
   ! Work out the paramagnetic current density "jp" on ".grid" using ".natural
   ! orbitals" .
   !    J_p(r) = - (eh/m) Re [ \sum_i n_i \phi^*_i(r) \nabla \phi^*_i(r)
     jp :: MAT{REAL}
   ENSURE(.grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no density matrix")
     pt :: MAT{REAL}*
     P :: MAT{CPX}*
     D :: VEC{CPX}*
     n_occ,n,n_pt :: INT
     occ :: REAL
     jp = ZERO
     n_pt = .grid.n_pt
     pt.create(n_pt,3); .grid.make_points(pt)
     D.create(n_pt)
     P.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_nabla_orbital_grid_c(P,D,.natural_orbitals.restricted_complex(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       jp(:,1) = jp(:,1) - occ*aimag(conjg(D(:))*P(:,1))
       jp(:,2) = jp(:,2) - occ*aimag(conjg(D(:))*P(:,2))
       jp(:,3) = jp(:,3) - occ*aimag(conjg(D(:))*P(:,3))
     end
     P.destroy
     D.destroy
     pt.destroy
   end

   make_solenoidal_jp_grid
   ! Make the solenoidal paramagnetic current density grid "jp" on ".grid"
   ENSURE(.grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
     arch :: ARCHIVE
     jp :: MAT{REAL}*
     .make_ao_density_matrix
     ENSURE(.density_matrix.created("restricted_complex"), "no density matrix")
     jp.create(.grid.n_pt,3)
     .make_solenoidal_jp_grid(jp,.density_matrix.restricted_complex)
     arch.set(.name,"solenoidal_jp_density_grid")
     arch.write(jp)
     arch.set(.name,"solenoidal_jp_density_grid",format="gnuplot,ascii")
     arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
     arch.set(.name,"solenoidal_jp_norm_density_grid",format="gnuplot,ascii")
     arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
     arch.set(.name,"solenoidal_jp_density_grid,normalized",format="gnuplot,ascii")
     arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
     jp.destroy
   end

   make_solenoidal_jp_grid(jp,dens)
   ! Make the solenoidal paramagnetic current density grid "jp" on ".grid"
   ! using AO density matrix "dens"
      jp :: MAT{REAL}
      dens :: MAT{CPX}, target
   ENSURE(.grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      Dba :: MAT{CPX}*
      pt,Jxab,Jyab,Jzab :: MAT{REAL}*
      q,fa,fb,la,lb,k :: INT
      fac :: REAL
      sh :: SHELL2
      pt.create(.grid.n_pt,3); .grid.make_points(pt)
      jp = ZERO
      do q = 1,.n_shell_pairs
        .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (fa==fb) fac=ONE
        Jxab.create(sh.a.n_comp,sh.b.n_comp)
        Jyab.create(sh.a.n_comp,sh.b.n_comp)
        Jzab.create(sh.a.n_comp,sh.b.n_comp)
        do k = 1,.grid.n_pt
          sh.make_solenoidal_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_product_with(real(aimag(Dba),kind=REAL_KIND))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_product_with(real(aimag(Dba),kind=REAL_KIND))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_product_with(real(aimag(Dba),kind=REAL_KIND))
        end
        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        sh.destroy_ptr_part
      end
      pt.destroy
      jp.zero_small_values(TOL(10))
   end

   make_irrotational_jp_grid
   ! Make the irrotational paramagnetic current density grid "jp" on ".grid"
   ENSURE(.grid.destroyed,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
      arch :: ARCHIVE
      jp :: MAT{REAL}*
      .make_ao_density_matrix
      ENSURE(.density_matrix.created("restricted_complex"), "no density matrix")
      jp.create(.grid.n_pt,3)
      .make_irrotational_jp_grid(jp,.density_matrix.restricted_complex)
      arch.set(.name,"irrotational_jp_density_grid")
      arch.write(jp)
      arch.set(.name,"irrotational_jp_density_grid",format="ascii")
      arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z)
      arch.set(.name,"irrotational_jp_norm_density_grid",format="ascii")
      arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, norm=TRUE)
      arch.set(.name,"irrotational_jp_density_grid,normalized",format="ascii")
      arch.write_gnuplot(jp, .grid.n_x, .grid.n_y, .grid.n_z, normalise=TRUE)
      jp.destroy
   end

   make_irrotational_jp_grid(jp,dens)
   ! Make the irrotational paramagnetic current density grid "jp" on ".grid"
   ! using AO density matrix "dens"
      jp :: MAT{REAL}
      dens :: MAT{CPX}, target
   ENSURE(.grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
      Dba :: MAT{CPX}*
      pt,Jxab,Jyab,Jzab :: MAT{REAL}*
      q,fa,fb,la,lb,k :: INT
      fac :: REAL
      sh :: SHELL2
      pt.create(.grid.n_pt,3); .grid.make_points(pt)
      jp = ZERO
      do q = 1,.n_shell_pairs
        .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
        Dba => dens(fb:lb,fa:la)
        fac = TWO; if (fa==fb) fac=ONE
        Jxab.create(sh.a.n_comp,sh.b.n_comp)
        Jyab.create(sh.a.n_comp,sh.b.n_comp)
        Jzab.create(sh.a.n_comp,sh.b.n_comp)
        do k = 1,.grid.n_pt
          sh.make_irrotational_jp_ints(Jxab,Jyab,Jzab,pt(k,:))
          jp(k,1) = jp(k,1) - fac*Jxab.trace_product_with(real(aimag(Dba),kind=REAL_KIND))
          jp(k,2) = jp(k,2) - fac*Jyab.trace_product_with(real(aimag(Dba),kind=REAL_KIND))
          jp(k,3) = jp(k,3) - fac*Jzab.trace_product_with(real(aimag(Dba),kind=REAL_KIND))
        end
        Jxab.destroy
        Jyab.destroy
        Jzab.destroy
        sh.destroy_ptr_part
      end
      pt.destroy
      jp.zero_small_values(TOL(10))
   end

   make_div_jp_grid
   ! Work out the divergence of the paramagnetic current density on ".grid"
   ! using ".natural orbitals".  A Gnuplot ascii file is generated.
   ENSURE(.grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.natural_orbitals.number_kind == "complex", "natural orbitals not complex")
      arch :: ARCHIVE
      div_jp :: VEC{REAL}*
      .make_ao_density_matrix
      .make_restricted_complex_NOs
      div_jp.create(.grid.n_pt)
      .make_div_jp_grid(div_jp)
      arch.set(.name,"div_jp_density_grid")
      arch.write(div_jp)
      arch.set(.name,"div_jp_density_grid",format="gnuplot,ascii")
      arch.write_gnuplot(div_jp, .grid.n_x, .grid.n_y, .grid.n_z)
      div_jp.destroy
   end

   make_div_jp_grid(div_jp)
   ! Work out the divergence of the paramagnetic current density "jp" on ".grid"
   ! using ".natural orbitals" .
   !  \nabla .  J_p(r) = - (eh/m) \sum_i n_i Im[ \phi^*_i(r) \nabla^2 \phi^_i(r) ]
     div_jp :: VEC{REAL}
   ENSURE(.grid.created,  "no grid")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.natural_orbitals.created, "no density matrix")
     pt :: MAT{REAL}*
     L :: MAT{CPX}*
     P :: MAT{CPX}*
     D :: VEC{CPX}*
     n_occ,n,n_pt :: INT
     occ :: REAL
     div_jp = ZERO
     n_pt = .grid.n_pt
     pt.create(n_pt,3); .grid.make_points(pt)
     D.create(n_pt)
     P.create(n_pt,3)
     L.create(n_pt,3)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_laplacian_orbital_grid_c(L,P,D,.natural_orbitals.restricted_complex(:,n), pt)
       occ = .occupation_numbers.restricted(n)
       div_jp(:) = div_jp(:) - occ*aimag(conjg(D(:))*(L(:,1)+L(:,2)+L(:,3)))
     end
     L.destroy
     P.destroy
     D.destroy
     pt.destroy
   end

! ***************************
! Isosurface plotting methods
! ***************************

   isosurface_plot ::: leaky
   ! Do one of the many kinds of isosurface plot calculations
   ENSURE(.isosurface.created,"no isosurface")
     self :: target
     slaterbasis :: VEC{SLATERBASIS}*
     coppensbasis :: VEC{COPPENSBASIS}*
     dft :: BIN
     saved_self => self ! Note this !
     .set_interpolator_info(.isosurface.iso_kind,.isosurface.interpolator)
     .set_ANO_info(.isosurface.iso_kind)
     select case (.isosurface.iso_kind)
        case("deformation_density              "); .isosurface.cubify(MOLECULE::deformation_density_grid)
        case("deformation_dft_eff_potential    "); .isosurface.cubify(MOLECULE::def_dft_eff_pot_grid)
        case("deformation_dft_energy           "); .isosurface.cubify(MOLECULE::def_dft_energy_grid)
        case("deformation_dft_xc_potential     "); .isosurface.cubify(MOLECULE::def_dft_xc_pot_grid)
        case("deformation_electric_potential   "); .isosurface.cubify(MOLECULE::def_e_pot_grid)
        case("deformation_g_kinetic_energy     "); .isosurface.cubify(MOLECULE::def_G_kinetic_grid)
        case("deformation_h_dft_energy         "); .isosurface.cubify(MOLECULE::def_H_dft_energy_grid)
        case("deformation_k_kinetic_energy     "); .isosurface.cubify(MOLECULE::def_K_kinetic_grid)
        case("deformation_laplacian            "); .isosurface.cubify(MOLECULE::def_laplacian_grid)
        case("dft_eff_potential                "); .isosurface.cubify(MOLECULE::dft_eff_pot_grid)
        case("dft_energy                       "); .isosurface.cubify(MOLECULE::dft_energy_grid)
        case("dft_xc_potential                 "); .isosurface.cubify(MOLECULE::dft_xc_pot_grid)
        case("electric_potential               "); .isosurface.cubify(MOLECULE::electric_potential_grid)
        case("electron_density                 "); .isosurface.cubify(MOLECULE::electron_density_grid)
        case("elf                              "); .isosurface.cubify(MOLECULE::ELF_grid)
        case("fermi_mobility                   "); .isosurface.cubify(MOLECULE::fermi_mobility_grid)
        case("grad_rho_on_rho                  "); .isosurface.cubify(MOLECULE::grad_rho_on_rho_grid)
        case("g_kinetic_energy                 "); .isosurface.cubify(MOLECULE::G_kinetic_energy_grid)
        case("h_dft_energy                     "); .isosurface.cubify(MOLECULE::H_dft_energy_grid)
        case("k_kinetic_energy                 "); .isosurface.cubify(MOLECULE::K_kinetic_energy_grid)
        case("laplacian                        "); .isosurface.cubify(MOLECULE::laplacian_grid)
        case("orbital                          "); .isosurface.cubify(MOLECULE::orbital_grid)
        case("oscillator_orbital               "); .isosurface.cubify(MOLECULE::oscillator_orbital_grid)
        case("orbital_density                  "); .isosurface.cubify(MOLECULE::orbital_density_grid)
        case("promolecule_density              "); .isosurface.cubify(MOLECULE::promolecule_density_grid)
        case("spin_density                     "); .isosurface.cubify(MOLECULE::spin_density_grid)
        case("stockholder_density              "); .isosurface.cubify(MOLECULE::stockholder_density_grid)
        case("stockholder_weight               "); .isosurface.cubify(MOLECULE::stockholder_density_grid)
        case("true_fermi_mobility              "); .isosurface.cubify(MOLECULE::true_fermi_mobility_grid)
        case("tsirelson_elf                    "); .isosurface.cubify(MOLECULE::Tsirelson_ELF_grid)
        case default;                UNKNOWN(.isosurface.iso_kind)
     end
   end

   plot_on_isosurface ::: leaky
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface---useful for mapping properties on a surface.
   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.surface_property/=" ","no isosurface surface_property specified")
     self :: target
     slaterbasis :: VEC{SLATERBASIS}*
     coppensbasis :: VEC{COPPENSBASIS}*
     dft :: BIN
     saved_self => self ! Note this !
     .set_interpolator_info(.isosurface.iso_kind,.isosurface.interpolator)
     .set_ANO_info(.isosurface.surface_property)
     select case (.isosurface.surface_property)
        case("deformation_density             "); .isosurface.plot_function(MOLECULE::deformation_density_grid)
        case("deformation_dft_eff_potential   "); .isosurface.plot_function(MOLECULE::def_dft_eff_pot_grid)
        case("deformation_dft_energy          "); .isosurface.plot_function(MOLECULE::def_dft_energy_grid)
        case("deformation_dft_xc_potential    "); .isosurface.plot_function(MOLECULE::def_dft_xc_pot_grid)
        case("deformation_electric_potential  "); .isosurface.plot_function(MOLECULE::def_e_pot_grid)
        case("deformation_g_kinetic_energy    "); .isosurface.plot_function(MOLECULE::def_G_kinetic_grid)
        case("deformation_h_dft_energy        "); .isosurface.plot_function(MOLECULE::def_H_dft_energy_grid)
        case("deformation_k_kinetic_energy    "); .isosurface.plot_function(MOLECULE::def_K_kinetic_grid)
        case("deformation_laplacian           "); .isosurface.plot_function(MOLECULE::def_laplacian_grid)
        case("dft_eff_potential               "); .isosurface.plot_function(MOLECULE::dft_eff_pot_grid)
        case("dft_energy                      "); .isosurface.plot_function(MOLECULE::dft_energy_grid)
        case("dft_xc_potential                "); .isosurface.plot_function(MOLECULE::dft_xc_pot_grid)
        case("electric_potential              "); .isosurface.plot_function(MOLECULE::electric_potential_grid)
        case("electron_density                "); .isosurface.plot_function(MOLECULE::electron_density_grid)
        case("elf                             "); .isosurface.plot_function(MOLECULE::ELF_grid)
        case("fermi_mobility                  "); .isosurface.plot_function(MOLECULE::fermi_mobility_grid)
        case("g_kinetic_energy                "); .isosurface.plot_function(MOLECULE::G_kinetic_energy_grid)
        case("h_dft_energy                    "); .isosurface.plot_function(MOLECULE::H_dft_energy_grid)
        case("k_kinetic_energy                "); .isosurface.plot_function(MOLECULE::K_kinetic_energy_grid)
        case("laplacian                       "); .isosurface.plot_function(MOLECULE::laplacian_grid)
        case("orbital                         "); .isosurface.plot_function(MOLECULE::orbital_grid)
        case("oscillator_orbital              "); .isosurface.plot_function(MOLECULE::oscillator_orbital_grid)
        case("orbital_density                 "); .isosurface.plot_function(MOLECULE::orbital_density_grid)
        case("promolecule_density             "); .isosurface.plot_function(MOLECULE::promolecule_density_grid)
        case("spin_density                    "); .isosurface.plot_function(MOLECULE::spin_density_grid)
        case("stockholder_density             "); .isosurface.plot_function(MOLECULE::stockholder_density_grid)
        case("stockholder_weight              "); .isosurface.plot_function(MOLECULE::stockholder_density_grid)
        case("true_fermi_mobility             "); .isosurface.plot_function(MOLECULE::true_fermi_mobility_grid)
        case("tsirelson_elf                   "); .isosurface.plot_function(MOLECULE::Tsirelson_ELF_grid)
        case("grad_rho_on_rho                 "); .isosurface.plot_function(MOLECULE::grad_rho_on_rho_grid)
        case default;                UNKNOWN(.isosurface.surface_property)
     end
   end

   saved_isosurface_plot ::: leaky
   ! Do one of the many kinds of isosurface plot calculations, but using the
   ! .saved molecule information with the CURRENT .isosurface information.
   ! That is, the isosurface stored for this molecule is actually that for the
   ! .saved molecule.
   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.saved.created,"no saved molecule")
     saved_isosurface :: ISOSURFACE*
     slaterbasis :: VEC{SLATERBASIS}*
     coppensbasis :: VEC{COPPENSBASIS}*
     dft :: BIN
     saved_self => .saved ! Note this !
     saved_isosurface => .saved.isosurface ! I'm not sure why this is necessary --dylan
     .saved.isosurface => .isosurface      ! ... or this
     .saved.set_interpolator_info(.isosurface.iso_kind,.isosurface.interpolator)
     .saved.set_ANO_info(.isosurface.iso_kind)
     select case (.isosurface.iso_kind)
        case("deformation_density             "); .isosurface.cubify(MOLECULE::deformation_density_grid)
        case("deformation_dft_eff_potential   "); .isosurface.cubify(MOLECULE::def_dft_eff_pot_grid)
        case("deformation_dft_energy          "); .isosurface.cubify(MOLECULE::def_dft_energy_grid)
        case("deformation_dft_xc_potential    "); .isosurface.cubify(MOLECULE::def_dft_xc_pot_grid)
        case("deformation_electric_potential  "); .isosurface.cubify(MOLECULE::def_e_pot_grid)
        case("deformation_g_kinetic_energy    "); .isosurface.cubify(MOLECULE::def_G_kinetic_grid)
        case("deformation_h_dft_energy        "); .isosurface.cubify(MOLECULE::def_H_dft_energy_grid)
        case("deformation_k_kinetic_energy    "); .isosurface.cubify(MOLECULE::def_K_kinetic_grid)
        case("deformation_laplacian           "); .isosurface.cubify(MOLECULE::def_laplacian_grid)
        case("dft_eff_potential               "); .isosurface.cubify(MOLECULE::dft_eff_pot_grid)
        case("dft_energy                      "); .isosurface.cubify(MOLECULE::dft_energy_grid)
        case("dft_xc_potential                "); .isosurface.cubify(MOLECULE::dft_xc_pot_grid)
        case("electric_potential              "); .isosurface.cubify(MOLECULE::electric_potential_grid)
        case("electron_density                "); .isosurface.cubify(MOLECULE::electron_density_grid)
        case("elf                             "); .isosurface.cubify(MOLECULE::ELF_grid)
        case("fermi_mobility                  "); .isosurface.cubify(MOLECULE::fermi_mobility_grid)
        case("g_kinetic_energy                "); .isosurface.cubify(MOLECULE::G_kinetic_energy_grid)
        case("h_dft_energy                    "); .isosurface.cubify(MOLECULE::H_dft_energy_grid)
        case("k_kinetic_energy                "); .isosurface.cubify(MOLECULE::K_kinetic_energy_grid)
        case("laplacian                       "); .isosurface.cubify(MOLECULE::laplacian_grid)
        case("orbital                         "); .isosurface.cubify(MOLECULE::orbital_grid)
        case("oscillator_orbital              "); .isosurface.cubify(MOLECULE::oscillator_orbital_grid)
        case("orbital_density                 "); .isosurface.cubify(MOLECULE::orbital_density_grid)
        case("promolecule_density             "); .isosurface.cubify(MOLECULE::promolecule_density_grid)
        case("spin_density                    "); .isosurface.cubify(MOLECULE::spin_density_grid)
        case("stockholder_density             "); .isosurface.cubify(MOLECULE::stockholder_density_grid)
        case("stockholder_weight              "); .isosurface.cubify(MOLECULE::stockholder_density_grid)
        case("true_fermi_mobility             "); .isosurface.cubify(MOLECULE::true_fermi_mobility_grid)
        case("tsirelson_elf                   "); .isosurface.cubify(MOLECULE::Tsirelson_ELF_grid)
        case("grad_rho_on_rho                 "); .isosurface.cubify(MOLECULE::grad_rho_on_rho_grid)
        case default;                UNKNOWN(.isosurface.iso_kind)
     end
     .saved.isosurface => saved_isosurface
   end

   saved_plot_on_isosurface ::: leaky
   ! Plot one of the many kinds of density functions on an existing
   ! isosurface---useful for mapping properties on a surface---but using the
   ! .saved molecule information for the density functions which are evaluated
   ! and stored on the current .isosurface.
   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.surface_property/=" ","no isosurface surface_property specified")
   ENSURE(.saved.created,"no saved molecule")
     saved_isosurface :: ISOSURFACE*
     slaterbasis :: VEC{SLATERBASIS}*
     coppensbasis :: VEC{COPPENSBASIS}*
     dft :: BIN
     saved_self => .saved ! Note this !
     saved_isosurface => .saved.isosurface ! I'm not sure why this is necessary --dylan
     .saved.isosurface => .isosurface      ! ... or this
     .saved.set_interpolator_info(.isosurface.iso_kind,.isosurface.interpolator)
     .saved.set_ANO_info(.isosurface.surface_property)
     select case (.isosurface.surface_property)
        case("deformation_density             "); .isosurface.plot_function(MOLECULE::deformation_density_grid)
        case("deformation_dft_eff_potential   "); .isosurface.plot_function(MOLECULE::def_dft_eff_pot_grid)
        case("deformation_dft_energy          "); .isosurface.plot_function(MOLECULE::def_dft_energy_grid)
        case("deformation_dft_xc_potential    "); .isosurface.plot_function(MOLECULE::def_dft_xc_pot_grid)
        case("deformation_electric_potential  "); .isosurface.plot_function(MOLECULE::def_e_pot_grid)
        case("deformation_g_kinetic_density   "); .isosurface.plot_function(MOLECULE::def_G_kinetic_grid)
        case("deformation_h_energy_density    "); .isosurface.plot_function(MOLECULE::def_H_dft_energy_grid)
        case("deformation_k_kinetic_density   "); .isosurface.plot_function(MOLECULE::def_K_kinetic_grid)
        case("deformation_laplacian_density   "); .isosurface.plot_function(MOLECULE::def_laplacian_grid)
        case("dft_eff_potential               "); .isosurface.plot_function(MOLECULE::dft_eff_pot_grid)
        case("dft_energy                      "); .isosurface.plot_function(MOLECULE::dft_energy_grid)
        case("dft_xc_potential                "); .isosurface.plot_function(MOLECULE::dft_xc_pot_grid)
        case("electric_potential              "); .isosurface.plot_function(MOLECULE::electric_potential_grid)
        case("electron_density                "); .isosurface.plot_function(MOLECULE::electron_density_grid)
        case("elf                             "); .isosurface.plot_function(MOLECULE::ELF_grid)
        case("fermi_mobility                  "); .isosurface.plot_function(MOLECULE::fermi_mobility_grid)
        case("g_kinetic_density               "); .isosurface.plot_function(MOLECULE::G_kinetic_energy_grid)
        case("h_dft_energy                    "); .isosurface.plot_function(MOLECULE::H_dft_energy_grid)
        case("k_kinetic_density               "); .isosurface.plot_function(MOLECULE::K_kinetic_energy_grid)
        case("laplacian_density               "); .isosurface.plot_function(MOLECULE::laplacian_grid)
        case("orbital                         "); .isosurface.plot_function(MOLECULE::orbital_grid)
        case("orbital_density                 "); .isosurface.plot_function(MOLECULE::orbital_density_grid)
        case("promolecule_density             "); .isosurface.plot_function(MOLECULE::promolecule_density_grid)
        case("spin_density                    "); .isosurface.plot_function(MOLECULE::spin_density_grid)
        case("stockholder_density             "); .isosurface.plot_function(MOLECULE::stockholder_density_grid)
        case("stockholder_weight              "); .isosurface.plot_function(MOLECULE::stockholder_density_grid)
        case("true_fermi_mobility             "); .isosurface.plot_function(MOLECULE::true_fermi_mobility_grid)
        case("tsirelson_elf                   "); .isosurface.plot_function(MOLECULE::Tsirelson_ELF_grid)
        case("grad_rho_on_rho                 "); .isosurface.plot_function(MOLECULE::grad_rho_on_rho_grid)
        case default;                UNKNOWN(.isosurface.surface_property)
     end
     .saved.isosurface => saved_isosurface
   end

   set_interpolator_info(plot_kind,interpolator) ::: leaky
   ! Set the interpolator info for all the atoms if the "plot_kind" is such
   ! that interpolation tables could be beneficial. This should be called just
   ! prior to doing the plot to take advantage of speed-ups.
      plot_kind :: STR
      interpolator :: INTERPOLATOR*
   ENSURE(.atom.created,"no atoms")
      if (plot_kind/="stockholder_density" AND plot_kind/="stockholder_weight" AND plot_kind/="promolecule_density") return
      ! If we get here, the interpolator information will be used
      if (interpolator.created) then  ! Only if the user enters it
         if (.slaterbasis.created)  .make_slater_interpolators(interpolator)
         if (.coppensbasis.created) .make_coppens_interpolators(interpolator)
      else if (.cluster.created) then ! Default: use cluster atom density cutoff
         if (.slaterbasis.created)  .make_slater_interpolators(tol=.cluster.atom_density_cutoff)
         if (.coppensbasis.created) .make_coppens_interpolators(tol=.cluster.atom_density_cutoff)
      else                            ! Use global default
         if (.slaterbasis.created)  .make_slater_interpolators
         if (.coppensbasis.created) .make_coppens_interpolators
      end
   end

   make_slater_interpolators(interpolator,tol) ::: leaky
   ! Make the slaterbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
   ! Otherwise use an atom density cutoff "tol".
   ! NOTE: any existing interpolators are destroyed first
      interpolator :: INTERPOLATOR*, optional
      tol :: REAL, optional
   ENSURE(.slaterbasis.created,"no slaterbasis")
      i :: INT
      do i = 1,.slaterbasis.dim   ! Make the interpolators
        .slaterbasis(i).make_interpolator(interpolator,tol)
      end                         ! If the atom bases are resolved, they now have interpolators
   end

   make_coppens_interpolators(interpolator,tol) ::: leaky
   ! Make the coppensbasis orbital density interpolators.
   ! Make them using the defaults set in a give "interpolator".
   ! Otherwise use an atom density cutoff "tol".
   ! NOTE: any existing interpolators are destroyed first
      interpolator :: INTERPOLATOR*, optional
      tol :: REAL, optional
   ENSURE(.coppensbasis.created,"no slaterbasis")
      i :: INT
      do i = 1,.coppensbasis.dim  ! Make the interpolators
        .coppensbasis(i).make_interpolator(interpolator,tol)
      end                         ! If the atom bases are resolved, they now have interpolators
   end

   set_ANO_info(plot_kind) ::: leaky
   ! Set the ANO info for all the atoms if the "plot_kind" is such that the ANO
   ! data must be made.
      plot_kind :: STR
      dft :: BIN
      if (plot_kind(1:11)/="deformation" AND plot_kind(1:4)/="e_hf") return
      ! If we get here, the ANO information will be used
      ENSURE(.basis.created,"no basis sets")
      ENSURE(.slaterbasis.destroyed,"cannot have slater basis present")
      ENSURE(.coppensbasis.destroyed,"cannot have coppens basis present")
      ENSURE(.atom.created,"no atoms")
      ENSURE(.atom(1).basis_kind=="gaussian","must use gaussian basis on atoms")
      if (.scfdata.destroyed) then; dft = FALSE
      else;                         dft = .scfdata.is_DFT_calculation
      end
      .get_ANO_data(use_ks=dft)
      .set_atom_shell_info
   end

   deformation_density_grid(g,pt) ::: selfless
   ! Work out the electron deformation density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_deformation_density_grid(g,pt)
   end

   def_e_pot_grid(g,pt) ::: selfless
   ! Work out the deformation electric potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_e_pot_grid(g,pt)
   end

   def_H_dft_energy_grid(g,pt) ::: selfless
   ! Work out the deformation slater H energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_H_dft_energy_grid(g,pt)
   end

   def_G_kinetic_grid(g,pt) ::: selfless
   ! Work out the deformation G-type kinetic density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_G_kinetic_grid(g,pt)
   end

   def_K_kinetic_grid(g,pt) ::: selfless
   ! Work out the deformation K-type kinetic density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_K_kinetic_grid(g,pt)
   end

   def_laplacian_grid(g,pt) ::: selfless
   ! Work out the deformation laplacian density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_laplacian_grid(g,pt)
   end

   def_dft_eff_pot_grid(g,pt) ::: selfless
   ! Work out the deformation DFT effective potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_dft_eff_pot_grid(g,pt)
   end

   def_dft_xc_pot_grid(g,pt) ::: selfless
   ! Work out the deformation DFT exchange corelation density grid "g" for a the
   ! points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_dft_xc_pot_grid(g,pt)
   end

   def_dft_energy_grid(g,pt) ::: selfless
   ! Work out the deformation DFT energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_def_dft_energy_grid(g,pt)
   end

   electron_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_density_grid(g,pt)
   end

   spin_density_grid(g,pt) ::: selfless
   ! Work out the electron density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals" and ".occupation_numbers" vector.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
   !  .make_ao_sz_density_matrix
   !  .make_natural_orbitals("restricted")
      .make_density_grid(g,pt,sgn=-1)
   end

   G_kinetic_energy_grid(g,pt) ::: selfless
   ! Work out the G-type kinetic energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_G_kinetic_energy_grid(g,pt)
   end

   K_kinetic_energy_grid(g,pt) ::: selfless
   ! Work out the K-type kinetic energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_K_kinetic_energy_grid(g,pt)
   end

   H_dft_energy_grid(g,pt) ::: selfless
   ! Work out the H-type DFT energy density grid "g" for a series of points
   ! "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_H_dft_energy_grid(g,pt)
   end

   laplacian_grid(g,pt) ::: selfless
   ! Work out the laplacian density grid "g" for a series of points "pt" for
   ! using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_laplacian_grid(g,pt)
   end

   dft_eff_pot_grid(g,pt) ::: selfless
   ! Work out the DFT effective potential grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_dft_eff_pot_grid(g,pt)
   end

   dft_xc_pot_grid(g,pt) ::: selfless
   ! Work out the DFT exchange corelation density grid "g" for a the
   ! points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_dft_xc_pot_grid(g,pt)
   end

   dft_energy_grid(g,pt) ::: selfless
   ! Work out the DFT energy density grid "g" for a the points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_dft_energy_grid(g,pt)
   end

   orbital_density_grid(g,pt) ::: selfless
   ! Work out the orbital density grid "g" for a series of points "pt" for using
   ! the ".natural orbitals", for a partcular orbital .grid.orbital.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
      gc :: VEC{CPX}*
      n_pt,orb :: INT
      grid :: PLOTGRID*
      self :: MOLECULE*; self => saved_self
      n_pt = pt.dim1
      grid => .isosurface.grid
      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0 ) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                 orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end
      if (.natural_orbitals.number_kind == "real") then
        .make_orbital_grid_r(g,.natural_orbitals.restricted(:,orb),pt,square=TRUE)
      else
        gc.create(n_pt)
        .make_orbital_grid_c(gc,.natural_orbitals.restricted_complex(:,orb),pt,square=TRUE)
        g = gc
        gc.destroy
      end
   end

   orbital_grid(g,pt) ::: selfless
   ! Work out the orbital grid "g" for a series of points "pt" for using
   ! the ".natural orbitals", for a partcular orbital .grid.orbital.
   ! NOTE: for complex orbitals, the absolute value times the sign of
   ! the complex part
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
      gc :: VEC{CPX}*
      n_pt,orb :: INT
      grid :: PLOTGRID*
      self :: MOLECULE*; self => saved_self
      n_pt = pt.dim1
      grid => .isosurface.grid
      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0 ) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end
      if (.natural_orbitals.number_kind == "real") then
        .make_orbital_grid_r(g,.natural_orbitals.restricted(:,orb),pt)
      else
        gc.create(n_pt)
        .make_orbital_grid_c(gc,.natural_orbitals.restricted_complex(:,orb),pt)
        g = sign(real(gc),aimag(gc))
        gc.destroy
      end
   end

   oscillator_orbital_grid(g,pt) ::: selfless
   ! Work out the oscillator orbital grid "g" for a series of points "pt" for
   ! using the ".natural orbitals", for a partcular orbital .grid.orbital.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(.isosurface.created,"no isosurface")
   ENSURE(.isosurface.grid.orbital>=0,"non-positive grid orbital")
   ENSURE(pt.dim1==g.dim1,"incompatible # of points, g and pt arrays")
   ENSURE(pt.dim2==3,"wrong shape, pt array")
   ENSURE(.natural_orbitals.created, "no natural orbitals")
   ENSURE(.localiser.created, "no localiser orbject created")
      n_pt,orb :: INT
      grid :: PLOTGRID*
      self :: MOLECULE*; self => saved_self
      n_pt = pt.dim1
      grid => .isosurface.grid
      orb = grid.orbital
      if (orb==0) then
         if      (grid.HOMO_orbital/=0 ) then; orb = .n_a + grid.HOMO_orbital
         else if (grid.LUMO_orbital/=-1) then; orb = .n_a + grid.LUMO_orbital
         else;                                 orb = .n_a
         end
         ENSURE(orb>0,"non positive orbital")
      end
      if (.natural_orbitals.number_kind == "real") then
        .make_oscillator_orbital_grid_r(g,orb,pt)
      else
        DIE("complex case not yet implemented")
      end
   end

   ELF_grid(g,pt) ::: selfless
   ! Work out the Electron Localisation Function (ELF) density "g" for a series
   ! of points "pt" for using the ".natural orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_ELF_grid(g,pt)
   end

   grad_rho_on_rho_grid(g,pt) ::: selfless
   ! Work out abs(grad(rho))/rho on a set of grid points "pt".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_grad_rho_on_rho_grid(g,pt)
   end

   Tsirelson_ELF_grid(g,pt) ::: selfless
   ! Work out the Tsirelson-Stash version of the Electron Localisation Function
   ! (ELF) density "g" for a series of points "pt" for using the ".natural
   ! orbitals".
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_Tsirelson_ELF_grid(g,pt)
   end

   fermi_mobility_grid(g,pt) ::: selfless
   ! Work out the Luken's fermi mobility density on a series of grid points "g"
   ! using ".natural orbitals" and the ".occupation_numbers" vector. A Gnuplot
   ! ascii file is generated.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_fermi_mobility_grid(g,pt)
   end

   true_fermi_mobility_grid(g,pt) ::: selfless
   ! Work out the Luken's true fermi mobility density (the one using kinetic
   ! energy matrix elements) on a series of grid points "g" using ".natural
   ! orbitals" and the ".occupation_numbers" vector. A Gnuplot ascii file is
   ! generated.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_true_fermi_mobility_grid(g,pt)
   end

   electric_potential_grid(g,pt) ::: selfless
   ! Make the electric potential grid "g" on a series of points "pt"
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
     .make_electric_potential_grid(g,pt)
   end

   stockholder_density_grid(g,pt) ::: selfless
   ! Work out the Hirshfeld stockholder density grid "g" for a series of points.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_stockholder_density_grid(g,pt)
   end

   promolecule_density_grid(g,pt) ::: selfless
   ! Work out the promolecule density grid "g" for a series of points.
      g  :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
      self :: MOLECULE*; self => saved_self
      .make_promolecule_density_grid(g,pt)
   end

!   promolecule_d_density_grid(g,dg,d2g,pt) ::: selfless
!   ! Work out the promolecule density grid "g", its derivative "dg", and second
!   ! derivative "d2g" for a series of points "pt".
!      g   :: VEC{REAL}, OUT
!      dg  :: MAT{REAL}, OUT
!      d2g :: MAT3{REAL}, OUT
!      pt  :: MAT{REAL}, IN
!      self :: MOLECULE*; self => saved_self
!      .make_promolecule_density_grid(g,dg,d2g,pt)
!   end

! ****************************
! Vibrationally averaged grids
! ****************************

   get_vib_averaged_rho_grid(density_grid)
   ! Set "density_grid" to the vibrationally averaged electron density grid.
   ! If the archive file exists, read it; otherwise make it.
      density_grid :: VEC{REAL}
   ENSURE(.grid.created,  "no grid")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.n_atom==2,"can only do diatomics")
      arch :: ARCHIVE
      arch.set(.name,"vib_averaged_rho_grid")
      if (NOT arch.exists) .make_vib_averaged_rho_grid
      arch.read(density_grid)
   end

   make_vib_averaged_rho_grid
   ! Work out the averaged density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector. A Gnuplot ascii file is generated.
   ENSURE(.grid.created,  "no grid")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.n_atom==2,"can only do diatomics")
      arch :: ARCHIVE
      density_grid :: VEC{REAL}*
      .move_origin_to_centre_of_mass
      density_grid.create(.grid.n_pt)
      .integrate_rho_grid(density_grid,-FOUR,FOUR,TOL(4))
      arch.set(.name,"vib_averaged_rho_grid")
      arch.write(density_grid)
      arch.set(.name,"vib_averaged_rho_grid",format="ascii")
      arch.write_gnuplot(density_grid, .grid.n_x, .grid.n_y, .grid.n_z)
      density_grid.destroy
   end

   integrate_rho_grid(res,a,b,accuracy,fa0,fb0) ::: recursive
   ! Integrate the rho grid between the limits "a" and "b" using adaptive
   ! trapezoidal rule with Simpsons approximation.  If present, "accuracy"
   ! is the required accuracy of the integral. If present, "fa0" and
   ! "fb0" are the value of the rho_grid at "a" and "b" respectively.
   ! size of "res" is .grid.n_pt.
      a,b :: REAL
      accuracy :: REAL, optional
      fa0,fb0 :: VEC{REAL}*, optional
      res :: VEC{REAL}*
   ENSURE(.grid.created, "no grid")
      fa,fb,fm,one_trap,two_trap,left,right :: VEC{REAL}*
      n_pt :: INT
      same :: BIN
      tol,h,m :: REAL
      depth :: INT = 0
      n_pt = .grid.n_pt
      depth = depth+1
      stdout.show("depth =",depth)
      tol = TOL(6)
      if (present(accuracy)) tol = accuracy
      h  = b-a
      m  = (a+b)/TWO
      if (present(fb0)) then; fb => fb0
      else;                   fb.create(n_pt); .make_rho_grid_at(b,fb)
      end
      if (present(fa0)) then; fa => fa0
      else;                   fa.create(n_pt); .make_rho_grid_at(a,fa)
      end
      fm.create(n_pt);    .make_rho_grid_at(m,fm)
      one_trap.create(n_pt)
      two_trap.create(n_pt)
      one_trap = h*(fa+fb)/TWO
      two_trap = h*(fa+TWO*fm+fb)/FOUR
      res = abs(one_trap-two_trap)
      same = maxval(res) < THREE*tol
      if (same AND depth>1) then
        res = (FOUR*two_trap - one_trap)/THREE
        two_trap.destroy
        one_trap.destroy
        fm.destroy
        fa.destroy
      else
        two_trap.destroy
        one_trap.destroy
        left.create(n_pt);  .integrate_rho_grid(left ,a,m,tol/TWO,fa0=fa,fb0=fm)
        right.create(n_pt); .integrate_rho_grid(right,m,b,tol/TWO,fa0=fm,fb0=fb)
        res = left + right
        right.destroy
        left.destroy
      end
      if (depth==1) fb.destroy
      depth = depth-1
   end

   make_rho_grid_at(q,rho)
   ! Work out the electron density on ".grid" using ".natural orbitals" and the
   ! ".occupation_numbers" vector at nuclear separation "q", where "q" is a
   ! dimensionless normal coordinate
   ! size or "rho" is .grid.n_pt.
      q :: REAL
      rho :: VEC{REAL}
      pt :: MAT{REAL}*
      re,w,mu, gamma,d,r, wt :: REAL
      n :: INT
      re = 2.0460259 ! N2
      w  = 2708      ! N2
      re = 1.3848617 ! H2
      w  = 4658      ! H2
      mu = .reduced_mass
      n = 1
      gamma = sqrt((w/WAVENUMBER_PER_HARTREE) &
                  * mu * MASS_OF_ELECTRON_PER_AMU ) ! This is gamma^(1/2)
      d = q/gamma ! d is the cartesian displacement in Bohr
      r = re + d  ! r is the actual separation of atoms in Bohr
      stdout.show("q =",q)
      stdout.show("d =",d)
      stdout.show("r =",r)
      stdout.show("g =",gamma)
      .atom(1).pos = ZERO
      .atom(2).pos = ZERO
      .atom(1).pos(3) = -r/TWO
      .atom(2).pos(3) = +r/TWO
      .move_origin_to_centre_of_mass
      .delete_scf_integrals
      .scf
      pt.create(.grid.n_pt,3); .grid.make_points(pt)
      .make_density_grid(rho,pt)
      pt.destroy
      wt = q.harmonic_vibrational_fn(n)
      wt = wt*wt
      rho = wt * rho
   end

!   integrate_density_numerically
!   ! Integrate the density numerically
!   ENSURE(.dftgrid.created, "no dftgrid info!")
!      n_pts :: INT
!      pt :: MAT{REAL}*
!      wt,rho :: VEC{REAL}*
!      n_e :: REAL
!      n_pts = .dftgrid.n_pts * .n_atom
!      stdout.show("number of grid points = ", n_pts)
!      pt.create(n_pts,3)
!      wt.create(n_pts)
!      rho.create(n_pts)
!      .dftgrid.make_grid(pt,wt,.atom)
!      .make_density_grid(rho,pt)
!      n_e = sum(rho*wt)
!      stdout.show("numerically integrated charge =",n_e)
!      rho.destroy
!      wt.destroy
!      pt.destroy
!   end

!   integrate_density_functional
!   ! Integrate some functional of the density and nabla density numerically
!   ! skw
!      n_pts :: INT
!      wt,rho,x,y,z :: VEC{REAL}*
!      pt,nabla_rho :: MAT{REAL}*
!      n_e,value :: REAL
!      ENSURE(.dftgrid.created, "no dftgrid info!")
!      n_pts = .dftgrid.n_pts * .n_atom
!      stdout.show("number of grid points = ", n_pts)
!      pt.create(n_pts,3)
!      wt.create(n_pts)
!      rho.create(n_pts)
!      nabla_rho.create(n_pts,3)
!      .dftgrid.make_grid(pt,wt,.atom)
!      .make_density_grid(rho,pt)
!      .make_nabla_density_grid(nabla_rho,pt)
!      x => pt(:,1); y => pt(:,2); z => pt(:,3)
!      n_e = sum(rho*wt)
!      value = sum(x*nabla_rho(:,1)*wt)
!      stdout.show("integrate(rho) =",n_e)
!      stdout.show("integrate(x*nabla_rho) =",value)
!      rho.destroy
!      nabla_rho.destroy
!      wt.destroy
!      pt.destroy
!   end

!*******************************************************************************
!                        Camp-King routines
!*******************************************************************************

!   camp_king(E_HF,E_K)
!   ! WARNING: the old matrices were removed, this routine needs to be examined
!   ! again ...
!   ! Uses .old_molecular_orbitals (lambda=0) and .molecular_orbitals (lambda=1)
!   ! to generate molecular orbitals at optimal lambda.  These overwrite
!   ! .molecular_orbitals.
!   ! E_HF and E_K are only changed if the orbitals are changed.
!   ! Can do restricted case only.
!     E_HF,E_K :: REAL, INOUT
!     F_backup,MO_backup,P_backup :: OPMATRIX*
!     old_MO,new_MO,old_F,old_P :: MAT{REAL}*
!     Uh,V,W,U,CV,CW,S,Q,Q1,F,Cj,Cj1,Cl :: MAT{REAL}*
!     theta :: VEC{REAL}*
!     minpq,n,n_p,n_q,i,k,j :: INT
!     ded0,ded1,ded1a,lambda,El :: REAL
!     tol,diis0,diis1,diisl :: REAL
!     ENSURE(.fock_matrix.spinorbital_kind=="restricted","only for restricted for now")
!
!     .scfdata.camp_king_iters=0
!     F_backup.create_copy(.fock_matrix)
!     MO_backup.create_copy(.molecular_orbitals)
!     P_backup.create_copy(.density_matrix)
!     .make_diis_error_length(diis1)
!
!     .unarchive_fock_matrix(archive_name="old_fock_matrix")
!     old_F  => .fock_matrix.restricted
!     .unarchive_molecular_orbitals(archive_name="old_molecular_orbitals")
!     old_MO => .molecular_orbitals.restricted
!     .unarchive_density_matrix(archive_name="old_density_matrix")
!     old_P  => .density_matrix.restricted
!     .make_diis_error_length(diis0)
!
!     .fock_matrix        => F_backup
!     .molecular_orbitals => MO_backup
!     new_MO              => .molecular_orbitals.restricted
!     .density_matrix     => P_backup
!
!     if (diis1 < 0.95*diis0) then
!       old_F.destroy
!       old_P.destroy
!       old_MO.destroy
!       return ! the new orbitals are better than the old.
!     end
!
!     n_p = .n_e/2
!     n_q = .n_bf - n_p
!     minpq = min(n_p,n_q)
!
!     Q.create(.n_bf,.n_bf)
!     Q = old_MO                                  ! Q is an orthogonal basis.
!
!     Q1.create(.n_bf,.n_bf)                      ! Get inverse of Q, store in Q1.
!     S.create(.n_bf,.n_bf)
!     .get_overlap_matrix(S)
!     Q1.to_product_of(Q,S,transpose_a=TRUE)
!     S.destroy
!
!     Cj.create(.n_bf,.n_bf)                      ! Convert the MOs into Q basis.
!     Cj1.create(.n_bf,.n_bf)
!     Cj.to_product_of(Q1,old_MO)
!     Cj1.to_product_of(Q1,new_MO)
!     Q1.destroy
!
!     V.create(.n_bf,.n_bf)
!     W.create(.n_bf,.n_bf)
!     theta.create(minpq)
!     U.create(.n_bf,.n_bf)
!     U.to_product_of(Cj,Cj1)                        ! eqn 8
!     V=Cj1
!     W=Cj1
!     U.make_corresponding_orbitals(V,W,theta,n_p)
!     U.destroy
!
!     CV.create(.n_bf,.n_bf)
!     CW.create(.n_bf,.n_bf)
!     CV.to_product_of(Cj,V)                         ! eqn 11
!     CW.to_product_of(Cj1,W)                        ! eqn 12
!     W.destroy
!     V.destroy
!     Cj1.destroy
!     Cj.destroy
!
!     F.create(.n_bf,.n_bf)
!     !get de/dl at l=1
!     F=F_backup.restricted                          ! Fbar at lambda=1
!     F.change_basis_using(Q)                              ! F = Q^t Fbar Q
!     F.change_basis_using(CW)                             ! eqn 28.
!     CW.destroy
!     ded1 = ZERO
!     do n=1,n_p
!       ded1 = ded1 + theta(n)*F(n+n_p,n)
!     end
!     ded1 = -FOUR * ded1
!
!     !get de/dl at l=0
!     F=old_F                                        ! Fbar at lambda=0
!     F.change_basis_using(Q)                              ! F = Q^t Fbar Q
!     F.change_basis_using(CV)                             ! eqn 27.
!     ded0 = ZERO
!     do n=1,n_p
!       ded0 = ded0 + theta(n)*F(n+n_p,n)
!     end
!     ded0 = -FOUR * ded0
!     F.destroy
!
!     .scfdata.camp_king_iters=0
!     if (abs(ded1) > TEN*abs(ded0)) then
!       lambda = 0.1
!     else
!       lambda = HALF
!     end
!     .old_fock_matrix.minus(.old_constraint_matrix)
!     .minimise_Camp_King_lambda(lambda,ded0,ded1a,Q,CV,theta,n_p,diis0)
!     .make_diis_error_length(diisl)
!     if (diisl < 0.95*diis1 OR abs(ded1a) < abs(ded1)) then
!       Uh.create(.n_bf,.n_bf)
!       .make_Camp_King_U_hat(Uh,lambda,theta)
!       Cl.create(.n_bf,.n_bf)
!       Cl.to_product_of(CV,Uh)
!       Uh.destroy
!       .molecular_orbitals.restricted.to_product_of(Q,Cl)
!       Cl.destroy
!       .schmidt_orthonormalise(.molecular_orbitals)
!       .make_scf_density_matrix(damp=FALSE)
!       .make_structure_factors
!       .scfdata.set(crystal=.crystal)
!
!       .make_fock_matrix
!       if (.scfdata.scf_kind == "xray_rhf") then
!         E_HF = .scf_energy
!         E_K = .kinetic_energy
!         .add_constraint
!       else
!         E_HF = .scf_energy
!         E_K = .kinetic_energy
!       end
!     else
!       .fock_matrix.set_to(F_backup)
!       .molecular_orbitals.set_to(MO_backup)
!       .density_matrix.set_to(P_backup)
!     end
!     .old_fock_matrix.plus(.old_constraint_matrix)
!
!     CV.destroy
!     theta.destroy
!     Q.destroy
!     F_backup.destroy
!     P_backup.destroy
!     MO_backup.destroy
!   end
!
!   minimise_Camp_King_lambda(lambda,ded0,dedx,Ql,CV,theta,n_p,diis0) ::: private
!   !
!     ded0,diis0 :: REAL, IN
!     lambda,tol,dedx :: REAL
!     n_p :: INT, IN
!     Ql,CV :: MAT{REAL}
!     theta :: VEC{REAL}
!      i :: INT
!     a,b,d,d1,d2,du,dv,dw,dx,e,fu,fv,fw,fx,olde,tol1,tol2,u,u1,u2,v,w,x,xm :: REAL
!     diisl :: REAL
!     ok1,ok2 :: BIN
!
!     tol=0.1
!     a=ZERO
!     if (ded0>0) a=-0.2
!     b=ONE
!     v=lambda
!     w=lambda
!     x=lambda
!     e=ZERO
!     d=ZERO
!     .get_Camp_King_energy(x,fx,dx,Ql,CV,theta,n_p,diisl)
!     fv=fx
!     fw=fx
!     dv=dx
!     dw=dx
!     .scfdata.camp_king_iters=0
!     do i=1,100
!       .scfdata.camp_king_iters=.scfdata.camp_king_iters+1
!       xm=HALF*(a+b)
!       tol1=tol*abs(x)+TOL(10)
!       tol2=TWO*tol1
!!       if (diisl < diis0) exit
!       if (abs(x-xm)<=(tol2-HALF*(b-a))) exit
!       if (abs(e)>tol1) then
!         d1=TWO*(b-a)
!         d2=d1
!         if (dw /= dx) d1=(w-x)*dx/(dx-dw)
!         if (dv /= dx) d2=(v-x)*dx/(dx-dv)
!         u1=x+d1
!         u2=x+d2
!         ok1=((a-u1)*(u1-b)>ZERO) AND (dx*d1 <=ZERO)
!         ok2=((a-u2)*(u2-b)>ZERO) AND (dx*d2 <=ZERO)
!         olde=e
!         e=d
!
!         if (ok1 OR ok2) then
!           if (ok1 AND ok2) then
!             if (abs(d1)<abs(d2)) then; d=d1
!             else;                      d=d2
!             end
!           else
!             if (ok1) then; d=d1
!             else;          d=d2
!             end
!           end if
!           if (abs(d)<=abs(HALF*olde)) then
!             u=x+d
!             if (u-a <tol2 OR b-u <tol2) d=sign(tol1,xm-x)
!           else
!             if (dx<=ZERO) then; e=a-x
!             else;               e=b-x
!             end
!             d=HALF*e
!           end if
!         else
!           if (dx>=ZERO) then; e=a-x
!           else;               e=b-x
!           end
!           d=HALF*e
!         end if
!       else
!         if (dx>=ZERO) then; e=a-x
!         else;               e=b-x
!         end
!         d=HALF*e
!       end if
!       if (abs(d)>=tol1) then
!         u=x+d
!         .get_Camp_King_energy(u,fu,du,Ql,CV,theta,n_p,diisl)
!       else
!         u=x+sign(tol1,d)
!         .get_Camp_King_energy(u,fu,du,Ql,CV,theta,n_p,diisl)
!         if (fu > fx) exit
!       end if
!       if (fu <= fx) then
!         if (u >= x) then
!           a=x
!         else
!           b=x
!         end if
!         v=w; fv=fw; dv=dw
!         w=x; fw=fx; dw=dx
!         x=u; fx=fu; dx=du
!       else
!         if (u < x) then
!           a=u
!         else
!           b=u
!         end if
!         if (fu <=fw OR w ==x) then
!           v=w; fv=fw; dv=dw
!           w=u; fw=fu; dw=du
!         else if (fu <=fv OR v ==x OR v ==w) then
!           v=u; fv=fu; dv=du
!         end if
!       end if
!       if (abs(fv-fw) < .scfdata.convergence AND abs(fv-fx) < .scfdata.convergence) then
!         exit
!       end
!     end do
!     lambda = x
!     dedx=dx
!   end
!
!   get_Camp_King_energy(lambda,El,dedl,Q,CV,theta,n_p,diisl) ::: private
!   !
!     Q,CV :: MAT{REAL}, IN
!     theta :: VEC{REAL}, IN
!     n_p :: INT, IN
!     constraint :: OPMATRIX*
!     lambda,El,dedl,diisl :: REAL
!     Uh,Cl,F :: MAT{REAL}*
!      n :: INT
!     Uh.create(.n_bf,.n_bf)
!     .make_Camp_King_U_hat(Uh,lambda,theta)
!     Cl.create(.n_bf,.n_bf)
!     Cl.to_product_of(CV,Uh)                          ! C(lambda) = C^j V Uh(lambda)
!     Uh.destroy
!     .molecular_orbitals.restricted.to_product_of(Q,Cl) ! Cbar(lambda) = Q C(lambda)
!     .schmidt_orthonormalise(.molecular_orbitals)
!     .make_scf_density_matrix(damp=FALSE)
!     .make_structure_factors
!     .make_fock_matrix
!     if (.scfdata.scf_kind == "xray_rhf") then
!       El = .scf_energy + .scfdata.lambda * .crystal.F_chi2
!       .add_constraint
!     else
!       El = .scf_energy
!     end
!     .make_diis_error_length(diisl)
!     F.create(.n_bf,.n_bf)
!     F=.fock_matrix.restricted                      ! Fbar at lambda in AO basis.
!     F.change_basis_using(Q)
!     F.change_basis_using(Cl)
!     Cl.destroy
!     dedl = ZERO
!     do n=1,n_p
!       dedl = dedl + theta(n)*F(n+n_p,n)
!     end
!     dedl = -FOUR * dedl
!     F.destroy
!   end
!
!   make_Camp_King_U_hat(Uh,lambda,theta) ::: private
!   !
!     self :: IN
!     Uh :: MAT{REAL}, target
!     lambda :: REAL, IN
!     theta :: VEC{REAL}, IN
!     sin_theta,cos_theta :: VEC{REAL}*
!     Uh_pp,Uh_qq,Uh_qp,Uh_pq :: MAT{REAL}*
!     minpq,maxpq,n_p,n_q,m,n :: INT
!     ok :: BIN
!
!     ok = size(Uh,1)==.n_bf AND size(Uh,2)==.n_bf
!     n_p = ceiling(.n_e/TWO)
!     n_q = .n_bf - n_p
!     minpq = min(n_p,n_q)
!     maxpq = max(n_p,n_q)
!     m=n_p-minpq
!     n=n_q-minpq
!     ENSURE(ok,"incorrect dimensions for Uh matrix")
!     DIE_IF(size(theta)/=minpq,"incorrect dimensions for theta array")
!
!     sin_theta.create(minpq)
!     cos_theta.create(minpq)
!     sin_theta = sin(theta*lambda)
!     cos_theta = cos(theta*lambda)
!
!     Uh=ZERO
!     Uh_pp => Uh(:n_p,:n_p)
!     Uh_qq => Uh(n_p+1:,n_p+1:)
!     Uh_qp => Uh(n_p+1:,:n_p)
!     Uh_pq => Uh(:n_p,n_p+1:)
!
!     Uh_pp(:minpq,:minpq).from_diagonal(cos_theta)
!     Uh_qq(:minpq,:minpq).from_diagonal(cos_theta)
!
!     Uh_qp(:minpq,:minpq).from_diagonal(-sin_theta)
!     Uh_pq(:minpq,:minpq).from_diagonal(sin_theta)
!
!     if (m>0) then ! do p-m:p block
!       Uh_pp(minpq+1:,minpq+1:).to_unit_mat
!     else if (n>0) then ! do p+q-n:p+q block
!       Uh_qq(minpq+1:,minpq+1:).to_unit_mat
!     end
!
!     cos_theta.destroy
!     sin_theta.destroy
!   end
!
!   dynamic_damp(E_HF,E_K)
!   ! Increase the damp factor until the new density matrix gives better results
!   ! than the previous one.  Good for difficult convergence.
!   ! E_HF and E_K are only changed if the orbitals are changed.
!     E_HF,E_K :: REAL, INOUT
!     F_backup,MO_backup,P_backup :: OPMATRIX*
!     theta :: VEC{REAL}*
!      n :: INT
!     diis0,diis1,diisl,damp,delta_damp,E0,E1,El,mix :: REAL
!     chi2 :: REAL
!
!     chi2=ZERO
!
!     F_backup.create_copy(.fock_matrix)
!     MO_backup.create_copy(.molecular_orbitals)
!     P_backup.create_copy(.density_matrix)
!     ! .fock_matrix contains .constraint_matrix
!     ! .old_fock_matrix contains .old_constraint_matrix
!
!     ! Get DIIS error and energy for new density
!     .make_diis_error_length(diis1)
!     if (.scfdata.scf_kind == "xray_rhf") then
!       ! Remove the constraint matrix from the new fock matrix.
!       F_backup.minus(.constraint_matrix)
!       .fock_matrix.set_to(F_backup)
!       .make_structure_factors
!       chi2 = .crystal.F_chi2
!     end
!     E1 = .scf_energy + .scfdata.lambda * chi2
!
!     ! Get DIIS error and energy for old density
!     .fock_matrix.set_to(.old_fock_matrix)
!     .density_matrix.set_to(.old_density_matrix)
!     .make_diis_error_length(diis0)
!     if (.scfdata.scf_kind == "xray_rhf") then
!       ! Remove the constraint matrix from the old fock matrix.
!       .old_fock_matrix.minus(.old_constraint_matrix)
!       .fock_matrix.set_to(.old_fock_matrix)
!       .make_structure_factors
!       chi2 = .crystal.F_chi2
!     end
!     E0 = .scf_energy + .scfdata.lambda * chi2
!
!     ! .fock_matrix does not contain .constraint_matrix
!     ! .old_fock_matrix does not contain .old_constraint_matrix
!
!     if (diis1<TEN*diis0) then
!       .fock_matrix.set_to(F_backup)
!       .molecular_orbitals.set_to(MO_backup)
!       .density_matrix.set_to(P_backup)
!       if (.scfdata.scf_kind == "xray_rhf") then
!         ! reinsert contraint matrices
!         F_backup.plus(.constraint_matrix)
!         .old_fock_matrix.plus(.old_constraint_matrix)
!         .make_structure_factors
!       end
!       P_backup.destroy
!       MO_backup.destroy
!       F_backup.destroy
!       return ! the new orbitals are better than the old.
!     end
!
!     mix = 0.9 ! How much of the new, not the old.
!     do n=1,15
!       .density_matrix.set_to(P_backup)
!       .fock_matrix.set_to(F_backup)
!       .density_matrix.damp(.old_density_matrix,ONE-mix)
!       .fock_matrix.damp(.old_fock_matrix,ONE-mix)
!       E_HF = .scf_energy
!       if (.scfdata.scf_kind == "xray_rhf") then
!         .make_structure_factors
!         .add_constraint
!         El = E_HF + .scfdata.lambda * .crystal.F_chi2
!       else
!         El = E_HF
!       end
!       .make_diis_error_length(diisl)
!       .scfdata.dynamic_damp_factor = ONE-mix
!       if (diisl<TEN*diis0) exit
!       mix = HALF * mix
!     end
!     E_K = .kinetic_energy ! move this outside of loop
!     .make_structure_factors
!     F_backup.destroy
!     P_backup.destroy
!     MO_backup.destroy
!   end

! *********************
! Roby analysis methods
! *********************

   roby_analysis ::: leaky
   ! Do one of the many kind of Roby population analysis
   ENSURE(.roby.created,"no robydata= supplied")
   ENSURE(.density_matrix.created,"no density")
     allowed_kind :: BIN
     allowed_kind =  .density_matrix.spinorbital_kind=="restricted" &
                  OR .density_matrix.spinorbital_kind=="unrestricted"
   ENSURE(allowed_kind,"only restricted or unrestricted densities are allowed")
     .get_ANO_data
     select case (.roby.roby_kind)
        case("atom_bond_analysis     "); .roby.atom_bond_analysis      ! This is a main option
        case("atom_shared_population "); .roby.atom_shared_population
        case("atom_pair_populations  "); .roby.atom_pair_populations
        case("atom_populations       "); .roby.atom_populations
        case("group_bond_analysis    "); .roby.group_bond_analysis     ! This is a main option
        case("group_shared_population"); .roby.group_shared_population
        case("group_pair_populations "); .roby.group_pair_populations
        case("group_populations      "); .roby.group_populations
        case default;                UNKNOWN(.roby.roby_kind)
     end
   end

!  ********************
!  ANO control routines
!  ********************

   get_ANO_data(use_ks) ::: leaky
   ! Get the restricted atomic natural orbitals (ANO) data for all atoms in the
   ! molecule, from an archive. If it is not there, then make it and archive it.
      use_ks :: BIN, optional
   ENSURE(.atom.created,"no atoms")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.basis.created,"no basis set")
   ENSURE(.unique_atom.created,"no unique atom list")
   ENSURE(.atom_kind.created,"no atom kind list")
      k,u,j :: INT
      .destroy_ANO_data
      do k = 1,.n_atom_kind ! Get ANO data only for unique atoms
        u = .unique_atom(k)
        .get_ANO_data_for_atom(u,use_ks)
        do j = u+1,.n_atom
           if (.atom_kind(j)/=k) cycle
           .atom(j).density_matrix     => .atom(u).density_matrix
           .atom(j).natural_orbitals   => .atom(u).natural_orbitals
           .atom(j).occupation_numbers => .atom(u).occupation_numbers
           .atom(j).energy             =  .atom(u).energy
        end
      end
   end

   get_ANO_data_for_atom(a,use_ks) ::: leaky
   ! Get the restricted atomic natural orbitals (ANO) data for atom "a" from an
   ! archive. If the archive is not there then make it.
     a :: INT
     use_ks :: BIN, optional
   ENSURE(.atom(a).natural_orbitals.destroyed,"NO's exist, atom "//trim(a.to_str))
   ENSURE(.atom(a).occupation_numbers.destroyed,"occupations exist, atom "//trim(a.to_str))
   ENSURE(.atom(a).density_matrix.destroyed,"density exists, atom "//trim(a.to_str))
     mol :: MOLECULE*
     n_no :: INT
     energy :: REAL
     output :: BIN
     mol.create
     .make_molecule_from_atom(a,mol)
     if (mol.archive_doesnt_exist("natural_orbitals","restricted")) &
       .make_ANO_data_for_atom(a,use_ks)
     mol.unarchive_natural_orbitals(genre="restricted")
     mol.unarchive_occupation_numbers(genre="restricted")
     mol.unarchive_density_matrix(genre="restricted")
     mol.unarchive(energy,"energy",genre="restricted")
     .atom(a).natural_orbitals   => mol.natural_orbitals
     .atom(a).occupation_numbers => mol.occupation_numbers
     .atom(a).density_matrix     => mol.density_matrix
     .atom(a).energy             =  energy
     mol.atom.nullify_ptr_part       ! do not destroy basis part
     nullify(mol.natural_orbitals)   ! do not destroy this
     nullify(mol.occupation_numbers) ! do not destroy this
     nullify(mol.density_matrix)     ! do not destroy this
     nullify(mol.basis)              ! do not destroy this
     nullify(mol.slaterbasis)        ! do not destroy this
     nullify(mol.coppensbasis)       ! do not destroy this
     mol.destroy
     output = FALSE
     if (NOT output) return
     n_no = .atom(a).no_of_occupied_NOs(tol=0.05d0)
     stdout.show("n_no=",n_no)
     .atom(a).put_natural_orbitals
   end

   make_ANO_data_for_atom(a,use_ks)
   ! Make and *archive* the spherically averaged restricted atomic natural
   ! orbitals (ANO) and density matrix data for atom "a".
     a :: INT
     use_ks :: BIN, optional
     mol :: MOLECULE*
     mol.create
     .make_molecule_from_atom(a,mol,use_ks)
   ! mol.scfdata.output = FALSE
     mol.scfdata.using_direct_scf = TRUE
     mol.scfdata.using_rough_convergence = FALSE
     mol.scf
     mol.delete_scf_MO_archive
     mol.delete_scf_fock_archive
     mol.delete_old_scf_archives
     mol.delete_scf_integrals
     mol.make_ao_density_matrix
     mol.pointgroup.create("oh")
     mol.symmetrise(mol.density_matrix)
     mol.archive_density_matrix
     mol.archive_energy(genre=.density_matrix.spinorbital_kind)
     mol.make_natural_orbitals       ! ... and archive them
     mol.atom.nullify_basis_part     ! do not destroy basis part
     mol.atom.destroy_ptr_part       ! do not destroy basis part
     nullify(mol.basis)              ! do not destroy basis part
     nullify(mol.slaterbasis)        ! do not destroy this
     nullify(mol.coppensbasis)       ! do not destroy this
     mol.destroy
   end

   destroy_ANO_data ::: leaky
   ! Destroy the restricted atomic natural orbitals (ANO) data for
   ! all atoms in the molecule.
      k,u,j :: INT
      if (.unique_atom.destroyed) return
      do k = 1,.n_atom_kind 
        u = .unique_atom(k)
        .atom(u).natural_orbitals.destroy
        .atom(u).occupation_numbers.destroy
        .atom(u).density_matrix.destroy
        nullify(.atom(u).natural_orbitals)
        nullify(.atom(u).occupation_numbers)
        nullify(.atom(u).density_matrix)
        .atom(u).energy = ZERO
        do j = u+1,.n_atom
           if (.atom_kind(j)/=k) cycle
           nullify(.atom(j).natural_orbitals)
           nullify(.atom(j).occupation_numbers)
           nullify(.atom(j).density_matrix)
           .atom(j).energy = ZERO
        end
      end
   end


   set_atom_shell_info ::: leaky
   ! Get the atom shell info for all atoms in the molecule. We make it only for
   ! the unique atoms and pointer copy to the non-unique atoms.
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.basis.created,"no basis set")
   ENSURE(.unique_atom.created,"no unique atom list")
   ENSURE(.atom_kind.created,"no atom kind list")
      k,u,j :: INT
      .destroy_atom_shell_info
      do k = 1,.n_atom_kind ! Get ANO data only for unique atoms
        u = .unique_atom(k)
        .atom(u).make_shell_info
        do j = u+1,.n_atom
           if (.atom_kind(j)/=k) cycle
           .atom(j).precomputed_basis_shellpair => .atom(u).precomputed_basis_shellpair
           .atom(j).first_basis_fn_for_shell    => .atom(u).first_basis_fn_for_shell
           .atom(j).last_basis_fn_for_shell     => .atom(u).last_basis_fn_for_shell
        end
      end
   end

   destroy_atom_shell_info ::: leaky
   ! Destroy the atom precomputed shellpair info.
      k,u,j :: INT
      if (.unique_atom.destroyed) return
      do k = 1,.n_atom_kind
        u = .unique_atom(k)
        .atom(u).precomputed_basis_shellpair.destroy
        .atom(u).first_basis_fn_for_shell.destroy
        .atom(u).last_basis_fn_for_shell.destroy
        nullify(.atom(u).precomputed_basis_shellpair)
        nullify(.atom(u).first_basis_fn_for_shell)
        nullify(.atom(u).last_basis_fn_for_shell)
        do j = u+1,.n_atom
           if (.atom_kind(j)/=k) cycle
           nullify(.atom(j).precomputed_basis_shellpair)
           nullify(.atom(j).first_basis_fn_for_shell)
           nullify(.atom(j).last_basis_fn_for_shell)
        end
      end
   end

!---------------------------------------------!
! Roby Energy and Shared Energy calculations  !
!---------------------------------------------!

!   roby_energy_analysis
!   ! directs the energy analysis of a diatomic
!    roby_atom :: VEC{INT}*
!    Ep_A, Ep_B, Ep_AB, E_A, E_B, E_AB :: REAL
!    a,b :: INT
!    .read_roby_atom(roby_atom)
!    ENSURE( size(roby_atom)==2, "Must supply a diatomic...")
!    a = roby_atom(1); b=roby_atom(2)
!    .put_roby_atom_energy( (/ a /) )
!    .put_roby_atom_energy( (/ b /) )
!    .put_roby_atom_energy( roby_atom )
!    Ep_A = .roby_atom_energy( (/a/))
!    Ep_B = .roby_atom_energy( (/b/))
!    Ep_AB = .roby_atom_energy( roby_atom)
!    E_A = .roby_total_atom_energy((/ a /), nuclei=roby_atom,output=TRUE)
!    E_B = .roby_total_atom_energy((/ b /), nuclei=roby_atom,output=TRUE)
!    E_AB = .roby_total_atom_energy(roby_atom, nuclei=roby_atom,output=TRUE)
!!    E_AB = .roby_atom_energy(roby_atom)
!    stdout.show( "Binding Energy: ", HALF * (E_A + E_B - E_AB + Ep_A + Ep_B - Ep_AB) )
!    .put_roby_shared_energy(roby_atom)
!    .put_roby_ionic_energy(roby_atom)
!    stdout.show("Nuclear potential for A:", .atom.nuclear_energy( (/ a /) ))
!    stdout.show("Nuclear potential for B:", .atom.nuclear_energy( (/ b /) ))
!    roby_atom.destroy
!   end
!
!   get_roby_shared_energy(roby_atom) result(se) ::: leaky
!   ! returns the shared energy of the atoms given in "roby_atom"
!   ! as well as the energy of all sub-groups of atoms "en_groups"
!     roby_atom :: VEC{INT}
!     se, energy_subgroup, en_groups :: REAL
!     m,k, n_k, n_roby_atom :: INT
!     comb_mat :: MAT{INT}*
!     n_roby_atom = size(roby_atom)
!     se = 0
!     do k = 1,n_roby_atom
!       n_k = n_roby_atom.choose(k)
!       comb_mat.create(k,n_k)
!       comb_mat = roby_atom.get_combination_matrix_from(k)
!       en_groups = 0
!       do m = 1,n_k
!         energy_subgroup = .roby_total_atom_energy(comb_mat(:,m),output=FALSE)
!         en_groups = en_groups + energy_subgroup
!       end
!       comb_mat.destroy
!       se = se - ((-1)**k)*en_groups
!     end
!   end
!
!   get_roby_ionic_energy(roby_atom, roby_atom2) result(ionic_energy) ::: leaky
!   ! returns the shared energy of the atoms given in "roby_atom"
!   ! as well as the energy of all sub-groups of atoms "en_groups"
!   roby_atom, roby_atom2 :: VEC{INT}
!   ionic_energy, energy_group1, energy_group2 :: REAL
!   ground1, ground2 :: REAL
!       energy_group1 = .roby_total_atom_energy(roby_atom,output=FALSE)
!       energy_group2 = .roby_total_atom_energy(roby_atom2,output=FALSE)
!       ground1 = sum(.atom(roby_atom).energy)
!       ground2 = sum(.atom(roby_atom2).energy)
!       stdout.flush
!       stdout.dash(real_fields=3)
!       stdout.put("Ground State Energy of Atom 1"); stdout.put(ground1)
!       stdout.flush
!       stdout.put("Ground State Energy of Atom 2"); stdout.put(ground2)
!       stdout.flush
!       stdout.dash(real_fields=3)
!       stdout.flush
!       ionic_energy = energy_group1 - energy_group2
!       ionic_energy = ionic_energy - ground1 + ground2
!   end
!
!   put_roby_shared_energy(atoms) ::: leaky
!   ! Evaluate and put the Roby shared energy for a group of atoms
!      atoms :: VEC{INT}, OPTIONAL
!      shared_energy :: REAL
!      roby_atom :: VEC{INT}*
!      if (PRESENT(atoms)) then
!          roby_atom.create(size(atoms))
!          roby_atom = atoms
!      else
!          .read_roby_atom(roby_atom)
!      end
!      shared_energy = .get_roby_shared_energy(roby_atom)
!      stdout.flush
!      stdout.dash(real_fields=3)
!      stdout.show("Shared energy =",shared_energy)
!      roby_atom.destroy
!   end
!
!   put_roby_ionic_energy(atoms) ::: leaky
!   ! Evaluate and put the Roby ionic energy for a group of atoms
!      atoms :: VEC{INT}, OPTIONAL
!      n_roby_atom :: INT
!      roby_atom :: VEC{INT}*
!      if (PRESENT(atoms)) then
!          roby_atom.create(size(atoms))
!          roby_atom = atoms
!      else
!          .read_roby_atom(roby_atom)
!      end
!      n_roby_atom = size(roby_atom)
!      ENSURE(n_roby_atom == 2, "current routine only for two atoms")
!      stdout.dash(real_fields=3)
!      stdout.show("Ionic Energy =", .get_roby_ionic_energy( roby_atom(1:1), roby_atom(2:2)))
!      stdout.flush
!      roby_atom.destroy
!   end
!
!   put_roby_atom_energy(atoms) ::: leaky
!   ! Evaluate and put the Roby ionic energy for a group of atoms
!      atoms :: VEC{INT}, OPTIONAL
!      n_roby_atom, i, a :: INT
!      roby_atom :: VEC{INT}*
!      E_T, E_P, E_A :: REAL
!      if (PRESENT(atoms)) then
!          roby_atom.create(size(atoms))
!          roby_atom = atoms
!      else
!          .read_roby_atom(roby_atom)
!      end
!      n_roby_atom = size(roby_atom)
!      stdout.dash(real_fields=3)
!      stdout.flush
!      stdout.text("Roby atom energy analysis:")
!      stdout.flush
!      stdout.dash(real_fields=3)
!      stdout.flush
!      stdout.text("Atoms =")
!      do i=1,n_roby_atom
!        a = roby_atom(i)
!        stdout.text(trim(.atom(a).label))
!      end
!      E_T = .roby_total_atom_energy(roby_atom)
!      E_P = .roby_atom_energy(roby_atom)
!      E_A = E_T/2 + E_P/2
!      stdout.flush
!      stdout.show("Atom Total Energy =", E_T)
!      stdout.flush
!      stdout.show("Promoted Atom Energy =", E_P)
!      stdout.flush
!      stdout.show("Partitioned Atom Energy =", E_A)
!      stdout.flush
!      stdout.dash(real_fields=3)
!      stdout.flush
!      roby_atom.destroy
!   end
!
!   roby_atom_energy(roby_atom) result(energy) ::: leaky
!   ! Return the Roby promoted atom energy for the group of atoms whose
!   ! indices are given in "roby_atom".
!      roby_atom :: VEC{INT}
!      energy :: REAL
!      D,D_save :: OPMATRIX*
!      P, Q :: MAT{REAL}*
!      D_save => .density_matrix
!      P.create(.n_bf, .n_bf)
!      if (.mult/=1) then
!        Q.create(.n_bf, .n_bf)
!        .make_roby_projected_density(P,roby_atom,.density_matrix.alpha)
!        .make_roby_projected_density(Q,roby_atom,.density_matrix.beta)
!        D.create(.n_bf,"unrestricted")
!        D.alpha = P        ! P is projected density
!        D.beta = Q         ! P is projected density
!        Q.destroy
!      else
!        D.create(.n_bf,"restricted")
!        .make_roby_projected_density(P,roby_atom)
!        D.restricted = P        ! P is projected density
!      end
!      .density_matrix => D
!      .make_fock_matrix(core=FALSE)
!      if (.mult/=1) then
!          .add_core_hamiltonian(.fock_matrix.beta, roby_atom)
!          .add_core_hamiltonian(.fock_matrix.alpha, roby_atom)
!      else
!          .add_core_hamiltonian(.fock_matrix.restricted, roby_atom)
!      end
!      energy = .scf_electronic_energy(D,roby_atom) + .atom(roby_atom).nuclear_energy
!      .density_matrix => D_save
!      D.destroy
!      P.destroy
!   end
!
!   roby_total_atom_energy(roby_atom, nuclei, output) result(energy) ::: leaky
!   ! Return the total Roby energy for the group of atoms whose
!   ! indices are given in "roby_atom" If output is present and false energy breakdown
!   ! output is suppressed. If nuclei is given then only the nuclei specified
!   ! are used for E_N and N_N and N_E interactions, and the projected atoms specified by nuclei for the E_E
!   ! repulsions
!      roby_atom :: VEC{INT}
!      nuclei :: VEC{INT}, optional
!      output :: BIN, optional
!      do_output :: BIN
!      energy, E_k, Na_Em, Na_Ea, Ea_Nm, Ea_Em, Ea_Ea :: REAL
!      Pa, Pb, Za, Zm, T :: MAT{REAL}*
!      D, D_save :: MAT{REAL}*
!      do_output=TRUE
!      if (present(output)) do_output=output              ! puts out the energies and sub-energies and all that
!      T.create(.n_bf, .n_bf); Pa.create(.n_bf, .n_bf)
!      Za.create(.n_bf, .n_bf); Zm.create(.n_bf, .n_bf)
!      if (present(nuclei)) then
!         .make_nuclear_matrix(Zm,nuclei)   ! The e->n attractions of the atoms electrons for the "nuclei"
!      else
!         .make_nuclear_matrix(Zm)          ! The e->n attractions of the atoms electrons for all the nuclei
!      end
!      .make_nuclear_matrix(Za,roby_atom)   ! The n->e attractions felt by the nuclei in the roby atom
!      .make_kinetic_matrix(T)              ! The electronic kinetic energy matrix
!      if (.mult/=1) then
!        Pb.create(.n_bf, .n_bf)
!        if (present(nuclei)) then          ! if we only want to look at interactions with subgroups of the molecule
!          D_save => .density_matrix.alpha  ! store the "real" density matrix of the molecule
!          D => .density_matrix.beta
!          .make_roby_projected_density(Pa,nuclei,.density_matrix.alpha)
!          .make_roby_projected_density(Pb,nuclei,.density_matrix.beta)
!          .density_matrix.alpha => Pa      ! replace the "real" density matrix with the projected "nuclei"
!          .density_matrix.beta => Pb
!          .make_fock_matrix(core=FALSE)    ! calculate e-e repulsions for all electrons in projected "nuclei"
!          !Na_Em = Za.trace_product_with(.density_matrix.alpha) + Za.trace_product_with(.density_matrix.beta)
!          Na_Em = .density_matrix.alpha.trace_product_with(Za) + .density_matrix.beta.trace_product_with(Za)
!                                           ! calculate n-e repulsions for all electrons in projected "nuclei"
!                                           ! and nuclei in "roby_atom"
!          .density_matrix.alpha => D_save  ! restore "real" density matrix
!          .density_matrix.beta => D
!        else
!          .make_fock_matrix(core=FALSE)    ! calculate e-e repulsions for all electrons in molecule
!        ! Na_Em = Za.trace_product_with(.density_matrix.alpha) + Za.trace_product_with(.density_matrix.beta)
!          Na_Em = .density_matrix.alpha.trace_product_with(Za) + .density_matrix.beta.trace_product_with(Za)
!                                           ! calculate e-e repulsions for all electrons in molecule with roby_atom
!        end
!        D_save => .density_matrix.alpha    ! save "real" density matrix
!        D => .density_matrix.beta
!        .make_roby_projected_density(Pa,roby_atom,.density_matrix.alpha)
!        .make_roby_projected_density(Pb,roby_atom,.density_matrix.beta )
!        Ea_Em = .fock_matrix.alpha.trace_product_with(Pa) + .fock_matrix.beta.trace_product_with(Pb)
!        E_k = T.trace_product_with(Pa) + T.trace_product_with(Pb)     ! calculate Kinetic Energy for "roby_atom" electrons
!        Na_Ea = Za.trace_product_with(Pa) + Za.trace_product_with(Pb) ! calculate Nuclear -> electron energy  (A->A)
!        Ea_Nm = Zm.trace_product_with(Pa) + Zm.trace_product_with(Pb) ! calculate Nuclear -> electron energy  (M->A)
!        .density_matrix.alpha => Pa        ! set "real" density matrix to be the projected atoms "roby_atom"
!        .density_matrix.beta => Pb
!        .make_fock_matrix(core=FALSE)      ! calculate repulsions within the "roby_atom"
!        Ea_Ea = .fock_matrix.alpha.trace_product_with(Pa) + .fock_matrix.beta.trace_product_with(Pb)
!        Ea_Em = Ea_Em - Ea_Ea/2            ! subtract 1/2 of the internal atom repulsions for double up
!        .density_matrix.alpha => D_save
!        .density_matrix.beta => D          ! reset "real" density matrix
!        Pb.destroy
!      else
!        if (present(nuclei)) then             ! to look at the energy of the atom in the field of only certain atoms "nuclei"
!          D_save => .density_matrix.restricted          ! save the "real" density matrix
!          .make_roby_projected_density(Pa,nuclei)   ! reset the "real" density matrix to a projected density
!          .density_matrix.restricted => Pa
!          Na_Em = Za.trace_product_with(.density_matrix.restricted)
!          .make_fock_matrix(core=FALSE)      ! no core and for the whole molecule
!          .density_matrix.restricted => D_save
!        else
!          Na_Em = Za.trace_product_with(.density_matrix.restricted)
!          .make_fock_matrix(core=FALSE)
!        end
!        D_save => .density_matrix.restricted
!        .make_roby_projected_density(Pa,roby_atom)
!        Ea_Em = .fock_matrix.restricted.trace_product_with(Pa)
!        Na_Ea = Za.trace_product_with(Pa)
!        Ea_Nm = Zm.trace_product_with(Pa)
!        E_k = T.trace_product_with(Pa)
!        .density_matrix.restricted => Pa
!        .make_fock_matrix(core=FALSE)      ! no core and for the whole molecule
!        Ea_Ea = .fock_matrix.restricted.trace_product_with(Pa)
!        Ea_Em = Ea_Em - Ea_Ea/2
!        .density_matrix.restricted => D_save
!      end
!      energy = Na_Em + E_k + Ea_Em + Ea_Nm - Na_Ea
!      if (present(nuclei)) then
!        energy = energy + .atom.nuclear_energy(roby_atom,nuclei)
!      else
!        energy = energy + .atom.nuclear_energy(roby_atom)
!      end
!      if (do_output) then
!       stdout.dash(real_fields=3)
!       stdout.show("N_a to E_m:",Na_Em)
!       stdout.show("N_a to E_a:",Na_Ea)
!       stdout.show("E_a to N_m:",Ea_Nm)
!       stdout.show("E_a to E_m:",Ea_Em)
!       stdout.show("N_a to N_m:", .atom.nuclear_energy(roby_atom))
!       stdout.show("Kinetic Energy:", E_k)
!       stdout.show("Total Energy:", energy)
!       stdout.dash(real_fields=3)
!      end
!      Pa.destroy
!   end

!-----------------------------------------!
! Plot covalent and ionic theta orbitals  !
!-----------------------------------------!

!   plot_roby_orbitals
!   ! Plots the covalent and ionic orbitals to a grid
!   roby_atom, roby_atom1, roby_atom2 :: VEC{INT}*
!     .read_roby_groups(roby_atom,roby_atom1,roby_atom2)
!     .plot_cos_sin_orbitals(roby_atom, roby_atom1, roby_atom2)
!     roby_atom.destroy
!     roby_atom1.destroy
!     roby_atom2.destroy
!   end
!
!   plot_cos_sin_orbitals(roby_atom, roby_atom1, roby_atom2)
!   ! Plots the cos and sin Roby-Gould orbitals
!   ! -----------------------------------------
!      roby_atom, roby_atom1, roby_atom2 :: VEC{INT}
!      C, theta_c, S, theta_s :: MAT{REAL}*
!      cval, sval :: VEC{REAL}*
!      c_pair, s_pair, cs_pair :: VEC{INT}*
!      n_a, n_b, n_ab :: INT
!      i, j, k, kk :: INT
!      proj_COs, proj_SOs, saved_NOs :: OPMATRIX*
!      arch :: ARCHIVE
!      gr :: VEC{REAL}*
!      pi_space, blurb :: BIN
!   ! -----------------------------------------
!      blurb = TRUE
!      DIE_IF(.grid.destroyed, "no grid exists")
!      DIE_IF(.mult/=1, "multiplicity /= 1")
!      DIE_IF(.natural_orbitals.number_kind /= "real","NOs not real")
!      n_a = .atom(roby_atom1).n_bf
!      n_b = .atom(roby_atom2).n_bf
!      n_ab = .atom(roby_atom).n_bf
!      DIE_IF(n_ab /= n_a + n_b, "n-ab /= n_a + n_b")
!      C.create(n_ab,n_ab); theta_c.create(n_ab, n_ab); cval.create(n_ab)
!      S.create(n_ab,n_ab); theta_s.create(n_ab, n_ab); sval.create(n_ab)
!      .make_shared_operator(C)
!      .make_ionic_operator(S)
!      .diagonalise_V_AB_operator(C,roby_atom,theta_c,cval)
!      .diagonalise_V_AB_operator(S,roby_atom,theta_s,sval)
!      c_pair.create(n_ab); s_pair.create(n_ab); cs_pair.create(n_ab)
!      .find_pairs(cval, sval, c_pair,s_pair,cs_pair)
!      .put_roby_eigenvalues(roby_atom1,roby_atom2,sval,cval,c_pair,s_pair,cs_pair,blurb)
!      saved_NOs => .natural_orbitals
!      gr.create(.grid.n_pt)
!      proj_COs.create( .n_bf, "restricted")
!      proj_SOs.create( .n_bf, "restricted")
!      .AO_subspace_set(proj_COs.restricted, theta_c, roby_atom)
!      .AO_subspace_set(proj_SOs.restricted, theta_s, roby_atom)
!      pi_space = TRUE
!      do i = 1, n_ab
!        stdout.flush; stdout.put("i,c_pair(i),s_pair(i),cs_pair(i) = ")
!        stdout.put(i); stdout.put(c_pair(i)); stdout.put(s_pair(i)); stdout.put(cs_pair(i))
!        j = cs_pair(i)
!        if (j < 0) cycle
!        stdout.put("cs_pair(i) >= 0")
!        if (pi_space AND s_pair(j) == -1) then
!           ! sin: pi/2
!           stdout.flush; stdout.put("pi/2")
!           k = j
!           kk = i
!           .natural_orbitals => proj_SOs
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"sin_pi_grid")
!           arch.write(gr)
!           arch.set(.name,"sin_pi_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
!        end
!        if (s_pair(j) > -1) then
!           stdout.flush; stdout.put("other")
!           ! cos: +
!           k = i
!           kk = k
!           .natural_orbitals => proj_COs
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"cos_orbital_grid")
!           arch.write(gr)
!           arch.set(.name,"cos_orbital_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
!           ! cos: -
!           k = c_pair(i)
!           kk = k
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"cos_orbital_grid")
!           arch.write(gr)
!           arch.set(.name,"cos_orbital_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
!           ! sin: +
!           k = j
!           kk = i
!           .natural_orbitals => proj_SOs
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"sin_orbital_grid")
!           arch.write(gr)
!           arch.set(.name,"sin_orbital_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
!           ! sin: -
!           k = s_pair(j)
!           kk = c_pair(i)
!           .make_orbital_grid(gr,k)
!           arch.set(.name,"sin_orbital_grid")
!           arch.write(gr)
!           arch.set(.name,"sin_orbital_grid"//trim(kk.to_str)//"",format="ascii")
!           arch.write_gnuplot(gr, .grid.n_x, .grid.n_y, .grid.n_z)
!        end
!      end
!      .natural_orbitals => saved_NOs
!      gr.destroy
!      proj_COs.destroy
!      proj_SOs.destroy
!      C.destroy; theta_c.destroy; cval.destroy
!      S.destroy; theta_s.destroy; sval.destroy
!      c_pair.destroy; s_pair.destroy; cs_pair.destroy
!   end

!  ***************************
!  Cluster generation routines
!  ***************************

   read_cluster ::: leaky
   ! Read in the crystal cluster data. NOTE: the .atom list must correspond to
   ! the (unpruned or pruned) asymmetric unit cell geometry of the .crystal.
   ENSURE(.atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")
      .cluster.destroy
      .crystal.make_fragment_data(.atom) 
      DIE_IF(any(.crystal.frag_atom_for_asym_unit_atom==0),"some asymetric unit atoms were not found")
      .cluster.create(.crystal,.atom(.crystal.frag_atom_for_asym_unit_atom))
      .cluster.read_keywords
   end

   create_cluster ::: leaky
   ! Create a new "self" by generating a cluster from information stored in
   ! .cluster.  The original molecule is stored in .saved and can be recovered
   ! by the "destroy_cluster" routine.
     self :: PTR
   ENSURE(.crystal.created,"no crystal data")
   ENSURE(.cluster.created,"no cluster data")
   ENSURE(.cluster.info_made,"no cluster data")
     fragment_atom :: VEC{ATOM}*

     ! Save the original molecule
     .save 

     ! Making a new cluster from .saved CIF
     .name  =  trim(.saved.name) // "_cluster"
     if (.saved.cif.created) .cif.create_copy(.saved.cif)

     ! Create copies so that they can easily be destroyed without leaks
     .cluster.create_copy(.saved.cluster)
     .cluster.create_atom_list(.atom)                  ! Make new .atom list
     .crystal.create_copy(.saved.cluster.crystal)      ! Make from the saved cluster crystal
     .cluster.create_fragment_atom_list(fragment_atom) ! This uses the info already in .cluster
     .crystal.make_fragment_data(fragment_atom)
     fragment_atom.nullify_basis_part                  ! Bases were only pointer assigned
     fragment_atom.destroy
     .set_atom_info

     ! Make sure basis is OK.
     if (.saved.basis_set_kind/=" ") then
        .set_basis_set_kind(.saved.basis_set_kind)
     else
        if (.saved.basis.created)               .basis.create_copy(.saved.basis)
        if (.saved.slaterbasis.created)   .slaterbasis.create_copy(.saved.slaterbasis)
        if (.saved.coppensbasis.created) .coppensbasis.create_copy(.saved.coppensbasis)
        .resolve_basis_info
     end

   ! *** not tested yet
   ! if (.saved.density_matrix.created) then
   ! if (.saved.density_matrix.restricted.created) then
   !    .density_matrix.create(.n_bf,"restricted")
   !    .cluster.make_density_matrix(.density_matrix.restricted,.saved.density_matrix.restricted,.atom)
   ! end
   ! end

     stdout.flush
     stdout.text("New molecule created with name: " // trim(.name))
     stdout.flush
     stdout.text('To recover the original molecule use the "unsave" or "destroy_cluster" keyword')

   end

   destroy_cluster ::: leaky
   ! Destroy a molecule created by the "create_cluster" routine, and recover
   ! the original molecule from .saved
     self :: PTR
   ENSURE(.saved.created,"no crystal data")
     .unsave
   end

!  *************
!  Miscellaneous
!  *************

!   put_sylvian_csizmadia_tensors
!   ! Put out the Sylvian-Csizmadia polarisability tensors.
!   ! This routine will read the value of the Unsold denominator.
!      Dx,Dy,Dz, P,Pi,Pj,MOi,MOj :: MAT{REAL}*
!      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}*
!      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}*
!      x,y,z, i,j :: INT
!      delta,fac :: REAL
!      alpha :: MAT{REAL}(3,3)
!      beta :: MAT3{REAL}(3,3,3)
!      alpha1 :: MAT3{REAL}*
!      alpha2 :: MAT4{REAL}*
!   ENSURE(.density_matrix.created,"no density matrix")
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created, "no atom info")
!      stdout.flush
!      stdout.text("Sylvian-Csizmadia polarisability tensors")
!      stdout.flush
!      stdin.read(delta)
!      stdout.show("Unsold denominator/a.u. =",delta)
!      Dx.create(.n_bf,.n_bf); Dy.create(.n_bf,.n_bf); Dz.create(.n_bf,.n_bf)
!      Qxx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
!      Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
!      Oxxx.create(.n_bf,.n_bf); Oyyy.create(.n_bf,.n_bf); Ozzz.create(.n_bf,.n_bf)
!      Oxxy.create(.n_bf,.n_bf); Oxxz.create(.n_bf,.n_bf)
!      Oyyx.create(.n_bf,.n_bf); Oyyz.create(.n_bf,.n_bf)
!      Ozzx.create(.n_bf,.n_bf); Ozzy.create(.n_bf,.n_bf)
!      Oxyz.create(.n_bf,.n_bf)
!      .get_dipole_matrices(Dx,Dy,Dz)
!      .get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
!      .get_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)
!      .make_ao_density_matrix
!      x = 1; y = 2; z = 3
!      P.create(.n_bf,.n_bf)
!      P = HALF*.density_matrix.restricted
!      alpha(x,x) = P.trace_product_with(Qxx) - P.trace_product_with(Dx,P,Dx)
!      alpha(y,y) = P.trace_product_with(Qyy) - P.trace_product_with(Dy,P,Dy)
!      alpha(z,z) = P.trace_product_with(Qzz) - P.trace_product_with(Dz,P,Dz)
!      alpha(y,x) = P.trace_product_with(Qxy) - P.trace_product_with(Dy,P,Dx)
!      alpha(z,x) = P.trace_product_with(Qxz) - P.trace_product_with(Dz,P,Dx)
!      alpha(z,y) = P.trace_product_with(Qyz) - P.trace_product_with(Dz,P,Dy)
!      alpha.symmetric_reflect
!      fac = FOUR/delta
!      alpha = fac*alpha
!      stdout.flush
!      stdout.show("No. of occupiedf orbitals = ",.n_a)
!      stdout.flush
!      stdout.text("Orbital eigenvalues:")
!      stdout.flush
!      stdout.put(.orbital_energies,"column")
!      stdout.flush
!      stdout.text("First polarisability:")
!      stdout.flush
!      stdout.put(alpha)
!      ! Evaluate the orbital contributions
!      alpha1.create(3,3,.n_a); alpha1 = ZERO
!      alpha2.create(3,3,.n_a,.n_a); alpha2 = ZERO
!      Pi.create(.n_bf,.n_bf)
!      Pj.create(.n_bf,.n_bf)
!      do i = 1,.n_a
!         MOi => .molecular_orbitals.restricted(:,i:i)
!         Pi.to_product_of(MOi,MOi,transpose_b=TRUE)
!         alpha1(x,x,i) = Pi.trace_product_with(Qxx) - Pi.trace_product_with(Dx,Pi,Dx)
!         alpha1(y,y,i) = Pi.trace_product_with(Qyy) - Pi.trace_product_with(Dy,Pi,Dy)
!         alpha1(z,z,i) = Pi.trace_product_with(Qzz) - Pi.trace_product_with(Dz,Pi,Dz)
!         alpha1(y,x,i) = Pi.trace_product_with(Qxy) - Pi.trace_product_with(Dy,Pi,Dx)
!         alpha1(z,x,i) = Pi.trace_product_with(Qxz) - Pi.trace_product_with(Dz,Pi,Dx)
!         alpha1(z,y,i) = Pi.trace_product_with(Qyz) - Pi.trace_product_with(Dz,Pi,Dy)
!         alpha1(:,:,i).symmetric_reflect
!         do j = 1,(i-1)
!            MOj => .molecular_orbitals.restricted(:,j:j)
!            Pj.to_product_of(MOj,MOj,transpose_b=TRUE)
!            alpha2(x,x,i,j) = -Pi.trace_product_with(Dx,Pj,Dx)-Pj.trace_product_with(Dx,Pi,Dx)
!            alpha2(y,y,i,j) = -Pi.trace_product_with(Dy,Pj,Dy)-Pj.trace_product_with(Dy,Pi,Dy)
!            alpha2(z,z,i,j) = -Pi.trace_product_with(Dz,Pj,Dz)-Pj.trace_product_with(Dz,Pi,Dz)
!            alpha2(y,x,i,j) = -Pi.trace_product_with(Dy,Pj,Dx)-Pj.trace_product_with(Dy,Pi,Dx)
!            alpha2(z,x,i,j) = -Pi.trace_product_with(Dz,Pj,Dx)-Pj.trace_product_with(Dz,Pi,Dx)
!            alpha2(z,y,i,j) = -Pi.trace_product_with(Dz,Pj,Dy)-Pj.trace_product_with(Dz,Pi,Dy)
!            alpha2(:,:,i,j).symmetric_reflect
!         end
!      end
!      Pj.destroy
!      Pi.destroy
!      alpha1 = fac*alpha1
!      alpha2 = fac*alpha2
!      stdout.flush
!      stdout.text("First polarisability, orbital contributions:")
!      stdout.flush
!      do i = 1,.n_a
!         stdout.text("... for orbital "//i.to_str.trim)
!         stdout.put(alpha1(:,:,i))
!      end
!      stdout.flush
!      stdout.text("First polarisability, orbital pair contributions:")
!      stdout.flush
!      do i = 1,.n_a
!      do j = 1,(i-1)
!         stdout.text("... for orbitals "//i.to_str.trim//" and "//j.to_str.trim)
!         stdout.put(alpha2(:,:,i,j))
!      end
!      end
!      stdout.flush
!      stdout.text("Sum of all orbital contributions:")
!      stdout.flush
!      alpha = ZERO
!      do i = 1,.n_a
!         alpha = alpha + alpha1(:,:,i)
!         do j = 1,(i-1)
!            alpha = alpha + alpha2(:,:,i,j)
!         end
!      end
!      stdout.put(alpha)
!      alpha2.destroy
!      alpha1.destroy
!      beta(x,x,x) = P.trace_product_with(Oxxx) - THREE*P.trace_product_with(Dx,P,Qxx) &
!                  + P.trace_product_with(Dx,P,Dx,P,Dx)
!      beta(y,y,y) = P.trace_product_with(Oyyy) - THREE*P.trace_product_with(Dy,P,Qyy) &
!                  + P.trace_product_with(Dy,P,Dy,P,Dy)
!      beta(z,z,z) = P.trace_product_with(Ozzz) - THREE*P.trace_product_with(Dz,P,Qzz) &
!                  + P.trace_product_with(Dz,P,Dz,P,Dz)
!      beta(y,x,x) = P.trace_product_with(Oxxy) - TWO*P.trace_product_with(Dx,P,Qxy) &
!                  - P.trace_product_with(Dy,P,Qxx) + P.trace_product_with(Dy,P,Dx,P,Dx)
!      beta(z,x,x) = P.trace_product_with(Oxxz) - TWO*P.trace_product_with(Dx,P,Qxz) &
!                  - P.trace_product_with(Dz,P,Qxx) + P.trace_product_with(Dz,P,Dx,P,Dx)
!      beta(y,y,x) = P.trace_product_with(Oyyx) - TWO*P.trace_product_with(Dy,P,Qxy) &
!                  - P.trace_product_with(Dx,P,Qyy) + P.trace_product_with(Dy,P,Dy,P,Dx)
!      beta(z,y,x) = P.trace_product_with(Oxyz) - P.trace_product_with(Dz,P,Qxy) &
!                  - P.trace_product_with(Dy,P,Qxz) - P.trace_product_with(Dx,P,Qyz) &
!                  + P.trace_product_with(Dz,P,Dy,P,Dx)
!      beta(z,z,x) = P.trace_product_with(Ozzx) - TWO*P.trace_product_with(Dz,P,Qxz) &
!                  - P.trace_product_with(Dx,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dx)
!      beta(z,y,y) = P.trace_product_with(Oyyz) - TWO*P.trace_product_with(Dy,P,Qyz) &
!                  - P.trace_product_with(Dz,P,Qyy) + P.trace_product_with(Dz,P,Dy,P,Dy)
!      beta(z,z,y) = P.trace_product_with(Ozzy) - TWO*P.trace_product_with(Dz,P,Qyz) &
!                  - P.trace_product_with(Dy,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dy)
!      beta.make_symmetric
!      fac = 12.0d0/delta
!      beta = fac*beta
!      stdout.flush
!      stdout.text("Second polarisability:")
!      stdout.flush
!      stdout.put(beta)
!      P.destroy
!      Oxyz.destroy
!      Ozzy.destroy; Ozzx.destroy
!      Oyyz.destroy; Oyyx.destroy
!      Oxxz.destroy; Oxxy.destroy
!      Ozzz.destroy; Oyyy.destroy; Oxxx.destroy
!      Qyz.destroy; Qxz.destroy; Qxy.destroy
!      Qzz.destroy; Qyy.destroy; Qxx.destroy
!      Dz.destroy; Dy.destroy; Dx.destroy
!   end

   make_weak_force_energy_shift
   ! Make the expectation value of the parity-violating energy shift.
   ! Requires some archived molecular orbitals, general_complex kind.
   ! Reference: R. Zanasi and P. Lazzeretti, CPL 286, 240 (1998)
   ENSURE(.basis_info_made, "no basis info")
       pt :: MAT{REAL}*
       Pa,Pb :: VEC{CPX}*
       Na,Nb :: MAT{CPX}*
       PV,NN :: VEC{REAL}*
       n, x,y,z :: INT
       Gamma :: REAL
        I :: CPX
       arch :: ARCHIVE
       .molecular_orbitals.destroy_ptr_part
       arch.set(.name,"molecular_orbitals")
       arch.read(.molecular_orbitals, genre="general_complex")
       Gamma = 5.73416d-17
       PV.create(.n_atom)
       pt.create(.n_atom,3)
       .atom.get_coordinates(pt)
       Pa.create(.n_atom);   Pb.create(.n_atom)
       Na.create(.n_atom,3); Nb.create(.n_atom,3)
       I = (ZERO,ONE)
       stdout.set_real_style("d")
       x = 1; y = 2; z = 3
       PV = ZERO
       do n = 1,.n_e
          .make_nabla_orbital_grid_c(Na,Pa,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
          .make_nabla_orbital_grid_c(Nb,Pb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
          PV(:) = PV(:) &
                + I*conjg(Nb(:,x))*Pa(:) + I*conjg(Na(:,x))*Pb(:) &
                - I*conjg(Pb(:))*Na(:,x) - I*conjg(Pa(:))*Nb(:,x) &
                +   conjg(Nb(:,y))*Pa(:) -   conjg(Na(:,y))*Pb(:) &
                +   conjg(Pb(:))*Na(:,y) -   conjg(Pa(:))*Nb(:,y) &
                + I*conjg(Na(:,z))*Pa(:) - I*conjg(Nb(:,z))*Pb(:) &
                - I*conjg(Pa(:))*Na(:,z) + I*conjg(Pb(:))*Nb(:,z)
       end
       PV = -HALF*Gamma*PV
       Nb.destroy; Na.destroy
       Pb.destroy; Pa.destroy
       pt.destroy
       NN.create(.n_atom)
       .atom.get_mean_neutron_numbers(NN)
       PV = PV*NN

       stdout.set_real_style("d")
       stdout.flush
       stdout.text("Contributions (by nucleus) to the parity-violating weak force energy shift term:")
       stdout.flush
       stdout.put(PV, format="column")
       stdout.flush
       stdout.show("Total contribution =", sum(PV) )
       stdout.flush
       stdout.text("Neutron numbers:")
       stdout.flush
       stdout.put(NN, format="column")
       stdout.set_real_style("f")
       NN.destroy
       PV.destroy
       .molecular_orbitals.destroy_ptr_part
   end

   put_g_tensor_information
   ! Put the g-tensor shift information to the output.
   ! Reference: Jayatilaka, JCP 108, 7587 (1998)
      S, Lx,Ly,Lz, Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, T :: MAT{REAL}*
      HH,P :: MAT{CPX}*
      Sx,Sy,Sz,SS_net, Mx,My,Mz,MM_net :: REAL
      Qx,Qy,Qz,QQ_net, Tx,Ty,Tz,TT_net :: REAL
      Sx_ppm,Sy_ppm,Sz_ppm, Mx_ppm,My_ppm,Mz_ppm :: REAL
      Qx_ppm,Qy_ppm,Qz_ppm, Tx_ppm,Ty_ppm,Tz_ppm :: REAL
      fac, fx,fy,fz, total :: REAL
      quantization_axis :: VEC{REAL}(3)
       I :: CPX
       m :: INT
      int_width :: BIN
      arch :: ARCHIVE
      .density_matrix.destroy_ptr_part
      arch.set(.name,"density_matrix")
      arch.read(.density_matrix, genre="general_complex")
      P => .density_matrix%general_complex
      HH.create(2*.n_bf,2*.n_bf)
      I = (ZERO,ONE)
      quantization_axis = .scfdata.quantization_axis
      ! Spin contribution
      S.create(.n_bf,.n_bf)
      .get_overlap_matrix(S)
      fac = G_FACTOR/FOUR
      HH = ZERO
      HH.beta_alpha_plus(S,factor=fac)
      HH.alpha_beta_plus(S,factor=fac)
      Sx = HH.trace_product_with(P)
      HH = ZERO
      HH.beta_alpha_plus(S,factor=fac*I)
      HH.alpha_beta_plus(S,factor=-fac*I)
      Sy = HH.trace_product_with(P)
      HH = ZERO
      HH.alpha_alpha_plus(S,factor=fac)
      HH.beta_beta_plus(S,factor=-fac)
      Sz = HH.trace_product_with(P)
      S.destroy
      m = .n_a - .n_b
      fx = m*fac*quantization_axis(1)
      fy = m*fac*quantization_axis(2)
      fz = m*fac*quantization_axis(3)
      Sx_ppm = (Sx-fx)*4000000/m
      Sy_ppm = (Sy-fy)*4000000/m
      Sz_ppm = (Sz-fz)*4000000/m
      SS_net = Sx_ppm*quantization_axis(1) + Sy_ppm*quantization_axis(2) + Sz_ppm*quantization_axis(3)
      ! L contribution
      Lx.create(.n_bf,.n_bf)
      Ly.create(.n_bf,.n_bf)
      Lz.create(.n_bf,.n_bf)
      .get_L_matrices(Lx,Ly,Lz)
      fac = HALF
      HH = ZERO
      HH.alpha_alpha_plus(Lx,factor=-fac*I)  ! -I factor for the nabla part
      HH.beta_beta_plus(Lx,factor=-fac*I)
      Mx = HH.trace_product_with(P)
      HH = ZERO
      HH.alpha_alpha_plus(Ly,factor=-fac*I)
      HH.beta_beta_plus(Ly,factor=-fac*I)
      My = HH.trace_product_with(P)
      HH = ZERO
      HH.alpha_alpha_plus(Lz,factor=-fac*I)
      HH.beta_beta_plus(Lz,factor=-fac*I)
      Mz = HH.trace_product_with(P)
      Lz.destroy; Ly.destroy; Lx.destroy
      Mx_ppm = Mx*4000000/m
      My_ppm = My*4000000/m
      Mz_ppm = Mz*4000000/m
      MM_net = Mx_ppm*quantization_axis(1) + My_ppm*quantization_axis(2) + Mz_ppm*quantization_axis(3)
      ! 1 electron LS gauge contribution
      Qxx.create(.n_bf,.n_bf); Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf)
      Qyx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
      Qzx.create(.n_bf,.n_bf); Qzy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
      .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
      fac = G_FACTOR/(TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      HH = ZERO
      HH.beta_alpha_plus(Qyy,factor=fac)
      HH.beta_alpha_plus(Qzz,factor=fac)
      HH.beta_alpha_plus(Qyx,factor=-I*fac)
      HH.alpha_alpha_plus(Qzx,factor=-fac)
      HH.beta_beta_plus(Qzx,factor=+fac)
      HH.make_hermitian
      Qx = HH.trace_product_with(P)
      HH = ZERO
      HH.beta_alpha_plus(Qxx,factor=I*fac)
      HH.beta_alpha_plus(Qzz,factor=I*fac)
      HH.beta_alpha_plus(Qxy,factor=-fac)
      HH.alpha_alpha_plus(Qzy,factor=-fac)
      HH.beta_beta_plus(Qzy,factor=+fac)
      HH.make_hermitian
      Qy = HH.trace_product_with(P)
      HH = ZERO
      HH.alpha_alpha_plus(Qxx,factor=fac)
      HH.alpha_alpha_plus(Qyy,factor=fac)
      HH.beta_beta_plus(Qxx,factor=-fac)
      HH.beta_beta_plus(Qyy,factor=-fac)
      HH.beta_alpha_plus(Qxz,factor=-fac)
      HH.beta_alpha_plus(Qyz,factor=-I*fac)
      HH.make_hermitian
      Qz = HH.trace_product_with(P)
      Qzz.destroy; Qzy.destroy; Qzx.destroy
      Qyz.destroy; Qyy.destroy; Qyx.destroy
      Qxz.destroy; Qxy.destroy; Qxx.destroy
      Qx_ppm = Qx*4000000/m
      Qy_ppm = Qy*4000000/m
      Qz_ppm = Qz*4000000/m
      QQ_net = Qx_ppm*quantization_axis(1) + Qy_ppm*quantization_axis(2) + Qz_ppm*quantization_axis(3)
      ! Relativistic kinetic energy contribution
      T.create(.n_bf,.n_bf)
      .get_kinetic_matrix(T)
      fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
      HH = ZERO
      HH.beta_alpha_plus(T,factor=fac)
      HH.alpha_beta_plus(T,factor=fac)
      Tx = HH.trace_product_with(P)
      HH = ZERO
      HH.beta_alpha_plus(T,factor=I*fac)
      HH.alpha_beta_plus(T,factor=-I*fac)
      Ty = HH.trace_product_with(P)
      HH = ZERO
      HH.alpha_alpha_plus(T,factor=fac)
      HH.beta_beta_plus(T,factor=-fac)
      Tz = HH.trace_product_with(P)
      T.destroy
      HH.destroy
      .density_matrix.destroy_ptr_part
      Tx_ppm = Tx*4000000/m
      Ty_ppm = Ty*4000000/m
      Tz_ppm = Tz*4000000/m
      TT_net = Tx_ppm*quantization_axis(1) + Ty_ppm*quantization_axis(2) + Tz_ppm*quantization_axis(3)

      stdout.set_real_style("d")
      int_width = TRUE
      stdout.flush
      stdout.text("Contribution to g-tensor shift:")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=2)
      stdout.put("Term",int_width); stdout.put("<value>");
      stdout.put("shift/ppm"); stdout.flush
      stdout.dash(int_fields=1,real_fields=2)
      stdout.text("Spin term:")
      stdout.put("S_x",int_width)
      stdout.set_real_style("d"); stdout.put(Sx)
      stdout.set_real_style("f"); stdout.put(Sx_ppm); stdout.flush
      stdout.put("S_y",int_width)
      stdout.set_real_style("d"); stdout.put(Sy)
      stdout.set_real_style("f"); stdout.put(Sy_ppm); stdout.flush
      stdout.put("S_z",int_width)
      stdout.set_real_style("d"); stdout.put(Sz);
      stdout.set_real_style("f"); stdout.put(Sz_ppm); stdout.flush
      stdout.put("Net",int_width); stdout.tab(real_fields=1);
      stdout.put(SS_net); stdout.flush
      stdout.text("Angular momentum term:")
      stdout.put("L_x",int_width)
      stdout.set_real_style("d"); stdout.put(Mx);
      stdout.set_real_style("f"); stdout.put(Mx_ppm); stdout.flush
      stdout.put("L_y",int_width)
      stdout.set_real_style("d"); stdout.put(My);
      stdout.set_real_style("f"); stdout.put(My_ppm); stdout.flush
      stdout.put("L_z",int_width)
      stdout.set_real_style("d"); stdout.put(Mz);
      stdout.set_real_style("f"); stdout.put(Mz_ppm); stdout.flush
      stdout.put("Net",int_width); stdout.tab(real_fields=1);
      stdout.put(MM_net); stdout.flush
      stdout.text("1-electron L:S gauge term:")
      stdout.put("Q_x",int_width)
      stdout.set_real_style("d"); stdout.put(Qx);
      stdout.set_real_style("f"); stdout.put(Qx_ppm); stdout.flush
      stdout.put("Q_y",int_width)
      stdout.set_real_style("d"); stdout.put(Qy);
      stdout.set_real_style("f"); stdout.put(Qy_ppm); stdout.flush
      stdout.put("Q_z",int_width)
      stdout.set_real_style("d"); stdout.put(Qz);
      stdout.set_real_style("f"); stdout.put(Qz_ppm); stdout.flush
      stdout.put("Net",int_width); stdout.tab(real_fields=1);
      stdout.put(QQ_net); stdout.flush
      stdout.text("Relativistic B:S kinetic term:")
      stdout.put("T_x",int_width)
      stdout.set_real_style("d"); stdout.put(Tx)
      stdout.set_real_style("f"); stdout.put(Tx_ppm); stdout.flush
      stdout.put("T_y",int_width)
      stdout.set_real_style("d"); stdout.put(Ty);
      stdout.set_real_style("f"); stdout.put(Ty_ppm); stdout.flush
      stdout.put("T_z",int_width)
      stdout.set_real_style("d"); stdout.put(Tz);
      stdout.set_real_style("f"); stdout.put(Tz_ppm); stdout.flush
      stdout.put("Net",int_width); stdout.tab(real_fields=1);
      stdout.put(TT_net); stdout.flush
      total = SS_net + MM_net + QQ_net + TT_net
      stdout.flush
      stdout.put("Total:",int_width); stdout.tab(real_fields=1); stdout.put(total)
      stdout.flush
      stdout.dash(int_fields=1,real_fields=2)
      stdout.set_real_style("f")
   end

!*******************************************************************************
!                      Thermal parameter fitting
!*******************************************************************************

   force_thermal_symmetry
   ! Impose crystal symmetry on the thermal tensors.
     self :: INOUT
   ENSURE(.crystal.created,"crystal not created")
   ENSURE(.n_atom==.crystal.n_fragment_atoms,"inconsistent crystal fragment")
     n,u,s,n_unique :: INT
     unique_thermals,seitz :: MAT3{REAL}*
     thermal,seitz_inv :: MAT{REAL}(3,3)
     n_equiv :: VEC{INT}*
     n_unique = .crystal.n_unique_frag_atoms
     seitz => .crystal.spacegroup.seitz
     unique_thermals.create(3,3,n_unique)
     unique_thermals = ZERO
     n_equiv.create(n_unique)
     n_equiv = 0
     ! change to crystal coordinates.
     do n=1,.n_atom
       u = .crystal.unique_atom_for_frag_atom(n)
       s = .crystal.unique_symop_for_frag_atom(n)
       seitz_inv.to_inverse_of(transpose(seitz(1:3,1:3,s)))
       thermal = .atom(n).thermal_tensor
       thermal.change_basis_using(.crystal.unit_cell.reciprocal_U_matrix)
       thermal.change_basis_using(seitz_inv)
       unique_thermals(:,:,u) = unique_thermals(:,:,u) + thermal
       n_equiv(u) = n_equiv(u) + 1
     end
     ! Average them.
     do u=1,n_unique
       unique_thermals(:,:,u) = unique_thermals(:,:,u) / n_equiv(u)
     end
     ! change back to cartesians.
     do n=1,.n_atom
       u = .crystal.unique_atom_for_frag_atom(n)
       s = .crystal.unique_symop_for_frag_atom(n)
       thermal = unique_thermals(:,:,u)
       thermal.change_basis_using(transpose(seitz(1:3,1:3,s)))
       thermal.change_basis_using(.crystal.unit_cell.direct_U_matrix)
       .atom(n).thermal_tensor = thermal
     end
     n_equiv.destroy
     unique_thermals.destroy
   end

   fit_thermal_parameters ::: leaky
   ! Fit the thermal parameters to the calculated structure factors.
   ! Uses a line search method.
   ENSURE(.atom.created, "no atoms to fit")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.thermal_smearing_model=="stewart","thermal smearing model must be stewart, so far")
   ENSURE(NOT .crystal.data.optimise_extinction,"cannot optimise extinction while refining thermal parameters")
     dim :: INT
     chi2_min :: REAL
     U :: VEC{REAL}*
     self :: PTR
     dim = .n_atom * 6
     U.create(dim)
     .get_thermal_parameters(U)
 !    .crystal.optimise_extinction = FALSE
 !    .crystal.optimise_scale = FALSE
     .atom.put_thermal_tensors
     saved_self => self
     VEC{REAL}:minimise_BFGS(MOLECULE::sfchi2,MOLECULE::d_sfchi2_d_thermal,U,chi2_min,tol=TOL(7),gtol=TOL(7),step=TOL(4))
     U.destroy
   end

   get_thermal_parameters(U) ::: private
   ! Get a set of thermal parameters from the atoms, assuming
   ! "U" is a vector of the independent thermal parameters.
      U :: VEC{REAL}
   ENSURE(size(U)==6*.n_atom, "wrong size, U")
      n,base :: INT
      do n = 1,.n_atom      ! get thermal parameters into array
        base = (n-1) * 6
        U(base+1) = .atom(n).thermal_tensor(1,1)
        U(base+2) = .atom(n).thermal_tensor(1,2)
        U(base+3) = .atom(n).thermal_tensor(1,3)
        U(base+4) = .atom(n).thermal_tensor(2,2)
        U(base+5) = .atom(n).thermal_tensor(2,3)
        U(base+6) = .atom(n).thermal_tensor(3,3)
      end
   end

   set_thermal_parameters(U) ::: private
   ! Set a new set of thermal parameters for all the atoms, assuming
   ! "U" is a vector of the independent thermal parameters.
      U :: VEC{REAL}
   ENSURE(size(U)==6*.n_atom, "wrong size, U")
      n,base :: INT
      do n = 1,.n_atom      ! get thermal parameters into array
        base = (n-1) * 6
        .atom(n).thermal_tensor(1,1) = U(base+1)
        .atom(n).thermal_tensor(1,2) = U(base+2)
        .atom(n).thermal_tensor(1,3) = U(base+3)
        .atom(n).thermal_tensor(2,2) = U(base+4)
        .atom(n).thermal_tensor(2,3) = U(base+5)
        .atom(n).thermal_tensor(3,3) = U(base+6)
        .atom(n).thermal_tensor(2,1) = .atom(n).thermal_tensor(1,2)
        .atom(n).thermal_tensor(3,1) = .atom(n).thermal_tensor(1,3)
        .atom(n).thermal_tensor(3,2) = .atom(n).thermal_tensor(2,3)
      end
      .force_thermal_symmetry
   end

   sfchi2(U) result(res) ::: leaky, selfless
   ! Evaluate the structure factor chi2.
     U :: VEC{REAL}
     res :: REAL
     self :: MOLECULE*
     self => saved_self
     ENSURE(.crystal.created, "no crystal")
     .set_thermal_parameters(U)
     .make_x_structure_factors
     res = .crystal.F_chi2
     stdout.show("new F_chi2 =",res)
   end

   d_sfchi2_d_thermal(U) result(res) ::: leaky, selfless
   ! Evaluate the gradient of the structure factor chi2 with respect to the
   ! unique thermal parameters.
   ! Size of res is [n_atom * 6].
     U :: VEC{REAL}
     res :: VEC{REAL}(size(U))
     sf_deriv,sf_deriv_eq :: MAT{CPX}*
     k_pts :: MAT{REAL}*
     genre :: STR
     self :: MOLECULE*
     self => saved_self
     ENSURE(.crystal.created, "no crystal")
     ENSURE(.density_matrix.created, "no density matrix")
     .set_thermal_parameters(U)
     k_pts.create(.crystal.n_unique_SF_k_pts,3)
     .crystal.make_unique_SF_k_pts(k_pts)
     sf_deriv.create( .crystal.n_refl, .n_atom * 6) ! d_Fc/d_U
     sf_deriv_eq.create(.n_atom * 6,.crystal.n_unique_SF_k_pts)
     genre = .density_matrix.spinorbital_kind
     if (genre.includes("complex")) then
       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted_complex,k_pts)
     else
       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pts)
     end
     .crystal.sum_unique_sf_deriv_U(sf_deriv,sf_deriv_eq)
     sf_deriv_eq.destroy
     ! Do the derivative with respect to chi2
     res = .crystal.d_chi2_dU(sf_deriv)
     sf_deriv.destroy
     k_pts.destroy
     .put_atom_thermal_tensors
   end

!*******************************************************************************
!                      Atom position fitting
!*******************************************************************************

   get_atom_positions(R) ::: private
   ! Get a set of atom positions "R"
      R :: VEC{REAL}
   ENSURE(R.dim==3*.n_atom, "wrong size, R")
      n,base :: INT
      do n = 1,.n_atom      ! get thermal parameters into array
        base = (n-1) * 3
        R(base+1) = .atom(n).pos(1)
        R(base+2) = .atom(n).pos(2)
        R(base+3) = .atom(n).pos(3)
      end
   end

   set_atom_positions(R) ::: private
   ! Set the atom positions from "R"
      R :: VEC{REAL}
   ENSURE(R.dim==3*.n_atom, "wrong size, R")
      n,base :: INT
      do n = 1,.n_atom      ! get thermal parameters into array
        base = (n-1) * 3
        .atom(n).pos(1) = R(base+1)
        .atom(n).pos(2) = R(base+2)
        .atom(n).pos(3) = R(base+3)
      end
   end

   chi2_pos(R) result(res) ::: leaky, selfless
   ! Evaluate the structure factor chi2 as a function of atom
   ! positions "R"
     R :: VEC{REAL}
     res :: REAL
     self :: MOLECULE*
     self => saved_self
     ENSURE(.crystal.created, "no crystal")
     .set_atom_positions(R)
     .make_x_structure_factors
     res = .crystal.F_chi2
     stdout.show("new F_chi2 =",res)
   end

!   d_chi2_pos(R) result(res) ::: leaky, selfless
!   ! Evaluate the derivative of the structure factor chi2 with respect to the
!   ! atom positions "R".
!     R :: VEC{REAL}
!     res :: VEC{REAL}(size(U))
!     sf_deriv,sf_deriv_eq :: MAT{CPX}*
!     k_pts :: MAT{REAL}*
!     genre :: STR
!     self :: MOLECULE*
!     self => saved_self
!     ENSURE(.crystal.created, "no crystal")
!     ENSURE(.density_matrix.created, "no density matrix")
!     .set_thermal_parameters(U)
!     k_pts.create(.crystal.n_unique_SF_k_pts,3)
!     .crystal.make_unique_SF_k_pts(k_pts)
!     sf_deriv.create( .crystal.n_refl, .n_atom * 6) ! d_Fc/d_U
!     sf_deriv_eq.create(.n_atom * 6,.crystal.n_unique_SF_k_pts)
!     genre = .density_matrix.spinorbital_kind
!     if (genre.includes("complex")) then
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted_complex,k_pts)
!     else
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pts)
!     end
!     .crystal.sum_unique_sf_deriv_U(sf_deriv,sf_deriv_eq)
!     sf_deriv_eq.destroy
!     ! Do the derivative with respect to chi2
!     res = .crystal.d_chi2_dU(sf_deriv)
!     sf_deriv.destroy
!     k_pts.destroy
!   end

!   make_ft(res,dens,k_pts)
!   ! Fourier transform of a density described by AO density matrix dens
!   ! evaluated at a series of reciprocal space points k_pts
!   ! Size of res is [size(k_pts,1)]
!      dens :: MAT{REAL}, target
!      k_pts :: MAT{REAL}, IN
!      res :: VEC{CPX}, OUT
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!      k_max,k,fa,fb,la,lb,q,atom_a,atom_b :: INT
!      sh :: SHELL2
!      ft_ab :: MAT3{CPX}*
!      dens_ba :: MAT{REAL}*
!      cutoff :: REAL
!      k_max = size(k_pts,1)
!      cutoff = TOL(10) / .n_shell_pairs
!      res = ZERO
!      parallel do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!         if (sh.skip_ft(cutoff)) then
!           sh.destroy_ptr_part
!           cycle
!         end
!         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp)
!         .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)
!!         dens_ba => dens(fb:lb,fa:la) ! P^dagger
!         dens_ba => dens(fa:la,fb:lb)
!         if (fa/=fb) then ! count off-diagonals twice.
!           do k = 1,k_max
!!              res(k) = res(k) + TWO*ft_ab(k,:,:).trace_product_with(dens_ba)
!              res(k) = res(k) + TWO*sum(ft_ab(k,:,:)*dens_ba(:,:))
!           end
!         else
!           do k = 1,k_max
!!              res(k) = res(k) + ft_ab(k,:,:).trace_product_with(dens_ba)
!              res(k) = res(k) + sum(ft_ab(k,:,:)*dens_ba(:,:))
!           end
!         end
!         ft_ab.destroy
!         sh.destroy_ptr_part
!      end
!      PARALLEL_SUM(res)
!   end


   zero_off_atom_density
   ! Zero the off-atom overlap blocks of the density matrix
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.restricted.created,"no restricted density")
      .zero_off_atom_blocks(.density_matrix.restricted)
   end

   zero_off_atom_blocks(P)
   ! Zero the off-atom overlap blocks in "P"
      P :: MAT{REAL}
   ENSURE(P.is_square,"wrong shape, P")
   ENSURE(P.dim1==.n_bf,"wrong size, P")
   ENSURE(.atom.created,"no atoms")
      a,b,na,fa,la,nb,fb,lb :: INT
      la = 0
      do a = 1,.n_atom
         na = .atom(a).n_bf
         fa = la + 1
         la = la + na
         lb = 0
         do b = 1,.n_atom
            nb = .atom(b).n_bf
            fb = lb + 1
            lb = lb + nb
            if (a==b) cycle
            P(fa:la,fb:lb) = ZERO
         end
      end
   end

end
