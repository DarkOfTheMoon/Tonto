!------------------------------------------------------------------------------
!
! INTERPOLATOR:
!
! For interpolating values from a 1-D table.
!
! The module takes as input some "data_point"'s with their assigned "values".
! Any data value is then assigned a value by interpolating between the two
! nearest data points.
! 
! The module allows for even-spaced or uneven-spaced data. In the former case
! all the "data_point"'s are not required: only the first data point and the
! "spacing".
!
! Copyright (C) Dylan Jayatilaka, 2002
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!------------------------------------------------------------------------------

module INTERPOLATOR

   implicit none

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   create(spacing,first) ::: leaky
   ! Create the object
     self :: PTR
     spacing :: REAL
     first :: REAL, optional
     .create
     .set_spacing(spacing)
     if (present(first)) .set_table_origin(first)
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(c) ::: leaky
   ! Copy the contents of "c" to self.
     c :: INTERPOLATOR, IN
     self = c
     .nullify_ptr_part
     if (c.data_point.created) &
        .data_point.create_copy(c.data_point)
     if (c.data_value.created) &
        .data_value.create_copy(c.data_value)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts
      nullify(.data_point)
      nullify(.data_value)
      nullify(.y2)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts
      .data_point.destroy
      .data_value.destroy
      .y2.destroy
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   set_defaults(spacing,first)
   ! Set up a defaults
      spacing,first :: REAL, optional
      .set_interpolation_kind(INTERPOLATOR_INTERPOLATION_KIND)
      .table_length  = INTERPOLATOR_TABLE_LENGTH
      .table_origin  = INTERPOLATOR_TABLE_ORIGIN
      .table_spacing = INTERPOLATOR_TABLE_SPACING
      .table_eps     = INTERPOLATOR_TABLE_EPS
      .n_data = 0
      .data_point.destroy
      .data_value.destroy
      .finalised = FALSE
      .y1_initial = INTERPOLATOR_Y1_INITIAL
      .y1_final   = INTERPOLATOR_Y1_FINAL
      .y2_initial = INTERPOLATOR_Y2_INITIAL
      .y2_final   = INTERPOLATOR_Y2_FINAL
      if (present(spacing)) .set_spacing(spacing)
      if (present(first))   .set_table_origin(first)
   end

   set_interpolation_kind(kind)
   ! Set the interpolator table "kind". All the interpolations involve
   ! treatments of the data_values, rather than the data points.
      kind :: STR
      .interpolation_kind = kind
      .interpolation_kind.to_lower_case
      select case (.interpolation_kind)
         case ("linear")                   ! Linear interpolation between data_value's
         case ("cubic_spline")             ! Cubic spline interpolation between data_value's
         case ("logarithmic_linear")       ! Linear interpolation between the log of the data_value's
         case ("logarithmic_cubic_spline") ! Spline interpolation between the log of the data_value's
         case default; UNKNOWN(.interpolation_kind)
      end
      .is_logarithmic = .interpolation_kind(1:11)=="logarithmic"
      .is_spline = .interpolation_kind=="cubic_spline" &
                OR .interpolation_kind=="logarithic_cubic_spline"
   end

   set_spacing(spacing) ::: leaky
   ! Set the "spacing" of an even-spaced interpolator
      spacing :: REAL
   ENSURE(spacing>ZERO,"spacing must be +ve")
      .table_spacing = spacing
   end

   set_table_spacing(spacing) ::: leaky
   ! Set the "spacing" of an even-spaced interpolator table
      spacing :: REAL
   ENSURE(spacing>ZERO,"spacing must be +ve")
      .table_spacing = spacing
   end

   set_table_length(length)
   ! Set the length of the interpolation table to be "length". This is for
   ! constant step size interpolation tables.
      length :: REAL
   ENSURE(length>ZERO,"the length must be positive")
      .table_length = length
   end

   set_table_origin(origin)
   ! Set the "origin" of the interpolation table to be "length" i.e. the first
   ! point. This is for constant step size interpolation tables.
      origin :: REAL
      .table_origin = origin
   end

   set_table_eps(eps)
   ! Set the tolernace on the table such that values smaller than "eps" are
   ! regarded as zero. This may reduce the length of the interpolation table.
      eps :: REAL
   ENSURE(eps>ZERO,"the eps must be positive")
      .table_eps = eps
   end

   is_even_spaced result (res) 
   ! Returns TRUE if the interpolator uses even spaced data points.
   ! NOTE: This does *not* mean the table is finalised.
      res :: BIN
      res = .table_spacing > ZERO AND .table_length>ZERO
   end

   first_data_point result (res) 
   ! Returns the first data point
      res :: REAL
   ENSURE(.finalised,"Not finalised")
   ENSURE(.n_data>0,"No data")
   ENSURE(.data_point.created,"No data")
      res = .data_point(1)
   end

   last_data_point result (res) 
   ! Returns the last data point
      res :: REAL
   ENSURE(.finalised,"Not finalised")
   ENSURE(.n_data>0,"No data")
   ENSURE(.data_point.created,"No data")
      res = .data_point(.n_data)
   end

   last_data_value result (res) 
   ! Returns the last data value
      res :: REAL
   ENSURE(.finalised,"Not finalised")
   ENSURE(.n_data>0,"No data")
   ENSURE(.data_value.created,"No data")
      res = .data_value(.n_data)
   end

!  *************
!  Input methods
!  *************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
         case ("}                  ")  ! exit case
         case ("data_points=       "); .read_data_points
         case ("data_values=       "); .read_data_values
         case ("interpolation_kind="); .read_interpolation_kind
         case ("put                "); .put
         case ("table_spacing=     "); .read_spacing
         case ("table_eps=         "); .read_table_eps
         case ("table_length=      "); .read_table_length
         case ("table_origin=      "); .read_table_origin
         case ("units=             "); INTERPOLATOR::read_units
         case ("y1_initial=        "); .read_y1_initial
         case ("y1_final=          "); .read_y1_final
         case ("y2_initial=        "); .read_y2_initial
         case ("y2_final=          "); .read_y2_final
         case default;         UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_interpolation_kind
   ! Read the kind of interpolation to use.
      kind :: STR
      stdin.read(kind)
      .set_interpolation_kind(kind)
   end

   read_table_length
   ! Read the length of the interpolation table to use. This is for constant
   ! step size interpolation tables.
      length :: REAL
      stdin.read(length)
      .set_table_length(length)
   end

   read_table_origin
   ! Read the table origin i.e. where the data points begin. This is used for
   ! constant step width interpolation.
      stdin.read(.table_origin)
   end

   read_table_eps
   ! Read the table eps value. Values smaller than this in the interpolation
   ! table are set to zero. This may reduce the size of the table.
      eps :: REAL
      stdin.read(eps)
      .set_table_eps(eps)
   end

   read_data_points ::: leaky
   ! Read in the data points.
      stdin.read_ptr(.data_point)
      ENSURE(NOT .is_even_spaced,"you already set spacing and table_length, for even spaced interpolation")
   end

   read_data_values ::: leaky
   ! Read in the data values.
      stdin.read_ptr(.data_point)
   end

   read_spacing ::: leaky
   ! Read in the spacing
   ENSURE(.data_point.destroyed OR .data_point.dim==1,"can't have more than one data point")
      spacing :: REAL
      stdin.read(spacing)
      .set_spacing(spacing)
   end

   read_y1_initial
   ! Read the initial first derivative for cubic spline interpolation
      stdin.read(.y1_initial)
   end

   read_y1_final
   ! Read the final first derivative for cubic spline interpolation
      stdin.read(.y1_final)
   end

   read_y2_initial
   ! Read the initial second derivative for cubic spline interpolation
      stdin.read(.y2_initial)
   end

   read_y2_final
   ! Read the final second derivative for cubic spline interpolation
      stdin.read(.y2_final)
   end

   finalise ::: leaky
   ! Check everything is OK after reading data. 
   ENSURE(.data_point.created," no data_point's")
   ENSURE(.data_value.created," no data_value's")
      order :: VEC{INT}*
      if (.is_even_spaced) then
         .set_even_spaced_data_points
         ! This can't be finalised until the data_values are specified
         ! Use one of the routines below which take a function "func".
         .finalised = FALSE
      else
         ENSURE(.data_point.dim==.data_value.dim,"inconsistent data/value lengths")
         ENSURE(.data_point.dim>2,"not enough data_point's")
         .n_data = .data_point.dim
         order.create(.n_data)
         ! Re-order from smallest to largest
         .data_point.quick_sort(order)
         .data_point = .data_point(order)
         .data_value = .data_value(order)
         order.destroy
         if (.is_spline) .set_spline_2nd_derivatives
         .finalised = TRUE
      end
   end

   set_even_spaced_data_points ::: leaky
   ! Set the ".data_point" to be even-spaced. In this routine .n_data must not
   ! have been set, nor ".data_values". Instead .n_data is worked out from the
   ! "first" data value, the "spacing", and the "length" of the interpolation
   ! region.
   ENSURE(.n_data==0,"there is already data")
   ENSURE(.data_point.destroyed,"there are already data_points")
   ENSURE(.data_value.destroyed,"there are already data_values")
   ENSURE(.table_spacing>ZERO,"spacing must be +ve")
   ENSURE(.table_length>ZERO,"table_length must be +ve")
      i :: INT
      p :: REAL
      .n_data = floor(.table_length/.table_spacing) + 1
      p = .table_origin
      .data_point.create(.n_data)
      do i = 1,.n_data
         .data_point(i) = p
         p = p + .table_spacing
      end
   end

   set_even_spaced_data(func,tol,length) ::: leaky
   ! Set ".data_point" to be even-spaced, starting from
   ! ".table_origin", with a given ".table_spacing", and with
   ! ".data_value" to be the corresponding values evaluated using
   ! monotonically decreasing function "func". The number of data
   ! values and the ".table_length" is either worked out from where
   ! function "func" is just smaller than "tol", with maximum length
   ! ".table_length"; or from the supplied "length".
      tol,length :: REAL, optional
      interface
         func(point) result (value)
            point :: REAL
            value :: REAL
         end
      end

   ENSURE(NOT (present(tol) AND present(length)),"can't supply both tol and length")

      if (present(tol)) then
         .set_even_spaced_data(.table_origin,.table_spacing,.table_length,func,tol)
      else if (present(length)) then
         .set_even_spaced_data(.table_origin,.table_spacing,length,func)
      else
         .set_even_spaced_data(.table_origin,.table_spacing,.table_length,func,.table_eps)
      end

   end

   set_even_spaced_data(first,spacing,length,func,tol) ::: leaky
   ! Set ".data_point" to be even-spaced, starting from the "first" value, with
   ! a given "spacing", extending until "length", and with ".data_value"
   ! to be the corresponding values evaluated using monotonically decreasing
   ! function "func". The number of data values is worked out from where
   ! function "func" is only just smaller than "tol". 
      spacing,first,length,tol :: REAL
      interface
         func(point) result (value)
            point :: REAL
            value :: REAL
         end
      end

   ENSURE(.n_data==0,"there is already data")
   ENSURE(.data_value.destroyed,"there are already data_values")
   ENSURE(.data_point.destroyed,"there are already data_points")
   ENSURE(spacing>ZERO,"spacing must be +ve")

      max_data :: INT
      i,s,n :: INT
      p,val :: REAL

      .table_spacing = spacing

      max_data = ceiling((length-first)/spacing) + 1
      .data_point.create(max_data)
      .data_value.create(max_data)

    ! ENSURE(func(first)>tol_max,"tol_max initially too small")
    ! ! Find first data_point
    ! p = first 
    ! do i = 1,max_data
    !    val = func(p)
    !    if (val<tol_max) exit
    !    p = p + spacing
    ! end
    ! ENSURE(val<tol_max,"tol_max finally too small")
    ! ! Find last data_point
    ! .data_point(1) = p - spacing
    ! .data_value(1) = val
    ! s = i
    ! n = 2

      p = first 
      s = 0
      n = 1
      do i = s+1,max_data
         val = func(p)
         .data_point(n) = p
         .data_value(n) = val
         if (val<tol) exit
         p = p + spacing
         n = n + 1
      end

      if (val>=tol) then
         WARN("data table not large enough")
         stdout.save
         stdout.set_real_style("e")
         stdout.set_real_width(16)
         stdout.set_real_precision(8)
         stdout.show("Smallest value in table =",val)
         stdout.show("Requested epsilon       =",tol)
         stdout.unsave
      end

      .n_data = n
      .data_value.shrink(.n_data)
      .data_point.shrink(.n_data)
      .table_length = .data_point(.n_data) ! reset the table length

      if (.is_logarithmic) then
         DIE_IF(any(.data_value<=ZERO),"-ve data_values cant be used with log interpolation")
         .data_value = log(.data_value)
      end

      if (.is_spline) .set_spline_2nd_derivatives

      .finalised = TRUE

   end

   set_even_spaced_data(first,spacing,length,func) ::: leaky
   ! Set ".data_point" to be even-spaced, starting from the "first" value, with
   ! a given "spacing", extending for a total "length", and with ".data_value"
   ! to be the corresponding values evaluated using function "func". 
      spacing,first,length :: REAL
      interface
         func(point) result (value)
            point :: REAL
            value :: REAL
         end
      end

   ENSURE(.n_data==0,"there is already data")
   ENSURE(.data_value.destroyed,"there are already data_values")
   ENSURE(.data_point.destroyed,"there are already data_points")
   ENSURE(spacing>ZERO,"spacing must be +ve")

      max_data :: INT
      i,s,n :: INT
      p,val :: REAL

      .table_spacing = spacing

      max_data = ceiling((length-first)/spacing) + 1
      .data_point.create(max_data)
      .data_value.create(max_data)
      p = first 
      s = 0
      n = 1
      do i = s+1,max_data
         val = func(p)
         .data_point(n) = p
         .data_value(n) = val
         p = p + spacing
         n = n + 1
      end

      .n_data = n
      .data_value.shrink(.n_data)
      .data_point.shrink(.n_data)
      .table_length = .data_point(.n_data) ! reset the table length

      if (.is_logarithmic) then
         DIE_IF(any(.data_value<=ZERO),"-ve data_values cant be used with log interpolation")
         .data_value = log(.data_value)
      end

      if (.is_spline) .set_spline_2nd_derivatives

      .finalised = TRUE

   end

   the_table_length(func,tol) result (p)
   ! Return the length of the interpolation table starting from ".table_origin"
   ! with a given ".table_spacing", extending for a total ".table_length", and
   ! with the data values to be the corresponding values evaluated using
   ! monotonically decreasing function "func". The length of the table "p" is
   ! worked out from where function "func" is only just smaller than "tol". 
   ! It cannot exceed ".table_length".
      tol,p :: REAL
      interface
         func(point) result (value)
            point :: REAL
            value :: REAL
         end
      end
   ENSURE(.n_data==0,"there is already data")
   ENSURE(.table_spacing>ZERO,"spacing must be +ve")
      first,spacing,length :: REAL
      max_data :: INT
      i,s :: INT
      val :: REAL
      first = .table_origin
      length = .table_length
      spacing = .table_spacing
      max_data = ceiling((length-first)/spacing) + 1
      p = first
      s = 0
      do i = s+1,max_data
         val = func(p)
         if (val<tol) exit
         p = p + spacing
      end
   end

   set_even_spaced_d_data(func) ::: leaky
   ! Set ".data_point" to be even-spaced, starting from the "first" value, with
   ! a given "spacing", extending for a total "length", and with ".data_value"
   ! to be the corresponding DERIVATIVE values evaluated using monotonically
   ! decreasing function "func". The number of data values is worked out from
   ! where function "func" is greater than "tol". 
      interface
         func(point) result (value)
            point :: REAL
            value :: REAL
         end
      end
      .set_even_spaced_d_data(.table_origin,.table_spacing,.table_length,func,.table_eps)
   end

   set_even_spaced_d_data(first,spacing,length,func,tol) ::: leaky
   ! Set ".data_point" to be even-spaced, starting from the "first" value, with
   ! a given "spacing", extending for a total "length", and with ".data_value"
   ! to be the corresponding DERIVATIVE values evaluated using monotonically
   ! decreasing function "func". The number of data values is worked out from
   ! where function "func" is only just smaller than "tol". 
      spacing,first,length,tol :: REAL
      interface
         func(point) result (value)
            point :: REAL
            value :: REAL
         end
      end
   ENSURE(.n_data==0,"there is already data")
   ENSURE(.data_value.destroyed,"there are already data_values")
   ENSURE(.data_point.destroyed,"there are already data_points")
   ENSURE(spacing>ZERO,"spacing must be +ve")
      max_data :: INT
      i,s,n :: INT
      p,del,val0,valp,valm :: REAL
      .table_spacing = spacing
      max_data = ceiling((length-first)/spacing) + 1
      .data_point.create(max_data)
      .data_value.create(max_data)
    ! ENSURE(func(first)>tol_max,"tol_max initially too small")
    ! ! Find first data_point
    ! p = first 
    ! do i = 1,max_data
    !    val = func(p)
    !    if (val<tol_max) exit
    !    p = p + spacing
    ! end
    ! ENSURE(val<tol_max,"tol_max finally too small")
    ! ! Find last data_point
    ! .data_point(1) = p - spacing
    ! .data_value(1) = val
    ! s = i
    ! n = 2
      del = TOL(6)
      p = first 
      s = 0
      n = 1
      do i = s+1,max_data
         valp = func(p+del)
         val0 = func(p)
         valm = func(p-del)
         .data_point(n) = p
         .data_value(n) = (valp-valm)/(TWO*del)
         p = p + spacing
         n = n + 1
         if (val0<tol) exit
      end
    ! if (val>=tol) then
    !    WARN("data table not large enough")
    !    stdout.save
    !    stdout.set_real_style("e")
    !    stdout.set_real_width(16)
    !    stdout.set_real_precision(8)
    !    stdout.show("Smallest value in table =",val)
    !    stdout.show("Requested epsilon       =",tol)
    !    stdout.unsave
    ! end
      .n_data = n-1
      .data_value.shrink(.n_data)
      .data_point.shrink(.n_data)
      .table_length = .data_point(.n_data) ! reset the table length
      if (.is_logarithmic) then
         DIE_IF(any(.data_value<=ZERO),"-ve data_values cant be used with log interpolation")
         .data_value = log(-.data_value)
      end
      if (.is_spline) .set_spline_2nd_derivatives
      .finalised = TRUE
   end

   set_even_spaced_d2_data(func) ::: leaky
   ! Set ".data_point" to be even-spaced, starting from the "first" value, with
   ! a given "spacing", extending for a total "length", and with ".data_value"
   ! to be the corresponding 2nd DERIVATIVE values evaluated using monotonically
   ! decreasing function "func". The number of data values is worked out from
   ! where function "func" is greater than "tol". 
      interface
         func(point) result (value)
            point :: REAL
            value :: REAL
         end
      end
      .set_even_spaced_d2_data(.table_origin,.table_spacing,.table_length,func,.table_eps)
   end

   set_even_spaced_d2_data(first,spacing,length,func,tol) ::: leaky
   ! Set ".data_point" to be even-spaced, starting from the "first" value, with
   ! a given "spacing", extending for a total "length", and with ".data_value"
   ! to be the corresponding 2nd DERIVATIVE values evaluated using monotonically
   ! decreasing function "func". The number of data values is worked out from
   ! where function "func" is only just smaller than "tol". 
      spacing,first,length,tol :: REAL
      interface
         func(point) result (value)
            point :: REAL
            value :: REAL
         end
      end
   ENSURE(.n_data==0,"there is already data")
   ENSURE(.data_value.destroyed,"there are already data_values")
   ENSURE(.data_point.destroyed,"there are already data_points")
   ENSURE(spacing>ZERO,"spacing must be +ve")
      max_data :: INT
      i,s,n :: INT
      p,del,del2,val0,valp,valm :: REAL
      .table_spacing = spacing
      max_data = ceiling((length-first)/spacing) + 1
      .data_point.create(max_data)
      .data_value.create(max_data)
    ! ENSURE(func(first)>tol_max,"tol_max initially too small")
    ! ! Find first data_point
    ! p = first 
    ! do i = 1,max_data
    !    val = func(p)
    !    if (val<tol_max) exit
    !    p = p + spacing
    ! end
    ! ENSURE(val<tol_max,"tol_max finally too small")
    ! ! Find last data_point
    ! .data_point(1) = p - spacing
    ! .data_value(1) = val
    ! s = i
    ! n = 2
      del = TOL(6)
      del2 = del*del
      p = first 
      s = 0
      n = 1
      do i = s+1,max_data
         valp = func(p+del)
         val0 = func(p)
         valm = func(p-del)
         .data_point(n) = p
         .data_value(n) = (valp+valm-TWO*val0)/del2
         p = p + spacing
         n = n + 1
         if (val0<tol) exit
      end
    ! if (val>=tol) then
    !    WARN("data table not large enough")
    !    stdout.save
    !    stdout.set_real_style("e")
    !    stdout.set_real_width(16)
    !    stdout.set_real_precision(8)
    !    stdout.show("Smallest value in table =",val)
    !    stdout.show("Requested epsilon       =",tol)
    !    stdout.unsave
    ! end
      .n_data = n-1
      .data_value.shrink(.n_data)
      .data_point.shrink(.n_data)
      .table_length = .data_point(.n_data) ! reset the table length
      if (.is_logarithmic) then
         DIE_IF(any(.data_value<=ZERO),"-ve data_values cant be used with log interpolation")
         .data_value = log(.data_value)
      end
      if (.is_spline) .set_spline_2nd_derivatives
      .finalised = TRUE
   end

!  ************
!  Set routines
!  ************

   set_data_points(points) ::: leaky
   ! Set the data "points". NOTE: Make sure that .finalise is called after all
   ! set routines.
      points :: VEC{REAL}
      .data_point.destroy
      .data_point.create_copy(points)
   end

   set_data_values(values) ::: leaky
   ! Set the data "values". NOTE: Make sure that .finalise is called after all
   ! set routines.
      values :: VEC{REAL}
      .data_value.destroy
      .data_value.create_copy(values)
   end

!  *****************
!  Values for points
!  *****************

   value_for(point) result (res)
   ! Return the interpolated value for "point".
      self :: IN
      point :: REAL, IN
      res :: REAL
   ENSURE(.finalised,"not finalised")
      del,frac :: REAL
      f,i1,i2 :: INT
      is_log :: BIN
      is_log = .is_logarithmic
      if (.is_even_spaced) then ! This is more efficient than below
         frac = (point - .data_point(1))/.table_spacing
         f  = floor(frac)
         i1 = f + 1
         i2 = i1 + 1
         if (frac>f) then ! point is between data_point's
           if (1<=i1 AND i2<=.n_data) then
              del = .data_value(i2) - .data_value(i1)
              res = .data_value(i1) + (frac-f)*del
              if (is_log) res = exp(res)
           else
              res = ZERO
           end
         else              ! point is exactly equal to a data_point
           if (1<=i1 AND i1<=.n_data) then
              res  = .data_value(i1)
              if (is_log) res = exp(res)
           else
              res = ZERO
           end
         end
      else
         if (point.is_in_range(.data_point.range)) then
            i1 = count(.data_point<=point) ! assuming .data is ordered !
            i1 = min(i1,.n_data-1)
            i2 = i1 + 1
            frac = (point - .data_point(i1))/(.data_point(i2)-.data_point(i1))
            del  = .data_value(i2) - .data_value(i1)
            res  = .data_value(i1) + frac*del
            if (is_log) res = exp(res)
         else
            res = ZERO 
         end
      end
   end

   values_for(points) result(values)
   ! Return the interpolated "values" for a series of "points".
      self :: IN
      points :: VEC{REAL}, IN
      values :: VEC{REAL}(points.dim)
   ENSURE(.finalised,"not finalised")
      point,del,frac,res :: REAL
      i,f,i1,i2 :: INT
      is_log :: BIN
      is_log = .is_logarithmic
      if (.is_even_spaced) then ! This is more efficient than below
        do i = 1,points.dim
          point = points(i)
          frac = (point - .data_point(1))/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          if (frac>f) then ! point lies betwen spacing
            if (1<=i1 AND i2<=.n_data) then
              del = .data_value(i2) - .data_value(i1)
              res = .data_value(i1) + (frac-f)*del
              if (is_log) res = exp(res)
              values(i) = res
            else
              values(i) = ZERO
            end
          else             ! point is exactly equal to a data_point
            if (1<=i1 AND i1<=.n_data) then
              res  = .data_value(i1)
              if (is_log) res = exp(res)
              values(i) = res
            else
              values(i) = ZERO
            end
          end
        end
      else
        do i = 1,points.dim
          point = points(i)
          if (point.is_in_range(.data_point.range)) then
            i1 = count(.data_point<=point) ! assuming .data is ordered !
            i1 = min(i1,.n_data-1)
            i2 = i1 + 1
            frac = (point - .data_point(i1))/(.data_point(i2)-.data_point(i1))
            del  = .data_value(i2) - .data_value(i1)
            res  = .data_value(i1) + frac*del
            if (is_log) res = exp(res)
            values(i) = res
          else
            values(i) = ZERO
          end
        end
      end
   end

   add_values_for(points,values)
   ! Add in the interpolated "values" for a series of "points" in the special
   ! case where the table_origin is ZERO and where the data is known to be even
   ! spaced. The finalisation tests and other preconditions are skipped in the
   ! interests of speed.
      self :: IN
      points :: VEC{REAL}, IN
      values :: VEC{REAL}, OUT

   ! ENSURE(.finalised,"not finalised")
   ! ENSURE(.is_even_spaced,"not even spaced")
   ! ENSURE(.table_origin.is_zero,"table_origin is not zero")
   ! ENSURE(all(points)>ZERO,"the points are not all +ve")

      del,frac,res,last :: REAL
      i,f,i1,i2 :: INT

      last =.data_point(.n_data)

      if (.is_logarithmic) then
        do i = 1,points.dim
          if (points(i)>=last) cycle
          frac = points(i)/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = .data_value(i1) + (frac-f)*del
          else             ! point is exactly equal to a data_point
            res  = .data_value(i1)
          end
          values(i) = values(i) + exp(res)
        end
      else
        do i = 1,points.dim
          if (points(i)>=last) cycle
          frac = points(i)/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          res  = .data_value(i1)
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = res + (frac-f)*del
          end
          values(i) = values(i) + res
        end
      end
   end

   add_values_for_squared(points,values)
   ! Add in the interpolated "values" for a series of "points" which are squared
   ! (i.e. we must square root to get the actual point) in the special
   ! case where the table_origin is ZERO and where the data is known to be even
   ! spaced. The finalisation tests and other preconditions are skipped in the
   ! interests of speed.
      self :: IN
      points :: VEC{REAL}, IN
      values :: VEC{REAL}, OUT

   ! ENSURE(.finalised,"not finalised")
   ! ENSURE(.is_even_spaced,"not even spaced")
   ! ENSURE(.table_origin.is_zero,"table_origin is not zero")
   ! ENSURE(all(points)>ZERO,"the points are not all +ve")

      del,frac,res,last,val :: REAL
      i,f,i1,i2 :: INT

      last =.data_point(.n_data)
      last = last*last

      if (.is_logarithmic) then
        do i = 1,points.dim
          if (points(i)>=last) cycle
          val = sqrt(points(i))
          frac = val/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = .data_value(i1) + (frac-f)*del
          else             ! point is exactly equal to a data_point
            res  = .data_value(i1)
          end
          values(i) = values(i) + exp(res)
        end
      else
        do i = 1,points.dim
          if (points(i)>=last) cycle
          val = sqrt(points(i))
          frac = val/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          res  = .data_value(i1)
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = res + (frac-f)*del
          end
          values(i) = values(i) + res
        end
      end
   end

! This is an old version of the routine above

   fast_values_for(points) result(values)
   ! Return the interpolated "values" for a series of "points" in the special
   ! case where the table_origin is ZERO and where the data is known to be even
   ! spaced. The finalisation tests and other precoditions are skipped in the
   ! interests of speed.
      self :: IN
      points :: VEC{REAL}, IN
      values :: VEC{REAL}(points.dim)
   ! ENSURE(.finalised,"not finalised")
   ! ENSURE(.is_even_spaced,"not even spaced")
   ! ENSURE(.table_origin.is_zero,"table_origin is not zero")
   ! ENSURE(all(points)>ZERO,"the points are not all +ve")
      del,frac,res,last :: REAL
      i,n,f,i1,i2 :: INT
      is_log :: BIN
      n = 0
      last =.data_point(.n_data)
      do i = 1,points.dim       ! set points off the end of the table
        if (points(i)<last) cycle
        values(i) = ZERO
        n = n + 1
      end
      if (n==points.dim) return ! all points too far away
      is_log = .is_logarithmic
      if (is_log) then
        do i = 1,points.dim
          if (points(i)>=last) cycle
          frac = points(i)/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = .data_value(i1) + (frac-f)*del
          else             ! point is exactly equal to a data_point
            res  = .data_value(i1)
          end
          values(i) = exp(res)
        end
      else
        do i = 1,points.dim
          if (points(i)>=last) cycle
          frac = points(i)/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          res  = .data_value(i1)
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = res + (frac-f)*del
          end
          values(i) = res
       end
     end
   end

   fast_values_for_squared(points) result(values)
   ! Return the interpolated "values" for a series of "points" which are squared
   ! (i.e. we must square root to get the actual point) in the special
   ! case where the table_origin is ZERO and where the data is known to be even
   ! spaced. The finalisation tests and other precoditions are skipped in the
   ! interests of speed.
      self :: IN
      points :: VEC{REAL}, IN
      values :: VEC{REAL}(points.dim)
   ! ENSURE(.finalised,"not finalised")
   ! ENSURE(.is_even_spaced,"not even spaced")
   ! ENSURE(.table_origin.is_zero,"table_origin is not zero")
   ! ENSURE(all(points)>ZERO,"the points are not all +ve")
      del,frac,res,last,val :: REAL
      i,n,f,i1,i2 :: INT
      is_log :: BIN
      n = 0
      last =.data_point(.n_data)
      last = last*last
      do i = 1,points.dim       ! set points off the end of the table
        if (points(i)<last) cycle
        values(i) = ZERO
        n = n + 1
      end
      if (n==points.dim) return ! all points too far away
      is_log = .is_logarithmic
      if (is_log) then
        do i = 1,points.dim
          if (points(i)>=last) cycle
          val = sqrt(points(i))
          frac = val/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = .data_value(i1) + (frac-f)*del
          else             ! point is exactly equal to a data_point
            res  = .data_value(i1)
          end
          values(i) = exp(res)
        end
      else
        do i = 1,points.dim
          if (points(i)>=last) cycle
          val = sqrt(points(i))
          frac = val/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          res  = .data_value(i1)
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = res + (frac-f)*del
          end
          values(i) = res
       end
     end
   end

   fast_d_values_for(points) result(values)
   ! Return the interpolated "values" for a series of "points" in the special
   ! case where the table_origin is ZERO and where the data is known to be even
   ! spaced. The finalisation tests and other preconditions are skipped in the
   ! interests of speed. This version is for radial DERIVATIVES, and has a minus
   ! sign when the log interpolation is used.
      self :: IN
      points :: VEC{REAL}, IN
      values :: VEC{REAL}(points.dim)
   ! ENSURE(.finalised,"not finalised")
   ! ENSURE(.is_even_spaced,"not even spaced")
   ! ENSURE(.table_origin.is_zero,"table_origin is not zero")
   ! ENSURE(all(points)>ZERO,"the points are not all +ve")
      del,frac,res,last :: REAL
      i,n,f,i1,i2 :: INT
      is_log :: BIN
      n = 0
      last =.data_point(.n_data)
      do i = 1,points.dim       ! set points off the end of the table
        if (points(i)<last) cycle
        values(i) = ZERO
        n = n + 1
      end
      if (n==points.dim) return ! all points too far away
      is_log = .is_logarithmic
      if (is_log) then
        do i = 1,points.dim
          if (points(i)>=last) cycle
          frac = points(i)/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = .data_value(i1) + (frac-f)*del
          else             ! point is exactly equal to a data_point
            res  = .data_value(i1)
          end
          values(i) = -exp(res)
        end
      else
        do i = 1,points.dim
          if (points(i)>=last) cycle
          frac = points(i)/.table_spacing
          f  = floor(frac)
          i1 = f + 1
          i2 = i1 + 1
          if (frac>f) then ! point lies between spacing
            del = .data_value(i2) - .data_value(i1)
            res = .data_value(i1) + (frac-f)*del
          else             ! point is exactly equal to a data_point
            res  = .data_value(i1)
          end
          values(i) = res
       end
     end
   end

   skip_values_for(points) result (res)
   ! Return TRUE if the interpolated "values" for a series of "points" are all
   ! zero, so that we can skip their evaluation.
      self :: IN
      points :: VEC{REAL}, IN
      res :: BIN
   ! ENSURE(.finalised,"not finalised")
   ! ENSURE(.is_even_spaced,"not even spaced")
   ! ENSURE(.table_origin.is_zero,"table_origin is not zero")
   ! ENSURE(all(points)>ZERO,"the points are not all +ve")
      i,n :: INT
      last :: REAL
      n = 0
      last =.data_point(.n_data)
      do i = 1,points.dim       ! set points off the end of the table
        if (points(i)<last) cycle
        n = n + 1
      end
      res = n==points.dim
   end

   set_data_values(func) ::: leaky
   ! Set the ".data_values" from the function "func", which returns "values"
   ! from a set of given "points".
      interface
         func(points,values)
            points :: VEC{REAL}
            values :: VEC{REAL}
         end
      end
   ENSURE(.finalised,"not finalised")
   ENSURE(.data_point.created,"no data_points")
   ENSURE(.data_point.dim==.n_data,"wrong number of data_points")
   WARN_IF(.data_value.created,"data_values will be lost")
      .data_value.destroy
      .data_value.create(.n_data)
      call func(.data_point,.data_value)
   end

   set_data_values(func_at,pos) ::: leaky
   ! Set the ".data_values" from the function "func_at", which returns "values"
   ! from a set of given "points", and an additional single "pos" as parameter.
      interface
         func_at(points,pos,values)
            points,values :: VEC{REAL}
            pos :: VEC{REAL}(3)
         end
      end
      pos :: VEC{REAL}(3)
   ENSURE(.finalised,"not finalised")
   ENSURE(.data_point.created,"no data_points")
   ENSURE(.data_point.dim==.n_data,"wrong number of data_points")
   WARN_IF(.data_value.created,"data_values will be lost")
      .data_value.destroy
      .data_value.create(.n_data)
      call func_at(.data_point,pos,.data_value)
   end

   spline_value_for(point) result (res)
   ! Return the spline interpolated value for "point".
      self :: IN
      point :: REAL, IN
      res :: REAL
   ENSURE(.finalised,"not finalised")
      frac,del,dl6,v1,v2,a,b :: REAL
      f,i1,i2 :: INT
      is_log :: BIN
      is_log = .is_logarithmic
      frac = (point - .data_point(1))/.table_spacing
      f  = floor(frac)
      if (.is_even_spaced) then ! This is more efficient than below
         i1 = f + 1
         i2 = i1 + 1
         if (frac>f) then ! point lies between spacings
           if (1<=i1 AND i2<=.n_data) then
              v1  = .data_value(i1)
              v2  = .data_value(i2)
              del = v2 - v1
              dl6 = del*del/SIX
              b = frac - f
              a = ONE - b
              res = a*v1 + b*v2 +(a*(a*a-1)*.y2(i1) + b*(b*b-1)*.y2(i2))*dl6
              if (is_log) res = exp(res)
           else
              res = ZERO
           end
         else              ! point is exactly on a data_point
           if (1<=i1 AND i1<=.n_data) then
              res  = .data_value(i1)
              if (is_log) res = exp(res)
           else
              res = ZERO
           end
         end
      else
         if (point.is_in_range(.data_point.range)) then
            i1 = count(.data_point<=point) ! assuming .data is ordered !
            i1 = min(i1,.n_data-1)
            i2 = i1 + 1
            v1 = .data_value(i1)
            v2 = .data_value(i2)
            del = v2 - v1
            dl6 = del*del/SIX
            b = frac - f
            a = ONE - b
            res = a*v1 + b*v2 +(a*(a*a-1)*.y2(i1) + b*(b*b-1)*.y2(i2))*dl6
            if (is_log) res = exp(res)
         else
            res = ZERO 
         end
      end
   end

   set_spline_2nd_derivatives ::: leaky
   ! Set .y2, the second derivatives of the interpolating function at the
   ! tabulated .data_points's. The values of the second derivatives at
   ! the endpoints are normally zero. The values of the first derivative are
   ! normally taken to be the finite difference of the first two or last two
   ! points.
   ENSURE(.data_point.created,"no data points")
   ENSURE(.data_value.created,"no data values")
   ENSURE(.n_data>=3,"must have at least 3 data points")
      dx,dxp,dxm,dy,dyp,dym,sig,p :: REAL
      n,i,ip1,im1 :: INT
      x,y,u :: VEC{REAL}*
      n = .n_data
      .y2.destroy
      .y2.create(n)
      x => .data_point
      y => .data_value
      u.create(n)
      dx = x(2) - x(1)
      dy = y(2) - y(1)
      .y2(1) = .y2_initial
      if (.y1_initial_set) then; u(1) = (THREE/dx)*(dy/dx - .y1_initial)
      else;                      u(1) = ZERO
      end
      do i = 2,n-1
         ip1 = i + 1
         im1 = i - 1
         dxp = x(ip1) - x(i)
         dxm = x(i)   - x(im1)
         dyp = y(ip1) - y(i)
         dym = y(i)   - y(im1)
         dx  = x(ip1) - x(im1)
         sig = dxm/dx
         p = sig*.y2(im1) + TWO
         .y2(i) = (sig-ONE)/p
         u(i) = (SIX*(dyp/dxp - dym/dxm)/dx - sig*u(im1))/p
      end
      dy = y(n) - y(n-1)
      dx = x(n) - x(n-1)
      if (.y1_final_set) then; u(n) = (THREE/dx)*(.y1_final - dy/dx)
      else;                    u(n) = ZERO
      end
      .y2(n) = (u(n) - .y2_final*u(n-1))/(.y2_final*.y2(n-1)+ONE)
      ! Back substitution of the triadiagonal algorithm
      do i = n-1,1,-1
         .y2(i) = .y2(i)*.y2(i+1) + u(i)
      end
      u.destroy
   end

   y1_initial_set result (res)
   ! Return TRUE if the first derivative at the start, .y1_initial, has been set
   ! by the user
      res :: BIN
      res = .y1_initial /= INTERPOLATOR_Y1_INITIAL
   end

   y1_final_set result (res)
   ! Return TRUE if the first derivative at the endpoint, .y1_final, has been
   ! set by the user
      res :: BIN
      res = .y1_final /= INTERPOLATOR_Y1_FINAL
   end

!  **************
!  Output methods
!  **************

   put
   ! Put the list of interpolating colours.
   ENSURE(.finalised,"not finalised")
      i :: INT
      stdout.flush
      stdout.text("INTERPOLATOR info")
      stdout.flush
      stdout.show("No. of interpolating data points =",.n_data)
      stdout.show("Using even spaced data points?   =",.is_even_spaced)
      stdout.flush
      if (.is_even_spaced) then
         stdout.show("Initial data value               =",.table_origin)
         stdout.show("Last data value                  =",.data_point(.n_data))
         stdout.show("Table length                     =",.table_length)
         stdout.show("Data point spacing               =",.table_spacing)
         stdout.flush
         stdout.dash(int_fields=1,real_fields=1)
         stdout.put("#",int_width=TRUE)
         stdout.put("Value")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=1)
         do i = 1,.n_data
            stdout.put(i)
            stdout.put(.data_value(i))
            stdout.flush
         end
         stdout.dash(int_fields=1,real_fields=1)
      else
         stdout.dash(int_fields=1,real_fields=1)
         stdout.put("#",int_width=TRUE)
         stdout.put("Point")
         stdout.put("Value")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=2)
         do i = 1,.n_data
            stdout.put(i)
            stdout.put(.data_point(i))
            stdout.put(.data_value(i))
            stdout.flush
         end
         stdout.dash(int_fields=1,real_fields=2)
      end
   end

end
