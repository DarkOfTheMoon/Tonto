!-------------------------------------------------------------------------------
!
! MOLECULE: An object representation of a molecule.
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.main.foo 2881 2006-06-27 11:15:21Z dylan_ $
!-------------------------------------------------------------------------------


module MOLECULE.MAIN

   implicit none

   saved_self :: MOLECULE*, private
   saved_sf_n :: MAT{CPX}*, private
   saved_arch :: TEXTFILE*, private
   X_old :: VEC{REAL}*, private  DEFAULT_NULL

contains

! ****************
! Crystal Explorer
! ****************

   read_CIF ::: leaky
   ! Read in CIF information, reset name of Job to cif file name
      self :: PTR
      head :: STR
      if (.cif.destroyed) .cif.create
      .cif.read_keywords
      if (.cif.file_name/=" " AND .cif.data_block_name/=" ") then
         head = .cif.file_name.filename_head
         ! Set name to the crystal data name
         .name = head.trim // "_" // .cif.data_block_name
         WARN("Job name has now been set to: "//.name.trim)
      end
   end

   read_CX_file_name 
   ! Read the CX file name
      stdin.read(.CX_file_name)
   end

   read_CX_uses_angstrom 
   ! Read whether CX should use angstroms
      stdin.read(.CX_uses_angstrom)
   end

!   read_CIF_file_name 
!   ! Read the CIF file name
!      file :: TEXTFILE
!      WARN_IF(.CIF_file_name/=" ","a CIF file name already exists")
!      WARN_IF(.CIF_data_block_name/=" ","a CIF data block name already exists")
!      stdin.read(.CIF_file_name)
!      ENSURE(file.exists(name=.CIF_file_name),"no CIF file exists named: "//.CIF_file_name.trim)
!   end

!   read_CIF_data_block_name 
!   ! Read the CIF data block name, set the job name to be this block name.
!   ENSURE(.CIF_file_name/=" ","specify CIF file name first")
!      head :: STR
!      stdin.read(.CIF_data_block_name)
!      head = .CIF_file_name.filename_head
!      ! Set name to the crystal data name
!      .name = head.trim // "_" // .CIF_data_block_name
!      WARN("Job name has now been set to: "//.name.trim)
!   end

   process_CIF ::: leaky
   ! Process a CIF file, and try to read crystal and atom information, either
   ! from the current ".cif.data_block_name", or from the first data block in
   ! the CIF file which is accetable.
   ENSURE(.cif.created,"no CIF object created")
      if (.cif.data_block_name==" ") then
         WARN("no CIF data block as specified, looking for first acceptable data block")
         .MAIN:find_CIF_crystal_data_block(.cif)
      end
      .MAIN:open_CIF_at_data_block(.cif)
      .MAIN:read_CIF_atoms(.cif)   ! Read in atoms of asymmetric unit
      .MAIN:read_CIF_crystal(.cif) ! Read crystal info
   end

   process_CIF_for_CX ::: leaky
   ! Process and entire .cif file by reading all acceptable data blocks (i.e.
   ! those with crystal and atom information) and then writing this information
   ! to a crystal explorer information file. 
      self :: PTR
   ENSURE(.CX_file_name/=" ","no CX file name")
   ENSURE(.cif.created,"no CIF object created")
   ENSURE(.cif.file_name/=" ","no CIF file name specified")
      found,CX_uses_angstrom :: BIN
      cif :: CIF*
      CX_file :: TEXTFILE*
      CX_file.create(.CX_file_name)
      CX_file.open(for="write")
      cif => .cif   ! Save .cif outside of self, since it gets destroyed
      nullify(.cif)
      do
         .MAIN:find_CIF_crystal_data_block(cif,found)
         if (NOT found) exit                  ! No more crystal data blocks
         .MAIN:read_CIF_atoms(cif)            ! Read in atoms of asymmetric unit
         .MAIN:read_CIF_crystal(cif)          ! Read crystal info
         .cluster.create(.crystal)
         .cluster.radius = ZERO       
         .cluster.generation_method = "fragment"
         .cluster.defragment = FALSE
         .cluster.make_info                   ! Create the cluster
         .cluster.put
         .MAIN:put_CX_data(CX_file,cif)       ! Write out the data
         CX_uses_angstrom  = .CX_uses_angstrom
         .destroy                             ! Destroy self, create from cif
         .create
         .CX_uses_angstrom = CX_uses_angstrom
         cif.start_of_data = cif.end_of_data  
      end
      cif.destroy
      CX_file.destroy
   end

!   process_CIF_crystal ::: leaky
!   ! Process a CIF file, but read *only* crystal information i.e. do *not*
!   ! define any atom list information or atom U matrix information.  Information
!   ! is processed either from the current ".cif.data_block_name", or from the
!   ! first data block in the CIF file which is accetable. NOTE: even though only
!   ! crystal information is inputted, the asymmetric unit atom positions must be
!   ! present.
!   ENSURE(.cif.created,"no CIF object created")
!      if (.cif.data_block_name==" ") then
!         WARN("no CIF data block as specified, looking for first acceptable data block")
!         .MAIN:find_CIF_crystal_data_block(.cif)
!      end
!      .MAIN:open_CIF_at_data_block(.cif)
!      .MAIN:read_CIF_crystal(.cif) ! Read crystal info
!   end

!   process_CIF_ADPs ::: leaky
!   ! Process a CIF file, and read only the ADP's, either from the current
!   ! ".cif.data_block_name", or from the first data block in the CIF file which
!   ! is accetable.
!   ENSURE(.cif.created,"no CIF object created")
!      if (.cif.data_block_name==" ") then
!         WARN("no CIF data block as specified, looking for first acceptable data block")
!         .MAIN:find_CIF_crystal_data_block(.cif)
!      end
!      .MAIN:open_CIF_at_data_block(.cif)
!      .MAIN:read_CIF_ADPs(.cif)    ! Read in atoms of asymmetric unit
!   end

!   find_CIF_crystal_data_block(found) 
!   ! Find the *first* block of crystal and atom information from the CIF file,
!   ! and set the locator ".cif.data_block_name".  The name of the molecule (job)
!   ! is set to be the name of the cif file concatenated with the data block
!   ! name.  
!      self :: PTR
!      found :: BIN, optional, OUT
!      .MAIN:find_CIF_crystal_data_block(.cif,found)
!   end

   find_CIF_crystal_data_block(cif,found) 
   ! Find the *first* block of crystal and atom information in the "cif" file
   ! (starting from line cif.start_of_data), and set the locator
   ! "cif.data_block_name".  The name of the molecule (job) is set to be the
   ! name of the cif file concatenated with the data block name.  
      cif :: CIF
      found :: BIN, optional, OUT
   ENSURE(cif.file.created,"no CIF file name")
   ENSURE(cif.file.name/=" ","no CIF file name")
      fnd :: BIN
      head :: STR
      head = cif.file.name.filename_head
      .name = head
      if (NOT cif.file.is_open) cif.open
      cif.find_crystal_data_block(fnd)
      if (present(found)) then
         found = fnd
         if (NOT found) return
      else 
         DIE_IF(NOT fnd,"couldn't find crystal data block")
      end
      .name = head.trim // "_" &
           // cif.data_block_name ! Set name to the crystal data name
      WARN("Job name has now been set to: "//.name.trim)
   end

   open_CIF_at_data_block(cif)
   ! Open the "cif" file with name "cif.file_name", and set it to the start of the
   ! data block with name "cif.data_block_name".
      cif :: CIF, PTR
   ENSURE(cif.created,"no CIF object created")
   ENSURE(cif.file_name/=" ","no CIF file name")
   ENSURE(cif.data_block_name/=" ","no CIF data block name")
      data_block_name :: STR
      data_block_name = cif.data_block_name ! Store this, since cif.data_block_name gets overwritten
      cif.open
      cif.find_data_block(data_block_name)
   end

   read_CIF_crystal(cif) ::: leaky
   ! Read crystal unit cell and spacegroup information (but NOT atom positions)
   ! from a CIF file called "cif".
      cif :: CIF

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Open the CIF if needed
      if (NOT cif.file.is_open) cif.open

      ! Create the crystal; it shouldn't really exist beforehand
      WARN_IF(.crystal.created,"crystal data already defined!")
      if (.crystal.destroyed) .crystal.create

      ! Read in the crystal from the CIF
      .crystal.read_CIF(cif,skip_atoms=TRUE)

      ! Only continue if there are some atoms ...
      if (NOT associated(.atom)) return
 
      .MAIN:set_atoms_and_crystal(cif) 

   end

   read_CIF_atoms(cif) ::: leaky
   ! Read atom information from a Crystallographic Information File, "cif".
   ! NOTE: Any previous atom information in destroyed.
      cif :: CIF

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")

      ! Open the CIF
      if (NOT cif.file.is_open) cif.open

      ! Read the atoms from the CIF
      if (.atom.created) then
         .atom.nullify_basis_part
         .atom.destroy
      end
      .atom.read_CIF(cif)

      ! Set defaults and bases
      .mult = nint(.default_multiplicity)
      .set_atom_info
      .resolve_basis_info

      ! Resolve axes in crystal is there
      if (.crystal.destroyed) return
 
      .MAIN:set_atoms_and_crystal(cif) 

   end

   set_atoms_and_crystal(cif) ::: private, leaky
   ! Set the atom and crystal information when processing the CIF.
   ! We may have to reset H atom positions.
      cif :: CIF

   ENSURE(.atom.created,"no atoms")
   ENSURE(.crystal.created,"no crystal")
 
      H_bond_length :: VEC{REAL}*
      has_Hs,reset :: BIN

      ! Change atom positions to cartesian
      .resolve_axis_system

      ! If the hydrogen's are all single bonded, reset the simple way.
      ! If disordered, this code assumes the disordered atoms are
      ! proximate to their bonded neighbours.
      if (.atom.has_all_Hs_single_bonded(has_Hs)) then

         if (has_Hs) then
         if (cif.apply_BH_bond_length) .atom.set_bond_lengths(5,1,cif.BH_bond_length) 
         if (cif.apply_CH_bond_length) .atom.set_bond_lengths(6,1,cif.CH_bond_length) 
         if (cif.apply_NH_bond_length) .atom.set_bond_lengths(7,1,cif.NH_bond_length) 
         if (cif.apply_OH_bond_length) .atom.set_bond_lengths(8,1,cif.OH_bond_length) 
         end

         .crystal.make_fragment_data(.atom)

      else ! There are floating hydrogens or multiple bonded H's ...

         ! Analyse the fragment symmetry information
         .crystal.make_fragment_data(.atom)

         ! Use the crystal to reset the hydrogen bond lengths
         H_bond_length.create(5,8)
         H_bond_length(5) =  cif.BH_bond_length
         H_bond_length(6) =  cif.CH_bond_length
         H_bond_length(7) =  cif.NH_bond_length
         H_bond_length(8) =  cif.OH_bond_length
         .crystal.reset_H_bond_lengths_in(.atom,H_bond_length,reset)
         H_bond_length.destroy

         ! Return if nothing was done
         if (NOT reset) return

         if (.atom.has_disorder) then
            WARN_IF(.atom.has_disorder,"DISORDERED ASYMMETRIC CELL MAY BE PRUNED")
            WARN_IF(.atom.has_disorder,"SOME ATOM INFORMATION MAY BE LOST")
         end

         ! Re-analyse the fragment symmetry information
         ! Maybe not all things in here need doing again ...
         .crystal.destroy_asymmetric_unit
         .crystal.make_fragment_data(.atom,warnings=FALSE)

      end

   end

   read_CIF_ADPs(cif) ::: leaky
   ! Read atom ADP information from a Crystallographic Information File, "cif".
      cif :: CIF
   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")
   ENSURE(.crystal.created,"must have crystal information")
      if (NOT cif.file.is_open) cif.open
      .atom.read_CIF_ADPs(cif)
      .resolve_axis_system
   end

   put_CX_data
   ! Output information that Crystal Explorer requires to the file 
   ! with name ".CX_file_name".
      .MAIN:put_CX_data(.cif)
   end

   put_CX_data(cif)
   ! Output information that Crystal Explorer requires to the file 
   ! with name ".CX_file_name".
      cif :: CIF*
      CX_file :: TEXTFILE*
      if (.CX_file_name/=" ") then
         CX_file.create(.CX_file_name)
         CX_file.open(for="write")
         .MAIN:put_CX_data(CX_file,cif)
         CX_file.close
         CX_file.destroy
      else
         .MAIN:put_CX_data(stdout,cif)
      end
   end

   put_CX_data(CX_file,cif)
   ! Output information that Crystal Explorer requires to file "CX_file".
   ! NOTE: this requires a "cif" file to have been read, and a valid data block
   ! name to be stored in the "cif" object.
     CX_file :: TEXTFILE*
     cif :: CIF*

   ENSURE(cif.created,"no CIF object created")
   ENSURE(cif.data_block_name/=" ","no CIF data block name")

     save :: TEXTFILE*
     done :: BIN
     CX_label,formula,spacegroup :: STR

     CX_label = cif.data_block_name

     stdout.flush
     stdout.text("Writing Crystal Explorer data file: " // CX_file.name.trim)
     stdout.flush

     ! Redirect stdout to out
     save   => stdout                      
     stdout => CX_file

     ! Reset output format
     stdout.save
     stdout.set_use_fields(FALSE)
     stdout.set_int_width(7)
     stdout.set_real_style("f")
     stdout.set_precision(5)
     stdout.set_real_width(12)

     stdout.flush
     stdout.text("Crystal Explorer data")

     stdout.flush
     stdout.show("begin CIF ",CX_label)
     stdout.show("file_name = ",cif.file_name)
     stdout.show("data_block_name = ",cif.data_block_name)
     stdout.text("end CIF")
     stdout.flush

     ! Crystal data and cluster/fragment positions
     ! Try saved cluster first
     done = FALSE
     if (.saved.created) then
     if (.saved.cluster.created) then
        ENSURE(.saved.cluster.info_made,"no cluster information")
        ENSURE(.saved.cluster.crystal.created,"no cluster crystal data")
        ENSURE(.saved.cluster.n_fragment_atoms>0,"no fragment size")
        formula    = .saved.cluster.crystal.CIF_chemical_formula
        spacegroup = .saved.cluster.crystal.spacegroup.HM_symbol
        stdout.show("begin crystal ",CX_label)
        .saved.cluster.crystal.put_CX(CX_label,formula,spacegroup) 
        .saved.cluster.put_CX(CX_label,angstrom=.CX_uses_angstrom)
        stdout.flush
        stdout.text("end crystal")
        done = TRUE
     end
     end

     ! Try normal cluster
     if (NOT done) then
     if (.cluster.created) then
        ENSURE(.cluster.info_made,"no cluster information")
        ENSURE(.cluster.crystal.created,"no cluster crystal data")
        ENSURE(.cluster.n_fragment_atoms>0,"no fragment size")
        formula    = .cluster.crystal.CIF_chemical_formula
        spacegroup = .cluster.crystal.spacegroup.HM_symbol
        stdout.show("begin crystal ",CX_label)
        .cluster.crystal.put_CX(CX_label,formula,spacegroup) 
        .cluster.put_CX(CX_label,angstrom=.CX_uses_angstrom)
        stdout.flush
        stdout.text("end crystal")
        done = TRUE
     end
     end

     ! Isosurface information
     if (.isosurface.created) then
     if (.isosurface.atom.created) then 

     ! Try saved cluster first
     done = FALSE
     if (.saved.created) then
     if (.saved.cluster.created) then
        .isosurface.put_CX(.isosurface.surface_label.trim &
                           ,.saved.cluster.fragment_atom_indices &
                           ,.saved.cluster.nonfragment_atom_indices &
                           ,angstrom=.CX_uses_angstrom)
        done = TRUE
     end
     end

     ! Try normal cluster
     if (NOT done) then
     if (.cluster.created) then
        .isosurface.put_CX(.isosurface.surface_label.trim &
                           ,.cluster.fragment_atom_indices &
                           ,.cluster.nonfragment_atom_indices &
                           ,angstrom=.CX_uses_angstrom)
        done = TRUE
     end
     end

     end
     end

     ! Put back stdout
     stdout.unsave
     stdout => save                        

   end

   read_rotate
   ! Rotate the whole molecule using matrix defined by its rotation "axis" and
   ! the "angle" of rotation around that axis, which are both inputted.
   ! Checked, 7/2/06; it needed the archives to be deleted to work
      R :: MAT{REAL}(3,3)
      axis :: VEC{REAL}(3)
      angle :: REAL
      stdin.read(axis)
      stdin.read(angle)
   ENSURE(NOT axis.is_zero,"axis must not be zero")
      .delete_scf_archives
      .delete_scf_integrals
      R.to_3x3_rotation_matrix(axis,angle)
      .MAIN:rotate_by(R)
   end

   rotate_by(R)
   ! Rotate the whole molecule using matrix "R" which specifies how positions in
   ! space are to be transformed i.e. x' = Rx.
      R :: MAT{REAL}
   ENSURE(R.is_square,"rotation matrix is not square")
   ENSURE(R.dim1==3,"rotation matrix must be 3x3")
    ! Rt :: MAT{REAL}(3,3)
    ! Rt = transpose(R)
      .atom.rotate_by(R)
      .MAIN:rotate_molecular_orbitals(R)
   end

   rotate_molecular_orbitals(R)
   ! Rotate the whole molecule using matrix "R" which specifies how positions in
   ! space are to be transformed i.e. x' = Rx.
      self :: IN
      R :: MAT{REAL}, IN
      archive :: ARCHIVE
      mo_kind :: STR
      if (.molecular_orbitals.destroyed) return
      if (.molecular_orbitals.all_destroyed) return
      mo_kind = .molecular_orbitals.spinorbital_kind
      select case (mo_kind)
         case("restricted")
                  .MAIN:rotate_orbitals(.molecular_orbitals.restricted,R)
         case("unrestricted")
                  .MAIN:rotate_orbitals(.molecular_orbitals.alpha,R)
                  .MAIN:rotate_orbitals(.molecular_orbitals.beta,R)
         case("general")
                  .MAIN:rotate_orbitals(.molecular_orbitals.general.alpha_alpha,R)
                  .MAIN:rotate_orbitals(.molecular_orbitals.general.alpha_beta,R)
                  .MAIN:rotate_orbitals(.molecular_orbitals.general.beta_alpha,R)
                  .MAIN:rotate_orbitals(.molecular_orbitals.general.beta_beta,R)
         case("restricted_complex")
                ! .MAIN:rotate_orbitals(.molecular_orbitals.restricted_complex,R)
         case("unrestricted_complex")
                ! .MAIN:rotate_orbitals(.molecular_orbitals.alpha_complex,R)
                ! .MAIN:rotate_orbitals(.molecular_orbitals.beta_complex,R)
         case("general_complex")
                ! .MAIN:rotate_orbitals(.molecular_orbitals.general_complex.alpha_alpha,R)
                ! .MAIN:rotate_orbitals(.molecular_orbitals.general_complex.alpha_beta,R)
                ! .MAIN:rotate_orbitals(.molecular_orbitals.general_complex.beta_alpha,R)
                ! .MAIN:rotate_orbitals(.molecular_orbitals.general_complex.beta_beta,R)
         case default;   DIE("unknown kind, "//trim(mo_kind))
      end
      archive.set(.name,"molecular_orbitals",genre=mo_kind)
      archive.write(.molecular_orbitals)
      if (.density_matrix.created) then
      if (.density_matrix.any_created) then
         .make_scf_density_matrix              ! This will archive the density
      end
      end
   end

   rotate_orbitals(MO,R)
   ! Rotate the molecular orbitals "MO" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
      MO,R :: MAT{REAL}
   ENSURE(MO.dim1==.n_bf,"wrong dim1 for MO orbitals")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")
      new :: MAT{REAL}*
      tr :: VEC{MAT_{REAL}}*
      s,f,l,a :: INT
      new.create(.n_bf,.n_bf)
      tr.make_gaussian_xyz_matrices(R)
      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],MO(f:l,:))
      end
      MO = new
      tr.destroy
      new.destroy
   end

   read_rotate_group ::: leaky
   ! Rotate a group "g" of atoms in the molecule using a matrix defined by its
   ! rotation "axis" and the "angle" of rotation around that axis, which are all
   ! inputted on the command line. The rotation is performed on the coordinates
   ! and the group-block diagonal of the density matrix. NOTE: this can be a
   ! problem for group off-diagonal blocks; this routine works for progroup
   ! densities only.
   ! Checked, 7/2/06; the energy decomposition was checked by manual rotation
   ENSURE(.atom_group.created,"no atom group information")
      axis :: VEC{REAL}(3)
      angle :: REAL
      mol :: MOLECULE*
      archive :: ARCHIVE
      R :: MAT{REAL}(3,3)
      v :: VEC{REAL}(3)
      P :: MAT{REAL}*
      g,i,a :: INT
      stdin.read(g)      ! read group
      stdin.read(axis)   ! read axis
      stdin.read(angle)  ! read angle
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
   ENSURE(NOT axis.is_zero,"axis must not be zero")
      .delete_scf_archives
      .delete_scf_integrals
      R.to_3x3_rotation_matrix(axis,angle)
      ! Rotate atoms; the line below does not work
    ! .atom(.atom_group(g).element).rotate_by(R)
      do i = 1,.atom_group(g).element.dim
         a = .atom_group(g)[i]
         v = .atom(a).pos 
         .atom(a).pos = matmul(R,v)
         .atom(a).thermal_tensor.back_transform_using(R)
      end
      .molecular_orbitals.destroy         ! leaky here
      if (.density_matrix.destroyed) return
   ENSURE(.density_matrix.restricted.created,"so far group rotation is for restricted densities only")
      ! Rotate density
      mol.create
      .make_molecule_from_atom_group(g,mol)
      P.create(mol.n_bf,mol.n_bf)
      .MAIN:put_group_density_to(P,g,mol)
      mol.MAIN:rotate_density_matrix(P,R)
      .MAIN:set_group_density_from(P,g,mol)
      P.destroy
      mol.atom.nullify_ptr_part ! do not destroy these
      nullify(mol.basis)        ! do not destroy this
      nullify(mol.slaterbasis)  ! do not destroy this
      nullify(mol.coppensbasis) ! do not destroy this
      mol.destroy
      archive.set(.name,"density_matrix",genre="restricted")
      archive.write(.density_matrix)
   end

   put_group_density_to(P,g,mol)
   ! Put the atom group "g" density matrix into "P". "mol" must be a molecule
   ! created from the appropriate atom group "g".
      P :: MAT{REAL}
      g :: INT, IN
      mol :: MOLECULE, IN
   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
      a,b,aa,bb,fa,la,fb,lb,faa,laa,fbb,lbb :: INT
      do a = 1,.atom_group(g).element.dim ! Copy this atom density
      do b = 1,.atom_group(g).element.dim
         aa  = .atom_group(g)[a]
         bb  = .atom_group(g)[b]
         faa = .first_basis_fn_for_atom(aa)
         fbb = .first_basis_fn_for_atom(bb)
         laa = .last_basis_fn_for_atom(aa)
         lbb = .last_basis_fn_for_atom(bb)
         fa  = mol.first_basis_fn_for_atom(a)
         fb  = mol.first_basis_fn_for_atom(b)
         la  = mol.last_basis_fn_for_atom(a)
         lb  = mol.last_basis_fn_for_atom(b)
         P(fa:la,fb:lb) = .density_matrix.restricted(faa:laa,fbb:lbb) 
      end
      end
   end

   set_group_density_from(P,g,mol)
   ! Set the atom group "g" density matrix from "P". "mol" must be a molecule
   ! created from the appropriate atom group "g".
      P :: MAT{REAL}
      g :: INT, IN
      mol :: MOLECULE, IN
   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")
      a,b,aa,bb,fa,la,fb,lb,faa,laa,fbb,lbb :: INT
      do a = 1,.atom_group(g).element.dim ! Copy this atom density
      do b = 1,.atom_group(g).element.dim
         aa  = .atom_group(g)[a]
         bb  = .atom_group(g)[b]
         faa = .first_basis_fn_for_atom(aa)
         fbb = .first_basis_fn_for_atom(bb)
         laa = .last_basis_fn_for_atom(aa)
         lbb = .last_basis_fn_for_atom(bb)
         fa  = mol.first_basis_fn_for_atom(a)
         fb  = mol.first_basis_fn_for_atom(b)
         la  = mol.last_basis_fn_for_atom(a)
         lb  = mol.last_basis_fn_for_atom(b)
         .density_matrix.restricted(faa:laa,fbb:lbb) = P(fa:la,fb:lb)
      end
      end
   end

   rotate_density_matrix(P,R)
   ! Rotate the density matrix "P" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
      P,R :: MAT{REAL}
   ENSURE(P.is_square,"wrong shape for density matrix P")
   ENSURE(P.dim1==.n_bf,"wrong dim1 for density matrix P")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")
      new :: MAT{REAL}*
      tr :: VEC{MAT_{REAL}}*
      s,f,l,a :: INT
      new.create(.n_bf,.n_bf)
      tr.make_gaussian_xyz_matrices(R)
      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],P(f:l,:))
      end
      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         P(:,f:l).to_product_of(new(:,f:l),transpose(tr(a)[:,:]))
      end
      tr.destroy
      new.destroy
   end

! *********
! Gradients
! *********

!   optimise_geometry
!   ! Optimise the Hartree-Fock SCF energy gradient.
!      k,i :: INT
!      p :: VEC{REAL}*
!      energy :: REAL
!      self :: target
!      p.create(3*.n_atom)
!      k = 0
!      do i = 1,.n_atom
!         p(k+1) = .atom(i).pos(1)
!         p(k+2) = .atom(i).pos(2)
!         p(k+3) = .atom(i).pos(3)
!         k = k + 3
!      end
!      saved_self => self
!      call minimise_BFGS(hf_scf_energy,hf_scf_gradient,p,energy,TOL(3),TOL(3),TOL(1),25)
!      stdout.show("Optimised energy = ",energy)
!      stdout.text("Optimised geometry:")
!      stdout.put(p,format="column")
!      p.destroy
!   end
!
!   hf_scf_energy(p) result (res) ::: selfless
!   ! Evaluates the total HF SCF energy (including nuclear)
!      p :: VEC{REAL}
!     res :: REAL
!     self :: MOLECULE*; self => saved_self
!   ENSURE(.n_atom*3==p.dim,"wrong size for p")
!     if (NOT .atom.geometry_vector.same_as(p,tol=TOL(9))) then
!        .atom.set_geometry_from_vector(p)
!        .delete_scf_integrals
!        .hf_scf
!     end
!     res = .scf_energy
!   end
!
!   the_scf_energy result (res)
!   ! Evaluates the total HF SCF energy (including nuclear)
!     res :: REAL
!     .scfdata.output = FALSE
!     .delete_scf_integrals
!     .hf_scf
!     res = .scf_electronic_energy(.density_matrix)
!     .scfdata.output = TRUE
!   end
!
!   the_e2_energy result (res)
!   ! Evaluates the total HF SCF energy (including nuclear)
!     res :: REAL
!   ! .scfdata.output = FALSE
!   ! .delete_scf_integrals
!   ! .hf_scf
!     .delete_scf_integrals
!     .make_fock_matrix(core=FALSE)
!     res = .scf_electronic_energy(.density_matrix,core=FALSE)
!   ! .scfdata.output = TRUE
!   end
!
!   hf_scf_gradient(p) result (g) ::: selfless
!   !  Evaluate the HF SCF gradient at geometry "g" and return the
!   !  answer as a vector "res"
!       p :: VEC{REAL}
!       g :: VEC{REAL}(size(p))
!      i,k :: INT
!      self :: MOLECULE*; self => saved_self
!   ENSURE(.n_atom*3==p.dim,"wrong size for p")
!      if (NOT .atom.geometry_vector.same_as(p,tol=TOL(9))) then
!        .atom.set_geometry_from_vector(p)
!        .delete_scf_integrals
!        .hf_scf
!      end
!      g = ZERO
!      .add_S_gradient_term(g)
!      .add_T_gradient_term(g)
!      .add_NA_gradient_term(g)
!      .add_2e_gradient_term(g)
!   end
!
!   hf_scf_energy_gradient
!   ! Calculate the Hartree-Fock SCF energy gradient.
!      g :: VEC{REAL}*
!      P :: MAT{REAL}*
!      delta, val :: REAL
!   ENSURE(.density_matrix.restricted.created,"no density matrix")
!      stdin.read(delta)
!      g.create(3*.n_atom)
!      g = ZERO
!      .add_S_gradient_term(g)
!      .make_fd_gradient(S_energy,delta)
!      .add_T_gradient_term(g)
!      .make_fd_gradient(T_energy,delta)
!      .add_NA_gradient_term(g)
!      .make_fd_gradient(NA_energy,delta)
!      .add_2e_gradient_term(g)
!      .make_fd_gradient(e2_energy,delta)
!      .make_fd_gradient(the_e2_energy,delta)
!      stdout.text("Energy gradient:")
!      stdout.put(g,format="column")
!      val = .e2_energy
!      stdout.show("e2_energy     = ",val)
!      val = .the_e2_energy
!      stdout.show("the_e2_energy = ",val)
!      g.destroy
!      .make_fd_gradient(the_scf_energy,delta)
!   end
!
!   energy_gradient(gradient)
!   ! Calculate the Hartree-Fock SCF energy gradient.
!       gradient :: VEC{REAL}
!       g :: VEC{REAL}*
!       P :: MAT{REAL}*
!   ENSURE(.density_matrix.restricted.created,"no density matrix")
!      g.create(3*.n_atom)
!      g = ZERO
!      .add_S_gradient_term(g)
!      .add_T_gradient_term(g)
!      .make_fd_gradient(T_energy)
!      .add_NA_gradient_term(g)
!      .make_fd_gradient(NA_energy)
!      .add_2e_gradient_term(g)
!      .make_fd_gradient(e2_energy)
!      gradient = gradient + g
!      g.destroy
!   end
!
!   make_e_weighted_density_matrix(D) ::: private
!   ! Make the eigenvalue weighted density matrix used in the overlap
!   ! derivative energy gradient term
!     D :: MAT{REAL}
!     X,MO :: MAT{REAL}*
!     eigenvalues :: VEC{REAL}*
!     eig_archive,MO_archive :: ARCHIVE
!     eig_archive.set(.name,"orbital_energies",genre="restricted")
!     MO_archive.set(.name,"molecular_orbitals",genre="restricted")
!   ENSURE(eig_archive.exists,"no eigenvalues")
!   ENSURE(MO_archive.exists,"no molecular orbitals")
!     X.create(.n_bf,.n_bf)
!     MO.create(.n_bf,.n_bf)
!     eigenvalues.create(.n_bf)
!     MO_archive.read(MO)
!     eig_archive.read(eigenvalues)
!     eigenvalues = TWO*eigenvalues
!     eigenvalues(.n_e/2+1:) = ZERO
!     X.to_product_with_diagonal(MO,eigenvalues)
!     D.to_product_of(X,MO,transpose_b=TRUE)
!     eigenvalues.destroy
!     MO.destroy
!     X.destroy
!   end
!
!   add_S_gradient_term(gradient) ::: private
!   ! Make the overlap derivative contribution to the SCF gradient by contracting
!   ! The overlap derivatives with the densitu matrix.
!     gradient :: VEC{REAL}
!     g :: VEC{REAL}*
!     SAx,SAy,SAz, D :: MAT{REAL}*
!     q,fa,la,fb,lb,atom_a,atom_b, ax,ay,az,bx,by,bz :: INT
!     val_x,val_y,val_z :: REAL
!     sh :: SHELL2
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.atom.created,  "no atom list")
!     g.create(3*.n_atom); g = ZERO
!     D.create(.n_bf,.n_bf)
!     .make_e_weighted_density_matrix(D) ! includes factor of 2
!     do q=1,.n_shell_pairs
!       .get_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!       if (atom_a/=atom_b) then
!       SAx.create(sh.a.n_comp,sh.b.n_comp)
!       SAy.create(sh.a.n_comp,sh.b.n_comp)
!       SAz.create(sh.a.n_comp,sh.b.n_comp)
!       sh.make_S_1st_deriv_ints(SAx,SAy,SAz)
!       val_x = SAx.trace_product_with(D(fb:lb,fa:la))
!       val_y = SAy.trace_product_with(D(fb:lb,fa:la))
!       val_z = SAz.trace_product_with(D(fb:lb,fa:la))
!       SAz.destroy; SAy.destroy; SAx.destroy
!       ax = 3*atom_a - 2; ay = 3*atom_a - 1; az = 3*atom_a
!       bx = 3*atom_b - 2; by = 3*atom_b - 1; bz = 3*atom_b
!       g(ax) = g(ax) + val_x ; g(ay) = g(ay) + val_y ; g(az) = g(az) + val_z
!       g(bx) = g(bx) - val_x ; g(by) = g(by) - val_y ; g(bz) = g(bz) - val_z
!       end
!       sh.destroy_ptr_part
!     end
!     D.destroy
!     stdout.flush
!     stdout.text("S gradient term:")
!     stdout.put(-TWO*g,format="column")
!     gradient = gradient - TWO*g ! factor TWO for upper half of shell pairs
!     g.destroy
!   end
!
!   add_T_gradient_term(gradient) ::: private
!   ! Add the kinetic derivative contribution to the SCF "gradient" by contracting
!   ! The kinetic integral derivatives with the densitu matrix.
!     gradient :: VEC{REAL}
!     g :: VEC{REAL}*
!     TAx,TAy,TAz, P :: MAT{REAL}*
!     q,fa,la,fb,lb,atom_a,atom_b, ax,ay,az,bx,by,bz :: INT
!     val_x,val_y,val_z :: REAL
!     arch :: ARCHIVE
!     sh :: SHELL2
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.atom.created,  "no atom list")
!     arch.set(.name,"density_matrix",genre="restricted")
!   ENSURE(arch.exists,"no density")
!     g.create(3*.n_atom); g = ZERO
!     P.create(.n_bf,.n_bf)
!     arch.read(P)
!     do q=1,.n_shell_pairs
!       .get_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!       if (atom_a/=atom_b) then
!       TAx.create(sh.a.n_comp,sh.b.n_comp)
!       TAy.create(sh.a.n_comp,sh.b.n_comp)
!       TAz.create(sh.a.n_comp,sh.b.n_comp)
!       sh.make_T_1st_deriv_ints(TAx,TAy,TAz)
!       val_x = TAx.trace_product_with(P(fb:lb,fa:la))
!       val_y = TAy.trace_product_with(P(fb:lb,fa:la))
!       val_z = TAz.trace_product_with(P(fb:lb,fa:la))
!       TAz.destroy; TAy.destroy; TAx.destroy
!       ax = 3*atom_a - 2; ay = 3*atom_a - 1; az = 3*atom_a
!       bx = 3*atom_b - 2; by = 3*atom_b - 1; bz = 3*atom_b
!       g(ax) = g(ax) + val_x ; g(ay) = g(ay) + val_y ; g(az) = g(az) + val_z
!       g(bx) = g(bx) - val_x ; g(by) = g(by) - val_y ; g(bz) = g(bz) - val_z
!       end
!       sh.destroy_ptr_part
!     end
!     P.destroy
!     stdout.flush
!     stdout.text("T gradient:")
!     stdout.put(TWO*g,format="column")
!     gradient = gradient + TWO*g ! factor for upper half of shell pairs
!     g.destroy
!   end
!
!   add_NA_gradient_term(gradient) ::: private
!   ! Add the nuclear attraction derivative contribution to the SCF "gradient" by contracting
!   ! the nuclear attraction integral derivatives with the densitu matrix. This term includes
!   ! the Helmann-Feynman contribution.
!     gradient :: VEC{REAL}
!     g :: VEC{REAL}*
!     NAx,NAy,NAz, NBx,NBy,NBz, P :: MAT{REAL}*
!     q,fa,la,fb,lb,atom_a,atom_b,c, ax,ay,az,bx,by,bz,cx,cy,cz :: INT
!     val_ax,val_ay,val_az, val_bx,val_by,val_bz, val_cx,val_cy,val_cz, Z, fac :: REAL
!     arch :: ARCHIVE
!     sh :: SHELL2
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.atom.created,  "no atom list")
!     arch.set(.name,"density_matrix",genre="restricted")
!   ENSURE(arch.exists,"no density")
!     g.create(3*.n_atom); g = ZERO
!     P.create(.n_bf,.n_bf)
!     arch.read(P)
!     do q=1,.n_shell_pairs
!       .get_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!       NAx.create(sh.a.n_comp,sh.b.n_comp)
!       NAy.create(sh.a.n_comp,sh.b.n_comp)
!       NAz.create(sh.a.n_comp,sh.b.n_comp)
!       NBx.create(sh.a.n_comp,sh.b.n_comp)
!       NBy.create(sh.a.n_comp,sh.b.n_comp)
!       NBz.create(sh.a.n_comp,sh.b.n_comp)
!       fac = TWO; if (fa==fb) fac = ONE
!       do c=1,.n_atom
!         if (atom_a==c AND atom_b==c) cycle
!         sh.make_NA_1st_deriv_ints(NAx,NAy,NAz,NBx,NBy,NBz,.atom(c).pos)
!         Z = - .atom(c).atomic_number * fac ! for upper half of shell pair
!         val_ax = Z * NAx.trace_product_with(P(fb:lb,fa:la))
!         val_ay = Z * NAy.trace_product_with(P(fb:lb,fa:la))
!         val_az = Z * NAz.trace_product_with(P(fb:lb,fa:la))
!         val_bx = Z * NBx.trace_product_with(P(fb:lb,fa:la))
!         val_by = Z * NBy.trace_product_with(P(fb:lb,fa:la))
!         val_bz = Z * NBz.trace_product_with(P(fb:lb,fa:la))
!         ax = 3*atom_a - 2; ay = 3*atom_a - 1; az = 3*atom_a
!         bx = 3*atom_b - 2; by = 3*atom_b - 1; bz = 3*atom_b
!         cx = 3*c      - 2; cy = 3*c      - 1; cz = 3*c
!         val_cx = -(val_ax + val_bx)
!         val_cy = -(val_ay + val_by)
!         val_cz = -(val_az + val_bz)
!         g(ax) = g(ax) + val_ax ; g(ay) = g(ay) + val_ay ; g(az) = g(az) + val_az
!         g(bx) = g(bx) + val_bx ; g(by) = g(by) + val_by ; g(bz) = g(bz) + val_bz
!         g(cx) = g(cx) + val_cx ; g(cy) = g(cy) + val_cy ; g(cz) = g(cz) + val_cz
!       end
!       NBz.destroy; NBy.destroy; NBx.destroy
!       NAz.destroy; NAy.destroy; NAx.destroy
!       sh.destroy_ptr_part
!     end
!     P.destroy
!     stdout.flush
!     stdout.text("NA gradient:")
!     stdout.put(g,format="column")
!     gradient = gradient + g
!     g.destroy
!   end
!
!   add_2e_gradient_term(gradient) ::: private
!   ! Add the two electron derivative contributions to the "gradient".
!     gradient :: VEC{REAL}
!     g :: VEC{REAL}*
!     P :: MAT{REAL}*
!     max_I,max_P :: VEC{REAL}*
!     sh :: SHELL4
!     AA,BB,CC :: MAT5{REAL}*
!     ab,cd, sa,sb,sc,sd, atom_a,atom_b,atom_c,atom_d :: INT
!     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     ax,ay,az,bx,by,bz,cx,cy,cz,dx,dy,dz :: INT
!     fac,P_dc,P_db,P_cb,P_ba,P_da,P_ca,cutoff,dens,P_max,IP_max :: REAL
!     AAx,AAy,AAz,BBx,BBy,BBz,CCx,CCy,CCz,DDx,DDy,DDz,SSx,SSy,SSz :: REAL
!     skip :: BIN
!     ab_same,cd_same,ac_same :: BIN
!     arch :: ARCHIVE
!     arch.set(.name,"density_matrix",genre="restricted")
!   ENSURE(arch.exists,"no density")
!     g.create(3*.n_atom); g = ZERO
!     P.create(.n_bf,.n_bf)
!     arch.read(P)
!     cutoff = .scfdata.eri_schwarz_cutoff
!     max_I.create(.n_shell_pairs)
!     max_P.create(.n_shell_pairs)
!     .make_max_abab_integrals(max_I)
!     .make_max_density_elements(max_P,P)
!     P_max = maxval(max_P)
!     IP_max = maxval(max_I) * P_max
!     do ab = 1, .n_shell_pairs
!       if (max_I(ab)*IP_max < cutoff)  cycle                         ! Rough Schwarz test, but quick.
!       .get_shell_pair_indices(ab,sa,sb,fa,la,fb,lb,atom_a,atom_b)   ! a & b shell indices.
!       ax = 3*atom_a-2; ay = 3*atom_a-1; az = 3*atom_a
!       bx = 3*atom_b-2; by = 3*atom_b-1; bz = 3*atom_b
!       ab_same = atom_a==atom_b
!       .set_shell_quartet_ab(sh,sa,sb)
!       do cd = 1,ab
!         if (max_I(ab)*max_I(cd)*P_max < cutoff)  cycle              ! Rough Schwarz test
!         .get_shell_pair_indices(cd,sc,sd,fc,lc,fd,ld,atom_c,atom_d) ! c & d shell indices.
!         cx = 3*atom_c-2; cy = 3*atom_c-1; cz = 3*atom_c
!         dx = 3*atom_d-2; dy = 3*atom_d-1; dz = 3*atom_d
!         cd_same = atom_c==atom_d
!         ac_same = atom_a==atom_c
!         if (ab_same AND cd_same AND ac_same) cycle ! by translational invariance
!         ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,sa,sb,sc,sd,max_P,max_I)
!         if (skip) cycle
!         .set_shell_quartet_cd(sh,sc,sd)
!         ! Evaluate the integrals' coincidence factors
!         fac = ONE
!         if (sa==sb)            fac = HALF * fac
!         if (sc==sd)            fac = HALF * fac
!         if (sa==sc AND sb==sd) fac = HALF * fac
!         AA.create(fa,la,fb,lb,fc,lc,fd,ld,1,3)
!         BB.create(fa,la,fb,lb,fc,lc,fd,ld,1,3)
!         CC.create(fa,la,fb,lb,fc,lc,fd,ld,1,3)
!         sh.make_ERI_derivatives(AA,BB,CC)
!         AA = fac*AA; BB = fac*BB; CC = fac*CC
!         do d = fd,ld
!         do c = fc,lc
!           P_dc = P(d,c)
!           do b = fb,lb
!             P_db = P(d,b)
!             P_cb = P(c,b)
!             do a = fa,la
!                P_ba = P(b,a)
!                P_da = P(d,a)
!                P_ca = P(c,a)
!                dens = FOUR*P_ba*P_dc - P_ca*P_db - P_da*P_cb
!                AAx = AA(a,b,c,d,1)*dens; AAy = AA(a,b,c,d,2)*dens; AAz = AA(a,b,c,d,3)*dens
!                BBx = BB(a,b,c,d,1)*dens; BBy = BB(a,b,c,d,2)*dens; BBz = BB(a,b,c,d,3)*dens
!                CCx = CC(a,b,c,d,1)*dens; CCy = CC(a,b,c,d,2)*dens; CCz = CC(a,b,c,d,3)*dens
!                DDx = -(AAx + BBx + CCx)
!                DDy = -(AAy + BBy + CCy)
!                DDz = -(AAz + BBz + CCz)
!                g(ax) = g(ax) + AAx; g(ay) = g(ay) + AAy; g(az) = g(az) + AAz
!                g(bx) = g(bx) + BBx; g(by) = g(by) + BBy; g(bz) = g(bz) + BBz
!                g(cx) = g(cx) + CCx; g(cy) = g(cy) + CCy; g(cz) = g(cz) + CCz
!                g(dx) = g(dx) + DDx; g(dy) = g(dy) + DDy; g(dz) = g(dz) + DDz
!             end
!           end
!         end
!         end
!         CC.destroy
!         BB.destroy
!         AA.destroy
!         sh.destroy_cd
!       end
!       sh.destroy_ab
!     end
!     max_P.destroy
!     max_I.destroy
!     P.destroy
!     stdout.flush
!     stdout.text("2e gradient:")
!     stdout.put(g,format="column")
!     gradient = gradient + g
!     g.destroy
!   end
!
!   make_fd_gradient(func,delta) ::: private
!   ! Make the finite difference gradient "g" of the value of function "func"
!   ! with respect to nuclear perturbations
!      interface
!         func(self) result (res)
!            self :: MOLECULE
!            res :: REAL
!         end
!      end
!      delta :: REAL, optional
!      g,p :: VEC{REAL}*
!      del,e_p,e_m :: REAL
!      a,i,ai :: INT
!      del = TOL(7)
!      if (present(delta)) del = delta
!      g.create(3*.n_atom)
!      p.create(3*.n_atom)
!      .atom.get_geometry_vector(p)
!      do a = 1,.n_atom
!      do i = 1,3
!         ai = 3*(a-1)+i
!         p(ai) = p(ai) + del
!         .atom.set_geometry_from_vector(p)
!         .delete_scf_integrals
!         e_p   = func(self)
!         p(ai) = p(ai) - TWO*del
!         .atom.set_geometry_from_vector(p)
!         .delete_scf_integrals
!         e_m   = func(self)
!         g(ai) = (e_p - e_m)/(TWO*del)
!         p(ai) = p(ai) + del
!    ! stdout.show("   ai =",ai)
!    ! stdout.show("   ep =",e_p)
!    ! stdout.show("   em =",e_m)
!         ! put back geometry
!         .atom.set_geometry_from_vector(p)
!      end
!      end
!      p.destroy
!      stdout.flush
!      stdout.text("Finite difference gradient:")
!      stdout.put(g,format="column")
!      g.destroy
!   end
!
!   S_energy result (res)
!   ! Make the energy weighted S energy
!     res :: REAL
!     D :: MAT{REAL}*
!     D.create(.n_bf,.n_bf)
!     .make_e_weighted_density_matrix(D) ! includes factor of 2
!     .get_overlap_matrix
!     res = - .overlap_matrix.trace_product_with(D)
!     D.destroy
!   end
!
!   T_energy result (res)
!   ! Make the kinetic energy
!     res :: REAL
!     T :: MAT{REAL}*
!     T.create(.n_bf,.n_bf)
!     .get_kinetic_matrix(T)
!     res = .expectation(T)
!     T.destroy
!   end
!
!   NA_energy result (res)
!   ! Make the electron-nuclear attraction energy
!     res :: REAL
!     Z :: MAT{REAL}*
!     Z.create(.n_bf,.n_bf)
!     .get_nuclear_matrix(Z)
!     res = .expectation(Z)
!     Z.destroy
!   end

! ******************
! Non orthogonal SCF
! ******************

   optimise_orbitals
   ! Optimise the Hartree-Fock orbitals directly using Fletcher Powell
      self :: target
      energy :: REAL
      MO :: VEC{REAL}*
      .get_initial_guess
      .molecular_orbitals.restricted.shrink(.n_bf,.n_a)
      MO.create(.n_bf*.n_a)
      MO = reshape(.molecular_orbitals.restricted,(/.n_bf*.n_a/))
      saved_self => self
      VEC{REAL}:minimise_BFGS(MOLECULE.MAIN::the_r_hf_energy,MOLECULE.MAIN::the_r_hf_energy_MO_gradient, &
         MO,energy,TOL(3),TOL(3),step=TOL(2))
    ! call minimise_FRPR_(the_r_hf_energy,the_r_hf_energy_MO_gradient,MO,energy,TOL(3),TOL(3),step=TOL(2))
      stdout.show("Optimised energy = ",energy)
      stdout.text("Optimised orbitals:")
      stdout.put(MO)
      MO.destroy
   end

   the_r_hf_energy(MO) result (res) ::: selfless
   ! Make the restricted Hartree-Fock energy from "MO", a vector representation
   ! of the occupied molecular orbitals. Includes nuclear contribution.
     MO :: VEC{REAL}, IN
     res :: REAL
     self :: MOLECULE*
     self => saved_self
     .molecular_orbitals.restricted = reshape(MO,(/.n_bf,.n_a/))
     .archive(.molecular_orbitals,"molecular_orbitals")
     .MAIN:make_non_ortho_scf_density ! writes density & occupations to disk
     .make_fock_matrix
     res = .scf_energy
     stdout.show("hf energy =",res)
   end

   r_hf_energy(MO) result (res)
   ! Make the Hartree-Fock energy without any intermediates.
   ! Includes nuclear contribution.
     MO :: MAT{REAL}
     res :: REAL
     P,N :: MAT{REAL}*
     P.create(.n_bf,.n_bf)
     N.create(.n_a ,.n_a)
     .MAIN:make_r_non_ortho_scf_density(P,MO,N) ! writes density to disk
     N.destroy
     res = .MAIN:e1_energy(P) + .MAIN:e2_energy(P) + .nuclear_energy
     P.destroy
     stdout.show("hf energy =",res)
   end

   e1_energy(P) result (res)
   ! Make the one-electron energy directly from the density matrix "P"
   ! without constructing any intermediates
     P   :: MAT{REAL}, target
     res :: REAL
   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(P.dim1==.n_bf,"wrong size, P")
   ENSURE(P.is_square,"wrong shape, P")
     X,Pp   :: MAT{REAL}*
     q,fa,la,fb,lb, c :: INT
     fac,this_res :: REAL
     sh :: SHELL2
     res = ZERO
     do q = 1,.n_shell_pairs
        .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
        fac = TWO
        if (fa==fb) fac = ONE
        X.create(fa,la,fb,lb)
        sh.get_kei(X)
        Pp => P(fb:lb,fa:la)
        this_res = X.trace_product_with(Pp)
        do c = 1,.n_atom
           sh.get_nuc(X,.atom(c).mass,.atom(c).pos)
           this_res = this_res - .atom(c).atomic_number*X.trace_product_with(Pp)
        end
        res = res + this_res * fac
        X.destroy
        sh.destroy_ptr_part
     end
   end

   e2_energy(P) result (res)
   ! Make the two electron electrostatic energy directly from the density
   ! matrix "P" without constructing any intermediates.
     res :: REAL
     P :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(P.dim1==.n_bf,"wrong size, P")
   ENSURE(P.is_square,"wrong shape, P")
     max_I,max_P :: VEC{REAL}*
     I :: MAT4{REAL}*
     sh :: SHELL4
     ab,cd, sa,sb,sc,sd, atom_a,atom_b,atom_c,atom_d :: INT
     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
     fac,P_dc,P_db,P_cb,cutoff,dens,P_max,IP_max :: REAL
     skip :: BIN
     cutoff = .scfdata.eri_schwarz_cutoff
     max_I.create(.n_shell_pairs)
     max_P.create(.n_shell_pairs)
     .make_max_abab_integrals(max_I)
     .make_max_density_elements(max_P,P)
     P_max  = maxval(max_P)
     IP_max = maxval(max_I) * P_max
     res = ZERO
     do ab = 1, .n_shell_pairs
       if (max_I(ab)*IP_max < cutoff)  cycle                         ! Rough Schwarz test, but quick.
       .get_shell_pair_indices(ab,sa,sb,fa,la,fb,lb,atom_a,atom_b)   ! a & b shell indices.
       .copy_shell_quartet_ab(sh,sa,sb)
       do cd = 1,ab
         if (max_I(ab)*max_I(cd)*P_max < cutoff)  cycle              ! Rough Schwarz test
         .get_shell_pair_indices(cd,sc,sd,fc,lc,fd,ld,atom_c,atom_d) ! c & d shell indices.
         ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
         skip = .schwarz_inequality_test(cutoff,ab,cd,sa,sb,sc,sd,max_P,max_I)
         if (skip) cycle
         .copy_shell_quartet_cd(sh,sc,sd)
         ! Evaluate the integrals' coincidence factors
         fac = ONE
         if (sa==sb)            fac = HALF * fac
         if (sc==sd)            fac = HALF * fac
         if (sa==sc AND sb==sd) fac = HALF * fac
         I.create(fa,la,fb,lb,fc,lc,fd,ld)
         sh.get_ERI(I)
         do d = fd,ld
         do c = fc,lc
           P_dc = P(d,c)
           do b = fb,lb
             P_db = P(d,b)
             P_cb = P(c,b)
             do a = fa,la
                dens = FOUR*P(b,a)*P_dc - P(c,a)*P_db - P(d,a)*P_cb
                res  = res + fac * I(a,b,c,d) * dens
             end
           end
           end
         end
         I.destroy
         sh.destroy_cd
       end
       sh.destroy_ab
     end
     max_P.destroy
     max_I.destroy
   end

   the_r_hf_energy_MO_gradient(MO) result(g) ::: selfless
   ! Evaluate the gradient of the restricted Hartree-Fock energy with
   ! respect to the molecular orbitals, (F - SDF) MO N, where "MO" is
   ! the matrix of the occupied molecular orbital coefficients.
     MO :: VEC{REAL}, IN
!    g  :: MAT{REAL}(saved_self.n_bf,saved_self.n_a)
     g  :: VEC{REAL}(saved_self.n_bf*saved_self.n_a)
     self :: MOLECULE*
     self => saved_self
     g = .MAIN:r_hf_energy_MO_gradient(reshape(MO,[.n_bf,.n_a]),make_fock=FALSE)
     ! The fock matrix is not made because in the minimiser the gradient is
     ! only ever called after the energy routine. This saves a fock build.
   end

   r_hf_energy_MO_gradient(MO,make_fock) result(g)
   ! Evaluate the gradient of the restricted Hartree-Fock energy with
   ! respect to the molecular orbitals, 2(2F - SPF) MO N, where "MO" is
   ! the matrix of the occupied molecular orbital coefficients.
   ! If "make_fock" is present and FALSE, the molecular_orbitals are defined
   ! from "MO", the MO's are archived, and the updated density matrix and
   ! fock matrix are not made but assumed to be pre-existing.
     MO :: MAT{REAL}, IN
     make_fock :: BIN, optional
   ENSURE(.scfdata.using_MO_gradient_update,"not allowed")
   ENSURE(MO.dim2==.n_a,"wrong dimension 2, MO")
     g :: VEC{REAL}(.n_bf*.n_a)
     do_fock :: BIN
     W,X,N,S, F,P,g1 :: MAT{REAL}*
     norm :: REAL
     archive :: ARCHIVE
     do_fock = TRUE
     if (present(make_fock)) do_fock = make_fock
     if (do_fock) then ! this assumes that a previous energy was called
        .molecular_orbitals.restricted = MO
        .archive(.molecular_orbitals,"molecular_orbitals")
        .MAIN:make_non_ortho_scf_density ! writes density & occupations to disk
        .make_fock_matrix
     end
     g1.create(.n_bf,.n_a)
     X.create(.n_bf,.n_bf)
     N.create(.n_a ,.n_a )
     S.create(.n_bf,.n_bf)
     W.create(.n_bf,.n_bf)
     F => .fock_matrix.restricted
     P => .density_matrix.restricted
     .get_overlap_matrix
     archive.set(.name,"non_ortho_occupation_matrix",genre="restricted")
     W.to_product_of(.overlap_matrix,P)
     X = -TWO*F
     X.plus_product_of(W,F)
     W.destroy
     X = -X
     S.create(.n_bf,.n_a)
     archive.read(N)
     S.to_product_of(MO,N)
     N.destroy
     g1.to_scaled_product_of(X,S,fac=TWO)
     S.destroy
     X.destroy
     norm = g1.trace_product_with(transpose(g1))
     stdout.show("hf energy gradient =",norm)
     g = reshape(g1,(/size(g)/))
     g1.destroy
   ! stdout.text("g:")
   ! stdout.put(g)
     !
   ! stdout.text("evaluate finite diff g")
   ! e0 = .r_hf_energy(MO)
   ! gg.create(3,3)
   ! do b = 1,3
   ! do i = 1,3
   !    MO(b,i) = MO(b,i) + 0.0005
   !    ep = .r_hf_energy(MO)
   !    MO(b,i) = MO(b,i) - 0.0005
   !    MO(b,i) = MO(b,i) - 0.0005
   !    em = .r_hf_energy(MO)
   !    gg(b,i) = (ep - em)/0.001
   !    MO(b,i) = MO(b,i) + 0.0005
   ! end
   ! end
   ! stdout.text("finite diff g:")
   ! stdout.put(gg)
   ! gg.destroy
   ! stop
   end

   make_non_ortho_scf_density ::: leaky
   ! Make the non orthogonal density matrix from the molecular orbitals.
   ! NOTE: the final computed density matrix is written to an archive.
   ! NOTE: if any old density matrix exists, it is saved in an old archive.
   ! NOTE: the non orthogonal occupation matrix i.e. the back tranform of
   ! the inverse of the MO overlap matrix is written to an archive.
   ENSURE(.basis_info_made, "no basis set")
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
     MO,D,N :: MAT{REAL}*
     orb_kind :: STR
     archive :: ARCHIVE
     ! Determine the kind of density matrix to be made
     if (.scfdata.destroyed) then; orb_kind = .molecular_orbitals.spinorbital_kind
     else;                         orb_kind = .scfdata.spinorbital_kind
     end
     ! Create space for the right kind of density matrix, or save old density matrix
     if (.density_matrix.destroyed(orb_kind)) then; .density_matrix.create(orb_kind)
     else;        .archive(.density_matrix,"old_density_matrix")
     end
     ! Now determine the kind of SCF (if any) associated with the density matrix
     if (.scfdata.destroyed) then; orb_kind = .molecular_orbitals.guess_scf_kind
     else;                         orb_kind = .scfdata.scf_kind
     end
     archive.set(.name,"non_ortho_occupation_matrix")
     select case (orb_kind)
       case ("rhf","restricted_hartree_fock","xray_rhf","noninteracting-group-rhf")
         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.mult==1,"this is not a singlet state")
         MO => .molecular_orbitals.restricted
         D  => .density_matrix.restricted
         N.create(.n_a,.n_a)
         .MAIN:make_r_non_ortho_scf_density(D,MO,N)
         archive.set_genre("restricted")
         archive.write(N)
         N.destroy
       case default
         DIE("unknown SCF kind, "//trim(orb_kind))
     end
     .archive(.density_matrix,"density_matrix")
   end

   make_r_non_ortho_scf_density(P,MO,N) ::: leaky
   ! Make the restricted non-orthogonal density matrix "P" from the molecular
   ! orbitals "MO". The cofactor/occupation matrix "N" is also returned if
   ! required. This density includes a factor of two.
     P,MO,N :: MAT{REAL}
   ENSURE(.basis_info_made, "no basis set")
   ENSURE(P.is_square,"wrong size, P")
   ENSURE(N.is_square,"wrong size, N")
   ENSURE(P.dim1==.n_bf,"wrong size, P")
   ENSURE(N.dim1==.n_a ,"wrong size, N")
   ENSURE(.mult==1,"this is not a singlet state")
   ENSURE(MO.dim2==.n_a,"wrong size, N")
     .get_overlap_matrix
     .overlap_matrix.change_basis_to(N,MO)
    ! stdout.text("N^-1:")
    ! stdout.put(N)
     N.to_inverse_of(N)
    ! stdout.text("N:")
    ! stdout.put(N)
     N.back_transform_to(P,MO)
     P = TWO*P
   end

!   make_r_fock_matrix(F,P,direct,core,r12,test)
!   ! Make a new restricted Fock matrix "F" from the density matrix "P".
!   ! If present and TRUE , "direct" means calculate integrals on the fly
!   ! If present and FALSE, "core" removes the core matrix contribution
!   ! If present and FALSE, "r12"  removes the two electron contribution
!     direct,core,r12,test :: BIN, optional
!     P,F :: MAT{REAL}
!     J,K :: MAT{REAL}*
!     do_direct,add_core,add_r12,do_test :: BIN
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(F.dim1==.n_bf,"wrong shape, F")
!   ENSURE(P.dim1==.n_bf,"wrong shape, P")
!   ENSURE(F.is_square,"wrong shape, P")
!   ENSURE(P.is_square,"wrong shape, P")
!     do_direct= FALSE
!     do_test= FALSE
!     add_core = TRUE
!     add_r12  = TRUE
!     if (present(direct)) do_direct = direct
!     if (present(test))   do_test  = test
!     if (present(core))   add_core = core
!     if (present(r12))    add_r12  = r12
!     if (add_r12) then
!        J.create(.n_bf,.n_bf)
!        K.create(.n_bf,.n_bf)
!        if (do_direct) then; .make_r_JK_direct(J,K,P)
!        else;                .make_r_JK_disk(J,K,P)
!        end
!        F = J - HALF*K
!        K.destroy
!        J.destroy
!     else
!        F = ZERO
!     end
!     if (add_core) .add_core_hamiltonian(F)
!   end

! ********************
! Energy decomposition
! ********************

!   put_energy_decomposition
!   ! Put out the energy decomposition specified in the .atom_group array
!      T,Z,C,K,P,E_T,E_Z,E_C,E_K :: MAT{REAL}*
!      n_group,i,j,ia,ib,a,b, fa,la,fb,lb :: INT
!      fac :: REAL
!      unit :: STR
!      arch1 :: ARCHIVE
!   ENSURE(.atom_group.created,"no atom group information")
!      arch1.set(.name,"density_matrix,restricted")
!   ENSURE(arch1.exists,"no density matrix")
!      P.create(.n_bf,.n_bf)
!      arch1.read(P)
!      .density_matrix.create("restricted")
!      .density_matrix.restricted = P
!      T.create(.n_bf,.n_bf); .get_kinetic_matrix(T)
!      Z.create(.n_bf,.n_bf); .get_nuclear_matrix(Z)
!      C.create(.n_bf,.n_bf)
!      K.create(.n_bf,.n_bf); .make_r_JK_direct(C,K,P)
!      .make_r_fock(direct=TRUE,core=FALSE,r12=TRUE)
!      n_group = size(.atom_group)
!      E_T.create(n_group,n_group); E_T = ZERO
!      E_Z.create(n_group,n_group); E_Z = ZERO
!      E_C.create(n_group,n_group); E_C = ZERO
!      E_K.create(n_group,n_group); E_K = ZERO
!      do i = 1,n_group
!      do j = 1,n_group
!      do ia = 1,size(.atom_group(i).element)
!      do ib = 1,size(.atom_group(j).element)
!         a = .atom_group(i).element(ia)
!         b = .atom_group(j).element(ib)
!         fa = .first_basis_fn_for_atom(a)
!         la = .last_basis_fn_for_atom(a)
!         fb = .first_basis_fn_for_atom(b)
!         lb = .last_basis_fn_for_atom(b)
!         fac = ONE
!       ! if (i/=j) fac = TWO
!         E_T(i,j) = E_T(i,j) + fac*T(fa:la,fb:lb).trace_product_with(P(fb:lb,fa:la))
!         E_Z(i,j) = E_Z(i,j) + fac*Z(fa:la,fb:lb).trace_product_with(P(fb:lb,fa:la))
!         E_C(i,j) = E_C(i,j) + fac*C(fa:la,fb:lb).trace_product_with(P(fb:lb,fa:la))
!         E_K(i,j) = E_K(i,j) - fac*K(fa:la,fb:lb).trace_product_with(P(fb:lb,fa:la))
!      end
!      end
!      end
!      end
!      E_C = HALF*E_C
!      E_K = HALF*HALF*E_K
!      stdout.text(" ")
!      stdout.text("F:")
!      stdout.put(.fock_matrix.restricted)
!      stdout.text(" ")
!      stdout.text("C-K/2:")
!      stdout.put(C-HALF*K)
!      stdout.text(" ")
!      stdout.text("Energy decomposition in AU ...")
!      stdout.text(" ")
!      stdout.text("Kinetic interaction terms")
!      stdout.put(E_T)
!      stdout.text(" ")
!      stdout.text("Nuclear attraction interaction terms")
!      stdout.put(E_Z)
!      stdout.text(" ")
!      stdout.text("Coulomb repulsion interaction terms")
!      stdout.put(E_C)
!      stdout.text(" ")
!      stdout.text("Exchange interaction terms")
!      stdout.put(E_K)
!      stdout.text(" ")
!      fac = sum(E_T+E_Z+E_C+E_K)
!      stdout.show("SCF electronic energy =",fac)
!      stdout.show("SCF energy            =",fac+.atom.nuclear_energy)
!      stdout.show("Kinetic energy        =",sum(E_T))
!      !
!      unit = "kcal/mol"
!      fac = unit.conversion_factor
!      E_T = fac*E_T
!      E_Z = fac*E_Z
!      E_C = fac*E_C
!      E_K = fac*E_K
!      stdout.text(" ")
!      stdout.text("Energy decomposition in kcal/mol ...")
!      stdout.text(" ")
!      stdout.text("Kinetic interaction terms")
!      stdout.put(E_T)
!      stdout.text(" ")
!      stdout.text("Nuclear attraction interaction terms")
!      stdout.put(E_Z)
!      stdout.text(" ")
!      stdout.text("Coulomb repulsion interaction terms")
!      stdout.put(E_C)
!      stdout.text(" ")
!      stdout.text("Exchange interaction terms")
!      stdout.put(E_K)
!      stdout.text(" ")
!      E_K.destroy
!      E_C.destroy
!      E_Z.destroy
!      E_T.destroy
!      K.destroy
!      C.destroy
!      Z.destroy
!      T.destroy
!   end
!
!   put_energy_partition
!   ! Put out the energy decomposition specified in the .atom_group array
!   ! This routine calculates quadricentric contributions which are
!   ! comparable to the Fischer-Kollmar decomposition.
!      T,Z,ZZ,C,K,P,W,E_T,E_Z, EE :: MAT{REAL}*
!      E_ZZ :: MAT3{REAL}*
!      E_C,E_K :: MAT4{REAL}*
!      n_group,x,y,i,j :: INT
!      fac :: REAL
!      unit :: STR
!      arch1 :: ARCHIVE
!      kinetic_energy,nuclear_attraction,nuclear_repulsion :: REAL
!      coulomb_repulsion,net_coulomb,bicentric_exchange :: REAL
!      exchange_attraction,total_interaction :: REAL
!   ENSURE(.atom_group.created,"no atom group information")
!      arch1.set(.name,"density_matrix,restricted")
!   ENSURE(arch1.exists,"no density matrix")
!      P.create(.n_bf,.n_bf)
!      arch1.read(P)
!      W.create(.n_bf,.n_bf)
!      T.create(.n_bf,.n_bf); .get_kinetic_matrix(T)
!      Z.create(.n_bf,.n_bf); .get_nuclear_matrix(Z)
!      n_group = size(.atom_group)
!      E_T.create(n_group,n_group); E_T = ZERO
!      E_Z.create(n_group,n_group); E_Z = ZERO
!      E_C.create(n_group,n_group,n_group,n_group); E_C = ZERO
!      E_K.create(n_group,n_group,n_group,n_group); E_K = ZERO
!      E_ZZ.create(n_group,n_group,n_group); E_ZZ = ZERO
!      ZZ.create(.n_bf,.n_bf)
!         do i = 1,n_group
!         do j = 1,i
!            W = ZERO
!            .atom_group_AO_subspace_set(W,P,i,j)
!            if (i/=j) &
!            .atom_group_AO_subspace_set(W,P,j,i)
!            E_T(i,j) = T.trace_product_with(W)
!            E_Z(i,j) = Z.trace_product_with(W)
!            do x = 1,n_group
!               .make_nuclear_matrix(ZZ,.atom_group(x).element)
!               E_ZZ(i,j,x) = ZZ.trace_product_with(W)
!            end
!         end
!         end
!      ZZ.destroy
!      C.create(.n_bf,.n_bf)
!      K.create(.n_bf,.n_bf)
!      do x = 1,n_group
!      do y = 1,x
!         .make_r_JK_group(C,K,P,x,y)
!         do i = 1,n_group
!         do j = 1,i
!            W = ZERO
!            .atom_group_AO_subspace_set(W,P,i,j)
!            if (i/=j) &
!            .atom_group_AO_subspace_set(W,P,j,i)
!            E_C(i,j,x,y) =  C.trace_product_with(W)
!            E_K(i,j,x,y) = -K.trace_product_with(W)
!         end
!         end
!      end
!      end
!      K.destroy
!      C.destroy
!      E_C = HALF*E_C
!      E_K = HALF*HALF*E_K
!      EE.create(n_group,n_group)
!      !
!      stdout.text(" ")
!      fac = sum(E_T+E_Z) + sum(E_C+E_K)
!      stdout.show("SCF electronic energy =",fac)
!      stdout.show("SCF energy            =",fac+.atom.nuclear_energy)
!      stdout.show("Kinetic energy        =",sum(E_T))
!!     stdout.text(" ")
!!     stdout.text("Energy decomposition in AU ...")
!!     stdout.text(" ")
!!     stdout.text("Kinetic interaction terms")
!!     stdout.put(E_T)
!!     stdout.text(" ")
!!     stdout.text("Nuclear attraction interaction terms")
!!     stdout.put(E_Z)
!!     stdout.text(" ")
!!     stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
!!     stdout.put(E_ZZ(:,:,1))
!!     stdout.text(" ")
!!     stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
!!     stdout.put(E_ZZ(:,:,2))
!!     EE(1,1) = .atom(.atom_group(1).element).nuclear_energy
!!     EE(2,2) = .atom(.atom_group(2).element).nuclear_energy
!!     EE(2,1) = .atom.nuclear_energy - EE(1,1) - EE(2,2)
!!     EE(1,2) = ZERO
!!     stdout.text(" ")
!!     stdout.text("Nuclear nuclear repulsion")
!!     stdout.put(EE)
!!     EE(1,1) = E_C(1,1,1,1)
!!     EE(2,1) = E_C(2,2,1,1)
!!     EE(1,2) = E_C(1,1,2,2)
!!     EE(2,2) = E_C(2,2,2,2)
!!     stdout.text(" ")
!!     stdout.text("Diagonal Coulomb repulsion interaction terms")
!!     stdout.put(EE)
!!     EE(1,1) = E_C(1,2,1,1)
!!     EE(2,1) = E_C(2,1,1,1)
!!     EE(1,2) = E_C(1,2,2,2)
!!     EE(2,2) = E_C(2,1,2,2)
!!     stdout.text(" ")
!!     stdout.text("Semi diagonal Coulomb repulsion interaction terms")
!!     stdout.put(EE)
!!     EE(1,1) = E_C(1,2,1,2)
!!     EE(2,1) = E_C(2,1,1,2)
!!     EE(1,2) = E_C(1,2,2,1)
!!     EE(2,2) = E_C(2,1,2,1)
!!     stdout.text(" ")
!!     stdout.text("Off diagonal Coulomb repulsion interaction terms")
!!     stdout.put(EE)
!!     stdout.text(" ")
!!     stdout.text("All Coulomb repulsion interaction terms")
!!     stdout.put(E_C)
!!     EE(1,1) = E_K(1,1,1,1)
!!     EE(2,1) = E_K(2,2,1,1)
!!     EE(1,2) = E_K(1,1,2,2)
!!     EE(2,2) = E_K(2,2,2,2)
!!     stdout.text(" ")
!!     stdout.text("Diagonal exchange interaction terms")
!!     stdout.put(EE)
!!     EE(1,1) = E_K(1,2,1,1)
!!     EE(2,1) = E_K(2,1,1,1)
!!     EE(1,2) = E_K(1,2,2,2)
!!     EE(2,2) = E_K(2,1,2,2)
!!     stdout.text(" ")
!!     stdout.text("Semi diagonal exchange interaction terms")
!!     stdout.put(EE)
!!     EE(1,1) = E_K(1,2,1,2)
!!     EE(2,1) = E_K(2,1,1,2)
!!     EE(1,2) = E_K(1,2,2,1)
!!     EE(2,2) = E_K(2,1,2,1)
!!     stdout.text(" ")
!!     stdout.text("Off diagonal exchange interaction terms")
!!     stdout.put(EE)
!!     stdout.text(" ")
!!     stdout.text("All exchange interaction terms")
!!     stdout.put(E_K)
!      !
!      unit = "kcal/mol"
!      fac = unit.conversion_factor
!      E_T = fac*E_T
!      E_Z = fac*E_Z
!      E_C = fac*E_C
!      E_K = fac*E_K
!      E_ZZ = fac*E_ZZ
!      stdout.text(" ")
!      stdout.text("Energy decomposition in kcal/mol ...")
!      stdout.text(" ")
!      stdout.text("Kinetic interaction terms")
!      stdout.put(E_T)
!      stdout.text(" ")
!      stdout.text("Nuclear attraction interaction terms")
!      stdout.put(E_Z)
!      stdout.text(" ")
!      stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
!      stdout.put(E_ZZ(:,:,1))
!      stdout.text(" ")
!      stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
!      stdout.put(E_ZZ(:,:,2))
!      EE(1,1) = fac*.atom(.atom_group(1).element).nuclear_energy
!      EE(2,2) = fac*.atom(.atom_group(2).element).nuclear_energy
!      nuclear_repulsion = fac*.atom.nuclear_energy - EE(1,1) - EE(2,2)
!      EE(2,1) = nuclear_repulsion
!      EE(1,2) = ZERO
!      stdout.text(" ")
!      stdout.text("Nuclear nuclear repulsion")
!      stdout.put(EE)
!      EE(1,1) = E_C(1,1,1,1)
!      EE(2,1) = E_C(2,2,1,1)
!      EE(1,2) = E_C(1,1,2,2)
!      EE(2,2) = E_C(2,2,2,2)
!      stdout.text(" ")
!      stdout.text("Diagonal Coulomb repulsion interaction terms")
!      stdout.put(EE)
!      EE(1,1) = E_C(1,2,1,1)
!      EE(2,1) = E_C(2,1,1,1)
!      EE(1,2) = E_C(1,2,2,2)
!      EE(2,2) = E_C(2,1,2,2)
!      stdout.text(" ")
!      stdout.text("Semi diagonal Coulomb repulsion interaction terms")
!      stdout.put(EE)
!      EE(1,1) = E_C(1,2,1,2)
!      EE(2,1) = E_C(2,1,1,2)
!      EE(1,2) = E_C(1,2,2,1)
!      EE(2,2) = E_C(2,1,2,1)
!      stdout.text(" ")
!      stdout.text("Off diagonal Coulomb repulsion interaction terms")
!      stdout.put(EE)
!      stdout.text(" ")
!      stdout.text("All Coulomb repulsion interaction terms")
!      stdout.put(E_C)
!      EE(1,1) = E_K(1,1,1,1)
!      EE(2,1) = E_K(2,2,1,1)
!      EE(1,2) = E_K(1,1,2,2)
!      EE(2,2) = E_K(2,2,2,2)
!      stdout.text(" ")
!      stdout.text("Diagonal exchange interaction terms")
!      stdout.put(EE)
!      EE(1,1) = E_K(1,2,1,1)
!      EE(2,1) = E_K(2,1,1,1)
!      EE(1,2) = E_K(1,2,2,2)
!      EE(2,2) = E_K(2,1,2,2)
!      stdout.text(" ")
!      stdout.text("Semi diagonal exchange interaction terms")
!      stdout.put(EE)
!      EE(1,1) = E_K(1,2,1,2)
!      EE(2,1) = E_K(2,1,1,2)
!      EE(1,2) = E_K(1,2,2,1)
!      EE(2,2) = E_K(2,1,2,1)
!      stdout.text(" ")
!      stdout.text("Off diagonal exchange interaction terms")
!      stdout.put(EE)
!      stdout.text(" ")
!      stdout.text("All exchange interaction terms")
!      stdout.put(E_K)
!      kinetic_energy = E_T(2,1)
!      nuclear_attraction = sum(E_Z) - E_ZZ(1,1,1) - E_ZZ(2,2,2)
!      coulomb_repulsion = sum(E_C) - E_C(1,1,1,1) - E_C(2,2,2,2)
!      net_coulomb = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
!      bicentric_exchange = E_K(1,1,2,2) + E_K(2,2,1,1)
!      exchange_attraction = sum(E_K) - E_K(1,1,1,1) - E_K(2,2,2,2)
!      total_interaction = kinetic_energy + net_coulomb + exchange_attraction
!      stdout.text(" ")
!      stdout.text("Interaction energies for "//trim(.name)//":")
!      stdout.text(" ")
!      stdout.show("Kinetic energy     =",kinetic_energy)
!      stdout.show("Exchange energy    =",exchange_attraction)
!      stdout.show("Kinetic + Exhange  =",kinetic_energy+exchange_attraction)
!      stdout.show("Bicentric Exchange =",bicentric_exchange)
!      stdout.show("Net Coulomb energy =",net_coulomb)
!      stdout.show("Total int. energy  =",total_interaction)
!      EE.destroy
!      E_ZZ.destroy
!      E_K.destroy
!      E_C.destroy
!      E_Z.destroy
!      E_T.destroy
!      Z.destroy
!      T.destroy
!      W.destroy
!      P.destroy
!   end
!
!   put_ortho_energy_partition
!   ! Put out the energy decomposition specified in the .atom_group array
!   ! This routine calculates quadricentric contributions which are
!   ! comparable to the Fischer-Kollmar decomposition in an orthogonalised
!   ! AO basis set
!      T,Z,ZZ,C,K,P,PP,W,E_T,E_Z, S,Sph,Smh, EE :: MAT{REAL}*
!      E_ZZ :: MAT3{REAL}*
!      E_C,E_K :: MAT4{REAL}*
!      n_group,i,j,g,h, fa,la,fb,lb :: INT
!      fac,fac_ij,fac_xy :: REAL
!      unit :: STR
!      arch1 :: ARCHIVE
!      kinetic_energy,nuclear_attraction,nuclear_repulsion :: REAL
!      coulomb_repulsion,net_coulomb,bicentric_exchange :: REAL
!      exchange_attraction,total_interaction :: REAL
!   ENSURE(.atom_group.created,"no atom group information")
!      arch1.set(.name,"density_matrix,restricted")
!   ENSURE(arch1.exists,"no density matrix")
!      P.create(.n_bf,.n_bf)
!      PP.create(.n_bf,.n_bf)
!      arch1.read(P)
!      W.create(.n_bf,.n_bf)
!      T.create(.n_bf,.n_bf); .get_kinetic_matrix(T)
!      Z.create(.n_bf,.n_bf); .get_nuclear_matrix(Z)
!      S.create(.n_bf,.n_bf); .get_overlap_matrix(S)
!      Sph.create(.n_bf,.n_bf); Sph.to_sqrt(S)
!      Smh.create(.n_bf,.n_bf); Smh.to_inverse_sqrt(S)
!      n_group = size(.atom_group)
!      E_T.create(n_group,n_group); E_T = ZERO
!      E_Z.create(n_group,n_group); E_Z = ZERO
!      E_C.create(n_group,n_group,n_group,n_group); E_C = ZERO
!      E_K.create(n_group,n_group,n_group,n_group); E_K = ZERO
!      E_ZZ.create(n_group,n_group,n_group); E_ZZ = ZERO
!      ZZ.create(.n_bf,.n_bf)
!      PP = P
!      PP.change_basis_using(Sph)
!         do i = 1,n_group
!         do j = 1,i
!            W = ZERO
!            .atom_group_AO_subspace_set(W,PP,i,j)
!            if (i/=j) &
!            .atom_group_AO_subspace_set(W,PP,j,i)
!            W.change_basis_using(Smh)
!            E_T(i,j) = T.trace_product_with(W)
!            E_Z(i,j) = Z.trace_product_with(W)
!            do g = 1,n_group
!               .make_nuclear_matrix(ZZ,.atom_group(g).element)
!               E_ZZ(i,j,g) = ZZ.trace_product_with(W)
!            end
!         end
!         end
!      ZZ.destroy
!      C.create(.n_bf,.n_bf)
!      K.create(.n_bf,.n_bf)
!      do g = 1,n_group
!      do h = 1,g
!         W = ZERO
!         .atom_group_AO_subspace_set(W,PP,g,h)
!         if (g/=h) &
!         .atom_group_AO_subspace_set(W,PP,h,g)
!         W.change_basis_using(Smh)
!         .make_r_JK_nosym(C,K,W)
!         do i = 1,n_group
!         do j = 1,i
!            W = ZERO
!            .atom_group_AO_subspace_set(W,PP,i,j)
!            if (i/=j) &
!            .atom_group_AO_subspace_set(W,PP,j,i)
!            W.change_basis_using(Smh)
!            E_C(i,j,g,h) =  C.trace_product_with(W)
!            E_K(i,j,g,h) = -K.trace_product_with(W)
!         end
!         end
!      end
!      end
!      K.destroy
!      C.destroy
!      E_C = HALF*E_C
!      E_K = HALF*HALF*E_K
!      EE.create(n_group,n_group)
!      !
!      stdout.text(" ")
!      fac = sum(E_T+E_Z) + sum(E_C+E_K)
!      stdout.show("SCF electronic energy =",fac)
!      stdout.show("SCF energy            =",fac+.atom.nuclear_energy)
!      stdout.show("Kinetic energy        =",sum(E_T))
!      !
!      unit = "kcal/mol"
!      fac = unit.conversion_factor
!      E_T = fac*E_T
!      E_Z = fac*E_Z
!      E_C = fac*E_C
!      E_K = fac*E_K
!      E_ZZ = fac*E_ZZ
!      stdout.text(" ")
!      stdout.text("Energy decomposition in kcal/mol ...")
!      stdout.text(" ")
!      stdout.text("Kinetic interaction terms")
!      stdout.put(E_T)
!      stdout.text(" ")
!      stdout.text("Nuclear attraction interaction terms")
!      stdout.put(E_Z)
!      stdout.text(" ")
!      stdout.text("Nuclear attraction interaction terms ONLY for group 1 nuclei")
!      stdout.put(E_ZZ(:,:,1))
!      stdout.text(" ")
!      stdout.text("Nuclear attraction interaction terms ONLY for group 2 nuclei")
!      stdout.put(E_ZZ(:,:,2))
!      EE(1,1) = fac*.atom(.atom_group(1).element).nuclear_energy
!      EE(2,2) = fac*.atom(.atom_group(2).element).nuclear_energy
!      nuclear_repulsion = fac*.atom.nuclear_energy - EE(1,1) - EE(2,2)
!      EE(2,1) = nuclear_repulsion
!      EE(1,2) = ZERO
!      stdout.text(" ")
!      stdout.text("Nuclear nuclear repulsion")
!      stdout.put(EE)
!      EE(1,1) = E_C(1,1,1,1)
!      EE(2,1) = E_C(2,2,1,1)
!      EE(1,2) = E_C(1,1,2,2)
!      EE(2,2) = E_C(2,2,2,2)
!      stdout.text(" ")
!      stdout.text("Diagonal Coulomb repulsion interaction terms")
!      stdout.put(EE)
!      EE(1,1) = E_C(1,2,1,1)
!      EE(2,1) = E_C(2,1,1,1)
!      EE(1,2) = E_C(1,2,2,2)
!      EE(2,2) = E_C(2,1,2,2)
!      stdout.text(" ")
!      stdout.text("Semi diagonal Coulomb repulsion interaction terms")
!      stdout.put(EE)
!      EE(1,1) = E_C(1,2,1,2)
!      EE(2,1) = E_C(2,1,1,2)
!      EE(1,2) = E_C(1,2,2,1)
!      EE(2,2) = E_C(2,1,2,1)
!      stdout.text(" ")
!      stdout.text("Off diagonal Coulomb repulsion interaction terms")
!      stdout.put(EE)
!      stdout.text(" ")
!      stdout.text("All Coulomb repulsion interaction terms")
!      stdout.put(E_C)
!      EE(1,1) = E_K(1,1,1,1)
!      EE(2,1) = E_K(2,2,1,1)
!      EE(1,2) = E_K(1,1,2,2)
!      EE(2,2) = E_K(2,2,2,2)
!      stdout.text(" ")
!      stdout.text("Diagonal exchange interaction terms")
!      stdout.put(EE)
!      EE(1,1) = E_K(1,2,1,1)
!      EE(2,1) = E_K(2,1,1,1)
!      EE(1,2) = E_K(1,2,2,2)
!      EE(2,2) = E_K(2,1,2,2)
!      stdout.text(" ")
!      stdout.text("Semi diagonal exchange interaction terms")
!      stdout.put(EE)
!      EE(1,1) = E_K(1,2,1,2)
!      EE(2,1) = E_K(2,1,1,2)
!      EE(1,2) = E_K(1,2,2,1)
!      EE(2,2) = E_K(2,1,2,1)
!      stdout.text(" ")
!      stdout.text("Off diagonal exchange interaction terms")
!      stdout.put(EE)
!      stdout.text(" ")
!      stdout.text("All exchange interaction terms")
!      stdout.put(E_K)
!      kinetic_energy = E_T(2,1)
!      nuclear_attraction = sum(E_Z) - E_ZZ(1,1,1) - E_ZZ(2,2,2)
!      coulomb_repulsion = sum(E_C) - E_C(1,1,1,1) - E_C(2,2,2,2)
!      net_coulomb = nuclear_attraction + nuclear_repulsion + coulomb_repulsion
!      bicentric_exchange = E_K(1,1,2,2) + E_K(2,2,1,1)
!      exchange_attraction = sum(E_K) - E_K(1,1,1,1) - E_K(2,2,2,2)
!      total_interaction = kinetic_energy + net_coulomb + exchange_attraction
!      stdout.text(" ")
!      stdout.text("Interaction energies for "//trim(.name)//":")
!      stdout.text(" ")
!      stdout.show("Kinetic energy     =",kinetic_energy)
!      stdout.show("Exchange energy    =",exchange_attraction)
!      stdout.show("Kinetic + Exhange  =",kinetic_energy+exchange_attraction)
!      stdout.show("Bicentric Exchange =",bicentric_exchange)
!      stdout.show("Net Coulomb energy =",net_coulomb)
!      stdout.show("Total int. energy  =",total_interaction)
!      EE.destroy
!      E_ZZ.destroy
!      E_K.destroy
!      E_C.destroy
!      E_Z.destroy
!      E_T.destroy
!      Smh.destroy
!      Sph.destroy
!      S.destroy
!      Z.destroy
!      T.destroy
!      W.destroy
!      PP.destroy
!      P.destroy
!   end
!
!   make_r_JK_group(J,K,P,row_group,col_group)
!   ! Make the real coulomb matrix "J" and exchange matrix "K" matrix from the
!   ! density matrix "P" which is non-zero only for rows belonging to basis
!   ! functions on atoms in group "row_group" and also columns for basis functions
!   ! on atoms in the "col_group", as specified in ".atom_group".
!     J,K,P :: MAT{REAL}
!     row_group,col_group :: INT
!     PP :: MAT{REAL}*
!      I :: MAT4{REAL}*
!     max_I,max_P :: VEC{REAL}*
!     sh4 :: SHELL4
!     ab,cd,i_a,i_b,i_c,i_d :: INT
!     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     I_abcd,factor,cutoff :: REAL
!     skip :: BIN
!   ENSURE(.atom_group.created,"no atom group information")
!   ENSURE(row_group<=size(.atom_group),"no such row group")
!   ENSURE(col_group<=size(.atom_group),"no such column group")
!   ENSURE(row_group>0,"row group index must be positive")
!   ENSURE(col_group>0,"column group index must be positive")
!     J = ZERO
!     K = ZERO
!     cutoff = SCFDATA_ERI_LIMIT
!     PP.create(.n_bf,.n_bf)
!     PP = ZERO
!     .atom_group_AO_subspace_set(PP,P,row_group,col_group)
!     if (row_group/=col_group) &
!     .atom_group_AO_subspace_set(PP,P,col_group,row_group)
!     max_I.create(.n_shell_pairs)
!     max_P.create(.n_shell_pairs)
!     .make_max_abab_integrals(max_I)
!     .make_max_density_elements(max_P,PP)
!     do ab = 1, .n_shell_pairs
!       .get_shell_pair_indices(ab,i_a,i_b)    ! a & b shell indices.
!       fa = .first_basis_fn_for_shell(i_a)
!       fb = .first_basis_fn_for_shell(i_b)
!       la = .last_basis_fn_for_shell(i_a)
!       lb = .last_basis_fn_for_shell(i_b)
!       .set_shell_quartet_ab(sh4,i_a,i_b)
!       do cd = 1,ab
!         .get_shell_pair_indices(cd,i_c,i_d)  ! c & d shell indices.
!         fc = .first_basis_fn_for_shell(i_c)
!         fd = .first_basis_fn_for_shell(i_d)
!         lc = .last_basis_fn_for_shell(i_c)
!         ld = .last_basis_fn_for_shell(i_d)
!                                        ! ab|cd < sqrt(ab|ab) * sqrt(cd|cd) test.
!         skip = .schwarz_inequality_test(cutoff,ab,cd,i_a,i_b,i_c,i_d,max_P,max_I)
!         if (skip) cycle
!                                              ! calculate ab|cd
!         .set_shell_quartet_cd(sh4,i_c,i_d)
!         factor = ONE                         ! Evaluate the integrals'
!         if (i_a==i_b) factor = HALF          ! coincidence factors
!         if (i_c==i_d) factor = HALF * factor
!         if (i_a==i_c AND i_b==i_d) factor = HALF * factor
!         I.create(fa,la,fb,lb,fc,lc,fd,ld)
!         sh4.get_ERI(I)
!           do d = fd,ld
!           do c = fc,lc
!           do b = fb,lb
!           do a = fa,la
!            I_abcd = factor * I(a,b,c,d)
!            J(a,b) = J(a,b) + I_abcd*PP(d,c) ! These are symmetric
!            J(a,b) = J(a,b) + I_abcd*PP(c,d)
!            J(b,a) = J(b,a) + I_abcd*PP(d,c)
!            J(b,a) = J(b,a) + I_abcd*PP(c,d)
!            J(c,d) = J(c,d) + I_abcd*PP(b,a)
!            J(c,d) = J(c,d) + I_abcd*PP(a,b)
!            J(d,c) = J(d,c) + I_abcd*PP(b,a)
!            J(d,c) = J(d,c) + I_abcd*PP(a,b)
!            K(a,d) = K(a,d) + I_abcd*PP(b,c) ! These are asymmetric
!            K(a,c) = K(a,c) + I_abcd*PP(b,d)
!            K(b,c) = K(b,c) + I_abcd*PP(a,d)
!            K(b,d) = K(b,d) + I_abcd*PP(a,c)
!            K(d,a) = K(d,a) + I_abcd*PP(c,b)
!            K(c,a) = K(c,a) + I_abcd*PP(d,b)
!            K(c,b) = K(c,b) + I_abcd*PP(d,a)
!            K(d,b) = K(d,b) + I_abcd*PP(c,a)
!           end
!           end
!           end
!           end
!         I.destroy
!         sh4.destroy_cd
!       end
!       sh4.destroy_ab
!     end
!     max_P.destroy
!     max_I.destroy
!     PP.destroy
!   end

! *************
! B field stuff
! *************

!   make_pcc_b_field
!   !
!      n_pt,i,j,n, k :: INT
!      aa,bb,cc :: REAL
!      pt :: MAT{REAL}*
!      dma :: MAT3{CPX}*
!      re,im :: REAL
!      n_pt = 59*75
!    ! n_pt = 25
!      pt.create(n_pt,3)
!      aa=7.4/sqrt(2.0)
!    ! aa=0.4/sqrt(2.0)
!      bb=0.2/sqrt(2.0)
!      n = 0
!      do i=1,75
!         cc=5.4
!    !    cc=0.6
!         do j=1,59
!            n = n+1
!            cc = cc - 0.2
!            pt(n,1)= aa
!            pt(n,2)=-aa
!            pt(n,3)= cc
!         end
!         aa = aa-bb
!      end
!      dma.create(160,160,4)
!      open(unit=99,file='opdens.c',form='formatted',status='old')
!      do i=1,160
!      do j=1,160
!         do k=1,4
!            read(99,*) re,im
!            dma(i,j,k) = cmplx(re,im,kind=CPX_KIND)
!         enddo
!      enddo
!      enddo
!      close(99)
!      .density_matrix.destroy("general_complex")
!      .density_matrix.create(160,"general_complex")
!      .density_matrix.general_complex.alpha_alpha_set_to(dma(:,:,1))
!      .density_matrix.general_complex.alpha_beta_set_to(dma(:,:,2))
!      .density_matrix.general_complex.beta_alpha_set_to(dma(:,:,3))
!      .density_matrix.general_complex.beta_beta_set_to(dma(:,:,4))
!      dma.destroy
!      .make_b_field_grid(pt)
!      pt.destroy
!   end
!
!   make_b_field_grid(pt)
!   ! Make the total b_field "b" on ".plot_grid"
!      pt :: MAT{REAL}
!      archive :: ARCHIVE
!      b,w :: MAT{REAL}*
!      complex :: BIN
!      n_pt :: INT
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE( .density_matrix.created, "no density matrix")
!      complex = .density_matrix.spinorbital_kind == "general_complex"
!   ENSURE(complex, "no general complex density matrix")
!      .make_spin_b_field_grid(pt)
!      .make_current_b_field_grid(pt)
!      n_pt = size(pt,1)
!      b.create(n_pt,3)
!      w.create(n_pt,3)
!      archive.set(.name,"spin_b_field_density_grid")
!      archive.read(b)
!      b = 0
!      archive.set(.name,"current_b_field_density_grid")
!      archive.read(w)
!      b = b + w
!      w.destroy
!      archive.set(.name,"b_field_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1)
!      archive.set(.name,"b_fie7d_norm_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
!      archive.set(.name,"b_field_density_grid,normalised,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
!      b.destroy
!   end
!
!   make_spin_b_field_grid(pt)
!   ! Make the b_field due to the spin density on ".plot_grid"
!      pt :: MAT{REAL}
!      archive :: ARCHIVE
!       b :: MAT{REAL}*
!      complex :: BIN
!      n_pt :: INT
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE( .density_matrix.created, "no density matrix")
!      complex = .density_matrix.spinorbital_kind == "general_complex"
!   ENSURE(complex, "no general complex density matrix")
!      n_pt = size(pt,1)
!      b.create(n_pt,3)
!      .make_spin_b_field_grid(b,.density_matrix.general_complex,pt)
!      archive.set(.name,"spin_b_field_density_grid")
!      archive.write(b)
!      archive.set(.name,"spin_b_field_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1)
!      archive.set(.name,"spin_b_field_norm_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
!      archive.set(.name,"spin_b_field_density_grid,normalised,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
!      b.destroy
!   end
!
!   make_spin_b_field_grid(bb,dens,pt)
!   ! Make the b_field "bb" due to the spin density on ".plot_grid" using complex general
!   ! AO density matrix "dens"
!      bb,pt :: MAT{REAL}
!      dens :: MAT{CPX}, target
!      Daa,Dba,Dbb :: MAT{CPX}*
!      Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz :: MAT{REAL}*
!      q,a,b,fa,fb,la,lb,k, n_pt :: INT
!      fac :: REAL
!      shell :: SHELL2
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE( .atom.created,  "no atom list")
!      n_pt = size(pt,1)
!      bb = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
!        Daa => dens(fb:lb,fa:la) ! alpha-alpha block
!        fb = fb + .n_bf
!        lb = lb + .n_bf
!        Dba => dens(fb:lb,fa:la) ! beta-alpha block
!        fa = fa + .n_bf
!        la = la + .n_bf
!        Dbb => dens(fb:lb,fa:la) ! beta-beta block
!        fac = ONE; if (a==b) fac=HALF
!        Mxx.create(shell.a.n_comp,shell.b.n_comp)
!        Mxy.create(shell.a.n_comp,shell.b.n_comp)
!        Mxz.create(shell.a.n_comp,shell.b.n_comp)
!        Myx.create(shell.a.n_comp,shell.b.n_comp)
!        Myy.create(shell.a.n_comp,shell.b.n_comp)
!        Myz.create(shell.a.n_comp,shell.b.n_comp)
!        Mzx.create(shell.a.n_comp,shell.b.n_comp)
!        Mzy.create(shell.a.n_comp,shell.b.n_comp)
!        Mzz.create(shell.a.n_comp,shell.b.n_comp)
!        do k = 1,n_pt
!          shell.make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,pt(k,:))
!          bb(k,1) = bb(k,1) + Mxx.trace_of_product( real(Dba))
!          bb(k,1) = bb(k,1) + Mxy.trace_of_product(aimag(Dba))
!          bb(k,1) = bb(k,1) + fac*Mxz.trace_of_product(real(Daa))
!          bb(k,1) = bb(k,1) - fac*Mxz.trace_of_product(real(Dbb))
!          bb(k,2) = bb(k,2) + Myx.trace_of_product( real(Dba))
!          bb(k,2) = bb(k,2) - Myy.trace_of_product(aimag(Dba))
!          bb(k,2) = bb(k,2) + fac*Myz.trace_of_product(real(Daa))
!          bb(k,2) = bb(k,2) - fac*Myz.trace_of_product(real(Dbb))
!          bb(k,3) = bb(k,3) + Mzx.trace_of_product( real(Dba))
!          bb(k,3) = bb(k,3) + Mzy.trace_of_product(aimag(Dba))
!          bb(k,3) = bb(k,3) + fac*Mzz.trace_of_product(real(Daa))
!          bb(k,3) = bb(k,3) - fac*Mzz.trace_of_product(real(Dbb))
!        end
!        Mzz.destroy; Mzy.destroy; Mzx.destroy
!        Myz.destroy; Myy.destroy; Myx.destroy
!        Mxz.destroy; Mxy.destroy; Mxx.destroy
!        shell.destroy_ptr_part
!      end
!      bb.zero_small_values(TOL(10))
!      fac = -G_FACTOR*HALF
!      bb = fac*bb
!   end
!
!   make_current_b_field_grid(pt)
!   ! Make the b_field due to the current density on ".plot_grid"
!      pt :: MAT{REAL}
!      archive :: ARCHIVE
!       b :: MAT{REAL}*
!      complex :: BIN
!      n_pt :: INT
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.density_matrix.created, "no density matrix")
!      .make_ao_density_matrix
!      complex = .density_matrix.spinorbital_kind.includes("complex")
!   ENSURE(complex, "no complex density matrix")
!      n_pt = size(pt,1)
!      b.create(n_pt,3)
!      .make_current_b_field_grid(b,.density_matrix.restricted_complex,pt)
!      archive.set(.name,"current_b_field_density_grid")
!      archive.write(b)
!      archive.set(.name,"current_b_field_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1)
!      archive.set(.name,"current_b_field_norm_density_grid,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, norm=TRUE)
!      archive.set(.name,"current_b_field_density_grid,normalised,gnuplot",format="ascii")
!      archive.write_gnuplot(b,75,59, 1, normalise=TRUE)
!      b.destroy
!   end
!
!   make_current_b_field_grid(bb,dens,pt)
!   ! Make the magnetic field B field "bb" due to the paramagnetic current
!   ! density at a set of points "pt" using a complex AO density matrix "dens"
!      bb,pt :: MAT{REAL}
!      dens :: MAT{CPX}, target
!      Dba :: MAT{CPX}*
!      Jx,Jy,Jz :: MAT{REAL}*
!      q,a,b,fa,fb,la,lb,k, n_pt :: INT
!      fac :: REAL
!      shell :: SHELL2
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE( .atom.created,  "no atom list")
!      n_pt = size(pt,1)
!      bb = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
!        Dba => dens(fb:lb,fa:la)
!        fac = ONE; if (a==b) fac=HALF
!        Jx.create(shell.a.n_comp,shell.b.n_comp)
!        Jy.create(shell.a.n_comp,shell.b.n_comp)
!        Jz.create(shell.a.n_comp,shell.b.n_comp)
!        do k = 1,n_pt
!          shell.make_magnetic_jp_ints(Jx,Jy,Jz,pt(k,:))
!          bb(k,1) = bb(k,1) + Jx.trace_of_product(aimag(Dba))
!          bb(k,2) = bb(k,2) + Jy.trace_of_product(aimag(Dba))
!          bb(k,3) = bb(k,3) + Jz.trace_of_product(aimag(Dba))
!        end
!        Jz.destroy; Jy.destroy; Jx.destroy
!        shell.destroy_ptr_part
!      end
!   !  bb.zero_small_values(TOL(10))
!      bb = -HALF*bb
!   end
!
!   make_spin_b_field_grid(bb,pt,Dx,Dy,Dz)
!   ! Make the magnetic B field "bb" due to the spin density at a set of points
!   ! given in "pt" using three real symmetric AO density matrices "Dx", "Dy" and
!   ! "Dz" corresponding to the Sx, Sy and Sz densities. Note: the contribution
!   ! is added to whatever is already in bb.
!      bb,pt :: MAT{REAL}
!      Dx,Dy,Dz :: MAT{REAL}, target
!      DD :: MAT3{REAL}*
!      M :: MAT4{REAL}*
!      Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz :: MAT{REAL}*
!      q,a,b,fa,fb,la,lb,n, n_pt, i,j,k :: INT
!      eps :: MAT3{REAL}(3,3,3)
!      fac :: REAL
!      shell :: SHELL2
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(pt.dim2==3,"no basis set")
!   ENSURE(Dx.dim1==.n_bf AND Dx.is_square,"wrong shape for Dx")
!   ENSURE(Dy.dim1==.n_bf AND Dy.is_square,"wrong shape for Dy")
!   ENSURE(Dz.dim1==.n_bf AND Dz.is_square,"wrong shape for Dz")
!      n_pt = size(pt,1)
!      bb = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(shell,q,a,b,fa,la,fb,lb)
!        DD.create(shell.a.n_comp,shell.b.n_comp,3)
!        DD(:,:,1) = Dx(fb:lb,fa:la)
!        DD(:,:,2) = Dy(fb:lb,fa:la)
!        DD(:,:,3) = Dz(fb:lb,fa:la)
!        fac = ONE; if (fa==fb) fac=HALF
!        M.create(shell.a.n_comp,shell.b.n_comp,3,3)
!        Mxx => M(:,:,1,1); Mxy => M(:,:,1,2); Mxz => M(:,:,1,3)
!        Myx => M(:,:,2,1); Myy => M(:,:,2,2); Myz => M(:,:,2,3)
!        Mzx => M(:,:,3,1); Mzy => M(:,:,3,2); Mzz => M(:,:,3,3)
!        do n = 1,n_pt
!          shell.make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,pt(n,:))
!          do i = 1,3
!          do j = 1,3
!          do k = 1,3
!             eps(i,j,k) = M(:,:,i,j).trace_product_with(DD(:,:,k))
!          end
!          end
!          end
!          bb(n,1) = bb(n,1) + eps(:,:,1).trace - eps(1,:,:).trace
!          bb(n,2) = bb(n,2) + eps(:,:,2).trace - eps(2,:,:).trace
!          bb(n,3) = bb(n,3) + eps(:,:,3).trace - eps(3,:,:).trace
!        end
!        M.destroy
!        DD.destroy
!        shell.destroy_ptr_part
!      end
!   !  bb.zero_small_values(TOL(10))
!      bb = -bb ! this is -g_e mu_b; the final answer is in units of mu_0/4pi
!   end
!
!   make_pcc_structure_factors
!   !
!       S :: MAT{REAL}*
!      mo,Smo :: MAT{REAL}*
!      in :: TEXTFILE*
!      k_pts :: MAT{REAL}*
!      ftnew,ft :: MAT3{CPX}*
!       W :: MAT{CPX}*
!      ftnew_nabla,ft_nabla :: MAT4{CPX}*
!      shell :: SHELL2*
!      n_refl,q,i,j :: INT
!      fa,la,fb,lb,a,b :: INT
!      fac :: REAL
!      mo.create(160,4)
!      in.create("mo35")
!      in.open(for="read")
!      in.read(mo,order="by_column")
!      stdout.text("mo")
!      stdout.put(mo)
!
!      S.create(160,160)
!      .make_overlap_matrix(S)
!
!      Smo.create(4,4)
!      Smo.create(4,4)
!      S.change_basis_using(Smo,mo)
!      stdout.text("Smo")
!      stdout.put(Smo)
!
!      n_refl = .crystal%n_refl
!
!      k_pts.create(n_refl,3)
!      .crystal.make_k_pts(k_pts)
!
!      shell.create
!      ftnew.create(4,4,1)
!      ftnew = ZERO
!      do q = 1,.n_shell_pairs
!          .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
!          ft.create(n_refl,shell%a%n_comp,shell%b%n_comp)
!          shell.make_ft(ft,k_pts)
!          fac = ONE
!          if (a==b) fac = HALF
!          do i = 1,n_refl
!             ftnew(:,:,i) = ftnew(:,:,i) + &
!                fac*matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) + &
!                fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) )
!          end
!          ft.destroy
!          shell.destroy_ptr_part
!      end
!
!      do i = 1,n_refl
!         stdout.put(ftnew(:,:,i))
!      end
!      ftnew.destroy
!
!      ftnew_nabla.create(4,4,3,1)
!      ftnew_nabla = ZERO
!      do q = 1,.n_shell_pairs
!          .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
!          ft_nabla.create(n_refl,shell%a%n_comp,shell%b%n_comp,3)
!          shell.make_ft_nabla(ft_nabla,k_pts)
!          fac = ONE
!          if (a==b) fac = HALF
!          do i = 1,n_refl
!          do j = 1,3
!             ftnew_nabla(:,:,j,i) = ftnew_nabla(:,:,j,i) + &
!                fac*matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) - &
!                fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) )
!          end
!          end
!          ft_nabla.destroy
!          shell.destroy_ptr_part
!      end
!
!      do i = 1,n_refl
!      do j = 1,3
!          stdout.show("component =",j)
!          stdout.put(ftnew_nabla(:,:,j,i))
!      end
!      end
!      ftnew_nabla.destroy
!      shell.destroy
!   end
!
!   make_pcc_L_matrices
!   !
!       S :: MAT{REAL}*
!      mo,Smo :: MAT{REAL}*
!      Lx,Ly,Lz :: MAT{REAL}*
!      Lxmo,Lymo,Lzmo :: MAT{REAL}*
!      in :: TEXTFILE*
!      mo.create(160,4)
!      in.create("mo35")
!      in.open(for="read")
!      in.read(mo,order="by_column")
!      stdout.text("mo")
!      stdout.put(mo)
!
!      S.create(160,160)
!      .make_overlap_matrix(S)
!
!      Smo.create(4,4)
!      Smo.create(4,4)
!      S.change_basis_using(Smo,mo)
!      stdout.text("Smo")
!      stdout.put(Smo)
!
!      Lx.create(.n_bf,.n_bf); Lx = ZERO
!      Ly.create(.n_bf,.n_bf); Ly = ZERO
!      Lz.create(.n_bf,.n_bf); Lz = ZERO
!      .make_L_matrices(Lx,Ly,Lz)
!
!    ! std_output.text("Lx")
!    ! std_output.put(Lx)
!    ! std_output.text("Ly")
!    ! std_output.put(Ly)
!    ! std_output.text("Lz")
!    ! std_output.put(Lz)
!
!      Lxmo.create(4,4)
!      Lymo.create(4,4)
!      Lzmo.create(4,4)
!      Lx.change_basis_using(Lxmo,mo)
!      Ly.change_basis_using(Lymo,mo)
!      Lz.change_basis_using(Lzmo,mo)
!
!      stdout.text("Lxmo")
!      stdout.put(Lxmo)
!      stdout.text("Lymo")
!      stdout.put(Lymo)
!      stdout.text("Lzmo")
!      stdout.put(Lzmo)
!      S.destroy
!      Smo.destroy
!      Lxmo.destroy; Lymo.destroy; Lzmo.destroy
!      Lx.destroy; Ly.destroy; Lz.destroy
!   end
!
!   test_spin_orbit_B_matrices
!   !
!      Lx,Ly,Lz :: MAT{REAL}*
!      fac :: REAL
!      fac = (TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)/G_FACTOR
!      Lx.create(.n_bf,.n_bf)
!      Ly.create(.n_bf,.n_bf)
!      Lz.create(.n_bf,.n_bf)
!      .make_spin_orbit_B_matrices(Lx,Ly,Lz)
!      stdout.text("x")
!      stdout.put( Lx)
!      stdout.text("y")
!      stdout.put( Ly)
!      stdout.text("z")
!      stdout.put( Lz)
!      .make_SOB_matrices(Lx,Ly,Lz)
!      stdout.text("x")
!      stdout.put( Lx)
!      stdout.text("y")
!      stdout.put( Ly)
!      stdout.text("z")
!      stdout.put( Lz)
!      Lx.destroy; Ly.destroy; Lz.destroy
!   end
!
!   make_SOB_matrices(SOBx,SOBy,SOBz)
!   ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy" and "SOBz"
!      SOBx,SOBy,SOBz :: MAT{REAL}
!      Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,Qx,Qy,Qz,Qss :: MAT{REAL}*
!      q,c,a,b,fa,la,fb,lb,atom_a,atom_b :: INT
!      fac,Z :: REAL
!      shell :: SHELL2
!      archive :: ARCHIVE
!      debug :: BIN
!      n_a,n_b :: INT
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE( .atom.created,  "no atom list")
!      fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
!      SOBx = ZERO; SOBy = ZERO; SOBz = ZERO
!      do q=1,.n_shell_pairs
!         .get_shell_pair(q,shell,fa,la,fb,lb)
!         n_a = shell%a%n_comp; n_b = shell%b%n_comp
!         Qss.create(n_a,n_b)
!         Qx.create(n_a,n_b);  Qy.create(n_a,n_b);  Qz.create(n_a,n_b)
!         Qxx.create(n_a,n_b); Qxy.create(n_a,n_b); Qxz.create(n_a,n_b)
!         Qyx.create(n_a,n_b); Qyy.create(n_a,n_b); Qyz.create(n_a,n_b)
!         Qzx.create(n_a,n_b); Qzy.create(n_a,n_b); Qzz.create(n_a,n_b)
!         do c = 1,.n_atom
!            Z = .atom(c)%atomic_number
!            shell.make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, .atom(c)%pos, .gauge_origin)
!            Qss = Qxx + Qyy + Qzz
!            Qx = Qss*.B_field(1) - Qxx*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
!            Qy = Qss*.B_field(2) - Qyx*.B_field(1) - Qyy*.B_field(2) - Qyz*.B_field(3)
!            Qz = Qss*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2) - Qzz*.B_field(3)
!            SOBx(fa:la,fb:lb) = SOBx(fa:la,fb:lb) - Z*Qx
!            SOBy(fa:la,fb:lb) = SOBy(fa:la,fb:lb) - Z*Qy
!            SOBz(fa:la,fb:lb) = SOBz(fa:la,fb:lb) - Z*Qz
!         end
!         shell.destroy_ptr_part
!         Qzz.destroy; Qzy.destroy; Qzx.destroy
!         Qyz.destroy; Qyy.destroy; Qyx.destroy
!         Qxz.destroy; Qxy.destroy; Qxx.destroy
!         Qz.destroy;  Qy.destroy;  Qx.destroy;  Qss.destroy
!      end
!      SOBx.make_symmetric
!      SOBy.make_symmetric
!      SOBz.make_symmetric
!    ! archive.set(.name,"SOB_x_matrix"); archive.write(SOBx)
!    ! archive.set(.name,"SOB_y_matrix"); archive.write(SOBy)
!    ! archive.set(.name,"SOB_z_matrix"); archive.write(SOBz)
!   end
!
!   make_pcc_densities
!   ! Calculate pcc's densities for the paper
!      mo :: MAT{REAL}*
!      mo35,mo48,mo49,mo50 :: VEC{REAL}*
!      p35,p48,p49,p50 :: VEC{REAL}*
!      g35,g48,g49,g50 :: MAT{REAL}*
!      j,s :: MAT{REAL}*
!      in :: TEXTFILE*
!      n_pt,k :: INT
!      mu,nu,rt3,fac :: REAL
!      archive :: ARCHIVE
!
!      mo35.create(160)
!      mo48.create(160)
!      mo49.create(160)
!      mo50.create(160)
!      in.create("mo35")
!      in.open(for="read")
!      in.read(mo35)
!      in.read(mo48)
!      in.read(mo49)
!      in.read(mo50)
!
!      n_pt = .plot_grid%n_pt
!      p35.create(n_pt); g35.create(n_pt,3)
!      p48.create(n_pt); g48.create(n_pt,3)
!      p49.create(n_pt); g49.create(n_pt,3)
!      p50.create(n_pt); g50.create(n_pt,3)
!      .make_orbital_grid(p35,mo35)
!      .make_orbital_grid(p48,mo48)
!      .make_orbital_grid(p49,mo49)
!      .make_orbital_grid(p50,mo50)
!      .make_nabla_orbital_grid(g35,mo35)
!      .make_nabla_orbital_grid(g48,mo48)
!      .make_nabla_orbital_grid(g49,mo49)
!      .make_nabla_orbital_grid(g50,mo50)
!
!      j.create(n_pt,3)
!      s.create(n_pt,3)
!      nu = 0.15578d0
!      mu = 0.19107d0
!      rt3 = ONE/sqrt(THREE)
!      fac = ONE/(ONE+mu*mu+nu*nu)
!      do k = 1,3
!         j(:,k) =      nu*(p35(:)*g48(:,k) - p48(:)*g35(:,k)) &
!                + HALF*mu*(p50(:)*g49(:,k) - p49(:)*g50(:,k))
!      end
!      j = fac*j
!
!      s(:,1) = -rt3*mu * (p35(:)*p49(:) - nu*p48(:)*p50(:))
!      s(:,2) = -rt3*mu * (p35(:)*p50(:) - nu*p48(:)*p49(:))
!      s(:,3) = (ONE+mu*mu/THREE) * p48(:)*p48(:) &
!             + (ONE+nu*nu+mu*mu/SIX) * (p49(:)*p49(:)+p50(:)*p50(:)) &
!             + (nu*nu+mu*mu/THREE) * p35(:)*p35(:)
!      s(:,3) = HALF*s(:,3)
!
!      archive.set(.name,"current_density")
!      archive.write(j)
!      archive.set(.name,"current_density,gnuplot",format="ascii")
!      archive.write_gnuplot(j, .plot_grid%n_x, .plot_grid%n_y, .plot_grid%n_z)
!      archive.set(.name,"current_norm_density,gnuplot",format="ascii")
!      archive.write_gnuplot(j, .plot_grid%n_x, .plot_grid%n_y, .plot_grid%n_z, norm=TRUE)
!      archive.set(.name,"current_density,normalised,gnuplot",format="ascii")
!      archive.write_gnuplot(j, .plot_grid%n_x, .plot_grid%n_y, .plot_grid%n_z, normalise=TRUE)
!
!      archive.set(.name,"spin_density")
!      archive.write(s)
!      archive.set(.name,"spin_density,gnuplot",format="ascii")
!      archive.write_gnuplot(s, .plot_grid%n_x, .plot_grid%n_y, .plot_grid%n_z)
!      archive.set(.name,"spin_norm_density,gnuplot",format="ascii")
!      archive.write_gnuplot(s, .plot_grid%n_x, .plot_grid%n_y, .plot_grid%n_z, norm=TRUE)
!      archive.set(.name,"spin_density,normalised,gnuplot",format="ascii")
!      archive.write_gnuplot(s, .plot_grid%n_x, .plot_grid%n_y, .plot_grid%n_z, normalise=TRUE)
!
!      s.destroy
!      j.destroy
!      g50.destroy; p50.destroy
!      g49.destroy; p49.destroy
!      g48.destroy; p48.destroy
!      g35.destroy; p35.destroy
!      in.close
!      in.destroy
!      mo50.destroy
!      mo49.destroy
!      mo48.destroy
!      mo35.destroy
!   end

! *******************
! Spherical averaging
! *******************

!   z_circularly_averaged_sf
!   ! Make the circularly averaged structure factors from zero up until a
!   ! specified value of sin(theta)/lambda. The average is taken for all angles
!   ! around the z axis.
! ! ENSURE(.crystal.created, "no crystal")
! ! ENSURE(.crystal.reflection_data_exists, "no reflection data")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.any_created, "no density matrix")
!      Fc :: MAT{CPX}*
!      k_pts :: MAT{REAL}*
!      k_values :: VEC{REAL}*
!      orb_kind :: STR
!      complex :: BIN
!      i,n_pts,n_theta :: INT
!      n_theta = 18
!      n_pts = 200
!      Fc.create(n_pts+1,n_theta+1)
!      k_values.create(n_pts+1)
!      do i = 0,n_pts
!         k_values(i+1) = i*0.01d0
!      end
!      .make_ao_density_matrix
!    ! .pointgroup.destroy
!    ! .pointgroup.create("oh")
!    ! .symmetrise(.density_matrix)
!      orb_kind = .density_matrix.spinorbital_kind
!      complex = orb_kind.includes("complex")
!      if (complex) then
!        DIE("complex density not yet implemented")
!      else
!        .MAIN:make_z_circularly_averaged_ft(Fc,.density_matrix.restricted,k_values,n_theta)
!      end
!      k_values.destroy
!      stdout.text("Circularly averaged structure factors:")
!      stdout.put(Fc)
!    ! .crystal.set_F_calc(Fc)
!    ! .crystal.make_F_predicted
!      Fc.destroy
!   end

!   make_z_circularly_averaged_ft(res,dens,k_values,n_theta)
!   ! Make the z circularly averaged fourier transform of a density described by
!   ! AO density matrix "dens" evaluated at a series of reciprocal space
!   ! distances "k_values" and "n_theta" + 1 equally spaced points, starting from
!   ! 0 and going up to PI.
!      res :: MAT{CPX}, OUT
!      dens :: MAT{REAL}, target
!      n_theta :: INT, IN
!      k_values :: VEC{REAL}, IN
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(res.dim1==k_values.dim,"incompatible res and k_values")
!   ENSURE(res.dim2==n_theta+1,"incompatible res and n_theta")
!      k,fa,fb,la,lb,q,t :: INT
!      sh :: SHELL2
!      ft_ab :: MAT4{CPX}*
!      dens_ba :: MAT{REAL}*
!      cutoff,fac,val :: REAL
!      res = ZERO
!      cutoff = TOL(10) / .n_shell_pairs
!      parallel do q = 1,.n_shell_pairs
!         .get_shell_pair(sh,q,fa,la,fb,lb)
!         if (sh.skip_ft(cutoff)) then
!           sh.destroy_ptr_part
!           cycle
!         end
!         ft_ab.create(sh.a.n_comp,sh.b.n_comp,k_values.dim,n_theta+1)
!         sh.make_z_circularly_averaged_ft(ft_ab,k_values,n_theta)
!         dens_ba => dens(fa:la,fb:lb)
!         fac = ONE
!         if (fa/=fb) fac = TWO ! count off-diagonals twice.
!         do t = 1,n_theta+1
!         do k = 1,k_values.dim
!            res(k,t) = res(k,t) + fac*sum(ft_ab(:,:,k,t)*dens_ba(:,:))
!         end
!         end
!         ft_ab.destroy
!         sh.destroy_ptr_part
!      end
!      PARALLEL_SYMMETRIC_SUM(res)
!   end

   spherically_averaged_sf
   ! Make the spherically averaged structure factors from zero up until a
   ! specified value of sin(theta)/lambda.
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
      Fc :: VEC{CPX}*
      k_values :: VEC{REAL}*
      orb_kind :: STR
      complex :: BIN
      i,k,n_pts :: INT
      n_pts = 750
      Fc.create(n_pts)
      k_values.create(n_pts)
      k = 0
      do i = 60,n_pts,7
         k = k + 1
         k_values(k) = i*0.01d0
      end
      Fc.shrink(k)
      k_values.shrink(k)
      .make_ao_density_matrix
    ! .pointgroup.destroy
    ! .pointgroup.create("oh")
    ! .symmetrise(.density_matrix)
      orb_kind = .density_matrix.spinorbital_kind
      complex = orb_kind.includes("complex")
      if (complex) then
        DIE("complex density not yet implemented")
      else
        .MAIN:make_spherically_averaged_ft(Fc,.density_matrix.restricted,k_values)
      end
      k_values.destroy
      stdout.text("Spherically averaged structure factors:")
      stdout.put(Fc,"column")
    ! .crystal.set_F_calc(Fc)
    ! .crystal.make_F_predicted
      Fc.destroy
   end

   make_spherically_averaged_ft(res,dens,k_values)
   ! Make the spherically averaged fourier transform of a density described by
   ! AO density matrix "dens" evaluated at a series of reciprocal space
   ! distances "k_values".
      res :: VEC{CPX}, OUT
      dens :: MAT{REAL}, target
      k_values :: VEC{REAL}, IN
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(res.dim==k_values.dim,"incompatible res and k_values")
      k,fa,fb,la,lb,q :: INT
      sh :: SHELL2
      ft_ab :: MAT3{CPX}*
      dens_ba :: MAT{REAL}*
      cutoff,fac :: REAL
      res = ZERO
      cutoff = TOL(10) / .n_shell_pairs
      do q = 1,.n_shell_pairs
         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
         dens_ba => dens(fa:la,fb:lb)
         if (sh.skip_ft(cutoff)) then
           sh.destroy_ptr_part
           cycle
         end
         ft_ab.create(sh.a.n_comp,sh.b.n_comp,k_values.dim)
         sh.make_spherically_averaged_ft(ft_ab,k_values)
!        dens_ba => dens(fb:lb,fa:la) ! P^dagger
!     stdout.text("ft_ab(1):")
!     stdout.put(ft_ab(:,:,1))
!     stdout.text("dens:")
!     stdout.put(dens_ba)
!     val = sum(ft_ab(:,:,1)*dens_ba(:,:))
!     stdout.show("contribution 1 =",val)
         fac = ONE
         if (fa/=fb) fac = TWO ! count off-diagonals twice.
         do k = 1,k_values.dim
            res(k) = res(k) + fac*sum(ft_ab(:,:,k)*dens_ba(:,:))
         end
         ft_ab.destroy
         sh.destroy_ptr_part
      end
   end


   make_spherically_averaged_HAs ::: leaky
   ! Make the spherically averaged Hirshfeld atom density
   ! interpolators for every atom.
   ENSURE(.use_interpolators,"must be using interpolators")

      interpolator :: VEC{INTERPOLATOR}*
      rho_av :: VEC{VEC_{REAL}}*
      eps,eps_a :: REAL
      a,l_max,iteration :: INT

      ! Set up the template for interpolators
      .interpolator.destroy
      .interpolator.create
      .interpolator.set_interpolation_method("cubic_spline")
      .interpolator.set_range_mapping("none")
      .interpolator.set_domain_mapping("sqrt(x/(1-x))*scale")
      .interpolator.set_table_length(ONE) 
      .interpolator.set_spacing(0.001d0) 
      .interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! Set up grids, atomic densities, and NO's
      .set_up_Hirshfeld_info

      ! List of initial atom interpolators. Leaky
      interpolator.create(.n_atom)
      do a = 1,.n_atom
         interpolator(a).copy(.atom(a).interpolator)
      end

      ! Destroy atom ANO data and interpolators. Leaky.
      .destroy_ANO_data
      .destroy_interpolators

      ! Set interpolators
      .interpolators_made = TRUE

      ! The list of new atomic radial densities
      rho_av.create(.n_atom)

      ! Reassign fresh interpolator copy; create averaged rho
      do a = 1,.n_atom
         .atom(a).interpolator => interpolator(a)
          rho_av(a).element.create(interpolator(a).n_data)
      end

      ! No of Gauss-Legendre integration points
      l_max = 35

      ! Banner
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("Iter",int_width=TRUE)
      stdout.put("Max change")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)

      ! Begin iterative cycle
      iteration = 0

      do

         iteration = iteration + 1

         stdout.show("Iteration = ",iteration)

         ! Spherically average each atom
         eps = ZERO
         do a = 1,.n_atom
            .MAIN:make_spherically_averaged_HA(rho_av(a).element,eps_a,a,interpolator(a),l_max)
            eps = max(eps,eps_a)
         end

         ! Update convergence
         stdout.put(iteration)
         stdout.put(eps)
         stdout.flush

         ! Transfer averaged values to atoms and interpolators
         do a = 1,.n_atom
            interpolator(a).set_data_values(rho_av(a).element)
            interpolator(a).finalise
            .atom(a).interpolator => interpolator(a)
          ! interpolator(a).put
         end

         ! Spherical atoms obtained
         if (eps<TOL(6)) exit
         if (iteration>50) exit

      end

      ! Footer
      stdout.put_dash(int_fields=1,real_fields=1)

      ! Copy atom interpolators. Leaky
      do a = 1,.n_atom
         nullify(.atom(a).interpolator)
         .atom(a).interpolator.create_copy(interpolator(a))
      end

      ! Clean up
      rho_av.destroy
      interpolator.destroy

   end

   make_spherically_averaged_HA(rho_av,eps,a,interpolator,l_max) 
   ! Make the spherically averaged Hirshfeld atom density "rho_av" for
   ! the atom with index "a". Also return "eps", the maximum 
   ! difference between the rho_av values and those stored in the
   ! interpolator data_values. The spacing and radial data values from
   ! the center of atom "a" are taken from the "interpolator". "l_max"
   ! is the maximum l value for the lebedev angular integration grid
      rho_av :: VEC{REAL}, OUT
      eps :: REAL, OUT
      a,l_max :: INT, IN
      interpolator :: INTERPOLATOR

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho_av.dim==interpolator.n_data,"wrong size, rho_av")
   ENSURE(a.is_in_range([1,.n_atom]),"a out of range")
   ENSURE(.interpolators_made,"No interpolators")

      pt :: MAT{REAL}*
      rho,Wa, del,pc :: VEC{REAL}*
      pos :: VEC{REAL}(3)
      old,r :: REAL
      n_pts,n,i :: INT
      lebedev :: LEBEDEV*

      ! Set the spherical grid
      lebedev.create 
      lebedev.set_l(l_max)

      ! No of quadrature points (on sphere)
      n_pts = lebedev.n_points

      ! Weight function, molecular density, spherical points
      ! and weights
      Wa.create(n_pts)
      rho.create(n_pts)
      pt.create(n_pts,3)

      del.create(interpolator.n_data)
      pc.create(interpolator.n_data)

      ! Atom position
      pos = .atom(a).pos

      ! Maximum relative difference
      eps = ZERO

      stdout.show("atom =",a)
      interpolator.put

    ! stdout.put("r")
    ! stdout.put("rho_av")
    ! stdout.put("old")
    ! stdout.put("%")
    ! stdout.flush

      ! Loop over radial values
      do i = 1,interpolator.n_data

         ! Table value r
         r = interpolator.data_point(i)

         ! Interpolator data valie
         old = interpolator.data_value(i)

         ! Convert to actual r?
         if (interpolator.domain_is_sqrt_x1x) &
            r = sqrt(r/(1-r))*interpolator.domain_scale_factor

         ! For each r, make a spherical shell of points
         do n = 1,n_pts
            pt(n,1) = pos(1) + r*lebedev.point(n,1)  
            pt(n,2) = pos(2) + r*lebedev.point(n,2)
            pt(n,3) = pos(3) + r*lebedev.point(n,3)
         end

         ! Weight function for atom a on the spherical shell
         .make_stockholder_atom_grid(Wa,a,pt)

         ! Molecular density on the spherical shell
         .make_density_grid(rho,pt)

         ! Weighted Hirshfeld atom density on shell
         Wa  = Wa*rho*lebedev.weight

         ! Averaged value
         rho_av(i) = sum(Wa)

         ! Average percentage change
         eps = max(eps,abs((rho_av(i)-old)))
         del(i) = rho_av(i)-old
         pc(i)  = del(i)/old

    ! stdout.put(r)
    ! stdout.put(rho_av(i))
    ! stdout.put(old)
    ! stdout.put(pc)
    ! stdout.flush

      end

      stdout.text("del:")
      stdout.put(del,"column")

      stdout.text("pc:")
      stdout.put(pc,"column")

      ! Clean up
      pc.destroy; del.destroy
      pt.destroy; rho.destroy; Wa.destroy
      lebedev.destroy

   end

   make_averaged_BDAs ::: leaky
   ! Make the spherically averaged bond density atom 
   ! interpolators for every atom.
   ENSURE(.use_interpolators,"must be using interpolators")

      interpolator :: VEC{INTERPOLATOR}*
      rho_av :: VEC{VEC_{REAL}}*
      eps,eps_a :: REAL
      a,l_max,iteration :: INT

      ! Set up the template for interpolators
      .interpolator.destroy
      .interpolator.create
      .interpolator.set_interpolation_method("cubic_spline")
      .interpolator.set_range_mapping("none")
      .interpolator.set_domain_mapping("sqrt(x/(1-x))*scale")
      .interpolator.set_table_length(ONE) 
      .interpolator.set_spacing(0.001d0) 
      .interpolator.set_table_eps(CLUSTER_ATOM_DENSITY_CUTOFF)

      ! Set up grids, atomic densities, and NO's
      .set_up_Hirshfeld_info

      ! List of initial atom interpolators. Leaky
      interpolator.create(.n_atom)
      do a = 1,.n_atom
         interpolator(a).copy(.atom(a).interpolator)
      end

      ! Destroy atom ANO data and interpolators. Leaky.
      .destroy_ANO_data
      .destroy_interpolators

      ! Set this switch
      .interpolators_made = TRUE

      ! The list of new atomic radial densities
      rho_av.create(.n_atom)

      ! Reassign fresh interpolator copy; create averaged rho
      do a = 1,.n_atom
         .atom(a).interpolator => interpolator(a)
          rho_av(a).element.create(interpolator(a).n_data)
      end

      ! No of Gauss-Legendre integration points
      l_max = 35

      ! Banner
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)
      stdout.put("Iter",int_width=TRUE)
      stdout.put("Max change")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=1)

      ! Begin iterative cycle
      iteration = 0

      do

         iteration = iteration + 1

         stdout.show("Iteration = ",iteration)

         ! Spherically average each atom
         eps = ZERO
         do a = 1,.n_atom
            .MAIN:make_averaged_BDAs(rho_av(a).element,eps_a,a,interpolator(a),l_max)
            eps = max(eps,eps_a)
         end

         ! Update convergence
         stdout.put(iteration)
         stdout.put(eps)
         stdout.flush

         ! Transfer averaged values to atoms and interpolators
         do a = 1,.n_atom
            interpolator(a).set_data_values(rho_av(a).element)
            interpolator(a).finalise
            .atom(a).interpolator => interpolator(a)
          ! interpolator(a).put
         end

         ! Spherical atoms obtained
         if (eps<TOL(6)) exit
         if (iteration>=1) exit

      end

      ! Footer
      stdout.put_dash(int_fields=1,real_fields=1)

      ! Copy atom interpolators. Leaky
      do a = 1,.n_atom
         nullify(.atom(a).interpolator)
         .atom(a).interpolator.create_copy(interpolator(a))
      end

      ! Clean up
      rho_av.destroy
      interpolator.destroy

   end

   make_averaged_BDAs(rho_av,eps,a,interpolator,l_max) 
   ! Make the spherically averaged Hirshfeld atom density "rho_av" for
   ! the atom with index "a". Also return "eps", the maximum 
   ! difference between the rho_av values and those stored in the
   ! interpolator data_values. The spacing and radial data values from
   ! the center of atom "a" are taken from the "interpolator". "l_max"
   ! is the maximum l value for the lebedev angular integration grid
      rho_av :: VEC{REAL}, OUT
      eps :: REAL, OUT
      a,l_max :: INT, IN
      interpolator :: INTERPOLATOR

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(rho_av.dim==interpolator.n_data,"wrong size, rho_av")
   ENSURE(a.is_in_range([1,.n_atom]),"a out of range")
   ENSURE(.interpolators_made,"No interpolators")

      pt :: MAT{REAL}*
      rho,Wa, del,pc :: VEC{REAL}*
      pos :: VEC{REAL}(3)
      old,r :: REAL
      n_pts,n,i :: INT
      lebedev :: LEBEDEV*

      ! Set the spherical grid
      lebedev.create 
      lebedev.set_l(l_max)

      ! No of quadrature points (on sphere)
      n_pts = lebedev.n_points

      ! Weight function, molecular density, spherical points
      ! and weights
      Wa.create(n_pts)
      rho.create(n_pts)
      pt.create(n_pts,3)

      del.create(interpolator.n_data)
      pc.create(interpolator.n_data)

      ! Atom position
      pos = .atom(a).pos

      ! Maximum relative difference
      eps = ZERO

      stdout.show("atom =",a)
      interpolator.put

    ! stdout.put("r")
    ! stdout.put("rho_av")
    ! stdout.put("old")
    ! stdout.put("%")
    ! stdout.flush

      ! Loop over radial values
      do i = 1,interpolator.n_data

         ! Table value r
         r = interpolator.data_point(i)

         ! Interpolator data valie
         old = interpolator.data_value(i)

         ! Convert to actual r?
         if (interpolator.domain_is_sqrt_x1x) &
            r = sqrt(r/(1-r))*interpolator.domain_scale_factor

         ! For each r, make a spherical shell of points
         do n = 1,n_pts
            pt(n,1) = pos(1) + r*lebedev.point(n,1)  
            pt(n,2) = pos(2) + r*lebedev.point(n,2)
            pt(n,3) = pos(3) + r*lebedev.point(n,3)
         end

         ! Weight function for atom a on the spherical shell
         .make_bond_density_atom_grid(Wa,pt,a)

         ! Weighted Hirshfeld atom density on shell
         Wa  = Wa*lebedev.weight

         ! Averaged value
         rho_av(i) = sum(Wa)

         ! Average percentage change
         eps = max(eps,abs((rho_av(i)-old)))
         del(i) = rho_av(i)-old
         pc(i)  = del(i)/old

    ! stdout.put(r)
    ! stdout.put(rho_av(i))
    ! stdout.put(old)
    ! stdout.put(pc)
    ! stdout.flush

      end

      stdout.text("del:")
      stdout.put(del,"column")

      stdout.text("pc:")
      stdout.put(pc,"column")

      ! Clean up
      pc.destroy; del.destroy
      pt.destroy; rho.destroy; Wa.destroy
      lebedev.destroy

   end

   put_BDA_charges
   ! Put the BDA charges.
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")

      bond :: VEC{VEC_{INT}}*
      bond_charge :: VEC{VEC_{REAL}}*
      label :: STR
      a,b,c :: INT
      has_bond :: BIN

      ! Make the charges
      .MAIN:make_BDA_charges(bond,bond_charge)

      ! Put the table
      stdout.dash(real_fields=3)
      stdout.tab(real_fields=1)
      stdout.put("Bonded")
      stdout.put("Bond")
      stdout.flush
      stdout.put("Atom")
      stdout.put("Atom")
      stdout.put("Charge")
      stdout.flush
      stdout.dash(real_fields=3)

      do a = 1,.n_atom

         label = trim(.atom(a).label) // "(" // trim(a.to_str) // ")"
         stdout.put(label)

         has_bond = bond(a).element.created
         if (has_bond) has_bond = bond(a).element.dim>0

         if (NOT has_bond) then
            stdout.flush
         else

            do b = 1,bond(a).element.dim
               if (b>1) stdout.tab(real_fields=1)
               c = bond(a).element(b)
               label = trim(.atom(c).label) // "(" // trim(c.to_str) // ")"
               stdout.put(label)
               stdout.put(-bond_charge(a).element(b))
               stdout.flush
            end
            stdout.tab(real_fields=2)
            stdout.put(-sum(bond_charge(a).element))
            stdout.flush

         end

      end

      stdout.dash(real_fields=3)

      ! Clean up
      bond.destroy
      bond_charge.destroy

   end

   make_BDA_charges(bond,bond_charge) ::: leaky
   ! make the bond density atom charges.
      bond :: VEC{VEC_{INT}}*
      bond_charge :: VEC{VEC_{REAL}}*

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")

      pt :: MAT{REAL}*
      wt,rho_aba,def_density_grid :: VEC{REAL}*
      bond_density_atom :: VEC{INT}*
      n_pt,a,b :: INT
      val :: REAL

      ! Set up grids, atomic densities, and NO's
      .set_up_Hirshfeld_info

      ! Array for bonds and bond charges
      bond.create(.n_atom)
      bond_charge.create(.n_atom)

      ! Loop over atoms, a
      do a = 1,.n_atom

         ! Make becke grid
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1

         ! Deformation density on grid
         def_density_grid.create(n_pt)
         .make_deformation_density_grid(def_density_grid,pt)

         ! Bond density on grid
         rho_aba.create(n_pt)

         ! bond density atom
         bond_density_atom.create(3)
         bond_density_atom(1) = a
         bond_density_atom(3) = a

         ! Loop over atoms b, bonded to a
         do b = 1,.n_atom

            if (a==b) cycle
            if (NOT .atom.bonded(a,b)) cycle

            ! Get the bond density
            bond_density_atom(2) = b
            .make_def_bond_density_grid(rho_aba,pt,bond_density_atom,def_density_grid)

            ! Get weighted integral
            rho_aba  = rho_aba*wt

            ! Get charge
            val = sum(rho_aba)

            ! Store charge
            bond(a).element.append(b)
            bond_charge(a).element.append(val)
          
         end

         ! Clean up
         bond_density_atom.destroy
         rho_aba.destroy
         def_density_grid.destroy
         pt.destroy; wt.destroy

      end

   end


! *************
! Miscellaneous
! *************

!   test_rchf_S
!   ! Test rchf S
!      S,D,T,U :: MAT{REAL}*
!      n_bf :: INT
!      .cluster.create_atom_list
!      .cluster.atom.make_index_info
!      n_bf = .cluster.atom.no_of_basis_functions
!      S.create(n_bf,n_bf)
!      ! .make_rxhf_overlap_matrix(S)
!      stdout.text("rchf S:")
!      stdout.put(S)
!      S.destroy
!   end

!   test_inv_sqrt_S
!   ! Test inv sqrt S routine
!      S,D,T,U :: MAT{REAL}*
!      S.create(.n_bf,.n_bf)
!      D.create(.n_bf,.n_bf)
!      T.create(.n_bf,.n_bf)
!      U.create(.n_bf,.n_bf)
!      .make_overlap_matrix(S)
!    ! U.to_unit_matrix 
!    ! D = S/NINE - U
!    ! stdout.text("delta")
!    ! stdout.put(D)
!    ! T = matmul(D,D)
!    ! D = T
!    ! stdout.text("delta^2")
!    ! stdout.put(D)
!    ! T = matmul(D,D)
!    ! D = T
!    ! stdout.text("delta^4")
!    ! stdout.put(D)
!    ! T = matmul(D,D)
!    ! D = T
!    ! stdout.text("delta^8")
!    ! stdout.put(D)
!      D.to_power_product_inv_sqrt_of(S,tol=TOL(10),prefactor=ONE/FOUR)
!      U = matmul(D,matmul(S,D))
!      stdout.text("check")
!      stdout.put(U)
!      stdout.show("is unit matrix =",U.is_unit_matrix)
!      D.to_power_product_inverse_of(S,tol=TOL(10),prefactor=ONE/FOUR)
!      U = matmul(D,S)
!      stdout.text("check")
!      stdout.put(U)
!      stdout.show("is unit matrix =",U.is_unit_matrix)
!      U.destroy
!      T.destroy
!      D.destroy
!      S.destroy
!   end

!   test_E_field_matrices
!   ! Test the E field matrices
!      Exx,Eyy,Ezz,Exy,Exz,Eyz :: MAT{REAL}*
!      Exp,Eyp,Ezp,Exm,Eym,Ezm,NN :: MAT{REAL}*
!      c :: VEC{REAL}(3)
!      Exp.create(.n_bf,.n_bf); Eyp.create(.n_bf,.n_bf); Ezp.create(.n_bf,.n_bf)
!      Exm.create(.n_bf,.n_bf); Eym.create(.n_bf,.n_bf); Ezm.create(.n_bf,.n_bf)
!      Exx.create(.n_bf,.n_bf); Eyy.create(.n_bf,.n_bf); Ezz.create(.n_bf,.n_bf)
!      Exy.create(.n_bf,.n_bf); Exz.create(.n_bf,.n_bf); Eyz.create(.n_bf,.n_bf)
!      NN.create(.n_bf,.n_bf)
!      c = [ZERO,ZERO,ZERO]
!      ! c = [ZERO,ZERO+TOL(5),ZERO]
!      .make_electric_field_matrices(Exp,Eyp,Ezp,c)
!      ! c = [ZERO,ZERO-TOL(5),ZERO]
!      ! .make_electric_field_matrices(Exm,Eym,Ezm,c)
!      ! c = [ZERO,ZERO,ZERO]
!      ! .make_EFG_matrices(Exx,Eyy,Ezz,Exy,Exz,Eyz,c)
!      ! Eyy = (Exp-Exm)/(TWO*TOL(5))
!      .MAIN:make_NE_matrix(NN)
!      stdout.text("Ex"); stdout.put(Exp)
!      ! stdout.text("numerical Exy 2"); stdout.put(Eyy)
!      stdout.text("numerical Ex"); stdout.put(NN)
!      Exp.destroy; Eyp.destroy; Ezp.destroy
!      Exm.destroy; Eym.destroy; Ezm.destroy
!      Exx.destroy; Eyy.destroy; Ezz.destroy
!      Exy.destroy; Exz.destroy; Eyz.destroy
!      NN.destroy
!   end

!   make_NE_matrix(Z)
!   ! Calculate the one-electron electron nuclear attractio matrix numerically.
!      Z :: MAT{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(.dftgrid.created, "need to specify dftgrid for ZORA")
!     ZZ :: MAT{REAL}*
!     sh :: SHELL2
!     arch :: ARCHIVE
!     q,fa,la,fb,lb :: INT
!     Z = ZERO
!     do q = 1,.n_shell_pairs
!        .get_shell_pair(sh,q,fa,la,fb,lb)
!        ZZ.create(sh.a.n_comp,sh.b.n_comp)
!        .dftgrid.make_matrix_elements_of(MOLECULE.MAIN:E_potential,self,sh,ZZ)
!        Z(fa:la,fb:lb) = Z(fa:la,fb:lb) + ZZ
!        ZZ.destroy
!        sh.destroy_ptr_part
!     end
!     Z.symmetric_reflect
!   end

!   E_potential(values,pts)
!   ! Calculate the electric field "values" at a given set of "pts".
!   ! This is useful for numerical integration.
!      values :: VEC{REAL}
!      pts :: MAT{REAL}
!      n_pts,n,i :: INT
!      r,x,y,z :: REAL
!      c :: VEC{REAL}(3)
!      n_pts = size(pts,1)
!      values = ZERO
!      c = [ZERO,ZERO,ZERO]
!      do i = 1,n_pts
!         r = c.distance_to(pts(i,:))
!         x = c(1)-pts(i,1)
!         y = c(2)-pts(i,2)
!         z = c(3)-pts(i,3)
!         if (r>tiny(r)) then
!           ! values(i) = values(i) + (-TWO*x*x+y*y+z*z)/(r*r*r*r*r) 
!           ! values(i) = values(i) + (-THREE*x*y)/(r*r*r*r*r) 
!           values(i) = values(i) + x/(r*r*r)
!         else
!           values(i) = values(i) + TEN**6
!         end
!      end
!   end

!   test_ZORA_SO_matrices
!   !
!      SOx,SOy,SOz :: MAT{REAL}*
!      ZOx,ZOy,ZOz, T :: MAT{REAL}*
!      T.create(.n_bf,.n_bf)
!      SOx.create(.n_bf,.n_bf); SOy.create(.n_bf,.n_bf); SOz.create(.n_bf,.n_bf)
!      ZOx.create(.n_bf,.n_bf); ZOy.create(.n_bf,.n_bf); ZOz.create(.n_bf,.n_bf)
!      .get_nuclear_matrix(SOz)
!      .make_ENA_matrix(ZOz)
!      stdout.text("NA"); stdout.put(SOz)
!      stdout.text("numerical NA"); stdout.put(ZOz)
!      .get_spin_orbit_matrices(SOx,SOy,SOz)
!      .get_1e_ZORA_matrices(T,ZOx,ZOy,ZOz)
!      stdout.text("SOx"); stdout.put(SOx)
!      stdout.text("ZOx"); stdout.put(ZOx)
!      stdout.text("SOy"); stdout.put(SOy)
!      stdout.text("ZOy"); stdout.put(ZOy)
!      stdout.text("SOz"); stdout.put(SOz)
!      stdout.text("ZOz"); stdout.put(ZOz)
!      SOx.destroy; SOy.destroy; SOz.destroy
!      ZOx.destroy; ZOy.destroy; ZOz.destroy
!      T.destroy
!   end
!
!   test_dftgrid
!   !
!      Z,NZ,DZ :: MAT{REAL}*
!      Z.create(.n_bf,.n_bf)
!      NZ.create(.n_bf,.n_bf)
!      DZ.create(.n_bf,.n_bf)
!      .make_nuclear_matrix(DZ,output=TRUE)
!      .make_nuclear_ints(Z)
!      .get_ENA_matrix(NZ)
!      stdout.text("DZ"); stdout.put(DZ)
!      stdout.text("Z"); stdout.put(Z)
!      stdout.text("NZ"); stdout.put(NZ)
!      .test_num
!      Z.destroy; NZ.destroy; DZ.destroy
!   end
!
!   make_nuclear_ints(Z,output)
!   ! Calculate the nuclear attraction matrix "Z"
!   ! if output is present and FALSE then do not make output archive
!      Z :: MAT{REAL}
!     output :: BIN, OPTIONAL
!     do_output :: BIN
!     atom :: ATOM*
!     Z_c :: MAT{REAL}*
!     q,c,fa,la,fb,lb :: INT
!     shell :: SHELL2
!     archive :: ARCHIVE
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE( .atom.created,  "no atom list")
!     do_output=TRUE
!     if (present(output)) do_output=output
!     Z = ZERO
!       do q=1,.n_shell_pairs
!         .get_shell_pair(shell,q,fa,la,fb,lb)
!         Z_c.create(shell.a.n_comp,shell.b.n_comp)
!         do c=1,.n_atom
!           atom=>.atom(c)
!         ! shell.get_nuc(Z_c, atom.mass,atom.pos)
!           shell.make_nuclear_attraction_ints(Z_c, atom.pos)
!           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.atomic_number * Z_c
!         end
!         Z_c.destroy
!         shell.destroy_ptr_part
!       end
!     Z.make_symmetric
!     if (do_output) then
!       archive.set(.name,"nuc_matrix")
!       archive.write(Z)
!     end
!   end
!
!   test_num
!   !
!     ZZ :: MAT{REAL}*
!     q,fa,la,fb,lb :: INT
!     shell :: SHELL2
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE( .atom.created,  "no atom list")
!   ENSURE( .dftgrid.created, "need to specify dftgrid for ZORA")
!        q = 529
!        .get_shell_pair(shell,q,fa,la,fb,lb)
!        write(*,*) "fa=",fa,"la=",la,"fb=",fb,"lb=",lb
!        ZZ.create(shell.a.n_comp,shell.b.n_comp)
!        .dftgrid.make_matrix_elements_of(nuc_pot,self,shell,ZZ)
!        stdout.text("ZZ")
!        stdout.put(ZZ)
!        ZZ.destroy
!        shell.destroy_ptr_part
!   end
!
!   nuc_pot(values,pts)
!   ! Calculate the nuclear potential "values" of a given set of "pts".
!   ! This is usefule for numerical integration of nuclear attraction integrals.
!      values :: VEC{REAL}
!      pts :: MAT{REAL}
!      n_pts,n,i :: INT
!      Z_n,r_ni :: REAL
!      pos :: VEC{REAL}(3)
!      n_pts = size(pts,1)
!      values = ZERO
!      do n = 1,.n_atom
!         Z_n = .atom(n).atomic_number
!         pos = .atom(n).pos
!         do i = 1,n_pts
!            r_ni = pos.distance_to(pts(i,:))
!            values(i) = values(i) + Z_n/r_ni
!         end
!      end
!   end
!
!   get_ENA_matrix(Z)
!   ! Set "Z" to the numerically calculated electron nuclear attraction matrix.
!   ! If archives exist, read them; otherwise make them.
!       Z :: MAT{REAL}
!      archive :: ARCHIVE
!      archive.set(.name,"ENA_matrix")
!      if (archive.exists) then
!         archive.read(Z)
!      else
!         .make_ENA_matrix(Z)
!      end
!   end
!
!   integrate_property(make_property_grid) result (res)
!   ! Integrate a scalar molecular property, which is represented by a subroutine
!   ! "make_property_grid" which returns "values" of the property in a vector,
!   ! given "mol" as the molecule, and "pts" as a set of points. The result of
!   ! the integration is "res".
!      interface
!         make_property_grid(mol,values,pts)
!            mol :: MOLECULE
!            values :: VEC{REAL}
!            pts :: MAT{REAL}
!         end
!      end
!      res :: REAL
!   ENSURE( .dftgrid.created,"no DFT grid information!")
!!      res = .dftgrid.integrate_molecular_property(make_property_grid,self)
!      res = ZERO
!   end
!
!   integrate_rho_numerically
!   ! Integrate the density numerically
!      res :: REAL
!      res = .integrate_property(make_density_grid_1)
!      stdout.show("numerically integrated charge =",res)
!   end
!
!   put_atom_kind_map
!   ! Check the atom kind map routine
!      res :: REAL
!      atom_kind,unique_atom :: VEC{INT}*
!      n_atom,n_kind :: INT
!      n_atom = .n_atom
!      atom_kind.create(n_atom)
!      .atom.make_atom_kind_list(atom_kind,n_kind)
!      stdout.text("atom kind")
!      stdout.put(atom_kind,"column")
!      unique_atom.create(n_kind)
!      .atom.make_unique_atom_list(unique_atom)
!      stdout.text("unique atom list")
!      stdout.put(unique_atom,"column")
!      unique_atom.destroy
!      atom_kind.destroy
!   end
!
!   test_eigen
!   !
!      n,i :: INT
!      dot :: REAL
!       m :: MAT{REAL}*
!      eval :: VEC{REAL}*
!      L,R,w :: MAT{REAL}*
!      stdin.read(n)
!      m.create(n,n)
!      stdin.read(m)
!      eval.create(n)
!      L.create(n,n)
!      R.create(n,n)
!      m.solve_general_eigenproblem(eval,L,R)
!      stdout.show("n =",n)
!      stdout.text("eval:")
!      stdout.put(eval,"column")
!      stdout.text("Left eigenvectors:")
!      stdout.put(L)
!      stdout.text("right eigenvectors:")
!      stdout.put(R)
!      w.create(n,n)
!      w.to_product_of(L,R,transpose_a=TRUE)
!      stdout.text("(left)^T x (right) eigenvectors:")
!      stdout.put(w)
!      w.destroy
!      R.destroy
!      L.destroy
!      eval.destroy
!      m.destroy
!   end

! *************************************************************
! Determinant Variation Perturbation Theory (DVPT) SCF routines
! *************************************************************

!   DVPT_scf ::: recursive, leaky
!   ! Do a restricted determinant variation perturbation theory SCF calculation. The following
!   ! are produced as results: .molecular_orbitals, .orbital_energies, .density_matrix
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE( .atom.created,  "no atom list")
!     .make_DVPT_initial_mos
!     .make_DVPT_density_matrices
!     .make_DVPT_fock_matrices
!     .scfdata.set(nuclear_energy=.nuclear_energy)
!     .scfdata.reset(energy=.DVPT_scf_energy, kinetic_energy=ZERO)
!
!   ! stdout.text("D:")
!   ! stdout.put(.density_matrix.restricted)
!   ! stdout.text("F:")
!   ! stdout.put(.fock_matrix.restricted)
!   ! .scfdata.scf_kind="rhf"
!   ! .scfdata.reset(energy=.scf_energy, kinetic_energy=ZERO)
!   ! .scfdata.scf_kind="rdvpt"
!
!     .scfdata.put_banner
!     ! Begin iterations
!     do
!     ! .extrapolate_scf
!       .update_DVPT_orbitals
!       .schmidt_orthonormalise(.molecular_orbitals)
!       .make_DVPT_density_matrices
!       .make_DVPT_fock_matrices
!       .save_DVPT_results
!       .scfdata.update(energy=.DVPT_scf_energy, kinetic_energy=ZERO)
!       .scfdata.put_results
!       if (.scfdata.scf_done) exit
!     end
!     .scfdata.cleanup_diis
!     .fock_matrix.destroy("restricted")
!   end
!
!   update_DVPT_orbitals
!   ! Solve for the new DVPT orbitals and energies. An initial set of orbitals
!   ! and a Fock matrix must already exist in memory. The new molecular orbitals
!   ! "MO*U" are found from the old MOs solving : (MO^T F MO)U = MO^T S MO U E
!   ! where U is a general matrix (since F is not symmetric).
!     MO_energies :: VEC{REAL}*
!     MO,F :: MAT{REAL}*
!     G,U,left :: MAT{REAL}*
!      i :: INT
!     MO_energies => .orbital_energies.restricted
!     MO => .molecular_orbitals.restricted
!     F  => .fock_matrix.restricted
!     G.create(.n_bf,.n_bf)
!     U.create(.n_bf,.n_bf)
!     left.create(.n_bf,.n_bf)
!     G = F
!     G.change_basis_using(MO)
!     ! Level shifting
!     if ( .scfdata.apply_level_shifting) then
!       do i = .n_a + 1, .n_bf
!         G(i,i) = .scfdata.level_shift + G(i,i)
!       end
!     end
!     G.solve_general_eigenproblem(MO_energies,left,U)
!     G.to_product_of(MO,U)
!     MO = G
!     left.destroy
!     U.destroy
!     G.destroy
!   end
!
!   save_DVPT_results
!   ! Save the DVPT results in various archives
!     archive :: ARCHIVE
!      m :: INT
!     .save_scf_results
!     m = .DVPT_order
!     archive.set(.name,"DVPT_mo_"// trim(m.to_str))
!     archive.write(.molecular_orbitals.restricted)
!   end
!
!   make_DVPT_initial_mos ::: leaky
!   ! Make the DVPT initial orbitals. Currently this is just the same
!   ! as the usual initial guess, but the MO's are written to disk.
!       m :: INT
!      MO :: MAT{REAL}*
!      m_archive :: ARCHIVE
!      m = .DVPT_order
!      m_archive.set(.name,"DVPT_mo_"// trim(m.to_str))
!      .scfdata.scf_kind = "rhf"
!      .get_initial_guess
!      .scfdata.scf_kind = "rdvpt"
!      MO => .molecular_orbitals.restricted
!      m_archive.write(MO)
!   end
!
!   DVPT_order result (X)
!   ! Determine the DVPT order by looking for the highest number "X" for
!   ! which a DVPT_mo_X archive file exists.
!       X :: INT
!      archive :: ARCHIVE
!      order :: INT = 999
!      if (order/=999) then
!         X = order
!      else
!         X = 0
!         do
!            archive.set(.name,"DVPT_mo_"// trim(X.to_str))
!            if (NOT archive.exists) exit
!            X = X + 1
!         end
!         order = X
!      end
!   end
!
!   make_DVPT_density_matrices
!   ! Make all the DVPT density matrices up to the required order
!   ! NOTE: the indice order is opposite to the paper.
!      m,j :: INT
!      m = .DVPT_order
!      do j = 0,m
!         .make_DVPT_density_matrix(m,j)
!      end
!      .make_DVPT_eff_density_matrix
!   !  .scfdata.scf_kind = "rhf"
!   !  .make_scf_density_matrix
!   !  .scfdata.scf_kind = "rdvpt"
!   end
!
!   make_DVPT_eff_density_matrix
!   ! Make the effective DVPT fock matrix
!      m,i,j :: INT
!      fac,sum,det :: REAL
!      DD,D :: MAT{REAL}*
!      d_archive :: ARCHIVE
!      .density_matrix.restricted.destroy
!      DD.create(.n_bf,.n_bf); DD = ZERO
!      D.create(.n_bf,.n_bf)
!      m   = .DVPT_order
!      do i = 0,m
!      do j = 0,i
!         fac = TWO
!         if (i==j) fac = ONE
!         .get_DVPT_density_matrix(D,det,i,j)
!         sum = sum + fac*det
!         D = fac*D
!         DD.plus(D)
!      end
!      end
!      DD = DD/sum
!      d_archive.set(.name,"DVPT_density_matrix")
!      d_archive.write(DD)
!      .density_matrix.restricted => DD
!      D.destroy
!   end
!
!   get_DVPT_density_matrix(D,determinant,left,right)
!   ! Get the determinant variation perturbation theory transition density matrix
!   ! for a left determinant orbitals "left" and  a right determinant orbitals "right".
!   ! Make the density if the archive does not exist.
!       D :: MAT{REAL}
!      determinant :: REAL
!      left,right :: INT
!      d_archive :: ARCHIVE
!      label :: STR
!      label = trim(left.to_str) // trim(right.to_str)
!      d_archive.set(.name,"DVPT_density_"// label)
!      if (NOT d_archive.exists) .make_DVPT_density_matrix(left,right)
!      d_archive.read(D)
!      d_archive.set(.name,"DVPT_determinant_"// trim(left.to_str) // trim(right.to_str))
!      d_archive.read(determinant)
!   end
!
!   make_DVPT_density_matrix(left,right)
!   ! Make the determinant variation perturbation theory transition density matrix
!   ! for a left determinant orbitals "left" and  a right determinant orbitals "right".
!   ! The density and determinant are stored as archives on disk.
!      left,right :: INT
!      D,L,R :: MAT{REAL}*
!      l_archive,r_archive,d_archive :: ARCHIVE
!      determinant :: REAL
!      D.create(.n_bf,.n_bf)
!      l_archive.set(.name,"DVPT_mo_"// trim(left.to_str))
!      r_archive.set(.name,"DVPT_mo_"// trim(right.to_str))
!   ENSURE(l_archive.exists, "no DVPT mo archive, no. ="// trim(left.to_str))
!   ENSURE(r_archive.exists, "no DVPT mo archive, no. ="// trim(right.to_str))
!      L.create(.n_bf,.n_bf)
!      R.create(.n_bf,.n_bf)
!      l_archive.read(L)
!      r_archive.read(R)
!      ! Make density matrix using occupied orbitals only
!      .make_DVPT_density_matrix(D,determinant,L(:,:.n_a),R(:,:.n_a))
!
!      !       stdout.show("det =",determinant)
!      !       stdout.text("MO:")
!      !       stdout.put(L(:,.n_a))
!      !       stdout.text("D:")
!      !       stdout.put(TWO*D)
!
!      R.destroy
!      L.destroy
!      d_archive.set(.name,"DVPT_density_"// trim(left.to_str) // trim(right.to_str))
!      d_archive.write(D)
!      d_archive.set(.name,"DVPT_determinant_"// trim(left.to_str) // trim(right.to_str))
!      d_archive.write(determinant)
!      D.destroy
!   end
!
!   make_DVPT_density_matrix(D,determinant,left,right)
!   ! Make the determinant variation perturbation theory transition density matrix "D" for a
!   ! left determinant of occupied orbitals "left" and a right determinant of occupied
!   ! orbitals "right". Also return the "determinant" of the orbital ovarlap matrix.
!       D :: MAT{REAL}
!      left,right :: MAT{REAL}
!      determinant :: REAL
!      S,O,C :: MAT{REAL}*
!      dim :: INT
!   ENSURE(size(D,1)==size(D,2),"D is not square")
!   ENSURE(size(D,1)==.n_bf,"D has wrong size")
!   ENSURE(size(left,1) ==.n_bf,"left has wrong size")
!   ENSURE(size(right,1)==.n_bf,"right has wrong size")
!   ENSURE(size(left,2)==size(right,2),"left and and right are incompatible")
!      dim = size(left,2)
!      S.create(dim,dim)
!      O.create(.n_bf,.n_bf)
!      .make_overlap_matrix(O)
!      O.change_basis_using(S,left,right)
!      O.destroy
!      C.create(dim,dim)
!      .make_cofactor(C,determinant,S)
!      C.back_transform_to(D,right,left)
!      C.destroy
!      S.destroy
!   end
!
!   make_cofactor(C,determinant,S)
!   ! Make the cofactor matrix "C" and "determinant" for the matrix "S".
!   ! Note: this constructs the alpha-alpha part of the cofactor, but the
!   ! determinant is that for the full overlap matrix
!      C,S :: MAT{REAL}
!      determinant :: REAL
!      eval,n :: VEC{REAL}*
!      left,right,W :: MAT{REAL}*
!      dim,i :: INT
!      dot :: REAL
!   ENSURE(size(C,1)==size(C,2),"C is not square")
!   ENSURE(size(S,1)==size(S,2),"incorrect size for array S")
!   ENSURE(size(S,1)==size(C,1),"array C and array S incompatible")
!      dim = size(C,1)
!      left.create(dim,dim)
!      right.create(dim,dim)
!      eval.create(dim)
!      ! Get the eigenvalues and determinant of S
!      S.solve_general_eigenproblem(eval,left,right)
!      determinant = product(eval)
!      determinant = determinant*determinant ! include beta part
!      ! Make the cofactor
!      n.create(dim)
!      n = determinant/eval
!      W.create(dim,dim)
!      W.to_product_with_diagonal(n,left,transpose_a=TRUE)
!      C = matmul(right,W)
!
!    ! stdout.text("*********make_cofactor**************")
!    ! stdout.text("S:")
!    ! stdout.put(S)
!    ! stdout.text("n:")
!    ! stdout.put(n,format="column")
!    ! stdout.text("L:")
!    ! stdout.put(left)
!    ! stdout.text("R:")
!    ! stdout.put(right)
!    ! W = matmul(right,transpose(left))
!    ! stdout.text("R L^T:")
!    ! stdout.put(W)
!    ! W = matmul(transpose(left),right)
!    ! stdout.text("L^T R:")
!    ! stdout.put(W)
!    ! stdout.text("C:")
!    ! stdout.put(C)
!    ! stdout.text("************************************")
!
!      W.destroy
!      n.destroy
!      eval.destroy
!      right.destroy
!      left.destroy
!   end
!
!   make_DVPT_fock_matrices ::: leaky
!   ! Make the DVPT fock matrices up to the required order,
!   ! including the effective fock matrix
!      m,j :: INT
!      m = .DVPT_order
!      do j = 0,m
!         .make_DVPT_fock_matrix(m,j)
!      end
!      .make_DVPT_eff_fock_matrix
!   !  .scfdata.scf_kind = "rhf"
!   !  .make_fock_matrix
!   !  .scfdata.scf_kind = "rdvpt"
!   end
!
!   make_DVPT_eff_fock_matrix ::: leaky
!   ! Make the effective DVPT fock matrix
!      m,j :: INT
!      E_m,E_mj,sum,det :: REAL
!      FF,F,W,D :: MAT{REAL}*
!      f_archive :: ARCHIVE
!      .fock_matrix.restricted.destroy
!      FF.create(.n_bf,.n_bf); FF = ZERO
!      F.create(.n_bf,.n_bf)
!      W.create(.n_bf,.n_bf)
!      D.create(.n_bf,.n_bf)
!      m   = .DVPT_order
!      E_m = .DVPT_electronic_energy
!      sum = ZERO
!      do j = 0,m
!         .get_DVPT_fock_matrix(F,m,j)
!         .get_DVPT_density_matrix(D,det,m,j)
!         sum = sum + det
!         det = 1/(TWO*det)
!         FF.plus(F)
!         .add_core_hamiltonian(FF)
!         E_mj = E_m + det*F.trace_of_product(D)
!         .make_overlap_matrix(F)
!         W.to_product_of(D,F)
!         D.to_product_of(F,W)
!         FF = FF - E_mj*D
!      end
!      FF = FF/sum
!      f_archive.set(.name,"DVPT_effective_fock_"// trim(m.to_str))
!      f_archive.write(FF)
!      .fock_matrix.restricted => FF
!      D.destroy
!      W.destroy
!      F.destroy
!   end
!
!   get_DVPT_fock_matrix(F,left,right)
!   ! Get the determinant variation perturbation theory transition Fock matrix
!   ! for a left determinant orbitals "left" and  a right determinant orbitals "right".
!       F :: MAT{REAL}
!      left,right :: INT
!      f_archive :: ARCHIVE
!      label :: STR
!      label = trim(left.to_str) // trim(right.to_str)
!      f_archive.set(.name,"DVPT_fock_"// label)
!      if (NOT f_archive.exists) .make_DVPT_fock_matrix(left,right)
!      f_archive.read(F)
!   end
!
!   make_DVPT_fock_matrix(left,right)
!   ! Make the determinant variation perturbation theory transition fock matrix
!   ! for a left determinant orbitals "left" and  a right determinant orbitals "right".
!   ! The Fock matrix is stored as an archive on disk.
!      left,right :: INT
!       F :: MAT{REAL}*
!      f_archive :: ARCHIVE
!      label :: STR
!      F.create(.n_bf,.n_bf)
!      .make_DVPT_fock_matrix(F,left,right)
!      label = trim(left.to_str) // trim(right.to_str)
!      f_archive.set(.name,"DVPT_fock_"// label)
!      f_archive.write(F)
!      F.destroy
!   end
!
!   make_DVPT_fock_matrix(F,left,right)
!   ! Make the determinant variation perturbation theory transition fock matrix for
!   ! a left determinant of orbitals "left" and a right determinant of orbitals
!   ! "right". If present, "D" is used as the density matrix.
!       F :: MAT{REAL}
!      left,right :: INT
!       P :: MAT{REAL}*
!      determinant,fac :: REAL
!      P.create(.n_bf,.n_bf)
!      .get_DVPT_density_matrix(P,determinant,left,right)
!   !  .make_r_asymmetric_fock(P,F,direct=FALSE,core=FALSE,r12=TRUE)
!      .make_r_fock(P,F,direct=FALSE,core=FALSE,r12=TRUE)
!      fac = TWO/determinant
!      F = fac*F
!      P.destroy
!   end
!
!   make_r_fock(P,F,direct,core,r12) ::: leaky
!   ! Make a new restricted Fock matrix "F" from the density matrix "P".
!   ! If present and TRUE , "direct" means calculate integrals on the fly
!   ! If present and FALSE, "core" removes the core matrix contribution
!   ! If present and FALSE, "r12"  removes the two electron contribution
!     direct,core,r12 :: BIN, optional
!     P,F :: MAT{REAL}
!     J,K :: MAT{REAL}*
!     do_direct,add_core,add_r12 :: BIN
!
!     do_direct= FALSE
!     add_core = TRUE
!     add_r12  = TRUE
!     if (present(direct)) do_direct = direct
!     if (present(core))   add_core = core
!     if (present(r12))    add_r12  = r12
!     if (add_r12) then
!        J.create(.n_bf,.n_bf)
!        K.create(.n_bf,.n_bf)
!        if (do_direct) then; .make_r_JK_direct(J,K,P)
!        else;                .make_r_JK_disk(J,K,P)
!        end
!        F = J - HALF*K
!        K.destroy
!        J.destroy
!     else
!        F = ZERO
!     end
!     if (add_core) .add_core_hamiltonian(F)
!   end
!
!   make_r_asymmetric_fock(P,F,direct,core,r12) ::: leaky
!   ! Make a new restricted Fock matrix "F" from an asymmetric density matrix "P".
!   ! If present and TRUE , "direct" means calculate integrals on the fly
!   ! If present and FALSE, "core" removes the core matrix contribution
!   ! If present and FALSE, "r12"  removes the two electron contribution
!     direct,core,r12 :: BIN, optional
!     P,F :: MAT{REAL}
!     J,K :: MAT{REAL}*
!     do_direct,add_core,add_r12 :: BIN
!   ENSURE(size(F,1)==.n_bf, "Fock matrix dimensions wrong")
!   ENSURE(size(P,1)==.n_bf, "Density matrix dimensions wrong")
!     do_direct= FALSE
!     add_core = TRUE
!     add_r12  = TRUE
!     if (present(direct)) do_direct = direct
!     if (present(core))   add_core = core
!     if (present(r12))    add_r12  = r12
!     if (add_r12) then
!        J.create(.n_bf,.n_bf)
!        K.create(.n_bf,.n_bf)
!        if (do_direct) then; .make_r_asymmetric_JK_direct(J,K,P)
!        else;                .make_r_asymmetric_JK_disk(J,K,P)
!        end
!        F = J - HALF*K
!        K.destroy
!        J.destroy
!     else
!        F = ZERO
!     end
!     if (add_core) then
!       .add_core_hamiltonian(F)
!     end
!   end
!
!   make_r_asymmetric_JK_direct(J,K,P)
!   ! Make the real coulomb matrices "J" and exchange matrix "K"  from an
!   ! asymmetric density matrix "P" directly from the integrals.
!     J,K,P :: MAT{REAL}
!      I :: MAT4{REAL}*
!     shell4 :: SHELL4*
!     I_max :: VEC{REAL}*
!     ac,ab,cd,aa,cc :: INT
!     a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     cutoff,I_abcd,factor :: REAL
!     skip :: BIN
!     J = ZERO
!     K = ZERO
!     cutoff = .scfdata.eri_schwarz_cutoff
!     shell4.create
!     I_max.create(.n_shell_pairs)
!     .make_max_abab_integrals(I_max)
!     do ab = 1,.n_shell_pairs
!       .get_shell_pair(ab,a,b)
!       fa = .first_basis_fn_for_shell(a)
!       fb = .first_basis_fn_for_shell(b)
!       la = .last_basis_fn_for_shell(a)
!       lb = .last_basis_fn_for_shell(b)
!       do cd = 1,ab
!         .get_shell_pair(cd,c,d)
!         fc = .first_basis_fn_for_shell(c)
!         fd = .first_basis_fn_for_shell(d)
!         lc = .last_basis_fn_for_shell(c)
!         ld = .last_basis_fn_for_shell(d)
!         .get_shell_quartet(shell4,a,b,c,d)
!         skip = .schwarz_inequality_test(cutoff,ab,cd,fa,la,fb,lb,fc,lc,fd,ld,P,I_max)
!         if (skip) then
!            shell4.destroy_ptr_part
!            cycle
!         end
!         I.create(fa,la,fb,lb,fc,lc,fd,ld)
!         shell4.get_ERI(I)
!         factor = ONE                                ! Evaluate the integrals
!         if (a==b)          factor = HALF            ! Coincidence factors
!         if (c==d)          factor = HALF * factor
!         if (a==c AND b==d) factor = HALF * factor
!         do d = fd,ld
!         do c = fc,lc
!         do b = fb,lb
!         do a = fa,la
!            I_abcd = factor * I(a,b,c,d)
!            J(a,b) = J(a,b) + I_abcd*(P(d,c)+P(c,d)) ! These are symmetric
!            J(c,d) = J(c,d) + I_abcd*(P(b,a)+P(a,b))
!            K(a,d) = K(a,d) + I_abcd*P(b,c)          ! These are asymmetric
!            K(a,c) = K(a,c) + I_abcd*P(b,d)
!            K(b,c) = K(b,c) + I_abcd*P(a,d)
!            K(b,d) = K(b,d) + I_abcd*P(a,c)
!            K(d,a) = K(d,a) + I_abcd*P(c,b)
!            K(c,a) = K(c,a) + I_abcd*P(d,b)
!            K(c,b) = K(c,b) + I_abcd*P(d,a)
!            K(d,b) = K(d,b) + I_abcd*P(c,a)
!         end
!         end
!         end
!         end
!         I.destroy
!         shell4.destroy_ptr_part
!       end
!     end
!     I_max.destroy
!     shell4.destroy
!     .weight_diagonal_blocks(J,TWO)
!     J.make_symmetric
!   end
!
!   make_r_asymmetric_JK_disk(J,K,P)
!   ! Make the real coulomb matrices "J" and exchange matrix "K"  from an
!   ! asymmetric density matrix "P" using disk integrals.
!     J,K,P :: MAT{REAL}
!     eri_archive,ind_archive :: ARCHIVE
!      I :: MAT4{REAL}*
!     q,n_quartets,a,b,c,d,fa,fb,fc,fd,la,lb,lc,ld :: INT
!     I_abcd :: REAL
!     eri_archive.create(.name,"eri_integrals")
!     ind_archive.create(.name,"eri_index")
!   ENSURE(.basis_info_made, "no basis set")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(eri_archive.exists, "no integral file")
!   ENSURE(ind_archive.exists, "no integral index file")
!     eri_archive.open(for="read-only",buffered=TRUE,type="real")
!     ind_archive.open(for="read-only",buffered=TRUE,type="int")
!     J = ZERO
!     K = ZERO
!     n_quartets = .n_shell_quartets
!     do
!        ind_archive.file.read(q)
!        if (q > n_quartets) exit
!        .get_shell_quartet(q,fa,la,fb,lb,fc,lc,fd,ld)
!        I.create(fa,la,fb,lb,fc,lc,fd,ld)
!        eri_archive.file.read(I)
!        do d = fd,ld
!        do c = fc,lc
!        do b = fb,lb
!        do a = fa,la
!           I_abcd = I(a,b,c,d)
!           J(a,b) = J(a,b) + I_abcd*(P(d,c)+P(c,d)) ! These are symmetric
!           J(c,d) = J(c,d) + I_abcd*(P(b,a)+P(a,b))
!           K(a,d) = K(a,d) + I_abcd*P(b,c)          ! These are asymmetric
!           K(a,c) = K(a,c) + I_abcd*P(b,d)
!           K(b,c) = K(b,c) + I_abcd*P(a,d)
!           K(b,d) = K(b,d) + I_abcd*P(a,c)
!           K(d,a) = K(d,a) + I_abcd*P(c,b)
!           K(c,a) = K(c,a) + I_abcd*P(d,b)
!           K(c,b) = K(c,b) + I_abcd*P(d,a)
!           K(d,b) = K(d,b) + I_abcd*P(c,a)
!        end
!        end
!        end
!        end
!        I.destroy
!     end
!     ind_archive.destroy
!     eri_archive.destroy
!     .weight_diagonal_blocks(J,TWO)
!     J.make_symmetric
!   end
!
!   get_shell_pair_indices_from(index,a,b)
!   ! Return the actual shell indicies "a" and "b" which map to "index"
!     index :: INT, IN
!     a,b :: INT, OUT
!     a  = (1+sqrt(8.0d0*index-7.0d0))/2
!     b  = index - a*(a-1)/2
!   end
!
!   DVPT_scf_energy result (res)
!   ! Evaluates the determinant variation perturbation theory SCF energy
!   ! (including the nuclear repulsion contribution)
!     res :: REAL
!     res = .DVPT_electronic_energy + .nuclear_energy
!   end
!
!   DVPT_electronic_energy result (res)
!   ! Evaluates the SCF electronic energy
!     res :: REAL
!     scf_kind :: STR
!     F,D :: MAT{REAL}*
!     m,i,j :: INT
!     fac,det,sum :: REAL
!     m = .DVPT_order
!     scf_kind = .scfdata.scf_kind
!     select case (scf_kind)
!        case ("rdvpt","restricted_dvpt")
!           F.create(.n_bf,.n_bf)
!           D.create(.n_bf,.n_bf)
!           res = ZERO
!           sum = ZERO
!           do i = 0,m
!           do j = 0,i
!              fac = TWO
!              if (i==j) fac = ONE
!              .get_DVPT_density_matrix(D,det,i,j)
!              .get_DVPT_fock_matrix(F,i,j)
!              .add_core_hamiltonian(F)
!
!           !  stdout.show("i   =",i)
!           !  stdout.show("j   =",j)
!           !  stdout.show("det =",det)
!           !  stdout.text("D:")
!           !  stdout.put(TWO*D)
!           !  stdout.text("F:")
!           !  stdout.put(F)
!
!              .add_core_hamiltonian(F)
!              res = res + fac*F.trace_of_product(D)
!              sum = sum + fac*det
!           end
!           end
!           res = res/sum
!           D.destroy
!           F.destroy
!        case default; DIE("not yet implemented, " // .scfdata.scf_kind)
!     end
!   end

!   make_spin_b_field_grid(bb,pt,Dx,Dy,Dz)
!   ! Make the magnetic B field "bb" due to the spin density at a set of points
!   ! given in "pt" using three real symmetric AO density matrices "Dx", "Dy" and
!   ! "Dz" corresponding to the Sx, Sy and Sz densities. Note: the contribution
!   ! is added to whatever is already in bb. Note: factor of half in the
!   ! densities is assumed.
!      bb,pt :: MAT{REAL}
!      Dx,Dy,Dz :: MAT{REAL}
!   ENSURE(.basis_info_made,"no basis set")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(pt.dim2==3,"no basis set")
!   ENSURE(Dx.dim1==.n_bf AND Dx.is_square,"wrong shape for Dx")
!   ENSURE(Dy.dim1==.n_bf AND Dy.is_square,"wrong shape for Dy")
!   ENSURE(Dz.dim1==.n_bf AND Dz.is_square,"wrong shape for Dz")
!      DD :: MAT3{REAL}*
!      M :: MAT4{REAL}*
!      Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz :: MAT{REAL}*
!      q,fa,fb,la,lb,n, n_pt, i,j,k :: INT
!      eps :: MAT3{REAL}(3,3,3)
!      fac :: REAL
!      shell :: SHELL2
!      n_pt = size(pt,1)
!      bb = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(shell,q,fa,la,fb,lb)
!        DD.create(shell.b.n_comp,shell.a.n_comp,3)
!        DD(:,:,1) = Dx(fb:lb,fa:la)
!        DD(:,:,2) = Dy(fb:lb,fa:la)
!        DD(:,:,3) = Dz(fb:lb,fa:la)
!        fac = ONE; if (fa==fb) fac=HALF
!        M.create(shell.a.n_comp,shell.b.n_comp,3,3)
!        Mxx => M(:,:,1,1); Mxy => M(:,:,1,2); Mxz => M(:,:,1,3)
!        Myx => M(:,:,2,1); Myy => M(:,:,2,2); Myz => M(:,:,2,3)
!        Mzx => M(:,:,3,1); Mzy => M(:,:,3,2); Mzz => M(:,:,3,3)
!        do n = 1,n_pt
!          shell.make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,pt(n,:))
!          do i = 1,3
!          do j = 1,3
!          do k = 1,3
!             eps(i,j,k) = M(:,:,i,j).trace_product_with(DD(:,:,k))
!          end
!          end
!          end
!          bb(n,1) = bb(n,1) + eps(:,:,1).trace - eps(1,:,:).trace
!          bb(n,2) = bb(n,2) + eps(:,:,2).trace - eps(2,:,:).trace
!          bb(n,3) = bb(n,3) + eps(:,:,3).trace - eps(3,:,:).trace
!        end
!        M.destroy
!        DD.destroy
!        shell.destroy_ptr_part
!      end
!   !  bb.zero_small_values(TOL(10))
!      bb = -bb ! this is -g_e mu_b; the final answer is in units of mu_0/4pi
!   end

!   make_spin_b_field
!   ! Make the magnetic B field "bb" due to the spin density at a set of points
!   ! given in "pt"
!      self :: target
!      B,pt,Dx,Dy,Dz :: MAT{REAL}*
!      dmc :: MAT3{CPX}*
!      aa,bb :: REAL
!      xv :: VEC{REAL}(3)
!      n_pt,i,j,k,n :: INT
!      n_pt = 60*75
!      n_pt = 56
!      dmc.create(160,160,4)
!      ! Read the density matrix
!      open(unit=13,file="opdens",status="old")
!      do i=1,160
!      do j=1,160
!      do k=1,4
!         read(13,*) dmc(i,j,k)
!      end
!      end
!      end
!      close(13)
!      ! Make the points array
!      pt.create(n_pt,3)
!      aa=7.4/sqrt(2.0)
!!      bb=0.2/sqrt(2.0)
!      bb=2./sqrt(2.0)
!      xv(1)=aa
!      xv(2)=-xv(1)
!      n = 0
!!      do i=1,75
!      do i=1,8
!        xv(3)=5.4
!   !     do j=1,59
!        do j=1,6
!          n = n + 1
!          pt(n,:) = xv
!    !      xv(3)=xv(3)-0.2
!          xv(3)=xv(3)-2.
!        end
!        n = n + 1
!        pt(n,:) = xv ! make one more point
!        xv(1)=xv(1)-bb
!        xv(2)=-xv(1)
!      end
!      Dx.create(160,160)
!      Dy.create(160,160)
!      Dz.create(160,160)
!      Dx =  dmc(:,:,2) + dmc(:,:,3)  * 0.5     ! ab + ba
!      Dy = (dmc(:,:,2) - dmc(:,:,3)) * (0,0.5) ! -i ab + i ba
!      Dz =  dmc(:,:,1) - dmc(:,:,4)  * 0.5     ! aa - bb
!      B.create(n_pt,3)
!      .MAIN:make_spin_b_field_grid(B,pt,Dx,Dy,Dz)
!      ! Write out the answer
!      stdout.flush
!      stdout.text("The magnetic field from the spin")
!      stdout.put(B)
!      B.destroy
!      Dz.destroy
!      Dy.destroy
!      Dx.destroy
!      pt.destroy
!   end

!   make_divergence_j_para
!   ! Make the divergence of the paramagnetic current at a set of points
!   ! given in "pt"
!      B,pt,Dx,Dy,Dz :: MAT{REAL}*
!      dmc :: MAT3{CPX}*
!      aa,bb :: REAL
!      xv :: VEC{REAL}(3)
!      n_pt,i,j,k,n :: INT
!      n_pt = 60*75
!      n_pt = 56
!      dmc.create(160,160,4)
!      ! Read the density matrix
!      open(unit=13,file="opdens",status="old")
!      do i=1,160
!      do j=1,160
!      do k=1,4
!         read(13,*) dmc(i,j,k)
!      end
!      end
!      end
!      close(13)
!      ! Make the points array
!      pt.create(n_pt,3)
!      aa=7.4/sqrt(2.0)
!!      bb=0.2/sqrt(2.0)
!      bb=2./sqrt(2.0)
!      xv(1)=aa
!      xv(2)=-xv(1)
!      n = 0
!!      do i=1,75
!      do i=1,8
!        xv(3)=5.4
!   !     do j=1,59
!        do j=1,6
!          n = n + 1
!          pt(n,:) = xv
!    !      xv(3)=xv(3)-0.2
!          xv(3)=xv(3)-2.
!        end
!        n = n + 1
!        pt(n,:) = xv ! make one more point
!        xv(1)=xv(1)-bb
!        xv(2)=-xv(1)
!      end
!      Dx.create(160,160)
!      Dy.create(160,160)
!      Dz.create(160,160)
!      Dx =  dmc(:,:,2) + dmc(:,:,3)  * 0.5     ! ab + ba
!      Dy = (dmc(:,:,2) - dmc(:,:,3)) * (0,0.5) ! -i ab + i ba
!      Dz =  dmc(:,:,1) - dmc(:,:,4)  * 0.5     ! aa - bb
!      B.create(n_pt,3)
!      .make_spin_b_field_grid(B,pt,Dx,Dy,Dz)
!      ! Write out the answer
!      stdout.flush
!      stdout.text("The magnetic field from the spin")
!      stdout.put(B)
!      B.destroy
!      Dz.destroy
!      Dy.destroy
!      Dx.destroy
!      pt.destroy
!   end

   cleanup ::: leaky
   ! Clean up all undeleted memory in all modules.
      self :: PTR
      atom :: ATOM
      basis :: BASIS
      coppensbasis :: COPPENSBASIS
      coppensorbital :: COPPENSORBITAL
      geminal :: GEMINAL_MF_SPECTRUM
      reflection :: REFLECTION
      shell :: SHELL
      slaterbasis :: SLATERBASIS
      slatershell :: SLATERSHELL

      GAUSSIAN_DATA:destroy_data ! Gaussian indices
      atom.clear_keys
      basis.clear_keys
      coppensbasis.clear_keys
      coppensorbital.clear_keys
      geminal.clear_keys
      reflection.clear_keys
      shell.clear_keys
      slaterbasis.clear_keys
      slatershell.clear_keys
      .destroy

   end

   run
   ! Main molecule run-loop; assumes stdin and stdout have been defined.
      self :: PTR
      .create
      .MAIN:put_banner
      .MAIN:read_keywords   ! do it here
      stdout.flush
      stdout.text(std_time.elapsed_time_message("job "//'"'// trim(.name) //'"'))
      stdout.text(std_time.elapsed_cpu_time_message("job "//'"'// trim(.name) //'"'))
      if (tonto.warnings_issued) then
      stdout.flush
      stdout.text("WARNINGS were issued in this job.")
      stdout.text("Look above, or in the stderr file.")
      end
      .destroy
   end

   put_banner
   ! Put to stdout the current TONTO banner
     stdout.text(" ")
     stdout.text("---------------------------------------------------------------")
     stdout.text("                                                               ")
     stdout.text(" T   O   N   T   O                                             ")
     stdout.text("                                                               ")
     stdout.text(" A free object-based system for computational chemistry        ")
     stdout.text("                                                               ")
     stdout.text(" Version: "//TONTO_VERSION//" ($Rev$)")
     stdout.text(" Platform: "//TONTO_PLATFORM)
     stdout.text(" Build-date: "//TONTO_BUILD_DATE)
     stdout.text("                                                               ")
     stdout.text(" For conditions of use, on-line documentation, and contributor ")
     stdout.text(" and developer information see :-                              ")
     stdout.text("                                                               ")
     stdout.text(" www."//"theochem."//"uwa."//"edu."//"au/tonto/                ")
     stdout.text("                                                               ")
     stdout.text(" Dylan Jayatilaka                                              ")
     stdout.text(" Daniel Grimwood                                               ")
     stdout.text("---------------------------------------------------------------")
     stdout.text(" ")
     stdout.text(std_time.start_time_message)
   end

   reset_molecule ::: leaky
   ! Resets the mol data type and reruns the read routine
      self :: PTR
      word :: STR
      .destroy
      .create
      stdin.read(word)          ! First keyword must be "name"
      word.to_lower_case
      ENSURE(word=="name=","first keyword must be name")
      stdin.read(.name)
   end

!   read_keywords ::: get_from(OBJECT, process_keyword=>MAIN:process_keyword), recursive, leaky
!   ! Read data from "stdin" using keyword style input.
!      self :: PTR
!   end

   read_keywords ::: recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")
      word :: STR
      stdin.read(word)
      stdout.flush
      stdout.text("keyword found --> " // trim(word))
      do                 ! Loop over input keywords
         stdin.read(word)
         DIE_IF(stdin.reverted,"unexpected end of file while reading keywords")
         word.to_lower_case
         if (NOT stdin.buffer_exhausted) then 
         if (stdin.next_item=="=") then ! assume this is an attached = sign
            stdin.skip_next_item
            word = trim(word) // "="
         end
         end
         stdout.flush
         stdout.text("keyword found --> " // trim(word))
         if (word=="}")      exit
         .MAIN:process_keyword(word)
      end
   end

!   read_keywords ::: get_from(OBJECT, process_keyword=>MAIN:process_keyword), recursive, leaky
!   ! Read data from "stdin" using keyword style input.
!      self :: PTR
!      word :: STR
!      stdin.read(word)
!   ENSURE(word=="{","expecting an open bracket symbol, {")
!      read_loop: do          ! Loop over keywords
!         stdin.read(word)
!         if (word=="}")      exit read_loop
!         if (stdin.reverted) exit read_loop
!         word.to_lower_case
!         .MAIN:process_keyword(word)
!      end do read_loop
!   end

   process_keyword(keyword) ::: recursive, leaky
   ! Process a keyword "word". Data is inputted from "stdin", unless
   ! "word" is a sequence of blank separated strings. In this case,
   ! the sequence is processed as if it were a separate file.
   ! NOTE : this routine reuires a MOLECULE pointer self variable
      self :: PTR
      keyword :: STR
      timer :: TIME

      timer.start_timing

      select case (keyword(1:30))
        case ("}                             "); ! exit case
        case ("assign_nos_to_mos             "); .assign_NOs_to_MOs
        case ("atoms=                        "); .read_atoms
        case ("atom_groups=                  "); .read_atom_groups
        case ("b_field=                      "); .read_B_field
        case ("basis_sets=                   "); .read_basis_sets
        case ("basis_directory=              "); .read_basis_directory
        case ("basis_name=                   "); .read_basis_name
        case ("becke_grid=                   "); .read_becke_grid
      ! case ("canonicalize_mos              "); .canonicalize_mos
        case ("change_axis_system_to         "); .change_axis_system_to
        case ("change_to_principal_axes      "); .change_to_principal_axes
        case ("change_to_principal_top_axes  "); .change_to_principal_top_axes
        case ("charge=                       "); .read_charge
        case ("check_dispersion_correction   "); .check_dispersion_correction
        case ("cif=                          "); .MAIN:read_CIF
        case ("cleanup_scf                   "); .cleanup_scf
        case ("cluster=                      "); .read_cluster
        case ("coppensbasis_name=            "); .read_coppensbasis_name
      ! case ("coppens_basis_sets=           "); .read_coppensbasis_sets
        case ("create_cluster                "); .create_cluster
        case ("crystal=                      "); .read_crystal
        case ("debug_on                      "); .read_debug_on
        case ("debug_off                     "); .read_debug_off
        case ("delete_plot_grid              "); .delete_plot_grid
        case ("delete_scf_integrals          "); .delete_scf_integrals
        case ("delete_scf_archives           "); .delete_scf_archives
        case ("destroy_cluster               "); .destroy_cluster
      ! case ("dftgrid=                      "); .read_dftgrid
      ! case ("dvpt_scf                      "); .DVPT_scf
        case ("e_field=                      "); .read_E_field
      ! case ("fit_adps_ls                   "); .MAIN:fit_ADPs_ls
      ! case ("fit_adps_asym_ls              "); .MAIN:fit_ADPs_asym_ls
      ! case ("fit_adps_normal               "); .MAIN:fit_ADPs_normal
      ! case ("fit_adps_normal_asym          "); .MAIN:fit_ADPs_normal_asym
      ! case ("fit_adps_plus_se_ls           "); .MAIN:fit_ADPs_plus_se_ls
        case ("fit_hirshfeld_atoms           "); .MAIN:fit_Hirshfeld_atoms
        case ("fit_hirshfeld_atoms_bfgs      "); .MAIN:fit_Hirshfeld_atoms_BFGS
        case ("fit_hirshfeld_atom_kappas     "); .MAIN:fit_Hirshfeld_atom_kappas
      ! case ("fit_hirshfeld_atoms_ls        "); .MAIN:fit_Hirshfeld_atoms_ls
        case ("force_thermal_symmetry        "); .MAIN:force_thermal_symmetry
        case ("gauge_origin=                 "); .read_gauge_origin
      ! case ("geminal_mf_spectrum=          "); .MAIN:read_geminal_mf_spectrum
      ! case ("gradient                      "); .hf_scf_energy_gradient
        case ("group_charges=                "); .read_group_charges
        case ("integrate_density_numerically "); .MAIN:integrate_density_numerically
        case ("interpolator=                 "); .MAIN:read_interpolator
        case ("invariom_database_directory=  "); .MAIN:read_invariom_directory
        case ("invariom_refinement=          "); .MAIN:read_invariom_refinement
        case ("isosurface=                   "); .read_isosurface
        case ("isosurface_plot               "); .isosurface_plot
      ! case ("integrate_density_functional  "); .integrate_density_functional
        case ("localise_mos=                 "); .MAIN:localise_MOs
        case ("locate_memory_leak            "); .MAIN:locate_memory_leak
        case ("make_ano_data                 "); .make_ANO_data
        case ("make_ao_density_matrix        "); .make_ao_density_matrix
        case ("make_ao_sz_density_matrix     "); .make_ao_sz_density_matrix
        case ("make_fermi_mobility_grid      "); .make_fermi_mobility_grid
        case ("make_file_delta_density_grid  "); .MAIN:make_file_delta_density_grid
        case ("make_file_delta_spin_grid     "); .MAIN:make_file_delta_spin_grid
        case ("make_fock_guess               "); .make_fock_guess
        case ("make_fock_matrix              "); .make_fock_matrix
        case ("make_h_structure_factors      "); .MAIN:make_H_structure_factors
        case ("make_irrotational_jp_grid     "); .make_irrotational_jp_grid
        case ("make_monomer_mos              "); .make_monomer_MOs
        case ("make_natural_orbitals         "); .make_natural_orbitals
      ! case ("make_pcc_b_field              "); .make_pcc_b_field
      ! case ("make_pcc_densities            "); .make_pcc_densities
      ! case ("make_pcc_L_matrices           "); .make_pcc_L_matrices
      ! case ("make_pcc_structure_factors    "); .make_pcc_structure_factors
      ! case ("make_pnd_scalar_magnetic_sf   "); .make_PND_scalar_magnetic_sf
        case ("make_progroup_density_matrix  "); .make_progroup_density_matrix
        case ("make_promolecule_density      "); .make_promolecule_density
        case ("make_promol_density_matrix    "); .make_promolecule_density
        case ("make_group_density_matrix     "); .make_group_density_matrix
        case ("make_promol_mos               "); .make_promol_MOs
        case ("make_scf_density_matrix       "); .make_scf_density_matrix(damp=FALSE)
      ! case ("make_spin_b_field             "); .MAIN:make_spin_b_field
        case ("make_spherically_averaged_bdas"); .MAIN:make_averaged_BDAs
        case ("make_spherically_averaged_has "); .MAIN:make_spherically_averaged_HAs
        case ("make_structure_factors        "); .make_x_structure_factors
        case ("make_symortho_density_matrix  "); .make_group_density_matrix
        case ("make_sz_structure_factors     "); .make_n_structure_factors
        case ("make_vib_averaged_rho_grid    "); .make_vib_averaged_rho_grid
        case ("make_weak_force_energy_shift  "); .make_weak_force_energy_shift
        case ("move_origin                   "); .move_origin
        case ("move_origin_to_centre_of_atoms"); .move_origin_to_centre_of_atoms
        case ("move_origin_to_centre_of_mass "); .move_origin_to_centre_of_mass
        case ("memory_limit=                 "); .MAIN:read_memory_limit
        case ("multiplicity=                 "); .read_multiplicity
        case ("name=                         "); .read_name
      ! case ("optimise_geometry             "); .optimise_geometry
        case ("optimise_orbitals             "); .MAIN:optimise_orbitals
        case ("optimise_thermal_parameters=  "); .read_optimise_thermals
        case ("output_style_options=         "); .MAIN:read_output_style_options
        case ("plot                          "); .plot
        case ("plot_grid=                    "); .read_plot_grid
        case ("plot_on_isosurface            "); .plot_on_isosurface
      ! case ("plot_covalent_density_orbitals"); .plot_covalent_density_orbitals
      ! case ("plot_covalent_orbitals        "); .plot_covalent_orbitals
      ! case ("plot_ionic_density_orbitals   "); .plot_ionic_density_orbitals
      ! case ("plot_ionic_orbitals           "); .plot_ionic_orbitals
      ! case ("plot_subspace_density         "); .plot_subspace_density
        case ("pointgroup=                   "); .read_pointgroup

        case ("put                           "); .put
        case ("put_1e_properties             "); .put_1e_properties
        case ("put_all_bonds                 "); .put_all_bonds
        case ("put_atom_coord_info           "); .atom.put_coord_info(FALSE)
        case ("put_all_atom_coord_info       "); .atom.put_coord_info(TRUE)
        case ("put_ao_energy_partition       "); .put_AO_energy_partition
        case ("put_bda_charges               "); .MAIN:put_BDA_charges
      ! case ("put_atom_kind_map             "); .put_atom_kind_map
        case ("put_chi2_vs_angle_plot        "); .crystal.put_chi2_vs_angle_plot
        case ("put_cif                       "); .MAIN:put_cif
      ! case ("put_cluster_input             "); .put_cluster_input
        case ("put_coppens_interpolators     "); .MAIN:put_coppens_interpolators
        case ("put_crystal                   "); .put_crystal
        case ("put_crystal_f_statistics      "); .put_crystal_F_statistics
        case ("put_crystal_reflection_data   "); .put_crystal_reflection_data
        case ("put_current_time              "); .put_current_time(timer)
        case ("put_debug_list                "); .put_debug_list
        case ("put_density_matrix            "); .put_density_matrix
        case ("put_diff_coppens_slater_ints  "); .MAIN:put_diff_coppens_slater_ints
        case ("put_diff_slater_interpolators "); .MAIN:put_diff_slater_interpolators
      ! case ("put_electrostatic_energy      "); .put_electrostatic_energy
        case ("put_fitting_plots             "); .crystal.put_fitting_plots ! <--
        case ("put_fock_matrix               "); .put_fock_matrix
      ! case ("put_f_calc                    "); .crystal.put_F_calc
        case ("put_fcalc_plots               "); .crystal.put_fcalc_plots
        case ("put_g_tensor_information      "); .put_g_tensor_information
        case ("put_hirshfeld_atom_info       "); .put_Hirshfeld_atom_info
        case ("put_hirshfeld_g_and_k_energy  "); .MAIN:put_Hirshfeld_G_and_K_energy
        case ("put_labelled_qq_plot          "); .crystal.put_labelled_qq_plot
      ! case ("put_mikes_polarisability      "); .MAIN:put_mikes_polarisability
        case ("put_molecular_orbitals        "); .put_molecular_orbitals
        case ("put_mos_and_energies          "); .put_mos_and_energies
        case ("put_mo_energy_partition       "); .put_MO_energy_partition
        case ("put_mulliken_populations      "); .put_mulliken_populations
        case ("put_natural_orbitals          "); .put_natural_orbitals
        case ("put_oscillator_overlaps       "); .MAIN:put_oscillator_overlaps
        case ("put_overlap_eigenvalues       "); .MAIN:put_overlap_eigenvalues
        case ("put_overlap_matrix            "); .MAIN:put_overlap_matrix
        case ("put_overlapping_atoms         "); .put_overlapping_atoms
        case ("put_pdb                       "); .MAIN:put_pdb
        case ("put_plot_grid                 "); .put_plot_grid
        case ("put_pnd_sf                    "); .put_PND_sf
        case ("put_pointgroup                "); .put_pointgroup
        case ("put_principal_axes            "); .put_principal_axes
        case ("put_qq_plot                   "); .crystal.put_qq_plot
        case ("put_roby_mmo_energy_partition "); .put_roby_mmo_energy_partition
        case ("put_roby_smo_energy_partition "); .put_roby_smo_energy_partition
        case ("put_sao_energy_partition      "); .put_SAO_energy_partition
        case ("put_scf_energy                "); .put_scf_energy
        case ("put_scf_energy_as_mo_parts    "); .MAIN:put_scf_energy_as_mo_parts
        case ("put_scf_energy_in_mo_pairs    "); .put_scf_energy_in_mo_pairs
        case ("put_scf_atomic_polarisabilitie"); .MAIN:put_scf_atomic_polarisability
        case ("put_scf_dipole_hyperpolarisabi"); .MAIN:put_scf_dipole_hyperpolarisa
        case ("put_scf_dipole_polarisability "); .MAIN:put_scf_dipole_polarisability
        case ("put_slater_interpolators      "); .MAIN:put_slater_interpolators
        case ("put_sos_dipole_polarisability "); .MAIN:put_sos_dipole_polarisability
        case ("put_sylvain_csizmadia_tensors "); .MAIN:put_sylvain_csizmadia_tensors
        case ("put_time_taken                "); .put_time_taken(timer)
        case ("put_uc_dipole_polarisability  "); .MAIN:put_uc_dipole_polarisability
        case ("put_uc_dipole_hyperpolarisabil"); .MAIN:put_uc_dipole_hyperpolar
        case ("put_uc_refractive_index       "); .MAIN:put_uc_refractive_index
        case ("put_vrml                      "); .put_vrml

        case ("read_archive                  "); .read_archive
        case ("read_ascii_archive            "); .read_ascii_archive
        case ("read_gaussian_fchk_file       "); .read_gaussian_FChk_file
        case ("redirect                      "); .MAIN:redirect
        case ("redirect_stdout               "); .MAIN:redirect_stdout
        case ("revert                        "); .MAIN:revert
        case ("revert_stdout                 "); .MAIN:revert_stdout
      ! case ("put_roby_shared_population    "); .put_roby_shared_population
      ! case ("roby_population_analysis      "); .roby_population_analysis
        case ("roby_analysis                 "); .roby_analysis
        case ("robydata=                     "); .read_robydata
        case ("saved_basis_name=             "); .read_saved_basis_name
        case ("saved_coppensbasis_name=      "); .read_saved_coppensbasis_name
        case ("saved_slaterbasis_name=       "); .read_saved_slaterbasis_name
        case ("saved_isosurface_plot         "); .saved_isosurface_plot
        case ("saved_plot_on_isosurface      "); .saved_plot_on_isosurface
        case ("set_atom_info                 "); .set_atom_info
        case ("scf                           "); .scf
        case ("scfdata=                      "); .read_scfdata
        case ("simulate_new_f_exp            "); .crystal.simulate_new_F_exp
        case ("slaterbasis_name=             "); .read_slaterbasis_name
      ! case ("slater_basis_sets=            "); .read_slaterbasis_sets
        case ("start_new_molecule            "); .MAIN:reset_molecule
        case ("start_timer                   "); timer.start_timing
      ! case ("test_spin_orbit_b_matrices    "); .test_spin_orbit_B_matrices
      ! case ("test_zora_so_matrices         "); .test_ZORA_SO_matrices
      ! case ("test_dftgrid                  "); .test_dftgrid
      ! case ("test_eigen                    "); .test_eigen
        case ("unsave                        "); .unsave
        case ("write_wfn_file                "); .write_wfn_file
        case ("write_archive                 "); .write_archive
        case ("write_ascii_archive           "); .write_ascii_archive
      ! case ("e2_energy                     "); stdout.put(.e2_energy)
      ! case ("the_e2_energy                 "); stdout.put(.the_e2_energy)
      ! case ("hf_energy                     "); stdout.put(.hf_energy)
        case ("zero_off_atom_density         "); .MAIN:zero_off_atom_density

        ! Crystal Explorer commands ...
      ! case ("cif_data_block_name=          "); .MAIN:read_CIF_data_block_name
      ! case ("cif_file_name=                "); .MAIN:read_CIF_file_name
        case ("cx_file_name=                 "); .MAIN:read_CX_file_name
        case ("cx_isosurface=                "); .read_CX_isosurface
        case ("cx_surface=                   "); .read_CX_isosurface
        case ("cx_uses_angstrom=             "); .MAIN:read_CX_uses_angstrom
        case ("process_cif                   "); .MAIN:process_CIF
      ! case ("process_cif_crystal           "); .MAIN:process_CIF_crystal
      ! case ("process_cif_adps              "); .MAIN:process_CIF_ADPs
        case ("process_cif_for_cx            "); .MAIN:process_CIF_for_CX
        case ("put_cx_data                   "); .MAIN:put_CX_data
        case ("put_next_neighbour_handedness "); .MAIN:put_next_neighbour_handedness
        case ("put_invariom_label            "); .MAIN:put_invariom_label
        case ("put_invariom_labels           "); .MAIN:put_invariom_labels
        case ("put_smiles_invariom_labels    "); .MAIN:put_smiles_invariom_labels

        ! Test commands ...
        case ("rotate                        "); .MAIN:read_rotate
        case ("rotate_group                  "); .MAIN:read_rotate_group
      ! case ("test_e_field_matrices         "); .MAIN:test_E_field_matrices
      ! case ("test_inv_sqrt_s               "); .MAIN:test_inv_sqrt_S
      ! case ("test_rchf_s                   "); .MAIN:test_rchf_S
      ! case ("make_periodic_fmm_levels      "); .make_periodic_fmm_levels
        case ("spherically_averaged_sf       "); .MAIN:spherically_averaged_sf 
      ! case ("z_circularly_averaged_sf      "); .MAIN:z_circularly_averaged_sf 
        case ("use_interpolators=            "); .MAIN:read_use_interpolators
        case ("zero_overlap_density          "); .MAIN:zero_overlap_density

        case  default ;               UNKNOWN(keyword)
      end
   end

! The minimal keyword version for CE

!   process_keyword(keyword) ::: recursive, leaky
!   ! Process a keyword "word". Data is inputted from "stdin", unless
!   ! "word" is a sequence of blank separated strings. In this case,
!   ! the sequence is processed as if it were a separate file.
!   ! NOTE : this routine reuires a MOLECULE pointer self variable
!      self :: PTR
!      keyword :: STR
!      timer :: TIME
!
!      timer.start_timing
!
!      select case (keyword)
!        case ("}                             "); ! exit case
!        case ("assign_nos_to_mos             "); .assign_NOs_to_MOs
!        case ("atoms=                        "); .read_atoms
!        case ("basis_set_directory=          "); .basis.read_library_directory
!        case ("basis_set_kind=               "); .read_basis_set_kind
!        case ("becke_grid=                   "); .read_becke_grid
!        case ("change_to_principal_axes      "); .change_to_principal_axes
!        case ("change_to_principal_top_axes  "); .change_to_principal_top_axes
!        case ("charge=                       "); .read_charge
!        case ("cif=                          "); .MAIN:read_CIF
!        case ("cleanup_scf                   "); .cleanup_scf
!        case ("cluster=                      "); .read_cluster
!        case ("create_cluster                "); .create_cluster
!        case ("crystal=                      "); .read_crystal
!        case ("delete_scf_integrals          "); .delete_scf_integrals
!        case ("delete_scf_archives           "); .delete_scf_archives
!        case ("destroy_cluster               "); .destroy_cluster
!        case ("dftgrid=                      "); .read_dftgrid
!        case ("isosurface=                   "); .read_isosurface
!        case ("isosurface_plot               "); .isosurface_plot
!        case ("make_ao_density_matrix        "); .make_ao_density_matrix
!        case ("make_scf_density_matrix       "); .make_scf_density_matrix(damp=FALSE)
!        case ("multiplicity=                 "); .read_multiplicity
!        case ("name=                         "); .read_name
!        case ("output_style_options=         "); .MAIN:read_output_style_options
!        case ("plot_on_isosurface            "); .plot_on_isosurface
!        case ("put                           "); .put
!        case ("put_all_bonds                 "); .put_all_bonds
!        case ("put_all_atom_coord_info       "); .atom.put_coord_info(TRUE)
!        case ("put_crystal                   "); .put_crystal
!        case ("put_current_time              "); .put_current_time(timer)
!        case ("put_molecular_orbitals        "); .put_molecular_orbitals
!        case ("put_mos_and_energies          "); .put_mos_and_energies
!        case ("put_mulliken_populations      "); .put_mulliken_populations
!        case ("put_principal_axes            "); .put_principal_axes
!        case ("put_time_taken                "); .put_time_taken(timer)
!        case ("read_archive                  "); .read_archive
!        case ("read_ascii_archive            "); .read_ascii_archive
!        case ("read_gaussian_fchk_file       "); .read_gaussian_FChk_file
!        case ("redirect                      "); .MAIN:redirect
!        case ("revert                        "); .MAIN:revert
!        case ("saved_basis_set_kind=         "); .read_saved_basis_set_kind
!        case ("saved_isosurface_plot         "); .saved_isosurface_plot
!        case ("saved_plot_on_isosurface      "); .saved_plot_on_isosurface
!        case ("set_atom_info                 "); .set_atom_info
!        case ("scf                           "); .scf
!        case ("scfdata=                      "); .read_scfdata
!        case ("start_timer                   "); timer.start_timing
!        case ("unsave                        "); .unsave
!        case ("write_wfn_file                "); .write_wfn_file
!        case ("write_archive                 "); .write_archive
!        case ("write_ascii_archive           "); .write_ascii_archive
!
!        ! Crystal Explorer commands ...
!        case ("cx_file_name=                 "); .MAIN:read_CX_file_name
!        case ("cx_surface=                   "); .read_CX_isosurface
!        case ("cx_isosurface=                "); .read_CX_isosurface
!        case ("cx_uses_angstrom=             "); .MAIN:read_CX_uses_angstrom
!        case ("process_cif                   "); .MAIN:process_CIF
!        case ("process_cif_for_cx            "); .MAIN:process_CIF_for_CX
!        case ("put_cx_data                   "); .MAIN:put_CX_data
!
!        case  default ;               UNKNOWN(keyword)
!      end
!   end

   read_output_style_options
   ! Read new output style options, for example change the
   ! width and number of field, or precision of output.
      stdout.read_keywords(stdin)
   end

   read_memory_limit
   ! Read in a new memory limit for the program to work within.
      limit :: INT
      stdin.read_int_quantity(limit) ! Limit is now in default units of words
      ENSURE(limit>0,"limit must be positive")
      tonto.reset_memory_limit(limit)
   end

   read_invariom_directory
   ! Read in the directory for the invariom database.
      stdin.read(.invariom_database_directory) 
   end

   read_invariom_refinement
   ! Read in the logical switch for the invariom refinement.
      stdin.read(.invariom_refinement) 
   end

   read_use_interpolators
   ! Read whether to use interpolators
      stdin.read(.use_interpolators) 
      if (.atom.created) .atom.set_use_interpolators(.use_interpolators)
   end

   read_interpolator ::: leaky
   ! Read template interpolators
      .interpolator.destroy
      .interpolator.create
      .interpolator.read_keywords
      .destroy_interpolators
   end

   locate_memory_leak
   ! Locate the memory leak when speicifying the address, amount of
   ! the leak, and routine name. Requires program compiled with
   ! -DTRACK_MEMORY_LOCATIONS.
   ENSURE(stdin.buffer.n_items==4,"must specify address, amount of leak, and leaky routine")
   ENSURE(stdin.buffer.item_index==1,"must be at the second item on the input line")
      address,amount :: INT
      routine :: STR
      stdin.read(routine) 
      stdin.read(amount) 
      stdin.read(address) 
      tonto.leaky_routine = routine
      tonto.leaky_amount  = amount
      tonto.leaky_address = address
   end

   redirect ::: leaky
   ! Redirect the input to the file whose name is the following string
   ! in the current input file.
      name :: STR
      stdin.read(name)
      stdin.redirect(name)
   end

   redirect_stdout ::: leaky
   ! Redirect stdout to the file whose name is the following string
   ! in the current input file.
      name :: STR
      stdin.read(name)
      stdout.redirect(name)
   end

   revert ::: leaky
   ! Revert stdin back to the previously stored input file
      stdin.revert
   end

   revert_stdout ::: leaky
   ! Revert stdout back to the previously stored input file
      stdout.revert
   end

   localise_MOs ::: leaky
   ! Localise the MO's
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no MO's")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created, "no atom info")
      D,Q :: MAT3{REAL}*
      D.create(.n_bf,.n_bf,3)
      Q.create(.n_bf,.n_bf,6)
      .get_dipole_matrices(D(:,:,1),D(:,:,2),D(:,:,3))
      .get_quadrupole_matrices(Q(:,:,1),Q(:,:,2),Q(:,:,3),Q(:,:,4),Q(:,:,5),Q(:,:,6))
      .localiser.create
      .localiser.set_defaults(.molecular_orbitals.restricted(:,1:.n_a),D,Q)
      .localiser.set_MO(.molecular_orbitals.restricted(:,1:.n_a))
      .localiser.read_keywords
      Q.destroy; D.destroy
   end

! ************
! Put routines
! ************

!   put_overlapping_atoms ::: leaky
!   ! Put the overlapping atoms
!      i,j,k :: INT
!      .make_overlapping_atoms2
!      stdout.dash(int_fields=3)
!      stdout.put("Atom",int_width=TRUE)
!      stdout.put("Atom",int_width=TRUE)
!      stdout.put("Overlap?",int_width=TRUE)
!      stdout.flush
!      stdout.dash(int_fields=3)
!      k = 0
!      do i = 1,.n_atom
!      do j = 1,i
!         k = k + 1
!         stdout.put(i)
!         stdout.put(j)
!         stdout.put(.overlapping_atoms(k))
!         stdout.flush
!      end
!      end
!      stdout.dash(int_fields=3)
!   end

   put_oscillator_overlaps
   ! Put out the overlap matrix between the normal and oscillator basis
   ! functions.
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no MO's")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created, "no atom info")
      SAO,SMO :: MAT4{REAL}*
      S,SS,TM :: MAT{REAL}*
      sh :: SHELL2
      ci,cj :: VEC{REAL}(3)
    ! list :: VEC{INT}*
      maxl,n,i,j,k,l,p,q,fa,la,fb,lb, nc,nt :: INT
      .get_overlap_matrix
      SS.create(.n_a,.n_a)
      .overlap_matrix.change_basis_to(SS,.localiser.MO)
      stdout.text("transformed S:")
      stdout.put(SS)
      SS.destroy
      ! Make the AO oscillator interals 
      maxl = 2                                  ! Set up l=2 oscillators
      n = maxl.n_comp_sum                       ! No. of oscillators 
      SMO.create(.n_a,n,.n_a,n)
      SAO.create(.n_bf,.n_bf,n,n)
      do i = 1,.n_a 
      do j = 1,.n_a  
         ci = .localiser.dipole(i,i,:)
         cj = .localiser.dipole(j,j,:)
         do q = 1,.n_shell_pairs
            .get_precomputed_shell_pair(sh,q,fa,la,fb,lb)
            sh.make_oscillator_overlap_ints(SAO(fa:la,fb:lb,:,:),ci,cj,0,maxl,0,maxl)
            sh.destroy_ptr_part
         end
         ! Transform to the MO basis
         do k = 1,n
         do l = 1,n
            SAO(:,:,k,l).symmetric_reflect
          ! SMO(i,k,j,l) = dot_product(matmul(SAO(:,:,k,l),.localiser.MO(:,j),.localiser.MO(:,i)))
         end
         end
      end
      end
      ! Transform to the MO basis
    ! do i = 1,n
    ! do j = 1,n
    !    SAO(:,:,i,j).symmetric_reflect
    !    SAO(:,:,i,j).change_basis_to(SMO(:,i,:,j),.localiser.MO)
    ! end
    ! end
      SAO.destroy
      ! Print out
      stdout.flush
      stdout.text("Oscillator overlap matrices, up to l = "//maxl.to_str.trim)
      stdout.text("Row = OMO, Col = oscillator fn: s, px, py, pz, ...")
      stdout.flush
      do i = 1,.n_a
         stdout.show("MO  = ",i)
         stdout.put(SMO(i,1,:,:))
      end
      ! Rearrange order to have all p, all d ... together
    ! list.create(n*.n_a)
    ! i = 0
    ! nt = 0
    ! do l = 0,maxl
    !    nc = l.n_comp
    !    k = nt
    !    do j = 1,.n_a
    !       list(i+1:i+nc) = [ (q,q=k+1,k+nc) ]
    !       i = i + nc
    !       k = k + n
    !    end
    !    nt = nt + nc
    ! end
    ! stdout.flush
    ! stdout.text("reorder list:")
    ! stdout.put(list,"column")
    ! list.destroy
      ! Print out
      SS.create(n*.n_a,n*.n_a)
      SS = reshape(SMO,[n*.n_a,n*.n_a])
      stdout.flush
      stdout.text("Ordered oscillator overlap matrix:")
      stdout.flush
      stdout.put(SS)
      ! Define the coefficient matrix TM for the projected oscillators
      TM.create(n*.n_a,n*.n_a); TM.to_unit_matrix
      S.create(n*.n_a,n*.n_a)
      nt = .n_a
      do l = 1,maxl
         nc = l.n_comp
         p = nt + 1
         q = nt + nc*.n_a
         TM(:,1:q).schmidt_orthonormalise(SS,from=p,to=nt)
         TM(:,p:q).symmetrically_orthonormalise(SS)
         nt = q
      end
      ! Print out
      stdout.flush
      stdout.text("Orthonormalised oscillator orbitals:")
      stdout.flush
      stdout.put(TM)
      SS.change_basis_to(S,TM)
      stdout.text("Transformed Oscillator overlap matrix:")
      stdout.put(S)
      ! Save the TM array for plots
      .localiser.TM.destroy
      .localiser.TM => TM
      S.destroy
      SS.destroy
      SMO.destroy
   end

   put_pdb
   ! Prints out a pdb file
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")
      pdbfile :: TEXTFILE*
      pdbfile.create("stdout.pdb")
      pdbfile.open(for="write")
      pdbfile.text("HEADER: TONTO generated PDB file")
      .crystal.put_pdb(pdbfile)
      .atom.put_pdb(pdbfile)
      pdbfile.close
      pdbfile.destroy
   end

   put_cif
   ! Prints out a cif file
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      scf_type :: STR
      mass,radius :: REAL

      ! Create the cif file
      stdout.redirect("stdout.cif")
      stdout.open(for="write")

      ! Put the header information
      stdout.text("# ------------------------")
      stdout.text("# TONTO generated CIF file")
      stdout.text("# ------------------------")
      stdout.flush 
      stdout.text("data_"//trim(.name))
      stdout.flush 
      stdout.text("_audit_creation_date               "//trim(std_time.current_date_YMD_str))
      stdout.text("_audit_creation_method             'Tonto v"//TONTO_VERSION//" ($Rev$)'")
      stdout.flush 
      stdout.text("# --------------------")
      stdout.text("# Chemical information")
      stdout.text("# --------------------")
      stdout.flush 
      stdout.text("_chemical_name_common              "//trim(.name))
      stdout.text("_chemical_formula_moiety           '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_sum              '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      mass = .atom.mass
      stdout.text("_chemical_formula_weight           "//trim(mass.to_str("f8.2")))
      stdout.text("_chemical_compound_source          'see text'")
      stdout.text("_chemical_absolute_configuration   unk")

      ! Put the crystal information
      scf_type = " "
      if (.scfdata.created) then
         scf_type = .scfdata.scf_kind
         if (.scfdata.is_DFT_calculation) then
            scf_type = trim(scf_type)//" "// &
                       trim(.scfdata.dft_exchange_functional)// &
                       trim(.scfdata.dft_correlation_functional)
         end
         if (.scfdata.using_cluster_charges) then
            radius = .scfdata.cluster_radius.to_units("angstrom")
            scf_type = trim(scf_type)//" using cluster charges, radius="// &
                       trim(radius.to_str("f5.1"))//" angstrom"
         end
      end
      .crystal.put_cif(.basis_name,scf_type)

      ! Clean up
      stdout.revert

   end

   put_overlap_matrix
   ! Print out the overlap matrix
   ! functions.
      .get_overlap_matrix
      stdout.text("Overlap matrix:")
      stdout.put(.overlap_matrix)
   end

   put_kinetic_energy_matrix
   ! Print out the kinetic energy matrix
      T :: MAT{REAL}*
      T.create(.n_bf,.n_bf)
      .get_kinetic_matrix(T)
      stdout.text("Kinetic energy matrix:")
      stdout.put(T)
      T.destroy
   end

   put_nuclear_attraction_matrix
   ! Print out the nuclear attractions matrix
      Z :: MAT{REAL}*
      Z.create(.n_bf,.n_bf)
      .get_nuclear_matrix(Z)
      stdout.text("Nuclear attraction matrix:")
      stdout.put(Z)
      Z.destroy
   end

   put_scf_energy_as_mo_parts
   ! Analyse the SCF energy into MO contributions
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.orbital_energies.created,"no MO energies")
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.scfdata.scf_kind=="rhf" OR .scfdata.scf_kind=="rks","must be restricted cakculation")
      H :: MAT{REAL}*
      mo_energy :: VEC{REAL}*
      i :: INT
      mo_energy.create(.n_a)
      H.create(.n_bf,.n_bf)
      .get_core_matrix
      .core_matrix.change_basis_to(H,.molecular_orbitals.restricted)
      do i = 1,.n_a
         mo_energy(i) = H(i,i) + .orbital_energies.restricted(i)
      end
      H.destroy
      stdout.flush
      stdout.text("SCF MO energy decomposition:",flush=1)
      stdout.show("SCF electronic energy =",sum(mo_energy))
      stdout.text("MO energies:",flush=1)
      stdout.flush
      stdout.put(mo_energy,"column")
   end

   put_Hirshfeld_G_and_K_energy
   ! Put the Hirshfeld G and K energies.

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")

      pt :: MAT{REAL}*
      E_G,E_K,wt,Wa,G_grid,K_grid :: VEC{REAL}*
      E_GT,E_KT :: REAL
      a,n_pt :: INT

      ! Set up grids, atomic densities, and NO's
      .set_up_Hirshfeld_info

      ! Atomic kinetic energy arrays
      E_G.create(.n_atom)
      E_K.create(.n_atom)

      ! Make the atomic energies
      do a = 1,.n_atom
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1
         Wa.create(n_pt)
         .make_stockholder_atom_grid(Wa,a,pt)
         G_grid.create(n_pt)
         K_grid.create(n_pt)
         .make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
         E_G(a) = sum(G_grid*Wa*wt)
         E_K(a) = sum(K_grid*Wa*wt)
         K_grid.destroy; G_grid.destroy
         Wa.destroy; wt.destroy; pt.destroy
      end

      ! Check total kinetic energies
      .becke_grid.make_grid(pt,wt)
      n_pt = pt.dim1
      G_grid.create(n_pt)
      K_grid.create(n_pt)
      .make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
      E_GT = sum(G_grid*wt)
      E_KT = sum(K_grid*wt)
      K_grid.destroy; G_grid.destroy
      wt.destroy; pt.destroy

      ! Put the table
      stdout.flush
      stdout.show("Numerical E_G       =",E_GT)
      stdout.show("Sum of atomic E_G's =",sum(E_G))
      stdout.show("Numerical E_K       =",E_KT)
      stdout.show("Sum of atomic E_K's =",sum(E_K))
      stdout.flush
      stdout.dash(int_fields=2,real_fields=2)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Label",int_width=TRUE)
      stdout.put("E_G")
      stdout.put("E_K")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=2)
      do a = 1,.n_atom
         stdout.put(a)
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(E_G(a))
         stdout.put(E_K(a))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=2)

      ! Clean up
      E_K.destroy; E_G.destroy

   end


   integrate_density_numerically
   ! Integrate the density numerically
      self :: PTR
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
      b :: BECKE_GRID*
      pt :: MAT{REAL}*
      wt,rho_grid :: VEC{REAL}*
      n_pt :: INT
      n_e :: REAL
      stdout.flush
      stdout.text("Numerically integrate the electron density with a BECKE_GRID :")
      stdout.flush
   !  b.create ! <<<<<<<<<<<<
   !  b.set_kind("mura_knowles")
   !  b.set_accuracy("low")
   !  b.set_grid_data
   !  b.set_partition_scheme("becke")
   !  b.set_partition_scaling_scheme("treutler_ahlrichs")
   !  b.set_scale_atomic_grids(TRUE)
   !  b.set_reduce_core_angular_grid(TRUE)
   !  b.set_reduce_H_angular_grid(TRUE)
      b => .becke_grid
      b.put
      b.put_atom_info
      b.make_grid(pt,wt) ! <<<<<<<<<<< leaky
      n_pt = pt.dim1
      rho_grid.create(n_pt)
      .make_density_grid(rho_grid,pt)
      n_e = sum(rho_grid*wt)
      rho_grid.destroy
      wt.destroy; pt.destroy
      stdout.show("n_pt = ",n_pt)
      stdout.show("n_e  = ",n_e)
   end

!   read_geminal_mf_spectrum
!   ! Read in geminale mean field spectrum options
!     self :: target
!     ENSURE(.atom.created,"no atom info")
!     ENSURE(.basis_info_made,"no basis info")
!     main :: MOLECULE.MAIN*
!     v :: MAT4{REAL}*
!     eri_archive :: ARCHIVE
!     n_bas :: INT
!     i,j :: INT
!     en :: REAL
!     nuc :: REAL
!!debug     H :: MAT{REAL}*
!     ! First create the MO integrals on disk
!     eri_archive.set(.name,"h_integrals")
!     v.create(.n_bf,.n_bf,.n_bf,.n_bf)
!     !trick to make sure we use only routines from molecule.main and not from
!     !molecule although the self is of type molecule.
!     main => self
!     .make_shellpair_vector
!     main.make_eri_integrals(v)
!     main.make_mo_eri_integrals(v,eri_archive,add_core=TRUE)
!    !debug H.create(.n_bf,.n_bf)
!    !debug .get_core_matrix(H)
!    !debug H.change_basis_using(.molecular_orbitals.restricted)
!    !debug do i = 1,.n_a
!    !debug    en = en + TWO*H(i,i)
!    !debug end
!      en = ZERO
!      do i = 1,.n_a
!      do j = 1,.n_a
!         en = en + TWO*v(i,j,i,j) - v(i,i,j,j)
!      end
!      end
!      en = en + .nuclear_energy
!      nuc = .nuclear_energy
!     stdout.show("energy = ",en)
!    !debug stdout.show("core energy = ",TWO*H(1:.n_a,1:.n_a).trace)
!     stdout.show("v(1,1,1,1)",v(1,1,1,1))
!     stdout.show("v(2,2,2,2)",v(2,2,2,2))
!     stdout.show("v(1,2,1,2)",v(1,2,1,2))
!     stdout.show("v(1,1,2,2)",v(1,1,2,2))
!     stdout.show("v(1,2,2,1)",v(1,1,2,2))
!     stdout.show("nuclear_energy",nuc)
!    !debug H.destroy      
!     v.destroy      
!     .geminal_mf_spectrum.create(.name,nuc,.n_a,.n_bf,n_bas,use_hf_default=TRUE)
!     .geminal_mf_spectrum.read_keywords
!   end

!   make_eri_integrals_nosym(v)
!   ! Calculate the electron repulsion integrals (ERI's) over all basis functions
!   ! and place them in the array "v". This will use up a lot of space!
!     self :: target
!     v :: MAT4{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(all(v.shape==[.n_bf,.n_bf,.n_bf,.n_bf]),"wrong shape for array v")
!   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")
!     sh4 :: SHELL4
!     ab,cd,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,skipped :: INT
!     skipped = 0
!     do a = 1,.n_shell
!     do b = 1,.n_shell
!     do c = 1,.n_shell
!     do d = 1,.n_shell
!       .get_shell(sh4.a,a,fa,la) 
!       .get_shell(sh4.b,b,fb,lb) 
!       .get_shell(sh4.c,c,fc,lc) 
!       .get_shell(sh4.d,d,fd,ld) 
!       sh4.get_ERI(v(fa:la,fb:lb,fc:lc,fd:ld))
!       sh4.destroy_ab
!       sh4.destroy_cd
!     end
!     end
!     end
!     end
!   end

!   make_eri_integrals(v)
!   ! Calculate the electron repulsion integrals (ERI's) over all basis functions
!   ! and place them in the array "v". This will use up a lot of space!
!     v :: MAT4{REAL}
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(all(v.shape==[.n_bf,.n_bf,.n_bf,.n_bf]),"wrong shape for array v")
!   ENSURE(.precomputed_basis_shellpair.created,"no precomputed shell pair information")
!     val :: REAL
!     sh4 :: SHELL4
!   ! sh4 :: SHELL1QUARTET
!     ab,cd,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld,skipped :: INT
!     skipped = 0
!     v = -ONE
!     do ab = 1,.n_shell_pairs
!       .get_shell_pair_indices(ab,a,b,fa,la,fb,lb) ! a & b shell indices.
!       .set_shell_quartet_ab(sh4,a,b) 
!       ! .set_precomp_shell_quartet_ab(sh4,a,b)
!       do cd = 1,ab
!         .get_shell_pair_indices(cd,c,d,fc,lc,fd,ld)  ! c & d shell indices.
!         .set_shell_quartet_cd(sh4,c,d) 
!         ! .set_precomp_shell_quartet_cd(sh4,c,d)
!         sh4.get_ERI(v(fa:la,fb:lb,fc:lc,fd:ld))
!         ! sh4.make_ERI_ints(v(fa:la,fb:lb,fc:lc,fd:ld))
!         ! Now symmetrise the integrals
!         do a = fa,la
!         do b = fb,lb
!         do c = fc,lc
!         do d = fd,ld
!            val = v(a,b,c,d)
!            v(a,b,d,c) = val
!            v(b,a,c,d) = val
!            v(b,a,d,c) = val
!            v(c,d,a,b) = val
!            v(c,d,b,a) = val
!            v(d,c,a,b) = val
!            v(d,c,b,a) = val
!         end
!         end
!         end
!         end
!         sh4.destroy_cd
!       end
!       sh4.destroy_ab
!     end
!   end

!   make_mo_eri_integrals(v,eri_archive,add_core)
!   ! Calculate the electron repulsion integrals (ERI's) in the MO basis from the
!   ! AO integrals stored in "v" and write them to disk in "eri_archive". If
!   ! "add_core" is present and true, the one electron core integrals are added
!   ! into the two electron MO integrals.
!     v :: MAT4{REAL}
!     eri_archive :: ARCHIVE
!     add_core :: BIN, optional
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!   ENSURE(.molecular_orbitals.created,"no molecular orbitals")
!   ENSURE(.molecular_orbitals.restricted.created,"no molecular orbitals")
!     H,S :: MAT{REAL}*
!     a,b,c,d :: INT
!     core :: BIN
!     core = FALSE
!     if (present(add_core)) core = add_core
!     if (core) then
!        S.create(.n_bf,.n_bf)
!        H.create(.n_bf,.n_bf)
!        .make_core_matrix(H)
!        .make_overlap_matrix(S)
!        H = H/(TWO*.n_a-1)
!     end
!     do a = 1,.n_bf
!       do b = 1,a-1
!!pcc should swap a and b to make it faster 
!         if (core) v(a,b,:,:) = v(a,b,:,:) + H * S(a,b) + S * H(a,b)
!         v(a,b,:,:).change_basis_using(.molecular_orbitals.restricted)
!         v(b,a,:,:) = v(a,b,:,:)
!       end
!       if (core) v(a,a,:,:) = v(a,a,:,:) + H * S(a,a) + S * H(a,a)
!       v(a,a,:,:).change_basis_using(.molecular_orbitals.restricted)
!     end
!     do c = 1,.n_bf
!       do d = 1,c-1
!         v(:,:,c,d).change_basis_using(.molecular_orbitals.restricted)
!         v(:,:,d,c) = v(:,:,c,d)
!       end
!       v(:,:,c,c).change_basis_using(.molecular_orbitals.restricted)
!     end
!!pcc   swapping of indices to speed up the hamiltonian function
!     do c = 1,.n_bf
!       do d = 1,c-1
!         H=v(:,d,c,:)
!         v(:,d,c,:)=v(:,c,d,:)
!         v(:,c,d,:)=H
!       end
!     end
!     H.destroy
!     S.destroy
!     eri_archive.write(v)
!   end

! ***************************************
! Scaled and derivative stockholder grids
! ***************************************

   fit_Hirshfeld_atom_kappas ::: leaky
   ! Fit the kappa scale factors for the Hirshfeld atoms so as to get
   ! the same G and K kinetic energies for each atom.
   ENSURE(.atom.created, "no atoms to fit")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created,"no crystal data")
   ENSURE(.crystal.xray_data.created,"no crystal xray data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")

      max_shift,max_allowed_shift,shift_convergence,delta,fac :: REAL
      kappa,kappa_old,kappa_del,G :: VEC{REAL}*
      H :: MAT{REAL}*
      iter,max_iter :: INT
      finished :: BIN

      ! Fit parameters
      max_iter = 50
      max_allowed_shift = 0.10d0
      shift_convergence = 0.001d0

      ! Set up grids, atomic densities
      .set_up_Hirshfeld_info

      ! Parameter vectors, shifts
      kappa.create(.n_atom)
      kappa_old.create(.n_atom)
      kappa_del.create(.n_atom)
      kappa = ONE

      ! Gradient and Hessian
      G.create(.n_atom)
      H.create(.n_atom,.n_atom)

      ! Begin kappa refinement loop
      iter = 0
      stdout.flush
      do
 
         iter = iter + 1

         ! Get the gradient G and Hessian H
         .MAIN:make_scaled_stockholder_derivs(G,H,kappa,delta,skip_NOs=TRUE)

         ! Solve for the shifts
         G = -G
         H.solve_linear_equation(G,kappa_del)

         ! Get the maximum shift
       ! kappa_del = G
         max_shift = maxval(abs(kappa_del))

         ! Renormalise shift if too big
         if (max_shift>max_allowed_shift) then
            fac = max_allowed_shift/max_shift
            kappa_del = fac * kappa_del
         end

         ! Put the results
         stdout.put(iter)
         stdout.put(max_shift)
         stdout.put(delta)
         stdout.flush
       ! stdout.text("G:")
       ! stdout.put(G,"column")

         ! Finished?
         finished = max_shift<shift_convergence OR iter>max_iter
         if (finished) exit

         ! Store parameters, add shift
         kappa_old = kappa
         kappa     = kappa + kappa_del
 
      end

      ! Put the results
      stdout.flush
      stdout.text("Final kinetic energies:")
      .MAIN:put_Hirshfeld_G_and_K_energy(kappa,skip_NOs=TRUE)
      stdout.flush
      stdout.text("kappa values:")
      stdout.put(kappa,"column")

      ! Clean up
      H.destroy; G.destroy
      kappa_del.destroy; kappa_old.destroy; kappa.destroy

   end

   put_Hirshfeld_G_and_K_energy(kappa,skip_NOs)
   ! Put the Hirshfeld G and K energies.

      kappa :: VEC{REAL}
      skip_NOs :: BIN, optional

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

      pt :: MAT{REAL}*
      E_G,E_K,wt,Wa,G_grid,K_grid :: VEC{REAL}*
      E_GT,E_KT :: REAL
      a,n_pt :: INT

      ! Set up grids, atomic densities
      .set_up_Hirshfeld_info(skip_NOs)

      ! Atomic kinetic energy arrays
      E_G.create(.n_atom)
      E_K.create(.n_atom)

      ! Make the atomic energies
      do a = 1,.n_atom
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1
         Wa.create(n_pt)
         .MAIN:make_stockholder_atom_grid(Wa,a,kappa,pt)
         G_grid.create(n_pt)
         K_grid.create(n_pt)
         .make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
         E_G(a) = sum(G_grid*Wa*wt)
         E_K(a) = sum(K_grid*Wa*wt)
         K_grid.destroy; G_grid.destroy
         Wa.destroy; wt.destroy; pt.destroy
      end

      ! Check total kinetic energies
      .becke_grid.make_grid(pt,wt)
      n_pt = pt.dim1
      G_grid.create(n_pt)
      K_grid.create(n_pt)
      .make_G_and_K_kinetic_grids(G_grid,K_grid,pt)
      E_GT = sum(G_grid*wt)
      E_KT = sum(K_grid*wt)
      K_grid.destroy; G_grid.destroy
      wt.destroy; pt.destroy

      ! Put the table
      stdout.flush
      stdout.show("Numerical E_G       =",E_GT)
      stdout.show("Sum of atomic E_G's =",sum(E_G))
      stdout.show("Numerical E_K       =",E_KT)
      stdout.show("Sum of atomic E_K's =",sum(E_K))
      stdout.flush
      stdout.dash(int_fields=2,real_fields=2)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Label",int_width=TRUE)
      stdout.put("E_G")
      stdout.put("E_K")
      stdout.flush
      stdout.dash(int_fields=2,real_fields=2)
      do a = 1,.n_atom
         stdout.put(a)
         stdout.put(.atom(a).label,int_width=TRUE)
         stdout.put(E_G(a))
         stdout.put(E_K(a))
         stdout.flush
      end
      stdout.dash(int_fields=2,real_fields=2)

      ! Clean up
      E_K.destroy; E_G.destroy

   end

   make_scaled_stockholder_derivs(G,H,kappa,delta,skip_NOs) ::: private
   ! Make the scaled stockholder atom derivatives "G" and hessian "H"
   ! for used in a Newton-Raphson procedure to find the best scale
   ! factors.
     self :: IN
     G :: VEC{REAL}, OUT
     H :: MAT{REAL}, OUT
     kappa :: VEC{REAL}, IN
     delta :: REAL
     skip_NOs :: BIN, optional

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(.becke_grid.created,"no becke_grid")
   ENSURE(.becke_grid.finalized,"no finalized becke_grid")
   ENSURE(H.is_square,"H is not square")
   ENSURE(G.dim==H.dim1,"G and H are inconsistent")

      Wa_cd :: MAT3{REAL}*
      pt,Wa_c :: MAT{REAL}*
      wt,Wa,G_grid,K_grid,Ga :: VEC{REAL}*
      delta2 :: REAL
      a,c,d,n_pt :: INT

      ! Set up grids, spherical atomic densities, and NO's
      .set_up_Hirshfeld_info(skip_NOs)

      ! Make the stockholder derivatives D and H
      delta = ZERO
      G = ZERO
      H = ZERO
      do a = 1,.n_atom

         ! Make integration grids
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1

         ! Make G and K kinetic densities
         G_grid.create(n_pt)
         K_grid.create(n_pt)
         .make_G_and_K_kinetic_grids(G_grid,K_grid,pt)

         ! Make Hirshfeld atoms
         Wa.create(n_pt)
         .MAIN:make_stockholder_atom_grid(Wa,a,kappa,pt)

         ! Make delta kinetic grid
         G_grid = (G_grid - K_grid)*wt
         delta2 = TWO*sum(G_grid*Wa)
         delta  = delta + QUARTER*delta2*delta2
         Wa.destroy
         K_grid.destroy

         ! Stockholder 1st derivatives
         Ga.create(.n_atom)
         Wa_c.create(n_pt,.n_atom)
         .MAIN:make_d_stockholder_atom_grid(Wa_c,a,kappa,pt)
         do c = 1,.n_atom
            Ga(c) = sum(Wa_c(:,c)*G_grid)
         end
         Wa_c.destroy

         ! Add contribution from 1st derivatives
         G = G + delta2*Ga
         H.plus_outer_product_of(Ga,TWO)
         Ga.destroy

         ! Stockholder 2nd derivatives
         Wa_cd.create(n_pt,.n_atom,.n_atom)
         .MAIN:make_d2_stockholder_atom_grid(Wa_cd,a,kappa,pt)

         ! Add contribution from 2nd derivatives
         G_grid = delta2*G_grid
         do c = 1,.n_atom
         do d = 1,.n_atom
            H(c,d) = H(c,d) + sum(Wa_cd(:,c,d)*G_grid)
         end
         end
         Wa_cd.destroy

         ! Clean
         G_grid.destroy
         wt.destroy; pt.destroy
      end

      delta = sqrt(delta)

   end

   make_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the scaled stockholder desity "grid" for the atom with index
   ! "a" and with scale parameters "kappa" using supplied points "pt".
   ! This uses gaussian atomic densities.
     self :: IN
     grid :: VEC{REAL}, OUT
     a  :: INT, IN
     kappa :: VEC{REAL}, IN
     pt :: MAT{REAL}, IN
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim==pt.dim1,"wrong size, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")
     rho_a :: VEC{REAL}*
     n_pt,i :: INT

     ! Allocate temporary densities
     n_pt = grid.dim
     rho_a.create(n_pt)

     ! Make density for atom "a"
     .atom(a).make_density_grid(rho_a,pt)

     ! Make total density in "grid"
     grid = kappa(a)*rho_a
     do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_density_grid(grid,pt,kappa(i))
     end

     ! Make the stockholder weight
     do i = 1,n_pt
       if (grid(i)>epsilon(ONE)) then; grid(i) = rho_a(i)/grid(i)
       else;                           grid(i) = ZERO
       end
     end
     rho_a.destroy

   end

   make_d_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the derivative scaled stockholder desity "grid" for the atom
   ! with index "a" and with scale parameters "kappa" using supplied
   ! points "pt".  This uses gaussian atomic densities.
     self :: IN
     grid :: MAT{REAL}, target, OUT
     a  :: INT, IN
     kappa :: VEC{REAL}, IN
     pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim1==pt.dim1,"wrong dim1, grid")
   ENSURE(grid.dim2==.n_atom,"wrong dim2, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

     rho_a,rho_c,rho,gc :: VEC{REAL}*
     n_pt,i,c :: INT

     ! Allocate temporary densities
     n_pt = grid.dim1
     rho_a.create(n_pt)
     rho_c.create(n_pt)
     rho.create(n_pt)

     ! Make density for atom "a"
     .atom(a).make_density_grid(rho_a,pt)

     ! Make total density in "rho" with kappa factors
     rho_a = kappa(a)*rho_a
     rho = rho_a
     do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_density_grid(rho,pt,kappa(i))
     end

     where (rho>epsilon(ONE)); rho_a = rho_a/(rho*rho)
     elsewhere;                rho_a = ZERO
     end

     ! Make the derivative stockholder weight
     do c = 1,.n_atom

        .atom(c).make_density_grid(rho_c,pt)

        gc => grid(:,c)
        gc = -rho_a*rho_c

        if (c/=a) cycle
        where (rho>epsilon(ONE)) gc = gc + rho_c/rho
         
     end

     ! Clean
     rho.destroy
     rho_c.destroy; rho_a.destroy

   end

   make_d2_stockholder_atom_grid(grid,a,kappa,pt)
   ! Make the 2nd derivative scaled stockholder desity "grid" for the
   ! atom with index "a" and with scale parameters "kappa" using
   ! supplied points "pt".  This uses gaussian atomic densities.
     self :: IN
     grid :: MAT3{REAL}, target, OUT
     a  :: INT, IN
     kappa :: VEC{REAL}, IN
     pt :: MAT{REAL}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom.has_all_interpolators,"missing atomic interpolators")
   ENSURE(grid.dim1==pt.dim1,"wrong dim1, grid")
   ENSURE(grid.dim2==.n_atom,"wrong dim2, grid")
   ENSURE(grid.dim3==.n_atom,"wrong dim3, grid")
   ENSURE(kappa.dim==.n_atom,"wrong size, kappa")

     rho_a,rho_c,rho_d,rho,gcd :: VEC{REAL}*
     n_pt,i,c,d :: INT

     ! Allocate temporary densities
     n_pt = grid.dim1
     rho_a.create(n_pt)
     rho_c.create(n_pt)
     rho_d.create(n_pt)
     rho.create(n_pt)

     ! Make density for atom "a"
     .atom(a).make_density_grid(rho_a,pt)

     ! Make total density in "rho" with kappa factors
     rho_a = kappa(a)*rho_a
     rho = rho_a
     do i = 1,.n_atom
        if (i==a) cycle
        .atom(i).add_density_grid(rho,pt,kappa(i))
     end

     where (rho>epsilon(ONE)); rho_a = TWO*rho_a/(rho*rho*rho)
     elsewhere;                rho_a = ZERO
     end

     where (rho>epsilon(ONE)); rho = ONE/(rho*rho)
     elsewhere;                rho = ZERO
     end

     ! Make the derivative stockholder weight
     do c = 1,.n_atom

        .atom(c).make_density_grid(rho_c,pt)

        do d = 1,.n_atom

           .atom(d).make_density_grid(rho_d,pt)
   
           gcd => grid(:,c,d)
           gcd =  rho_a*rho_c*rho_d
   
           if (c==a) gcd = gcd - rho_d*rho
           if (d==a) gcd = gcd - rho_c*rho
         
        end

     end

     ! Clean
     rho.destroy
     rho_d.destroy; rho_c.destroy; rho_a.destroy

   end

! *************************
! Polarisabilities and CPHF
! *************************

   put_sylvain_csizmadia_tensors
   ! Put out the Sylvain-Csizmadia polarisability tensors.  This
   ! routine will read the value of the Unsold denominator.

   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.molecular_orbitals.created,"no molecular orbitals")
   ENSURE(.molecular_orbitals.restricted.created,"no restricted molecular orbitals")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created, "no atom info")

      Dx,Dy,Dz, P,MOi :: MAT{REAL}*
      Qxx,Qyy,Qzz,Qxy,Qxz,Qyz :: MAT{REAL}*
      Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz :: MAT{REAL}*
      x,y,z, i,j :: INT
      delta,fac :: REAL
      orb_e :: VEC{REAL}*
      Pi :: MAT{REAL}*
      Tx,Ty,Tz :: MAT3{REAL}*
      alpha,eigenvectors :: MAT{REAL}(3,3)
      beta :: MAT3{REAL}(3,3,3)
      bvec,eigenvalues :: VEC{REAL}(3)
      alpha1 :: MAT3{REAL}*
      alpha2 :: MAT4{REAL}*

      stdout.flush
      stdout.text("Sylvian-Csizmadia polarisability tensors")

      ! Input Unsold denominator
      stdin.read(delta)
      stdout.flush
      stdout.show("Unsold denominator/a.u. =",delta)

      ! Allocate space for moment matrix elements, and get them
      Dx.create(.n_bf,.n_bf); Dy.create(.n_bf,.n_bf); Dz.create(.n_bf,.n_bf)
      Qxx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
      Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
      Oxxx.create(.n_bf,.n_bf); Oyyy.create(.n_bf,.n_bf); Ozzz.create(.n_bf,.n_bf)
      Oxxy.create(.n_bf,.n_bf); Oxxz.create(.n_bf,.n_bf)
      Oyyx.create(.n_bf,.n_bf); Oyyz.create(.n_bf,.n_bf)
      Ozzx.create(.n_bf,.n_bf); Ozzy.create(.n_bf,.n_bf)
      Oxyz.create(.n_bf,.n_bf)
      .get_dipole_matrices(Dx,Dy,Dz)
      .get_quadrupole_matrices(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz)
      .get_octupole_matrices(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz)

      ! Get the half-occupied density matrix
      .make_ao_density_matrix
      P.create(.n_bf,.n_bf)
      P = HALF*.density_matrix.restricted

      ! Set the component indices
      x = 1; y = 2; z = 3

      ! Evaluate the polarisability
      alpha(x,x) = P.trace_product_with(Qxx) - P.trace_product_with(Dx,P,Dx)
      alpha(y,y) = P.trace_product_with(Qyy) - P.trace_product_with(Dy,P,Dy)
      alpha(z,z) = P.trace_product_with(Qzz) - P.trace_product_with(Dz,P,Dz)
      alpha(y,x) = P.trace_product_with(Qxy) - P.trace_product_with(Dy,P,Dx)
      alpha(z,x) = P.trace_product_with(Qxz) - P.trace_product_with(Dz,P,Dx)
      alpha(z,y) = P.trace_product_with(Qyz) - P.trace_product_with(Dz,P,Dy)
      alpha.symmetric_reflect

      ! Evaluate user-input polarisability
      stdout.flush
      stdout.flush
      fac = FOUR/delta
      alpha = fac*alpha

      stdout.flush
      stdout.text("Sylvain-Csizmadia first polarisability - using user-input Unsold denominator (au):")
      stdout.flush
      stdout.put(alpha) 
      stdout.flush
      stdout.show("Mean polarisability = ",THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))

!     stdout.flush
!     stdout.text("Sylvain-Csizmadia first polarisability - using user-input Unsold denominator (SI):")
!     stdout.flush
!     stdout.put(alpha*ELECTRIC_POLARISABILITY_SI_PER_AU) 
!     stdout.flush
!     stdout.show("Mean polarisability = ",ELECTRIC_POLARISABILITY_SI_PER_AU*THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))

      stdout.flush
      stdout.text("Principal values (au) :")
      stdout.flush
      alpha.solve_eigenproblem(eigenvalues,eigenvectors)
      stdout.put(eigenvalues,"column")
!     stdout.flush
!     stdout.text("Principal values (SI) :")
!     stdout.flush
!     stdout.put(eigenvalues*ELECTRIC_POLARISABILITY_SI_PER_AU,"column")
      stdout.flush
      stdout.text("Principal directions :")
      stdout.flush
      stdout.put(eigenvectors)

      ! Evaluate Sylvain-Csizmadia polarisability
      alpha = alpha/fac
      fac = 0
      do i = 1,.n_a
         fac = fac - FOUR/(.n_a*.orbital_energies.restricted(i))
      end
      alpha = fac*alpha

      stdout.flush
      stdout.text("Sylvain-Csizmadia first polarisability (au):")
      stdout.flush
      stdout.put(alpha) 
      stdout.flush
      stdout.show("Mean polarisability = ",THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))

!     stdout.flush
!     stdout.text("Sylvain-Csizmadia first polarisability (SI):")
!     stdout.flush
!     stdout.put(alpha*ELECTRIC_POLARISABILITY_SI_PER_AU) 
!     stdout.flush
!     stdout.show("Mean polarisability = ",ELECTRIC_POLARISABILITY_SI_PER_AU*THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))

      stdout.flush
      stdout.text("Principal values (au) :")
      stdout.flush
      alpha.solve_eigenproblem(eigenvalues,eigenvectors)
      stdout.put(eigenvalues,"column")
!     stdout.flush
!     stdout.text("Principal values (SI) :")
!     stdout.flush
!     stdout.put(eigenvalues*ELECTRIC_POLARISABILITY_SI_PER_AU,"column")
      stdout.flush
      stdout.text("Principal directions :")
      stdout.flush
      stdout.put(eigenvectors)

      ! Whitten-Spackman-Jayatilaka polarisability
      orb_e.create(.n_a)
      alpha1.create(3,3,.n_a);      alpha1 = ZERO
      alpha2.create(3,3,.n_a,.n_a); alpha2 = ZERO
      Pi.create(.n_bf,.n_bf)
      Tx.create(.n_bf,.n_bf,.n_a)
      Ty.create(.n_bf,.n_bf,.n_a)
      Tz.create(.n_bf,.n_bf,.n_a)
      do i = 1,.n_a
         MOi => .molecular_orbitals.restricted(:,i:i)
         Pi.to_product_of(MOi,MOi,transpose_b=TRUE)
         Tx(:,:,i) = matmul(Pi,Dx) 
         Ty(:,:,i) = matmul(Pi,Dy)
         Tz(:,:,i) = matmul(Pi,Dz)
      end
      do i = 1,.n_a
         MOi => .molecular_orbitals.restricted(:,i:i)
         Pi.to_product_of(MOi,MOi,transpose_b=TRUE)
         alpha1(x,x,i) = Pi.trace_product_with(Qxx) - Tx(:,:,i).trace_product_with(Tx(:,:,i))
         alpha1(y,y,i) = Pi.trace_product_with(Qyy) - Ty(:,:,i).trace_product_with(Ty(:,:,i))
         alpha1(z,z,i) = Pi.trace_product_with(Qzz) - Tz(:,:,i).trace_product_with(Tz(:,:,i))
         alpha1(y,x,i) = Pi.trace_product_with(Qxy) - Ty(:,:,i).trace_product_with(Tx(:,:,i))
         alpha1(z,x,i) = Pi.trace_product_with(Qxz) - Tz(:,:,i).trace_product_with(Tx(:,:,i))
         alpha1(z,y,i) = Pi.trace_product_with(Qyz) - Tz(:,:,i).trace_product_with(Ty(:,:,i))
         alpha1(:,:,i) = -FOUR*alpha1(:,:,i)/(.orbital_energies.restricted(i))
         do j = 1,(i-1)
             alpha2(x,x,i,j) = -Tx(:,:,i).trace_product_with(Tx(:,:,j)) - Tx(:,:,j).trace_product_with(Tx(:,:,i))
             alpha2(y,y,i,j) = -Ty(:,:,i).trace_product_with(Ty(:,:,j)) - Ty(:,:,j).trace_product_with(Ty(:,:,i))
             alpha2(z,z,i,j) = -Tz(:,:,i).trace_product_with(Tz(:,:,j)) - Tz(:,:,j).trace_product_with(Tz(:,:,i))
             alpha2(y,x,i,j) = -Ty(:,:,i).trace_product_with(Tx(:,:,j)) - Ty(:,:,j).trace_product_with(Tx(:,:,i))
             alpha2(z,x,i,j) = -Tz(:,:,i).trace_product_with(Tx(:,:,j)) - Tz(:,:,j).trace_product_with(Tx(:,:,i))
             alpha2(z,y,i,j) = -Tz(:,:,i).trace_product_with(Ty(:,:,j)) - Tz(:,:,j).trace_product_with(Ty(:,:,i))
             alpha2(:,:,i,j) = -TWO*alpha2(:,:,i,j)*(ONE/.orbital_energies.restricted(i) + ONE/.orbital_energies.restricted(j))
         end
      end
      Tz.destroy; Ty.destroy; Tx.destroy
      Pi.destroy

    ! stdout.flush
    ! stdout.text("First polarisability, orbital contributions:")
    ! stdout.flush
    ! do i = 1,.n_a
    !    stdout.text("... for orbital "//i.to_str.trim)
    !    stdout.put(1.0/.orbital_energies.restricted(i))
    !    stdout.flush
    !    stdout.put(alpha1(:,:,i))
    ! end
    ! stdout.flush
    ! stdout.text("First polarisability, orbital pair contributions:")
    ! stdout.flush
    ! do i = 1,.n_a
    ! do j = 1,(i-1)
    !    stdout.text("... for orbitals "//i.to_str.trim//" and "//j.to_str.trim)
    !    stdout.put(0.5*(ONE/.orbital_energies.restricted(i) + ONE/.orbital_energies.restricted(j)))
    !    stdout.flush
    !    stdout.put(alpha2(:,:,i,j))
    ! end
    ! end

      stdout.flush
      alpha = ZERO
      do i = 1,.n_a
         alpha = alpha + alpha1(:,:,i)
         do j = 1,(i-1)
            alpha = alpha + alpha2(:,:,i,j)
         end
      end
      alpha.symmetric_reflect

      stdout.flush
      stdout.text("Whitten-Spackman-Jayatilaka first polarisability (au):")
      stdout.flush
      stdout.put(alpha) 
      stdout.flush
      stdout.show("Mean polarisability = ",THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))

!     stdout.flush
!     stdout.text("Whitten-Spackman-Jayatilaka first polarisability (SI):")
!     stdout.flush
!     stdout.put(alpha*ELECTRIC_POLARISABILITY_SI_PER_AU) 
!     stdout.flush
!     stdout.show("Mean polarisability = ",ELECTRIC_POLARISABILITY_SI_PER_AU*THIRD*(alpha(x,x)+alpha(y,y)+alpha(z,z)))

      stdout.flush
      stdout.text("Principal values (au) :")
      stdout.flush
      alpha.solve_eigenproblem(eigenvalues,eigenvectors)
      stdout.put(eigenvalues,"column")
!     stdout.flush
!     stdout.text("Principal values (SI) :")
!     stdout.flush
!     stdout.put(eigenvalues*ELECTRIC_POLARISABILITY_SI_PER_AU,"column")
      stdout.flush
      stdout.text("Principal directions :")
      stdout.flush
      stdout.put(eigenvectors)

!      stdout.flush
!      stdout.text("First polarisability, mono-orbital contributions:")
!      stdout.flush
!      do i = 1,.n_a
!         do j = 1,.n_a
!            if (i==j) cycle
!            alpha1(:,:,i) = alpha1(:,:,i) + HALF*alpha2(:,:,i,j)
!         end
!         stdout.text("... for orbital "//i.to_str.trim)
!         stdout.put(alpha1(:,:,i))
!      end
!      stdout.flush
!      stdout.text("Sum of all mono-orbital contributions:")
!      stdout.flush
!      alpha = ZERO
!      do i = 1,.n_a
!         alpha = alpha + alpha1(:,:,i)
!      end
!      stdout.put(alpha)

      alpha2.destroy
      alpha1.destroy
      orb_e.destroy

      beta(x,x,x) = P.trace_product_with(Oxxx) - THREE*P.trace_product_with(Dx,P,Qxx) &
                  + P.trace_product_with(Dx,P,Dx,P,Dx)
      beta(y,y,y) = P.trace_product_with(Oyyy) - THREE*P.trace_product_with(Dy,P,Qyy) &
                  + P.trace_product_with(Dy,P,Dy,P,Dy)
      beta(z,z,z) = P.trace_product_with(Ozzz) - THREE*P.trace_product_with(Dz,P,Qzz) &
                  + P.trace_product_with(Dz,P,Dz,P,Dz)
      beta(y,x,x) = P.trace_product_with(Oxxy) - TWO*P.trace_product_with(Dx,P,Qxy) &
                  - P.trace_product_with(Dy,P,Qxx) + P.trace_product_with(Dy,P,Dx,P,Dx)
      beta(z,x,x) = P.trace_product_with(Oxxz) - TWO*P.trace_product_with(Dx,P,Qxz) &
                  - P.trace_product_with(Dz,P,Qxx) + P.trace_product_with(Dz,P,Dx,P,Dx)
      beta(y,y,x) = P.trace_product_with(Oyyx) - TWO*P.trace_product_with(Dy,P,Qxy) &
                  - P.trace_product_with(Dx,P,Qyy) + P.trace_product_with(Dy,P,Dy,P,Dx)
      beta(z,y,x) = P.trace_product_with(Oxyz) - P.trace_product_with(Dz,P,Qxy) &
                  - P.trace_product_with(Dy,P,Qxz) - P.trace_product_with(Dx,P,Qyz) &
                  + P.trace_product_with(Dz,P,Dy,P,Dx)
      beta(z,z,x) = P.trace_product_with(Ozzx) - TWO*P.trace_product_with(Dz,P,Qxz) &
                  - P.trace_product_with(Dx,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dx)
      beta(z,y,y) = P.trace_product_with(Oyyz) - TWO*P.trace_product_with(Dy,P,Qyz) &
                  - P.trace_product_with(Dz,P,Qyy) + P.trace_product_with(Dz,P,Dy,P,Dy)
      beta(z,z,y) = P.trace_product_with(Ozzy) - TWO*P.trace_product_with(Dz,P,Qyz) &
                  - P.trace_product_with(Dy,P,Qzz) + P.trace_product_with(Dz,P,Dz,P,Dy)
      beta.make_symmetric
      fac = 12.0d0/delta
      beta = fac*beta

      P.destroy
      Oxyz.destroy
      Ozzy.destroy; Ozzx.destroy
      Oyyz.destroy; Oyyx.destroy
      Oxxz.destroy; Oxxy.destroy
      Ozzz.destroy; Oyyy.destroy; Oxxx.destroy
      Qyz.destroy; Qxz.destroy; Qxy.destroy
      Qzz.destroy; Qyy.destroy; Qxx.destroy
      Dz.destroy; Dy.destroy; Dx.destroy
   
      stdout.flush
      stdout.text("Dipole hyperpolarisability - using user input Usold denominator (au):")
      stdout.flush
      stdout.put(beta) 

!     stdout.flush
!     stdout.text("Dipole hyperpolarisability - using user input Usold denominator (SI):")
!     stdout.flush
!     stdout.put(beta*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU) 

      beta.set_vector_hyperpolarisability(bvec)

      stdout.flush
      stdout.text("Vector dipole hyperpolarisability (au):")
      stdout.flush
      stdout.put(bvec)

!     stdout.flush
!     stdout.text("Vector dipole hyperpolarisability (SI):")
!     stdout.flush
!     stdout.put(bvec*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU)
   end

   put_sos_dipole_polarisability ::: leaky
   ! Calculate the dipole polarisability using the sum-over-states (SOS) formula.
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
   ENSURE(.scfdata.created,"no scf data")
   ENSURE(.scfdata.scf_kind=="rhf","SOS polarisability only for RHF case")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")
      D  :: MAT3{REAL}*
      MO :: MAT{REAL}*
      e  :: VEC{REAL}*
      eigenvalues :: VEC{REAL}(3)
      alpha,eigenvectors :: MAT{REAL}(3,3)
      l,m,a,i,n_occ :: INT
      val :: REAL

      MO => .molecular_orbitals.restricted
      e  => .orbital_energies.restricted
      n_occ = .n_a   ! The number of occupied orbitals
     
      ! Get the dipole moment matrices in the AO basis.
      D.create(.n_bf,.n_bf,3)
      .get_dipole_matrices(D(:,:,1),D(:,:,2),D(:,:,3))
      
      ! Change dipole matrices from AO -> MO basis
      D(:,:,1).change_basis_using(MO)
      D(:,:,2).change_basis_using(MO)
      D(:,:,3).change_basis_using(MO)
      
      ! Do the calculation
      alpha = ZERO
      do l = 1,3
      do m = 1,l
         val = ZERO
         do a = n_occ+1,.n_bf
         do i = 1,n_occ
            val = val + (D(a,i,l)*D(a,i,m))/(e(a)-e(i))
         end
         end
         alpha(l,m) = val 
      end
      end
      D.destroy
      alpha = FOUR*alpha
      alpha.symmetric_reflect

      .dipole_polarisability.destroy
      .dipole_polarisability.create(3,3) ! leaky here
      .dipole_polarisability = alpha

      stdout.flush
      stdout.text("Sum-over-states dipole polarisability (au):")
      stdout.flush
      stdout.put(alpha) 
      stdout.flush
      stdout.show("Mean polarisability = ",THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3)))

 !    stdout.flush
 !    stdout.text("Sum-over-states dipole polarisability (SI):")
 !    stdout.flush
 !    stdout.put(alpha*ELECTRIC_POLARISABILITY_SI_PER_AU) 
 !    stdout.flush
 !    stdout.show("Mean polarisability = ",ELECTRIC_POLARISABILITY_SI_PER_AU*THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3)))

      stdout.flush
      stdout.text("Principal values (au) :")
      stdout.flush
      alpha.solve_eigenproblem(eigenvalues,eigenvectors)
      stdout.put(eigenvalues,"column")
!     stdout.flush
!     stdout.text("Principal values (SI) :")
!     stdout.flush
!     stdout.put(eigenvalues*ELECTRIC_POLARISABILITY_SI_PER_AU,"column")
      stdout.flush
      stdout.text("Principal directions :")
      stdout.flush
      stdout.put(eigenvectors)
   end

!   put_scf_dipole_polarisability ::: leaky
!   ! Calculate the polarisability using Coupled Perturbed Hartree-Fock theory.
!   ENSURE(.molecular_orbitals.created,"no MO's")
!   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
!   ENSURE(.scfdata.created,"no scf data")
!   ENSURE(.scfdata.scf_kind=="rhf","SOS polarisability only for RHF case")
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom info")
!      D_mo,D_ao,U,F,dpol :: MAT3{REAL}*
!      e, wt,rho,Wa, alpha_bar_rs :: VEC{REAL}* !mjt
!      MO,xi_vv,xi_oo,W, alpha_bar, pt :: MAT{REAL}* !mjt
!      alpha,eigenvectors :: MAT{REAL}(3,3)
!      beta  :: MAT3{REAL}(3,3,3)
!      bvec,eigenvalues :: VEC{REAL}(3)
!      n,n_occ,n_vir,l,m,a,b,i,j,n_pair,ix,ix1,ix2, n_pt :: INT !mjt
!      val,val1,val2 :: REAL
!      indices :: VEC{INT}*
!      destroy_becke,dft :: BIN
!
!      .make_U_electric_dipole
!   
!      MO => .molecular_orbitals.restricted
!      e  => .orbital_energies.restricted
!      n = .n_bf
!
!      n_occ = .n_a 
!      n_vir = n - n_occ
!      n_pair = n_occ*n_vir !mjt
!
!      ! Get the dipole moment matrices in the AO basis.
!      U.create(n_vir,n_occ,3)
!
!      ! Get the dipole moment matrices in the AO basis.
!      D_ao.create(n,n,3)
!      D_mo.create(n_vir,n_occ,3)
!      .get_dipole_matrices(D_ao(:,:,1),D_ao(:,:,2),D_ao(:,:,3))
!      
!      ! Change dipole matrices from AO -> MO basis
!      D_ao(:,:,1).change_basis_to(D_mo(:,:,1),MO(:,n_occ+1:),MO(:,:n_occ))
!      D_ao(:,:,2).change_basis_to(D_mo(:,:,2),MO(:,n_occ+1:),MO(:,:n_occ))
!      D_ao(:,:,3).change_basis_to(D_mo(:,:,3),MO(:,n_occ+1:),MO(:,:n_occ))
!
!      ! Solve the CPHF equations
!      D_mo = -D_mo
!      .MAIN:solve_CPHF_equations(U,D_mo) 
!   
!      ! Finally calculate polarisability using U and D
!      alpha = 0
!      do l = 1,3
!      do m = 1,l
!         val = ZERO
!         do a = 1,n_vir
!         do i = 1,n_occ
!            val = val + D_mo(a,i,l)*U(a,i,m)
!         end
!         end
!         alpha(l,m) = val
!      end
!      end
!      alpha = FOUR*alpha
!      alpha.symmetric_reflect
!   
!      stdout.save
!      stdout.set_real_style("e")
!
!      stdout.flush
!      stdout.text("Dipole polarisability (au):")
!      stdout.flush
!      stdout.put(alpha) 
!      stdout.flush
!      stdout.show("Mean polarisability = ",THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3)))
!
!      stdout.flush
!      stdout.text("Dipole polarisability (SI):")
!      stdout.flush
!      stdout.put(alpha*ELECTRIC_POLARISABILITY_SI_PER_AU) 
!      stdout.flush
!      stdout.show("Mean polarisability = ",ELECTRIC_POLARISABILITY_SI_PER_AU*THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3)))
!
!      stdout.flush
!      stdout.text("Principal values (au) :")
!      stdout.flush
!      alpha.solve_eigenproblem(eigenvalues,eigenvectors)
!      stdout.put(eigenvalues,"column")
!      stdout.flush
!      stdout.text("Principal values (SI) :")
!      stdout.flush
!      stdout.put(eigenvalues*ELECTRIC_POLARISABILITY_SI_PER_AU,"column")
!      stdout.flush
!      stdout.text("Principal directions :")
!      stdout.flush
!      stdout.put(eigenvectors)
!
!      .dipole_polarisability.destroy
!      .dipole_polarisability.create(3,3) ! leaky here
!      .dipole_polarisability = alpha
!
!      !mjt Calculate the orbital-pair contribution to the mean polarisability from alpha_bar
!
!      alpha_bar.create(n_vir,n_occ) !mjt
!      alpha_bar_rs.create(n_pair) !mjt
!      indices.create(n_pair) !mjt
!
!      stdout.flush
!      stdout.text("Mean dipole polarisbility, top orbital-pair contributions:")
!      stdout.flush
!      alpha_bar = 0
!      do a = 1,n_vir
!      do i = 1,n_occ
!         val = 0
!         do l = 1,3
!            val = val + D_mo(a,i,l)*U(a,i,l)
!         end
!         alpha_bar(a,i) = val
!      end
!      end
!      alpha_bar = THIRD * alpha_bar
!      alpha_bar_rs = reshape(abs(alpha_bar),[n_pair]) ! reshape matrix into vector
!      alpha_bar_rs.quick_sort(indices,TRUE)      ! sort the vector in descending order
!      stdout.dash(int_fields=3,real_fieds=1)
!      stdout.put("Rank",int_width=TRUE)
!      stdout.put("a",int_width=TRUE)
!      stdout.put("i",int_width=TRUE)
!      stdout.put("alpha_ai")
!      stdout.dash(int_fields=3,real_fieds=1)
!      do a = 1,5 ! take the top 5 results
!         ix = indices(a) ! get the index
!         ix1 = mod(ix,n_vir)
!         ix2 = (ix-1)/n_vir + 1
!         stdout.put(a)
!         stdout.put(ix1)
!         stdout.put(ix2)
!         stdout.put(alpha_bar(ix1,ix2))
!         stdout.flush
!      end
!      stdout.dash(int_fields=3,real_fieds=1)
!    
!      indices.destroy
!      alpha_bar.destroy
!      alpha_bar_rs.destroy
!      
!      !mjt end of block
!
!      D_mo.destroy
!
!      ! Calculate hyperpolarisability using U and D
!      ! Taken from Colwell et al, CPL 210, p. 261 (1993)
!
!      ! Make F(k). We don't need the U term in eqn (29)
!      F.create(n,n,3)
!      D_ao(:,:,1).change_basis_to(F(:,:,1),MO)
!      D_ao(:,:,2).change_basis_to(F(:,:,2),MO)
!      D_ao(:,:,3).change_basis_to(F(:,:,3),MO)
!      .MAIN:add_A_times_U(F,U)
!
!      ! Make beta
!      beta = ZERO
!      xi_oo.create(n_occ,n_occ)
!      xi_vv.create(n_vir,n_vir)
!      do m = 1,3
!      do n = 1,3
!         xi_vv = matmul(U(:,:,m),transpose(U(:,:,n))) &
!               + matmul(U(:,:,n),transpose(U(:,:,m))) 
!         xi_oo = matmul(transpose(U(:,:,m)),U(:,:,n)) &
!               + matmul(transpose(U(:,:,n)),U(:,:,m)) 
!         do l = 1,3
!            val1 =  TWO*F(1 :n_occ,1 :n_occ,l).trace_product_with(xi_oo)
!            val2 = -TWO*F(n_occ+1:,n_occ+1:,l).trace_product_with(xi_vv)
!            val  = val1 + val2
!            beta(l,m,n) = beta(l,m,n) + val
!            beta(m,n,l) = beta(m,n,l) + val
!            beta(n,l,m) = beta(n,l,m) + val
!         end
!      end
!      end
!      xi_vv.destroy; xi_oo.destroy; F.destroy
!   
!      stdout.flush
!      stdout.text("Dipole hyperpolarisability (au):")
!      stdout.flush
!      stdout.put(beta) 
!
!      stdout.flush
!      stdout.text("Dipole hyperpolarisability (SI):")
!      stdout.flush
!      stdout.put(beta*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU) 
!
!      .dipole_hyperpolarisability.destroy
!      .dipole_hyperpolarisability.create(3,3,3) ! leaky here
!      .dipole_hyperpolarisability = beta
!
!      beta.set_vector_hyperpolarisability(bvec)
!
!      stdout.flush
!      stdout.text("Vector dipole hyperpolarisability (au):")
!      stdout.flush
!      stdout.put(bvec)
!
!      stdout.flush
!      stdout.text("Vector dipole hyperpolarisability (SI):")
!      stdout.flush
!      stdout.put(bvec*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU)
!      stdout.unsave
!
!
!      ! ****************************
!      ! Distributed polarisabilities
!      ! ****************************
!
!      .distributed_polarisability.create(3,3,.n_atom)
!      dpol => distributed_polarisability
!
!      ! Make the AO density matrices
!      F.create(n,n,3)
!      W.create(n_vir,n)
!      do i = 1,3
!         W.to_product_of(U(:,:,i),transpose(MO(:,1:n_occ)))
!         F(:,:,i).to_product_of(MO(:,n_occ+1:),W)
!         F(:,:,i) = TWO*(F(:,:,i) + transpose(F(:,:,i)))
!      end
!      W.destroy
!
!      ! Set up integration grid if not there
!      if (.becke_grid.destroyed) then
!         destroy_becke = TRUE
!         .becke_grid.create
!         .becke_grid.set_defaults
!         .becke_grid.set_atom_info(.atom.atomic_number &
!                                  ,.atom.transposed_coordinates &
!                                  ,.atom.minimum_basis_exponents &
!                                  ,.atom) ! leaky
!         .becke_grid.set_grid_data
!      else
!         destroy_becke = FALSE
!         ENSURE(.becke_grid.finalized,"no finalized becke_grid")
!      end
!
!      ! Make the becke grid integration grid
!      .becke_grid.make_grid(pt,wt) ! <<<<<<<<<<< leaky
!
!    ! ! Write Becke grid information and make grid
!    ! .becke_grid.put
!    ! .becke_grid.put_atom_info
!
!      ! Set up atomic densities for stockholder weights
!      if (NOT .atom.has_all_ANO_data) then
!         if (.scfdata.destroyed) then; dft = FALSE
!         else;                         dft = .scfdata.is_DFT_calculation
!         end
!         .make_ANO_data(use_ks=dft)
!      end
!
!      ! Assign NO's to MO's for density evaluation
!      .assign_NOs_to_MOs
!
!      ! Integrate the charges
!      n_pt = pt.dim1
!      Wa.create(n_pt)
!      rho.create(n_pt)
!      do i = 1,3
!         .make_density_grid(rho,pt)
!         rho = rho*wt
!         do a = 1,.n_atom
!            .make_stockholder_atom_grid(Wa,a,pt)
!            Wa = rho*Wa
!            dpol(1,i,a) = sum(Wa*(pt(:,1)-.atom(a).pos(1)))
!            dpol(2,i,a) = sum(Wa*(pt(:,2)-.atom(a).pos(2)))
!            dpol(3,i,a) = sum(Wa*(pt(:,3)-.atom(a).pos(3)))
!         end
!      end
!      rho.destroy; Wa.destroy
!      wt.destroy; pt.destroy
!      if (destroy_becke) .becke_grid.destroy
!
!      F.destroy
!      D_ao.destroy
!      U.destroy
!
!      ! Calculate dipole contributions
!      e_dipole = sum(dipole,dim=2)
!      n_dipole = ZERO
!      do a = 1,.n_atom
!         n_dipole = n_dipole + charge(a)*.atom(a).pos
!      end
!      t_dipole = e_dipole + n_dipole
!      ed = e_dipole.norm
!      nd = n_dipole.norm
!      td = t_dipole.norm
!
!      ! Write results in au
!      stdout.flush
!      stdout.text("Hirshfeld charges and dipole moments (au):")
!      stdout.flush
!      stdout.show("No. of integration grid points = ",n_pt)
!      stdout.show("Check: no. of electrons        = ",n_e)
!      stdout.flush
!      stdout.dash(int_fields=1,real_fields=5)
!      stdout.tab(int_fields=1)
!      stdout.put("q")
!      stdout.put("mu_x")
!      stdout.put("mu_y")
!      stdout.put("mu_z")
!      stdout.put("|mu|")
!      stdout.flush
!      stdout.put("Atom",int_width=TRUE)
!      stdout.tab(real_fields=1)
!      stdout.put("/au")
!      stdout.put("/au")
!      stdout.put("/au")
!      stdout.put("/au")
!      stdout.flush
!      stdout.dash(int_fields=1,real_fields=5)
!      do a = 1,.n_atom
!         stdout.put(.atom(a).label,int_width=TRUE)
!         stdout.put(charge(a))
!         stdout.put(dipole(1,a))
!         stdout.put(dipole(2,a))
!         stdout.put(dipole(3,a))
!         ed = dipole(:,a).norm
!         stdout.put(ed)
!         stdout.flush
!      end
!      stdout.dash(int_fields=1,real_fields=5)
!      stdout.flush
!      stdout.text("Distributed dipole moments:")
!      stdout.flush
!      stdout.show("Total electronic dipole magnitude/au    =",ed)
!      stdout.show("Total nuclear dipole magnitude/au       =",nd)
!      stdout.show("Total dipole magnitude/au               =",td)
!
!      ! Write results in Debye
!      stdout.flush
!      stdout.text("Hirshfeld charges and dipole moments (Debye):")
!      stdout.flush
!      stdout.dash(int_fields=1,real_fields=5)
!      stdout.tab(int_fields=1)
!      stdout.put("q")
!      stdout.put("mu_x")
!      stdout.put("mu_y")
!      stdout.put("mu_z")
!      stdout.put("|mu|")
!      stdout.flush
!      stdout.put("Atom",int_width=TRUE)
!      stdout.tab(real_fields=1)
!      stdout.put("/Debye")
!      stdout.put("/Debye")
!      stdout.put("/Debye")
!      stdout.put("/Debye")
!      stdout.flush
!      stdout.dash(int_fields=1,real_fields=5)
!      do a = 1,.n_atom
!         stdout.put(.atom(a).label,int_width=TRUE)
!         stdout.put(charge(a))
!         stdout.put(dipole(1,a).to_units("debye"))
!         stdout.put(dipole(2,a).to_units("debye"))
!         stdout.put(dipole(3,a).to_units("debye"))
!         ed = dipole(:,a).norm
!         stdout.put(ed.to_units("debye"))
!         stdout.flush
!      end
!      stdout.dash(int_fields=1,real_fields=5)
!      stdout.flush
!      stdout.show("Total electronic dipole magnitude/Debye =",ed.to_units("debye"))
!      stdout.show("Total nuclear dipole magnitude/Debye    =",nd.to_units("debye"))
!      stdout.show("Total dipole magnitude/Debye            =",td.to_units("debye"))
!   end

!   put_scf_dipole_polarisability_orig ::: leaky
!   ! Calculate the polarisability using Coupled Perturbed Hartree-Fock theory.
!   ENSURE(.molecular_orbitals.created,"no MO's")
!   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
!   ENSURE(.scfdata.created,"no scf data")
!   ENSURE(.scfdata.scf_kind=="rhf","SOS polarisability only for RHF case")
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom info")
!      D_mo,D_ao,U,F,dpol :: MAT3{REAL}*
!      e, wt,rho,Wa, alpha_bar_rs :: VEC{REAL}* !mjt
!      MO,xi_vv,xi_oo,W, alpha_bar, pt :: MAT{REAL}* !mjt
!      alpha,eigenvectors :: MAT{REAL}(3,3)
!      beta  :: MAT3{REAL}(3,3,3)
!      bvec,eigenvalues :: VEC{REAL}(3)
!      n,n_occ,n_vir,l,m,a,b,i,j,n_pair,ix,ix1,ix2, n_pt :: INT !mjt
!      val,val1,val2 :: REAL
!      indices :: VEC{INT}*
!      destroy_becke,dft :: BIN
!   
!      MO => .molecular_orbitals.restricted
!      e  => .orbital_energies.restricted
!      n = .n_bf
!
!      n_occ = .n_a 
!      n_vir = n - n_occ
!      n_pair = n_occ*n_vir !mjt
!
!      ! Get the dipole moment matrices in the AO basis.
!      U.create(n_vir,n_occ,3)
!
!      ! Get the dipole moment matrices in the AO basis.
!      D_ao.create(n,n,3)
!      D_mo.create(n_vir,n_occ,3)
!      .get_dipole_matrices(D_ao(:,:,1),D_ao(:,:,2),D_ao(:,:,3))
!      
!      ! Change dipole matrices from AO -> MO basis
!      D_ao(:,:,1).change_basis_to(D_mo(:,:,1),MO(:,n_occ+1:),MO(:,:n_occ))
!      D_ao(:,:,2).change_basis_to(D_mo(:,:,2),MO(:,n_occ+1:),MO(:,:n_occ))
!      D_ao(:,:,3).change_basis_to(D_mo(:,:,3),MO(:,n_occ+1:),MO(:,:n_occ))
!
!      ! Solve the CPHF equations
!      D_mo = -D_mo
!      .MAIN:solve_CPHF_equations(U,D_mo) 
!   
!      ! Finally calculate polarisability using U and D
!      alpha = 0
!      do l = 1,3
!      do m = 1,l
!         val = ZERO
!         do a = 1,n_vir
!         do i = 1,n_occ
!            val = val + D_mo(a,i,l)*U(a,i,m)
!         end
!         end
!         alpha(l,m) = val
!      end
!      end
!      alpha = FOUR*alpha
!      alpha.symmetric_reflect
!   
!      stdout.save
!      stdout.set_real_style("e")
!
!      stdout.flush
!      stdout.text("Dipole polarisability (au):")
!      stdout.flush
!      stdout.put(alpha) 
!      stdout.flush
!      stdout.show("Mean polarisability = ",THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3)))
!
!      stdout.flush
!      stdout.text("Dipole polarisability (SI):")
!      stdout.flush
!      stdout.put(alpha*ELECTRIC_POLARISABILITY_SI_PER_AU) 
!      stdout.flush
!      stdout.show("Mean polarisability = ",ELECTRIC_POLARISABILITY_SI_PER_AU*THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3)))
!
!      stdout.flush
!      stdout.text("Principal values (au) :")
!      stdout.flush
!      alpha.solve_eigenproblem(eigenvalues,eigenvectors)
!      stdout.put(eigenvalues,"column")
!      stdout.flush
!      stdout.text("Principal values (SI) :")
!      stdout.flush
!      stdout.put(eigenvalues*ELECTRIC_POLARISABILITY_SI_PER_AU,"column")
!      stdout.flush
!      stdout.text("Principal directions :")
!      stdout.flush
!      stdout.put(eigenvectors)
!
!      .dipole_polarisability.destroy
!      .dipole_polarisability.create(3,3) ! leaky here
!      .dipole_polarisability = alpha
!
!      !mjt Calculate the orbital-pair contribution to the mean polarisability from alpha_bar
!
!      alpha_bar.create(n_vir,n_occ) !mjt
!      alpha_bar_rs.create(n_pair) !mjt
!      indices.create(n_pair) !mjt
!
!      stdout.flush
!      stdout.text("Mean dipole polarisbility, top orbital-pair contributions:")
!      stdout.flush
!      alpha_bar = 0
!      do a = 1,n_vir
!      do i = 1,n_occ
!         val = 0
!         do l = 1,3
!            val = val + D_mo(a,i,l)*U(a,i,l)
!         end
!         alpha_bar(a,i) = val
!      end
!      end
!      alpha_bar = THIRD * alpha_bar
!      alpha_bar_rs = reshape(abs(alpha_bar),[n_pair]) ! reshape matrix into vector
!      alpha_bar_rs.quick_sort(indices,TRUE)      ! sort the vector in descending order
!      stdout.dash(int_fields=3,real_fieds=1)
!      stdout.put("Rank",int_width=TRUE)
!      stdout.put("a",int_width=TRUE)
!      stdout.put("i",int_width=TRUE)
!      stdout.put("alpha_ai")
!      stdout.dash(int_fields=3,real_fieds=1)
!      do a = 1,5 ! take the top 5 results
!         ix = indices(a) ! get the index
!         ix1 = mod(ix,n_vir)
!         ix2 = (ix-1)/n_vir + 1
!         stdout.put(a)
!         stdout.put(ix1)
!         stdout.put(ix2)
!         stdout.put(alpha_bar(ix1,ix2))
!         stdout.flush
!      end
!      stdout.dash(int_fields=3,real_fieds=1)
!    
!      indices.destroy
!      alpha_bar.destroy
!      alpha_bar_rs.destroy
!      
!      !mjt end of block
!
!      D_mo.destroy
!
!      ! Calculate hyperpolarisability using U and D
!      ! Taken from Colwell et al, CPL 210, p. 261 (1993)
!
!      ! Make F(k). We don't need the U term in eqn (29)
!      F.create(n,n,3)
!      D_ao(:,:,1).change_basis_to(F(:,:,1),MO)
!      D_ao(:,:,2).change_basis_to(F(:,:,2),MO)
!      D_ao(:,:,3).change_basis_to(F(:,:,3),MO)
!      .MAIN:add_A_times_U(F,U)
!
!      ! Make beta
!      beta = ZERO
!      xi_oo.create(n_occ,n_occ)
!      xi_vv.create(n_vir,n_vir)
!      do m = 1,3
!      do n = 1,3
!         xi_vv = matmul(U(:,:,m),transpose(U(:,:,n))) &
!               + matmul(U(:,:,n),transpose(U(:,:,m))) 
!         xi_oo = matmul(transpose(U(:,:,m)),U(:,:,n)) &
!               + matmul(transpose(U(:,:,n)),U(:,:,m)) 
!         do l = 1,3
!            val1 =  TWO*F(1 :n_occ,1 :n_occ,l).trace_product_with(xi_oo)
!            val2 = -TWO*F(n_occ+1:,n_occ+1:,l).trace_product_with(xi_vv)
!            val  = val1 + val2
!            beta(l,m,n) = beta(l,m,n) + val
!            beta(m,n,l) = beta(m,n,l) + val
!            beta(n,l,m) = beta(n,l,m) + val
!         end
!      end
!      end
!      xi_vv.destroy; xi_oo.destroy; F.destroy
!   
!      stdout.flush
!      stdout.text("Dipole hyperpolarisability (au):")
!      stdout.flush
!      stdout.put(beta) 
!
!      stdout.flush
!      stdout.text("Dipole hyperpolarisability (SI):")
!      stdout.flush
!      stdout.put(beta*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU) 
!
!      .dipole_hyperpolarisability.destroy
!      .dipole_hyperpolarisability.create(3,3,3) ! leaky here
!      .dipole_hyperpolarisability = beta
!
!      beta.set_vector_hyperpolarisability(bvec)
!
!      stdout.flush
!      stdout.text("Vector dipole hyperpolarisability (au):")
!      stdout.flush
!      stdout.put(bvec)
!
!      stdout.flush
!      stdout.text("Vector dipole hyperpolarisability (SI):")
!      stdout.flush
!      stdout.put(bvec*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU)
!      stdout.unsave
!
!
!      ! ****************************
!      ! Distributed polarisabilities
!      ! ****************************
!
!      .distributed_polarisability.create(3,3,.n_atom)
!      dpol => distributed_polarisability
!
!      ! Make the AO density matrices
!      F.create(n,n,3)
!      W.create(n_vir,n)
!      do i = 1,3
!         W.to_product_of(U(:,:,i),transpose(MO(:,1:n_occ)))
!         F(:,:,i).to_product_of(MO(:,n_occ+1:),W)
!         F(:,:,i) = TWO*(F(:,:,i) + transpose(F(:,:,i)))
!      end
!      W.destroy
!
!      ! Set up integration grid if not there
!      if (.becke_grid.destroyed) then
!         destroy_becke = TRUE
!         .becke_grid.create
!         .becke_grid.set_defaults
!         .becke_grid.set_atom_info(.atom.atomic_number &
!                                  ,.atom.transposed_coordinates &
!                                  ,.atom.minimum_basis_exponents &
!                                  ,.atom) ! leaky
!         .becke_grid.set_grid_data
!      else
!         destroy_becke = FALSE
!         ENSURE(.becke_grid.finalized,"no finalized becke_grid")
!      end
!
!      ! Make the becke grid integration grid
!      .becke_grid.make_grid(pt,wt) ! <<<<<<<<<<< leaky
!
!    ! ! Write Becke grid information and make grid
!    ! .becke_grid.put
!    ! .becke_grid.put_atom_info
!
!      ! Set up atomic densities for stockholder weights
!      if (NOT .atom.has_all_ANO_data) then
!         if (.scfdata.destroyed) then; dft = FALSE
!         else;                         dft = .scfdata.is_DFT_calculation
!         end
!         .make_ANO_data(use_ks=dft)
!      end
!
!      ! Assign NO's to MO's for density evaluation
!      .assign_NOs_to_MOs
!
!      ! Integrate the charges
!      n_pt = pt.dim1
!      Wa.create(n_pt)
!      rho.create(n_pt)
!      do i = 1,3
!         .make_density_grid(rho,pt)
!         rho = rho*wt
!         do a = 1,.n_atom
!            .make_stockholder_atom_grid(Wa,a,pt)
!            Wa = rho*Wa
!            dpol(1,i,a) = sum(Wa*(pt(:,1)-.atom(a).pos(1)))
!            dpol(2,i,a) = sum(Wa*(pt(:,2)-.atom(a).pos(2)))
!            dpol(3,i,a) = sum(Wa*(pt(:,3)-.atom(a).pos(3)))
!         end
!      end
!      rho.destroy; Wa.destroy
!      wt.destroy; pt.destroy
!      if (destroy_becke) .becke_grid.destroy
!
!      F.destroy
!      D_ao.destroy
!      U.destroy
!
!      ! Calculate dipole contributions
!      e_dipole = sum(dipole,dim=2)
!      n_dipole = ZERO
!      do a = 1,.n_atom
!         n_dipole = n_dipole + charge(a)*.atom(a).pos
!      end
!      t_dipole = e_dipole + n_dipole
!      ed = e_dipole.norm
!      nd = n_dipole.norm
!      td = t_dipole.norm
!
!      ! Write results in au
!      stdout.flush
!      stdout.text("Hirshfeld charges and dipole moments (au):")
!      stdout.flush
!      stdout.show("No. of integration grid points = ",n_pt)
!      stdout.show("Check: no. of electrons        = ",n_e)
!      stdout.flush
!      stdout.dash(int_fields=1,real_fields=5)
!      stdout.tab(int_fields=1)
!      stdout.put("q")
!      stdout.put("mu_x")
!      stdout.put("mu_y")
!      stdout.put("mu_z")
!      stdout.put("|mu|")
!      stdout.flush
!      stdout.put("Atom",int_width=TRUE)
!      stdout.tab(real_fields=1)
!      stdout.put("/au")
!      stdout.put("/au")
!      stdout.put("/au")
!      stdout.put("/au")
!      stdout.flush
!      stdout.dash(int_fields=1,real_fields=5)
!      do a = 1,.n_atom
!         stdout.put(.atom(a).label,int_width=TRUE)
!         stdout.put(charge(a))
!         stdout.put(dipole(1,a))
!         stdout.put(dipole(2,a))
!         stdout.put(dipole(3,a))
!         ed = dipole(:,a).norm
!         stdout.put(ed)
!         stdout.flush
!      end
!      stdout.dash(int_fields=1,real_fields=5)
!      stdout.flush
!      stdout.text("Distributed dipole moments:")
!      stdout.flush
!      stdout.show("Total electronic dipole magnitude/au    =",ed)
!      stdout.show("Total nuclear dipole magnitude/au       =",nd)
!      stdout.show("Total dipole magnitude/au               =",td)
!
!      ! Write results in Debye
!      stdout.flush
!      stdout.text("Hirshfeld charges and dipole moments (Debye):")
!      stdout.flush
!      stdout.dash(int_fields=1,real_fields=5)
!      stdout.tab(int_fields=1)
!      stdout.put("q")
!      stdout.put("mu_x")
!      stdout.put("mu_y")
!      stdout.put("mu_z")
!      stdout.put("|mu|")
!      stdout.flush
!      stdout.put("Atom",int_width=TRUE)
!      stdout.tab(real_fields=1)
!      stdout.put("/Debye")
!      stdout.put("/Debye")
!      stdout.put("/Debye")
!      stdout.put("/Debye")
!      stdout.flush
!      stdout.dash(int_fields=1,real_fields=5)
!      do a = 1,.n_atom
!         stdout.put(.atom(a).label,int_width=TRUE)
!         stdout.put(charge(a))
!         stdout.put(dipole(1,a).to_units("debye"))
!         stdout.put(dipole(2,a).to_units("debye"))
!         stdout.put(dipole(3,a).to_units("debye"))
!         ed = dipole(:,a).norm
!         stdout.put(ed.to_units("debye"))
!         stdout.flush
!      end
!      stdout.dash(int_fields=1,real_fields=5)
!      stdout.flush
!      stdout.show("Total electronic dipole magnitude/Debye =",ed.to_units("debye"))
!      stdout.show("Total nuclear dipole magnitude/Debye    =",nd.to_units("debye"))
!      stdout.show("Total dipole magnitude/Debye            =",td.to_units("debye"))
!   end


   put_uc_dipole_polarisability ::: leaky
   ! Calculate the unit cell dipole polarisability using Coupled Perturbed
   ! Hartree-Fock theory. It assumes that the crystal data is present, and that
   ! the polarisabilities for each molecules can be added up.
   ENSURE(.dipole_polarisability.created,"no dipole_polarisability")
   ENSURE(.atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")
      alpha :: MAT{REAL}(3,3)

      ! Make it
      .MAIN:make_uc_dipole_polarisability(alpha)

      ! Print the polarisability
      stdout.flush
      stdout.text("Unit cell dipole polarisability (au)")
      stdout.text("------------------------------------")
      .MAIN:put_dipole_polarisability(alpha)

   end

   make_uc_dipole_polarisability(uc_alpha) ::: leaky
   ! Calculate the unit cell dipole polarisability using Coupled Perturbed
   ! Hartree-Fock theory. It assumes that the crystal data is present, and that
   ! the polarisabilities for each molecules can be added up.
      uc_alpha :: MAT{REAL}(3,3)

   ENSURE(.dipole_polarisability.created,"no dipole_polarisability")
   ENSURE(.atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")

      ! Molecular polarisability
      uc_alpha = .dipole_polarisability

      ! Make the unit cell cluster
      DIE_IF(any(.crystal.frag_atom_for_asym_unit_atom==0),"some asymetric unit atoms were not found")
      .cluster.destroy
      .cluster.create(.crystal)
      .cluster.set_generation_method("unit_cell")
      .cluster.defragment = FALSE
      .cluster.radius = ZERO
      .cluster.make_info
      .cluster.add_uc_tensors(uc_alpha)
   end

   put_uc_dipole_hyperpolar ::: leaky
   ! Calculate the unit cell dipole hyperpolarisability using Coupled Perturbed
   ! Hartree-Fock theory. It assumes that the crystal data is present, and that
   ! the polarisabilities for each molecules can be added up.
   ENSURE(.dipole_hyperpolarisability.created,"no dipole_hyperpolarisability")
   ENSURE(.atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")
      beta :: MAT3{REAL}(3,3,3)
      bvec :: VEC{REAL}(3)

      beta = .dipole_hyperpolarisability

      .cluster.destroy
      .crystal.make_fragment_data(.atom) 
      DIE_IF(any(.crystal.frag_atom_for_asym_unit_atom==0),"some asymetric unit atoms were not found")
      .cluster.create(.crystal)
      .cluster.set_generation_method("unit_cell")
      .cluster.defragment = FALSE
      .cluster.radius = ZERO
      .cluster.make_info
      .cluster.add_uc_tensors(beta)

      stdout.flush
      stdout.text("Unit cell dipole hyperpolarisability (au):")
      stdout.flush
      stdout.put(beta) 
!     stdout.flush
!     stdout.text("Unit Cell dipole hyperpolarisability (SI):")
!     stdout.flush
!     stdout.put(beta*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU) 

      beta.set_vector_hyperpolarisability(bvec)
      stdout.flush
      stdout.text("Vector dipole hyperpolarisability (au):")
      stdout.flush
      stdout.put(bvec)

!     stdout.flush
!     stdout.text("Vector dipole hyperpolarisability (SI):")
!     stdout.flush
!     stdout.put(bvec*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU)

   end


   put_uc_refractive_index ::: leaky
   ! Calculate the unit cell refractive index from the atomic charge
   ! and dipoole polarisabilities.
   DIE_IF(.dipole_polarisability.destroyed,"no dipole_polarisability")
   ENSURE(.atom.created,"no atom data")
   ENSURE(.crystal.created,"no crystal data")
   ENSURE(.crystal.fragment_info_made,"no crystal fragment info")
   DIE_IF(any(.crystal.frag_atom_for_asym_unit_atom==0),"some asymetric unit atoms were not found")

      chi1 :: MAT{REAL}(3,3)
      chi2 :: MAT3{REAL}(3,3,3)

      ! Make sure asymmetric unit is generated from the fragment
      ! (Also it assigns atomic charges, polarisabilities to asymmetric unit)
      .crystal.destroy_asymmetric_unit
      .crystal.make_fragment_data(.atom,warnings=FALSE) 
      DIE_IF(.crystal.asymmetric_unit_atom.destroyed,"atom list does not span asymmetric unit")

      ! Make the cluster
      .cluster.destroy
      .cluster.create(.crystal)
      .cluster.make_info ! leaky here

      stdout.flush
      stdout.text("Unit cell susceptibilities and Refractive Indices")
      stdout.text("-------------------------------------------------")

      stdout.flush
      stdout.text("=== Naive method (no local field effects) ===")
      .cluster.make_chi1_naive(chi1,.dipole_polarisability)
      .MAIN:put_refractive_indices(chi1)

      stdout.flush
      stdout.text("=== ALFFA method (single site per molecule, at COM) ===")
      .cluster.make_chi1_ALFFA(chi1,.dipole_polarisability)
      .MAIN:put_refractive_indices(chi1)

      stdout.flush
      stdout.text("=== RLFTn method (multiple sites per molecule) ===")
      .cluster.make_chi1_RLFTn(chi1,.dipole_polarisability)
      .MAIN:put_refractive_indices(chi1)

      stdout.flush
      stdout.text("=== Spackman's RLFTn method (L tensor averaged over sites) ===")
      .cluster.make_chi1_RLFTn_av_L(chi1,.dipole_polarisability)
      .MAIN:put_refractive_indices(chi1)

   end 

   put_refractive_indices(chi1) ::: private
   ! Put out the permittivity and unit cell refractive index
      chi1 :: MAT{REAL}(3,3)

      eps,eigenvectors :: MAT{REAL}(3,3)
      eigenvalues :: VEC{REAL}(3)

      ! Print out the susceptibility
      stdout.flush
      stdout.text("chi1 :")
      stdout.flush
      stdout.put(chi1) 
      stdout.flush

      ! Work out the permittivity
      eps.to_unit_matrix
      eps = eps + chi1

    ! ! Print it out
    ! stdout.flush
    ! stdout.text("Unit cell permittivity tensor, epsilon :")
    ! stdout.flush
    ! stdout.put(eps) 
    ! stdout.flush

      ! Get the optic axes
      eps.solve_eigenproblem(eigenvalues,eigenvectors)

      ! Print out the refractive indices
      stdout.flush
      stdout.text("Refractive indices :")
      stdout.flush
      stdout.put(sqrt(eigenvalues),"column")

      ! Optic axes ...
      stdout.flush
      stdout.text("Principal directions (columns):")
      stdout.flush
      stdout.put(eigenvectors)

      stdout.flush
      stdout.text("Principal directions (rows):")
      stdout.flush
      stdout.put(transpose(eigenvectors))

      if (.crystal.created) then
      stdout.flush
      stdout.text("Principal directions in crystal axis system :")
      stdout.flush
      eigenvectors.change_basis_using(.crystal.unit_cell.inverse_matrix,.crystal.unit_cell.direct_matrix) 
      stdout.put(eigenvectors)
      end
   end 

   put_refractive_indices(chi2,chi1) ::: private
   ! Put out the chi2
      chi2 :: MAT3{REAL}(3,3,3)
      chi1 :: MAT{REAL}(3,3)

      eps,eigenvectors :: MAT{REAL}(3,3)
      eigenvalues :: VEC{REAL}(3)
      beta :: MAT3{REAL}(3,3,3)

      ! Print out the 2nd susceptibility
      stdout.flush
      stdout.put(chi2) 
      stdout.flush

      ! Work out the permittivity
      eps.to_unit_matrix
      eps = eps + chi1

      ! Get the optic axes
      eps.solve_eigenproblem(eigenvalues,eigenvectors)

      ! Beta in the optic axis frame
      beta = chi2
      beta.change_basis_using(eigenvectors)

      ! chi2 in the optic axis frame
      stdout.flush
      stdout.text("chi2 in the optic axis frame :")
      stdout.flush
      stdout.put(chi2) 

   end 


   make_scf_dipole_polarisability ::: leaky
   ! Make the SCF electric dipole polarisability
      U,D_mo :: MAT3{REAL}*
      alpha :: MAT{REAL}*
      n_vir,n_occ,l,m,a,i :: INT
      val :: REAL

      ! <<<< Create dipole polarisability >>>>>
      .dipole_polarisability.destroy
      .dipole_polarisability.create(3,3) ! leaky here
      alpha => .dipole_polarisability

      ! Make the U matrices if needed
      if (.U_electric_dipole.destroyed) .MAIN:make_U_electric_dipole
      U => .U_electric_dipole
   
      ! Get the dipole moment matrices in the AO basis.
      n_occ = .n_a 
      n_vir = .n_bf - .n_a
      D_mo.create(n_vir,n_occ,3)
      .MAIN:get_VO_MO_dipole_matrices(D_mo)
      D_mo = -D_mo
      
      ! Calculate polarisability using U and D ...
      alpha = 0
      do l = 1,3
      do m = 1,l
         val = ZERO
         do a = 1,n_vir
         do i = 1,n_occ
            val = val + D_mo(a,i,l)*U(a,i,m)
         end
         end
         alpha(l,m) = val
      end
      end
      alpha = FOUR*alpha
      alpha.symmetric_reflect

      D_mo.destroy

   end

   put_scf_dipole_polarisability ::: leaky
   ! Put the SCF polarisability
   
      ! Make the polarisability .....
      .MAIN:make_scf_dipole_polarisability
   
      ! Print out the answer
      .MAIN:put_dipole_polarisability(.dipole_polarisability) 

      ! Biggest contributions
      .MAIN:put_big_dipole_pol_contr

   end

   put_dipole_polarisability(alpha) ::: leaky
   ! Put the dipole polarisability 
      alpha :: MAT{REAL}(3,3), IN

      eigenvectors :: MAT{REAL}(3,3)
      eigenvalues,reorder :: VEC{REAL}(3)
      mean,fac :: REAL

      ! Conversion factor
      fac = ELECTRIC_POLARISABILITY_SI_PER_AU * TEN**40

      ! Print out the answer
      stdout.flush
      stdout.text("Dipole polarisability (au):")
      stdout.flush
      stdout.put(alpha) 
      stdout.flush
      mean = THIRD*(alpha(1,1)+alpha(2,2)+alpha(3,3))
      stdout.show("Mean polarisability (au) = ",mean)

      stdout.flush
      stdout.text("Dipole polarisability (SI) x 10^40:")
      stdout.flush
      stdout.put(alpha*fac)
      stdout.flush
      stdout.show("Mean polarisability (SI) x 10^40 = ",mean*fac)

      ! Get principal axes
      alpha.solve_eigenproblem(eigenvalues,eigenvectors)

      ! Put in descending order
      eigenvalues.reverse_order
      eigenvectors.reverse_column_order

      ! Put eigenvalues
      stdout.flush
      stdout.text("Principal values (au) :")
      stdout.flush
      stdout.put(eigenvalues,"column")

      stdout.flush
      stdout.text("Principal values (SI) x 10^40 :")
      stdout.flush
      stdout.put(eigenvalues*fac,"column")

      ! Optic axes ...
      stdout.flush
      stdout.text("Principal directions (columns):")
      stdout.flush
      stdout.put(eigenvectors)

      stdout.flush
      stdout.text("Principal directions (rows):")
      stdout.flush
      stdout.put(transpose(eigenvectors))

      if (.crystal.created) then
      stdout.flush
      stdout.text("Principal directions in crystal axis system :")
      stdout.flush
      eigenvectors.change_basis_using(.crystal.unit_cell.inverse_matrix,.crystal.unit_cell.direct_matrix) 
      stdout.put(eigenvectors)
      end

   end

   put_big_dipole_pol_contr ::: leaky
   ! Put the main contributions to the SCF polarisability
   ! Tidied from mjt --- dylan
      U,D_mo :: MAT3{REAL}* 
      alpha_bar,alpha_abs :: VEC{REAL}*
      indices :: VEC{INT}*
      a,i,ai,l,n_vir,n_occ :: INT 
      val :: REAL

      ! Make the U matrices/dipole integrals if needed
      if (.U_electric_dipole.destroyed) .MAIN:make_U_electric_dipole
      U => .U_electric_dipole
   
      ! Get the virtual-occupied MO dipole moment matrices
      n_occ = .n_a 
      n_vir = .n_bf - .n_a
      D_mo.create(n_vir,n_occ,3)
      .MAIN:get_VO_MO_dipole_matrices(D_mo)
      D_mo = -D_mo
      
      ! Get the individual orbital contributions to the
      ! mean polarisabilitity
      alpha_bar.create(n_vir*n_occ)
      ai = 0
      do i = 1,n_occ
      do a = 1,n_vir
         val = ZERO
         do l = 1,3
            val = val + D_mo(a,i,l)*U(a,i,l)
         end
         ai = ai + 1
         alpha_bar(ai) = val
      end
      end
      alpha_bar = THIRD * FOUR * alpha_bar
      D_mo.destroy

      ! Get largest contributions in "indices"
      indices.create(n_vir*n_occ)
      alpha_abs.create(n_vir*n_occ)
      alpha_abs = abs(alpha_bar)
      alpha_abs.quick_sort(indices,decreasing_order=TRUE)

      ! Print out the largest contributions
      stdout.flush
      stdout.text("Mean dipole polarisability, top orbital-pair contributions:")
      stdout.flush
      stdout.show("Check: mean polarisability =",sum(alpha_bar))
      stdout.flush
      stdout.dash(int_fields=3,real_fields=1)
      stdout.put("Rank",int_width=TRUE)
      stdout.put("a",int_width=TRUE)
      stdout.put("i",int_width=TRUE)
      stdout.put("alpha_ai")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=1)
      do l = 1,5 ! take the top 5 results
         ai = indices(l) ! get the index
         a  = mod(ai,n_vir)
         i  = (ai-1)/n_vir + 1
         stdout.put(l)
         stdout.put(a)
         stdout.put(i)
         stdout.put(alpha_bar(ai))
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=1)
    
      alpha_abs.destroy
      indices.destroy
      alpha_bar.destroy
      
   end


   make_scf_dipole_hyperpolarisa ::: leaky
   ! Calculate scf dipole hyperpolarisability
   ! Taken from Colwell et al, CPL 210, p. 261 (1993)
      beta,U,F :: MAT3{REAL}*
      xi_vv,xi_oo :: MAT{REAL}* 
      n_occ,n_vir,l,m,n :: INT 
      val,val1,val2 :: REAL

      ! <<<< Create dipole hyperpolarisability >>>>>
      .dipole_hyperpolarisability.destroy
      .dipole_hyperpolarisability.create(3,3,3) ! leaky here
      beta => .dipole_hyperpolarisability

      ! Make the U matrices/dipole integrals if needed
      if (.U_electric_dipole.destroyed) .MAIN:make_U_electric_dipole
      U => .U_electric_dipole
   
      ! Make F(k). We don't need the U term in eqn (29)
      ! See Colwell et al, CPL 210, p. 261 (1993)
      F.create(.n_bf,.n_bf,3)
      .MAIN:get_MO_dipole_matrices(F)
      .MAIN:add_A_times_U(F,U)

      ! Make beta
      beta = ZERO
      n_occ = .n_a 
      n_vir = .n_bf - n_occ
      xi_oo.create(n_occ,n_occ)
      xi_vv.create(n_vir,n_vir)
      do m = 1,3
      do n = 1,3
         xi_vv = matmul(U(:,:,m),transpose(U(:,:,n))) &
               + matmul(U(:,:,n),transpose(U(:,:,m))) 
         xi_oo = matmul(transpose(U(:,:,m)),U(:,:,n)) &
               + matmul(transpose(U(:,:,n)),U(:,:,m)) 
         do l = 1,3
            val1 =  TWO*F(1 :n_occ,1 :n_occ,l).trace_product_with(xi_oo)
            val2 = -TWO*F(n_occ+1:,n_occ+1:,l).trace_product_with(xi_vv)
            val  = val1 + val2
            beta(l,m,n) = beta(l,m,n) + val
            beta(m,n,l) = beta(m,n,l) + val
            beta(n,l,m) = beta(n,l,m) + val
         end
      end
      end
      xi_vv.destroy; xi_oo.destroy; F.destroy
   
   end

   put_scf_dipole_hyperpolarisa ::: leaky
   ! Calculate the polarisability using Coupled Perturbed Hartree-Fock theory.
      beta :: MAT3{REAL}*
      bvec :: VEC{REAL}(3)
   
      ! Do it .....
      .MAIN:make_scf_dipole_hyperpolarisa
      beta => .dipole_hyperpolarisability
      beta.set_vector_hyperpolarisability(bvec)

      ! Print the results

      stdout.flush
      stdout.text("Dipole hyperpolarisability (au):")
      stdout.flush
      stdout.put(beta) 

!     stdout.flush
!     stdout.text("Dipole hyperpolarisability (SI):")
!     stdout.flush
!     stdout.put(beta*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU) 

      stdout.flush
      stdout.text("Vector dipole hyperpolarisability (au):")
      stdout.flush
      stdout.put(bvec)

!     stdout.flush
!     stdout.text("Vector dipole hyperpolarisability (SI):")
!     stdout.flush
!     stdout.put(bvec*ELECTRIC_POLARISABILITY_SI_PER_AU/ELECTRIC_FIELD_SI_PER_AU)

   end


   make_scf_atomic_polarisability 
   ! Calculate the polarisability using Coupled Perturbed Hartree-Fock theory.
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
      U,D :: MAT3{REAL}*
      MO,pt,NO :: MAT{REAL}*
      wt,Wai,rhoi,occ :: VEC{REAL}*
      n_pt,i,a :: INT

      ! Make the U matrices/dipole integrals if needed
      if (.U_electric_dipole.destroyed) .MAIN:make_U_electric_dipole
      U => .U_electric_dipole

      ! Make the AO perturbed density matrices
      MO => .molecular_orbitals.restricted
      D.create(.n_bf,.n_bf,3)
      .MAIN:make_perturbed_densities(D,U,MO,.n_a)

      .set_up_Hirshfeld_info

      ! Make the becke grid integration grid
      .becke_grid.make_grid(pt,wt) ! <<<<<<<<<<< leaky

      ! Integrate the polarisabilities
      n_pt = pt.dim1
      NO.create(.n_bf,.n_bf)
      occ.create(n_pt)
      Wai.create(n_pt)
      rhoi.create(n_pt)

      do i = 1,3
         .make_r_NOs(NO,occ,D(:,:,i))
         .make_density_grid_r(rhoi,pt,NO,occ)
         rhoi = rhoi*wt
         do a = 1,.n_atom
            .make_stockholder_atom_grid(Wai,a,pt)
            Wai = -rhoi*Wai
            .atom(a).charge_polarisability(i)   = sum(Wai)
            .atom(a).dipole_polarisability(1,i) = sum(Wai*(pt(:,1)-.atom(a).pos(1)))
            .atom(a).dipole_polarisability(2,i) = sum(Wai*(pt(:,2)-.atom(a).pos(2)))
            .atom(a).dipole_polarisability(3,i) = sum(Wai*(pt(:,3)-.atom(a).pos(3)))
         end
      end
      rhoi.destroy; Wai.destroy
      occ.destroy; NO.destroy
      wt.destroy; pt.destroy
      D.destroy

      .atomic_polarisabilities_made = TRUE

   end

   put_scf_atomic_polarisability 
   ! Calculate the polarisability using Coupled Perturbed Hartree-Fock theory.
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
      dpol,alpha,alpha_q,alpha_m  :: MAT{REAL}(3,3)
      qpol :: VEC{REAL}(3)
      a :: INT
      asym :: REAL

      ! Make it
      if (NOT .atomic_polarisabilities_made) .MAIN:make_scf_atomic_polarisability 

      ! Write results in au
      alpha_q = ZERO
      stdout.flush
      stdout.text("Hirshfeld atomic charge polarisabilities (au):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("q_x")
      stdout.put("q_y")
      stdout.put("q_z")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         qpol = .atom(a).charge_polarisability 
         stdout.put(qpol(1))
         stdout.put(qpol(2))
         stdout.put(qpol(3))
         stdout.flush
         alpha_q(:,1) = alpha_q(:,1) + .atom(a).pos*qpol(1)
         alpha_q(:,2) = alpha_q(:,2) + .atom(a).pos*qpol(2)
         alpha_q(:,3) = alpha_q(:,3) + .atom(a).pos*qpol(3)
      end
      stdout.dash(int_fields=1,real_fields=3)
      stdout.flush

      ! Write results in au
      alpha_m = ZERO
      asym = ZERO
      stdout.flush
      stdout.text("Hirshfeld atomic dipole polarisabilities (au):")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("a_:x")
      stdout.put("a_:y")
      stdout.put("a_:z")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      do a = 1,.n_atom
         stdout.put(.atom(a).label,int_width=TRUE)
         dpol = .atom(a).dipole_polarisability
         stdout.put(dpol(1,1))
         stdout.put(dpol(1,2))
         stdout.put(dpol(1,3))
         stdout.flush
         stdout.tab(int_fields=1)
         stdout.put(dpol(2,1))
         stdout.put(dpol(2,2))
         stdout.put(dpol(2,3))
         stdout.flush
         stdout.tab(int_fields=1)
         stdout.put(dpol(3,1))
         stdout.put(dpol(3,2))
         stdout.put(dpol(3,3))
         asym = max(asym,abs(dpol(1,2)-dpol(2,1)))
         asym = max(asym,abs(dpol(1,3)-dpol(3,1)))
         asym = max(asym,abs(dpol(2,3)-dpol(3,2)))
         stdout.flush
         alpha_m = alpha_m + dpol
      end
      stdout.dash(int_fields=1,real_fields=3)
      stdout.flush
      stdout.show("Maximum asymmetry in polarisabilities = ",asym)
      stdout.flush
      stdout.text("Contribution to molecular polarisability from atomic charges (au):")
      stdout.put(alpha_q)
      stdout.flush
      stdout.text("Contribution to molecular polarisability from atomic dipoles (au):")
      stdout.put(alpha_m)
      stdout.flush
      stdout.text("Molecular polarisability (au):")
      alpha = alpha_q + alpha_m
      stdout.put(alpha)

   end



   make_U_electric_dipole ::: leaky
   ! Calculate U matrices for electric dipole perturbations using
   ! Coupled Perturbed Hartree-Fock theory. NOTE: restricted case only
   ! so far.
      U,D_mo :: MAT3{REAL}*
      n_occ,n_vir :: INT 
   
      ! Dimensions
      n_occ = .n_a 
      n_vir = .n_bf - n_occ

      ! Get the virtual-occupied dipole moment matrices in the MO basis
      D_mo.create(n_vir,n_occ,3)
      .MAIN:get_VO_MO_dipole_matrices(D_mo)
      D_mo = -D_mo
   
      ! <<<<< U matrices. Leaky. >>>>>
      .U_electric_dipole.destroy
      U.create(n_vir,n_occ,3)

      ! Solve the CPHF equations
      .get_overlap_matrix
      .MAIN:set_CPHF_DIIS
      .MAIN:solve_CPHF_equations(U,D_mo) 
      D_mo.destroy

      ! Assign U matrices
      .U_electric_dipole => U

   end

   make_perturbed_densities(D,U,MO,n_occ) ::: leaky
   ! Make the perturbed densities "D" from the "U" matrices by back
   ! transforming with the "MO" from orbital "n_occ".
      D :: MAT3{REAL}, OUT
      U :: MAT3{REAL}, IN
      MO :: MAT{REAL}, IN
      n_occ :: INT, optional, IN
   ENSURE(D.dim1==.n_bf AND D.dim2==.n_bf,"wrong size, D")
   ENSURE(D.dim3==U.dim3,"incompatible D and U")
   ENSURE(MO.is_square AND MO.dim1==.n_bf,"wrong size, MO")
      i :: INT
      if (present(n_occ)) then
         ENSURE(n_occ>0,"n_occ must be positive")
         ENSURE(n_occ<=.n_bf,"n_occ must not exceed n_bf")
         do i = 1,U.dim3
            U(:,:,i).back_transform_to(D(:,:,i),MO(:,n_occ+1:),MO(:,:n_occ))
            D(:,:,i).symmetrize              
         end
      else
         do i = 1,U.dim3
            U(:,:,i).back_transform_to(D(:,:,i),MO)
            D(:,:,i).symmetrize              
         end
      end
      D = FOUR*D
   end

   get_MO_dipole_matrices(D_mo)
   ! Get the MO dipole matrices
      D_mo :: MAT3{REAL}
   ENSURE(D_mo.dim1==.n_bf AND D_mo.dim2==.n_bf AND D_mo.dim3==3,"wrong shape, D_mo")
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
      MO   :: MAT{REAL}*

      ! Get the dipole moment matrices in the AO basis.
      .get_dipole_matrices(D_mo(:,:,1),D_mo(:,:,2),D_mo(:,:,3))
      
      ! Change dipole matrices from AO -> MO basis
      MO => .molecular_orbitals.restricted
      D_mo(:,:,1).change_basis_using(MO)
      D_mo(:,:,2).change_basis_using(MO)
      D_mo(:,:,3).change_basis_using(MO)
      
   end

   get_VO_MO_dipole_matrices(D_mo)
   ! Get the virtual-occupied MO dipole matrices
      D_mo :: MAT3{REAL}
   ENSURE(D_mo.dim1==(.n_bf-.n_a) AND D_mo.dim2==.n_a AND D_mo.dim3==3,"wrong shape, D_mo")
   ENSURE(.molecular_orbitals.created,"no MO's")
   ENSURE(.molecular_orbitals.restricted.created,"no restricted MO's")
      D_ao :: MAT3{REAL}*
      MO   :: MAT{REAL}*
      n_occ :: INT
   
      ! Get the dipole moment matrices in the AO basis.
      D_ao.create(.n_bf,.n_bf,3)
      .get_dipole_matrices(D_ao(:,:,1),D_ao(:,:,2),D_ao(:,:,3))
      
      ! Change dipole matrices from AO -> MO basis
      MO => .molecular_orbitals.restricted
      n_occ = .n_a 
      D_ao(:,:,1).change_basis_to(D_mo(:,:,1),MO(:,n_occ+1:),MO(:,:n_occ))
      D_ao(:,:,2).change_basis_to(D_mo(:,:,2),MO(:,n_occ+1:),MO(:,:n_occ))
      D_ao(:,:,3).change_basis_to(D_mo(:,:,3),MO(:,n_occ+1:),MO(:,:n_occ))
      D_ao.destroy
      
   end

   set_CPHF_DIIS ::: leaky 
   ! Set up the DIIS archives for a CPHF calculations.
   ENSURE(.scfdata.created,"no scf data")

      test :: REAL

      ! Set up DIIS
      test = .scfdata.diis.convergence_tolerance
      .scfdata.diis.cleanup
    ! .scfdata.diis.nullify_ptr_part
      .scfdata.diis.set_defaults
      .scfdata.diis.set_archive_root_name(.name)
      .scfdata.diis.set_archive_name("CPHF")
      .scfdata.diis.set_save_iteration(0)
      .scfdata.diis.set_start_iteration(2)
      .scfdata.diis.convergence_tolerance = test

   end

   solve_CPHF_equations(U,rhs) 
   ! Solve the coupled-perturbed Hartree-Fock (CPHF) equations. The result is
   ! the derivative MO coefficients "U" (virtual-occupied block) and "rhs" is the
   ! right hand side of the CPHF equations (virtual-occupied block). The
   ! convergence tolerance and the number of iterations are controlled via the
   ! scfdata block, since this is a self consistent procedure.
   ! WARNING: this asumed the DIIS archives have been set up already.
      U,rhs :: MAT3{REAL}*
   ENSURE(.scfdata.created,"no scf data")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(U.created,"No U")
   ENSURE(rhs.created,"No rhs")
   ENSURE(U.dim1==(.n_bf-.n_a),"wrong size, U, dimension 1")
   ENSURE(U.dim2==.n_a,"wrong size, U, dimension 2")
   ENSURE(rhs.dim1==(.n_bf-.n_a),"wrong size, rhs, dimension 1")
   ENSURE(rhs.dim2==.n_a,"wrong size, rhs dimension 2")
   ENSURE(U.dim3==rhs.dim3,"incompatible sizes, U and rhs")
      e :: VEC{REAL}*
      U_old :: MAT3{REAL}*
      MO,U_ao,AU,J,K,W :: MAT{REAL}*
      n_occ,n_vir,n_pert,n,a,i,iteration :: INT
      n_str :: STR
      test :: REAL
      use_diis,converged :: BIN
      arch :: ARCHIVE

      ! Use DIIS?
      use_diis = .scfdata.using_CPHF_diis

      ! Assign MO's, orbital ranges
      MO => .molecular_orbitals.restricted
      e  => .orbital_energies.restricted
      n_occ = .n_a 
      n_vir = .n_bf - .n_a
      n_pert = U.dim3
   
      ! Read or calculate initial approximation for U
      if (.scfdata.initial_Us=="restricted") then
         stdout.flush
         stdout.text("As requested from scfdata, reading U's from disk ...")
         arch.set(.name,"U_electric_dipole",genre="restricted")
         arch.read(U)
      else ! Set SOS initial guess
         do n = 1,n_pert
            do a = 1,n_vir
            do i = 1,n_occ
               U(a,i,n) =  rhs(a,i,n)/(e(n_occ+a) - e(i))
            end
            end
         end
      end

      ! Allocate space for temporaries
      U_old.create(n_vir,n_occ,n_pert)
      U_ao.create(.n_bf,.n_bf)
      AU => U_ao
      W.create(n_vir,n_occ)        
      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)

      ! Begin iterative procedure

      stdout.flush
      stdout.text("Solve CPHF equations")
      iteration = 0

      do
         iteration = iteration + 1
         DIE_IF(iteration>.scfdata.max_iterations,"too many iterations") 

         U_old = U
         test = ZERO

         ! For each perturbation, Update U
         do n = 1,n_pert

            ! U -> AO basis
            U(:,:,n).back_transform_to(U_ao,MO(:,n_occ+1:),MO(:,:n_occ))
            U_ao.symmetrize              

            ! A times U -> AO basis -> MO basis -> W
            .make_r_JK_direct2(J,K,U_ao)  
            AU = FOUR*J - TWO*K
            .shift_linear_dependence_from(AU)
            AU.change_basis_to(W,MO(:,n_occ+1:),MO(:,:n_occ))

            ! Update U
            do a = 1,n_vir               
            do i = 1,n_occ
               U(a,i,n) = (ONE/(e(n_occ+a) - e(i))) * (rhs(a,i,n) - W(a,i))
            end
            end

            ! DIIS extrapolation
            if (use_diis) then
               n_str = n.to_str
               .scfdata.diis.par_tag = "U"//trim(n_str)
               .scfdata.diis.err_tag = "delta_U"//trim(n_str)
               .scfdata.diis.lhs_tag = "lhs,diis,U"//trim(n_str)
               W = U(:,:,n) - U_old(:,:,n)
               .scfdata.diis.extrapolate(U(:,:,n),W)
               test = max(test,.scfdata.diis.error_length)

               ! Manually reset the DIIS object
               if (n<n_pert) then
                  .scfdata.diis.iteration = .scfdata.diis.iteration - 1
                  .scfdata.diis.kept = .scfdata.diis.kept - 1
               end

            else
               W = U(:,:,n) - U_old(:,:,n)
               test = max(test,sqrt(W.dot(W)))
            end

         end

         ! Write archive for restart
         arch.set(.name,"U_electric_dipole",genre="restricted")
         arch.write(U)

         ! Converged ?
         stdout.show("Iteration "//iteration.to_str.trim//", convergence = ",test)
         converged = test<.scfdata.diis.convergence_tolerance
         if (converged) exit

      end

      ! Clean-up
      K.destroy; J.destroy; W.destroy
      U_ao.destroy; U_old.destroy
      .scfdata.diis.delete_CPHF_archives(n_pert)
   end

! This version uses MAT3 DIIS

!   solve_CPHF_equations(U,rhs) 
!   ! Solve the coupled-perturbed Hartree-Fock (CPHF) equations. The result is
!   ! the derivative MO coefficients "U" (virtual-occupied block) and "rhs" is the
!   ! right hand side of the CPHF equations (virtual-occupied block). The
!   ! convergence tolerance and the number of iterations are controlled via the
!   ! scfdata block, since this is a self consistent procedure.
!      U,rhs :: MAT3{REAL}*
!   ENSURE(.scfdata.created,"no scf data")
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom info")
!   ENSURE(U.dim1==(.n_bf-.n_a),"wrong size, U, dimension 1")
!   ENSURE(U.dim2==.n_a,"wrong size, rhs, dimension 2")
!   ENSURE(rhs.dim1==(.n_bf-.n_a),"wrong size, rhs, dimension 1")
!   ENSURE(rhs.dim2==.n_a,"wrong size, rhs dimension 2")
!   ENSURE(U.dim3==rhs.dim3,"incompatible sizes, U and rhs")
!      e,UU,DU :: VEC{REAL}*
!      U_old,Delta :: MAT3{REAL}*
!      MO,U_ao,AU,J,K,W :: MAT{REAL}*
!      alpha :: MAT{REAL}(3,3)
!      n_occ,n_vir,n_pert,n,a,i,iteration :: INT
!      n_str :: STR
!      test :: REAL
!      use_diis,converged :: BIN
!
!      ! Set up DIIS
!      use_diis = .scfdata.using_CPHF_diis
!      test = .scfdata.diis.convergence_tolerance
!      .scfdata.diis.cleanup
!      .scfdata.diis.set_defaults
!      .scfdata.diis.set_archive_root_name(.name)
!      .scfdata.diis.set_archive_name("CPHF")
!      .scfdata.diis.set_save_iteration(0)
!      .scfdata.diis.set_start_iteration(1)
!      .scfdata.diis.convergence_tolerance = test
!      .scfdata.diis.par_tag = "U"
!      .scfdata.diis.err_tag = "delta_U"
!      .scfdata.diis.lhs_tag = "lhs,diis,U"
!
!      ! Assign MO's, orbital ranges
!      MO => .molecular_orbitals.restricted
!      e  => .orbital_energies.restricted
!      n_occ = .n_a 
!      n_vir = .n_bf - n_occ
!   
!      ! Calculate initial approximation for U
!      n_pert = U.dim3
!      do n = 1,n_pert
!         do a = 1,n_vir
!         do i = 1,n_occ
!            U(a,i,n) =  rhs(a,i,n)/(e(n_occ+a) - e(i))
!         end
!         end
!      end
!
!      ! Allocate space for temporaries
!      U_old.create(n_vir,n_occ,n_pert)
!      U_ao.create(.n_bf,.n_bf)
!      AU => U_ao
!      Delta.create(n_vir,n_occ,n_pert)        
!      W.create(n_vir,n_occ)        
!      J.create(.n_bf,.n_bf)
!      K.create(.n_bf,.n_bf)
!
!      ! Begin iterative procedure
!
!      stdout.flush
!      stdout.text("Solve CPHF equations")
!      iteration = 0
!
!      do
!         iteration = iteration + 1
!         DIE_IF(iteration>.scfdata.max_iterations,"too many iterations") 
!
!         U_old = U
!         test = ZERO
!
!         ! For each perturbation, Update U
!         do n = 1,n_pert
!
!            ! U -> AO basis
!            U(:,:,n).back_transform_to(U_ao,MO(:,n_occ+1:),MO(:,:n_occ))
!            U_ao.symmetrize              
!
!            ! A times U -> AO basis -> MO basis -> W
!            .make_r_JK_direct(J,K,U_ao)  
!            AU = FOUR*J - TWO*K
!            AU.change_basis_to(W,MO(:,n_occ+1:),MO(:,:n_occ))
!
!            ! Update U
!            do a = 1,n_vir               
!            do i = 1,n_occ
!               U(a,i,n) = (ONE/(e(n_occ+a) - e(i))) * (rhs(a,i,n) - W(a,i))
!            end
!            end
!
!         end
!
!         ! DIIS, if requested
!         Delta = U - U_old
!         if (use_diis) then
!            .scfdata.diis.extrapolate(U,Delta)
!            test = .scfdata.diis.error_length
!         else
!             test = sqrt(Delta.dot(Delta))
!         end
!
!         ! Converged ?
!         stdout.show("Iteration "//iteration.to_str.trim//", convergence = ",test)
!         converged = test<.scfdata.diis.convergence_tolerance
!         if (converged) exit
!
!      end
!
!      ! Clean-up
!      K.destroy
!      J.destroy
!      W.destroy
!      Delta.destroy
!      U_ao.destroy
!      U_old.destroy
!      .scfdata.diis.delete_CPHF_archives(n_pert)
!   end

   make_A_times_U(AU,U) 
   ! Make the full A times U matrix in the MO basis
      AU,U :: MAT3{REAL}*
   ENSURE(.scfdata.created,"no scf data")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(U.dim1==(.n_bf-.n_a),"wrong size, U, dimension 1")
   ENSURE(U.dim2==.n_a,"wrong size, rhs, dimension 2")
   ENSURE(AU.dim1==.n_bf,"wrong size, AU")
   ENSURE(AU.dim2==.n_bf,"wrong size, AU")
   ENSURE(U.dim3==AU.dim3,"incompatible sizes, U and AU")
      MO,U_ao,J,K :: MAT{REAL}*
      n :: INT
      MO => .molecular_orbitals.restricted
      U_ao.create(.n_bf,.n_bf)
      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      do n = 1,U.dim3
         U(:,:,n).back_transform_to(U_ao,MO(:,.n_a+1:),MO(:,:.n_a))
         U_ao.symmetrize              ! U -> AO basis
         .make_r_JK_direct(J,K,U_ao)  ! A times U
         AU(:,:,n) = FOUR*J - TWO*K
         AU(:,:,n).change_basis_using(MO)
      end
      K.destroy
      J.destroy
      U_ao.destroy
   end

   add_A_times_U(AU,U) ::: private
   ! Add the full A matrix times the full U matrix to "AU". "U" is the
   ! virtual-occupied block of the full U matrix.
      AU,U :: MAT3{REAL}*
   ENSURE(.scfdata.created,"no scf data")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")
   ENSURE(U.dim1==(.n_bf-.n_a),"wrong size, U, dimension 1")
   ENSURE(U.dim2==.n_a,"wrong size, rhs, dimension 2")
   ENSURE(AU.dim1==.n_bf,"wrong size, AU")
   ENSURE(AU.dim2==.n_bf,"wrong size, AU")
   ENSURE(U.dim3==AU.dim3,"incompatible sizes, U and AU")
      MO,J,K,W :: MAT{REAL}*
      n :: INT
      MO => .molecular_orbitals.restricted
      J.create(.n_bf,.n_bf)
      K.create(.n_bf,.n_bf)
      W.create(.n_bf,.n_bf)
      do n = 1,U.dim3
         U(:,:,n).back_transform_to(W,MO(:,.n_a+1:),MO(:,:.n_a))
         W.symmetrize              ! U -> AO basis
         .make_r_JK_direct(J,K,W)  
         W = FOUR*J - TWO*K        ! W = A times U
         W.change_basis_using(MO)
         AU(:,:,n) = AU(:,:,n) + W
      end
      W.destroy
      K.destroy
      J.destroy
   end

   put_mikes_polarisability 
   ! Calculate the polarisability using Dylans "complicated" method

   ENSURE(.molecular_orbitals.restricted.created,"no MO's")
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom info")

   D :: MAT3{REAL}*
   e :: VEC{REAL}*
   alpha :: MAT{REAL}(3,3)
   U_old :: MAT3{REAL}*
   U_new,J,K :: MAT3{REAL}*
   AU :: MAT3{REAL}*
   Ubar :: MAT3{REAL}*
   MO :: MAT{REAL}*
   X,Y,Z,p,q,l,m,n_occ,i,cyc :: INT
   tol,test :: REAL

   MO => .molecular_orbitals.restricted
   X = 1; Y = 2; Z = 3 ! Used to index into the U array
   tol = 1.0e-5 ! The convergence tolerance for the iterative procedure

   alpha = 0

   n_occ = .n_e/2      ! Determine the number of occupied orbitals

   stdout.flush
   stdout.text("Mike's More Complicated Polarisability:")
   stdout.flush
stdout.text(".n_bf is : ")
stdout.put(.n_bf)
stdout.flush
   D.create(.n_bf,.n_bf,3) ! 3=x,y,z
   .get_dipole_matrices(D(:,:,1),D(:,:,2),D(:,:,3))
   D(:,:,X).change_basis_using(.molecular_orbitals.restricted)
   D(:,:,Y).change_basis_using(.molecular_orbitals.restricted)
   D(:,:,Z).change_basis_using(.molecular_orbitals.restricted)

   e => .orbital_energies.restricted

   U_old.create(.n_bf,.n_bf,3) ! 3=x,y,z
   U_new.create(.n_bf,.n_bf,3) ! 3=x,y,z 
   AU.create(.n_bf,.n_bf,3) ! 3=x,y,z
   Ubar.create(.n_bf,.n_bf,3) ! 3=x,y,z
   J.create(.n_bf,.n_bf,3) ! 3=x,y,z
   K.create(.n_bf,.n_bf,3) ! 3=x,y,z

   Ubar = 0 ! Initialise Ubar

   ! Calculate initial approximation for U
   do p=1,.n_bf
      do q=1,.n_bf
         if (p==q) then
         U_old(p,q,X) = ZERO
         U_old(p,q,Y) = ZERO
         U_old(p,q,Z) = ZERO
         else
         U_old(p,q,X) =  - D(p,q,X)/(e(p) - e(q))
         U_old(p,q,Y) =  - D(p,q,Y)/(e(p) - e(q))
         U_old(p,q,Z) =  - D(p,q,Z)/(e(p) - e(q))
         end
      end
    end

   cyc = 0
   ! Use an interative procedure to determine U 
   do
      cyc = cyc + 1
      U_old(n_occ+1:,1:n_occ,1).back_transform_to(Ubar(:,:,1),MO(:,n_occ+1:),MO(:,1:n_occ))
      U_old(n_occ+1:,1:n_occ,2).back_transform_to(Ubar(:,:,2),MO(:,n_occ+1:),MO(:,1:n_occ))
      U_old(n_occ+1:,1:n_occ,3).back_transform_to(Ubar(:,:,3),MO(:,n_occ+1:),MO(:,1:n_occ))
    ! .MAIN:make_mikes_A_times_U(AU,Ubar)
      Ubar(:,:,X).symmetrize
      Ubar(:,:,Y).symmetrize
      Ubar(:,:,Z).symmetrize
      .make_r_JK_direct(J(:,:,1),K(:,:,1),Ubar(:,:,1))
      .make_r_JK_direct(J(:,:,2),K(:,:,2),Ubar(:,:,2))
      .make_r_JK_direct(J(:,:,3),K(:,:,3),Ubar(:,:,3))
      AU = FOUR*J - TWO*K
      AU(:,:,1).change_basis_using(MO)
      AU(:,:,2).change_basis_using(MO)
      AU(:,:,3).change_basis_using(MO)
      do p=1,.n_bf
         do q=1,.n_bf
            if (p==q) then
            U_new(p,q,X) = ZERO
            U_new(p,q,Y) = ZERO
            U_new(p,q,Z) = ZERO
            else
            U_new(p,q,X) = (-1/(e(p) - e(q))) * (D(p,q,X) + AU(p,q,X))
            U_new(p,q,Y) = (-1/(e(p) - e(q))) * (D(p,q,Y) + AU(p,q,Y))
            U_new(p,q,Z) = (-1/(e(p) - e(q))) * (D(p,q,Z) + AU(p,q,Z))
            end
         end
      end
      test = maxval(abs(U_new(n_occ+1:,1:n_occ,:)-U_old(n_occ+1:,1:n_occ,:)))
      stdout.show("cycle "//cyc.to_str.trim//", test = ",test)
      if ( test < tol) exit


      U_old = U_new 
    end

   ! Finally Calculate polarisability using U and D
   do l=1,3
      do m=1,l ! Calculate only the lower triangle
         do p=n_occ+1,.n_bf
            do i=1,n_occ
               alpha(l,m) = alpha(l,m) + D(p,i,l)*U_new(p,i,m)
            end
         end
      end
    end
   alpha = alpha*2 ! Apply factor

   stdout.flush
   stdout.text("First polarisability:")
   stdout.flush
   stdout.put(alpha)

   ! Do some tidying up
   D.destroy
   K.destroy
   J.destroy
   U_old.destroy
   U_new.destroy
   Ubar.destroy
   end

   zero_overlap_density
   ! Calculate the noninteracting group overlap matrix "S"
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.density_matrix.created, "no density matrix")
     q,fa,la,fb,lb, atom_a,atom_b :: INT
     sh :: SHELL2
     do q=1,.n_shell_pairs
       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
       if(atom_a/=atom_b) .density_matrix.restricted(fa:la,fb:lb)=ZERO
       sh.destroy_ptr_part
     end
     .density_matrix.restricted.symmetric_reflect
   end



!   apply_anti_hrr(P,PP) ::: leaky
!   ! Apply the anti-horizontal recursion relation (i.e. the ant-transfer
!   ! relation) to matrix "P" to produce the shell pair vector "PP" which has to
!   ! be multipled by the source integrals to give the contracted term (usually
!   ! the J-matrix)
!      P :: MAT{REAL}
!      PP :: VEC{VEC_{REAL}*
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom info")
!      R :: VEC{REAL}(3)
!      R1,R2,R3,T1,T2,T3,fx,fy,fz :: REAL
!      ax,ay,az,bx,by,bz,Rx,Ry,Rz, ab :: VEC{REAL}*
!      binbx,binby,binbz :: VEC{INT}*
!      q,fa,la,fb,lb,atom_a,atom_b,aa,bb :: INT
!      i,a,b,x,y,z,xa,ya,za,xb,yb,zb,xx,yy,zz :: INT
!      sh :: SHELL2
!      PP.create(.n_shell_pairs)                                     ! leaky
!      Rx.create(.basis_l_max)
!      Ry.create(.basis_l_max)
!      Rz.create(.basis_l_max)
!      aa = 0
!      bb = 0
!      do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!         if (sh.l_sum==0) then
!            PP(q).element.create(1)                                 ! leaky
!            PP(q)[1] = P(fa,fb)
!         else
!            fa = ncomp_up_to(.a.l-1)
!            fb = ncomp_up_to(.b.l-1)
!            la = fa + sh.a.n_comp
!            lb = fb + sh.b.n_comp
!            ax => nx(fa+1:la); ay => ny(fa+1:la); az => nz(fa+1:la)
!            bx => nx(fb+1:lb); by => ny(fb+1:lb); bz => nz(fb+1:lb)
!            PP(q).element.create(sh.n_gaussians)                    ! leaky
!            ab => PP(q).element
!            ab = ZERO
!            if (sh.a.l > sh.b.l) then
!               if (atom_a/=aa OR atom_b/=bb) then
!                  aa = atom_a; bb = atom_b
!                  R = sh.a.pos - sh.b.pos
!                  R1 = R(1);   R2 = R(2);   R3 = R(3)
!                  T1 = R1;     T2 = R2;     T3 = R3
!                  Rx(1) = ONE; Ry(1) = ONE; Rz(1) = ONE
!                  do i = 2,sh.l_max+1
!                     Rx(i) = T1; T1 = R1*T1
!                     Ry(i) = T2; T2 = R2*T2
!                     Rz(i) = T3; T3 = R2*T3
!                  end
!               end
!               do b = 1,sh.b.n_comp
!                  xb = bx(b); yb = by(b); zb = bz(b)
!                  binbx => binomial(bx).element
!                  binby => binomial(by).element
!                  binbz => binomial(bz).element
!                  do a = 1,sh.a.n_comp
!                     xa = ax(a); ya = ay(a); za = az(a)
!                     do x = 1,bx 
!                        xx = xa + x - 1
!                        fx = binbx(x)*Rx(bx-x+1)
!                        do y = 1,by 
!                           yy = ya + y - 1
!                           fy = binby(y)*Ry(by-y+1)
!                           do z = 1,bz 
!                              zz = za + z - 1
!                              fz = binbz(z)*Rz(bz-z+1)
!                              i = index_of(xx,yy,zz) - fa
!                              ab(i) = ab(i) + fx*fy*fz
!                           end
!                        end
!                     end
!                  end
!               end
!            else
!               if (atom_a/=aa OR atom_b/=bb) then
!                  aa = atom_a; bb = atom_b
!                  R = sh.b.pos - sh.a.pos
!                  R1 = R(1);   R2 = R(2);   R3 = R(3)
!                  T1 = R1;     T2 = R2;     T3 = R3
!                  Rx(1) = ONE; Ry(1) = ONE; Rz(1) = ONE
!                  do i = 2,sh.l_max+1
!                     Rx(i) = T1; T1 = R1*T1
!                     Ry(i) = T2; T2 = R2*T2
!                     Rz(i) = T3; T3 = R2*T3
!                  end
!               end
!               do a = 1,sh.a.n_comp
!                  xa = ax(a); ya = ay(a); za = az(a)
!                  binax => binomial(ax).element
!                  binay => binomial(ay).element
!                  binaz => binomial(az).element
!                  do b = 1,sh.b.n_comp
!                     xb = bx(b); yb = by(b); zb = bz(b)
!                     do x = 1,ax 
!                        xx = xb + x - 1
!                        fx = binax(x)*Rx(ax-x+1)
!                        do y = 1,ay 
!                           yy = yb + y - 1
!                           fy = binay(y)*Ry(ay-y+1)
!                           do z = 1,az 
!                              zz = zb + z - 1
!                              fz = binaz(z)*Rz(az-z+1)
!                              i = index_of(xx,yy,zz) - fb
!                              ab(i) = ab(i) + fx*fy*fz
!                           end
!                        end
!                     end
!                  end
!               end
!            end
!         end
!         sh.destroy_ptr_part
!      end
!      Rz.destroy
!      Ry.destroy
!      Rx.destroy
!   end

   make_file_delta_density_grid  
   ! This routine will read in names for two files containing
   ! molecular orbitals, then read in type of molecular orbitals and
   ! will make density difference between first and second one.

   ENSURE(.plot_grid.created, "no grid")
   DIE_IF(stdin.buffer.n_items/=4,"must supply 3 arguments")

      arch :: ARCHIVE
      grid1,grid2 :: VEC{REAL}*
      pt :: MAT{REAL}*
      name_mo_1,name_mo_2,genre :: STR       

      .molecular_orbitals.destroy

      ! Read MO1 & MO2 file names and kind
      stdin.read(name_mo_1)
      stdin.read(name_mo_2)
      stdin.read(genre)
      
      ! Read 1st MO's
      arch.set(.name,name_mo_1,genre)  
      arch.read(.molecular_orbitals)
      .assign_NOs_to_MOs
        
      ! Make density grid for MO1
      grid1.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
      .make_density_grid(grid1,pt)
      pt.destroy

      ! Read 2nd MO's
      arch.set(.name,name_mo_2,genre)  
      arch.read(.molecular_orbitals)
      .assign_NOs_to_MOs

      ! Make density grid for MO2
      grid2.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
      .make_density_grid(grid2,pt)
      pt.destroy

      ! Subtract
      grid1 = grid1 - grid2
      
      ! Print
      .dump_plot_grid(grid1,"file_delta_density_grid")

      ! Clean up
      grid2.destroy
      grid1.destroy
      .molecular_orbitals.destroy

   end

   make_file_delta_spin_grid  
   ! This routine will read in names for two files containing
   ! molecular orbitals, then read in type of molecular orbitals and
   ! will make SPIN denstity difference between first file and the
   ! second one.

   ENSURE(.plot_grid.created, "no grid")
   DIE_IF(stdin.buffer.n_items/=4,"must supply 3 arguments")

      arch :: ARCHIVE
      grid1,grid2 :: VEC{REAL}*
      pt :: MAT{REAL}*
      name_mo_1,name_mo_2,genre :: STR       

      .molecular_orbitals.destroy

      ! Read MO1 & MO2 file names and kind
      stdin.read(name_mo_1)
      stdin.read(name_mo_2)
      stdin.read(genre)
      
      ! Read 1st MO's
      arch.set(.name,name_mo_1,genre)  
      arch.read(.molecular_orbitals)
      .assign_NOs_to_MOs
        
      ! Make density grid for MO1
      grid1.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
      .make_density_grid(grid1,pt,sgn=-1)
      pt.destroy

      ! Read 2nd MO's
      arch.set(.name,name_mo_2,genre)  
      arch.read(.molecular_orbitals)
      .assign_NOs_to_MOs

      ! Make density grid for MO2
      grid2.create(.plot_grid.n_pt)
      pt.create(.plot_grid.n_pt,3); .plot_grid.make_points(pt)
      .make_density_grid(grid2,pt,sgn=-1)
      pt.destroy

      ! Subtract
      grid1 = grid1 - grid2
      
      ! Print
      .dump_plot_grid(grid1,"file_delta_spin_grid")

      ! Clean up
      grid2.destroy
      grid1.destroy
      .molecular_orbitals.destroy

   end


   put_overlap_eigenvalues
   ! Calculate the overlap matrix eigenvalues
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,  "no atom list")
   ENSURE(.atom.bases_are_resolved,  "no atom bases")

     .get_overlap_matrix

     stdout.save
     stdout.set_real_style("e")
     stdout.set_real_width(20)
     stdout.set_real_precision(10)
     stdout.text("Overlap matrix eigenvalues:")
     stdout.put(.overlap_eigenvalues,"column")
     stdout.unsave
   end


!  *****************
!  Put interpolators
!  *****************

   put_slater_interpolators 
   ! Print out the slaterbasis interpolator tables for a certain
   ! "basis_kind" for all interpolators up to "Z_max" and up to a
   ! certain "density_cutoff", all these as read from stdin.

   ENSURE(stdin.buffer.n_items==4,"must be three items after the keyword")
   ENSURE(stdin.buffer.item_index==1,"must be at the second items on the input line")

      interpolator :: INTERPOLATOR*
      slaterbasis  :: VEC{SLATERBASIS}*
      labels :: VEC{STR}*
      basis_kind,plotfile :: STR
      density_cutoff :: REAL
      Z_max,Z :: INT

      ! Read the input
      stdin.read(basis_kind)
      stdin.read(Z_max)
      stdin.read(density_cutoff)

      ! Create a log-linear prototype interpolator
      interpolator.create  
      interpolator.set_table_length(60.0d0)
      interpolator.set_table_eps(density_cutoff)
      interpolator.set_interpolation_method("linear")
      interpolator.set_range_mapping("logarithmic")
      interpolator.set_domain_mapping("none")

      ! Get the library basis set labels up to Z_max
      labels => VEC{ATOM}:library_basis_labels(Z_max,basis_kind)

      ! Read the library bases
      slaterbasis.read_library_data(slaterbasis.library_file(basis_kind),labels)

      ! Make interpolators and put out the gnuplots
      do Z = 1,slaterbasis.dim   

         stdout.show("Z = ",Z)

         slaterbasis(Z).make_interpolator(interpolator)

         plotfile = trim(Z.to_str)//"_"//trim(ATOM:chemical_symbol(Z))
         plotfile = trim(plotfile)//"_"//trim(basis_kind)//".gnuplot"
         stdout.redirect(plotfile)
         slaterbasis(Z).interpolator.put_gnuplot
         stdout.revert

      end                         

      stdout.text("Finished all interpolator plots")

      ! Cleanup
      slaterbasis.destroy
      labels.destroy
      interpolator.destroy

   end

   put_coppens_interpolators ::: get_from(MOLECULE.MAIN:put_slater_interpolators, SLATERBASIS=>COPPENSBASIS)
   ! Print out the slaterbasis interpolator tables for a certain
   ! "basis_kind" for all interpolators up to "Z_max" and up to a
   ! certain "density_cutoff", all these as read from stdin.
   end

   put_diff_slater_interpolators 
   ! Print out the difference between two slaterbasis interpolator tables for 
   ! bases "basis1" and "basis2", for all interpolators up to "Z_max"
   ! and up to a certain "density_cutoff", all these as read from
   ! stdin.

   ENSURE(stdin.buffer.n_items==5,"must be four items fater the keyword")
   ENSURE(stdin.buffer.item_index==1,"must be at the second items on the input line")

      interpolator :: INTERPOLATOR*
      slater1basis,slater2basis :: VEC{SLATERBASIS}*
      labels :: VEC{STR}*
      basis1,basis2,plotfile :: STR
      density_cutoff :: REAL
      Z_max,Z :: INT

      ! Read the input
      stdin.read(basis1)
      stdin.read(basis2)
      stdin.read(Z_max)
      stdin.read(density_cutoff)

      ! Create a log-linear prototype interpolator
      interpolator.create  
      interpolator.set_table_length(60.0d0)
      interpolator.set_table_eps(density_cutoff)
      interpolator.set_interpolation_method("linear")
      interpolator.set_range_mapping("logarithmic")
      interpolator.set_domain_mapping("none")

      ! Get the library basis set labels up to Z_max
      labels => VEC{ATOM}:library_basis_labels(Z_max,basis1)
      slater1basis.read_library_data(slater1basis.library_file(basis1),labels)
      labels.destroy
      labels => VEC{ATOM}:library_basis_labels(Z_max,basis2)
      slater2basis.read_library_data(slater2basis.library_file(basis2),labels)
      labels.destroy

      ! Make interpolators and put out the gnuplots
      do Z = 1,slater1basis.dim   

         stdout.show("Z = ",Z)

         slater1basis(Z).make_interpolator(interpolator)
         slater2basis(Z).make_interpolator(interpolator)

         plotfile = trim(Z.to_str)//"_"//trim(ATOM:chemical_symbol(Z))
         plotfile = trim(plotfile)//"_"//trim(basis1)//"-"//trim(basis2)//".gnuplot"
         stdout.redirect(plotfile)
         slater1basis(Z).interpolator.put_gnuplot(slater2basis(Z).interpolator)
         stdout.revert

      end                         

      stdout.text("Finished all interpolator plots")

      ! Cleanup
      slater2basis.destroy
      slater1basis.destroy
      interpolator.destroy

   end

   put_diff_coppens_slater_ints 
   ! Print out the difference between two slaterbasis interpolator tables for 
   ! bases "basis1" and "basis2", for all interpolators up to "Z_max"
   ! and up to a certain "density_cutoff", all these as read from
   ! stdin.

   ENSURE(stdin.buffer.n_items==5,"must be four items fater the keyword")
   ENSURE(stdin.buffer.item_index==1,"must be at the second items on the input line")

      interpolator :: INTERPOLATOR*
      coppensbasis :: VEC{COPPENSBASIS}*
      slaterbasis  :: VEC{SLATERBASIS}*
      labels :: VEC{STR}*
      basis1,basis2,plotfile :: STR
      density_cutoff :: REAL
      Z_max,Z :: INT

      ! Read the input
      stdin.read(basis1)
      stdin.read(basis2)
      stdin.read(Z_max)
      stdin.read(density_cutoff)

      ! Create a log-linear prototype interpolator
      interpolator.create  
      interpolator.set_table_length(60.0d0)
      interpolator.set_table_eps(density_cutoff)
      interpolator.set_interpolation_method("linear")
      interpolator.set_range_mapping("logarithmic")
      interpolator.set_domain_mapping("none")

      ! Get the library basis set labels up to Z_max
      labels => VEC{ATOM}:library_basis_labels(Z_max,basis1)
      coppensbasis.read_library_data(coppensbasis.library_file(basis1),labels)
      labels.destroy
      labels => VEC{ATOM}:library_basis_labels(Z_max,basis2)
      slaterbasis.read_library_data(slaterbasis.library_file(basis2),labels)
      labels.destroy
    
      ! Make interpolators and put out the gnuplots

      do Z = 1,slaterbasis.dim   

         stdout.show("Z = ",Z)

         coppensbasis(Z).make_interpolator(interpolator)
         slaterbasis(Z).make_interpolator(interpolator)

         plotfile = trim(Z.to_str)//"_"//trim(ATOM:chemical_symbol(Z))
         plotfile = trim(plotfile)//"_"//trim(basis1)//"-"//trim(basis2)//".gnuplot"
         stdout.redirect(plotfile)
         coppensbasis(Z).interpolator.put_gnuplot(slaterbasis(Z).interpolator)
         stdout.revert

      end                         

      stdout.text("Finished all interpolator plots")

      ! Cleanup
      slaterbasis.destroy
      coppensbasis.destroy
      interpolator.destroy

   end

!  ***************
!  Invariom labels
!  ***************

   put_smiles_invariom_labels
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      labels :: VEC{STR}*
      invariom_kind :: VEC{VEC_{INT}}*
      n_kind,n_elem,n_dash,k,l :: INT

      ! Get the invariom labels
      labels => .atom.smiles_invariom_labels

      ! Put labels out
      stdout.flush
      stdout.text("SMILES invariom labels:")
      stdout.put(labels,"column",left_justify=TRUE)

      ! Make the invariom kind table
      invariom_kind.repetitions_in(labels)

      ! Maximum no. of elements
      n_kind = invariom_kind.dim
      n_elem = 0
      do k = 1,n_kind
         n_elem = max(n_elem,invariom_kind(k).element.dim)
      end

      ! Put invariom kind table out
      stdout.flush
      stdout.show("No. of distinct labels = ",invariom_kind.dim)                                  
      stdout.flush
      stdout.text("Table of invariom kinds")
      stdout.flush
      n_dash = min(10,n_elem)
      stdout.dash(width=5*(n_dash+1))
      stdout.put("Kind",width=5)
      stdout.put(" #'s",width=5)
      stdout.flush
      stdout.dash(width=5*(n_dash+1))
      do k = 1,n_kind
         stdout.put(k,width=5)
         n_elem = invariom_kind(k).element.dim
         stdout.put(invariom_kind(k)[1],width=5)
         l = 1
         do 
            l = l + 1
            if (l>n_elem) exit
            if (mod(l,10)==1) then
            stdout.flush
            stdout.tab(width=5)
            end
            stdout.put(invariom_kind(k)[l],width=5)
         end
         stdout.flush
      end
      stdout.dash(width=5*(n_dash+1))

      ! Cleanup
      invariom_kind.destroy
      labels.destroy

   end

   put_invariom_labels
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      labels :: VEC{STR}*
      invariom_kind :: VEC{VEC_{INT}}*

      n_kind,n_elem,n_dash,k,l :: INT

      ! Get the invariom labels
      labels => .atom.invariom_labels

      ! Put labels out
      stdout.flush
      stdout.text("Atom names and their invariom labels:")

      do k = 1,labels.dim
         stdout.put(k,width=5)
         stdout.put(.atom(k).label,width=10,left_justify=TRUE)
         stdout.put(labels(k),width=25,left_justify=TRUE)
         stdout.flush
      end
      stdout.flush


      ! Make the invariom kind table
      invariom_kind.repetitions_in(labels)

      ! Maximum no. of elements
      n_kind = invariom_kind.dim
      n_elem = 0
      do k = 1,n_kind
         n_elem = max(n_elem,invariom_kind(k).element.dim)
      end

      ! Put invariom kind table out
      stdout.flush
      stdout.show("No. of distinct labels = ",invariom_kind.dim)                                  
      stdout.flush
      stdout.text("Table of invariom kinds")
      stdout.flush
      n_dash = min(10,n_elem)
      stdout.dash(width=5*(n_dash+1))
      stdout.put("Kind",width=5)
      stdout.put(" #'s",width=5)
      stdout.flush
      stdout.dash(width=5*(n_dash+1))
      do k = 1,n_kind
         stdout.put(k,width=5)
         n_elem = invariom_kind(k).element.dim
         stdout.put(invariom_kind(k)[1],width=5)
         l = 1
         do 
            l = l + 1
            if (l>n_elem) exit
            if (mod(l,10)==1) then
            stdout.flush
            stdout.tab(width=5)
            end
            stdout.put(invariom_kind(k)[l],width=5)
         end
         stdout.flush
      end
      stdout.dash(width=5*(n_dash+1))

      ! Cleanup
      invariom_kind.destroy
      labels.destroy

   end

   put_invariom_label
   ! Analyse the SCF energy into MO contributions
   ENSURE(.atom.created,"no atoms")
      label :: STR
      i :: INT
      stdin.read(i)
      label = .atom.invariom_label_of(i)
      stdout.flush
      stdout.show("Invariom label for atom "//trim(i.to_str)//" = ",label)
   end

   put_next_neighbour_handedness
   ! Put the next neighbour handedness out, for the atom with the
   ! index specified in the input.
   ENSURE(.atom.created,"no atoms")
      hand :: STR
      i :: INT
      stdin.read(i)
      hand = .atom.next_neighbour_handedness_of(i)
      stdout.flush
      stdout.show("Next-neighbour handedness of atom "//trim(i.to_str)//" = ",hand)
   end

!  ***************************
!  Hirshfeld structure factors
!  ***************************

   make_H_structure_factors ::: leaky
   ! Make the Hirshfeld structure factors
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")

      k_pts,pt,kU :: MAT{REAL}*
      sf_eq,Fc :: VEC{CPX}*
      wt,rho,Wa,tf, u1,u2,u3,k1,k2,k3,r1,r2,r3 :: VEC{REAL}*
      n_e,k1k,k2k,k3k,kr,rf :: REAL
      n_k,n_pt,a,k,i :: INT
      sf :: CPX

      ! Set up grids, atomic densities, and NO's
      .set_up_Hirshfeld_info

      ! Structure factors
      Fc.create(.crystal.n_refl)

      ! Symmetry generated K points and SF's
      n_k = .crystal.n_unique_SF_k_pts
      sf_eq.create(n_k)
      k_pts.create(n_k,3)
      kU.create(n_k,3)
      tf.create(n_k)

      ! Make list of symmetry non-equivalent symops
      .crystal.make_unique_SF_k_pts(k_pts)
      k1 => k_pts(:,1)
      k2 => k_pts(:,2)
      k3 => k_pts(:,3)

      ! Make the structure factors
      n_e = ZERO
      sf_eq = ZERO
      do a = 1,.n_atom
         .becke_grid.make_grid(pt,wt,[a])
         n_pt = pt.dim1
         Wa.create(n_pt)
         rho.create(n_pt)
         .make_density_grid(rho,pt)
         .make_stockholder_atom_grid(Wa,a,pt)
         Wa = rho*Wa*wt
         n_e = n_e + sum(Wa)
         kU = matmul(k_pts,.atom(a).thermal_tensor)
         u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)
         tf = exp(-HALF*(u1*k1+u2*k2+u3*k3))
         rf = ONE/.crystal.repetition_factor(a)
         do k = 1,n_k
            k1k = k1(k); k2k = k2(k); k3k = k3(k)
            sf = ZERO
            do i = 1,n_pt 
               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
               sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
            end
            sf = sf * rf
            sf_eq(k) = sf_eq(k) + sf * tf(k)
         end
         rho.destroy; Wa.destroy
         wt.destroy; pt.destroy
      end
      tf.destroy; kU.destroy; k_pts.destroy

      ! Check integration accuracy
      stdout.flush
      stdout.text("Making Hirshfeld structure factors ...")
      stdout.flush
      stdout.show("Check: no. of electrons        = ",n_e)

      ! Sum the symmetry equivalent SF's
      .crystal.sum_unique_sf(Fc,sf_eq)
      sf_eq.destroy

      ! Dispersion correction
      if (.crystal.correct_dispersion) then
        k_pts.create(.crystal.n_refl,3)
        .crystal.make_k_pts(k_pts)
        .add_dispersion_correction(Fc,k_pts)
        k_pts.destroy
      end

      ! Set the calculated SF's
      .crystal.set_F_calc(Fc)
      Fc.destroy

      ! Make chi2
      .crystal.make_F_predicted
      .crystal.put_F_statistics

   end

!  **********************
!  Hirshfeld atom fitting
!  **********************

   fit_Hirshfeld_atoms ::: leaky
   ! Fit the Hirshfeld atoms to the calculated structure factors.
   ENSURE(.atom.created, "no atoms to fit")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created,"no crystal data")
   ENSURE(.crystal.xray_data.created,"no crystal xray data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")

      X,X_old,dX :: VEC{REAL}*
      sf_n :: MAT{CPX}*
      n_p,n_atom :: INT
      chi2_increased,finished :: BIN

      ! Set up grids, atomic densities, and NO's (leaky)
      .set_up_Hirshfeld_info

      ! Constants
      n_atom = .crystal.asymmetric_unit_atom.dim
      n_p = 9*n_atom

      ! Parameter vectors, shifts
      X.create(n_p); X_old.create(n_p)
      dX.create(n_p)

      ! Parameter uncertainties, correlations (leaky)
      .crystal.data.delta_p.create(n_p)
      .crystal.data.delta_p = ZERO
      .crystal.data.correlation_matrix.create(n_p,n_p)
 
      ! Get the initial parameters
      .MAIN:get_asym_atom_params_into(X)

      ! Aspherical unique atomic SF's
      if (.invariom_refinement) then; .MAIN:get_unique_invariom_SFs(sf_n)
      else;                           .MAIN:get_unique_atom_SFs(sf_n)
      end

      ! Banner and initialise refinement
      .crystal.initialise_refinement

      ! Begin refinement loop
      do
 
         ! Set parameters "X", get the shifts "dX"
         .MAIN:get_asym_atom_param_shifts(dX,X,sf_n)

         ! Put the results
         .crystal.put_iteration_results
 
         ! Finished?
         finished = .crystal.refinement_finished(chi2_increased)
         if (chi2_increased) then ! roll back the parameters
            X = X_old
            .crystal.data.chi2 = .crystal.data.chi2_old
         end
         if (finished) exit

         ! Store parameters, add shift
         .crystal.data.chi2_old = .crystal.data.chi2
         X_old = X
         X = X + dX
 
      end

      ! Set the parameter errors
      .crystal.set_parameter_errors

      ! Correct parameter errors
      .MAIN:uniq_to_asym_atom_shifts(.crystal.data.delta_p)

      ! Banner and finalise refinement
      .crystal.finalise_refinement

      ! Set the final geometry and ADP's
      .MAIN:set_from_asym_atom_params(X)

      ! Write a CIF file
      .MAIN:put_cif
 
      ! Clean up
      sf_n.destroy
      dX.destroy; X_old.destroy; X.destroy

      ! Delete stored matrices
      .destroy_scf_results
      .delete_scf_archives
      .delete_scf_integrals

   end

   get_unique_atom_SFs(sf_n) ::: leaky, private
   ! Get "sf_n", the structure factors for the symmetry related 
   ! K points with *no* thermal smearing, for every unique atom. 
      sf_n :: MAT{CPX}*

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created, "no reflection data")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")

      k_pt,pt :: MAT{REAL}*
      wt,rho,Wa, k1,k2,k3,r1,r2,r3 :: VEC{REAL}*
      k1k,k2k,k3k,kr,rf :: REAL
      n_k,n_pt,f,a,u,k,i,n_atom :: INT
      sf_u :: VEC{CPX}*
      sf :: CPX


      ! Set up grids, atomic densities, and NO's (leaky)
      .set_up_Hirshfeld_info

      n_k = .crystal.n_unique_SF_k_pts
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Allocate structure factor array (leaky)
      sf_n.create(n_k,n_atom)

      k_pt.create(n_k,3)     
      .crystal.make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! Make the structure factors
      if (DO_IN_PARALLEL) sf_n = ZERO
      parallel do u = 1,.crystal.n_unique_frag_atoms
         f = .crystal.unique_frag_atom(u)
         a = .crystal.asym_unit_atom_for_frag_atom(f)
         .becke_grid.make_grid(pt,wt,[f])
         n_pt = pt.dim1
         Wa.create(n_pt)
         rho.create(n_pt)
         .make_density_grid(rho,pt)
         .make_stockholder_atom_grid(Wa,f,pt)
         Wa = rho*Wa*wt
         rf = ONE/.crystal.asym_atom_rep_factor(a)
         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)
         sf_u => sf_n(:,u)
         do k = 1,n_k
            k1k = k1(k); k2k = k2(k); k3k = k3(k)
            sf = ZERO
            do i = 1,n_pt ! integrate over all space
               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
             ! sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
               sf = sf + Wa(i)*exp(cmplx(ZERO,kr))
            end
            sf_u(k) = sf * rf
         end
         rho.destroy; Wa.destroy
         wt.destroy; pt.destroy
       ! if (DO_IN_PARALLEL) then
       !    PARALLEL_BROADCAST(sf_n(:,u),tonto.processor_rank)
       ! end
      end
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_n)
      end

      .put_debug(sf_n,"get_unique_atom_sfs")

   end

   get_unique_invariom_SFs(sf_n) ::: private
   ! Get "sf_n", the structure factors for the symmetry related 
   ! K points with *no* thermal smearing, for every unique invariom. 
      sf_n :: MAT{CPX}*

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created, "no reflection data")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(sf_n.dim1==.crystal.n_unique_SF_k_pts, "wrong dim1, sf_n")
   ENSURE(sf_n.dim2==.crystal.asymmetric_unit_atom.dim, "wrong dim2, sf_n")

      k_pt,pt :: MAT{REAL}*
      wt,rho,Wa, k1,k2,k3,r1,r2,r3 :: VEC{REAL}*
      k1k,k2k,k3k,kr,rf :: REAL
      n_k,n_pt,f,a,u,k,i,n_ui,ui :: INT
      sf_u :: VEC{CPX}*
      sf :: CPX
      labels :: VEC{STR}*
      invariom_kind :: VEC{VEC_{INT}}*

      ! Set up grids, atomic densities, and NO's
      .set_up_Hirshfeld_info

      ! Make the symmetry generated k's
      n_k = .crystal.n_unique_SF_k_pts
      k_pt.create(n_k,3)     
      .crystal.make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! Get the invariom labels
      labels => .atom.invariom_labels
      ! Make the invariom kind table
      ! For making the sf's we first check which invarioms are 
      ! unique as the unique atoms could be assigned the same invariom
      ! We need to get the unique invarioms for the assymetric unit
      invariom_kind.repetitions_in(labels(.crystal.unique_frag_atom))
      stdout.put(labels(.crystal.unique_frag_atom),"column")
      n_ui = invariom_kind.dim
      sf_n.create(n_k,n_ui)
      stop
      ! Make the structure factors
      if (DO_IN_PARALLEL) sf_n = ZERO
      parallel do ui = 1,n_ui
         u = invariom_kind(ui)[1]
         f = .crystal.unique_frag_atom(u)
         a = .crystal.asym_unit_atom_for_frag_atom(f)
         .becke_grid.make_grid(pt,wt,[f])
         n_pt = pt.dim1
         Wa.create(n_pt)
         rho.create(n_pt)
         .make_density_grid(rho,pt)
         .make_stockholder_atom_grid(Wa,f,pt)
         Wa = rho*Wa*wt
         rf = ONE/.crystal.asym_atom_rep_factor(a)
         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)
         sf_u => sf_n(:,ui)
         do k = 1,n_k
            k1k = k1(k); k2k = k2(k); k3k = k3(k)
            sf = ZERO
            do i = 1,n_pt ! integrate over all space
               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
             ! sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
               sf = sf + Wa(i)*exp(cmplx(ZERO,kr))
            end
            sf_u(k) = sf * rf
         end
         rho.destroy; Wa.destroy
         wt.destroy; pt.destroy
       ! if (DO_IN_PARALLEL) then
       !    PARALLEL_BROADCAST(sf_n(:,u),tonto.processor_rank)
       ! end
      end
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_n)
      end

      .put_debug(sf_n,"get_unique_atom_sfs")

   end


   get_asym_atom_param_shifts(dX,X,sf_n) ::: leaky, private
   ! Given a set of atom parameters "X" (positions and ADP's), and
   ! unique atom structure factors "sf_n" for the symmetry related K
   ! points, evaluate the shifts "dX" by solving the normal equations.
   ! "sf_n" is updated at the end. 

      dX :: VEC{REAL}, OUT
      X  :: VEC{REAL}, IN
      sf_n :: MAT{CPX}, target, INOUT

   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created, "no reflection data")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(NOT .crystal.correct_dispersion, "dispersion is not corrected yet")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(X.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, X")
   ENSURE(sf_n.dim1==.crystal.n_unique_SF_k_pts, "wrong dim1, sf_n")
   ENSURE(sf_n.dim2==.crystal.asymmetric_unit_atom.dim, "wrong dim2, sf_n")

      sf_d,dFc :: MAT{CPX}*
      k_pt,kU,dFa  :: MAT{REAL}*
      sf_e,sf_u,Fc :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,d1,d2,d3,kr,tf,val :: REAL
      n_refl,n_atom,n_k,n_p,f,u,k,base :: INT
      sf,sf2,II :: CPX

      ! Constants
      II = cmplx(ZERO,ONE)
      n_refl = .crystal.n_refl
      n_k = .crystal.n_unique_SF_k_pts
      n_atom = .crystal.asymmetric_unit_atom.dim
      n_p = 9*n_atom

      ! Set atom positions and ADP's
      .MAIN:set_from_asym_atom_params(X)

      ! Structure factors and derivatives
      sf_d.create(n_k,n_p)    ! Derivative symmetry generated SF's
      sf_e.create(n_k)        ! Symmetry generated SF's

      ! Make the symmetry generated k's
      k_pt.create(n_k,3)      ! K points
      kU.create(n_k,3)        ! K times thermal tensors
      .crystal.make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)

      ! Make the structure factors and derivatives
      sf_e = ZERO
      if (DO_IN_PARALLEL) sf_d = ZERO

      if (.crystal.data.refine_positions_and_ADPs) then 

         if (.crystal.data.refine_H_ADPs) then ! Refine H ADP's
   
            if (NOT .crystal.data.refine_H_U_iso) then ! Refine anisotropic H ADP's
   
               parallel do u = 1,.crystal.n_unique_frag_atoms
                  f = .crystal.unique_frag_atom(u)
                  base = 9*(u-1)
                  kU = matmul(k_pt,.atom(f).thermal_tensor)
                  u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
                  sf_u => sf_n(:,u)
                  do k = 1,n_k
                     k1k = k1(k); k2k = k2(k); k3k = k3(k)
                     tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                     sf = sf_u(k) * tf
                     sf_e(k) = sf_e(k) + sf
                     sf_d(k,base+1) = II*k1k*sf
                     sf_d(k,base+2) = II*k2k*sf
                     sf_d(k,base+3) = II*k3k*sf
                     sf2 = HALF*sf
                     sf_d(k,base+4) = -k1k*k1k*sf2
                     sf_d(k,base+5) = -k2k*k2k*sf2
                     sf_d(k,base+6) = -k3k*k3k*sf2
                     sf_d(k,base+7) = -k1k*k2k*sf 
                     sf_d(k,base+8) = -k1k*k3k*sf 
                     sf_d(k,base+9) = -k2k*k3k*sf 
                  end
               end
   
            else if (.crystal.data.refine_H_U_iso) then ! Refine isotropic H ADP's
   
               parallel do u = 1,.crystal.n_unique_frag_atoms
                  f = .crystal.unique_frag_atom(u)
                  base = 9*(u-1)
                  kU = matmul(k_pt,.atom(f).thermal_tensor)
                  u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
                  sf_u => sf_n(:,u)
                  if (.atom(f).atomic_number/=1) then
                     do k = 1,n_k
                        k1k = k1(k); k2k = k2(k); k3k = k3(k)
                        tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                        sf = sf_u(k) * tf
                        sf_e(k) = sf_e(k) + sf
                        sf_d(k,base+1) = II*k1k*sf
                        sf_d(k,base+2) = II*k2k*sf
                        sf_d(k,base+3) = II*k3k*sf
                        sf2 = HALF*sf
                        sf_d(k,base+4) = -k1k*k1k*sf2
                        sf_d(k,base+5) = -k2k*k2k*sf2
                        sf_d(k,base+6) = -k3k*k3k*sf2
                        sf_d(k,base+7) = -k1k*k2k*sf 
                        sf_d(k,base+8) = -k1k*k3k*sf 
                        sf_d(k,base+9) = -k2k*k3k*sf 
                     end
                  else
                     do k = 1,n_k
                        k1k = k1(k); k2k = k2(k); k3k = k3(k)
                        tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                        sf = sf_u(k) * tf
                        sf_e(k) = sf_e(k) + sf
                        sf_d(k,base+1) = II*k1k*sf
                        sf_d(k,base+2) = II*k2k*sf
                        sf_d(k,base+3) = II*k3k*sf
                        sf2 = HALF*sf
                        val = -sf2*(k1k*k1k+k2k*k2k+k3k*k3k)
                        sf_d(k,base+4) = val
                        sf_d(k,base+5) = val
                        sf_d(k,base+6) = val
                        sf_d(k,base+7) = ZERO
                        sf_d(k,base+8) = ZERO
                        sf_d(k,base+9) = ZERO
                     end
                  end
               end

            end
   
         else if (NOT .crystal.data.refine_H_ADPs) then ! Don't refine H ADP's

            parallel do u = 1,.crystal.n_unique_frag_atoms
               f = .crystal.unique_frag_atom(u)
               base = 9*(u-1)
               kU = matmul(k_pt,.atom(f).thermal_tensor)
               u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
               sf_u => sf_n(:,u)
               if (.atom(f).atomic_number/=1) then
                  do k = 1,n_k
                     k1k = k1(k); k2k = k2(k); k3k = k3(k)
                     tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                     sf = sf_u(k) * tf
                     sf_e(k) = sf_e(k) + sf
                     sf_d(k,base+1) = II*k1k*sf
                     sf_d(k,base+2) = II*k2k*sf
                     sf_d(k,base+3) = II*k3k*sf
                     sf2 = HALF*sf
                     sf_d(k,base+4) = -k1k*k1k*sf2
                     sf_d(k,base+5) = -k2k*k2k*sf2
                     sf_d(k,base+6) = -k3k*k3k*sf2
                     sf_d(k,base+7) = -k1k*k2k*sf 
                     sf_d(k,base+8) = -k1k*k3k*sf 
                     sf_d(k,base+9) = -k2k*k3k*sf 
                  end
               else
                  do k = 1,n_k
                     k1k = k1(k); k2k = k2(k); k3k = k3(k)
                     tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                     sf = sf_u(k) * tf
                     sf_e(k) = sf_e(k) + sf
                     sf_d(k,base+1) = II*k1k*sf
                     sf_d(k,base+2) = II*k2k*sf
                     sf_d(k,base+3) = II*k3k*sf
                     sf_d(k,base+4) = ZERO
                     sf_d(k,base+5) = ZERO
                     sf_d(k,base+6) = ZERO
                     sf_d(k,base+7) = ZERO
                     sf_d(k,base+8) = ZERO
                     sf_d(k,base+9) = ZERO
                  end
               end
            end

         end

      else if (.crystal.data.refine_positions_only) then ! Refine positions only

         parallel do u = 1,.crystal.n_unique_frag_atoms
            f = .crystal.unique_frag_atom(u)
            base = 9*(u-1)
            kU = matmul(k_pt,.atom(f).thermal_tensor)
            u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
            sf_u => sf_n(:,u)
            do k = 1,n_k
               k1k = k1(k); k2k = k2(k); k3k = k3(k)
               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
               sf = sf_u(k) * tf
               sf_e(k) = sf_e(k) + sf
               sf_d(k,base+1) = II*k1k*sf
               sf_d(k,base+2) = II*k2k*sf
               sf_d(k,base+3) = II*k3k*sf
               sf_d(k,base+4) = ZERO
               sf_d(k,base+5) = ZERO
               sf_d(k,base+6) = ZERO
               sf_d(k,base+7) = ZERO
               sf_d(k,base+8) = ZERO
               sf_d(k,base+9) = ZERO
            end
         end

      else if (.crystal.data.refine_ADPs_only) then ! Refine ADP's only

         if (.crystal.data.refine_H_ADPs) then ! Refine H ADP's

            if (NOT .crystal.data.refine_H_U_iso) then ! Refine ADP's: with anisotropic H ADP's
   
               parallel do u = 1,.crystal.n_unique_frag_atoms
                  f = .crystal.unique_frag_atom(u)
                  base = 9*(u-1)
                  kU = matmul(k_pt,.atom(f).thermal_tensor)
                  u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
                  sf_u => sf_n(:,u)
                  do k = 1,n_k
                     k1k = k1(k); k2k = k2(k); k3k = k3(k)
                     tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                     sf = sf_u(k) * tf
                     sf_e(k) = sf_e(k) + sf
                     sf_d(k,base+1) = ZERO
                     sf_d(k,base+2) = ZERO
                     sf_d(k,base+3) = ZERO
                     sf2 = HALF*sf
                     sf_d(k,base+4) = -k1k*k1k*sf2
                     sf_d(k,base+5) = -k2k*k2k*sf2
                     sf_d(k,base+6) = -k3k*k3k*sf2
                     sf_d(k,base+7) = -k1k*k2k*sf 
                     sf_d(k,base+8) = -k1k*k3k*sf 
                     sf_d(k,base+9) = -k2k*k3k*sf 
                  end
               end
   
            else if (.crystal.data.refine_H_U_iso) then ! Refine ADP's: with isotropic H ADP's
   
               parallel do u = 1,.crystal.n_unique_frag_atoms
                  f = .crystal.unique_frag_atom(u)
                  base = 9*(u-1)
                  kU = matmul(k_pt,.atom(f).thermal_tensor)
                  u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
                  sf_u => sf_n(:,u)
                  if (.atom(f).atomic_number/=1) then
                     do k = 1,n_k
                        k1k = k1(k); k2k = k2(k); k3k = k3(k)
                        tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                        sf = sf_u(k) * tf
                        sf_e(k) = sf_e(k) + sf
                        sf_d(k,base+1) = ZERO
                        sf_d(k,base+2) = ZERO
                        sf_d(k,base+3) = ZERO
                        sf2 = HALF*sf
                        sf_d(k,base+4) = -k1k*k1k*sf2
                        sf_d(k,base+5) = -k2k*k2k*sf2
                        sf_d(k,base+6) = -k3k*k3k*sf2
                        sf_d(k,base+7) = -k1k*k2k*sf 
                        sf_d(k,base+8) = -k1k*k3k*sf 
                        sf_d(k,base+9) = -k2k*k3k*sf 
                     end
                  else
                     do k = 1,n_k
                        k1k = k1(k); k2k = k2(k); k3k = k3(k)
                        tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                        sf = sf_u(k) * tf
                        sf_e(k) = sf_e(k) + sf
                        sf_d(k,base+1) = ZERO
                        sf_d(k,base+2) = ZERO
                        sf_d(k,base+3) = ZERO
                        sf2 = HALF*sf
                        val = -sf2*(k1k*k1k+k2k*k2k+k3k*k3k)
                        sf_d(k,base+4) = val
                        sf_d(k,base+5) = val
                        sf_d(k,base+6) = val
                        sf_d(k,base+7) = ZERO
                        sf_d(k,base+8) = ZERO
                        sf_d(k,base+9) = ZERO
                     end
                  end
               end
   
            end 

         else if (NOT .crystal.data.refine_H_ADPs) then ! Don't refine H ADP's
   
            parallel do u = 1,.crystal.n_unique_frag_atoms
               f = .crystal.unique_frag_atom(u)
               base = 9*(u-1)
               kU = matmul(k_pt,.atom(f).thermal_tensor)
               u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
               sf_u => sf_n(:,u)
               if (.atom(f).atomic_number/=1) then
                  do k = 1,n_k
                     k1k = k1(k); k2k = k2(k); k3k = k3(k)
                     tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                     sf = sf_u(k) * tf
                     sf_e(k) = sf_e(k) + sf
                     sf_d(k,base+1) = ZERO
                     sf_d(k,base+2) = ZERO
                     sf_d(k,base+3) = ZERO
                     sf2 = HALF*sf
                     sf_d(k,base+4) = -k1k*k1k*sf2
                     sf_d(k,base+5) = -k2k*k2k*sf2
                     sf_d(k,base+6) = -k3k*k3k*sf2
                     sf_d(k,base+7) = -k1k*k2k*sf 
                     sf_d(k,base+8) = -k1k*k3k*sf 
                     sf_d(k,base+9) = -k2k*k3k*sf 
                  end
               else
                  do k = 1,n_k
                     k1k = k1(k); k2k = k2(k); k3k = k3(k)
                     tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
                     sf = sf_u(k) * tf
                     sf_e(k) = sf_e(k) + sf
                     sf_d(k,base+1) = ZERO
                     sf_d(k,base+2) = ZERO
                     sf_d(k,base+3) = ZERO
                     sf_d(k,base+4) = ZERO
                     sf_d(k,base+5) = ZERO
                     sf_d(k,base+6) = ZERO
                     sf_d(k,base+7) = ZERO
                     sf_d(k,base+8) = ZERO
                     sf_d(k,base+9) = ZERO
                  end
               end
            end
   
         end

      end ! different kinds of refinement

      ! Clean
      kU.destroy
      k_pt.destroy

      if (DO_IN_PARALLEL) then
         PARALLEL_SUM(sf_e)
         PARALLEL_SUM(sf_d)
      end

      if (.debugging("get_asym_atom_shifts")) then
         stdout.text("sf_e:")
         stdout.put(sf_e)
         stdout.text("sf_d:")
         stdout.put(sf_d)
      end

      ! Sum the symmetry equivalent SF's
      Fc.create(n_refl) 
      .crystal.sum_unique_sf(Fc,sf_e)
      sf_e.destroy

      if (.debugging("get_asym_atom_shifts")) then
         stdout.text("Fc:")
         stdout.put(Fc)
      end

      ! Set the calculated SF's
      .crystal.set_F_calc(Fc)
      Fc.destroy

      ! Make chi2
      .crystal.make_F_predicted

      if (.debugging("get_asym_atom_shifts")) then
         .crystal.put_F_statistics
      end
    
      ! Get the derivative complex SF's, unique atoms only
      dFc.create(n_refl,n_p)  ! Derivative complex structure factors
      .crystal.sum_unique_sf_derivs_t(dFc,sf_d)
      sf_d.destroy

      ! Get the derivative absolute SF's, unique atoms only
      dFa.create(n_refl,n_p)
      .crystal.d_F_abs_dX(dFa,dFc)
      dFc.destroy

      if (.debugging("get_asym_atom_shifts")) then
         stdout.text("dFdX:")
         stdout.put(dFa)
      end
 
      ! Get the unique atom shifts, dX (leaky)
      .crystal.solve_normal_equations(dX,dFa)
      dFa.destroy

      ! Update # of params and chi2
      .crystal.update_n_param_and_chi2

      ! Eliminate symmetry breaking in dX
      .MAIN:stabilize_uniq_atom_shifts(dX)

      ! Update the unique atom SF's
      k_pt.create(n_k,3)      ! K points
      .crystal.make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)
      do u = 1,n_atom
         base = 9*(u-1)
         d1 = dX(base+1)
         d2 = dX(base+2)
         d3 = dX(base+3)
         sf_u => sf_n(:,u)
         do k = 1,n_k
            kr = k1(k)*d1+k2(k)*d2+k3(k)*d3
            sf_u(k) = sf_u(k) * cmplx(cos(kr),sin(kr))
         end
      end
      k_pt.destroy

      ! Change dX to asym atom shifts
      .MAIN:uniq_to_asym_atom_shifts(dX)
 
   end

!   get_asym_atom_param_shifts(X,dX,chi2,n_e,max_shift,max_allowed_shift) ::: private
!   ! Given a set of atom parameters "X" (positions and ADP's),
!   ! evaluate the shifts "dX" by solving the normal equations.
!      X  :: VEC{REAL}, IN
!      dX :: VEC{REAL}, OUT
!      chi2 :: REAL, OUT
!      n_e  :: REAL, OUT
!      max_shift :: REAL, optional, OUT
!      max_allowed_shift :: REAL, optional, IN
!
!   ENSURE(present(max_shift) EQV present(max_allowed_shift),"max_shift, max_allowed_shift not both present")
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.data.created, "no reflection data")
!   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
!   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
!   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
!   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
!   ENSURE(NOT .crystal.correct_dispersion, "dispersion is not corrected yet")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
!   ENSURE(.molecular_orbitals.created, "no MO's")
!   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
!   ENSURE(X.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, X")
!
!      k_pt,pt,kU :: MAT{REAL}*
!      sf_d,dF :: MAT{CPX}*
!      sf_e,Fc :: VEC{CPX}*
!      wt,rho,Wa, u1,u2,u3,k1,k2,k3,r1,r2,r3 :: VEC{REAL}*
!      k1k,k2k,k3k,kr,rf,tf,fac :: REAL
!      n_refl,n_k,n_p,n_pt,a,u,k,i,base :: INT
!      sf,sf2,II :: CPX
!
!      ! Constants
!      II = cmplx(ZERO,ONE)
!      n_refl = .crystal.n_refl
!      n_k = .crystal.n_unique_SF_k_pts
!      n_p = 9*.crystal.asymmetric_unit_atom.dim
!
!      ! Set atom positions and ADP's
!      .MAIN:set_from_asym_atom_params(X)
!    ! .scf
!    ! .cleanup_scf
!
!      ! Set up grids, atomic densities, and NO's
!    ! .set_up_Hirshfeld_info
!
!      ! Structure factors and derivatives
!      dF.create(n_refl,n_p)  ! Derivative structure factors
!      sf_d.create(n_k,n_p)   ! Derivative symmetry generated SF's
!      Fc.create(n_refl)      ! Structure factors
!      sf_e.create(n_k)       ! Symmetry generated SF's
!      k_pt.create(n_k,3)     ! K points
!      kU.create(n_k,3)       ! K times thermal tensors
!
!      ! Make the symmetry generated k's
!      .crystal.make_unique_SF_k_pts(k_pt)
!      k1 => k_pt(:,1)
!      k2 => k_pt(:,2)
!      k3 => k_pt(:,3)
!
!      ! Make the structure factors and derivatives
!      sf_e = ZERO
!      n_e = ZERO
!      u = -1
!      do a = 1,.n_atom
!         if (a/=.crystal.unique_atom_for_frag_atom(a)) cycle
!         u = u + 1
!         .becke_grid.make_grid(pt,wt,[a])
!         n_pt = pt.dim1
!         Wa.create(n_pt)
!         rho.create(n_pt)
!         .make_density_grid(rho,pt)
!         .make_stockholder_atom_grid(Wa,a,pt)
!         Wa = rho*Wa*wt
!         rf = ONE/.crystal.asym_atom_rep_factor(a) ! WRONG
!         n_e = n_e + rf*sum(Wa)
!         kU = matmul(k_pt,.atom(a).thermal_tensor)
!         u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
!         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)
!         ! Do SF part
!         do k = 1,n_k
!            k1k = k1(k); k2k = k2(k); k3k = k3(k)
!            sf = ZERO
!            do i = 1,n_pt ! integrate over all space
!               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
!               sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
!            end
!            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
!            sf = sf * rf * tf
!            sf_e(k) = sf_e(k) + sf
!         end
!         ! Do derivative SF if needed
!         base = 9*u
!         do k = 1,n_k
!            k1k = k1(k); k2k = k2(k); k3k = k3(k)
!            sf = ZERO
!            do i = 1,n_pt ! integrate over all space
!               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
!               sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
!            end
!            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
!            sf = sf * rf * tf
!            sf_d(k,base+1) = II*k1k*sf
!            sf_d(k,base+2) = II*k2k*sf
!            sf_d(k,base+3) = II*k3k*sf
!            sf2 = HALF*sf
!            sf_d(k,base+4) = -k1k*k1k*sf2
!            sf_d(k,base+5) = -k2k*k2k*sf2
!            sf_d(k,base+6) = -k3k*k3k*sf2
!            sf_d(k,base+7) = -k1k*k2k*sf 
!            sf_d(k,base+8) = -k1k*k3k*sf 
!            sf_d(k,base+9) = -k2k*k3k*sf 
!         end
!         rho.destroy; Wa.destroy
!         wt.destroy; pt.destroy
!      end
!      kU.destroy; k_pt.destroy
!
!      ! Sum the symmetry equivalent SF's
!      .crystal.sum_unique_sf(Fc,sf_e)
!      sf_e.destroy
!
!      ! Set the calculated SF's
!      .crystal.set_F_calc(Fc)
!      Fc.destroy
!
!      ! Make chi2
!      .crystal.make_F_predicted
!      chi2 = .crystal.F_chi2
!    
!      ! Get the derivative SF's, unique atoms only
!      .crystal.sum_unique_sf_derivs_t(dF,sf_d)
!      sf_d.destroy
! 
!      ! Get the unique atom shifts, dX
!      .crystal.solve_normal_equations(dX,dF,max_shift,max_allowed_shift)
!      dF.destroy
!
!      ! Change dX to asym atom shifts
!      .MAIN:uniq_to_asym_atom_params(dX)
! 
!   end

!   get_asym_atom_param_shifts(X,dX,chi2,n_e,max_shift,max_allowed_shift) ::: private
!   ! Given a set of atom parameters "X" (positions and ADP's),
!   ! evaluate the shifts "dX" by solving the normal equations.
!      X  :: VEC{REAL}, IN
!      dX :: VEC{REAL}, OUT
!      chi2 :: REAL, OUT
!      n_e :: REAL, OUT
!      max_shift :: REAL, optional, OUT
!      max_allowed_shift :: REAL, optional, IN
!
!   ENSURE(present(max_shift) EQV present(max_allowed_shift),"max_shift, max_allowed_shift not both present")
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.data.created, "no reflection data")
!   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
!   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
!   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
!   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
!   ENSURE(NOT .crystal.correct_dispersion, "dispersion is not corrected yet")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
!   ENSURE(.molecular_orbitals.created, "no MO's")
!   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
!   ENSURE(X.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, X")
!
!      k_pt,pt,kU :: MAT{REAL}*
!      sf_d,dF :: MAT{CPX}*
!      sf_e,Fc :: VEC{CPX}*
!      wt,rho,Wa, u1,u2,u3,k1,k2,k3,r1,r2,r3 :: VEC{REAL}*
!      k1k,k2k,k3k,kr,rf,tf,fac :: REAL
!      n_refl,n_k,n_p,n_pt,a,u,k,i,base :: INT
!      sf,sf2,II :: CPX
!
!      ! Constants
!      II = cmplx(ZERO,ONE)
!      n_refl = .crystal.n_refl
!      n_k = .crystal.n_unique_SF_k_pts
!      n_p = 9*.crystal.asymmetric_unit_atom.dim
!
!      ! Set atom positions and ADP's
!      .MAIN:set_from_asym_atom_params(X)
!    ! .scf
!    ! .cleanup_scf
!
!      ! Set up grids, atomic densities, and NO's
!      .set_up_Hirshfeld_info
!
!      ! Structure factors and derivatives
!      dF.create(n_refl,n_p)  ! Derivative structure factors
!      sf_d.create(n_k,n_p)   ! Derivative symmetry generated SF's
!      Fc.create(n_refl)      ! Structure factors
!      sf_e.create(n_k)       ! Symmetry generated SF's
!      k_pt.create(n_k,3)     ! K points
!      kU.create(n_k,3)       ! K times thermal tensors
!
!      ! Make the symmetry generated k's
!      .crystal.make_unique_SF_k_pts(k_pt)
!      k1 => k_pt(:,1)
!      k2 => k_pt(:,2)
!      k3 => k_pt(:,3)
!
!      ! Make the structure factors and derivatives
!      sf_e = ZERO
!      n_e = ZERO
!      u = -1
!      do a = 1,.n_atom
!         rf = .crystal.repetition_factor(a)
!         if (rf.equals(ZERO)) cycle
!         rf = ONE/rf
!         .becke_grid.make_grid(pt,wt,[a])
!         n_pt = pt.dim1
!         Wa.create(n_pt)
!         rho.create(n_pt)
!         .make_density_grid(rho,pt)
!         .make_stockholder_atom_grid(Wa,a,pt)
!         Wa = rho*Wa*wt
!         n_e = n_e + rf*sum(Wa)
!         kU = matmul(k_pt,.atom(a).thermal_tensor)
!         u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
!         r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)
!         ! Do SF part
!         do k = 1,n_k
!            k1k = k1(k); k2k = k2(k); k3k = k3(k)
!            sf = ZERO
!            do i = 1,n_pt ! integrate over all space
!               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
!               sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
!            end
!            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
!            sf = sf * rf * tf
!            sf_e(k) = sf_e(k) + sf
!         end
!         ! Do derivative SF if needed
!         if (a==.crystal.unique_atom_for_frag_atom(a)) then
!         u = u + 1
!         base = 9*u
!         do k = 1,n_k
!            k1k = k1(k); k2k = k2(k); k3k = k3(k)
!            sf = ZERO
!            do i = 1,n_pt ! integrate over all space
!               kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
!               sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
!            end
!            tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
!            sf = sf * rf * tf
!            sf_d(k,base+1) = II*k1k*sf
!            sf_d(k,base+2) = II*k2k*sf
!            sf_d(k,base+3) = II*k3k*sf
!            sf2 = HALF*sf
!            sf_d(k,base+4) = -k1k*k1k*sf2
!            sf_d(k,base+5) = -k2k*k2k*sf2
!            sf_d(k,base+6) = -k3k*k3k*sf2
!            sf_d(k,base+7) = -k1k*k2k*sf 
!            sf_d(k,base+8) = -k1k*k3k*sf 
!            sf_d(k,base+9) = -k2k*k3k*sf 
!         end
!         end
!         rho.destroy; Wa.destroy
!         wt.destroy; pt.destroy
!      end
!      kU.destroy; k_pt.destroy
!
!      ! Sum the symmetry equivalent SF's
!      .crystal.sum_unique_sf(Fc,sf_e)
!      sf_e.destroy
!
!      ! Set the calculated SF's
!      .crystal.set_F_calc(Fc)
!      Fc.destroy
!
!      ! Make chi2
!      .crystal.make_F_predicted
!      chi2 = .crystal.F_chi2
!    
!      ! Get the derivative SF's, unique atoms only
!      .crystal.sum_unique_sf_derivs_t(dF,sf_d)
!      sf_d.destroy
! 
!      ! Get the unique atom shifts dX
!      .crystal.solve_normal_equations(dX,dF,max_shift,max_allowed_shift)
!      dF.destroy
!
!      ! Change shifts to asym atom shifts
!      .MAIN:uniq_to_asym_atom_params(dX)
! 
!   end

   get_asym_atom_params_into(X) ::: private
   ! Get the asymmetric atom positions and ADP's "X" from the unique
   ! atoms in the .atom list. Also set the positions and ADP's for the
   ! .crystal.asymmetric_unit_atom's to be the same as those in "X". 
      X :: VEC{REAL}, OUT
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_symop_for_frag_atom.created,"no crystal asym_symop_for_frag_atom")
   ENSURE(.crystal.frag_atom_for_asym_unit_atom.created,"no crystal frag_atom_for_asym_unit_atom")
   ENSURE(all(.crystal.frag_atom_for_asym_unit_atom>0),"fragment does not generate unit cell")
   ENSURE(X.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, X")
   ENSURE(.crystal.data.created, "no crystal data")

      n_atom,base,u,f,a,s :: INT
      therm,DM :: MAT{REAL}(3,3)
      seitz :: MAT3{REAL}*
      atom :: VEC{ATOM}*
      pf :: VEC{REAL}(3)
      val :: REAL

      ! Asymmetric unit atoms
      atom => .crystal.asymmetric_unit_atom
      n_atom = atom.dim

      ! Set the asym atom positions and ADP's from unique .atom's
      seitz => .crystal.xyz_seitz_matrices
      DM = .crystal.unit_cell.direct_matrix
      do u = 1,.crystal.n_unique_frag_atoms
         f = .crystal.unique_frag_atom(u)
         a = .crystal.asym_unit_atom_for_frag_atom(f)
         s = .crystal.asym_symop_for_frag_atom(f)
         pf = .atom(f).pos - matmul(DM,.crystal.asym_shift_for_frag_atom(:,f))
         atom(a).pos = matmul(pf,seitz(:,:,s))
         therm = .atom(f).thermal_tensor                 ! This must be in cartesian axes
         therm.change_basis_using(seitz(:,:,s))          ! Use R to change U tensor basis
         if (.crystal.data.refine_H_U_iso) then          ! If refining H atom U_iso's ...
         if (atom(a).atomic_number==1) then              ! Make isotropic
            val = THIRD*(therm(1,1) + therm(2,2) + therm(3,3))
            therm(1,1) = val
            therm(2,2) = val
            therm(3,3) = val
            therm(1,2) = ZERO; therm(2,1) = ZERO
            therm(1,3) = ZERO; therm(3,1) = ZERO
            therm(2,3) = ZERO; therm(3,2) = ZERO
         end
         end
         atom(a).thermal_tensor = therm                  
      end
      seitz.destroy

      ! Get the asym atom positions and ADP's in X array
      do a = 1,n_atom    
         base = 9*(a-1) 
         X(base+1) = atom(a).pos(1)
         X(base+2) = atom(a).pos(2)
         X(base+3) = atom(a).pos(3)
         X(base+4) = atom(a).thermal_tensor(1,1)
         X(base+5) = atom(a).thermal_tensor(2,2)
         X(base+6) = atom(a).thermal_tensor(3,3)
         X(base+7) = atom(a).thermal_tensor(1,2)
         X(base+8) = atom(a).thermal_tensor(1,3)
         X(base+9) = atom(a).thermal_tensor(2,3)
      end

   end

   set_from_asym_atom_params(X) ::: private
   ! Set the positions and ADP's for the .crystal.asymmetric_unit_atom's 
   ! and also the .atom's from the asymmetric atom parameter vector "X".  
   ! Symmetry is used to copy these ADP's and positions into the .atom list.  
      X :: VEC{REAL}, IN
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(.crystal.asym_symop_for_frag_atom.created,"no crystal asym_symop_for_frag_atom")
   ENSURE(.crystal.frag_atom_for_asym_unit_atom.created,"no crystal frag_atom_for_asym_unit_atom")
   ENSURE(all(.crystal.frag_atom_for_asym_unit_atom>0),"fragment does not generate unit cell")
   ENSURE(X.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, X")

      n_atom,base,f,a,s :: INT
      therm,DM :: MAT{REAL}(3,3)
      seitz :: MAT3{REAL}*
      atom :: VEC{ATOM}*

      ! Asymmetric unit atoms
      atom => .crystal.asymmetric_unit_atom
      n_atom = atom.dim

      ! Set asym atom positions and ADP's from X array
      do a = 1,n_atom  
         base = 9*(a-1)
         atom(a).pos(1)              = X(base+1)
         atom(a).pos(2)              = X(base+2)
         atom(a).pos(3)              = X(base+3)
         atom(a).thermal_tensor(1,1) = X(base+4)
         atom(a).thermal_tensor(2,2) = X(base+5)
         atom(a).thermal_tensor(3,3) = X(base+6)
         atom(a).thermal_tensor(1,2) = X(base+7)
         atom(a).thermal_tensor(1,3) = X(base+8)
         atom(a).thermal_tensor(2,3) = X(base+9)
         atom(a).thermal_tensor(2,1) = atom(a).thermal_tensor(1,2)
         atom(a).thermal_tensor(3,1) = atom(a).thermal_tensor(1,3)
         atom(a).thermal_tensor(3,2) = atom(a).thermal_tensor(2,3)
      end

      ! Copy the asym atom ADP's out to all .atom's
      seitz => .crystal.transposed_xyz_seitz_matrices    ! transposed !
      DM = .crystal.unit_cell.direct_matrix
      do f = 1,.n_atom 
         a = .crystal.asym_unit_atom_for_frag_atom(f)
         s = .crystal.asym_symop_for_frag_atom(f)
         .atom(f).pos = matmul(atom(a).pos,seitz(:,:,s)) &
                      + matmul(DM,.crystal.asym_shift_for_frag_atom(:,f))
         therm = atom(a).thermal_tensor                  ! This must be in cartesian axes
         therm.change_basis_using(seitz(:,:,s))          ! Use R^T to change U tensor basis
         .atom(f).thermal_tensor = therm                  
      end
      seitz.destroy

   end

   stabilize_uniq_atom_shifts(dX) ::: private
   ! Stabilize "dX", the unique atom shifts in positions and ADP's in
   ! the .atom list, removing any symmetry breaking component.
      dX :: VEC{REAL}, INOUT
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_symop_for_frag_atom.created,"no crystal asym_symop_for_frag_atom")
   ENSURE(.crystal.frag_atom_for_asym_unit_atom.created,"no crystal frag_atom_for_asym_unit_atom")
   ENSURE(all(.crystal.frag_atom_for_asym_unit_atom>0),"fragment does not generate unit cell")
   ENSURE(dX.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, dX")

      n_atom,n_stab,base,f,u,a,s,n :: INT
      stabilizer :: VEC{INT}*
      pos,posn :: VEC{REAL}(3)
      ADP,ADPn,ADPt :: MAT{REAL}(3,3)
      posf,posa,symop :: MAT{REAL}*
      seitz,ADPf,ADPa :: MAT3{REAL}*

      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Asym atom and unique atom position/ADP shifts
      posf.create(3,n_atom)
      posa.create(3,n_atom)
      ADPf.create(3,3,n_atom)
      ADPa.create(3,3,n_atom)

      ! Get unique fragment .atom position/ADP shifts
      do u = 1,n_atom  
         base = 9*(u-1)
         posf(1,u)   = dX(base+1)
         posf(2,u)   = dX(base+2)
         posf(3,u)   = dX(base+3)
         ADPf(1,1,u) = dX(base+4)
         ADPf(2,2,u) = dX(base+5)
         ADPf(3,3,u) = dX(base+6)
         ADPf(1,2,u) = dX(base+7)
         ADPf(1,3,u) = dX(base+8)
         ADPf(2,3,u) = dX(base+9)
         ADPf(2,1,u) = ADPf(1,2,u)
         ADPf(3,1,u) = ADPf(1,3,u)
         ADPf(3,2,u) = ADPf(2,3,u)
      end

      ! Set the asym atom position/ADP shifts
      seitz => .crystal.xyz_seitz_matrices
      do u = 1,.crystal.n_unique_frag_atoms
         f = .crystal.unique_frag_atom(u)
         a = .crystal.asym_unit_atom_for_frag_atom(f)
         s = .crystal.asym_symop_for_frag_atom(f)
         symop => seitz(:,:,s)
         posa(:,a) = matmul(posf(:,u),symop)
         ADPf(:,:,u).change_basis_to(ADPa(:,:,a),symop)
      end

      ! Symmetrize the asym atom positions/ADP's
      do a = 1,n_atom    
         stabilizer => .crystal.asym_atom_stabilizer(a).element
         n_stab = stabilizer.dim
         if (n_stab<=1) cycle
         pos = posa(:,a)
         ADP = ADPa(:,:,a)
         posn = pos
         ADPn = ADP
         do n = 2,n_stab
            s = stabilizer(n)
            symop => seitz(:,:,s)
            ADP.back_transform_to(ADPt,symop)
            ADPn = ADPn + ADPt
            posn = posn + matmul(symop,pos)
         end
         posa(:,a)   = posn/stabilizer.dim
         ADPa(:,:,a) = ADPn/stabilizer.dim
      end

      ! Copy back the asym atom position/ADP shifts to uniq shifts
      do u = 1,.crystal.n_unique_frag_atoms
         f = .crystal.unique_frag_atom(u)
         a = .crystal.asym_unit_atom_for_frag_atom(f)
         s = .crystal.asym_symop_for_frag_atom(f)
         symop => seitz(:,:,s)
         posf(:,u) = matmul(symop,posa(:,a))
         ADPa(:,:,a).back_transform_to(ADPf(:,:,u),symop)
      end
      seitz.destroy

      ! Put back uniq atom positions/ADP's in dX array
      do u = 1,n_atom    
         base = 9*(u-1) 
         dX(base+1) = posf(1,u)
         dX(base+2) = posf(2,u)
         dX(base+3) = posf(3,u)
         dX(base+4) = ADPf(1,1,u)
         dX(base+5) = ADPf(2,2,u)
         dX(base+6) = ADPf(3,3,u)
         dX(base+7) = ADPf(1,2,u)
         dX(base+8) = ADPf(1,3,u)
         dX(base+9) = ADPf(2,3,u)
      end

      ADPa.destroy; posa.destroy
      ADPf.destroy; posf.destroy

   end

   uniq_to_asym_atom_params(X) ::: private
   ! From "X", the unique atom positions and ADP's in the .atom list,
   ! return the asymmetric atom positions and ADP's in the same "X"
   ! parameter vector.
      X :: VEC{REAL}, INOUT
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_symop_for_frag_atom.created,"no crystal asym_symop_for_frag_atom")
   ENSURE(.crystal.frag_atom_for_asym_unit_atom.created,"no crystal frag_atom_for_asym_unit_atom")
   ENSURE(all(.crystal.frag_atom_for_asym_unit_atom>0),"fragment does not generate unit cell")
   ENSURE(X.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, X")

      n_atom,base,f,u,a,s :: INT
      DM  :: MAT{REAL}(3,3)
      posf,posa :: MAT{REAL}*
      seitz,ADPf,ADPa :: MAT3{REAL}*
      pf :: VEC{REAL}(3)

      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Unique .atom positions and ADP's 
      posf.create(3,n_atom)
      posa.create(3,n_atom)
      ADPf.create(3,3,n_atom)
      ADPa.create(3,3,n_atom)

      ! Get unique .atom parameters
      do u = 1,n_atom  
         base = 9*(u-1)
         posf(1,u)   = X(base+1)
         posf(2,u)   = X(base+2)
         posf(3,u)   = X(base+3)
         ADPf(1,1,u) = X(base+4)
         ADPf(2,2,u) = X(base+5)
         ADPf(3,3,u) = X(base+6)
         ADPf(1,2,u) = X(base+7)
         ADPf(1,3,u) = X(base+8)
         ADPf(2,3,u) = X(base+9)
         ADPf(2,1,u) = ADPf(1,2,u)
         ADPf(3,1,u) = ADPf(1,3,u)
         ADPf(3,2,u) = ADPf(2,3,u)
      end

      ! Set the positions and ADP's from unique X
      seitz => .crystal.xyz_seitz_matrices
      DM = .crystal.unit_cell.direct_matrix
      do u = 1,.crystal.n_unique_frag_atoms
         f = .crystal.unique_frag_atom(u)
         a = .crystal.asym_unit_atom_for_frag_atom(f)
         s = .crystal.asym_symop_for_frag_atom(f)
         pf = posf(:,u) - matmul(DM,.crystal.asym_shift_for_frag_atom(:,f))
         posa(:,a) = matmul(pf,seitz(:,:,s))
         ADPf(:,:,u).change_basis_to(ADPa(:,:,a),seitz(:,:,s))
      end
      seitz.destroy

      ! Get the asym atom positions and ADP's in X array
      do a = 1,n_atom    
         base = 9*(a-1) 
         X(base+1) = posa(1,a)
         X(base+2) = posa(2,a)
         X(base+3) = posa(3,a)
         X(base+4) = ADPa(1,1,a)
         X(base+5) = ADPa(2,2,a)
         X(base+6) = ADPa(3,3,a)
         X(base+7) = ADPa(1,2,a)
         X(base+8) = ADPa(1,3,a)
         X(base+9) = ADPa(2,3,a)
      end

      ADPa.destroy; posa.destroy
      ADPf.destroy; posf.destroy

   end

   uniq_to_asym_atom_shifts(dX) ::: private
   ! From "dX", the unique atom shifts in positions and ADP's in the
   ! .atom list, return the *asymmetric* atom shifts positions and
   ! ADP's in the same "dX" parameter vector.
      dX :: VEC{REAL}, INOUT
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_symop_for_frag_atom.created,"no crystal asym_symop_for_frag_atom")
   ENSURE(.crystal.frag_atom_for_asym_unit_atom.created,"no crystal frag_atom_for_asym_unit_atom")
   ENSURE(all(.crystal.frag_atom_for_asym_unit_atom>0),"fragment does not generate unit cell")
   ENSURE(dX.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, dX")

      n_atom,base,f,u,a,s :: INT
      posf,posa :: MAT{REAL}*
      seitz,ADPf,ADPa :: MAT3{REAL}*

      ! Asymmetric unit atoms
      n_atom = .crystal.asymmetric_unit_atom.dim

      ! Unique .atom positions and ADP's 
      posf.create(3,n_atom)
      posa.create(3,n_atom)
      ADPf.create(3,3,n_atom)
      ADPa.create(3,3,n_atom)

      ! Get unique fragment .atom parameters
      do u = 1,n_atom  
         base = 9*(u-1)
         posf(1,u)   = dX(base+1)
         posf(2,u)   = dX(base+2)
         posf(3,u)   = dX(base+3)
         ADPf(1,1,u) = dX(base+4)
         ADPf(2,2,u) = dX(base+5)
         ADPf(3,3,u) = dX(base+6)
         ADPf(1,2,u) = dX(base+7)
         ADPf(1,3,u) = dX(base+8)
         ADPf(2,3,u) = dX(base+9)
         ADPf(2,1,u) = ADPf(1,2,u)
         ADPf(3,1,u) = ADPf(1,3,u)
         ADPf(3,2,u) = ADPf(2,3,u)
      end

      ! Set the asym atom positions and ADP's
      seitz => .crystal.xyz_seitz_matrices
      do u = 1,.crystal.n_unique_frag_atoms
         f = .crystal.unique_frag_atom(u)
         a = .crystal.asym_unit_atom_for_frag_atom(f)
         s = .crystal.asym_symop_for_frag_atom(f)
         posa(:,a) = matmul(posf(:,u),seitz(:,:,s))
         ADPf(:,:,u).change_basis_to(ADPa(:,:,a),seitz(:,:,s))
      end
      seitz.destroy

      ! Get asym atom positions and ADP's in dX array
      do a = 1,n_atom    
         base = 9*(a-1) 
         dX(base+1) = posa(1,a)
         dX(base+2) = posa(2,a)
         dX(base+3) = posa(3,a)
         dX(base+4) = ADPa(1,1,a)
         dX(base+5) = ADPa(2,2,a)
         dX(base+6) = ADPa(3,3,a)
         dX(base+7) = ADPa(1,2,a)
         dX(base+8) = ADPa(1,3,a)
         dX(base+9) = ADPa(2,3,a)
      end

      ADPa.destroy; posa.destroy
      ADPf.destroy; posf.destroy

   end


   fit_Hirshfeld_atoms_BFGS ::: leaky
   ! Fit the Hirshfeld atoms to the calculated structure factors.
   ! Uses a line search method.
      self :: PTR
   ENSURE(.atom.created, "no atoms to fit")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.thermal_smearing_model=="stewart","thermal smearing model must be stewart, so far")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")

      chi2_min :: REAL
      X :: VEC{REAL}*
      sf_n :: MAT{CPX}*
      n_k,n_p,n_atom :: INT
      arch,keep :: TEXTFILE*

      ! Set up grids, atomic densities, and NO's
      .set_up_Hirshfeld_info

      ! Constants
      n_atom = .crystal.asymmetric_unit_atom.dim
      n_p = 9*n_atom
      n_k = .crystal.n_unique_SF_k_pts

      ! Get the initial parameters
      X.create(n_p)
      .MAIN:get_asym_atom_params_into(X)
      X_old.create_copy(X)

      ! Aspherical unique atomic SF's
      sf_n.create(n_k,n_atom)
      .MAIN:get_unique_atom_SFs(sf_n)

      ! Archive initial parameters
      arch.create(trim(.name)//",atom_parameters")
      arch.open(for="writing")
      keep   => stdout
      stdout => arch
      stdout.show("Iteration = ",0)
      .atom.put_coordinates
      .atom.put_thermal_tensors
      stdout => keep

      ! Banner
      stdout.flush
      stdout.text("Refining atom positions and ADP's using BFGS")
      stdout.text("--------------------------------------------")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)
      stdout.put("Iter",int_width=TRUE)
      stdout.put("chi2")
      stdout.put("Max dchi2")
      stdout.flush
      stdout.dash(int_fields=1,real_fields=3)

      saved_self => self
      saved_sf_n => sf_n
      saved_arch => arch
      VEC{REAL}:minimise_BFGS_v2(MOLECULE.MAIN::d_chi2H_dX,X,chi2_min,tol=TOL(6),gtol=TOL(3),step=TOL(4))

      stdout.dash(int_fields=1,real_fields=3)

      arch.destroy
      sf_n.destroy
      X_old.destroy; X.destroy

   end

   d_chi2H_dX(X,chi2,dchi2) ::: public, selfless
   ! Make the derivatives of the Hirshfeld structure factor chi2
   ! with respect to parameters "X" comprised of atom positions and
   ! thermal parameters, returning the chi2 in "f" and its derivative
   ! in "df".
      X  :: VEC{REAL}, IN
      chi2  :: REAL, OUT
      dchi2 :: VEC{REAL}, optional, OUT

      dX :: VEC{REAL}*
      self :: MOLECULE*
      keep :: TEXTFILE*
      k_pt,kU :: MAT{REAL}*
      sf_n,sf_d,dF :: MAT{CPX}*
      sf_e,sf_u,Fc :: VEC{CPX}*
      u1,u2,u3,k1,k2,k3 :: VEC{REAL}*
      k1k,k2k,k3k,d1,d2,d3,kr,tf :: REAL
      n_refl,n_atom,n_k,n_p,f,u,k,base :: INT
      iter :: INT = 0
      sf,sf2,II :: CPX

      ! Set self
      self => saved_self
      sf_n => saved_sf_n

      ! Check
   ENSURE(.basis_info_made,"no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no crystal")
   ENSURE(.crystal.data.created, "no reflection data")
   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
   ENSURE(NOT .crystal.correct_dispersion, "dispersion is not corrected yet")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
   ENSURE(.molecular_orbitals.created, "no MO's")
   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
   ENSURE(X.dim==9*.crystal.asymmetric_unit_atom.dim, "wrong size, X")
   ENSURE(X_old.created, "no X_old")
   ENSURE(sf_n.dim1==.crystal.n_unique_SF_k_pts, "wrong dim1, sf_n")
   ENSURE(sf_n.dim2==.crystal.asymmetric_unit_atom.dim, "wrong dim2, sf_n")

      ! Constants
      II = cmplx(ZERO,ONE)
      n_refl = .crystal.n_refl
      n_k = .crystal.n_unique_SF_k_pts
      n_atom = .crystal.asymmetric_unit_atom.dim
      n_p = 9*n_atom

      ! Ensure symmetric parameters
      dX.create(n_p)
      dX = X - X_old
      .MAIN:stabilize_uniq_atom_shifts(dX)
      dX = X_old + dX

      ! Set symmetrised atom positions and ADP's
      .MAIN:set_from_asym_atom_params(dX)

      ! Structure factors and derivatives
      if (present(dchi2)) then
      dF.create(n_refl,n_p)  ! Derivative structure factors
      sf_d.create(n_k,n_p)   ! Derivative symmetry generated SF's
      end
      Fc.create(n_refl)      ! Structure factors
      sf_e.create(n_k)       ! Symmetry generated SF's
      k_pt.create(n_k,3)     ! K points
      kU.create(n_k,3)       ! K times thermal tensors

      ! Make the symmetry generated k's
      .crystal.make_unique_SF_k_pts(k_pt)
      k1 => k_pt(:,1)
      k2 => k_pt(:,2)
      k3 => k_pt(:,3)
 
      ! Update the unique atom SF's
      do u = 1,n_atom
         base = 9*(u-1)
         d1 = dX(base+1) - X_old(base+1)
         d2 = dX(base+2) - X_old(base+2)
         d3 = dX(base+3) - X_old(base+3)
         sf_u => sf_n(:,u)
         do k = 1,n_k
            kr = k1(k)*d1+k2(k)*d2+k3(k)*d3
            sf_u(k) = sf_u(k) * cmplx(cos(kr),sin(kr))
         end
      end
      X_old = dX
      dX.destroy

      if (NOT present(dchi2)) then

         ! Make the structure factors only
         sf_e = ZERO
         do u = 1,.crystal.n_unique_frag_atoms
            f = .crystal.unique_frag_atom(u)
            base = 9*(u-1)
            kU = matmul(k_pt,.atom(f).thermal_tensor)
            u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
            sf_u => sf_n(:,u)
            do k = 1,n_k
               k1k = k1(k); k2k = k2(k); k3k = k3(k)
               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
               sf = sf_u(k) * tf
               sf_e(k) = sf_e(k) + sf
            end
         end
         kU.destroy
         k_pt.destroy

      else

         ! Make the structure factors and derivatives
         sf_e = ZERO
         do u = 1,.crystal.n_unique_frag_atoms
            f = .crystal.unique_frag_atom(u)
            base = 9*(u-1)
            kU = matmul(k_pt,.atom(f).thermal_tensor)
            u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
            sf_u => sf_n(:,u)
            do k = 1,n_k
               k1k = k1(k); k2k = k2(k); k3k = k3(k)
               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
               sf = sf_u(k) * tf
               sf_e(k) = sf_e(k) + sf
               sf_d(k,base+1) = II*k1k*sf
               sf_d(k,base+2) = II*k2k*sf
               sf_d(k,base+3) = II*k3k*sf
               sf2 = HALF*sf
               sf_d(k,base+4) = -k1k*k1k*sf2
               sf_d(k,base+5) = -k2k*k2k*sf2
               sf_d(k,base+6) = -k3k*k3k*sf2
               sf_d(k,base+7) = -k1k*k2k*sf 
               sf_d(k,base+8) = -k1k*k3k*sf 
               sf_d(k,base+9) = -k2k*k3k*sf 
            end
         end
         kU.destroy
         k_pt.destroy

      end

      ! Sum the symmetry equivalent SF's
      .crystal.sum_unique_sf(Fc,sf_e)
      sf_e.destroy

      ! Set the calculated SF's
      .crystal.set_F_calc(Fc)
      Fc.destroy

      ! Make chi2
      .crystal.make_F_predicted
      chi2 = .crystal.F_chi2

      if (present(dchi2)) then
    
         ! Get the derivative SF's, unique atoms only
         .crystal.sum_unique_sf_derivs_t(dF,sf_d)
         sf_d.destroy

         ! Make derivative with respect to chi2
         .crystal.d_chi2_dX(dchi2,dF)
         dF.destroy

      end

      ! Iteration results
      iter = iter + 1
      stdout.put(iter)
      stdout.put(chi2)
      if (present(dchi2)) stdout.put(maxval(abs(dchi2)))
      stdout.flush
 
      ! Archive parameters
      keep   => stdout
      stdout => saved_arch
      stdout.show("Iteration = ",iter)
      .atom.put_coordinates
      .atom.put_thermal_tensors
      stdout => keep

   end


!   fit_Hirshfeld_atoms_ls ::: leaky
!   ! Fit the Hirshfeld atoms to the calculated structure factors.
!   ! Uses a line search method.
!      self :: PTR
!   ENSURE(.atom.created, "no atoms to fit")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.data.thermal_smearing_model=="stewart","thermal smearing model must be stewart, so far")
! ! ENSURE(NOT .crystal.data.optimise_extinction,"cannot optimise extinction while refining thermal parameters")
!      n_p :: INT
!      chi2_min :: REAL
!      U :: VEC{REAL}*
!      n_p = .n_atom * 9
!      U.create(n_p)
!      .MAIN:get_atom_parameters(U)
!      .atom.put_coordinates
!      .atom.put_thermal_tensors
!    ! .MAIN:set_atom_parameters(U)
!    ! .atom.put_coordinates
!    ! .atom.put_thermal_tensors
!    ! .scf
!    ! .cleanup_scf
!    ! .make_x_structure_factors
!    ! .put_crystal_reflection_data
!    ! stop
!      saved_self => self
!      VEC{REAL}:minimise_BFGS_v2(MOLECULE.MAIN::d_chi2H_dX,U,chi2_min,tol=TOL(4),gtol=TOL(4),step=TOL(4))
!      U.destroy
!   end
!
!   d_chi2H_dX(X,chi2,dchi2) ::: public, leaky, selfless
!   ! Make the derivatives of the Hirshfeld structure factor chi2
!   ! with respect to parameters "X" comprised of atom positions and
!   ! thermal parameters, returning the chi2 in "f" and its derivative
!   ! in "df".
!      X  :: VEC{REAL}, IN
!      chi2  :: REAL, OUT
!      dchi2 :: VEC{REAL}, optional, OUT
!
!      k_pt,pt,kU :: MAT{REAL}*
!      sf_d,dF :: MAT{CPX}*
!      sf_e,Fc :: VEC{CPX}*
!      wt,rho,Wa, u1,u2,u3,k1,k2,k3,r1,r2,r3 :: VEC{REAL}*
!      n_e,k1k,k2k,k3k,kr,rf,tf :: REAL
!      n_refl,n_k,n_p,n_pt,a,k,i,base :: INT
!      sf,sf2,II :: CPX
!      self :: MOLECULE*
!
!      ! Set self
!      self => saved_self
!
!      ! Check
!   ENSURE(.basis_info_made,"no basis info")
!   ENSURE(.atom.created,"no atom list")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.xray_data.created, "no x-ray reflection data")
!   ENSURE(NOT .crystal.correct_dispersion, "dispersion is not corrected yet")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
!   ENSURE(.molecular_orbitals.created, "no MO's")
!   ENSURE(.molecular_orbitals.restricted.created, "no restricted MO's")
!   ENSURE(X.dim==9*.n_atom, "wrong size, X")
!
!      ! Constants
!      II = cmplx(ZERO,ONE)
!      n_refl = .crystal.n_refl
!      n_k = .crystal.n_unique_SF_k_pts
!      n_p = 9*.n_atom
!
!      ! Set atom positions and ADP's
!      .MAIN:set_atom_parameters(X)
!    ! .scf
!    ! .cleanup_scf
!
!      ! Set up grids, atomic densities, and NO's
!      .set_up_Hirshfeld_info
!
!      ! Derivative SF's
!      if (present(dchi2)) then
!      dF.create(n_refl,n_p)  ! Derivative structure factors
!      sf_d.create(n_k,n_p)   ! Derivative symmetry generated SF's
!      end
!
!      ! Structure factors
!      Fc.create(n_refl)      ! Structure factors
!      sf_e.create(n_k)       ! Symmetry generated SF's
!      k_pt.create(n_k,3)     ! K points
!      kU.create(n_k,3)       ! K times thermal tensors
!
!      ! Make the symmetry generated k's
!      .crystal.make_unique_SF_k_pts(k_pt)
!      k1 => k_pt(:,1)
!      k2 => k_pt(:,2)
!      k3 => k_pt(:,3)
!
!      if (present(dchi2)) then
!
!         ! Make the structure factors
!         n_e = ZERO
!         sf_e = ZERO
!         do a = 1,.n_atom
!            .becke_grid.make_grid(pt,wt,[a])
!            n_pt = pt.dim1
!            Wa.create(n_pt)
!            rho.create(n_pt)
!            .make_density_grid(rho,pt)
!            .make_stockholder_atom_grid(Wa,a,pt)
!            Wa = rho*Wa*wt
!            n_e = n_e + sum(Wa)
!            kU = matmul(k_pt,.atom(a).thermal_tensor)
!            u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
!            r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)
!            rf = ONE/.crystal.repetition_factor(a)
!            base = (a-1) * 9
!            do k = 1,n_k
!               k1k = k1(k); k2k = k2(k); k3k = k3(k)
!               sf = ZERO
!               do i = 1,n_pt ! integrate over all space
!                  kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
!                  sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
!               end
!               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
!               sf = sf * rf * tf
!               sf_e(k) = sf_e(k) + sf
!               sf_d(k,base+1) = II*k1k*sf
!               sf_d(k,base+2) = II*k2k*sf
!               sf_d(k,base+3) = II*k3k*sf
!               sf2 = HALF*sf
!               sf_d(k,base+4) = -k1k*k1k*sf2
!               sf_d(k,base+5) = -k2k*k2k*sf2
!               sf_d(k,base+6) = -k3k*k3k*sf2
!               sf_d(k,base+7) = -k1k*k2k*sf 
!               sf_d(k,base+8) = -k1k*k3k*sf 
!               sf_d(k,base+9) = -k2k*k3k*sf 
!            end
!            rho.destroy; Wa.destroy
!            wt.destroy; pt.destroy
!         end
!         kU.destroy; k_pt.destroy
!   
!         ! Check integration accuracy
!         stdout.flush
!         stdout.text("Making Hirshfeld structure factors ...")
!         stdout.flush
!         stdout.show("Check: no. of electrons        = ",n_e)
!   
!         ! Sum the symmetry equivalent SF's
!         .crystal.sum_unique_sf(Fc,sf_e)
!         sf_e.destroy
!   
!         ! Set the calculated SF's
!         .crystal.set_F_calc(Fc)
!         Fc.destroy
!   
!         ! Make chi2
!         .crystal.make_F_predicted
!         chi2 = .crystal.F_chi2
!    
!         ! Get the derivative SF's
!         .crystal.sum_unique_sf_derivs_t(dF,sf_d)
!         sf_d.destroy
!    
!         ! Make derivative with respect to chi2
!         .crystal.d_chi2_dX(dchi2,dF)
!         dF.destroy
!         stdout.text("dchi2:")
!         stdout.put(dchi2)
!    
!         ! Output current ADP's
!         .atom.put_coordinates
!         .atom.put_thermal_tensors
!
!      else
!
!         ! Make the structure factors
!         n_e = ZERO
!         sf_e = ZERO
!         do a = 1,.n_atom
!            .becke_grid.make_grid(pt,wt,[a])
!            n_pt = pt.dim1
!            Wa.create(n_pt)
!            rho.create(n_pt)
!            .make_density_grid(rho,pt)
!            .make_stockholder_atom_grid(Wa,a,pt)
!            Wa = rho*Wa*wt
!            n_e = n_e + sum(Wa)
!            kU = matmul(k_pt,.atom(a).thermal_tensor)
!            u1 => kU(:,1); u2 => kU(:,2); u3 => kU(:,3)
!            r1 => pt(:,1); r2 => pt(:,2); r3 => pt(:,3)
!            rf = ONE/.crystal.repetition_factor(a)
!            do k = 1,n_k
!               k1k = k1(k); k2k = k2(k); k3k = k3(k)
!               sf = ZERO
!               do i = 1,n_pt ! integrate over all space
!                  kr = k1k*r1(i)+k2k*r2(i)+k3k*r3(i)
!                  sf = sf + Wa(i)*cmplx(cos(kr),sin(kr))
!               end
!               tf = exp(-HALF*(u1(k)*k1k+u2(k)*k2k+u3(k)*k3k))
!               sf = sf * rf * tf
!               sf_e(k) = sf_e(k) + sf 
!            end
!            rho.destroy; Wa.destroy
!            wt.destroy; pt.destroy
!         end
!         kU.destroy; k_pt.destroy
!   
!         ! Check integration accuracy
!         stdout.flush
!         stdout.text("Making Hirshfeld structure factors ...")
!         stdout.flush
!         stdout.show("Check: no. of electrons        = ",n_e)
!   
!         ! Sum the symmetry equivalent SF's
!         .crystal.sum_unique_sf(Fc,sf_e)
!         sf_e.destroy
!   
!         ! Set the calculated SF's
!         .crystal.set_F_calc(Fc)
!         Fc.destroy
!   
!         ! Make chi2
!         .crystal.make_F_predicted
!         chi2 = .crystal.F_chi2
!         stdout.show("new F_chi2 =",chi2)
!
!      end
!
!   end
!
!   get_atom_parameters(X) ::: private
!   ! Get the atom positions and ADP's in "X"
!      X :: VEC{REAL}, OUT
!   ENSURE(X.dim==9*.n_atom, "wrong size, X")
!      n,base :: INT
!      do n = 1,.n_atom    ! get parameters into X
!         base = (n-1) * 9
!         X(base+1) = .atom(n).pos(1)
!         X(base+2) = .atom(n).pos(2)
!         X(base+3) = .atom(n).pos(3)
!         X(base+4) = .atom(n).thermal_tensor(1,1)
!         X(base+5) = .atom(n).thermal_tensor(2,2)
!         X(base+6) = .atom(n).thermal_tensor(3,3)
!         X(base+7) = .atom(n).thermal_tensor(1,2)
!         X(base+8) = .atom(n).thermal_tensor(1,3)
!         X(base+9) = .atom(n).thermal_tensor(2,3)
!      end
!   end
!
!   set_atom_parameters(X) ::: private
!   ! Set the atom positions and ADP's from "X"
!      X :: VEC{REAL}, IN
!   ENSURE(X.dim==9*.n_atom, "wrong size, X")
!   ENSURE(.crystal.created, "no crystal")
!      n,base :: INT
!      do n = 1,.n_atom    ! set parameters from X
!         base = (n-1) * 9
!         .atom(n).pos(1)              = X(base+1)
!         .atom(n).pos(2)              = X(base+2)
!         .atom(n).pos(3)              = X(base+3)
!         .atom(n).thermal_tensor(1,1) = X(base+4)
!         .atom(n).thermal_tensor(2,2) = X(base+5)
!         .atom(n).thermal_tensor(3,3) = X(base+6)
!         .atom(n).thermal_tensor(1,2) = X(base+7)
!         .atom(n).thermal_tensor(1,3) = X(base+8)
!         .atom(n).thermal_tensor(2,3) = X(base+9)
!         .atom(n).thermal_tensor(2,1) = .atom(n).thermal_tensor(1,2)
!         .atom(n).thermal_tensor(3,1) = .atom(n).thermal_tensor(1,3)
!         .atom(n).thermal_tensor(3,2) = .atom(n).thermal_tensor(2,3)
!      end
!    ! .crystal.destroy_asymmetric_unit
!    ! .crystal.make_fragment_data(.atom)
!    ! .MAIN:force_thermal_symmetry
!   end

!  ************************************************
!  Thermal parameter fitting using normal equations
!  ************************************************

!   fit_ADPs_normal_asym ::: leaky
!   ! Fit the thermal parameters (ADP's) to the calculated structure
!   ! factors.  Uses normal equations. Uses asymmetric unit atoms.
!   ENSURE(.atom.created, "no atoms to fit")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.data.thermal_smearing_model=="stewart","thermal smearing model must be stewart, so far")
!   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
!
!     U,U_old,dU :: VEC{REAL}*
!     n_p,iter :: INT
!     chi2,chi2_old,tol :: REAL
!
!   ! sf_d :: MAT{REAL}*
!   ! dchi2 :: VEC{REAL}*
!
!     ! Don't optimise these, but they can be preset
!     .crystal.data.optimise_extinction = FALSE
!     .crystal.data.optimise_scale = FALSE
!
!     n_p = 6*.crystal.asymmetric_unit_atom.dim
!     U.create(n_p)
!     U_old.create(n_p)
!     dU.create(n_p)
!
!   ! sf_d.create(.crystal.n_refl,n_p)
!   ! dchi2.create(n_p)
!
!     .MAIN:get_ADPs_asym(U)
!     .atom.put_thermal_tensors
!
!     chi2_old = huge(ONE)
!     iter = 0
!
!     do
!
!        iter = iter + 1
!
!        .MAIN:get_ADP_shifts_asym(U,dU,chi2) 
!
!   ! stdout.text("U:")
!   ! stdout.put(U,"column")
!   ! stdout.text("dU:")
!   ! stdout.put(dU,"column")
!   ! stop
!
!   ! .MAIN:get_fd_chi2_derivatives(U,dchi2) 
!   ! stdout.text("dchi2:")
!   ! stdout.put(dchi2,"column")
!   ! .MAIN:get_fd_sf_derivatives(U,sf_d) 
!   ! stdout.text("sf_d:")
!   ! stdout.put(sf_d)
!   ! stop
!
!        tol = maxval(abs(dU))
!        stdout.show("chi2 =",chi2)
!        stdout.show("tol  =",tol)
!        .put_atom_thermal_tensors
!
!        if (tol<TOL(3)) then
!           stdout.text("Converged.")
!           exit
!        end
!        if (chi2_old<chi2) then
!           U = U_old
!           chi2 = chi2_old
!           stdout.text("Chi2 has increased.")
!           exit
!        end
!        if (iter>100) then
!           stdout.text("Exceeded maximum iterations.")
!           exit
!        end
!
!        chi2_old = chi2
!        U_old = U
!        U = U + dU
!
!     end
!
!     .MAIN:set_ADPs_asym(U)
!
!     dU.destroy; U_old.destroy; U.destroy
!
!   end
!
!   get_ADP_shifts_asym(U,dU,chi2) 
!   ! Evaluate the the "shifts" in a given set of ADP's "U" by solving
!   ! the normal equations.
!     U :: VEC{REAL}, IN
!     dU :: VEC{REAL}, OUT
!     chi2  :: REAL, OUT
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
!   ENSURE(U.dim==6*.crystal.asymmetric_unit_atom.dim, "wrong size, U")
!
!     sf_deriv,sf_deriv_eq :: MAT{CPX}*
!     k_pt :: MAT{REAL}*
!     n_refl,n_k,n_p :: INT
!
!   ! dchi2 :: VEC{REAL}*
!
!     ! Constants
!     n_refl = .crystal.n_refl
!     n_k = .crystal.n_unique_SF_k_pts
!     n_p = U.dim
!
!     ! Set the ADP's
!     .MAIN:set_ADPs_asym(U)
!
!     ! Make the structure factors
!     .make_x_structure_factors
!     chi2 = .crystal.F_chi2
!
!     ! Make the symetry related k points
!     k_pt.create(n_k,3)
!     .crystal.make_unique_SF_k_pts(k_pt)
!
!     ! Make the symmetry related derivative SF's
!     sf_deriv.create(n_refl,n_p) ! d_Fc/d_U
!     sf_deriv_eq.create(n_k,n_p)
!     .MAIN:make_unique_d_ft_dU(sf_deriv_eq,k_pt,.density_matrix.restricted)
!
!     ! Get the derivative SF's
!     .crystal.sum_unique_sf_derivs_t(sf_deriv,sf_deriv_eq)
!     sf_deriv_eq.destroy
!
!     ! Get the shifts dU
!     .crystal.solve_normal_equations(dU,sf_deriv)
!
!   ! ! Below checked by FD
!   ! dchi2.create(n_p)
!   ! .crystal.d_chi2_dX(dchi2,sf_deriv)
!   ! stdout.text("dchi2:")
!   ! stdout.put(dchi2,"column")
!   ! dchi2.destroy
!
!     sf_deriv.destroy
!     k_pt.destroy
!
!   end
!
!   fit_ADPs_normal ::: leaky
!   ! Fit the thermal parameters (ADP's) to the calculated structure
!   ! factors.  Uses normal equations.
!   ENSURE(.atom.created, "no atoms to fit")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.data.thermal_smearing_model=="stewart","thermal smearing model must be stewart, so far")
!
!     U,Uo,dU :: VEC{REAL}*
!     n_p :: INT
!     chi2,tol :: REAL
!
!   ! sf_d :: MAT{REAL}*
!   ! dchi2 :: VEC{REAL}*
!
!     ! Don't optimise these, but they can be preset
!     .crystal.data.optimise_extinction = FALSE
!     .crystal.data.optimise_scale = FALSE
!
!     n_p = 6*.n_atom 
!     U.create(n_p)
!     Uo.create(n_p)
!     dU.create(n_p)
!
!   ! sf_d.create(.crystal.n_refl,n_p)
!   ! dchi2.create(n_p)
!
!     .MAIN:get_ADPs(U)
!     .atom.put_thermal_tensors
!
!     do
!
!        .MAIN:get_ADP_shifts(U,dU,chi2) 
!
!        ! Force thermal symmetry
!        Uo = U
!        U  = U + dU
!        .MAIN:set_ADPs(U)
!        .MAIN:get_ADPs(U)
!        dU = U - Uo
!     stdout.text("Uo:")
!     stdout.put(Uo,"column")
!     stdout.text("U:")
!     stdout.put(U,"column")
!     stdout.text("dU:")
!     stdout.put(dU,"column")
!
!   ! .MAIN:get_fd_chi2_derivatives(U,dchi2) 
!   ! stdout.text("dchi2:")
!   ! stdout.put(dchi2,"column")
!   ! .MAIN:get_fd_sf_derivatives(U,sf_d) 
!   ! stdout.text("sf_d:")
!   ! stdout.put(sf_d)
!   ! stop
!        tol = maxval(abs(dU))
!        stdout.show("chi2 =",chi2)
!        stdout.show("tol  =",tol)
!        .put_atom_thermal_tensors
!        if (tol<TOL(3)) exit
!     end
!
!     dU.destroy; U.destroy
!
!   end
!
!   get_ADP_shifts(U,dU,chi2) 
!   ! Evaluate the the "shifts" in a given set of ADP's "U" by solving
!   ! the normal equations.
!     U :: VEC{REAL}, IN
!     dU :: VEC{REAL}, OUT
!     chi2  :: REAL, OUT
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
!   ENSURE(U.dim==6*.n_atom, "wrong size, U")
!
!     sf_deriv,sf_deriv_eq :: MAT{CPX}*
!     k_pts :: MAT{REAL}*
!     n_refl,n_k,n_p :: INT
!
!   ! dchi2 :: VEC{REAL}*
!
!     ! Constants
!     n_refl = .crystal.n_refl
!     n_k = .crystal.n_unique_SF_k_pts
!     n_p = U.dim
!
!     ! Set the ADP's
!     .MAIN:set_ADPs(U)
!
!     ! Make the structure factors
!     .make_x_structure_factors
!     chi2 = .crystal.F_chi2
!
!     ! Make the symetry related k points
!     k_pts.create(n_k,3)
!     .crystal.make_unique_SF_k_pts(k_pts)
!
!     ! Make the symmetry related derivative SF's
!     sf_deriv.create(n_refl,n_p) ! d_Fc/d_U
!     sf_deriv_eq.create(n_p,n_k)
!     .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pts)
!
!     ! Get the derivative SF's
!     .crystal.sum_unique_sf_derivs(sf_deriv,sf_deriv_eq)
!     sf_deriv_eq.destroy
!
!     ! Get the shifts dU
!     .crystal.solve_normal_equations(dU,sf_deriv)
!
!   ! ! Below checked by FD
!   ! dchi2.create(n_p)
!   ! .crystal.d_chi2_dX(dchi2,sf_deriv)
!   ! stdout.text("dchi2:")
!   ! stdout.put(dchi2,"column")
!   ! dchi2.destroy
!
!     sf_deriv.destroy
!     k_pts.destroy
!
!   end
!
!   get_fd_sf_derivatives(U,sf_d) 
!   ! Evaluate the the "shifts" in a given set of ADP's "U" by solving
!   ! the normal equations.
!     U :: VEC{REAL}
!     sf_d :: MAT{REAL}, OUT
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
!   ENSURE(U.dim==.n_atom*6, "wrong size, U")
!
!     n_refl,n_k,n_p, i,s :: INT
!     del,chi2 :: REAL
!
!     ! Constants
!     n_refl = .crystal.n_refl
!     n_k = .crystal.n_unique_SF_k_pts
!     n_p = U.dim
!     del = TOL(3)
!
!     sf_d = ZERO
!
!     do i = 1,n_p
!     do s = -1,1,2
!
!        U(i) = U(i) + s*del
!
!        ! Set the ADP's
!        .MAIN:set_ADPs(U)
!
!        ! Make the structure factors
!        .make_x_structure_factors
!
!        sf_d(:,i) = sf_d(:,i) + s*.crystal.data.reflections.F_pred/(TWO*del)
!
!        U(i) = U(i) - s*del
!
!     end
!     end
!
!   end
!
!   get_fd_chi2_derivatives(U,dchi2) 
!   ! Evaluate the the "shifts" in a given set of ADP's "U" by solving
!   ! the normal equations.
!     U :: VEC{REAL}
!     dchi2 :: VEC{REAL}, OUT
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.density_matrix.created, "no density matrix")
!   ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
!   ENSURE(U.dim==.n_atom*6, "wrong size, U")
!
!     n_refl,n_k,n_p, i,s :: INT
!     del,chi2 :: REAL
!
!     ! Constants
!     n_refl = .crystal.n_refl
!     n_k = .crystal.n_unique_SF_k_pts
!     n_p = U.dim
!     del = TOL(3)
!
!     dchi2 = ZERO
!
!     do i = 1,n_p
!     do s = -1,1,2
!
!        U(i) = U(i) + s*del
!
!        ! Set the ADP's
!        .MAIN:set_ADPs(U)
!
!        ! Make the structure factors
!        .make_x_structure_factors
!        chi2 = .crystal.F_chi2
!
!        dchi2(i) = dchi2(i) + s*chi2/(TWO*del)
!
!        U(i) = U(i) - s*del
!
!     end
!     end
!
!   end

!  *************************
!  Thermal parameter fitting
!  *************************

!   fit_ADPs_asym_ls ::: leaky
!   ! Fit the thermal parameters to the calculated structure factors.
!   ! This fits the atoms in the asymmetric unit, but copies out the
!   ! ADP's to the current fragment. Uses a line search method.
!     self :: PTR
!   ENSURE(.atom.created, "no atoms to fit")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.data.created,"no crystal data")
!   ENSURE(.crystal.data.thermal_smearing_model=="stewart","thermal smearing model must be stewart, so far")
!   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
! ! ENSURE(NOT .crystal.data.optimise_extinction,"cannot optimise extinction while refining thermal parameters")
!
!     chi2_min :: REAL
!     U :: VEC{REAL}*
!     n_p :: INT
!
!     n_p = 6*.crystal.asymmetric_unit_atom.dim
!     U.create(n_p)
!
! !   .crystal.optimise_extinction = FALSE
! !   .crystal.optimise_scale = FALSE
!
!     .MAIN:get_ADPs_asym(U)
!     .atom.put_thermal_tensors
!   ! .make_x_structure_factors
!   ! .put_crystal_reflection_data
!
!   ! .MAIN:set_ADPs_asym(U)
!   ! .atom.put_thermal_tensors
!   ! .make_x_structure_factors
!   ! .put_crystal_reflection_data
!   ! stop
!
!     saved_self => self
!     VEC{REAL}:minimise_BFGS_v2(MOLECULE.MAIN::d_chi2_dU_asym,U,chi2_min,tol=TOL(4),gtol=TOL(4),step=TOL(4))
!
!     U.destroy
!
!   end
!
!   d_chi2_dU_asym(U,chi2,dchi2) ::: public, leaky, selfless
!   ! Evaluate the structure factor chi2.
!     U  :: VEC{REAL}, IN
!     chi2  :: REAL, OUT
!     dchi2 :: VEC{REAL}, optional, OUT
!
!     sf_deriv,sf_deriv_eq :: MAT{CPX}*
!     n_refl,n_k,n_p :: INT
!     k_pt :: MAT{REAL}*
!     self :: MOLECULE*
!
!     ! Set self
!     self => saved_self
!     ENSURE(.crystal.created, "no crystal")
!     ENSURE(.density_matrix.created, "no density matrix")
!     ENSURE(.density_matrix.restricted.created, "no restricted density matrix")
!
!     ! No. of parameters
!     n_refl = .crystal.n_refl
!     n_k = .crystal.n_unique_SF_k_pts
!     n_p = U.dim
!
!     ! Set the ADP's
!     .MAIN:set_ADPs_asym(U)
!
!     ! Make the structure factors
!     .make_x_structure_factors
!     chi2 = .crystal.F_chi2
!     stdout.show("new chi2 =",chi2)
!
!     ! Return if no derivatives needed
!     if (NOT present(dchi2)) return
!
!     ! Make the symmetry related k's
!     k_pt.create(n_k,3)
!     .crystal.make_unique_SF_k_pts(k_pt)
!
!     ! Make the symmetry related derivative SF's
!     sf_deriv.create(n_refl,n_p) ! d_Fc/d_U
!     sf_deriv_eq.create(n_k,n_p)
!     .MAIN:make_unique_d_ft_dU(sf_deriv_eq,k_pt,.density_matrix.restricted)
!
!     ! Get the derivative SF's
!     .crystal.sum_unique_sf_derivs_t(sf_deriv,sf_deriv_eq)
!     sf_deriv_eq.destroy
!
!     ! Do the derivative with respect to chi2
!     .crystal.d_chi2_dX(dchi2,sf_deriv)
!     sf_deriv.destroy
!     k_pt.destroy
!
!     ! Output current ADP's
!     .put_atom_thermal_tensors
!
!   end
!
!   make_unique_d_ft_dU(res,k_pt,dens)
!   ! Return "res", the derivatives of the complex structure factors
!   ! evaluated at "k_pt" with respect to the .atom ADP's, using the
!   ! density matrix "dens". Only the symmetry unique atom derivatives
!   ! are done.
!     res :: MAT{CPX}, target
!     k_pt :: MAT{REAL}, IN
!     dens :: MAT{REAL}, IN, target
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
!
!     ft_ab2,tmp1,tmp2,tmpa1,tmpa2,tmpa3,tmpa4,tmpa5,tmpa6 :: CPX
!     k_max,k,fa,fb,la,lb,q,atom_a,atom_b,basea,baseb :: INT
!     delta,g,separation,x,y,z,z2 :: REAL
!     diff :: VEC{REAL}(3)
!     sh :: SHELL2
!     ft_ab :: MAT3{CPX}*
!     dens_ba :: MAT{REAL}*
!     cutoff :: REAL
!     unique_a,unique_b,skip :: BIN
!
!     k_max = k_pt.dim1
!     cutoff = TOL(10) / .n_shell_pairs
!     res = ZERO
!
!     parallel do q = 1, .n_shell_pairs
!       .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!       unique_a = atom_a==.crystal.unique_atom_for_frag_atom(atom_a)
!       unique_b = atom_b==.crystal.unique_atom_for_frag_atom(atom_b)
!       skip = sh.skip_ft(cutoff)
!       if (skip OR NOT (unique_a OR unique_b)) then
!         sh.destroy_ptr_part
!         cycle
!       end
!       ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp)
!       .make_ft_pair(ft_ab,k_pt,sh,atom_a,atom_b)
!       dens_ba => dens(fb:lb,fa:la)
!       if (fa/=fb) ft_ab = TWO * ft_ab ! count off-diagonals twice.
!       diff = .atom(atom_a).pos - .atom(atom_b).pos
!       separation = diff.norm
!       g=HALF
!       if (separation > 2.5d0) g=QUARTER
!       g = g * (-HALF) ! k_pt is 2pi * Bh so formula was divided by 4pi^2.
!
!       basea = 6*(atom_a-1)
!       if (atom_a == atom_b) then
!         delta = TWO * g
!         do k = 1,k_max
!           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * delta
!           x = k_pt(k,1)           ! SBh_x
!           y = k_pt(k,2)           ! SBh_y
!           z = k_pt(k,3)           ! SBh_z
!           tmp1 = ft_ab2 * x
!           tmp2 = ft_ab2 * y
!           z2 = TWO * z
!           res(k,basea+1) = res(k,basea+1) + tmp1 * x
!           res(k,basea+2) = res(k,basea+2) + tmp1 * y * TWO
!           res(k,basea+3) = res(k,basea+3) + tmp1 * z2
!           res(k,basea+4) = res(k,basea+4) + tmp2 * y
!           res(k,basea+5) = res(k,basea+5) + tmp2 * z2
!           res(k,basea+6) = res(k,basea+6) + ft_ab2 * z * z
!         end
!       else
!         baseb = (atom_b-1) * 6
!         do k = 1,k_max
!           ft_ab2 = ft_ab(k,:,:).trace_product_with(dens_ba) * g
!           x = k_pt(k,1)           ! SBh_x
!           y = k_pt(k,2)           ! SBh_y
!           z = k_pt(k,3)           ! SBh_z
!           tmp1 = ft_ab2 * x
!           tmp2 = ft_ab2 * y
!           z2 = TWO * z
!           tmpa1 = tmp1 * x
!           tmpa2 = tmp1 * y * TWO
!           tmpa3 = tmp1 * z2
!           tmpa4 = tmp2 * y
!           tmpa5 = tmp2 * z2
!           tmpa6 = ft_ab2 * z * z
!           res(k,basea+1) = res(k,basea+1) + tmpa1
!           res(k,basea+2) = res(k,basea+2) + tmpa2
!           res(k,basea+3) = res(k,basea+3) + tmpa3
!           res(k,basea+4) = res(k,basea+4) + tmpa4
!           res(k,basea+5) = res(k,basea+5) + tmpa5
!           res(k,basea+6) = res(k,basea+6) + tmpa6
!           res(k,baseb+1) = res(k,baseb+1) + tmpa1
!           res(k,baseb+2) = res(k,baseb+2) + tmpa2
!           res(k,baseb+3) = res(k,baseb+3) + tmpa3
!           res(k,baseb+4) = res(k,baseb+4) + tmpa4
!           res(k,baseb+5) = res(k,baseb+5) + tmpa5
!           res(k,baseb+6) = res(k,baseb+6) + tmpa6
!         end
!       end
!       ft_ab.destroy
!       sh.destroy_ptr_part
!     end
!     PARALLEL_SUM(res)
!   end
!
!   get_ADPs_asym(U) ::: private
!   ! Get the ADP's from the .atom array and set the ADP's for the
!   ! .crystal.asymmetric_unit_atom's, then copy those to the parameter
!   ! vector "U". The order of the elements in "U" is defined by the
!   ! way the derivatives are evaluated. 
!      U :: VEC{REAL}
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
!   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
!   ENSURE(.crystal.unique_atom_for_frag_atom.created,"no crystal unique_atom_for_frag_atom")
!   ENSURE(.crystal.asym_symop_for_frag_atom.created,"no crystal asym_symop_for_frag_atom")
!   ENSURE(.crystal.frag_atom_for_asym_unit_atom.created,"no crystal frag_atom_for_asym_unit_atom")
!   ENSURE(all(.crystal.frag_atom_for_asym_unit_atom>0),"fragment does not generate unit cell")
!   ENSURE(U.dim==6*.crystal.asymmetric_unit_atom.dim, "wrong size, U")
!
!      n_atom,n,base,a,s :: INT
!      therm :: MAT{REAL}(3,3)
!      seitz :: MAT3{REAL}*
!      atom :: VEC{ATOM}*
!
!      ! Asymmetric unit atoms
!      atom => .crystal.asymmetric_unit_atom
!      n_atom = atom.dim
!
!      ! Copy the ADP's in from unique .atom's
!      seitz => .crystal.xyz_seitz_matrices  
!      do n = 1,.n_atom 
!         if (n/=.crystal.unique_atom_for_frag_atom(n)) cycle
!         a = .crystal.asym_unit_atom_for_frag_atom(n)
!         s = .crystal.asym_symop_for_frag_atom(n)
!       ! atom(a).pos = matmul(.atom(n).pos,seitz(:,:,s))
!       ! atom(a).axis_system = "cartesian"  
!         therm = .atom(n).thermal_tensor                 ! This must be in cartesian axes
!         therm.change_basis_using(seitz(:,:,s))          ! Use R to change U tensor basis
!         atom(a).thermal_tensor = therm                  
!         atom(a).thermal_axis_system = "cartesian"       ! ... in cartesians ...
!      end
!      seitz.destroy
!
!      ! Get ADP's in U array
!      do n = 1,n_atom    
!         base = 6*(n-1) 
!         U(base+1) = atom(n).thermal_tensor(1,1)
!         U(base+2) = atom(n).thermal_tensor(1,2)
!         U(base+3) = atom(n).thermal_tensor(1,3)
!         U(base+4) = atom(n).thermal_tensor(2,2)
!         U(base+5) = atom(n).thermal_tensor(2,3)
!         U(base+6) = atom(n).thermal_tensor(3,3)
!      end
!
!   end
!
!   set_ADPs_asym(U) ::: private
!   ! Set the ADP's for the .crystal.asymmetric_unit_atom's from the
!   ! parameter vector "U" and copy these ADP's by symmetry to the
!   ! .atom array.  The order of the elements in "U" is defined by the
!   ! way the derivatives are evaluated. 
!      U :: VEC{REAL}, IN
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.asymmetric_unit_atom.created,"no crystal asymmetric unit atoms")
!   ENSURE(.crystal.asym_unit_atom_for_frag_atom.created,"no crystal asym_unit_atom_for_frag_atom")
!   ENSURE(.crystal.asym_symop_for_frag_atom.created,"no crystal asym_symop_for_frag_atom")
!   ENSURE(.crystal.frag_atom_for_asym_unit_atom.created,"no crystal frag_atom_for_asym_unit_atom")
!   ENSURE(all(.crystal.frag_atom_for_asym_unit_atom>0),"fragment does not generate unit cell")
!   ENSURE(U.dim==6*.crystal.asymmetric_unit_atom.dim, "wrong size, U")
!
!      n_atom,n,base,a,s :: INT
!      therm :: MAT{REAL}(3,3)
!      seitz :: MAT3{REAL}*
!      atom :: VEC{ATOM}*
!
!      ! Asymmetric unit atoms
!      atom => .crystal.asymmetric_unit_atom
!      n_atom = atom.dim
!
!      ! Set ADP's from U array
!      do n = 1,n_atom  
!         base = 6*(n-1)
!         atom(n).thermal_tensor(1,1) = U(base+1)
!         atom(n).thermal_tensor(1,2) = U(base+2)
!         atom(n).thermal_tensor(1,3) = U(base+3)
!         atom(n).thermal_tensor(2,2) = U(base+4)
!         atom(n).thermal_tensor(2,3) = U(base+5)
!         atom(n).thermal_tensor(3,3) = U(base+6)
!         atom(n).thermal_tensor(2,1) = atom(n).thermal_tensor(1,2)
!         atom(n).thermal_tensor(3,1) = atom(n).thermal_tensor(1,3)
!         atom(n).thermal_tensor(3,2) = atom(n).thermal_tensor(2,3)
!      end
!
!      ! Copy the ADP's out to all .atom's
!      seitz => .crystal.transposed_xyz_seitz_matrices    ! transposed !
!      do n = 1,.n_atom 
!         a = .crystal.asym_unit_atom_for_frag_atom(n)
!         s = .crystal.asym_symop_for_frag_atom(n)
!       ! .atom(a).pos = matmul(atom(n).pos,seitz(:,:,s))
!       ! .atom(a).axis_system = "cartesian"  
!         therm = atom(a).thermal_tensor                  ! This must be in cartesian axes
!         therm.change_basis_using(seitz(:,:,s))          ! Use R^T to change U tensor basis
!         .atom(n).thermal_tensor = therm                  
!         .atom(n).thermal_axis_system = "cartesian"      ! ... in cartesians ...
!      end
!      seitz.destroy
!
!   end


!   fit_ADPs_ls ::: leaky
!   ! Fit the thermal parameters to the calculated structure factors.
!   ! This fits the atoms in the asymmetric unit, but copies out the
!   ! ADP's to the current fragment. Uses a line search method.
!     self :: PTR
!   ENSURE(.atom.created, "no atoms to fit")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.data.created,"no crystal data")
!   ENSURE(.crystal.data.thermal_smearing_model=="stewart","thermal smearing model must be stewart, so far")
! ! ENSURE(NOT .crystal.data.optimise_extinction,"cannot optimise extinction while refining thermal parameters")
!
!     chi2_min :: REAL
!     U :: VEC{REAL}*
!     n_p :: INT
!
!     n_p = .n_atom * 6
!     U.create(n_p)
!
! !   .crystal.optimise_extinction = FALSE
! !   .crystal.optimise_scale = FALSE
!
!     .MAIN:get_ADPs(U)
!
!     .atom.put_thermal_tensors
!
!     saved_self => self
!     VEC{REAL}:minimise_BFGS_v2(MOLECULE.MAIN::d_chi2_dU,U,chi2_min,tol=TOL(4),gtol=TOL(4),step=TOL(4))
!
!     U.destroy
!
!   end
!
!   d_chi2_dU(U,f,df) ::: public, leaky, selfless
!   ! Evaluate the structure factor chi2.
!     U  :: VEC{REAL}, IN
!     f  :: REAL, OUT
!     df :: VEC{REAL}, optional, OUT
!
!     sf_deriv,sf_deriv_eq :: MAT{CPX}*
!     k_pts :: MAT{REAL}*
!     genre :: STR
!     self :: MOLECULE*
!
!     ! Set self
!     self => saved_self
!     ENSURE(.crystal.created, "no crystal")
!     ENSURE(.density_matrix.created, "no density matrix")
!
!     ! Set the ADP's
!     .MAIN:set_ADPs(U)
!
!     ! Make the structure factors
!     .make_x_structure_factors
!     f = .crystal.F_chi2
!     stdout.show("new F_chi2 =",f)
!
!     ! Return if no derivatives needed
!     if (NOT present(df)) return
!
!     ! Make the symetry related k points
!     k_pts.create(.crystal.n_unique_SF_k_pts,3)
!     .crystal.make_unique_SF_k_pts(k_pts)
!
!     ! Make the symmetry related derivative SF's
!     sf_deriv.create(.crystal.n_refl,.n_atom*6) ! d_Fc/d_U
!     sf_deriv_eq.create(.n_atom*6,.crystal.n_unique_SF_k_pts)
!     genre = .density_matrix.spinorbital_kind
!     if (genre.includes("complex")) then
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted_complex,k_pts)
!     else
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pts)
!     end
!
!     ! Get the derivative SF's
!     .crystal.sum_unique_sf_derivs(sf_deriv,sf_deriv_eq)
!     sf_deriv_eq.destroy
!
!     ! Do the derivative with respect to chi2
!     .crystal.d_chi2_dX(df,sf_deriv)
!     sf_deriv.destroy
!     k_pts.destroy
!
!     ! Output current ADP's
!     .put_atom_thermal_tensors
!
!   end
!
!   get_ADPs(U) ::: private
!   ! Get a set of thermal parameters from the atoms, assuming
!   ! "U" is a vector of the independent thermal parameters.
!      U :: VEC{REAL}
!   ENSURE(size(U)==6*.n_atom, "wrong size, U")
!      n,base :: INT
!      do n = 1,.n_atom      ! get thermal parameters into array
!        base = (n-1) * 6
!        U(base+1) = .atom(n).thermal_tensor(1,1)
!        U(base+2) = .atom(n).thermal_tensor(1,2)
!        U(base+3) = .atom(n).thermal_tensor(1,3)
!        U(base+4) = .atom(n).thermal_tensor(2,2)
!        U(base+5) = .atom(n).thermal_tensor(2,3)
!        U(base+6) = .atom(n).thermal_tensor(3,3)
!      end
!   end
!
!   set_ADPs(U) ::: private
!   ! Set a new set of thermal parameters for all the atoms, assuming
!   ! "U" is a vector of the independent thermal parameters.
!      U :: VEC{REAL}, IN
!   ENSURE(size(U)==6*.n_atom, "wrong size, U")
!      n,base :: INT
!      do n = 1,.n_atom      ! get thermal parameters into array
!        base = (n-1) * 6
!        .atom(n).thermal_tensor(1,1) = U(base+1)
!        .atom(n).thermal_tensor(1,2) = U(base+2)
!        .atom(n).thermal_tensor(1,3) = U(base+3)
!        .atom(n).thermal_tensor(2,2) = U(base+4)
!        .atom(n).thermal_tensor(2,3) = U(base+5)
!        .atom(n).thermal_tensor(3,3) = U(base+6)
!        .atom(n).thermal_tensor(2,1) = .atom(n).thermal_tensor(1,2)
!        .atom(n).thermal_tensor(3,1) = .atom(n).thermal_tensor(1,3)
!        .atom(n).thermal_tensor(3,2) = .atom(n).thermal_tensor(2,3)
!      end
!      .MAIN:force_thermal_symmetry
!   end

!   sfchi2(U) result (res) ::: public, leaky, selfless
!   ! Evaluate the structure factor chi2.
!     U :: VEC{REAL}, IN
!     res :: REAL
!     self :: MOLECULE*
!     self => saved_self
!     ENSURE(.crystal.created, "no crystal")
!     .MAIN:set_ADPs(U)
!     .make_x_structure_factors
!     res = .crystal.F_chi2
!     stdout.show("new F_chi2 =",res)
!   end
!
!   d_sfchi2_d_thermal(U) result (res) ::: public, leaky, selfless
!   ! Evaluate the gradient of the structure factor chi2 with respect to the
!   ! unique thermal parameters.
!   ! Size of res is [n_atom * 6].
!     U :: VEC{REAL}, IN
!     res :: VEC{REAL}(size(U))
!     sf_deriv,sf_deriv_eq :: MAT{CPX}*
!     k_pts :: MAT{REAL}*
!     genre :: STR
!     self :: MOLECULE*
!     self => saved_self
!     ENSURE(.crystal.created, "no crystal")
!     ENSURE(.density_matrix.created, "no density matrix")
!  print *,"A ="
!     .MAIN:set_ADPs(U)
!  print *,"B ="
!     k_pts.create(.crystal.n_unique_SF_k_pts,3)
!     .crystal.make_unique_SF_k_pts(k_pts)
!  print *,"C ="
!     sf_deriv.create( .crystal.n_refl, .n_atom * 6) ! d_Fc/d_U
!     sf_deriv_eq.create(.n_atom * 6,.crystal.n_unique_SF_k_pts)
!     genre = .density_matrix.spinorbital_kind
!     if (genre.includes("complex")) then
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted_complex,k_pts)
!     else
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pts)
!     end
!  print *,"D ="
!     .crystal.sum_unique_sf_derivs(sf_deriv,sf_deriv_eq)
!  print *,"E ="
!     sf_deriv_eq.destroy
!     ! Do the derivative with respect to chi2
!     res = .crystal.d_chi2_dU(sf_deriv)
!  print *,"F ="
!     sf_deriv.destroy
!     k_pts.destroy
!     .put_atom_thermal_tensors
!  print *,"G ="
!  stdout.put(res,"column")
!   end


!   fit_ADPs_plus_se_ls ::: leaky
!   ! Fit the ADP's and extinction and scale factors to the structure
!   ! factors.  Uses a line search method.
!     self :: PTR
!   ENSURE(.atom.created, "no atoms to fit")
!   ENSURE(.crystal.created, "no crystal")
!   ENSURE(.crystal.data.created,"no crystal data")
!   ENSURE(.crystal.data.thermal_smearing_model=="stewart","thermal smearing model must be stewart, so far")
!     chi2_min :: REAL
!     U :: VEC{REAL}*
!     n_p :: INT
!
!     n_p = 6*.n_atom + 2
!     U.create(n_p)
!
!     .MAIN:get_ADPs_plus_se(U)
!     .atom.put_thermal_tensors
!
!     saved_self => self
!     VEC{REAL}:minimise_BFGS_v2(MOLECULE.MAIN::d_chi2_dU_plus_se,U,chi2_min,tol=TOL(4),gtol=TOL(4),step=TOL(4))
!
!     U.destroy
!
!   end
!
!   get_ADPs_plus_se(U) ::: private
!   ! Get the ADP's from the atoms, and extinction and scale
!   ! factors, in a paremeter vector "U".
!      U :: VEC{REAL}, OUT
!   ENSURE(U.dim==6*.n_atom+2, "wrong size, U")
!      n,base :: INT
!      do n = 1,.n_atom      ! get thermal parameters into array
!        base = (n-1) * 6
!        U(base+1) = .atom(n).thermal_tensor(1,1)
!        U(base+2) = .atom(n).thermal_tensor(1,2)
!        U(base+3) = .atom(n).thermal_tensor(1,3)
!        U(base+4) = .atom(n).thermal_tensor(2,2)
!        U(base+5) = .atom(n).thermal_tensor(2,3)
!        U(base+6) = .atom(n).thermal_tensor(3,3)
!      end
!      U(6*.n_atom+1) = .crystal.data.extinction_factor
!      U(6*.n_atom+2) = .crystal.data.scale_factor
!   end
!
!   set_ADPs_plus_se(U) ::: private
!   ! Set the ADP's of the atoms, and extinction and scale
!   ! factors, from the paremeter vector "U".
!      U :: VEC{REAL}, IN
!   ENSURE(U.dim==6*.n_atom+2, "wrong size, U")
!      n,base :: INT
!      do n = 1,.n_atom      ! get thermal parameters into array
!        base = (n-1) * 6
!        .atom(n).thermal_tensor(1,1) = U(base+1)
!        .atom(n).thermal_tensor(1,2) = U(base+2)
!        .atom(n).thermal_tensor(1,3) = U(base+3)
!        .atom(n).thermal_tensor(2,2) = U(base+4)
!        .atom(n).thermal_tensor(2,3) = U(base+5)
!        .atom(n).thermal_tensor(3,3) = U(base+6)
!        .atom(n).thermal_tensor(2,1) = .atom(n).thermal_tensor(1,2)
!        .atom(n).thermal_tensor(3,1) = .atom(n).thermal_tensor(1,3)
!        .atom(n).thermal_tensor(3,2) = .atom(n).thermal_tensor(2,3)
!      end
!      .crystal.data.extinction_factor = U(6*.n_atom+1)
!      .crystal.data.scale_factor      = U(6*.n_atom+2)
!      .MAIN:force_thermal_symmetry
!   end
!
!   d_chi2_dU_plus_se(U,chi2,dchi2) ::: public, leaky, selfless
!   ! Evaluate the structure factor chi2.
!     U  :: VEC{REAL}, IN
!     chi2  :: REAL, OUT
!     dchi2 :: VEC{REAL}, optional, OUT
!
!     sf_deriv,sf_deriv_eq :: MAT{CPX}*
!     k_pt :: MAT{REAL}*
!     genre :: STR
!     n_k,n_refl,n_p :: INT
!     self :: MOLECULE*
!
!     ! Set self
!     self => saved_self
!
!     ! Check
!     ENSURE(.crystal.created, "no crystal")
!     ENSURE(.density_matrix.created, "no density matrix")
!     ENSURE(U.dim==6*.n_atom+2, "wrong size, U")
!     if (present(dchi2)) then
!     ENSURE(U.dim==dchi2.dim, "wrong size, dchi2")
!     end
!
!     ! Constants
!     n_k = .crystal.n_unique_SF_k_pts
!     n_refl = .crystal.n_refl
!     n_p = 6*.n_atom
!
!     ! Set the ADP's
!     .MAIN:set_ADPs_plus_se(U)
!
!     ! Make the structure factors
!     .make_x_structure_factors
!     chi2 = .crystal.F_chi2
!     stdout.show("new F_chi2 =",chi2)
!
!     ! Return if no derivatives needed
!     if (NOT present(dchi2)) return
!
!     ! Make the symetry related k points
!     k_pt.create(n_k,3)
!     .crystal.make_unique_SF_k_pts(k_pt)
!
!     ! Make the symmetry related derivative SF's
!     sf_deriv.create(n_refl,n_p) ! d_Fc/d_U
!     sf_deriv_eq.create(n_p,n_k)
!     genre = .density_matrix.spinorbital_kind
!     if (genre.includes("complex")) then
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted_complex,k_pt)
!     else
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pt)
!     end
!
!     ! Get the derivative SF's
!     .crystal.sum_unique_sf_derivs(sf_deriv,sf_deriv_eq)
!     sf_deriv_eq.destroy
!
!     ! Do the derivative with respect to chi2
!     ! Also extinction and scale factors.
!     .crystal.d_chi2_dX_plus_se(dchi2,sf_deriv)
!     sf_deriv.destroy
!     k_pt.destroy
!
!     ! Output current ADP's
!     .put_atom_thermal_tensors
!
!   end


   force_thermal_symmetry
   ! Impose crystal symmetry on the thermal tensors.
   ENSURE(.crystal.created,"crystal not created")
   ENSURE(.n_atom==.crystal.n_fragment_atoms,"inconsistent crystal fragment")
     n,u,s,n_unique :: INT
     unique_thermals,seitz :: MAT3{REAL}*
     thermal,unit,seitz_t,seitz_inv :: MAT{REAL}(3,3)
     n_equiv :: VEC{INT}*

     ! Setup
     n_unique = .crystal.n_unique_frag_atoms
     seitz => .crystal.spacegroup.seitz
     unique_thermals.create(3,3,n_unique)
     unit.to_unit_matrix
     unique_thermals = ZERO
     n_equiv.create(n_unique)
     n_equiv = 0

     ! Change to crystal coordinates.
     do n = 1,.n_atom
       u = .crystal.unique_atom_for_frag_atom(n)
       s = .crystal.asym_symop_for_frag_atom(n)
       seitz_t = transpose(seitz(1:3,1:3,s))
       seitz_t(1,1) = seitz_t(1,1) + TOL(8) ! lapack bug
       seitz_inv.to_inverse_of(seitz_t)
       thermal = .atom(n).thermal_tensor
       thermal.change_basis_using(.crystal.unit_cell.reciprocal_U_matrix)
       thermal.change_basis_using(seitz_inv)
       unique_thermals(:,:,u) = unique_thermals(:,:,u) + thermal
       n_equiv(u) = n_equiv(u) + 1
     end

     ! Average them.
     do u = 1,n_unique
       unique_thermals(:,:,u) = unique_thermals(:,:,u) / n_equiv(u)
     end

     ! Change back to cartesians.
     do n = 1,.n_atom
       u = .crystal.unique_atom_for_frag_atom(n)
       s = .crystal.asym_symop_for_frag_atom(n)
       thermal = unique_thermals(:,:,u)
       thermal.change_basis_using(transpose(seitz(1:3,1:3,s)))
       thermal.change_basis_using(.crystal.unit_cell.direct_U_matrix)
       .atom(n).thermal_tensor = thermal
     end

     n_equiv.destroy
     unique_thermals.destroy

   end


!*******************************************************************************
!                      Atom position fitting
!*******************************************************************************

!   get_atom_positions(R) ::: private
!   ! Get a set of atom positions "R"
!      R :: VEC{REAL}
!   ENSURE(R.dim==3*.n_atom, "wrong size, R")
!      n,base :: INT
!      do n = 1,.n_atom      ! get thermal parameters into array
!        base = (n-1) * 3
!        R(base+1) = .atom(n).pos(1)
!        R(base+2) = .atom(n).pos(2)
!        R(base+3) = .atom(n).pos(3)
!      end
!   end
!
!   set_atom_positions(R) ::: private
!   ! Set the atom positions from "R"
!      R :: VEC{REAL}
!   ENSURE(R.dim==3*.n_atom, "wrong size, R")
!      n,base :: INT
!      do n = 1,.n_atom      ! get thermal parameters into array
!        base = (n-1) * 3
!        .atom(n).pos(1) = R(base+1)
!        .atom(n).pos(2) = R(base+2)
!        .atom(n).pos(3) = R(base+3)
!      end
!   end
!
!   chi2_pos(R) result (res) ::: leaky, selfless
!   ! Evaluate the structure factor chi2 as a function of atom
!   ! positions "R"
!     R :: VEC{REAL}
!     res :: REAL
!     self :: MOLECULE*
!     self => saved_self
!     ENSURE(.crystal.created, "no crystal")
!     .MAIN:set_atom_positions(R)
!     .make_x_structure_factors
!     res = .crystal.F_chi2
!     stdout.show("new F_chi2 =",res)
!   end
!
!   d_chi2_pos(R) result (res) ::: leaky, selfless
!   ! Evaluate the derivative of the structure factor chi2 with respect to the
!   ! atom positions "R".
!     R :: VEC{REAL}
!     res :: VEC{REAL}(size(U))
!     sf_deriv,sf_deriv_eq :: MAT{CPX}*
!     k_pts :: MAT{REAL}*
!     genre :: STR
!     self :: MOLECULE*
!     self => saved_self
!     ENSURE(.crystal.created, "no crystal")
!     ENSURE(.density_matrix.created, "no density matrix")
!     .set_ADPs(U)
!     k_pts.create(.crystal.n_unique_SF_k_pts,3)
!     .crystal.make_unique_SF_k_pts(k_pts)
!     sf_deriv.create( .crystal.n_refl, .n_atom * 6) ! d_Fc/d_U
!     sf_deriv_eq.create(.n_atom * 6,.crystal.n_unique_SF_k_pts)
!     genre = .density_matrix.spinorbital_kind
!     if (genre.includes("complex")) then
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted_complex,k_pts)
!     else
!       .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pts)
!     end
!     .crystal.sum_unique_sf_derivs(sf_deriv,sf_deriv_eq)
!     sf_deriv_eq.destroy
!     ! Do the derivative with respect to chi2
!     res = .crystal.d_chi2_dU(sf_deriv)
!     sf_deriv.destroy
!     k_pts.destroy
!   end

!   make_ft(res,dens,k_pts)
!   ! Fourier transform of a density described by AO density matrix dens
!   ! evaluated at a series of reciprocal space points k_pts
!   ! Size of res is [size(k_pts,1)]
!      dens :: MAT{REAL}, target
!      k_pts :: MAT{REAL}, IN
!      res :: VEC{CPX}, OUT
!   ENSURE(.basis_info_made, "no basis info")
!   ENSURE(.atom.created,  "no atom list")
!      k_max,k,fa,fb,la,lb,q,atom_a,atom_b :: INT
!      sh :: SHELL2
!      ft_ab :: MAT3{CPX}*
!      dens_ba :: MAT{REAL}*
!      cutoff :: REAL
!      k_max = size(k_pts,1)
!      cutoff = TOL(10) / .n_shell_pairs
!      res = ZERO
!      parallel do q = 1,.n_shell_pairs
!         .get_precomputed_shell_pair(sh,q,fa,la,fb,lb,atom_a,atom_b)
!         if (sh.skip_ft(cutoff)) then
!           sh.destroy_ptr_part
!           cycle
!         end
!         ft_ab.create(k_max,sh.a.n_comp,sh.b.n_comp)
!         .make_ft_pair(ft_ab,k_pts,sh,atom_a,atom_b)
!!         dens_ba => dens(fb:lb,fa:la) ! P^dagger
!         dens_ba => dens(fa:la,fb:lb)
!         if (fa/=fb) then ! count off-diagonals twice.
!           do k = 1,k_max
!!              res(k) = res(k) + TWO*ft_ab(k,:,:).trace_product_with(dens_ba)
!              res(k) = res(k) + TWO*sum(ft_ab(k,:,:)*dens_ba(:,:))
!           end
!         else
!           do k = 1,k_max
!!              res(k) = res(k) + ft_ab(k,:,:).trace_product_with(dens_ba)
!              res(k) = res(k) + sum(ft_ab(k,:,:)*dens_ba(:,:))
!           end
!         end
!         ft_ab.destroy
!         sh.destroy_ptr_part
!      end
!      PARALLEL_SUM(res)
!   end


   zero_off_atom_density
   ! Zero the off-atom overlap blocks of the density matrix
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.restricted.created,"no restricted density")
      .MAIN:zero_off_atom_blocks(.density_matrix.restricted)
   end

   zero_off_atom_blocks(P)
   ! Zero the off-atom overlap blocks in "P"
      P :: MAT{REAL}
   ENSURE(P.is_square,"wrong shape, P")
   ENSURE(P.dim1==.n_bf,"wrong size, P")
   ENSURE(.atom.created,"no atoms")
      a,b,na,fa,la,nb,fb,lb :: INT
      la = 0
      do a = 1,.n_atom
         na = .atom(a).n_bf
         fa = la + 1
         la = la + na
         lb = 0
         do b = 1,.n_atom
            nb = .atom(b).n_bf
            fb = lb + 1
            lb = lb + nb
            if (a==b) cycle
            P(fa:la,fb:lb) = ZERO
         end
      end
   end


end
