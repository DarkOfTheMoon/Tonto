!-------------------------------------------------------------------------------
!
! SHELL2 : pair of SHELLs
!
! Given two shells, can calculate
!  - Fourier transform of their product, evaluated on a grid
!  - overlap integrals
!  - kinetic energy integrals
!  - nuclear attraction integrals
!
! Based on the Rys method, as described by Lindh et al,
! J. Chem. Phys 84(7) 3963-3974
!
! - overlap (non rys version) and kinetic energy integrals work at least
!   up to (q|q).
! - methods using the rys module are limited up to about (m|m) due to
!   the general rys method algorithm failing.  (As tested with atoms on the
!   same center.  Different centers can go higher, but not recommended).
! - Accuracy at higher than (d|d) has not been tested.
!
! (c) Daniel Grimwood, 1998
!
! $Id$
!-------------------------------------------------------------------------------

module SHELL2

   use TYPES
   use SYSTEM
   use INT
   use IVEC
   use IMAT
   use IMAT3
   use VEC
   use MAT
   use MAT3
   use CMAT
   use CMAT3
   use TEXTFILE
   use RYS
   use GAUSSIAN2
   use SHELL
   use SHELL1

   implicit none         

#include "macros"
#include "shell2.int"

!   type shell2_type
!
!   SHELL1 :: a
!   ! Shell "a" of the pair
!
!   SHELL1 :: b
!   ! Shell "b" of the pair
!
!   end

   DBL, private :: pi212  = 1.1283791670955d+0
   IVEC(9), private :: first_pt = (/1,2,4, 7,11,16,22,29,37/)
   IVEC(9), private :: last_pt  = (/1,3,6,10,15,21,28,36,45/)

   VEC(45), private :: gauss_hermite_pt = (/ &
       0.000000000000000e+0, &
 ! H_11
      -0.707106781186548e+0, 0.707106781186548e+0, &
 ! H_12 H_22
      -1.224744871391590e+0, 0.000000000000000e+0, 1.224744871391590e+0, &
 ! H_13 H_23 H_33
      -1.650680123885780e+0,-0.524647623275290e+0, 0.524647623275290e+0, 1.650680123885780e+0, &
 ! H_*4
      -2.020182870456090e+0,-0.958572464613819e+0, 0.000000000000000e+0, 0.958572464613819e+0, &
 ! H_*5
       2.020182870456090e+0, &
      -2.350604973674000e+0,-1.335849074014000e+0,-0.436077411928000e+0, 0.436077411928000e+0, &
 ! H_*6
       1.335849074014000e+0, 2.350604973674000e+0, &
      -2.651961356835233e+0,-1.673551628767471e+0,-0.816287882858965e+0, 0.000000000000000e+0, &
 ! H_*7
       0.816287882858965e+0, 1.673551628767471e+0, 2.651961356835233e+0, &
      -2.930637420257244e+0,-1.981656756695843e+0,-1.157193712446780e+0,-0.381186990207322e+0, &
 ! H_*8
       0.381186990207322e+0, 1.157193712446780e+0, 1.981656756695843e+0, 2.930637420257244e+0, &
      -3.190993201781528e+0,-2.266580584531843e+0,-1.468553289216668e+0,-0.723551018752838e+0, &
 ! H_*9
       0.000000000000000e+0, 0.723551018752838e+0, 1.468553289216668e+0, 2.266580584531843e+0, &
       3.190993201781528e+0  /)

   VEC(45), private :: gauss_hermite_wt = (/ &
       1.772453850905520e+0, &
 ! W_11
       0.886226925452800e+0, 0.886226925452800e+0, &
 ! W_12 W_22
       0.295408975150900e+0, 1.181635900604000e+0, 0.295408975150900e+0, & ! W_13 W_23 W_33
       8.131283544725000e-2, 8.049140900055000e-1, 8.049140900055000e-1, 8.131283544725000e-2, &
 ! W_*4
       1.995324205905000e-2, 3.936193231522000e-1, 9.453087204829000e-1, 3.936193231522000e-1, &
 ! W_*5
       1.995324205905000e-2, &
       4.530009905509000e-3, 1.570673203229000e-1, 7.246295952244000e-1, 7.246295952244000e-1, &
 ! W_*6
       1.570673203229000e-1, 4.530009905509000e-3, &
       9.717812450995000e-4, 5.451558281913000e-2, 4.256072526101000e-1, 8.102646175568000e-1, &
 ! W_*7
       4.256072526101000e-1, 5.451558281913000e-2, 9.717812450995000e-4, &
       1.996040722114000e-4, 1.707798300741000e-2, 2.078023258149000e-1, 6.611470125582000e-1, &
 ! W_*8
       6.611470125582000e-1, 2.078023258149000e-1, 1.707798300741000e-2, 1.996040722114000e-4, &
       3.960697726326000e-5, 4.943624275537000e-3, 8.847452739438000e-2, 4.326515590026000e-1, &
 ! W_*9
       7.202352156061000e-1, 4.326515590026000e-1, 8.847452739438000e-2, 4.943624275537000e-3, &
       3.960697726326000e-5  /)

contains

  create [leaky]
  ! Creates a shell2 object
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SHELL2_SIZE)
    .nullify_ptr_part
  end

  create(shell_a,shell_b) [leaky]
  ! Create a copy of a shell1 objects
    PTR :: self
    SHELL1, IN :: shell_a,shell_b
    .create
    .copy(shell_a,shell_b)
  end

  create(shell_a,shell_b,pos_a,pos_b) [leaky]
  ! Create a copy of a shell1 objects with positions
    PTR :: self
    SHELL, IN :: shell_a,shell_b
    VEC(3), IN :: pos_a,pos_b
    .create
    .copy(shell_a,shell_b,pos_a,pos_b)
  end

  destroy [leaky]
  ! Destroys a shell2 object
    PTR :: self
    if (.destroyed) return
    .destroy_ptr_part
    DELETE_MEM(SHELL2_SIZE)
    deallocate(self)
  end

  nullify_ptr_part
  ! Nullify the pointer parts of self
     .a.nullify_ptr_part
     .b.nullify_ptr_part
  end

  destroy_ptr_part
  ! Destroy the pointer parts of self
     .a.destroy_ptr_part
     .b.destroy_ptr_part
  end

  created result(res)
  ! Returns true if self has been created
    PTR :: self
    BIN :: res
    res = associated(self)
  end

  destroyed result(res)
  ! Returns true if self has *not* been created
    PTR :: self
    BIN :: res
    res = NOT associated(self)
  end

  put(out)
  ! Put the shell2 information on file "out"
    TEXTFILE :: out
    out.put("Shell a:",flush=1)
    .a.put(out)
    out.put("Shell b:",flush=1)
    .b.put(out)
    out.flush
  end

  copy(shell_a,shell_b) [leaky]
  ! Copy the shell2 using shell1 objects
    SHELL1, IN :: shell_a,shell_b
    .a.copy(shell_a)
    .b.copy(shell_b)
  end

  copy(shell_a,shell_b,pos_a,pos_b) [leaky]
  ! Copy the shell2 using shell objects and positions
    SHELL, IN :: shell_a,shell_b
    VEC, IN :: pos_a,pos_b
    .a.copy(shell_a,pos_a)
    .b.copy(shell_b,pos_b)
  end

  set(shell_a,shell_b)
  ! Set the shell2 using shell1 objects
    SHELL1, IN :: shell_a,shell_b
    .a.set(shell_a)
    .b.set(shell_b)
  end

  set(shell_a,shell_b,pos_a,pos_b)
  ! Copy the shell2 using shell objects
    SHELL, IN :: shell_a,shell_b
    VEC, IN :: pos_a,pos_b
    .a.set(shell_a,pos_a)
    .b.set(shell_b,pos_b)
  end

  normalize_ft(ft)
  ! Multiplies the ft product at a series of k points, by the normalization
  ! factors for the two gaussian shells.
    CMAT3, target :: ft
    CVEC* :: ft_ab
    VEC* :: fac_a,fac_b
    DBL :: fac
    INT :: a,b,n_comp_a,n_comp_b,aaa
    aaa = 0
    if (.a.l<2) aaa = aaa + 1
    if (.b.l<2) aaa = aaa + 2
    select case (aaa)
      case (0)    ! The general case.
        n_comp_a = .a.n_comp; n_comp_b = .b.n_comp
        fac_a.create(n_comp_a); fac_a.normalizing_factors( .a.l )
        fac_b.create(n_comp_b); fac_b.normalizing_factors( .b.l )
        do b = 1, n_comp_b
          fac = fac_b(b)
          do a = 1, n_comp_a
            ft_ab => ft(:,a,b)
            ft_ab(:) = ft_ab(:) * fac * fac_a(a)
          end
        end
        fac_a.destroy
        fac_b.destroy
      case (1)    ! When "a" is an s or p function.
        n_comp_a = .a.n_comp; n_comp_b = .b.n_comp
        fac_b.create(n_comp_b); fac_b.normalizing_factors( .b.l )
        do b = 1, n_comp_b
          fac = fac_b(b)
          do a = 1, n_comp_a
            ft_ab => ft(:,a,b)
            ft_ab(:) = ft_ab(:) * fac
          end
        end
        fac_b.destroy
      case (2)    ! When "b" is an s or p function.
        n_comp_a = .a.n_comp; n_comp_b = .b.n_comp
        fac_a.create(n_comp_a); fac_a.normalizing_factors( .a.l )
        do a = 1, n_comp_a
          fac = fac_a(a)
          do b = 1, n_comp_b
            ft_ab => ft(:,a,b)
            ft_ab(:) = ft_ab(:) * fac
          end
        end
        fac_a.destroy
      case (3)    ! When both are s or p functions, don't need to normalise.
    end
  end

  skip_ft(cutoff) result (res)
  ! Whether the ft for this shell pair is too small.
    IN :: self
    DBL, IN :: cutoff
    BIN :: res
    DBL :: R2,gamma,g1,e2,ex,ey,ez
    VEC(3) :: AB
    INT :: a,b,t_max
    MAT3* :: e
    GAUSSIAN2 :: G_ab
    G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
    t_max = .a.l + .b.l
    e.create((/0,t_max/),(/0,.a.l/),(/0,.b.l/))
    AB = (.a.pos-.b.pos)
    R2 = dot_product(AB,AB)
    res = TRUE
    do a = 1, .a.n_cc
      G_ab.set(ex_a=.a.ex(a))
      do b = 1, .b.n_cc
        G_ab.set(ex_b=.b.ex(b))
        e=ZERO; G_ab.make_e_coeff(e,1);   ex=maxval(e)
        e=ZERO; G_ab.make_e_coeff(e,2);   ey=maxval(e)
        e=ZERO; G_ab.make_e_coeff(e,3);   ez=maxval(e)
        gamma = .a.ex(a) + .b.ex(b)
        g1 = 1/gamma
        e2 = ex*ey*ez*(g1)**(THREE/TWO)*exp(-.a.ex(a)*.b.ex(b)*g1*R2)
        if (e2>cutoff) then
          res = FALSE
          e.destroy
          RETURN
        end
      end
    end
    e.destroy
  end

  skip_ft(Pmax,cutoff) result (res)
  ! Whether the ft for this shell pair is too small.
    IN :: self
    DBL, IN :: Pmax,cutoff
    BIN :: res
    DBL :: R2,gamma,g1,e2,ex,ey,ez,fac
    VEC(3) :: AB
    INT :: a,b,t_max
    MAT3* :: e
    GAUSSIAN2 :: G_ab
    G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
    t_max = .a.l + .b.l
    e.create((/0,t_max/),(/0,.a.l/),(/0,.b.l/))
    AB = (.a.pos-.b.pos)
    R2 = dot_product(AB,AB)
    res = TRUE
    do a = 1, .a.n_cc
      G_ab.set(ex_a=.a.ex(a))
      fac=.a.cc(a)*Pmax
      do b = 1, .b.n_cc
        G_ab.set(ex_b=.b.ex(b))
        e=ZERO; G_ab.make_e_coeff(e,1);   ex=maxval(e)
        e=ZERO; G_ab.make_e_coeff(e,2);   ey=maxval(e)
        e=ZERO; G_ab.make_e_coeff(e,3);   ez=maxval(e)
        gamma = .a.ex(a) + .b.ex(b)
        g1 = 1/gamma
        e2 = ex*ey*ez*(g1)**(THREE/TWO)*exp(-.a.ex(a)*.b.ex(b)*g1*R2)
        if (e2*.b.cc(b)*fac>cutoff) then
          res = FALSE
          e.destroy
          RETURN
        end
      end
    end
    e.destroy
  end

   make_ft(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
      CMAT3, target :: res
      MAT, IN :: k_pts
      GAUSSIAN2 :: G_ab
      CMAT3* :: ft_ab
      INT :: a,b,k_max,i,j,n_comp_a,n_comp_b
      DBL :: ca,fac
      CVEC* :: res_ij
      n_comp_a = .a.n_comp; n_comp_b = .b.n_comp
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      ft_ab.create(k_max,n_comp_a,n_comp_b)
      do a = 1, .a.n_cc
         G_ab.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G_ab.set(ex_b=.b.ex(b))
            G_ab.make_ft(ft_ab,k_pts)
            fac = ca * .b.cc(b)
            do j=1,n_comp_b
              do i=1,n_comp_a
                res_ij => res(:,i,j)
                res_ij(:) = res_ij(:) + ft_ab(:,i,j) * fac
              end
            end
         end
      end
      ft_ab.destroy
      .normalize_ft(res)
   end

   make_ft(res,k_pts,thermal)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction.
      CMAT3, target :: res
      CMAT3* :: ft_ab
      MAT, IN :: k_pts
      MAT3, target :: thermal
      GAUSSIAN2 :: G_ab
      VEC* :: therm
      INT :: a,b,k_max,i,j,n_comp_a,n_comp_b
      DBL :: ca,fac
      CVEC* :: res_ij
      n_comp_a = .a.n_comp; n_comp_b = .b.n_comp
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      ft_ab.create(k_max,n_comp_a,n_comp_b)
      do a = 1, .a.n_cc
         G_ab.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G_ab.set(ex_b=.b.ex(b))
            G_ab.make_ft(ft_ab,k_pts)
            fac = ca * .b.cc(b)
            therm => thermal(:,a,b)
            do j=1,n_comp_b
              do i=1,n_comp_a
                res_ij => res(:,i,j)
                res_ij(:) = res_ij(:) + ft_ab(:,i,j) * fac * therm(:)
              end
            end
         end
      end
      ft_ab.destroy
      .normalize_ft(res)
   end

   make_ft(res,k_pts,thermal,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Also adds in thermal correction.  Partition factors also included.
      CMAT3, target :: res
      MAT, IN :: k_pts,partition
      MAT3, target :: thermal
      GAUSSIAN2 :: G_ab
      CMAT3* :: ft_ab
      VEC* :: therm
      INT :: a,b,k_max,i,j,n_comp_a,n_comp_b
      DBL :: ca,fac
      CVEC* :: res_ij
      n_comp_a = .a.n_comp; n_comp_b = .b.n_comp
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      ft_ab.create(k_max,n_comp_a,n_comp_b)
      do a = 1, .a.n_cc
         G_ab.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G_ab.set(ex_b=.b.ex(b))
            G_ab.make_ft(ft_ab,k_pts)
            fac = ca * .b.cc(b) * partition(a,b)
            therm => thermal(:,a,b)
            do j=1,n_comp_b
              do i=1,n_comp_a
                res_ij => res(:,i,j)
                res_ij(:) = res_ij(:) + ft_ab(:,i,j) * fac * therm(:)
              end
            end
         end
      end
      ft_ab.destroy
      .normalize_ft(res)
   end

   make_ft(res,k_pts,partition)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.a.n_comp,.b.n_comp].
   ! Partition factors also included.
      CMAT3, target :: res
      MAT, IN :: k_pts,partition
      GAUSSIAN2 :: G_ab
      CMAT3* :: ft_ab
      INT :: a,b,k_max,i,j,n_comp_a,n_comp_b
      DBL :: ca,fac
      CVEC* :: res_ij
      n_comp_a = .a.n_comp; n_comp_b = .b.n_comp
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      ft_ab.create(k_max,n_comp_a,n_comp_b)
      do a = 1, .a.n_cc
         G_ab.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G_ab.set(ex_b=.b.ex(b))
            G_ab.make_ft(ft_ab,k_pts)
            fac = ca * .b.cc(b) * partition(a,b)
            do j=1,n_comp_b
              do i=1,n_comp_a
                res_ij => res(:,i,j)
                res_ij(:) = res_ij(:) + ft_ab(:,i,j) * fac
              end
            end
         end
      end
      ft_ab.destroy
      .normalize_ft(res)
   end

  make_gaussian_partition(res,factor_a,factor_b)
  ! Make the factors for partitioning the density contribution from
  ! each atom.
  ! Dimensions of res are [.a.n_cc,.b.n_cc].
    MAT, OUT :: res
    DBL, IN :: factor_a,factor_b
    INT :: a,b
    DBL :: ex_a,ex_b,exb_fb
    do b = 1, .b.n_cc
      ex_b = .b.ex(b)
      exb_fb = ex_b * factor_b
      do a = 1, .a.n_cc
        ex_a = .a.ex(a)
        res(a,b) = (exb_fb + ex_a * factor_a) / (ex_a + ex_b)
      end
    end
  end

  make_gaussian_partition(res,factor_a,factor_b)
  ! Make the factors for partitioning the density contribution from
  ! each atom.
  ! Dimensions of res are [.a.n_cc,.b.n_cc].
    CMAT, OUT :: res
    CDBL, IN :: factor_a,factor_b
    INT :: a,b
    DBL :: ex_a,ex_b,exb_fb
    do b = 1, .b.n_cc
      ex_b = .b.ex(b)
      exb_fb = ex_b * factor_b
      do a = 1, .a.n_cc
        ex_a = .a.ex(a)
        res(a,b) = (exb_fb + ex_a * factor_a) / (ex_a + ex_b)
      end
    end
  end

  make_tanaka_thermal_smearing(res,k_pts,Ua,Ub)
  ! Make the thermal smearing correction according to Tanaka.
  ! Dimensions of "res" are [k_max,.a.n_cc,.b.n_cc].
  ! "res" contains the correction for each pair of primitives.
    MAT3, OUT :: res
    MAT, IN :: k_pts,Ua,Ub
    MAT(3,3) :: Ua_ea,Ub_eb,U
    MAT* :: k_trans
    VEC(3) :: S,Utemp
    INT :: a,b,k,k_max
    DBL :: ea,eb
    k_max  = size(k_pts,1)
    k_trans.create(3,k_max)
    k_trans = transpose(k_pts)
    do a = 1, .a.n_cc
      ea = .a.ex(a)
      Ua_ea = ea * Ua
      do b = 1, .b.n_cc
        eb = .b.ex(b)
        Ub_eb = eb * Ub
        U = (Ua_ea + Ub_eb) / (ea + eb)
        do k = 1,k_max
          S = k_trans(:,k)
          Utemp = matmul(U,S)         ! Change coordinates of the U matrix.
          res(k,a,b) = exp(-HALF*dot_product(S,Utemp))
        end
      end
    end
    k_trans.destroy
  end

   make_ft_nabla(res,k_pts)
   ! Calculates the Fourier transform for a product of the gradient of
   ! shell a minus shell b for two contracted gaussian shells, evaluated 
   ! at a series of k points k_pts
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      CMAT4 :: res
      MAT, IN :: k_pts
      GAUSSIAN2 :: G_ab
      CMAT4* :: ft_ab
      INT :: a,b,k_max
      DBL :: ca,cb,cacb
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1, .a.n_cc
         G_ab.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G_ab.set(ex_b=.b.ex(b))
            cb = .b.cc(b)
            cacb = ca*cb
            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G_ab.make_ft_nabla(ft_ab,k_pts)
            res = res + ft_ab*cacb
            ft_ab.destroy
         end
      end
      .normalize_ft(res(:,:,:,1))
      .normalize_ft(res(:,:,:,2))
      .normalize_ft(res(:,:,:,3))
   end

   make_ft_nabla(res,k_pts,thermal,partition)
   ! Calculates "res" the Fourier transform for a product of the gradient of
   ! shell a minus shell b for two contracted gaussian shells, evaluated 
   ! at a series of k points "k_pts", including "thermal" smearing corrections
   ! and "partition" factors.
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      CMAT4 :: res
      MAT, IN :: k_pts,partition
      MAT3, target :: thermal
      VEC* :: therm
      GAUSSIAN2 :: G_ab
      CMAT4* :: ft_ab
      INT :: a,b,k_max,i,j
      DBL :: ca,cb,fac
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1, .a.n_cc
         G_ab.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G_ab.set(ex_b=.b.ex(b))
            cb = .b.cc(b)
            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G_ab.make_ft_nabla(ft_ab,k_pts)
            fac   =  ca*cb*partition(a,b)
            therm => thermal(:,a,b)
            do i = 1,.a.n_comp
            do j = 1,.b.n_comp
                res(:,i,j,1) = res(:,i,j,1) + ft_ab(:,i,j,1) * fac * therm(:)
                res(:,i,j,2) = res(:,i,j,2) + ft_ab(:,i,j,2) * fac * therm(:)
                res(:,i,j,3) = res(:,i,j,3) + ft_ab(:,i,j,3) * fac * therm(:)
            end
            end
            ft_ab.destroy
         end
      end
      .normalize_ft(res(:,:,:,1))
      .normalize_ft(res(:,:,:,2))
      .normalize_ft(res(:,:,:,3))
   end

   make_ft_r(res,k_pts)
   ! Calculates the Fourier transform for a product of two contracted
   ! gaussian shells, evaluated at a series of k points k_pts
   ! Dimensions of res are [k_max,.n_comp_a,.n_comp_b,3].
      MAT, IN :: k_pts
      CMAT4 :: res
      GAUSSIAN2 :: G_ab
      CMAT4* :: ft_ab
      INT :: a,b,k_max
      DBL :: ca,cb,cacb
      k_max  = size(k_pts,1)
      res = ZERO
      G_ab.set(.a.l,.a.pos,ZERO,.b.l,.b.pos,ZERO)
      do a = 1, .a.n_cc
         G_ab.set(ex_a=.a.ex(a))
         ca = .a.cc(a)
         do b = 1, .b.n_cc
            G_ab.set(ex_b=.b.ex(b))
            cb = .b.cc(b)
            cacb = ca*cb
            ft_ab.create(k_max,.a.n_comp,.b.n_comp,3)
            G_ab.make_ft_r(ft_ab,k_pts)
            res = res + ft_ab*cacb
            ft_ab.destroy
         end
      end
      .normalize_ft(res(:,:,:,1))
      .normalize_ft(res(:,:,:,2))
      .normalize_ft(res(:,:,:,3))
   end

!  *********************************
!  Simplistic CADPAC-style integrals
!  *********************************

   make_overlap_ints(S)
   ! Calculates overlap integral matrix, using Gauss-Hermite quadrature, like in
   ! CADPAC
      MAT :: S
      MAT* :: SS
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      S = ZERO
      SS.create(.a.n_comp,.b.n_comp)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_overlap_ints(SS)
         cacb = .a.cc(a)*.b.cc(b)
         S = S + SS*cacb
      end
      end
      SS.destroy
      .normalize(S)
   end

   make_dipole_ints(Dx,Dy,Dz,origin)
   ! Make the dipole moment integral matrices "Di" 
   ! with gauge origin "origin"
      MAT :: Dx,Dy,Dz
      VEC(3) :: origin
      MAT* :: DDx,DDy,DDz
      GAUSSIAN2 :: G
      INT :: a,b,n_a,n_b
      DBL :: cacb
      Dx = ZERO; Dy = ZERO; Dz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      DDx.create(n_a,n_b); DDy.create(n_a,n_b); DDz.create(n_a,n_b)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_dipole_ints(DDx,DDy,DDz,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Dx = Dx + DDx*cacb; Dy = Dy + DDy*cacb; Dz = Dz + DDz*cacb
      end
      end
      DDz.destroy; DDy.destroy; DDx.destroy
      .normalize(Dx); .normalize(Dy); .normalize(Dz)
   end

   make_quadrupole_ints(Qxx,Qyy,Qzz,Qxy,Qxz,Qyz,origin)
   ! Make the quadrupole moment integral matrices "Qij" 
   ! with gauge origin "origin"
      MAT :: Qxx,Qyy,Qzz,Qxy,Qxz,Qyz
      VEC(3) :: origin
      MAT* :: QQxx,QQyy,QQzz,QQxy,QQxz,QQyz
      GAUSSIAN2 :: G
      INT :: a,b,n_a,n_b
      DBL :: cacb
      Qxx = ZERO; Qyy = ZERO; Qzz = ZERO
      Qxy = ZERO; Qxz = ZERO; Qyz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      QQxx.create(n_a,n_b); QQyy.create(n_a,n_b); QQzz.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQxz.create(n_a,n_b); QQyz.create(n_a,n_b)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_quadrupole_ints(QQxx,QQyy,QQzz,QQxy,QQxz,QQyz,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Qxx = Qxx + QQxx*cacb; Qyy = Qyy + QQyy*cacb; Qzz = Qzz + QQzz*cacb
         Qxy = Qxy + QQxy*cacb; Qxz = Qxz + QQxz*cacb; Qyz = Qyz + QQyz*cacb
      end
      end
      QQyz.destroy; QQxz.destroy; QQxy.destroy
      QQzz.destroy; QQyy.destroy; QQxx.destroy
      .normalize(Qxx); .normalize(Qyy); .normalize(Qzz)
      .normalize(Qxy); .normalize(Qxz); .normalize(Qyz)
   end

   make_octupole_ints(Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz,origin)
   ! Make the octupole moment integral matrices "Oijk" 
   ! with gauge origin "origin"
      MAT :: Oxxx,Oyyy,Ozzz,Oxxy,Oxxz,Oyyx,Oyyz,Ozzx,Ozzy,Oxyz
      VEC(3) :: origin
      MAT* :: OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz
      GAUSSIAN2 :: G
      INT :: a,b,n_a,n_b
      DBL :: cacb
      Oxxx = ZERO; Oyyy = ZERO; Ozzz = ZERO
      Oxxy = ZERO; Oxxz = ZERO
      Oyyx = ZERO; Oyyz = ZERO
      Ozzx = ZERO; Ozzy = ZERO
      Oxyz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      OOxxx.create(n_a,n_b); OOyyy.create(n_a,n_b); OOzzz.create(n_a,n_b)
      OOxxy.create(n_a,n_b); OOxxz.create(n_a,n_b)
      OOyyx.create(n_a,n_b); OOyyz.create(n_a,n_b)
      OOzzx.create(n_a,n_b); OOzzy.create(n_a,n_b)
      OOxyz.create(n_a,n_b)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_octupole_ints(OOxxx,OOyyy,OOzzz,OOxxy,OOxxz,OOyyx,OOyyz,OOzzx,OOzzy,OOxyz,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Oxxx = Oxxx + OOxxx*cacb; Oyyy = Oyyy + OOyyy*cacb; Ozzz = Ozzz + OOzzz*cacb
         Oxxy = Oxxy + OOxxy*cacb; Oxxz = Oxxz + OOxxz*cacb
         Oyyx = Oyyx + OOyyx*cacb; Oyyz = Oyyz + OOyyz*cacb
         Ozzx = Ozzx + OOzzx*cacb; Ozzy = Ozzy + OOzzy*cacb
         Oxyz = Oxyz + OOxyz*cacb
      end
      end
      OOxyz.destroy
      OOzzy.destroy; OOzzx.destroy
      OOyyz.destroy; OOyyx.destroy
      OOxxz.destroy; OOxxy.destroy
      OOzzz.destroy; OOyyy.destroy; OOxxx.destroy
      .normalize(Oxxx); .normalize(Oyyy); .normalize(Ozzz)
      .normalize(Oxxy); .normalize(Oxxz)
      .normalize(Oyyx); .normalize(Oyyz)
      .normalize(Ozzx); .normalize(Ozzy)
      .normalize(Oxyz)
   end

   make_nuclear_attraction_ints(N,c)
   ! Make the nuclear attraction integral matrix "N" for nucleus at position "c"
      MAT :: N
      VEC(3) :: c
      MAT* :: NN
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      N = ZERO
      NN.create(.a.n_comp,.b.n_comp)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_nuclear_attraction_ints(NN,c)
         cacb = .a.cc(a)*.b.cc(b)
         N = N + NN*cacb
      end
      end
      NN.destroy
      .normalize(N)
   end

  make_electric_potential_grid(pot_grid,dens,pt)
  ! Make the nuclear attraction integral matrix "N" for nucleus at position "c"
    VEC :: pot_grid
    MAT :: dens,pt
    MAT* :: N,NN
    MAT* :: Nx,Ny,Nz,epa_epb_x,epa_epb_y,epa_epb_z,prefac
    IVEC* :: ax,ay,az,bx,by,bz
    VEC(3) :: rab
    DBL :: p,xx,wt,rpcx,rpcy,rpcz,cx,cy,cz,d
    DBL :: posax,posay,posaz,posbx,posby,posbz,exa,exb,r2ab
    DBL :: r0x,r0y,r0z,t,rax,ray,raz,rbx,rby,rbz,ptx,pty,ptz,wtx,wty,wtz
    DBL :: epa_epb_xab,epa_epb_yab,epa_epb_zab,r,r1,gpt
    INT :: a,b,k,j,n_roots,aa,bb,al1,bl1,i,pti,m
    RYS* :: rys

    rab = .a.pos - .b.pos
    r2ab = sum(rab*rab)
    posax = .a.pos(1); posay = .a.pos(2); posaz = .a.pos(3)
    posbx = .b.pos(1); posby = .b.pos(2); posbz = .b.pos(3)
    al1 = .a.l+1;      bl1 = .b.l+1
    n_roots = (al1+bl1)/2
    rys.create(n_roots)

    if (.a.l==0 AND .b.l==0) then
      wt = gauss_hermite_wt(1)
      d = dens(1,1) * wt*wt*wt

      pot_grid = ZERO
      do a = 1,.a.n_cc
        do b = 1,.b.n_cc
          exa = .a.ex(a)
          exb = .b.ex(b)
          p = exa + exb
          epa_epb_xab = (exa*posax+exb*posbx)/p
          epa_epb_yab = (exa*posay+exb*posby)/p
          epa_epb_zab = (exa*posaz+exb*posbz)/p
          t = d * .a.cc(a)*.b.cc(b)*exp(-exa*exb*r2ab/p)*pi212/p
          do k = 1,size(pt,1)
            rpcx = epa_epb_xab - pt(k,1)
            rpcy = epa_epb_yab - pt(k,2)
            rpcz = epa_epb_zab - pt(k,3)
            xx = p*(rpcx*rpcx+rpcy*rpcy+rpcz*rpcz)
            rys.get_weights_and_u_roots(xx)
            pot_grid(k) = pot_grid(k) + rys.weight(1)*t
          end
        end
      end
    else
      epa_epb_x.create(.a.n_cc,.b.n_cc)
      epa_epb_y.create(.a.n_cc,.b.n_cc)
      epa_epb_z.create(.a.n_cc,.b.n_cc)
      prefac.create(.a.n_cc,.b.n_cc)
      do a = 1,.a.n_cc
        exa = .a.ex(a)
        do b = 1,.b.n_cc
          exb = .b.ex(b)
          p = exa + exb
          epa_epb_x(a,b) = (exa*posax+exb*posbx)/p
          epa_epb_y(a,b) = (exa*posay+exb*posby)/p
          epa_epb_z(a,b) = (exa*posaz+exb*posbz)/p
          prefac(a,b) = .a.cc(a)*.b.cc(b)*exp(-exa*exb*r2ab/p)*pi212/p
        end
      end

      N.create(.a.n_comp,.b.n_comp)
      NN.create(.a.n_comp,.b.n_comp)
      ax.create(.a.n_comp); ay.create(.a.n_comp); az.create(.a.n_comp)
      bx.create(.b.n_comp); by.create(.b.n_comp); bz.create(.b.n_comp)
      Nx.create(al1,bl1); Ny.create(al1,bl1); Nz.create(al1,bl1)
      .a.l.make_gaussian_xyz_indices(ax,ay,az)
      .b.l.make_gaussian_xyz_indices(bx,by,bz)
      do k = 1,size(pt,1)
        cx = pt(k,1)
        cy = pt(k,2)
        cz = pt(k,3)
        N = ZERO
        do a = 1,.a.n_cc
          do b = 1,.b.n_cc
            exa = .a.ex(a)
            exb = .b.ex(b)
            p = exa + exb
            epa_epb_xab = epa_epb_x(a,b)
            epa_epb_yab = epa_epb_y(a,b)
            epa_epb_zab = epa_epb_z(a,b)
            rpcx = epa_epb_xab - cx
            rpcy = epa_epb_yab - cy
            rpcz = epa_epb_zab - cz
            xx = p*(rpcx*rpcx+rpcy*rpcy+rpcz*rpcz)
            rys.get_weights_and_u_roots(xx)
            NN = ZERO
            do j = 1,n_roots
              r  = rys.root(j)
              r1 = ONE + r
              t = sqrt(p*r1)
              r0x = (epa_epb_xab + cx*r)/r1
              r0y = (epa_epb_yab + cy*r)/r1
              r0z = (epa_epb_zab + cz*r)/r1
              Nx = ZERO
              Ny = ZERO
              Nz = ZERO
              do aa = 1,al1
                do bb = 1,bl1
                  i = (aa+bb)/2
                  do pti = first_pt(i),last_pt(i)
                    wt = gauss_hermite_wt(pti)
                    wtx = wt
                    wty = wt
                    wtz = wt
                    gpt = gauss_hermite_pt(pti)/t
                    ptx = gpt + r0x
                    pty = gpt + r0y
                    ptz = gpt + r0z
                    if(aa>1) then
                      rax = ptx - posax
                      ray = pty - posay
                      raz = ptz - posaz
                      do m=1,aa-1
                        wtx = wtx*rax
                        wty = wty*ray
                        wtz = wtz*raz
                      end
                    end
                    if(bb>1) then
                      rbx = ptx - posbx
                      rby = pty - posby
                      rbz = ptz - posbz
                      do m=1,bb-1
                        wtx = wtx*rbx
                        wty = wty*rby
                        wtz = wtz*rbz
                      end
                    end
                    Nx(aa,bb) = Nx(aa,bb) + wtx
                    Ny(aa,bb) = Ny(aa,bb) + wty
                    Nz(aa,bb) = Nz(aa,bb) + wtz
                  end
                end
              end
  
              Nz = Nz*rys.weight(j)
              NN = NN + Nx(ax,bx)*Ny(ay,by)*Nz(az,bz)
            end
            N = N + NN*prefac(a,b)
          end
        end
        .normalize(N)
        pot_grid(k) = N.trace_of_product(dens)
      end
      Nz.destroy; Ny.destroy; Nx.destroy
      bz.destroy; by.destroy; bx.destroy
      az.destroy; ay.destroy; ax.destroy
      NN.destroy
      N.destroy
      prefac.destroy
      epa_epb_z.destroy; epa_epb_y.destroy; epa_epb_x.destroy
    end
    rys.destroy
  end

   make_spin_orbit_ints(Lx,Ly,Lz,c)
   ! Make the spin orbit integral matrices "Lx" "Ly" and "Lz" for nucleus at
   ! position "c"
      MAT :: Lx,Ly,Lz
      VEC(3) :: c
      MAT* :: LLx,LLy,LLz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Lx = ZERO; Ly = ZERO; Lz = ZERO
      LLx.create(.a.n_comp,.b.n_comp)
      LLy.create(.a.n_comp,.b.n_comp)
      LLz.create(.a.n_comp,.b.n_comp)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_spin_orbit_ints(LLx,LLy,LLz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Lx = Lx + LLx*cacb
         Ly = Ly + LLy*cacb
         Lz = Lz + LLz*cacb
      end
      end
      LLz.destroy; LLy.destroy; LLx.destroy
      .normalize(Lx); .normalize(Ly); .normalize(Lz)
   end

   make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,c,origin)
   ! Make the gauge modified (B field) spin orbit integral matrices "Qij" 
   ! for nucleus at position "c" and gauge origin "origin"
      MAT :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz
      VEC(3) :: c,origin
      MAT* :: QQxx,QQxy,QQxz,QQyx,QQyy,QQyz,QQzx,QQzy,QQzz
      GAUSSIAN2 :: G
      INT :: a,b,n_a,n_b
      DBL :: cacb
      Qxx = ZERO; Qyx = ZERO; Qzx = ZERO
      Qxy = ZERO; Qyy = ZERO; Qzy = ZERO
      Qxz = ZERO; Qyz = ZERO; Qzz = ZERO
      n_a = .a.n_comp; n_b = .b.n_comp
      QQxx.create(n_a,n_b); QQyx.create(n_a,n_b); QQzx.create(n_a,n_b)
      QQxy.create(n_a,n_b); QQyy.create(n_a,n_b); QQzy.create(n_a,n_b)
      QQxz.create(n_a,n_b); QQyz.create(n_a,n_b); QQzz.create(n_a,n_b)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_spin_orbit_B_ints(QQxx,QQxy,QQxz,QQyx,QQyy,QQyz,QQzx,QQzy,QQzz,c,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Qxx = Qxx + QQxx*cacb; Qxy = Qxy + QQxy*cacb; Qxz = Qxz + QQxz*cacb
         Qyx = Qyx + QQyx*cacb; Qyy = Qyy + QQyy*cacb; Qyz = Qyz + QQyz*cacb
         Qzx = Qzx + QQzx*cacb; Qzy = Qzy + QQzy*cacb; Qzz = Qzz + QQzz*cacb
      end
      end
      QQzz.destroy; QQyz.destroy; QQxz.destroy
      QQzy.destroy; QQyy.destroy; QQxy.destroy
      QQzx.destroy; QQyx.destroy; QQxx.destroy
      .normalize(Qxx); .normalize(Qxy); .normalize(Qxz)
      .normalize(Qyx); .normalize(Qyy); .normalize(Qyz)
      .normalize(Qzx); .normalize(Qzy); .normalize(Qzz)
   end

   make_L_ints(Lx,Ly,Lz,origin)
   ! Calculate the angular momentum integral matrices "Lx", "Ly", "Lz", 
   ! with "origin" as gauge origin, using Gauss-Hermite quadrature
      MAT :: Lx,Ly,Lz
      VEC(3) :: origin
      MAT* :: LLx,LLy,LLz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Lx = ZERO; Ly = ZERO; Lz = ZERO
      LLx.create(.a.n_comp,.b.n_comp)
      LLy.create(.a.n_comp,.b.n_comp)
      LLz.create(.a.n_comp,.b.n_comp)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_L_ints(LLx,LLy,LLz,origin)
         cacb = .a.cc(a)*.b.cc(b)
         Lx = Lx + LLx*cacb
         Ly = Ly + LLy*cacb
         Lz = Lz + LLz*cacb
      end
      end
      LLz.destroy; LLy.destroy; LLx.destroy
      .normalize(Lx); .normalize(Ly); .normalize(Lz)
   end

   make_solenoidal_jp_ints(Jx,Jy,Jz,c)
   ! Make the solenoidal "Ji" integral matrices evaluated at position "c"
      MAT :: Jx,Jy,Jz
      VEC(3) :: c
      MAT* :: Ix,Iy,Iz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_solenoidal_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
      .normalize(Jx); .normalize(Jy); .normalize(Jz)
   end

   make_irrotational_jp_ints(Jx,Jy,Jz,c)
   ! Make the irrotational "Ji" integral matrices evaluated at position "c"
      MAT :: Jx,Jy,Jz
      VEC(3) :: c
      MAT* :: Ix,Iy,Iz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_irrotational_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
      .normalize(Jx); .normalize(Jy); .normalize(Jz)
   end

   make_magnetic_jp_ints(Jx,Jy,Jz,c)
   ! Make the magnetic "Ji" integral matrices evaluated at position "c"
      MAT :: Jx,Jy,Jz
      VEC(3) :: c
      MAT* :: Ix,Iy,Iz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Jx = ZERO; Jy = ZERO; Jz = ZERO
      Ix.create(.a.n_comp,.b.n_comp)
      Iy.create(.a.n_comp,.b.n_comp)
      Iz.create(.a.n_comp,.b.n_comp)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_magnetic_jp_ints(Ix,Iy,Iz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Jx = Jx + Ix*cacb
         Jy = Jy + Iy*cacb
         Jz = Jz + Iz*cacb
      end
      end
      Iz.destroy; Iy.destroy; Ix.destroy
      .normalize(Jx); .normalize(Jy); .normalize(Jz)
   end

   make_magnetic_S_ints(Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz,c)
   ! Make the magnetic "Mij" integral matrices evaluated at position "c"
      MAT :: Mxx,Mxy,Mxz,Myx,Myy,Myz,Mzx,Mzy,Mzz
      VEC(3) :: c
      MAT* :: Ixx,Ixy,Ixz,Iyx,Iyy,Iyz,Izx,Izy,Izz
      GAUSSIAN2 :: G
      INT :: a,b
      DBL :: cacb
      Mxx = ZERO; Mxy = ZERO; Mxz = ZERO
      Myx = ZERO; Myy = ZERO; Myz = ZERO
      Mzx = ZERO; Mzy = ZERO; Mzz = ZERO
      Ixx.create(.a.n_comp,.b.n_comp)
      Ixy.create(.a.n_comp,.b.n_comp)
      Ixz.create(.a.n_comp,.b.n_comp)
      Iyx.create(.a.n_comp,.b.n_comp)
      Iyy.create(.a.n_comp,.b.n_comp)
      Iyz.create(.a.n_comp,.b.n_comp)
      Izx.create(.a.n_comp,.b.n_comp)
      Izy.create(.a.n_comp,.b.n_comp)
      Izz.create(.a.n_comp,.b.n_comp)
      G.l_a   = .a.l;   G.l_b   = .b.l
      G.pos_a = .a.pos; G.pos_b = .b.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.make_magnetic_S_ints(Ixx,Ixy,Ixz,Iyx,Iyy,Iyz,Izx,Izy,Izz,c)
         cacb = .a.cc(a)*.b.cc(b)
         Mxx = Mxx + Ixx*cacb; Mxy = Mxy + Ixy*cacb; Mxz = Mxz + Ixz*cacb
         Myx = Myx + Iyx*cacb; Myy = Myy + Iyy*cacb; Myz = Myz + Iyz*cacb
         Mzx = Mzx + Izx*cacb; Mzy = Mzy + Izy*cacb; Mzz = Mzz + Izz*cacb
      end
      end
      Izz.destroy; Izy.destroy; Izx.destroy
      Iyz.destroy; Iyy.destroy; Iyx.destroy
      Ixz.destroy; Ixy.destroy; Ixx.destroy
      .normalize(Mxx); .normalize(Mxy); .normalize(Mxz)
      .normalize(Myx); .normalize(Myy); .normalize(Myz)
      .normalize(Mzx); .normalize(Mzy); .normalize(Mzz)
   end

!  ******************************
!  Roland Lindh's style integrals
!  ******************************

  s_overlap(zeta,zz,r2) result (res) [elemental]
  ! Calculate the overlap of two s functions.
    IN :: self
    DBL, IN :: zeta,zz,r2
    DBL :: res,PI_zinv
    PI_zinv = PI/zeta
    res=PI_zinv*sqrt(PI_zinv) * exp(-zz*r2)
! For some wierd reason, this function gives different results.
! Structure factors are out in 5th the decimal place.
!    res=(PI/zeta)**(1.5d0) * exp(-zz*r2)
  end

  make_overlap(ab)
  ! Calculate the overlap matrix for the two shells
    MAT :: ab
    VEC* :: es
    INT :: n
    n = (.a.l+.b.l).n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
    es.create(n)
    .make_overlap_es(es)
    .transfer(es,ab)
    es.destroy
    .normalize(ab)
  end

  make_overlap_es(es)
  ! Make the (es) overlap integrals, summed over primitives
    IN :: self
    VEC, OUT :: es
    VEC* :: temp
    VEC(3) :: AB
    INT :: a,b,templb,tempub,n_e
    DBL :: r2ab,ea,eb

    n_e    = .a.l + .b.l
    tempub = n_e.n_comp_sum
    templb = (max(.a.l,.b.l)-1).n_comp_sum + 1
    temp.create(tempub)

    AB = .a.pos - .b.pos
    r2ab = dot_product(AB,AB)

    es=ZERO
    do a=1, .a.n_cc
      ea=.a.ex(a)
      do b=1, .b.n_cc
        eb=.b.ex(b)
        .form_overlap_es(temp,ea,eb,r2ab,n_e)
        es=es + .a.cc(a) * .b.cc(b) * temp(templb:tempub)
      end
    end
    temp.destroy
  end

  form_overlap_es(es,ea,eb,r2ab,n_e)
  ! Form the (es) overlap integrals for a pair of primitives
    IN :: self
    VEC, INOUT :: es
    INT, IN :: n_e
    DBL, IN :: r2ab,ea,eb
    VEC(3) :: PE
    IVEC(3) :: a_momenta
    IMAT3* :: index
    IMAT* :: momenta
    DBL :: zinv2,zeta,zz,PEi
    INT :: j,z,lz,a1,a2,tmp

    zeta=ea+eb
    zz=ea*eb/zeta

    es=ZERO
    es(1)=.s_overlap(zeta,zz,r2ab)

    if (n_e > 0) then
      zinv2=HALF/zeta
      if (.a.l > .b.l) then
        PE=(eb*.b.pos + ea*.a.pos)/zeta - .a.pos
      else
        PE=(eb*.b.pos + ea*.a.pos)/zeta - .b.pos
      end

      es(2) = PE(1) * es(1)                                ! p||s
      es(3) = PE(2) * es(1)
      es(4) = PE(3) * es(1)

      if (n_e > 1) then
        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        do j=5, n_e.n_comp_sum                               ! d||s to n_e||s
          a_momenta = momenta(:,j)
          z = a_momenta.first_nonzero_component
          lz = a_momenta(z)
          a_momenta(z) = a_momenta(z)-1
          a1 = index(a_momenta(1),a_momenta(2),a_momenta(3))
          PEi=PE(z)
          if (lz < 2) then
            es(j) = PEi * es(a1)
          else
            a_momenta(z) = a_momenta(z)-1
            a2 = index(a_momenta(1),a_momenta(2),a_momenta(3))
            es(j) = PEi * es(a1) + zinv2 * (lz-1) * es(a2)
          end
        end
        index.destroy
        momenta.destroy
      end
    end
  end

  get_kei(kei,overlap)
  ! Calculate the kinetic energy and overlap (optional) integrals.
  ! (More efficient than making them separate).
    IN :: self
    MAT, INOUT :: kei
    MAT, INOUT, optional :: overlap

    .make_kei(kei,overlap)
    if (present(overlap)) .normalize(overlap)
    .normalize(kei)
  end

  make_kei(kei,overlap)
  ! Makes the kei and overlap matrics, summed over primitives
  ! Is called by kei, but does not do the orbital normalization corrections
    IN :: self
    MAT, INOUT :: kei
    MAT, INOUT, optional :: overlap
    MAT* :: temp_kei,temp_overlap
    VEC(3) :: P,PA,PB,ara,brb,AB
    INT :: a,b,alb,aub,blb,bub
    DBL :: ca,ea,eb,zeta,zinv2,r2ab
    alb = (.a.l-1).n_comp_sum + 1; aub = alb + .a.n_comp -1
    blb = (.b.l-1).n_comp_sum + 1; bub = blb + .b.n_comp -1
    temp_kei.create(aub,bub)
    temp_overlap.create(aub,bub)
    kei=ZERO
    if (present(overlap)) overlap=ZERO
    AB = .a.pos - .b.pos
    r2ab = dot_product(AB,AB)
    do a=1, .a.n_cc
      ca=.a.cc(a)
      ea=.a.ex(a)
      ara=ea*.a.pos
      do b=1, .b.n_cc
        eb    = .b.ex(b)
        brb   = eb * .b.pos
        zeta  = ea + eb
        zinv2 = HALF / zeta
        P     = (ara + brb) / zeta
        PA    = P - .a.pos
        PB    = P - .b.pos
        if (.a.l > .b.l) then
          .form_overlap_mat_a(temp_kei,temp_overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
        else
          .form_overlap_mat_b(temp_kei,temp_overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
        end
        if (present(overlap)) &
          overlap = overlap + ca * .b.cc(b) * temp_overlap(alb:aub,blb:bub)
        kei = kei + ca * .b.cc(b) * temp_kei(alb:aub,blb:bub)
      end
    end
    temp_kei.destroy
    temp_overlap.destroy
  end

  form_overlap_mat_a(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
  ! Makes the kinetic energy and overlap matrices for a primitive pair
  ! if .a.l > .b.l
    IN :: self
    MAT, INOUT :: overlap,kei
    VEC(3), IN :: PA,PB
    IVEC(3) :: a_momenta, b_momenta
    IMAT3* :: index
    IMAT* :: momenta
    DBL, IN :: zinv2,zeta,ea,eb,r2ab
    INT :: j,z,lza,lzb,a,a1,a2,b,b1,laub
    INT :: la,lb,la1_n_comp_sum,lb1_n_comp_sum,la_n_comp_sum,lb_n_comp_sum
    INT :: na,b_n_comp_sum,tmp
    DBL :: PAi,PBi,zz,zz2,zinv2_na,zinv2_nb,zz_ea,zz_eb,zz_ea_na

    zz       = ea * eb / zeta
    zz2      = 2 * zz
    zz_ea    = zz / ea
    zz_eb    = zz / eb
    b_n_comp_sum = .b.l.n_comp_sum

    overlap(1,1) = .s_overlap(zeta,zz,r2ab)
    kei(1,1)     = zz * (3.0-zz2 * r2ab) * overlap(1,1)

    momenta.create(3, .a.l.n_comp_sum)
    tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.a.l)
    index.create(0,.a.l, 0,.a.l, 0,.a.l)
    index.make_index_of_components(momenta)

    do j = 2, b_n_comp_sum                                ! s||p to s||lb
      a_momenta    = momenta(:,j)                         ! p||s to lb||s
      z            = a_momenta.first_nonzero_component
      lza          = a_momenta(z)
      a_momenta(z) = a_momenta(z) - 1
      a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
      PBi          = PB(z)
      PAi          = PA(z)
      if (lza < 2) then
        overlap(1,j) = PBi * overlap(1,a1)
        kei(1,j)     = PBi * kei(1,a1) + zz2 * overlap(1,j)
        overlap(j,1) = PAi * overlap(a1,1)
        kei(j,1)     = PAi * kei(a1,1) + zz2 * overlap(j,1)
      else
        na           = lza - 1
        zinv2_na     = zinv2 * na
        a_momenta(z) = a_momenta(z) - 1
        a2           = index(a_momenta(1),a_momenta(2),a_momenta(3))
        overlap(1,j) = PBi * overlap(1,a1) + zinv2_na * overlap(1,a2)
        kei(1,j)     = PBi * kei(1,a1) + zinv2_na * kei(1,a2) + &
                       zz2 * overlap(1,j) - zz_eb * na * overlap(1,a2)
        overlap(j,1) = PAi * overlap(a1,1) + zinv2_na * overlap(a2,1)
        kei(j,1)     = PAi * kei(a1,1) + zinv2_na * kei(a2,1) + &
                       zz2 * overlap(j,1) - zz_ea * na * overlap(a2,1)
      end
    end

    do j = b_n_comp_sum + 1, (.a.l-.b.l).n_comp_sum   ! lb||s to la-lb||s
      a_momenta    = momenta(:,j)
      z            = a_momenta.first_nonzero_component
      lza          = a_momenta(z)
      a_momenta(z) = a_momenta(z) - 1
      a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
      PAi          = PA(z)
      if (lza < 2) then
        overlap(j,1) = PAi * overlap(a1,1)
        kei(j,1)     = PAi * kei(a1,1) + zz2 * overlap(j,1)
      else
        na           = lza - 1
        zinv2_na     = zinv2 * na
        a_momenta(z) = a_momenta(z) - 1
        a2           = index(a_momenta(1),a_momenta(2),a_momenta(3))
        overlap(j,1) = PAi * overlap(a1,1) + zinv2_na * overlap(a2,1)
        kei(j,1)     = PAi * kei(a1,1) + zinv2_na * kei(a2,1) + &
                       zz2 * overlap(j,1) - zz_ea * na * overlap(a2,1)
      end
    end

    laub = .a.l - .b.l
    do lb = 1, .b.l
      lb1_n_comp_sum = (lb-1).n_comp_sum + 1
      lb_n_comp_sum  = lb.n_comp_sum
      laub           = laub + 1
      do la = 1, laub
        la1_n_comp_sum = (la-1).n_comp_sum + 1
        la_n_comp_sum  = la.n_comp_sum
        do a = la1_n_comp_sum, la_n_comp_sum
          a_momenta    = momenta(:,a)
          z            = a_momenta.first_nonzero_component
          lza          = a_momenta(z)
          a_momenta(z) = a_momenta(z) - 1
          a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
          PAi          = PA(z)
          if (lza==1) then
            do b = lb1_n_comp_sum,lb_n_comp_sum
              lzb = momenta(z,b)
              if (lzb==0) then
                overlap(a,b) = PAi * overlap(a1,b)
                kei(a,b)     = PAi * kei(a1,b) + zz2 * overlap(a,b)
              else
                b_momenta    = momenta(:,b)
                b_momenta(z) = b_momenta(z) - 1
                b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
                zinv2_nb     = zinv2 * lzb
                overlap(a,b) = PAi * overlap(a1,b) + zinv2_nb * overlap(a1,b1)
                kei(a,b)     = PAi * kei(a1,b) + zinv2_nb * kei(a1,b1) + &
                               zz2 * overlap(a,b)
              end
            end
          else
            na           = lza - 1
            zinv2_na     = zinv2 * na
            zz_ea_na    = zz_ea * na
            a_momenta(z) = a_momenta(z) - 1
            a2           = index(a_momenta(1),a_momenta(2),a_momenta(3))
            do b = lb1_n_comp_sum, lb_n_comp_sum
              lzb = momenta(z,b)
              if (lzb==0) then
                overlap(a,b) = PAi * overlap(a1,b) + zinv2_na * overlap(a2,b)
                kei(a,b)     = PAi * kei(a1,b) + zinv2_na * kei(a2,b) + &
                               zz2 * overlap(a,b) - zz_ea_na * overlap(a2,b)
              else
                zinv2_nb     = zinv2 * lzb
                b_momenta    = momenta(:,b)
                b_momenta(z) = b_momenta(z) - 1
                b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
                overlap(a,b) = PAi * overlap(a1,b) + zinv2_na * overlap(a2,b) +&
                               zinv2_nb * overlap(a1,b1)
                kei(a,b)     = PAi * kei(a1,b) + zinv2_na * kei(a2,b) + &
                               zinv2_nb * kei(a1,b1) + &
                               zz2 * overlap(a,b) - zz_ea_na * overlap(a2,b)
              end
            end
          end
        end
      end
    end
    momenta.destroy
    index.destroy
  end

  form_overlap_mat_b(kei,overlap,PA,PB,zinv2,zeta,ea,eb,r2ab)
  ! Makes the kinetic energy and overlap matrices for a primitive pair
  ! if .b.l > .a.l
    IN :: self
    MAT, INOUT :: overlap,kei
    VEC(3), IN :: PA,PB
    IVEC(3) :: b_momenta, a_momenta
    IMAT3* :: index
    IMAT* :: momenta
    DBL, IN :: zinv2,zeta,ea,eb,r2ab
    INT :: j,z,lza,lzb,a,a1,b,b1,b2,lbub,la,lb
    INT :: la1_n_comp_sum,lb1_n_comp_sum,la_n_comp_sum,lb_n_comp_sum
    INT :: nb,a_n_comp_sum,tmp
    DBL :: PAi,PBi,zz,zz2,zinv2_na,zinv2_nb,zz_ea,zz_eb,zz_eb_nb

    zz      = ea * eb / zeta
    zz2     = 2 * zz
    zz_ea    = zz / ea
    zz_eb    = zz / eb
    a_n_comp_sum  = .a.l.n_comp_sum

    overlap(1,1) = .s_overlap(zeta,zz,r2ab)
    kei(1,1)     = zz * (3.0-zz2 * r2ab) * overlap(1,1)

    momenta.create(3, .b.l.n_comp_sum)
    tmp=0;    tmp.make_gaussian_xyz_powers(momenta,.b.l)
    index.create(0,.b.l, 0,.b.l, 0,.b.l)
    index.make_index_of_components(momenta)

    do j=2, a_n_comp_sum                               ! p||s to la||s
      b_momenta    = momenta(:,j)                      ! s||p to s||la
      z            = b_momenta.first_nonzero_component
      lzb          = b_momenta(z)
      b_momenta(z) = b_momenta(z)-1
      b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
      PBi          = PB(z)
      PAi          = PA(z)
      if (lzb < 2) then
        overlap(j,1) = PAi * overlap(b1,1)
        kei(j,1)     = PAi * kei(b1,1) + zz2 * overlap(j,1)
        overlap(1,j) = PBi * overlap(1,b1)
        kei(1,j)     = PBi * kei(1,b1) + zz2 * overlap(1,j)
      else
        nb           = lzb - 1
        zinv2_nb     = zinv2 * nb
        b_momenta(z) = b_momenta(z) - 1
        b2           = index(b_momenta(1),b_momenta(2),b_momenta(3))
        overlap(j,1) = PAi * overlap(b1,1) + zinv2_nb * overlap(b2,1)
        kei(j,1)     = PAi * kei(b1,1) + zinv2_nb * kei(b2,1) + &
                       zz2 * overlap(j,1) - zz_ea * nb * overlap(b2,1)
        overlap(1,j) = PBi * overlap(1,b1) + zinv2_nb * overlap(1,b2)
        kei(1,j)     = PBi * kei(1,b1) + zinv2_nb * kei(1,b2) + &
                       zz2 * overlap(1,j) - zz_eb * nb * overlap(1,b2)
      end
    end

    do j= a_n_comp_sum + 1, (.b.l-.a.l).n_comp_sum      ! s||lb to s||lb-la
      b_momenta    = momenta(:,j)                       ! s||p to s||la
      z            = b_momenta.first_nonzero_component
      lzb          = b_momenta(z)
      b_momenta(z) = b_momenta(z) - 1
      b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
      PBi          = PB(z)
      if (lzb < 2) then
        overlap(1,j) = PBi * overlap(1,b1)
        kei(1,j)     = PBi * kei(1,b1) + zz2 * overlap(1,j)
      else
        nb           = lzb - 1
        zinv2_nb     = zinv2 * nb
        b_momenta(z) = b_momenta(z) - 1
        b2           = index(b_momenta(1),b_momenta(2),b_momenta(3))
        overlap(1,j) = PBi * overlap(1,b1) + zinv2_nb * overlap(1,b2)
        kei(1,j)     = PBi * kei(1,b1) + zinv2_nb * kei(1,b2) + &
                       zz2 * overlap(1,j) - zz_eb * nb * overlap(1,b2)
      end
    end

    lbub = .b.l - .a.l
    do la = 1, .a.l
      la1_n_comp_sum = (la-1).n_comp_sum + 1
      la_n_comp_sum  = la.n_comp_sum
      lbub           = lbub + 1
      do lb = 1, lbub
        lb1_n_comp_sum = (lb-1).n_comp_sum+1
        lb_n_comp_sum  = lb.n_comp_sum
        do b = lb1_n_comp_sum, lb_n_comp_sum
          b_momenta    = momenta(:,b)
          z            = b_momenta.first_nonzero_component
          lzb          = b_momenta(z)
          b_momenta(z) = b_momenta(z) - 1
          b1           = index(b_momenta(1),b_momenta(2),b_momenta(3))
          PBi          = PB(z)
          if (lzb == 1) then
            do a = la1_n_comp_sum, la_n_comp_sum
              lza = momenta(z,a)
              if (lza == 0) then
                overlap(a,b) = PBi * overlap(a,b1)
                kei(a,b)     = PBi * kei(a,b1) + zz2 * overlap(a,b)
              else
                a_momenta    = momenta(:,a)
                a_momenta(z) = a_momenta(z) - 1
                a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
                zinv2_na     = zinv2 * lza
                overlap(a,b) = PBi * overlap(a,b1) + zinv2_na * overlap(a1,b1)
                kei(a,b)     = PBi * kei(a,b1) + zinv2_na * kei(a1,b1) + &
                               zz2 * overlap(a,b)
              end
            end
          else
            nb           = lzb - 1
            zinv2_nb     = zinv2 * nb
            zz_eb_nb     = zz_eb * nb
            b_momenta(z) = b_momenta(z) - 1
            b2           = index(b_momenta(1),b_momenta(2),b_momenta(3))
            do a = la1_n_comp_sum, la_n_comp_sum
              lza = momenta(z,a)
              if (lza==0) then
                overlap(a,b) = PBi * overlap(a,b1) + zinv2_nb * overlap(a,b2)
                kei(a,b)     = PBi * kei(a,b1) + zinv2_nb * kei(a,b2)+ &
                               zz2 * overlap(a,b) - zz_eb_nb * overlap(a,b2)
              else
                zinv2_na     = zinv2 * lza
                a_momenta    = momenta(:,a)
                a_momenta(z) = a_momenta(z) - 1
                a1           = index(a_momenta(1),a_momenta(2),a_momenta(3))
                overlap(a,b) = PBi * overlap(a,b1) + zinv2_nb * overlap(a,b2) +&
                               zinv2_na * overlap(a1,b1)
                kei(a,b)     = PBi * kei(a,b1) + zinv2_nb * kei(a,b2) + &
                               zinv2_na * kei(a1,b1) + &
                               zz2 * overlap(a,b) - zz_eb_nb * overlap(a,b2)
              end
            end
          end
        end
      end
    end
    momenta.destroy
    index.destroy
  end

  get_nuc(ab,mass_c,pos_c)
  ! Calculate the nuclear attraction matrix for the two shells with the
  ! nucleus at c.
    IN :: self
    MAT, OUT :: ab
    DBL, IN :: mass_c
    VEC(3), IN :: pos_c
    VEC* :: es
    INT :: n
    n = (.a.l+.b.l).n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
    es.create(n)
    .make_nuc_es(es,mass_c,pos_c)
    .transfer(es,ab)
    es.destroy
    .normalize(ab)
  end

  make_nuc_es(es,mass_c,pos_c)
  ! Make the (es) nuclear attraction integrals, summed over primitives
  ! Numbers may be slightly different to cadpac due to a relativistic correction
  ! term.
    IN :: self
    VEC, OUT :: es
    DBL, IN :: mass_c
    VEC(3), IN :: pos_c
    VEC* :: esadd
    MAT* :: Ix,Iy,Iz
    RYS* :: rysa
    VEC* :: rzt,ce
    IMAT* :: momenta
    VEC(3) :: P,PA,PB,QP,ara,AB
    DBL :: QP2,a,b,zeta,zinv,kab,rho,xx,eta_c
    INT :: ag,bg,e,eub,nroots,n_e
    DBL :: norma,normb,norm,r2ab

    eub  = size(es)
    n_e  = .a.l + .b.l
    AB   = .a.pos - .b.pos
    r2ab = dot_product(AB,AB)

    if (mass_c < TOL(15)) then
      eta_c=1.0d30  ! Very big.
    else
      eta_c=3880000000d0*(mass_c**(-TWOTHIRDS))
    end
   eta_c = 1.0d60 ! uncomment this to get rid of relativistic correction.
    esadd.create(eub)
    es=ZERO
    nroots=(n_e+2)/2
    rysa.create(nroots)
    Ix.create(nroots,n_e+1)
    Iy.create(nroots,n_e+1)
    Iz.create(nroots,n_e+1)
    rzt.create(nroots)
    ce.create(nroots)

    momenta.create(3, eub)
    max(.a.l,.b.l).make_gaussian_xyz_powers(momenta,n_e)
    momenta = momenta + 1

    norm=TWO*PI
    do ag = 1, .a.n_cc
      a     = .a.ex(ag)
      norma = norm * .a.cc(ag)
      ara   = a * .a.pos
      do bg = 1, .b.n_cc
        b     = .b.ex(bg)
        zeta  = a + b
        zinv  = ONE / zeta
        kab   = exp(-a * b * r2ab * zinv)
        rho   = zeta * eta_c / (zeta + eta_c)
        P     = (ara + b * .b.pos) * zinv
        PA    = P - .a.pos
        PB    = P - .b.pos
        QP    = pos_c - P
        QP2   = dot_product(QP,QP)
        normb = norma * .b.cc(bg) * sqrt(rho*zinv) * kab * zinv
        xx    = rho * QP2
        rysa.get_weights(xx)
        .nuc_form_2d_ints(Ix,Iy,Iz,rysa.r,rho,zinv,PA,PB,QP,rzt,ce,n_e)
        do e=1,eub
          esadd(e) = sum(Ix(:,momenta(1,e)) * Iy(:,momenta(2,e)) * &
                                      Iz(:,momenta(3,e)) * rysa.w)
        end
        es=es+normb*esadd
      end
    end
    momenta.destroy
    Ix.destroy
    Iy.destroy
    Iz.destroy
    rysa.destroy
    esadd.destroy
    rzt.destroy
    ce.destroy
  end

  nuc_form_2d_ints(Ix,Iy,Iz,t2,rho,zinv,PA,PB,QP,rzt,ce,n_e) [pure]
  ! Forms the two dimentional integrals
    IN :: self
    MAT, INOUT :: Ix,Iy,Iz
    VEC, IN :: t2
    DBL, IN :: rho,zinv
    INT, IN :: n_e
    VEC(3), IN :: PA,PB,QP
    VEC, INOUT :: rzt,ce
    INT :: e,e1,ep1
    Ix(:,1) = ONE
    Iy(:,1) = ONE
    Iz(:,1) = ONE
    if (n_e/=0) then
       rzt = rho*t2*zinv
       if (.a.l > .b.l) then
         Ix(:,2)=PA(1)+rzt(:)*QP(1)
         Iy(:,2)=PA(2)+rzt(:)*QP(2)
         Iz(:,2)=PA(3)+rzt(:)*QP(3)
       else
         Ix(:,2)=PB(1)+rzt(:)*QP(1)
         Iy(:,2)=PB(2)+rzt(:)*QP(2)
         Iz(:,2)=PB(3)+rzt(:)*QP(3)
       end
       ce = (ONE-rzt)*HALF*zinv
       if (n_e>1) then
         do e = 2,n_e
           e1=e-1
           ep1=e+1
           Ix(:,ep1)=Ix(:,2)*Ix(:,e)+e1*ce(:)*Ix(:,e1)
           Iy(:,ep1)=Iy(:,2)*Iy(:,e)+e1*ce(:)*Iy(:,e1)
           Iz(:,ep1)=Iz(:,2)*Iz(:,e)+e1*ce(:)*Iz(:,e1)
         end
       end
    end
  end

  transfer(es,ab)
  ! Applies the transfer equation to (e|s) to give (a|b)
    IN :: self
    VEC, IN :: es
    MAT, OUT :: ab
    if (.a.l > .b.l) then
      .transfer_l_a_highest(es,ab)
    else
      .transfer_l_b_highest(es,ab)
    end
  end

  transfer_l_a_highest(es,ab)
  ! Applies the transfer equation to (e|s) to give (a|b)
  ! where a has the higher angular momentum.
    IN :: self
    VEC, IN :: es
    MAT, OUT :: ab
    VEC(3) :: ABvec
    IMAT* :: momenta
    IMAT3* :: index
    IVEC(3) :: a_momenta,b_momenta
    MAT* :: int_new,int_old
    INT :: a,b,lb,aub,bub,lb1_n_comp_sum,lb2_n_comp_sum
    INT :: a1,b1,z,n_e,eadd,tmp
    DBL :: ABi

    select case (.b.l)
      case (0)
        ab(:,1)=es

      case (1)
        ABvec = .a.pos - .b.pos
        eadd  = (.a.l-1).n_comp_sum
        n_e   = .a.l + .b.l
        aub   = (n_e-1).n_comp_sum - eadd

        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        do b=1,3
          z   = momenta(:,b+1).first_nonzero_component
          ABi = ABvec(z)
          do a=1,aub
            a_momenta    = momenta(:, a + eadd)
            a_momenta(z) = a_momenta(z) + 1
            a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
            ab(a,b)      = es(a1) + ABi * es(a)
          end
        end
        index.destroy
        momenta.destroy

      case default
        ABvec = .a.pos - .b.pos
        n_e   = .a.l + .b.l
        eadd  = (max(.a.l,.b.l)-1).n_comp_sum
        aub   = (n_e-1).n_comp_sum - eadd

        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        int_new.create(aub,3)
        do b=1,3
          z   = momenta(:,b+1).first_nonzero_component
          ABi = ABvec(z)
          do a=1,aub
            a_momenta    = momenta(:, a + eadd)
            a_momenta(z) = a_momenta(z) + 1
            a1 = index(a_momenta(1), a_momenta(2), a_momenta(3)) - eadd
            int_new(a,b) = es(a1) + ABi * es(a)
          end
        end

        do lb=2, .b.l-1
          lb1_n_comp_sum = (lb-1).n_comp_sum
          lb2_n_comp_sum = (lb-2).n_comp_sum
          bub            = lb.n_comp_sum - lb1_n_comp_sum
          aub            = (n_e-lb).n_comp_sum - eadd
          int_old        => int_new
          nullify(int_new)
          int_new.create(aub,bub)
          do b=1,bub
            b_momenta    = momenta(:, b + lb1_n_comp_sum)
            z            = b_momenta.first_nonzero_component
            b_momenta(z) = b_momenta(z) - 1
            b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
            ABi          = ABvec(z)
            do a=1,aub
              a_momenta    = momenta(:, a + eadd)
              a_momenta(z) = a_momenta(z) + 1
              a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
              int_new(a,b) = int_old(a1,b1) + ABi * int_old(a,b1)
            end
          end
          int_old.destroy
        end

        lb1_n_comp_sum = (.b.l-1).n_comp_sum
        lb2_n_comp_sum = (.b.l-2).n_comp_sum
        bub            = .b.l.n_comp_sum - lb1_n_comp_sum
        aub            = (n_e-.b.l).n_comp_sum - eadd
        int_old        => int_new
        do b=1,bub
          b_momenta    = momenta(:, b + lb1_n_comp_sum)
          z            = b_momenta.first_nonzero_component
          b_momenta(z) = b_momenta(z) - 1
          b1 = index(b_momenta(1),b_momenta(2),b_momenta(3)) - lb2_n_comp_sum
          ABi          = ABvec(z)
          do a=1,aub
            a_momenta    = momenta(:, a + eadd)
            a_momenta(z) = a_momenta(z) + 1
            a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - eadd
            ab(a,b)      = int_old(a1,b1) + ABi * int_old(a,b1)
          end
        end
        int_old.destroy
        index.destroy
        momenta.destroy
    end
  end

  transfer_l_b_highest(es,ab)
  ! Applies the transfer equation to (e|s) to give (a|b)
  ! where b has the higher angular momentum.
    IN :: self
    VEC, IN :: es
    MAT, OUT :: ab
    VEC(3) :: BAvec
    MAT* :: int_new,int_old
    IMAT* :: momenta
    IMAT3* :: index
    IVEC(3) :: a_momenta,b_momenta
    INT :: a,b,la,aub,bub,la1_n_comp_sum,la2_n_comp_sum
    INT :: a1,b1,z,n_e,eadd,tmp
    DBL :: BAi

    select case (.a.l)
      case (0)
        ab(1,:)=es

      case (1)
        n_e   = .a.l + .b.l
        BAvec = .b.pos - .a.pos
        eadd  = (.b.l-1).n_comp_sum
        bub   = (n_e-1).n_comp_sum - eadd

        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        do a=1,3
          z   = momenta(:,a+1).first_nonzero_component
          BAi = BAvec(z)
          do b=1, bub
            b_momenta    = momenta(:, b + eadd)
            b_momenta(z) = b_momenta(z) + 1
            b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
            ab(a,b)      = es(b1) + BAi * es(b)
          end
        end
        index.destroy
        momenta.destroy

      case default
        BAvec = .b.pos - .a.pos
        n_e   = .a.l + .b.l
        eadd  = (.b.l-1).n_comp_sum
        bub   = (n_e-1).n_comp_sum - eadd

        momenta.create(3, n_e.n_comp_sum)
        tmp=0;    tmp.make_gaussian_xyz_powers(momenta,n_e)
        index.create(0,n_e, 0,n_e, 0,n_e)
        index.make_index_of_components(momenta)

        int_new.create(3,bub)
        do a = 1, 3
          z   = momenta(:,a+1).first_nonzero_component
          BAi = BAvec(z)
          do b = 1, bub
            b_momenta    = momenta(:, b + eadd)
            b_momenta(z) = b_momenta(z) + 1
            b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
            int_new(a,b) = es(b1) + BAi * es(b)
          end
        end

        do la=2, .a.l - 1
          la1_n_comp_sum = (la-1).n_comp_sum
          la2_n_comp_sum = (la-2).n_comp_sum
          aub            = la.n_comp_sum - la1_n_comp_sum
          bub            = (n_e-la).n_comp_sum - eadd
          int_old=>int_new
          nullify(int_new)
          int_new.create(aub,bub)
          do a=1,aub
            a_momenta    = momenta(:,a + la1_n_comp_sum)
            z            = a_momenta.first_nonzero_component
            a_momenta(z) = a_momenta(z) - 1
            a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - la2_n_comp_sum
            BAi          = BAvec(z)
            do b=1,bub
              b_momenta    = momenta(:,b + eadd)
              b_momenta(z) = b_momenta(z) + 1
              b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
              int_new(a,b) = int_old(a1,b1) + BAi * int_old(a1,b)
            end
          end
          int_old.destroy
        end

        la1_n_comp_sum = (.a.l-1).n_comp_sum
        la2_n_comp_sum = (.a.l-2).n_comp_sum
        aub            = .a.l.n_comp_sum - la1_n_comp_sum
        bub            = (n_e-.a.l).n_comp_sum - eadd
        int_old=>int_new
        do a=1,aub
          a_momenta    = momenta(:,a + la1_n_comp_sum)
          z            = a_momenta.first_nonzero_component
          a_momenta(z) = a_momenta(z) - 1
          a1 = index(a_momenta(1),a_momenta(2),a_momenta(3)) - la2_n_comp_sum
          BAi          = BAvec(z)
          do b=1,bub
            b_momenta    = momenta(:,b + eadd)
            b_momenta(z) = b_momenta(z) + 1
            b1 = index(b_momenta(1), b_momenta(2), b_momenta(3)) - eadd
            ab(a,b)      = int_old(a1,b1) + BAi * int_old(a1,b)
          end
        end
        int_old.destroy
        index.destroy
        momenta.destroy
    end
  end

! Normalization routines and functions

  normalize(ab)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for orbitals a and b.
    IN :: self
    MAT, INOUT :: ab
    VEC* :: anorm,bnorm
    INT :: a,b
    if (NOT (.a.l<2 AND .b.l<2)) then
      anorm.create(.a.n_comp);    anorm.normalizing_factors( .a.l )
      bnorm.create(.b.n_comp);    bnorm.normalizing_factors( .b.l )
      do a = 1, .a.n_comp
        do b = 1, .b.n_comp
          ab(a,b)=ab(a,b)*anorm(a)*bnorm(b)
        end
      end
      bnorm.destroy
      anorm.destroy
    end
  end

end
