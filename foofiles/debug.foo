!---------------------------------------------------------------------------
!
! DEBUG: Debug print options ...
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: object.foo 3026 2007-03-04 10:45:02Z dylan_ $
!---------------------------------------------------------------------------

virtual module DEBUG

   implicit none

   debug_list :: VEC{STR}*, private  DEFAULT_NULL

contains

!  **************
!  Debug printing
!  **************

   read_debug_on ::: leaky
   ! Read a debug descriptor and add it to the list.
     name :: STR
     stdin.read(name)
     debug_list.append(name)
   end

   read_debug_off ::: leaky
   ! Read a debug descriptor and remove it from the list.
     name :: STR
     stdin.read(name)
     debug_list.prune(name)
   end

   debugging(name) result (res)
   ! Return TRUE if the debug switch "name" has been set.
     name :: STR
     res :: BIN
     res = FALSE
     if (debug_list.destroyed) return
     res = name.is_included_in_any(debug_list) 
   end

   put_debug_list
   ! Put of the list of debug switches
     if (debug_list.destroyed) return
     stdout.put(debug_list,"column")
   end

   put_debug(X,name) ::: template
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
     X :: TYPE
     name :: STR
     if (NOT .debugging(name)) return
     stdout.show(trim(name)//" = ",X)
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: template
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
     X :: TYPE
     name :: STR
     if (NOT .debugging(name)) return
     stdout.flush
     stdout.text(trim(name)//":")
     stdout.put(X)
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: template
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
     X :: TYPE
     name :: STR
     if (NOT .debugging(name)) return
     stdout.text(trim(name)//":")
     X.put
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>SHELL2)
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: template
   ! Put *opmatrix* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
     X :: OPMATRIX
     name :: STR
     if (NOT .debugging(name)) return
     if (X.restricted.created) then
        stdout.flush
        stdout.text(trim(name)//", restricted:")
        stdout.put(X.restricted)
     end
     if (X.alpha.created) then
        stdout.flush
        stdout.text(trim(name)//", alpha:")
        stdout.put(X.alpha)
     end
     if (X.beta.created) then
        stdout.flush
        stdout.text(trim(name)//", beta:")
        stdout.put(X.beta)
     end
     if (X.general.created) then
        stdout.flush
        stdout.text(trim(name)//", general:")
        stdout.put(X.general)
     end
     if (X.restricted_complex.created) then
        stdout.flush
        stdout.text(trim(name)//", restricted_complex:")
        stdout.put(X.restricted_complex)
     end
     if (X.alpha_complex.created) then
        stdout.flush
        stdout.text(trim(name)//", alpha_complex:")
        stdout.put(X.alpha_complex)
     end
     if (X.beta_complex.created) then
        stdout.flush
        stdout.text(trim(name)//", beta_complex:")
        stdout.put(X.beta_complex)
     end
     if (X.general_complex.created) then
        stdout.flush
        stdout.text(trim(name)//", general_complex:")
        stdout.put(X.general_complex)
     end
   end

end

