!-------------------------------------------------------------------------------
!
! TYPES : used to deposit all derived types used in TONTO.
!
! A separate module is required so that two modules can see each others types
! even if they can't use each others routines by with a "use" statement. 
!
! Please follow the indenting style here to allow the foo version of
! ctags to do its work properly
!
! (c) dylan jayatilaka, university of western australia, 1998
!
! $Id$
!
!-------------------------------------------------------------------------------

module TYPES

   implicit none

   type TIME

     start_time5 :: VEC{INT}(5)
     ! Contains real start time, in Julian day,h,m,s,ms
   
     stop_time5 :: VEC{INT}(5)
     ! Contains real stop time, in Julian day,h,m,s,ms
   
     cpu_start_time :: REAL
     ! Contains CPU start time, in seconds
   
     cpu_stop_time :: REAL
     ! Contains CPU stop time, in seconds

   end

   type PARALLEL
 
     is_parallel :: BIN  DEFAULT(FALSE)
     ! Whether we are doing a parallel job, or not.

     do_parallel_lock :: STR  DEFAULT(" ")
     ! This is set to the name of the routine which calls the parallel do loop.
     ! Only the routine with the same name may unlock the parallel loop. This
     ! implementation assumes that all routines with parallel do loops have
     ! distinct names (append with the module name, if not; or use a unique ID).
     ! Further, recursive routines cannot have parallel do loops.
 
     master_rank :: INT  DEFAULT(0)
     ! The rank of the master processor. It can be useful to change this, since
     ! only the master processor is allowed to so IO.

     processor_rank :: INT  DEFAULT(0)
     ! The rank number of the current processor
 
     n_processors :: INT  DEFAULT(1)
     ! The number of processors
 
     mpi_status :: INT  DEFAULT(0)
     ! Status field used for all MPI routines.
 
     max_n_skip_proc :: INT DEFAULT(0)
     ! maximum number of processors that can be skipped when assigning a
     ! processor grid.

     blacs_2d_context :: VEC{INT}(50)
     ! BLACS internal descriptor.

     proc_grid_nrow :: INT DEFAULT(0)
     ! Number of processors in a row of the processor grid
     ! nprows * npcols <= n_processors

     proc_grid_ncol :: INT DEFAULT(0)
     ! Number of processors in a column of the processor grid

     proc_grid_myrow :: INT DEFAULT(0)
     ! This processor's row of the processor grid

     proc_grid_mycol :: INT DEFAULT(0)
     ! This processor's column of the processor grid

   end

   type SYSTEM

     error_status :: INT  DEFAULT(0)
     ! Set non-zero on error.

     warnings_issued :: BIN  DEFAULT(FALSE)
     ! Set TRUE if warings were issued through the system

     error_output_unit :: INT  DEFAULT(SYSTEM_ERROR_OUTPUT_UNIT)
     ! The file unit number for error messages.

     keyword_echo :: BIN  DEFAULT(TRUE)
     ! Whether to echo use-input keywords

     ! ******************************
     ! Memory tracking and management
     ! ******************************

     memory_used :: INT  DEFAULT(0)
     ! The amount of memory used by the program so far.

     memory_blocks_used :: INT  DEFAULT(0)
     ! The current number of active memory blocks allocated using "create"
     ! commands

     max_memory_used :: INT  DEFAULT(0)
     ! The maximum amount of memory used so far.

     max_memory_blocks_used :: INT  DEFAULT(0)
     ! The maximum number of memory blocks allocated used by the program so far.

     memory_limit :: INT  DEFAULT(SYSTEM_MEMORY_LIMIT)
     ! A soft memory limit. A warning is generated if this limit is exceeded bu
     ! the program is not stopped.

     memory_limit_exceeded :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the soft memory limit is exceeded.

     memory_leak_detected :: BIN  DEFAULT(FALSE)
     ! Set TRUE if a memory leak has been detected. This is to prevent cascading
     ! memory leak reports from parent routines. However, this switch is set back
     ! to FALSE whenever a new routine is entered at a level below where the
     ! current leak occured, so it is not so useful.

     memory_leak_level :: INT  DEFAULT(0)
     ! Gives the memory leak level below which leaks are not reported. This is to
     ! ensure that the same memory leak is not reported at lower levels. The
     ! variable is reset to 0 whenever a new routine is entered at a level lower
     ! than the leak.

     memory_units :: STR  DEFAULT(SYSTEM_MEMORY_UNITS)
     ! The units for acconting for memory usage.
   
     ! ************************
     ! Memory address locations
     ! ************************

     n_addresses :: INT  DEFAULT(0)
     ! The number of addresses stoted in the address stack.
     ! Available only if the address of the object can be determined.
     ! Available only if call stack management is activated.

     max_addresses :: INT  DEFAULT(0)
     ! The maximum number of addresses stoted in the address stack.

     memory_address_stack :: VEC{INT}* DEFAULT_NULL
     ! An array which stores the addresses of the objects which have been
     ! allocated. Used to check if all allocated objects have been deallocated.

     memory_amount_stack :: VEC{INT}* DEFAULT_NULL
     ! An array which stores the memory used for the objects which have been
     ! allocated. Used to check if all allocated objects have been deallocated.

     memory_call_stack :: VEC{STR}(len=BSTR_SIZE)*  DEFAULT_NULL
     ! Stores the call stack at the point when memory was requested.
     ! It matches the "memory_address_stack", holding the correspoding address.

     leaky_address :: INT  DEFAULT(0)
     ! The address of a leak whose corresponding full call stack will be printed out.
     ! If 0, nothing is done.

     leaky_amount :: INT  DEFAULT(0)
     ! The amount of the memory leak. Used to home in on a particular leak.

     leaky_routine :: STR  DEFAULT(" ")
     ! The name of a leaky routine whose full call stack will be printed out.
     ! If blank, nothing is done.

     leaky_call_stack :: VEC{STR}*  DEFAULT_NULL
     ! The stack trace for the leaky routine specified in .leak_routine

     ! ************************************
     ! Call stack management system options
     ! ************************************

     stack_level :: INT  DEFAULT(0)
     ! The current call-stack level.

     max_stack_level :: INT  DEFAULT(0)
     ! The maximum call-stack level reached in the program.

     stack_show_level :: INT  DEFAULT(-1)
     ! Enable printing of the call-stack, for all routines at this level or higher
     ! in the call-stack.

     memory_used_stack :: VEC{INT}* DEFAULT_NULL
     ! An array which stores the amount of memory used by each routine at a given
     ! call-level in the call-stack.

     call_stack :: VEC{STR}*  DEFAULT_NULL
     ! Stores the name of each subroutine at each call-level, for routine traceback.

     flat_stack :: STR(len=BSTR_SIZE)  DEFAULT(" ")
     ! Stores as much of the call stack in a flat string

     show_call_stack :: BIN  DEFAULT(FALSE)
     ! If TRUE, tells whether to show an indented call-stack as the program runs.
     ! The memory gained or lost by each routine is also displayed.  Be warned,
     ! setting this switch produces copious output.

     io_file :: TEXTFILE*  DEFAULT_NULL
     ! Last I/O file used

     known_keywords :: VEC{STR}*  DEFAULT_NULL
     ! List of known keywords in the current case statement, if applicable
     ! This allows a nice error message to be returned saying what the allowed
     ! options in the case statement were.

     ! ***********************************
     ! Timing and profiling system options
     ! ***********************************

     time_stack_level :: INT  DEFAULT(0)
     ! The current time call-stack level. This is essentially just the same as
     ! stack_level. It is not the same since we may want to check timings when the
     ! ENSURE statements are turned on -- call_stack always implies ENSURE.

     time_call_stack :: VEC{INT}*  DEFAULT_NULL
     ! Stores the *indices* of the routines called at each call-level.  This is
     ! used for subracting the childrens elspased times from parent routines.

     time_strt_stack :: VEC{REAL}*  DEFAULT_NULL
     ! Stores the starting times for all routines in the time_call_stack.

     n_timed_routines :: INT  DEFAULT(0)
     ! The number of routines that have currently been called and are being timed.

     time_for_routine :: VEC{REAL}*  DEFAULT_NULL
     ! The time taken for a particular routine -- all routines called in the
     ! program will be timed in this stack.

     name_for_routine :: VEC{STR}*  DEFAULT_NULL
     ! The name for a particular timed routine -- all routines called in the
     ! program will be named in this stack.

     n_calls_for_routine :: VEC{INT}*  DEFAULT_NULL
     ! The number of calls for the particular routine in the timing stack.

     time_limit :: REAL  DEFAULT(ZERO)
     ! Set a total time limit on a profile run. A zero value means no time limit.
     ! If the time limit is exceeded the programs stops and dumps a profile up to
     ! that point. Pretty good, huh.

     show_cumulative_time :: BIN DEFAULT(FALSE)
     ! If TRUE, then when showing timing information the cumulative routine time
     ! is shown (including the time for called routines) rather than the actual 
     ! time for only the lines in the routine. If FALSE, there are usually
     ! roundoff errors present due top the inaccuracy of the fortran CPU_TIME
     ! intrinsic function.

     ! **********************************************************
     ! Parallel processor system options, inherited from PARALLEL
     ! **********************************************************

     is_parallel :: BIN  DEFAULT(FALSE)
     ! Whether we are doing a parallel job, or not.

     do_parallel_lock :: STR  DEFAULT(" ")
     ! This is set to the name of the routine which calls the parallel do loop.
     ! Only the routine with the same name may unlock the parallel loop. This
     ! implementation assumes that all routines with parallel do loops have
     ! distinct names (append with the module name, if not; or use a unique ID).
     ! Further, recursive routines cannot have parallel do loops.
 
     master_rank :: INT  DEFAULT(0)
     ! The rank of the master processor. It can be useful to change this, since

     processor_rank :: INT  DEFAULT(0)
     ! The rank number of the current processor

     n_processors :: INT  DEFAULT(1)
     ! The number of processors

     mpi_status :: INT  DEFAULT(0)
     ! Status field used for all MPI routines.

   end

   type COMMAND_LINE

     n_arg :: INT
     ! The number of command line arguments

     arg :: VEC{STR}*
     ! The list of comman line arguments

   end

   type BUFFER

     item_start :: INT
     ! The position of the first character of the last item processed in
     ! the buffer string

     item_end :: INT
     ! The position of the last character of the last item processed in
     ! the buffer string

     item_index :: INT
     ! The item number of the last item processed in the buffer string

     n_items :: INT
     ! The total number of items in the string

     analysed :: BIN  DEFAULT(FALSE)
     ! True, if the buffer string has been analysed

     comment_chars :: STR  DEFAULT(BUFFER_COMMENT_CHARS)
     ! The comment character symbols (concatenated) to be used in the
     ! buffer string

     quote_chars :: STR  DEFAULT(BUFFER_QUOTE_CHARS)
     ! The quote character symbols (concatenated) to be used in the
     ! buffer string

     ignore_unmatched_quotes :: BIN  DEFAULT(FALSE)
     ! If TRUE then unmatched quote character on a sigle line are deemed an error.

     eliminate_specials :: BIN  DEFAULT(TRUE)
     ! If TRUE then non-ascii characters are set to blank

     replacement_list :: MAT{STR}*  DEFAULT_NULL
     ! A list of replacement strings to apply to the buffer string, before
     ! analysis.

     string :: STR(len=BSTR_SIZE)  DEFAULT(" ")
     ! This is the actual buffer string

   end

   type UNIT_NUMBER

     unit :: INT
     ! The unit number

   end

   type FILE

     name :: STR  DEFAULT("unknown")
     ! The name of the file

     unit :: INT  DEFAULT(0)
     ! The unit number

     record :: INT  DEFAULT(1)
     ! The current record of the output

     io_status :: INT  DEFAULT(0)
     ! Set non-zero if there is an error condition

     action :: STR  DEFAULT("readwrite")
     ! The type of action performed on this file

     file_status :: STR  DEFAULT("unknown")
     ! File status

     buffered :: BIN  DEFAULT(FALSE)
     ! Whether to use buffering if the file is for numbers

     buffer_type :: STR  DEFAULT("INT")
     ! What type of buffer it is.

     int_buffer_pos :: INT  DEFAULT(1)
     ! The integer buffer position marker

     int_buffer :: VEC{INT}* DEFAULT_NULL
     ! The integer buffer which is flushed to the file when full

     real_buffer_pos :: INT  DEFAULT(1)
     ! The real buffer position marker

     real_buffer :: VEC{REAL}* DEFAULT_NULL
     ! The real buffer which is flushed to the file when full

     cpx_buffer_pos :: INT  DEFAULT(1)
     ! The cpx buffer position marker

     cpx_buffer :: VEC{CPX}* DEFAULT_NULL
     ! The cpx buffer which is flushed to the file when full

   end

   type TEXTFILE

     name :: STR  DEFAULT("unknown")
     ! The name of the file

     action :: STR  DEFAULT("unknown")
     ! The action status of the file, "read" or "write"

     unit :: INT
     ! The unit number

     record :: INT
     ! The current record of the output

     io_status :: INT  DEFAULT(0)
     ! Set non-zero if there is an error condition

     ignore_end_of_file :: BIN  DEFAULT(FALSE)
     ! Set to TRUE if the end of file is not to be regarded as an error.

     no_of_lines :: INT DEFAULT(-1)
     ! The number of lines in the file. This is only set if the end-of-file is
     ! encountered.

     use_fields :: BIN  DEFAULT(TEXTFILE_USE_FIELDS)
     ! If set TRUE, then items are output is set fields with certain field widths.
     ! e.g. integers have withd int_width. If not TRUE then the minimum field
     ! width is used.

     n_fields :: INT  DEFAULT(TEXTFILE_N_FIELDS)
     ! No of fields (i.e. columns) to use for outputting the variable

     int_width :: INT  DEFAULT(TEXTFILE_INT_WIDTH)
     ! Width of an integer field

     real_width :: INT  DEFAULT(TEXTFILE_REAL_WIDTH)
     ! Width of a real field

     real_precision :: INT  DEFAULT(TEXTFILE_REAL_PRECISION)
     ! No. of decimal places to use for outputing a real variable

     real_style :: STR  DEFAULT(TEXTFILE_REAL_STYLE)
     ! Fortran style character for a real variable

     margin_width :: INT  DEFAULT(TEXTFILE_MARGIN_WIDTH)
     ! Margin width

     use_labels :: BIN  DEFAULT(TEXTFILE_USE_LABELS)
     ! Whether to use column and row labels on vectors and matrices

     default_units :: STR  DEFAULT(" ")
     ! Each REAL number is assumed to have "default_units", and are converted
     ! into generic (internal) units, usually A.U.

     comment_chars :: STR  DEFAULT(TEXTFILE_COMMENT_CHARS)
     ! The comment character symbols (concatenated) to be used in the textfile

     quote_chars :: STR  DEFAULT(TEXTFILE_QUOTE_CHARS)
     ! The quote character symbols (concatenated) to be used in the textfile

     ignore_unmatched_quotes :: BIN  DEFAULT(FALSE)
     ! If TRUE then unmatched quote character on a sigle line are deemed an error.

     eliminate_specials :: BIN  DEFAULT(TRUE)
     ! If TRUE then non-ascii characters are set to blank

     replacement_list :: MAT{STR}* DEFAULT_NULL
     ! A list of strings and their replacements, to be applied when every line is
     ! inputted, if required.

     buffer :: BUFFER
     ! The output buffer which holds one line of output to be flushed

     internal :: VEC{STR}* DEFAULT_NULL
     ! Used to keep a record of of the entire file, internally

     saved :: TEXTFILE* DEFAULT_NULL
     ! Used to keep a record of a previous file, say for input redirect

   end

   type ARCHIVE

     root_name :: STR
     ! Archive root name (usually, the name of the job)

     name :: STR
     ! Archive name (usually, the name of the entity in the archive)

     genre :: STR
     ! Archive basis genre for opmatrix objects, or a qualifier for name

     format :: STR
     ! Archive format (blank for binary)

     file :: FILE* DEFAULT_NULL
     ! Binary file part

     textfile :: TEXTFILE* DEFAULT_NULL
     ! Text file part

   end

   type CIF

     file_name :: STR  DEFAULT(" ")
     ! The name of the CIF file to open

     file :: TEXTFILE* DEFAULT_NULL
     ! The actual CIF file to be processed

     data_block_name :: STR  DEFAULT(" ")
     ! The name of the data block

     start_of_data :: INT  DEFAULT(1)
     ! The starting line of the data block

     end_of_data :: INT  DEFAULT(0)
     ! The end line of the data block

     data_block_found :: BIN  DEFAULT(FALSE)
     ! Set TRUE if a data block has been sucessfully found

     BH_bond_length :: REAL  DEFAULT(-CIF_BH_BOND_LENGTH*BOHR_PER_ANGSTROM)
     ! If greater than zero any BH bonds in the CIF file are set to this

     CH_bond_length :: REAL  DEFAULT(-CIF_CH_BOND_LENGTH*BOHR_PER_ANGSTROM)
     ! If greater than zero any CH bonds in the CIF file are set to this

     NH_bond_length :: REAL  DEFAULT(-CIF_NH_BOND_LENGTH*BOHR_PER_ANGSTROM)
     ! If greater than zero any NH bonds in the CIF file are set to this

     OH_bond_length :: REAL  DEFAULT(-CIF_OH_BOND_LENGTH*BOHR_PER_ANGSTROM)
     ! If greater than zero any OH bonds in the CIF file are set to this

     U_iso_is_B_iso :: BIN  DEFAULT(FALSE)
     ! If TRUE, then any U_iso values in the CIF file are interpreted as B_iso
     ! values. This is a hack that should not be used except when the CIF file is
     ! hand made using B_iso values.

     U_is_B :: BIN  DEFAULT(FALSE)
     ! If TRUE, then any U values (i.e. ADP's) in the CIF file are interpreted as B
     ! values. This is a hack that should not be used except when the CIF file is
     ! hand made using B_iso values.

     U_is_beta :: BIN  DEFAULT(FALSE)
     ! If TRUE, then any U values (i.e. ADP's) in the CIF file are interpreted as
     ! beta values. This is a hack that should not be used except when the CIF
     ! file is hand made using B_iso values.

   end

   type RYS

     n_roots :: INT
     ! No. of rys roots

     weight :: VEC{REAL}* DEFAULT_NULL
     ! The Rys weights

     root :: VEC{REAL}* DEFAULT_NULL
     ! The Rys roots

   end

   type VEC_{BIN}

     element :: VEC{BIN}* DEFAULT_NULL
     ! Encapsulated type

   end

   type VEC_{INT}

     element :: VEC{INT}* DEFAULT_NULL
     ! Encapsulated type

   end

   type VEC_{REAL}

     element :: VEC{REAL}* DEFAULT_NULL
     ! Encapsulated vec type

   end

   array type VEC{VEC_{BIN}}

     ! A 1-D array of VEC_{BIN} objects

   end

   array type VEC{VEC_{INT}}

     ! A 1-D array of VEC_{INT} objects

   end

   array type VEC{VEC_{REAL}}

     ! A 1-D array of VEC_{REAL} objects

   end

   array type MAT{VEC_{INT}}

     ! A matrix of VEC_{INT} objects

   end

   array type MAT{VEC_{REAL}}

     ! A matrix of VEC_{REAL} objects

   end

   array type MAT3{VEC_{INT}}

     ! A 3D matrix of VEC_{INT} objects

   end

   array type MAT3{VEC_{REAL}}

     ! A 3D matrix of VEC_{REAL} objects

   end

   array type MAT3{VEC_{BIN}}

     ! A 3D matrix of VEC_{BIN} objects

   end

   type VEC_{VEC_{INT}}

     element :: VEC{VEC_{INT}}* DEFAULT_NULL
     ! Encapsulated encapsulated vector

   end

   type VEC_{VEC_{REAL}}

     element :: VEC{VEC_{REAL}}* DEFAULT_NULL
     ! Encapsulated encapsulated vector

   end

   array type VEC{VEC_{VEC_{INT}}}

     ! A 1-D array of VEC_{VEC_{INT}} objects

   end

   array type VEC{VEC_{VEC_{REAL}}}

     ! A 1-D array of VEC_{VEC_{REAL}} objects

   end

   type MAT_{INT}

     element :: MAT{INT}* DEFAULT_NULL
     ! Encapsulated mat type

   end

   type MAT_{REAL}

     element :: MAT{REAL}* DEFAULT_NULL
     ! Encapsulated mat type

   end

   array type VEC{MAT_{INT}}

     ! A 1-D array of MAT_{INT} objects

   end

   array type VEC{MAT_{REAL}}

     ! A 1-D array of MAT_{REAL} objects

   end

   array type MAT{MAT_{REAL}}

     ! A matrix of MAT_{REAL} objects

   end

   type MAT3_{REAL}

     element :: MAT3{REAL}* DEFAULT_NULL
     ! Encapsulated mat3 type

   end

   array type VEC{MAT3_{REAL}}

     ! A 1-D array of MAT3_{REAL} objects

   end

   type MAT4_{REAL}

     element :: MAT4{REAL}* DEFAULT_NULL
     ! Encapsulated mat4 type

   end

   array type VEC{MAT4_{REAL}}

     ! A 1-D array of MAT4_{REAL} objects

   end

   type OPVECTOR

     n_bf :: INT
     ! No of spatial basis functions (i.e. AO's)

     restricted :: VEC{REAL}* DEFAULT_NULL
     ! Restricted spinorbital representation

     alpha :: VEC{REAL}* DEFAULT_NULL
     ! Alpha part of a DODS representation

     beta :: VEC{REAL}* DEFAULT_NULL
     ! Beta  part of a DODS representation

     general :: VEC{REAL}* DEFAULT_NULL
     ! General mixed alpha-beta matrix representation

   end

   type OPMATRIX

     n_bf :: INT
     ! No of real spatial basis functions (i.e. AO's)

     restricted :: MAT{REAL}* DEFAULT_NULL
     ! Restricted spinorbital representation

     alpha :: MAT{REAL}* DEFAULT_NULL
     ! Alpha part of a DODS representation

     beta :: MAT{REAL}* DEFAULT_NULL
     ! Beta  part of a DODS representation

     general :: MAT{REAL}* DEFAULT_NULL
     ! General mixed alpha-beta matrix representation

     restricted_complex :: MAT{CPX}* DEFAULT_NULL
     ! Complex restricted representation

     alpha_complex :: MAT{CPX}* DEFAULT_NULL
     ! Complex alpha part of a DODS representation

     beta_complex :: MAT{CPX}* DEFAULT_NULL
     ! Complex beta  part of a DODS representation

     general_complex :: MAT{CPX}* DEFAULT_NULL
     ! Complex general mixed alpha-beta matrix representation

     triangle :: VEC{REAL}* DEFAULT_NULL
     ! Space saving for symmetric matrices: lower triangle only

     square :: VEC{REAL}* DEFAULT_NULL
     ! Space saving for hermitian matrices: lower triangle is real part, upper is imaginary

   end

   type HASH{VEC{INT},VEC{INT}}

     n_keys :: INT
     ! The number of keys

     n_size :: INT
     ! The size of the keys and values arrays.

     reverse_search :: BIN
     ! If TRUE, the search for values is performed from the largest key to the
     ! smallest.

     keys :: MAT{INT}* DEFAULT_NULL
     ! The array of keys, stored contigously by columns.

     values :: MAT{INT}* DEFAULT_NULL
     ! The array of values.

   end

   type ADAPTIVE_QUADRATURE

     algorithm :: STR  DEFAULT(" ")
     ! Identifier for the kind of quadrature algorithm

     accuracy :: REAL  DEFAULT(QUADRATURE_ACCURACY)
     ! The accuracy required for adapative quadratures

     n_points :: INT  DEFAULT(0)
     ! No. of quadrature points. For adaptive quadrature it is set to thye number
     ! of function eveluations.

     lower_limit :: REAL  DEFAULT(-ONE)
     ! Lower integration limit (if appropriate)

     upper_limit :: REAL  DEFAULT(ONE)
     ! Upper integration limit (if appropriate)

     point :: MAT{REAL}*  DEFAULT_NULL
     ! The 3D quadrature points

     weight :: VEC{REAL}*  DEFAULT_NULL
     ! The quadrature weight

     embedded_weight :: VEC{REAL}*  DEFAULT_NULL
     ! The embedded set of quadrature weights--for embedded cubature.

   end

!   type QUADRATURE
!
!   quad_kind :: STR  DEFAULT(" ")
!    Identifier for the kind of quadrature
!
!   accuracy :: REAL  DEFAULT(QUADRATURE_ACCURACY)
!    The accuracy required for adapative quadratures
!
!   n_points :: INT  DEFAULT(0)
!    No. of quadrature points. For adaptive quadrature it is set to thye number
!    of function eveluations.
!
!   lower_limit :: REAL  DEFAULT(-ONE)
!    Lower integration limit (if appropriate)
!
!   upper_limit :: REAL  DEFAULT(ONE)
!    Upper integration limit (if appropriate)
!
!   gauss_laguerre_alpha :: REAL  DEFAULT(ONE)
!    Gauss-Laguerre alpha parameter
!
!   gauss_jacobi_alpha :: REAL  DEFAULT(ONE)
!    Gauss-Jacobi alpha parameter
!
!   gauss_jacobi_beta :: REAL  DEFAULT(ONE)
!    Gauss-Jacobi alpha parameter
!
!   eps :: REAL  DEFAULT(QUADRATURE_EPS)
!    The relative accuracy of the roots when they are polished
!
!   maxit :: INT  DEFAULT(QUADRATURE_MAXIT)
!    The maximum iterations to work solve for the roots.
!
!   root :: VEC{REAL}*  DEFAULT_NULL
!    The 1D quadrature point i.e. root of the appropriate orthogonal polynomial
!
!   point :: MAT{REAL}*  DEFAULT_NULL
!    The 3D quadrature points
!
!   weight :: VEC{REAL}*  DEFAULT_NULL
!    The quadrature weight
!
!   embedded_weight :: VEC{REAL}*  DEFAULT_NULL
!    The embedded set of quadrature weights--for embedded cubature.
!
!   finalised :: BIN  DEFAULT(FALSE)
!    Set TRUE when all initialisations are completed.
!
!   end

   type QUADRATURE

     kind :: STR  DEFAULT(" ")
     ! Identifier for the kind of quadrature

     n_points :: INT  DEFAULT(0)
     ! No of quadrature points, or the order of the quadrature

     fold_weight_function_in :: BIN  DEFAULT(TRUE)
     ! The quadrature of I = Int f(x) dx is I = Sum_i f(x_i) w_i, i.e. no weight
     ! function appears in the integrand; it has been folded into w_i.  If this
     ! switch is set FALSE then f(x) = F(x) W(x) and the quadrature is defined as
     ! I = Int F(x) W(x) dx = Sum_i F(x_i) W_i i.e. the function F(x) to be
     ! quadrated does *not* have the weight W(x) folded in, as does f(x). The
     ! weights are related by w_i = W(x_i) W_i. Normally the program calculated
     ! W_i but it delivers w_i.

     lower_limit :: REAL  DEFAULT(-ONE)
     ! Lower integration limit (if appropriate)

     upper_limit :: REAL  DEFAULT(ONE)
     ! Upper integration limit (if appropriate)

     gauss_laguerre_alpha :: REAL  DEFAULT(ONE)
     ! Gauss-Laguerre alpha parameters

     gauss_jacobi_alpha :: REAL  DEFAULT(ONE)
     ! Gauss-Jacobi alpha parameter

     gauss_jacobi_beta :: REAL  DEFAULT(ONE)
     ! Gauss-Jacobi alpha parameter

     eps :: REAL  DEFAULT(QUADRATURE_EPS)
     ! The relative accuracy of the roots when they are polished

     maxit :: INT  DEFAULT(QUADRATURE_MAXIT)
     ! The maximum iterations to work solve for the roots.

     point :: VEC{REAL}*  DEFAULT_NULL
     ! The quadrature point i.e. root of the appropriate orthogonal polynomial

     weight :: VEC{REAL}*  DEFAULT_NULL
     ! The quadrature weight

     finalised :: BIN  DEFAULT(FALSE)
     ! Set TRUE when all initialisations are completed.

   end

   array type VEC{QUADRATURE}

     ! A 1-D array of QUADRATURE objects

   end

   type QUADRATURE2

     x :: QUADRATURE
     ! Quadrature object for the x-axis

     y :: QUADRATURE
     ! Quadrature object for the x-axis

     n_points :: INT  DEFAULT(0)
     ! No. of quadrature points in the direct product quadrature.

     point :: MAT{REAL}*  DEFAULT_NULL
     ! The quadrature points, in the (x,y) plane.

     weight :: VEC{REAL}*  DEFAULT_NULL
     ! The quadrature weights.

   end

   type LEBEDEV

     n_points :: INT  DEFAULT(0)
     ! No of quadrature points

     l :: INT  DEFAULT(0)
     ! The angular momentum that this quadrature will integrate up to.

     point :: MAT{REAL}*  DEFAULT_NULL
     ! Coordinates of the quadrature points

     weight :: VEC{REAL}*  DEFAULT_NULL
     ! The quadrature weights (normalised to unity)

     n_points_per_shell :: VEC{INT}*  DEFAULT_NULL
     ! No of ppoints per shell. This is used to save work when calculating the
     ! atomic grids on each shell.

     n :: INT, private DEFAULT(0)
     ! Private counter to keep track of how many points have been added into the
     ! quadrature grid.

     s :: INT, private DEFAULT(0)
     ! Private counter to keep track of how many shells there are in the
     ! quadrature grid.

   end

   type REFLECTION

     h :: INT  DEFAULT(0)
     ! Miller h index for the reflection

     k :: INT  DEFAULT(0)
     ! Miller k index for the reflection

     l :: INT  DEFAULT(0)
     ! Miller l index for the reflection

     theta :: REAL  DEFAULT(ZERO)
     ! The Bragg angle theta of reflection

     equivalence_factor :: INT  DEFAULT(1)
     ! The number of distinct reflections 
     !which are symmetry equivalent

     F_exp :: REAL  DEFAULT(ZERO)
     ! Experimental structure factor

     F_sigma :: REAL  DEFAULT(ZERO)
     ! Experimental error in the structure factor

     F_calc :: CPX  DEFAULT(ZERO)
     ! Calculated complex structure factor without including corrections

     F_pred :: REAL  DEFAULT(ZERO)
     ! Calculated structure factor including scale and extinction corrections

     F2_exp :: REAL  DEFAULT(ZERO)
     ! Experimental structure factor squared

     F2_sigma :: REAL  DEFAULT(ZERO)
     ! Experimental error in the structure factor squared

     F2_pred :: REAL  DEFAULT(ZERO)
     ! Calculated  structure factor squared

     F2_exp_inputted :: BIN  DEFAULT(FALSE)
     ! Set TRUE only if the experimental structure factor squared has been
     ! inputted. We need this to make sure that the F2_sigma values are specified
     ! after the F2_exp values, since the former are required to derive the
     ! F_sigma values.

     I_exp :: REAL  DEFAULT(ZERO)
     ! Experimental intensity

     I_sigma :: REAL  DEFAULT(ZERO)
     ! Experimental error in the intensity

     I_pred :: REAL  DEFAULT(ZERO)
     ! Calculated intensity including scale and extinction corrections

     group :: INT DEFAULT(ZERO)
     ! Specifies the group that this reflection belongs to. Reflections in
     ! different groups may get treated differently e.g. be optimised with
     ! different scale factors.

   end

   array type VEC{REFLECTION}

     ! A 1-D array of REFLECTION objects

   end

   type DIIS

     genre :: STR  DEFAULT(DIIS_GENRE)
     ! The kind of DIIS procedure to use

     iteration :: INT  DEFAULT(0)
     ! The iteration count for the DIIS procedure. It gets incremented every time
     ! one of the extrapolators/interpolators are called.

     start_iteration :: INT  DEFAULT(DIIS_START_ITERATION)
     ! The iteration when the DIIS procedure is supposed to start accelerating the
     ! requested object. The DIIS acceleration procedure works on the saved vectors,
     ! and the procedure can start saving vectors before starting the acceleration
     ! procedure.

     save_iteration :: INT  DEFAULT(DIIS_SAVE_ITERATION)
     ! The iteration when the DIIS object starts saving vectors. It must be equal
     ! or smaller than the start_iteration. The previously saved vectors are used
     ! in the acceleration procedure.

     keep :: INT  DEFAULT(DIIS_KEEP)
     ! No. of DIIS vectors to keep for use in extrapolation

     kept :: INT  DEFAULT(0)
     ! The actual number of DIIS vectors kept.

     oldest :: VEC{INT}*  DEFAULT_NULL
     ! A list of the indices of the oldest vectors.

     new :: INT  DEFAULT(0)
     ! The integer identifier for the new (current) parameter vector, usually the
     ! Fock matrix.  This is equal to .iteration only if .iteration<=.keep;
     ! otherwise it is an integer in the range [1,.keep] which corresponds to the
     ! parameter vector with the worst error (DIIS) or the oldest vector (EDIIS).
     ! In this way, the worst/oldest parameter and error vectors are pruned.

     error_length :: REAL  DEFAULT(ZERO)
     ! The length of the DIIS error vector

     convergence_tolerance :: REAL  DEFAULT(DIIS_CONVERGENCE_TOLERANCE)
     ! This tolerance specifies when the DIIS/EDIIS procedure is regarded to be
     ! converged.

     start_tolerance :: REAL  DEFAULT(DIIS_START_TOLERANCE)
     ! In the case when the method is "ediis+diis", this tolerance specifies when
     ! the EDIIS procedure finishes and when the DIIS procedure begins.

     encore_iterations :: INT  DEFAULT(DIIS_ENCORE_ITERATIONS)
     ! In the case when the method is "ediis+diis", this tolerance specifies how
     ! many EDIIS iterations are to be performed again, assuming that EDIIS was
     ! already performed before, and DIIS has started to diverge.

     stage :: INT   DEFAULT(0)
     ! The stage of the "ediis+diis" calculation. If 0, we have not yet started
     ! the first DIIS. If 1, we have finished EDIIS and started DIIS. If 2, we
     ! have reached stage 1, but we need encore EDIIS iterations.

     encore :: INT   DEFAULT(0)
     ! The iteration counter for encore iterations.

     replacement_method :: STR  DEFAULT(DIIS_REPLACEMENT_METHOD)
     ! This specifies the method to be used when replacing the DIIS vectors, in
     ! the case when the DIIS space becomes saturated. The choices are "worst"
     ! item, or "oldest" item.

     archive :: ARCHIVE
     ! Archive used to store the DIIS parameter and error vectors

     par_tag :: STR  DEFAULT("fock_matrix")
     ! A string tag used to identify the parameter vectors stored on disk, which
     ! are used to construct the next DIIS approximation.

     err_tag :: STR  DEFAULT("pulay_error")
     ! A string tag used to identify the error vectors stored on disk, which
     ! are used to construct the next DIIS approximation.

     lhs_tag :: STR  DEFAULT("diis_lhs")
     ! A string tag used to identify the DIIS LHS matrix stored on disk.

     lhs_tol :: REAL  DEFAULT(TOL(10))
     ! Tolernace for solving the non-linear DDIIS  equations iteratively.

     S :: MAT{REAL}*  DEFAULT_NULL
     ! The overlap matrix. Used to calculate commutators.

     F :: OPMATRIX*   DEFAULT_NULL
     ! The current fock matrix. It gets stored on disk, and then extrapolated or
     ! interpolated by the DIIS routines.

     F_tag :: STR  DEFAULT("fock_matrix")
     ! A string tag used to identify the Fock matrices stored on disk, which
     ! are used to construct the next DIIS approximation. 

     D :: OPMATRIX*   DEFAULT_NULL
     ! The density matrix corresponding to the current fock matrix. It gets stored
     ! on disk and is used to calculate the commutators.

     D_tag :: STR  DEFAULT("density_matrix")
     ! A string tag used to identify the Density matrices stored on disk, which
     ! are used to construct the next DIIS approximation. 

     J :: OPMATRIX*   DEFAULT_NULL
     ! The coulomb matrix corresponding to the current fock matrix. It gets stored
     ! on disk and is used to calculate commutators in the UHF case only.

     J_tag :: STR  DEFAULT("coulomb_matrix")
     ! A string tag used to identify the Coulomb J matrices stored on disk, which
     ! are used to construct the next DIIS approximation in the UHF case.

     energy :: VEC{REAL}*   DEFAULT_NULL
     ! The current SCF electronic energy (or energies, in the UHF case), used in
     ! energy DIIS.

     e_tag :: STR  DEFAULT("energy")
     ! A string tag used to identify the energy stored on disk, which
     ! are used to construct the next DIIS approximation. 

     force_convexity :: BIN  DEFAULT(DIIS_FORCE_CONVEXITY)
     ! If TRUE the diis coefficients are forced to be positive to ensure that any
     ! extrapolated density matrix is a convex linear combination. This is TRUE by
     ! default for the EDIIS method.

     micro_iteration_method :: STR   DEFAULT(DIIS_MICRO_ITERATION_METHOD)
     ! The name of the method used to solve the DDIIS equations iteratively.
     ! These are called DDIIS micro iterations.

     micro_starting_guess :: STR   DEFAULT(DIIS_MICRO_STARTING_GUESS)
     ! The starting guess to use for the solving the DDIIS equations iteratively.
     ! They can be started with the "last" density or "diis" coefficients.

     micro_convergence_tol :: REAL  DEFAULT(DIIS_MICRO_CONVERGENCE_TOL)
     ! The tolerace for solving the non-linear DDIIS  equations iteratively.

     micro_max_iterations :: INT  DEFAULT(DIIS_MICRO_MAX_ITERATIONS)
     ! This is the maximum number of micro iterations allowed when solving the
     ! non-linear DDIIS equations by simple relaxation.

     micro_damp_factor :: REAL  DEFAULT(DIIS_MICRO_DAMP_FACTOR)
     ! The damp factor to use when solving the non-linear DDIIS equations by
     ! simple relaxation.

   end

   type GAUSSIAN

     l :: INT, readonly  DEFAULT(0)
     ! l quantum number for the gaussian

     ex :: REAL  DEFAULT(ZERO)
     ! Exponent for the gaussian

     pos :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Position of the gaussian

     n_comp :: INT, readonly  DEFAULT(0)
     ! No. of cartesian components for the gaussian

     n_sph :: INT, readonly  DEFAULT(0)
     ! No. of spherical components for the gaussian shell

     first_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the first gaussian. For lookups.

     last_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the last gaussian. For lookups.

   end

   type GAUSSIAN2

     a :: GAUSSIAN
     ! Shell "a" of the pair

     b :: GAUSSIAN
     ! Shell "b" of the pair

   end

   type GAUSSIAN4

     a :: GAUSSIAN
     ! Shell "a" of the quartet

     b :: GAUSSIAN
     ! Shell "b" of the quartet

     c :: GAUSSIAN
     ! Shell "c" of the quartet

     d :: GAUSSIAN
     ! Shell "d" of the quartet

   end

   type RMS_INDICES

     xyz0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where nx and ny and nz are zero

     yz0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where ny and nz are zero (not including any above)

     xz0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where nx and nz are zero (not including any above)

     xy0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where nx and ny are zero (not including any above)

     z0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where nz is zero (not including any above)

     y0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where ny is zero (not including any above)

     x0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where nx is zero (not including any above)

     n0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where none of nx, ny, nz is zero (not including any above)

     a0 :: VEC{INT}*  DEFAULT_NULL
     ! list of the indices where any  of nx, ny, nz is zero i.e. complement of n0

!     xy_rms :: VEC{VEC_{INT}}*  DEFAULT_NULL
!     ! list of the repeated nx and ny indices for use in the reduced
!     ! multiplication scheme for indices which are non-zero

     xy_rms_n :: VEC{VEC_{INT}}*  DEFAULT_NULL
     ! list of the repeated nx and ny indices for use in the reduced
     ! multiplication scheme for indices which are non-zero

!     xy_unique_n :: VEC{INT}*  DEFAULT_NULL
!     ! list of the unique nx and ny indices for use in the reduced
!     ! multiplication scheme for indices which are non-zero

     xy_rms_a :: VEC{VEC_{INT}}*  DEFAULT_NULL
     ! list of the repeated nx and ny indices for use in the reduced
     ! multiplication scheme where at least one index is zero

!     xy_unique_a :: VEC{INT}*  DEFAULT_NULL
!     ! list of the unique nx and ny indices for use in the reduced
!     ! multiplication scheme where at least one index is zero

     yz0px :: VEC{INT}*  DEFAULT_NULL
     ! px powers for the yz0 indices

     xz0py :: VEC{INT}*  DEFAULT_NULL
     ! py powers for the xz0 indices

     xy0pz :: VEC{INT}*  DEFAULT_NULL
     ! pz powers for the xz0 indices

     z0px :: VEC{INT}*  DEFAULT_NULL
     ! px and py powers for the z0 indices

     z0py :: VEC{INT}*  DEFAULT_NULL
     ! px and py powers for the z0 indices

     y0px :: VEC{INT}*  DEFAULT_NULL
     ! px and pz powers for the y0 indices

     y0pz :: VEC{INT}*  DEFAULT_NULL
     ! px and pz powers for the y0 indices

     x0py :: VEC{INT}*  DEFAULT_NULL
     ! py and pz powers for the x0 indices

     x0pz :: VEC{INT}*  DEFAULT_NULL
     ! py and pz powers for the x0 indices

     n1 :: VEC{INT}*  DEFAULT_NULL
     ! Indices and non-zero powers for non-rms terms

     n1px :: VEC{INT}*  DEFAULT_NULL
     ! Indices and non-zero powers for non-rms terms

     n1py :: VEC{INT}*  DEFAULT_NULL
     ! Indices and non-zero powers for non-rms terms

     n1pz :: VEC{INT}*  DEFAULT_NULL
     ! Indices and non-zero powers for non-rms terms

     n2 :: VEC{VEC_{INT}}*  DEFAULT_NULL
     ! Indices and non-zero powers for rms terms

     n2px :: VEC{VEC_{INT}}*  DEFAULT_NULL
     ! Indices and non-zero powers for rms terms

     n2py :: VEC{VEC_{INT}}*  DEFAULT_NULL
     ! Indices and non-zero powers for rms terms

     n2pz :: VEC{VEC_{INT}}*  DEFAULT_NULL
     ! Indices and non-zero powers for rms terms

   end

   array type MAT{RMS_INDICES}

     ! A 2-D array of RMS_INDICES objects

   end

   type RMS2_INDICES

   !   e :: VEC{INT}*  DEFAULT_NULL
   !   ! list of the "e" indices for forming the esfs(e,f) integrals
   !
   !   f :: VEC{INT}*  DEFAULT_NULL
   !   ! list of the "f" indices for forming the esfs(e,f) integrals
   !
   !   ex :: VEC{INT}*  DEFAULT_NULL
   !   ! x power of the cartesian gaussian on the e side
   !
   !   ey :: VEC{INT}*  DEFAULT_NULL
   !   ! y power of the cartesian gaussian on the e side
   !
   !   ez :: VEC{INT}*  DEFAULT_NULL
   !   ! z power of the cartesian gaussian on the e side
   !
   !   fx :: VEC{INT}*  DEFAULT_NULL
   !   ! x power of the cartesian gaussian on the f side
   !
   !   fy :: VEC{INT}*  DEFAULT_NULL
   !   ! y power of the cartesian gaussian on the f side
   !
   !   fz :: VEC{INT}*  DEFAULT_NULL
   !   ! z power of the cartesian gaussian on the f side
   !
   !   Ixy_is_1 :: VEC{INT}*  DEFAULT_NULL
   !   ! No. of rms elements where Ix*Iy = 1
   !
   !   Ixy_is_x :: VEC{INT}*  DEFAULT_NULL
   !   ! No. of rms elements where Ix*Iy = Ix
   !
   !   Ixy_is_y :: VEC{INT}*  DEFAULT_NULL
   !   ! No. of rms elements where Ix*Iy = Iy
   !
   !   Ixy_is_p :: VEC{INT}*  DEFAULT_NULL
   !   ! No. of rms elements for Ix*Iy 

     ef :: VEC{INT}*  DEFAULT_NULL
     ! List of linearised "e,f" indices for accessing the esfs(e,f) integrals

     efx :: VEC{INT}*  DEFAULT_NULL
     ! List of linearised "ex,fx" indices for accessing the Ix(ex,fx) integrals

     efy :: VEC{INT}*  DEFAULT_NULL
     ! List of linearised "ey,fy" indices for accessing the Iy(ey,fy) integrals

     efz :: VEC{INT}*  DEFAULT_NULL
     ! List of linearised "ez,fz" indices for accessing the Iz(ez,fz) integrals

     no_Ixy_is_1 :: INT
     ! Number of terms where Ix*Iy is 1.

     no_Ixy_is_x :: INT
     ! Offset for terms where Ix*Iy = Ix .

     no_Ixy_is_y :: INT
     ! Offset for terms where Ix*Iy = Iy.

     do_Ixy_is_x :: VEC{BIN}*  DEFAULT_NULL
     ! If TRUE, then we should set Ix*Iy = Ix 

     do_Ixy_is_y :: VEC{BIN}*  DEFAULT_NULL
     ! If TRUE, then we should set Ix*Iy = Iy 

     do_Ixy :: VEC{BIN}*  DEFAULT_NULL
     ! If TRUE, then we should set Ix*Iy 

   end

   array type MAT{RMS2_INDICES}

     ! A 2-D array of RMS2_INDICES objects

   end

   array type MAT4{RMS2_INDICES}

     ! A 2-D array of RMS2_INDICES objects

   end

   type GAUSSIAN_DATA

     l_max :: INT
     ! The maximum l value for which the data is defined.

   end

   type SHELL

     l :: INT, readonly  DEFAULT(0)
     ! (Maximum) l quantum number for the gaussian shell
  
     l_chr :: STR, readonly  DEFAULT(" ")
     ! The character symbol for the shell e.g. "s", "p", "L", "d" ...

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the components are spherical harmonics, else cartesian

     n_comp :: INT, readonly  DEFAULT(0)
     ! No. of cartesian components for the gaussian shell

     n_sph :: INT, readonly  DEFAULT(0)
     ! No. of spherical components for the gaussian shell

     n_bf :: INT, readonly  DEFAULT(0)
     ! No. of basis functions in the shell

     first_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the first gaussian in the shell. For lookups.

     last_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the last gaussian in the shell. For lookups.

     n_cc :: INT  DEFAULT(0)
     ! No. of contractions for the gaussian shell

     ex :: VEC{REAL}* DEFAULT_NULL
     ! Exponent vector

     cc :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector

     cc_s :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector for s functions in an L shell

     cc_p :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector for p functions in an L shell

   end

   array type VEC{SHELL}

     ! A 1-D array of SHELL objects

   end

   type SHELL1

     l :: INT, readonly  DEFAULT(0)
     ! (Maximum) l quantum number of the shell
  
     l_chr :: STR, readonly  DEFAULT(" ")
     ! The character symbol for the shell e.g. "s", "p", "l", "d" ...

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the components are spherical harmonics, else cartesian

     n_comp :: INT, readonly  DEFAULT(0)
     ! No. of components for the shell

     n_sph :: INT, readonly  DEFAULT(0)
     ! No. of spherical components for the gaussian shell

     n_bf :: INT, readonly  DEFAULT(0)
     ! No. of basis functions in the shell

     first_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the first gaussian in the shell. For lookups.

     last_gaussian :: INT, readonly  DEFAULT(0)
     ! Lexical index of the last gaussian in the shell. For lookups.

     n_cc :: INT  DEFAULT(0)
     ! No. of contraction coefficients for the shell

     pos :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Position of the shell

     ex :: VEC{REAL}* DEFAULT_NULL
     ! Exponent vector

     cc :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector

     cc_s :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector for s functions in an L shell

     cc_p :: VEC{REAL}* DEFAULT_NULL
     ! Contraction coefficient vector for p functions in an L shell

   end

   type SHELL2

     a :: SHELL1, readonly
     ! Shell "a" of the pair

     b :: SHELL1, readonly
     ! Shell "b" of the pair

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the components are spherical harmonics, else cartesian

     n_gaussian_pairs :: INT, readonly
     ! The number of gaussian pair products in the shell pair, .a.n_cc*.b.n_cc

     l_max :: INT, readonly
     ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

     l_min :: INT, readonly
     ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

     l_sum :: INT, readonly
     ! Sum of the angular momenta on each shell, .a.l+.b.l

     first_gaussian :: INT, readonly
     ! Lexical index of the first gaussian in the shell with momentum .l_max

     last_gaussian :: INT, readonly
     ! Lexical index of the last gaussian in the shell with momentum .l_sum

     n_gaussian :: INT, readonly
     ! The number of gaussians in the source integral list.

   !  kappa_max :: REAL
   !  ! Maximum of .a.cc * .b.cc * kappa_ab for the two electron integrals.

     destroy_all :: BIN, readonly
     ! Set TRUE or if all the pointer parts are to be destroyed. Sometimes you
     ! want this FALSE when pointers are assigned to save computation.

     exponent_sum :: VEC{REAL}* DEFAULT_NULL
     ! The sum of all gaussian pair exponents as a flattened array with shell "a"
     ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

     exponent_inv :: VEC{REAL}* DEFAULT_NULL
     ! The inverse of the sum of the gaussian pair exponents, as a flattened
     ! array, 1/(.a.ex(:)+.b.ex(:))

   !  a_exponent_inv :: VEC{REAL}* DEFAULT_NULL
   !  ! The product of the exponent of shell "a" with the inverse of the sum of the
   !  ! gaussian pair exponents, as a flattened array, .a.ex(:)/(.a.ex(:)+.b.ex(:))

   !  b_exponent_inv :: VEC{REAL}* DEFAULT_NULL
   !  ! The product of the exponent of shell "b" with the inverse of the sum of the
   !  ! gaussian pair exponents, as a flattened array, .b.ex(:)/(.a.ex(:)+.b.ex(:))

     cc_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient product with an exponential part for each
     ! gaussian pair as a flattened array with shell "a" gaussian components
     ! incrementing most rapidly. Useful for integral evaluation.

     cc_s_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the s-function part of an L shell

     cc_p_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the p-function part of an L shell

     same_center :: BIN
     ! If TRUE, then the centers of a and b are the same.

     pair_center :: MAT{REAL}* DEFAULT_NULL
     ! The center of the product gaussian of gaussians .a and .b.

     center_diff :: MAT{REAL}* DEFAULT_NULL
     ! The difference between pair_center and the position of the gaussian of
     ! higher angular momentum out of .a and .b.

   end

   type SHELL1PAIR

     a :: SHELL1, readonly
     ! Shell "a" of the pair

     b :: SHELL1, readonly
     ! Shell "b" of the pair

     n_gaussian_pairs :: INT, readonly
     ! The number of gaussian pair products in the shell pair, .a.n_cc*.b.n_cc

     n_comp_pairs :: INT, readonly
     ! The number of cartesian gaussian component pairs in the shell
     ! pair, i.e.  .a.n_comp*.b.n_comp

     n_sph_pairs :: INT, readonly
     ! The number of spherical gaussian component pairs in the shell
     ! pair, i.e.  .a.n_sph*.b.n_sph

     n_bf_pairs :: INT, readonly
     ! The number of basis function component pairs in the shell pair,

     l_max :: INT, readonly
     ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

     l_min :: INT, readonly
     ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

     l_sum :: INT, readonly
     ! Sum of the angular momenta on each shell

     first_gaussian :: INT, readonly
     ! Lexical index of the first gaussian in the shell with momentum .l_max

     last_gaussian :: INT, readonly
     ! Lexical index of the last gaussian in the shell with momentum .l_sum

     n_gaussian :: INT, readonly
     ! The number of gaussians in the source integral list.

   !  kappa_max :: REAL
   !  ! Maximum of .a.cc * .b.cc * kappa_ab for the two electron integrals.

   !  exponent_a :: VEC{REAL}* DEFAULT_NULL
   !  ! The a exponent.

   !  exponent_b :: VEC{REAL}* DEFAULT_NULL
   !  ! The b exponent.

     exponent_sum :: VEC{REAL}* DEFAULT_NULL
     ! The sum of all gaussian pair exponents as a flattened array with shell "a"
     ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

     exponent_inv :: VEC{REAL}* DEFAULT_NULL
     ! The inverse of the sum of the gaussian pair exponents, as a flattened
     ! array, 1/(.a.ex(:)+.b.ex(:))

   !  a_exponent_inv :: VEC{REAL}* DEFAULT_NULL
   !  ! The product of the exponent of shell "a" with the inverse of the sum of the
   !  ! gaussian pair exponents, as a flattened array, .a.ex(:)/(.a.ex(:)+.b.ex(:))

   !  b_exponent_inv :: VEC{REAL}* DEFAULT_NULL
   !  ! The product of the exponent of shell "b" with the inverse of the sum of the
   !  ! gaussian pair exponents, as a flattened array, .b.ex(:)/(.a.ex(:)+.b.ex(:))

     cc_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient product with an exponential part for each
     ! gaussian pair as a flattened array with shell "a" gaussian components
     ! incrementing most rapidly. Useful for integral evaluation.

     cc_s_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the s-function part of an L shell

     cc_p_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the p-function part of an L shell

     pair_center :: MAT{REAL}* DEFAULT_NULL
     ! The center of the product gaussian of gaussians .a and .b.

     center_diff :: MAT{REAL}* DEFAULT_NULL
     ! The difference between pair_center and the position of the gaussian of
     ! higher angular momentum out of .a and .b.

   end

   array type MAT{SHELL1PAIR}

     ! A 1-D array of SHELL1PAIR objects

   end

   type SHELL4

     a :: SHELL1
     ! Shell "a" of the quartet

     b :: SHELL1
     ! Shell "b" of the quartet

     c :: SHELL1
     ! Shell "c" of the quartet

     d :: SHELL1
     ! Shell "d" of the quartet

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the integrals from this shell should be converted
     ! to spherical harmonics

   end

   type SHELL1QUARTET

     a :: SHELL1 
     ! Shell "a" of the quartet

     b :: SHELL1 
     ! Shell "b" of the quartet

     c :: SHELL1 
     ! Shell "c" of the quartet

     d :: SHELL1 
     ! Shell "d" of the quartet

     is_spherical :: BIN, readonly  DEFAULT(SHELL_IS_SPHERICAL)
     ! Set TRUE if the integrals from this shell should be converted
     ! to spherical harmonics

     ab_nullify :: BIN
     ! Whether to nullify the precalculated .ab vectors or destroy them, i.e.
     ! whether they were pointer assigned or created/calculated.

     cd_nullify :: BIN
     ! Whether to nullify the precalculated .cd vectors or destroy them, i.e.
     ! whether they were pointer assigned or created/calculated.

     ab_n_gaussian_pairs :: INT
     ! The number of (ab| gaussian pair products in the shell pair

     ab_n_comp_pairs :: INT
     ! The number of (ab| cartesian basis function pairs in the shell pair

     ab_n_sph_pairs :: INT
     ! The number of (ab| spherical basis function pairs in the shell pair

     ab_n_bf_pairs :: INT
     ! The number of (ab| basis function pairs in the shell pair

     ab_l_max :: INT
     ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

     ab_l_min :: INT
     ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

     ab_l_tri :: INT
     ! Triangular index for the ab angular momentum pair

     ab_l_sum :: INT
     ! Sum of the angular momenta on each shell, .a.l+.b.l

     ab_first_gaussian :: INT
     ! Index of first gaussian in pair ab

     ab_last_gaussian :: INT
     ! Index of last gaussian in pair ab

     n_ab :: INT
     ! The number of ab gaussian functions required for the source integrals.

   !  ab_kappa_max :: REAL
   !  ! Maximum of .a.cc * .b.cc * kappa_ab for the two electron integrals.

     ab_exponent_sum :: VEC{REAL}* DEFAULT_NULL
     ! The sum of all gaussian pair exponents as a flattened array with shell "a"
     ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

     ab_exponent_inv :: VEC{REAL}* DEFAULT_NULL
     ! The inverse of ab_exponent_sum.

     ab_cc_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient product with an exponential part for each
     ! gaussian pair as a flattened array with shell "a" gaussian components
     ! incrementing most rapidly. Useful for integral evaluation.

     ab_cc_s_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the s-function part of an L shell

     ab_cc_p_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the p-function part of an L shell

     ab_same_center :: BIN
     ! Whether centers of a and b are the same.

     ab_pair_center :: MAT{REAL}* DEFAULT_NULL
     ! The center of the product gaussian of gaussians .a and .b.

     ab_center_diff :: MAT{REAL}* DEFAULT_NULL
     ! The difference between ab_pair_center and the position of the gaussian of
     ! higher angular momentum out of .a and .b.

     cd_n_gaussian_pairs :: INT
     ! The number of |cd) gaussian pair products in the shell pair

     cd_n_comp_pairs :: INT
     ! The number of |cd) cartesian basis function pairs in the shell pair

     cd_n_sph_pairs :: INT
     ! The number of |cd) spherical basis function pairs in the shell pair

     cd_n_bf_pairs :: INT
     ! The number of |cd) basis function component pairs in the shell pair

     cd_l_max :: INT
     ! Maximum of the angular momenta on each shell, max(.c.l,.d.l)

     cd_l_min :: INT
     ! Minimum of the angular momenta on each shell, min(.c.l,.d.l)

     cd_l_tri :: INT
     ! Triangular index for the cd angular momentum pair

     cd_l_sum :: INT
     ! Sum of the angular momenta on each shell, .c.l+.d.l

     cd_first_gaussian :: INT
     ! Index of first gaussian in pair cd

     cd_last_gaussian :: INT
     ! Index of last gaussian in pair cd

     n_cd :: INT
     ! The number of cd gaussian functions required for the source integrals.

   !  cd_kappa_max :: REAL
   !  ! Maximum of .c.cc * .d.cc * kappa_cd for the two electron integrals.

     cd_exponent_sum :: VEC{REAL}* DEFAULT_NULL
     ! The sum of all gaussian pair exponents as a flattened array with shell "c"
     ! exponents incrementing most rapidly, .c.ex(:)+.d.ex(:)

     cd_exponent_inv :: VEC{REAL}* DEFAULT_NULL
     ! The inverse of ab_exponent_sum.

     cd_cc_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient product with an exponential part for each
     ! gaussian pair as a flattened array with shell "c" gaussian components
     ! incrementing most rapidly. Useful for integral evaluation.

     cd_cc_s_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the s-function part of an L shell

     cd_cc_p_prefactor :: VEC{REAL}* DEFAULT_NULL
     ! As above, for the p-function part of an L shell

     cd_same_center :: BIN
     ! Whether centers of c and c are the same.

     cd_pair_center :: MAT{REAL}* DEFAULT_NULL
     ! The center of the product gaussian of gaussians .c and .d.

     cd_center_diff :: MAT{REAL}* DEFAULT_NULL
     ! The difference between cd_pair_center and the position of the gaussian of
     ! higher angular momentum out of .c and .d.

     ab_form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .ab_l_max up to .a.l+.b.l.

     ab_form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .ab_l_max up to .a.l+.b.l.

     ab_form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .ab_l_max up to .a.l+.b.l.

     ab_form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .ab_l_max up to .a.l+.b.l.  This version is for the
     ! reduced multiplication scheme, where the y and z arrays have been collapsed
     ! into one product array.

     cd_form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .cd_l_max up to .c.l+.d.l.

     cd_form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .cd_l_max up to .c.l+.d.l.

     cd_form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .cd_l_max up to .c.l+.d.l.

     cd_form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL
     ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
     ! angular momenta from .cd_l_max up to .c.l+.d.l.  This version is for the
     ! reduced multiplication scheme, where the y and z arrays have been collapsed
     ! into one product array.

     r2ab :: REAL
     ! The distance between shells .a and .b.

     r2cd :: REAL
     ! The distance between shells .c and .d.

   end

   type BASIS

     label :: STR
     ! Unique label for the basis set

     is_spherical :: BIN   DEFAULT(FALSE)
     ! Set TRUE if using spherical harmonic basis

     n_shell :: INT
     ! No. of shells in the basis, equal to size(shell)

     n_bf :: INT
     ! No. of basis functions for the shell

     n_prim :: INT
     ! No. of primitives for the shell

     shell :: VEC{SHELL}* DEFAULT_NULL
     ! The list of gaussian shells in the basis set

   end

   array type VEC{BASIS}

     ! A 1-D array of BASIS objects

   end

   type INTERPOLATOR

     interpolation_method :: STR, readonly  DEFAULT(INTERPOLATOR_INTERPOLATION_METHOD)
     ! The interpolation method used, usually "linear". Also allowed
     ! is "cubic_spline". 

     interpolation_is_spline :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if it is a spline interpolation

     range_mapping :: STR, readonly  DEFAULT(INTERPOLATOR_RANGE_MAPPING)
     ! How the function values are treated before being stored as
     ! interpolation table data_values, i.e. "none" or "logarithmic"

     range_is_logarithmic :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if range has ben logged

     domain_mapping :: STR, readonly  DEFAULT(INTERPOLATOR_DOMAIN_MAPPING)
     ! How the data_points are treated before evaluation by the
     ! interpolation function, e.g. "none", "sqrt", "sqrt(x/(1-x))*scale".
     ! NOTE: when obtaining the tabulated values it is the users
     ! responsibility to use the inverse domain mapping function to
     ! obtain the actual table value x.

     domain_scale_factor :: REAL, readonly  DEFAULT(ZERO)
     ! A factor which is used to rescale the domain mapping function

     domain_is_sqrt :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if domain has been sqrted

     domain_is_sqrt_x1x :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if domain maps to sqrt(x/(1-x))

     table_origin :: REAL  DEFAULT(INTERPOLATOR_TABLE_ORIGIN)
     ! The origin of the table use i.e. where the table starts. Used for setting
     ! up even spaced data.

     table_length :: REAL  DEFAULT(INTERPOLATOR_TABLE_LENGTH)
     ! The length of the table use; it starts from the origin. Used for setting up
     ! even spaced data.

     table_spacing :: REAL  DEFAULT(INTERPOLATOR_TABLE_SPACING)
     ! The spacing between data points, if using an even spaced grid.
     ! (this is the case if spacing in non-zero)

     table_eps :: REAL  DEFAULT(INTERPOLATOR_TABLE_EPS)
     ! If there are values smaller than this in the interpolation table, they are
     ! set to zero. The interpolation table may be reduced in size.

     n_data :: INT  DEFAULT(0)
     ! The number of "data_points" and "values" in the table.

     data_point :: VEC{REAL}*  DEFAULT_NULL
     ! The list of data points, from smallest to largest.

     data_value :: VEC{REAL}*  DEFAULT_NULL
     ! The list of values corresponding to each data value.

     finalised :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the object is ready for use

     y2 :: VEC{REAL}*  DEFAULT_NULL
     ! The tabulated values of the second derivatives at the data_point's. This is
     ! used only for cubic spline interpolation.

     y1_initial :: REAL  DEFAULT(INTERPOLATOR_Y1_INITIAL)
     ! The first derivative at the initial data_point to use, when doing cubic
     ! spline interpolation.

     y1_final :: REAL  DEFAULT(INTERPOLATOR_Y1_FINAL)
     ! The first derivative at the final data_point to use, when doing cubic
     ! spline interpolation.

   end

   array type VEC{INTERPOLATOR}

     ! A 1-D array of INTERPOLATOR objects

   end

   type SLATERSHELL

     l :: INT, readonly  DEFAULT(0)
     ! l quantum number 
  
     l_chr :: STR, readonly  DEFAULT(" ")
     ! The character symbol for the shell e.g. "s", "p", "l", "d" ...

     n_comp :: INT, readonly  DEFAULT(0)
     ! The number of l-components, normally 2*l+1 for spherical type slater
     ! functions.

     n_orb :: INT, readonly DEFAULT(0)
     ! The number of generally contracted orbitals.

     n_prim :: INT, readonly  DEFAULT(0)
     ! No. of exponents/contractions (i.e. the number of primitives for one
     ! *single* angular momentum shell component, e.g. p_x).

     n :: VEC{INT}* DEFAULT_NULL
     ! The n quantum numbers.

     z :: VEC{REAL}* DEFAULT_NULL
     ! The exponent zeta for each slater function

     c :: MAT{REAL}* DEFAULT_NULL
     ! The contraction coefficient matrix -- this is a generally contracted slater
     ! shell. The size of .dim1 is "n_cc". The size of .dim2 is "n_orb".

     orb_kind :: VEC{STR}* DEFAULT_NULL
     ! The kinds of the orbitals (1s, 2s, 2p, etc.), if available.
     ! It's length is "n_orb".

     occupancy :: VEC{INT}* DEFAULT_NULL
     ! The occupany number of each contracted orbital, if available.
     ! It's length is "n_orb".

   end

   array type VEC{SLATERSHELL}

     ! A 1-D array of SLATERSHELL objects

   end

   type SLATERBASIS

     label :: STR
     ! Unique label for the basis set

     configuration :: STR
     ! A STR representation of the configuration.

     n_shell :: INT
     ! No. of shells in the basis, equal to size(shell)

     n_bf :: INT
     ! No. of basis functions for the shell

     n_prim :: INT
     ! No. of primitives for the shell

     shell :: VEC{SLATERSHELL}*  DEFAULT_NULL
     ! The list of gaussian shells in the basis set

     use_interpolator :: BIN  DEFAULT(TRUE)
     ! Whether to use interpolators

     interpolator :: INTERPOLATOR*  DEFAULT_NULL
     ! An interpolator object, used for calculating the atomic density at a
     ! certain radius, from the slater "shell" of orbitals

     d1_interpolator :: INTERPOLATOR*  DEFAULT_NULL
     ! The same as above, but for the 1st derivative of the density.

     d2_interpolator :: INTERPOLATOR*  DEFAULT_NULL
     ! The same as above, but for the 2nd derivative of the density.

   end

   array type VEC{SLATERBASIS}

     ! A 1-D array of SLATERBASIS objects

   end

   type COPPENSORBITAL

     orb_kind :: STR, readonly
     ! The kind of the orbital (1s, 2s, 2p, etc.)

     occupancy :: INT, readonly
     ! The number of electrons in the orbital.

     n_fun :: INT, readonly
     ! The number of contracted fitting functions

     n :: VEC{INT}* DEFAULT_NULL
     ! The n quantum numbers

     c :: VEC{REAL}* DEFAULT_NULL
     ! The contraction coefficient

     z :: VEC{REAL}* DEFAULT_NULL
     ! The exponent zeta for each slater function

   end

   array type VEC{COPPENSORBITAL}

     ! A 1-D array of COPPENSORBITAL objects

   end

   type COPPENSBASIS

     label :: STR
     ! The basis label

     n_orb :: INT
     ! The number of orbitals in the basis

     n_prim :: INT
     ! The number of primitive functions in the basis

     orbital :: VEC{COPPENSORBITAL}*  DEFAULT_NULL
     ! The list of fitted Slater atomic orbitals, Coppens style.

     use_interpolator :: BIN  DEFAULT(TRUE)
     ! Whether to use interpolators

     interpolator :: INTERPOLATOR*  DEFAULT_NULL
     ! An interpolator object, used for calculating the atomic density at a
     ! certain radius, from e.g. the coppensbasis

   end

   array type VEC{COPPENSBASIS}

     ! A 1-D array of COPPENSBASIS objects

   end

   type ATOM

     label :: STR  DEFAULT("?")
     ! The label for the atom (not necessarily unique)

     atomic_number :: INT
     ! The atomic number

     oxidation_state :: INT   DEFAULT(0)
     ! The atomic oxidation state

     pos :: VEC{REAL}(3)
     ! Atom position

     axis_system :: STR  DEFAULT("cartesian")
     ! Specifies the coordinate axis system

     U_iso :: REAL  DEFAULT(ZERO)
     ! The isotropic thermal smearing value for the atom

     thermal_tensor :: MAT{REAL}(3,3)  DEFAULT(ZERO)
     ! The thermal tensor for the atom

     thermal_axis_system :: STR  DEFAULT("cartesian")
     ! Specifies the thermal tensor coordinate system

     charge :: REAL  DEFAULT(ZERO)
     ! The charge on the atom

     dipole :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! The dipole on the atom

     quadrupole :: MAT{REAL}(3,3)  DEFAULT(ZERO)
     ! The quadrupole on the atom

     spin :: REAL  DEFAULT(ZERO)
     ! The value of unpaired spin on this atom

     spin_dipole :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! The Sz spin dipole on the atom

     spin_quadrupole :: MAT{REAL}(3,3)  DEFAULT(ZERO)
     ! The Sz spin quadrupole on the atom

     charge_polarisability :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! The charge polarisability on the atom

     dipole_polarisability :: MAT{REAL}(3,3)  DEFAULT(ZERO)
     ! The dipole polarisability on the atom

     basis_label :: STR  DEFAULT(" ")
     ! The label of the basis set to match to. e.g. when looking in
     ! the library

     basis_kind :: STR  DEFAULT(" ")
     ! The kind of basis set to use in calculations. Note that there
     ! may be more than omne type of basis present for an atom.

     basis :: BASIS* DEFAULT_NULL
     ! The basis for the atom

     slaterbasis_label :: STR  DEFAULT(" ")
     ! The label of the slater basis set to match to.

     slaterbasis :: SLATERBASIS* DEFAULT_NULL
     ! The Slater function basis set for the atom. This includes
     ! occupancies and can be used for Hirshfeld surface plots and
     ! sum-of-spherical atoms densities.

     coppensbasis_label :: STR  DEFAULT(" ")
     ! The label of the coppens basis set to match to.

     coppensbasis :: COPPENSBASIS* DEFAULT_NULL
     ! The Coppens-style fitted relativistic orbital basis for the
     ! atom. This is used for Hirshfeld surface plots and
     ! sum-of-spherical atoms densities.

     atomic_orbitals :: OPMATRIX* DEFAULT_NULL
     ! The atomic orbitals for the atom

     density_matrix :: OPMATRIX* DEFAULT_NULL
     ! The density matrix for the atom

     natural_orbitals :: OPMATRIX* DEFAULT_NULL
     ! The natural orbitals for the atom

     occupation_numbers :: OPVECTOR* DEFAULT_NULL
     ! The occupation numbers for the atom

     use_interpolator :: BIN  DEFAULT(TRUE)
     ! Whether to use interpolators for spherical densities

     interpolator :: INTERPOLATOR*  DEFAULT_NULL
     ! An interpolator object, used for calculating the atomic
     ! density at a certain radius. This is for gaussian bases only.

     first_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL
     ! First basis function for a given shell

     last_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL
     ! Last basis function for a given shell

     precomputed_basis_shellpair :: MAT{SHELL1PAIR}* DEFAULT_NULL
     ! Precomputed stuff for shellpairs of the basis set, to speed up
     ! later calculations of gaussian integrals.

     energy :: REAL
     ! The energy of the isolated atom

     group :: INT
     ! An integer which describes thr group to which the atom belongs

     invariom_label :: STR  DEFAULT(" ")
     ! The label for the invariom 

     protein_strand :: INT   DEFAULT(0)
     ! Protein strand that this atom belongs to

     residue_atom_code :: STR  DEFAULT(" ")
     ! The unique code for the atom in its (protein-)residue

     residue_code :: STR  DEFAULT(" ")
     ! The parent protein residue code that this atom belongs to

     residue_sequence_number :: INT  DEFAULT(0)
     ! The residue sequence number 

     mm_forcefield_name :: STR  DEFAULT(" ")
     ! The name of the forcefield (e.g. amber, sybyl,...)

     mm_atom_type :: STR  DEFAULT(" ")
     ! The atom type, used to define the force field potential

     mm_charge :: REAL  DEFAULT(ZERO)
     ! The atomic charge (relative to the force field!)

     restraining_position :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! A position used for restrained geometry optimization

     restraining_force_constant :: REAL  DEFAULT(ZERO)
     ! A force constant used for restrained geometry optimisations

     site_occupancy :: REAL  DEFAULT(ONE)
     ! The crystallographic site occupancy.

     site_disorder_group :: INT  DEFAULT(ZERO)
     ! The crystallographic site disorder group.

   end

   array type VEC{ATOM}

     ! A 1-D array of ATOM's

   end

   type PLOT_GRID

     plot_kind :: STR  DEFAULT(" ")
     ! The type of plot calculation wanted

     orbital :: INT  DEFAULT(0)
     ! The orbital to plot (if any)

     HOMO_orbital :: INT  DEFAULT(0)
     ! The HOMO orbital to plot. A value "n" indicates the HOMO+"n".

     LUMO_orbital :: INT  DEFAULT(0)
     ! The LUMO orbital to plot. A value "n" indicates the LUMO+"n".

     bond_density_atom :: VEC{INT}*   DEFAULT_NULL
     ! Pair of atoms indices whose bond density should be plotted.
     ! Triple indicates an atom within a bond.

     interpolator :: INTERPOLATOR*  DEFAULT_NULL
     ! This is used for setting defaults for isosurfaces which make
     ! use of spherical atomiuc densities.

     n_x :: INT  DEFAULT(PLOT_GRID_NX)
     ! The number of points on the x-axis

     n_y :: INT  DEFAULT(PLOT_GRID_NY)
     ! The number of points on the y-axis

     n_z :: INT  DEFAULT(PLOT_GRID_NZ)
     ! The number of points on the z-axis

     n_pt :: INT  DEFAULT(0)
     ! The total no. of points in the plot

     atom :: VEC{ATOM}* DEFAULT_NULL
     ! List of atoms which can be used to define grid aces and positions.

     destroy_atom :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the .atom list must be destroyed.

     centre_atom :: INT  DEFAULT(0)
     ! Use this atom as the centre of the plot

     x_atom_1, x_atom_2 :: INT
     ! These atoms define the x-axis of the plot

     y_atom_1, y_atom_2 :: INT
     ! These atoms define the y-axis of the plot (made orthogonal to the x-axis)

     z_atom_1, z_atom_2 :: INT
     ! These atoms define the z-axis of the plot.

     del_x :: REAL  DEFAULT(ONE)
     ! The distance between axis points in the plot

     del_y :: REAL  DEFAULT(ONE)
     ! The distance between axis points in the plot

     del_z :: REAL  DEFAULT(ONE)
     ! The distance between axis points in the plot

     centre :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Centre of the plot

     origin :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Bottom left point of the plot

     x_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_X_AXIS)
     ! x-axis of the plot

     y_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_Y_AXIS)
     ! y-axis of the plot

     z_axis :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_Z_AXIS)
     ! z-axis of the plot

     width :: VEC{REAL}(3)  DEFAULT(PLOT_GRID_WIDTH)
     ! The widths (in a.u.) of each axis of the plot

     offset :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! The centre of the plot is offset by this amount

     x_width_set :: BIN  DEFAULT(TRUE)
     ! If False the x_width, i.e. width(1), is to be calculated from the size of
     ! the inputted x_axis vector; or if a width has *not* been inputted.

     y_width_set :: BIN  DEFAULT(TRUE)
     ! If False the y_width, i.e. width(2), is to be calculated from the size of
     ! the inputted y_axis vector; or if a width has *not* been inputted.

     z_width_set :: BIN  DEFAULT(TRUE)
     ! If False the z_width, i.e. width(3), is to be calculated from the size of
     ! the inputted z_axis vector; or if a width has *not* been inputted.

     x_axis_defined :: BIN  DEFAULT(FALSE)
     ! Flag set true if the user has defined the x_axis in the input

     y_axis_defined :: BIN  DEFAULT(FALSE)
     ! Flag set true if the user has defined the y_axis in the input

     z_axis_defined :: BIN  DEFAULT(FALSE)
     ! Flag set true if the user has defined the z_axis in the input

     box_centre :: VEC{REAL}(3)
     ! The centre of the bounding box, defined as the centre of an optional
     ! inputted atom list.

     bounding_box :: VEC{REAL}(3)
     ! The bounding box for the molecule, defined from an optional atom list.

     box_scale_factor :: REAL
     ! Scale factor for the bounding box.  Usually leave it at 1.

     box_axes :: MAT{REAL}(3,3)
     ! The axes of the bounding box, defined as the principal axes of the shape
     ! tensor (essentially the unit weighted moment of inertia tensor). Defined
     ! from an optionally inputted atom list.

     use_unit_cell_as_bbox :: BIN   DEFAULT(FALSE)
     ! IF set TRUE the bounding box is supposed to bethe unit cell.

     desired_separation :: REAL  DEFAULT(ZERO)
     ! The desired separation between grid points.

     plot_units :: STR  DEFAULT(" ")
     ! Default units for the plot: the value is used to convert the grid values

     plot_format :: STR  DEFAULT(" ")
     ! Default format for the plot: if blank, all known formats are produced.

     use_plot_max :: BIN   DEFAULT(FALSE)
     ! Whether to reset the plot maximum

     use_plot_min :: BIN   DEFAULT(FALSE)
     ! Whether to reset the plot minimum

     plot_max :: REAL   DEFAULT(ZERO)
     ! Whether to reset the plot maximum

     plot_min :: REAL   DEFAULT(ZERO)
     ! Whether to reset the plot minimum

   end

   type DFT_FUNCTIONAL

     name :: STR  DEFAULT(" ")
     ! The name of the functional to use

     Xalpha :: REAL  DEFAULT(DFT_FUNCTIONAL_XALPHA)
     ! The valueof the alpha parameter in the Xalpha functional

     rho_cutoff :: REAL   DEFAULT(DFT_FUNCTIONAL_RHO_CUTOFF)
     ! The value of the density below which the functional and the potential are
     ! set to zero.

   end

   type BECKE_GRID

     kind :: STR  DEFAULT(BECKE_GRID_KIND)
     ! The exact type of Becke grid to use

     atom :: VEC{ATOM}*
     ! A list of atoms for which the DFT integration grids are to be made.
     ! It is just pointer copied. If associated, it is used to generate the atom
     ! basis function grids for gaussian DFT calculations.

     atom_Z :: VEC{INT}*  DEFAULT_NULL
     ! List of atomic numbers for the atoms which are to be integrated

     atom_pos :: MAT{REAL}*  DEFAULT_NULL
     ! List of atomic positions for the atoms which are to be integrated

     atom_zeta :: VEC{REAL}*  DEFAULT_NULL
     ! List of scaling factors used in the transformation to the radial
     ! integration interval.

     atom_lowest_exponents :: VEC{REAL}* DEFAULT_NULL
     ! List of lowest exponents for the atoms basis functions. Used to prune
     ! radial grid points when it is known for certain that the grid is to be used
     ! for evaluating basis function matrix elements.

     atom_min_distance :: VEC{REAL}*, private  DEFAULT_NULL
     ! For every atom, the minimum distance to the nearest atom.

     atom_min_distance2 :: VEC{REAL}*, private  DEFAULT_NULL
     ! For every atom, the square of the minimum distance to the
     ! nearest atom.

     r_max_SS :: VEC{REAL}*, private  DEFAULT_NULL
     ! For each atom, the minimum distances for Stratmann-Scuseria partitioning

     r_max_S2 :: VEC{REAL}*, private  DEFAULT_NULL
     ! For each atom, the minimum squared distances for
     ! Stratmann-Scuseria partitioning

     n_unique_atoms :: INT, private
     ! No. of atoms of unique kind. An atom is the same as another if it has the
     ! same nuclear charge.

     unique_atom :: VEC{INT}*, private  DEFAULT_NULL
     ! unique_atom(k) is the index of the "k"-th unique atom.

     unique_atom_for :: VEC{INT}*, private  DEFAULT_NULL
     ! unique_atom_for(a) is the index of the unique atom equivalent to "a".

     basis_function_cutoff :: REAL  DEFAULT(BECKE_GRID_BASIS_FUNCTION_CUTOFF)
     ! Below this cutoff, *atomic* grid points whose corresponding basis function values
     ! (which are to be integrated) are assumed to be zero. In combination with
     ! the .atom_lowest_exponents this cutoff is used to prune *atomic* grids of
     ! unnecessary points.

     basis_function_pair_cutoff :: REAL  DEFAULT(BECKE_GRID_RHO_CUTOFF)
     ! *Atom pair* grid points where the *product* of the two basis function
     ! values is smaller than this cutoff are assumed to be zero. In combination
     ! with the .atom_lowest_exponents this cutoff is used to prune *atom pair*
     ! grids of unnecessary points.

     partition_cutoff :: REAL  DEFAULT(BECKE_GRID_PARTITION_CUTOFF)
     ! Below this cutoff, basis function values which are to be integrated are
     ! assumed to be zero. In combination with the .atom_lowest_exponents 

     rho_cutoff :: REAL   DEFAULT(BECKE_GRID_RHO_CUTOFF)
     ! The value of the density below which the functional and the potential are
     ! set to zero on this grid. This variable is passed to the DFT_FUNCTIONAL
     ! object. It is also used to eliminate density evaluation at grid points, and
     ! it determines the overlapping_atoms array.

     n_radial_points ::  INT DEFAULT(0)
     ! No. of radial points desired for the Hydrogen atom. The number of points
     ! used for other atoms is normally 5 more for every extra shell, according
     ! to Becke's original rule of thumb.

     n_extra_points_per_shell :: INT DEFAULT(BECKE_GRID_EXTRA_POINTS_PER_SHELL)
     ! The number of extra points to use per n-shell over and above the default
     ! number .n_radial_points for the Hydrogen atom.

     accuracy :: STR  DEFAULT(BECKE_GRID_ACCURACY)
     ! A keyword describing the desired accuracy of the integration grid.

     l_angular_grid :: INT DEFAULT(0)
     ! Angular momentum which is to be integrated exactly by the angular grid.

     l_H_angular_grid :: INT DEFAULT(0)
     ! Angular momentum which is to be integrated exactly by the angular grid
     ! for the Hydrogen/Helium atoms only. For other atoms .l_angular_grid is used.

     pruning_scheme :: STR  DEFAULT(BECKE_GRID_PRUNING_SCHEME)
     ! This describes the method to reduce angluar grids near the atomic nuclei.
     ! It can be "none", "treutler_ahlrichs", or "sg-1". This variable sets the
     ! .reduce_core_angular_grid and .reduce_H_angular_grid switches.

    ! reduce_core_angular_grid :: BIN  DEFAULT(BECKE_GRID_REDUCE_CORE_ANGULAR_GRID)
    ! ! If set TRUE the order of the angular grid near the core of the atom is
    ! ! reduced to make smaller meshes. So far the scheme of Treutler and Ahlrichs
    ! ! is used.

     reduce_H_angular_grid :: BIN  DEFAULT(BECKE_GRID_REDUCE_H_ANGULAR_GRID)
     ! If set TRUE the order of the angular grid for Hydrogen and Helium are
     ! reduced to .l_H_angular_grid.

     scale_atomic_grids :: BIN  DEFAULT(BECKE_GRID_SCALE_ATOMIC_GRIDS)
     ! If set TRUE, the atomic grids are scaled according to the authors
     ! recommended scaling factors. This does *not* mean that the partition
     ! function is also scaled to account for varying atomic sizes.

     partition_power :: INT  DEFAULT(BECKE_GRID_PARTITION_POWER)
     ! Used in smoothing the partition boundary

     stratmann_scuseria_A :: REAL  DEFAULT(BECKE_GRID_STRATMANN_SCUSERIA_A)
     ! The Stratmann-Scuseria "a" parameter, used in defining their piecewise
     ! partition function. See CPL 257 p. 213 (1996).

     partition_scheme :: STR  DEFAULT(BECKE_GRID_PARTITION_SCHEME)
     ! This describes the method to partition the electron density into atomic
     ! contributions which are then integrated separately. Currently there are
     ! "becke" and "delley". The former is based on smoothed-out Voronoi
     ! polyhedra. The latter are based on Hirshfeld-like partitioning using
     ! exponential functions.

     partition_scaling_scheme :: STR  DEFAULT(BECKE_GRID_PARTITION_SCALING_SCHEME)
     ! This chooses the precise method to scale the sizes of the "atoms" generated
     ! by the atomic partition function. For "becke" partitioning the default is
     ! by "truetler_ahlrichs", but you can choose "none" or "becke". For "delley"
     ! partitioning the only option is "none" i.e. no atomic rescaling.  Usually
     ! the scaling is based on the Bragg-Slater radii (except for H, where twice
     ! the radii is used). Treutler and Ahlrichs recommended using the square root
     ! of the ratio of Bragg Slater radii.

     finalized :: BIN  DEFAULT(FALSE)
     ! Set to true if the DFTGRID has been "set" using set_grid_data

     n_points_for_row :: VEC{INT}*, private  DEFAULT_NULL
     ! The number of points for a given row of the periodic table, for the
     ! current grid settings.

     radial_grid :: VEC{QUADRATURE}*  DEFAULT_NULL
     ! The radial quadrature points, one for every row of the periodic table.

     lebedev_grid :: LEBEDEV*  DEFAULT_NULL
     ! The angular quadrature points. We use a Lebedev grid.

     lebedev_H_grid :: LEBEDEV*  DEFAULT_NULL
     ! The angular quadrature points for the Hydrogen atom.

     lebedev_L3_grid :: LEBEDEV*  DEFAULT_NULL
     ! Angular quadrature points for L=3, used close to the atom.

     lebedev_L5_grid :: LEBEDEV*  DEFAULT_NULL
     ! Angular quadrature points for L=5, used close to the atom.

     lebedev_L7_grid :: LEBEDEV*  DEFAULT_NULL
     ! Angular quadrature points for L=7, used close to the atom.

     lebedev_L9_grid :: LEBEDEV*  DEFAULT_NULL
     ! Angular quadrature points for L=9, used close to the atom.

     lebedev_L11_grid :: LEBEDEV*  DEFAULT_NULL
     ! Angular quadrature points for L=11, used close to the atom.

     n_unscaled_points :: INT DEFAULT(0)
     ! No. of quadrature points in the reference atom.

     unscaled_point :: MAT{REAL}*, private  DEFAULT_NULL
     ! The unscaled spherical quadrature grid points centered at the origin, 
     ! for a reference atom.

     unscaled_weight :: VEC{REAL}*, private  DEFAULT_NULL
     ! The unscaled spherical quadrature grid weights for a reference atom.

     n_points :: INT DEFAULT(0)
     ! No. of points in quadrature grid for the whole molecule.

     atom_points :: VEC{MAT_{REAL}}*  DEFAULT_NULL
     ! The complete list of grid points for the unique atoms in .atoms_Z

     atom_weights :: VEC{VEC_{REAL}}*  DEFAULT_NULL
     ! The complete list of grid weights for the unique atoms in .atom_Z.

     atom_grid0 :: VEC{MAT_{REAL}}*  DEFAULT_NULL
     ! List of atomic density grids for the unique atoms

     atom_grid1 :: VEC{MAT3_{REAL}}*  DEFAULT_NULL
     ! List of atomic gradient density grids for the unique atoms

     weight_is_0 :: VEC{BIN}*  DEFAULT_NULL
     ! Set to TRUE if the weight for a particular point is zero. Used to eliminate
     ! grid points from product grids.

   end

   type DFTGRID

     spherical_grid_kind :: STR  DEFAULT(DFTGRID_SPHERICAL_GRID_KIND)
     ! Identifier for the kind of spherical grid

     radial_grid_kind :: STR  DEFAULT(DFTGRID_RADIAL_GRID_KIND)
     ! Type of radial grid

     spherical_grid_order :: INT  DEFAULT(DFTGRID_SPHERICAL_GRID_ORDER)
     ! Order of the spherical grid

     radial_grid_order :: INT  DEFAULT(DFTGRID_RADIAL_GRID_ORDER)
     ! Order of the radial grid

     n_spherical_pts :: INT  DEFAULT(0)
     ! No of spherical grid points

     n_radial_pts :: INT  DEFAULT(0)
     ! No of radial grid points

     n_pts :: INT  DEFAULT(0)
     ! No of integration grid points

     becke_m_partition_power :: REAL  DEFAULT(DFTGRID_BECKE_M_PARTITION_POWER)
     ! Used in smoothing the partition boundary

     gauss_chebyshev_alpha :: REAL  DEFAULT(DFTGRID_GAUSS_CHEBYSHEV_ALPHA)
     ! Gauss-Chebychev radial grid parameters

     gauss_chebyshev_m :: REAL   DEFAULT(DFTGRID_GAUSS_CHEBYSHEV_M)
     ! ?

     euler_maclaurin_alpha :: REAL  DEFAULT(DFTGRID_EULER_MACLAURIN_ALPHA)
     ! Euler-Maclaurin radial grid parameters

     euler_maclaurin_m :: REAL   DEFAULT(DFTGRID_EULER_MACLAURIN_M)
     !

     archive :: ARCHIVE
     ! Archive to store the generated grids

     finalized :: BIN  DEFAULT(FALSE)
     ! Set to true if the DFTGRID has been "set" using set_grid_data

     reference_atom_points :: MAT{REAL}* DEFAULT_NULL
     ! The dft grid points at the origin for a single (unscaled) reference atom.

     reference_atom_weights :: VEC{REAL}* DEFAULT_NULL
     ! The dft grid weights at the origin for a single (unscaled) reference atom.

   end

   type IRREP

     label :: STR(4)
     ! Irrep label

     dimension :: INT
     ! Irrep dimension

     character :: VEC{REAL}* DEFAULT_NULL
     ! Characters for the irrep

     mat :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for the irrep

   end

   array type VEC{IRREP}

     ! A 1-D array of IRREP objects

   end

   type POINTGROUP

     symbol :: STR(4)
     ! symmetry symbol

     ID_symbol :: STR(4)
     ! group id symbol

     ID_number :: INT
     ! group id number

     axis_order :: INT
     ! principal axis order

     order :: INT
     ! order of the group

     n_irrep :: INT
     ! no of irreducible representations

     n_gen :: INT
     ! No. of generators

     has_complex_irreps :: BIN
     ! true if the group has complex irreps

     table :: MAT{INT}* DEFAULT_NULL
     ! group multiplication table

     mat :: MAT3{REAL}* DEFAULT_NULL
     ! 3x3 representation matrices

     use_spherical_basis :: BIN   DEFAULT(FALSE)
     ! Set true if you want to use spherical harmonic basis set
     ! Necessary for the correct rep matrices

     ptr :: MAT3{REAL}* DEFAULT_NULL
     ! 3x3 representation matrices for p functions, same as mat

     dtr :: MAT3{REAL}* DEFAULT_NULL
     ! 6x6 representation matrices for d functions

     ftr :: MAT3{REAL}* DEFAULT_NULL
     ! 10x10 representation matrices for f functions

     gtr :: MAT3{REAL}* DEFAULT_NULL
     ! 15x15 representation matrices for g functions

     inverse :: VEC{INT}* DEFAULT_NULL
     ! Indices of inverse group elements

     irrep :: VEC{IRREP}* DEFAULT_NULL
     ! List of irrrducible representations

   end

   type UNIT_CELL

     angle :: VEC{REAL}(3)
     ! The cell angles  (in radians)

     length :: VEC{REAL}(3)
     ! The cell lengths (in bohr)

     volume :: REAL
     ! The cell volumes (bohr^3)

     direct_matrix :: MAT{REAL}(3,3)
     ! Direct lattice cell matrix (bohr). The columns are vectors of the three
     ! cell axes.

     inverse_matrix :: MAT{REAL}(3,3)
     ! Inverse direct lattice cell matrix (bohr^{-1})

     reciprocal_matrix :: MAT{REAL}(3,3)
     ! Reciprocal lattice cell matrix (bohr^{-1}).

     direct_U_matrix :: MAT{REAL}(3,3)
     ! Converts thermal tensors from crystal to cartesian systems.

     reciprocal_U_matrix :: MAT{REAL}(3,3)
     ! Converts thermal tensors from cartesian to crystal systems.

     info_made :: BIN
     ! Set TRUE if all the above information is consistent.

   end

   array type VEC{UNIT_CELL}

      ! A 1-D array of UNIT_CELL objects

   end

   type MULTI_T_ADP

     ! -------------------
     ! Calculation options
     ! -------------------

     fit_method :: STR   DEFAULT("unknown")
     ! The method used to refine the ADP's

     n_modes :: INT   DEFAULT(0)
     ! The number of modes in the model ... must be set since
     ! otherwise too many maodes will be refined

     omega_high :: REAL DEFAULT(3600)
     ! Initial high frequency for guessing normal mode frequencies
     ! Value given in cm-1

     omega_low ::  REAL DEFAULT(100)
     ! Initial low frequency for guessing TLS mode frequencies
     ! Value given in cm-1

     fix_gruneisens :: BIN  DEFAULT(FALSE)
     ! Whether to fix the Gruneisen parameters

     ! -----------------
     ! Experimental data
     ! -----------------

     n_T :: INT  DEFAULT(0)
     ! The number of temperatures

     n_atom :: INT   DEFAULT(0)
     ! The number of atoms in the file

     n3n :: INT   DEFAULT(0)
     ! Three times the number of atoms

     atom :: VEC{ATOM}*
     ! The list of atoms for the first CIF file used to construct
     ! the starting rigid modes L^rigid

     cif_file_name :: VEC{STR}* DEFAULT_NULL
     ! A list of the CIF files names that contain the multi
     ! temperature ADP data. Normally ordered from lowest 
     ! to highest temperature.

     temperature :: VEC{REAL}*   DEFAULT_NULL
     ! The different experimental temperatures

     temperature_sigma :: VEC{REAL}*   DEFAULT_NULL
     ! The uncertainty in the experimental temperatures

     origin :: VEC{REAL}(3)   DEFAULT(ZERO)
     ! Origin used to calculate libration modes.
     ! By default set to the COM of molecule at T=T_1

     unit_cell :: VEC{UNIT_CELL}*
     ! The list of unit cells at the different temperatures

     unit_cell_sigma :: VEC{UNIT_CELL}*
     ! The list of unit cell errors at the different temperatures

     ADP :: VEC{MAT3_{REAL}}* DEFAULT_NULL
     ! A list of the X-ray ADP's at the different temperatures
     ! n_T x (3x3) in size

     ADP_sigma :: VEC{MAT3_{REAL}}*   DEFAULT_NULL
     ! The corresponding errors for the ADP's at the different
     ! temperatures, n_T x (3x3) in size

     cov :: MAT3{REAL}*  DEFAULT_NULL
     ! For every temperature, the full covariance matrix between
     ! positions are ADP's as output from e.g. a Tonto refinement

     weight :: MAT3{REAL}*  DEFAULT_NULL
     ! For every temperature, the full weight matrix, usually the
     ! inverse of cov above

     ! -----------------------------------------
     ! Model derived info and useful temporaries
     ! -----------------------------------------

     U :: MAT3{REAL}*   DEFAULT_NULL
     ! The calculated mass weighted ADP's

     R :: MAT{REAL}*   DEFAULT_NULL
     ! The list of mixing coefficients for the rigid body modes

     L_rigid :: MAT{REAL}*   DEFAULT_NULL
     ! The list of mixing coefficients for the rigid body modes

     L :: MAT{REAL}*   DEFAULT_NULL
     ! The list of normal modes

     lambda :: VEC{REAL}*
     ! Lagrange multipliers for mode orthogonality

     omega :: VEC{REAL}*   DEFAULT_NULL
     ! The list of harmonic frequencies

     omega_bar :: MAT{REAL}*, private   DEFAULT_NULL
     ! The list of modified harmonic frequencies

     amplitude :: MAT{REAL}*, private   DEFAULT_NULL
     ! The list of amplitudes for each mode omega bar each temperature

     d_amplitude_dw :: MAT{REAL}*, private   DEFAULT_NULL
     ! The 1st derivative amplitudes w.r.t. omega bar, for each temperature

     d2_amplitude_dw2 :: MAT{REAL}*, private   DEFAULT_NULL
     ! The 2nd derivative amplitudes w.r.t. omega bar, for each temperature

     gamma_G :: VEC{REAL}*   DEFAULT_NULL
     ! The list of Grueneisen constants

     del_V_on_V :: VEC{REAL}*   DEFAULT_NULL
     ! The relative changes in unit cell volumes

     ! ----------------
     ! Private switches
     ! ----------------

     cif_files_read :: BIN   DEFAULT(FALSE)
     ! Set TRUE if the cif files have been read

     initialised :: BIN   DEFAULT(FALSE)
     ! Set up starting info

   end

   type SPACEGROUP

     IT_symbol :: STR   DEFAULT("?")
     ! International Table (Hermann-Maguin) symmetry symbol

     IT_group_number :: INT   DEFAULT(0)
     ! International tables group number

     Hall_symbol :: STR   DEFAULT("?")
     ! Hall notation symbol

     HM_symbol :: STR   DEFAULT("?")
     ! Hermann-Mauguin notation symbol

     Schoenflies_symbol :: STR   DEFAULT("?")
     ! Hermann-Mauguin notation symbol

     lattice_symbol :: STR(1)   DEFAULT("?")
     ! Lattice symmetry symbol

     lattice_symbol_index :: INT   DEFAULT(0)
     ! Lattice symbol index number

     lattice_type :: STR   DEFAULT("?")
     ! Lattice type

     centrosymmetric :: BIN   DEFAULT(FALSE)
     ! True if center of symmetry present

     axis_order :: VEC{INT}(3)   DEFAULT(0)
     ! Order of each crystal axis

     axis_symbol :: VEC{STR}(len=1,3)   DEFAULT(" ")
     ! Superscript rotation axis symbol

     axis_symbol_index :: VEC{INT}(3)   DEFAULT(0)
     ! Indicates the numberical index corresponding to the axis symbol x, y, z ...

     has_axis_bar :: VEC{BIN}(3)   DEFAULT(FALSE)
     ! True if bar for this axis

     has_translation :: VEC{BIN}(3)   DEFAULT(FALSE)
     ! True if translation subscript present for this axis

     translation_symbol :: MAT{STR}(len=1,3,3)   DEFAULT(" ")
     ! Subscript translation symbols for each axis

     origin_shift :: VEC{INT}(3)   DEFAULT(0)
     ! Subscript translation symbols for each axis

     nL :: INT   DEFAULT(0)
     ! No. of translational lattice generators

     nR :: INT   DEFAULT(0)
     ! No. of rotation generators

     nG :: INT   DEFAULT(0)
     ! No. of generators

     n_seitz :: INT   DEFAULT(0)
     ! No. of Seitz matrices

     seitz :: MAT3{REAL}* DEFAULT_NULL
     ! The spacegroup Seitz matrices.


   !  n_unique :: INT
   !  ! No. of equivalent positions unrelated by traslation or inversion

   !  unique_symop :: VEC{INT}* DEFAULT_NULL
   !  ! Index of unique symops not related by translation or inversion

   !  map_to_unique :: VEC{INT}* DEFAULT_NULL
   !  ! Maps symop to a unique symop. Negative indicates inversion

     n_inverted_symops :: INT   DEFAULT(0)
     ! Number of symmetry operations related by inversion

     inverted_symop :: VEC{INT}* DEFAULT_NULL
     ! Indices of the unique symops related by inversion

     translated_symop :: VEC{INT}* DEFAULT_NULL
     ! Indices of the unique symops related by translation

     n_unique_SF_symops :: INT
     ! Number of unique symmetry operations not related by inversion or
     ! translation. This is used to save work in structure factor (SF)
     ! calculations.

     unique_SF_symop :: VEC{INT}* DEFAULT_NULL
     ! Indices of the unique symops not related by inversion or translation.
     ! This is used to save work in structure factor (SF) calculations.

     analysed :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the spacegroup symbol has been succesfully analysed

   end

   type DIFFRACTION_DATA

     data_kind :: STR
     ! Tells whether this is X-ray, neutron, or whatever data

     reflections :: VEC{REFLECTION}* DEFAULT_NULL
     ! The structure factor information. NOTE: this can stand for either X-ray or
     ! PND reflections depending on the case.

     scale_factor :: REAL
     ! Scale factor to apply to the predicted structure factors

     scale_factors :: VEC{REAL}* DEFAULT_NULL
     ! A set of scale factors to apply to structure factors from different groups.

     exp_scale_factor :: REAL
     ! Fixed scale factor to apply to the experimental structure factors

     optimise_scale :: BIN
     ! True if an overall scaler factor is to be optimised, for use in calculating
     ! F_pred

     synthesize_sigma_I :: BIN
     ! True if artificial sigma(I) errors are to be generated from poisson
     ! statistics and used in calculating agreement statistics

     optimise_extinction :: BIN
     ! True if extinction is to be optimised.

     correct_dispersion :: BIN
     ! True if dispersion is to be corrected

     extinction_factor :: REAL
     ! Secondary extinction factor

     SF_mixing_parameter :: REAL  DEFAULT(ZERO)
     ! Read the SF mixiing parameter which includes some percentage of
     ! the experimental structure factors into the predicted structure
     ! factors. This may help convergence in constrained HF problems.

     wavelength :: REAL
     ! Experiment wavelength

     thermal_smearing_model :: STR
     ! Thermal smearing model for ft integrals

     partition_model :: STR
     ! Model for partitioning fragments of the molecule

     n_param :: INT
     ! No. of fitting parameters used

     F_exp_min :: REAL  DEFAULT(DIFFRACTION_DATA_F_EXP_MIN)
     ! Minimum acceptable value for F_exp

     F_sigma_min :: REAL  DEFAULT(DIFFRACTION_DATA_F_SIGMA_MIN)
     ! Minimum acceptable value for F_sigma

     F_sigma_max :: REAL  DEFAULT(DIFFRACTION_DATA_F_SIGMA_MAX)
     ! Maximum acceptable value for F_sigma

     F_sigma_cutoff :: REAL DEFAULT(DIFFRACTION_DATA_F_SIGMA_CUTOFF)
     ! Default or selected sigma cutoff for pruning weak reflection data

     temperature :: REAL   DEFAULT(ZERO)
     ! Experimental temperature, for NKA

     NKA_T_sequence_no :: INT   DEFAULT(0)
     ! Sequence no. for NKA output file

     ! -------------------------------
     ! Structure refinement parameters
     ! -------------------------------

     refine_structure :: BIN, readonly  DEFAULT(FALSE)
     ! Set TRUE if a structure is being refined

     refine_positions_only :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you only want to refine the coordinates

     refine_ADPs_only :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you only want to refine the hydrogen ADP's

     refine_H_ADPs :: BIN  DEFAULT(TRUE)
     ! Set FALSE if you don't want to refine the hydrogen ADP's

     refine_H_U_iso :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you only want to refine refine U_iso for the H atoms

     iteration :: INT
     ! The iterations coiunter for structure refinement

     chi2 :: REAL
     ! The current iteration's value of chi2

     chi2_old :: REAL
     ! The previous iteration's value of chi2

     max_iterations :: INT  DEFAULT(DIFFRACTION_DATA_MAX_ITER)
     ! The maximum number of iterations for the normal equations

     min_iterations :: INT  DEFAULT(DIFFRACTION_DATA_MIN_ITER)
     ! The minumum number of iterations for the normal equations

     tol_shift_convergence :: REAL DEFAULT(DIFFRACTION_DATA_TOL_SHIFT_CONV)
     ! Tolerance for convergence of the parameter shifts when solving
     ! the normal equations

     max_shift :: REAL
     ! The maximum shift in the parameter vector during a refinekentg
     ! step.

     max_allowed_shift :: REAL  DEFAULT(DIFFRACTION_DATA_MAX_SHIFT)
     ! The maximum allowed shift when solving the normal equations:
     ! If any one of the parameters shifts obtained from solving the
     ! normal equations is greater than this value, they are all
     ! rescaled so that the largest is this value.

     tol_0 :: REAL  DEFAULT(DIFFRACTION_DATA_TOL_0)
     ! The tolerance used to detect exact zero eigenvalues in the
     ! normal equations

     n_0 :: INT
     ! The number of zero eigenvalues detected when solving the
     ! normal equations

     tol_near_0 :: REAL  DEFAULT(DIFFRACTION_DATA_TOL_NEAR_0)
     ! The tolerance used to detect near zero eigenvalues in the
     ! normal equations

     n_near_0 :: INT
     ! The number near zero eigenvalues detected when solving the
     ! normal equations

     near_0_eigenvalues :: VEC{REAL}*  DEFAULT_NULL
     ! The near zero eigenvalues obtained when solving the normal
     ! equations. Useful to see parameter correlations.

     near_0_eigenvectors :: MAT{REAL}*  DEFAULT_NULL
     ! The columns of eigenvectors with near zero eigenvalue obtained
     ! when solving the normal equations. Useful to see parameter
     ! correlations.

     display_correlation_matrix :: BIN  DEFAULT(FALSE)
     ! Whether to display the correlation matrix or not

     display_near_0_eigenvectors :: BIN  DEFAULT(FALSE)
     ! Whether to display the near zero eigenvectors

     delta_p :: VEC{REAL}*  DEFAULT_NULL
     ! Uncertainties in the parameters

     min_correlation :: REAL  DEFAULT(DIFFRACTION_DATA_MIN_CORRELATION)
     ! The minimu value for correlation matrix elements before they
     ! are printed out in the output.

     covariance_matrix :: MAT{REAL}*  DEFAULT_NULL
     ! The covariance matrix for the parameters i.e.
     ! the inverse of the LHS of the least squares matrix.

     correlation_matrix :: MAT{REAL}*  DEFAULT_NULL
     ! The correlation coefficient matrix for the parameters

     refine_atom_parameters :: MAT{INT}*  DEFAULT_NULL
     ! The list of atom parameters which should be refined. This is
     ! an N x 10 list. The 10'th column holds the indices of the
     ! atoms which should be refined. The first nine columns hold 0's
     ! and 1's indicating whether certain parameters should be
     ! refined. The first three are for the coordinates of the atom
     ! and the last six are for the ADP's in the order xx, yy, zz,
     ! xy, xz, yz.

   end

   type CRYSTAL

     CIF_chemical_formula :: STR  DEFAULT("?")
     ! The chemical formula, as found in a CIF file.

     spacegroup :: SPACEGROUP
     ! The crystal spacegroup

     unit_cell :: UNIT_CELL
     ! The crystal unit cell

     n_fragment_atoms :: INT
     ! No. of atoms in the inputted cell fragment, used to calculate
     ! structure factors, or do wavefunction fitting.

     fragment_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The geometry for a molecular fragment in the crystal (in
     ! fractional coordinates) used to calculate structure factors or do
     ! wavefunction fitting. IMPORTANT NOTE --- this is not to be
     ! confused with the "asymmetric_unit_geometry"; it may include
     ! symmetry non-unique atoms.

     n_asymmetric_unit_atoms :: INT
     ! No. of atoms in the asymmetric unit of the unit cell.

     asymmetric_unit_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The asymmetric unit geometry. Usually inputted from a CIF file. This
     ! may or may not be the same as fragment_geometry. It is NOT used for
     ! structure factor calculations, but for cluster generation.

     prune_asymmetric_unit :: BIN  DEFAULT(TRUE)
     ! Set TRUE if you want to prune the asymmetric unit. Sometimes the asymmetric
     ! unit may not be asymmetric i.e. it may have symmetry-equivalent atoms
     ! repeated. This could be because of an input or CIF file error, or it could
     ! be genuinely correct because the repeated atom corresponds to a disordered
     ! position.  

     asymmetric_unit_atom :: VEC{ATOM}*  DEFAULT_NULL
     ! The set of asymmetric unit atoms.

     n_unit_cell_atoms :: INT
     ! Total no. of unit cell atoms.

     unit_cell_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The full unit cell geometry, in the crystal coordiante system, generated
     ! from the asymmetric_unit_geometry.

     ! --------------------------------------------------------
     ! Arrays relating fragment, unit cell, and asymmetric cell
     ! --------------------------------------------------------

     fragment_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the fragment related information has been made

     asym_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! .asym_atom_for_unit_cell_atom(a) is the index of the unique unit cell atom
     ! in .asymmetric_unit_geometry which generates .unit_cell_geometry(:,a).

     symop_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! "symop_for_unit_cell_atom(u)" is the index of the spacegroup symmetry
     ! operation that generates atom position "unit_cell_geometry(:,u)" from 
     ! the atom with index ".asym_atom_for_unit_cell_atom(u)" with position 
     ! in ".asymmetric_unit_geometry".

     frag_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! .frag_atom_for_unit_cell_atom(u) is the index of the fragment atom in
     ! .fragment_geometry which is equivalent to .unit_cell_geometry(:,u) 
     ! *by translation only*.  This index may be zero---meaning there is
     ! no fragment atom for unit cell atom u.

     unit_cell_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! .unit_cell_atom_for_frag_atom(f) is the index of the unit cell atom in
     ! .unit_cell_geometry which is equivalent to .fragment_geometry(:,f). 
     ! *by translation only*. It is the inverse of the array above. 

     frag_atom_for_asym_unit_atom :: VEC{INT}* DEFAULT_NULL
     ! .frag_atom_for_asym_unit_atom(a) is the index of the fragment atom in
     ! .fragment_geometry which is generated from the asymmetric unit atom
     ! position .asymmeric_unit_geometry(:,a) *by any crystal symop*.
     ! This index may be zero meaning that there is no fragment atom for
     ! asymmetric atom "a".  index is zero. This array is used to extract
     ! the atom list of the asymmetric unit from a given fragment for
     ! cluster generation.

     asym_unit_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! .asym_unit_atom_for_frag_atom(a) is the index of the asymmetric atom in
     ! .asymmetric_unit_geometry which is equivalent to .fragment_geometry(:,a) 
     ! *by any crystal symop*.  This is the inverse of the array above. 

     frag_parent_for_cell_atom :: VEC{INT}* DEFAULT_NULL
     ! .frag_parent_for_unit_cell_atom(u) is the index of the fragment atom in
     ! .fragment_geometry which is equivalent to .unit_cell_geometry(:,u) 
     ! *by any crystal symop*. IT never has zero elements.

     n_unique_frag_atoms :: INT
     ! No. of unique fragment atoms.

     unique_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! The list of unique fragment atoms, determined as the first
     ! atom in the fragment which is generated by a particular
     ! asymmetric unit atom.

     unique_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! .unique_atom_for_frag_atom(f) is the index of the symmetry-unique atom
     ! position in .fragment_geometry which generates .fragment_geometry(:,f).
     ! It is determined as the first atom in the fragment which is
     ! generated by a particular asymmetric unit atom. See below.

     asym_symop_for_frag_atom :: VEC{INT}* DEFAULT_NULL
     ! "asym_symop_for_frag_atom(f)" is the index of the symop which
     ! maps an asymmetric_unit_atom into the unit cell atom which is
     ! equivalent to fragment atom "f" by translation.

     asym_shift_for_frag_atom :: MAT{REAL}* DEFAULT_NULL
     ! "asym_shift_for_frag_atom(f)" is the shift required to map
     ! an asymmetric_unit_atom into the fragment atom after applying
     ! the 3x3 seitz operator with index "unique_symop_for_atom(f)".

     ! ------------------
     ! Repetition factors
     ! ------------------

     Z :: REAL
     ! The Z factor for the molecular cell fragment in the unit cell

     use_manual_repetition_factors :: BIN  DEFAULT(FALSE)
     ! If this is set TRUE, then the user should manually enter the
     ! desired repetition factors. For experts only!

     repetition_factor :: VEC{REAL}* DEFAULT_NULL
     ! The number of times a fragment atom is mapped into itself (or
     ! a translation of itself) by the spacegroup. Used in structure
     ! factor calcs from a fragment geometry or a portion of it; in
     ! the latter case can be reset manually.

     asym_atom_rep_factor :: VEC{REAL}* DEFAULT_NULL
     ! The number of times an asymmetric unit atom is mapped into
     ! itself by the spacegroup. For structure factor calcs based on
     ! the asymmetric unit.

     asym_atom_stabilizer :: VEC{VEC_{INT}}* DEFAULT_NULL
     ! The partition factors for asymmetric_unit_geometry. For
     ! structure factor calcs based on the asymmetric unit.

     ! --------------------------
     ! Unit cell connection table
     ! --------------------------

     unit_cell_connection :: VEC{VEC_{VEC_{INT}}}*  DEFAULT_NULL
     ! List of which unit cell atoms are connected to which other unit cell atoms,
     ! and in what cell e.g. "connection(i).element(k)" represents the "k"-th atom
     ! connected to atom "i" in the ".crystal.unit_cell_geometry", and it is
     ! comprised of a 4-vector, the first three elements being the cell of the
     ! "k"-th connected atom, and the last element being the index of the actual
     ! unit cell atom connected to unit cell atom "i".

     unit_cell_mol_for_atom :: VEC{INT}*  DEFAULT_NULL
     ! "unit_cell_mol_for_atom(i)" is the index of the molecule to which a
     ! particular unit cell atom "i" belongs. See comments for "unit_cell_mol".

     n_unit_cell_mols :: INT   DEFAULT(0)
     ! The number of molecules in the unit cell. Fragments of molecules are
     ! counted as separate molecules.

     ! ---------------
     ! Stablizer group
     ! ---------------

     n_stabilizer_symops :: INT
     ! No. of symops needed to make the unit_cell_geometry from fragment_geometry

     stabilizer_symop :: VEC{INT}* DEFAULT_NULL
     ! Indices of the symops in the spacegroup seitz list which map
     ! .fragment_geometry into itself.

     str :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for s-type gaussian functions of the stabilizer symops.

     ptr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for p-type gaussian functions of the stabilizer symops.

     dtr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for d-type gaussian functions of the stabilizer symops.

     ftr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for f-type gaussian functions of the stabilizer symops.

     gtr :: MAT3{REAL}* DEFAULT_NULL
     ! Representation matrices for g-type gaussian functions of the stabilizer symops.

     ! ----------------
     ! Diffraction data
     ! ----------------

     data_kind :: STR
     ! Kind of diffraction experiment used.

     data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The structure factor and fitting data. NOTE: this can stand for either X-ray or
     ! PND data depending on the case.

     xray_data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The X-ray structure factor and fitting data

     pnd_data :: DIFFRACTION_DATA* DEFAULT_NULL
     ! The PND scalar structure factor and fitting data

     r_free_percentage :: INT  DEFAULT(0)
     ! A percentage which tells how much of the data is to be reserved
     ! and not fitted in the model

     xray_r_free_data :: DIFFRACTION_DATA*  DEFAULT_NULL
     ! This is the excluded X-ray data used to calculate R free

     pnd_r_free_data :: DIFFRACTION_DATA*  DEFAULT_NULL
     ! This is the excluded PND data used to calculate R free

     core_reflection :: VEC{REFLECTION}* DEFAULT_NULL
     ! Form factors for the core only ... for working our R(val) for example

     finalize :: BIN  DEFAULT(TRUE)
     ! FInalize or update self after reading ...

   end

   type CLUSTER

     radius :: REAL  DEFAULT(CLUSTER_RADIUS)
     ! The radius of the cluster. This number determines the maximum acceptable
     ! distance between an atom in fragment_geometry and any atom in the crystal
     ! lattice. It defines the size of the cluster in the case that
     ! "generation_method" component (see below) takes the value "within_radius".

     atom_density_cutoff :: REAL  DEFAULT(CLUSTER_ATOM_DENSITY_CUTOFF)
     ! This number is used to define a cluster radius (see above). The radius is
     ! defined from it, as the *largest* distance from any atom in the
     ! asymmetric_cell_atom list where the atomic electron density becomes smaller
     ! than this number. It requires that slater or coppens bases are defined for
     ! the asymmetric_cell_atom's, and it requires that the generation method be
     ! set to "for_hirshfeld_surface". It is primarily used for clusters generated
     ! from a fragment which will correctly produce the Hirshfeld surface.

     generation_method :: STR  DEFAULT(CLUSTER_GENERATION_METHOD)
     ! This option tell how to make the cluster: whether to add atoms within a
     ! certain distance (radius) of the starting fragment, whether to make a
     ! cluster specifically for generating a hirshfeld surface, whether to just
     ! make the unit cell, or the unit cell and the starting fragment.

     defragment :: BIN  DEFAULT(CLUSTER_DEFRAGMENT)
     ! If TRUE, the cluster ends are defragmented, i.e. any atoms which are
     ! "bonded" at the ends of the cluster are included into the cluster. This
     ! oisn't a good idea for network covalent solids or zeolites: the
     ! defragmentation will end when all bonded entites with the 3x3 cube of
     ! units cells near the origin have been constructed.

     n_atoms :: INT
     ! The number of atoms in the cluster

     geometry :: MAT{REAL}* DEFAULT_NULL
     ! The (3 x .n_atoms) sized array of cluster atom positions, in crystal
     ! coordiantes

     crystal :: CRYSTAL* DEFAULT_NULL
     ! The crystal information used to generate the cluster. The most important
     ! part used is the asymmetric unit cell geometry.

     asymmetric_unit_atom :: VEC{ATOM}* DEFAULT_NULL
     ! The atom list data associated with the *asymmetric* unit cell_geometry (see
     ! below) used to generate the cluster atom positions. It must be consistent
     ! with the crystal asymmetric unit.

     n_fragment_atoms :: INT
     ! The number of fragment atoms used to build the cluster

     fragment_geometry :: MAT{REAL}* DEFAULT_NULL
     ! The (3 x .n_fragment_atoms) sized array of fragment atom positions used to
     ! generate the cluster: the cluster will usually be arranged as the set of
     ! atoms within a certain radius of this fragment geometry. It is in the
     ! crystal coordinate system. Note that the fragment geometry might not
     ! include an asymmetric cell unit.

     fragment_width :: VEC{REAL}(3)
     ! The width of the crystal fragment, to the nearest unit cell

     fragment_offset :: VEC{INT}(3)
     ! The center point of the fragment_geometry, to the nearest unit cell

     unit_cell_offset :: VEC{REAL}(3)  DEFAULT(ZERO)
     ! Unit cell offset to use when generating an offset unit cell.

     h_min :: VEC{INT}(3), private
     ! The minimum values of the cells to search over in a within_radius cluster

     h_max :: VEC{INT}(3), private
     ! The maximum values of the cells to search over in a within_radius cluster

     n_shift :: INT  DEFAULT(0)
     ! The number of distinct translational shifts used to generate the atoms in
     ! the cluster.

     shift :: MAT{INT}* DEFAULT_NULL
     ! The (3 x .n_shift) sized list of translational shifts used to generate the
     ! cluster from the crystal unit cell atoms. See ".shift_for_atom".

     shift_for_atom :: VEC{INT}* DEFAULT_NULL
     ! ".shift_for_atom(a)" is the index of the translational shift in array
     ! ".shift", that shift being added to the position of the crystal unit cell
     ! atom whose index is given by ".occupation_list(a)/1000" in order to
     ! generate the cluster atom "a" whose position is given by ".geometry(a)".

     is_fragment_atom :: VEC{BIN}* DEFAULT_NULL
     ! is_fragment_atom(a) is TRUE if .geometry(:,a) is the position of a fragment
     ! atom, i.e. if "a" is the index of a fragm,ent atom.

     occupation_list :: VEC{INT}*  DEFAULT_NULL
     ! The list of atoms in the cluster which are occupied. This is a coded
     ! integer representing the triple of integers (h1,h2,h3), the cell where the
     ! atom resides, as well as the integer index i for the unit cell atom. The
     ! cell integers are limited to be in the range [-4,4] and at most 10^6 atoms
     ! in the cluster.

     molecule_for_atom :: VEC{INT}*  DEFAULT_NULL
     ! An integer which tells which molecule the cluster atoms belongs to.

     atom_connection :: VEC{VEC_{INT}}*  DEFAULT_NULL
     ! atom_connection(i)[:] are those atoms which are connected to atom "i".

     n_molecules :: INT   DEFAULT(0)
     ! The number of molecules in the cluster

     info_made :: BIN  DEFAULT(FALSE)
     ! Set to true if the routine make_info has been called

   end

   type SCFDATA

     ! ****** SCF kind *********

     scf_kind :: STR  DEFAULT(" ")
     ! The kind of SCF calculation to perform

     ! ****** DFT functional options *********

     dft_exchange_functional :: STR  DEFAULT(SCFDATA_DFT_EXCHANGE_FUNCTIONAL)
     ! The DFT exchange functional to be used

     dft_correlation_functional :: STR  DEFAULT(SCFDATA_DFT_CORRELATION_FUNCTIONAL)
     ! The DFT correlation functional to be used

     using_GGA_exchange :: BIN  DEFAULT(SCFDATA_USING_GGA_EXCHANGE)
     ! TRUE if the exchange functional uses the generalised gradient
     ! approximation, otherwise false.

     using_GGA_correlation :: BIN  DEFAULT(SCFDATA_USING_GGA_CORRELATION)
     ! TRUE if the correlation functional uses the generalised gradient
     ! approximation, otherwise false.

     ! ****** Iteration counters *********

     iteration :: INT  DEFAULT(0)
     ! The interation count for the SCF procedure

     total_iterations :: INT  DEFAULT(0)
     ! The total interation count for the SCF procedure, which does not get reset
     ! after each lambda increment, in the case of a constrained SCF procedure.

     lambda_iteration :: INT  DEFAULT(0)
     ! Lambda iteration count for the constrained SCF procedure

     min_iterations :: INT  DEFAULT(SCFDATA_MIN_ITERATIONS)
     ! The minimum number of SCF iterations to perform

     max_iterations :: INT  DEFAULT(SCFDATA_MAX_ITERATIONS)
     ! The maximum number of SCF iterations to perform

     ! ****** Stored energies *********

     nuclear_energy :: REAL  DEFAULT(ZERO)
     ! Nuclear repulsion energy for the associated molecule

     kinetic_energy :: REAL  DEFAULT(ZERO)
     ! The kinetic energy for the associated molecule

     dft_energy_correction :: REAL  DEFAULT(ZERO)
     ! The DFT energy correction to the SCF energy for the associated molecule

     dft_alpha_energy_correction :: REAL  DEFAULT(ZERO)
     ! The DFT alpha energy correction to the SCF energy for the associated molecule

     dft_beta_energy_correction :: REAL  DEFAULT(ZERO)
     ! The DFT beta energy correction to the SCF energy for the associated molecule

     energy :: REAL  DEFAULT(ZERO)
     ! The SCF energy for the associated molecule

     old_energy :: REAL  DEFAULT(ZERO)
     ! The SCF energy from the previous SCF cycle

     energy_difference :: REAL  DEFAULT(ZERO)
     ! The change in the SCF energy between cycles

     ! ****** Constrained SCF data *********

     lambda :: REAL  DEFAULT(ZERO)
     ! The initial lambda value to use in a constrained SCF procedure

     initial_lambda :: REAL  DEFAULT(ZERO)
     ! The starting lambda value in a constrained SCF procedure

     lambda_max :: REAL  DEFAULT(ZERO)
     ! The maximum lambda value to use in a constrained SCF procedure

     lambda_step :: REAL  DEFAULT(ONE)
     ! The value to step the lambda value between lambda cycles in a 
     ! constrained SCF calc.

     fit_value :: REAL  DEFAULT(ZERO)
     ! The value of E + lambda * penalty in a constrained SCF calc.
     ! Penalty can be the Chi2, or a combination of Chi2's if more than one
     ! type of diffraction data is to be fitted.

     old_fit_value :: REAL  DEFAULT(ZERO)
     ! The value of E + lambda * penalty of the previous iteration in a
     ! constrained  SCF calc.

     penalty :: REAL  DEFAULT(ZERO)
     ! Penalty statistic for a constrained SCF calc

     old_penalty :: REAL  DEFAULT(ZERO)
     ! Penalty statistic for a constrained SCF calc of the previous iteration

     zero_oo_constraint_block :: BIN   DEFAULT(FALSE)
     ! Zero the occ-occ block of the constraint matrix. This should
     ! not affect the answer but only the canonicalisation

   
     crystal :: CRYSTAL*  DEFAULT_NULL
     ! The crystal information for the diffraction experiment

     ! ****** Crystal SCF data *********

     kappa :: REAL DEFAULT(ZERO)
     ! The kappa value used to multiply the orthogonality projector, uses in an
     ! embedded SCF procedure

     unit_cell_axis_divisions :: VEC{INT}(3)
     ! Number of integer divisions of the unit cell in each lattice direction.

     crystallite_side_length :: REAL
     ! The desired side length for the crystallite. This determines the number of
     ! levels that will be used.

     fmm_accuracy :: REAL
     ! The accuracy required for the multipole expansion of the inverse particle
     ! separation.

     ! ****** Initial guess options *********

     initial_density :: STR  DEFAULT("core")
     ! The kind of density matrix to start the SCF calc

     initial_mos :: STR  DEFAULT(" ")
     ! The kind of initial MO's to start the SCF calc

     initial_Us :: STR  DEFAULT(" ")
     ! The kind of initial U matrices to start the CPHF from

     ! ****** SCF convergence/accuracy related options *********

     convergence :: REAL  DEFAULT(SCFDATA_CONVERGENCE)
     ! A number which measures the convergence of the SCF

     damp_finish :: INT  DEFAULT(DIIS_START_ITERATION)
     ! Iteration when density matrix damping is turned off

     damp_factor :: REAL  DEFAULT(SCFDATA_DAMP_FACTOR)
     ! The damping factor to use

     level_shift_finish :: INT  DEFAULT(DIIS_START_ITERATION)
     ! Iteration when level shifting is turned off

     level_shift :: REAL  DEFAULT(SCFDATA_LEVEL_SHIFT)
     ! Value to level shift the virtual orbitals

     linear_dependence_tol :: REAL   DEFAULT(SCFDATA_LINEAR_DEPENDENCE_TOL)
     ! Eigenvalues of the overlap matrix smaller than this value are level shifted.

     linear_dependence_shift :: REAL   DEFAULT(SCFDATA_LINEAR_DEPENDENCE_SHIFT)
     ! A level shift to apply to eigenvalues of the overlap matrix which are
     ! smaller than the above tolerance. If tolerance is zero, no shifting is done.  

     MO_gradient_stepsize :: REAL  DEFAULT(0.01d0)
     ! The stepisize to use for updating the orbitals

     max_update_stepsize :: REAL  DEFAULT(0.01d0)
     ! The maximum update stepsize to use for updating any SCF object, e.g. the orbitals

     eri_disk_cutoff :: REAL  DEFAULT(SCFDATA_ERI_DISK_CUTOFF)
     ! Cutoff for the two electron integrals, on disk

     eri_schwarz_cutoff :: REAL  DEFAULT(SCFDATA_ERI_SCHWARZ_CUTOFF)
     ! Cutoff for the two electron integrals

     eri_J_density_cutoff :: REAL  DEFAULT(SCFDATA_ERI_J_DENSITY_CUTOFF)
     ! Cutoff for the J density matrix elements in Schwarz test

     eri_K_density_cutoff :: REAL  DEFAULT(SCFDATA_ERI_K_DENSITY_CUTOFF)
     ! Cutoff for the K density matrix elements in Schwarz test

     eri_bf_overlap_cutoff :: REAL DEFAULT(SCFDATA_ERI_BF_OVERLAP_CUTOFF)
     ! The cutoff for the ERI Schwarz test.

     eri_primitive_pair_cutoff :: REAL DEFAULT(SCFDATA_ERI_PAIR_CUTOFF)
     ! The cutoff for the exponential prefactor for the product of two
     ! gaussian primitives, below which that primitive pair is ignored in the
     ! calculation of the ERI's.

     atom_overlap_cutoff :: REAL  DEFAULT(SCFDATA_ATOM_OVERLAP_CUTOFF)
     ! The value of the maximum overlap between basis functions on two different
     ! atoms, below which the atoms are considered *not* overlapping. This is used
     ! to defined the .overlapping_atoms array used in linear scaling DFT matrix
     ! element evaluation.

     XC_atom_separation_cutoff :: REAL  DEFAULT(SCFDATA_XC_ATOM_SEPARATION_CUTOFF)
     ! The exchange correlation matrix in DFT calculations is *not* calculated
     ! for basis functions on atoms separated by *more* than this distance.
     ! This allows linear scaling of the exchange correlation terms (except for a
     ! negligible N^2 contribution due to the atom-distance test).

     ! ****** DIIS convergence related options *********

     diis :: DIIS
     ! For diis extrapolation (usually Fock matrix DIIS extrapolation)

     diis_error :: REAL  DEFAULT(ZERO)
     ! The DIIS error

     old_diis_error :: REAL  DEFAULT(ZERO)
     ! The DIIS error of the previous iteration

     diis_start_iteration :: INT  DEFAULT(DIIS_START_ITERATION)
     ! This is a copy of .diis.start_iteration, which needs to be saved when
     ! lambda is reset in constrained SCF calculations.

     diis_save_iteration :: INT  DEFAULT(DIIS_SAVE_ITERATION)
     ! This is a copy of .diis.save_iteration, which needs to be saved when
     ! lambda is reset in constrained SCF calculations.

     using_previous_diis_info :: BIN   DEFAULT(TRUE)
     ! If set TRUE, then in a constrained SCF calculation, the previous DIIS
     ! vectors are re-used to estimate a new set of DIIS vectors.

     diis_error_temp_cutoff :: REAL  DEFAULT(DIIS_ERROR_TEMP_CUTOFF)
     ! The DIIS error at which pFON fractional occupation numbers are turned off
     ! and the temperature is set to zero.

     ! ****** General Complex HF options *********

     sl_1e_factor :: REAL  DEFAULT(ONE)
     ! Factor to apply to the 1-electron S.L terms

     sl_2e_factor :: REAL  DEFAULT(ONE)
     ! Factor to apply to the 2-electron S.L terms

     quantization_axis :: VEC{REAL}(3)  DEFAULT([ZERO,ZERO,ONE])
     ! Quantization axis for GCHF, if using initial MO's as a guess

     ! ****** Logical switches *********

     group :: BIN  DEFAULT(FALSE)
     ! Set TRUE if doing a noninteracting group SCF calculation

     output :: BIN  DEFAULT(TRUE)
     ! True if output is wanted; sometimes we supress output e.g. when we do
     ! atomic SCF calculations to get a good initial guess, or if we are just not
     ! interested in the SCF output.

     guess_output :: BIN  DEFAULT(FALSE)
     ! TRUE if the output for the initial guess is to be printed.

     is_guess :: BIN  DEFAULT(FALSE)
     ! TRUE if this SCF is an initial guess.

     test :: BIN  DEFAULT(FALSE)
     ! Test flag. Set True if some test procedure is to be executed

     stabilize_density :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the density is to be averaged over the stabilizer
     ! group in xray constrained calculations (rhf only so far).

     ! ****** Relativity *********

     relativity_kind :: STR  DEFAULT("none")
     ! What kind of relativity are you using?

     using_iotc :: BIN  DEFAULT(FALSE)
     ! Switch on/off the 1 electron IOTC terms

     using_douglas_kroll_hess :: BIN  DEFAULT(FALSE)
     ! Switch on/off the 1 electron DKH terms

!    using_SO_coupling :: BIN  DEFAULT(FALSE)
     ! Switch on/off the 1 electron DKH terms

     DK1_PCE :: BIN  DEFAULT(FALSE)
     ! Switch on/off the DK1_PCE terms

     DK2_PCE :: BIN  DEFAULT(FALSE)
     ! Switch on/off the DK2_PCE terms

     DK1 :: BIN  DEFAULT(TRUE)
     ! Switch on/off the DK1 terms

     DK2 :: BIN  DEFAULT(TRUE)
     ! Switch on/off the DK2 terms

     DK3 :: BIN  DEFAULT(FALSE)
     ! Switch on/off the DK3 terms

     using_ppzpp :: BIN DEFAULT(FALSE)
     ! switch on/off the PCE correction
      
     PCE_CORR :: BIN DEFAULT(FALSE)
     ! switch on/off the PCE correction 
      
     using_SO_FDFF :: BIN  DEFAULT(FALSE)
     ! Switch on/off the SO corrections to SO scalar terms 
     ! which are missed in the works of Hess

     using_1e_zora_term :: BIN  DEFAULT(FALSE)
     ! Switch on/off the 1 electron ZORA terms

     using_pauli_terms :: BIN  DEFAULT(FALSE)
     ! Use the Pauli terms

     using_1e_sl_term :: BIN  DEFAULT(FALSE)
     ! Switch on/off the 1 electron S.L term

     using_1e_srxa_term :: BIN  DEFAULT(FALSE)
     ! Switch on/off the 1 electron diamagnetic term

     using_2e_sl_term :: BIN  DEFAULT(FALSE)
     ! Switch on/off the 2 electron S.L terms

     using_aa_term :: BIN  DEFAULT(FALSE)
     ! Switch on/off the A.A diamagnetic term

     using_bl_term :: BIN  DEFAULT(FALSE)
     ! Switch on/off the B.L term (complex SCF reqd.)

     using_bs_term :: BIN  DEFAULT(FALSE)
     ! Switch on/off the B.S term

     using_bs_t_term :: BIN  DEFAULT(FALSE)
     ! Switch on/off the (B.S) T_e term

     ! ****** Convergence/Build *********

     using_damping :: BIN  DEFAULT(SCFDATA_USING_DAMPING)
     ! True if using damping

     using_pFON :: BIN  DEFAULT(FALSE)
     ! True if using pFON

     using_delta_build :: BIN  DEFAULT(TRUE)
     ! True if using an incremental (delta) fock build as advocated by Almlof.

     using_direct_scf :: BIN  DEFAULT(TRUE)
     ! True if using direct SCF

     using_fock_diis :: BIN  DEFAULT(TRUE)
     ! True if using DIIS extrapolation for fock matrices

     using_level_shift :: BIN  DEFAULT(SCFDATA_USING_LEVEL_SHIFT)
     ! True if using level shifting

     using_orbital_locking :: BIN  DEFAULT(FALSE)
     ! True if using orbital locking

     using_MO_diis :: BIN  DEFAULT(FALSE)
     ! True if using DIIS extrapolation for molecular orbitals

     using_MO_gradient_update :: BIN  DEFAULT(FALSE)
     ! Set TRUE if using the gradient of the orbital coefficients to
     ! update the coefficients

     using_CPHF_diis :: BIN  DEFAULT(TRUE)
     ! True if using DIIS extrapolation for CPHF equations

     using_NDDO :: BIN  DEFAULT(FALSE)
     ! Neglect of diatomic differential overlap

     using_NUDO :: BIN  DEFAULT(FALSE)
     ! Neglect of unconnected differential overlap

     using_PIE :: BIN  DEFAULT(FALSE)
     ! Projective integral expansion method (PIE) developed by Mayer.
     ! See Mayer, CPL 332, 381 (2000).

     ! ****** Cluster/crystal SCF *********

     using_cluster_charges :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to surround the molecule with charges.

     using_SC_cluster_charges :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to surround the molecule with *self consistent* charges. 
     ! These charges are reculculated every SCF iteration.

     using_qq_cluster_charges :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to surround the molecule with *self consistent* 
     ! quadrupole charges. You still need to set use_sc_cluster_charges

     cluster_radius :: REAL  DEFAULT(SCFDATA_CLUSTER_RADIUS)
     ! Radius of the cluster to use to generate cluster

     cluster :: CLUSTER*  DEFAULT_NULL
     ! A cluster used to get the cluster charges

     save_cluster_charges :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to save the cluster charges

     cluster_charge :: VEC{REAL}*   DEFAULT_NULL
     ! List of saved cluster charges

     cluster_pos :: MAT{REAL}*   DEFAULT_NULL
     ! List of saved cluster positions for the charges

     using_SC_Lorentz_fields :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to use local Lorentz fields from atomic
     ! point charges and point dipoles, summed to infinity using
     ! the Lorentz tensor.

     delete_scf_archives :: BIN  DEFAULT(TRUE)
     ! Delete all but the molecular orbitals after an SCF
     ! calculation. Keeping the archives can save work later.

   end

   type COLOUR

     name :: STR
     ! The standard colour name for this colour.

     RGB255 :: VEC{INT}(3)
     ! The RGB triple for this colour as a triple of integers between 0 and 255.

   end

   type COLOURFUNCTION

     n_data :: INT
     ! The number of data values (and their associated colours) used to make
     ! the colour function

     data :: VEC{REAL}* DEFAULT_NULL
     ! The list of data values, from smallest to largest

     RGB :: MAT{REAL}* DEFAULT_NULL
     ! The RGB values corresponding to each data value. Their norm should be
     ! between zero and 3.

     finalised :: BIN
     ! Set TRUE if the object is ready for use

   end

   type CAPPINGSQUARE

     case :: INT
     ! A coded bit string to describe the particular case for capping
     ! triangles. These are essentially the same as for marching squares.

     face_number :: INT
     ! Integer representing which face the of the cube the capping square belongs to.
     ! i.e. it's orientation. if face_number=1 then it's the z=0 face.

     iso_value :: REAL
     ! The isovalue to be used for the isosurface

     vertex_pos :: MAT{REAL}(3,0:3)
     ! A (3 x 0:3) dimensioned list of the actual coordinates of each square vertex.
     ! The second index is the standard capping square vertex number.

     value_at_vertex :: VEC{REAL}(0:3)
     ! A (0:3) dimensioned list of the values of the function at each square vertex.

     edge_vertex_index :: VEC{INT}(0:7)
     ! A (0:7) dimensioned list of the  triangle vertex *indices* for each "edge" of the capping square.
     ! Because the vertices of the square are involved in triangulation that are encoded as edges:
     ! v0 -> e4, v1 -> e5, v2 -> e6, v4 -> e7.
     ! Not all these edge are new since they include the edge vertices taken from the marching cube

     edge_vertex_pos :: MAT{REAL}(3,0:7)
     ! A (3 x 0:7) dimensioned list of the interpolated triangle vertex
     ! coordinates on each edge of the cube (if that edge is needed).

     cap_vertex_flag :: VEC{BIN}(0:3)
     ! Used to flag vertices of capping square which belong to caps
     ! and therefore need to be triangulated.

     n_triangle :: INT
     ! The number of triangles formed on this capping square.

     n_pt :: INT
     ! The number of points up until this square was analysed. Used to
     ! keep a list of unique indices to define triangle vertices and
     ! points.

     no_new_vertex :: INT
     ! A capping square contains previously determined edge vertices (from marching cube)
     ! and new edge vertices. The contains the number of new edge vertices.

     triangle_edge_index :: MAT{INT}(3,4)
     ! The (3 x .n_triangle) dimensioned list of 3-edges on the capping
     ! square used to form triangles. This is just the appropriate row
     ! from the triangle_table. The maximum number of triangles is 4.

     triangle_vertex_index :: MAT{INT}(3,4)
     ! The (3,.n_triangle) dimensioned list of groups of 3 *unique*
     ! triangle vertex *indices*. These indices point to a unique list
     ! of points. The maximum number of triangles is 4.

     new_vertex_index :: VEC{INT}(4)
     ! A list of the edge indices for each new triangle vertex index.
     ! Only the vertices of the square become new edge vertices hence
     ! only can have four new vertex indices.

     edge_vertex_gradient :: MAT{REAL}(3,0:7)
     ! A (3 x 0:7) dimensioned list of the triangle vertex
     ! normals on each edge of the capping square (if that edge is needed).

     edge_mean_curvature :: VEC{REAL}(0:7)
     ! A (0:7) dimensioned list of the mean curvatures
     ! on each edge of the capping square that crosses the isosurface (if that
     ! edge is needed).

     edge_gaussian_curvature :: VEC{REAL}(0:7)
     ! A (0:7) dimensioned list of the gaussian
     ! curvatures on each edge of the capping square that crosses the isosurface
     ! (if that edge is needed).

   end

   type MARCHINGCUBE

     vertex_pos :: MAT{REAL}(3,0:7)
     ! A (3 x 0:7) dimensioned list of the actual coordinates of each cube vertex.
     ! The second index is the standard marching cubes vertex number.

     value_at_vertex :: VEC{REAL}(0:7)
     ! A (0:7) dimensioned list of the values of the function at each cube vertex.

     vertex_gradient :: MAT{REAL}(3,0:7)
     ! A (3 x 0:7) dimensioned list of the vertex gradients at each cube vertex.
     ! The second index is the standard marching cubes vertex number.

     vertex_hessian :: MAT3{REAL}(3,3,0:7)
     ! A (3 x 3 x 0:7) dimensioned list of the hessian at each cube vertex.
     ! The third index is the standard marching cubes vertex number.

   !  vertex_hessian_eigenvalues :: MAT{REAL}(3,0:7)
   !  ! A (3 x 3 x 0:7) dimensioned list of the hessian eigenvalues at each cube vertex.
   !  ! The third index is the standard marching cubes vertex number.

   !  vertex_hessian_eigenvectors :: MAT3{REAL}(3,3,0:7)
   !  ! A (3 x 3 x 0:7) dimensioned list of the hessian eigenvectors at each cube vertex.
   !  ! The third index is the standard marching cubes vertex number.

     x_side_length :: REAL
     ! The length of the x side of the cube

     y_side_length :: REAL
     ! The length of the y side of the cube

     z_side_length :: REAL
     ! The length of the z side of the cube

     axes :: MAT{REAL}(3,3)
     ! The axes of the marching cube, if not usual x,y,z

     inverse_axes :: MAT{REAL}(3,3)
     ! The inverse (transpose) of the axes of the marching cube

     iso_value :: REAL
     ! The isovalue to be used for the isosurface

     accuracy :: REAL
     ! The function accuracy to which each isosurface point is
     ! determined

     case :: INT
     ! The case number of this marching cube, for lookup in edge_table
     ! and triangle_table

     interior_case :: INT
     ! The case number corresponding to a cube being wholly within a
     ! surface.  Normally this is when the interior of the surface has
     ! larger values than the exterior, and in this case the default is 0.

     exterior_case :: INT
     ! The case number corresponding to a cube being wholly outside a
     ! surface.  Normally this is when the interior of the surface has
     ! smaller values than the exterior, and in this case the default is
     ! 255.

     edge_bit_string :: INT
     ! The edge bit string for the marching cube. This is just the
     ! appropriate element of the edge_table i.e. if the bit is set,
     ! then that edge crosses the isosurface and must be interpolated.

     skip_bit_string :: INT
     ! A bit string which tells whether to skip processing certain cube
     ! edges.  Can be used when certain edge vertex points are already
     ! done.

     cube_bit_string :: INT
     ! The grad bit string for the marching cube. This tells which
     ! *vertices* of the cube cross the isosurface and must be
     ! interpolated.

     n_edge :: INT
     ! The number of marching cube edges that need to be considered on
     ! this marching cube

     n_active_edge :: INT
     ! The number of active marching cube edges that need to be
     ! considered on this marching cube, taking into account the
     ! skip_bit_string

     n_triangle :: INT
     ! The number of triangles formed on this marching cube

     n_pt :: INT
     ! The number of points up until this cube was analysed. Used to
     ! keep a list of unique indices to define triangle vertices and
     ! points.

     triangle_edge_index :: MAT{INT}(3,5)
     ! The (3 x .n_triangle) dimensioned list of 3-edges on the marching
     ! cube used to form triangles. This is just the appropriate row
     ! from the triangle_table. The maximum number of triangles is 5.

     triangle_vertex_index :: MAT{INT}(3,5)
     ! The (3,.n_triangle) dimensioned list of groups of 3 *unique*
     ! triangle vertex *indices*. These indices point to a unique list
     ! of points. The maximum number of triangles is 5.

     edge_vertex_pos :: MAT{REAL}(3,0:11)
     ! A (3 x 0:11) dimensioned list of the interpolated triangle vertex
     ! coordinates on each edge of the cube (if that edge is needed).

     edge_vertex_value :: VEC{REAL}(0:11)
     ! A (0:11) dimensioned list of the interpolated vertex values
     ! normals on each edge of the cube (if that edge is needed).

     edge_vertex_gradient :: MAT{REAL}(3,0:11)
     ! A (3 x 0:11) dimensioned list of the interpolated triangle vertex
     ! normals on each edge of the cube (if that edge is needed).

     edge_vertex_hessian :: MAT3{REAL}(3,3,0:11)
     ! A (3 x 3 x 0:11) dimensioned list of the interpolated triangle
     ! vertex hessians on each edge of the cube (if that edge is
     ! needed).

     edge_mean_curvature :: VEC{REAL}(0:11)
     ! A (0:11) dimensioned list of the (interpolated) mean curvatures
     ! on each edge of the cube that crosses the isosurface (if that
     ! edge is needed).

     edge_gaussian_curvature :: VEC{REAL}(0:11)
     ! A (0:11) dimensioned list of the (interpolated) gaussian
     ! curvatures on each edge of the cube that crosses the isosurface
     ! (if that edge is needed).

     edge_vertex_index :: VEC{INT}(0:12)
     ! A (0:11) dimensioned list of the *unique* triangle vertex
     ! *indices* for each edge of the marching cube (if that edge is
     ! needed). The 12-th component is used for re-use counting.

     vertex_edge_index :: VEC{INT}(12)
     ! A list of the edge indices for each unique triangle vertex index.
     ! Essentially, this is the reverse mapping of edge_vertex_index.

   end

   array type VEC{MARCHINGCUBE}

     ! A 1-D array of MARCHINGCUBE objects

   end

   type ISOSURFACE

     iso_kind :: STR
     ! The kind of isosurface plot, if known. This helps in deciding which way the
     ! normals of the isosurface should point.

     triangulation_method :: STR
     ! The method used to triangulate the isosurface.

     iso_value :: REAL
     ! The isovalue to be used for the isosurface

     iso_values :: VEC{REAL}*
     ! List of *multiple* isovalues to be used for the isosurfaces

     plot_grid :: PLOT_GRID
     ! The isosurface plotgrid

     n_pt :: INT
     ! The number of isosurface points

     point :: MAT{REAL}*  DEFAULT_NULL
     ! A (3 x n_pt) list of points on the isosurface

     n_face :: INT
     ! The number of triangulated faces on the isosurface

     face :: MAT{INT}*  DEFAULT_NULL
     ! A (3 x n_face) list of the triangular faces of the surface. Each face is
     ! represented by three integers which move in an anticlockwise direction when
     ! viewed from the outside.

     n_cap :: INT
     ! The number of triangulated faces making up the caps

     cap :: MAT{INT}*  DEFAULT_NULL
     ! A (3 x n_cap) list of the triangular faces of the capping region. Each face is
     ! represented by three integers which move in an anticlockwise direction when
     ! viewed from the outside.

     point_gradient :: MAT{REAL}*  DEFAULT_NULL
     ! A (3 x n_pt) list of the function gradient vectors for every point on the
     ! isosurface

     point_mean_curvature :: VEC{REAL}*  DEFAULT_NULL
     ! A (3 x n_pt) list of the mean surface curvatures for every point on the
     ! isosurface

     point_gaussian_curvature :: VEC{REAL}*  DEFAULT_NULL
     ! A (3 x n_pt) list of the gaussian surface curvatures for every point on the
     ! isosurface

     area :: REAL
     ! The area of the isosurface, calculated from the triangulate isosurface

     volume :: REAL
     ! The volume of the isosurface, calculated from the triangulate isosurface.

     an_volume :: REAL
     ! The volume of the isosurface, calculated from the triangulate isosurface by
     ! using the average face normal for each triangle face. The average face
     ! normal is calculated from the average of the norms of the point_gradient's
     ! at each surface point.

     volume_min :: REAL
     ! A lower bound to the interior volume of the isosurface, calculated by
     ! counting the number of cubes inside the surface.

     volume_max :: REAL
     ! An upper bound to the interior volume of the isosurface, calculated by
     ! counting the number of cubes inside and on the surface.

     n_skip :: INT
     ! The number of function evaluations skipped (recursive method only)
     ! This is in fact worked out by counting the total number of evaluations.

     level :: INT
     ! The current level to which the initial box has been divided, in the
     ! recursive marching cube algorithm.

     final_level :: INT
     ! The final level to which the initial box must be divided, in the
     ! recursive marching cube algorithm.

     scan_level :: INT
     ! The level to which the initial box must be divided, in the recursive
     ! marching cube algorithm, to achieve resolution of all important features.
     ! It is determined by the .minimum_scan_division setting; or if this is
     ! smaller than the .minimum_scan_level, that value is used instead.

     minimum_scan_level :: INT  DEFAULT(ISOSURFACE_MINIMUM_SCAN_LEVEL)
     ! The smallest acceptable scan level used in the recursive marching cubes
     ! algorithm.

     minimum_scan_division :: REAL  DEFAULT(ZERO)
     ! The minimum acceptable voxel side length to which the initial box must be
     ! divided, in the recursive marching cube algorithm, to achieve resolution of
     ! all important features. The minimum_scan_level (above) may override this
     ! setting.

     voxel_proximity_factor :: REAL  DEFAULT(ISOSURFACE_VOXEL_PROXIMITY_FACTOR)
     ! Setting this value determines when a voxel is deemed to be "close" to the
     ! isosurface, and hence should be subdivided. It works by seeing if the
     ! .iso_value is within this factor times the difference between the maximum
     ! and minimum values on the voxel vertices. If it is, then the voxel is
     ! "close" to the surface.

     cube :: MARCHINGCUBE
     ! The marching cube used to generate the isosurface

     cap_square :: CAPPINGSQUARE
     ! The cap square used to generate the caps on the boundary of the plot grid

     del_x :: REAL   DEFAULT(ONE)
     ! The current box x side length in the recursive marching cubes algorithm.

     del_y :: REAL   DEFAULT(ONE)
     ! The current box y side length in the recursive marching cubes algorithm.

     del_z :: REAL   DEFAULT(ONE)
     ! The current box z side length in the recursive marching cubes algorithm.

     x :: INT
     ! The (partial) x-coordinate of the box in the recursive marching cubes
     ! algorithm.  This is a binary number, with each bit from the right
     ! representing a segment double the size to which the current box belongs.

     y :: INT
     ! The (partial) y-coordinate of the box in the recursive marching cubes
     ! algorithm.  This is a binary number, with each bit from the right
     ! representing a box double the size to which the current box belongs.

     z :: INT
     ! The (partial) z-coordinate of the box in the recursive marching cubes
     ! algorithm.  This is a binary number, with each bit from the right
     ! representing a box double the size to which the current box belongs.

     hash :: HASH{VEC{INT},VEC{INT}}* DEFAULT_NULL
     ! A hash table storing marching cube edge_vertex_index information as a
     ! function of the cube coordinates, [.x,.y,.z]

     small_hash :: BIN  DEFAULT(FALSE)
     ! Set TRUE if you want to prube dead elements from the hash table

     big_interior :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the interior of the isosurface is bigger than the exterior,
     ! i.e. if the point_normals are to be reversed on output. This switch could
     ! probably be determined automatically, assuming the botton left had corner
     ! of the plot (the first point) was "outside".

     cap_ends :: INT  DEFAULT(0)
     ! Set non-zero if you want the ends of the isosurface on the
     ! bounding cube to be capped. Set less than one if you want values
     ! less than the isosurface capped, or greater than one if you want
     ! values greater than the iso value capped.
     
     cap_suppress :: BIN DEFAULT(FALSE)
     ! If TRUE caps are not outputed in put_faces even if they have been generated.

   !  shift :: VEC{REAL}* DEFAULT_NULL
   !  ! A list of distances representing how far each point shifted from its
   !  ! estimate to come to the isosurface.

   !  adjoining_face :: MAT{INT}* DEFAULT_NULL
   !  ! A (3 x n_face) list of the three adjoining faces for a particular face

   !  adjoining_edge :: MAT{INT}* DEFAULT_NULL
   !  ! A (3 x n_face) list of the adjoining edge for the adjoining faces for
   !  ! a particular face

   !  ok :: VEC{BIN}* DEFAULT_NULL
   !  ! A list of switches telling if each face is acceptably smooth.

   !  ok_neighbours :: VEC{BIN}* DEFAULT_NULL
   !  ! A list of switched telling if all three neighbours of each face is acceptably smooth.

   !  n_skip :: INT
   !  ! The number of faces which are acceptapbly smooth, and can be skippped

   !  smallness :: REAL
   !  ! The maximum acceptable distance between triangulated points.
   !  ! Used as a face smallness criteria.

   !  flatness :: REAL
   !  ! The maximum acceptable distance between a triangulated point and its ray origin
   !  ! i.e. its "shift" (see above).  Used as a face flatness criteria.

   !  accuracy :: REAL
   !  ! The accuracy to which each isosurface point is determined

     surface_property :: STR  DEFAULT(" ")
     ! The name of a surface property to plot or calculate on the isosurface
     ! surface.

     surface_property_values :: VEC{REAL}* DEFAULT_NULL
     ! The values of .surface_property, evaluated on the isosurface surface.

     surface_iso_values :: VEC{REAL}*  DEFAULT_NULL
     ! The values of the iso_value on the surface, in the case when multiple
     ! isosurfaces have been calculated and merged together into a single surface.

     surface_point :: VEC{REAL}(3)
     ! A special point which lies on or near the isosurface, used for calculations
     ! of connected area, for example.

     chop_surface_property_range :: BIN
     ! When plotting a surface, whether to chop the surface property accorsding to
     ! the lower and upper bounds specified below, rather than scaling the
     ! smallest value to zero and the largest to one.

     surface_property_lower_bound :: REAL  DEFAULT(ISOSURFACE_PROPERTY_LB)
     ! A lower bound to the property value, for calculating surface areas, and for
     ! chopping the range of surface property values.

     surface_property_upper_bound :: REAL  DEFAULT(ISOSURFACE_PROPERTY_UB)
     ! A upper bound to the property value, for calculating surface areas, and for
     ! chopping the range of surface property values.

     surface_prop_lower_bound_abs :: REAL  DEFAULT(ISOSURFACE_PROPERTY_LB_ABS)
     ! A lower bound to the absolute value of the property, for calculating the
     ! log of the surface property values.

     surface_prop_upper_bound_abs :: REAL  DEFAULT(ISOSURFACE_PROPERTY_UB_ABS)
     ! A upper bound to the absolute value of the property, for calculating the
     ! log of the surface property values.

     colour :: COLOURFUNCTION*  DEFAULT_NULL
     ! A colourfunction used for colouring the isourface

     atom :: VEC{ATOM}*  DEFAULT_NULL
     ! A list of atoms associated with ths isosurface.

     destroy_atom :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the .atom list must be destroyed.

     interpolator :: INTERPOLATOR*  DEFAULT_NULL
     ! This is used for setting defaults for isosurfaces which make
     ! use of spherical atomiuc densities.

   !   use_interpolator :: BIN  DEFAULT(TRUE)
   !   ! If set TRUE, then the routine used to calculate the isosurface may use
   !   ! interpolation tables, rather than exact values, if possible.
   !
   !   interpolation_kind :: STR  DEFAULT(ISOSURFACE_INTERPOLATION_KIND)
   !   ! The kind of interpolator to use. It is only used for Hirshfeld surfaces.
   !
   !   interpolator_table_length :: REAL  DEFAULT(ISOSURFACE_TABLE_LENGTH)
   !   ! The length of the table used in the interpolator
   !
   !   interpolator_table_spacing :: REAL  DEFAULT(ISOSURFACE_TABLE_SPACING)
   !   ! The spacing betwen points in the interpolator.
   !
   !   interpolator_table_eps :: REAL  DEFAULT(ISOSURFACE_TABLE_EPS)
   !   ! Values smaller than this in the interpolation table are set to zero, with a
   !   ! consequent reduction in the table size.

   end

   type ROBY

     roby_kind :: STR
     ! The kind of Roby calculation to perform

     n1 :: VEC{REAL}* DEFAULT_NULL
     ! Roby population for each atom-group

     n2 :: MAT{REAL}* DEFAULT_NULL
     ! Roby pair population for each atom-group pair
     ! NOTE: these are *not* shared populations

     n_shared :: REAL
     ! Roby multiple shared population for a specified atom-group

     bond_index :: MAT{REAL}* DEFAULT_NULL
     ! Gould Bond indices for each pair of atoms

     percent_covalency :: MAT{REAL}* DEFAULT_NULL
     ! The % covalency of the given bond pair

     gould_charge :: VEC{REAL}* DEFAULT_NULL
     ! Roby-Gould charges

     cruickshank_charge :: VEC{REAL}* DEFAULT_NULL
     ! Cruikshank-Avramedes charges

     summed_n2 :: VEC{REAL}* DEFAULT_NULL
     ! Summed atom-group pair populations

     summed_n3 :: VEC{REAL}* DEFAULT_NULL
     ! Summed atom-group triple populations

     subgroup_pop :: VEC{REAL}* DEFAULT_NULL
     ! The subgroup population contributions when calculating multiple shared
     ! populations.

     atom_list :: VEC{INT}* DEFAULT_NULL
     ! The indices of a list of roby atoms to be used in some way
     ! for population analysis

     atom_group :: VEC{VEC_{INT}}* DEFAULT_NULL
     ! The indices of the roby atoms defining different spaces

     analyse_all_atom_pairs :: BIN
     ! If set TRUE, the bond index information is printed out ONLY for every
     ! atom pair which is considered "bonded". Otherwise all pairs of atoms are
     ! analysed. This is onlyeffective when an atom_list is defined.

     bond_scale_factor :: REAL
     ! Used to multiply the sum of the Bragg-Slater radii for two atoms,
     ! to determine a distance cutoff within which the atoms are regarded
     ! to be bonded

     covalent_cutoff :: REAL
     ! Angles (in radians) greater than this are ignored when calculating
     ! the covalent bond index

     ionic_cutoff :: REAL
     ! Angles (in radians) greater than this are ignored when calculating
     ! the ionic bond index

     pi_on_2_cutoff :: REAL
     ! Angles (in radians) greater than this are regareded as pi/2

     zero_cutoff :: REAL
     ! Angles (in radians) *less* than this are regareded as zero

     occupied_ANO_cutoff :: REAL
     ! Atomic natural orbitals with occupations less than this number
     ! are regarded as unoccupied. This number is used to define the Roby
     ! atomic projector

     output_theta_info :: BIN
     ! If set TRUE, the bond index information is printed out for every
     ! space V_theta. See the paper for details.

     atom_a :: VEC{INT}* DEFAULT_NULL
     ! The indices of the atoms defining space V_A

     atom_b :: VEC{INT}* DEFAULT_NULL
     ! The indices of the atoms defining space V_B

     atom_ab :: VEC{INT}* DEFAULT_NULL
     ! The indices of the roby atoms defining spaces V_A and V_B

     theta_C :: MAT{REAL}* DEFAULT_NULL
     ! The matrix of the covalent theta orbitals

     eval_C :: VEC{REAL}* DEFAULT_NULL
     ! The array of the covalent theta eigenvalues

     theta_angle :: VEC{REAL}* DEFAULT_NULL
     ! The array of covalent theta angles

     pair :: VEC{INT}* DEFAULT_NULL
     ! An array which pairs the positive eigenvalues in eval_C with the
     ! negative eigenvalues, thus definining each theta subspace

     theta_I :: MAT{REAL}* DEFAULT_NULL
     ! The matrix of the covalent theta orbitals

     eval_I :: VEC{REAL}* DEFAULT_NULL
     ! The matrix of the covalent theta eigenvalues

     pop_C :: VEC{REAL}* DEFAULT_NULL
     ! Covalent theta orbital popualtions

     pop_I :: VEC{REAL}* DEFAULT_NULL
     ! Covalent theta orbital popualtions

     pop_A :: VEC{REAL}* DEFAULT_NULL
     ! Atom "A" theta orbital popualtions

     pop_B :: VEC{REAL}* DEFAULT_NULL
     ! Atom "B" theta orbital popualtions

     covalent_index :: VEC{REAL}* DEFAULT_NULL
     ! The vector of each covalent theta bond index

     ionic_index :: VEC{REAL}* DEFAULT_NULL
     ! The vector of each covalent theta bond index

     proportion_a :: MAT{REAL}* DEFAULT_NULL
     ! The proportion to partition for atom A, between two atoms (A,B)
     ! using Gould's probabilistic scheme

     charge :: INT
     ! The total charge on the molecule

     mult :: INT
     ! The spin multiplicity of the molecule

     rho :: OPMATRIX* DEFAULT_NULL
     ! The density matrix of the molecule

     overlap_matrix :: MAT{REAL}* DEFAULT_NULL
     ! The full molecular overlap matrix for Roby analysis

     atom :: VEC{ATOM}* DEFAULT_NULL
     ! The actual list of atoms to be used in the Roby calculations
     ! Usually this will come from a MOLECULE object

   end

   type MO_LOCALISER

     algorithm :: STR  DEFAULT(MO_LOCALISER_ALGORITHM)
     ! Identifier for the kind of localising algorithm

     n_orb :: INT  DEFAULT (0)
     ! The number of molecular orbitals to be localised. It must not exceed the
     ! first dimension of the dipole integrals.

     accuracy :: REAL  DEFAULT(MO_LOCALISER_ACCURACY)
     ! Used to decide when the iterative localising algorithm should terminate

     iteration :: INT  DEFAULT(0)
     ! The iteration counter, for the number of iterative steps used to refine
     ! the localised orbitals.

     max_iterations :: INT  DEFAULT(MO_LOCALISER_MAXIT)
     ! The maximum number of iterations allowed

     MO :: MAT{REAL}*  DEFAULT_NULL
     ! The original molecular orbitals to be localised.

     TM :: MAT{REAL}*  DEFAULT_NULL
     ! The orthogonal transformation matrix from the old to the new MO's.

     dipole :: MAT3{REAL}*  DEFAULT_NULL
     ! The dipole moment integrals in the (current) MO basis, used for the Boys
     ! scheme and for analysing the spread of the localised orbitals. The first
     ! two indices are for the orbitals, the last for the component x, y, or z.

     quadrupole :: MAT3{REAL}*  DEFAULT_NULL
     ! The quadrupole moment integrals in the (current) MO, used to analyse the
     ! localised orbitals. The first two indices are for the orbitals, the last
     ! for the component xx, yy, zz, xy, xz, yz.

   end

   type GEMINAL_MF_SPECTRUM

     name :: STR
     ! Name of the associated molecule

     nuclear_energy :: REAL
     ! Nuclear repulsion energy for the associated molecule

     n_geminals :: INT
     ! The total number of geminal functions

     i_geminals :: INT
     ! The number of geminal contraction being updated

     n_bf :: INT
     ! The number of one-particle basis functions

     n_bas :: INT
     ! The number of basis geminal functions for the particular contraction
     ! considered

     n_dependent :: INT
     ! The number of quasi linearly dependent geminal functions 
     ! for the particular contraction considered

     bra :: VEC{MAT_{REAL}}*
     ! The array of contracted wavefunctions in the bra.
     ! The first component is the function of the contraction considered.
     ! The (n_geminals - 1) other components are the ground state wave functions
     ! of the other contractions

     ket :: VEC{MAT_{REAL}}*
     ! The array of contracted wavefunctions in the ket
     ! The first component is the function of the contraction considered.
     ! The (n_geminals - 1) other components are the ground state wave functions
     ! of the other contractions

    !  special_bra :: VEC{VEC_{INT}}*
     ! This bra contains only the indices of one geminal product basis function.

     special_ket :: VEC{VEC_{INT}}*
     ! This ket contains only the indices of one product basis function.

     contraction_wfs :: VEC{MAT_{REAL}}*
     ! The array of geminal wavefunctions of the particular contraction considered

     contraction_energies :: VEC{REAL}*
     ! The array of geminal energies of the particular contraction considered

!pcc     two_orthogonality :: BIN
     ! flag for two orthogonality used to simplify matrix element
     ! calculation

     tol :: REAL
     ! tolerance used in the tests to cutoff branches in the recursions 
     ! when calculating matrix elements

     ld_tol :: REAL
     ! tolerance for quasi linear dependence in the MF scalar product
     ! geometry

     ig_tol :: REAL
     ! tolerance for being considered an internal geminal of a geminal
     ! product

   end

   type GEMINAL_MF_SCHEME

   spectrum :: GEMINAL_MF_SPECTRUM*
   ! spectrum of one contraction for a given step in the contraction scheme

   max_iterations :: INT
   ! Maximum allowed iterations including step 0 
   ! default is 1001

   n_iterations :: INT
   ! No of iterations performed so far

   n_orbitals :: INT
   ! number of molecular orbitals retained for constructing geminals,
   ! possibly reduced with respect to the size of the atomic orbitals 
   ! default is the number of the atomic orbitals

   tolerance_scheme :: VEC{INT}*
   ! The array of integers determining the tolerance (10^-n) used in the tests
   ! to cutoff branches in the recursions when calculating matrix elements
   ! it should increase with the step number and ultimately the tolerance should
   ! be less than the convergence threshold.
   ! default is 10

   ld_tol_scheme :: VEC{REAL}*
   ! The array of tolerance for quasi linear dependence in the MF scalar product
   ! geometry for the steps of the MF scheme
   ! default is LINEAR_DEPENDENCE_TOL

   ig_tol_scheme :: VEC{REAL}*
   ! The array of tolerance for being considered an internal geminal of a geminal
   ! product in MF steps
   ! default is INTERNAL_GEMINAL_TOL

   truncation_scheme :: VEC{REAL}*
   ! The array of variable determining the energies above which we
   ! truncate

   do_triplet_energies :: VEC{BIN}*
   ! array of flags to control diagonalisation of geminal triplet matrices 

   convergence_threshold :: REAL
   ! threshold for the convergence of the MF scheme

   add_core :: BIN
   ! flag to add the contribution of the one-electron term of the
   ! Hamiltonian to the electronic repulsion integrals.
   ! default is true

   use_brillouin :: BIN
   ! flag to diagonalise only the double excitated geminal matrix at step 0
   ! default is false

   make_integrals :: BIN
   ! flag to calculate and write an <ij|kl> file in an archive 
   ! default is true, set false if there is already one to be used 

   make_singlet_extremals :: BIN
   ! flag to calculate and write the geminals that diagonalize the <ij|kl>
   ! default is false

   readin_mos :: BIN
   ! flag to readin molecular orbitals to be used when making an <ij|kl> file
   ! default is false, meaning that canonical mo's are to be used 

 !  readin_gems :: BIN
   ! flag to readin geminals coefficients to make guess geminals for
   ! instance.
   ! default is false, meaning that guess geminals built over
   ! canonical mo's are used 

   readin_scheme :: BIN
   ! flag to readin arrays of parameters possibly different for each
   ! GMFCI steps, these parameters are, in order, ld_tol(i_step),
   ! ig_tol(i_step),tolerance_scheme(i_step),do_triplet(i_step),
   ! truncation_scheme(i_step)
   ! default is false, meaning that the same parameters will be used
   ! for all the steps

   guess_type :: STR
   ! character string describing the type of guess geminals to be used
   ! valid options are hf, agp, random, readin.
   ! Default is hf.

   starting_group :: INT
   ! Number of the active group to start with at step 1
   ! if 0 (default) the group with second lowest ground state energy is used

   orthogonality_type :: STR
   ! character string describing the type of orthogonality to be enforced
   ! between the active geminals and the spectators
   ! valid options are one_orthogonality, sf_two_orthogonality,
   ! sp_two_orthogonality, default is no orthogonality constraint

   print_hamiltonian :: BIN
   ! flag to print hamiltonian
   ! default is false

   end

   type MOLECULE

     name :: STR
     ! Name of molecule

     charge :: INT
     ! Electric charge of the molecule

     mult :: INT
     ! Spin multiplicity of the molecule

     E_field :: VEC{REAL}(3)
     ! Applied electric field in atomic units

     B_field :: VEC{REAL}(3)
     ! Applied magnetic field in atomic units

     gauge_origin :: VEC{REAL}(3)
     ! Global gauge origin for magnetic field

     atom :: VEC{ATOM}* DEFAULT_NULL
     ! List of atoms in molecule

     atom_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the atom info has been made.

     basis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the gaussian basis set class
     ! to be used for each atom

     basis_l_max :: INT
     ! The maximum l value for the basis set

     basis :: VEC{BASIS}* DEFAULT_NULL
     ! List of basis sets used

     use_spherical_basis :: BIN   DEFAULT(FALSE)
     ! Set true if you want to use spherical harmonic basis set
     ! NOTE: not done properly yet

     slaterbasis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the Slater basis set class
     ! to be used for each atom

     slaterbasis :: VEC{SLATERBASIS}* DEFAULT_NULL
     ! List of Slater basis sets used

     coppensbasis_name :: STR  DEFAULT(" ")
     ! A string representing the name of the Coppens basis set class
     ! to be used for each atom

     coppensbasis :: VEC{COPPENSBASIS}* DEFAULT_NULL
     ! List of coppens basis sets used

     basis_info_made :: BIN
     ! Set TRUE if the gaussian basis set info has been made.

     plot_grid :: PLOT_GRID* DEFAULT_NULL
     ! Rectangular grid data, for plots

     use_interpolators :: BIN  DEFAULT(TRUE)
     ! Set to use interpolators

     interpolator :: INTERPOLATOR*  DEFAULT_NULL
     ! Template interpolator object used for setting options

     isosurface :: ISOSURFACE* DEFAULT_NULL
     ! An object used for creating triangluated meshes for isosurface plots.

    ! dftgrid :: DFTGRID* DEFAULT_NULL
    ! ! DFT integration grid data. Should be obsoleted from 24/7/05

     becke_grid :: BECKE_GRID* DEFAULT_NULL
     ! Becke DFT integration grid data

     crystal :: CRYSTAL* DEFAULT_NULL
     ! Crystal data for the enclosing crystal

     cluster :: CLUSTER* DEFAULT_NULL
     ! Crystal cluster data

     cif :: CIF* DEFAULT_NULL
     ! Crystallographic Information file (CIF) object

     pointgroup :: POINTGROUP* DEFAULT_NULL
     ! Pointgroup symmetry of the molecule

     saved :: MOLECULE* DEFAULT_NULL
     ! For saving self and temporarily using an alternative in its place

     n_e :: INT
     ! No of electrons

     n_a :: INT
     ! No of alpha electrons

     n_b :: INT
     ! No of beta electrons

     n_atom :: INT
     ! No of atoms

     n_atom_kind :: INT
     ! No of atoms of a different kind

     n_basis :: INT
     ! No of basis sets

     n_shell :: INT
     ! Total number of shells in the molecular basis set

     n_shell_pairs :: INT
     ! Total number of shell pairs in the molecular basis set

     n_bf :: INT
     ! Total number of basis functions in the molecular basis set

     n_prim :: INT
     ! Total number of primitives in the molecular basis set

     n_unique_shells :: INT
     ! Number of unique shells in the basis set.

     atom_for_shell :: VEC{INT}* DEFAULT_NULL
     ! Atom index for molecular shell index array

     atom_shell_for_shell :: VEC{INT}* DEFAULT_NULL
     ! Atom shell index for molecular shell index array

     first_shell_for_atom :: VEC{INT}* DEFAULT_NULL
     ! First molecule shell index for an atom

     last_shell_for_atom :: VEC{INT}* DEFAULT_NULL
     ! Last molecule shell index for an atom

     basis_shell_for_shell :: VEC{INT}* DEFAULT_NULL
     ! Map a shell of the molecule to a shell of the basis set

     first_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL
     ! First basis function for a given shell

     last_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL
     ! Last basis function for a given shell

     angular_moment_for_shell :: VEC{INT}* DEFAULT_NULL
     ! Angular moment for a given shell

     first_basis_fn_for_atom :: VEC{INT}* DEFAULT_NULL
     ! For the atom basis function limits

     last_basis_fn_for_atom :: VEC{INT}* DEFAULT_NULL
     ! For the atom basis function limits

     precomputed_basis_shellpair :: MAT{SHELL1PAIR}* DEFAULT_NULL
     ! Precomputed stuff for shellpairs of the basis set, to speed up
     ! later calculations of gaussian integrals.

     max_I :: VEC{REAL}*, private  DEFAULT_NULL 
     ! Maximum of the (ab|ab) integrals, used for SChwarz inequality test to
     ! eliminate two electron integrals.

     atom_kind :: VEC{INT}* DEFAULT_NULL
     ! The unique kind of each atom in .atom

     unique_atom :: VEC{INT}* DEFAULT_NULL
     ! List of the unique atoms (of different kind). It is always the
     ! first one in the list of all the atoms with the same kind.

     ANO_data_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the ANO data info has been made.

     ANO_interpolators_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the ANO interpolators have been made.

     interpolators_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the interpolators of any kind have been made.

     spherical_atom_data_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the spherical atom data info has been made.
     ! They are derived from an existing molecular density matrix.

     overlapping_atoms :: VEC{BIN}* DEFAULT_NULL
     ! List of atom-pairs (in lower triangular form) which have significant
     ! overlap. Used in linear scaling DFT calculations.

     overlapping_atoms_for_atom :: VEC{VEC_{INT}}* DEFAULT_NULL
     ! List of atoms which have significant overlap with another

     scfdata :: SCFDATA* DEFAULT_NULL
     ! SCF data object

     orbital_energies :: OPVECTOR* DEFAULT_NULL
     ! The orbital energies

     molecular_orbitals :: OPMATRIX* DEFAULT_NULL
     ! The molecular orbitals

     density_matrix :: OPMATRIX* DEFAULT_NULL
     ! The density matrix

     natural_orbitals :: OPMATRIX* DEFAULT_NULL
     ! The natural orbitals

     occupation_numbers :: OPVECTOR* DEFAULT_NULL
     ! The natural orbital occupation numbers

     geminal_mf_spectrum :: GEMINAL_MF_SPECTRUM*
     ! The geminal mean field spectrum stuff ...

     geminal_mf_scheme :: GEMINAL_MF_SCHEME*
     ! The geminal mean field scheme stuff ...

     overlap_matrix :: MAT{REAL}* DEFAULT_NULL
     ! The basis function overlap matrix

     overlap_eigenvectors :: MAT{REAL}* DEFAULT_NULL
     ! The overlap matrix eigenvectors

     overlap_eigenvalues :: VEC{REAL}* DEFAULT_NULL
     ! The overlap matrix eigenvalues

     max_S :: VEC{REAL}* DEFAULT_NULL
     ! The maximum value of the basis function overlap matrix
     ! over pairs of shells ... for skip testing ...

     core_matrix :: OPMATRIX* DEFAULT_NULL
     ! The basis function core matrix

     fock_matrix :: OPMATRIX* DEFAULT_NULL
     ! The fock matrix

     constraint_matrix :: OPMATRIX* DEFAULT_NULL
     ! The constraint matrix, used for X-ray or PND constrained SCF calculations

     old_molecular_orbitals :: OPMATRIX* DEFAULT_NULL
     ! The molecular orbitals from the previous SCF iteration.
     ! NOTE: this is currently obsolete, but was used for Camp-king (?)

     old_density_matrix :: OPMATRIX* DEFAULT_NULL
     ! The density matrix from the previous SCF iteration, used for incremental
     ! Fock matrix builds in the direct SCF method -- but NOT for density matrix
     ! damping.

     old_fock_matrix :: OPMATRIX* DEFAULT_NULL
     ! The fock matrix from the previous SCF iteration, used for incremental Fock
     ! matrix builds in the direct SCF method.

     old_constraint_matrix :: OPMATRIX* DEFAULT_NULL
     ! The constraint matrix from the previous SCF iteration

     atom_group :: VEC{VEC_{INT}}* DEFAULT_NULL
     ! A list of atom group indices, for group property decomposition

     atom_group_energy :: VEC{REAL}* DEFAULT_NULL
     ! The SCF energy of each atom group

     group_charges :: VEC{INT}* DEFAULT_NULL
     ! A list of charges for each group in the molecule, defined in atom_groups.

     mos_per_group :: VEC{INT}* DEFAULT_NULL
     ! A list of the number of MO's to use when constructing the density matrix
     ! for each atom group. Only the lowest MO's up to this number are used.

     optimise_thermals :: BIN
     ! Whether to optimise the thermal parameters

     roby :: ROBY* DEFAULT_NULL
     ! A Roby data object

  !  CIF_file_name :: STR  DEFAULT(" ")
  !  ! The name of a CIF file to be used for input

  !  CIF_data_block_name :: STR  DEFAULT(" ")
  !  ! The name of a CIF file data block, to be used for processing

     CX_file_name :: STR  DEFAULT(" ")
     ! The name of the Crystal Explorer (CX) output file

     CX_uses_angstrom :: BIN  DEFAULT(FALSE)
     ! Set TRUE if output for CX should be in Angstrom, not Bohr.

     localiser :: MO_LOCALISER*
     ! AN MO localiser object

     U_electric_dipole :: MAT3{REAL}*
     ! The derivative U matrices for electric dipole perturbations

     dipole_polarisability :: MAT{REAL}*  DEFAULT_NULL
     ! The dipole polarisability of the molecule.

     dipole_hyperpolarisability :: MAT3{REAL}*  DEFAULT_NULL
     ! The dipole hyperpolarisability of the molecule.

     Hirshfeld_atom_info_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the Hirshfeld atomic properties are made

     atomic_polarisabilities_made :: BIN  DEFAULT(FALSE)
     ! Set TRUE if the atomic polarisabilities are made

     invariom_database_directory :: STR  DEFAULT(" ")
     ! Location of the invariom database

     invariom_refinement :: BIN DEFAULT(FALSE)
     ! Logical to switch on invariom refinement

   end

end
