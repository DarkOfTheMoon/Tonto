!-------------------------------------------------------------------------------
!
! TYPES : used to deposit all derived types used in TONTO.
!
! A separate module is required so that two modules can use each others types
! even if they can't use each others routines by with a "use" statement. In the
! C++ language every one of TONTO's objects are "friendly" with each other.
!
! (c) dylan jayatilaka, university of western australia, 1998
!
! $Id$
!
!-------------------------------------------------------------------------------

module TYPES

   implicit none

   type SYSTEM

   error_status :: INT  DEFAULT(0)
   ! Set non-zero on error.

   error_output_unit :: INT  DEFAULT(SYSTEM_ERROR_OUTPUT_UNIT)
   ! The file unit number for error messages.

   ! ******************************
   ! Memory tracking and management
   ! ******************************

   memory_used :: INT  DEFAULT(0)
   ! The amount of memory used by the program so far.

   memory_blocks_used :: INT  DEFAULT(0)
   ! The current number of active memory blocks allocated using "create"
   ! commands

   max_memory_used :: INT  DEFAULT(0)
   ! The maximum amount of memory used so far.

   max_memory_blocks_used :: INT  DEFAULT(0)
   ! The maximum number of memory blocks allocated used by the program so far.

   memory_limit :: INT  DEFAULT(SYSTEM_MEMORY_LIMIT)
   ! A soft memory limit. A warning is generated if this limit is exceeded bu
   ! the program is not stopped.

   memory_limit_exceeded :: BIN  DEFAULT(FALSE)
   ! Set TRUE if the soft memory limit is exceeded.

   memory_leak_detected :: BIN  DEFAULT(FALSE)
   ! Set TRUE if a memory leak has been detected. This is to prevent cascading
   ! memory leak reports from parent routines. However, this switch is set back
   ! to FALSE whenever a new routine is entered at a level below where the
   ! current leak occured, so it is not so useful.

   memory_leak_level :: INT  DEFAULT(0)
   ! Gives the memory leak level below which leaks are not reported. This is to
   ! ensure that the same memory leak is not reported at lower levels. The
   ! variable is reset to 0 whenever a new routine is entered at a level lower
   ! than the leak.

   memory_units :: STR  DEFAULT(SYSTEM_MEMORY_UNITS)
   ! The units for acconting for memory usage.

   ! ************************************
   ! Call stack management system options
   ! ************************************

   stack_level :: INT  DEFAULT(0)
   ! The current call-stack level.

   max_stack_level :: INT  DEFAULT(0)
   ! The maximum call-stack level reached in the program.

   stack_show_level :: INT  DEFAULT(-1)
   ! Enable printing of the call-stack, for all routines at this level or higher
   ! in the call-stack.

   memory_used_stack :: VEC{INT}* DEFAULT_NULL
   ! An array which stores the amount of memory used by each routine at a given
   ! call-level in the call-stack.

   call_stack :: VEC{STR}*  DEFAULT_NULL
   ! Stores the name of each subroutine at each call-level, for routine traceback.

   show_call_stack :: BIN  DEFAULT(FALSE)
   ! If TRUE, tells whether to show an indented call-stack as the program runs.
   ! The memory gained or lost by each routine is also displayed.  Be warned,
   ! setting this switch produces copious output.

   io_file :: TEXTFILE*  DEFAULT_NULL
   ! Last I/O file used

   known_keywords :: VEC{STR}*  DEFAULT_NULL
   ! List of known keywords in the current case statement, if applicable
   ! This allows a nice error message to be returned saying what the allowed
   ! options in the case statement were.

   ! ***********************************
   ! Timing and profiling system options
   ! ***********************************

   time_stack_level :: INT  DEFAULT(0)
   ! The current time call-stack level. This is essentially just the same as
   ! stack_level. It is not the same since we may want to check timings when the
   ! ENSURE statements are turned on -- call_stack always implies ENSURE.

   time_call_stack :: VEC{INT}*  DEFAULT_NULL
   ! Stores the *indices* of the routines called at each call-level.  This is
   ! used for subracting the childrens elspased times from parent routines.

   time_strt_stack :: VEC{REAL}*  DEFAULT_NULL
   ! Stores the starting times for all routines in the time_call_stack.

   n_timed_routines :: INT  DEFAULT(0)
   ! The number of routines that have currently been called and are being timed.

   time_for_routine :: VEC{REAL}*  DEFAULT_NULL
   ! The time taken for a particular routine -- all routines called in the
   ! program will be timed in this stack.

   name_for_routine :: VEC{STR}*  DEFAULT_NULL
   ! The name for a particular timed routine -- all routines called in the
   ! program will be named in this stack.

   n_calls_for_routine :: VEC{INT}*  DEFAULT_NULL
   ! The number of calls for the particular routine in the timing stack.

   time_limit :: REAL  DEFAULT(ZERO)
   ! Set a total time limit on a profile run. A zero value means no time limit.
   ! If the time limit is exceeded the programs stops and dumps a profile up to
   ! that point. Pretty good, huh.

   show_cumulative_time :: BIN DEFAULT(FALSE)
   ! If TRUE, then when showing timing information the cumulative routine time
   ! is shown (including the time for called routines) rather than the actual 
   ! time for only the lines in the routine. If FALSE, there are usually
   ! roundoff errors present due top the inaccuracy of the fortran CPU_TIME
   ! intrinsic function.

   ! **********************************************************
   ! Parallel processor system options, inherited from PARALLEL
   ! **********************************************************

   is_parallel :: BIN  DEFAULT(FALSE)
   ! Whether we are doing a parallel job, or not.

   do_parallel_lock :: STR  DEFAULT(" ")
   ! This is set to the name of the routine which calls the parallel do loop.
   ! Only the routine with the same name may unlock the parallel loop. This
   ! implementation assumes that all routines with parallel do loops have
   ! distinct names (append with the module name, if not; or use a unique ID).
   ! Further, recursive routines cannot have parallel do loops.
 
   master_rank :: INT  DEFAULT(0)
   ! The rank of the master processor. It can be useful to change this, since

   processor_rank :: INT  DEFAULT(0)
   ! The rank number of the current processor

   n_processors :: INT  DEFAULT(1)
   ! The number of processors

   mpi_status :: INT  DEFAULT(0)
   ! Status field used for all MPI routines.

   end

   type PARALLEL
 
   is_parallel :: BIN  DEFAULT(FALSE)
   ! Whether we are doing a parallel job, or not.

   do_parallel_lock :: STR  DEFAULT(" ")
   ! This is set to the name of the routine which calls the parallel do loop.
   ! Only the routine with the same name may unlock the parallel loop. This
   ! implementation assumes that all routines with parallel do loops have
   ! distinct names (append with the module name, if not; or use a unique ID).
   ! Further, recursive routines cannot have parallel do loops.
 
   master_rank :: INT  DEFAULT(0)
   ! The rank of the master processor. It can be useful to change this, since
   ! only the master processor is allowed to so IO.

   processor_rank :: INT  DEFAULT(0)
   ! The rank number of the current processor
 
   n_processors :: INT  DEFAULT(1)
   ! The number of processors
 
   mpi_status :: INT  DEFAULT(0)
   ! Status field used for all MPI routines.
 
   end

   type TIME

   started :: VEC{INT}(5)
   ! Contains real start time, in Julian day,h,m,s,ms

   stopped :: VEC{INT}(5)
   ! Contains real stop time, in Julian day,h,m,s,ms

   start_cpu :: REAL
   ! Contains CPU start time, in seconds

   stop_cpu :: REAL
   ! Contains CPU stop  time, in seconds

   end

   type BUFFER

   item_start :: INT
   ! The position of the first character of the last item processed in
   ! the buffer string

   item_end :: INT
   ! The position of the last character of the last item processed in
   ! the buffer string

   item_index :: INT
   ! The item number of the last item processed in the buffer string

   n_items :: INT
   ! The total number of items in the string

   analysed :: BIN  DEFAULT(FALSE)
   ! True, if the buffer string has been analysed

   comment_chars :: STR  DEFAULT(BUFFER_COMMENT_CHARS)
   ! The comment character symbols (concatenated) to be used in the
   ! buffer string

   quote_chars :: STR  DEFAULT(BUFFER_QUOTE_CHARS)
   ! The quote character symbols (concatenated) to be used in the
   ! buffer string

   string :: STR(len=BSTR_SIZE)  DEFAULT(" ")
   ! This is the actual buffer string

   end

   type UNITNUMBER

   unit :: INT
   ! The unit number

   end

   type FILE

   name :: STR  DEFAULT("unknown")
   ! The name of the file

   unit :: INT  DEFAULT(0)
   ! The unit number

   record :: INT  DEFAULT(1)
   ! The current record of the output

   io_status :: INT  DEFAULT(0)
   ! Set non-zero if there is an error condition

   action :: STR  DEFAULT("readwrite")
   ! The type of action performed on this file

   file_status :: STR  DEFAULT("unknown")
   ! File status

   buffered :: BIN  DEFAULT(FALSE)
   ! Whether to use buffering if the file is for numbers

   buffer_type :: STR  DEFAULT("INT")
   ! What type of buffer it is.

   int_buffer_pos :: INT  DEFAULT(1)
   ! The integer buffer position marker

   int_buffer :: VEC{INT}* DEFAULT_NULL
   ! The integer buffer which is flushed to the file when full

   real_buffer_pos :: INT  DEFAULT(1)
   ! The real buffer position marker

   real_buffer :: VEC{REAL}* DEFAULT_NULL
   ! The real buffer which is flushed to the file when full

   cpx_buffer_pos :: INT  DEFAULT(1)
   ! The cpx buffer position marker

   cpx_buffer :: VEC{CPX}* DEFAULT_NULL
   ! The cpx buffer which is flushed to the file when full

   end

   type TEXTFILE

   name :: STR  DEFAULT("unknown")
   ! The name of the file

   action :: STR  DEFAULT("unknown")
   ! The action status of the file, "read" or "write"

   unit :: INT
   ! The unit number

   record :: INT
   ! The current record of the output

   io_status :: INT
   ! Set non-zero if there is an error condition

   ignore_end_of_file :: BIN  DEFAULT(FALSE)
   ! Set to TRUE if the end of file is not to be regarded as an error.

   no_of_lines :: INT DEFAULT(-1)
   ! The number of lines in the file. This is only set if the end-of-file is
   ! encountered.

   n_fields :: INT  DEFAULT(TEXTFILE_N_FIELDS)
   ! No of fields (i.e. columns) to use for outputting the variable

   int_width :: INT  DEFAULT(TEXTFILE_INT_WIDTH)
   ! Width of an integer field

   real_width :: INT  DEFAULT(TEXTFILE_REAL_WIDTH)
   ! Width of a real field

   real_precision :: INT  DEFAULT(TEXTFILE_REAL_PRECISION)
   ! No. of decimal places to use for outputing a real variable

   real_style :: STR  DEFAULT(TEXTFILE_REAL_STYLE)
   ! Fortran style character for a real variable

   margin_width :: INT  DEFAULT(TEXTFILE_MARGIN_WIDTH)
   ! Margin width

   use_labels :: BIN  DEFAULT(TEXTFILE_USE_LABELS)
   ! Whether to use column and row labels on vectors and matrices

   default_units :: STR  DEFAULT(" ")
   ! Each REAL number is assumed to have "default_units", and are converted
   ! into generic (internal) units, usually A.U.

   comment_chars :: STR  DEFAULT(TEXTFILE_COMMENT_CHARS)
   ! The comment character symbols (concatenated) to be used in the textfile

   quote_chars :: STR  DEFAULT(TEXTFILE_QUOTE_CHARS)
   ! The quote character symbols (concatenated) to be used in the textfile

   replacement_list :: MAT{STR}* DEFAULT_NULL
   ! A list of strings and their replacements, to be applied when every line is
   ! inputted, if required.

   buffer :: BUFFER
   ! The output buffer which holds one line of output to be flushed

   internal :: VEC{STR}* DEFAULT_NULL
   ! Used to keep a record of of the entire file, internally

   saved :: TEXTFILE* DEFAULT_NULL
   ! Used to keep a record of a previous file, say for input redirect

   end

   type ARCHIVE

   root_name :: STR
   ! Archive root name (usually, the name of the job)

   name :: STR
   ! Archive name (usually, the name of the entity in the archive)

   genre :: STR
   ! Archive basis genre for opmatrix objects, or a qualifier for name

   format :: STR
   ! Archive format (blank for binary)

   file :: FILE* DEFAULT_NULL
   ! Binary file part

   textfile :: TEXTFILE* DEFAULT_NULL
   ! Text file part

   end

   type CIF

   file_name :: STR  DEFAULT(" ")
   ! The name of the CIF file to open

   file :: TEXTFILE* DEFAULT_NULL
   ! The actual CIF file to be processed

   data_block_name :: STR  DEFAULT(" ")
   ! The name of the data block

   start_of_data :: INT  DEFAULT(1)
   ! The starting line of the data block

   end_of_data :: INT  DEFAULT(0)
   ! The end line of the data block

   data_block_found :: BIN  DEFAULT(FALSE)
   ! Set TRUE if a data block has been sucessfully found

   CH_bond_length :: REAL  DEFAULT(-CIF_CH_BOND_LENGTH*BOHR_PER_ANGSTROM)
   ! If greater than zero any CH bonds in the CIF file are set to this

   NH_bond_length :: REAL  DEFAULT(-CIF_NH_BOND_LENGTH*BOHR_PER_ANGSTROM)
   ! If greater than zero any NH bonds in the CIF file are set to this

   OH_bond_length :: REAL  DEFAULT(-CIF_OH_BOND_LENGTH*BOHR_PER_ANGSTROM)
   ! If greater than zero any OH bonds in the CIF file are set to this

   U_iso_is_B_iso :: BIN  DEFAULT(FALSE)
   ! If TRUE, then any U_iso values in the CIF file are interpreted as B_iso
   ! values. This is a hack that should not be used except when the CIF file is
   ! hand made using B_iso values.

   U_is_B :: BIN  DEFAULT(FALSE)
   ! If TRUE, then any U values (i.e. ADP's) in the CIF file are interpreted as B
   ! values. This is a hack that should not be used except when the CIF file is
   ! hand made using B_iso values.

   U_is_beta :: BIN  DEFAULT(FALSE)
   ! If TRUE, then any U values (i.e. ADP's) in the CIF file are interpreted as
   ! beta values. This is a hack that should not be used except when the CIF
   ! file is hand made using B_iso values.

   end

   type RYS

   nroots :: INT
   ! No. of rys roots

   w :: VEC{REAL}* DEFAULT_NULL
   ! The Rys weights

   r :: VEC{REAL}* DEFAULT_NULL
   ! The Rys roots

   end

   type VEC_{INT}

   element :: VEC{INT}* DEFAULT_NULL
   ! Encapsulated ivec type

   end

   array type VEC{VEC_{INT}}

      ! A 1-D array of VEC_{INT} objects

   end

   type VEC_{REAL}

   element :: VEC{REAL}* DEFAULT_NULL
   ! Encapsulated vec type

   end

   array type MAT{VEC_{INT}}

      ! A matrix of VEC_{INT} objects

   end

   array type MAT3{VEC_{INT}}

      ! A 3D matrix of VEC_{INT} objects

   end

   array type MAT3{VEC_{REAL}}

      ! A 3D matrix of VEC_{REAL} objects

   end

   array type VEC{VEC_{REAL}}

      ! A 1-D array of VEC_{REAL} objects

   end

   array type MAT{VEC_{REAL}}

      ! A matrix of VEC_{REAL} objects

   end

   type VEC_{VEC_{REAL}}

   element :: VEC{VEC_{REAL}}* DEFAULT_NULL
   ! Encapsulated encapsulated vector

   end

   array type VEC{VEC_{VEC_{REAL}}}

      ! A 1-D array of VEC_{VEC_{REAL}} objects

   end

   type MAT_{REAL}

   element :: MAT{REAL}* DEFAULT_NULL
   ! Encapsulated mat type

   end

   array type VEC{MAT_{REAL}}

      ! A 1-D array of MAT_{REAL} objects

   end

   array type MAT{MAT_{REAL}}

      ! A matrix of MAT_{REAL} objects

   end

   type MAT3_{REAL}

   element :: MAT3{REAL}* DEFAULT_NULL
   ! Encapsulated mat3 type

   end

   array type VEC{MAT3_{REAL}}

      ! A 1-D array of MAT3_{REAL} objects

   end

   type MAT4_{REAL}

   element :: MAT4{REAL}* DEFAULT_NULL
   ! Encapsulated mat4 type

   end

   array type VEC{MAT4_{REAL}}

      ! A 1-D array of MAT4_{REAL} objects

   end

   type OPVECTOR

   n_bf :: INT
   ! No of spatial basis functions (i.e. AO's)

   restricted :: VEC{REAL}* DEFAULT_NULL
   ! Restricted spinorbital representation

   alpha :: VEC{REAL}* DEFAULT_NULL
   ! Alpha part of a DODS representation

   beta :: VEC{REAL}* DEFAULT_NULL
   ! Beta  part of a DODS representation

   general :: VEC{REAL}* DEFAULT_NULL
   ! General mixed alpha-beta matrix representation

   end

   type OPMATRIX

   n_bf :: INT
   ! No of real spatial basis functions (i.e. AO's)

   restricted :: MAT{REAL}* DEFAULT_NULL
   ! Restricted spinorbital representation

   alpha :: MAT{REAL}* DEFAULT_NULL
   ! Alpha part of a DODS representation

   beta :: MAT{REAL}* DEFAULT_NULL
   ! Beta  part of a DODS representation

   general :: MAT{REAL}* DEFAULT_NULL
   ! General mixed alpha-beta matrix representation

   restricted_complex :: MAT{CPX}* DEFAULT_NULL
   ! Complex restricted representation

   alpha_complex :: MAT{CPX}* DEFAULT_NULL
   ! Complex alpha part of a DODS representation

   beta_complex :: MAT{CPX}* DEFAULT_NULL
   ! Complex beta  part of a DODS representation

   general_complex :: MAT{CPX}* DEFAULT_NULL
   ! Complex general mixed alpha-beta matrix representation

   triangle :: VEC{REAL}* DEFAULT_NULL
   ! Space saving for symmetric matrices: lower triangle only

   square :: VEC{REAL}* DEFAULT_NULL
   ! Space saving for hermitian matrices: lower triangle is real part, upper is imaginary

   end

   type HASH{VEC{INT},VEC{INT}}

   n_keys :: INT
   ! The number of keys

   n_size :: INT
   ! The size of the keys and values arrays.

   reverse_search :: BIN
   ! If TRUE, the search for values is performed from the largest key to the
   ! smallest.

   keys :: MAT{INT}* DEFAULT_NULL
   ! The array of keys, stored contigously by columns.

   values :: MAT{INT}* DEFAULT_NULL
   ! The array of values.

   end

   type ADAPTIVE_QUADRATURE

   algorithm :: STR  DEFAULT(" ")
   ! Identifier for the kind of quadrature algorithm

   accuracy :: REAL  DEFAULT(QUADRATURE_ACCURACY)
   ! The accuracy required for adapative quadratures

   n_points :: INT  DEFAULT(0)
   ! No. of quadrature points. For adaptive quadrature it is set to thye number
   ! of function eveluations.

   lower_limit :: REAL  DEFAULT(-ONE)
   ! Lower integration limit (if appropriate)

   upper_limit :: REAL  DEFAULT(ONE)
   ! Upper integration limit (if appropriate)

   point :: MAT{REAL}*  DEFAULT_NULL
   ! The 3D quadrature points

   weight :: VEC{REAL}*  DEFAULT_NULL
   ! The quadrature weight

   embedded_weight :: VEC{REAL}*  DEFAULT_NULL
   ! The embedded set of quadrature weights--for embedded cubature.

   end

!   type QUADRATURE
!
!   quad_kind :: STR  DEFAULT(" ")
!    Identifier for the kind of quadrature
!
!   accuracy :: REAL  DEFAULT(QUADRATURE_ACCURACY)
!    The accuracy required for adapative quadratures
!
!   n_points :: INT  DEFAULT(0)
!    No. of quadrature points. For adaptive quadrature it is set to thye number
!    of function eveluations.
!
!   lower_limit :: REAL  DEFAULT(-ONE)
!    Lower integration limit (if appropriate)
!
!   upper_limit :: REAL  DEFAULT(ONE)
!    Upper integration limit (if appropriate)
!
!   gauss_laguerre_alpha :: REAL  DEFAULT(ONE)
!    Gauss-Laguerre alpha parameter
!
!   gauss_jacobi_alpha :: REAL  DEFAULT(ONE)
!    Gauss-Jacobi alpha parameter
!
!   gauss_jacobi_beta :: REAL  DEFAULT(ONE)
!    Gauss-Jacobi alpha parameter
!
!   eps :: REAL  DEFAULT(QUADRATURE_EPS)
!    The relative accuracy of the roots when they are polished
!
!   maxit :: INT  DEFAULT(QUADRATURE_MAXIT)
!    The maximum iterations to work solve for the roots.
!
!   root :: VEC{REAL}*  DEFAULT_NULL
!    The 1D quadrature point i.e. root of the appropriate orthogonal polynomial
!
!   point :: MAT{REAL}*  DEFAULT_NULL
!    The 3D quadrature points
!
!   weight :: VEC{REAL}*  DEFAULT_NULL
!    The quadrature weight
!
!   embedded_weight :: VEC{REAL}*  DEFAULT_NULL
!    The embedded set of quadrature weights--for embedded cubature.
!
!   finalised :: BIN  DEFAULT(FALSE)
!    Set TRUE when all initialisations are completed.
!
!   end

   type QUADRATURE

   kind :: STR  DEFAULT(" ")
   ! Identifier for the kind of quadrature

   n_points :: INT  DEFAULT(0)
   ! No of quadrature points, or the order of the quadrature

   fold_weight_function_in :: BIN  DEFAULT(TRUE)
   ! The quadrature of I = Int f(x) dx is I = Sum_i f(x_i) w_i, i.e. no weight
   ! function appears in the integrand; it has been folded into w_i.  If this
   ! switch is set FALSE then f(x) = F(x) W(x) and the quadrature is defined as
   ! I = Int F(x) W(x) dx = Sum_i F(x_i) W_i i.e. the function F(x) to be
   ! quadrated does *not* have the weight W(x) folded in, as does f(x). The
   ! weights are related by w_i = W(x_i) W_i. Normally the program calculated
   ! W_i but it delivers w_i.

   lower_limit :: REAL  DEFAULT(-ONE)
   ! Lower integration limit (if appropriate)

   upper_limit :: REAL  DEFAULT(ONE)
   ! Upper integration limit (if appropriate)

   gauss_laguerre_alpha :: REAL  DEFAULT(ONE)
   ! Gauss-Laguerre alpha parameters

   gauss_jacobi_alpha :: REAL  DEFAULT(ONE)
   ! Gauss-Jacobi alpha parameter

   gauss_jacobi_beta :: REAL  DEFAULT(ONE)
   ! Gauss-Jacobi alpha parameter

   eps :: REAL  DEFAULT(QUADRATURE_EPS)
   ! The relative accuracy of the roots when they are polished

   maxit :: INT  DEFAULT(QUADRATURE_MAXIT)
   ! The maximum iterations to work solve for the roots.

   point :: VEC{REAL}*  DEFAULT_NULL
   ! The quadrature point i.e. root of the appropriate orthogonal polynomial

   weight :: VEC{REAL}*  DEFAULT_NULL
   ! The quadrature weight

   finalised :: BIN  DEFAULT(FALSE)
   ! Set TRUE when all initialisations are completed.

   end

   array type VEC{QUADRATURE}

      ! A 1-D array of QUADRATURE objects

   end

   type QUADRATURE2

   x :: QUADRATURE
   ! Quadrature object for the x-axis

   y :: QUADRATURE
   ! Quadrature object for the x-axis

   n_points :: INT  DEFAULT(0)
   ! No. of quadrature points in the direct product quadrature.

   point :: MAT{REAL}*  DEFAULT_NULL
   ! The quadrature points, in the (x,y) plane.

   weight :: VEC{REAL}*  DEFAULT_NULL
   ! The quadrature weights.

   end

   type LEBEDEV

   n_points :: INT  DEFAULT(0)
   ! No of quadrature points

   l :: INT  DEFAULT(0)
   ! The angular momentum that this quadrature will integrate up to.

   point :: MAT{REAL}*  DEFAULT_NULL
   ! Coordinates of the quadrature points

   weight :: VEC{REAL}*  DEFAULT_NULL
   ! The quadrature weights (normalised to unity)

   n_points_per_shell :: VEC{INT}*  DEFAULT_NULL
   ! No of ppoints per shell. This is used to save work when calculating the
   ! atomic grids on each shell.

   n :: INT, private DEFAULT(0)
   ! Private counter to keep track of how many points have been added into the
   ! quadrature grid.

   s :: INT, private DEFAULT(0)
   ! Private counter to keep track of how many shells there are in the
   ! quadrature grid.

   end

   type REFLECTION

   h :: INT  DEFAULT(0)
   ! Miller h index for the reflection

   k :: INT  DEFAULT(0)
   ! Miller k index for the reflection

   l :: INT  DEFAULT(0)
   ! Miller l index for the reflection

   theta :: REAL  DEFAULT(ZERO)
   ! The Bragg angle theta of reflection

   equivalence_factor :: INT  DEFAULT(1)
   ! The number of distinct reflections 
   !which are symmetry equivalent

   F_exp :: REAL  DEFAULT(ZERO)
   ! Experimental structure factor

   F_sigma :: REAL  DEFAULT(ZERO)
   ! Experimental error in the structure factor

   F_calc :: CPX  DEFAULT(ZERO)
   ! Calculated complex structure factor without including corrections

   F_pred :: REAL  DEFAULT(ZERO)
   ! Calculated structure factor including scale and extinction corrections

   F2_exp :: REAL  DEFAULT(ZERO)
   ! Experimental structure factor squared

   F2_sigma :: REAL  DEFAULT(ZERO)
   ! Experimental error in the structure factor squared

   F2_exp_inputted :: BIN  DEFAULT(FALSE)
   ! Set TRUE only if the experimental structure factor squared has been
   ! inputted. We need this to make sure that the F2_sigma values are specified
   ! after the F2_exp values, since the former are required to derive the
   ! F_sigma values.

   I_exp :: REAL  DEFAULT(ZERO)
   ! Experimental intensity

   I_sigma :: REAL  DEFAULT(ZERO)
   ! Experimental error in the intensity

   I_pred :: REAL  DEFAULT(ZERO)
   ! Calculated intensity including scale and extinction corrections

   group :: INT DEFAULT(ZERO)
   ! Specifies the group that this reflection belongs to. Reflections in
   ! different groups may get treated differently e.g. be optimised with
   ! different scale factors.

   end

   array type VEC{REFLECTION}

      ! A 1-D array of REFLECTION objects

   end

   type DIIS

   genre :: STR  DEFAULT(DIIS_GENRE)
   ! The kind of DIIS procedure to use

   iteration :: INT  DEFAULT(0)
   ! The iteration count for the DIIS procedure. It gets incremented every time
   ! one of the extrapolators/interpolators are called.

   start_iteration :: INT  DEFAULT(DIIS_START_ITERATION)
   ! The iteration when the DIIS procedure is supposed to start accelerating the
   ! requested object. The DIIS acceleration procedure works on the saved vectors,
   ! and the procedure can start saving vectors before starting the acceleration
   ! procedure.

   save_iteration :: INT  DEFAULT(DIIS_SAVE_ITERATION)
   ! The iteration when the DIIS object starts saving vectors. It must be equal
   ! or smaller than the start_iteration. The previously saved vectors are used
   ! in the acceleration procedure.

   keep :: INT  DEFAULT(DIIS_KEEP)
   ! No. of DIIS vectors to keep for use in extrapolation

   kept :: INT  DEFAULT(0)
   ! The actual number of DIIS vectors kept.

   oldest :: VEC{INT}*  DEFAULT_NULL
   ! A list of the indices of the oldest vectors.

   new :: INT  DEFAULT(0)
   ! The integer identifier for the new (current) parameter vector, usually the
   ! Fock matrix.  This is equal to .iteration only if .iteration<=.keep;
   ! otherwise it is an integer in the range [1,.keep] which corresponds to the
   ! parameter vector with the worst error (DIIS) or the oldest vector (EDIIS).
   ! In this way, the worst/oldest parameter and error vectors are pruned.

   error_length :: REAL  DEFAULT(ZERO)
   ! The length of the DIIS error vector

   convergence_tolerance :: REAL  DEFAULT(DIIS_CONVERGENCE_TOLERANCE)
   ! This tolerance specifies when the DIIS/EDIIS procedure is regarded to be
   ! converged.

   start_tolerance :: REAL  DEFAULT(DIIS_START_TOLERANCE)
   ! In the case when the method is "ediis+diis", this tolerance specifies when
   ! the EDIIS procedure finishes and when the DIIS procedure begins.

   encore_iterations :: REAL  DEFAULT(DIIS_ENCORE_ITERATIONS)
   ! In the case when the method is "ediis+diis", this tolerance specifies how
   ! many EDIIS iterations are to be performed again, assuming that EDIIS was
   ! already performed before, and DIIS has started to diverge.

   stage :: INT   DEFAULT(0)
   ! The stage of the "ediis+diis" calculation. If 0, we have not yet started
   ! the first DIIS. If 1, we have finished EDIIS and started DIIS. If 2, we
   ! have reached stage 1, but we need encore EDIIS iterations.

   encore :: INT   DEFAULT(0)
   ! The iteration counter for encore iterations.

   replacement_method :: STR  DEFAULT(DIIS_REPLACEMENT_METHOD)
   ! This specifies the method to be used when replacing the DIIS vectors, in
   ! the case when the DIIS space becomes saturated. The choices are "worst"
   ! item, or "oldest" item.

   archive :: ARCHIVE
   ! Archive used to store the DIIS parameter and error vectors

   par_tag :: STR  DEFAULT("fock_matrix")
   ! A string tag used to identify the parameter vectors stored on disk, which
   ! are used to construct the next DIIS approximation.

   err_tag :: STR  DEFAULT("pulay_error")
   ! A string tag used to identify the error vectors stored on disk, which
   ! are used to construct the next DIIS approximation.

   lhs_tag :: STR  DEFAULT("diis_lhs")
   ! A string tag used to identify the DIIS LHS matrix stored on disk.

   lhs_tol :: REAL  DEFAULT(TOL(10))
   ! Tolernace for solving the non-linear DDIIS  equations iteratively.

   S :: MAT{REAL}*  DEFAULT_NULL
   ! The overlap matrix. Used to calculate commutators.

   F :: OPMATRIX*   DEFAULT_NULL
   ! The current fock matrix. It gets stored on disk, and then extrapolated or
   ! interpolated by the DIIS routines.

   F_tag :: STR  DEFAULT("fock_matrix")
   ! A string tag used to identify the Fock matrices stored on disk, which
   ! are used to construct the next DIIS approximation. 

   D :: OPMATRIX*   DEFAULT_NULL
   ! The density matrix corresponding to the current fock matrix. It gets stored
   ! on disk and is used to calculate the commutators.

   D_tag :: STR  DEFAULT("density_matrix")
   ! A string tag used to identify the Density matrices stored on disk, which
   ! are used to construct the next DIIS approximation. 

   J :: OPMATRIX*   DEFAULT_NULL
   ! The coulomb matrix corresponding to the current fock matrix. It gets stored
   ! on disk and is used to calculate commutators in the UHF case only.

   J_tag :: STR  DEFAULT("coulomb_matrix")
   ! A string tag used to identify the Coulomb J matrices stored on disk, which
   ! are used to construct the next DIIS approximation in the UHF case.

   energy :: VEC{REAL}*   DEFAULT_NULL
   ! The current SCF electronic energy (or energies, in the UHF case), used in
   ! energy DIIS.

   e_tag :: STR  DEFAULT("energy")
   ! A string tag used to identify the energy stored on disk, which
   ! are used to construct the next DIIS approximation. 

   force_convexity :: BIN  DEFAULT(DIIS_FORCE_CONVEXITY)
   ! If TRUE the diis coefficients are forced to be positive to ensure that any
   ! extrapolated density matrix is a convex linear combination. This is TRUE by
   ! default for the EDIIS method.

   micro_iteration_method :: STR   DEFAULT(DIIS_MICRO_ITERATION_METHOD)
   ! The name of the method used to solve the DDIIS equations iteratively.
   ! These are called DDIIS micro iterations.

   micro_starting_guess :: STR   DEFAULT(DIIS_MICRO_STARTING_GUESS)
   ! The starting guess to use for the solving the DDIIS equations iteratively.
   ! They can be started with the "last" density or "diis" coefficients.

   micro_convergence_tol :: REAL  DEFAULT(DIIS_MICRO_CONVERGENCE_TOL)
   ! The tolerace for solving the non-linear DDIIS  equations iteratively.

   micro_max_iterations :: INT  DEFAULT(DIIS_MICRO_MAX_ITERATIONS)
   ! This is the maximum number of micro iterations allowed when solving the
   ! non-linear DDIIS equations by simple relaxation.

   micro_damp_factor :: REAL  DEFAULT(DIIS_MICRO_DAMP_FACTOR)
   ! The damp factor to use when solving the non-linear DDIIS equations by
   ! simple relaxation.

   end

   type GAUSSIAN

   l :: INT  DEFAULT(0)
   ! l quantum number for the gaussian

   ex :: REAL  DEFAULT(ZERO)
   ! Exponent for the gaussian

   pos :: VEC{REAL}(3)  DEFAULT(ZERO)
   ! Position of the gaussian
   end

   type GAUSSIAN2

   a :: GAUSSIAN
   ! Shell "a" of the pair

   b :: GAUSSIAN
   ! Shell "b" of the pair

   end

   type GAUSSIAN4

   a :: GAUSSIAN
   ! Shell "a" of the quartet

   b :: GAUSSIAN
   ! Shell "b" of the quartet

   c :: GAUSSIAN
   ! Shell "c" of the quartet

   d :: GAUSSIAN
   ! Shell "d" of the quartet

   end

   type SHELL

   l :: INT  DEFAULT(0)
   ! l quantum number for the gaussian shell

   n_comp :: INT  DEFAULT(0)
   ! No. of components for the gaussian shell

   n_cc :: INT  DEFAULT(0)
   ! No. of contractions for the gaussian shell

   ex :: VEC{REAL}* DEFAULT_NULL
   ! Exponent vector

   cc :: VEC{REAL}* DEFAULT_NULL
   ! Contraction coefficient vector

   end

   array type VEC{SHELL}

      ! A 1-D array of SHELL objects

   end

   type SHELL1

   l :: INT  DEFAULT(0)
   ! l quantum number of the shell

   n_comp :: INT  DEFAULT(0)
   ! No. of components for the shell

   n_cc :: INT  DEFAULT(0)
   ! No. of contraction coefficients for the shell

   pos :: VEC{REAL}(3)  DEFAULT(ZERO)
   ! Position of the shell

   ex :: VEC{REAL}* DEFAULT_NULL
   ! Exponent vector

   cc :: VEC{REAL}* DEFAULT_NULL
   ! Contraction coefficient vector

   end

   type SHELL2

   a :: SHELL1
   ! Shell "a" of the pair

   b :: SHELL1
   ! Shell "b" of the pair

   n_gaussian_pairs :: INT
   ! The number of gaussian pair products in the shell pair, .a.n_cc*.b.n_cc

   l_max :: INT
   ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

   l_min :: INT
   ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

   l_sum :: INT
   ! Sum of the angular momenta on each shell, .a.l+.b.l

   kappa_max :: REAL
   ! Maximum of .a.cc * .b.cc * kappa_ab for the two electron integrals.

   exponent_sum :: VEC{REAL}* DEFAULT_NULL
   ! The sum of all gaussian pair exponents as a flattened array with shell "a"
   ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

   exponent_inv :: VEC{REAL}* DEFAULT_NULL
   ! The inverse of the sum of the gaussian pair exponents, as a flattened
   ! array, 1/(.a.ex(:)+.b.ex(:))

   a_exponent_inv :: VEC{REAL}* DEFAULT_NULL
   ! The product of the exponent of shell "a" with the inverse of the sum of the
   ! gaussian pair exponents, as a flattened array, .a.ex(:)/(.a.ex(:)+.b.ex(:))

   b_exponent_inv :: VEC{REAL}* DEFAULT_NULL
   ! The product of the exponent of shell "b" with the inverse of the sum of the
   ! gaussian pair exponents, as a flattened array, .b.ex(:)/(.a.ex(:)+.b.ex(:))

   cc_prefactor :: VEC{REAL}* DEFAULT_NULL
   ! The contraction coefficient product with an exponential part for each
   ! gaussian pair as a flattened array with shell "a" gaussian components
   ! incrementing most rapidly. Useful for integral evaluation.

   normalising_factors :: VEC{REAL}* DEFAULT_NULL
   ! The product of the normalisation coefficients, as a flattened array,
   ! .a.l.normalising_factors * .b.l.normalising_factors.

   pair_center :: MAT{REAL}* DEFAULT_NULL
   ! The center of the product gaussian of gaussians .a and .b.

   center_diff :: MAT{REAL}* DEFAULT_NULL
   ! The difference between pair_center and the position of the gaussian of
   ! higher angular momentum out of .a and .b.

   end

   type SHELLPAIR

   a :: SHELL
   ! Shell "a" of the pair

   b :: SHELL
   ! Shell "b" of the pair

   n_gaussian_pairs :: INT
   ! The number of gaussian pair products in the shell pair, .a.n_cc*.b.n_cc

   l_max :: INT
   ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

   l_min :: INT
   ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

   l_sum :: INT
   ! Sum of the angular momenta on each shell

   exponent_sum :: VEC{REAL}* DEFAULT_NULL
   ! The sum of all gaussian pair exponents as a flattened array with shell "a"
   ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

   exponent_inv :: VEC{REAL}* DEFAULT_NULL
   ! The inverse of the sum of the gaussian pair exponents, as a flattened
   ! array, 1/(.a.ex(:)+.b.ex(:))

   a_exponent_inv :: VEC{REAL}* DEFAULT_NULL
   ! The product of the exponent of shell "a" with the inverse of the sum of the
   ! gaussian pair exponents, as a flattened array, .a.ex(:)/(.a.ex(:)+.b.ex(:))

   b_exponent_inv :: VEC{REAL}* DEFAULT_NULL
   ! The product of the exponent of shell "b" with the inverse of the sum of the
   ! gaussian pair exponents, as a flattened array, .b.ex(:)/(.a.ex(:)+.b.ex(:))

   cc_prefactor :: VEC{REAL}* DEFAULT_NULL
   ! The contraction coefficient product with an exponential part for each
   ! gaussian pair as a flattened array with shell "a" gaussian components
   ! incrementing most rapidly. Useful for integral evaluation.

   normalising_factors :: VEC{REAL}* DEFAULT_NULL
   ! The product of the normalisation coefficients, as a flattened array,
   ! .a.l.normalising_factors * .b.l.normalising_factors.

   hrr_index_larger :: MAT3{INT}* DEFAULT_NULL
   ! The mapping of the cartesian angular momenta to a single array, from
   ! max(.a.l,.b.l) to .a.l+.b.l.  In the HRR, this is the index for the
   ! component with the larger angular momentum.

   hrr_index_smaller :: MAT3{INT}* DEFAULT_NULL
   ! The mapping of the cartesian angular momenta to a single array, from zero
   ! up to .a.l+.b.l.  In the HRR, this is the index for the component with the
   ! smaller angular momentum.

   hrr_components :: MAT{INT}* DEFAULT_NULL
   ! Cartesian components of the angular momenta from zero up to .a.l+.b.l.

   hrr_comp_to_use :: VEC{INT}* DEFAULT_NULL
   ! Which cartesian component of angular momentum to use for the HRR for the
   ! angular momenta between zero up to .a.l+.b.l.

   form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .l_max up to .a.l+.b.l.

   form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .l_max up to .a.l+.b.l.

   form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .l_max up to .a.l+.b.l.

   form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .l_max up to .a.l+.b.l.  This version is for the
   ! reduced multiplication scheme, where the y and z arrays have been collapsed
   ! into one product array.

   end

   array type VEC{SHELLPAIR}

      ! A 1-D array of SHELLPAIR objects

   end

   type SHELL4

   a :: SHELL1
   ! Shell "a" of the quartet

   b :: SHELL1
   ! Shell "b" of the quartet

   c :: SHELL1
   ! Shell "c" of the quartet

   d :: SHELL1
   ! Shell "d" of the quartet

   end

   type SHELLQUARTET

   ab :: SHELLPAIR* DEFAULT_NULL
   ! Pair "ab" of the quartet

   cd :: SHELLPAIR* DEFAULT_NULL
   ! Pair "cd" of the quartet

   end

   type SHELL1QUARTET

   a :: SHELL* DEFAULT_NULL
   ! Shell "a" of the quartet

   b :: SHELL* DEFAULT_NULL
   ! Shell "b" of the quartet

   c :: SHELL* DEFAULT_NULL
   ! Shell "c" of the quartet

   d :: SHELL* DEFAULT_NULL
   ! Shell "d" of the quartet

   pos_a :: VEC{REAL}(3)
   ! Position of the "a" shell.

   pos_b :: VEC{REAL}(3)
   ! Position of the "b" shell

   pos_c :: VEC{REAL}(3)
   ! Position of the "c" shell

   pos_d :: VEC{REAL}(3)
   ! Position of the "d" shell

   ab_nullify :: BIN
   ! Whether to nullify the precalculated .ab vectors or destroy them, i.e.
   ! whether they were pointer assigned or created/calculated.

   cd_nullify :: BIN
   ! Whether to nullify the precalculated .cd vectors or destroy them, i.e.
   ! whether they were pointer assigned or created/calculated.

   ab_n_gaussian_pairs :: INT
   ! The number of gaussian pair products in the shell pair, .a.n_cc*.b.n_cc

   ab_l_max :: INT
   ! Maximum of the angular momenta on each shell, max(.a.l,.b.l)

   ab_l_min :: INT
   ! Minimum of the angular momenta on each shell, min(.a.l,.b.l)

   ab_l_sum :: INT
   ! Sum of the angular momenta on each shell, .a.l+.b.l

   ab_kappa_max :: REAL
   ! Maximum of .a.cc * .b.cc * kappa_ab for the two electron integrals.

   ab_exponent_sum :: VEC{REAL}* DEFAULT_NULL
   ! The sum of all gaussian pair exponents as a flattened array with shell "a"
   ! exponents incrementing most rapidly, .a.ex(:)+.b.ex(:)

   ab_cc_prefactor :: VEC{REAL}* DEFAULT_NULL
   ! The contraction coefficient product with an exponential part for each
   ! gaussian pair as a flattened array with shell "a" gaussian components
   ! incrementing most rapidly. Useful for integral evaluation.

   ab_normalising_factors :: VEC{REAL}* DEFAULT_NULL
   ! The product of the normalisation coefficients, as a flattened array,
   ! .a.l.normalising_factors * .b.l.normalising_factors.

   ab_pair_center :: MAT{REAL}* DEFAULT_NULL
   ! The center of the product gaussian of gaussians .a and .b.

   ab_center_diff :: MAT{REAL}* DEFAULT_NULL
   ! The difference between ab_pair_center and the position of the gaussian of
   ! higher angular momentum out of .a and .b.

   cd_n_gaussian_pairs :: INT
   ! The number of gaussian pair products in the shell pair, .c.n_cc*.d.n_cc

   cd_l_max :: INT
   ! Maximum of the angular momenta on each shell, max(.c.l,.d.l)

   cd_l_min :: INT
   ! Minimum of the angular momenta on each shell, min(.c.l,.d.l)

   cd_l_sum :: INT
   ! Sum of the angular momenta on each shell, .c.l+.d.l

   cd_kappa_max :: REAL
   ! Maximum of .c.cc * .d.cc * kappa_cd for the two electron integrals.

   cd_exponent_sum :: VEC{REAL}* DEFAULT_NULL
   ! The sum of all gaussian pair exponents as a flattened array with shell "c"
   ! exponents incrementing most rapidly, .c.ex(:)+.d.ex(:)

   cd_cc_prefactor :: VEC{REAL}* DEFAULT_NULL
   ! The contraction coefficient product with an exponential part for each
   ! gaussian pair as a flattened array with shell "c" gaussian components
   ! incrementing most rapidly. Useful for integral evaluation.

   cd_normalising_factors :: VEC{REAL}* DEFAULT_NULL
   ! The product of the normalisation coefficients, as a flattened array,
   ! .c.l.normalising_factors * .d.l.normalising_factors.

   cd_pair_center :: MAT{REAL}* DEFAULT_NULL
   ! The center of the product gaussian of gaussians .c and .d.

   cd_center_diff :: MAT{REAL}* DEFAULT_NULL
   ! The difference between cd_pair_center and the position of the gaussian of
   ! higher angular momentum out of .c and .d.

   ab_hrr_index_larger :: MAT3{INT}* DEFAULT_NULL
   ! The mapping of the cartesian angular momenta to a single array, from
   ! max(.a.l,.b.l) to .a.l+.b.l.  In the HRR, this is the index for the
   ! component with the larger angular momentum.

   ab_hrr_index_smaller :: MAT3{INT}* DEFAULT_NULL
   ! The mapping of the cartesian angular momenta to a single array, from zero
   ! up to .a.l+.b.l.  In the HRR, this is the index for the component with the
   ! smaller angular momentum.

   ab_hrr_components :: MAT{INT}* DEFAULT_NULL
   ! Cartesian components of the angular momenta from zero up to .a.l+.b.l.

   ab_hrr_comp_to_use :: VEC{INT}* DEFAULT_NULL
   ! Which cartesian component of angular momentum to use for the HRR for the
   ! angular momenta between zero up to .a.l+.b.l.

   ab_form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .ab_l_max up to .a.l+.b.l.

   ab_form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .ab_l_max up to .a.l+.b.l.

   ab_form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .ab_l_max up to .a.l+.b.l.

   ab_form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .ab_l_max up to .a.l+.b.l.  This version is for the
   ! reduced multiplication scheme, where the y and z arrays have been collapsed
   ! into one product array.

   cd_hrr_index_larger :: MAT3{INT}* DEFAULT_NULL
   ! The mapping of the cartesian angular momenta to a single array, from
   ! max(.c.l,.d.l) to .c.l+.d.l.  In the HRR, this is the index for the
   ! component with the larger angular momentum.

   cd_hrr_index_smaller :: MAT3{INT}* DEFAULT_NULL
   ! The mapping of the cartesian angular momenta to a single array, from zero
   ! up to .c.l+.d.l.  In the HRR, this is the index for the component with the
   ! smaller angular momentum.

   cd_hrr_components :: MAT{INT}* DEFAULT_NULL
   ! Cartesian components of the angular momenta from zero up to .c.l+.d.l.

   cd_hrr_comp_to_use :: VEC{INT}* DEFAULT_NULL
   ! Which cartesian component of angular momentum to use for the HRR for the
   ! angular momenta between zero up to .c.l+.d.l.

   cd_form_3dints_x_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .cd_l_max up to .c.l+.d.l.

   cd_form_3dints_y_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .cd_l_max up to .c.l+.d.l.

   cd_form_3dints_z_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .cd_l_max up to .c.l+.d.l.

   cd_form_3dints_yz_rms_indices :: VEC{INT}* DEFAULT_NULL
   ! Which indices to use for combining the 2d ERIs to 3d ERIS, for the
   ! angular momenta from .cd_l_max up to .c.l+.d.l.  This version is for the
   ! reduced multiplication scheme, where the y and z arrays have been collapsed
   ! into one product array.

   r2ab :: REAL
   ! The distance between shells .a and .b.

   r2cd :: REAL
   ! The distance between shells .c and .d.

   end

   type BASIS

   label :: STR
   ! Unique label for the basis set

   n_shell :: INT
   ! No. of shells in the basis, equal to size(shell)

   n_bf :: INT
   ! No. of basis functions for the shell

   n_prim :: INT
   ! No. of primitives for the shell

   shell :: VEC{SHELL}* DEFAULT_NULL
   ! The list of gaussian shells in the basis set

   end

   array type VEC{BASIS}

      ! A 1-D array of BASIS objects

   end

   type INTERPOLATOR

   interpolation_kind :: STR  DEFAULT(INTERPOLATOR_INTERPOLATION_KIND)
   ! The kind of interpolation used (usually "linear"). Also allowed is
   ! "logarithmic".

   table_origin :: REAL  DEFAULT(INTERPOLATOR_TABLE_ORIGIN)
   ! The origin of the table use i.e. where the table starts. Used for setting
   ! up even spaced data.

   table_length :: REAL  DEFAULT(INTERPOLATOR_TABLE_LENGTH)
   ! The length of the table use; it starts from the origin. Used for setting up
   ! even spaced data.

   table_spacing :: REAL  DEFAULT(INTERPOLATOR_TABLE_SPACING)
   ! The spacing between data points, if using an even spaced grid.
   ! (this is the case if spacing in non-zero)

   table_eps :: REAL  DEFAULT(INTERPOLATOR_TABLE_EPS)
   ! If there are values smaller than this in the interpolation table, they are
   ! set to zero. The interpolation table may be reduced in size.

   n_data :: INT  DEFAULT(0)
   ! The number of "data_points" and "values" in the table.

   data_point :: VEC{REAL}*  DEFAULT_NULL
   ! The list of data points, from smallest to largest.

   data_value :: VEC{REAL}*  DEFAULT_NULL
   ! The list of values corresponding to each data value.

   finalised :: BIN  DEFAULT(FALSE)
   ! Set TRUE if the object is ready for use

   y2 :: VEC{REAL}*  DEFAULT_NULL
   ! The tabulated values of the second derivatives at the data_point's. This is
   ! used only for cubic spline interpolation.

   y1_initial :: REAL  DEFAULT(INTERPOLATOR_Y1_INITIAL)
   ! The first derivative at the initial data_point to use, when doing cubic
   ! spline interpolation.

   y1_final :: REAL  DEFAULT(INTERPOLATOR_Y1_FINAL)
   ! The first derivative at the final data_point to use, when doing cubic
   ! spline interpolation.

   y2_initial :: REAL  DEFAULT(INTERPOLATOR_Y2_INITIAL)
   ! The second derivative at the initial data_point to use, when doing cubic
   ! spline interpolation. Normally ZERO.

   y2_final :: REAL  DEFAULT(INTERPOLATOR_Y2_FINAL)
   ! The second derivative at the final data_point to use, when doing cubic
   ! spline interpolation. Normally ZERO.

   end

   type SLATERSHELL

   l :: INT  DEFAULT(0)
   ! l quantum number 

   n_comp :: INT  DEFAULT(0)
   ! The number of l-components, normally 2*l+1 for spherical type slater
   ! functions.

   n_orb :: INT DEFAULT(0)
   ! The number of generally contracted orbitals.

   n_prim :: INT  DEFAULT(0)
   ! No. of exponents/contractions (i.e. the number of primitives for one
   ! *single* angular momentum shell component, e.g. p_x).

   n :: VEC{INT}* DEFAULT_NULL
   ! The n quantum numbers.

   z :: VEC{REAL}* DEFAULT_NULL
   ! The exponent zeta for each slater function

   c :: MAT{REAL}* DEFAULT_NULL
   ! The contraction coefficient matrix -- this is a generally contracted slater
   ! shell. The size of .dim1 is "n_cc". The size of .dim2 is "n_orb".

   orb_kind :: VEC{STR}* DEFAULT_NULL
   ! The kinds of the orbitals (1s, 2s, 2p, etc.), if available.
   ! It's length is "n_orb".

   occupancy :: VEC{INT}* DEFAULT_NULL
   ! The occupany number of each contracted orbital, if available.
   ! It's length is "n_orb".

   end

   array type VEC{SLATERSHELL}

      ! A 1-D array of SLATERSHELL objects

   end

   type SLATERBASIS

   label :: STR
   ! Unique label for the basis set

   configuration :: STR
   ! A STR representation of the configuration.

   n_shell :: INT
   ! No. of shells in the basis, equal to size(shell)

   n_bf :: INT
   ! No. of basis functions for the shell

   n_prim :: INT
   ! No. of primitives for the shell

   shell :: VEC{SLATERSHELL}* DEFAULT_NULL
   ! The list of gaussian shells in the basis set

   interpolator :: INTERPOLATOR* DEFAULT_NULL
   ! An interpolator object, used for calculating the atomic density at a
   ! certain radius, from the slater "shell" of orbitals

   d_interpolator :: INTERPOLATOR* DEFAULT_NULL
   ! The same as above, but for the 1st derivative of the density.

   d2_interpolator :: INTERPOLATOR* DEFAULT_NULL
   ! The same as above, but for the 2nd derivative of the density.

   end

   array type VEC{SLATERBASIS}

      ! A 1-D array of SLATERBASIS objects

   end

   type COPPENSORBITAL

   orb_kind :: STR
   ! The kind of the orbital (1s, 2s, 2p, etc.)

   occupancy :: INT
   ! The number of electrons in the orbital.

   n_fun :: INT
   ! The number of contracted fitting functions

   n :: VEC{INT}* DEFAULT_NULL
   ! The n quantum numbers

   c :: VEC{REAL}* DEFAULT_NULL
   ! The contraction coefficient

   z :: VEC{REAL}* DEFAULT_NULL
   ! The exponent zeta for each slater function

   end

   array type VEC{COPPENSORBITAL}

      ! A 1-D array of COPPENSORBITAL objects

   end

   type COPPENSBASIS

   label :: STR
   ! The basis label

   n_orb :: INT
   ! The number of orbitals in the basis

   n_prim :: INT
   ! The number of primitive functions in the basis

   orbital :: VEC{COPPENSORBITAL}* DEFAULT_NULL
   ! The list of fitted Slater atomic orbitals, Coppens style.

   interpolator :: INTERPOLATOR* DEFAULT_NULL
   ! An interpolator object, used for calculating the atomic density at a
   ! certain radius, from e.g. the coppensbasis

   end

   array type VEC{COPPENSBASIS}

      ! A 1-D array of COPPENSBASIS objects

   end

   type ATOM

   label :: STR  DEFAULT("?")
   ! The label for the atom (not necessarily unique)

   atomic_number :: INT
   ! The atomic number

   oxidation_state :: INT   DEFAULT(0)
   ! The atomic oxidation state

   pos :: VEC{REAL}(3)
   ! Atom position

   axis_system :: STR  DEFAULT("cartesian")
   ! Specifies the coordinate axis system

   U_iso :: REAL  DEFAULT(ZERO)
   ! The isotropic thermal smearing value for the atom

   thermal_tensor :: MAT{REAL}(3,3)  DEFAULT(ZERO)
   ! The thermal tensor for the atom

   thermal_axis_system :: STR  DEFAULT("cartesian")
   ! Specifies the thermal tensor coordinate system

   basis_label :: STR  DEFAULT(" ")
   ! The label of the basis set to match to.

   basis :: BASIS* DEFAULT_NULL
   ! The basis for the atom

   slaterbasis :: SLATERBASIS* DEFAULT_NULL
   ! The Slater function basis set for the atom. This includes occupancies and
   ! can be used for Hirshfeld surface plots and sum-of-spherical atoms densities.

   coppensbasis :: COPPENSBASIS* DEFAULT_NULL
   ! The Coppens-style fitted relativistic orbital basis for the atom. This is
   ! used for Hirshfeld surface plots and sum-of-spherical atoms densities.

   density_matrix :: OPMATRIX* DEFAULT_NULL
   ! The density matrix for the atom

   natural_orbitals :: OPMATRIX* DEFAULT_NULL
   ! The natural orbitals for the atom

   occupation_numbers :: OPVECTOR* DEFAULT_NULL
   ! The occupation numbers for the atom

   energy :: REAL
   ! The energy of the isolated atom

   group :: INT
   ! An integer which describes thr group to which the atom belongs

   sequence_number :: INT  DEFAULT(0)
   ! The sequence number (unique within on molecule, only one chain allowed yet)

   residue_atom_name :: STR  DEFAULT("?")
   ! The unique name for the atom in its (protein-)residue

   residue_name :: STR  DEFAULT("UNK")
   ! The residue name (must be part of residue table for pdbfile as input)

   mm_forcefield_name :: STR  DEFAULT("?")
   ! The name of the forcefield (e.g. amber, sybyl,...)

   mm_atom_type :: STR  DEFAULT("?")
   ! The atom type, used to define the force field potential

   mm_charge :: REAL  DEFAULT(ZERO)
   ! The atomic charge (relative to the force field!)

   restraining_position :: VEC{REAL}(3)  DEFAULT(ZERO)
   ! A position used for restrained geometry optimization

   restraining_force_constant :: REAL  DEFAULT(ZERO)
   ! A force constant used for restrained geometry optimisations

   site_occupancy :: REAL  DEFAULT(ONE)
   ! The crystallographic site occupancy.

   end

   array type VEC{ATOM}

      ! A 1-D array of ATOM's

   end

   type PLOTGRID

   plot_kind :: STR  DEFAULT(" ")
   ! The type of plot calculation wanted

   orbital :: INT  DEFAULT(0)
   ! The orbital to plot (if any)

   HOMO_orbital :: INT  DEFAULT(0)
   ! The HOMO orbital to plot. A value "n" indicates the HOMO+"n".

   LUMO_orbital :: INT  DEFAULT(0)
   ! The LUMO orbital to plot. A value "n" indicates the LUMO+"n".

   n_x :: INT  DEFAULT(PLOTGRID_NX)
   ! The number of points on the x-axis

   n_y :: INT  DEFAULT(PLOTGRID_NY)
   ! The number of points on the y-axis

   n_z :: INT  DEFAULT(PLOTGRID_NZ)
   ! The number of points on the z-axis

   n_pt :: INT  DEFAULT(0)
   ! The total no. of points in the plot

   atom :: VEC{ATOM}* DEFAULT_NULL
   ! List of atoms which can be used to define grid aces and positions.

   centre_atom :: INT  DEFAULT(0)
   ! Use this atom as the centre of the plot

   x_atom_1, x_atom_2 :: INT
   ! These atoms define the x-axis of the plot

   y_atom_1, y_atom_2 :: INT
   ! These atoms define the y-axis of the plot (made orthogonal to the x-axis)

   z_atom_1, z_atom_2 :: INT
   ! These atoms define the z-axis of the plot.

   del :: REAL  DEFAULT(ONE)
   ! The distance between axis points in the plot

   centre :: VEC{REAL}(3)  DEFAULT(ZERO)
   ! Centre of the plot

   origin :: VEC{REAL}(3)  DEFAULT(ZERO)
   ! Bottom left point of the plot

   x_axis :: VEC{REAL}(3)  DEFAULT(PLOTGRID_X_AXIS)
   ! x-axis of the plot

   y_axis :: VEC{REAL}(3)  DEFAULT(PLOTGRID_Y_AXIS)
   ! y-axis of the plot

   z_axis :: VEC{REAL}(3)  DEFAULT(PLOTGRID_Z_AXIS)
   ! z-axis of the plot

   width :: VEC{REAL}(3)  DEFAULT(PLOTGRID_WIDTH)
   ! The widths (in a.u.) of each axis of the plot

   offset :: VEC{REAL}(3)  DEFAULT(ZERO)
   ! The centre of the plot is offset by this amount

   x_width_set :: BIN  DEFAULT(TRUE)
   ! If False the x_width, i.e. width(1), is to be calculated from the size of
   ! the inputted x_axis vector; or if a width has *not* been inputted.

   y_width_set :: BIN  DEFAULT(TRUE)
   ! If False the y_width, i.e. width(2), is to be calculated from the size of
   ! the inputted y_axis vector; or if a width has *not* been inputted.

   z_width_set :: BIN  DEFAULT(TRUE)
   ! If False the z_width, i.e. width(3), is to be calculated from the size of
   ! the inputted z_axis vector; or if a width has *not* been inputted.

   x_axis_defined :: BIN  DEFAULT(FALSE)
   ! Flag set true if the user has defined the x_axis in the input

   y_axis_defined :: BIN  DEFAULT(FALSE)
   ! Flag set true if the user has defined the y_axis in the input

   z_axis_defined :: BIN  DEFAULT(FALSE)
   ! Flag set true if the user has defined the z_axis in the input

   box_centre :: VEC{REAL}(3)
   ! The centre of the bounding box, defined as the centre of an optional
   ! inputted atom list.

   bounding_box :: VEC{REAL}(3)
   ! The bounding box for the molecule, defined from an optional atom list.

   box_scale_factor :: REAL
   ! Scale factor for the bounding box.  Usually leave it at 1.

   box_axes :: MAT{REAL}(3,3)
   ! The axes of the bounding box, defined as the principal axes of the shape
   ! tensor (essentially the unit weighted moment of inertia tensor). Defined
   ! from an optionally inputted atom list.

   desired_separation :: REAL  DEFAULT(ZERO)
   ! The desired separation between grid points.

   end

   type DFT_FUNCTIONAL

   name :: STR  DEFAULT(" ")
   ! The name of the functional to use

   Xalpha :: REAL  DEFAULT(DFT_FUNCTIONAL_XALPHA)
   ! The valueof the alpha parameter in the Xalpha functional

   end

   type BECKE_GRID

   kind :: STR  DEFAULT(BECKE_GRID_KIND)
   ! The exact type of Becke grid to use

   atom_Z :: VEC{INT}*  DEFAULT_NULL
   ! List of atomic numbers for the atoms which are to be integrated

   atom_pos :: MAT{REAL}*  DEFAULT_NULL
   ! List of atomic positions for the atoms which are to be integrated

   atom_zeta :: VEC{REAL}*  DEFAULT_NULL
   ! List of scaling factors used in the transformation to the radial
   ! integration interval.

   n_radial_points ::  INT DEFAULT(0)
   ! No. of radial points desired for the Hydrogen atom. The number of points
   ! used for other atoms is normally 5 more for every extra shell, according
   ! to Becke's original rule of thumb.

   n_extra_points_per_shell :: INT DEFAULT(BECKE_GRID_EXTRA_POINTS_PER_SHELL)
   ! The number of extra points to use per n-shell over and above the default
   ! number .n_radial_points for the Hydrogen atom.

   accuracy :: STR  DEFAULT(BECKE_GRID_ACCURACY)
   ! A keyword describing the desired accuracy of the integration grid.

   l_angular_grid :: INT DEFAULT(0)
   ! Angular momentum which is to be integrated exactly by the angular grid.

   l_H_angular_grid :: INT DEFAULT(0)
   ! Angular momentum which is to be integrated exactly by the angular grid
   ! for the Hydrogen/Helium atoms only. For other atoms .l_angular_grid is used.

   reduce_core_angular_grid :: BIN  DEFAULT(BECKE_GRID_REDUCE_CORE_ANGULAR_GRID)
   ! If set TRUE the order of the angular grid near the core of the atom is
   ! reduced to make smaller meshes. So far the scheme of Treutler and Ahlrichs
   ! is used.

   reduce_H_angular_grid :: BIN  DEFAULT(BECKE_GRID_REDUCE_H_ANGULAR_GRID)
   ! If set TRUE the order of the angular grid for Hydrogen and Helium are
   ! reduced to .l_H_angular_grid.

   scale_atomic_grids :: BIN  DEFAULT(BECKE_GRID_SCALE_ATOMIC_GRIDS)
   ! If set TRUE, the atomic grids are scaled according to the authors
   ! recommended scaling factors. This does *not* mean that the partition
   ! function is also scaled to account for varying atomic sizes.

   partition_power :: INT  DEFAULT(BECKE_GRID_PARTITION_POWER)
   ! Used in smoothing the partition boundary

   partition_scheme :: STR  DEFAULT(BECKE_GRID_PARTITION_SCHEME)
   ! This describes the method to partition the electron density into atomic
   ! contributions which are then integrated separately. Currently there are
   ! "becke" and "delley". The former is based on smoothed-out Voronoi
   ! polyhedra. The latter are based on Hirshfeld-like partitioning using
   ! exponential functions.

   partition_scaling_scheme :: STR  DEFAULT(BECKE_GRID_PARTITION_SCALING_SCHEME)
   ! This chooses the precise method to scale the sizes of the "atoms" generated
   ! by the atomic partition function. For "becke" partitioning the default is
   ! by "truetler_ahlrichs", but you can choose "none" or "becke". For "delley"
   ! partitioning the only option is "none" i.e. no atomic rescaling.  Usually
   ! the scaling is based on the Bragg-Slater radii (except for H, where twice
   ! the radii is used). Treutler and Ahlrichs recommended using the square root
   ! of the ratio of Bragg Slater radii.

   finalized :: BIN  DEFAULT(FALSE)
   ! Set to true if the DFTGRID has been "set" using set_grid_data

   radial_grid :: VEC{QUADRATURE}*  DEFAULT_NULL
   ! The radial quadrature points, one for every row of the periodic table.

   lebedev_grid :: LEBEDEV*  DEFAULT_NULL
   ! The angular quadrature points. We use a Lebedev grid.

   lebedev_H_grid :: LEBEDEV*  DEFAULT_NULL
   ! The angular quadrature points for the Hydrogen atom.

   lebedev_L5_grid :: LEBEDEV*  DEFAULT_NULL
   ! Angular quadrature points for L=5, used close to the atom.

   lebedev_L11_grid :: LEBEDEV*  DEFAULT_NULL
   ! Angular quadrature points for L=11, used close to the atom.

   n_unscaled_points :: INT DEFAULT(0)
   ! No. of quadrature points in the reference atom.

   unscaled_point :: MAT{REAL}*, private  DEFAULT_NULL
   ! The unscaled spherical quadrature grid points centered at the origin, 
   ! for a reference atom.

   unscaled_weight :: VEC{REAL}*, private  DEFAULT_NULL
   ! The unscaled spherical quadrature grid weights for a reference atom.

   n_points_for_row :: VEC{INT}*, private  DEFAULT_NULL
   ! The number of points for a given row of the periodic table, for the
   ! current grid settings.

   n_points :: INT DEFAULT(0)
   ! No. of points in quadrature grid for the whole molecule.

   point :: MAT{REAL}*  DEFAULT_NULL
   ! The complete list of grid points appropriate for the specified atoms

   weight :: VEC{REAL}*  DEFAULT_NULL
   ! The complete list of grid weights appropriate for the specified atoms

   end

   type DFTGRID

   spherical_grid_kind :: STR  DEFAULT(DFTGRID_SPHERICAL_GRID_KIND)
   ! Identifier for the kind of spherical grid

   radial_grid_kind :: STR  DEFAULT(DFTGRID_RADIAL_GRID_KIND)
   ! Type of radial grid

   spherical_grid_order :: INT  DEFAULT(DFTGRID_SPHERICAL_GRID_ORDER)
   ! Order of the spherical grid

   radial_grid_order :: INT  DEFAULT(DFTGRID_RADIAL_GRID_ORDER)
   ! Order of the radial grid

   n_spherical_pts :: INT  DEFAULT(0)
   ! No of spherical grid points

   n_radial_pts :: INT  DEFAULT(0)
   ! No of radial grid points

   n_pts :: INT  DEFAULT(0)
   ! No of integration grid points

   becke_m_partition_power :: REAL  DEFAULT(DFTGRID_BECKE_M_PARTITION_POWER)
   ! Used in smoothing the partition boundary

   gauss_chebyshev_alpha :: REAL  DEFAULT(DFTGRID_GAUSS_CHEBYSHEV_ALPHA)
   ! Gauss-Chebychev radial grid parameters

   gauss_chebyshev_m :: REAL   DEFAULT(DFTGRID_GAUSS_CHEBYSHEV_M)
   ! ?

   euler_maclaurin_alpha :: REAL  DEFAULT(DFTGRID_EULER_MACLAURIN_ALPHA)
   ! Euler-Maclaurin radial grid parameters

   euler_maclaurin_m :: REAL   DEFAULT(DFTGRID_EULER_MACLAURIN_M)
   !

   archive :: ARCHIVE
   ! Archive to store the generated grids

   finalized :: BIN  DEFAULT(FALSE)
   ! Set to true if the DFTGRID has been "set" using set_grid_data

   reference_atom_points :: MAT{REAL}* DEFAULT_NULL
   ! The dft grid points at the origin for a single (unscaled) reference atom.

   reference_atom_weights :: VEC{REAL}* DEFAULT_NULL
   ! The dft grid weights at the origin for a single (unscaled) reference atom.

   end

   type IRREP

   label :: STR(4)
   ! Irrep label

   dimension :: INT
   ! Irrep dimension

   character :: VEC{REAL}* DEFAULT_NULL
   ! Characters for the irrep

   mat :: MAT3{REAL}* DEFAULT_NULL
   ! Representation matrices for the irrep

   end

   array type VEC{IRREP}

      ! A 1-D array of IRREP objects

   end

   type POINTGROUP

   symbol :: STR(4)
   ! symmetry symbol

   ID_symbol :: STR(4)
   ! group id symbol

   ID_number :: INT
   ! group id number

   axis_order :: INT
   ! principal axis order

   order :: INT
   ! order of the group

   n_irrep :: INT
   ! no of irreducible representations

   n_gen :: INT
   ! No. of generators

   has_complex_irreps :: BIN
   ! true if the group has complex irreps

   table :: MAT{INT}* DEFAULT_NULL
   ! group multiplication table

   mat :: MAT3{REAL}* DEFAULT_NULL
   ! 3x3 representation matrices

   ptr :: MAT3{REAL}* DEFAULT_NULL
   ! 3x3 representation matrices for p functions, same as mat

   dtr :: MAT3{REAL}* DEFAULT_NULL
   ! 6x6 representation matrices for d functions

   ftr :: MAT3{REAL}* DEFAULT_NULL
   ! 10x10 representation matrices for f functions

   gtr :: MAT3{REAL}* DEFAULT_NULL
   ! 15x15 representation matrices for g functions

   inverse :: VEC{INT}* DEFAULT_NULL
   ! Indices of inverse group elements

   irrep :: VEC{IRREP}* DEFAULT_NULL
   ! List of irrrducible representations

   end

   type UNITCELL

   angle :: VEC{REAL}(3)
   ! The cell angles  (in radians)

   length :: VEC{REAL}(3)
   ! The cell lengths (in bohr)

   volume :: REAL
   ! The cell volumes (bohr^3)

   direct_matrix :: MAT{REAL}(3,3)
   ! Direct lattice cell matrix (bohr). The columns are vectors of the three
   ! cell axes.

   inverse_matrix :: MAT{REAL}(3,3)
   ! Inverse direct lattice cell matrix (bohr^{-1})

   reciprocal_matrix :: MAT{REAL}(3,3)
   ! Reciprocal lattice cell matrix (bohr^{-1}).

   direct_U_matrix :: MAT{REAL}(3,3)
   ! Converts thermal tensors from crystal to cartesian systems.

   reciprocal_U_matrix :: MAT{REAL}(3,3)
   ! Converts thermal tensors from cartesian to crystal systems.

   info_made :: BIN
   ! Set TRUE if all the above information is consistent.

   end

   type SPACEGROUP

   IT_symbol :: STR
   ! International Table (Hermann-Maguin) symmetry symbol

   IT_group_number :: INT
   ! International tables group number

   Hall_symbol :: STR
   ! Hall notation symbol

   HM_symbol :: STR
   ! Hermann-Mauguin notation symbol

   Schoenflies_symbol :: STR
   ! Hermann-Mauguin notation symbol

   lattice_symbol :: STR(1)
   ! Lattice symmetry symbol

   lattice_symbol_index :: INT
   ! Lattice symbol index number

   lattice_type :: STR
   ! Lattice type

   centrosymmetric :: BIN
   ! True if center of symmetry present

   axis_order :: VEC{INT}(3)
   ! Order of each crystal axis

   axis_symbol :: VEC{STR}(len=1,3)
   ! Superscript rotation axis symbol

   axis_symbol_index :: VEC{INT}(3)
   ! Indicates the numberical index corresponding to the axis symbol x, y, z ...

   has_axis_bar :: VEC{BIN}(3)
   ! True if bar for this axis

   has_translation :: VEC{BIN}(3)
   ! True if translation subscript present for this axis

   translation_symbol :: MAT{STR}(len=1,3,3)
   ! Subscript translation symbols for each axis

   origin_shift :: VEC{INT}(3)
   ! Subscript translation symbols for each axis

   nL :: INT
   ! No. of translational lattice generators

   nR :: INT
   ! No. of rotation generators

   nG :: INT
   ! No. of generators

   n_seitz :: INT
   ! No. of Seitz matrices

   seitz :: MAT3{REAL}* DEFAULT_NULL
   ! The spacegroup Seitz matrices.

   n_unique :: INT
   ! No. of equivalent positions unrelated by traslation or inversion

   unique_symop :: VEC{INT}* DEFAULT_NULL
   ! Index of unique symops not related by translation or inversion

   map_to_unique :: VEC{INT}* DEFAULT_NULL
   ! Maps symop to a unique symop. Negative indicates inversion

   analysed :: BIN  DEFAULT(FALSE)
   ! Set TRUE if the spacegroup symbol has been succesfully analysed

   end

   type DIFFRACTION_DATA

   data_kind :: STR
   ! Tells whether this is X-ray, neutron, or whatever data

   reflections :: VEC{REFLECTION}* DEFAULT_NULL
   ! The structure factor information. NOTE: this can stand for either X-ray or
   ! PND reflections depending on the case.

   scale_factor :: REAL
   ! Scale factor to apply to the predicted structure factors

   scale_factors :: VEC{REAL}* DEFAULT_NULL
   ! A set of scale factors to apply to structure factors from different groups.

   exp_scale_factor :: REAL
   ! Fixed scale factor to apply to the experimental structure factors

   optimise_scale :: BIN
   ! True if an overall scaler factor is to be optimised, for use in calculating
   ! F_pred

   synthesize_sigma_I :: BIN
   ! True if artificial sigma(I) errors are to be generated from poisson
   ! statistics and used in calculating agreement statistics

   optimise_extinction :: BIN
   ! True if extinction is to be optimised.

   correct_dispersion :: BIN
   ! True if dispersion is to be corrected

   extinction_factor :: REAL
   ! Secondary extinction factor

   wavelength :: REAL
   ! Experiment wavelength

   thermal_smearing_model :: STR
   ! Thermal smearing model for ft integrals

   partition_model :: STR
   ! Model for partitioning fragments of the molecule

   n_param :: INT
   ! No of fitting parameters used

   F_exp_min :: REAL  DEFAULT(DIFFRACTION_DATA_F_EXP_MIN)
   ! Minimum acceptable value for F_exp

   F_sigma_min :: REAL  DEFAULT(DIFFRACTION_DATA_F_SIGMA_MIN)
   ! Minimum acceptable value for F_sigma

   F_sigma_max :: REAL  DEFAULT(DIFFRACTION_DATA_F_SIGMA_MAX)
   ! Maximum acceptable value for F_sigma

   end

   type CRYSTAL

   data_kind :: STR
   ! Kind of diffraction experiment used.

   CIF_chemical_formula :: STR  DEFAULT("?")
   ! The chemical formula, as found in a CIF file.

   spacegroup :: SPACEGROUP
   ! The crystal spacegroup

   unitcell :: UNITCELL
   ! The crystal unit cell

   n_fragment_atoms :: INT
   ! No. of atoms in the inputted cell fragment, used to calculate structure
   ! factors, or do wavefunction fitting.

   fragment_geometry :: MAT{REAL}* DEFAULT_NULL
   ! The geometry for a molecular fragment in the crystal (in the crystal
   ! coordiante system) used to calculate structure factors or do wavefunction
   ! fitting. IMPORTANT NOTE --- this is not to be confused with the
   ! "asymmetric_unit_geometry"; it may include symmetry non-unique atoms.

   n_fragment_cell_atoms :: INT
   ! No. of atoms in the whole unit cell which are generated from
   ! "fragment_geometry" by spacegroup symmetry operations. This will be the
   ! whole unit cell if the "fragment_geometry" includes all asymmetric unit
   ! cell.

   fragment_cell_geometry :: MAT{REAL}* DEFAULT_NULL
   ! The geometry of all atoms in the unit cell generated from
   ! "fragment_geometry" by the spacegroup symmetry operations. It will usually
   ! be the full "unit_cell_geometry", but may not be.

   symop_for_frag_cell_atom :: VEC{INT}* DEFAULT_NULL
   ! "symop_for_frag_cell_atom(a)" is the index of the spacegroup seitz symmetry
   ! operation that generates atom position "fragment_cell_geometry(:,a)" from
   ! the atom with index "frag_atom_for_frag_cell_atom(a)" whose position is
   ! given in "fragment_geometry".

   shift_for_frag_cell_atom :: MAT{INT}* DEFAULT_NULL
   ! "shift_for_frag_cell_atom(a)" is the actual translational shift used to
   ! generate atom position "fragment_cell_geometry(:,a)" from the atom with
   ! index "frag_atom_for_frag_cell_atom(a)" whose position is given in
   ! in "fragment_geometry", in conjuction with "symop_for_frag_cell_atom(a)".

   frag_atom_for_frag_cell_atom :: VEC{INT}* DEFAULT_NULL
   ! "frag_atom_for_frag_cell_atom(a)" is the index of the fragment atom in
   ! "fragment_geometry" which generates atom position
   ! "fragment_cell_geometry(:,a)", using the seitz symmetry operator whose
   ! index is given by "symop_for_frag_cell_atom(a)" and the translational shift
   ! given explicitly by "shift_for_frag_cell_atom(:,a)"..

   n_unique_frag_atoms :: INT
   ! No. of unique fragment atoms.

   unique_frag_atom :: VEC{INT}* DEFAULT_NULL
   ! The list of symmetry-unique fragment atoms. This list may be a subset of
   ! the asymmetric unit -- but it usually will be the asymmetric unit.

   unique_symop_for_frag_atom :: VEC{INT}* DEFAULT_NULL
   ! "unique_symop_for_frag_atom(a)" is the index of the spacegroup symmetry
   ! operation which maps the atom "unique_atom_for_frag_atom(a)" onto the
   ! "a"-th atom position, fragment_geometry(:,a).

   unique_shift_for_frag_atom :: MAT{INT}* DEFAULT_NULL
   ! "unique_shift_for_frag_atom(a)" is the actual translational shift used to
   ! generate the atom position "fragment_geometry(:,a)" from the atom with
   ! index "unique_atom_for_frag_atom(a)" in conjunction with the seitz symop
   ! with index "unique_symop_for_frag_atom(a)".

   unique_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
   ! "unique_atom_for_frag_atom(a)" is the index of the symmetry-unique atom
   ! position in "fragment_geometry" which generates the position
   ! "fragment_geometry(:,a)".

!   n_reduced_symops :: INT
!   ! No. of symops needed to make the unit_cell_geometry from fragment_geometry
!   ! OBSOLETE

!   reduced_symop :: VEC{INT}* DEFAULT_NULL
!   ! Indices of the reduced symops in the spacegroup seitz list, i.e. those
!   ! symops which make distinctly different fragment_geometries when transformed
!   ! back to the unit cell. The unit symop is part of the reduced_symop list.
!   ! OBSOLETE

!   n_cluster_symops :: INT
!   ! No. of cluster symops which generate distinctly different fragment
!   ! geometries.  OBSOLETE

!   cluster_symop :: VEC{INT}* DEFAULT_NULL
!   ! Indices of the cluster symops in the spacegroup seitz list. These are the
!   ! same as the reduced_symop's, except that the fragment_geometry and its
!   ! symmetry transform are not mapped back to the unit cell
!   ! OBSOLETE

   n_inverted_symops :: INT
   ! Number of symmetry operations related by inversion

   inverted_symop :: VEC{INT}* DEFAULT_NULL
   ! Indices of the unique symops related by inversion

   translated_symop :: VEC{INT}* DEFAULT_NULL
   ! Indices of the unique symops related by translation

   n_unique_SF_symops :: INT
   ! Number of unique symmetry operations not related by inversion or
   ! translation. This is used to save work in structure factor (SF)
   ! calculations.

   unique_SF_symop :: VEC{INT}* DEFAULT_NULL
   ! Indices of the unique symops not related by inversion or translation.
   ! This is used to save work in structure factor (SF) calculations.

   use_manual_repetition_factors :: BIN  DEFAULT(FALSE)
   ! If this is set TRUE, then the user should manually enter the desired
   ! repetition factors. For experts only!

   repetition_factor :: VEC{REAL}* DEFAULT_NULL
   ! The partition factors for fragment_geometry Useful to get structure
   ! factor contributions from a small portion of the fragment.

   Z :: REAL
   ! The crystallographic Z factor for the molecular cell fragment in the
   ! unitcell

   fragment_info_made :: BIN
   ! Set TRUE if the fragment related information has been made

   n_asymmetric_unit_atoms :: INT
   ! No. of atoms in the asymmetric unit of the unit cell.

   asymmetric_unit_geometry :: MAT{REAL}* DEFAULT_NULL
   ! The asymmetric unit geometry. Usually inputted from a CIF file. This
   ! may or may not be the same as fragment_geometry. It is NOT used for
   ! structure factor calculations, but for cluster generation.

   prune_asymmetric_unit :: BIN  DEFAULT(FALSE)
   ! Set TRUE if you want to prune the asymmetric unit. Sometimes the asymmetric
   ! unit may not be asymmetric i.e. it may have symmetry-equivalent atoms
   ! repeated. This could be because of an input or CIF file error, or it could
   ! be genuinely correct because the repeated atom corresponds to a disordered
   ! position. For Hirshfeld surface plots, which can cope with disorder, you
   ! probably do not want to remove or prune the asymmetric atom list, but for
   ! crystal calculations you must do so.

   n_unit_cell_atoms :: INT
   ! Total no. of unit cell atoms.

   unit_cell_geometry :: MAT{REAL}* DEFAULT_NULL
   ! The full unit cell geometry, in the crystal coordiante system, generated
   ! from the asymmetric_unit_geometry.

   symop_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
   ! "symop_for_unit_cell_atom(a)" is the index of the spacegroup symmetry
   ! operation that generates atom position "unit_cell_geometry(:,a)" from a
   ! unique atom position in "asymmetric_unit_geometry".

   shift_for_unit_cell_atom :: MAT{INT}* DEFAULT_NULL
   ! "shift_for_unit_cell_atom(a)" is the actual translational shift used to
   ! generate atom position "unit_cell_geometry(:,a)" from a unique atom
   ! position in "asymmetric_unit_geometry" in conjunction with the symmetry
   ! operator with index "symop_for_unit_cell_atom(a)".

   asym_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
   ! "asym_atom_for_unit_cell_atom(a)" is the index of the unique unit cell atom
   ! in "asymmetric_unit_geometry" which generates atom position
   ! "unit_cell_geometry(:,a)".

   frag_cell_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
   ! "frag_cell_for_unit_cell_atom(u)" is the index of the fragment cell atom in
   ! "fragment_cell_geometry" which is the same as "unit_cell_geometry(:,u)".
   ! This index may be zero---meaning there is no fragment atom for a particular
   ! unit cell atom.

   frag_atom_for_unit_cell_atom :: VEC{INT}* DEFAULT_NULL
   ! "frag_atom_for_unit_cell_atom(u)" is the index of the fragment atom in
   ! "fragment_geometry" which is equivalent to "unit_cell_geometry(:,u)". 
   ! This index may be zero---meaning there is no fragment atom for a particular
   ! unit cell atom.

   frag_atom_for_asym_unit_atom :: VEC{INT}* DEFAULT_NULL
   ! "frag_atom_for_asym_unit_atom(a)" is the index of the fragment atom in
   ! "fragment_geometry" which is generated from the asymmetric unit atom
   ! position "asymmeric_unit_geometry(:,a)". NOTE -- it may be that there is no
   ! fragment atom generated by a particular asymmetric unit atom; then the
   ! index is zero. This array is used to extract the atom list of the
   ! asymmetric unit from a given fragment for cluster generation.

   asym_unit_atom_for_frag_atom :: VEC{INT}* DEFAULT_NULL
   ! "asym_unit_atom_for_frag_atom(a)" is the index of the asymmetric atom in
   ! "asymmetric_unit_geometry" which is the parent of "fragment_geometry(:,a)". 
   ! This is the inverse of the array above. NOTE -- it may be that there is no
   ! asymmetric atom which generates by a particular fragment atom; then the
   ! index is zero. 

   data :: DIFFRACTION_DATA* DEFAULT_NULL
   ! The structure factor and fitting data. NOTE: this can stand for either X-ray or
   ! PND data depending on the case.

   xray_data :: DIFFRACTION_DATA* DEFAULT_NULL
   ! The X-ray structure factor and fitting data

   pnd_data :: DIFFRACTION_DATA* DEFAULT_NULL
   ! The PND scalar structure factor and fitting data

   end

   type CLUSTER

   radius :: REAL  DEFAULT(CLUSTER_RADIUS)
   ! The radius of the cluster. This number determines the maximum acceptable
   ! distance between an atom in fragment_geometry and any atom in the crystal
   ! lattice. It defines the size of the cluster in the case that
   ! "generation_method" component (see below) takes the value "within_radius".

   atom_density_cutoff :: REAL  DEFAULT(CLUSTER_ATOM_DENSITY_CUTOFF)
   ! This number is used to define a cluster radius (see above). The radius is
   ! defined from it, as the *largest* distance from any atom in the
   ! asymmetric_cell_atom list where the atomic electron density becomes smaller
   ! than this number. It requires that slater or coppens bases are defined for
   ! the asymmetric_cell_atom's, and it requires that the generation method be
   ! set to "for_hirshfeld_surface". It is primarily used for clusters generated
   ! from a fragment which will correctly produce the Hirshfeld surface.

   generation_method :: STR  DEFAULT(CLUSTER_GENERATION_METHOD)
   ! This option tell how to make the cluster: whether to add atoms within a
   ! certain distance (radius) of the starting fragment, whether to make a
   ! cluster specifically for generating a hirshfeld surface, whether to just
   ! make the unit cell, or the unit cell and the starting fragment.

   start_with_fragment :: BIN  DEFAULT(FALSE)
   ! Start building the cluster from the initial fragment geometry as the first
   ! few atoms. This makes for easy comparison of geometry in the final
   ! generated cluster.

   defragment :: BIN  DEFAULT(CLUSTER_DEFRAGMENT)
   ! If TRUE, the cluster ends are defragmented, i.e. any atoms which are
   ! "bonded" at the ends of the cluster are included into the cluster. This
   ! oisn't a good idea for network covalent solids or zeolites: the
   ! defragmentation will end when all bonded entites with the 3x3 cube of
   ! units cells near the origin have been constructed.

   n_atoms :: INT
   ! The number of atoms in the cluster

   geometry :: MAT{REAL}* DEFAULT_NULL
   ! The (3 x .n_atoms) sized array of cluster atom positions, in crystal
   ! coordiantes

   crystal :: CRYSTAL* DEFAULT_NULL
   ! The crystal information used to generate the cluster. The most important
   ! part used is the asymmetric unit cell geometry.

   asymmetric_cell_atom :: VEC{ATOM}* DEFAULT_NULL
   ! The atom list data associated with the *asymmetric* unit cell_geometry (see
   ! below) used to generate the cluster atom positions. It must be consistent
   ! with the crystal asymmetric unit.

   atom :: VEC{ATOM}* DEFAULT_NULL
   ! The atom list for the generated cluster. This is not usually made unless
   ! requested.

   n_fragment_atoms :: INT
   ! The number of fragment atoms used to build the cluster

   fragment_geometry :: MAT{REAL}* DEFAULT_NULL
   ! The (3 x .n_fragment_atoms) sized array of fragment atom positions used to
   ! generate the cluster: the cluster will usually be arranged as the set of
   ! atoms within a certain radius of this fragment geometry. It is in the
   ! crystal coordinate system. Note that the fragment geometry might not
   ! include an asymmetric cell unit.

   fragment_width :: VEC{REAL}(3)
   ! The width of the crystal fragment, to the nearest unit cell

   fragment_offset :: VEC{INT}(3)
   ! The center point of the fragment_geometry, to the nearest unit cell

!  n_symop :: INT
!  ! The number of symmetry operators used to generate the cluster from the
!  ! asymmetric unit.

!  symop :: MAT{INT}* DEFAULT_NULL
!  ! The (4 x .n_symop) sized list of symmetry operators used to generate the
!  ! cluster from the asymmetric unit atoms. symop(1,q) is the index of the
!  ! Seitz operator, while symop(2:4,q) is the translation vector applied (in
!  ! the crystal axis coordinate system).

   n_shift :: INT  DEFAULT(0)
   ! The number of distinct translational shifts used to generate the atoms in
   ! the cluster.

   shift :: MAT{INT}* DEFAULT_NULL
   ! The (3 x .n_shift) sized list of translational shifts used to generate the
   ! cluster from the crystal unit cell atoms. See ".shift_for_atom".

   shift_for_atom :: VEC{INT}* DEFAULT_NULL
   ! ".shift_for_atom(a)" is the index of the translational shift in array
   ! ".shift", that shift being added to the position of the crystal unit cell
   ! atom whose index is given by ".unit_cell_atom_for_atom(a)" in order to
   ! generate the cluster atom "a" whose position is given by ".geometry(a)".

   unit_cell_atom_for_atom :: VEC{INT}* DEFAULT_NULL
   ! "unit_cell_atom_for_atom(a)" is the index of the unit cell atom which is
   ! related to the cluster atom whose position is ".geometry(:,a)" by a bravais
   ! translation given in the "shift" array by the column with index
   ! ".shift_for_atom(a)".

   do_fragment_symop :: BIN  DEFAULT(FALSE)
   ! If set TRUE, the "fragment_symop", "fragment_symop_for_atom" and the
   ! "fragment_parent_for_atom" arrays are defined. See below.

   n_fragment_symop :: INT
   ! The number of symmetry operators used to generate the cluster from the
   ! *fragment geometry*. NOTE: this is defined only when the fragment cell
   ! geometry and the unit cell geometry are the same i.e. when the fragment
   ! geometry includes an asymmetric cell unit.

   fragment_symop :: MAT{INT}* DEFAULT_NULL
   ! The (4 x .n_fragment_symop) sized list of symmetry operators used to
   ! generate the cluster from the *fragment geometry*. fragment_symop(1,q) is
   ! the index of the Seitz operator, while fragment_symop(2:4,q) is the
   ! translation vector applied (in the crystal axis coordinate system). NOTE:
   ! This is defined only when the fragment cell geometry and the unit cell
   ! geometry are the same i.e. when the fragment geometry includes an
   ! asymmetric cell unit.

!  symop_for_atom :: VEC{INT}* DEFAULT_NULL
!  ! symop_for_atom(a) is the *index* "s" of the symmetry operation in .symop,
!  ! .symop(:,s), used to generate the cluster atom "a", whose positon is given
!  ! by .geometry(:,a), from an atom in the crystal asymmetric unit, whose index
!  ! is given by "parent_for_atom(a)".
!  ! NOTE: this is currently obsolete

!  parent_for_atom :: VEC{INT}* DEFAULT_NULL
!  ! parent_for_atom(a) is the index of the unique asymmetric unit cell atom
!  ! which *generates* the cluster atom "a" using one of the symmetry operations
!  ! in .symop (specifically the symop with index .symop_for_atom(a)).
!  ! NOTE: this is currently obsolete

   fragment_symop_for_atom :: VEC{INT}* DEFAULT_NULL
   ! fragment_symop_for_atom(a) is the *index* "s" of the symmetry operation in
   ! .fragment_symop, .fragment_symop(:,s), used to generate the cluster atom
   ! "a", whose positon is given by .geometry(:,a), from an atom in
   ! fragment_geometry, whose index is given by "fragment_parent_for_atom(a)".
   ! This is defined only when the fragment cell geometry and the unit cell
   ! geometry are the same i.e. when the fragment geometry includes an
   ! asymmetric cell unit.

!  fragment_parent_for_atom :: VEC{INT}* DEFAULT_NULL
!  ! fragment_parent_for_atom(a) is the index of the fragment geometry atom
!  ! which *generates* the cluster atom "a" using one of the symmetry operations
!  ! in .fragment_symop (specifically the symop with index
!  ! .fragment_symop_for_atom(a)).  This is defined only when the fragment cell
!  ! geometry and the unit cell geometry are the same i.e. when the fragment
!  ! geometry includes an asymmetric cell unit.
!  ! NOTE: this is currently obsolete

   fragment_parents_for_atom :: MAT{INT}* DEFAULT_NULL
   ! fragment_parents_for_atom(a,s) is the index of the (not necesarily symmetry
   ! unique) atom in .geometry which *generates* the cluster atom "a" using the
   ! fragment symmetry operation with index "s", ie .fragment_symop_for_atom(s).

   fragment_child_for_atom :: MAT{INT}* DEFAULT_NULL
   ! fragment_child_for_atom(a,s) is the index of the (not necesarily symmetry
   ! unique) atom in .geometry which is *generated by* the cluster atom "a" using the
   ! fragment symmetry operation with index "s", ie .fragment_symop_for_atom(s).
   ! It is the inverse of the array above.

!  atom_for_cell_atom :: MAT{INT}* DEFAULT_NULL
!  ! atom_for_cell_atom(a,s) is the index of the cluster atom in .geometry which
!  ! is *generated by* asymmetric cell atom "a", whose position is in
!  ! .crystal.asymmetric_cell_geometry(:,a), by the symop with index "s",
!  ! .symop(:,s). This is the inverse information array of parent_for_atom(a).
!  ! NOTE: this is currently obsolete.

!  minimum_distance_to_atom :: VEC{REAL}* DEFAULT_NULL
!  ! minimum_distance_to_atom(a) is the minimum distance from the cluster
!  ! atom "a", whose position is given in .geometry(:,a), to the crystal
!  ! fragment, whose geometry is given in .fragment_geometry
!  ! NOTE: this is currently obsolete.

!  closest_fragment_atom_to_atom :: VEC{INT}* DEFAULT_NULL
!  ! closest_fragment_atom_to_atom(a) is the index of the atom in
!  ! .fragment_geometry which is closest to the cluster atom "a", whose positon
!  ! is .geometry(:,a).
!  ! NOTE: this is currently obsolete.

   is_fragment_atom :: VEC{BIN}* DEFAULT_NULL
   ! is_fragment_atom(a) is TRUE if .geometry(:,a) is the position of a fragment
   ! atom, i.e. if "a" is the index of a fragm,ent atom.

!  symop_is_redundant :: VEC{BIN}* DEFAULT_NULL
!  ! symop_is_redundant(q) is TRUE if .symop(:,q) does not generate any new
!  ! cluster atom (cluster atom positions are stored in .geometry). Instead,
!  ! symops earlier in the .symop list are able to generate the atoms that symop
!  ! "q" can generate. NOTE: this is currently obsolete.

!  partition_factor :: VEC{REAL}* DEFAULT_NULL
!  ! A list of partition factors which can be applied to a density matrix in
!  ! order to partition it. This array can be generated automatically, or it can
!  ! be explicitly inputted.
!  ! NOTE: this is currently obsolete

   info_made :: BIN  DEFAULT(FALSE)
   ! Set to true if the routine make_info has been called

   end

   type SCFDATA

   ! ****** SCF kind *********

   scf_kind :: STR  DEFAULT(" ")
   ! The kind of SCF calculation to perform

   ! ****** DFT functional options *********

   dft_exchange_functional :: STR  DEFAULT(SCFDATA_DFT_EXCHANGE_FUNCTIONAL)
   ! The DFT exchange functional to be used

   dft_correlation_functional :: STR  DEFAULT(SCFDATA_DFT_CORRELATION_FUNCTIONAL)
   ! The DFT correlation functional to be used

   using_GGA_exchange :: BIN  DEFAULT(SCFDATA_USING_GGA_EXCHANGE)
   ! TRUE if the exchange functional uses the generalised gradient
   ! approximation, otherwise false.

   using_GGA_correlation :: BIN  DEFAULT(SCFDATA_USING_GGA_CORRELATION)
   ! TRUE if the correlation functional uses the generalised gradient
   ! approximation, otherwise false.

   ! ****** Iteration counters *********

   iteration :: INT  DEFAULT(0)
   ! The interation count for the SCF procedure

   total_iterations :: INT  DEFAULT(0)
   ! The total interation count for the SCF procedure, which does not get reset
   ! after each lambda increment, in the case of a constrained SCF procedure.

   lambda_iteration :: INT  DEFAULT(0)
   ! Lambda iteration count for the constrained SCF procedure

   min_iterations :: INT  DEFAULT(SCFDATA_MIN_ITERATIONS)
   ! The minimum number of SCF iterations to perform

   max_iterations :: INT  DEFAULT(SCFDATA_MAX_ITERATIONS)
   ! The maximum number of SCF iterations to perform

   ! ****** Stored energies *********

   nuclear_energy :: REAL  DEFAULT(ZERO)
   ! Nuclear repulsion energy for the associated molecule

   kinetic_energy :: REAL  DEFAULT(ZERO)
   ! The kinetic energy for the associated molecule

   dft_energy_correction :: REAL  DEFAULT(ZERO)
   ! The DFT energy correction to the SCF energy for the associated molecule

   energy :: REAL  DEFAULT(ZERO)
   ! The SCF energy for the associated molecule

   old_energy :: REAL  DEFAULT(ZERO)
   ! The SCF energy from the previous SCF cycle

   energy_difference :: REAL  DEFAULT(ZERO)
   ! The change in the SCF energy between cycles

   ! ****** Constrained SCF data *********

   lambda :: REAL  DEFAULT(ZERO)
   ! The initial lambda value to use in a constrained SCF procedure

   lambda_max :: REAL  DEFAULT(ZERO)
   ! The maximum lambda value to use in a constrained SCF procedure

   lambda_step :: REAL  DEFAULT(ONE)
   ! The value to step the lambda value between lambda cycles in a 
   ! constrained SCF calc.

   fit_value :: REAL  DEFAULT(ZERO)
   ! The value of E + lambda * penalty in a constrained SCF calc.
   ! Penalty can be the Chi2, or a combination of Chi2's if more than one
   ! type of diffraction data is to be fitted.

   old_fit_value :: REAL  DEFAULT(ZERO)
   ! The value of E + lambda * penalty of the previous iteration in a
   ! constrained  SCF calc.

   penalty :: REAL  DEFAULT(ZERO)
   ! Penalty statistic for a constrained SCF calc

   old_penalty :: REAL  DEFAULT(ZERO)
   ! Penalty statistic for a constrained SCF calc of the previous iteration
   
   crystal :: CRYSTAL*  DEFAULT_NULL
   ! The crystal information for the diffraction experiment

   ! ****** Crystal SCF data *********

   kappa :: REAL DEFAULT(ZERO)
   ! The kappa value used to multiply the orthogonality projector, uses in an
   ! embedded SCF procedure

   unitcell_axis_divisions :: VEC{INT}(3)
   ! Number of integer divisions of the unit cell in each lattice direction.

   crystallite_side_length :: REAL
   ! The desired side length for the crystallite. This determines the number of
   ! levels that will be used.

   fmm_accuracy :: REAL
   ! The accuracy required for the multipole expansion of the inverse particle
   ! separation.

   ! ****** Initial guess options *********

   initial_density :: STR  DEFAULT("core")
   ! The kind of density matrix to start the SCF calc

   initial_mos :: STR  DEFAULT(" ")
   ! The kind of initial MO's to start the SCF calc

   ! ****** SCF convergence/accuracy related options *********

   convergence :: REAL  DEFAULT(SCFDATA_CONVERGENCE)
   ! A number which measures the convergnece of the SCF

   rough_convergence :: REAL  DEFAULT(SCFDATA_ROUGH_CONVERGENCE)
   ! How much to converge to before increasing integral accuracy

   rough_diis_convergence :: REAL  DEFAULT(SCFDATA_ROUGH_DIIS_CONVERGENCE)
   ! How much to converge the DIIS error to before increasing integral accuracy

   damp_finish :: INT  DEFAULT(DIIS_START_ITERATION)
   ! Iteration when density matrix damping is turned off

   damp_factor :: REAL  DEFAULT(SCFDATA_DAMP_FACTOR)
   ! The damping factor to use

   dynamic_damp_factor :: REAL  DEFAULT(ZERO)
   ! Damp factor used by the Dynamic Damper

   level_shift_finish :: INT  DEFAULT(DIIS_START_ITERATION)
   ! Iteration when level shifting is turned off

   level_shift :: REAL  DEFAULT(SCFDATA_LEVEL_SHIFT)
   ! Value to level shift the virtual orbitals

   MO_gradient_stepsize :: REAL  DEFAULT(0.01d0)
   ! The stepisize to use for updating the orbitals

   max_update_stepsize :: REAL  DEFAULT(0.01d0)
   ! The maximum update stepsize to use for updating any SCF object, e.g. the orbitals

   eri_limit :: REAL  DEFAULT(SCFDATA_ERI_LIMIT)
   ! Cutoff for the two electron integrals

   old_eri_cutoff :: REAL  DEFAULT(SCFDATA_ERI_LIMIT)
   ! Previous iteration's cutoff for the two electron integrals, used for
   ! detecting if an incremental fock build is required.

   atom_overlap_cutoff :: REAL  DEFAULT(SCFDATA_ATOM_OVERLAP_CUTOFF)
   ! The value of the maximum overlap between basis functions on two different
   ! atoms, below which the atoms are considered *not* overlapping.

   XC_atom_separation_cutoff :: REAL  DEFAULT(SCFDATA_XC_ATOM_SEPARATION_CUTOFF)
   ! The exchange correlation matrix in DFT calculations is *not* calculated
   ! for basis functions on atoms separated by *more* than this distance.
   ! This allows linear scaling of the exchange correlation terms (except for a
   ! negligible N^2 contribution due to the atom-distance test).

   ! ****** DIIS convergence related options *********

   diis :: DIIS
   ! For diis extrapolation (usually Fock matrix DIIS extrapolation)

   diis_error :: REAL  DEFAULT(ZERO)
   ! The DIIS error

   old_diis_error :: REAL  DEFAULT(ZERO)
   ! The DIIS error of the previous iteration

   diis_start_iteration :: INT  DEFAULT(DIIS_START_ITERATION)
   ! This is a copy of .diis.start_iteration, which needs to be saved when
   ! lambda is reset in constrained SCF calculations.

   diis_save_iteration :: INT  DEFAULT(DIIS_SAVE_ITERATION)
   ! This is a copy of .diis.save_iteration, which needs to be saved when
   ! lambda is reset in constrained SCF calculations.

   using_previous_diis_info :: BIN   DEFAULT(TRUE)
   ! If set TRUE, then in a constrained SCF calculation, the previous DIIS
   ! vectors are re-used to estimate a new set of DIIS vectors.

   ! ****** General Complex HF options *********

   sl_1e_factor :: REAL  DEFAULT(ONE)
   ! Factor to apply to the 1-electron S.L terms

   sl_2e_factor :: REAL  DEFAULT(ONE)
   ! Factor to apply to the 2-electron S.L terms

   quantization_axis :: VEC{REAL}(3)  DEFAULT([ZERO,ZERO,ONE])
   ! Quantization axis for GCHF, if using initial MO's as a guess

   ! ****** Logical switches in alphabetical order *********

   group :: BIN  DEFAULT(FALSE)
   ! Set TRUE if doing a noninteracting group SCF calculation

   output :: BIN  DEFAULT(TRUE)
   ! True if output is wanted; sometimes we supress output e.g. when we do
   ! atomic SCF calculations to get a good initial guess.

   test :: BIN  DEFAULT(FALSE)
   ! Test flag. Set True if some test procedure is to be executed

   using_1e_sl_term :: BIN  DEFAULT(TRUE)
   ! Switch on/off the 1 electron S.L term

   using_1e_srxa_term :: BIN  DEFAULT(TRUE)
   ! Switch on/off the 1 electron diamagnetic term

   using_1e_zora_term :: BIN  DEFAULT(FALSE)
   ! Switch on/off the 1 electron ZORA terms

   using_2e_sl_term :: BIN  DEFAULT(TRUE)
   ! Switch on/off the 2 electron S.L terms

   using_aa_term :: BIN  DEFAULT(TRUE)
   ! Switch on/off the A.A diamagnetic term

   using_bl_term :: BIN  DEFAULT(TRUE)
   ! Switch on/off the B.L term (complex SCF reqd.)

   using_bs_term :: BIN  DEFAULT(TRUE)
   ! Switch on/off the B.S term

   using_bs_t_term :: BIN  DEFAULT(TRUE)
   ! Switch on/off the (B.S) T_e term

   using_damping :: BIN  DEFAULT(SCFDATA_USING_DAMPING)
   ! True if using damping

   using_delta_build :: BIN  DEFAULT(FALSE)
   ! True if using an incremental (delta) fock build as advocated by Almlof.

   using_direct_scf :: BIN  DEFAULT(FALSE)
   ! True if using direct SCF

   using_dynamic_damping :: BIN  DEFAULT(FALSE)
   ! True if using the Dynamic Damper

   using_fock_diis :: BIN  DEFAULT(TRUE)
   ! True if using DIIS extrapolation for fock matrices

   using_level_shift :: BIN  DEFAULT(SCFDATA_USING_LEVEL_SHIFT)
   ! True if using level shifting

   using_MO_diis :: BIN  DEFAULT(FALSE)
   ! True if using DIIS extrapolation for molecular orbitals

   using_MO_gradient_update :: BIN  DEFAULT(FALSE)
   ! Set TRUE if using the gradient of the orbital coefficients to
   ! update the coefficients

   using_NDDO :: BIN  DEFAULT(FALSE)
   ! Neglect of diatomic differential overlap

   using_NUDO :: BIN  DEFAULT(FALSE)
   ! Neglect of unconnected differential overlap

   using_PIE :: BIN  DEFAULT(FALSE)
   ! Projective integral expansion method (PIE) developed by Mayer.
   ! See Mayer, CPL 332, 381 (2000).

   using_rough_convergence :: BIN  DEFAULT(SCFDATA_USING_ROUGH_CONVERGENCE)
   ! Whether to apply lower integral accuracy

   end

   type COLOUR

   name :: STR
   ! The standard colour name for this colour.

   RGB255 :: VEC{INT}(3)
   ! The RGB triple for this colour as a triple of integers between 0 and 255.

   end

   type COLOURFUNCTION

   n_data :: INT
   ! The number of data values (and their associated colours) used to make
   ! the colour function

   data :: VEC{REAL}* DEFAULT_NULL
   ! The list of data values, from smallest to largest

   RGB :: MAT{REAL}* DEFAULT_NULL
   ! The RGB values corresponding to each data value. Their norm should be
   ! between zero and 3.

   finalised :: BIN
   ! Set TRUE if the object is ready for use

   end

   type MARCHINGCUBE

   vertex_pos :: MAT{REAL}(3,0:7)
   ! A (3 x 0:7) dimensioned list of the actual coordinates of each cube vertex.
   ! The second index is the standard marching cubes vertex number.

   value_at_vertex :: VEC{REAL}(0:7)
   ! A (0:7) dimensioned list of the values of the function at each cube vertex.

   vertex_gradient :: MAT{REAL}(3,0:7)
   ! A (3 x 0:7) dimensioned list of the vertex gradients at each cube vertex.
   ! The second index is the standard marching cubes vertex number.

   vertex_hessian :: MAT3{REAL}(3,3,0:7)
   ! A (3 x 3 x 0:7) dimensioned list of the hessian at each cube vertex.
   ! The third index is the standard marching cubes vertex number.

!  vertex_hessian_eigenvalues :: MAT{REAL}(3,0:7)
!  ! A (3 x 3 x 0:7) dimensioned list of the hessian eigenvalues at each cube vertex.
!  ! The third index is the standard marching cubes vertex number.

!  vertex_hessian_eigenvectors :: MAT3{REAL}(3,3,0:7)
!  ! A (3 x 3 x 0:7) dimensioned list of the hessian eigenvectors at each cube vertex.
!  ! The third index is the standard marching cubes vertex number.

   side_length :: REAL
   ! The length of each side of the cube

   iso_value :: REAL
   ! The isovalue to be used for the isosurface

   accuracy :: REAL
   ! The function accuracy to which each isosurface point is determined

   case :: INT
   ! The case number of this marching cube, for lookup in edge_table and
   ! triangle_table

   interior_case :: INT
   ! The case number corresponding to a cube being wholly within a surface.
   ! Normally this is when the interior of the surface has larger values than
   ! the exterior, and in this case the default is 0.

   exterior_case :: INT
   ! The case number corresponding to a cube being wholly outside a surface.
   ! Normally this is when the interior of the surface has smaller values than
   ! the exterior, and in this case the default is 255.

   edge_bit_string :: INT
   ! The edge bit string for the marching cube. This is just the appropriate
   ! element of the edge_table i.e. if the bit is set, then that edge crosses
   ! the isosurface and must be interpolated.

   skip_bit_string :: INT
   ! A bit string which tells whether to skip processing certain cube edges.
   ! Can be used when certain edge vertex points are already done.

   cube_bit_string :: INT
   ! The grad bit string for the marching cube. This tells which *vertices* of
   ! the cube cross the isosurface and must be interpolated.

   n_edge :: INT
   ! The number of marching cube edges that need to be considered on this
   ! marching cube

   n_triangle :: INT
   ! The number of triangles formed on this marching cube

   n_pt :: INT
   ! The number of points up until this cube was analysed. Used to keep a
   ! list of unique indices to define triangle vertices and points.

   triangle_edge_index :: MAT{INT}(3,5)
   ! The (3 x .n_triangle) dimensioned list of 3-edges on the marching cube
   ! used to form triangles. This is just the appropriate row from the
   ! triangle_table. The maximum number of triangles is 5.

   triangle_vertex_index :: MAT{INT}(3,5)
   ! The (3,.n_triangle) dimensioned list of groups of 3 *unique* triangle
   ! vertex *indices*. These indices point to a unique list of points. The
   ! maximum number of triangles is 5.

   edge_vertex_pos :: MAT{REAL}(3,0:11)
   ! A (3 x 0:11) dimensioned list of the interpolated triangle vertex
   ! coordinates on each edge of the cube (if that edge is needed).

   edge_vertex_value :: VEC{REAL}(0:11)
   ! A (0:11) dimensioned list of the interpolated vertex values normals
   ! on each edge of the cube (if that edge is needed).

   edge_vertex_gradient :: MAT{REAL}(3,0:11)
   ! A (3 x 0:11) dimensioned list of the interpolated triangle vertex normals
   ! on each edge of the cube (if that edge is needed).

   edge_vertex_hessian :: MAT3{REAL}(3,3,0:11)
   ! A (3 x 3 x 0:11) dimensioned list of the interpolated triangle vertex
   ! hessians on each edge of the cube (if that edge is needed).

   edge_mean_curvature :: VEC{REAL}(0:11)
   ! A (0:11) dimensioned list of the (interpolated) mean curvatures on each
   ! edge of the cube that crosses the isosurface (if that edge is needed).

   edge_gaussian_curvature :: VEC{REAL}(0:11)
   ! A (0:11) dimensioned list of the (interpolated) gaussian curvatures on each
   ! edge of the cube that crosses the isosurface (if that edge is needed).

   edge_vertex_index :: VEC{INT}(0:11)
   ! A (0:11) dimensioned list of the *unique* triangle vertex *indices* DEFAULT_NULL
   ! for each edge of the marching cube (if that edge is needed).

   vertex_edge_index :: VEC{INT}(12)
   ! A list of the edge indices for each unique triangle vertex index.
   ! Essentially, this is the reverse mapping of edge_vertex_index.

   end

   array type VEC{MARCHINGCUBE}

      ! A 1-D array of MARCHINGCUBE objects

   end

   type ISOSURFACE

   iso_kind :: STR
   ! The kind of isosurface plot, if known. This helps in deciding which way the
   ! normals of the isosurface should point.

   triangulation_method :: STR
   ! The method used to triangulate the isosurface.

   iso_value :: REAL
   ! The isovalue to be used for the isosurface

   iso_values :: VEC{REAL}*
   ! List of *multiple* isovalues to be used for the isosurfaces

   grid :: PLOTGRID
   ! The isosurface plotgrid

   n_pt :: INT
   ! The number of isosurface points

   point :: MAT{REAL}* DEFAULT_NULL
   ! A (3 x n_pt) list of points on the isosurface

   n_face :: INT
   ! The number of triangulated faces on the isosurface

   face :: MAT{INT}* DEFAULT_NULL
   ! A (3 x n_face) list of the triangular faces of the surface. Each face is
   ! represented by three integers which move in an anticlockwise direction when
   ! viwed from the outside.

   point_gradient :: MAT{REAL}* DEFAULT_NULL
   ! A (3 x n_pt) list of the function gradient vectors for every point on the
   ! isosurface

   point_mean_curvature :: VEC{REAL}* DEFAULT_NULL
   ! A (3 x n_pt) list of the mean surface curvatures for every point on the
   ! isosurface

   point_gaussian_curvature :: VEC{REAL}* DEFAULT_NULL
   ! A (3 x n_pt) list of the gaussian surface curvatures for every point on the
   ! isosurface

   area :: REAL
   ! The area of the isosurface, calculated from the triangulate isosurface

   volume :: REAL
   ! The volume of the isosurface, calculated from the triangulate isosurface.

   an_volume :: REAL
   ! The volume of the isosurface, calculated from the triangulate isosurface by
   ! using the average face normal for each triangle face. The average face
   ! normal is calculated from the average of the norms of the point_gradient's
   ! at each surface point.

   volume_min :: REAL
   ! A lower bound to the interior volume of the isosurface, calculated by
   ! counting the number of cubes inside the surface.

   volume_max :: REAL
   ! An upper bound to the interior volume of the isosurface, calculated by
   ! counting the number of cubes inside and on the surface.

   n_skip :: INT
   ! The number of function evaluations skipped (recursive method only)
   ! This is in fact worked out by counting the total number of evaluations.

   level :: INT
   ! The current level to which the initial box has been divided, in the
   ! recursive marching cube algorithm.

   final_level :: INT
   ! The final level to which the initial box must be divided, in the
   ! recursive marching cube algorithm.

   scan_level :: INT
   ! The level to which the initial box must be divided, in the recursive
   ! marching cube algorithm, to achieve resolution of all important features.
   ! It is determined by the .minimum_scan_division setting; or if this is
   ! smaller than the .minimum_scan_level, that value is used instead.

   minimum_scan_level :: INT  DEFAULT(ISOSURFACE_MINIMUM_SCAN_LEVEL)
   ! The smallest acceptable scan level used in the recursive marching cubes
   ! algorithm.

   minimum_scan_division :: REAL  DEFAULT(ZERO)
   ! The minimum acceptable voxel side length to which the initial box must be
   ! divided, in the recursive marching cube algorithm, to achieve resolution of
   ! all important features. The minimum_scan_level (above) may override this
   ! setting.

   voxel_proximity_factor :: REAL  DEFAULT(ISOSURFACE_VOXEL_PROXIMITY_FACTOR)
   ! Setting this value determines when a voxel is deemed to be "close" to the
   ! isosurface, and hence should be subdivided. It works by seeing if the
   ! .iso_value is within this factor times the difference between the maximum
   ! and minimum values on the voxel vertices. If it is, then the voxel is
   ! "close" to the surface.

   del :: REAL
   ! The current box side length in the recursive marching cubes algorithm.

   x :: INT
   ! The (partial) x-coordinate of the box in the recursive marching cubes
   ! algorithm.  This is a binary number, with each bit from the right
   ! representing a segment double the size to which the current box belongs.

   y :: INT
   ! The (partial) y-coordinate of the box in the recursive marching cubes
   ! algorithm.  This is a binary number, with each bit from the right
   ! representing a box double the size to which the current box belongs.

   z :: INT
   ! The (partial) z-coordinate of the box in the recursive marching cubes
   ! algorithm.  This is a binary number, with each bit from the right
   ! representing a box double the size to which the current box belongs.

   hash :: HASH{VEC{INT},VEC{INT}}* DEFAULT_NULL
   ! A hash table storing marching cube edge_vertex_index information as a
   ! function of the cube coordinates, [.x,.y,.z]

   big_interior :: BIN
   ! Set TRUE if the interior of the isosurface is bigger than the exterior,
   ! i.e. if the point_normals are to be reversed on output. This switch could
   ! probably be determined automatically, assuming the botton left had corner
   ! of the plot (the first point) was "outside".

!  shift :: VEC{REAL}* DEFAULT_NULL
!  ! A list of distances representing how far each point shifted from its
!  ! estimate to come to the isosurface.

!  adjoining_face :: MAT{INT}* DEFAULT_NULL
!  ! A (3 x n_face) list of the three adjoining faces for a particular face

!  adjoining_edge :: MAT{INT}* DEFAULT_NULL
!  ! A (3 x n_face) list of the adjoining edge for the adjoining faces for
!  ! a particular face

!  ok :: VEC{BIN}* DEFAULT_NULL
!  ! A list of switches telling if each face is acceptably smooth.

!  ok_neighbours :: VEC{BIN}* DEFAULT_NULL
!  ! A list of switched telling if all three neighbours of each face is acceptably smooth.

!  n_skip :: INT
!  ! The number of faces which are acceptapbly smooth, and can be skippped

!  smallness :: REAL
!  ! The maximum acceptable distance between triangulated points.
!  ! Used as a face smallness criteria.

!  flatness :: REAL
!  ! The maximum acceptable distance between a triangulated point and its ray origin
!  ! i.e. its "shift" (see above).  Used as a face flatness criteria.

!  accuracy :: REAL
!  ! The accuracy to which each isosurface point is determined

   surface_property :: STR  DEFAULT(" ")
   ! The name of a surface property to plot or calculate on the isosurface
   ! surface.

   surface_property_values :: VEC{REAL}* DEFAULT_NULL
   ! The values of .surface_property, evaluated on the isosurface surface.

   surface_iso_values :: VEC{REAL}*  DEFAULT_NULL
   ! The values of the iso_value on the surface, in the case when multiple
   ! isosurfaces have been calculated and merged together into a single surface.

   surface_point :: VEC{REAL}(3)
   ! A special point which lies on or near the isosurface, used for calculations
   ! of connected area, for example.

   chop_surface_property_range :: BIN
   ! When plotting a surface, whether to chop the surface property accorsding to
   ! the lower and upper bounds specified below, rather than scaling the
   ! smallest value to zero and the largest to one.

   surface_property_lower_bound :: REAL  DEFAULT(ISOSURFACE_PROPERTY_LB)
   ! A lower bound to the property value, for calculating surface areas, and for
   ! chopping the range of surface property values.

   surface_property_upper_bound :: REAL  DEFAULT(ISOSURFACE_PROPERTY_UB)
   ! A upper bound to the property value, for calculating surface areas, and for
   ! chopping the range of surface property values.

   surface_prop_lower_bound_abs :: REAL  DEFAULT(ISOSURFACE_PROPERTY_LB_ABS)
   ! A lower bound to the absolute value of the property, for calculating the
   ! log of the surface property values.

   surface_prop_upper_bound_abs :: REAL  DEFAULT(ISOSURFACE_PROPERTY_UB_ABS)
   ! A upper bound to the absolute value of the property, for calculating the
   ! log of the surface property values.

   colour :: COLOURFUNCTION* DEFAULT_NULL
   ! A colourfunction used for colouring the isourface

   atom :: VEC{ATOM}* DEFAULT_NULL
   ! A list of atoms associated with ths isosurface.

   interpolator :: INTERPOLATOR*  DEFAULT_NULL
   ! This is used for setting defaults for the Stockholder isosurfaces which are
   ! generated using Slater or Coppens basis functions.

!   use_interpolator :: BIN  DEFAULT(TRUE)
!   ! If set TRUE, then the routine used to calculate the isosurface may use
!   ! interpolation tables, rather than exact values, if possible.
!
!   interpolation_kind :: STR  DEFAULT(ISOSURFACE_INTERPOLATION_KIND)
!   ! The kind of interpolator to use. It is only used for Hirshfeld surfaces.
!
!   interpolator_table_length :: REAL  DEFAULT(ISOSURFACE_TABLE_LENGTH)
!   ! The length of the table used in the interpolator
!
!   interpolator_table_spacing :: REAL  DEFAULT(ISOSURFACE_TABLE_SPACING)
!   ! The spacing betwen points in the interpolator.
!
!   interpolator_table_eps :: REAL  DEFAULT(ISOSURFACE_TABLE_EPS)
!   ! Values smaller than this in the interpolation table are set to zero, with a
!   ! consequent reduction in the table size.

   end

   type ROBY

   roby_kind :: STR
   ! The kind of Roby calculation to perform

   n1 :: VEC{REAL}* DEFAULT_NULL
   ! Roby population for each atom-group

   n2 :: MAT{REAL}* DEFAULT_NULL
   ! Roby pair population for each atom-group pair
   ! NOTE: these are *not* shared populations

   n_shared :: REAL
   ! Roby multiple shared population for a specified atom-group

   bond_index :: MAT{REAL}* DEFAULT_NULL
   ! Gould Bond indices for each pair of atoms

   percent_covalency :: MAT{REAL}* DEFAULT_NULL
   ! The % covalency of the given bond pair

   gould_charge :: VEC{REAL}* DEFAULT_NULL
   ! Roby-Gould charges

   cruickshank_charge :: VEC{REAL}* DEFAULT_NULL
   ! Cruikshank-Avramedes charges

   summed_n2 :: VEC{REAL}* DEFAULT_NULL
   ! Summed atom-group pair populations

   summed_n3 :: VEC{REAL}* DEFAULT_NULL
   ! Summed atom-group triple populations

   subgroup_pop :: VEC{REAL}* DEFAULT_NULL
   ! The subgroup population contributions when calculating multiple shared
   ! populations.

   atom_list :: VEC{INT}* DEFAULT_NULL
   ! The indices of a list of roby atoms to be used in some way
   ! for population analysis

   atom_group :: VEC{VEC_{INT}}* DEFAULT_NULL
   ! The indices of the roby atoms defining different spaces

   analyse_all_atom_pairs :: BIN
   ! If set TRUE, the bond index information is printed out ONLY for every
   ! atom pair which is considered "bonded". Otherwise all pairs of atoms are
   ! analysed. This is onlyeffective when an atom_list is defined.

   bond_scale_factor :: REAL
   ! Used to multiply the sum of the Bragg-Slater radii for two atoms,
   ! to determine a distance cutoff within which the atoms are regarded
   ! to be bonded

   covalent_cutoff :: REAL
   ! Angles (in radians) greater than this are ignored when calculating
   ! the covalent bond index

   ionic_cutoff :: REAL
   ! Angles (in radians) greater than this are ignored when calculating
   ! the ionic bond index

   pi_on_2_cutoff :: REAL
   ! Angles (in radians) greater than this are regareded as pi/2

   zero_cutoff :: REAL
   ! Angles (in radians) *less* than this are regareded as zero

   occupied_ANO_cutoff :: REAL
   ! Atomic natural orbitals with occupations less than this number
   ! are regarded as unoccupied. This number is used to define the Roby
   ! atomic projector

   output_theta_info :: BIN
   ! If set TRUE, the bond index information is printed out for every
   ! space V_theta. See the paper for details.

   atom_a :: VEC{INT}* DEFAULT_NULL
   ! The indices of the atoms defining space V_A

   atom_b :: VEC{INT}* DEFAULT_NULL
   ! The indices of the atoms defining space V_B

   atom_ab :: VEC{INT}* DEFAULT_NULL
   ! The indices of the roby atoms defining spaces V_A and V_B

   theta_C :: MAT{REAL}* DEFAULT_NULL
   ! The matrix of the covalent theta orbitals

   eval_C :: VEC{REAL}* DEFAULT_NULL
   ! The array of the covalent theta eigenvalues

   theta_angle :: VEC{REAL}* DEFAULT_NULL
   ! The array of covalent theta angles

   pair :: VEC{INT}* DEFAULT_NULL
   ! An array which pairs the positive eigenvalues in eval_C with the
   ! negative eigenvalues, thus definining each theta subspace

   theta_I :: MAT{REAL}* DEFAULT_NULL
   ! The matrix of the covalent theta orbitals

   eval_I :: VEC{REAL}* DEFAULT_NULL
   ! The matrix of the covalent theta eigenvalues

   pop_C :: VEC{REAL}* DEFAULT_NULL
   ! Covalent theta orbital popualtions

   pop_I :: VEC{REAL}* DEFAULT_NULL
   ! Covalent theta orbital popualtions

   pop_A :: VEC{REAL}* DEFAULT_NULL
   ! Atom "A" theta orbital popualtions

   pop_B :: VEC{REAL}* DEFAULT_NULL
   ! Atom "B" theta orbital popualtions

   covalent_index :: VEC{REAL}* DEFAULT_NULL
   ! The vector of each covalent theta bond index

   ionic_index :: VEC{REAL}* DEFAULT_NULL
   ! The vector of each covalent theta bond index

   proportion_a :: MAT{REAL}* DEFAULT_NULL
   ! The proportion to partition for atom A, between two atoms (A,B)
   ! using Gould's probabilistic scheme

   charge :: INT
   ! The total charge on the molecule

   mult :: INT
   ! The spin multiplicity of the molecule

   rho :: OPMATRIX* DEFAULT_NULL
   ! The density matrix of the molecule

   overlap_matrix :: MAT{REAL}* DEFAULT_NULL
   ! The full molecular overlap matrix for Roby analysis

   atom :: VEC{ATOM}* DEFAULT_NULL
   ! The actual list of atoms to be used in the Roby calculations
   ! Usually this will come from a MOLECULE object

   end

   type MO_LOCALISER

   algorithm :: STR  DEFAULT(MO_LOCALISER_ALGORITHM)
   ! Identifier for the kind of localising algorithm

   n_orb :: INT  DEFAULT (0)
   ! The number of molecular orbitals to be localised. It must not exceed the
   ! first dimension of the dipole integrals.

   accuracy :: REAL  DEFAULT(MO_LOCALISER_ACCURACY)
   ! Used to decide when the iterative localising algorithm should terminate

   iteration :: INT  DEFAULT(0)
   ! The iteration counter, for the number of iterative steps used to refine
   ! the localised orbitals.

   max_iterations :: INT  DEFAULT(MO_LOCALISER_MAXIT)
   ! The maximum number of iterations allowed

   MO :: MAT{REAL}*  DEFAULT_NULL
   ! The original molecular orbitals to be localised.

   TM :: MAT{REAL}*  DEFAULT_NULL
   ! The orthogonal transformation matrix from the old to the new MO's.

   dipole :: MAT3{REAL}*  DEFAULT_NULL
   ! The dipole moment integrals in the (current) MO basis, used for the Boys
   ! scheme and for analysing the spread of the localised orbitals. The first
   ! two indices are for the orbitals, the last for the component x, y, or z.

   quadrupole :: MAT3{REAL}*  DEFAULT_NULL
   ! The quadrupole moment integrals in the (current) MO, used to analyse the
   ! localised orbitals. The first two indices are for the orbitals, the last
   ! for the component xx, yy, zz, xy, xz, yz.

   end

   type FMM_CUBE

   centre :: VEC{REAL}(3)
   ! Position of the centre of the cube.

   atomlist :: VEC{INT}*
   ! Indices of the atoms that are in this cube.

   n_atoms :: INT
   ! Number of atoms in this cube

   width :: REAL
   ! Width of this cube

   child :: VEC{FMM_CUBE}*
   ! Child cubes contained in this cube.  (Usually 8 in 3 dimensions).

   end

   array type VEC{FMM_CUBE}

   ! A 1-D array of FMM_CUBE objects

   end

   type PERIODIC_FMM_LEVEL

   level_number :: INT
   ! Index of this level relative to the original unit cell, which is level 0.

   crystal :: CRYSTAL*
   ! The crystal that is being used to set up the periodic fmm levels.

   scale_factor :: REAL
   ! 3**level_number, which is in the type because it is used a lot.

   centre :: VEC{REAL}(3)
   ! Centre point for the whole cell, this level.

   origin :: VEC{REAL}(3)
   ! The origin, or bottom left hand corner, for the cell on this level.
   ! NOTE: this is in fractional coordinates.

   unitcell_origin :: VEC{REAL}(3)
   ! The origin, or bottom left hand corner, for the unitcell.
   ! NOTE: this is in fractional coordinates.

   divisions :: VEC{INT}(3)
   ! Number of integer divisions of the unit cell in each lattice direction,
   ! which defines a BOX.

   subsubbox_radius_0 :: REAL
   ! The radius which encloses a subsubbox at level 0.

   subsubbox_radius :: REAL
   ! The radius which encloses a subsubbox at this level.

   crystallite_side_length :: REAL
   ! The desired side length for the crystallite. This determines the number of
   ! levels that will be used.

   accuracy :: REAL
   ! The accuracy required for the multipole expansion of the electrostatic
   ! potential

   l_max :: INT
   ! The maximum number of multipoles required at this level to achieve the
   ! given accuracy (see above)

   potential_method :: STR
   ! The potential evaluation method to use: "point-centred-monopole",
   ! "cell-centred-multipole", or "either". In the latter case the
   ! .preferred_potential_method decides which of the two to use.

   preferred_potential_method :: STR
   ! The preferred potential evaluation method to use in the case when the
   ! .potential_method (above) is "either".

   fragment_charges :: VEC{REAL}*
   ! The list of fragment charges.

   fragment_positions :: MAT{REAL}*
   ! The list of fragment positions.

   charges :: VEC{REAL}*
   ! The list of charges in the unit cell, generated from the .fragment_charges.
   ! Only used for levels 0 and 1.

   positions :: MAT{REAL}*
   ! The list of positions for the charges in the unit cell, generayed from the
   ! .fragment_positions. Only used for levels 0 and 1.

   unitcell_charge :: REAL
   ! The total (absolute) charge in the unit cell

   indices_for_box :: MAT3{VEC_{INT}}*
   ! The list of indices which map the .charges and .positions into boxes.

   total_charge_for_box :: MAT3{REAL}*
   ! The total charge for each box of this level. 

   total_charge_for_1st_subsubbox :: MAT3{REAL}*
   ! The total charge for the first subsubbox of this level. The rest are the
   ! same. They are defined rom and the same as the box charges (see above) two
   ! levels down. They are used to determine .l_max for this level.

   multipoles_for_box :: MAT3{VEC_{REAL}}*
   ! The multipoles for each box of this level. 

   multipoles_for_1st_subsubbox :: MAT3{VEC_{REAL}}*
   ! The multipoles for the first subsubbox of this level. The rest are the
   ! same. They are defined from and the same as the box multipoles (see above)
   ! two levels down.

   end

   array type VEC{PERIODIC_FMM_LEVEL}

   ! A 1-D array of PERIODIC_FMM_LEVEL objects

   end

   type GEMINAL_MF_SPECTRUM

   name :: STR
   ! Name of the associated molecule

   nuclear_energy :: REAL
   ! Nuclear repulsion energy for the associated molecule

   n_geminals :: INT
   ! The number of geminal functions

   n_bf :: INT
   ! The number of one-particle basis functions

   n_bas :: INT
   ! The number of basis geminal functions for the particular contraction
   ! considered

   bra :: VEC{MAT_{REAL}}*
   ! The array of contracted wavefunctions in the bra.
   ! The first component is the function of the contraction considered.
   ! The (n_geminals - 1) other components are the ground state wave functions
   ! of the other contractions

   ket :: VEC{MAT_{REAL}}*
   ! The array of contracted wavefunctions in the ket
   ! The first component is the function of the contraction considered.
   ! The (n_geminals - 1) other components are the ground state wave functions
   ! of the other contractions

 !  special_bra :: VEC{VEC_{INT}}*
   ! This bra contains only the indices of one geminal product basis function.

   special_ket :: VEC{VEC_{INT}}*
   ! This ket contains only the indices of one product basis function.

   contraction_wfs :: VEC{MAT_{REAL}}*
   ! The array of geminal wavefunctions of the particular contraction considered

   contraction_energies :: VEC{REAL}*
   ! The array of geminal energies of the particular contraction considered

   end

   type MOLECULE

   name :: STR
   ! Name of molecule

   charge :: INT
   ! Electric charge of the molecule

   mult :: INT
   ! Spin multiplicity of the molecule

   E_field :: VEC{REAL}(3)
   ! Applied electric field in atomic units

   B_field :: VEC{REAL}(3)
   ! Applied magnetic field in atomic units

   gauge_origin :: VEC{REAL}(3)
   ! Global gauge origin for magnetic field

   atom :: VEC{ATOM}* DEFAULT_NULL
   ! List of atoms in molecule

   basis_set_kind :: STR
   ! A suffix string representing the name of the basis set class
   ! to be used for each atom

   basis :: VEC{BASIS}* DEFAULT_NULL
   ! List of basis sets used

   slaterbasis :: VEC{SLATERBASIS}* DEFAULT_NULL
   ! List of Slater basis sets used

   coppensbasis :: VEC{COPPENSBASIS}* DEFAULT_NULL
   ! List of coppens basis sets used

   basis_info_made :: BIN
   ! Set TRUE if the gaussian basis set info has been made.

   grid :: PLOTGRID* DEFAULT_NULL
   ! Rectangular grid data, for plots

   isosurface :: ISOSURFACE* DEFAULT_NULL
   ! An object used for creating triangluated meshes for isosurface plots.

   dftgrid :: DFTGRID* DEFAULT_NULL
   ! DFT integration grid data. Should be obsoleted from 24/7/05

   becke_grid :: BECKE_GRID* DEFAULT_NULL
   ! Becke DFT integration grid data

   rough_becke_grid :: BECKE_GRID* DEFAULT_NULL
   ! Rough Becke DFT integration grid data -- for quick low quality integration

   crystal :: CRYSTAL* DEFAULT_NULL
   ! Crystal data for the enclosing crystal

   cluster :: CLUSTER* DEFAULT_NULL
   ! Crystal cluster data

   cif :: CIF* DEFAULT_NULL
   ! Crystallographic Information file (CIF) object

   pointgroup :: POINTGROUP* DEFAULT_NULL
   ! Pointgroup symmetry of the molecule

   saved :: MOLECULE* DEFAULT_NULL
   ! For saving self and temporarily using an alternative in its place

   n_e :: INT
   ! No of electrons

   n_a :: INT
   ! No of alpha electrons

   n_b :: INT
   ! No of beta electrons

   n_atom :: INT
   ! No of atoms

   n_atom_kind :: INT
   ! No of atoms of a different kind

   n_basis :: INT
   ! No of basis sets

   n_shell :: INT
   ! Total number of shells in the molecular basis set

   n_shell_pairs :: INT
   ! Total number of shell pairs in the molecular basis set

   n_bf :: INT
   ! Total number of basis functions in the molecular basis set

   n_prim :: INT
   ! Total number of primitives in the molecular basis set

   n_unique_shells :: INT
   ! Number of unique shells in the basis set.

   atom_for_shell :: VEC{INT}* DEFAULT_NULL
   ! Atom index for molecular shell index array

   atom_shell_for_shell :: VEC{INT}* DEFAULT_NULL
   ! Atom shell index for molecular shell index array

   first_shell_for_atom :: VEC{INT}* DEFAULT_NULL
   ! First molecule shell index for an atom

   last_shell_for_atom :: VEC{INT}* DEFAULT_NULL
   ! Last molecule shell index for an atom

   basis_shell_for_shell :: VEC{INT}* DEFAULT_NULL
   ! Map a shell of the molecule to a shell of the basis set

   first_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL
   ! First basis function for a given shell

   last_basis_fn_for_shell :: VEC{INT}* DEFAULT_NULL
   ! Last basis function for a given shell

   angular_moment_for_shell :: VEC{INT}* DEFAULT_NULL
   ! Angular moment for a given shell

   first_basis_fn_for_atom :: VEC{INT}* DEFAULT_NULL
   ! For the atom basis function limits

   last_basis_fn_for_atom :: VEC{INT}* DEFAULT_NULL
   ! For the atom basis function limits

   precomputed_basis_shellpair :: VEC{SHELLPAIR}* DEFAULT_NULL
   ! Precomputed stuff for shellpairs of the basis set, to speed up
   ! later calculations of gaussian integrals.

   atom_kind :: VEC{INT}* DEFAULT_NULL
   ! The unique kind of each atom in .atom

   unique_atom :: VEC{INT}* DEFAULT_NULL
   ! List of the unique atoms (of different kind)

   overlapping_atoms :: VEC{BIN}* DEFAULT_NULL
   ! List of atom-pairs (in lower triangular form) which have significant
   ! overlap. Used in linear scaling DFT calculations.

   scfdata :: SCFDATA* DEFAULT_NULL
   ! SCF data object

   orbital_energies :: OPVECTOR* DEFAULT_NULL
   ! The orbital energies

   molecular_orbitals :: OPMATRIX* DEFAULT_NULL
   ! The molecular orbitals

   density_matrix :: OPMATRIX* DEFAULT_NULL
   ! The density matrix

   natural_orbitals :: OPMATRIX* DEFAULT_NULL
   ! The natural orbitals

   occupation_numbers :: OPVECTOR* DEFAULT_NULL
   ! The natural orbital occupation numbers

   fock_matrix :: OPMATRIX* DEFAULT_NULL
   ! The fock matrix

   constraint_matrix :: OPMATRIX* DEFAULT_NULL
   ! The constraint matrix, used for X-ray or PND constrained SCF calculations

   old_molecular_orbitals :: OPMATRIX* DEFAULT_NULL
   ! The molecular orbitals from the previous SCF iteration.
   ! NOTE: this is currently obsolete, but was used for Camp-king (?)

   old_density_matrix :: OPMATRIX* DEFAULT_NULL
   ! The density matrix from the previous SCF iteration, used for incremental
   ! Fock matrix builds in the direct SCF method -- but NOT for density matrix
   ! damping.

   old_fock_matrix :: OPMATRIX* DEFAULT_NULL
   ! The fock matrix from the previous SCF iteration, used for incremental Fock
   ! matrix builds in the direct SCF method.

   old_constraint_matrix :: OPMATRIX* DEFAULT_NULL
   ! The constraint matrix from the previous SCF iteration

   atom_group :: VEC{VEC_{INT}}* DEFAULT_NULL
   ! A list of atom group indices, for group property decomposition

   atom_group_energy :: VEC{REAL}* DEFAULT_NULL
   ! The SCF energy of each atom group

   group_charges :: VEC{INT}* DEFAULT_NULL
   ! A list of charges for each group in the molecule, defined in atom_groups.

   optimise_thermals :: BIN
   ! Whether to optimise the thermal parameters

   roby :: ROBY* DEFAULT_NULL
   ! A Roby data object

!  CIF_file_name :: STR  DEFAULT(" ")
!  ! The name of a CIF file to be used for input

!  CIF_data_block_name :: STR  DEFAULT(" ")
!  ! The name of a CIF file data block, to be used for processing

   CX_file_name :: STR  DEFAULT(" ")
   ! The name of the Crystal Explorer (CX) output file

   geminal_mf_spectrum :: GEMINAL_MF_SPECTRUM*
   ! The geminal mean field stuff ...

   periodic_fmm_level :: VEC{PERIODIC_FMM_LEVEL}*
   ! The hierarchy of periodic FMM levels, used for calculating the coulomb
   ! interaction in crystal scf calculations.

   localiser :: MO_LOCALISER*
   ! AN MO localiser object

   end

end
