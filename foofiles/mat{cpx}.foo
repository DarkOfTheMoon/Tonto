!---------------------------------------------------------------------------
!
!  complex matrix operations :: MAT{CPX} ...
!
! Copyright (C) Dylan Jayatilaka, 1996
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module MAT{CPX}

   implicit none

   tol5 :: REAL, private = 1.0d-5
!   tol10 :: REAL, private = 1.0d-10

   interface trace_of_product_with
     trace_product_with
   end

   interface diagonal_set_to
      set_diagonal_to
   end

   interface diagonal_plus
      increment_diagonal_by
   end

   interface diagonal_times
      scale_diagonal_by
   end

   interface diagonal_max_abs
      max_abs_diagonal_element 
   end

contains

! *****************
! Memory allocation
! *****************

   create(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given dimensions
      self :: PTR
      dim1,dim2 :: INT, IN
   end

   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the specified "bounds" for each dimension
      self :: PTR
      bounds :: VEC{INT}(2), IN
   end

   create(lb1,ub1,lb2,ub2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given dimensions
      self :: PTR
      lb1,ub1,lb2,ub2 :: INT, IN
   end

   create(bounds1,bounds2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the specified bounds for each dimension
      self :: PTR
      bounds1,bounds2 :: VEC{INT}, IN
   end

   create(bounds) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a matrix with the given bounds for all dimensions
      self :: PTR
      bounds :: MAT{INT}(2,2), IN
   end

   create_copy(matrix) ::: get_from(MAT{INTRINSIC}), leaky
   ! Create a replica copy of matrix
      self :: PTR
      matrix :: MAT{CPX}, IN
   end

   destroy ::: get_from(MAT{INTRINSIC}), leaky
   ! Destroy the object
      self :: PTR
   end

   created result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

! ****************************
! Size-of and shape operations 
! ****************************

   size result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the array
      res :: INT
   end

   dim1 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the 1st dimension
      res :: INT
   end

   dim2 result (res) ::: get_from(MAT{INTRINSIC}), inlined_by_foo
   ! Return the size of the 2nd dimension
      res :: INT
   end

   shape result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the shape of "self"
      res :: VEC{INT}(2)
   end

   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}), pure
   ! Returns TRUE if the matrix "a" has the same shape as "self"
      self :: IN
      a :: MAT{CPX}, IN
      res :: BIN
   end

   is_same_shape_as(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}), pure
   ! Returns TRUE if the matrix "a" has the same shape as "self"
      self :: IN
      a :: MAT{REAL}, IN
      res :: BIN
   end

   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}), pure
   ! Returns TRUE if the matrix "a" is the transposed shape of self
      self :: IN
      a :: MAT{CPX}, IN
      res :: BIN
   end

   is_transposed_shape_of(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}), pure
   ! Returns TRUE if the matrix "a" is the transposed shape of self
      self :: IN
      a :: MAT{REAL}, IN
      res :: BIN
   end

   is_square result (res) ::: get_from(MAT{INTRINSIC}), pure
   ! Returns TRUE if the matrix is square
      self :: IN
      res :: BIN
   end

! ***********************
! Shrinking and expansion
! ***********************

   shrink(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Shrinks self to dimension dim1xdim2.  Contents are retained.
     self :: PTR
     dim1,dim2 :: INT, IN
   end

   expand(dim1,dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Expands self to dimension dim1xdim2.  Contents are retained.
     self :: PTR
     dim1,dim2 :: INT, IN
   end

   shrink_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Shrinks columns of self to dimension dim2. Contents are retained.
     self :: PTR
     dim2 :: INT, IN
   end

   expand_columns(dim2) ::: get_from(MAT{INTRINSIC}), leaky
   ! Expands the columns self to dim2.  Contents are retained.
     self :: PTR
     dim2 :: INT, IN
   end

   append_columns(cols) ::: get_from(MAT{INTRINSIC}), leaky
   ! Append the columns "cols" onto the end of self.
     self :: PTR
     cols :: MAT{CPX}
   end

   append_column(col) ::: get_from(MAT{INTRINSIC}), leaky
   ! Append the column "col" onto the end of self.
     self :: PTR
     col :: VEC{CPX}
   end

! ********************
! Comparison functions
! ********************

   equals(b) result (res) ::: get_from(MAT{INTRINSIC})
   ! Check if the matrix is the same as "b".
      self :: IN
      b :: MAT{CPX}, IN
      res :: BIN
   end

   same_as(b,eps,diff) result (res) ::: get_from(MAT{INTRINSIC})
   ! Check if the matrix is the same as "b", within "eps", and return the
   ! actual difference in "diff"
      self :: IN
      b :: MAT{CPX}, IN
      eps :: REAL, IN, optional
      diff :: REAL, OUT, optional
      res :: BIN
   end

! *****************
! Inquiry functions
! *****************

   is_diagonal result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is a diagonal matrix
      self :: IN
      res :: BIN
   end

   has_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has 1's as diagonal elements
      self :: IN
      res :: BIN
   end

   has_minus_unit_diagonal result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has -1's as diagonal elements
      self :: IN
      res :: BIN
   end

   is_unit_matrix result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is the unit matrix
      self :: IN
      res :: BIN
   end

   is_inversion_matrix result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is an inversion matrix
   ! i.e. minus the unit matrix
      self :: IN
      res :: BIN
   end

   is_symmetric result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is a symmetric matrix
      self :: IN
      res :: BIN
   end

   is_antisymmetric result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" is an antisymmetric matrix
      self :: IN
      res :: BIN
   end

   is_zero(eps) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return TRUE is "self" is the zero matrix, i.e. every element is zero.
   ! If present, "eps" is used to decide when a small number is zero.
      eps :: REAL, optional, IN
      res :: BIN
   end

   is_hermitian(tol) result (res)
   ! Returns TRUE if the matrix is hermitian. You can set the tolerance "tol"
   ! for comparison.
      self :: IN
      res :: BIN
      tol :: REAL, optional
      res = .is_square AND .same_as(transpose(conjg(self)),tol)
   end

   is_antihermitian(tol) result (res)
   ! Returns TRUE if the matrix is antihermitian. You can set the tolerance
   ! "tol" for comparison.
      self :: IN
      res :: BIN
      tol :: REAL, optional
      res = .is_square AND .same_as(-transpose(conjg(self)),tol)
   end

! *****************
! Column operations 
! *****************

   has_column(c,eps,col) result (res) ::: get_from(MAT{INTRINSIC})
   ! Returns TRUE if the matrix "self" has a column "c", with "eps" tolerance.
   ! If present, the matching column index "col" is also returned.
      self :: IN
      c :: VEC{CPX}, IN
      eps :: REAL, optional
      col :: INT, optional
      res :: BIN
   end

   column_index(c,eps) result (res) ::: get_from(MAT{INTRINSIC})
   ! The matching column index is returned, if the column matches "col" to
   ! tolerance "eps", if it is present.
      self :: IN
      c :: VEC{CPX}, IN
      res :: INT
      eps :: REAL, optional
   end

   swap_columns(col1,col2) ::: get_from(MAT{INTRINSIC})
   ! Swap columns "col1" and "col2" of self
      col1,col2 :: INT, IN
   end

   swap_columns(list) ::: get_from(MAT{INTRINSIC})
   ! Sequentially swap all columns in a column "list",
   ! self(:,i)      = self(:,list(i))
   ! self(:,col(i)) = self(:,i)
      list :: VEC{INT}, IN
   end

   column_norms result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the norms of every column
      res :: VEC{REAL}(.dim2)
   end

   get_column_norms(res) ::: get_from(MAT{INTRINSIC})
   ! Return the norms of every column
      res :: VEC{REAL}
   end

   get_column_dot_products(res) ::: get_from(MAT{INTRINSIC})
   ! Return the dot products of every column with itself.
   ! Good for testing distances without using a sqrt.
      res :: VEC{REAL}
   end

   index_of_minimum_column_norm(offset) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the column index of the column with the *minimum* norm. If present,
   ! "offset" is subtracted from every column beforehand, and then added back
   ! afterwards. This is useful for finding the index of the column with minimum
   ! distance to "offset", for a list of points held in "self".
      offset :: VEC{CPX}(.dim1), optional
      res :: INT
   end

   max_abs_column_difference result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the maximum of the absolute difference between all the column vector
   ! pairs of the matrix.
      res :: VEC{REAL}(.dim1)
   end

   mean_column_vector result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the mean of the column vectors.
      res :: VEC{CPX}(.dim1)
   end

   sum_column_vectors result (res) ::: get_from(MAT{INTRINSIC})
   ! Sum the column vectors (i.e. rows) in "self".
      res :: VEC{CPX}(.dim1)
   end

   reverse_column_order ::: get_from(MAT{INTRINSIC})
   ! Reverse the order of the columns of self.
   end

! **************
! Row operations
! **************

   sum_row_vectors result (res) ::: get_from(MAT{INTRINSIC})
   ! Sum the row vectors (i.e. columns) in "self".
      res :: VEC{CPX}(.dim2)
   end

! ******************************************
! Matrix algebra and vector space operations
! ******************************************

   determinant result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the determinant a 3x3 matrix
      self :: IN
      res :: CPX
   end

   cofactor result (res) ::: get_from(MAT{INTRINSIC}), leaky
   ! Return the cofactor of a 3x3 matrix
      self :: IN
      res :: MAT{CPX}*
   end

   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{CPX}, RES_TYPE=>CPX)
   ! Multiply the matrix self by vector "l" on the left and vector "r" on the
   ! right ie:  res = l^dagger self r. Useful for non-unit metric dot_products.
     self :: IN
     l,r :: VEC{CPX}, IN
     res :: CPX 
   end

   dot(l,r) result (res) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{REAL}, RES_TYPE=>CPX)
   ! Multiply the matrix self by vector "l" on the left and vector "r" on the
   ! right ie:  res = l^dagger self r. Useful for non-unit metric dot_products.
     self :: IN
     l,r :: VEC{REAL}, IN
     res :: CPX 
   end

   rotate(v) ::: get_from(MAT{INTRINSIC})
   ! Rotate vector "v" by self
     v :: VEC{CPX}, INOUT
   end

   to_unit_matrix ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the unit matrix
   end

   zero_small_values(eps) ::: get_from(MAT{INTRINSIC}), pure
   ! Zero elements of the matrix which are less than "eps" in magnitude
      self :: INOUT
      eps :: REAL, IN
   end

   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Set self to "a"
      a :: MAT{CPX}, IN
   ENSURE(.is_same_shape_as(a),"incompatible shape")
   end

   set_to(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Set self to "a"
      a :: MAT{REAL}, IN
   ENSURE(.is_same_shape_as(a),"incompatible shape")
   end

   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Self becomes the transpose of "a"
     self :: OUT
     a :: MAT{CPX}, IN
   end

   set_to_transpose_of(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Self becomes the transpose of "a"
     self :: OUT
     a :: MAT{REAL}, IN
   end

   to_transpose ::: get_from(MAT{INTRINSIC})
   ! Self becomes its own transpose.
     self :: INOUT
   end

   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Add to self the matrix "a"
      a :: MAT{CPX}, IN
   end

   plus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Add to self the matrix "a"
      a :: MAT{REAL}, IN
   end

   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Subtract from self the matrix "a"
      a :: MAT{CPX}, IN
   end

   minus(a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Subtract from self the matrix "a"
      a :: MAT{REAL}, IN
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)
   ! Set "self" to matrix "at" scaled by "fac"
      self :: OUT
      a :: MAT{CPX}, IN
      fac :: CPX, IN
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)
   ! Set "self" to matrix "at" scaled by "fac"
      self :: OUT
      a :: MAT{CPX}, IN
      fac :: REAL, IN
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Set "self" to matrix "at" scaled by "fac"
      self :: OUT
      a :: MAT{REAL}, IN
      fac :: CPX, IN
   end

   to_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Set "self" to matrix "at" scaled by "fac"
      self :: OUT
      a :: MAT{REAL}, IN
      fac :: REAL, IN
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)
   ! Add to "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: MAT{CPX}, IN
      fac :: CPX, IN
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)
   ! Add to "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: MAT{CPX}, IN
      fac :: REAL, IN
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Add to "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: MAT{REAL}, IN
      fac :: CPX, IN
   end

   plus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Add to "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: MAT{REAL}, IN
      fac :: REAL, IN
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>CPX)
   ! Subtract from "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: A_TYPE, IN
      fac :: FAC_TYPE, IN
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX}, FAC_TYPE=>REAL)
   ! Subtract from "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: A_TYPE, IN
      fac :: FAC_TYPE, IN
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Subtract from "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: A_TYPE, IN
      fac :: FAC_TYPE, IN
   end

   minus_scaled(a,fac) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Subtract from "self" matrix "a" scaled by "fac"
      self :: INOUT
      a :: A_TYPE, IN
      fac :: FAC_TYPE, IN
   end

   to_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL})
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
     self :: OUT
     a,b :: MAT{REAL}, IN
     transpose_a, transpose_b :: BIN, optional, IN
   end

   to_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   ! Likewise for the dagger operations.
     self :: OUT
     a,b :: MAT{CPX}, IN
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   end

   to_product_of(a,b,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the product of complex matrix "a" and real matrix "b".  If
   ! present, "dagger_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      dagger_a, transpose_b :: BIN, optional
   end

   to_product_of(a,b,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC})
   ! Set "self" to the product of real matrix "a" and complex matrix "b".  If
   ! present, "transpose_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      transpose_a, dagger_b :: BIN, optional
   end

   plus_product_of(a,b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL})
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
     self :: INOUT
     a,b :: MAT{REAL}, IN
     transpose_a, transpose_b :: BIN, optional, IN
   end

   plus_product_of(a,b,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC})
   ! Add to "self" the matrix product of "a" and "b". If present, "transpose_a"
   ! and "transpose_b" can be set to TRUE if "a" and "b" need to be transposed.
   ! Likewise for the dagger operations.
     self :: INOUT
     a,b :: MAT{CPX}, IN
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   end

   plus_product_of(a,b,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC})
   ! Add to "self" the product of complex matrix "a" and real matrix "b".  If
   ! present, "dagger_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      dagger_a, transpose_b :: BIN, optional
   end

   plus_product_of(a,b,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC})
   ! Add to "self" the product of real matrix "a" and complex matrix "b".  If
   ! present, "transpose_a" and "dagger_b" can be set to TRUE if "a" and "b"
   ! needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      transpose_a, dagger_b :: BIN, optional
   end

   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
     self :: OUT
     a,b :: MAT{REAL}, IN
     fac :: CPX
     transpose_a, transpose_b :: BIN, optional, IN
   end

   to_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.
     self :: OUT
     a,b :: MAT{REAL}, IN
     fac :: REAL
     transpose_a, transpose_b :: BIN, optional, IN
   end

   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
     self :: OUT
     a,b :: MAT{CPX}, IN
     fac :: CPX
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   end

   to_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Set "self" to the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
     self :: OUT
     a,b :: MAT{CPX}, IN
     fac :: REAL
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   end

   to_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Set "self" to the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      fac :: CPX
      dagger_a, transpose_b :: BIN, optional
   end

   to_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Set "self" to the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      fac :: REAL
      dagger_a, transpose_b :: BIN, optional
   end

   to_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Set "self" to the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      fac :: CPX
   end

   to_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Set "self" to the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: OUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      fac :: REAL
   end

   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>CPX)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! neeb to be transposed.
     self :: INOUT
     a,b :: MAT{REAL}, IN
     fac :: CPX
     transpose_a, transpose_b :: BIN, optional, IN
   end

   plus_scaled_product_of(a,b,fac,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, AB_TYPE=>MAT{REAL}, FAC_TYPE=>REAL)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! neeb to be transposed.
     self :: INOUT
     a,b :: MAT{REAL}, IN
     fac :: REAL
     transpose_a, transpose_b :: BIN, optional, IN
   end

   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
     self :: INOUT
     a,b :: MAT{CPX}, IN
     fac :: CPX
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   end

   plus_scaled_product_of(a,b,fac,dagger_a,dagger_b,transpose_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Add to "self" the matrix product of "a" and "b" scaled by "fac". If
   ! present, "transpose_a" and "transpose_b" can be set to TRUE if "a" and "b"
   ! need to be transposed.  Likewise for the dagger operations.
     self :: INOUT
     a,b :: MAT{CPX}, IN
     fac :: REAL
     dagger_a, dagger_b, transpose_a, transpose_b :: BIN, optional, IN
   end

   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Add to "self" the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      fac :: CPX
      dagger_a, transpose_b :: BIN, optional
   end

   plus_scaled_product_of(a,b,fac,dagger_a,transpose_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Add to "self" the product of complex matrix "a" and real matrix "b" scaled
   ! by "fac".  If present, "dagger_a" and "transpose_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{CPX}
      b :: MAT{REAL}
      fac :: REAL
      dagger_a, transpose_b :: BIN, optional
   end

   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Add to "self" the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      fac :: CPX
      transpose_a, dagger_b :: BIN, optional
   end

   plus_scaled_product_of(a,b,fac,transpose_a,dagger_b) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Add to "self" the product of real matrix "a" and complex matrix "b" scaled
   ! by "fac".  If present, "transpose_a" and "dagger_b" can be set to TRUE if
   ! "a" and "b" needs to be daggerred or transposed.
      self :: INOUT
      a :: MAT{REAL}
      b :: MAT{CPX}
      fac :: REAL
      transpose_a, dagger_b :: BIN, optional
   end

   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, DIAG_TYPE=>VEC{CPX})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, ""transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      self :: INOUT
      a :: MAT{REAL}, IN
      diag :: VEC{CPX}, IN
      transpose_a :: BIN, optional, IN
   end

   to_product_with_diagonal(a,diag,transpose_a) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL}, DIAG_TYPE=>VEC{REAL})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, ""transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      self :: INOUT
      a :: MAT{REAL}, IN
      diag :: VEC{REAL}, IN
      transpose_a :: BIN, optional, IN
   end

   to_product_with_diagonal(a,diag,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DIAG_TYPE=>VEC{CPX})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, "dagger_a" or "transpose_a" can be set to TRUE
   ! if "a" needs to be daggered or transposed.
      self :: OUT
      a :: MAT{CPX}, IN
      diag :: VEC{CPX}, IN
      dagger_a, transpose_a :: BIN, optional, IN
   end

   to_product_with_diagonal(a,diag,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DIAG_TYPE=>VEC{REAL})
   ! Set "self" to the matrix product of "a" with diagonal matrix "diag" (stored
   ! as a vector).  If present, "dagger_a" or "transpose_a" can be set to TRUE
   ! if "a" needs to be daggered or transposed.
      self :: OUT
      a :: MAT{CPX}, IN
      diag :: VEC{REAL}, IN
      dagger_a, transpose_a :: BIN, optional, IN
   end

   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{CPX}, A_TYPE=>MAT{REAL})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      self :: OUT
      dg :: VEC{CPX}, IN
      a :: MAT{REAL}, IN
      transpose_a :: BIN, optional, IN
   end

   to_product_with_diagonal(dg,a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{REAL}, A_TYPE=>MAT{REAL})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "transpose_a" can be set to TRUE if "a" needs
   ! to be transposed.
      self :: OUT
      dg :: VEC{REAL}, IN
      a :: MAT{REAL}, IN
      transpose_a :: BIN, optional, IN
   end

   to_product_with_diagonal(dg,a,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{CPX})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "dagger_a" or "transpose_a" can be set to
   ! TRUE if "a" needs to be daggered or transposed.
      self :: OUT
      dg :: VEC{CPX}, IN
      a :: MAT{CPX}, IN
      dagger_a, transpose_a :: BIN, optional, IN
   end

   to_product_with_diagonal(dg,a,dagger_a,transpose_a) ::: get_from(MAT{INTRINSIC}, DG_TYPE=>VEC{REAL})
   ! Set "self" to the matrix product of diagonal matrix "dg" (stored as a
   ! vector) and "a".  If present, "dagger_a" or "transpose_a" can be set to
   ! TRUE if "a" needs to be daggered or transposed.
      self :: OUT
      dg :: VEC{REAL}, IN
      a :: MAT{CPX}, IN
      dagger_a, transpose_a :: BIN, optional, IN
   end

! ****************
! Trace operations
! ****************

   trace result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of self
      self :: IN
      res :: CPX
   end

   trace_product_with(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{CPX})
   ! Return the trace of the product of "self" with matrix "a".
      self :: IN
      a :: MAT{CPX}, IN
      res :: CPX
   end

   trace_product_with(a) result (res) ::: get_from(MAT{INTRINSIC}, A_TYPE=>MAT{REAL})
   ! Return the trace of the product of "self" with matrix "a".
      self :: IN
      a :: MAT{REAL}, IN
      res :: CPX
   end

   trace_product_with(a,b,c) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of the product of "self" with matrices "a", "b" and "c".
      a,b,c :: MAT{CPX}
      res :: CPX
   end

   trace_product_with(a,b,c,d,e) result (res) ::: get_from(MAT{INTRINSIC})
   ! Return the trace of the product of "self" with matrices "a", "b" ... "e".
      a,b,c,d,e :: MAT{CPX}
      res :: CPX
   end

! ************************
! Change of basis routines
! ************************

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)
   ! Change the basis of "self" using vectors "V"; self = V^dagger self V
      V :: MAT{CPX}, IN
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
   ! Change the basis of "self" using vectors "V"; self = V^dagger self V
      V :: MAT{REAL}, IN
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>VEC{CPX})
   ! Change the basis of "self" using diagonal matrix "V" (stored as a vector).
   ! self = V self V
      V :: VEC{CPX}, IN
   end

   change_basis_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>VEC{REAL})
   ! Change the basis of "self" using diagonal matrix "V" (stored as a vector).
   ! self = V self V
      V :: VEC{REAL}, IN
   end

   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{CPX})
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
      L,R :: VEC{CPX}, IN
   end

   change_basis_using(L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>VEC{REAL})
   ! Change the basis of "self" using diagonal matrices "L" and "R" (stored as
   ! vectors).  self = L self R
      L,R :: VEC{REAL}, IN
   end

   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new".  new = V^dagger self V
      self :: IN
      new :: MAT{CPX}, OUT
      V :: V_TYPE, IN
   end

   change_basis_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
   ! Change the basis of "self" using vectors "V", and place the result in
   ! "new".  new = V^dagger self V
      self :: IN
      new :: MAT{CPX}, OUT
      V :: V_TYPE, IN
   end

   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{CPX}, TRANSPOSE_A=>DAGGER_A)
   ! Change the basis of "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L^dagger self R
      self :: IN
      new :: MAT{CPX}, OUT
      L,R :: LR_TYPE, IN
   end

   change_basis_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})
   ! Change the basis of "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L^dagger self R
      self :: IN
      new :: MAT{CPX}, OUT
      L,R :: LR_TYPE, IN
   end

   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)
   ! Back transform "self" using vectors "V", and place the result in "self".
   ! self = V self V^dagger
      V :: MAT{CPX}, IN
   end

   back_transform_using(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
   ! Back transform "self" using vectors "V", and place the result in "self".
   ! self = V self V^dagger
      V :: MAT{REAL}, IN
   end

   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! new = V self V^dagger
      self :: IN
      new :: MAT{CPX}, OUT
      V :: V_TYPE, IN
   end

   back_transform_to(new,V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
   ! Back transform "self" using vectors "V", and place the result in "new".
   ! new = V self V^dagger
      self :: IN
      new :: MAT{CPX}, OUT
      V :: V_TYPE, IN
   end

   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{CPX}, TRANSPOSE_B=>DAGGER_B)
   ! Back transform "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L self R^dagger
      self :: IN
      new :: MAT{CPX}, OUT
      L,R :: LR_TYPE, IN
   end

   back_transform_to(new,L,R) ::: get_from(MAT{INTRINSIC}, LR_TYPE=>MAT{REAL})
   ! Back transform "self" using left and right matrices "L" and "R"
   ! and place the result in "new", new = L self R^dagger
      self :: IN
      new :: MAT{CPX}, OUT
      L,R :: LR_TYPE, IN
   end

!   similarity_transform(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{CPX})
!   ! Do a similarity transform of "self" using vectors "V": self = V self V^-1
!      V :: MAT{CPX}, IN
!   end

!   similarity_transform(V) ::: get_from(MAT{INTRINSIC}, V_TYPE=>MAT{REAL})
!   ! Do a similarity transform of "self" using vectors "V": self = V self V^-1
!      V :: MAT{REAL}, IN
!   end

! **************************
! Operations on the diagonal
! **************************

   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{CPX})
   ! Converts the diagonal vector "d" to matrix "self".
      d :: VEC{CPX}
   end

   set_from_diagonal(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})
   ! Converts the diagonal vector "d" to matrix "self".
      d :: VEC{REAL}
   end

   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{CPX})
   ! Set the diagonal of "self" to th diagonal vector "d"
      d :: VEC{CPX}
   end

   set_diagonal_to(d) ::: get_from(MAT{INTRINSIC}, D_TYPE=>VEC{REAL})
   ! Set the diagonal of "self" to th diagonal vector "d"
      d :: VEC{REAL}
   end

   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>CPX)
   ! Set the diagonal of "self" to "val"
      val :: CPX
   end

   set_diagonal_to(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>REAL)
   ! Set the diagonal of "self" to "val"
      val :: REAL
   end

   put_diagonal_to(d) ::: get_from(MAT{INTRINSIC})
   ! Get the diagonal elements of "self" in vector "d"
      d :: VEC{CPX}
   end

   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>CPX)
   ! Add "val" to the diagonal of "self"
      val :: CPX
   end

   increment_diagonal_by(val) ::: get_from(MAT{INTRINSIC}, VAL_TYPE=>REAL)
   ! Add "val" to the diagonal of "self"
      val :: REAL
   end

   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>CPX)
   ! Weight the diagonal elements of "self" by "fac"
      fac :: CPX, IN
   end

   scale_diagonal_by(fac) ::: get_from(MAT{INTRINSIC}, FAC_TYPE=>REAL)
   ! Weight the diagonal elements of "self" by "fac"
      fac :: REAL, IN
   end

   zero_diagonal ::: get_from(MAT{INTRINSIC})
   ! Zero the diagonal elements of "self"
   ENSURE(.is_square,"non-square matrix")
   end

   zero_off_diagonal ::: get_from(MAT{INTRINSIC})
   ! Zero the off diagonal elements of "self"
   ENSURE(.is_square,"non-square matrix")
   end

   max_abs_diagonal_element result (res) ::: get_from(MAT{INTRINSIC})
   ! Get the maximum absolute value of the diagonal elements of the self matrix
      res :: REAL
   end

! ************************
! Symmetrising and folding
! ************************

   symmetrize ::: get_from(MAT{INTRINSIC})
   ! Set self to half of itself plus half its transpose, i.e.
   ! self = 1/2 (self + self^T)
   ENSURE(.is_square,"non-square matrix")
   end

   antisymmetrize ::: get_from(MAT{INTRINSIC})
   ! Set self to half of itself minus half its transpose, i.e.
   ! self = 1/2 (self - self^T)
   ENSURE(.is_square,"non-square matrix")
   end

   symmetric_fold ::: get_from(MAT{INTRINSIC})
   ! Add the upper triangle of "self" into the lower triangle
   end

   antisymmetric_fold ::: get_from(MAT{INTRINSIC})
   ! Subtract the upper triangle of "self" into the lower triangle
   end

   symmetric_reflect ::: get_from(MAT{INTRINSIC})
   ! Make the upper triangle of "self" the same as the lower triangle
   end

   antisymmetric_reflect ::: get_from(MAT{INTRINSIC})
   ! Make the upper triangle of "self" the negative of the lower triangle and
   ! make the diagonal zero.
   end

   symmetric_fold_to_triangle(tr) ::: get_from(MAT{INTRINSIC})
   ! Add the upper triangle of "self" into the lower triangle and return
   ! the lower triangle "tr" as a vector across rows.
      tr :: VEC{CPX}
   end

   hermitianize
   ! Set self to half of itself plus half its dagger, i.e.
   ! self = 1/2 (self + self^dagger)
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      val :: CPX
      do i = 1,.dim1
         do j = 1,i
            val = HALF*(self(i,j)+conjg(self(j,i)))
            self(i,j) = val
            self(j,i) = conjg(val)
         end
      end
   end

   antihermitianize
   ! Set self to half of itself minus half its dagger, i.e.
   ! self = 1/2 (self - self^dagger)
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      val :: CPX
      do i = 1,.dim1
         do j = 1,i
            val = HALF*(self(i,j)-conjg(self(j,i)))
            self(i,j) =  val
            self(j,i) = -conjg(val)
         end
      end
   end

   hermitian_fold
   ! Add the hermitian conjugate of the upper half of the matrix into its lower
   ! half, and make the diagonal real.
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(i,j) = self(i,j) + conjg(self(j,i))
         end
         self(i,i) = real(self(i,i),kind=REAL_KIND)
      end
   end

   antihermitian_fold
   ! Subtract the hermitian conjugate of the upper half of the matrix into its
   ! lower half, and make the diagonal complex
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i
            self(i,j) = self(i,j)-conjg(self(j,i))
         end
         self(i,i) = HALF*self(i,i)
      end
   end

   make_hermitian
   ! Make the upper half of self hermitian with respect to the lower half
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = conjg(self(i,j))
         end
      end
      do i = 1,.dim1
         self(i,i) = real(self(i,i),kind=REAL_KIND)
      end
   end

   hermitian_reflect
   ! Make the upper half of self hermitian with respect
   ! to the lower half
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = conjg(self(i,j))
         end
      end
      do i = 1,.dim1
         self(i,i) = real(self(i,i),kind=REAL_KIND)
      end
   end

   make_antihermitian
   ! Make the upper half of self anti-hermitian with respect
   ! to the lower half
   ENSURE(.is_square,"non-square matrix")
      i,j :: INT
      do i = 1,.dim1
         do j = 1,i-1
            self(j,i) = -conjg(self(i,j))
         end
      end
      do i = 1,.dim1
         self(i,i) = HALF*(self(i,i)-conjg(self(i,i)))
      end
   end

   antihermitian_reflect
   ! Make the upper half of self anti-hermitian with respect
   ! to the lower half
   ENSURE(.is_square,"non-square matrix")
      dim1,i,j :: INT
      dim1 = .dim1
      do i = 1,dim1
         do j = 1,i-1
            self(j,i) = -conjg(self(i,j))
         end
      end
      do i = 1,.dim1
         self(i,i) = HALF*(self(i,i)-conjg(self(i,i)))
      end
   end

! **************************************
! Compression and uncompression routines
! **************************************

   compress_to_square(sq)
   ! Compresses the hermitian matrix self to vector "sq". First comes the
   ! lower half of the real part, then lower half of the imaginary part.
      self :: IN
      sq :: VEC{REAL}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(sq.dim>=self.dim,"sq array too small")
      i,j,ij :: INT
      ij = 0
      do i = 1,.dim1
         do j = 1,i
            sq(ij+j) = real(self(i,j),kind=REAL_KIND)
         end
         ij = ij+i
      end
      do i = 1,.dim1
         do j = 1,i-1
            sq(ij+j) = aimag(self(i,j))
         end
         ij = ij+i-1
      end
   end

   uncompress_from_square(sq)
   ! Uncompress the vector "sq" to a hermitian matrix assuming the lower half
   ! of the real part comes first, then the lower half of the imaginary part.
      sq :: VEC{REAL}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(sq.dim>=self.dim,"sq array too small")
      i,j,ij :: INT
      ij = 0
      do i = 1,.dim1
         do j = 1,i
            self(i,j) = sq(ij+j)
            self(j,i) = sq(ij+j)
         end
         ij = ij+i
      end
      do i = 1,.dim1
         do j = 1,i-1
            self(i,j) = self(i,j) + cmplx(ZERO,sq(ij+j),kind=CPX_KIND)
            self(j,i) = self(j,i) - cmplx(ZERO,sq(ij+j),kind=CPX_KIND)
         end
         ij = ij+i-1
      end
   end

   compress_to_triangle(tr) ::: get_from(MAT{INTRINSIC})
   ! Converts the lower triangle of matrix self to the triangle "tr".
   ! using row order.
   end

   uncompress_from_triangle(tr)
   ! Converts the triangle "tr" into the hermitian matrix "self".
   ! WARNING: won't work for symmetric matrices
      tr :: VEC{CPX}
   ENSURE(.is_square,"non-square matrix")
   ENSURE(tr.dim>=.tri_size,"tr array too small")
      i,j,ij :: INT
      ij = 0
      do i = 1,.dim1
         do j = 1,i
            self(i,j) =       tr(ij+j)
            self(j,i) = conjg(tr(ij+j))
         end
         ij = ij+i
      end
   end

   tri_size result (ltr) ::: get_from(MAT{INTRINSIC})
   ! Returns the size of the lower triangle needed to store self.
   end

! *****************
! Orthogonalisation
! *****************

   schmidt_orthonormalise(S,scale) ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric. If "scale" is present, it is set to the product of the
   ! normalisation factors used to normalise each column after the Schmidt
   ! procedure.
     self :: target
     S :: MAT{REAL}, IN
     scale :: REAL, optional
   end

   reverse_schmidt_orthonormalise(S) ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" using "S" as the
   ! metric.
     self :: target
     S :: MAT{REAL}
   end

   schmidt_orthonormalise ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self".
     self :: target
   end

   reverse_schmidt_orthogonalise ::: get_from(MAT{INTRINSIC})
   ! Schmidt orthonormalise the column vectors in "self" using unit metric.
      self :: target
   end

   symmetrically_orthonormalise(S) ::: get_from(MAT{INTRINSIC})
   ! Symmetrically orthonormalise the column vectors in "self" using "S" as the
   ! metric.
     S :: MAT{REAL}, IN
   end

   make_diagonally_dominant(permutation) ::: get_from(MAT{INTRINSIC})
   ! Rearrange the order of the columns of self so that the largest magnitude
   ! elements in each column occur along the diagonal. If "permutation" is
   ! present, it is the array which achieves this ordering, i.e. at the end of
   ! the routine, what is done is: self = self(:,permutation).
      permutation :: VEC{INT}, optional
   end

! *********************
! Eigenproblem routines
! *********************

   solve_eigenproblem(eigenvalues,eigenvectors,routine)
   ! Solve the hermitian eigenvalue problem for self
      eigenvalues :: VEC{REAL}
      eigenvectors :: MAT{CPX}
      routine :: STR, optional
#ifdef ESSL
      .solve_eigenproblem_ESSL(eigenvalues,eigenvectors,routine)
#else
      .solve_eigenproblem_LAPACK(eigenvalues,eigenvectors,routine)
#endif
   end

   solve_eigenproblem_ESSL(eigenvalues,eigenvectors,routine) ::: private
   ! Solve the hermitian eigenvalue problem for self. ESSL version.
      eigenvalues :: VEC{REAL}
      eigenvectors :: MAT{CPX}
      routine :: STR, optional
   ENSURE(.is_square,"non-square matrix")
   ENSURE(eigenvalues.dim>=.dim1,"supplied eigenvalue array too small")
   ENSURE(eigenvectors.dim>=self.dim,"supplied eigenvector array too small")
   ENSURE(NOT present(routine),"routine specifier not allowed in ESSL version")
      ap :: VEC{CPX}*
      RW :: VEC{REAL}*
      dim :: INT
      dim = .dim1
      ap.create(dim*(dim+1)/2)
      self.compress_to_triangle(ap)
      RW.create(4*dim)
#ifdef ESSL
      call zhpev(21,ap,eigenvalues,eigenvectors,dim,dim,RW,4*dim)
#endif
      RW.destroy
      ap.destroy
   end

   solve_eigenproblem_LAPACK(eigenvalues,eigenvectors,routine) ::: private
   ! Solve the hermitian eigenvalue problem for self. LAPACK version.
      eigenvalues :: VEC{REAL}
      eigenvectors :: MAT{CPX}
      routine :: STR, optional
   ENSURE(.is_square,"non-square matrix")
   ENSURE(eigenvalues.dim>=.dim1,"supplied eigenvalue array too small")
   ENSURE(eigenvectors.dim>=self.dim,"supplied eigenvector array too small")
      rout :: STR
      ap,W :: VEC{CPX}*
      RW :: VEC{REAL}*
      dim,fail,info :: INT
      rout = "zheev"
      if (present(routine)) rout = routine
      dim = .dim1
      select case (rout)
        case ("zheev")
          W.create(dim*dim)
          RW.create(3*dim)
          eigenvectors.set_to(self)
          fail = 0
#ifndef ESSL
          call zheev("V","L",dim,eigenvectors,dim,eigenvalues,W,dim*dim,RW,fail)
#endif
          RW.destroy
          W.destroy
        case ("zhpev")
          ap.create(dim*(dim+1)/2)
          self.compress_to_triangle(ap)
          W.create(2*dim)
          RW.create(3*dim)
#ifndef ESSL
          call zhpev("V","U",dim,ap,eigenvalues,eigenvectors,dim,W,RW,info)
#endif
          RW.destroy
          W.destroy
          ap.destroy
      end
   end

! These next few commented routines are unused ESSL routines.

!   solve_general_eigenproblem(eigenvalues,eigenvectors)
!   ! Solve the eigenproblem for "self", yeilding a vector of "eigenvalues" and
!   ! a matrix of "eigenvectors"
!      eigenvalues :: VEC{CPX}
!      eigenvectors :: MAT{CPX}
!       W :: VEC{REAL}*
!      dim1,dim2,dime,dimv :: INT
!      select :: BIN
!      dim1 = .dim1
!      dim2 = .dim2
!      dime = size(eigenvalues)
!      dimv = size(eigenvectors)
!      ENSURE(dim1==dim2,"non-square matrix")
!      ENSURE(dime>=dim1,"supplied eigenvalue array too small")
!      ENSURE(dimv>=dim1*dim1,"supplied eigenvector matrix too small")
!      W.create(3*dim1)
!      call zgeev(1,self,dim1,eigenvalues,eigenvectors,dim1,select,dim1,W,3*dim1)
!      W.destroy
!   end
!
!   solve_linear_equations(rhs,solution)
!   ! Solve the linear equations posed by "self", with "rhs" as the RHS vector,
!   ! yeilding vector "solution" as the answer
!      rhs, solution :: VEC{CPX}
!      err,nrhs :: INT
!      LU :: MAT{CPX}*
!      pivot :: VEC{INT}*
!      dim,dim1,dim2 :: INT
!      dim1 = .dim1
!      dim2 = .dim2
!      ENSURE(dim1==dim2,"non-square matrix")
!      dim = size(rhs)
!      ENSURE(dim==dim1,"incompatible rhs")
!      nrhs = 1
!      LU.create(dim,dim)
!      pivot.create(dim)
!      LU = self
!      solution = rhs
!      call zgef(LU,dim,dim,pivot)
!      call zges(LU,dim,dim,pivot,solution,0)
!      pivot.destroy
!      LU.destroy
!   end
!
!   solve_linear_equations(rhs,solution)
!   ! Solve the linear equations posed by "self", with "rhs" as a matrix of RHS vectors,
!   ! yeilding matrix "solution" as a matrix of solution vectors.
!      rhs, solution :: MAT{CPX}
!      err,nrhs :: INT
!      LU :: MAT{CPX}*
!      pivot :: VEC{INT}*
!      dim1,dim2 :: INT
!      dim1 = .dim1
!      dim2 = .dim2
!      ENSURE(dim1==dim2,"non-square matrix")
!      dim1 = size(rhs,1)
!      nrhs = size(rhs,2)
!      ENSURE(dim1==dim2,"rhs incompatible with coefficient matrix")
!      ENSURE(nrhs>0,"no rhs vectors")
!      LU.create(dim1,dim1)
!      pivot.create(dim1)
!      LU = self
!      solution = rhs
!      call zgef(LU,dim1,dim1,pivot)
!      call zgesm("N",LU,dim1,dim1,pivot,solution,dim1,nrhs)
!      pivot.destroy
!      LU.destroy
!   end

! **********************************************************
! Matrix functions: square roots, inverses, and exponentials
! **********************************************************

   to_sqrt_of(R) ::: get_from(MAT{INTRINSIC})
   ! self = sqrt(R), cannot have R=self
      R :: MAT{CPX}
   end

   to_inverse_sqrt_of(R) ::: get_from(MAT{INTRINSIC})
   ! self = sqrt(R)^(-1), cannot have R=self
      R :: MAT{CPX}
   end

   to_power_series_inverse_of(S,tol,max_it) ::: get_from(MAT{INTRINSIC})
   ! Set self to the power series inverse square root of "S".
   ! If "tol" is present, make sure that the maximum deviation from the exact
   ! answer is less than "tol" times the smallest element of "S". If "max_it"
   ! is present, use this as the maximum number of terms in the power series,
   ! before termination with an error.
      S :: MAT{CPX}
      tol :: REAL, optional
      max_it :: INT, optional
   end

   to_power_series_inv_sqrt_of(S,tol,prefactor,max_it) ::: get_from(MAT{INTRINSIC})
   ! Set self to the inverse square root of "S", a matrix which is required to
   ! have a unit diagonal. The method uses a binomial power series expansion.
   ! If "tol" is present, make sure that the maximum deviation from the exact
   ! answer is less than "tol" times the smallest element of "S". If "max_it"
   ! is present, use this as the maximum number of terms in the power series,
   ! before termination with an error.
      S :: MAT{CPX}
      tol,prefactor :: REAL, optional
      max_it :: INT, optional
   end

   to_exponential_of(X,tol) ::: get_from(MAT{INTRINSIC})
   ! Exponentiate the matrix "X" using a power series expansion, self = exp(X),
      X :: MAT{CPX}
      tol :: REAL, optional
   end

   exponentiate_to(U,tol) ::: get_from(MAT{INTRINSIC})
   ! Exponentiate the matrix self using a power series expansion, U = exp(self),
   ! so that the maximum deviation from the exact answer is less than "tol"
   ! if present. 
   end

   antisymmetric_exponential_to(U,eval,evec) ::: get_from(MAT{INTRINSIC})
   ! Make unitary matrix U = exp(self) where "self" must be antisymmetric.
   ! Uses the formula:  exp A = V (cos P) V^t + V (sin P)/P V^t A
   !                        P = sqrt diag(eig(A^t A))
   ! (c) dylan jayatilaka, university of western australia, 1993
   ! WARNING: Untested in TONTO and looks wrong.
      U :: MAT{CPX}
      evec :: MAT{CPX}*, optional
      eval :: VEC{REAL}*, optional
   end

!  ***********************
!  Spin-orbital operations
!  ***********************

!  Block returning routines

   alpha_alpha result (res) ::: get_from(MAT{INTRINSIC})
   ! return the alpha-alpha sector of the matrix
      self :: target
      res :: MAT{CPX}*
   end

   beta_alpha result (res) ::: get_from(MAT{INTRINSIC})
   ! return the beta-alpha sector of the matrix
      self :: target
      res :: MAT{CPX}*
   end

   alpha_beta result (res) ::: get_from(MAT{INTRINSIC})
   ! return the alpha-beta sector of the matrix
      self :: target
      res :: MAT{CPX}*
   end

   beta_beta result (res) ::: get_from(MAT{INTRINSIC})
   ! return the beta-beta sector of the matrix
      self :: target
      res :: MAT{CPX}*
   end

!  Set_to routines

   alpha_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Set the alpha-alpha sector of the matrix to "X"
      X :: MAT{CPX}, IN
   end

   alpha_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Set the alpha-alpha sector of the matrix to "X"
      X :: MAT{REAL}, IN
   end

   alpha_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Set the alpha-alpha sector of the matrix to "X"
      X :: MAT{CPX}, IN
      factor :: CPX, IN
   end

   alpha_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Set the alpha-alpha sector of the matrix to "X"
      X :: MAT{CPX}, IN
      factor :: REAL, IN
   end

   alpha_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Set the alpha-alpha sector of the matrix to "X"
      X :: MAT{REAL}, IN
      factor :: CPX, IN
   end

   alpha_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Set the alpha-alpha sector of the matrix to "X"
      X :: MAT{REAL}, IN
      factor :: REAL, IN
   end

   beta_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Set the beta-alpha sector of the matrix to "X"
      X :: MAT{CPX}, IN
   end

   beta_alpha_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Set the beta-alpha sector of the matrix to "X"
      X :: MAT{REAL}, IN
   end

   beta_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Set the beta-alpha sector of the matrix to "X"
      X :: MAT{CPX}, IN
      factor :: CPX, IN
   end

   beta_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Set the beta-alpha sector of the matrix to "X"
      X :: MAT{CPX}, IN
      factor :: REAL, IN
   end

   beta_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Set the beta-alpha sector of the matrix to "X"
      X :: MAT{REAL}, IN
      factor :: CPX, IN
   end

   beta_alpha_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Set the beta-alpha sector of the matrix to "X"
      X :: MAT{REAL}, IN
      factor :: REAL, IN
   end

   alpha_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Set the alpha-beta sector of the matrix to "X"
      X :: MAT{CPX}, IN
   end

   alpha_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Set the alpha-beta sector of the matrix to "X"
      X :: MAT{REAL}, IN
   end

   alpha_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Set the alpha-beta sector of the matrix to "X"
      X :: MAT{CPX}, IN
      factor :: CPX, IN
   end

   alpha_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Set the alpha-beta sector of the matrix to "X"
      X :: MAT{CPX}, IN
      factor :: REAL, IN
   end

   alpha_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Set the alpha-beta sector of the matrix to "X"
      X :: MAT{REAL}, IN
      factor :: CPX, IN
   end

   alpha_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Set the alpha-beta sector of the matrix to "X"
      X :: MAT{REAL}, IN
      factor :: REAL, IN
   end

   beta_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Set the beta-beta sector of the matrix to "X"
      X :: MAT{CPX}, IN
   end

   beta_beta_set_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Set the beta-beta sector of the matrix to "X"
      X :: MAT{REAL}, IN
   end

   beta_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Set the beta-beta sector of the matrix to "X"
      X :: MAT{CPX}, IN
      factor :: CPX, IN
   end

   beta_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Set the beta-beta sector of the matrix to "X"
      X :: MAT{CPX}, IN
      factor :: REAL, IN
   end

   beta_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Set the beta-beta sector of the matrix to "X"
      X :: MAT{REAL}, IN
      factor :: CPX, IN
   end

   beta_beta_set_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Set the beta-beta sector of the matrix to "X"
      X :: MAT{REAL}, IN
      factor :: REAL, IN
   end

!  Put_to routines

   alpha_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Put the alpha-alpha sector of the matrix to "X"
      X :: MAT{CPX}, OUT
   end

   alpha_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Put the alpha-alpha sector of the matrix to "X"
      X :: MAT{REAL}, OUT
   end

   alpha_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Put the alpha-alpha sector of the matrix to "X"
      X :: MAT{CPX}, OUT
      factor :: CPX
   end

   alpha_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Put the alpha-alpha sector of the matrix to "X"
      X :: MAT{CPX}, OUT
      factor :: REAL
   end

   alpha_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Put the alpha-alpha sector of the matrix to "X"
      X :: MAT{REAL}, OUT
      factor :: CPX
   end

   alpha_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Put the alpha-alpha sector of the matrix to "X"
      X :: MAT{REAL}, OUT
      factor :: REAL
   end

   beta_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Put the beta-alpha sector of the matrix to "X"
      X :: MAT{CPX}, OUT
   end

   beta_alpha_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Put the beta-alpha sector of the matrix to "X"
      X :: MAT{REAL}, OUT
   end

   beta_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Put the beta-alpha sector of the matrix to "X"
      X :: MAT{CPX}, OUT
      factor :: CPX, IN
   end

   beta_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Put the beta-alpha sector of the matrix to "X"
      X :: MAT{CPX}, OUT
      factor :: REAL, IN
   end

   beta_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Put the beta-alpha sector of the matrix to "X"
      X :: MAT{REAL}, OUT
      factor :: CPX, IN
   end

   beta_alpha_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Put the beta-alpha sector of the matrix to "X"
      X :: MAT{REAL}, OUT
      factor :: REAL, IN
   end

   alpha_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Put the alpha-beta sector of the matrix to "X"
      X :: MAT{CPX}, OUT
   end

   alpha_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Put the alpha-beta sector of the matrix to "X"
      X :: MAT{REAL}, OUT
   end

   alpha_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Put the alpha-beta sector of the matrix to "X"
      X :: MAT{CPX}, OUT
      factor :: CPX, IN
   end

   alpha_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Put the alpha-beta sector of the matrix to "X"
      X :: MAT{CPX}, OUT
      factor :: REAL, IN
   end

   alpha_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Put the alpha-beta sector of the matrix to "X"
      X :: MAT{REAL}, OUT
      factor :: CPX, IN
   end

   alpha_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Put the alpha-beta sector of the matrix to "X"
      X :: MAT{REAL}, OUT
      factor :: REAL, IN
   end

   beta_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Put the beta-beta sector of the matrix to "X"
      X :: MAT{CPX}, OUT
   end

   beta_beta_put_to(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Put the beta-beta sector of the matrix to "X"
      X :: MAT{REAL}, OUT
   end

   beta_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Put the beta-beta sector of the matrix to "X"
      X :: MAT{CPX}, OUT
      factor :: CPX, IN
   end

   beta_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Put the beta-beta sector of the matrix to "X"
      X :: MAT{CPX}, OUT
      factor :: REAL, IN
   end

   beta_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Put the beta-beta sector of the matrix to "X"
      X :: MAT{REAL}, OUT
      factor :: CPX, IN
   end

   beta_beta_put_to(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Put the beta-beta sector of the matrix to "X"
      X :: MAT{REAL}, OUT
      factor :: REAL, IN
   end

!  plus routines

   alpha_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Add "X" to the alpha-alpha sector of the matrix
      X :: MAT{CPX}, IN
   end

   alpha_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Add "X" to the alpha-alpha sector of the matrix
      X :: MAT{REAL}, IN
   end

   alpha_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Add "X" to the alpha-alpha sector of the matrix
      X :: MAT{CPX}, IN
      factor :: CPX, IN
   end

   alpha_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Add "X" to the alpha-alpha sector of the matrix
      X :: MAT{CPX}, IN
      factor :: REAL, IN
   end

   alpha_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Add "X" to the alpha-alpha sector of the matrix
      X :: MAT{REAL}, IN
      factor :: CPX, IN
   end

   alpha_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Add "X" to the alpha-alpha sector of the matrix
      X :: MAT{REAL}, IN
      factor :: REAL, IN
   end

   beta_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Add "X" to the beta-alpha sector of the matrix
      X :: MAT{CPX}, IN
   end

   beta_alpha_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Add "X" to the beta-alpha sector of the matrix
      X :: MAT{REAL}, IN
   end

   beta_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Add "X" to the beta-alpha sector of the matrix
      X :: MAT{CPX}, IN
      factor :: CPX, IN
   end

   beta_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Add "X" to the beta-alpha sector of the matrix
      X :: MAT{CPX}, IN
      factor :: REAL, IN
   end

   beta_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Add "X" to the beta-alpha sector of the matrix
      X :: MAT{REAL}, IN
      factor :: CPX, IN
   end

   beta_alpha_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Add "X" to the beta-alpha sector of the matrix
      X :: MAT{REAL}, IN
      factor :: REAL, IN
   end

   alpha_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Add "X" to the alpha-beta sector of the matrix
      X :: MAT{CPX}, IN
   end

   alpha_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Add "X" to the alpha-beta sector of the matrix
      X :: MAT{REAL}, IN
   end

   alpha_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Add "X" to the alpha-beta sector of the matrix
      X :: MAT{CPX}, IN
      factor :: CPX, IN
   end

   alpha_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Add "X" to the alpha-beta sector of the matrix
      X :: MAT{CPX}, IN
      factor :: REAL, IN
   end

   alpha_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Add "X" to the alpha-beta sector of the matrix
      X :: MAT{REAL}, IN
      factor :: CPX, IN
   end

   alpha_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Add "X" to the alpha-beta sector of the matrix
      X :: MAT{REAL}, IN
      factor :: REAL, IN
   end

   beta_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX})
   ! Add "X" to the beta-beta sector of the matrix
      X :: MAT{CPX}, IN
   end

   beta_beta_plus(X) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL})
   ! Add "X" to the beta-beta sector of the matrix
      X :: MAT{REAL}, IN
   end

   beta_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>CPX)
   ! Add "X" to the beta-beta sector of the matrix
      X :: MAT{CPX}, IN
      factor :: CPX, IN
   end

   beta_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{CPX}, FACTOR_TYPE=>REAL)
   ! Add "X" to the beta-beta sector of the matrix
      X :: MAT{CPX}, IN
      factor :: REAL, IN
   end

   beta_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>CPX)
   ! Add "X" to the beta-beta sector of the matrix
      X :: MAT{REAL}, IN
      factor :: CPX, IN
   end

   beta_beta_plus(X,factor) ::: get_from(MAT{INTRINSIC}, X_TYPE=>MAT{REAL}, FACTOR_TYPE=>REAL)
   ! Add "X" to the beta-beta sector of the matrix
      X :: MAT{REAL}, IN
      factor :: REAL, IN
   end

end
