! $Id$
!---------------------------------------------------------------------------
!
!  OUTPUT: Line oriented formatted advancing sequential file output,
!  including operations to stdout.
!
!  The output object is a file label with a buffer and formatting object. 
!  The output object can be used for pretty output in columns 
!  of a specified width, with double precision  numbers having a specified 
!  precision and "style" (set using fortran conventions).
!  A line count is maintained to allow back-tracking and overwriting
!  previous lines.
!
!  (c) dylan jayatilaka, daniel grimwood, 1998
!
!---------------------------------------------------------------------------
module OUTPUT

   use TYPES
   use SYSTEM
   use STR
   use INT
   use BUFFER
   use UNITNUMBER
   use INPUT

   implicit none         

#  include "macros"
#  include "output.int"

!  type output_type
!     INT :: unit      ! This is a FILE
!     INT :: record     
!     INT :: io_status  
!     STR :: name       
!     INT :: fields    ! This is a DBLFMT
!     INT :: dbl_width     
!     INT :: dbl_precision 
!     STR :: dbl_style     
!     INT :: margin    ! These are new
!     BIN :: labels    
!     BUFFER :: buffer
!  end 
  
   OUTPUT, PTR, public :: std_output DEFAULT_NULL

   interface put
      put_str, put_int, put_bin, put_dbl, put_cdbl
      put_ivec, put_strvec, put_vec, put_cvec 
      put_imat, put_mat, put_mat3, put_mat4,
      put_cmat, put_cmat3, put_cmat4, put_cmat5
      put_gaussian, put_gaussian2, put_opvec, put_opmat
   end
  
   interface show
      show_str, show_int, show_bin, show_dbl_1, show_dbl_3, show_vec
   end
  
contains
      
!  *****************************
!  File creation type operations
!  *****************************

   create_std_output
   ! Create a standard output file object.
   ! Return a pointer to it if already created
      PTR :: self
      if (std_output.destroyed) then
         allocate(std_output)
         ADD_MEM(OUTPUT_SIZE)
         std_output%name = "std_output"
         std_output%record = 1
         std_output%unit = OUTPUT_STD_OUTPUT_UNIT
         std_output%io_status = 0
         std_output.set_default_format
      end
      std_output%buffer.clear
      std_output.put_margin
      self => std_output
   end

   create(name) 
   ! Create a output file object. This does not open the file.
      PTR :: self
      CHR(*) :: name
      UNITNUMBER :: unitnumber
      nullify(self)
      allocate(self)
      ADD_MEM(OUTPUT_SIZE)
      .name = name
      .record = 1
      .io_status = 0
      unitnumber.get( .unit)
      .set_default_format
      .buffer.clear
      .put_margin
   end

   destroy
   ! Destroy the file object
      PTR :: self
      UNITNUMBER :: unitnumber
      if (.destroyed) return
      unitnumber.free( .unit)
      DELETE_MEM(OUTPUT_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   open 
   ! Open the output file associated with the output object
      .system_update
      if (.file_exists) then
         open(unit=.unit,      &
              file=.name,      &
              status="old",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening old file"//.name)
      else
         open(unit=.unit,      &
              file=.name,      &
              status="new",        &
              access="sequential", &
              form="formatted",    &
              iostat=.io_status)
         DIE_IF(.io_status>0,"error opening new file"//.name)
      end
   end

   close
   ! Close the output file associated with the object
      .system_update
      close(unit=.unit)
      .system_done
   end

   close_and_delete
   ! Close and delete the output file associated with the output object
      .system_update
      close(unit=.unit,status="delete")
      .system_done
   end

   delete
   ! Delete the output file associated with the output object
      .system_update
      if (.file_is_not_open) .open
      .close_and_delete
      .system_done
   end

  read(in)
  ! Read defaults from the file "in"
    INPUT :: in
    STR :: word
    .system_update
    read_loop : do
      in.read(word); word.to_lower_case
      select case (word)
        case("labels");      in.read( .labels )
        case("margin");      in.read( .margin )
        case("fields");      in.read( .fields )
        case("width");       in.read( .dbl_width )
        case("precision");   in.read( .dbl_precision )
        case("dbl_style");   in.read( .dbl_style )
        case default;        DIE("unknown directive, "//word.trim)
      end
    end do read_loop
  end

!  ********************
!  Data output routines
!  ********************
   
   put_margin
   ! Put a margin into the buffer of the output object
      .system_update
      .buffer.put_str(repeat(" ",.margin))
   end

   flush
   ! Flush the buffer to the output file
      .system_update
      write(.unit,'(a)') trim( .buffer%buffer_str )
      .buffer.clear
      .put_margin
      .record = .record + 1
      .system_update
   end

   flush(times)
   ! Flush the buffer multiple times to get extra carriage returns
     INT :: times
     INT :: i
     .system_update
     do i=1,times
        .flush
     end
   end

   tab(dbl_fields,int_fields,bin_fields,width)
   ! Tab across the specified number of fields in the output buffer
   ! "dbl_fields", "int_fields" and "bin_fields" refer to the number of 
   ! dbl, integer and logical fields to tab; "width" is the width of spaces
   ! to tab.
      INT, optional :: dbl_fields,int_fields,bin_fields,width
      .system_update
      if (present(dbl_fields)) &
         .buffer.put_str(repeat(repeat(" ",.dbl_width),dbl_fields)) 
      if (present(int_fields)) &
         .buffer.put_str(repeat(repeat(" ",.int_width),int_fields)) 
      if (present(bin_fields)) &
         .buffer.put_str(repeat(repeat(" ",.int_width),bin_fields)) 
      if (present(width)) &
         .buffer.put_str(repeat(" ",width)) 
   end
     
   dash(dbl_fields,int_fields,bin_fields,width)
   ! Put a dashed line into the buffer. "dbl_fields", "int_fields" and 
   ! "bin_fields" refer to the number of dbl, integer and logical fields 
   ! to draw the line over; "width" is the width of characters to draw the dashed line
      INT, optional :: dbl_fields,int_fields,bin_fields,width
      .system_update
      .put_dash(dbl_fields,int_fields,bin_fields,width,flush=1)
   end

   put_dash(dbl_fields,int_fields,bin_fields,width,flush)
   ! Put a dashed line into the buffer. "dbl_fields", "int_fields" and 
   ! "bin_fields" refer to the number of dbl, integer and logical fields 
   ! to draw the line over; "width" is the width of characters to draw the dashed line
      INT, optional :: dbl_fields,int_fields,bin_fields,width,flush
      .system_update
      if (present(dbl_fields)) &
         .buffer.put_str(repeat(repeat("-",.dbl_width),dbl_fields)) 
      if (present(int_fields)) &
         .buffer.put_str(repeat(repeat("-",.int_width),int_fields)) 
      if (present(bin_fields)) &
         .buffer.put_str(repeat(repeat("-",.int_width),bin_fields)) 
      if (present(width)) &
         .buffer.put_str(repeat("-",width)) 
      if (present(flush)) .flush(flush)
   end
 
   show_str(pretext,string,int_width)
   ! Put a formatted STR into the output buffer with descriptive "pretext"
      CHR(*) :: pretext
      CHR(*) :: string
      BIN, optional :: int_width
      .system_update
      .put_text(pretext)
      .put_str(string,int_width,flush=1)
   end
 
   show_int(pretext,value,dbl_width) 
   ! Put a formatted INT into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      BIN, optional :: dbl_width
      INT :: value
      .system_update
      .put_text(pretext)
      .put(value,dbl_width,flush=1)
   end
 
   show_bin(pretext,value,dbl_width)
   ! Put a formatted BIN into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      BIN, optional :: dbl_width
      BIN :: value
      .system_update
      .put_text(pretext)
      .put(value,dbl_width,flush=1)
   end
 
   show_dbl_1(pretext,value)
   ! Put a formatted DBL into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      DBL :: value
      .system_update
      .put_text(pretext)
      .put(value,flush=1)
   end
 
   show_dbl_3(pretext,val1,val2,val3)
   ! Put a formatted DBL's into the output buffer with descriptive "pretext".
      CHR(*) :: pretext
      DBL :: val1,val2,val3
      .system_update
      .put_text(pretext)
      .put(val1)
      .put(val2)
      .put(val3,flush=1)
   end
 
   show_vec(pretext,value)
   ! Put a formatted DBL "value" into the output buffer with descriptive "pretext"
      CHR(*) :: pretext
      VEC :: value
      BIN :: labels
      .system_update
      .put_text(pretext)
      labels = .labels
      .set_labels(FALSE) 
      .put(value)
      .set_labels(labels)
      .flush
   end

   text(string,dbl_width,int_width,flush)
   ! Put text into the output buffer as is and flush,
   ! unless an explicit flush is present
      CHR(*) :: string
      BIN, optional :: dbl_width,int_width
      INT, optional :: flush
      .system_update
      if (present(flush)) then
         .put_text(string,dbl_width,int_width,flush)
      else
         .put_text(string,dbl_width,int_width,flush=1)
      end
   end

   put_text(string,dbl_width,int_width,flush)
   ! Put text into the output buffer as is.
      CHR(*) :: string
      BIN, optional :: dbl_width,int_width
      INT, optional :: flush
      CHR( .int_width ) :: int_string
      CHR( .dbl_width ) :: dbl_string
      .system_update
      if (present(dbl_width) AND (len(string) <= .dbl_width )) then
        dbl_string = string
        .buffer.put_str( dbl_string ) 
      else if (present(int_width) AND (len(string) <= .int_width )) then
        int_string = string
        .buffer.put_str( int_string ) 
      else
        .buffer.put_str( string ) 
      end
      if (present(flush)) .flush(flush)
   end
 
   put_str(string,int_width,flush)
   ! Put a formatted STR into the output buffer; if too big, put as is.
   ! if present and TRUE, "int_width" says to use field width of int_width
   ! if present, flush is how many times to flush the buffer. 
      CHR(*) :: string
      INT, optional :: flush
      BIN, optional :: int_width
      STR :: form
      INT :: wid
      .system_update
      wid = .dbl_width
      if (present(int_width)) wid = .int_width
      if (len_trim(string)>wid) then
         .buffer.put_str(trim(string)) 
      else if (len_trim(string)/=0) then
         form = "a" // trim( wid.to_str)
         .buffer.put_formatted_str(trim(string),form) 
      end
      if (present(flush)) .flush(flush)
   end

   put_unit(value,units)
   ! Put a formatted value and its units into the output buffer.
     INT, IN :: value
     STR, IN :: units
     STR :: form
     .system_update
     form=.format_int( .field_width(value) )
     .buffer.put_formatted_int(value,form) 
     .put_text( " " // units.trim)
     if (value /= 1) .put_text("s")
   end

   put_int(value,dbl_width,flush)
   ! Put a formatted integer into the output buffer; the field width used is int_width, 
   ! usually the length of the nondecimal part of a formatted DBL number.
   ! Can override the width and use dbl_width if "dbl_width" is set to TRUE
      INT :: value
      INT, optional :: flush
      BIN, optional :: dbl_width
      STR :: form
      .system_update
      form=.format_int( .int_width)
      if (present(dbl_width)) then
        if (dbl_width) form=.format_int( .dbl_width)
      end
      .buffer.put_formatted_int(value,form) 
      if (present(flush)) .flush(flush)
   end

   put_int_with_zeros(int,width,flush)
     INT, IN :: int, width
     INT, optional :: flush
     INT :: int_width
     STR :: form
     .system_update
     int_width = .field_width(int)
     if (int<0) then
       .buffer.put_str("-")
       form=.format_int(int_width-1)
     else
       form=.format_int(int_width)
     end
     .buffer.put_str(repeat("0",width-int_width)) 
     .buffer.put_formatted_int(abs(int),form)
     if (present(flush)) .flush(flush)
   end

   put_bin(value,dbl_width,flush)
   ! Put a formatted logical into the output buffer; can specify the width of
   ! the field if desired. Otherwise, the field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      BIN :: value
      INT, optional :: flush
      BIN, optional :: dbl_width
      STR :: form
      .system_update
      form=.format_bin( .int_width)
      if (present(dbl_width)) then
        if (dbl_width) form=.format_bin( .dbl_width)
      end
      .buffer.put_formatted_bin(value,form) 
     if (present(flush)) .flush(flush)
   end

   put_dbl(value,flush)
   ! Put a formatted DBL into the output buffer
   ! The field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      DBL :: value
      STR :: form
      INT, optional :: flush
      .system_update
      form=.format_dbl( .dbl_style, .dbl_width, .dbl_precision)
      .buffer.put_formatted_dbl(value,form) 
      if (present(flush)) .flush(flush)
   end
      
   put_cdbl(value,flush) 
   ! Put a formatted CDBL into the output buffer
   ! The field with used is int_width, or
   ! the length of the nondecimal part of a formatted DBL number
      CDBL :: value
      STR :: form
      INT, optional :: flush
      .system_update
      form=.format_dbl( .dbl_style, .dbl_width, .dbl_precision)
      .buffer.put_formatted_cdbl(value,form) 
      if (present(flush)) .flush(flush)
   end

   put_ivec(vec,format)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      .system_update
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_ivec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_ivec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_ivec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      INT :: dim,i
      .system_update
      dim = size(vec)
      do i = 1,dim
         if (.labels_used) then
            .put_int(i)
         end
         .put_int(vec(i),flush=1)
      end
   end

   put_ivec_by_row(vec)
   ! Put a formatted integer vector into the output buffer
      IVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      .system_update
      dim = size(vec)
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .put_int(i)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put_int(vec(i))
         end
         .flush
      end
   end

   put_strvec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      STRVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      .system_update
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_strvec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_strvec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_strvec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      STRVEC :: vec
      INT :: dim,i
      .system_update
      dim = size(vec)
      do i = 1,dim
         if (.labels_used) then
            .put_int(i)
         end
         .put(vec(i))
         .flush
      end
   end

   put_strvec_by_row(vec)
   ! Put a formatted string vector into the output buffer
      STRVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      .system_update
      dim = size(vec)
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(dbl_fields=1)
            do i = f,l
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(dbl_fields=1)
         end
         do i = f,l
            .put_str(vec(i))
         end
         .flush
      end
   end

   put_vec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      VEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      .system_update
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_vec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_vec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_vec_by_column(vec)
   ! Put a formatted integer vector into the output buffer
      VEC :: vec
      INT :: dim,i
      .system_update
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      do i = 1,dim
         if (.labels_used) then
!           .put_int(i,dbl_width=TRUE)
            .put_int(i)
         end
         .put(vec(i),flush=1)
      end
   end

   put_vec_by_row(vec)
   ! Put a formatted DBL vector into the output buffer
      VEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      .system_update
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      fields = .fields
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put(vec(i))
         end
         .flush
      end
   end

   put_cvec(vec,format)
   ! Put a formatted dbl vector into the output buffer
      CVEC :: vec
      CHR(*), optional :: format
      STR :: fmt
      .system_update
      fmt = "as_row"
      if (present(format)) fmt = format
      select case (fmt)
         case("as_row","by_row","row_wise","row")
            .put_cvec_by_row(vec)
         case("as_column","by_column","column_wise","column")
            .put_cvec_by_column(vec)
         case default
            DIE("unknown format, "// fmt.trim)
      end
   end

   put_cvec_by_column(vec)
   ! Put a formatted complex vector into the output buffer
      CVEC :: vec
      INT :: dim,i
      .system_update
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      do i = 1,dim
         if (.labels_used) then
            .put_int(i,dbl_width=TRUE)
         end
         .put(vec(i),flush=1)
      end
   end

   put_cvec_by_row(vec)
   ! Put a formatted DBL vector into the output buffer
      CVEC :: vec
      INT :: dim,block,nb,f,l,i,fields
      .system_update
      dim = size(vec)
      WARN_IF(dim==0,"zero length vector!")
      fields = .fields/2
      nb = (dim-0.1)/fields+1
      do block = 1,nb
         f = 1+fields*(block-1)
         l = min(f+fields-1,dim)
         if (block>1) .flush
         if (.labels_used) then
!           .tab(int_fields=1)
            do i = f,l
               .tab(dbl_fields=1)
               .put_int(i,dbl_width=TRUE)
            end
            .flush(2)
!           .tab(int_fields=1)
         end
         do i = f,l
            .put(vec(i))
         end
         .flush
      end
   end

   put_imat(mx,order)
   ! Put a formatted integer matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      IMAT :: mx
      CHR(*), optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      .system_update
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields
      if (NOT present(order)) then     ! formatted output
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .put_int(j)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put_int(mx(i,j))
               end
               .flush
            end
         end
      else                             ! unformatted output
         select case (order)
            case ("by_column","column_wise","transpose")
               do j = 1,dim2
               do i = 1,dim1
                  .put_int(mx(i,j))
                  if(mod(i,fields)==0) .flush
               end
               .flush
               end
            case ("by_row","row_wise","normal")
               do i = 1,dim1
               do j = 1,dim2
                  .put_int(mx(i,j))
                  if(mod(j,fields)==0) .flush
               end
               .flush
               end
         end
      end
   end

   put_mat(mx,order)
   ! Put a formatted DBL matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      MAT :: mx
      STR, optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      .system_update
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields
      if (NOT present(order)) then
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .put_int(j,dbl_width=TRUE)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put_dbl(mx(i,j))
               end
               .flush
            end
         end
      else
         select case (order)
            case ("by_column","column_wise","transpose")
               do j = 1,dim2
               do i = 1,dim1
                  .put_dbl(mx(i,j))
                  if(mod(i,fields)==0) .flush
               end
               .flush
               end
            case ("by_row","row_wise","normal")
               do i = 1,dim1
               do j = 1,dim2
                  .put_dbl(mx(i,j))
                  if(mod(j,fields)==0) .flush
               end
               .flush
               end
         end
      end
   end

   put_formatted_mat(mx,form)
   ! Put out a matrix suitable to be read in by other programs.
   ! Will overwrite the current buffer.
     MAT, IN :: mx
     CHR(*), IN :: form
     INT :: columns,first,last,i,j,nbasis,count,old_margin
     STR :: forma,formb
     .system_update

     i = form.scan("FfEe")
     form.get_next_item_position(first,last)
     DIE_IF( i==0, "incorrect format specification")
     forma=" "
     forma(1:i-first)=form(first:i-1)
     DIE_IF( forma.is_not_int, "incorrect format specification")
     columns = forma.to_int
     formb=" "
     formb(1:last-i+1) = form(i:last)

     .buffer%pos = 0
     .system_update
     old_margin = .margin
     .margin = 0
     nbasis=size(mx,1)
     count=0
     do i=1,nbasis
       do j=1,nbasis
         .buffer.put_formatted_dbl(mx(i,j), formb.trim) 
         count=count+1
         if (count==columns) then
           .flush
           count=0
         end
       end
     end
     if (NOT count == 0) .flush
     .margin = old_margin
   end

!   put_cadpac_guess(mx,n_occ)
!   ! Put out a matrix suitable for a GUESS = CARDS for cadpac.
!     MAT, IN :: mx
!     INT, IN :: n_occ
!     INT :: i,j,nbasis,count,margin
!     STR :: string
!
!     .buffer%pos = 0
!     .system_update
!     margin = .margin
!     .margin = 0
!     nbasis=size(mx,1)
!     count=0
!     do i=1,nbasis
!       do j=1,nbasis
!         .buffer.put_formatted_dbl(mx(i,j),"(F15.7)") 
!         count=count+1
!         if (count==5) then
!           .flush
!           count=0
!         end
!       end
!     end
!     .margin = margin
!   end

   put_cmat(mx,order)
   ! Put a formatted CDBL matrix into the output buffer
   ! If "order" is present use unformatted output suitable for ASCII archive
      CMAT :: mx
      CHR(*), optional :: order
      INT :: i,j,block,nb,f,l,dim1,dim2,fields
      .system_update
      dim1 = size(mx,1)
      dim2 = size(mx,2)
      WARN_IF(dim1==0,"zero sized 1st dimension!")
      WARN_IF(dim2==0,"zero sized 2nd dimension!")
      fields = .fields/2
      if (NOT present(order)) then
         nb = (dim2-0.1)/fields+1
         do block = 1,nb
            f = 1+fields*(block-1)
            l = min(f+fields-1,dim2)
            if (block>1) .flush
            if (.labels_used) then
               .tab(int_fields=1)
               do j = f,l
                  .tab(dbl_fields=1)
                  .put_int(j,dbl_width=TRUE)
               end
               .flush(2)
            end
            do i = 1,dim1
               if (.labels_used)     .put_int(i)
               if (.labels_not_used) .tab(int_fields=1)
               do j = f,l
                  .put(mx(i,j))
               end
               .flush
            end
         end
      else
         select case (order)
            case ("by_column","column_wise","transpose")
               do j = 1,dim2
               do i = 1,dim1
                  .put(mx(i,j))
                  if(mod(i,fields)==0) .flush
               end
               .flush
               end
            case ("by_row","row_wise","normal")
               do i = 1,dim1
               do j = 1,dim2
                  .put(mx(i,j))
                 if(mod(j,fields)==0) .flush
               end
               .flush
               end
         end
      end
   end

   put_mat3(mx)
   ! Put a MAT3 into the output buffer flat style
     MAT3 :: mx
     INT :: a,b,c,aub,bub,cub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           .put(a)
           .put(b)
           .put(c)
           .put_dbl(mx(a,b,c),flush=1)
         end
       end
     end
   end

   put_mat4(mx)
   ! Put a MAT4 into the output buffer flat style
     MAT4 :: mx
     INT :: a,b,c,d,aub,bub,cub,dub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             .put(a)
             .put(b)
             .put(c)
             .put(d)
             .put_dbl(mx(a,b,c,d),flush=1)
           end
         end
       end
     end
   end

   put_cmat3(mx)
   ! Put a MAT3 into the output buffer flat style
     CMAT3 :: mx
     INT :: a,b,c,aub,bub,cub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           .put(a)
           .put(b)
           .put(c)
           .put(mx(a,b,c),flush=1)
         end
       end
     end
   end

   put_cmat4(mx)
   ! Put a CMAT4 into the output buffer flat style
     CMAT4 :: mx
     INT :: a,b,c,d,aub,bub,cub,dub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     WARN_IF(aub==0,"zero sized 1st dimension!")
     WARN_IF(bub==0,"zero sized 2nd dimension!")
     WARN_IF(cub==0,"zero sized 3rd dimension!")
     WARN_IF(dub==0,"zero sized 4th dimension!")
     do a=1,aub
       do b=1,bub
         do c=1,cub
           do d=1,dub
             .put(a)
             .put(b)
             .put(c)
             .put(d)
             .put(mx(a,b,c,d),flush=1)
           end
         end
       end
     end
   end

   put_cmat5(mx)
   ! Put a CMAT5 into the output buffer flat style
     CMAT5 :: mx
     INT :: a,b,c,d,e,aub,bub,cub,dub,eub
     .system_update
     aub=size(mx,1)
     bub=size(mx,2)
     cub=size(mx,3)
     dub=size(mx,4)
     eub=size(mx,5)
     do a=1,aub
     do b=1,bub
     do c=1,cub
     do d=1,dub
     do e=1,eub
        .put(a)
        .put(b)
        .put(c)
        .put(d)
        .put(e)
        .put(mx(a,b,c,d,e),flush=1)
     end
     end
     end
     end
     end
   end

   put_gaussian(g)
   ! Output gaussian information
      GAUSSIAN :: g
      .system_update
      .flush
      .show("L quantum number = ",g%l)
      .show("Position         = ",g%pos(1),g%pos(2),g%pos(3))
      .show("Exponent         = ",g%ex)
   end

   put_gaussian2(g)
   ! Output gaussian information
      GAUSSIAN2 :: g
      .system_update
      .flush
      .put_text("Shell a:\n")
      .show("L quantum number = ",g%l_a)
      .show("Position         = ",g%pos_a(1),g%pos_a(2),g%pos_a(3))
      .show("Exponent         = ",g%ex_a)
      .put_text("Shell b:\n")
      .show("L quantum number = ",g%l_b)
      .show("Position         = ",g%pos_b(1),g%pos_b(2),g%pos_b(3))
      .show("Exponent         = ",g%ex_b)
   end

  put_opvec(vec,format)
  ! Outputs the opvec
    OPVEC, IN :: vec
    CHR(*), optional :: format
    .system_update
    if (associated(vec%restricted)) then
      .flush
      .put_text("restricted part:",flush=2)
      .put(vec%restricted,format)
    end
    if (associated(vec%alpha)) then
      .flush
      .put_text("alpha part:",flush=2)
      .put(vec%alpha,format)
    end
    if (associated(vec%beta)) then
      .flush
      .put_text("beta part:",flush=2)
      .put(vec%beta,format)
    end
    if (associated(vec%general)) then
      .flush
      .put_text("general part:",flush=2)
      .put(vec%general,format)
    end
  end

  put_opmat(mat,order)
  ! Outputs the opmat
    OPMAT, IN :: mat
    CHR(*), optional :: order
    .system_update
    if (associated(mat%restricted)) then
      .flush
      .put_text("restricted part:",flush=2)
      .put(mat%restricted,order)
    end
    if (associated(mat%alpha)) then
      .flush
      .put_text("alpha part:",flush=2)
      .put(mat%alpha,order)
    end
    if (associated(mat%beta)) then
      .flush
      .put_text("beta part:",flush=2)
      .put(mat%beta,order)
    end
    if (associated(mat%general)) then
      .flush
      .put_text("general part:",flush=2)
      .put(mat%general,order)
    end
    if (associated(mat%restricted_complex)) then
      .flush
      .put_text("complex restricted part:",flush=2)
      .put(mat%restricted_complex,order)
    end
    if (associated(mat%alpha_complex)) then
      .flush
      .put_text("complex alpha part:",flush=2)
      .put(mat%alpha_complex,order)
    end
    if (associated(mat%beta_complex)) then
      .flush
      .put_text("beta part:",flush=2)
      .put(mat%beta_complex,order)
    end
    if (associated(mat%general_complex)) then
      .flush
      .put_text("complex general part:",flush=2)
      .put(mat%general_complex,order)
    end
  end

!  ***********************************
!  Inquiry methods inherited from FILE
!  ***********************************

   file_exists result(res)
   ! Returns true if the file exists on the file system
      BIN :: res
      .system_update
      inquire(file=.name,exist=res)
   end

   file_does_not_exist result(res)
   ! Returns true if the file does *not* exist on the file system
      BIN :: res
      .system_update
      res = NOT (.file_exists)
   end

   file_is_open result(res)
   ! Returns true if the file has been opened
      BIN :: res
      ! inquire(unit=.unit,opened=res)
      .system_update
      inquire(file=.name,opened=res)
   end

   file_is_not_open result(res)
   ! Returns true if the file has *not* been opened
      BIN :: res
      .system_update
      res = NOT (.file_is_open)
   end

   file_unit_used result(res)
   ! Returns true if the file unit is in use
      BIN :: res
      .system_update
      inquire(unit=.unit,opened=res)
   end

   file_unit_not_used result(res)
   ! Returns true if the file unit is *not* in use
      BIN :: res
      .system_update
      inquire(unit=.unit,opened=res)
      res = NOT res
   end

   file_line_number result(res)
   ! Return the line number of the file
      INT :: res
      .system_update
      res = .record
   end

   file_record result(res) 
   ! Return record position of the file
      INT :: res
      .system_update
      res = .record
   end

   io_status result(res) 
   ! Return the file unit number
      INT :: res
      .system_update
      res = .io_status
   end

   unit result(res) 
   ! Return the file unit number
      INT :: res
      .system_update
      res = .unit
   end

   name result(res) 
   ! Return the file name as a default str
      STR :: res
      .system_update
      res = .name
   end

!  *********************
!  New inquiry functions
!  *********************
      
   labels result(res)
      BIN :: res
      .system_update
      res = .labels
   end
      
   labels_used result(res)
      BIN :: res
      .system_update
      res = .labels
   end
      
   labels_not_used result(res)
      BIN :: res
      .system_update
      res = NOT (.labels)
   end

!  **********************************
!  Line repositioning type operations
!  **********************************

   rewind 
   ! Rewind the output file
      .system_update
      rewind(unit=.unit,iostat=.io_status)
      DIE_IF(.io_status>0,"rewind error")
      .record = 1
      .system_update
   end

   move_to_end 
   ! Move to the end of the output file
      .system_update
      do
         read(unit=.unit,fmt="()",iostat=.io_status)
         if (.io_status>0) exit
         .record = .record + 1
         .system_update
      end
      backspace(unit=.unit,iostat=.io_status)
      .record = max(0,.record-1)
   end

   backspace_line 
   ! Move to the previous line in the file
      INT :: lastline
      .system_update
      lastline = .record-1
      .move_to_line(lastline) 
   end

   skip_line
   ! Skip the current line in the file
      INT :: nextline
      .system_update
      nextline = .record+1
      .move_to_line(nextline) 
   end

   move_to_line(line) 
   ! Skip to the specified "line" in the file
      INT :: line
      .system_update
      DIE_IF(line<1,"can't move to non-positive line")
      if (line<.record) then
         do 
            backspace(unit=.unit,iostat=.io_status)
            DIE_IF(.io_status>0,"backspace error")
            .record = max(1,.record-1)
            .system_update
            if (line==.record) exit
         end
      else if (line>.record) then
         do 
            read(unit=.unit,fmt="()",iostat=.io_status)
            DIE_IF(.io_status>0,"read error")
            .record = .record + 1
            .system_update
            if (line==.record) exit
         end
      end
   end

!  *******************
!  New set fmt methods
!  *******************

   set_labels(labels) 
   ! Set whether to use numbered labels on matrix or vector output
      BIN :: labels
      .system_update
      .labels = labels
   end

   set_margin(margin) 
   ! Set the width of the margin in the buffer. Takes effect at the next
   ! output line
      INT :: margin
      .system_update
      DIE_IF(margin<0,"margin less than zero")
      DIE_IF(margin>STR_SIZE,"margin too large")
      DIE_IF(.buffer%pos>.margin,"set margin only on empty buffers")
      .margin = margin
      .buffer.clear
      .put_margin
   end

!  ************************
!  Inherited dblfmt methods
!  ************************
      
   set_default_format 
   ! Set the default settings for the DBL formatting object
   ! Extra functions added compared to inherited code
      .system_update
      .labels        = OUTPUT_USE_LABELS
      .margin        = OUTPUT_MARGIN_WIDTH
      .fields        = OUTPUT_NO_OF_FIELDS
      .int_width     = OUTPUT_INT_WIDTH
      .dbl_width     = OUTPUT_DBL_WIDTH
      .dbl_precision = OUTPUT_PRECISION
      .dbl_style     = OUTPUT_DBL_STYLE
   end

   set_page_width(width)
   ! Set the default number of fields to fit in printer page
      INT, IN :: width
      INT :: fields
      .system_update
      fields=floor(real(width - .margin,kind=DBL_KIND) / .dbl_width)
      .set_fields(fields)
   end

   set_dbl_width(width) 
   ! Set the width in the dblfmt format object
      INT :: width
      .system_update
      DIE_IF(width<0,"width less than zero")
      DIE_IF(width<.dbl_precision,"width smaller than precision")
      .dbl_width = width
   end
      
   set_fields(fields) 
   ! Set the number of fields in the dblfmt format object
      INT :: fields
      .system_update
      DIE_IF(fields<1,"not enough fields")
      .fields = fields
   end
      
   set_dbl_precision(precision) 
   ! Set the precision required in the dblfmt format object
      INT :: precision
      .system_update
      DIE_IF(precision<0,"precision less than zero")
      DIE_IF(precision>.dbl_width,"precision greater than field width")
      .dbl_precision = precision
   end
      
   set_dbl_style(dbl_style) 
   ! Set the fortran format style string in the dblfmt format object
      CHR(*) :: dbl_style
      CHR(2) :: style
      .system_update
      style = adjustl(dbl_style)
      if (style/="f" AND style/="d" AND style/="e" AND style/="en" AND style/="es") &
         DIE("unrecognized style, "//style)
      .dbl_style = style
   end

   field_width(num) result (res)
   ! Return the field width that would look nice
     INT :: res
     INT, IN :: num
     DBL :: temp
      .system_update
     res=0
     if (num<0) res=res+1
     temp=abs(num)
     do
       res=res+1
       temp=temp/10
       if (temp < 1.0d0) exit
     end
   end

   format_dbl(style,width,precision) result (res)
   ! Format for a DBL string
      STR :: res
      STR, IN :: style
      INT, IN :: width,precision
      .system_update
      res = trim(style) // trim( width.to_str) // "." // trim( precision.to_str)
   end

   format_int(width) result (res)
   ! Format for a INT string
      STR :: res
      INT, IN :: width
      .system_update
      res = "i" // trim( width.to_str)
   end

   format_bin(width) result (res)
   ! Format for a INT string
      STR :: res
      INT, IN :: width
      .system_update
      res = "l" // trim( width.to_str)
   end

!******************************************************************************
! Test the module.
!******************************************************************************

  test
  ! Test the routines in the module.
    VEC(10) :: vec
    MAT(2,2) :: mat
    vec = ONE
    mat = ZERO
    .system_update
    .flush(2)
    .put_text("Unformatted stuff:",flush=1)
    .put_text("    a lot of space             .")
    .put_text("  Don't you think?",flush=2)
    .put_text("Formatted stuff:",flush=1)
    .put("integers:")
    .put("ONE",int_width=TRUE)
    .put("TWO",int_width=TRUE)
    .put("THREE",int_width=TRUE,flush=1)
    .tab(dbl_fields=1)
    .put(1);        .put(2);        .put(3,flush=2)
    .put("logical:")
    .put("TRUE",int_width=TRUE)
    .put("FALSE",int_width=TRUE,flush=1)
    .tab(dbl_fields=1)
    .put(TRUE);     .put(FALSE,flush=2)
    .put("real:")
    .put("ONE");    .put("TWO");    .put("THREE",flush=1)
    .tab(dbl_fields=1)
    .put(ONE);      .put(TWO);      .put(THREE,flush=2)
    .put_text("A vector with 10 elements:",flush=1)
    .put_text("by row, default page width:",flush=1)
    .put(vec)
    .flush
    .put_text("by row, page width 80 characters:",flush=1)
    .set_page_width(80)
    .put(vec)
    .flush
    .put_text("by column:",flush=1)
    .put(vec,"by_column")
    .flush(2)
    .put_text("A 2x2 matrix:",flush=1)
    .put(mat)
    .flush(2)
  end

  system_update
  ! Lets the system know info about the file being written, in case of error.
    std_system%file_name = .name
    std_system%file_record = .record
    std_system%file_operation = "write"
  end

  system_done
  ! Lets the system know the file has suspended being used.
    std_system%file_name = ""
    std_system%file_record = 0
    std_system%file_operation = ""
  end

end 
