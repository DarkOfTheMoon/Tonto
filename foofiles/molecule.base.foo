!===============================================================================
!
! MOLECULE.BASE 
!
! An object representation of a molecule.
!
! These are base methods needed by all other submodules.
!
! The submodule hierarchy is shown below. 
! . The numbers (if any) indicate (roughly) the number of used
!   procedures from the module at the head of the column. This is
!   useful if you want to decouple the modules even further. 
! . The type of routines in each submodule is more-or-less
!   straightforward to understand from the three- or four-letter
!   pneumonic e.g. REL is for relativistic routines.
!
! .BASE
! |=>2 .CE
! |=>3     .REL 
! |=>  |=>     .GRID
! |=>      |=>7     .XTAL
! |=>6         |=>1       .INTS
! |=>2              |=>2       .GEM
! |=>  |=>5              |=>2       .FOCK
! |=>  |=>2    |=>7     |=>  |=>1        .SCF
! |=>4         |=>      |=>  |=>1 |=>        .PROP
! |=>          |=>      |=>       |=>  |=>        .PLOT
! |=>          |=>4               |=>6      |=>5       .TAD
! |=>3         |=>3     |=>4 |=>2      |=>1 |=>1            .CP 
! .MISC
! .MAIN
!
! Copyright (C) Dylan Jayatilaka, Daniel Grimwood, 1996
! Copyright (C) Dylan Jayatilaka 2012-
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id: molecule.base.foo 3$
!===============================================================================

module MOLECULE.BASE

   implicit none

#  undef  ENSURE
#  define ENSURE(X,Y)       ENSURE0(X,Y)

   saved_self :: MOLECULE*, private

   debug_list :: VEC{STR}*  DEFAULT_NULL

contains

!  ==================
!  Create and destroy
!  ==================

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky, recursive
   ! Destroy an object
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the molecule

      nullify(.atom)
      nullify(.atom_group)

      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)

      nullify(.plot_grid)
      nullify(.interpolator)
      nullify(.isosurface)

      nullify(.becke_grid)

      nullify(.crystal)
      nullify(.cluster)
      nullify(.cif)
      nullify(.pointgroup)

      nullify(.atom_for_shell)
      nullify(.atom_shell_for_shell)
      nullify(.first_shell_for_atom)
      nullify(.last_shell_for_atom)
      nullify(.basis_shell_for_shell)
      nullify(.first_basis_fn_for_shell)
      nullify(.last_basis_fn_for_shell)
      nullify(.angular_moment_for_shell)
      nullify(.first_basis_fn_for_atom)
      nullify(.last_basis_fn_for_atom)
      nullify(.precomputed_basis_shellpair)
      nullify(.max_I)
      nullify(.overlapping_atoms)
      nullify(.overlapping_atoms_for_atom)

      nullify(.scfdata)

      nullify(.orbital_energies)
      nullify(.molecular_orbitals)
      nullify(.density_matrix)
      nullify(.old_density_matrix)
      nullify(.delta_density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation_numbers)
      nullify(.overlap_matrix)
      nullify(.overlap_eigenvectors)
      nullify(.overlap_eigenvalues)
      nullify(.max_S)
      nullify(.kinetic_energy_matrix)
      nullify(.nuclear_attraction_matrix)
      nullify(.core_matrix)
      nullify(.fock_matrix)
      nullify(.fock_2e_matrix)
      nullify(.constraint_matrix)

      nullify(.roby)
      nullify(.saved)
      nullify(.localiser)

      nullify(.U_electric_dipole)
      nullify(.dipole_polarisability)
      nullify(.dipole_hyperpolarisability)

   end

   destroy_ptr_part ::: recursive, leaky
   ! Destroy the pointer parts of a molecule object

      g :: INT
      mol :: MOLECULE*

      ! Saved molecule
      .saved.::destroy

      ! Atoms (nullify pointed-to atoms before)
      .atom.destroy

      ! Atom_groups
      if (.atom_group.created) then

         do g = 1,.atom_group.dim

            mol => .atom_group(g).mol

            if (mol.::destroyed) cycle

            mol.atom.nullify_ptr_part ! do not destroy these
            nullify(mol.basis)        ! do not destroy this
            nullify(mol.slaterbasis)  ! do not destroy this
            nullify(mol.coppensbasis) ! do not destroy this

            mol.::destroy

         end

      end

      .atom_group.destroy

      ! Destroy bases and pointed
      .basis.destroy
      .slaterbasis.destroy
      .coppensbasis.destroy

      ! Grids, interpolators & plots
      .plot_grid.destroy
      .interpolator.destroy
      .isosurface.destroy
      .becke_grid.destroy

      ! Crystals and clusters
      .crystal.destroy
      .cluster.destroy
      .cif.destroy
      .pointgroup.destroy

      ! Basis set & integral info arrays
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .basis_shell_for_shell.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .precomputed_basis_shellpair.destroy
      .max_I.destroy
      .overlapping_atoms.destroy
      .overlapping_atoms_for_atom.destroy

      ! SCF data
      .scfdata.destroy

      ! SCF info
      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .max_S.destroy
      .kinetic_energy_matrix.destroy
      .nuclear_attraction_matrix.destroy

      ! SCF intermediates
      .core_matrix.destroy
      .fock_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy

      ! Bond analysis
      .roby.destroy

      ! Localised MO's
      .localiser.destroy

      ! CPHF and response properties
      .U_electric_dipole.destroy
      .dipole_polarisability.destroy
      .dipole_hyperpolarisability.destroy

   end

   destroy_matrices ::: leaky
   ! Destroy the matrices of a molecule object
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy

      .orbital_energies.destroy
      .molecular_orbitals.destroy
      .density_matrix.destroy
      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy
      .max_S.destroy
      .kinetic_energy_matrix.destroy
      .nuclear_attraction_matrix.destroy

      .core_matrix.destroy
      .fock_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy

      .atom_group.destroy

   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   save ::: leaky
   ! Save everything about "self" in ".saved".
      self :: PTR

      saved :: MOLECULE*

      ! Save self
      saved => self

      ! Recreate
      .::create

      ! Set .saved 
      .saved => saved

   end

   unsave ::: leaky
   ! Revert back to a previously saved molecule stored in .saved, and
   ! destroy everything about the current molecule in "self".
   ! WARNING: be careful when setting up self, make sure none of its pointer
   ! parts refer to .saved information.
      self :: PTR

   ENSURE(.saved.created,"no previous settings")

      saved :: MOLECULE*

      ! Save .saved
      saved => .saved

      ! Destroy self (not .saved)
      nullify(.saved) 
      .::destroy

      ! Restore self
      self => saved   

   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   copy(mol) ::: leaky
   ! Set self to be a copy of "mol"
      mol :: MOLECULE, IN

      ! Copy all non-pointer fields
      self = mol

      ! Create a copy of all pointer fields
      .::nullify_ptr_part

      if (mol.atom.created)                       .atom.create_copy(mol.atom)

      if (mol.basis.created)                      .basis.create_copy(mol.basis)
      if (mol.slaterbasis.created)                .slaterbasis.create_copy(mol.slaterbasis)
      if (mol.coppensbasis.created)               .coppensbasis.create_copy(mol.coppensbasis)

      if (mol.plot_grid.created)                  .plot_grid.create_copy(mol.plot_grid)
      if (mol.interpolator.created)               .interpolator.create_copy(mol.interpolator)
      if (mol.isosurface.created)                 .isosurface.create_copy(mol.isosurface)

      if (mol.becke_grid.created)                 .becke_grid.create_copy(mol.becke_grid)

      if (mol.crystal.created)                    .crystal.create_copy(mol.crystal)
      if (mol.cluster.created)                    .cluster.create_copy(mol.cluster)
      if (mol.cif.created)                        .cif.create_copy(mol.cif)
      if (mol.pointgroup.created)                 .pointgroup.create_copy(mol.pointgroup)

      if (mol.saved.::created)                    .saved.::create_copy(mol.saved)

      if (mol.atom_for_shell.created)             .atom_for_shell.create_copy(mol.atom_for_shell)
      if (mol.atom_shell_for_shell.created)       .atom_shell_for_shell.create_copy(mol.atom_shell_for_shell)
      if (mol.first_shell_for_atom.created)       .first_shell_for_atom.create_copy(mol.first_shell_for_atom)
      if (mol.last_shell_for_atom.created)        .last_shell_for_atom.create_copy(mol.last_shell_for_atom)
      if (mol.first_basis_fn_for_shell.created)   .first_basis_fn_for_shell.create_copy(mol.first_basis_fn_for_shell)
      if (mol.last_basis_fn_for_shell.created)    .last_basis_fn_for_shell.create_copy(mol.last_basis_fn_for_shell)
      if (mol.angular_moment_for_shell.created)   .angular_moment_for_shell.create_copy(mol.angular_moment_for_shell)
      if (mol.overlapping_atoms.created)          .overlapping_atoms.create_copy(mol.overlapping_atoms)
      if (mol.overlapping_atoms_for_atom.created) .overlapping_atoms_for_atom.create_copy(mol.overlapping_atoms_for_atom)
      if (mol.first_basis_fn_for_atom.created)    .first_basis_fn_for_atom.create_copy(mol.first_basis_fn_for_atom)
      if (mol.last_basis_fn_for_atom.created)     .last_basis_fn_for_atom.create_copy(mol.last_basis_fn_for_atom)

      if (mol.scfdata.created)                    .scfdata.create_copy(mol.scfdata)

      if (mol.orbital_energies.created)           .orbital_energies.create_copy(mol.orbital_energies)
      if (mol.molecular_orbitals.created)         .molecular_orbitals.create_copy(mol.molecular_orbitals)
      if (mol.density_matrix.created)             .density_matrix.create_copy(mol.density_matrix)
      if (mol.old_density_matrix.created)         .old_density_matrix.create_copy(mol.old_density_matrix)
      if (mol.delta_density_matrix.created)       .delta_density_matrix.create_copy(mol.delta_density_matrix)
      if (mol.natural_orbitals.created)           .natural_orbitals.create_copy(mol.natural_orbitals)
      if (mol.occupation_numbers.created)         .occupation_numbers.create_copy(mol.occupation_numbers)
      if (mol.overlap_matrix.created)             .overlap_matrix.create_copy(mol.overlap_matrix)
      if (mol.overlap_eigenvectors.created)       .overlap_eigenvectors.create_copy(mol.overlap_eigenvectors)
      if (mol.overlap_eigenvalues.created)        .overlap_eigenvalues.create_copy(mol.overlap_eigenvalues)
      if (mol.max_S.created)                      .max_S.create_copy(mol.max_S)
      if (mol.kinetic_energy_matrix.created)      .kinetic_energy_matrix.create_copy(mol.kinetic_energy_matrix)
      if (mol.nuclear_attraction_matrix.created)  .nuclear_attraction_matrix.create_copy(mol.nuclear_attraction_matrix)

      if (mol.core_matrix.created)                .core_matrix.create_copy(mol.core_matrix)
      if (mol.fock_matrix.created)                .fock_matrix.create_copy(mol.fock_matrix)
      if (mol.fock_2e_matrix.created)             .fock_2e_matrix.create_copy(mol.fock_2e_matrix)
      if (mol.constraint_matrix.created)          .constraint_matrix.create_copy(mol.constraint_matrix)

      if (mol.atom_group.created)                 .atom_group.create_copy(mol.atom_group)

      if (mol.U_electric_dipole.created)          .U_electric_dipole.create_copy(mol.U_electric_dipole)
      if (mol.dipole_polarisability.created)      .dipole_polarisability.create_copy(mol.dipole_polarisability)
      if (mol.dipole_hyperpolarisability.created) .dipole_hyperpolarisability.create_copy(mol.dipole_hyperpolarisability)

   end

!  ================
!  Specific cleanup
!  ================

   destroy_ANOs ::: leaky
   ! Destroy the ANO's for all atoms in the molecule.

   ENSURE(.atom.created,"no atoms")

      if (NOT .::has_all_ANOs) return

      .atom.destroy_ANOs

   end

   destroy_ANO_interpolators ::: leaky
   ! Destroy the (non-unique) ANO interpolators 

   ENSURE(.atom.created,"no atoms")

      if (NOT .::has_all_ANO_interpolators) return

      .atom.destroy_ANO_interpolators

   end

   destroy_interpolators ::: leaky
   ! Destroy the (unique) interpolators (*not* ANO interpolators)

   ENSURE(.atom.created,"no atoms")

      if (NOT .::has_all_interpolators) return

      .atom.destroy_interpolators

   end

   destroy_spherical_atom_data ::: leaky
   ! Destroy the restricted atomic natural orbitals (ANO) data for
   ! all atoms in the molecule.

   ENSURE(.atom.created,"no atoms")

      if (NOT .::has_all_spherical_atom_data) return

      .atom.destroy_spherical_atom_data

   end

   destroy_atom_shell_info ::: leaky
   ! Destroy the atom precomputed shellpair info.

   ENSURE(.atom.created,"no atoms")

      if (NOT .::has_all_atom_shell_info) return

      .atom.destroy_shell_info

   end

!  SCF

   destroy_scf_results(keep_MOs,keep_DM) ::: leaky
   ! Destroy the SCF results in memory
      keep_MOs,keep_DM :: BIN, optional

      delete_MOs,delete_DM :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      delete_DM = TRUE
      if (present(keep_DM))  delete_DM  = NOT keep_DM

      if (delete_MOs) .molecular_orbitals.destroy
      if (delete_DM)  .density_matrix.destroy

      .orbital_energies.destroy
      .fock_matrix.destroy

   end

   destroy_tmp_scf_matrices
   ! Destroy any temporary matrices stored in memory.
      .old_density_matrix.destroy
      .delta_density_matrix.destroy
      .fock_2e_matrix.destroy
      .constraint_matrix.destroy
   end

   destroy_scf_integrals ::: leaky
   ! Destroy all SCF-related integrals in memory. 

      .overlap_matrix.destroy
      .overlap_eigenvectors.destroy
      .overlap_eigenvalues.destroy

      .kinetic_energy_matrix.destroy
      .nuclear_attraction_matrix.destroy
      .core_matrix.destroy

   end

!  ============
!  Set defaults
!  ============

   set_defaults ::: leaky
   ! Set up a default molecule

      .name = "unknown"
      .charge = 0
      .spin_multiplicity = 1
      .n_e = 0
      .n_a = 0
      .n_b = 0
      .E_field = ZERO
      .B_field = ZERO
      .gauge_origin = ZERO

      .n_atom = 0
      .atom_info_made = FALSE
      .n_atom_kind = 0

      .n_bf = 0
      .basis_name = " "
      .n_basis = 0
      .basis_l_max = -1
      .use_spherical_basis = FALSE
      .n_bf = 0
      .n_prim = 0
      .slaterbasis_name = " "
      .coppensbasis_name = " "
      .basis_info_made = FALSE

      .use_interpolators = TRUE

      .n_shell = 0
      .n_shell_pairs = 0
      .n_unique_shells = 0

      .CX_file_name = " "
      .CX_uses_angstrom = FALSE

      .Hirshfeld_atom_info_made = FALSE
      .uHirshfeld_atom_info_made = FALSE
      .atomic_polarisabilities_made = FALSE

      .invariom_database_directory = " "
      .invariom_refinement = FALSE

      if (.atom.created) then
         .name              = .::chemical_formula
         .spin_multiplicity = .::default_spin_multiplicity
         .::set_atom_info
      end

   end

   set_scf_guess_defaults_from(scfdata) ::: leaky
   ! Set scf  data options for a guess-type SCF defaults
      scfdata :: SCFDATA*

      ! Set the SCF defaults (leaky)
      if (scfdata.destroyed) then
         .::set_scf_defaults
         .scfdata.set_output(FALSE) 
      else if (scfdata.use_default_guess_options) then
         .::set_scf_defaults
         .scfdata.set_output(FALSE) 
      else
         .::set_scf_defaults(scfdata) ! leaky
      end

      ! Reset some defaults from scfdata, if it is there
      if (scfdata.created) then
         .scfdata.set_output(scfdata.guess_output) 
         .scfdata.set_convergence(scfdata.convergence)
         .scfdata.diis.set_convergence_tolerance(scfdata.diis.convergence_tolerance)
         .scfdata.set_relativity_kind(scfdata.relativity_kind)
      end

      ! Nuclear energy
      .scfdata.nuclear_repulsion_energy = .::nuclear_repulsion_energy

      ! Finalise
      .scfdata.finalize

   end

   set_scf_defaults(scfdata) ::: leaky
   ! Set up scf defaults for molecule
      scfdata :: SCFDATA*, optional

      if (.scfdata.destroyed) then; .scfdata.create
      else;                         .scfdata.set_defaults
      end

      if (.spin_multiplicity==1) .scfdata.set_scf_kind("rhf")
      if (.spin_multiplicity/=1) .scfdata.set_scf_kind("uhf")

      if (present(scfdata)) then
         .scfdata = scfdata
         nullify(.scfdata.cluster)
         nullify(.scfdata.cluster_charges)
         nullify(.scfdata.cluster_charge_positions)
         if (.scfdata.scf_kind/=" ") then
         if (.scfdata.is_DFT_calculation) then
            if (.spin_multiplicity==1) .scfdata.set_scf_kind("rks")
            if (.spin_multiplicity/=1) .scfdata.set_scf_kind("uks")
         end
         end
      end

      .scfdata.nuclear_repulsion_energy = .::nuclear_repulsion_energy

      .::initialize_DFT_grids

   end

   initialize_DFT_grids ::: leaky
   ! Initialise DFT grids, if not already done so.
   ENSURE(.scfdata.created,"no scfdata")

      if (NOT .scfdata.is_DFT_calculation) return

      if (.becke_grid.destroyed) then
         .becke_grid.create
         .becke_grid.set_grid_data(.atom)
      end

      .BASE:make_overlapping_atoms

   end

!  ===========
!  Set methods
!  ===========

   set_saved_self ::: get_from(OBJECT)
   ! Set saved_self
   end

   set_charge(val)
   ! Set the charge to "val"
      val :: INT
      .charge = val
   end

   set_atom_info ::: leaky
   ! Set the associated atom information, including the number of alpha and beta
   ! electrons. NOTE: The multiplicity must be right for this to work.  The
   ! routine tries to reassign the multiplicity so that it will be consistent
   ! with the charge.
   ENSURE(.atom.created,"no atom info")
   ENSURE(.atom_group.destroyed,"don't reset atom info after groups are defined!")

      ! Finalize
      .atom.update

      ! No. of atoms
      .n_atom = .atom.dim

      ! No. of atom kinds
      .n_atom_kind = maxval(.atom.kind)

      ! Reset multiplicity?
      if (NOT .::has_valid_no_of_beta_electrons) then
         WARN("Inconsistent charge and multiplicity")
         WARN("Reassigning the multiplicity")
         .spin_multiplicity = .::default_spin_multiplicity
      end

      ! Now can set # of electrons
      .n_e = .::no_of_electrons
      .n_a = .::no_of_alpha_electrons
      .n_b = .::no_of_beta_electrons

      .atom_info_made = TRUE

   end

   resolve_basis_info ::: leaky
   ! Match the basis set labels for every atom with the actual atomic basis set.
   ! Also perform any finalization procedures to fully define all objects.
   ! This version is supposed to work for multiple bases.
      .::resolve_coppensbases
      .::resolve_slaterbases
      .::resolve_gaussianbases
   end

   resolve_gaussianbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.destroyed) return

      if (.n_atom<1) return

      if (.atom.bases_are_resolved) then
         stdout.flush
         stdout.text("Gaussian bases all resolved")
         return
      end

      ! Resolve from a library .....
      if (.basis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.basis.created) .basis.renormalise

         ! Read the basis from the library
         library = .basis.library_file(.basis_name)
         library_basis_labels => .atom.library_basis_labels(.basis_name)
         .basis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         stdout.flush
         stdout.text("Added "//trim(n_unique.to_str)//" bases from library: "//trim(.basis_name))

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.basis.created) then

            .basis.set_spherical(.use_spherical_basis)
            .atom.resolve_bases(.basis,.basis_name)
            .atom.set_basis_kind("gaussian")

            ! Unnormalise if completely done
            .basis.unnormalise        

            .::set_basis_info         

         end

      ! Resolve from existing .basis .....
      else if (.basis.created) then

            .basis.set_spherical(.use_spherical_basis)
            .atom.resolve_bases(.basis)
            .atom.set_basis_kind("gaussian")

            ! Unnormalise if completely done
            if (.atom.bases_are_resolved) .::set_basis_info          

      end

      if (.basis.created) then
      if (.atom.bases_are_resolved) then
         stdout.flush
         stdout.text("Gaussian bases all resolved")
      else
         stdout.flush
         WARN("not all Gaussian bases were resolved")
      end
      end

   end

   resolve_slaterbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.destroyed) return

      if (.n_atom<1) return

      if (.atom.slaterbases_are_resolved) then
         stdout.flush
         stdout.text("Slater bases all resolved")
         return
      end

      ! Resolve from a library .....
      if (.slaterbasis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.slaterbasis.created) .slaterbasis.renormalise

         ! Read the basis from the library
         library = .slaterbasis.library_file(.slaterbasis_name)
         library_basis_labels => .atom.library_basis_labels(.slaterbasis_name)
         .slaterbasis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         stdout.flush
         stdout.text("Added "//trim(n_unique.to_str)//" bases from library: "//trim(.slaterbasis_name))

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.slaterbasis.created) then
            .atom.resolve_bases(.slaterbasis,.slaterbasis_name)
            .atom.set_basis_kind("slater")

            ! Unnormalise if completely done
            .slaterbasis.unnormalise        
         end

      ! Resolve from existing .basis .....
      else if (.slaterbasis.created) then

            .atom.resolve_bases(.slaterbasis)
            .atom.set_basis_kind("slater")

      end

      if (.slaterbasis.created) then
      if (.atom.slaterbases_are_resolved) then
         stdout.flush
         stdout.text("Slater bases all resolved")
      else
         stdout.flush
         WARN("not all Slater bases were resolved")
      end
      end

   end

   resolve_coppensbases ::: leaky
   ! Match the basis set labels for every atom with the actual atomic
   ! basis set.
      library_basis_labels :: VEC{STR}*
      n_unique :: INT
      library :: STR

      if (.atom.destroyed) return

      if (.n_atom<1) return

      if (.atom.coppensbases_are_resolved) then
         stdout.flush
         stdout.text("Coppens bases all resolved")
         return
      end

      ! Resolve from a library .....
      if (.coppensbasis_name/=" ") then

         ! Renormalise basis sets. (The library is in normalised form)
         if (.coppensbasis.created) .coppensbasis.renormalise

         ! Read the basis from the library
         library = .coppensbasis.library_file(.coppensbasis_name)
         library_basis_labels => .atom.library_basis_labels(.coppensbasis_name)
         .coppensbasis.read_library_data(library,library_basis_labels,n_unique)
         library_basis_labels.destroy

         stdout.flush
         stdout.text("Added "//trim(n_unique.to_str)//" bases from library: "//trim(.coppensbasis_name))

         ! Resolve atom bases afresh i.e. point atom.basis to .basis
         if (.coppensbasis.created) then
            .atom.resolve_bases(.coppensbasis,.coppensbasis_name)
            .atom.set_basis_kind("coppens")

            ! Unnormalise if completely done
            .coppensbasis.unnormalise        
         end

      ! Resolve from existing .basis .....
      else if (.coppensbasis.created) then

            .atom.resolve_bases(.coppensbasis)
            .atom.set_basis_kind("coppens")

      end

      if (.coppensbasis.created) then
      if (.atom.coppensbases_are_resolved) then
         stdout.flush
         stdout.text("Coppens bases all resolved")
      else
         stdout.flush
         WARN("not all Coppens bases were resolved")
      end
      end

   end

   resolve_axis_system
   ! Change the axis system to crystal coordinates, if required.

      if (.crystal.destroyed) return
      if (.atom.destroyed)    return

      .atom.resolve_axis_system(.crystal.unit_cell)

   end

   change_axis_system_to
   ! Change the axis system to crystal coordinates, if required.

      axis_system :: STR

      if (.crystal.destroyed) return
      if (.atom.destroyed)    return

      stdin.read(axis_system)

      .atom.change_axis_system_to(axis_system,.crystal.unit_cell)

   end

   set_basis_info ::: leaky
   ! Set the molecule basis set information; the atom list must exist.
   ENSURE(.atom.created,"no atom info")

      if (.basis.destroyed) return

      if (NOT .atom.bases_are_resolved) then

         .basis_info_made = FALSE

      else

         .n_basis       = .basis.dim
         .n_bf          = .atom.n_bf
         .n_prim        = .atom.n_prim
         .n_shell       = .atom.n_shell
         .n_shell_pairs = .::no_of_shell_pairs

         ! Make shell-basis-function limts, etc. (keaky)
         .::make_shell_info 

         .basis_info_made = TRUE

      end

   end

   set_basis_name(name) ::: leaky
   ! Set a gaussian *library* basis set name
      name :: STR

   ENSURE(all(name/=non_gaussian),"basis "//trim(name)//"is not a gaussian basis")

      non_gaussian :: VEC{STR}(len=17,4) = &
         ["Clementi-Roetti  ", &
          "Thakkar          ", &
          "vanLenthe-Barends", &
          "Coppens          "  ]

      ! Set the basis kind
      .basis_name = name

      ! Destroy links to previous bases
      if (.atom.created) .atom.nullify_basis_part 
      .basis.destroy

      ! Make fresh basis set links (might be leaky)
      .::resolve_gaussianbases

   end

   set_slaterbasis_name(name) ::: leaky
   ! Set a slater *library* basis set name
      name :: STR

   ENSURE(any(name==slater),"basis "//trim(name)//"is not a known slater basis")

      slater :: VEC{STR}(len=17,3) = &
         ["Clementi-Roetti  ",       &
          "Thakkar          ",       &
          "vanLenthe-Barends"        ]

      ! Set the basis kind
      .slaterbasis_name = name

      ! Destroy links to previous bases
      if (.atom.created) .atom.nullify_slaterbasis_part 
      .slaterbasis.destroy

      ! Make fresh basis set links (might be leaky)
      .::resolve_slaterbases

   end

   set_coppensbasis_name(name) ::: leaky
   ! Set a coppens *library* basis set name
      name :: STR

   ENSURE(name=="Coppens","basis "//trim(name)//"is not a known coppens basis")

      ! Set the basis kind
      .coppensbasis_name = name

      ! Destroy links to previous bases
      if (.atom.created) .atom.nullify_coppensbasis_part 
      .coppensbasis.destroy

      ! Make fresh basis set links (might be leaky)
      .::resolve_coppensbases

   end

   set_scf_occupations(NO_kind)
   ! Set the SCF occupation numbers for the natural orbitals
      NO_kind :: STR

      select case (NO_kind)

         case ("restricted")
            .occupation_numbers.restricted(1:.n_a) = TWO

         case ("unrestricted")
            .occupation_numbers.alpha(1:.n_a) = ONE
            .occupation_numbers.beta(1:.n_b)  = ONE

         case ("general")
            .occupation_numbers.general(1:.n_e) = ONE

         case ("restricted_complex")
            .occupation_numbers.restricted(1:.n_a) = TWO

         case ("unrestricted_complex")
            .occupation_numbers.alpha(1:.n_a) = ONE
            .occupation_numbers.beta(1:.n_b)  = ONE

         case ("general_complex")
            .occupation_numbers.general(1:.n_e) = ONE
      end

   end

!  ============
!  Read routine
!  ============

   read_CIF_ADPs(cif) ::: leaky
   ! Read atom ADP information from a Crystallographic Information File, "cif".
      cif :: CIF

   ENSURE(cif.start_of_data>0,"no start of data in CIF")
   ENSURE(cif.end_of_data>cif.start_of_data,"no end of data in CIF")
   ENSURE(.crystal.created,"must have crystal information")

      if (NOT cif.file.is_open) cif.open

      .atom.read_CIF_ADPs(cif)

      .::resolve_axis_system

   end

!  ===================
!  Redirect and revert
!  ===================

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   redirect_stdout ::: leaky
   ! Redirect stdout to the file whose name is the following string
   ! in the current input file.

      name :: STR

      if (FALSE) self = self

      stdin.read(name)
      stdout.redirect(name)

   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

   revert_stdout ::: leaky
   ! Revert stdout back to the previously stored input file
      if (FALSE) self = self
      stdout.revert
   end

!  ==================
!  Read/write archive
!  ==================

   read_archive ::: leaky
   ! Read the archive called "name" with "genre", e.g.  "restricted".
   ! For use with TONTO generated archives.
   ENSURE(stdin.n_line_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,genre :: STR

      stdin.read(name)
      stdin.read(genre)

      stdout.text("reading archive : " // trim(name))
      .::read_archive(name,genre)

   end

   read_archive(name,genre) ::: leaky
   ! Read the archive called "name" with "genre", e.g. "restricted".
   ! For use with TONTO generated archives.
      name,genre :: STR, IN

   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      arch :: ARCHIVE

      ! Set the archive "name" & "genre"
      arch.set(.name,name,genre=genre)

      ! Read the archive
      select case (name)

         case ("molecular_orbitals")
            if (.molecular_orbitals.destroyed) .molecular_orbitals.create(.n_bf)
            arch.read(.molecular_orbitals)

         case ("density_matrix    ")
            if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
            arch.read(.density_matrix)

         case ("MP2_density_matrix")
            if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
            arch.read(.density_matrix)

         case ("MP3_density_matrix")
            if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
            arch.read(.density_matrix)

         case ("fock_matrix       ")
            if (.fock_matrix.destroyed) .fock_matrix.create(.n_bf)
            arch.read(.fock_matrix)

         case ("orbital_energies  ")
            if (.orbital_energies.destroyed) .orbital_energies.create(.n_bf)
            arch.read(.orbital_energies)

         case ("natural_orbitals  ")
            if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals)

         case ("occupation_numbers")
            if (.occupation_numbers.destroyed) .occupation_numbers.create(.n_bf)
            arch.read(.occupation_numbers)

         case ("covalent_orbitals ")
            if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals)

         case ("ionic_orbitals    ")
            if (.natural_orbitals.destroyed) .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals)

         case ("U_electric_dipole ")
            if (.U_electric_dipole.destroyed) .U_electric_dipole.create(.n_bf,.n_bf,3)
            arch.read(.U_electric_dipole)

         case default
            UNKNOWN(name)
            
      end

      ! Clean up
      arch.close

   end

   read_ascii_archive ::: leaky
   ! Read the archive called "name" with "genre", e.g. "restricted".
   ENSURE(stdin.buffer.n_items==3, "must specify an archive and a kind")
   ENSURE(.n_bf>0, "need to already know the number of basis functions")

      name,genre :: STR
      arch :: ARCHIVE

      ! Read archive name & genre
      stdin.read(name)
      stdin.read(genre)

      ! Set archive "name", "genre" & ascii format
      arch.set(.name,name,genre=genre,format="ascii")

      ! Read the archive
      select case (name)

         case ("molecular_orbitals")
            if (.molecular_orbitals.destroyed) .molecular_orbitals.create(.n_bf)
            arch.read(.molecular_orbitals,by_column=TRUE)

         case ("density_matrix    ")
            if (.density_matrix.destroyed)     .density_matrix.create(.n_bf)
            arch.read(.density_matrix,by_column=TRUE)

         case ("MP2_density_matrix")
            if (.density_matrix.destroyed)     .density_matrix.create(.n_bf)
            arch.read(.density_matrix,by_column=TRUE)

         case ("MP3_density_matrix")
            if (.density_matrix.destroyed)     .density_matrix.create(.n_bf)
            arch.read(.density_matrix,by_column=TRUE)

         case ("orbital_energies  ")
            if (.orbital_energies.destroyed)   .orbital_energies.create(.n_bf)
            arch.read(.orbital_energies)

         case ("natural_orbitals  ")
            if (.natural_orbitals.destroyed)   .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals,by_column=TRUE)

         case ("occupation_numbers")
            if (.occupation_numbers.destroyed) .occupation_numbers.create(.n_bf)
            arch.read(.occupation_numbers)

         case ("covalent_orbitals ")
            if (.natural_orbitals.destroyed)   .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals,by_column=TRUE)

         case ("ionic_orbitals    ")
            if (.natural_orbitals.destroyed)   .natural_orbitals.create(.n_bf)
            arch.read(.natural_orbitals,by_column=TRUE)

         case ("fock_matrix       ")
            if (.fock_matrix.destroyed)        .fock_matrix.create(.n_bf)
            arch.read(.fock_matrix,by_column=TRUE)

         case default
            UNKNOWN(name)

      end

      ! Clean up
      arch.close
   
   end

   write_archive
   ! Write the archive called "name". The genre is defined by the
   ! object to be written.

      name :: STR
      arch :: ARCHIVE

      ! Read the archive "name"
      stdin.read(name)

      ! Set archive "name"
      arch.set(.name,name)

      ! Write the archive, "genre" from object
      select case (name)

         case ("molecular_orbitals")
            DIE_IF(.molecular_orbitals.destroyed,"no molecular_orbitals")
            arch.write(.molecular_orbitals)

         case ("density_matrix    ")
            DIE_IF(.density_matrix.destroyed,"no density_matrix")
            arch.write(.density_matrix)

         case ("natural_orbitals  ")
            DIE_IF(.natural_orbitals.destroyed,"no natural_orbitals")
            arch.write(.natural_orbitals)

         case ("occupation_numbers")
            DIE_IF(.occupation_numbers.destroyed,"no occupation_numbers")
            arch.write(.occupation_numbers)

         case ("fock_matrix       ")
            DIE_IF(.fock_matrix.destroyed,"no fock_matrix")
            arch.write(.fock_matrix)

         case ("orbital_energies  ")
            DIE_IF(.orbital_energies.destroyed,"no orbital_energies")
            arch.write(.orbital_energies)

         case ("U_electric_dipole ")
            DIE_IF(.U_electric_dipole.destroyed,"no U_electric_dipole")
            arch.write(.U_electric_dipole)

         case default
            UNKNOWN(name)

      end

      ! Clean up
      arch.close

   end

   write_ascii_archive
   ! Write the archive called "name". The genre is defined by the
   ! object to be written. 

      name :: STR
      arch :: ARCHIVE

      ! Read the archive "name"
      stdin.read(name)

      ! Set the archive "name" and ascii format
      arch.set(.name,name,format="ascii")

      ! Write the archive, "genre" from object
      select case (name)
         case ("molecular_orbitals"); arch.write(.molecular_orbitals,by_column=TRUE)
         case ("density_matrix    "); arch.write(.density_matrix,    by_column=TRUE)
         case ("natural_orbitals  "); arch.write(.natural_orbitals,  by_column=TRUE)
         case ("occupation_numbers"); arch.write(.occupation_numbers,by_column=TRUE)
         case ("fock_matrix       "); arch.write(.fock_matrix,       by_column=TRUE)
         case ("orbital_energies  "); arch.write(.orbital_energies,  by_column=TRUE)
         case default;     UNKNOWN(name)
      end

      ! Clean up
      arch.close

   end

!  ======================
!  Gaussian chk interface
!  ======================

! Can thesed be condensed into one?

   read_g09_FChk_file(name) ::: leaky
   ! Read a g09 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy :: VEC{REAL}*
      temp_mat,DD,MO :: MAT{REAL}*
      Z, a,s,t, f,l,g,h :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE
      Nc :: REAL

      ! Destroy existing basis, and atom list
      if (.basis.created) .basis.destroy
      if (.atom.created)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open(for="read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independ",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis functions different to no. of independent functions")
      WARN_IF(.n_bf/=n_independent,"The MO's will be wrong but the density matrix is correct")

      ! Read in atoms
      chkfile.look_for("Atomic numbers",from=1); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
      end

      ! Read in nuclear charges
      chkfile.look_for("Nuclear charges",from=1); chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(Nc)
         .atom(a).set_nuclear_charge(Nc)
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(.atom(a).position)
      end

      chkfile.look_for("Number of contracted shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)


      ! Read gaussian shell info.
      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + sum(atom_p)
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis. Expand out L shells.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy
      G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy
      G_ex.destroy
      G_cc.destroy

      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis 
      .::set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! .basis.unnormalise ! NOTE this
      .::set_atom_info
      .::resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf,n_independent)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .::swap_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .::swap_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .::swap_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .density_matrix.destroy
      .::read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.created) then
         if (.molecular_orbitals.restricted.created) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .::read_gX_MP2_dm(chkfile,restricted)

      ! Extract MP3 density matrix to file.  UHF untested
      .::read_gX_MP3_dm(chkfile,restricted)

      ! Extract CC density matrix to file.  UHF untested
      .::read_gX_CC_dm(chkfile,restricted)

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archiveive files
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .::resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   read_g03_FChk_file(name) ::: leaky
   ! Read a g09 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy :: VEC{REAL}*
      temp_mat,DD,MO :: MAT{REAL}*
      Z, a,s,t, f,l,g,h :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE
      Nc :: REAL

      ! Destroy existing basis, and atom list
      if (.basis.created) .basis.destroy
      if (.atom.created)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open(for="read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independant functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis functions different to no. of independent functions")
      WARN_IF(.n_bf/=n_independent,"The MO's will be wrong but the density matrix is correct")

      chkfile.look_for("Number of contracted shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! Read in atoms
      chkfile.look_for("Atomic numbers",from=1); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
      end

      ! Read in nuclear charges
      chkfile.look_for("Nuclear charges",from=1); chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(Nc)
         .atom(a).set_nuclear_charge(Nc)
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(.atom(a).position)
      end

      ! Read gaussian shell info.
      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + sum(atom_p)
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis. Expand out L shells.
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy
      G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy
      G_ex.destroy; G_cc.destroy

      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis 
      .::set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! Set atom/basis info
      .::set_atom_info
      .::resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf,n_independent)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .::swap_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .::swap_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .::swap_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .density_matrix.destroy
      .::read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.created) then
         if (.molecular_orbitals.restricted.created) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .::read_gX_MP2_dm(chkfile,restricted)

      ! Extract MP3 density matrix to file.  UHF untested
      .::read_gX_MP3_dm(chkfile,restricted)

      ! Extract CC density matrix to file.  UHF untested
      .::read_gX_CC_dm(chkfile,restricted)

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archiveive files
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .::resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   read_g94_FChk_file(name) ::: leaky
   ! Read a g94 checkpoint file (after fchk conversion to ASCII) into TONTO
      name :: STR, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")

      fchk :: STR
      chkfile :: TEXTFILE*
      shell_l,n_prim_for_shell,atom_for_shell,atom_p :: VEC{INT}*
      G_n_prim_for_shell,G_atom_for_shell,G_shell_type :: VEC{INT}*
      G_ex,G_cc,G_cp, ex,cc,orb_energy :: VEC{REAL}*
      temp_mat,DD,MO :: MAT{REAL}*
      Z, a,s,t, f,l,g,h :: INT
      n_prim_shells,n_shell,n_prim,n_independent :: INT
      restricted :: BIN
      archive :: ARCHIVE

      ! Destroy existing basis, and atom list
      if (.basis.created) .basis.destroy
      if (.atom.created)  .atom.destroy

      ! Create scfdata
      .scfdata.destroy
      .scfdata.create

      ! Get FChk file name
      if (present(name)) then;                 fchk = name
      else
         if (NOT stdin.buffer_exhausted) then; stdin.read(fchk) ! specified on stdin
         else;                                 fchk = .name
         end
      end

      ! Open FChk file
      chkfile.create(fchk)
      chkfile.open(for="read")
      chkfile.move_to_line(1)

      ! Read in basic stuff.
      chkfile.look_for("Number of atoms",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_atom)

      chkfile.look_for("Charge",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.charge)

      chkfile.look_for("Multiplicity",from=1)
      chkfile.move_to_line_item(3); chkfile.read(.spin_multiplicity)

      chkfile.look_for("Number of electrons",from=1)
      chkfile.move_to_line_item(5); chkfile.read(.n_e)

      chkfile.look_for("Number of alpha electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_a)

      chkfile.look_for("Number of beta electrons",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_b)

      chkfile.look_for("Number of basis functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(.n_bf)

      n_independent = .n_bf
      chkfile.look_for("Number of independant functions",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_independent)
      WARN_IF(.n_bf/=n_independent,"No. of basis functions different to no. of independent functions")
      WARN_IF(.n_bf/=n_independent,"The MO's will be wrong but the density matrix is correct")

      chkfile.look_for("Number of contracted shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_shell)

      chkfile.look_for("Number of primitive shells",from=1)
      chkfile.move_to_line_item(6); chkfile.read(n_prim_shells)

      chkfile.look_for("Total Energy",from=1)
      chkfile.move_to_line_item(4); chkfile.read(.scfdata.energy)

      ! Read in atoms
      chkfile.look_for("Atomic numbers",from=1); chkfile.read_line
      .atom.create(.n_atom)
      do a = 1,.n_atom
         chkfile.read(Z)
         .atom(a).set_atomic_number(Z)
      end

      ! Read in coordinates
      chkfile.look_for("Current cartesian coordinates",from=1)
      chkfile.read_line
      do a = 1,.n_atom
         chkfile.read(.atom(a).position)
      end

      ! Read gaussian shell info.
      G_shell_type.create(n_shell)
      G_n_prim_for_shell.create(n_shell)
      G_atom_for_shell.create(n_shell)
      G_ex.create(n_prim_shells)
      G_cc.create(n_prim_shells)

      chkfile.look_for("Shell types",from=1); chkfile.read_line
      chkfile.read(G_shell_type)
      DIE_IF(any(G_shell_type<-1),"unknown shell types exist")

      chkfile.look_for("Number of primitives per shell",from=1); chkfile.read_line
      chkfile.read(G_n_prim_for_shell)

      chkfile.look_for("Shell to atom map",from=1); chkfile.read_line
      chkfile.read(G_atom_for_shell)

      chkfile.look_for("Primitive exponents",from=1); chkfile.read_line
      chkfile.read(G_ex)

      chkfile.look_for("Contraction coefficients",from=1); chkfile.read_line
      chkfile.read(G_cc)

      ! SP type shells
      G_cp.create(n_prim_shells); G_cp = 0
      atom_p.create(.n_atom);     atom_p = 0
      if (any(G_shell_type==-1)) then
        do s = 1,n_shell
           if (G_shell_type(s)/=-1) cycle
           a = G_atom_for_shell(s)
           atom_p(a) = atom_p(a) + 1
           n_prim_shells = n_prim_shells + G_n_prim_for_shell(s)
        end
        chkfile.look_for("P(S=P)",from=1); chkfile.read_line
        chkfile.read(G_cp)
      end

      ! Get correct number of shells
      .n_shell = n_shell + sum(atom_p)
      atom_p.destroy

      ! Create basis set arrays
      shell_l.create(.n_shell)
      n_prim_for_shell.create(.n_shell)
      atom_for_shell.create(.n_shell)
      ex.create(n_prim_shells)
      cc.create(n_prim_shells)

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         stdout.show(" n_shell =", n_shell)
         stdout.show(".n_shell =",.n_shell)

         stdout.text("Shell types:")
         stdout.put(G_shell_type)

         stdout.text("Number of prims for:")
         stdout.put(G_n_prim_for_shell)

         stdout.text("Atom for shell:")
         stdout.put(G_atom_for_shell)

         stdout.text("Primitive exponents:")
         stdout.put(G_ex)

         stdout.text("Contractions:")
         stdout.put(G_cc)

         stdout.text("P(SP) contractions:")
         stdout.put(G_cp)

      end

      ! Copy the basis. 
      t = 0
      l = 0; h = 0

      do s = 1,n_shell

        t = t + 1
        n_prim = G_n_prim_for_shell(s)
        f = l + 1; l = l + n_prim
        g = h + 1; h = h + n_prim

        ! Expand out L shell
        if (G_shell_type(s)==-1) then

           shell_l(t) = 0                    ! S part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)

           t = t + 1
           f = l + 1
           l = l + n_prim
           shell_l(t) = 1                    ! P part of L shell
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)
           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cp(g:h)

        ! Normal shell
        else

           ex(f:l) = G_ex(g:h)
           cc(f:l) = G_cc(g:h)
           shell_l(t) = abs(G_shell_type(s)) ! WARNING: sometimes this can be -2
           n_prim_for_shell(t) = n_prim
           atom_for_shell(t) = G_atom_for_shell(s)

        end

      end

      G_cp.destroy
      G_shell_type.destroy
      G_atom_for_shell.destroy
      G_n_prim_for_shell.destroy
      G_ex.destroy
      G_cc.destroy
      
      ENSURE(.n_shell==t,"wrong number of shells")

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         stdout.text("ex:")
         stdout.put(ex)

         stdout.text("cc:")
         stdout.put(cc)

      end

      ! Set basis 
      .::set_basis_from_gX_data(shell_l,n_prim_for_shell,atom_for_shell,ex,cc)

      cc.destroy
      ex.destroy
      atom_for_shell.destroy
      n_prim_for_shell.destroy
      shell_l.destroy

      ! .basis.unnormalise ! NOTE this
      .::set_atom_info
      .::resolve_basis_info

      ! Read in orbital energies.
      orb_energy.create(n_independent)
      chkfile.look_for("Alpha Orbital Energies",from=1)
      chkfile.read_line; chkfile.read(orb_energy)
      .orbital_energies.destroy
      if (trim(chkfile.next_str)=="Beta") then
         restricted = FALSE
         .scfdata.set_scf_kind("uhf")
         .orbital_energies.create(.n_bf,"unrestricted")
         .orbital_energies.alpha = ZERO
         .orbital_energies.alpha(1:n_independent) = orb_energy
         chkfile.read_line; chkfile.read(orb_energy)
         .orbital_energies.beta = ZERO
         .orbital_energies.beta(1:n_independent) = orb_energy
         orb_energy.destroy
      else
         restricted = TRUE
         .scfdata.set_scf_kind("rhf")
         .orbital_energies.create(.n_bf,"restricted")
         .orbital_energies.restricted = ZERO
         .orbital_energies.restricted(1:n_independent) = orb_energy
         orb_energy.destroy
      end

      ! Read in molecular orbitals.
      temp_mat.create(.n_bf,n_independent)
      chkfile.look_for("Alpha MO",from=1)
      chkfile.read_line
      chkfile.read(temp_mat)

      .molecular_orbitals.destroy
      if (trim(chkfile.next_str)=="Beta") then
         .molecular_orbitals.create(.n_bf,"unrestricted")
         .molecular_orbitals.alpha = ZERO
         .molecular_orbitals.alpha(1:.n_bf,1:n_independent) = transpose(temp_mat)
         chkfile.read_line; chkfile.read(temp_mat)
         .molecular_orbitals.beta = ZERO
         .molecular_orbitals.beta(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .::swap_g94_orbital_order(.molecular_orbitals.alpha,"row")
         .::swap_g94_orbital_order(.molecular_orbitals.beta, "row")
      else
         .molecular_orbitals.create(.n_bf,"restricted")
         .molecular_orbitals.restricted = ZERO
         .molecular_orbitals.restricted(1:.n_bf,1:n_independent) = transpose(temp_mat)
         temp_mat.destroy
         .::swap_g94_orbital_order(.molecular_orbitals.restricted,"row")
      end

      ! Read in density matrix.
      .density_matrix.destroy
      .::read_gX_SCF_dm(chkfile,restricted,.density_matrix)

      ! Debug
      if (.::debugging("read_gaussian_FChk_file")) then

         if (.molecular_orbitals.created) then
         if (.molecular_orbitals.restricted.created) then
            MO => .molecular_orbitals.restricted(:,1:.n_a)
            DD.create(.n_bf,.n_bf)
            DD.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            DD = abs(DD - .density_matrix.restricted)
            stdout.text("Diff density matrix:")
            stdout.put(DD)
            stdout.show("max diff between MO reconstructed density =",maxval(DD))
            DD.destroy
         end
         end

      end

      ! Extract MP2 density matrix to file.  UHF untested
      .::read_gX_MP2_dm(chkfile,restricted)

      ! Extract MP3 density matrix to file.  UHF untested
      .::read_gX_MP3_dm(chkfile,restricted)

      ! Extract CC density matrix to file.  UHF untested
      .::read_gX_CC_dm(chkfile,restricted)

      ! Close chkfile
      chkfile.close; chkfile.destroy

      ! Save data in archiveive files
      archive.set_defaults
      archive.set(.name,"density_matrix")
      archive.write(.density_matrix)
      archive.set(.name,"molecular_orbitals")
      archive.write(.molecular_orbitals)
      archive.set(.name,"orbital_energies")
      archive.write(.orbital_energies)

      if (associated(.crystal)) then
         .::resolve_axis_system
         .crystal.make_fragment_data(.atom,assign_atom=TRUE)
      end

   end

   set_basis_from_gX_data(l_4_shell,n_cc_4_sh,atom_4_sh,ex_4_prim,cc_4_prim) ::: private, leaky
   ! Set the basis from gaussian data "XXX_4_sh" are the shell data
   ! flattened over all molecular shells. "XXX_4_prim" are (likewise)
   ! data flattened over molecular primitives.
      l_4_shell,n_cc_4_sh,atom_4_sh :: VEC{INT}, IN
      ex_4_prim,cc_4_prim :: VEC{REAL}, IN

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.atom.created,"no atonm list")
   ENSURE(.atom.dim==.n_atom,"wrong size, atom list")

      n_basis,n_shell,n_cc :: INT
      a,s,t, f,l, b :: INT
      basis :: BASIS*
      sh :: SHELL*
      same :: BIN

      ! Molecular basis (to be appended to)
      n_basis = 0
      .basis.create(n_basis)

      ! Basis fn/shell counters
      l = 0   ! Last primitive, flattened over all atoms
      t = 0   ! Last shell, flattened over all shells

      ! Loop atom "a"
      do a = 1,.n_atom

         ! Basis for atom "a"
         basis.create
         basis.label = trim(.atom(a).chemical_symbol) // ":gaussian"

         ! Set basis label and kind
         .atom(a).set_basis_label(basis.label)
         .atom(a).set_basis_kind("gaussian")

         ! No. of shells
         n_shell = count(atom_4_sh==a)

         ! Create basis shells
         basis.n_shell = n_shell
         basis.shell.create(n_shell)
         basis.shell.nullify_ptr_part

         ! Set basis shells
         do s = 1,n_shell

            ! This shell
            sh => basis.shell(s)

            ! Set shell L
            sh.set_l(l_4_shell(t+s))
            sh.set_n_comp

            ! Set shell n_cc
            n_cc    = n_cc_4_sh(t+s)
            sh.n_cc = n_cc

            ! Set shell exponents/contractions
            sh.exponent.create(n_cc)
            sh.contraction.create(n_cc)
            f = l + 1
            l = l + n_cc
            sh.exponent    = ex_4_prim(f:l)
            sh.contraction = cc_4_prim(f:l)

         end

         ! Set no. of bf'd and primitives
         basis.n_bf   = basis.no_of_basis_functions
         basis.n_prim = basis.no_of_primitives
         basis.unnormalise ! Note this

         t = t + n_shell

         ! Seen basis before?
         same = FALSE
         do b = 1,n_basis
            if (NOT .basis(b).same_as(basis)) cycle
            same = TRUE
            exit
         end

         ! Append only new basis to .basis
         if (NOT same) then
            n_basis = n_basis + 1
            .basis.append(basis)
         end

         ! Clean
         basis.destroy

      end

   end

   read_gX_dm(chkfile,restricted,dm) ::: template, private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
      chkfile :: TEXTFILE*
      restricted :: BIN, IN
      dm :: OPMATRIX*, optional

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.n_bf>0,"no basis functions")

      D,spin,total :: OPMATRIX*
      archive :: ARCHIVE

      ! Extract density matrix
      if (NOT chkfile.has_string("TAG Density")) return

      if (restricted) then

         ! Read restricted density (triangle) "name" into "D"
         D.create(.n_bf, "restricted")
         D.triangle.create(D.l_compress("restricted"))
         chkfile.look_for("Total TAG Density")
         chkfile.read_line
         chkfile.read(D.triangle)
         D.uncompress

         ! Swap orbital order
         .::swap_g94_orbital_order(D.restricted,"row")
         .::swap_g94_orbital_order(D.restricted,"column")

      else

         ! Create
         D.create(.n_bf,"unrestricted")
         total.create(.n_bf, "restricted")
         spin.create(.n_bf, "restricted")

         ! Read total density (triangle) TAG into "total"
         total.triangle.create(total.l_compress("restricted"))
         chkfile.look_for("Total TAG Density")
         chkfile.read_line
         chkfile.read(total.triangle)
         total.uncompress

         ! Read spin density (triangle) trim(tag) into "spin"
         spin.triangle.create(spin.l_compress("restricted"))
         chkfile.look_for("Spin TAG Density")
         chkfile.read_line
         chkfile.read(spin.triangle)
         spin.uncompress

         ! Define alpha and beta densities
         D.beta  = (total.restricted - spin.restricted)/2
         D.alpha = (spin.restricted  + total.restricted)/2

         ! Clean
         spin.destroy
         total.destroy

         ! Swap orbital order
         .::swap_g94_orbital_order(D.alpha,"row")
         .::swap_g94_orbital_order(D.alpha,"column")
         .::swap_g94_orbital_order(D.beta, "row")
         .::swap_g94_orbital_order(D.beta, "column")

      end

      ! Archive the density "D"
      archive.set_defaults
      archive.set(.name,NAME)
      archive.write(D)

      ! Clean
      if (present(dm)) then; dm => D
      else;                  D.destroy
      end

   end

   read_gX_SCF_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG=>SCF, NAME=>"SCF_density_matrix"), private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP2_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG=>MP2,  NAME=>"MP2_density_matrix"), private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_MP3_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG=>MP3,  NAME=>"MP3_density_matrix"), private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
   end

   read_gX_CC_dm(chkfile,restricted,dm) ::: get_from(read_gX_dm, TAG=>CC,  NAME=>"CC_density_matrix"), private
   ! Read a gaussian density matrix with TAG which may be
   ! "restricted" (or not) from "chkfile". Archive it as NAME.
   ! If "dm" is present it is created to be the density matrix.
   end

   swap_g94_orbital_order(X,swap)
   ! Swap the order of f orbitals on matrix "X" after reading a
   ! gaussian checkpoint file, for "swap" equal to "row" or "1", or
   ! "coloumn" or "2". Also: remove the intra-shell basis function
   ! normalisation factors which are not used in Tonto.
      X :: MAT{REAL}
      swap :: STR
      s,f,l,ls,fg,lg,i,j :: INT
      fac :: VEC{REAL}*
      ff :: VEC{INT}(10) = (/ 1, 2, 3, 5, 6, 4, 9, 7, 8, 10 /)
      select case (swap)
         case("row","1")
            do s = 1,.n_shell
               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)
               ENSURE(ls<=3,"cannot yet convert order for g shells")
               if (ls==3) then ! swap f functions
                  X(f:l,:) = X(f-1+ff,:)
               end
               if (ls>1) then  ! normalisation factors
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1     
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do i = f,l
                     X(i,:) = X(i,:)*fac(i-f+1)
                  end
               end
            end
         case("column","2")
            do s = 1,.n_shell
               f  = .first_basis_fn_for_shell(s)
               l  = .last_basis_fn_for_shell(s)
               ls = .angular_moment_for_shell(s)
               ENSURE(ls<=3,"cannot yet convert order for g shells")
               if (ls==3) then ! swap f functions
                  X(:,f:l) = X(:,f-1+ff)
               end
               if (ls>1) then  ! normalisation factors
                  lg = GAUSSIAN_DATA:n_comp_up_to(ls-1)
                  fg = lg + 1     
                  lg = lg + GAUSSIAN_DATA:n_comp(ls)
                  fac => GAUSSIAN_DATA::normalising_factors(fg:lg)
                  do j = f,l
                     X(:,j) = X(:,j)*fac(j-f+1)
                  end
               end
            end
         case default
            DIE("unknown swap kind, "//trim(swap))
      end
   end

!  ========================
!  AIM2000/Morphy interface
!  ========================

   write_morphy98_wfn_file ::: leaky
   ! Write a morphy98 .wfn file

   ENSURE(.occupation_numbers.created("restricted"), "No occupation numbers")
   ENSURE(.orbital_energies.created("restricted"), "No orbital energies")
   ENSURE(.molecular_orbitals.created("restricted"), "No orbitals")

      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}*
      evec :: VEC{REAL}*
      dmatrix, cc :: MAT{REAL}*
      sh :: SHELL*
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
!      title_format :: STR, parameter = "(A80)"
      n_vars_format :: STR, parameter = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "(1A4, I3, 1A30, F12.8, 1A15, F12.8)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(name)
      wfnfile.open(for="write")

      if (mod(.n_e, 2)==0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end

      write(unit = wfnfile.unit, fmt = '(a)') trim(name) // " computed by TONTO"
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).position, REALIFY(.atom(i).atomic_number) , i = 1, .n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )

      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atomn  = .atom_for_shell(a)
        shelln = .atom_shell_for_shell(a)
        sh => .atom(atomn).basis.shell(shelln)
        l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
        do j = 1, sh.n_cc
          if (sh.l==3) then
            lvec(pcount  ) = l + 1
            lvec(pcount+1) = l + 2
            lvec(pcount+2) = l + 3
            lvec(pcount+3) = l + 4
            lvec(pcount+4) = l + 5
            lvec(pcount+5) = l + 7
            lvec(pcount+6) = l + 6
            lvec(pcount+7) = l + 8
            lvec(pcount+8) = l + 9
            lvec(pcount+9) = l + 10
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              pcount = pcount + 1
            end
          else
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              lvec(pcount) = l + i
              pcount = pcount + 1
            end
          end
        end
      end

      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec

      lvec.destroy
      evec.destroy

      dmatrix.create(.n_prim, .n_bf)
      cc.create(.n_prim, .n_bf)

      .::make_contraction_matrix(cc)

      dmatrix.to_product_of(cc,.molecular_orbitals.restricted)

      do i = 1, n_orbitals
         write(unit = wfnfile.unit, fmt = mol_title_format) &
            "MO  ", i, &
            "OCC NO = ", .occupation_numbers.restricted(i), &
            " ORB. ENERGY = ", .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end

      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      if (.scfdata.created) then
      write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, TWO
      else
      write(unit = wfnfile.unit, fmt = e_v_format) ZERO, TWO
      end

      ! Clean
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy

   end

   write_aim2000_wfn_file ::: leaky
   ! Writes a proaim2000 .wfn file
   ENSURE(.occupation_numbers.created("restricted"), "No occupation numbers")
   ENSURE(.orbital_energies.created("restricted"), "No orbital energies")
   ENSURE(.molecular_orbitals.created("restricted"), "No orbitals")
      name :: STR
      wfnfile :: TEXTFILE*
      lvec :: VEC{INT}*
      evec :: VEC{REAL}*
      dmatrix, cc :: MAT{REAL}*
      sh :: SHELL*
      i, j, pcount, n_orbitals, a, l, atomn, shelln :: INT
!      title_format :: STR, parameter = "(A80)"
      n_vars_format :: STR, parameter = "(A8, 10X, I5, 15X, I5, 15X, I5, 17X)"
      atom_format :: STR, parameter = "(A5, I3, '    (CENTRE', 1I3, ') ', 3F12.8, '          ', F5.1)"
      c_assignment_format :: STR, parameter = "('CENTRE ASSIGNMENTS  ', 20I3)"
      t_assignment_format :: STR, parameter = "('TYPE ASSIGNMENTS    ', 20I3)"
      exponent_format :: STR, parameter = "('EXPONENTS ', 5D14.7)"
      mol_title_format :: STR, parameter = "('MO  ', I3,'    MO 0.0        OCC NO =',F13.7,'  ORB. ENERGY =',F12.7)"
      coefficient_format :: STR, parameter = "(5D16.8)"
      e_v_format :: STR, parameter = "(' THE HF ENERGY = ', F20.12, ' THE VIRIAL(-V/T)=', F13.8)"

      name = .name
      if (NOT stdin.buffer_exhausted) stdin.read(name)

      wfnfile.create(name)
      wfnfile.open(for="write")

      if (mod(.n_e, 2)==0) then
         n_orbitals = .n_e / 2
      else
         n_orbitals = (.n_e + 1) / 2
      end

      write(unit = wfnfile.unit, fmt = '(a)') trim(name) // " computed by TONTO"
      write(unit = wfnfile.unit, fmt = n_vars_format) "GAUSSIAN", n_orbitals, .n_prim, .n_atom
      write(unit = wfnfile.unit, fmt = atom_format) (.atom(i).label, i, i, &
         .atom(i).position, REALIFY(.atom(i).atomic_number) , i = 1, .n_atom)
      write(unit = wfnfile.unit, fmt = c_assignment_format) ((j, i = 1, .atom(j).n_prim ), j = 1, .n_atom )

      pcount = 1
      lvec.create(.n_prim)
      evec.create(.n_prim)
      do a = 1, .n_shell
        atomn  = .atom_for_shell(a)
        shelln = .atom_shell_for_shell(a)
        sh => .atom(atomn).basis.shell(shelln)
        l = GAUSSIAN_DATA:n_comp_up_to(sh.l) - sh.n_comp
        do j = 1, sh.n_cc
          if (sh.l==3) then
            lvec(pcount  ) = l + 1
            lvec(pcount+1) = l + 2
            lvec(pcount+2) = l + 3
            lvec(pcount+3) = l + 4
            lvec(pcount+4) = l + 5
            lvec(pcount+5) = l + 7
            lvec(pcount+6) = l + 6
            lvec(pcount+7) = l + 8
            lvec(pcount+8) = l + 9
            lvec(pcount+9) = l + 10
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              pcount = pcount + 1
            end
          else
            do i = 1, sh.n_comp
              evec(pcount) = sh.exponent(j)
              lvec(pcount) = l + i
              pcount = pcount + 1
            end
          end
        end
      end

      write(unit = wfnfile.unit, fmt = t_assignment_format) lvec
      write(unit = wfnfile.unit, fmt = exponent_format) evec

      lvec.destroy
      evec.destroy

      dmatrix.create(.n_prim, .n_bf)
      cc.create(.n_prim, .n_bf)

      .::make_contraction_matrix(cc)

      dmatrix.to_product_of(cc,.molecular_orbitals.restricted)

      do i = 1, n_orbitals
         write(unit=wfnfile.unit, fmt=mol_title_format) &
            i, .occupation_numbers.restricted(i), .orbital_energies.restricted(i)
         write(unit = wfnfile.unit, fmt = coefficient_format) dmatrix(:, i)
      end

      write(unit = wfnfile.unit, fmt = "(1A8)") "END DATA"
      if (.scfdata.created) then
      write(unit = wfnfile.unit, fmt = e_v_format) .scfdata.energy, 2.0D00
      else
      write(unit = wfnfile.unit, fmt = e_v_format) ZERO, 2.0D00
      end

      ! Clean
      cc.destroy
      dmatrix.destroy
      wfnfile.close
      wfnfile.destroy

   end

!  =====================================
!  Make molecule from atom or atom group
!  =====================================

   make_molecule_from_atom(n,mol) ::: leaky
   ! Make a fully fledged molecule "mol" from a single atom "n" in self
   ! The new molecule is ready for an SCF calculation.
   ! DANGER: see warnings below
      n :: INT, IN
      mol :: MOLECULE

   ENSURE(n<=.n_atom,"atom number n too big")

      i :: INT

      ! Clear the pointer part
      mol.::nullify_ptr_part

      ! Create the single atom and copy its pointers
      ! WARNING: dont destroy ptr parts of mol.atom 
      mol.atom.create(1)
      mol.atom(1) = .atom(n) ! <<< pointer copy here
      mol.atom(1).set_position([ZERO,ZERO,ZERO])

      ! Set default molecule e.g. the name, atom_info
      ! and default multiplicity ...
      mol.::set_defaults

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol 
      mol.::set_basis_data_from(self)

      ! Don't remake ANO data if there
      i = 0
      mol.::set_ANOs_from_sublist_of(self,[(i,i=n,n)])

      ! Set guess-type SCF defaults
      mol.::set_scf_guess_defaults_from(.scfdata)

   end

   make_molecule_from_atom_group(n,mol) ::: leaky
   ! Make a fully fledged molecule "mol" from group "n" of atoms
   ! specified in .atom_group(n).element(:), ready fro an SCF calculation.
      n :: INT
      mol :: MOLECULE

   ENSURE(.atom_group.created,"no atom_group info")
   ENSURE(n<=.atom_group.dim,"group number n too big")

      ! Clear the pointer part
      mol.::nullify_ptr_part

      ! Create the single atom and copy its pointers
      ! WARNING: dont destroy ptr parts of mol.atom 
      mol.atom.create(.atom_group(n).n_atoms)
      mol.atom = .atom(.atom_group(n).atom_index) 

      ! Set default molecule e.g. the name, atom_info
      ! and default multiplicity ...
      mol.::set_defaults

      ! Reset .name after .set_defaults
      mol.name              = .atom_group(n).name 
      mol.charge            = .atom_group(n).charge
      mol.spin_multiplicity = mol.::default_spin_multiplicity
      mol.::set_atom_info

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol !
      mol.::set_basis_data_from(self)

      ! Don't remake ANO data if there
      mol.::set_ANOs_from_sublist_of(self,.atom_group(n).atom_index)

      ! Assign the crystal
      ! WARNING: dont destroy ...
      if (.crystal.created) mol.crystal => .crystal

      ! Set guess-type SCF defaults
      mol.::set_scf_guess_defaults_from(.scfdata)

   end

!   make_scfdata_cluster_molecule(n,mol) ::: leaky
!   ! Make a fully fledged molecule "mol" from the cluster stored 
!   ! in the .scfdata.cluster "n".
!      n :: INT
!      mol :: MOLECULE
!
!   ENSURE(.scfdata.created,"no scfdata")
!   ENSURE(.scfdata.cluster.created,"no scfdata cluster")
!   ENSURE(.atom_group.created,"no atom_group info")
!   ENSURE(n<=.scfdata.cluster.n_molecules," n too big")
!
!      ! Clear the pointer part
!      mol.nullify_ptr_part
!
!      ! Create the single atom and copy its pointers
!      ! WARNING: dont destroy ptr parts of mol.atom 
!      mol.atom.create(.atom_group(n).n_atoms)
!      mol.atom = .atom(.atom_group(n).atom_index) 
!
!      ! Reset the .atom list to the cluster fragment
!      .cluster.create_fragment_atom_list(mol.atom) 
!      mol.set_atom_info
!      mol.resolve_basis_info
!      mol.set_basis_info
!
!      ! The name for the new cluster
!      mol.name = trim(.name) // "_" // trim(n.to_str)
!
!      ! If a CIF exists, copy that
!      if (.saved.cif.created) .cif.create_copy(.saved.cif)
!
!      ! We want the saved crystal 
!      ! It should be consistent with the cluster.
!      mol.crystal.create_copy(.crystal) 
!
!      ! Set up basis sets
!      if (.atom.created) .atom.nullify_bases
!      if (mol.basis.created)               mol.basis.create_copy(.basis)
!      if (.saved.slaterbasis.created)   mol.slaterbasis.create_copy(.slaterbasis)
!      if (.saved.coppensbasis.created)  mol.coppensbasis.create_copy(.coppensbasis)
!      mol.basis_name        = .saved.basis_name
!      mol.slaterbasis_name  = .saved.slaterbasis_name
!      mol.coppensbasis_name = .saved.coppensbasis_name
!      .resolve_basis_info
!      .set_basis_info
!
!   end

   set_basis_data_from(mol) ::: leaky
   ! Set the basis data from molecule "mol" 
   ! Make sure none of these bases are destroyed.
      mol :: MOLECULE, IN

      ! Copy the basis set and set the basis info
      ! WARNING: dont destroy basis of mol 
      .use_spherical_basis = mol.use_spherical_basis
      .basis              => mol.basis                   
      .slaterbasis        => mol.slaterbasis
      .coppensbasis       => mol.coppensbasis

      .::set_basis_info ! leaky

   end

   set_ANOs_from_sublist_of(mol,list) ::: private
   ! Set ANO data and atom shell info from molecule "mol" from the
   ! sublist "list". Make sure none of these are destroyed!
   ! NOTE: No point to assign unique data, all data is non-unique
      mol :: MOLECULE, IN
      list :: VEC{INT}, IN

   ENSURE(.atom.created,"no atoms")
   ENSURE(.n_atom_kind>0,"atoms not finalized")
   ENSURE(mol.atom.created,"mol has no atoms")
   ENSURE(mol.n_atom_kind>0,"mol atoms not finalized")
   ENSURE(list.dim==.atom.dim,"inconsistent list length")

      a,b :: INT
      made_ANO,made_int,made_shl :: BIN

      ! Assign ANO orbitals
      made_ANO = mol.::has_all_ANOs
      .atom.set_ANOs_made(made_ANO)
      if (made_ANO) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).density_matrix     => mol.atom(b).density_matrix
            .atom(a).natural_orbitals   => mol.atom(b).natural_orbitals
            .atom(a).occupation_numbers => mol.atom(b).occupation_numbers
            .atom(a).atomic_orbitals    => mol.atom(b).atomic_orbitals
            .atom(a).set_energy(mol.atom(b).energy)
         end
      end

      ! Assign ANO interpolators
      made_ANO = mol.::has_all_ANO_interpolators
      made_int = mol.::has_all_interpolators
      .atom.set_ANO_interpolators_made(made_ANO)
      .atom.set_interpolators_made(made_int)
      if (made_ANO OR made_int) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).interpolator => mol.atom(b).interpolator
         end
      end

      ! Assign atom shell info
      made_shl = mol.::has_all_atom_shell_info
      .atom.set_shell_info_made(made_shl)
      if (made_shl) then
         do a = 1,list.dim
            b = list(a)
            .atom(a).first_basis_fn_for_shell    => mol.atom(b).first_basis_fn_for_shell
            .atom(a).last_basis_fn_for_shell     => mol.atom(b).last_basis_fn_for_shell
            .atom(a).precomputed_basis_shellpair => mol.atom(b).precomputed_basis_shellpair
         end
      end

      ! Since all are ptr assigned, no atom is unique
      ! and all ptrs must be nullified
      .atom.set_is_unique_kind(FALSE)

   end

!  ===============
!  Atom group info
!  ===============

   make_atom_group_info ::: leaky
   ! Make the .atom_group information
   ENSURE(.atom.created,"atom groups must be defined after atoms=")

      mol :: MOLECULE*
      g :: INT

      do g = 1,.atom_group.dim 

         mol.::create

         .::make_molecule_from_atom_group(g,mol)

         .atom_group(g).mol => mol

      end

   end

   update_atom_group_info ::: leaky
   ! Make the .atom_group information
   ENSURE(.atom.created,"atom groups must be defined after atoms=")

      mol :: MOLECULE*
      g :: INT

      do g = 1,.atom_group.dim 

         mol => .atom_group(g).mol
         ENSURE(mol.created,"atom_group molecule "//trim(g.to_str)//" does not exist")

         ! Don't remake ANO data if there
         mol.::set_ANOs_from_sublist_of(self,.atom_group(g).atom_index)

         ! Assign the crystal
         ! WARNING: dont destroy ...
         if (.crystal.created) mol.crystal => .crystal

         ! Set guess-type SCF defaults
         mol.::set_scf_guess_defaults_from(.scfdata)

      end

   end

!  =================
!  VEC{ATOM} methods
!  =================

   default_spin_multiplicity result (res)
   ! Return the default multiplicity for a molecule.
      self :: IN
      res :: INT

   ENSURE(.atom.created,"no atom info")

      n_e :: INT

      n_e = .::no_of_electrons

      if (.atom.dim==1) then; res = .atom(1).ground_state_multiplicity(n_e)
      else;                   res = mod(n_e,2) + 1
      end

   end

   nuclear_repulsion_energy result (res)
   ! Return the nuclear repulsion energy
      res :: REAL

   ENSURE(.atom.created,"atom list required")

      i :: INT
      scf_kind :: STR

      scf_kind = "unknown"
      if (.scfdata.created) scf_kind = .scfdata.scf_kind

      i = 0
      res = ZERO
      select case (scf_kind)
         case ("embedded_rhf"); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
         case ("crystal_rhf "); res = .atom.nuclear_repulsion_energy([(i,i=1,.saved.n_atom)])
         case default;          res = .atom.nuclear_repulsion_energy
      end

   end

   nuclear_dipole_moment result (res)
   ! Return the nuclear dipole moment
      res :: VEC{REAL}(3)
      res = .atom.nuclear_dipole_moment
   end

   chemical_formula(with_spaces) result (res)
   ! Return the chemical formula for the molecule, as a string, in alphabetical
   ! order of elements
      with_spaces :: BIN, optional
      res :: STR
   ENSURE(.atom.created,"atom list required")
      res = .atom.chemical_formula(with_spaces)
   end

   centre_of_mass result(centre)
   ! Return the centre of mass
      centre :: VEC{REAL}(3)
   ENSURE(.atom.created,"atom list required")
      centre = .atom.centre_of_mass
   end

   centre_of_atoms result(centre)
   ! Return the centroid of the atom positions
      centre :: VEC{REAL}(3)
   ENSURE(.atom.created,"atom list required")
      centre = .atom.centre_of_atoms
   end

   change_to_principal_axes
   ! Move the origin to the centre of mass and change to the principal axis
   ! coordinate system
   ENSURE(.atom.created,"atom list required")
      .atom.change_to_principal_axes
   end

   change_to_principal_top_axes
   ! Move the origin to the centre of mass and change to the principal axis
   ! coordinate system, where the symmetric top axis is the z axis and where the
   ! determinant of the axes transformation is 1.
   ENSURE(.atom.created,"atom list required")
      .atom.change_to_principal_top_axes
   end

   molecular_weight result (res)
   ! Return the molceular weight
      res :: REAL
   ENSURE(.atom.created,"atom list required")
      res = .atom.molecular_weight
   end

   reduced_mass result (res)
   ! Return the reduced mass
      res :: REAL
   ENSURE(.atom.created,"atom list required")
      res = .atom.reduced_mass
   end

   move_origin_to_centre_of_mass
   ! Move the origin to the centre of mass
   ENSURE(.atom.created,"atom list required")

      .atom.move_origin_to_centre_of_mass

      if (.becke_grid.created) .becke_grid.set_grid_data(.atom) ! leaky

   end

   move_origin_to_centre_of_atoms
   ! Move the origin to the centre of atoms
   ENSURE(.atom.created,"atom list required")

      .atom.move_origin_to_centre_of_atoms

      if (.becke_grid.created) .becke_grid.set_grid_data(.atom) ! leaky

   end

   move_origin
   ! Move the origin by a user specified vector
   ENSURE(.atom.created,"atom list required")
   ENSURE(stdin.buffer.n_items==4 OR stdin.buffer.n_items==5,"origin shift needed on same line")
      shift :: VEC{REAL}(3)

      stdin.read(shift)
      .atom.translate_by(shift)

      if (.becke_grid.created) .becke_grid.set_grid_data(.atom) ! leaky

   end

   atom_index_from_position(pos) result (res)
   ! Return the index of atom from its position "pos"
      pos :: VEC{REAL}(3)
      res :: INT

   ENSURE(.atom.created,"atom list required")

      res = .atom.atom_index_from_position(pos)

   end

   put_coordinates_to(g,positions_as_rows,skip_dummies)
   ! Put the atom coordinates to "g"
      g :: MAT{REAL}
      positions_as_rows :: BIN, IN
      skip_dummies :: BIN, IN, optional

   ENSURE(.atom.created,"no atom list")

      .atom.put_coordinates_to(g,positions_as_rows,skip_dummies)

   end


   has_all_ANOs result (res)
   ! Return TRUE if the ANO data is made for every atom.
      res :: BIN
      res = .atom.created
      if (res) res = .atom.has_all_ANOs
   end

   has_all_ANO_interpolators result (res)
   ! Return TRUE if the ANO interpolators are made for every atom.
      res :: BIN
      res = .atom.created
      if (res) res = .atom.has_all_ANO_interpolators
   end

   has_all_interpolators result (res)
   ! Return TRUE if the per-atom interpolators are made for every atom.
      res :: BIN
      res = .atom.created
      if (res) res = .atom.has_all_interpolators
   end

   has_all_spherical_atom_data result (res)
   ! Return TRUE if the per-atom interpolators are made for every atom.
      res :: BIN
      res = .atom.created
      if (res) res = .atom.has_all_spherical_atom_data
   end

   has_all_atom_shell_info result (res)
   ! Return TRUE if the per-atom interpolators are made for every atom.
      res :: BIN
      res = .atom.created
      if (res) res = .atom.has_all_shell_info
   end

!  ===============
!  Inquiry methods
!  ===============

   no_of_electrons result (res)
   ! Work out and return the number of electrons in the molecule.
      res :: INT

   ENSURE(.atom.created,  "no atom list")

      res = .atom.no_of_electrons - .charge

   end

   no_of_alpha_electrons result (res)
   ! Work out and return the number of alpha electrons in the molecule.
      res :: INT

      res = .::no_of_electrons - .::no_of_beta_electrons

   end

   no_of_beta_electrons result (res)
   ! Work out and return the number of beta electrons in the molecule
      res :: INT

      tmp :: INT

      tmp = .::no_of_electrons - .::no_of_unpaired_electrons

      res = tmp/2

      ENSURE(tmp.is_even,"Inconsistent multiplicity, non integer # of beta electrons")

   end

   has_valid_no_of_beta_electrons result (res)
   ! Return TRUE if the number of beta electrons is valid based on the
   ! assigned charge and multiplicity i.e. it must come out integral.
      res :: BIN

      tmp :: INT

      tmp = .::no_of_electrons - .::no_of_unpaired_electrons

      res = tmp.is_even

   end

   no_of_unpaired_electrons result (res)
   ! Work out and return the number of unpaired electrons in the molecule
      res :: INT

      res = .spin_multiplicity - 1

      ENSURE(res<=.::no_of_electrons,"Wrong multiplicity, not enough electrons")

   end

   no_of_atom_pairs result (res)
   ! Return the number of atom pairs in the molecule
      res :: INT
   ENSURE(.atom.created,"no atom list")
      res = .n_atom*(.n_atom+1)/2
   end

   no_of_shell_pairs result (res)
   ! Return the number of shell pairs in the basis set for the molecule
      res :: INT

   ENSURE(.atom.created,  "no atom list")
   ENSURE(.atom.bases_are_resolved,"gaussian bases not all resolved")

      n_shell :: INT

      n_shell = .atom.n_shell
      res     = n_shell*(n_shell+1)/2

   end

   n_shell_quartets result (res)
   ! Return the number of shell quartets in the basis set for the molecule
   ! Note, "res" will die at 22 shells for integer(2).
   !       "res" will die at 361 shells for integer(4).
   !       "res" will die at 92681 shells for integer(8).
      res :: INT

      n_shell_pair :: INT

      n_shell_pair = .::no_of_shell_pairs

      if (n_shell_pair/sqrt(TWO) <= (huge(n_shell_pair))**HALF) then
         res = n_shell_pair*(n_shell_pair+1)/2
      else
         WARN("too many shells")
         res = 0
      end

   end

   no_of_occupied_NOs(genre,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      genre :: STR, optional
      tol :: REAL, optional
      res :: INT
   ENSURE(.occupation_numbers.created,"no occupation numbers")
      res = .occupation_numbers.no_of_occupied(genre,tol)
   end

   DFT_grid_info_made result (res)
   ! Return TRUE if the DFT grid information is made
      res :: BIN
      res = .becke_grid.created  &
          AND .overlapping_atoms.created &
          AND .overlapping_atoms_for_atom.created
   end

   has_Hirshfeld_inputs result (res)
   ! Return TRUE if the inputs for a Hirshfeld calc are there
      res :: BIN
      res =  .::DFT_grid_info_made &
         AND .::has_all_ANOs &
         AND ( .::has_all_ANO_interpolators &
         OR    .::has_all_interpolators &
         OR    .::has_all_spherical_atom_data ) 
   end

!  =================
!  Overlapping atoms
!  =================

   is_overlapping_atom(a,b) result (res)
   ! Return TRUE if atoms "a" and "b" overlap.
      a,b :: INT, IN
      res :: BIN

   ENSURE(.overlapping_atoms.created,"no .overlapping_atoms")

      aa,bb,ab :: INT

      if (a==b) then
         res = TRUE
      else
         aa = max(a,b)
         bb = min(a,b)
         ab = int(HALF*aa*(aa-1)) + bb
         res = .overlapping_atoms(ab)
      end

   end

   is_overlapping_atom(a,list) result (res)
   ! Return TRUE if atom "a" overlaps with *any* atoms in the "list".
      a :: INT, IN
      list :: VEC{INT}, IN
      res :: BIN

   ENSURE(.overlapping_atoms.created,"no .overlapping_atoms")

      i,b,aa,bb,ab :: INT

      res = FALSE

      do i = 1,list.dim

         b = list(i)

         if (a==b) then
            res = TRUE
            exit
         else
            aa = max(a,b)
            bb = min(a,b)
            ab = int(HALF*aa*(aa-1)) + bb
            if (.overlapping_atoms(ab)) then
               res = TRUE
               exit
            end
         end

      end

   end

   overlapping_atoms_for(list) result (res) ::: leaky
   ! Return the list of atoms which overlaps with those in "list".
      list :: VEC{INT}, IN
      res :: VEC{INT}*

      a,k :: INT

      res.create(.n_atom)

      k = 0

      do a = 1,.n_atom

         if (NOT .::is_overlapping_atom(a,list)) cycle

         k = k + 1
         res(k) = a

      end

      res.shrink(k)

   end

   make_max_S_for_shell_pairs(max_S)
   ! Make "max_S", the maximum of the overlap integrals between basis
   ! functions in pairs of shells.
      max_S :: VEC{REAL}

   ENSURE(.overlap_matrix.created,"no overlap_matrix")
   ENSURE(max_S.dim==.::no_of_shell_pairs,"wrong size, S_max")

      ab,a,b,fa,fb,la,lb :: INT

      do ab = 1,.n_shell_pairs

         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2

         fa = .first_basis_fn_for_shell(a)
         la = .last_basis_fn_for_shell(a)
         fb = .first_basis_fn_for_shell(b)
         lb = .last_basis_fn_for_shell(b)

         max_S(ab) = maxval(abs(.overlap_matrix(fa:la,fb:lb)))

      end

   end

! Below does not work ... but it does with lower cutoff

   make_overlapping_atoms ::: leaky
   ! Make the list of overlapping atoms
   ENSURE(.basis_info_made,"no basis set")
   ENSURE(.becke_grid.created,"no becke_grid")

      r_max :: VEC{REAL}*
      d :: VEC{REAL}(3)
      r :: REAL
      a,b,ab,n_atom_pairs :: INT

      n_atom_pairs = .::no_of_atom_pairs

      ! Overlapping atoms pair array
      .overlapping_atoms.destroy
      .overlapping_atoms.create(n_atom_pairs)

      ! Overlapping atoms list array
      .overlapping_atoms_for_atom.destroy
      .overlapping_atoms_for_atom.create(.n_atom)

      ! Make the maximum radii
      r_max.create(.n_atom)
      do a = 1,.n_atom
         ! sqrt because we are dealing with overlaps
         r_max(a) = .atom(a).r_max(.becke_grid.basis_function_cutoff)
      end 

      .::put_debug(r_max,"make_overlapping_atoms: r_max")

      ! Make the overlapping atom arrays
      do ab = 1,n_atom_pairs
         a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
         b = ab - a*(a-1)/2
         d = .atom(a).position - .atom(b).position
         r = sqrt(dot_product(d,d))
         if (r>(r_max(a)+r_max(b))) then
            .overlapping_atoms(ab) = FALSE
         else 
            .overlapping_atoms(ab) = TRUE
         end
      end

      ! Make the overlapping atom arrays
      do a = 1,.n_atom

         ! Atom a overlaps itself
         .overlapping_atoms_for_atom(a).element.append(a)

         ! Loop over other atoms "b"
         do b = 1,a-1

            ! Distance "r" to atom "b"
            d = .atom(a).position - .atom(b).position
            r = sqrt(dot_product(d,d))
            if (r>(r_max(a)+r_max(b))) cycle

            ! Atoms "a" and "b" overlap
            .overlapping_atoms_for_atom(a).element.append(b)
            .overlapping_atoms_for_atom(b).element.append(a)

         end

      end

      r_max.destroy

      ! Reorder the lists
      do a = 1,.n_atom
         .overlapping_atoms_for_atom(a).element.sort
      end 

   end

!   make_overlapping_atoms2 ::: leaky
!   ! Make the list of overlapping atoms
!   ENSURE(.basis_info_made,"no basis set")
!   ENSURE(.scfdata.created,"no scfdata")
!      S_max :: VEC{REAL}*
!      n_atom_pairs :: INT
!      n_atom_pairs = .no_of_atom_pairs
!      .overlapping_atoms.destroy
!      .overlapping_atoms.create(n_atom_pairs)
!      S_max.create(n_atom_pairs)
!      .make_S_max_for_atom_pairs(S_max)
!      .overlapping_atoms = S_max>.scfdata.atom_overlap_cutoff
!      S_max.destroy
!   end
!
!   make_S_max_for_atom_pairs(S_max)
!   ! Make "S_max", the maximum of the overlap integrals between *pairs of atoms*
!      S_max :: VEC{REAL}
!   ENSURE(S_max.dim==.no_of_atom_pairs,"wrong size, S_max")
!      ab,a,b,fa,fb,la,lb :: INT
!      do ab = 1, .no_of_atom_pairs
!       a = (1+int(sqrt(EIGHT*ab-SEVEN)))/2
!       b = ab - a*(a-1)/2
!       fa = .first_basis_fn_for_atom(a)
!       la = .last_basis_fn_for_atom(a)
!       fb = .first_basis_fn_for_atom(b)
!       lb = .last_basis_fn_for_atom(b)
!       S_max(ab) = maxval(.overlap_matrix(fa:la,fb:lb))
!      end
!   end

!  =================
!  Atom pair indices
!  =================

   get_atom_pair_indices(index,a,b,fa,la,na,fb,lb,nb) 
   ! Return the atom indicies "a" and "b" which map to an atom-pair "index".
   ! Also get "fa", "la" and "fb", "lb", the indices of first and last basis
   ! functions for atoms "a" and "b", and "na" and "nb", the number of basis
   ! functions on those atoms, respectively. NOTE: "fa" and "fb" are actually
   ! the first basis functions for atoms "a" and "b" *minus 1*.  
      index :: INT, IN
      a,b,fa,la,na,fb,lb,nb :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_atom(a) - 1
      la =  .last_basis_fn_for_atom(a)
      na = la - fa

      fb = .first_basis_fn_for_atom(b) - 1
      lb =  .last_basis_fn_for_atom(b)
      nb = lb - fb

   end

!  ==================================
!  VEC{ATOM} shell extraction methods
!  ==================================

   get_shell(shell,index) ::: leaky
   ! Get basis set "shell" corresponding to "index"
      self :: IN
      index :: INT, IN
      shell :: SHELL, OUT
      aa,sa :: INT
      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      shell.copy(.atom(aa).basis.shell(sa) )
   end

   get_shell(shell,index) ::: leaky
   ! Update the shell1 "shell".
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   get_shell(shell,index,fa,la) ::: leaky
   ! Get the "index"-th "shell" of the basis set with first bf index
   ! "fa", last bf index "la".
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

   get_shell(shell,index,fa,la,na) ::: leaky
   ! Get the "index"-th "shell" of the basis set with first bf index
   ! "fa", last bf index "la", and "na" the no. of bf's in the shell.
      self :: IN
      index :: INT, IN
      shell :: SHELL1, OUT
      fa,la,na :: INT, OUT

      aa,sa :: INT

      aa = .atom_for_shell(index)
      sa = .atom_shell_for_shell(index)
      fa = .first_basis_fn_for_shell(index)
      la = .last_basis_fn_for_shell(index)
      na = la - fa + 1

      shell.copy(.atom(aa).basis.shell(sa),.atom(aa).position)

   end

!  ==================
!  Shell pair indices
!  ==================

   get_shell_pair_indices(index,a,b,fa,la,na,fb,lb,nb)
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      a,b,fa,la,fb,lb,na,nb :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      na = la - fa + 1
      nb = lb - fb + 1

   end

   get_shell_pair_indices(index,a,b,fa,la,na,fb,lb,nb,atom_a,atom_b)
   ! Return the shell indicies "a" and "b" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
   ! Also return the atom indices "atom_a" and "atom_b" for each shell.
      index :: INT, IN
      a,b,fa,la,na,fb,lb,nb,atom_a,atom_b :: INT, OUT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      na = la - fa + 1
      nb = lb - fb + 1

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

   end

!  ===========
!  Shell pairs
!  ===========

   get_precomputed_shell_pair(shell,index,fa,la,na,fb,lb,nb) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      fa,la,na,fb,lb,nb :: INT, OUT
      a,b,aa,sa,bb,sb :: INT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb), & 
         .atom(aa).position,.atom(bb).position, &
         aa==bb,skip=FALSE)

      ! Debug
      .::put_debug(shell,"get_precomputed_shell_pair: shell")

   end

   get_precomputed_shell_pair(shell,index,fa,la,na,fb,lb,nb,atom_a,atom_b) ::: leaky
   ! Get the SHELL2 object "shell" correponding to the pair index "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL2, OUT
      fa,la,na,fb,lb,nb,atom_a,atom_b :: INT, OUT
      a,b,sa,sb :: INT

      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      b  = index - a*(a-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)

      na = la - fa + 1
      nb = lb - fb + 1

      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)
      sb = .basis_shell_for_shell(b)

      shell.set_and_precompute_from(.precomputed_basis_shellpair(sa,sb), & 
         .atom(atom_a).position,.atom(atom_b).position, &
         atom_a==atom_b,FALSE)

   end

!  =====================
!  Shell quartet indices
!  =====================

   get_shell_quartet_indices(index,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky
   ! For the quartet index "index" return the shell indicies "a", "b",
   ! "c" and "d" which map to "index". Also return the basis function
   ! start indices "fa", "la", etc ...
      index :: INT, IN
      fa,la,fb,lb,fc,lc,fd,ld :: INT, OUT
      a,b,c,d :: INT
      ab,cd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)
      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)

   end

   get_shell_quartet_indexes(index,a,b,c,d,atom_a,atom_b,atom_c,atom_d)
   ! For the quartet index "index" return the shell indicies "a", "b", "c" and
   ! "d" which map to "index" and the corresponding atom centers. Note different
   ! spelling for this routine and the one above to avoid overload problems.
      index :: INT, IN
      a,b,c,d,atom_a,atom_b,atom_c,atom_d :: INT, OUT
      ab,cd :: INT
      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      atom_b = .atom_for_shell(b)
      atom_c = .atom_for_shell(c)
      atom_d = .atom_for_shell(d)
   end

!  ==============
!  Shell quartets
!  ==============

   copy_shell_quartet(shell,a,b,c,d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the indicies "a", "b", "c"
   ! and "d".
      shell :: SHELL4, OUT
      a,b,c,d :: INT, IN
      aa,sa,bb,sb,cc,sc,dd,sd :: INT

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

   end

   copy_shell_quartet(shell,index,a,b,c,d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d :: INT, OUT
      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2

      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)
      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)
      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

   end

   copy_shell_quartet(shell,index,a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Also return the basis function start indices "fa", "la", etc ...
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d,fa,la,fb,lb,fc,lc,fd,ld :: INT, OUT
      ab,cd,aa,sa,bb,sb,cc,sc,dd,sd :: INT

      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2

      aa = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      bb = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      cc = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      dd = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)

      shell.copy(.atom(aa).basis.shell(sa), .atom(bb).basis.shell(sb), &
                 .atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(aa).position, .atom(bb).position,               &
                 .atom(cc).position, .atom(dd).position )

      fa = .first_basis_fn_for_shell(a)
      fb = .first_basis_fn_for_shell(b)
      fc = .first_basis_fn_for_shell(c)
      fd = .first_basis_fn_for_shell(d)

      la = .last_basis_fn_for_shell(a)
      lb = .last_basis_fn_for_shell(b)
      lc = .last_basis_fn_for_shell(c)
      ld = .last_basis_fn_for_shell(d)

   end

   copy_shell_quartet(shell,index,a,b,c,d,atom_a,atom_b,atom_c,atom_d) ::: leaky
   ! Get the SHELL4 object "shell" correponding to the quartet index "index"
   ! Also return the shell indicies "a", "b", "c" and "d" which map to "index"
   ! Plus the atoms which the shells are on.
      index :: INT, IN
      shell :: SHELL4, OUT
      a,b,c,d,atom_a,atom_b,atom_c,atom_d :: INT, OUT
      ab,cd,sa,sb,sc,sd :: INT
      ab = (1+int(sqrt(8.0d0*index-7.0d0)))/2
      cd = index - ab*(ab-1)/2
      a  = (1+int(sqrt(8.0d0*ab-7.0d0)))/2
      b  = ab - a*(a-1)/2
      c  = (1+int(sqrt(8.0d0*cd-7.0d0)))/2
      d  = cd - c*(c-1)/2
      atom_a = .atom_for_shell(a)
      sa = .atom_shell_for_shell(a)
      atom_b = .atom_for_shell(b)
      sb = .atom_shell_for_shell(b)
      atom_c = .atom_for_shell(c)
      sc = .atom_shell_for_shell(c)
      atom_d = .atom_for_shell(d)
      sd = .atom_shell_for_shell(d)
      shell.copy(.atom(atom_a).basis.shell(sa), .atom(atom_b).basis.shell(sb), &
                 .atom(atom_c).basis.shell(sc), .atom(atom_d).basis.shell(sd), &
                 .atom(atom_a).position, .atom(atom_b).position, &
                 .atom(atom_c).position, .atom(atom_d).position )
   end

   copy_shell_quartet_ab(shell,a,b) ::: leaky
   ! Set the a and b parts of the "shell" SHELL4 object.
      shell :: SHELL4, INOUT
      a,b :: INT, IN
      aa,sa,bb,sb :: INT

      aa = .atom_for_shell(a)
      bb = .atom_for_shell(b)

      sa = .atom_shell_for_shell(a)
      sb = .atom_shell_for_shell(b)

      shell.copy_ab(.atom(aa).basis.shell(sa), &
                    .atom(bb).basis.shell(sb), &
                    .atom(aa).position, .atom(bb).position)

   end

   copy_shell_quartet_cd(shell,c,d) ::: leaky
   ! Set the c and d parts of the "shell" SHELL4 object.
      shell :: SHELL4, INOUT
      c,d :: INT, IN
      cc,sc,dd,sd :: INT

      cc = .atom_for_shell(c)
      dd = .atom_for_shell(d)

      sc = .atom_shell_for_shell(c)
      sd = .atom_shell_for_shell(d)

      shell.copy_cd(.atom(cc).basis.shell(sc), .atom(dd).basis.shell(sd), &
                 .atom(cc).position, .atom(dd).position)

   end


   set_new_shell_quartet_ab(shell,a,b,skip) ::: leaky
   ! Set the "a" and "b" parts of the "shell" SHELL4 object. If "skip" is TRUE
   ! then some primitive pairs are ignored, if too small (this should not be set
   ! if any atoms in the qurtet are the same; if in doubt set skip=FALSE).
      shell :: SHELL1QUARTET, INOUT
      a,b :: INT, IN
      skip :: BIN

      aa,sa,bb,sb :: INT

      aa = .atom_for_shell(a)         !which atom.
      bb = .atom_for_shell(b)

      sa = .basis_shell_for_shell(a)  !which shell.
      sb = .basis_shell_for_shell(b)

      shell.set_ab_new(.precomputed_basis_shellpair(sa,sb),   &
                       .atom(aa).position,.atom(bb).position, &
                       aa==bb,skip)

   end

   set_new_shell_quartet_cd(shell,c,d,skip) ::: leaky
   ! Set the "c" and "d" parts of the "shell" SHELL4 object. If "skip" is TRUE
   ! then some primitive pairs are ignored, if too small (this should not be set
   ! if any atoms in the qurtet are the same; if in doubt set skip=FALSE).
      shell :: SHELL1QUARTET, INOUT
      c,d :: INT, IN
      skip :: BIN

      cc,sc,dd,sd :: INT

      cc = .atom_for_shell(c)         !which atom.
      dd = .atom_for_shell(d)

      sc = .basis_shell_for_shell(c)  !which shell.
      sd = .basis_shell_for_shell(d)

      shell.set_cd_new(.precomputed_basis_shellpair(sc,sd),   &
                       .atom(cc).position,.atom(dd).position, &
                       cc==dd,skip)

   end

!  ======================
!  Make shell information
!  ======================

   make_shell_info ::: leaky
   ! Define a vector of atom numbers corresponding to the molecule's
   ! basis set shell numbers; also define a vector of atom shell numbers
   ! corresponding to the molecule basis set shell number
   ENSURE(.atom.created,"no atom information")
   ENSURE(.atom.bases_are_resolved,"gaussian bases not all resolved")
   ENSURE(.n_atom>0,"no atoms")
   ENSURE(.basis.created,"no basis set")

      ! Set basis l_max before anything else
      .basis_l_max = .basis.maximum_basis_set_l_value
      GAUSSIAN_DATA:set_indices(.basis_l_max) 

      ! Set atom for shell 
      .atom_for_shell.destroy
      .atom_shell_for_shell.destroy
      .atom_for_shell       => .atom.atom_for_shell
      .atom_shell_for_shell => .atom.atom_shell_for_shell

      ! Set first/last shell for atom 
      .first_shell_for_atom.destroy
      .last_shell_for_atom.destroy
      .first_shell_for_atom.create(.n_atom)
      .last_shell_for_atom.create(.n_atom)
      .atom.make_shell_for_atom_limits(.first_shell_for_atom,.last_shell_for_atom)

      ! Set first/last bf for shell
      .first_basis_fn_for_shell.destroy
      .last_basis_fn_for_shell.destroy
      .angular_moment_for_shell.destroy
      .atom.make_shell_limits(.first_basis_fn_for_shell,.last_basis_fn_for_shell,.angular_moment_for_shell)

      ! Set first/last bf for atom
      .first_basis_fn_for_atom.destroy
      .last_basis_fn_for_atom.destroy
      .atom.make_atom_basis_fn_limits(.first_basis_fn_for_atom,.last_basis_fn_for_atom)

      ! Shell pointer into flattened .basis vector
      .::make_basis_shell_for_shell

      ! Precalculate non-positional basis-pair information
      .::make_precomputed_shellpairs

   end

   make_precomputed_shellpairs ::: leaky
   ! Make a SHELLPAIR vector "shellpair" which includes precomputed data for the
   ! basis set.
   ! NOTE for later: n_unique_shells should be a basisvec routine.
   ! NOTE for later: precomputed_basis_shellpair should be a MAT{REAL} type

   ENSURE(.basis.created,"no basis set")
      i,j,a,b,p,q :: INT

      .n_unique_shells = .basis.no_of_shells

      ! Recreate
      .precomputed_basis_shellpair.destroy
      .precomputed_basis_shellpair.create(.n_unique_shells,.n_unique_shells)

      ! Loop over bases "p"
      p = 0
      do i = 1,.basis.dim    
      do a = 1,.basis(i).n_shell

        p = p + 1

        ! Loop over bases "q"
        q = 0
        do j = 1,.basis.dim 
        do b = 1,.basis(j).n_shell

           q = q + 1

           ! Copy the shells
           .precomputed_basis_shellpair(p,q).copy_a(.basis(i).shell(a))
           .precomputed_basis_shellpair(p,q).copy_b(.basis(j).shell(b))

           ! Precalculate non-positional info
           .precomputed_basis_shellpair(p,q).make_precalculated_data

        end
        end

      end
      end

   end

   first_basis_shell_for_atom(atom) result (res)
   ! Return the index of the first shell in .basis (treating .basis as a
   ! flattened list of shells) which has the same basis label as "atom".
   ! NOTE for later: this should be a basisvec routine.
      atom :: INT, IN
      res :: INT

      i,j :: INT

      res = 0

      i = 1
      ! Loop over bases
      do j = 1,.basis.dim 
         if (.basis(j).label==.atom(atom).basis.label) then
            res = i
            exit
         else
            i = i + .basis(j).n_shell
         end
      end

      DIE_IF(res==0,"atom basis label not found")

   end

   make_basis_shell_for_shell ::: leaky
   ! Return the index of the first shell in .basis (treating .basis as
   ! a flattened list of shells) for a given shell index in the
   ! molecular basis set (i.e. the flattened list of shells in the
   ! .atom list).  NOTE for later: this should be a basisvec routine.
   ENSURE(.basis.created,"no basis set")

      sh,at,atom_shell,ind :: INT

      .basis_shell_for_shell.destroy
      .basis_shell_for_shell.create(.n_shell)

      do sh = 1,.n_shell

         ! Which atom?
         at = .atom_for_shell(sh)                 

         ! Which shell for this atom?
         atom_shell = .atom_shell_for_shell(sh)   

         ! First shell for this atom in the basis set
         ind = .::first_basis_shell_for_atom(at)    

         ! The shell-index for the flattened basis vector
         .basis_shell_for_shell(sh) = ind + atom_shell - 1

      end

   end

!  ===============
!  Atom-shell info
!  ===============

   make_atom_shell_info ::: leaky
   ! Get the atom shell info for all atoms in the molecule. We make it
   ! only for the unique atoms and pointer copy to the non-unique
   ! atoms, just like for ANO atom information.
   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.basis.created,"no basis set")
   ENSURE(.n_atom_kind>0,"no atom kinds set")

      kind,a,b :: INT
      atom_a,atom_b :: ATOM*

      if (.::has_all_atom_shell_info) return

      ! Destroy ...  in case .ANO_data_made 
      ! was deliberately set FALSE
      .::destroy_atom_shell_info

      do a = 1,.n_atom

         atom_a => .atom(a)

         ! Unique atom?
         if (NOT atom_a.is_unique_kind) cycle

         kind = atom_a.kind

         ! Make the shell info
         atom_a.make_shell_info
 
         ! Copy it to non-unique atoms
         do b = a+1,.n_atom

            atom_b => .atom(b)

            if (atom_b.kind/=kind) cycle

            atom_b.first_basis_fn_for_shell    => atom_a.first_basis_fn_for_shell
            atom_b.last_basis_fn_for_shell     => atom_a.last_basis_fn_for_shell
            atom_b.precomputed_basis_shellpair => atom_a.precomputed_basis_shellpair

         end

      end

      .atom.set_shell_info_made(TRUE)

   end

!  ========================
!  Contraction Coefficients
!  ========================

   make_contraction_matrix(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each basis set
   ! Size of cc_mat is [.n_prim,.n_bf].
      cc_mat :: MAT{REAL}, OUT
   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      b = 1
      p = 1
      cc_mat = ZERO
      do a = 1,.n_atom
         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf
         .atom(a).basis.make_contraction_matrix(cc_mat(p:p+ap-1,b:b+ab-1))
         p = p + ap
         b = b + ab
      end

   end

   make_normalised_contraction_mx(cc_mat)
   ! Returns the matrix of complete contraction coefficients for each
   ! basis set. Size of cc_mat is [.n_prim,.n_bf]. Primitive components
   ! are properly normalised.
      cc_mat :: MAT{REAL}, OUT
   ENSURE(cc_mat.dim1==.n_prim,"wrong shape, cc_mat")
   ENSURE(cc_mat.dim2==.n_bf,  "wrong shape, cc_mat")

      a,b,p,ap,ab :: INT

      .basis.renormalise

      b = 1
      p = 1
      cc_mat = ZERO
      do a = 1,.n_atom
         ap = .atom(a).basis.n_prim
         ab = .atom(a).basis.n_bf
         .atom(a).basis.make_normalised_contraction_mx(cc_mat(p:p+ap-1,b:b+ab-1))
         p = p + ap
         b = b + ab
      end

      .basis.unnormalise

   end

!  ======================
!  Density matrix methods
!  ======================

   make_density_matrix_from_NOs ::: leaky
   ! Make the .density_matrix from the *natural_orbitals* and the
   ! *occupation_numbers* vector. Only restricted so far.

   ENSURE(.occupation_numbers.created, "no occupation numbers")
   ENSURE(.natural_orbitals.created, "no natural orbitals")

      NO,D :: MAT{REAL}*
      occ :: VEC{REAL}*
      genre :: STR
      arch :: ARCHIVE

      genre = .natural_orbitals.spinorbital_kind

      ! Destroy
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)

      ! Make it
      select case (genre)

         case ("restricted")

            ENSURE(.natural_orbitals.created("restricted"),"no NO's")
            
            occ.create(.n_bf)
            NO.create(.n_bf,.n_bf)
            
            occ = sqrt(.occupation_numbers.restricted)
            NO.to_product_with_diagonal(.natural_orbitals.restricted,occ)
            D => .density_matrix.restricted
            D.to_product_of(NO,NO,transpose_b=TRUE)
            
            NO.destroy
            occ.destroy

         case default

            DIE("unknown SCF kind, "//trim(genre))

      end

      ! Archive
      arch.set(.name,"density_matrix",genre)
      arch.write(.density_matrix)

   end

   make_scf_density_matrix(damp,n_a,method) ::: leaky
   ! Make the density matrix from the molecular orbitals. If "damp" is present
   ! use it to damp the updated density matrix. If "n_a" is present it is used
   ! as the number of alpha electrons in embedded scf calculations. If
   ! "method" is present it is used as the kind of density matrix to make.
   ! NOTE: the final computed density matrix is written to an archive
   ! NOTE: if any old density matrix exists, it is saved in an old archive.
      damp :: BIN, optional
      n_a :: INT, optional
      method :: STR, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")

      T :: REAL
      damping,do_archive,do_delta_density,use_pFON :: BIN
      MO,D,MOa,MOb,Da,Db,F,Fa,Fb :: MAT{REAL}*
      CMO,CD,CMOa,CMOb,CDa,CDb :: MAT{CPX}*
      scf_method,genre :: STR

      ! Determine (or guess) the kind of SCF method to be used.
      if      (present(method))  then; scf_method = method
      else if (.scfdata.created) then; scf_method = .scfdata.scf_kind
      else;                            scf_method = .molecular_orbitals.guess_scf_kind
      end

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .molecular_orbitals.spinorbital_kind
      end

      ! Make the delta density matrix?
      do_delta_density = .delta_density_matrix.created
      if (.scfdata.created) do_delta_density = do_delta_density AND .scfdata.do_delta_build

      ! Determine if density matrix damping is to be used
      damping = .old_density_matrix.created
      if      (present(damp)) then;    damping = damping AND damp
      else if (.scfdata.created) then; damping = damping AND .scfdata.apply_damping
      end

      ! Determine if pFON should be used
      use_pFON = FALSE
      if (.scfdata.created AND .fock_matrix.created(genre)) use_pFON = .scfdata.apply_pFON

      ! Create the density matrix (leaky)
      if (.density_matrix.destroyed) .density_matrix.create(.n_bf)
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)

      ! Save the old density if damping
      .old_density_matrix.destroy
      if (do_delta_density OR damping) then
         .old_density_matrix.create_copy(.density_matrix)
         .old_density_matrix.compress
      end

      ! Do it: make the density matrix
      select case (scf_method)

       case ("rhf","rks","xray_rks","xray_rhf","noninteracting-group-rhf")

         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")

         if (use_pFON) then

            D  => .density_matrix.restricted
            MO => .molecular_orbitals.restricted
            F  => .fock_matrix.restricted
            T = .scfdata.temperature_for_pFON
            ::make_finite_T_density_matrix(D,MO,F,T,.n_a)
            D = TWO*D

         else

            MO => .molecular_orbitals.restricted(:,1:.n_a)
            D  => .density_matrix.restricted
            D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

         end

         if (scf_method(1:4)=="xray" AND .scfdata.stabilize_density) .::stabilize(D)

         .::put_debug(D,"make_scf_density_matrix: restricted density matrix")

       case ("progroup")

         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")
         ENSURE(present(n_a),"n_a must be specified")

         MO => .molecular_orbitals.restricted(:,1:n_a)
         D  => .density_matrix.restricted
         D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)

       case ("rohf")

         ENSURE(.molecular_orbitals.created("restricted"),"no MO's")

         MOa => .molecular_orbitals.restricted(:,1:.n_a)
         MOb => .molecular_orbitals.restricted(:,1:.n_b)
         Da  => .density_matrix.alpha
         Db  => .density_matrix.beta
         Da.to_product_of(MOa,MOa,transpose_b=TRUE)
         Db.to_product_of(MOb,MOb,transpose_b=TRUE)

       case ("uhf","uks","xray_uhf","xray_uks", &
             "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

         ENSURE(.molecular_orbitals.created("unrestricted"),"no MO's")

         if (use_pFON) then

            MOa => .molecular_orbitals.alpha
            MOb => .molecular_orbitals.beta
            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta
            Fa  => .fock_matrix.alpha
            Fb  => .fock_matrix.beta
            T = .scfdata.temperature_for_pFON
            ::make_finite_T_density_matrix(Da,MOa,Fa,T,.n_a)
            ::make_finite_T_density_matrix(Db,MOb,Fb,T,.n_b)

         else

            MOa => .molecular_orbitals.alpha(:,1:.n_a)
            MOb => .molecular_orbitals.beta(:,1:.n_b)
            Da  => .density_matrix.alpha
            Db  => .density_matrix.beta
            Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            Db.to_product_of(MOb,MOb,transpose_b=TRUE)

         end

       case ("ghf")

         ENSURE(.molecular_orbitals.created("general"),"no MO's")
         ENSURE(.spin_multiplicity==1,"this is not a singlet state")

         MO => .molecular_orbitals.general(:,1:.n_e)
         D  => .density_matrix.general
         D.to_product_of(MO,MO,transpose_b=TRUE)

       case ("rchf")

         ENSURE(.molecular_orbitals.created("restricted_complex"),"no MO's")

         CMO => .molecular_orbitals.restricted_complex(:,1:.n_a)
         CD  => .density_matrix.restricted_complex
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)
         CD = TWO*CD

       case ("uchf")

         ENSURE(.molecular_orbitals.created("unrestricted_complex"),"no MO's")

         CMOa => .molecular_orbitals.alpha_complex(:,1:.n_a)
         CMOb => .molecular_orbitals.beta_complex(:,1:.n_b)
         CDa  => .density_matrix.alpha_complex
         CDb  => .density_matrix.beta_complex
         CDa.to_product_of(CMOa,CMOa,dagger_b=TRUE)
         CDb.to_product_of(CMOb,CMOb,dagger_b=TRUE)

       case ("gchf")

         ENSURE(.molecular_orbitals.created("general_complex"),"no MO's")

         CMO => .molecular_orbitals.general_complex(:,1:.n_e)
         CD  => .density_matrix.general_complex
         CD.to_product_of(CMO,CMO,dagger_b=TRUE)

       case default
         DIE("unknown SCF kind, "//trim(scf_method))

      end

      ! Damp the density matrix if required
      if (damping) then
         .old_density_matrix.uncompress
         .density_matrix.damp(.old_density_matrix,.scfdata.damp_factor)
      end

      ! Archive density matrix?
      do_archive = FALSE
      if (do_archive) .::archive(.density_matrix,"density_matrix")

      ! Debug
      .::put_debug(.density_matrix,"make_scf_density_matrix: density matrix")

      ! Save the delta density matrix for incremental Fock build
      if (do_delta_density) then
         .delta_density_matrix => .old_density_matrix
         .delta_density_matrix.to_scaled(.delta_density_matrix,-ONE)
         .delta_density_matrix.plus(.density_matrix)
      else
         .old_density_matrix.destroy
      end

   end

   make_finite_T_density_matrix(D,MO,F,T,n_e) ::: selfless
   ! Make the finite temperature density matrix "D" from molecular
   ! orbitals "MO" according to the pFON method with temperature "T"
   ! and number of electrons "n_e" *for a given spin*, as in Rabuck
   ! and Scuseria, JCP 110, 695 (1999).  There must exist a current
   ! fock_matrix "F" made from "D" which is used to get the
   ! eigenvalues for the Fermi-Dirac distribution.
      D,MO :: MAT{REAL}
      F :: MAT{REAL}
      T :: REAL
      n_e :: INT

   ENSURE(F.is_square,"F must be square")
   ENSURE(F.is_same_shape_as(MO),"incompatible F and MO")
   ENSURE(n_e<MO.dim2,"fewer MO's than electrons")
   ENSURE(T>=ZERO,"T must be positive")

      W :: MAT{REAL}*
      occ :: VEC{REAL}*
      ind :: VEC{INT}*
      beta,e_homo,e_lumo,e_fermi,homo_lumo_gap :: REAL
      n_orb,i,j,n_frac :: INT

      n_orb = F.dim1

      occ.create(n_orb)     
      ind.create(n_orb)

      ! Make the occupation numbers
      W.create(n_orb,n_orb)
      W.to_product_of(F,MO)
      do i = 1,n_orb        ! These are energies
        occ(i) = dot_product(MO(:,i),W(:,i))
      end
      occ.quick_sort(ind)   ! "ind" has the energies sorted
      W.destroy

      beta    = KELVIN_PER_HARTREE/T
      e_homo  = occ(ind(n_e))
      e_lumo  = occ(ind(n_e+1))
      e_fermi = HALF*(e_homo + e_lumo)
      homo_lumo_gap = e_lumo - e_homo
      do j = 1,n_orb        ! These are the occupation numbers
         i = ind(j)
         occ(i) = ONE/(ONE+exp(beta*(occ(i)-e_fermi)))
      end                   

      ! The number of fractional orbitals
      if      (homo_lumo_gap>0.135e0) then; n_frac = 5
      else if (homo_lumo_gap<0.090e0) then; n_frac = 3
      else;                                 n_frac = 4
      end

      ! Reset the fractional occupancies
      do j = 1,n_orb        
         i = ind(j)
         if      (j<=n_e-n_frac) then; occ(i) = ONE
         else if (j >n_e+n_frac) then; occ(i) = ZERO
         end
      end

      ! Form the temperature broadended density
      D = ZERO
      do j = 1,n_e+n_frac   
         i = ind(j)
         D.plus_scaled_product_of(MO(:,i:i),MO(:,i:i),fac=occ(i),transpose_b=TRUE)
      end

      ind.destroy
      occ.destroy

   end

   make_ao_density_matrix ::: leaky
   ! Make the AO (spin independent) density matrix from the existing density
   ! matrix. The result is placed in the "restricted" part of the density
   ! matrix. 

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      ! Leaky
      .::make_ao_density_matrix(.density_matrix)   

   end

   make_ao_density_matrix(D) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. 
      D :: OPMATRIX*

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.created, "no density matrix")
   ENSURE(D.any_created, "no density matrix")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = D.spinorbital_kind
      end

      select case (genre)

         case ("restricted")
            ! do nothing

         case ("unrestricted")

            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.alpha + D.beta

         case ("general")

            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.general.alpha_alpha + D.general.beta_beta

         case ("restricted_complex")
            ! do nothing

         case ("unrestricted_complex")

            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.alpha_complex + D.beta_complex

         case ("general_complex")

            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.general_complex.alpha_alpha + D.general_complex.beta_beta

         case default

            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_density_matrix(P)
   ! Make the AO (spin independent) density matrix "P" from the
   ! existing density matrix. 
      P :: MAT{REAL}

      .::make_ao_RE_density_matrix(P)

   end

   make_ao_RE_density_matrix(P)
   ! Make the REAL AO (spin independent) density matrix "P" from the
   ! existing density matrix. 
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      select case (genre)

         case ("restricted")
            P = .density_matrix.restricted

         case ("unrestricted")
            P = .density_matrix.alpha + .density_matrix.beta

         case ("general")
            P = .density_matrix.general.alpha_alpha &
              + .density_matrix.general.beta_beta

         case ("restricted_complex")
            P = RE(.density_matrix.restricted_complex)

         case ("unrestricted_complex")
            P = RE(.density_matrix.alpha_complex) &
              + RE(.density_matrix.beta_complex)

         case ("general_complex")
            P = RE(.density_matrix.general_complex.alpha_alpha) &
              + RE(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_IM_density_matrix(P)
   ! Make the IMAGINARY AO (spin independent) density matrix "P" from
   ! the existing density matrix. 
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      P = ZERO

      if (genre=="restricted")   return
      if (genre=="unrestricted") return
      if (genre=="general")      return

      select case (genre)

         case ("restricted_complex")
            P = IM(.density_matrix.restricted_complex)

         case ("unrestricted_complex")
            P = IM(.density_matrix.alpha_complex) &
              + IM(.density_matrix.beta_complex)

         case ("general_complex")
            P = IM(.density_matrix.general_complex.alpha_alpha) &
              + IM(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_sz_density_matrix ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included.

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      .::make_ao_sz_density_matrix(.density_matrix)   ! leaky

   end

   make_ao_sz_density_matrix(D) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included!
      D :: OPMATRIX*

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(D.created, "no density matrix")
   ENSURE(D.any_created, "no density matrix")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = D.spinorbital_kind
      end

      if (genre=="restricted") return

      select case (genre)

         case ("unrestricted")
            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.alpha - D.beta

         case ("general")
            D.destroy("restricted")
            D.create("restricted")
            D.restricted = D.general.alpha_alpha - D.general.beta_beta

         case ("unrestricted_complex")
            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.alpha_complex - D.beta_complex

         case ("general_complex")
            D.destroy("restricted_complex")
            D.create("restricted_complex")
            D.restricted_complex = D.general_complex.alpha_alpha - D.general_complex.beta_beta

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_sz_density_matrix(P) ::: leaky
   ! Make the AO (spin independent) density matrix from the existing
   ! density matrix. The result is placed in the "restricted" part of
   ! the density matrix. NOTE: factor 1/2 not included!
      P :: MAT{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(P.dim1==.n_bf, "P: wrong dim1")
   ENSURE(P.dim2==.n_bf, "P: wrong dim2")

      genre :: STR

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            P = .density_matrix.alpha &
              - .density_matrix.beta

         case ("general")
            P = .density_matrix.general.alpha_alpha &
              - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            P = RE(.density_matrix.alpha_complex) &
              - RE(.density_matrix.beta_complex )

         case ("general_complex")
            P = RE(.density_matrix.general_complex.alpha_alpha) &
              - RE(.density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

   end

   make_ao_spin_densities(S) ::: leaky
   ! Make  the AO spin density matrices. 
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{CPX}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            S(:,:,3) = .density_matrix.alpha &
                     - .density_matrix.beta

         case ("general")
            S(:,:,1) = .density_matrix.general.alpha_beta  &
                     + .density_matrix.general.beta_alpha
            S(:,:,3) = .density_matrix.general.alpha_alpha &
                     - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            S(:,:,3) = .density_matrix.alpha_complex &
                     - .density_matrix.beta_complex

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) =   .density_matrix.general_complex.alpha_beta  &
                     +   .density_matrix.general_complex.beta_alpha
            S(:,:,2) = I*.density_matrix.general_complex.alpha_beta  &
                     - I*.density_matrix.general_complex.beta_alpha
            S(:,:,3) =   .density_matrix.general_complex.alpha_alpha & 
                     -   .density_matrix.general_complex.beta_beta

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_ao_RE_spin_densities(S) ::: leaky
   ! Make the REAL part of the AO spin density matrices. 
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted") return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted")
            S(:,:,3) = .density_matrix.alpha &
                     - .density_matrix.beta

         case ("general")
            S(:,:,1) = .density_matrix.general.alpha_beta  &
                     + .density_matrix.general.beta_alpha
            S(:,:,3) = .density_matrix.general.alpha_alpha &
                     - .density_matrix.general.beta_beta

         case ("unrestricted_complex")
            S(:,:,3) = RE(.density_matrix.alpha_complex) &
                     - RE(.density_matrix.beta_complex)

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) = RE(  .density_matrix.general_complex.alpha_beta)  &
                     + RE(  .density_matrix.general_complex.beta_alpha)
            S(:,:,2) = RE(I*.density_matrix.general_complex.alpha_beta)  &
                     - RE(I*.density_matrix.general_complex.beta_alpha)
            S(:,:,3) = RE(  .density_matrix.general_complex.alpha_alpha) & 
                     - RE(  .density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_ao_IM_spin_densities(S) ::: leaky
   ! Make the IMAGINARY part of the AO spin density matrices. 
   ! NOTE: factor 1/2 IS included.
      S :: MAT3{REAL}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")
   ENSURE(S.dim1==.n_bf, "S: wrong dim1")
   ENSURE(S.dim2==.n_bf, "S: wrong dim2")
   ENSURE(S.dim3==3,     "S: wrong dim3")

      genre :: STR
      I :: CPX

      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .density_matrix.spinorbital_kind
      end

      S = ZERO

      if (genre=="restricted")   return
      if (genre=="unrestricted") return
      if (genre=="general")      return
      if (genre=="restricted_complex") return

      select case (genre)

         case ("unrestricted_complex")
            S(:,:,3) = IM(.density_matrix.alpha_complex) &
                     - IM(.density_matrix.beta_complex)

         case ("general_complex")
            I = IMAGIFY(ONE)
            S(:,:,1) = IM(  .density_matrix.general_complex.alpha_beta)  &
                     - IM(  .density_matrix.general_complex.beta_alpha)
            S(:,:,2) = IM(I*.density_matrix.general_complex.alpha_beta)  &
                     - IM(I*.density_matrix.general_complex.beta_alpha)
            S(:,:,3) = IM(  .density_matrix.general_complex.alpha_alpha) & 
                     - IM(  .density_matrix.general_complex.beta_beta)

         case default
            DIE("unknown kind, "//trim(genre))

      end

      ! Factor 1/2
      S = HALF*S

   end

   make_scf_density_matrix(n,nb)
   ! Make the density matrix from orbital "n" of the molecular orbitals.
   ! If present, orbital "nb" of the beta molecular orbitals is used.
   ! If either index is not an occupied MO, the density is set to zero.
      n :: INT, IN
      nb :: INT, IN, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")

      MO,D,MOa,MOb,Da,Db :: MAT{REAL}*
      CMO,CD,CMOa,CMOb,CDa,CDb :: MAT{CPX}*
      genre :: STR
      arch :: ARCHIVE
      m :: INT
      uhf :: BIN

      uhf = .scfdata.scf_kind.includes("unrestricted")
      WARN_IF(present(nb) AND (NOT uhf), "nb ignored")

      m = n
      if (present(nb)) m = nb

      genre = .scfdata.spinorbital_kind
      .density_matrix.destroy(genre)
      .density_matrix.create(genre)

      select case (.scfdata.scf_kind)

         case ("rhf","rks","xray_rhf","xray_rks","noninteracting-group-rhf")

            ENSURE(.spin_multiplicity==1,"this is not a singlet state")

            D  => .density_matrix.restricted

            if (n>0 AND n<=.n_a) then
               MO => .molecular_orbitals.restricted(:,n:n)
               D.to_scaled_product_of(MO,MO,fac=TWO,transpose_b=TRUE)
            else
               D = ZERO
            end

         case ("rohf")

            Da => .density_matrix.alpha
            Db => .density_matrix.beta

            if (n>0 AND n<=.n_b) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               MOb => .molecular_orbitals.restricted(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
               Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            else if (n>nb AND n<=.n_a) then
               MOa => .molecular_orbitals.restricted(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
               Da = ZERO
               Db = ZERO
            end

         case ("uhf","uks","xray_uhf","xray_uks", &
               "pnd_uhf","pnd_uks","xray_pnd_uhf","xray_pnd_uks")

            Da => .density_matrix.alpha
            Db => .density_matrix.beta

            if (n>0 AND n<=.n_a) then
               MOa => .molecular_orbitals.alpha(:,n:n)
               Da.to_product_of(MOa,MOa,transpose_b=TRUE)
            else
               Da = ZERO
            end

            if (m>0 AND m<=.n_b) then
               MOb => .molecular_orbitals.beta(:,m:m)
               Db.to_product_of(MOb,MOb,transpose_b=TRUE)
            else
               Db = ZERO
            end

         case ("ghf")

            ENSURE(.spin_multiplicity==1,"this is not a singlet state")

            D =>  .density_matrix.general

            if (n>0 AND n<=.n_e) then
               MO => .molecular_orbitals.general(:,n:n)
               D.to_product_of(MO,MO,transpose_b=TRUE)
            else
               D = ZERO
            end

         case ("rchf")

            CD => .density_matrix.restricted_complex

            if (n>0 AND n<=.n_a) then
               CMO => .molecular_orbitals.restricted_complex(:,n:n)
               CD.to_scaled_product_of(CMO,CMO,fac=TWO,dagger_b=TRUE)
            else
               CD = ZERO
            end

         case ("uchf")

            CDa => .density_matrix.alpha_complex
            CDb => .density_matrix.beta_complex

            if (n>0 AND n<=.n_a) then
               CMOa => .molecular_orbitals.alpha_complex(:,n:n)
               CDa.to_product_of(CMOa,CMOa,dagger_b=TRUE)
            else
               CDa = ZERO
            end

            if (m>0 AND m<=.n_b) then
               CMOb => .molecular_orbitals.beta_complex(:,m:m)
               CDb.to_product_of(CMOb,CMOb,dagger_b=TRUE)
            else
               CDb = ZERO
            end

         case ("gchf")

            CD =>  .density_matrix.general_complex

            if (n>0 AND n<=.n_e) then
               CMO => .molecular_orbitals.general_complex(:,n:n)
               CD.to_product_of(CMO,CMO,dagger_b=TRUE)
            else
               CD = ZERO
            end

         case default;
            DIE("unknown kind, "//trim(.scfdata.scf_kind))

      end

      ! Archive
      arch.set(.name,"density_matrix",genre)
      arch.write(.density_matrix)

   end

!  =============================================
!  Spherically average atoms in existing density
!  =============================================

   make_spherical_atoms ::: leaky
   ! Get the spherical atom natural orbitals (ANO) data for all
   ! atoms in the molecule.

   ENSURE(.atom.created,"no atoms")
   ENSURE(.atom_info_made,"no atom info")
   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis_info_made,"no basis_set info")
   ENSURE(.density_matrix.created,"no density_matrix")
   ENSURE(.density_matrix.any_created,"no density_matrix")

      D :: OPMATRIX*
      genre :: STR
      a :: INT

      if (.::has_all_spherical_atom_data) return

      if (.::has_all_ANOs) .::destroy_ANOs

      ! Determine (or guess) the genre of density matrix to be made
      if (.scfdata.created) then; genre = .scfdata.spinorbital_kind
      else;                       genre = .molecular_orbitals.spinorbital_kind
      end

      ! Copy existing density matrix
      D.create(.n_bf,genre)
      D.create_copy(.density_matrix)

      ! Make the restricted density matrix
      .::make_ao_density_matrix(D)


      ! Spherically average the molecule AO density
      do a = 1,.n_atom
         .::spherically_average_atom(a,D.restricted)
      end
      D.destroy

      .atom.set_spherical_atom_data_made(TRUE)

   end

   spherically_average_atom(a,D) ::: leaky, private
   ! Make the spherically averaged restricted atomic natural orbitals
   ! (ANO) and density matrix data and interpolator for atom "a" from
   ! a given (real) density matrix "D".
      a :: INT
      D :: MAT{REAL}

   ENSURE(.atom(a).natural_orbitals.destroyed,"NO's exist, atom "//trim(a.to_str))
   ENSURE(.atom(a).occupation_numbers.destroyed,"occupations exist, atom "//trim(a.to_str))
   ENSURE(.atom(a).density_matrix.destroyed,"density exists, atom "//trim(a.to_str))

      f,l :: INT
      mol :: MOLECULE*

      ! Create the molecule
      mol.::create
      .::make_molecule_from_atom(a,mol)

      ! Get the density matrix
      mol.density_matrix.create(mol.n_bf)
      mol.density_matrix.create(genre="restricted")
      f = .first_basis_fn_for_atom(a)
      l =  .last_basis_fn_for_atom(a)
      mol.density_matrix.restricted = D(f:l,f:l)

      ! Spherically average the AO density
      mol.pointgroup.create("oh",.use_spherical_basis)
      mol.::symmetrize(mol.density_matrix)

      ! Make the natural orbitals
      mol.::make_natural_orbitals 

      ! Clean up the SCF files
      mol.::delete_archive("natural_orbitals")
      mol.::delete_archive("occupation_numbers")

      ! Destroy the atoms's NO and interpolator info
      .atom(a).interpolator.destroy
      .atom(a).density_matrix.destroy
      .atom(a).occupation_numbers.destroy
      .atom(a).natural_orbitals.destroy

      ! Copy the results
      .atom(a).natural_orbitals   => mol.natural_orbitals
      .atom(a).occupation_numbers => mol.occupation_numbers
      .atom(a).density_matrix     => mol.density_matrix

      ! Make the interpolator
      .atom(a).make_interpolator

      ! Nullify parts we just copied or can't destroy
      mol.atom.nullify_ptr_part       ! do not destroy ptr part
      nullify(mol.natural_orbitals)   ! do not destroy this
      nullify(mol.occupation_numbers) ! do not destroy this
      nullify(mol.density_matrix)     ! do not destroy this
      nullify(mol.basis)              ! do not destroy this
      nullify(mol.slaterbasis)        ! do not destroy this
      nullify(mol.coppensbasis)       ! do not destroy this

      ! Safe to destroy
      mol.::destroy

   end

!  =============
!  Group density
!  =============

   put_group_density_to(P,g,mol)
   ! Put the atom group "g" density matrix into "P". "mol" must be a molecule
   ! created from the appropriate atom group "g".
      P :: MAT{REAL}
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")

      a,b,aa,bb,fa,la,fb,lb,faa,laa,fbb,lbb :: INT

      do a = 1,.atom_group(g).n_atoms ! Copy this atom density
      do b = 1,.atom_group(g).n_atoms
         aa  = .atom_group(g).atom_index(a)
         bb  = .atom_group(g).atom_index(b)
         faa = .first_basis_fn_for_atom(aa)
         fbb = .first_basis_fn_for_atom(bb)
         laa = .last_basis_fn_for_atom(aa)
         lbb = .last_basis_fn_for_atom(bb)
         fa  = mol.first_basis_fn_for_atom(a)
         fb  = mol.first_basis_fn_for_atom(b)
         la  = mol.last_basis_fn_for_atom(a)
         lb  = mol.last_basis_fn_for_atom(b)
         P(fa:la,fb:lb) = .density_matrix.restricted(faa:laa,fbb:lbb) 
      end
      end

   end

   set_group_density_from(P,g,mol)
   ! Set the atom group "g" density matrix from "P". "mol" must be a molecule
   ! created from the appropriate atom group "g".
      P :: MAT{REAL}
      g :: INT, IN
      mol :: MOLECULE, IN

   ENSURE(.atom_group.created,"no atom group information")
   ENSURE(g>0,"group number must be positive")
   ENSURE(g<=.atom_group.dim,"group number exceeds number of groups")

      a,b,aa,bb,fa,la,fb,lb,faa,laa,fbb,lbb :: INT

      do a = 1,.atom_group(g).n_atoms ! Copy this atom density
      do b = 1,.atom_group(g).n_atoms
         aa  = .atom_group(g).atom_index(a)
         bb  = .atom_group(g).atom_index(b)
         faa = .first_basis_fn_for_atom(aa)
         fbb = .first_basis_fn_for_atom(bb)
         laa = .last_basis_fn_for_atom(aa)
         lbb = .last_basis_fn_for_atom(bb)
         fa  = mol.first_basis_fn_for_atom(a)
         fb  = mol.first_basis_fn_for_atom(b)
         la  = mol.last_basis_fn_for_atom(a)
         lb  = mol.last_basis_fn_for_atom(b)
         .density_matrix.restricted(faa:laa,fbb:lbb) = P(fa:la,fb:lb)
      end
      end

   end

!  =================
!  Expectation value
!  =================

   expectation(X) result (res)
   ! Evaluates the expectation value of the matrix of the operator X
   ! with the current density matrix
      X :: MAT{REAL}
      res :: REAL

   ENSURE(X.is_square,"X operator matrix is not square")

      orb_kind :: STR

      res = ZERO

      orb_kind = .density_matrix.spinorbital_kind

      select case (orb_kind)

        case ("restricted")
           ENSURE(X.dim1==.n_bf,"wrong size, X")
           res = .density_matrix.restricted.trace_product_with(X)

        case ("unrestricted")
           ENSURE(X.dim1==.n_bf,"wrong size, X")
           res = .density_matrix.alpha.trace_product_with(X)
           res = .density_matrix.beta.trace_product_with(X) + res

        case ("general_complex")
           ENSURE(X.dim1==2*.n_bf,"wrong size, X")
           res = MAT{REAL}:trace_product_with(RE(.density_matrix.general_complex),X)

        case default
           DIE("unimplemented kind, "//trim(orb_kind))
      
      end

   end

!  =================
!  Molecule rotation
!  =================

   rotate_by(R)
   ! Rotate the whole molecule using matrix "R" which specifies how positions in
   ! space are to be transformed i.e. x' = Rx.
      R :: MAT{REAL}

   ENSURE(R.is_square,"rotation matrix is not square")
   ENSURE(R.dim1==3,"rotation matrix must be 3x3")

      .atom.rotate_by(R)
      .::rotate_MOs_and_density_matrix(R)

   end

   rotate_MOs_and_density_matrix(R)
   ! Rotate the MO's and density matrix using matrix "R" which
   ! specifies how positions in space are to be transformed 
   ! i.e. x' = Rx.
      self :: IN
      R :: MAT{REAL}, IN
 
      mo_kind :: STR
 
      if (.molecular_orbitals.destroyed) return
      if (.molecular_orbitals.all_destroyed) return
 
      mo_kind = .molecular_orbitals.spinorbital_kind
      select case (mo_kind)

         case("restricted")
                  .::rotate_orbitals(.molecular_orbitals.restricted,R)
                  .::rotate_density_matrix(.density_matrix.restricted,R)

         case("unrestricted")
                  .::rotate_orbitals(.molecular_orbitals.alpha,R)
                  .::rotate_orbitals(.molecular_orbitals.beta,R)
                  .::rotate_density_matrix(.density_matrix.alpha,R)
                  .::rotate_density_matrix(.density_matrix.beta,R)

         case("general")
                  .::rotate_orbitals(.molecular_orbitals.general.alpha_alpha,R)
                  .::rotate_orbitals(.molecular_orbitals.general.alpha_beta,R)
                  .::rotate_orbitals(.molecular_orbitals.general.beta_alpha,R)
                  .::rotate_orbitals(.molecular_orbitals.general.beta_beta,R)
                  .::rotate_density_matrix(.density_matrix.general.alpha_alpha,R)
                  .::rotate_density_matrix(.density_matrix.general.alpha_beta,R)
                  .::rotate_density_matrix(.density_matrix.general.beta_alpha,R)
                  .::rotate_density_matrix(.density_matrix.general.beta_beta,R)

         case("restricted_complex")
                ! .::rotate_orbitals(.molecular_orbitals.restricted_complex,R)
         case("unrestricted_complex")
                ! .::rotate_orbitals(.molecular_orbitals.alpha_complex,R)
                ! .::rotate_orbitals(.molecular_orbitals.beta_complex,R)
         case("general_complex")
                ! .::rotate_orbitals(.molecular_orbitals.general_complex.alpha_alpha,R)
                ! .::rotate_orbitals(.molecular_orbitals.general_complex.alpha_beta,R)
                ! .::rotate_orbitals(.molecular_orbitals.general_complex.beta_alpha,R)
                ! .::rotate_orbitals(.molecular_orbitals.general_complex.beta_beta,R)
         case default;   DIE("unknown kind, "//trim(mo_kind))

      end
 
   end

   rotate_orbitals(MO,R)
   ! Rotate the molecular orbitals "MO" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
      MO,R :: MAT{REAL}

   ENSURE(MO.dim1==.n_bf,"wrong dim1 for MO orbitals")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")
   ENSURE(NOT .use_spherical_basis,"only for cartesian bases")

      new :: MAT{REAL}*
      tr :: VEC{MAT_{REAL}}*
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      tr.make_gaussian_xyz_matrices(R)

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],MO(f:l,:))
      end

      MO = new

      tr.destroy
      new.destroy

   end

   rotate_density_matrix(P,R)
   ! Rotate the density matrix "P" using matrix "R", where "R" specifies
   ! how positions in space are to be transformed i.e. x' = Rx.
      P,R :: MAT{REAL}

   ENSURE(P.is_square,"wrong shape for density matrix P")
   ENSURE(P.dim1==.n_bf,"wrong dim1 for density matrix P")
   ENSURE(R.is_square,"rotation matrix R is not square")
   ENSURE(R.dim1==3,"rotation matrix R is not 3x3")

      new :: MAT{REAL}*
      tr :: VEC{MAT_{REAL}}*
      s,f,l,a :: INT

      new.create(.n_bf,.n_bf)
      tr.make_gaussian_xyz_matrices(R)

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         new(f:l,:).to_product_of(tr(a)[:,:],P(f:l,:))
      end

      do s = 1,.n_shell
         f = .first_basis_fn_for_shell(s)
         l = .last_basis_fn_for_shell(s)
         a = .angular_moment_for_shell(s)
         P(:,f:l).to_product_of(new(:,f:l),transpose(tr(a)[:,:]))
      end

      tr.destroy
      new.destroy

   end

   rotate_group(g,axis,angle) ::: leaky
   ! Rotate a group "g" of atoms in the molecule using a matrix defined by its
   ! rotation "axis" and the "angle" of rotation around that axis, which are all
   ! inputted on the command line. The rotation is performed on the coordinates
   ! and the group-block diagonal of the density matrix. NOTE: this can be a
   ! problem for group off-diagonal blocks; this routine works for progroup
   ! densities only.
   ! Checked, 7/2/06; the energy decomposition was checked by manual rotation
      g :: INT
      axis :: VEC{REAL}(3)
      angle :: REAL

   ENSURE(.atom_group.created,"no atom group information")

      mol :: MOLECULE*
      archive :: ARCHIVE
      R :: MAT{REAL}(3,3)
      v :: VEC{REAL}(3)
      P :: MAT{REAL}*
      i,a :: INT

      ! Clean up different-geometry data
      .::delete_scf_archives

      R.to_3x3_rotation_matrix(axis,angle)

      ! Rotate atoms; the line below does not work
      do i = 1,.atom_group(g).n_atoms
         a = .atom_group(g).atom_index(i)
         v = .atom(a).position 
         .atom(a).position.to_product_of(R,v)
         .atom(a).ADP_tensor.back_transform_using(R)
      end

      .molecular_orbitals.destroy         ! leaky here
      if (.density_matrix.destroyed) return

      ENSURE(.density_matrix.restricted.created,"so far group rotation is for restricted densities only")

      ! Create molecule
      mol.::create
      .::make_molecule_from_atom_group(g,mol)

      ! Rotate density
      P.create(mol.n_bf,mol.n_bf)
      .::put_group_density_to(P,g,mol)
      mol.::rotate_density_matrix(P,R)
      .::set_group_density_from(P,g,mol)
      P.destroy

      mol.atom.nullify_ptr_part ! do not destroy these
      nullify(mol.basis)        ! do not destroy this
      nullify(mol.slaterbasis)  ! do not destroy this
      nullify(mol.coppensbasis) ! do not destroy this
      mol.::destroy

      ! Write out the density matrix
      archive.set(.name,"density_matrix",genre="restricted")
      archive.write(.density_matrix)

   end

!  ==============================
!  Shift/remove linear dependence
!  ==============================

   shift_dependence_from_r(F)
   ! Level shift the linear dependence in AO matrix "F" using overlap
   ! eigenvectors "evec" with small eigenvalue "eval".
   ! WARNING: this routine assumes eval's are ordered 
   ! smallest to largest.
      F :: MAT{REAL}

   ENSURE(.scfdata.created,"no scfdata")
   ENSURE(.overlap_eigenvectors.created,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.created,"no overlap_eigenvalues")
   ENSURE(F.dim1==.n_bf,"wrong size, F")

      n :: INT
      tol,shift :: REAL

      ! Get no of vectors smaller than "tol"
      tol = .scfdata.linear_dependence_tol
      n   = .overlap_eigenvalues.index_of_first_greater_than(tol) - 1

      ! Decouple and shift the small eigenvectors to high energy
      shift = .scfdata.linear_dependence_shift
      ::decouple_and_shift_r(F,.overlap_eigenvectors,n,shift)

   end

   decouple_and_shift_r(F,evec,n,shift) ::: selfless
   ! In "F", decouple the first "n" eigenvectors "evec" and shift them
   ! to eigenvalue "shift". NOTE: ensure "evec" is orthonormal.
      F :: MAT{REAL}
      evec :: MAT{REAL}, IN
      n :: INT, IN
      shift  :: REAL, IN

      ! Return if no vectores to shift/decouple
      if (n==1) return

      ! Change to the eigenvector basis
      F.change_basis_using(evec)

      ! Decouple the vectors
      F(:n,n+1:) = ZERO
      F(n+1:,:n) = ZERO

      ! Shift the first n eigenvectors
      F(:n,:n).set_diagonal_to(shift)

      ! Revert from the eigenvector basis
      F.back_transform_using(evec)

   end

!  ================
!  Natural orbitals
!  ================

   make_natural_orbitals(genre) ::: leaky
   ! Make the natural orbitals from the density matrix
      genre :: STR, optional

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.any_created, "no density matrix")

      orb_kind :: STR

      if (present(genre)) then; orb_kind = genre
      else;                     orb_kind = .density_matrix.spinorbital_kind
      end

      select case (orb_kind)
         case ("restricted        "); .::make_restricted_NOs
         case ("unrestricted      "); .::make_unrestricted_NOs
!        case ("general           "); .::make_general_NOs
         case ("restricted_complex"); .::make_restricted_complex_NOs
         case ("general_complex   "); .::make_general_complex_NOs
         case default;                UNKNOWN(orb_kind)
      end

   end

   make_restricted_NOs ::: leaky
   ! Make the restricted natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted.created, "no density matrix")
   ENSURE(.overlap_matrix.created, "no overlap matrix")

      ! Recreate (leaky)
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"restricted")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"restricted")

      ! Make the restricted NO's
      .::make_r_NOs(.natural_orbitals.restricted,   &
                    .occupation_numbers.restricted, &
                    .density_matrix.restricted)

   end

   make_unrestricted_NOs ::: leaky
   ! Make the unrestricted natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.alpha.created, "no density matrix")
   ENSURE(.density_matrix.beta.created, "no density matrix")
   ENSURE(.overlap_matrix.created, "no overlap matrix")

      ! Recreate (leaky)
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"unrestricted")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"unrestricted")

      ! Make the unrestricted NO's
      .::make_r_NOs(.natural_orbitals.alpha,.occupation_numbers.alpha,.density_matrix.alpha)
      .::make_r_NOs(.natural_orbitals.beta, .occupation_numbers.beta, .density_matrix.beta)

   end

   make_r_NOs(NO,occupation,P)
   ! Make the real natural orbitals "NO" and "occupation" numbers from the
   ! density matrix "P"
      NO,P :: MAT{REAL}
      occupation :: VEC{REAL}

   ENSURE(.overlap_matrix.created,"no overlap matrix")

      V,X :: MAT{REAL}*

      V.create(.n_bf,.n_bf)
      .::make_r_overlap_sqrt(V)

      X.create(.n_bf,.n_bf)

      P.change_basis_to(X,V)
      X.solve_eigenproblem(occupation,V)

      .::make_r_overlap_inverse_sqrt(X)

      NO.to_product_of(X,V)

      X.destroy
      V.destroy

      occupation = occupation(.n_bf:1:-1)
      NO         = NO(:,.n_bf:1:-1)

   end

   make_restricted_complex_NOs ::: leaky
   ! Make the restricted complex natural orbitals from the density matrix
   ENSURE(.density_matrix.created, "no density matrix")
   ENSURE(.density_matrix.restricted_complex.created, "no density matrix")
   ENSURE(.overlap_matrix.created, "no overlap matrix")

      V,X :: MAT{CPX}*
      O :: MAT{REAL}*

      ! Recreate
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"restricted_complex")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"restricted")

      V.create(.n_bf,.n_bf)
      O.create(.n_bf,.n_bf)

      .::make_r_overlap_sqrt(O)

      X.create(.n_bf,.n_bf)
      .density_matrix.restricted_complex.change_basis_to(X,O)
      X.solve_eigenproblem(.occupation_numbers.restricted,V)
      X.destroy

      .::make_r_overlap_inverse_sqrt(O)

      .natural_orbitals.restricted_complex.to_product_of(O,V)

      O.destroy
      V.destroy

      .occupation_numbers.restricted       = .occupation_numbers.restricted(.n_bf:1:-1)
      .natural_orbitals.restricted_complex = .natural_orbitals.restricted_complex(:,.n_bf:1:-1)

   end

   make_general_complex_NOs ::: leaky
   ! Make the general natural orbitals and occupations from the complex density
   ! matrix.
   ENSURE(.density_matrix.created,"no density matrix")
   ENSURE(.density_matrix.general_complex.created,"no density matrix")
   ENSURE(.overlap_matrix.created, "no overlap matrix")

      R :: MAT{REAL}*
      V,X :: MAT{CPX}*

      ! Recreate
      .natural_orbitals.destroy
      .natural_orbitals.create(.n_bf,"general_complex")
      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,"general")


      V.create(2*.n_bf,2*.n_bf)
      R.create(.n_bf,.n_bf)

      .::make_r_overlap_sqrt(R)

      V = ZERO
      V.alpha_alpha_set_to(R)
      V.beta_beta_set_to(R)

      R.destroy

      X.create(2*.n_bf,2*.n_bf)
      X = .density_matrix.general_complex
      X.change_basis_using(V)
      X.solve_eigenproblem(.occupation_numbers.general,V)

      R.create(.n_bf,.n_bf)
      .::make_r_overlap_inverse_sqrt(R)

      X = ZERO
      X.alpha_alpha_set_to(R)
      X.beta_beta_set_to(R)
      R.destroy

      .natural_orbitals.general_complex.to_product_of(X,V)
      .occupation_numbers.general = .occupation_numbers.general(2*.n_bf:1:-1)
      .natural_orbitals.general   = .natural_orbitals.general(:,2*.n_bf:1:-1)

      X.destroy
      V.destroy

   end

!  ===================
!  Overlap matrix sqrt
!  ===================

   make_r_overlap_sqrt(S_sqrt) ::: leaky
   ! Get "S_sqrt", the sqrt overlap matrix 
      S_sqrt :: MAT{REAL}, OUT

   ENSURE(.overlap_eigenvectors.created,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.created,"no overlap_values")
   ENSURE(S_sqrt.is_square,"non-square S_qrt")
   ENSURE(S_sqrt.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.scfdata.created) then
         tol   = .scfdata.linear_dependence_tol
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_sqrt.to_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

   make_r_overlap_inverse_sqrt(S_inv) ::: leaky
   ! Get "S_inv", the inverse sqrt overlap matrix 
      S_inv :: MAT{REAL}, OUT

   ENSURE(.overlap_eigenvectors.created,"no overlap_eigenvectors")
   ENSURE(.overlap_eigenvalues.created,"no overlap_values")
   ENSURE(S_inv.is_square,"non-square S_inv")
   ENSURE(S_inv.dim1==.overlap_eigenvectors.dim1,"wrong shape for S_sqrt")

      tol :: REAL

      if (.scfdata.created) then
         tol   = .scfdata.linear_dependence_tol
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors,tol)
      else
         S_inv.to_inverse_sqrt_of(.overlap_eigenvalues,.overlap_eigenvectors)
      end

   end

!  ==========================
!  Natural orbital assignment
!  ==========================

   assign_NOs_to_MOs ::: leaky
   ! Assign the natural orbitals to be the molecular_orbitals
   ENSURE(.molecular_orbitals.created, "no molecular orbitals")
   ENSURE(.molecular_orbitals.any_created, "no molecular orbitals")

      NO_kind :: STR

      .natural_orbitals.destroy
      .natural_orbitals.create_copy(.molecular_orbitals)

      NO_kind = .natural_orbitals.spinorbital_kind

      .occupation_numbers.destroy
      .occupation_numbers.create(.n_bf,NO_kind)

      .occupation_numbers.set_to_zero
      .::set_scf_occupations(NO_kind)

   end

   assign_MOs_to_NOs ::: leaky
   ! Assign the MOs to be the same as the natural orbitals

      NO_kind :: STR
      
      .molecular_orbitals.destroy
      .molecular_orbitals.create_copy(.natural_orbitals)

      NO_kind = .natural_orbitals.spinorbital_kind

      .occupation_numbers.destroy
      .occupation_numbers.create(NO_kind)

      .occupation_numbers.set_to_zero
      .::set_scf_occupations(NO_kind)

   end

!  ================
!  Symmetry methods
!  ================

   symmetrize(mat,orb_kind)
   ! Symmetrize an opmatrix matrix "mat" and of spinorbital_kind
   ! "orb_kind" (if specified)
      mat :: OPMATRIX
      orb_kind :: STR, optional

      itemkind :: STR

      itemkind = mat.spinorbital_kind
      if (present(orb_kind)) itemkind = orb_kind

      select case (itemkind)
         case ("restricted");           .::symmetrize(mat.restricted)
         case ("unrestricted");         .::symmetrize(mat.alpha)
                                        .::symmetrize(mat.beta)
         case ("general");              .::symmetrize(mat.general.alpha_alpha)
                                        .::symmetrize(mat.general.beta_beta)
                                        .::symmetrize(mat.general.alpha_beta)
                                        .::symmetrize(mat.general.beta_alpha)
         case ("restricted_complex");   .::symmetrize(mat.restricted_complex)
         case ("unrestricted_complex"); .::symmetrize(mat.alpha_complex)
                                        .::symmetrize(mat.beta_complex)
         case ("general_complex");      .::symmetrize(mat.general_complex.alpha_alpha)
                                        .::symmetrize(mat.general_complex.beta_beta)
                                        .::symmetrize(mat.general_complex.alpha_beta)
                                        .::symmetrize(mat.general_complex.beta_alpha)
         case default;   DIE("unknown kind, "//trim(orb_kind))
      end

   end

   symmetrize(mat) ::: template
   ! Symmetrize a matrix
      mat :: MAT{TYPE}

   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.pointgroup.created, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,W :: MAT{TYPE}*
      tra,trb :: MAT{REAL}*
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}*

      image.create(.n_shell, .pointgroup.order)
      .::make_image_of_shell(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.pointgroup.order

         do a = 1,.n_shell

            tra => .pointgroup.xyz_matrix(n,.angular_moment_for_shell(a))
            i = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb => .pointgroup.xyz_matrix(n,.angular_moment_for_shell(b))
               j = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               W.create(na,nb)
               W.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(W,trb,transpose_b=TRUE)
               W.destroy

            end

         end

      end

      mat = sym/REALIFY(.pointgroup.order)

      sym.destroy
      image.destroy

   end

   symmetrize(mat) ::: get_from(symmetrize, TYPE=>REAL)
   ! Symmetrize a matrix
   end

   symmetrize(mat) ::: get_from(symmetrize, TYPE=>CPX)
   ! Symmetrize a matrix
   end

   make_image_of_shell(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! pointgroup operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      res :: MAT{INT}, OUT

   ENSURE(.pointgroup.created, "no pointgroup")
   ENSURE(res.dim1==.n_shell, "dimension 1 of matrix incorrect")
   ENSURE(res.dim2==.pointgroup.order, "dimension 2 of matrix incorrect")

      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT

      do n = 1,.pointgroup.order
      do a = 1,.n_shell

         aa = .atom_for_shell(a)
         as = .atom_shell_for_shell(a)

         new_pos.to_product_of(.pointgroup.mat(:,:,n), .atom(aa).position)

         new_atom = .::atom_index_from_position(new_pos)

         fs = .first_shell_for_atom(new_atom)
         res(a,n) = fs + as - 1

      end
      end

   end


!   stabilize(mat,orb_kind) ::: get_from(stabilize, symmetrise=>stabilize)
!   ! Symmetrise an opmatrix matrix "mat" of spinorbital_kind "orb_kind" (if
!   ! specified)
!   end

   stabilize(mat) ::: template
   ! Stabilize a matrix
      mat :: MAT{TYPE}

   ENSURE(NOT .use_spherical_basis,"not implemented")
   ENSURE(.basis_info_made, "no basis info")
   ENSURE(.atom.created,"no atom list")
   ENSURE(.crystal.created, "no pointgroup")
   ENSURE(mat.is_square,"non-square matrix")
   ENSURE(mat.dim1==.n_bf,"incorrectly dimensioned matrix")

      sym,w :: MAT{TYPE}*
      tra,trb :: MAT{REAL}*
      n,a,b,i,j,na,nb :: INT
      fa,fb,fi,fj,la,lb,li,lj :: INT
      image :: MAT{INT}*

      image.create(.n_shell,.crystal.n_stabilizer_symops)
      .::make_image_of_stabilizer(image)

      sym.create(.n_bf,.n_bf)
      sym = ZERO

      do n = 1,.crystal.n_stabilizer_symops

         do a = 1,.n_shell

            tra => .crystal.xyz_stabilizer_matrix(n,.angular_moment_for_shell(a))

            i  = image(a,n)
            fa = .first_basis_fn_for_shell(a)
            fi = .first_basis_fn_for_shell(i)
            la = .last_basis_fn_for_shell(a)
            li = .last_basis_fn_for_shell(i)
            na = la - fa + 1

            do b = 1,.n_shell

               trb => .crystal.xyz_stabilizer_matrix(n,.angular_moment_for_shell(b))

               j  = image(b,n)
               fb = .first_basis_fn_for_shell(b)
               fj = .first_basis_fn_for_shell(j)
               lb = .last_basis_fn_for_shell(b)
               lj = .last_basis_fn_for_shell(j)
               nb = lb - fb + 1

               w.create(na,nb)
               w.to_product_of(tra,mat(fa:la,fb:lb))
               sym(fi:li,fj:lj).plus_product_of(w,trb,transpose_b=TRUE)
               w.destroy

            end

         end

      end

      mat = sym/REALIFY(.crystal.n_stabilizer_symops)

      sym.destroy
      image.destroy

   end

   stabilize(mat) ::: get_from(stabilize, TYPE=>REAL)
   ! Stabilize a matrix
   end

   stabilize(mat) ::: get_from(stabilize, TYPE=>CPX)
   ! Stabilize a matrix
   end

   make_image_of_stabilizer(res)
   ! Return an array "res(a,n)" which is the image of shell "a" under
   ! a crystal stabilizer operation "n"
   ! Size of "res" is [.n_shell,.pointgroup.order]
      res :: MAT{INT}, OUT

   ENSURE(.crystal.created, "no crystal")
   ENSURE(res.dim1==.n_shell, "dimension 1 of matrix incorrect")
   ENSURE(res.dim2==.crystal.n_stabilizer_symops, "dimension 2 of matrix incorrect")

      new_pos :: VEC{REAL}(3)
      n,a,aa,as,new_atom,fs :: INT

      do n = 1,.crystal.n_stabilizer_symops
      do a = 1,.n_shell

         aa = .atom_for_shell(a)
         as = .atom_shell_for_shell(a)

         new_pos.to_product_of(.crystal.ptr(:,:,n), .atom(aa).position)

         new_atom = .::atom_index_from_position(new_pos)

         fs = .first_shell_for_atom(new_atom)
         res(a,n) = fs + as - 1

      end
      end

   end

!  ==================
!  Archiving routines
!  ==================

   archive(opmatrix,archive_name,genre,with_lambda)
   ! Save "opmatrix" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      opmatrix :: OPMATRIX
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN

      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda

      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(opmatrix,genre)

      if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(opmatrix,genre)
        end
        end
      end

   end

   archive(opvector,archive_name,genre,with_lambda)
   ! Save "opvector" to an archive on disk with name "archive_name".
   ! The genre is guessed from "opmatrix" unless "genre" is present.
   ! If "with_lambda" is present and TRUE and the archives are not to
   ! be deleted after the scf calculation, then the lambda value is
   ! attached to the stored archive.
      opvector :: OPVECTOR
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN
      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(opvector,genre)
      if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(opvector,genre)
        end
        end
      end
   end

   archive(item,archive_name,genre,with_lambda)
   ! Save "item" to an archive on disk with name "archive_name". 
      item :: REAL
      archive_name :: STR
      genre :: STR, optional
      with_lambda :: BIN, optional
      archive :: ARCHIVE
      avec_lambda :: BIN
      avec_lambda = FALSE
      if (present(with_lambda)) avec_lambda = with_lambda
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.write(item,genre)
      if (avec_lambda) then
        if (.scfdata.created) then
        if (.scfdata.scf_kind.includes("xray_") OR .scfdata.scf_kind.includes("pnd_")) then
        archive.set(.name,trim(archive_name)//",lambda="//trim(.scfdata.lambda.to_str("f5.3")))
        archive.write(item,genre)
        end
        end
      end
   end

   unarchive(opmatrix,archive_name,genre) ::: leaky
   ! Recover the "opmatrix" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opmatrix".
      opmatrix :: OPMATRIX*
      archive_name :: STR
      genre :: STR, optional
   ENSURE(opmatrix.any_created,"no opmatrix genre created")
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(opmatrix,genre)
   end

   unarchive(opvector,archive_name,genre) ::: leaky
   ! Recover the "opvector" from an archive on disk with name "archive_name".
   ! The kind is guessed from "opvector".
      opvector :: OPVECTOR
      archive_name :: STR
      genre :: STR, optional
   ENSURE(opvector.any_created,"no opvector genre created")
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(opvector,genre)
   end

   unarchive(item,archive_name,genre) ::: leaky
   ! Recover the "item" from an archive on disk with name "archive_name".
      item :: REAL
      archive_name :: STR
      genre :: STR, optional
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name)
      archive.read(item,genre)
   end

   unarchive(archive_name,genre) ::: template
   ! Recover the object from an archive on disk
      archive_name,genre :: STR, optional
   ENSURE(.basis_info_made,"no basis set info")
      name :: STR
      name = "NAME"
      if (present(archive_name)) name = archive_name
      if (.NAME.destroyed) then
        ENSURE(present(genre),"missing genre")
        .NAME.create(.n_bf,genre)
      end
      .unarchive(.NAME,name,genre)
   end

   delete_archive(name)
   ! Delete the archive called "name"
      name :: STR, IN

      archive :: ARCHIVE

      archive.set_defaults
      archive.set(.name,name)
      archive.delete_all_genres

   end

   archive_exists(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      archive_name,genre :: STR
      res :: BIN
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name,genre)
      res = archive.exists
   end

   archive_doesnt_exist(archive_name,genre) result (res)
   ! Return TRUE if the fock matrix exists
      archive_name,genre :: STR
      res :: BIN
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,archive_name,genre)
      res = NOT archive.exists
   end

!  ===================
!  SCF archive cleanup
!  ===================

! May be needed by involved non-SCF routines

   delete_scf_archives(keep_MOs,keep_DM) ::: recursive
   ! Delete any SCF-procedure generated archives stored on disk.
      keep_MOs,keep_DM :: BIN, optional

      archive :: ARCHIVE
      delete_MOs,delete_DM :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      delete_DM = TRUE
      if (present(keep_DM))  delete_DM  = NOT keep_DM

      archive.set_defaults

      if (delete_MOs) then
      archive.set(.name,"molecular_orbitals");          archive.delete_all_genres
      archive.set(.name,"orbital_energies");            archive.delete_all_genres
      end

      if (delete_DM) then
      archive.set(.name,"density_matrix");              archive.delete_all_genres
      end

      archive.set(.name,"fock_matrix");                 archive.delete_all_genres
      archive.set(.name,"natural_orbitals");            archive.delete_all_genres
      archive.set(.name,"occupation_numbers");          archive.delete_all_genres
      archive.set(.name,"energy");                      archive.delete_all_genres

      archive.set(.name,"promolecule_density_matrix");  archive.delete_all_genres
      archive.set(.name,"progroup_density_matrix");     archive.delete_all_genres
      archive.set(.name,"progroup_molecular_orbitals"); archive.delete_all_genres

      archive.set(.name,"U_electric_dipole");           archive.delete_all_genres

      archive.set(.name,"j_matrix");                    archive.delete_all_genres
      archive.set(.name,"constraint_matrix");           archive.delete_all_genres

      archive.set(.name,"eri_integrals");               archive.delete_all_genres
      archive.set(.name,"eri_index");                   archive.delete_all_genres

      ! WARNING: These two below are recursive
      .::delete_atom_scf_archives 
      .::delete_group_scf_archives 

      .::delete_lambda_scf_archives(keep_MOs)

   end

   delete_lambda_scf_archives(keep_MOs) ::: private
   ! Delete any lambda type archives stored on disk.
      keep_MOs :: BIN, optional

      l,l_max :: REAL
      l_str :: STR(len=5)
      archive :: ARCHIVE
      delete_MOs :: BIN

      delete_MOs = TRUE
      if (present(keep_MOs)) delete_MOs = NOT keep_MOs

      if (NOT delete_MOs)                  return
      if (.scfdata.destroyed)              return
      if (NOT .scfdata.is_constrained_scf) return

      archive.set_defaults
      l = .scfdata.initial_lambda
      l_max = .scfdata.lambda_max + l

      do 
         if (l>l_max) exit
         l_str = trim(l.to_str("f5.3"))
         archive.set(.name,"molecular_orbitals,lambda="//trim(l_str)); archive.delete_all_genres
         archive.set(.name,"orbital_energies,lambda="//trim(l_str));   archive.delete_all_genres
         l = l + .scfdata.lambda_step
      end

   end

   delete_atom_scf_archives ::: recursive, leaky
   ! Delete the atom SCF archives, if they exist.

      a :: INT
      mol :: MOLECULE*

      if (.n_atom_kind<=0) return

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle

         ! Delete
         mol.::create
         mol.name = .atom(a).chemical_symbol
         mol.::delete_scf_archives  
         mol.::destroy

      end

   end

   delete_group_scf_archives ::: recursive, private
   ! Delete any group type SCF archives.
      g :: INT

      if (.atom_group.destroyed) return

      do g = 1,.atom_group.dim
         if (.atom_group(g).mol.destroyed) cycle
         .atom_group(g).mol.::delete_scf_archives
      end

   end

   delete_scf_MO_archive
   ! Delete the SCF MO archives
      archive :: ARCHIVE
      archive.set_defaults
      archive.set(.name,"molecular_orbitals"); archive.delete_all_genres
      archive.set(.name,"orbital_energies");   archive.delete_all_genres
   end

!  ==============
!  Output methods
!  ==============

   put
   ! Put all the available molecule information on file

   DIE_IF(tonto.destroyed,"no tonto variable")

      .::put_basics

      if (tonto.low_verbosity) then
      if (.atom.created) then
         if (.atom.dim>100) return
      end
      end

      if (.atom.created)        .::put_atoms
      if (.atom_group.created)  .::atom_group.put
      if (.pointgroup.created)  .::put_pointgroup
      if (.crystal.created)     .::put_crystal
      if (.cluster.created)     .::put_cluster
      if (.becke_grid.created)  .::put_becke_grid

      if (.overlapping_atoms.created AND .atom.created) then
         .::put_overlapping_atoms
         .::put_overlapping_atoms_4_atom
      end

   end

   put_basics
   ! Put basic molecule information

      stdout.flush
      stdout.flush
      stdout.text("====================")
      stdout.text("Molecule information")
      stdout.text("====================")

      stdout.flush
      stdout.show("Name                   =",.name)

      stdout.flush
      stdout.show("Chemical Formula       =",trim(.::chemical_formula(with_spaces=TRUE)))
      stdout.show("Molecular weight       =",.atom.molecular_weight)

      stdout.flush
      stdout.show("Charge                 =",.charge)
      stdout.show("Multiplicity           =",.spin_multiplicity)

      stdout.flush
      stdout.show("No. of atoms           =",.n_atom)
      stdout.show("No. of electrons       =",.n_e)
      stdout.show("No. of alpha electrons =",.n_a)
      stdout.show("No. of beta  electrons =",.n_b)

      if (.atom.has_all_bases) stdout.flush
      if (.basis_name/=" ") then
      stdout.show("Gaussian basis name    =",.basis_name)
      stdout.show("Spherical harmonics?   =",.use_spherical_basis)
      end
      if (.slaterbasis_name/=" ") &
      stdout.show("Slater basis name      =",.slaterbasis_name)
      if (.coppensbasis_name/=" ") &
      stdout.show("Coppens basis name     =",.coppensbasis_name)

      if (NOT .E_field.is_zero) &
      stdout.show("Applied E Field        =",.E_field(1),.E_field(2),.E_field(3))
      if (NOT .B_field.is_zero) &
      stdout.show("Applied B Field        =",.B_field(1),.B_field(2),.B_field(3))
      if (NOT .gauge_origin.is_zero) &
      stdout.show("B field Gauge origin   =",.gauge_origin)

   end

   put_atoms
   ! Output the atom coordinate and basis set information

   ENSURE(.atom.created,"no atom list")

      .atom.put_coordinate_info

      if (.basis.created)        .::put_bases
    ! if (.coppensbasis.created) .put_coppensbases
    ! if (.slaterbasis.created)  .put_slaterbases
    ! .put_atom_ADP_tensors

   end

   put_principal_axes
   ! Output the atom principal axes
   ENSURE(.atom.created,"no atom list")
      .atom.put_principal_axes
   end

   put_bases
   ! Output the molecule basis set information, if the bases are all resolved.

   ENSURE(.atom.created,"no atom list")
   ENSURE(.basis.created,"no basis set list")

      if (NOT .atom.bases_are_resolved) return

      stdout.flush
      stdout.flush
      stdout.text("===================")
      stdout.text("Gaussian basis sets")
      stdout.text("===================")
      stdout.flush
      stdout.show("Basis name             =",.basis_name)
      stdout.flush
      stdout.show("No. of basis sets      =",.n_basis)
      stdout.show("No. of shells          =",.n_shell)
      stdout.show("No. of shell pairs     =",.::no_of_shell_pairs)
      stdout.show("No. of basis functions =",.n_bf)
      stdout.show("No. of primitives      =",.n_prim)
      stdout.flush

      .basis.renormalise
      .basis.put
      .basis.unnormalise

   end

   put_slaterbases
   ! Output the molecule slaterbasis set information, if the bases are all
   ! resolved.
   ENSURE(.atom.created,"no atom list")
   ENSURE(.slaterbasis.created,"no basis set list")
      if (NOT .atom.slaterbases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom slaterbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.slaterbasis.dim)
      .slaterbasis.put
   end

   put_coppensbases
   ! Output the molecule coppensbasis set information, if the bases are all
   ! resolved.
   ENSURE(.atom.created,"no atom list")
   ENSURE(.coppensbasis.created,"no basis set list")
      if (NOT .atom.coppensbases_are_resolved) return
      stdout.flush
      stdout.text("Molecule atom coppensbasis set information:")
      stdout.flush
      stdout.show("No. of basis sets =",.coppensbasis.dim)
      stdout.show("Maximum N value   =",.coppensbasis.maximum_basis_n_value)
      stdout.show("No. of orbitals   =",.coppensbasis.no_of_orbitals)
      stdout.show("No. of primitives =",.coppensbasis.no_of_primitives)
      .coppensbasis.put
   end

!   put_atom_ADP_tensors
!   ! Output the ADP (thermal) tensors if they exist.
!   
!   ENSURE(.atom.created,"no atom info")
!
!      xmodel,nmodel :: STR
!
!      if (NOT .atom.has_nonzero_ADPs) return
!
!      xmodel = "none"
!      nmodel = "none"
!      if (.crystal.created) then
!         if (.crystal.xray_data.created) xmodel = .crystal.xray_data.thermal_smearing_model
!         if (.crystal.pnd_data.created)  nmodel = .crystal.pnd_data.thermal_smearing_model
!      end
!
!      stdout.flush
!      stdout.flush
!      stdout.text("==============================")
!      stdout.text("Atomic displacement parameters")
!      stdout.text("==============================")
!      stdout.flush
!      stdout.show("X-ray ADP model =",xmodel)
!      stdout.show("PND   ADP model =",nmodel)
!
!      .atom.put_ADPs(.crystal.unit_cell)
!
!   end

   put_atom_groups
   ! Out out the .atom_group info array
   ENSURE(.atom_group.created,"no atom group information")
      .atom_group.put
   end

   put_overlapping_atoms
   ! Out out the .overlapping_atom info array
   ENSURE(.overlapping_atoms.created,"no overlapping_atoms")
   ENSURE(.atom.created,"no atoms")

      i,j,k :: INT

      stdout.save
      stdout.set_int_width(4)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.text(" ")
      stdout.text("Overlapping atoms:")
      stdout.text(" ")

      do i = 1,.atom.dim
         k = 1
         stdout.put(i)
         do j = 1,.atom.dim
            if (NOT .::is_overlapping_atom(i,j)) cycle
            k = k + 1
            stdout.put(j)
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end

      stdout.unsave

   end

   put_overlapping_atoms_4_atom
   ! Out out the .overlapping_atoms_for_atom info array
   ENSURE(.overlapping_atoms.created,"no overlapping_atoms")
   ENSURE(.atom.created,"no atoms")

      i,j,k :: INT

      stdout.save
      stdout.set_int_width(4)
      stdout.set_no_of_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)

      stdout.text(" ")
      stdout.text("Overlapping atoms for atom:")
      stdout.text(" ")

      do i = 1,.atom.dim
         stdout.put(i)
         k = 1
         do j = 1,.overlapping_atoms_for_atom(i).element.dim
            k = k + 1
            stdout.put(.overlapping_atoms_for_atom(i)[j])
            if (mod(k,25)==0) stdout.flush
         end
            if (mod(k,25)/=0) stdout.flush
      end

      stdout.unsave

   end

   put_pointgroup
   ! Output the current pointgroup
      .pointgroup.put
   end

   put_plot_grid
   ! Output the current grid.
   ENSURE(.plot_grid.created,"no plot grid to output")
      .plot_grid.put
   end

   put_becke_grid
   ! Output the current DFT grid.
   ENSURE(.becke_grid.created,"no Becke integration grid to output")
      .becke_grid.put
   end

   put_crystal
   ! Output the current crystal
      .crystal.put
   end

   put_cluster
   ! Put out the cluster information
   ENSURE(.cluster.created,"no cluster data")
      .cluster.put
   end

   put_crystal_reflection_data
   ! Output the current crystal
      .crystal.put_reflection_data
   end

   put_crystal_F_statistics
   ! Output the current crystal
      .crystal.put_F_statistics
   end

   put_molecular_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_MOs_and_energies
   ! Output the current associated molecular orbitals and their energies
      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.orbital_energies)
      stdout.flush
      stdout.text("Molecular orbitals:")
      stdout.put(.molecular_orbitals)
   end

   put_MO_energies
   ! Output the molecular orbital energies
      stdout.flush
      stdout.text("Molecular orbital energies:")
      stdout.put(.orbital_energies)
   end

   put_natural_orbitals
   ! Output the current associated molecular orbitals
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put(.occupation_numbers)
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put(.natural_orbitals)
   end

   put_density_matrix
   ! Output the current associated density matrix
   ENSURE(.density_matrix.created,"no density matrix")
      stdout.flush
      stdout.text("Density matrix:")
      stdout.put(.density_matrix)
   end

   put_fock_matrix
   ! Output the current associated fock matrix
   ENSURE(.fock_matrix.created,"no fock matrix")
      stdout.flush
      stdout.text("Fock matrix:")
      stdout.put(.fock_matrix)
   end

   put_current_time(timer)
   ! Output the current time
      timer :: TIME
      if (FALSE) self = self
      stdout.text(timer.current_time_message)
   end

   put_time_taken(timer)
   ! Output the time taken as given by the "timer" object
      timer :: TIME
      if (FALSE) self = self
      stdout.text(timer.elapsed_time_message)
   end

   put_vrml
   ! Output a VRML file for the coordinate geometry
   ENSURE(.atom.created,"no atom list!")
      out :: TEXTFILE*
      out.create(trim(.name)//achar(46)//"wrl")
      out.open(for="write")
      stdout.text("Generating VRML molecule")
      out.text("#VRML V2.0 utf8")
      out.text("NavigationInfo { type " // achar(34) // "EXAMINE" // achar(34) // " }")
      out.text("Viewpoint { ")
      out.text("position 0 0 10")
      out.text("fieldOfView 1")
      out.text("orientation 0 0 1 0")
      out.text('description "camera z"')
      out.text("}")
      out.text("DirectionalLight {")
      out.text("  color 1 1 1")
      out.text("  direction 1 0 0")
      out.text("  intensity 0.4")
      out.text("}")
      .atom.put_vrml(out)
      if (.isosurface.created) .isosurface.put_vrml(out)
      stdout.text("done VRML molecule")
   end

!  =====
!  ANO's
!  =====

   put_ANOs ::: leaky
   ! Put the ANO data out for all atoms in the molecule.
   ENSURE(.atom.created,"no atoms")

      k,a,b :: INT
      list :: STR

      if (NOT .::has_all_ANOs) return

      if (.n_atom_kind<=0) return

      stdout.flush
      stdout.text("========")
      stdout.text("ANO data")
      stdout.text("========")

      do a = 1,.n_atom

         ! Unique atom?
         if (NOT .atom(a).is_unique_kind) cycle
         k = .atom(a).kind

         list = trim(a.to_str)
         do b = a+1,.n_atom
            if (.atom(b).kind/=k) cycle
            list = trim(list)//" "//trim(b.to_str)
         end
         list = "ANO's for atoms ... "//trim(list)

         stdout.flush
         stdout.text(repeat("=",len_trim(list)))
         stdout.text(list)
         stdout.text(repeat("=",len_trim(list)))
         .atom(a).put_ANOs
         stdout.flush

      end

   end

!  =======
!  Put cif
!  =======

   put_cif
   ! Prints out a cif file for the crystal asymmetric unit
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      scf_type :: STR
      mass,radius :: REAL

      ! Create the cif file
      stdout.redirect(trim(.name)//".standard.cif")
      stdout.open(for="write")

      ! Put the header information
      stdout.text("# ========================")
      stdout.text("# TONTO generated CIF file")
      stdout.text("# ========================")
      stdout.flush 
      stdout.text("data_"//trim(.name))
      stdout.flush 
      stdout.text("_audit_creation_date               "//trim(std_time.current_date_YMD_str))
      stdout.text("_audit_creation_method             'Tonto v"//TONTO_VERSION//" ($Rev: 3699 $)'")
      stdout.flush 
      stdout.text("# ==================--")
      stdout.text("# Chemical information")
      stdout.text("# ==================--")
      stdout.flush 
      stdout.text("_chemical_name_common              "//trim(.name))
      stdout.text("_chemical_formula_moiety           '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_sum              '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      mass = .atom.mass
      stdout.text("_chemical_formula_weight           "//trim(mass.to_str("f8.2")))
      stdout.text("_chemical_compound_source          'see text'")
      stdout.text("_chemical_absolute_configuration   unk")

      ! Put the crystal information
      scf_type = " "
      if (.scfdata.created) then
         scf_type = .scfdata.scf_kind
         if (.scfdata.is_DFT_calculation) then
            scf_type = trim(scf_type)//" "// &
                       trim(.scfdata.dft_exchange_functional)// &
                       trim(.scfdata.dft_correlation_functional)
         end
         if (.scfdata.using_cluster_charges) then
            radius = .scfdata.cluster_radius.to_units("angstrom")
            scf_type = trim(scf_type)//" using cluster charges, radius="// &
                       trim(radius.to_str("f5.1"))//" angstrom"
         end
      end
      .crystal.put_cif(.basis_name,scf_type)

      ! Clean up
      stdout.revert

   end

   put_accurate_cif
   ! Prints out an accurate cif file for the crystal asymmetric unit
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      scf_type :: STR
      mass,radius :: REAL

      ! Create the cif file
      stdout.redirect(trim(.name)//".accurate.cif")
      stdout.open(for="write")

      ! Put the header information
      stdout.text("# ========================")
      stdout.text("# TONTO generated CIF file")
      stdout.text("# ========================")
      stdout.flush 
      stdout.text("data_"//trim(.name))
      stdout.flush 
      stdout.text("_audit_creation_date               "//trim(std_time.current_date_YMD_str))
      stdout.text("_audit_creation_method             'Tonto v"//TONTO_VERSION//" ($Rev: 3699 $)'")
      stdout.flush 
      stdout.text("# ==================--")
      stdout.text("# Chemical information")
      stdout.text("# ==================--")
      stdout.flush 
      stdout.text("_chemical_name_common              "//trim(.name))
      stdout.text("_chemical_formula_moiety           '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_sum              '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      mass = .atom.mass
      stdout.text("_chemical_formula_weight           "//trim(mass.to_str("f8.2")))
      stdout.text("_chemical_compound_source          'see text'")
      stdout.text("_chemical_absolute_configuration   unk")

      ! Put the crystal information
      scf_type = " "
      if (.scfdata.created) then
         scf_type = .scfdata.scf_kind
         if (.scfdata.is_DFT_calculation) then
            scf_type = trim(scf_type)//" "// &
                       trim(.scfdata.dft_exchange_functional)// &
                       trim(.scfdata.dft_correlation_functional)
         end
         if (.scfdata.using_cluster_charges) then
            radius = .scfdata.cluster_radius.to_units("angstrom")
            scf_type = trim(scf_type)//" using cluster charges, radius="// &
                       trim(radius.to_str("f5.1"))//" angstrom"
         end
      end
      .crystal.put_accurate_cif(.basis_name,scf_type)

      ! Clean up
      stdout.revert

   end

   put_molecule_cif
   ! Prints out an accurate cif file for the actual molecule
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      scf_type :: STR
      mass,radius :: REAL

      ! Create the cif file
      stdout.redirect(trim(.name)//".molecule.cif")
      stdout.open(for="write")

      ! Reset no. of fields per line
      stdout.save
      stdout.set_no_of_fields_per_line(5)

      ! Put the header information
      stdout.text("# ========================")
      stdout.text("# TONTO generated CIF file")
      stdout.text("# ========================")
      stdout.flush 
      stdout.text("data_"//trim(.name))
      stdout.flush 
      stdout.text("_audit_creation_date               "//trim(std_time.current_date_YMD_str))
      stdout.text("_audit_creation_method             'Tonto v"//TONTO_VERSION//" ($Rev: 3699 $)'")
      stdout.flush 
      stdout.text("# ==================--")
      stdout.text("# Chemical information")
      stdout.text("# ==================--")
      stdout.flush 
      stdout.text("_chemical_name_common              "//trim(.name))
      stdout.text("_chemical_formula_moiety           '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      stdout.text("_chemical_formula_sum              '"//trim(.atom.chemical_formula(with_spaces=TRUE))//"'")
      mass = .atom.mass
      stdout.text("_chemical_formula_weight           "//trim(mass.to_str("f8.2")))
      stdout.text("_chemical_compound_source          'see text'")
      stdout.text("_chemical_absolute_configuration   unk")

      ! Put the crystal information
      scf_type = " "
      if (.scfdata.created) then
         scf_type = .scfdata.scf_kind
         if (.scfdata.is_DFT_calculation) then
            scf_type = trim(scf_type)//" "// &
                       trim(.scfdata.dft_exchange_functional)// &
                       trim(.scfdata.dft_correlation_functional)
         end
         if (.scfdata.using_cluster_charges) then
            radius = .scfdata.cluster_radius.to_units("angstrom")
            scf_type = trim(scf_type)//" using cluster charges, radius="// &
                       trim(radius.to_str("f5.1"))//" angstrom"
         end
      end
      .crystal.put_molecule_cif(.atom,.basis_name,scf_type)

      ! Clean up
      stdout.unsave
      stdout.revert

   end

   put_NKA_cartesian
   ! Prints out (some of) the data for an NKA analysis
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      ! Create the NKA file
      stdout.redirect("stdout.nka_cartesian")
      stdout.open(for="write")

      ! Reset accuracy
      stdout.save
      stdout.set_real_width(11)
      stdout.set_real_precision(6)

      ! Name
      stdout.text(.name)

      ! Put the NKA data
      .crystal.put_NKA_cartesian

      ! Clean up
      stdout.unsave
      stdout.revert

   end

!   put_NKA_crystal
!   ! Prints out (some of) the data for an NKA analysis
!   ENSURE(.crystal.created, "No crystal")
!   ENSURE(.atom.created, "No atom")
!
!      ! Create the NKA file
!      stdout.redirect("stdout.nka_crystal")
!      stdout.open(for="write")
!
!      ! Reset accuracy
!      stdout.save
!      stdout.set_real_width(11)
!      stdout.set_real_precision(6)
!
!      ! Name
!      stdout.text(.name)
!
!      ! Put the NKA data
!      .crystal.put_NKA_crystal
!
!      ! Clean up
!      stdout.unsave
!      stdout.revert
!
!   end

   put_excel_crystal
   ! Prints out crystal data in excel format for easy comparison
   ENSURE(.crystal.created, "No crystal")
   ENSURE(.atom.created, "No atom")

      ! Create the NKA file
      stdout.redirect("stdout.nka_excel")
      stdout.open(for="write")

      ! Reset accuracy
      stdout.save
      stdout.set_real_width(11)
      stdout.set_real_precision(6)

      ! Name
      stdout.text(.name)

      ! Put the Excel data
      .crystal.put_excel_crystal

      ! Clean up
      stdout.unsave
      stdout.revert

   end

!  ==============
!  Debug printing
!  ==============

   set_debug_on(name) ::: get_from(DEBUG), leaky
   ! Add a debug descriptor to the list.
   end

   set_debug_off(name) ::: get_from(DEBUG), leaky
   ! Remove a debug descriptor from the list.
   end

   read_debug_on ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and add it to the list.
   end

   read_debug_off ::: get_from(DEBUG), leaky
   ! Read a debug descriptor and remove it from the list.
   end

   debugging(name) result (res) ::: get_from(DEBUG)
   ! Return TRUE if the debug switch "name" has been set.
   end

   put_debug_list ::: get_from(DEBUG)
   ! Put of the list of debug switches
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>STR)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>BIN)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>INT)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>REAL)
   ! Put *number* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{INT})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>VEC{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{REAL})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>MAT{CPX})
   ! Put *array* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG, TYPE=>SHELL2)
   ! Put *object* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

   put_debug(X,name) ::: get_from(DEBUG)
   ! Put *opmatrix* "X" to output, with descriptor "name", if the debug switch for
   ! it has been set.
   end

end
