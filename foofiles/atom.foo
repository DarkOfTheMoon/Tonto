!-------------------------------------------------------------------------------
! ATOM: a QM atom with a basis set
!
! (c) Dylan Jayatilaka, november 1997
!
! $Id$
!-------------------------------------------------------------------------------
module ATOM

   use TYPES
   use SYSTEM
   use STR
   use BUFFER
   use INT
   use INPUT
   use OUTPUT
   use VEC
   use MAT
   use MAT3
   use OPVEC
   use OPMAT
   use SHELL
   use BASIS

   implicit none         

#  include "macros"
#  include "atom.int"

!   type atom_type
!
!   STR :: label
!   ! The label for the atom (not necessarily unique)
!
!   INT :: atomic_number
!   ! The atomic number
!
!   VEC(3) :: pos
!   ! Atom position
!
!   MAT(3,3) :: thermal_tensor DEFAULT(ZERO)
!   ! The thermal tensor for the atom
!
!   BASIS, PTR :: basis DEFAULT_NULL
!   ! The basis for the atom
!
!   OPMAT, PTR :: natural_orbitals DEFAULT_NULL
!   ! The natural orbitals for the atom
!
!   OPVEC, PTR :: occupation DEFAULT_NULL
!   ! The occupation numbers for the atom
!
!   end

   !  Periodic Table

   CHR(2), private :: element_symbols(103) = (/ &
    "H ",                                                                                "He", &
    "Li","Be",                                                  "B ","C ","N ","O ","F ","Ne", &
    "Na","Mg",                                                  "Al","Si","P ","S ","Cl","Ar", &
    "K ","Ca","Sc","Ti","V ","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr", &
    "Rb","Sr","Y ","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I ","Xe", &
    "Cs","Ba","La",     "Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu", &
                   "Hf","Ta","W ","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn", &
    "Fr","Ra","Ac",     "Th","Pa","U ","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr" /)

   !  Bragg-Slater radii taken from Aaron Lee's code

   VEC(54) :: bragg_slater_radii = (/ &
      0.35d0,0.35d0,                                           &
      1.45d0,1.05d0,0.85d0,0.70d0,0.65d0,0.60d0,0.50d0,0.45d0, &
      1.80d0,1.50d0,1.25d0,1.10d0,1.00d0,1.00d0,1.00d0,1.00d0, &
      2.20d0,1.80d0,                                           &
      1.60d0,1.40d0,1.35d0,1.40d0,1.40d0,                      &
      1.40d0,1.35d0,1.35d0,1.35d0,1.35d0,                      &
                    1.30d0,1.25d0,1.15d0,1.15d0,1.15d0,1.15d0, &
      1.30d0,1.30d0,                                           &
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      &
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0  /)

   !  Abundance weighted atomic masses taken from the WWW to be the same
   !  as Turbomol

   VEC(92) :: atomic_masses = (/ &
       1.007970d0,   4.002600d0, &
       6.939000d0,   9.012200d0,  10.811000d0,  12.011150d0,  14.006700d0,  15.999400d0,  18.998400d0,  20.183000d0, &
      22.989800d0,  24.312000d0,  26.981500d0,  28.086000d0,  30.973800d0,  32.064000d0,  35.453000d0,  39.948000d0, &
      39.102000d0,  40.080000d0, &
                    44.956000d0,  47.900000d0,  50.942000d0,  51.996000d0,  54.938000d0, &
                    55.850000d0,  58.933200d0,  58.710000d0,  63.540000d0,  65.370000d0, &
                                  69.720000d0,  72.590000d0,  74.921600d0,  78.960000d0,  79.909000d0,  83.800000d0, &
      85.470000d0,  87.620000d0,  &
                    88.905000d0,  91.220000d0,  92.906000d0,  95.940000d0,  99.000000d0, &
                   101.070000d0, 102.905000d0, 106.400000d0, 107.870000d0, 112.400000d0, &
                                 114.820000d0, 118.690000d0, 121.750000d0, 127.600000d0, 126.904000d0, 131.300000d0, &
     132.905000d0, 137.330000d0, &
                   138.910000d0, 140.115000d0, 140.908000d0, 144.240000d0, 146.920000d0, 150.360000d0, 151.965000d0, &
                   157.250000d0, 158.925000d0, 162.500000d0, 164.930000d0, 167.260000d0, 168.930000d0, 173.040000d0, &
                   174.970000d0, 178.490000d0, 180.950000d0, 183.850000d0, 186.210000d0, &
                   190.200000d0, 192.220000d0, 195.080000d0, 196.070000d0, 200.590000d0, &
                                 204.380000d0, 207.200000d0, 208.980000d0, 208.980000d0, 209.990000d0, 222.020000d0, &
     223.020000d0, 226.030000d0, &
                   227.030000d0, 232.040000d0, 231.040000d0, 238.030000d0 /)

   !  Abundance-weighted coherent neutron scattering lengths in fm taken from:
   !  International Tables for Crystallography, Vol. C, 1992, pp 384-391

   VEC(95) :: neutron_scattering_lengths = (/ &
      -3.7390,  3.2600, &
      -1.9000,  7.7900,  5.3000,  6.6460,  9.3600,  5.8030,  5.6540,  4.5470, &
       3.6300,  5.3750,  3.4490,  4.1490,  5.1300,  2.8470,  9.5770,  1.9090, &
       3.7100,  4.9000, & 
               12.2900, -3.4380,  -.3824,  3.6350, -3.7300, &
                9.5400,  2.5000, 10.3000,  7.7180,  5.6890, &
                         7.2879,  8.1929,  6.5800,  7.9700,  6.7950,  7.8000, &
       7.0800,  7.0200, &
                7.7500,  7.1600,  7.0540,  6.9500,  6.8000, &
                7.2100,  5.8800,  5.9100,  5.9220,  5.1000, &
                         4.0650,  6.2257,  5.5700,  5.8000,  5.2800,  4.8500, &
       5.4200,  5.0600, &
                8.2400,  4.8400,  4.4500,  7.6900, 12.6000,  4.2000,  6.7300, &
                9.5000,  7.3800, 16.9000,  8.0800,  8.0300,  7.0700, 12.4100, &
                7.2100,  7.7700,  6.9100,  4.7700,  9.2000, &
               11.0000, 10.6000,  9.6000,  7.6300, 12.6920, &
                         8.7760,  9.4017,  8.5307,  0.0000,  0.0000,  0.0000, & 
       0.0000, 10.0000, &
                0.0000, 10.6300,  9.1000,  8.4170, 10.5500, 14.1000,  8.3000 /)


   ! First element is f', second is f".  Cr wavelength = 2.291A.
   CVEC(92) :: dispersion_correction_Cr = (/ &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),  (0.0d0, 0.0d0), &
     (0.0d0, 0.1d0),   (0.0d0, 0.1d0),   (0.1d0, 0.1d0),   (0.1d0, 0.2d0),  (0.1d0, 0.3d0), &
     (0.2d0, 0.4d0),   (0.2d0, 0.5d0),   (0.2d0, 0.6d0),   (0.3d0, 0.8d0),  (0.3d0, 0.9d0), &
     (0.3d0, 1.2d0),   (0.3d0, 1.4d0),   (0.2d0, 1.7d0),   (0.0d0, 2.1d0),  (-0.2d0, 2.6d0), &
     (-0.7d0, 3.1d0),  (-1.7d0, 3.7d0),  (-4.4d0, 0.5d0),  (-2.2d0, 0.6d0), (-1.8d0, 0.7d0), &
     (-1.6d0, 0.8d0),  (-1.4d0, 0.9d0),  (-1.2d0, 1.1d0),  (-1.1d0, 1.2d0), (-1.0d0, 1.4d0), &
     (-0.9d0, 1.6d0),  (-0.8d0, 1.8d0),  (-0.7d0, 2.1d0),  (-0.7d0, 2.3d0), (-0.7d0, 2.5d0), &
     (-0.7d0, 2.8d0),  (-0.7d0, 3.2d0),  (-0.7d0, 3.6d0),  (-0.7d0, 3.9d0), (-0.8d0, 4.3d0), &
     (-0.8d0, 4.8d0),  (-0.9d0, 5.3d0),  (-1.1d0, 5.9d0),  (-1.2d0, 6.4d0), (-1.4d0, 6.9d0), &
     (-1.7d0, 7.5d0),  (-2.0d0, 8.2d0),  (-2.3d0, 8.8d0),  (-2.8d0, 9.5d0), (-3.3d0, 10.3d0), &
     (-4.0d0, 11.1d0), (-5.0d0, 11.9d0), (-7.1d0, 13.1d0), (-9d0, 10d0),    (-12d0, 11d0), &
     (-11d0, 8d0),     (-14d0, 3d0),     (-10d0, 3d0),     (-9d0, 3d0),     (-8d0, 4d0), &
     (-7d0, 4d0),      (-7d0, 4d0),      (-6d0, 5d0),      (-6d0, 5d0),     (-6d0, 6d0), &
     (-6d0, 6d0),      (-5d0, 7d0),      (-5d0, 7d0),      (-5d0, 8d0),     (-5d0, 8d0), &
     (-5d0, 9d0),      (-5d0, 9d0),      (-5d0, 10d0),     (-5d0, 10d0),    (-5d0, 11d0), &
     (-5d0, 12d0),     (-5d0, 13d0),     (-5d0, 14d0),     (-5d0, 14d0),    (-5d0, 15d0), &
     (-5d0, 16d0),     (-6d0, 17d0),     (-6d0, 18d0),     (-7d0, 19d0),    (-8d0, 20d0), &
     (-9d0, 22d0),     (-10d0, 23d0),    (-11d0, 24d0),    (-12d0, 26d0),   (-13d0, 27d0), &
     (-15d0, 28d0),    (-17d0, 27d0)/)

   ! First element is f', second is f".  Cu wavelength = 1.542A.
   CVEC(92) :: dispersion_correction_Cu = (/ &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),  (0.0d0, 0.0d0),   (0.0d0, 0.0d0), &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.1d0),  (0.0d0, 0.1d0),   (0.1d0, 0.1d0), &
     (0.1d0, 0.2d0),   (0.1d0, 0.2d0),   (0.1d0, 0.3d0),  (0.2d0, 0.4d0),   (0.2d0, 0.5d0), &
     (0.3d0, 0.6d0),   (0.3d0, 0.7d0),   (0.3d0, 0.8d0),  (0.3d0, 1.0d0),   (0.3d0, 1.3d0), &
     (0.3d0, 1.5d0),   (0.2d0, 1.8d0),   (0.1d0, 2.2d0),  (-0.1d0, 2.5d0),  (-0.5d0, 2.9d0), &
     (-1.1d0, 3.3d0),  (-2.2d0, 3.8d0),  (-3.1d0, 0.5d0), (-2.1d0, 0.6d0),  (-1.7d0, 0.7d0), &
     (-1.5d0, 0.8d0),  (-1.3d0, 0.9d0),  (-1.2d0, 1.0d0), (-1.1d0, 1.1d0),  (-1.0d0, 1.3d0), &
     (-1.0d0, 1.5d0),  (-0.9d0, 1.7d0),  (-0.8d0, 1.8d0), (-0.8d0, 2.0d0),  (-0.7d0, 2.2d0), &
     (-0.7d0, 2.5d0),  (-0.6d0, 2.7d0),  (-0.6d0, 3.0d0), (-0.6d0, 3.3d0),  (-0.6d0, 3.6d0), &
     (-0.6d0, 3.9d0),  (-0.6d0, 4.3d0),  (-0.7d0, 4.6d0), (-0.8d0, 5.0d0),  (-0.9d0, 5.4d0), &
     (-1.0d0, 5.8d0),  (-1.1d0, 6.2d0),  (-1.3d0, 6.7d0), (-1.6d0, 7.2d0),  (-1.9d0, 7.7d0), &
     (-2.3d0, 8.3d0),  (-2.7d0, 8.9d0),  (-3.1d0, 9.6d0), (-3.6d0, 10.2d0), (-4.4d0, 10.9d0), &
     (-5.3d0, 11.5d0), (-6.7d0, 12.4d0), (-9d0, 10.2d0),  (-12d0, 11.2d0),  (-11d0, 7d0), &
     (-10d0, 8d0),     (-13d0, 3d0),     (-9d0, 3d0),     (-8d0, 4d0),      (-8d0, 4d0), &
     (-7d0, 4d0),      (-7d0, 4d0),      (-6d0, 5d0),     (-6d0, 5d0),      (-6d0, 5d0), &
     (-6d0, 6d0),      (-6d0, 6d0),      (-5d0, 7d0),     (-5d0, 7d0),      (-5d0, 8d0), &
     (-5d0, 8d0),      (-5d0, 9d0),      (-5d0, 9d0),     (-5d0, 10d0),     (-5d0, 10d0), &
     (-5d0, 11d0),     (-5d0, 11d0),     (-5d0, 12d0),    (-5d0, 12d0),     (-5d0, 13d0), &
     (-5d0, 14d0),     (-5d0, 15d0) /)

   ! First element is f', second is f".  Mo wavelength = 0.7107A.
   CVEC(92) :: dispersion_correction_Mo = (/ &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),  &
     (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),   (0.0d0, 0.0d0),  &
     (0.0d0, 0.1d0),   (0.0d0, 0.1d0),   (0.1d0, 0.1d0),   (0.1d0, 0.1d0),   (0.1d0, 0.1d0),  &
     (0.1d0, 0.2d0),   (0.1d0, 0.2d0),   (0.1d0, 0.2d0),   (0.2d0, 0.3d0),   (0.2d0, 0.3d0),  &
     (0.2d0, 0.4d0),   (0.2d0, 0.5d0),   (0.3d0, 0.6d0),   (0.3d0, 0.7d0),   (0.3d0, 0.8d0),  &
     (0.3d0, 0.9d0),   (0.3d0, 1.0d0),   (0.3d0, 1.1d0),   (0.3d0, 1.3d0),   (0.3d0, 1.5d0),  &
     (0.2d0, 1.6d0),   (0.2d0, 1.8d0),   (0.1d0, 2.0d0),   (-0.1d0, 2.2d0),  (-0.3d0, 2.4d0),  &
     (-0.6d0, 2.7d0),  (-0.9d0, 3.0d0),  (-1.4d0, 3.4d0),  (-2.3d0, 3.7d0),  (-2.8d0, 0.6d0),  &
     (-2.1d0, 0.6d0),  (-1.7d0, 0.7d0),  (-1.5d0, 0.8d0),  (-1.3d0, 0.8d0),  (-1.2d0, 0.9d0),  &
     (-1.1d0, 1.0d0),  (-1.0d0, 1.1d0),  (-0.9d0, 1.3d0),  (-0.8d0, 1.4d0),  (-0.8d0, 1.5d0),  &
     (-0.8d0, 1.6d0),  (-0.7d0, 1.8d0),  (-0.7d0, 1.9d0),  (-0.6d0, 2.1d0),  (-0.6d0, 2.3d0),  &
     (-0.6d0, 2.5d0),  (-0.5d0, 2.7d0),  (-0.5d0, 2.9d0),  (-0.5d0, 3.1d0),  (-0.5d0, 3.3d0),  &
     (-0.5d0, 3.5d0),  (-0.5d0, 3.7d0),  (-0.5d0, 3.9d0),  (-0.6d0, 4.1d0),  (-0.6d0, 4.3d0),  &
     (-0.7d0, 4.7d0),  (-0.7d0, 5.0d0),  (-0.7d0, 5.3d0),  (-0.8d0, 5.6d0),  (-0.8d0, 5.9d0),  &
     (-0.9d0, 6.1d0),  (-1.0d0, 6.4d0),  (-1.1d0, 6.7d0),  (-1.3d0, 7.1d0),  (-1.5d0, 7.5d0),  &
     (-1.7d0, 7.9d0),  (-2.0d0, 8.3d0),  (-2.2d0, 8.7d0),  (-2.5d0, 9.2d0),  (-2.9d0, 9.7d0),  &
     (-3.5d0, 10.2d0), (-4.1d0, 10.7d0), (-4.8d0, 11.1d0), (-5.5d0, 11.7d0), (-7d0, 9d0),  &
     (-8d0, 10d0),     (-8d0, 7d0),      (-7d0, 7d0),      (-7d0, 8d0),      (-7d0, 7d0),  &
     (-7d0, 8d0),      (-8d0, 8d0) /)

contains

!  ******************
!  Allocation methods
!  ******************

   create
   ! Create an atom
      PTR :: self
      nullify(self)
      allocate(self)
      .nullify_ptr_part
      ADD_MEM(ATOM_SIZE)
      .thermal_tensor = ZERO
   end

  create_copy(atom)
  ! Create a copy of atom.
    ATOM :: atom
    PTR :: self
    .create
    .copy(atom)
  end

  copy(atom)
  ! Make self a copy of atom.
    ATOM :: atom
    self%label = atom%label
    self%atomic_number = atom%atomic_number
    self%pos = atom%pos
    self%thermal_tensor = atom%thermal_tensor
    if (associated(atom%basis)) self%basis => atom%basis
  end

   destroy 
   ! Destroy an atom
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      deallocate(self)
      DELETE_MEM(ATOM_SIZE)
   end
  
   nullify_ptr_part
   ! Nullify the pointer parts of the atom
      nullify(.basis)
      nullify(.natural_orbitals)
      nullify(.occupation)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of an atom
      .basis.destroy
      .natural_orbitals.destroy
      .occupation.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end
 
   set_default
   ! Set a default atom
      .thermal_tensor = ZERO
      .label = "H"
      .atomic_number = 1
      .pos = (/ZERO,ZERO,ZERO/)
      .basis.create
      .basis.set_default
   end

!  *************
!  Input methods
!  *************

   read(in)
   ! Read an ATOM (without basis set) from "in"
   ! Atom symbol followed by three coordinates
      INPUT :: in
      INT :: lensym,z
      STR :: symbol
      in.read(.label)                ! Input atom label
      if (.label.is_int) then        ! The label must be the atomic number
         z = .label.to_int
         .atomic_number = z
      else                           ! The first part of the label is the element symbol
         lensym = .label.scan("123456789 ")-1
         symbol = .label(1:lensym)
         DIE_IF(lensym>2 OR lensym==0,"unacceptable atom symbol, "// trim(.label))
         symbol(1:1).to_upper_case
         symbol(2:2).to_lower_case
         if (any(element_symbols==symbol(1:2))) then
            do z=1,size(element_symbols)
               if (element_symbols(z)==symbol(1:2)) exit
            end
            .atomic_number = z
         else
            DIE("unknown element symbol: "//trim(symbol))
         end
      end
      in.read(.pos)                  ! read the coordinates
   end

   read_basis(in)
   ! Read an ATOM basis set from "in"
      INPUT :: in
      if (NOT associated(.basis)) .basis.create 
      .basis.read(in)
   end

   read_basis_label(in) [leaky]
   ! Read only the ATOM basis set label from "in"
      INPUT :: in
      .basis.create 
      .basis.read_label(in)
   end

   read_basis_shellvec(in) [leaky]
   ! Read only the ATOM basis shell vector part from "in"
      INPUT :: in
      .basis.create 
      .basis.read_shellvec(in)
   end

   read_thermal_tensor(in,unitcell,crystal)
   ! Read thermal parameters from "in", assumed in cartesian basis system with
   ! units (Angstrom)^-2. "unitcell" describes the crystal axis system.

   ! Whether already in crystal axis system can be controlled by the keywords
   ! "crystal" or "cartesian" at the end of the line, or call the routine with
   ! crystal=TRUE or FALSE.  Input line has priority when both specified.
   ! Default is crystal system.
      INPUT :: in
      UNITCELL :: unitcell
      BIN, IN, optional :: crystal
      STR :: coords
      BIN :: cryst
      cryst = TRUE                  ! Default is crystal coordinates
      in.read(.thermal_tensor(1,1)) ! Units must be angstrom^-2
      in.read(.thermal_tensor(2,2)) 
      in.read(.thermal_tensor(3,3)) 
      in.read(.thermal_tensor(1,2)) 
      in.read(.thermal_tensor(1,3)) 
      in.read(.thermal_tensor(2,3)) 
      .thermal_tensor(2,1) = .thermal_tensor(1,2)
      .thermal_tensor(3,1) = .thermal_tensor(1,3)
      .thermal_tensor(3,2) = .thermal_tensor(2,3)
      ! assume in Angtrom^{-2} ... change to bohr^{-2}
      .thermal_tensor = .thermal_tensor*(BOHR_PER_ANGSTROM)**2 

      if ( in%buffer.not_exhausted ) then
        in.read(coords)
        coords.to_lower_case
        select case (coords)
          case ("cartesian"); cryst = FALSE
          case ("crystal"); cryst = TRUE
          case default; DIE("unknown coordinate system " // trim(coords))
        end
      else
        if (present(crystal)) cryst = crystal
      end

      if (cryst) .thermal_tensor_to_cartesian(unitcell)
   end

   thermal_tensor_to_cartesian(unitcell)
   ! Treat thermal parameters to get cartesian orientation
      UNITCELL :: unitcell
      MAT(3,3) :: rcm
      VEC(3) :: len(3)
      INT :: i
      rcm = unitcell%reciprocal_cell_matrix
      do i = 1,3
         len(i) = sqrt(rcm(1,i)**2+rcm(2,i)**2+rcm(3,i)**2)
      end
      .thermal_tensor.change_basis(len)
      .thermal_tensor.change_basis(transpose(unitcell%cell_matrix))
   end

   thermal_tensor_to_crystal(unitcell)
   ! Treat thermal parameters to get crystal orientation
      UNITCELL :: unitcell
      MAT(3,3) :: rcm
      VEC(3) :: len(3)
      INT :: i
      rcm = unitcell%reciprocal_cell_matrix
      do i = 1,3
         len(i) = sqrt(rcm(1,i)**2+rcm(2,i)**2+rcm(3,i)**2)
      end
      len = ONE/len
      .thermal_tensor.change_basis(rcm)
      .thermal_tensor.change_basis(len)
   end

   put(out)
   ! Put out the atom information to file "out"
      OUTPUT :: out
      out.text("Atom data\n")
      out.show("Label                  =",.label)
      out.show("Atom coordinates       =",.pos)
      out.show("Atomic No.             =",.atomic_number)
      out.show("Chemical symbol        =",trim(.chemical_symbol))
      out.show("No. of shells          =",.n_shell)
      out.show("No. of basis functions =",.n_bf)
      out.show("No. of primitives      =",.n_prim)
      out.flush
      out.text("Basis set\n")
      .basis.put(out)
   end 

  put_thermal_tensor(out)
  ! Output the thermal tensor.  Does not put a header or carriage return.
  ! Only outputs the 6 independent ones, not all 9.
    OUTPUT :: out
    out.put(.thermal_tensor(1,1))
    out.put(.thermal_tensor(2,2)) 
    out.put(.thermal_tensor(3,3)) 
    out.put(.thermal_tensor(1,2)) 
    out.put(.thermal_tensor(1,3)) 
    out.put(.thermal_tensor(2,3)) 
  end

   put_natural_orbitals(out)
   ! Put out the current associated molecular orbitals to file "out"
      OUTPUT :: out
      out.flush
      out.text("Natural orbital occupations:")
      out.put( .occupation, format="column")
      out.flush
      out.text("Natural orbitals:")
      out.put( .natural_orbitals)
   end

!  ***************
!  Inquiry methods
!  ***************

   same_kind_as(atom) result(res)
   ! Return TRUE if self is the same kind of atom as "atom". The position and
   ! label are not compared since the same kind of atom can have a different
   ! position and label.  To check if the basis set is the same, only the
   ! label is used.

      ATOM :: atom
      BIN :: res
      ENSURE( .basis.created,"no basis set to compare")
      res = .atomic_number==atom%atomic_number AND &
            .basis%label==atom%basis%label
   end

   no_of_shells result(res) 
   ! Return the no of shells
      INT :: res
      res = .basis%n_shell
   end

   n_shell result(res) 
   ! Return the no of shells
      INT :: res
      res = .basis%n_shell
   end

   no_of_basis_functions result (res)
   ! Return the no of basis functions
      INT :: res
      res = .basis.no_of_basis_functions
   end

   n_bf result (res)
   ! Return the no of basis functions
      INT :: res
      res = .basis%n_bf
   end

   no_of_primitives result (res)
   ! Return the no of primitives for this atom
      INT :: res
      res = .basis.no_of_primitives
   end

   n_prim result (res)
   ! Return the no of primitives for this atom
      INT :: res
      res = .basis%n_prim
   end

   no_of_occupied_NOs(kind,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose, 
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      STR, optional :: kind
      DBL, optional :: tol
      INT :: res
      STR :: itemkind
      DBL :: eps
      INT :: n,n_bf
      ENSURE( .occupation.created, "no occupation numbers")
      itemkind = .occupation.spinorbital_kind
      if (present(kind)) itemkind=kind
      eps = TOL(7)
      if (present(tol)) eps = tol 
      select case (itemkind)
         case ("restricted")
            n_bf = .occupation%n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation%restricted(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("unrestricted")
            n_bf = .occupation%n_bf
            res = 2*n_bf
            do n = 1,n_bf
               if (.occupation%alpha(n)<eps) then
                  res = n-1
                  exit
               end
            end
            do n = 1,n_bf
               if (.occupation%beta(n)<eps) then
                  res = res + n-1
                  exit
               end
            end
         case ("alpha")
            n_bf= .occupation%n_bf
            res = 2*n_bf 
            do n = 1, n_bf
               if (.occupation%alpha(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("beta")
            n_bf= .occupation%n_bf
            res = 2*n_bf 
            do n = 1, n_bf
               if (.occupation%beta(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case ("general")
            n_bf = 2*.occupation%n_bf
            res = n_bf
            do n = 1,n_bf
               if (.occupation%general(n)<eps) then
                  res = n-1
                  exit
               end
            end
         case default
            DIE("unknown occupation number kind, "// itemkind.trim)
      end
   end
   
   chemical_symbol result(res)
   ! Return the chemical symbol for this atom
      CHR(2) :: res
      if (.atomic_number<1 OR .atomic_number>103) then; res = "??"
      else;                  res = element_symbols(.atomic_number)
      end
   end

   mass result (res)
   ! Return the atomic mass for this atom
      DBL :: res
      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                  res = atomic_masses(.atomic_number)
      end
   end

   mean_neutron_number result (res)
   ! Return the average (abundance weighted) number of neutrons for this atom,
   ! calculated roughly by subtracting the number of protons from the atomic mass.
      DBL :: res
      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                  res = .mass - .atomic_number
      end
   end

   bragg_slater_radius result (res)
   ! Return the Bragg-Slater radius for this atom
      DBL :: res
      if (.atomic_number<1 OR .atomic_number>54) then; res = ZERO
      else;                  res = bragg_slater_radii(.atomic_number)
      end
   end

   neutron_scattering_length result (res)
   ! Return the neutron scattering length for this atom
      DBL :: res
      if (.atomic_number<1 OR .atomic_number>95) then; res = ZERO
      else;            res = neutron_scattering_lengths(.atomic_number)
      end
   end

   period_number result(p)
   ! Return the period (i.e. row) on which the atom lies
      INT :: p
      INT :: noble,n
      p = 1
      if (.atomic_number<1) return
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (.atomic_number <= noble) exit
         p = p + 1
      end 
   end

   column_number result(col)
   ! Return the period column (i.e. row) on which the atom lies
      INT :: col
      INT :: p,noble,n
      p = 1
      if (.atomic_number<1) return
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (.atomic_number <= noble) exit
         p = p + 1
      end 
      noble = noble - 2*n**2
      col = .atomic_number - noble
   end

   period_block result(b)
   ! Return the period bloc character in which the atom lies
      CHR :: b
      INT :: p,col
      p   = .period_number
      col = .column_number
      if (p<4) then
         select case (col)
            case (1:2);   b = "s"
            case (3:8);   b = "p"
         end
      else if (p<6) then
         select case (col)
            case (1:2);   b = "s"
            case (3:12);  b = "d"
            case (13:18); b = "p"
         end
      else if (p<8) then
         select case (col)
            case (1:2);   b = "s"
            case (3:16);  b = "f"
            case (17:26); b = "d"
            case (27:32); b = "p"
         end
      else 
         DIE("cannot assign for period "// p.to_str.trim)
      end
   end

   ground_state_multiplicity result(mult)
   ! Return the ground state multiplicity for this atom according to Hunds rule
   ! (Note this is not neccesarily the real ground state, esp. for Cu)
      INT :: mult
      INT :: p,col
      p   = .period_number
      col = .column_number
      if (p<4) then
         select case (col)
            case (2,8);   mult = 1
            case (1,3,7); mult = 2
            case (4,6);   mult = 3
            case (5);     mult = 4
         end
      else if (p<6) then
         select case (col)
            case (2,12,18);      mult = 1
            case (1,3,11,13,17); mult = 2
            case (4,10,14,16);   mult = 3
            case (5,9,15);       mult = 4
            case (6,8);          mult = 5
            case (7);            mult = 6
         end
      else if (p<8) then
         select case (col)
            case (2,16,26,32);         mult = 1
            case (1,3,15,17,25,27,31); mult = 2
            case (4,14,18,24,28,30);   mult = 3
            case (5,13,19,23,29);      mult = 4
            case (6,12,20,22);         mult = 5
            case (7,11,21);            mult = 6
            case (8,10);               mult = 7
            case (9);                  mult = 8
         end
      else 
         DIE("cannot assign for period "// p.to_str.trim)
      end
   end

  dispersion_correction(wavelength) result(res)
  ! The dispersion correction which best matches the wavelength.
    IN :: self
    DBL :: wavelength
    CDBL :: res
    if (.atomic_number<1 OR .atomic_number>92) then
      res = ZERO
    else
      if (wavelength < 1.1) then
        res = dispersion_correction_Mo( .atomic_number )
      else if (wavelength < 1.9) then
        res = dispersion_correction_Cu( .atomic_number )
      else
        res = dispersion_correction_Cr( .atomic_number )
      end
    end
  end

end 
