!-------------------------------------------------------------------------------
!
! ATOM: can be a quantum mechanical atom, with a basis set
!       or a molecular mechanical atom with a force field potential
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module ATOM

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

!  ***************
!  Data statements
!  ***************

   !  The Periodic Table

   element_symbols :: VEC{STR}(len=2,103)

   data element_symbols/ &
    "H ",                                                                                "He", &
    "Li","Be",                                                  "B ","C ","N ","O ","F ","Ne", &
    "Na","Mg",                                                  "Al","Si","P ","S ","Cl","Ar", &
    "K ","Ca","Sc","Ti","V ","Cr","Mn","Fe","Co","Ni","Cu","Zn","Ga","Ge","As","Se","Br","Kr", &
    "Rb","Sr","Y ","Zr","Nb","Mo","Tc","Ru","Rh","Pd","Ag","Cd","In","Sn","Sb","Te","I ","Xe", &
    "Cs","Ba","La",     "Ce","Pr","Nd","Pm","Sm","Eu","Gd","Tb","Dy","Ho","Er","Tm","Yb","Lu", &
                   "Hf","Ta","W ","Re","Os","Ir","Pt","Au","Hg","Tl","Pb","Bi","Po","At","Rn", &
    "Fr","Ra","Ac",     "Th","Pa","U ","Np","Pu","Am","Cm","Bk","Cf","Es","Fm","Md","No","Lr"/

   element_names :: VEC{STR}(len=12,103)

   data element_names/ &
    "Hydrogen    ","Helium      ", &
    "Lithium     ","Beryllium   ", &
    "Boron       ","Carbon      ","Nitrogen    ","Oxygen      ","Fluorine    ","Neon        ", &
    "Sodium      ","Magnesium   ", &
    "Aluminium   ","Silicon     ","Phosphorous ","Sulfur      ","Chlorine    ","Argon       ", &
    "Potassium   ","Calcium     ", &
    "Scandium    ","Titanium    ","Vanadium    ","Chromium    ","Manganese   ", &
    "Iron        ","Cobalt      ","Nickel      ","Copper      ","Zinc        ", &
    "Gallium     ","Germanium   ","Arsenic     ","Selinium    ","Bromine     ","Krypton     ", &
    "Rubidium    ","Strontium   ", &
    "Yttrium     ","Zirconium   ","Niobium     ","Molybdenum  ","Technitium  ", &
    "Ruthenium   ","Rhodium     ","Palladium   ","Silver      ","Cadmium     ", &
    "Indium      ","Tin         ","Antimony    ","Tellurium   ","Iodine      ","Xenon       ", &
    "Cesium      ","Barium      ", &
    "Lanthanum   ", &
    "Cerium      ","Praseodymium","Neodymium   ","Promethium  ","Samarium    ","Europium    ","Gadolinium  ", &
    "Terbium     ","Dysprosium  ","Holmium     ","Erbium      ","Thulium     ","Ytterbium   ","Lutetium    ", &
                   "Haffnium    ","Tantalum    ","Tangsten    ","Rhenium     ", &
    "Osmium      ","Iridium     ","Platinum    ","Gold        ","Mercury     ", &
    "Thallium    ","Lead        ","Bismuth     ","Polonium    ","Astatine    ","Radon       ", &
    "Francium    ","Radium      ", &
    "Actinium    ", &
    "Thorium     ","Protactinium","Uranium     ","Neptunium   ","Plutonium   ","Americium   ","Curium      ", &
    "Berkellium  ","Californium ","Einsteinium ","Fermium     ","Mendelevium ","Nobelium    ","Lawrencium  "/

   !  Bragg-Slater radii taken from Aaron Lee's code

   bragg_slater_radii :: VEC{REAL}(54)

   data bragg_slater_radii/ &
      0.35d0,0.35d0,                                           &
      1.45d0,1.05d0,0.85d0,0.70d0,0.65d0,0.60d0,0.50d0,0.45d0, &
      1.80d0,1.50d0,1.25d0,1.10d0,1.00d0,1.00d0,1.00d0,1.00d0, &
      2.20d0,1.80d0,                                           &
      1.60d0,1.40d0,1.35d0,1.40d0,1.40d0,                      &
      1.40d0,1.35d0,1.35d0,1.35d0,1.35d0,                      &
                    1.30d0,1.25d0,1.15d0,1.15d0,1.15d0,1.15d0, &
      1.30d0,1.30d0,                                           &
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      &
      1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,                      &
                    1.30d0,1.30d0,1.30d0,1.30d0,1.30d0,1.30d0  /

   !  Abundance weighted atomic masses taken from the WWW to be the same as Turbomol

   atomic_masses :: VEC{REAL}(92)

   data atomic_masses/ &
       1.007970d0,   4.002600d0, &
       6.939000d0,   9.012200d0,  10.811000d0,  12.011150d0,  14.006700d0,  15.999400d0,  18.998400d0,  20.183000d0, &
      22.989800d0,  24.312000d0,  26.981500d0,  28.086000d0,  30.973800d0,  32.064000d0,  35.453000d0,  39.948000d0, &
      39.102000d0,  40.080000d0, &
                    44.956000d0,  47.900000d0,  50.942000d0,  51.996000d0,  54.938000d0, &
                    55.850000d0,  58.933200d0,  58.710000d0,  63.540000d0,  65.370000d0, &
                                  69.720000d0,  72.590000d0,  74.921600d0,  78.960000d0,  79.909000d0,  83.800000d0, &
      85.470000d0,  87.620000d0,  &
                    88.905000d0,  91.220000d0,  92.906000d0,  95.940000d0,  99.000000d0, &
                   101.070000d0, 102.905000d0, 106.400000d0, 107.870000d0, 112.400000d0, &
                                 114.820000d0, 118.690000d0, 121.750000d0, 127.600000d0, 126.904000d0, 131.300000d0, &
     132.905000d0, 137.330000d0, &
                   138.910000d0, 140.115000d0, 140.908000d0, 144.240000d0, 146.920000d0, 150.360000d0, 151.965000d0, &
                   157.250000d0, 158.925000d0, 162.500000d0, 164.930000d0, 167.260000d0, 168.930000d0, 173.040000d0, &
                   174.970000d0, 178.490000d0, 180.950000d0, 183.850000d0, 186.210000d0, &
                   190.200000d0, 192.220000d0, 195.080000d0, 196.070000d0, 200.590000d0, &
                                 204.380000d0, 207.200000d0, 208.980000d0, 208.980000d0, 209.990000d0, 222.020000d0, &
     223.020000d0, 226.030000d0, &
                   227.030000d0, 232.040000d0, 231.040000d0, 238.030000d0/

   !  Abundance-weighted coherent neutron scattering lengths in fm taken from:
   !  International Tables for Crystallography, Vol. C, 1992, pp 384-391

   neutron_scattering_lengths :: VEC{REAL}(95)

   data neutron_scattering_lengths/ &
      -3.7390,  3.2600, &
      -1.9000,  7.7900,  5.3000,  6.6460,  9.3600,  5.8030,  5.6540,  4.5470, &
       3.6300,  5.3750,  3.4490,  4.1490,  5.1300,  2.8470,  9.5770,  1.9090, &
       3.7100,  4.9000, &
               12.2900, -3.4380,  -.3824,  3.6350, -3.7300, &
                9.5400,  2.5000, 10.3000,  7.7180,  5.6890, &
                         7.2879,  8.1929,  6.5800,  7.9700,  6.7950,  7.8000, &
       7.0800,  7.0200, &
                7.7500,  7.1600,  7.0540,  6.9500,  6.8000, &
                7.2100,  5.8800,  5.9100,  5.9220,  5.1000, &
                         4.0650,  6.2257,  5.5700,  5.8000,  5.2800,  4.8500, &
       5.4200,  5.0600, &
                8.2400,  4.8400,  4.4500,  7.6900, 12.6000,  4.2000,  6.7300, &
                9.5000,  7.3800, 16.9000,  8.0800,  8.0300,  7.0700, 12.4100, &
                7.2100,  7.7700,  6.9100,  4.7700,  9.2000, &
               11.0000, 10.6000,  9.6000,  7.6300, 12.6920, &
                         8.7760,  9.4017,  8.5307,  0.0000,  0.0000,  0.0000, &
       0.0000, 10.0000, &
                0.0000, 10.6300,  9.1000,  8.4170, 10.5500, 14.1000,  8.3000/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f".  Cr wavelength = 2.289620A.

   dispersion_correction_Cr :: VEC{CPX}(92)

   data dispersion_correction_Cr/ &
    (  0.0,  0.0), (  0.0,  0.0), (  0.0023,  0.0008), (  0.0083,  0.0033), (0.0190,  0.0094), &
    (  0.0364,  0.0213), (  0.0606,  0.0416), (  0.0928,  0.0731), (  0.1324,  0.1192), (  0.1793,  0.1837), &
    (  0.2295,  0.2699), (  0.2778,  0.3812), (  0.3260,  0.5212), (  0.3647,  0.6921), (  0.3898,  0.8984), &
    (  0.3899,  1.1410), (  0.3508,  1.4222), (  0.2609,  1.7458), (  0.0914,  2.1098), ( -0.1987,  2.5138), &
    ( -0.6935,  2.9646), ( -1.6394,  3.4538), ( -4.4818,  0.4575), ( -2.1308,  0.5468), ( -1.5980,  0.6479), &
    ( -1.2935,  0.7620), ( -1.0738,  0.8897), ( -0.9005,  1.0331), ( -0.7338,  1.1930), ( -0.6166,  1.3712), &
    ( -0.4989,  1.5674), ( -0.3858,  1.7841), ( -0.2871,  2.0194), ( -0.1919,  2.2784), ( -0.1095,  2.5578), &
    ( -0.0316,  2.8669), (  0.0247,  3.1954), (  0.1037,  3.6029), (  0.1263,  3.9964), (  0.1338,  4.4226), &
    (  0.1211,  4.8761), (  0.0801,  5.3484), ( -0.0025,  5.8597), ( -0.1091,  6.4069), ( -0.2630,  6.9820), &
    ( -0.4640,  7.5938), ( -0.7387,  8.2358), ( -1.1086,  8.9174), ( -1.5975,  9.6290), ( -2.2019, 10.3742), &
    ( -3.0637, 11.1026), ( -4.2407, 11.8079), ( -5.6353, 12.6156), ( -8.1899, 11.7407), (-10.3310, 12.8551), &
    (-11.0454, 10.0919), (-12.8190,  3.5648), ( -9.3304,  3.8433), ( -7.9841,  4.1304), ( -7.1451,  4.4278), &
    ( -6.5334,  4.7422), ( -6.0570,  5.0744), ( -5.6630,  5.4178), ( -5.3778,  5.7756), ( -5.0951,  6.1667), &
    ( -4.8149,  6.5527), ( -4.5887,  6.9619), ( -4.4106,  7.3910), ( -4.2698,  7.8385), ( -4.1523,  8.2969), &
    ( -4.0630,  8.7649), ( -4.0564,  9.2832), ( -3.9860,  9.8171), ( -3.9270, 10.3696), ( -3.9052, 10.9346), &
    ( -3.9016, 11.5251), ( -3.9049, 12.1453), ( -3.9435, 12.7910), ( -3.9908, 13.4551), ( -4.1029, 14.1473), &
    ( -4.2233, 14.8643), ( -4.4167, 15.5987), ( -4.6533, 16.3448), ( -4.9604, 17.1410), ( -5.3399, 17.9390), &
    ( -5.7275, 18.7720), ( -6.2180, 19.6009), ( -6.7502, 20.4389), ( -7.4161, 21.3053), ( -8.2118, 22.2248), &
    ( -9.4459, 23.1548), ( -9.9362, 23.1239)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f".  Cu wavelength = 1.540520A.

   dispersion_correction_Cu :: VEC{CPX}(92)

   data dispersion_correction_Cu/ &
    (  0.0,  0.0), (  0.0,  0.0), (  0.0008,  0.0003), (  0.0038,  0.0014), (  0.0090,  0.0039), &
    (  0.0181,  0.0091), (  0.0311,  0.0180), (  0.0492,  0.0322), (  0.0727,  0.0534), (  0.1019,  0.0833), &
    (  0.1353,  0.1239), (  0.1719,  0.1771), (  0.2130,  0.2455), (  0.2541,  0.3302), (  0.2955,  0.4335), &
    (  0.3331,  0.5567), (  0.3639,  0.7018), (  0.3843,  0.8717), (  0.3868,  1.0657), (  0.3641,  1.2855), &
    (  0.3119,  1.5331), (  0.2191,  1.8069), (  0.0687,  2.1097), ( -0.1635,  2.4439), ( -0.5299,  2.8052), &
    ( -1.1336,  3.1974), ( -2.3653,  3.6143), ( -3.0029,  0.5091), ( -1.9646,  0.5888), ( -1.5491,  0.6778), &
    ( -1.2846,  0.7763), ( -1.0885,  0.8855), ( -0.9300,  1.0051), ( -0.7943,  1.1372), ( -0.6763,  1.2805), &
    ( -0.5657,  1.4385), ( -0.4688,  1.6079), ( -0.3528,  1.8200), ( -0.2670,  2.0244), ( -0.1862,  2.2449), &
    ( -0.1121,  2.4826), ( -0.0483,  2.7339), (  0.0057,  3.0049), (  0.0552,  3.2960), (  0.0927,  3.6045), &
    (  0.1215,  3.9337), (  0.1306,  4.2820), (  0.1185,  4.6533), (  0.0822,  5.0449), (  0.0259,  5.4591), &
    ( -0.0562,  5.8946), ( -0.1759,  6.3531), ( -0.3257,  6.8362), ( -0.5179,  7.3500), ( -0.7457,  7.9052), &
    ( -1.0456,  8.4617), ( -1.4094,  9.0376), ( -1.8482,  9.6596), ( -2.4164, 10.2820), ( -3.1807, 10.9079), &
    ( -4.0598, 11.5523), ( -5.3236, 12.2178), ( -8.9294, 11.1857), ( -8.8380, 11.9157), ( -9.1472,  9.1891), &
    ( -9.8046,  9.8477), (-14.9734,  3.7046), ( -9.4367,  3.9380), ( -8.0393,  4.1821), ( -7.2108,  4.4329), &
    ( -6.6179,  4.6937), ( -6.1794,  4.9776), (  5.7959,  5.2718), ( -5.4734,  5.5774), ( -5.2083,  5.8923), &
    ( -4.9801,  6.2216), ( -4.7710,  6.5667), ( -4.5932,  6.9264), ( -4.4197,  7.2980), ( -4.2923,  7.6849), &
    ( -4.1627,  8.0900), ( -4.0753,  8.5060), ( -4.0111,  8.9310), ( -3.9670,  9.3834), ( -3.9588,  9.8433), &
    ( -3.9487, 10.3181), ( -3.9689, 10.8038), ( -4.0088, 11.2969), ( -4.0794, 11.7994), ( -4.1491, 12.3296), &
    ( -4.2473, 12.8681), ( -4.3638, 13.4090)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f".  Mo wavelength = 0.709260A.

   dispersion_correction_Mo :: VEC{CPX}(92)

   data dispersion_correction_Mo/ &
    (  0.0,  0.0), (  0.0,  0.0), ( -0.0003,  0.0001), (  0.0005,  0.0002), (  0.0013,  0.0007),  &
    (  0.0033,  0.0016), (  0.0061,  0.0033), (  0.0106,  0.0060), (  0.0171,  0.0103), (  0.0259,  0.0164),  &
    (  0.0362,  0.0249), (  0.0486,  0.0363), (  0.0645,  0.0514), (  0.0817,  0.0704), (  0.1023,  0.0942),  &
    (  0.1246,  0.1234), (  0.1484,  0.1585), (  0.1743,  0.2003), (  0.2009,  0.2494), (  0.2262,  0.3064),  &
    (  0.2519,  0.3716), (  0.2776,  0.4457), (  0.3005,  0.5294), (  0.3209,  0.6236), (  0.3368,  0.7283),  &
    (  0.3463,  0.8444), (  0.3494,  0.9721), (  0.3393,  1.1124), (  0.3201,  1.2651), (  0.2839,  1.4301),  &
    (  0.2307,  1.6083), (  0.1547,  1.8001), (  0.0499,  2.0058), ( -0.0929,  2.2259), ( -0.2901,  2.4595),  &
    ( -0.5574,  2.7079), ( -0.9393,  2.9676), ( -1.5307,  3.2498), ( -2.7962,  3.5667), ( -2.9673,  0.5597),  &
    ( -2.0727,  0.6215), ( -1.6857,  0.6857), ( -1.4390,  0.7593), ( -1.2594,  0.8363), ( -1.1178,  0.9187),  &
    ( -0.9988,  1.0072), ( -0.8971,  1.1015), ( -0.8075,  1.2024), ( -0.7276,  1.3100), ( -0.6537,  1.4246),  &
    ( -0.5866,  1.5461), ( -0.5308,  1.6751), ( -0.4742,  1.8119), ( -0.4205,  1.9578), ( -0.3680,  2.1192),  &
    ( -0.3244,  2.2819), ( -0.2871,  2.4523), ( -0.2486,  2.6331), ( -0.2180,  2.8214), ( -0.1943,  3.0179),  &
    ( -0.1753,  3.2249), ( -0.1638,  3.4418), ( -0.1578,  3.6682), ( -0.1653,  3.9035), ( -0.1723,  4.1537),  &
    ( -0.1892,  4.4098), ( -0.2175,  4.6783), ( -0.2586,  4.9576), ( -0.3139,  5.2483), ( -0.3850,  5.5486),  &
    ( -0.4720,  5.8584), ( -0.5830,  6.1852), ( -0.7052,  6.5227), ( -0.8490,  6.8722), ( -1.0185,  7.2310),  &
    ( -1.2165,  7.6030), ( -1.4442,  7.9887), ( -1.7033,  8.3905), ( -2.0133,  8.8022), ( -2.3894,  9.2266),  &
    ( -2.8358,  9.6688), ( -3.3944, 10.1111), ( -4.1077, 10.2566), ( -5.1210, 11.0496), ( -7.9122,  9.9777),  &
    ( -8.0659, 10.4580), ( -7.2224,  7.7847), ( -6.7704,  8.1435), ( -6.8494,  8.5178), ( -7.2400,  8.8979),  &
    ( -8.0334,  9.2807), ( -9.6767,  9.6646)/

   ! X-ray dispersion correction factors.
   ! First element is f', second is f".  Ag wavelength = 0.559360A.

   dispersion_correction_Ag :: VEC{CPX}(92)

   data dispersion_correction_Ag/ &
    (  0.0,  0.0), (  0.0,  0.0), ( -0.0004,  0.0000), (  0.0001,  0.0001), (  0.0004,  0.0004),  &
    (  0.0015,  0.0009), (  0.0030,  0.0019), (  0.0056,  0.0036), (  0.0096,  0.0061), (  0.0152,  0.0098),  &
    (  0.0218,  0.0150), (  0.0298,  0.0220), (  0.0406,  0.0313), (  0.0522,  0.0431), (  0.0667,  0.0580),  &
    (  0.0826,  0.0763), (  0.0998,  0.0984), (  0.1191,  0.1249), (  0.1399,  0.1562), (  0.1611,  0.1926),  &
    (  0.1892,  0.2348), (  0.2060,  0.2830), (  0.2276,  0.3376), (  0.2496,  0.3992), (  0.2704,  0.4681),  &
    (  0.2886,  0.5448), (  0.3050,  0.6296), (  0.3147,  0.7232), (  0.3240,  0.8257), (  0.3242,  0.9375),  &
    (  0.3179,  1.0589), (  0.3016,  1.1903), (  0.2758,  1.3314), (  0.2367,  1.4831), (  0.1811,  1.6452),  &
    (  0.1067,  1.8192), (  0.0068,  2.0025), ( -0.1172,  2.2025), ( -0.2879,  2.4099), ( -0.5364,  2.6141),  &
    ( -0.8282,  2.8404), ( -1.2703,  3.0978), ( -2.0087,  3.3490), ( -5.3630,  3.6506), ( -2.5280,  0.5964),  &
    ( -1.9556,  0.6546), ( -1.6473,  0.7167), ( -1.4396,  0.7832), ( -1.2843,  0.8542), ( -1.1587,  0.9299),  &
    ( -1.0547,  1.0104), ( -0.9710,  1.0960), ( -0.8919,  1.1868), ( -0.8200,  1.2838), ( -0.7527,  1.3916),  &
    ( -0.6940,  1.5004), ( -0.6411,  1.6148), ( -0.5890,  1.7358), ( -0.5424,  1.8624), ( -0.5012,  1.9950),  &
    ( -0.4626,  2.1347), ( -0.4287,  2.2815), ( -0.3977,  2.4351), ( -0.3741,  2.5954), ( -0.3496,  2.7654),  &
    ( -0.3302,  2.9404), ( -0.3168,  3.1241), ( -0.3091,  3.3158), ( -0.3084,  3.5155), ( -0.3157,  3.7229),  &
    ( -0.3299,  3.9377), ( -0.3548,  4.1643), ( -0.3831,  4.3992), ( -0.4201,  4.6430), ( -0.4693,  4.8944),  &
    ( -0.5280,  5.1558), ( -0.5977,  5.4269), ( -0.6812,  5.7081), ( -0.7638,  5.9978), ( -0.8801,  6.2989),  &
    ( -1.0117,  6.6090), ( -1.1676,  6.9287), ( -1.3494,  7.2566), ( -1.5613,  7.5986), ( -1.8039,  7.9509),  &
    ( -2.0847,  8.3112), ( -2.4129,  8.6839), ( -2.8081,  9.0614), ( -3.2784,  9.4502), ( -3.8533,  9.8403),  &
    ( -4.6067, 10.2413), ( -5.7225, 10.6428)/

contains

!  ******************
!  Allocation methods
!  ******************

   create ::: leaky
   ! Create an atom
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults
   end

   create_copy(atom) ::: leaky
   ! Create a copy of atom.
     atom :: ATOM
     self :: PTR
     .create
     .copy(atom)
   end

   copy(atom) ::: leaky
   ! Make self a copy of atom.  WARNING: the basis part is not explicitly
   ! copied, so be careful with destroy operations.
     atom :: ATOM
     self = atom
     ! if (atom.basis.created) .basis.create_copy(atom.basis)
     ! if (atom.slaterbasis.created) .coppensbasis.create_copy(atom.coppensbasis)
     ! if (atom.coppensbasis.created) .coppensbasis.create_copy(atom.coppensbasis)
     if (atom.density_matrix.created) .density_matrix.create_copy(atom.density_matrix)
     if (atom.natural_orbitals.created) .natural_orbitals.create_copy(atom.natural_orbitals)
     if (atom.occupation_numbers.created) .occupation_numbers.create_copy(atom.occupation_numbers)
   end

   destroy ::: leaky
   ! Destroy an atom
      self :: PTR
      if (.destroyed) return
      .destroy_ptr_part
      deallocate(self)
      DELETE_MEMORY(SELF_TYPE_SIZE)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the atom
      nullify(.basis)
      nullify(.slaterbasis)
      nullify(.coppensbasis)
      nullify(.density_matrix)
      nullify(.natural_orbitals)
      nullify(.occupation_numbers)
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of an atom
      .basis.destroy
      .slaterbasis.destroy
      .coppensbasis.destroy
      .density_matrix.destroy
      .natural_orbitals.destroy
      .occupation_numbers.destroy
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   set_defaults
   ! Set a default atom
      .label = "?"
      .atomic_number = 0
      .oxidation_state = 0
      .pos = [ ZERO,ZERO,ZERO ]
      .U_iso = ZERO
      .thermal_tensor = ZERO
      .basis_label = " "
      .axis_system = "cartesian"
      .thermal_axis_system = "cartesian"
      .energy = ZERO
      .group  = 0
      ! MM/protien defaults
      .sequence_number = 0
      .residue_atom_name = "?"
      .residue_name = "UNK"
      .mm_forcefield_name = "?"
      .mm_atom_type = "?"
      .mm_charge = ZERO
      .restraining_position = [ ZERO,ZERO,ZERO ]
      .restraining_force_constant = ZERO
      .site_occupancy = ONE
   end

   set_label_and_atomic_number(label)
   ! Set an ATOM "label" and extract the atomic number from it.
      label :: STR
      lensym,z :: INT
      symbol :: STR
      error :: BIN
      .label = label
      if (label.is_int) then    ! The label must be the atomic number
         z = label.to_int
         .atomic_number = z
      else                      ! First part of the label is the element symbol
         lensym = label.scan("0123456789 ")-1
         error = lensym>2 OR lensym==0
         ENSURE(NOT error,"unacceptable atom symbol, "// trim(label))
         symbol = label(1:lensym)
         symbol(1:1).to_upper_case
         symbol(2:2).to_lower_case
         if (symbol=="D" OR symbol=="T") then
           .atomic_number = 1
         else if (any(element_symbols==symbol(1:2))) then
            do z = 1,size(element_symbols)
               if (element_symbols(z)==symbol(1:2)) exit
            end
           .atomic_number = z
         else
            DIE("unknown element symbol: "//trim(symbol))
         end
      end
   end

   set_coppensbasis_label(label)
   ! Set the coppensbasis "label".
      label :: STR
      if (.coppensbasis.destroyed) .coppensbasis.create
      .coppensbasis.set_label(label)
   end

!  ************
!  I/O Routines
!  ************

   read_keywords ::: leaky
   ! Read data from "stdin" using keyword style input.
   ENSURE(stdin.next_item=="{","expecting an open bracket symbol, {")
     keyword :: STR
     stdin.read(keyword)         ! Read opening brace
     do                          ! Loop over keywords
       stdin.read(keyword)
       if (keyword=="}")   exit  ! Exit on closing brace
       if (stdin.reverted) exit  ! Exit if internal file reverted
       .process_keyword(keyword)
     end
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("}                            ")  ! exit case
       case ("axis_system=                 "); .read_axis_system
       case ("basis=                       "); .read_basis
       case ("basis_label=                 "); .read_basis_label
       case ("coppensbasis=                "); .read_coppensbasis
       case ("group=                       "); .read_group
       case ("junk=                        "); .read_junk
       case ("label=                       "); .read_label
       case ("make_slater_interpolator     "); .make_slater_interpolator
       case ("mm_atom_type=                "); .read_mm_atom_type
       case ("mm_charge=                   "); .read_mm_charge
       case ("mm_forcefield_name=          "); .read_mm_forcefield_name
       case ("oxidation_state=             "); .read_oxidation_state
       case ("pdb_input_line=              "); .read_pdb_input_line
       case ("pos=                         "); .read_pos
       case ("position=                    "); .read_pos
       case ("put                          "); .put
       case ("put_interpolator             "); .put_interpolator
       case ("read_library_data            "); .read_library_data
       case ("residue_atom_name=           "); .read_residue_atom_name
       case ("residue_name=                "); .read_residue_name
       case ("restraining_position=        "); .read_restraining_position
       case ("restraining_force_constant=  "); .read_restraining_force
       case ("sequence_number=             "); .read_sequence_number
       case ("site_occupancy=              "); .read_site_occupancy
       case ("slaterbasis=                 "); .read_slaterbasis
       case ("thermal_axis_system=         "); .read_thermal_axis_system
       case ("thermal_tensor=              "); .read_thermal_tensor
       case ("u_iso=                       "); .read_U_iso
       case ("u_tensor=                    "); .read_thermal_tensor
       case ("units=                       "); .read_units
       ! These are only for making custom tables for the list type
       case ("---For custom tables---      ");
       case ("flush                        "); stdout.flush
       case ("put_atomic_number            "); stdout.put(.atomic_number)
       case ("put_bragg_slater_radius      "); stdout.put(.bragg_slater_radius)
       case ("put_chemical_symbol          "); stdout.put(.chemical_symbol,int_width=TRUE)
       case ("put_column_number            "); stdout.put(.column_number)
       case ("put_ground_state_multiplicity"); stdout.put(.ground_state_multiplicity)
       case ("put_label                    "); stdout.put(.label,int_width=TRUE)
       case ("put_mass                     "); stdout.put(.mass)
       case ("put_mean_neutron_number      "); stdout.put(.mean_neutron_number)
       case ("put_neutron_scattering_length"); stdout.put(.neutron_scattering_length)
       case ("put_period_block             "); stdout.put(.period_block)
       case ("put_period_number            "); stdout.put(.period_number)
       case ("put_pos                      "); stdout.put(.pos(1))
                                               stdout.put(.pos(2))
                                               stdout.put(.pos(3))
       case ("put_position                 "); stdout.put(.pos(1))
                                               stdout.put(.pos(2))
                                               stdout.put(.pos(3))
       case ("put_thermal_tensor           "); .put_thermal_tensor
       case  default;                        UNKNOWN(word)
     end
   end

   read_units 
   ! Read a string which describes the units to be used
      stdin.set_default_units(stdin.next_str)
   end

   read_junk
   ! Read in a junk string, useful for ignoring a field
      stdin.skip_next_item
   end

   read_group
   ! Read the index which describes the group the atom belongs to.
      stdin.read(.group)
   end

   read_pos
   ! Read in the position
      stdin.read(.pos)
   end

   read_label
   ! Read an ATOM label.
      .set_label_and_atomic_number(stdin.next_str)  ! Input atom label
   end

   read_oxidation_state
   ! Read the oxidation state
      stdin.read(.oxidation_state)
   end

   read_residue_atom_name
   ! Read the atom name that this atom belongs to a residue (case sensitive).
      stdin.read(.residue_atom_name)
   end

   read_residue_name
   ! Read the residue name that this atom belongs to.
      stdin.read(.residue_name)
   end

   read_pdb_input_line
   ! Read a line in the PDB input style
      word :: STR
      stdin.read(word)
      word.to_lower_case
      ENSURE(word=="atom","PDB line does not begin with 'atom'")
      .read_residue_atom_name
      .read_residue_name
      .read_sequence_number
      .read_pos
      .read_junk
      .read_junk
      .read_label
   end

   read_sequence_number
   ! Read the sequence number of the residue in the molecule
      stdin.read(.sequence_number)
   end

   read_mm_atom_type
   ! Read the atom type potential, used to define the force field potential
      stdin.read(.mm_atom_type)
   end

   read_mm_charge
   ! Read the MM charge on this atom
      stdin.read(.mm_charge)
   end

   read_mm_forcefield_name
   ! Read the MM forcefield name for this atom
      stdin.read(.mm_forcefield_name)
   end

   read_restraining_position
   ! Read the restraining position
      stdin.read(.restraining_position)
   end

   read_restraining_force
   ! Read the restrain force constant for this atom
      stdin.read(.restraining_force_constant)
   end

   read_site_occupancy
   ! Read the site occupancy, used mainly for crystallographic applications.
      stdin.read(.site_occupancy)
   end

   read_axis_system
   ! Read a string which describes the axis system. Currently allowed is
   ! "cartesian" or "crystal". NOTE: .thermal_axis_system is changed too.
      stdin.read(.axis_system)
      .thermal_axis_system = .axis_system
      select case (.axis_system)
        case ("cartesian")
        case ("crystal  ")
        case default
          UNKNOWN(.axis_system)
      end
   end

   set_axis_system(word)
   ! Read a string which describes the axis system. Currently allowed is
   ! "cartesian" or "crystal". NOTE: .thermal_axis_system is changed too.
     word :: STR, IN
     .axis_system = word
     .thermal_axis_system = .axis_system
     select case (.axis_system)
       case ("cartesian")
       case ("crystal  ")
       case default
         UNKNOWN(.axis_system)
     end
   end

   read_thermal_axis_system
   ! Read a string which describes the thermal tensor axis system.
   ! Currently allowed, is "cartesian" or "crystal".
      stdin.read(.thermal_axis_system)
      select case (.thermal_axis_system)
        case ("cartesian")
        case ("crystal  ")
        case default
          UNKNOWN(.thermal_axis_system)
      end
   end

   set_thermal_axis_system(word)
   ! Read a string which describes the thermal tensor axis system.
   ! Currently allowed, is "cartesian" or "crystal".
     word :: STR, IN
     .thermal_axis_system = word
     select case (.thermal_axis_system)
       case ("cartesian")
       case ("crystal  ")
       case default
         UNKNOWN(.thermal_axis_system)
     end
   end

   read_basis ::: leaky
   ! Read the basis set from "stdin"
      .basis.create
      .basis.read_keywords
   end

   read_basis_label ::: leaky
   ! Read the basis set label from "stdin" which will be used to match a basis
   ! set to ...
      stdin.read(.basis_label)
   end

   read_slaterbasis ::: leaky
   ! Read the slaterbasis set from "stdin"
      .slaterbasis.create
      .slaterbasis.read_keywords
   end

   read_coppensbasis ::: leaky
   ! Read the coppensbasis set from "stdin"
      .coppensbasis.create
      .coppensbasis.read_keywords
   end

   read_U_iso
   ! Read the isotropic thermal parameters from "stdin".  NOTE: units are
   ! Bohr^2, not Angstrom^2.
      stdin.read(.U_iso)
   end

   read_thermal_tensor
   ! Read thermal parameters from "stdin". These are assumed to be in the
   ! cartesian axis system, and in bohr^2.  The expansion of the thermal
   ! smearing temperature factor term is:
   !              TF = exp ( -2\pi^2 U_{ij} h_i h_j a^*_i a^*_j )
   ! where (h) are the miller indices and (a^*) are the reciprocal lattice
   ! constants in angstrom^{-2}.
      tensor :: VEC{REAL}(6)
      stdin.read(tensor)
      .thermal_tensor(1,1) = tensor(1) ! Units must be bohr^2
      .thermal_tensor(2,2) = tensor(2) ! unless over-ridden by read_units=
      .thermal_tensor(3,3) = tensor(3)
      .thermal_tensor(1,2) = tensor(4)
      .thermal_tensor(1,3) = tensor(5)
      .thermal_tensor(2,3) = tensor(6)
      .thermal_tensor(2,1) = .thermal_tensor(1,2)
      .thermal_tensor(3,1) = .thermal_tensor(1,3)
      .thermal_tensor(3,2) = .thermal_tensor(2,3)
   end

!  ********************
!  Key related routines
!  ********************

   read_keys
   ! Read the "keys".
     .clear_keys
     stdin.read_ptr(keys)
     tonto.ignore_memory_leak(memory_blocks_gained=1)
   end

   process_keys ::: leaky
   ! Process each of the words in the "keys" list.
   ENSURE(keys.created,"no keys")
      k,l,n_key :: INT
      keyword :: STR
      internal :: VEC{STR}* 
      n_key = size(keys)
      k = 0
      do
         k = k + 1
         keyword = keys(k)
         if (keyword=="}") exit
         if (keyword=="{") then
            l = keys(k:).index_of_matching_bracket("{")
            ENSURE(l>0,"no matching closing brace, }")
            internal => keys(k:k+l-1)
            stdin.redirect(internal)
            .read_keywords
            stdin.revert
            k = k+l-1
         else if (keyword.includes(" ")) then
            internal => keyword.split
            stdin.redirect(internal)
            .read_keywords
            internal.destroy
            stdin.revert
         else
            .process_keyword(keyword)
         end
         if (k==n_key) exit
      end
   end

   keys_created result (res)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
      res = keys.created
   end

   set_keys(the_keys)
   ! This is for setting the "keys" externally.
     the_keys :: VEC{STR}
     .clear_keys
     keys.create_copy(the_keys)
     tonto.ignore_memory_leak(memory_blocks_gained=1)
   end

   clear_keys
   ! This is for destroying the "keys" externally.
     if (keys.destroyed) return
     keys.destroy
     tonto.ignore_memory_leak(memory_blocks_gained=-1)
   end

   put_table_footer
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
     stdout.dash(width=.table_width)
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")
     word :: STR
     width,k :: INT
     width = .table_width
     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case ("put_label   "); stdout.put("label",int_width=TRUE)
           case ("put_n_shells"); stdout.put("n_shells",int_width=TRUE)
           case ("put_n_bf    "); stdout.put("n_bf",int_width=TRUE)
           case ("put_n_prim  "); stdout.put("n_prim",int_width=TRUE)
           case ("flush       "); stdout.flush; exit
         end
         if (k==size(keys)) then
           stdout.flush ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
     res :: INT
   ENSURE(keys.created,"no keys")
     word :: STR
     int_dash,real_dash,k :: INT
     int_dash = 0
     real_dash = 0
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}           "); ! exit surrounding loop
         case ("put_label   "); int_dash = int_dash + 1
         case ("put_n_shells"); int_dash = int_dash + 1
         case ("put_n_bf    "); int_dash = int_dash + 1
         case ("put_n_prim  "); int_dash = int_dash + 1
         case ("flush       "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  *******************
!  Axis change methods
!  *******************

   resolve_axis_system(crystal)
   ! Change the axis system for the position and thermal tensors to
   ! "cartesian". "crystal" holds the axis system information.
     crystal :: CRYSTAL, IN
     if (.axis_system=="crystal")         .position_from(crystal)
     if (.thermal_axis_system=="crystal") .thermal_tensor_from(crystal)
   end

   change_axis_system_to(axiskind,crystal)
   ! Change the axis system for the position and thermal tensors
   ! to "axiskind", either crystal or cartesian.
     axiskind :: STR, IN
     crystal :: CRYSTAL, IN
     select case (axiskind)
       case ("cartesian"); .position_from(crystal); .thermal_tensor_from(crystal)
       case ("crystal  "); .position_to(crystal);   .thermal_tensor_to(crystal)
       case default
         UNKNOWN(axiskind)
     end
   end

   change_thermal_axis_system_to(axiskind,crystal)
   ! Change the axis system for the thermal tensors to "axiskind",
   ! either crystal or cartesian.
     axiskind :: STR, IN
     crystal :: CRYSTAL, IN
     select case (axiskind)
       case ("cartesian"); .thermal_tensor_from(crystal)
       case ("crystal  "); .thermal_tensor_to(crystal)
       case default
         UNKNOWN(axiskind)
     end
   end

   thermal_tensor_from(crystal)
   ! Change thermal parameters in the crystal axis system to the
   ! cartesian axis system
     crystal :: CRYSTAL, IN
     select case (.thermal_axis_system)
       case ("crystal  ")
         if (.U_iso>ZERO) then ! convert U_iso first
            .thermal_tensor(1,1) = .U_iso
            .thermal_tensor(2,2) = .U_iso
            .thermal_tensor(3,3) = .U_iso
            .thermal_tensor(1,2) = .U_iso * cos(crystal.unitcell.gamma_star)
            .thermal_tensor(1,3) = .U_iso * cos(crystal.unitcell.beta_star)
            .thermal_tensor(2,3) = .U_iso * cos(crystal.unitcell.alpha_star)
         end
         .thermal_tensor.change_basis_using(crystal.unitcell.direct_U_matrix)
         .thermal_axis_system = "cartesian"
       case ("cartesian")
         ! do nothing
       case default
         UNKNOWN(.thermal_axis_system)
     end
   end

   thermal_tensor_to(crystal)
   ! Change thermal parameters in the cartesian axis system to the
   ! crystal axis system
     crystal :: CRYSTAL, IN
     select case (.thermal_axis_system)
       case ("crystal  ")
         ! do nothing
       case ("cartesian")
         .thermal_tensor.change_basis_using(crystal.unitcell.reciprocal_U_matrix)
         .thermal_axis_system = "crystal"
       case default
         UNKNOWN(.thermal_axis_system)
     end
   end

   position_from(crystal)
   ! Change atom positions in the crystal axis system to the
   ! cartesian axis system
     crystal :: CRYSTAL, IN
     select case (.axis_system)
       case ("crystal  ")
         .pos = matmul(crystal.unitcell.direct_matrix,.pos)
         .axis_system = "cartesian"
       case ("cartesian")
         ! do nothing
       case default
         UNKNOWN(.axis_system)
     end
   end

   position_to(crystal)
   ! Change atom positions in the cartesian axis system to the
   ! the crystal axis system
     crystal :: CRYSTAL, IN
     select case (.axis_system)
       case ("crystal  ")
         ! do nothing
       case ("cartesian")
         .pos = matmul(crystal.unitcell.inverse_matrix,.pos)
         .axis_system = "crystal"
       case default
         UNKNOWN(.axis_system)
     end
   end

   change_coordinate_axes(axes)
   ! Change the coordiantes and thermal tensors to be expressed in terms of a
   ! new set of orthogonal "axes". We must be n the cartesian axis system.
   ENSURE(.axis_system=="cartesian","positions must be in cartesian axis system")
   ENSURE(.thermal_axis_system=="cartesian","U's must be in cartesian axis system")
     axes :: MAT{REAL}(3,3), IN
     .pos = matmul(axes,.pos)
     .thermal_tensor.change_basis_using(axes) ! WARNING: this may not be correct
   end

!  ************************
!  Basis resolution methods
!  ************************

!   resolve_basis(basis,clobber,found) ::: leaky
!   ! Resolve the basis set by matching the basis set label with one of the
!   ! labels from the basis set vector "basis". If "clobber" is present and TRUE
!   ! (the default situation), then the matched basis is pointer assigned to the
!   ! matching element in "basis" irrespective of whether it is already
!   ! associated; otherwise if the matching basis set is already assigned, it is
!   ! not pointer assigned. If present, "found" is set TRUE if the basis set has
!   ! been resolved (or was already resolved if clobber was not set), or false
!   ! otherwise. If "found" is not present, and a match has not been found, an
!   ! error is generated
!      basis :: VEC{BASIS}*
!      clobber,found :: BIN, optional
!      b :: INT
!      check :: VEC{BIN}*
!      force,fnd :: BIN
!   ENSURE(basis.created, "no basis set")
!      force = TRUE
!      if (present(clobber)) force = clobber
!      if (.basis.destroyed) then
!         if (present(found)) found = FALSE
!         return
!      end
!      if (NOT force) then
!         if (present(found)) found = TRUE
!         return
!      end
!      check.create(basis.dim)
!      check = basis.label==.basis.label
!      b = check.index_of_first_true_element
!      check.destroy
!      fnd = b>0
!      if (fnd) then
!      !  .basis.destroy     ! don't destroy
!         .basis => basis(b) ! NOTE : this is a pointer assign NOT COPY
!      end
!      if (present(found)) then; found = fnd
!      else; ENSURE(fnd,"unknown basis, "// trim(.basis.label))
!      end
!   end
!
!   resolve_library_basis(basis,clobber,found) ::: leaky
!   ! Resolve the basis set by first looking in the "basis" list, and then (if
!   ! needed) looking in a basis set library file. The appropriate basis set
!   ! library files are obtained from the basis set qualifier -- the part after
!   ! the colon in the atom basis set label. For example, if the atom basis set
!   ! label is "H:DZP", then the qualifier is "DZP" and the routine looks in
!   ! library file basis_sets/"DZP" for a matching basis set. If found, the basis
!   ! set is appended to "basis". If "clobber" is present and TRUE (the default
!   ! situation), then the matched basis is pointer assigned to the matching
!   ! element in "basis" irrespective of whether it is already associated;
!   ! otherwise if the matching basis set is already associated, it is not
!   ! pointer assigned.  If present, "found" is set TRUE if the basis set has
!   ! been resolved, or false otherwise. If "found" is not present, and a match
!   ! has not been found, an error is generated
!   ! NOTE: this should probably not be used ... .basis should be filled first
!   ! with the right bases and then they should be resolved in one hit.
!      basis :: VEC{BASIS}*
!      clobber,found :: BIN, optional
!      i :: INT
!      basis_label,basis_kind,library :: STR
!      force,fnd :: BIN
!   ENSURE(.basis.created,"no basis set")
!      force = TRUE
!      if (present(clobber)) force = clobber
!      if (.basis.created AND NOT force) then
!         if (present(found)) found = TRUE
!         return
!      end
!      if (basis.created) .resolve_basis(basis,clobber=TRUE,found=fnd)
!      if (fnd) return
!      basis_label = .basis.label                 ! Look for this <<<<<<<
!      if (basis_label.includes(":")) then        ! look in library directory
!         i = basis_label.index_of_substring(":")
!         if (i>0) then
!            basis_kind = basis_label(i+1:)
!            if (basis_kind/=" ") then
!               library = basis.library_directory(basis_kind)
!               basis.read_library_data(library,[basis_label])
!               ! .basis.destroy  ! don't destroy ????
!               .basis => basis(basis.dim)  ! NOTE : this is a pointer assign NOT COPY
!               fnd = TRUE
!            end
!         end
!      end
!      if (present(found)) then; found = fnd
!      else; ENSURE(fnd,"unknown basis, "// trim(.basis.label))
!      end
!   end
!
!   resolve_basis_suffix(basis,suffix,clobber,found) ::: leaky
!   ! Resolve the basis set by first making a standard basis label, by joining
!   ! the atom chemical symbol with the :"suffix" string, and then trying to find
!   ! a match with one of the "basis" set vector labels.  If "clobber" is present
!   ! and FALSE, then only an unassociated .basis is resolved.  If "found" is
!   ! present and it is set TRUE if there was a match, otherwise FALSE; and if it
!   ! is not present an error is generated if no match is found.
!      basis :: VEC{BASIS}*
!      suffix :: STR
!      clobber,found :: BIN, optional
!      label :: STR
!      b :: INT
!      force,fnd :: BIN
!   ENSURE(basis.created,"no basis")
!      force = TRUE
!      if (present(clobber)) force = clobber
!      if (.basis.created AND NOT force) then
!         if (present(found)) found = TRUE
!         return
!      end
!      label = .library_basis_label(suffix)
!      fnd = FALSE
!      do b = 1,basis.dim
!         if (basis(b).label.same_as(label,ignore_case=TRUE)) then
!            fnd = TRUE
!            exit
!         end
!      end
!      if (fnd) then
!      !  .basis.destroy     ! don't destroy
!         .basis => basis(b) ! NOTE : this is a pointer assign NOT COPY
!      end
!      if (present(found)) then; found = fnd
!      else; ENSURE(fnd,"unknown basis, "// trim(.basis.label))
!      end
!   end
!
!   resolve_basis(basis,clobber,found) ::: leaky
!   ! Resolve the basis set by matching the basis set label with one of the
!   ! labels from the basis set vector "basis". If "clobber" is present and TRUE
!   ! (the default situation), then the matched basis is pointer assigned to the
!   ! matching element in "basis" irrespective of whether it is already
!   ! associated; otherwise if the matching basis set is already assigned, it is
!   ! not pointer assigned. If present, "found" is set TRUE if the basis set has
!   ! been resolved (or was already resolved if clobber was not set), or false
!   ! otherwise. If "found" is not present, and a match has not been found, an
!   ! error is generated
!      basis :: VEC{SLATERBASIS}*
!      clobber,found :: BIN, optional
!      b :: INT
!      check :: VEC{BIN}*
!      force,fnd :: BIN
!   ENSURE(basis.created, "no Coppens basis set")
!      force = TRUE
!      if (present(clobber)) force = clobber
!      if (.slaterbasis.destroyed) then
!         if (present(found)) found = FALSE
!         return
!      end
!      if (.slaterbasis.created AND NOT force) then
!         if (present(found)) found = TRUE
!         return
!      end
!      check.create(basis.dim)
!      check = basis.label==.slaterbasis.label
!      b = check.index_of_first_true_element
!      check.destroy
!      fnd = b>0
!      if (fnd) then
!      !  .slaterbasis.destroy     ! don't destroy
!         .slaterbasis => basis(b) ! NOTE : this is a pointer assign NOT COPY
!      end
!      if (present(found)) then; found = fnd
!      else; ENSURE(fnd,"unknown basis, "// trim(.slaterbasis.label))
!      end
!   end
!
!   resolve_library_basis(basis,clobber,found) ::: leaky
!   ! Resolve the basis set by first looking in the "basis" list, and then (if
!   ! needed) looking in a basis set library file. The appropriate basis set
!   ! library files are obtained from the basis set qualifier -- the part after
!   ! the colon in the atom basis set label. For example, if the atom basis set
!   ! label is "H:DZP", then the qualifier is "DZP" and the routine looks in
!   ! library file basis_sets/"DZP" for a matching basis set. If found, the basis
!   ! set is appended to "basis". If "clobber" is present and TRUE (the default
!   ! situation), then the matched basis is pointer assigned to the matching
!   ! element in "basis" irrespective of whether it is already associated;
!   ! otherwise if the matching basis set is already associated, it is not
!   ! pointer assigned.  If present, "found" is set TRUE if the basis set has
!   ! been resolved, or false otherwise. If "found" is not present, and a match
!   ! has not been found, an error is generated
!      basis :: VEC{SLATERBASIS}*
!      clobber,found :: BIN, optional
!      i :: INT
!      basis_label,basis_kind,library :: STR
!      force,fnd :: BIN
!   ENSURE(.slaterbasis.created,"no Slater basis set")
!      force = TRUE
!      if (present(clobber)) force = clobber
!      if (.slaterbasis.created AND NOT force) then
!         if (present(found)) found = TRUE
!         return
!      end
!      if (basis.created) .resolve_basis(basis,clobber=TRUE,found=fnd)
!      if (fnd) return
!      basis_label = .slaterbasis.label                 ! Look for this <<<<<<<
!      if (basis_label.includes(":")) then        ! look in library directory
!         i = basis_label.index_of_substring(":")
!         if (i>0) then
!            basis_kind = basis_label(i+1:)
!            if (basis_kind/=" ") then
!               library = basis.library_directory(basis_kind)
!               basis.read_library_data(library,[basis_label])
!               ! .slaterbasis.destroy  ! don't destroy ????
!               .slaterbasis => basis(basis.dim)  ! NOTE : this is a pointer assign NOT COPY
!               fnd = TRUE
!            end
!         end
!      end
!      if (present(found)) then; found = fnd
!      else; ENSURE(fnd,"unknown basis, "// trim(.slaterbasis.label))
!      end
!   end
!
!   resolve_basis_suffix(basis,suffix,clobber,found) ::: leaky
!   ! Resolve the basis set by first making a standard basis label, by joining
!   ! the atom chemical symbol with the :"suffix" string, and then trying to find
!   ! a match with one of the "basis" set vector labels.  If "clobber" is present
!   ! and FALSE, then only an unassociated .slaterbasis is resolved.  If "found" is
!   ! present and it is set TRUE if there was a match, otherwise FALSE; and if it
!   ! is not present an error is generated if no match is found.
!      basis :: VEC{SLATERBASIS}*
!      suffix :: STR
!      clobber,found :: BIN, optional
!      label :: STR
!      b :: INT
!      force,fnd :: BIN
!   ENSURE(basis.created,"no Coppens basis")
!      force = TRUE
!      if (present(clobber)) force = clobber
!      if (.slaterbasis.created AND NOT force) then
!         if (present(found)) found = TRUE
!         return
!      end
!      label = .library_basis_label(suffix)
!      fnd = FALSE
!      do b = 1,basis.dim
!         if (basis(b).label.same_as(label,ignore_case=TRUE)) then
!            fnd = TRUE
!            exit
!         end
!      end
!      if (fnd) then
!      !  .slaterbasis.destroy     ! don't destroy
!         .slaterbasis => basis(b) ! NOTE : this is a pointer assign NOT COPY
!      end
!      if (present(found)) then; found = fnd
!      else; ENSURE(fnd,"unknown basis, "// trim(.slaterbasis.label))
!      end
!   end

!   resolve_basis(basis,clobber,found) 
!   ! Resolve the basis set by matching the basis set label with one of the
!   ! labels from the basis set vector "basis". If "clobber" is present and TRUE
!   ! (the default situation), then the matched basis is pointer assigned to the
!   ! matching element in "basis" irrespective of whether it is already
!   ! associated; otherwise if the matching basis set is already assigned, it is
!   ! not pointer assigned. If present, "found" is set TRUE if the basis set has
!   ! been resolved (or was already resolved if clobber was not set), or false
!   ! otherwise. If "found" is not present, and a match has not been found, an
!   ! error is generated
!      basis :: VEC{COPPENSBASIS}*
!      clobber,found :: BIN, optional
!      b :: INT
!      check :: VEC{BIN}*
!      force,fnd :: BIN
!   ENSURE(basis.created, "no Coppens basis set")
!      force = TRUE
!      if (present(clobber)) force = clobber
!      stdout.text("1==")
!      if (.coppensbasis.destroyed) then
!         if (present(found)) found = FALSE
!         return
!      end
!      stdout.text("2==")
!      if (.coppensbasis.created AND NOT force) then
!      if (.coppensbasis.label/=" ") then
!         if (present(found)) found = TRUE
!         return
!      end
!      end
!      stdout.text("2==")
!      check.create(basis.dim)
!      check = basis.label==.coppensbasis.label
!      b = check.index_of_first_true_element
!      check.destroy
!      fnd = b>0
!      stdout.show("coppensbasis label =",.coppensbasis.label)
!      stdout.show("found              =",fnd)
!      if (fnd) then
!      !  .coppensbasis.destroy     ! don't destroy
!         .coppensbasis => basis(b) ! NOTE : this is a pointer assign NOT COPY
!      end
!      if (present(found)) then; found = fnd
!      else; ENSURE(fnd,"unknown basis, "// trim(.coppensbasis.label))
!      end
!   end

!   set_basis(basis,clobber) 
!   ! Set the .coppensbasis to be "basis". If "clobber" is present and TRUE (the
!   ! default situation), then .coppensbasis is pointer assigned to the matching
!   ! element in "basis" irrespective of whether it is already associated;
!   ! otherwise it is not pointer assigned. 
!      basis :: COPPENSBASIS
!      clobber :: BIN, optional
!      force :: BIN
!      force = TRUE
!      if (present(clobber)) force = clobber
!      if (.coppensbasis.created AND NOT force) then
!      if (.coppensbasis.label/=" ") then
!         return
!      end
!      end
!      .coppensbasis => basis ! NOTE : this is a pointer assign NOT COPY
!   end

!   resolve_library_basis(basis,clobber,found) ::: leaky
!   ! Resolve the basis set by first looking in the "basis" list, and then (if
!   ! needed) looking in a basis set library file. The appropriate basis set
!   ! library files are obtained from the basis set qualifier -- the part after
!   ! the colon in the atom basis set label. For example, if the atom basis set
!   ! label is "H:DZP", then the qualifier is "DZP" and the routine looks in
!   ! library file basis_sets/"DZP" for a matching basis set. If found, the basis
!   ! set is appended to "basis". If "clobber" is present and TRUE (the default
!   ! situation), then the matched basis is pointer assigned to the matching
!   ! element in "basis" irrespective of whether it is already associated;
!   ! otherwise if the matching basis set is already associated, it is not
!   ! pointer assigned.  If present, "found" is set TRUE if the basis set has
!   ! been resolved, or false otherwise. If "found" is not present, and a match
!   ! has not been found, an error is generated
!      basis :: VEC{COPPENSBASIS}*
!      clobber,found :: BIN, optional
!      i :: INT
!      basis_label,basis_kind,library :: STR
!      force,fnd :: BIN
!   ENSURE(.coppensbasis.created,"no Coppens basis set")
!      force = TRUE
!      if (present(clobber)) force = clobber
!      if (.coppensbasis.created AND NOT force) then
!         if (present(found)) found = TRUE
!         return
!      end
!      if (basis.created) .resolve_basis(basis,clobber=TRUE,found=fnd)
!      if (fnd) return
!      basis_label = .coppensbasis.label                 ! Look for this <<<<<<<
!      if (basis_label.includes(":")) then        ! look in library directory
!         i = basis_label.index_of_substring(":")
!         if (i>0) then
!            basis_kind = basis_label(i+1:)
!            if (basis_kind/=" ") then
!               library = basis.library_directory(basis_kind)
!               basis.read_library_data(library,[basis_label])
!               ! .coppensbasis.destroy  ! don't destroy ?
!               .coppensbasis => basis(basis.dim)  ! NOTE : this is a pointer assign NOT COPY
!               fnd = TRUE
!            end
!         end
!      end
!      if (present(found)) then; found = fnd
!      else; ENSURE(fnd,"unknown basis, "// trim(.coppensbasis.label))
!      end
!   end

   resolve_basis(basis,suffix,found)
   ! Resolve the .basis by firstly trying to matching the ".basis_label"
   ! with one of the labels from "basis". If that fails, and "suffix" is present
   ! and not blank, then a library basis label is generated from the "suffix"
   ! and we try and match again to one of the labels in "basis". If present,
   ! "found" is set TRUE if the basis set has been resolved, or FALSE otherwise.
      basis :: VEC{BASIS}*
      suffix :: STR, optional
      found :: BIN, optional
   ENSURE(basis.created,"no basis")
      fnd :: BIN
      fnd = FALSE
      if (.basis_label/=" ") then
         .basis.resolve_by_label(.basis_label,basis,clobber=TRUE,found=fnd)
      end
      if (NOT fnd AND present(suffix)) then
      if (suffix/=" ") then
         .basis.resolve_by_label(.library_basis_label(suffix),basis,clobber=TRUE,found=fnd)
      end
      end
      if (present(found)) found = fnd
   end

   resolve_basis(basis,suffix,found)
   ! Resolve the .slaterbasis by firstly trying to matching the ".basis_label"
   ! with one of the labels from "basis". If that fails, and "suffix" is present
   ! and not blank, then a library basis label is generated from the "suffix"
   ! and we try and match again to one of the labels in "basis". If present,
   ! "found" is set TRUE if the basis set has been resolved, or FALSE otherwise.
      basis :: VEC{SLATERBASIS}*
      suffix :: STR, optional
      found :: BIN, optional
   ENSURE(basis.created,"no basis")
      fnd :: BIN
      fnd = FALSE
      if (.basis_label/=" ") then
         .slaterbasis.resolve_by_label(.basis_label,basis,clobber=TRUE,found=fnd)
      end
      if (NOT fnd AND present(suffix)) then
      if (suffix/=" ") then
         .slaterbasis.resolve_by_label(.library_basis_label(suffix),basis,clobber=TRUE,found=fnd)
      end
      end
      if (present(found)) found = fnd
   end

   resolve_basis(basis,suffix,found)
   ! Resolve the .coppensbasis by firstly trying to matching the ".basis_label"
   ! with one of the labels from "basis". If that fails, and "suffix" is present
   ! and not blank, then a library basis label is generated from the "suffix"
   ! and we try and match again to one of the labels in "basis". If present,
   ! "found" is set TRUE if the basis set has been resolved, or FALSE otherwise.
      basis :: VEC{COPPENSBASIS}*
      suffix :: STR, optional
      found :: BIN, optional
   ENSURE(basis.created,"no basis")
      fnd :: BIN
      fnd = FALSE
      if (.basis_label/=" ") then
         .coppensbasis.resolve_by_label(.basis_label,basis,clobber=TRUE,found=fnd)
      end
      if (NOT fnd AND present(suffix)) then
      if (suffix/=" ") then
         .coppensbasis.resolve_by_label(.library_basis_label(suffix),basis,clobber=TRUE,found=fnd)
      end
      end
      if (present(found)) found = fnd
   end

!   resolve_by_basis_label(basis,label,clobber,found)
!   ! Resolve the .coppensbasis set by matching the ".basis_label" with one of
!   ! the labels from "basis". IF "label" is present it is used instead of
!   ! ".basis_label". If "clobber" is present and TRUE (the default situation),
!   ! then .coppensbasis is pointer assigned to the matching element in "basis"
!   ! irrespective of whether it is already associated; otherwise it is not
!   ! pointer assigned. If present, "found" is set TRUE if the basis set has been
!   ! resolved (or was already resolved if clobber was not set), or false
!   ! otherwise. If "found" is not present, and a match has not been found, an
!   ! error is generated
!      basis :: VEC{COPPENSBASIS}*
!      label :: STR
!      clobber,found :: BIN, optional
!   ENSURE(basis.created,"no Coppens basis")
!      .coppensbasis.resolve_by_label(label,basis,clobber,found)
!   end
!
!   resolve_by_basis_suffix(basis,suffix,clobber,found) 
!   ! Resolve the basis set by first making a standard basis label, by joining
!   ! the atom chemical symbol with the ":suffix" string, and then trying to find
!   ! a match with one of the "basis" set vector labels.  If "clobber" is present
!   ! and FALSE, then only an unassociated .coppensbasis is resolved.  If "found" is
!   ! present and it is set TRUE if there was a match, otherwise FALSE; and if it
!   ! is not present an error is generated if no match is found.
!      basis :: VEC{COPPENSBASIS}*
!      suffix :: STR
!      clobber,found :: BIN, optional
!      label :: STR
!   ENSURE(basis.created,"no Coppens basis")
!      label = .library_basis_label(suffix)
!      .coppensbasis.resolve_by_label(label,basis,clobber,found)
!   end

   read_library_data ::: leaky
   ! Read the basis from the library. The library directory is as currenly
   ! specified in the BASIS module. The basis_set_kind is extracted from the
   ! atom .basis_label.
   ENSURE(.basis_label/=" ","There is no basis label")
   ENSURE(.basis_label.includes(":"),"The basis_label has no colon, hence no kind part")
      basis :: VEC{BASIS}*
      slaterbasis :: VEC{SLATERBASIS}*
      coppensbasis :: VEC{COPPENSBASIS}*
      basis_set_kind :: STR
      basis_set_kind = .basis_label(.basis_label.index_of(":")+1:)
      select case (.basis_label)
         case ("Coppens")
            coppensbasis.destroy
            nullify(coppensbasis)
            coppensbasis.read_library_data(coppensbasis.library_directory(basis_set_kind),[.basis_label])
            .coppensbasis.create_copy(coppensbasis(1))
            coppensbasis.destroy
         case ("Thakkar","Clementi-Roetti")
            slaterbasis.destroy
            nullify(slaterbasis)
            slaterbasis.read_library_data(slaterbasis.library_directory(basis_set_kind),[.basis_label])
            .slaterbasis.create_copy(slaterbasis(1))
            slaterbasis.destroy
         case default
            basis.destroy
            nullify(basis)
            basis.read_library_data(basis.library_directory(basis_set_kind),[.basis_label])
            .basis.create_copy(basis(1))
            basis.destroy
      end
   end

!  ***************
!  Inquiry methods
!  ***************

   same_kind_as(atom) result(res)
   ! Return TRUE if self is the same kind of atom as "atom". The position and
   ! label are not compared since the same kind of atom can have a different
   ! position and label.  To check if the basis set is the same, only the
   ! label is used.
      atom :: ATOM
      res :: BIN
      bases_created,coppens_created,slater_created :: BIN
      bases_destroyed,coppens_destroyed,slater_destroyed :: BIN
      mixed :: BIN
      bases_created     = .basis.created AND atom.basis.created
      coppens_created   = .coppensbasis.created AND atom.coppensbasis.created
      slater_created    = .slaterbasis.created  AND atom.slaterbasis.created
      bases_destroyed   = .basis.destroyed AND atom.basis.destroyed
      coppens_destroyed = .coppensbasis.destroyed AND atom.coppensbasis.destroyed
      slater_destroyed  = .slaterbasis.destroyed   AND atom.slaterbasis.destroyed
      mixed = NOT (bases_created   OR bases_destroyed)   OR &
              NOT (coppens_created OR coppens_destroyed) OR &
              NOT (slater_created  OR slater_destroyed) 
      if (mixed) then
         res = FALSE
      else
         res = .atomic_number==atom.atomic_number 
         if (bases_created)   res = res AND .basis.label==atom.basis.label 
         if (coppens_created) res = res AND .coppensbasis.label==atom.coppensbasis.label 
         if (slater_created)  res = res AND .slaterbasis.label==atom.slaterbasis.label 
      end
   end

   no_of_shells result(res) ::: pure
   ! Return the no of shells
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.no_of_shells
   end

   n_shell result(res) ::: pure
   ! Return the no of shells
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.n_shell
   end

   no_of_basis_functions result (res) ::: pure
   ! Evaluate and return the no. of basis functions
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.no_of_basis_functions
   end

   n_bf result (res) ::: pure
   ! Return the no. of basis functions
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.n_bf
   end

   no_of_primitives result (res) ::: pure
   ! Return the no of primitives for this atom
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.no_of_primitives
   end

   n_prim result (res) ::: pure
   ! Return the no of primitives for this atom
      self :: IN
      res :: INT
   ENSURE(.basis.created,"no basis")
      res = .basis.n_prim
   end

   no_of_occupied_NOs(axiskind,tol) result (res)
   ! Returns the number of non-zero occupied natural orbitals. For this purpose,
   ! zero is defined to be "tol" if present, or TOL(7) otherwise
      self :: IN
      axiskind :: STR, optional, IN
      tol :: REAL, optional, IN
      res :: INT
   ENSURE(.occupation_numbers.created,"no occupation numbers")
      res = .occupation_numbers.no_of_occupied(axiskind,tol)
   end

   chemical_symbol(Z) result(res)
   ! Return the chemical symbol for this atom. If "Z" is present then the symbol
   ! returned is the one for the atom with atomic number "Z".
      Z :: INT, IN, optional
      res :: STR(len=2)
      atomic_number :: INT
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z
      if (atomic_number<1 OR atomic_number>103) then; res = "??"
      else;                  res = element_symbols(atomic_number)
      end
   end

   chemical_name result(res)
   ! Return the chemical name for this atom
      res :: STR(12)
      if (.atomic_number<1 OR .atomic_number>103) then; res = "??"
      else;                  res = element_names(.atomic_number)
      end
   end

   mass result (res)
   ! Return the atomic mass for this atom
      res :: REAL
      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                  res = atomic_masses(.atomic_number)
      end
   end

   mean_neutron_number result (res)
   ! Return the average (abundance weighted) number of neutrons for this atom,
   ! calculated roughly by subtracting the number of protons from the atomic mass.
      res :: REAL
      if (.atomic_number<1 OR .atomic_number>92) then; res = ZERO
      else;                  res = .mass - .atomic_number
      end
   end

   bragg_slater_radius result (res)
   ! Return the Bragg-Slater radius for this atom
   ! WARNING: this is in Angstroms!
      res :: REAL
   ENSURE(.atomic_number > 0,"atomic number less than 1")
      if (.atomic_number>54) then; res = ZERO
      else;                  res = bragg_slater_radii(.atomic_number)
      end
   end

   neutron_scattering_length result (res)
   ! Return the neutron scattering length for this atom
      res :: REAL
      if (.atomic_number<1 OR .atomic_number>95) then; res = ZERO
      else;            res = neutron_scattering_lengths(.atomic_number)
      end
   end

   period_number(Z) result(p)
   ! Return the period (i.e. row) on which the atom lies.
   ! If "Z" is present it is used as the atomic number.
       Z :: INT, optional
       p :: INT
      atomic_number,noble,n :: INT
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z
      p = 1
      if (atomic_number<1) return
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (atomic_number <= noble) exit
         p = p + 1
      end
   end

   column_number(Z) result(col)
   ! Return the period column (i.e. row) on which the atom lies.
   ! If "Z" is present it is used as the atomic number.
       Z :: INT, optional
      col :: INT
      atomic_number,p,noble,n :: INT
      atomic_number = .atomic_number
      if (present(Z)) atomic_number = Z
      p = 1
      if (atomic_number<1) return
      noble = 0
      do
         n = (p+2)/2
         noble = noble + 2*n**2
         if (atomic_number <= noble) exit
         p = p + 1
      end
      noble = noble - 2*n**2
      col = atomic_number - noble
   end

   period_block(Z) result(b)
   ! Return the period block character in which the atom lies.
   ! If "Z" is present it is used as the atomic number.
       Z :: INT, optional
       b :: STR(1)
      p,col :: INT
      p   = .period_number(Z)
      col = .column_number(Z)
      if (p<4) then
         select case (col)
            case (1:2);   b = "s"
            case (3:8);   b = "p"
         end
      else if (p<6) then
         select case (col)
            case (1:2);   b = "s"
            case (3:12);  b = "d"
            case (13:18); b = "p"
         end
      else if (p<8) then
         select case (col)
            case (1:2);   b = "s"
            case (3:16);  b = "f"
            case (17:26); b = "d"
            case (27:32); b = "p"
         end
      else
         DIE("cannot assign for period "// trim(p.to_str))
      end
   end

   ground_state_multiplicity(Z) result(mult)
   ! Return the ground state multiplicity for this atom according to Hunds rule
   ! (Note this is not neccesarily the real ground state, esp. for Cu)
   ! If "Z" is present it is used as the atomic number.
       Z :: INT, optional
      mult :: INT
      p,col :: INT
      p   = .period_number(Z)
      col = .column_number(Z)
      if (p<4) then
         select case (col)
            case (2,8);   mult = 1
            case (1,3,7); mult = 2
            case (4,6);   mult = 3
            case (5);     mult = 4
         end
      else if (p<6) then
         select case (col)
            case (2,12,18);      mult = 1
            case (1,3,11,13,17); mult = 2
            case (4,10,14,16);   mult = 3
            case (5,9,15);       mult = 4
            case (6,8);          mult = 5
            case (7);            mult = 6
         end
      else if (p<8) then
         select case (col)
            case (2,16,26,32);         mult = 1
            case (1,3,15,17,25,27,31); mult = 2
            case (4,14,18,24,28,30);   mult = 3
            case (5,13,19,23,29);      mult = 4
            case (6,12,20,22);         mult = 5
            case (7,11,21);            mult = 6
            case (8,10);               mult = 7
            case (9);                  mult = 8
         end
      else
         DIE("cannot assign for period "// trim(p.to_str))
      end
   end

   dispersion_correction(wavelength) result(res)
   ! The dispersion correction which best matches the wavelength.
     self :: IN
     wavelength :: REAL
     res :: CPX
     if (.atomic_number<1 OR .atomic_number>92) then
       res = ZERO
     else
       if (wavelength < 1.15) then
         res = dispersion_correction_Ag( .atomic_number ) ! 0.559A/1.06au
       else if (wavelength < 2.1) then
         res = dispersion_correction_Mo( .atomic_number ) ! 0.709A/1.34au
       else if (wavelength < 3.6) then
         res = dispersion_correction_Cu( .atomic_number ) ! 1.541A/2.91au
       else
         res = dispersion_correction_Cr( .atomic_number ) ! 2.29A/4.33au
       end
     end
   end

   library_basis_label(suffix) result (label) ::: leaky
   ! Return a library basis set label by appending "suffix" to the
   ! chemical symbol.
      suffix :: STR
      label :: STR
      symbol :: STR
      symbol = .chemical_symbol
      select case (suffix)
         case ("Coppens")
            if (.atomic_number>55) then
               select case (.atomic_number)
                  case (56);     symbol = "Sr"
                  case (57:71);  symbol = "Y"
                  case (72:87);  symbol = .chemical_symbol(.atomic_number-32)
                  case (88);     symbol = "Sr"
                  case (89:103); symbol = "Y"
               end
               WARN("Replaced basis for atom "//.chemical_symbol.trim//" with that for atom "//symbol.trim)
            end
            label = trim(symbol)//trim(.oxidation_state_str)//":"//trim(suffix)
         case ("Thakkar")
            label = trim(symbol)//trim(.oxidation_state_str)//":"//trim(suffix)
         case default
            label = trim(symbol)//":"//trim(suffix)
      end
   end

   oxidation_state_str result (res) 
   ! Return the oxidation state string, i.e. if the oxidation state is +3, then
   ! the returned string is "3+"; or if the oxidation state is -1 then the
   ! returned string is "-". This is useful for resolving certain library basis
   ! labels.
      res :: STR
      charge :: INT
      charge = .oxidation_state
      if (charge==0) then
         res = " "
      else
         if (charge>0) then; res = "+"
         else;               res = "-"
         end
         charge = abs(charge)
         if (charge/=1) res = trim(charge.to_str)//trim(res)
      end
   end

   has_ANO_data result (res)
   ! Return TRUE if the ANO data exists for the atom.
      res :: BIN
      res = .natural_orbitals.created AND .occupation_numbers.created
   end

   has_basis result (res)
   ! Return TRUE if the basis exists
      res :: BIN
      res = .basis.created
   end

   has_basis_label result (res)
   ! Return TRUE if the basis label exists and is not blank
      res :: BIN
      if (.basis.destroyed) then;       res = FALSE
      else if (.basis.label==" ") then; res = FALSE
      else;                             res = TRUE
      end
   end

   min_basis_exponent result (res)
   ! Return the minimum exponent in the basis.
     res :: REAL
     if (.coppensbasis.created) then
       res = .coppensbasis.min_exponent
     else if (.basis.created) then
       res = .basis.min_exponent
     else
       DIE("no basis")
     end
   end

   is_bonded_to(b,scale_factor) result(res)
   ! Return true if "self" is bonded to "b".  If present, "scale_factor" is used
   ! to determine a multiple of the sum of the Bragg-Slater radii within which
   ! the atoms are regarded to be bonded.
      b :: ATOM
      scale_factor :: REAL, optional
      res :: BIN
      bond_max,fac :: REAL
      fac = VEC_ATOM_BONDED_SCALE_FACTOR
      if (present(scale_factor)) fac = scale_factor
      bond_max = fac*(self.bragg_slater_radius + b.bragg_slater_radius)
      bond_max = bond_max*BOHR_PER_ANGSTROM
      res = .is_nearby_to(b,bond_max)
   end

   is_nearby_to(b,dist) result(res)
   ! Return TRUE if atom "self" and atom "b" are nearby, i.e. within length
   ! "dist".
      b :: ATOM
      dist :: REAL
      res :: BIN
      tmp :: VEC{REAL}(3)
      r2 :: REAL
      tmp = .pos - b.pos
      tmp = abs(tmp)
      if      (tmp(1)>dist) then
         res = FALSE
      else if (tmp(2)>dist) then
         res = FALSE
      else if (tmp(3)>dist) then
         res = FALSE
      else
         r2 = dot_product(tmp,tmp)
         res = (r2 < dist*dist)
      end
   end

!  *************************
!  Density plotting routines
!  *************************

   make_density_grid(density_grid,pt)
   ! Work out the electron "density_grid" on "pt" using ".natural orbitals" and
   ! the ".occupation_numbers" vector.
      self :: IN
      density_grid :: VEC{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
      if      (.slaterbasis.created) then
         .slaterbasis.make_density_grid(density_grid,pt,.pos)
      else if (.coppensbasis.created) then
         .coppensbasis.make_density_grid(density_grid,pt,.pos)
      else if (.basis.created AND .natural_orbitals.created) then
         if (.natural_orbitals.number_kind == "real") then
            .make_density_grid_r(density_grid,pt)
         else
            .make_density_grid_c(density_grid,pt)
         end
      else
         DIE("Can't made density grid")
      end
      if (NOT .site_occupancy.same_as(ONE)) &
         density_grid = .site_occupancy*density_grid
   end

   make_density_grid(density,d_density,d2_density,pt)
   ! Work out the electron "density", its 1st derivative "d_density" and 2nd
   ! derivative "d2_density" for a set of points "pt". NOTE: this is only
   ! implemented in a very limited way so far.
      self :: IN
      density :: VEC{REAL}, OUT
      d_density :: MAT{REAL}, OUT
      d2_density :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(density.dim==pt.dim1,"inconsistent number of points")
   ENSURE(d_density.dim2==pt.dim1,"inconsistent number of points")
   ENSURE(d2_density.dim3==pt.dim1,"inconsistent number of points")
   ENSURE(d_density.dim1==3,"wrong dim1 for d_density")
   ENSURE(d2_density.dim1==3,"wrong dim1 for d2_density")
   ENSURE(d2_density.dim2==3,"wrong dim1 for d2_density")
      if      (.slaterbasis.created) then
         .slaterbasis.make_density_grid(density,d_density,d2_density,pt,.pos)
      else if (.coppensbasis.created) then
         DIE("not implemented yet")
      else if (.basis.created AND .natural_orbitals.created) then
         DIE("not implemented yet")
       ! if (.natural_orbitals.number_kind == "real") then
       !    .make_density_grid_r(density_grid,pt)
       ! else
       !    .make_density_grid_c(density_grid,pt)
       ! end
      else
         DIE("Can't made density grid")
      end
      ! This is highly didgy ...
      if (NOT .site_occupancy.same_as(ONE)) then
         density = .site_occupancy*density
         d_density = .site_occupancy*d_density
         d2_density = .site_occupancy*d2_density
      end
   end

   skip_density_grid(pt) result (res)
   ! Work out whether we can skip this density grid because all the points are
   ! so far away that the density values will be zero.
      self :: IN
      pt :: MAT{REAL}, IN
      res :: BIN
      res = FALSE
      if    (.slaterbasis.created) then
         if (.slaterbasis.interpolator.created) then
         res = .slaterbasis.skip_interpolated_density_grid(pt,.pos)
         end
      else if (.coppensbasis.created) then
         if   (.coppensbasis.interpolator.created) then
         res = .coppensbasis.skip_interpolated_density_grid(pt,.pos)
         end
      end
   end

   make_density_grid_r(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted real
   ! natural orbitals
     self :: IN
     density_grid :: VEC{REAL}, OUT
     pt :: MAT{REAL}, IN
   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
     NO :: VEC{REAL}*
     n_occ,n :: INT
     density_grid = ZERO
     NO.create(pt.dim1)
     n_occ = .no_of_occupied_NOs
     do n = 1,n_occ
       .make_orbital_grid_r(NO,.natural_orbitals.restricted(:,n),pt,.pos)
       density_grid = density_grid &
                    + .occupation_numbers.restricted(n)*NO*NO
     end
     NO.destroy
   end

   make_density_grid_c(density_grid,pt)
   ! Make the "density_grid" for the supplied points "pt" from restricted
   ! complex natural orbitals.
      density_grid :: VEC{REAL}
      pt :: MAT{REAL}
   ENSURE(pt.dim2==3,"wrong dimension for points array")
   ENSURE(density_grid.dim==pt.dim1,"inconsistent number of points")
   ENSURE(.natural_orbitals.created("restricted_complex"),"no restricted NO's")
   ENSURE(.occupation_numbers.created("restricted"),"no occupation numbers")
      NO :: VEC{CPX}*
      n_occ,n :: INT
      density_grid = ZERO
      NO.create(pt.dim1)
      n_occ = .no_of_occupied_NOs
      do n = 1,n_occ
         .make_orbital_grid_c(NO,.natural_orbitals.restricted_complex(:,n),pt,.pos)
         density_grid = density_grid &
                      + .occupation_numbers.restricted(n)*conjg(NO)*NO
      end
      NO.destroy
   end

   make_orbital_grid_r(g,orb,pt,pos,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt" for an atom at position
   ! "pos". If "square" is present and TRUE, the square of the orbital density
   ! is returned.
      g :: VEC{REAL}, OUT
      orb :: VEC{REAL}, IN
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN
      square :: BIN, optional, IN
   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,f,l,s :: INT
      sq = FALSE
      if (present(square)) sq = square
      n_pt = pt.dim1
      g = ZERO
      l = 0
      do s = 1,.n_shell
         sh.set(.basis.shell(s),pos)
         f = l + 1
         l = f + sh.n_comp - 1
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g = g + matmul(sh_grid,orb(f:l))
         sh_grid.destroy
      end
      if (sq) g = g*g
   end

   make_orbital_grid_c(g,orb,pt,pos,square)
   ! Evaluate the orbital density grid "g" for *one* AO-basis coefficient
   ! orbital vector "orb" on a set of grid points "pt" for an atom at position
   ! "pos". If "square" is present and TRUE, the square of the orbital density
   ! is returned.
      self :: IN
      g :: VEC{CPX}, OUT
      orb :: VEC{CPX}, IN
      pt :: MAT{REAL}, IN
      pos :: VEC{REAL}(3), IN
      square :: BIN, optional, IN
   ENSURE(.basis.created,"no basis set")
   ENSURE(.basis.no_of_basis_functions==orb.dim,"incorrect suize, orb")
      sq :: BIN
      sh :: SHELL1
      sh_grid :: MAT{REAL}*
      n_pt,f,l,s :: INT
      sq = FALSE
      if (present(square)) sq = square
      n_pt = pt.dim1
      g = ZERO
      l = 0
      do s = 1,.n_shell
         sh.set(.basis.shell(s),pos)
         f = l + 1
         l = f + sh.n_comp - 1
         sh_grid.create(n_pt,sh.n_comp)
         sh.make_grid(sh_grid,pt)
         g = g + matmul(sh_grid,orb(f:l))
         sh_grid.destroy
      end
      if (sq) g = conjg(g)*g
   end

   density_at_radius(R) result (res)
   ! Work out the electron at radius "R".
      R,res :: REAL
      density_grid :: VEC{REAL}(1)
      pt :: MAT{REAL}(3,1)
      if      (.slaterbasis.created AND .slaterbasis.shell.created) then
         res = .slaterbasis.density_at_radius(R)
      else if (.coppensbasis.created AND .coppensbasis.orbital.created) then
         res = .coppensbasis.density_at_radius(R)
      else if (.basis.created) then
         pt(:,1) = .pos + [R,ZERO,ZERO]
         if (.natural_orbitals.number_kind == "real") then
            .make_density_grid_r(density_grid,pt)
         else
            .make_density_grid_c(density_grid,pt)
         end
         res = density_grid(1)
      end
   end

   make_slater_interpolator ::: leaky
   ! Make a the slaterbasis interpolator.
   ENSURE(.slaterbasis.created,"no slater basis")
      .slaterbasis.make_interpolator
   end

!  ***************************
!  Basis shell access routines
!  ***************************

   get_shell_limits(first,last) ::: leaky
   ! Get the indices of first and last basis functions in a particular shell
   ! "s", first(s) and last(s), respectively.
      first,last :: VEC{INT}*
      n_shell,f,l,s :: INT
      n_shell = .basis.n_shell
      nullify(first); first.create(n_shell)
      nullify(last);  last.create(n_shell)
      l = 0
      do s = 1,n_shell
         f = l + 1
         l = f + .basis.shell(s).n_comp - 1
         first(s) = f
         last(s)  = l
      end
   end

!  **************
!  Output methods
!  **************

   put
   ! Put out the atom information to file "stdout"
     stdout.flush
     stdout.show("Label                  =",trim(.label))
     stdout.show("Atomic No.             =",.atomic_number)
     stdout.show("Chemical symbol        =",trim(.chemical_symbol))
     stdout.show("Atom coordinates       =",.pos(1),.pos(2),.pos(3))
     if (.sequence_number/=0) .put_mm_info
     if (.basis.created) .basis.put
     if (.coppensbasis.created) .coppensbasis.put
   ! if (.interpolator.created) .interpolator.put
   end

   put_mm_info
   ! Put out the MM/protien part of the atom information to file "stdout"
     stdout.flush
     stdout.show("Residue atom name      =",trim(.residue_atom_name))
     stdout.show("Residue name           =",trim(.residue_name))
     stdout.show("Sequence number        =",.sequence_number)
     stdout.show("MM forcefield name     =",.mm_forcefield_name)
     stdout.show("MM atom type           =",.mm_atom_type)
     stdout.show("MM charge              =",.mm_charge)
     stdout.show("Restraining position   =",.restraining_position)
     stdout.show("Restraining force      =",.restraining_force_constant)
   end

   put_thermal_tensor(units)
   ! Output the thermal tensor.  Does not put a header or carriage return.
   ! Only outputs the 6 independent ones, not all 9.
     units :: STR, optional
     unit :: STR
     U :: VEC{REAL}(6)
     unit = "bohr^2"
     if (present(units)) unit = units
     if (unit=="bohr^2") then
        stdout.put(.thermal_tensor(1,1))
        stdout.put(.thermal_tensor(2,2))
        stdout.put(.thermal_tensor(3,3))
        stdout.put(.thermal_tensor(1,2))
        stdout.put(.thermal_tensor(1,3))
        stdout.put(.thermal_tensor(2,3))
     else
        U(1) = .thermal_tensor(1,1)
        U(2) = .thermal_tensor(2,2)
        U(3) = .thermal_tensor(3,3)
        U(4) = .thermal_tensor(1,2)
        U(5) = .thermal_tensor(1,3)
        U(6) = .thermal_tensor(2,3)
        U.convert_to(unit)
        stdout.put(U(1))
        stdout.put(U(2))
        stdout.put(U(3))
        stdout.put(U(4))
        stdout.put(U(5))
        stdout.put(U(6))
     end
   end

   put_natural_orbitals
   ! Put out the current associated molecular orbitals to file "out"
   ENSURE(.natural_orbitals.created,"no natural orbitals")
   ENSURE(.occupation_numbers.created,"no natural orbital occupations")
      stdout.flush
      stdout.text("Natural orbital occupations:")
      stdout.put( .occupation_numbers, format="column")
      stdout.flush
      stdout.text("Natural orbitals:")
      stdout.put( .natural_orbitals)
   end

   put_interpolator
   ! Put out the atom information to file "stdout"
      if (.slaterbasis.created) then
         stdout.flush
         stdout.text("Atom slaterbasis info:")
         if (.slaterbasis.interpolator.created) .slaterbasis.interpolator.put
      end
      if (.coppensbasis.created) then
         stdout.flush
         stdout.text("Atom coppensbasis info:")
         if (.coppensbasis.interpolator.created) .coppensbasis.interpolator.put
      end
   end

end

