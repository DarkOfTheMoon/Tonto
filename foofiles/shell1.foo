!-------------------------------------------------------------------------------
!
! SHELL1 
!
! For describing contracted cartesian gaussian shells with a position
! coordinate. Largely inherited from SHELL.
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!-------------------------------------------------------------------------------

module SHELL1

   implicit none

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end

   nullify_ptr_part ::: get_from(SHELL)
   ! Nullify the pointer part of a shell object
   end

   destroy_ptr_part ::: get_from(SHELL), leaky
   ! Destroy pointer part of a shell object
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   create_copy(object) ::: get_from(OBJECT), leaky
   ! Create a copy of object
   end

   create_copy(shell,pos) ::: leaky
   ! Create a shell object from another copy
      self :: PTR
      shell :: SHELL, IN
      pos :: VEC{REAL}, IN
      .create
      .copy(shell,pos)
   end

   copy(shell) ::: get_from(SHELL, SHELL=>SHELL1), leaky
   ! Copy a shell object. Make sure pointer parts are nullified or
   ! destroyed, as you like, before using this.
   end

   copy(shell,pos) ::: leaky
   ! Make a shell1 object from a shell1 object.
   ! The position "pos" overides "shell.pos".
   ! NOTE : ensure the ptr parts have been destroyed or nullified beforehand.
      shell :: SHELL1, IN
      pos :: VEC{REAL}, IN
      .copy(shell)
      .pos = pos
   end

   copy(shell) ::: leaky
   ! Make a shell1 object from the shell. The position is *not* set.
   ! NOTE : ensure the ptr parts have been destroyed beforehand.
      self :: OUT
      shell :: SHELL, IN
   ENSURE(.ex.destroyed,"ex not destroyed")
   ENSURE(.cc.destroyed,"cc not destroyed")
   ENSURE(.cc_s.destroyed,"cc_s not destroyed")
   ENSURE(.cc_p.destroyed,"cc_p not destroyed")
      .l = shell.l
      .l_chr = shell.l_chr
      .is_spherical = shell.is_spherical
      .n_comp = shell.n_comp
      .n_sph = shell.n_sph
      .first_gaussian = shell.first_gaussian
      .last_gaussian = shell.last_gaussian
      .n_cc = shell.n_cc
      .nullify_ptr_part
      if (shell.ex.created) .ex.create_copy(shell.ex)
      if (shell.cc.created) .cc.create_copy(shell.cc)
      if (shell.cc_s.created) .cc_s.create_copy(shell.cc_s)
      if (shell.cc_p.created) .cc_p.create_copy(shell.cc_p)
   end

   copy(shell,pos) ::: leaky
   ! Make a SHELL1 object from the SHELL "shell" and its position "pos".
   ! NOTE : ensure the ptr parts have been destroyed beforehand.
      self :: OUT
      shell :: SHELL, IN
      pos :: VEC{REAL}, IN
      .copy(shell)
      .pos = pos
   end

   set(object) ::: get_from(OBJECT)
   ! Set the object. Pointer parts are assigned not copied.
   end

   set(shell,pos)
   ! Set a shell1 object. Pointer parts are assigned not copied.
      shell :: SHELL, optional
      pos :: VEC{REAL}, optional
      if (present(shell)) then
         .l = shell.l
         .l_chr = shell.l_chr
         .is_spherical = shell.is_spherical
         .n_comp = shell.n_comp
         .n_sph = shell.n_sph
         .first_gaussian = shell.first_gaussian
         .last_gaussian = shell.last_gaussian
         .n_cc = shell.n_cc
         .ex   => shell.ex
         .cc   => shell.cc
         .cc_s => shell.cc_s
         .cc_p => shell.cc_p
      end
      if (present(pos)) .pos = pos
   end

   set_defaults
   ! Set defaults
      .l = 0
      .l_chr = " "
      .is_spherical = SHELL_IS_SPHERICAL
      .n_cc = 0
      .n_comp = 0
      .n_sph = 0
      .first_gaussian = 0
      .last_gaussian = 0
      .pos = ZERO
   end

   set_l(l) ::: get_from(SHELL, SHELL=>SHELL1)
   ! Set the l value
   end

   set_n_comp ::: get_from(SHELL, SHELL=>SHELL1)
   ! Set the number of components. "L" shells are a special case.
   end

!  *************
!  Input methods
!  *************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
      keyword :: STR, IN
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
       case ("}           "); ! exit surrounding loop
       case ("cc=         "); .read_cc
       case ("ex=         "); .read_ex
       case ("ex,cc=      "); .read_ex_cc
       case ("junk,ex,cc= "); .read_junk_ex_cc
       case ("l=          "); .read_l
       case ("l_chr=      "); .read_l_chr
       case ("n_cc=       "); .read_n_cc
       case ("pos=        "); .read_pos
       case ("put         "); .put
       case ("spherical=  "); .read_spherical
       case ("units=      "); SHELL1::read_units
       ! These are only for making custom tables for the list type
      ! case ("flush       "); stdout.flush
      ! case ("put_l       "); stdout.put(.l)
      ! case ("put_l_chr   "); stdout.put(.l_chr,int_width=TRUE)
      ! case ("put_l_int   "); stdout.put(.l)
      ! case ("put_n_cc    "); stdout.put(.n_cc)
      ! case ("put_n_prim  "); stdout.put(.n_prim)
      ! case ("put_norm    "); stdout.put(.norm)
       case default;         UNKNOWN(word)
      end
   end

   read_units ::: get_from(OBJECT), selfless, private
   ! Read a string which describes the units to be used
   end

   read_l ::: get_from(SHELL)
   ! Read in the l symbol
   end

   read_l_int ::: get_from(SHELL)
   ! Read in the l integer. No way to get "L" shells in this input mode.
   end

   read_l_chr ::: get_from(SHELL)
   ! Read in the l symbol
   end

   read_spherical ::: get_from(SHELL)
   ! Read in if this is a spherical shell
   end

   read_n_cc ::: get_from(SHELL)
   ! Read in the number of contraction coefficients
   end

   read_ex ::: get_from(SHELL), leaky
   ! Read in the exponents
   end

   read_cc ::: get_from(SHELL), leaky
   ! Read in the contraction coefficients
   end

   read_ex_cc ::: get_from(SHELL), leaky
   ! Read in the exponents and contractions
   end

   read_junk_ex_cc ::: get_from(SHELL), leaky
   ! Read in the exponents and contractions preceded by a junk string
   end

   read_pos
   ! Read in the position
      stdin.read(.pos)
   end

!  *********************
!  Miscellaneous methods
!  *********************

   n_comp(l) result (res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of cartesian components in a gaussian shell of momentum "l".
   end

   n_comp_up_to(l) result (res) ::: get_from(GAUSSIAN_DATA), selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
   end

   l_chr(l) result (res) ::: get_from(SHELL), selfless, private
   ! Return a character representation for angular mtm "l"
   ! Of course, "L" shells are never returned: they have mixed mtm.
   end

   same_as(sh) result(same)
   ! Return TRUE if the shell "self" is the same as "sh".
      sh :: SHELL1
      same :: BIN
      same = .l_chr==sh.l_chr &
         AND (.is_spherical EQV sh.is_spherical) &
         AND (.ex.created EQV sh.ex.created) &
         AND (.cc.created EQV sh.cc.created) &
         AND (.cc_s.created EQV sh.cc_s.created) &
         AND (.cc_p.created EQV sh.cc_p.created) 
      if (NOT same) return
      same = .pos.same_as(sh.pos)
      if (NOT same) return
      if (.ex.created AND sh.ex.created) same = .ex.same_as(sh.ex) 
      if (NOT same) return
      if (.l_chr/="L") then
         if (.cc.created   AND sh.cc.created)   same = .cc.same_as(sh.cc) 
      else
         if (.cc_s.created AND sh.cc_s.created) same = .cc_s.same_as(sh.cc_s) 
         if (NOT same) return
         if (.cc_p.created AND sh.cc_p.created) same = .cc_p.same_as(sh.cc_p) 
      end
   end

   make_contraction_matrix(ccm,ccp) ::: get_from(SHELL)
   ! Return the contraction coefficient matrix "ccm" which converts
   ! primitives to basis functions. It is with respect to uniform
   ! normalisation i.e. all components are normalised to the first
   ! component, x^l. If this is an "L" shell, "ccp" may also be
   ! returned, the contraction matrix for the "p" shell. size "ccm" is
   ! normally (.n_prim,.n_comp).
   end

   norm result (res) ::: get_from(SHELL), pure
   ! Return the norm of the shell, assuming that the existing contraction
   ! coefficients are with respect to NORMALISED primitive gaussians.
   end

   unnormalise ::: get_from(SHELL)
   ! Assuming the existing contraction coefficients are initially with respect
   ! to NORMALISED primitive gaussians, take out this normalisation factor of
   ! each primitive and put it in the contraction coefficient. The normalisation
   end

   renormalise ::: get_from(SHELL)
   ! Assuming the existing contraction coefficients are with respect to raw
   ! UNNORMALISED primitive gaussians, put back this normalisation factor for
   end

!   renormalise
!   ! Normalise self as if all components in the shell were x^l, and also
!   ! assuming the existing contraction coefficients are with respect to raw
!   ! unnormalised gaussians. This will undo routine "unnormalise".
!   ! The overall ((TWO*PI)**(THREE/FOUR)) / .norm factor is to make the
!   ! cc=1 for a shell with one primitive
!      .cc(:) = .cc(:) / ((FOUR*.ex(:))**(HALF*.l+HALF+QUARTER)) &
!               * (sqrt(.l.double_factorial) * ((TWO*PI)**(THREE/FOUR)) / .norm)
!   end

   n_prim result (res) ::: get_from(SHELL)
   ! Return the number of primitive gaussians in the shell
   end

   put
   ! Put the shell information to "stdout"
      i :: INT
      stdout.flush
      stdout.show("Shell type = ",.l_chr)
      stdout.show("l          = ",.l)
      stdout.show("position   =",.pos)
      stdout.show("is_spherical   = ",.is_spherical)
      stdout.show("n_comp         = ",.n_comp)
      stdout.show("n_sph          = ",.n_sph)
      stdout.show("first_gaussian = ",.first_gaussian)
      stdout.show("last_gaussian  = ",.last_gaussian)
      if (.n_cc<=0) return
      if (.l_chr/="L") then
         ENSURE(.ex.created,"no exponents")
         ENSURE(.cc.created,"no contractions")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=2)
         stdout.put("#", int_width=TRUE)
         stdout.put("Exponents")
         stdout.put("Contraction")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=2)
         do i = 1,.n_cc
            stdout.put(i)
            stdout.put(.ex(i))
            stdout.put(.cc(i))
            stdout.flush
         end
         stdout.dash(int_fields=1,real_fields=2)
      else
         ENSURE(.ex.created,"no exponents")
         ENSURE(.cc_s.created,"no s contractions")
         ENSURE(.cc_p.created,"no p contractions")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=3)
         stdout.put("#", int_width=TRUE)
         stdout.put("Exponents")
         stdout.put("Contraction")
         stdout.flush
         stdout.dash(int_fields=1,real_fields=3)
         do i = 1,.n_cc
            stdout.put(i)
            stdout.put(.ex(i))
            stdout.put(.cc_s(i))
            stdout.put(.cc_p(i))
            stdout.flush
         end
         stdout.dash(int_fields=1,real_fields=3)
      end
   end

! ************
! Grid methods
! ************

   r_max(cutoff) result (res)
   ! Return the radius where all basis functions becomes smaller than "cutoff".
      cutoff :: REAL, IN
      res :: REAL
      alpha :: REAL
      alpha = ONE/minval(.ex)
      if (cutoff<=ZERO) then; res = huge(ONE)
      else;    res = sqrt(-alpha*log(cutoff/sum(abs(.cc))))
      end
   end

   r2_max(cutoff) result (res)
   ! Return the radius where all basis functions becomes smaller than "cutoff".
      cutoff :: REAL, IN
      res :: REAL
      alpha :: REAL
      alpha = ONE/minval(.ex)
      if (cutoff<=ZERO) then; res = huge(ONE)
      else;    res = -alpha*log(cutoff/sum(abs(.cc)))
      end
   end

   make_skip_list(skip,n_keep,r2,preskip,n_pt,cutoff) ::: public
   ! From a list of squared distances "r2" and preskipped points
   ! "preskip" return those distances where the basis function has a
   ! significant value above "cutoff".
      skip :: VEC{BIN}(n_pt), OUT
      n_keep :: INT, OUT
      r2 :: VEC{REAL}(n_pt), IN
      preskip :: VEC{BIN}(n_pt), IN
      n_pt :: INT, IN
      cutoff :: REAL, IN

      r2_max :: REAL
      s :: BIN
      n :: INT

      r2_max = .r2_max(cutoff)

      n_keep = 0

      do n = 1,n_pt

         s = preskip(n)
         skip(n) = s
         if (s) cycle

         s = r2(n)>r2_max
         skip(n) = s

         if (s) cycle

         n_keep = n_keep + 1

      end

   end

   make_significant_points(x,y,z,r2,skip,pt,cutoff) ::: leaky
   ! From a given list of points "pt" return the significant displacements "x",
   ! "y", "z" and their square "r2". These are comprised of those points for
   ! which the basis functions of the atom have a significant value above
   ! "cutoff" i.e. those points for which "skip" is FALSE.
      x,y,z,r2 :: VEC{REAL}*
      skip :: VEC{BIN}*
      pt :: MAT{REAL}, IN
      cutoff :: REAL, IN

      xx,yy,zz,rr, px,py,pz, r2_max :: REAL
      n_pt,n,k :: INT

      n_pt = pt.dim1
      skip.create(n_pt)
      x.create(n_pt); y.create(n_pt); z.create(n_pt)
      r2.create(n_pt)

      r2_max = .r2_max(cutoff)
      px = .pos(1) 
      py = .pos(2) 
      pz = .pos(3) 

      k = 0
      do n = 1,n_pt
         xx = pt(n,1) - px 
         yy = pt(n,2) - py
         zz = pt(n,3) - pz 
         rr = xx*xx + yy*yy + zz*zz
         skip(n) = rr>r2_max
         if (skip(n)) cycle
         k = k + 1
         x(k) = xx
         y(k) = yy
         z(k) = zz
         r2(k) = rr
      end

      if (k==0) then
         skip.destroy
         x.destroy; y.destroy; z.destroy
         r2.destroy
      else
         x.shrink(k); y.shrink(k); z.shrink(k)
         r2.shrink(k)
      end

   end


   make_grid(g,pt)
   ! Return "g(i,n)", the value of the shell component "n" on grid point "i"
   ! given a set of grid points "pt(i,1:3)"
   ! Note: it is assumed that the shell is normalised, and the appropriate
   ! double factorial normalising factors are introduced for each component
      pt :: MAT{REAL}, target
       g :: MAT{REAL}, target
      x,y,z :: VEC{REAL}*
      x => pt(:,1); y => pt(:,2); z => pt(:,3)
      .make_grid(g,x,y,z)
   end


   make_grid(f,x,y,z)
   ! Return "f(i,n)", the value of the shell component "n" on grid point "i"
   ! given a set of grid points "(x(i),y(i),z(i))"
   ! Note: it is assumed that the shell is normalised to the component x^2; the
   ! appropriate double factorial normalising factors are introduced for each
   ! component (if required) so that each component is properly normalised.
      x,y,z :: VEC{REAL}
      f :: MAT{REAL}
   ENSURE(f.dim1==x.dim,"inconsistent f and x")
   ENSURE(f.dim1==y.dim,"inconsistent f and x")
   ENSURE(f.dim1==z.dim,"inconsistent f and x")
      fac,bx,by,bz :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b, ff,lf :: INT
      rr,xx,yy,zz,posx,posy,posz,f0,f1,bxb,byb,bzb :: REAL
      xx2,yy2,zz2,xx3,yy3,zz3,zz_f1 :: REAL
      n_pt = size(x)
      posx = .pos(1); posy = .pos(2); posz = .pos(3)
      select case (.l)
        case (0) ! S function ...........
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             f(n,1) = sum(.cc * exp( -rr * .ex ))
          end
        case (1) ! P function ...........
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             f0 = sum(.cc * exp( -rr * .ex ))
             f(n,1) = xx*f0
             f(n,2) = yy*f0
             f(n,3) = zz*f0
          end
        case (2) ! D function ...........
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             f0 = sum(.cc * exp( -rr * .ex ))
             f1 = sqrt(THREE)*f0
             zz_f1 = zz*f1
             f(n,1) = xx*xx*f0
             f(n,2) = yy*yy*f0
             f(n,3) = zz*zz*f0
             f(n,4) = xx*yy*f1
             f(n,5) = xx*zz_f1
             f(n,6) = yy*zz_f1
          end
        case (3) ! F function ...........
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             xx2 = xx*xx
             yy2 = yy*yy
             zz2 = zz*zz
             xx3 = xx2*xx
             yy3 = yy2*yy
             zz3 = zz2*zz
             rr = xx2 + yy2 + zz2
             f0 = sum(.cc * exp( -rr * .ex ))
             f(n,1)  = fac(1)*f0*xx3
             f(n,2)  = fac(2)*f0*yy3
             f(n,3)  = fac(3)*f0*zz3
             f(n,4)  = fac(4)*f0*xx2*yy
             f(n,5)  = fac(5)*f0*xx2*zz
             f(n,6)  = fac(6)*f0*xx*yy2
             f(n,7)  = fac(7)*f0*yy2*zz
             f(n,8)  = fac(8)*f0*xx*zz2
             f(n,9)  = fac(9)*f0*yy*zz2
             f(n,10) = fac(10)*f0*xx*yy*zz
          end
        case default ! General l function ...........
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l)
          by.create(0,.l)
          bz.create(0,.l)
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             f0 = sum( .cc * exp( -rr * .ex ))
             ! Cartesian orbital part
             ! x**b,y**b,z**b for b=0,.l
             bx(0) = ONE;   by(0) = ONE;   bz(0) = ONE
             bx(1) = xx;    by(1) = yy;    bz(1) = zz
             bxb = xx;      byb = yy;      bzb = zz
             do b=2,.l
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Combine cartesian orbital powers with the exponential part
             f(n,:) = fac(:)*f0*bx(nx(:))*by(ny(:))*bz(nz(:))
          end
          bz.destroy; by.destroy; bx.destroy
      end
   end

   make_grid(f,x,y,z,r2,cutoff)
   ! Return "f(i,n)", the value of the shell component "n" on grid point "i".
   ! "x", "y", "z" are the differences between the points "pt" and the shell
   ! center, "r2" is an array for the square of the distance from the points
   ! "pt" to ".pos". These arrays can be efficiently precalculated under some
   ! circumstances, when shell belonging to a whole atom are being calculated.
   ! NOTE: it is assumed that the shell is normalised to the component x^2; the
   ! appropriate double factorial normalising factors are introduced for each
   ! component (if required) so that each component is properly normalised.
      f :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL
   ENSURE(f.dim1==x.dim,"inconsistent f and x")
   ENSURE(f.dim1==y.dim,"inconsistent f and x")
   ENSURE(f.dim1==z.dim,"inconsistent f and x")
      fac,bx,by,bz :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b, ff,lf :: INT
      rr,xx,yy,zz,f0,f1,bxb,byb,bzb :: REAL
      alpha,r_max,r2_max,xx2,yy2,zz2,xx3,yy3,zz3,zz_f1 :: REAL
      n_pt = x.dim
      f = ZERO
      alpha = ONE/minval(.ex)
      if (cutoff<=ZERO) then; r2_max = huge(ONE)
      else;    r_max = sqrt(-alpha*log(cutoff)); r2_max = r_max*r_max
      end
      select case (.l)
        case (0) ! S function ...........
          do n = 1,n_pt
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             f(n,1) = sum(.cc * exp( -rr * .ex ))
          end
        case (1) ! P function ...........
          do n = 1,n_pt
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             f0 = sum(.cc * exp( -rr * .ex ))
             f(n,1) = xx*f0
             f(n,2) = yy*f0
             f(n,3) = zz*f0
          end
        case (2) ! D function ...........
          do n = 1,n_pt
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             f0 = sum(.cc * exp( -rr * .ex ))
             f1 = sqrt(THREE)*f0
             zz_f1 = zz*f1
             f(n,1) = xx*xx*f0
             f(n,2) = yy*yy*f0
             f(n,3) = zz*zz*f0
             f(n,4) = xx*yy*f1
             f(n,5) = xx*zz_f1
             f(n,6) = yy*zz_f1
          end
        case (3) ! F function ...........
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          do n = 1,n_pt
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             xx2 = xx*xx
             yy2 = yy*yy
             zz2 = zz*zz
             xx3 = xx2*xx
             yy3 = yy2*yy
             zz3 = zz2*zz
             f0 = sum(.cc * exp( -rr * .ex ))
             f(n,1)  = fac(1)*f0*xx3
             f(n,2)  = fac(2)*f0*yy3
             f(n,3)  = fac(3)*f0*zz3
             f(n,4)  = fac(4)*f0*xx2*yy
             f(n,5)  = fac(5)*f0*xx2*zz
             f(n,6)  = fac(6)*f0*xx*yy2
             f(n,7)  = fac(7)*f0*yy2*zz
             f(n,8)  = fac(8)*f0*xx*zz2
             f(n,9)  = fac(9)*f0*yy*zz2
             f(n,10) = fac(10)*f0*xx*yy*zz
          end
        case default ! General l function ...........
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l)
          by.create(0,.l)
          bz.create(0,.l)
          do n = 1,n_pt
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             f0 = sum( .cc * exp( -rr * .ex ))
             ! Cartesian orbital part
             ! x**b,y**b,z**b for b=0,.l
             bx(0) = ONE;   by(0) = ONE;   bz(0) = ONE
             bx(1) = xx;    by(1) = yy;    bz(1) = zz
             bxb = xx;      byb = yy;      bzb = zz
             do b=2,.l
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Combine cartesian orbital powers with the exponential part
             f(n,:) = fac(:)*f0*bx(nx(:))*by(ny(:))*bz(nz(:))
          end
          bz.destroy; by.destroy; bx.destroy
      end
   end

   make_skip_grid(f,n_keep,n_comp,x,y,z,r2,skip,n_pt) ::: public
   ! Return "f(i,n)", the value of the shell component "n" on grid
   ! point "i".  "x", "y", "z" are precomputed differences between the
   ! points "pt" and the shell center, "r2" is a precomputed array for
   ! the square of the distance from the points "pt" to ".pos". "skip"
   ! is an array to skip elements too small ...  see make_skip_list.
   ! NOTE: it is assumed that the shell is normalised to the component
   ! x^2; the appropriate double factorial normalising factors are
   ! must be introduced for each component (if required) so that each
   ! component is properly normalised.
      f :: MAT{REAL}(n_keep,n_comp), OUT
      x,y,z,r2 :: VEC{REAL}(n_pt), IN
      skip :: VEC{BIN}(n_pt), IN
      n_keep,n_comp,n_pt :: INT, IN
 ! ENSURE(f.dim1==x.dim,"inconsistent f and x")
 ! ENSURE(f.dim1==y.dim,"inconsistent f and x")
 ! ENSURE(f.dim1==z.dim,"inconsistent f and x")
      fac,bx,by,bz :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n,i,b, ff,lf :: INT
      rr,xx,yy,zz,f0,f1,bxb,byb,bzb :: REAL
      xx2,yy2,zz2,xx3,yy3,zz3,zz_f1 :: REAL

      select case (.l)

        case (0) ! S function ...........
          i = 0
          do n = 1,n_pt
             if (skip(n)) cycle
             i = i + 1
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             f(i,1) = sum(.cc * exp( -rr * .ex ))
          end

        case (1) ! P function ...........
          i = 0
          do n = 1,n_pt
             if (skip(n)) cycle
             i = i + 1
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             f0 = sum(.cc * exp( -rr * .ex ))
             f(i,1) = xx*f0
             f(i,2) = yy*f0
             f(i,3) = zz*f0
          end

        case (2) ! D function ...........
          i = 0
          do n = 1,n_pt
             if (skip(n)) cycle
             i = i + 1
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             f0 = sum(.cc * exp( -rr * .ex ))
             f1 = sqrt(THREE)*f0
             zz_f1 = zz*f1
             f(i,1) = xx*xx*f0
             f(i,2) = yy*yy*f0
             f(i,3) = zz*zz*f0
             f(i,4) = xx*yy*f1
             f(i,5) = xx*zz_f1
             f(i,6) = yy*zz_f1
          end

        case (3) ! F function ...........
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          i = 0
          do n = 1,n_pt
             if (skip(n)) cycle
             i = i + 1
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             xx2 = xx*xx
             yy2 = yy*yy
             zz2 = zz*zz
             xx3 = xx2*xx
             yy3 = yy2*yy
             zz3 = zz2*zz
             f0 = sum(.cc * exp( -rr * .ex ))
             f(i,1)  = fac(1)*f0*xx3
             f(i,2)  = fac(2)*f0*yy3
             f(i,3)  = fac(3)*f0*zz3
             f(i,4)  = fac(4)*f0*xx2*yy
             f(i,5)  = fac(5)*f0*xx2*zz
             f(i,6)  = fac(6)*f0*xx*yy2
             f(i,7)  = fac(7)*f0*yy2*zz
             f(i,8)  = fac(8)*f0*xx*zz2
             f(i,9)  = fac(9)*f0*yy*zz2
             f(i,10) = fac(10)*f0*xx*yy*zz
          end

        case default ! General l function ...........
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l)
          by.create(0,.l)
          bz.create(0,.l)
          i = 0
          do n = 1,n_pt
             if (skip(n)) cycle
             i = i + 1
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             f0 = sum( .cc * exp( -rr * .ex ))
             ! Cartesian orbital part
             ! x**b,y**b,z**b for b=0,.l
             bx(0) = ONE;   by(0) = ONE;   bz(0) = ONE
             bx(1) = xx;    by(1) = yy;    bz(1) = zz
             bxb = xx;      byb = yy;      bzb = zz
             do b=2,.l
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Combine cartesian orbital powers with the exponential part
             f(i,:) = fac(:)*f0*bx(nx(:))*by(ny(:))*bz(nz(:))
          end
          bz.destroy; by.destroy; bx.destroy

      end
   end

!   make_grid(f,skip,x,y,z,r2,cutoff)
!   ! Return "f(i,n)", the value of the shell component "n" on grid point "i".
!   ! "x", "y", "z" are the differences between the points "pt" and the shell
!   ! center, "r2" is an array for the square of the distance from the points
!   ! "pt" to ".pos". These arrays can be efficiently precalculated under some
!   ! circumstances, when shell belonging to a whole atom are being calculated.
!   ! NOTE: it is assumed that the shell is normalised to the component x^2; the
!   ! appropriate double factorial normalising factors are introduced for each
!   ! component (if required) so that each component is properly normalised.
!      f :: MAT{REAL}, OUT
!      skip :: VEC{BIN}
!      x,y,z,r2 :: VEC{REAL}, IN
!      cutoff :: REAL
!   ENSURE(f.dim1==x.dim,"inconsistent f and x")
!   ENSURE(f.dim1==y.dim,"inconsistent f and x")
!   ENSURE(f.dim1==z.dim,"inconsistent f and x")
!      fac,bx,by,bz :: VEC{REAL}*
!      nx,ny,nz :: VEC{INT}*
!      n_pt,n,b :: INT
!      big :: BIN
!      rr,xx,yy,zz,f0,f1,bxb,byb,bzb :: REAL
!      alpha,r_max,r2_max,xx2,yy2,zz2,xx3,yy3,zz3,zz_f1 :: REAL
!      n_pt = x.dim
!      f = ZERO
!      alpha = ONE/minval(.ex)
!      if (cutoff<=ZERO) then; r2_max = huge(ONE)
!      else;    r_max = sqrt(-alpha*log(cutoff)); r2_max = r_max*r_max
!      end
!      select case (.l)
!        case (0) ! S function ...........
!          do n = 1,n_pt
!             xx = x(n); yy = y(n); zz = z(n)
!             rr = r2(n)
!             big = rr>r2_max
!             skip(n) = big
!             if (big) cycle
!             f(n,1) = sum(.cc * exp( -rr * .ex ))
!          end
!        case (1) ! P function ...........
!          do n = 1,n_pt
!             xx = x(n); yy = y(n); zz = z(n)
!             rr = r2(n)
!             big = rr>r2_max
!             skip(n) = big
!             if (big) cycle
!             f0 = sum(.cc * exp( -rr * .ex ))
!             f(n,1) = xx*f0
!             f(n,2) = yy*f0
!             f(n,3) = zz*f0
!          end
!        case (2) ! D function ...........
!          do n = 1,n_pt
!             xx = x(n); yy = y(n); zz = z(n)
!             rr = r2(n)
!             big = rr>r2_max
!             skip(n) = big
!             if (big) cycle
!             f0 = sum(.cc * exp( -rr * .ex ))
!             f1 = sqrt(THREE)*f0
!             zz_f1 = zz*f1
!             f(n,1) = xx*xx*f0
!             f(n,2) = yy*yy*f0
!             f(n,3) = zz*zz*f0
!             f(n,4) = xx*yy*f1
!             f(n,5) = xx*zz_f1
!             f(n,6) = yy*zz_f1
!          end
!        case (3) ! F function ...........
!          fac.create(.n_comp)
!          .set_normalising_factors(fac)
!          do n = 1,n_pt
!             xx = x(n); yy = y(n); zz = z(n)
!             rr = r2(n)
!             big = rr>r2_max
!             skip(n) = big
!             if (big) cycle
!             xx2 = xx*xx
!             yy2 = yy*yy
!             zz2 = zz*zz
!             xx3 = xx2*xx
!             yy3 = yy2*yy
!             zz3 = zz2*zz
!             f0 = sum(.cc * exp( -rr * .ex ))
!             f(n,1)  = fac(1)*f0*xx3
!             f(n,2)  = fac(2)*f0*yy3
!             f(n,3)  = fac(3)*f0*zz3
!             f(n,4)  = fac(4)*f0*xx2*yy
!             f(n,5)  = fac(5)*f0*xx2*zz
!             f(n,6)  = fac(6)*f0*xx*yy2
!             f(n,7)  = fac(7)*f0*yy2*zz
!             f(n,8)  = fac(8)*f0*xx*zz2
!             f(n,9)  = fac(9)*f0*yy*zz2
!             f(n,10) = fac(10)*f0*xx*yy*zz
!          end
!          fac.destroy
!        case default ! General l function ...........
!          fac.create(.n_comp)
!          nx.create(.n_comp); ny.create(.n_comp); nz.create(.n_comp)
!          fac.set_normalising_factors(fac,nx,ny,nz)
!          bx.create(0,.l)
!          by.create(0,.l)
!          bz.create(0,.l)
!          do n = 1,n_pt
!             xx = x(n); yy = y(n); zz = z(n)
!             rr = r2(n)
!             big = rr>r2_max
!             skip(n) = big
!             if (big) cycle
!             f0 = sum( .cc * exp( -rr * .ex ))
!             ! Cartesian orbital part
!             ! x**b,y**b,z**b for b=0,.l
!             bx(0) = ONE;   by(0) = ONE;   bz(0) = ONE
!             bx(1) = xx;    by(1) = yy;    bz(1) = zz
!             bxb = xx;      byb = yy;      bzb = zz
!             do b=2,.l
!               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
!               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
!             end
!             ! Combine cartesian orbital powers with the exponential part
!             f(n,:) = fac(:)*f0*bx(nx(:))*by(ny(:))*bz(nz(:))
!          end
!          bz.destroy; by.destroy; bx.destroy
!          nz.destroy; ny.destroy; nx.destroy
!          fac.destroy
!     end
!   end


   make_nabla_grid(g,pt)
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      g :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(size(pt,2)==3,"pt matrix incorrectly dimensioned")
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,facb :: REAL
      g0,g1,g1x,g1y,g1z,x,y,z,bxb,byb,bzb :: REAL
      n_pt = size(pt,1)
      x = .pos(1);  y = .pos(2);  z = .pos(3)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             rr = xx*xx + yy*yy + zz*zz
             g1 = -TWO*sum(.ex*.cc*exp(-.ex*rr))
             g(n,1,1) = g1*xx
             g(n,1,2) = g1*yy
             g(n,1,3) = g1*zz
          end
        case (1)
          cc_exp_rr.create(.n_cc)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             rr = xx*xx + yy*yy + zz*zz
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             g(n,1,1) = g0+xx*g1x
             g(n,1,2) = xx*g1y
             g(n,1,3) = xx*g1z
             g(n,2,1) = yy*g1x
             g(n,2,2) = g0+yy*g1y
             g(n,2,3) = yy*g1z
             g(n,3,1) = zz*g1x
             g(n,3,2) = zz*g1y
             g(n,3,3) = g0+zz*g1z
          end
          cc_exp_rr.destroy
        case default
          cc_exp_rr.create(.n_cc)
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
          gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             rr = xx*xx + yy*yy + zz*zz
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
             bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
             bx(1) = xx;          by(1) = yy;          bz(1) = zz
             bxb = xx;            byb = yy;            bzb = zz
             gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
             gxb(1) = g0+xx*g1x;  gyb(1) = g0+yy*g1y;  gzb(1) = g0+zz*g1z
             do b=2,.l
               gxb(b) = (b*g0+xx*g1x) * bxb           ! (n-1)th power
               gyb(b) = (b*g0+yy*g1y) * byb           ! of the xyz part
               gzb(b) = (b*g0+zz*g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Loop over basis functions
             do b = 1,.n_comp
                nxb = nx(b)
                nyb = ny(b)
                nzb = nz(b)
                facb = fac(b)         ! Basis fn. normalisation factor
                g(n,b,1) = facb * gxb(nxb) *  by(nyb) *  bz(nzb)
                g(n,b,2) = facb *  bx(nxb) * gyb(nyb) *  bz(nzb)
                g(n,b,3) = facb *  bx(nxb) *  by(nyb) * gzb(nzb)
             end
          end
          gzb.destroy;  gyb.destroy;  gxb.destroy
          bz.destroy;   by.destroy;   bx.destroy
          cc_exp_rr.destroy
      end
   end

   make_nabla_grid(g,x,y,z,r2,cutoff)
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      g :: MAT3{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb :: REAL
      alpha,r_max,r2_max,xx,yy,zz,rr,facb :: REAL
      n_pt = x.dim
      g = ZERO
      alpha = ONE/minval(.ex)
      if (cutoff<=ZERO) then; r2_max = huge(ONE)
      else;    r_max = sqrt(-alpha*log(cutoff)); r2_max = r_max*r_max
      end
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             g1 = -TWO*sum(.ex*.cc*exp(-.ex*rr))
             g(n,1,1) = g1*xx
             g(n,1,2) = g1*yy
             g(n,1,3) = g1*zz
          end
        case (1)
          cc_exp_rr.create(.n_cc)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             g(n,1,1) = g0+xx*g1x
             g(n,1,2) = xx*g1y
             g(n,1,3) = xx*g1z
             g(n,2,1) = yy*g1x
             g(n,2,2) = g0+yy*g1y
             g(n,2,3) = yy*g1z
             g(n,3,1) = zz*g1x
             g(n,3,2) = zz*g1y
             g(n,3,3) = g0+zz*g1z
          end
          cc_exp_rr.destroy
        case default
          cc_exp_rr.create(.n_cc)
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
          gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
             bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
             bx(1) = xx;          by(1) = yy;          bz(1) = zz
             bxb = xx;            byb = yy;            bzb = zz
             gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
             gxb(1) = g0+xx*g1x;  gyb(1) = g0+yy*g1y;  gzb(1) = g0+zz*g1z
             do b=2,.l
               gxb(b) = (b*g0+xx*g1x) * bxb           ! (n-1)th power
               gyb(b) = (b*g0+yy*g1y) * byb           ! of the xyz part
               gzb(b) = (b*g0+zz*g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Loop over basis functions
             do b = 1,.n_comp
                nxb = nx(b)
                nyb = ny(b)
                nzb = nz(b)
                facb = fac(b)         ! Basis fn. normalisation factor
                g(n,b,1) = facb * gxb(nxb) *  by(nyb) *  bz(nzb)
                g(n,b,2) = facb *  bx(nxb) * gyb(nyb) *  bz(nzb)
                g(n,b,3) = facb *  bx(nxb) *  by(nyb) * gzb(nzb)
             end
          end
          gzb.destroy;  gyb.destroy;  gxb.destroy
          bz.destroy;   by.destroy;   bx.destroy
          cc_exp_rr.destroy
      end
   end


   make_nabla_grid(g,f,pt)
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)". Also return the
   ! "f(i,n)" the value of the shell component "n" on grid point "i". It is more
   ! efficient to compute both at once.
      f :: MAT{REAL}, OUT
      g :: MAT3{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(size(pt,2)==3,"pt matrix incorrectly dimensioned")
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,x,y,z,bxb,byb,bzb,by_bz,facb_bx :: REAL
      n_pt = size(pt,1)
      x = .pos(1);  y = .pos(2);  z = .pos(3)
      cc_exp_rr.create(.n_cc)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             rr = xx*xx + yy*yy + zz*zz
             cc_exp_rr = .cc*exp(-.ex*rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             f(n,1)   = sum(cc_exp_rr)
             g(n,1,1) = g1*xx
             g(n,1,2) = g1*yy
             g(n,1,3) = g1*zz
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             rr = xx*xx + yy*yy + zz*zz
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             f(n,1) = xx*g0
             f(n,2) = yy*g0
             f(n,3) = zz*g0
             g(n,1,1) = g0+xx*g1x
             g(n,1,2) = xx*g1y
             g(n,1,3) = xx*g1z
             g(n,2,1) = yy*g1x
             g(n,2,2) = g0+yy*g1y
             g(n,2,3) = yy*g1z
             g(n,3,1) = zz*g1x
             g(n,3,2) = zz*g1y
             g(n,3,3) = g0+zz*g1z
          end
        case default
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
          gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             ! Radial part, summed over primitives
             rr = xx*xx + yy*yy + zz*zz
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             ! Cartesian orbital part
             ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             xx_g1x = xx*g1x
             yy_g1y = yy*g1y
             zz_g1z = zz*g1z
             bxb = xx;            byb = yy;            bzb = zz
             bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
             bx(1) = xx;          by(1) = yy;          bz(1) = zz
             gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
             gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
             do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Combine cartesian orbital powers with the exponential part
             do b = 1,.n_comp
               nxb = nx(b)
               nyb = ny(b)
               nzb = nz(b)
               facb = fac(b)         ! Basis fn. normalisation factor
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               facb_bx = facb  *  bxb
               f(n,b)   = facb_bx * by_bz * g0
               g(n,b,1) = facb    * gxb(nxb) * by_bz
               g(n,b,2) = facb_bx * gyb(nyb) * bzb
               g(n,b,3) = facb_bx * byb      * gzb(nzb)
             end

          end
          gzb.destroy;  gyb.destroy;  gxb.destroy
          bz.destroy;   by.destroy;   bx.destroy
      end
      cc_exp_rr.destroy
   end

   make_nabla_grid(g,f,x,y,z,r2)
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)". Also return the
   ! "f(i,n)" the value of the shell component "n" on grid point "i". It is more
   ! efficient to compute both at once.  "x", "y", "z" are the differences
   ! between the points "pt" and the shell center, "r2" is an array for the
   ! square of the distance from the points "pt" to ".pos". These arrays can be
   ! efficiently precalculated under some circumstances, when shell belonging to
   ! a whole atom are being calculated.
      f :: MAT{REAL}, OUT
      g :: MAT3{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz,facb_bx :: REAL
      n_pt = x.dim
      g = ZERO
      f = ZERO
      cc_exp_rr.create(.n_cc)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             cc_exp_rr = .cc*exp(-.ex*rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             f(n,1)   = sum(cc_exp_rr)
             g(n,1,1) = g1*xx
             g(n,1,2) = g1*yy
             g(n,1,3) = g1*zz
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             f(n,1) = xx*g0
             f(n,2) = yy*g0
             f(n,3) = zz*g0
             g(n,1,1) = g0+xx*g1x
             g(n,1,2) = xx*g1y
             g(n,1,3) = xx*g1z
             g(n,2,1) = yy*g1x
             g(n,2,2) = g0+yy*g1y
             g(n,2,3) = yy*g1z
             g(n,3,1) = zz*g1x
             g(n,3,2) = zz*g1y
             g(n,3,3) = g0+zz*g1z
          end
        case default
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
          gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             ! Cartesian orbital part
             ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             xx_g1x = xx*g1x
             yy_g1y = yy*g1y
             zz_g1z = zz*g1z
             bxb = xx;            byb = yy;            bzb = zz
             bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
             bx(1) = xx;          by(1) = yy;          bz(1) = zz
             gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
             gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
             do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Combine cartesian orbital powers with the exponential part
             do b = 1,.n_comp
               nxb = nx(b)
               nyb = ny(b)
               nzb = nz(b)
               facb = fac(b)         ! Basis fn. normalisation factor
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               facb_bx = facb  *  bxb
               f(n,b)   = facb_bx * by_bz * g0
               g(n,b,1) = facb    * gxb(nxb) * by_bz
               g(n,b,2) = facb_bx * gyb(nyb) * bzb
               g(n,b,3) = facb_bx * byb      * gzb(nzb)
             end
          end
          gzb.destroy;  gyb.destroy;  gxb.destroy
          bz.destroy;   by.destroy;   bx.destroy
      end
      cc_exp_rr.destroy
   end

   make_nabla_grid(g,f,x,y,z,r2,cutoff)
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)". Also return the
   ! "f(i,n)" the value of the shell component "n" on grid point "i". It is more
   ! efficient to compute both at once.  "x", "y", "z" are the differences
   ! between the points "pt" and the shell center, "r2" is an array for the
   ! square of the distance from the points "pt" to ".pos". These arrays can be
   ! efficiently precalculated under some circumstances, when shell belonging to
   ! a whole atom are being calculated.
      f :: MAT{REAL}, OUT
      g :: MAT3{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      r2_max,xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz,facb_bx :: REAL
      n_pt = x.dim
      g = ZERO
      f = ZERO
      r2_max = .r2_max(cutoff)
      cc_exp_rr.create(.n_cc)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             cc_exp_rr = .cc*exp(-.ex*rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             f(n,1)   = sum(cc_exp_rr)
             g(n,1,1) = g1*xx
             g(n,1,2) = g1*yy
             g(n,1,3) = g1*zz
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             f(n,1) = xx*g0
             f(n,2) = yy*g0
             f(n,3) = zz*g0
             g(n,1,1) = g0+xx*g1x
             g(n,1,2) = xx*g1y
             g(n,1,3) = xx*g1z
             g(n,2,1) = yy*g1x
             g(n,2,2) = g0+yy*g1y
             g(n,2,3) = yy*g1z
             g(n,3,1) = zz*g1x
             g(n,3,2) = zz*g1y
             g(n,3,3) = g0+zz*g1z
          end
        case default
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
          gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx = x(n); yy = y(n); zz = z(n)
             rr = r2(n)
             if (rr>r2_max) cycle
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             ! Cartesian orbital part
             ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             xx_g1x = xx*g1x
             yy_g1y = yy*g1y
             zz_g1z = zz*g1z
             bxb = xx;            byb = yy;            bzb = zz
             bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
             bx(1) = xx;          by(1) = yy;          bz(1) = zz
             gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
             gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
             do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Combine cartesian orbital powers with the exponential part
             do b = 1,.n_comp
               nxb = nx(b)
               nyb = ny(b)
               nzb = nz(b)
               facb = fac(b)         ! Basis fn. normalisation factor
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               facb_bx = facb  *  bxb
               f(n,b)   = facb_bx * by_bz * g0
               g(n,b,1) = facb    * gxb(nxb) * by_bz
               g(n,b,2) = facb_bx * gyb(nyb) * bzb
               g(n,b,3) = facb_bx * byb      * gzb(nzb)
             end
          end
          gzb.destroy;  gyb.destroy;  gxb.destroy
          bz.destroy;   by.destroy;   bx.destroy
      end
      cc_exp_rr.destroy
   end

!   make_nabla_grid(g,f,skip,x,y,z,r2,cutoff)
!   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
!   ! on grid point "i" given a set of grid points "pt(i,1:3)". Also return the
!   ! "f(i,n)" the value of the shell component "n" on grid point "i". It is more
!   ! efficient to compute both at once.  "x", "y", "z" are the differences
!   ! between the points "pt" and the shell center, "r2" is an array for the
!   ! square of the distance from the points "pt" to ".pos". These arrays can be
!   ! efficiently precalculated under some circumstances, when shell belonging to
!   ! a whole atom are being calculated.
!      f :: MAT{REAL}, OUT
!      g :: MAT3{REAL}, OUT
!      skip :: VEC{BIN}, OUT
!      x,y,z,r2 :: VEC{REAL}, IN
!      cutoff :: REAL, IN
!      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
!      nx,ny,nz :: VEC{INT}*
!      big :: BIN
!      n_pt,n,b,nxb,nyb,nzb :: INT
!      r2_max,xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
!      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz,facb_bx :: REAL
!      n_pt = x.dim
!      g = ZERO
!      f = ZERO
!      r2_max = .r2_max(cutoff)
!      cc_exp_rr.create(.n_cc)
!      select case (.l)
!        case (0)
!          do n = 1,n_pt              ! Do the exponential part of the gaussian
!             xx = x(n); yy = y(n); zz = z(n)
!             ! Radial part, summed over primitives
!             rr = r2(n)
!             big = rr>r2_max
!             skip(n) = big
!             if (big) cycle
!             cc_exp_rr = .cc*exp(-.ex*rr)
!             g1 = -TWO*sum(.ex*cc_exp_rr)
!
!             f(n,1)   = sum(cc_exp_rr)
!             g(n,1,1) = g1*xx
!             g(n,1,2) = g1*yy
!             g(n,1,3) = g1*zz
!          end
!        case (1)
!          do n = 1,n_pt              ! Do the exponential part of the gaussian
!             xx = x(n); yy = y(n); zz = z(n)
!             ! Radial part, summed over primitives
!             rr = r2(n)
!             big = rr>r2_max
!             skip(n) = big
!             if (big) cycle
!             cc_exp_rr = .cc*exp(-.ex*rr)
!             g0 = sum(cc_exp_rr)
!             g1 = -TWO*sum(.ex*cc_exp_rr)
!
!             g1x = g1*xx
!             g1y = g1*yy
!             g1z = g1*zz
!             f(n,1) = xx*g0
!             f(n,2) = yy*g0
!             f(n,3) = zz*g0
!             g(n,1,1) = g0+xx*g1x
!             g(n,1,2) = xx*g1y
!             g(n,1,3) = xx*g1z
!             g(n,2,1) = yy*g1x
!             g(n,2,2) = g0+yy*g1y
!             g(n,2,3) = yy*g1z
!             g(n,3,1) = zz*g1x
!             g(n,3,2) = zz*g1y
!             g(n,3,3) = g0+zz*g1z
!          end
!        case default
!          fac.create(.n_comp)
!          nx.create(.n_comp); ny.create(.n_comp); nz.create(.n_comp)
!          .set_normalising_factors(fac,nx,ny,nz)
!          bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
!          gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
!          do n = 1,n_pt              ! Do the exponential part of the gaussian
!             xx = x(n); yy = y(n); zz = z(n)
!             ! Radial part, summed over primitives
!             rr = r2(n)
!             big = rr>r2_max
!             skip(n) = big
!             if (big) cycle
!             cc_exp_rr = .cc*exp(-.ex*rr)
!             g0 = sum(cc_exp_rr)
!             g1 = -TWO*sum(.ex*cc_exp_rr)
!             ! Cartesian orbital part
!             ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
!             g1x = g1*xx
!             g1y = g1*yy
!             g1z = g1*zz
!             xx_g1x = xx*g1x
!             yy_g1y = yy*g1y
!             zz_g1z = zz*g1z
!             bxb = xx;            byb = yy;            bzb = zz
!             bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
!             bx(1) = xx;          by(1) = yy;          bz(1) = zz
!             gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
!             gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
!             do b=2,.l
!               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
!               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
!               gzb(b) = (b*g0+zz_g1z) * bzb
!               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
!               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
!             end
!             ! Combine cartesian orbital powers with the exponential part
!             do b = 1,.n_comp
!               nxb = nx(b)
!               nyb = ny(b)
!               nzb = nz(b)
!               facb = fac(b)         ! Basis fn. normalisation factor
!               bxb = bx(nxb)
!               byb = by(nyb)
!               bzb = bz(nzb)
!               by_bz = byb *  bzb
!               facb_bx = facb  *  bxb
!               f(n,b)   = facb_bx * by_bz * g0
!               g(n,b,1) = facb    * gxb(nxb) * by_bz
!               g(n,b,2) = facb_bx * gyb(nyb) * bzb
!               g(n,b,3) = facb_bx * byb      * gzb(nzb)
!             end
!
!          end
!          gzb.destroy;  gyb.destroy;  gxb.destroy
!          bz.destroy;   by.destroy;   bx.destroy
!          nz.destroy; ny.destroy; nx.destroy
!          fac.destroy
!      end
!      cc_exp_rr.destroy
!   end


   make_nabla_grid(Gx,Gy,Gz,F,pt)
   ! Return "Gj(i,n)", the value of the gradient with respect to coordinate "j"
   ! of the shell component "n", evaluated at grid point "i", given a set of
   ! grid points "pt(i,1:3)". Likewise, "F(i,n)" is the value of the shell
   ! component "n" evaluated at grid point "i". It is more eficient to compute
   ! both "Gn" and "F" at once. The "Gn" are presented as separate components to
   ! allow contiguous memory access for the calling routine.  
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      pt :: MAT{REAL}, IN
   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
   ENSURE(Gx.is_same_shape_as(F) ,"Gx and F incompatible")
   ENSURE(pt.dim2==3,"pt matrix incorrectly dimensioned")
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,x,y,z,bxb,byb,bzb,by_bz,facb_bx :: REAL
      n_pt = size(pt,1)
      x = .pos(1);  y = .pos(2);  z = .pos(3)
      cc_exp_rr.create(.n_cc)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             rr = xx*xx + yy*yy + zz*zz
             cc_exp_rr = .cc*exp(-.ex*rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             F(n,1)   = sum(cc_exp_rr)
             Gx(n,1) = g1*xx
             Gy(n,1) = g1*yy
             Gz(n,1) = g1*zz
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             rr = xx*xx + yy*yy + zz*zz
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             F(n,1) = xx*g0
             F(n,2) = yy*g0
             F(n,3) = zz*g0
             Gx(n,1) = g0+xx*g1x
             Gy(n,1) = xx*g1y
             Gz(n,1) = xx*g1z
             Gx(n,2) = yy*g1x
             Gy(n,2) = g0+yy*g1y
             Gz(n,2) = yy*g1z
             Gx(n,3) = zz*g1x
             Gy(n,3) = zz*g1y
             Gz(n,3) = g0+zz*g1z
          end
        case default
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
          gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             xx=pt(n,1) - x;   yy=pt(n,2) - y;   zz=pt(n,3) - z
             ! Radial part, summed over primitives
             rr = xx*xx + yy*yy + zz*zz
             cc_exp_rr = .cc*exp(-.ex*rr)
             g0 = sum(cc_exp_rr)
             g1 = -TWO*sum(.ex*cc_exp_rr)
             ! Cartesian orbital part
             ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             xx_g1x = xx*g1x
             yy_g1y = yy*g1y
             zz_g1z = zz*g1z
             bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
             bx(1) = xx;          by(1) = yy;          bz(1) = zz
             bxb = xx;            byb = yy;            bzb = zz
             gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
             gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
             do b=2,.l
               gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
               gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
               gzb(b) = (b*g0+zz_g1z) * bzb
               bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
               bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
             end
             ! Combine cartesian orbital powers with the exponential part
             do b = 1,.n_comp
               nxb = nx(b)
               nyb = ny(b)
               nzb = nz(b)
               facb = fac(b)         ! Basis fn. normalisation factor
               bxb = bx(nxb)
               byb = by(nyb)
               bzb = bz(nzb)
               by_bz = byb *  bzb
               facb_bx = facb  *  bxb
               F(n,b)   = facb_bx * by_bz * g0
               Gx(n,b) = facb    * gxb(nxb) * by_bz
               Gy(n,b) = facb_bx * gyb(nyb) * bzb
               Gz(n,b) = facb_bx * byb      * gzb(nzb)
             end

          end
          gzb.destroy;  gyb.destroy;  gxb.destroy
          bz.destroy;   by.destroy;   bx.destroy
      end
      cc_exp_rr.destroy
   end


   make_nabla_grid(Gx,Gy,Gz,F,x,y,z,r2)
   ! Return "Gj(i,n)", the value of the gradient with respect to coordinate "j"
   ! of the shell component "n", evaluated at grid point "i", given a set of
   ! grid points "pt(i,1:3)". Likewise, "F(i,n)" is the value of the shell
   ! component "n" evaluated at grid point "i". It is more eficient to compute
   ! both "Gn" and "F" at once. The "Gn" are presented as separate components to
   ! allow contiguous memory access for the calling routine.  "x", "y", "z" are
   ! the differences between the points "pt" and the shell center, "r2" is an
   ! array for the square of the distance from the points "pt" to ".pos". These
   ! arrays can be efficiently precalculated under some circumstances, when
   ! shell belonging to a whole atom are being calculated.
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
   ENSURE(Gx.is_same_shape_as(F) ,"Gx and F incompatible")
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      r2_max,xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz,facb_bx :: REAL
      n_pt = x.dim
      F = ZERO
      Gx = ZERO
      Gy = ZERO
      Gz = ZERO
      cc_exp_rr.create(.n_cc)
      select case (.l)
         case (0)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               xx = x(n); yy = y(n); zz = z(n)
               rr = r2(n)
               cc_exp_rr = .cc*exp(-.ex*rr)
               g1 = -TWO*sum(.ex*cc_exp_rr)
               F(n,1)  = sum(cc_exp_rr)
               Gx(n,1) = g1*xx
               Gy(n,1) = g1*yy
               Gz(n,1) = g1*zz
            end
         case (1)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               xx = x(n); yy = y(n); zz = z(n)
               rr = r2(n)
               cc_exp_rr = .cc*exp(-.ex*rr)
               g0 = sum(cc_exp_rr)
               g1 = -TWO*sum(.ex*cc_exp_rr)
               g1x = g1*xx
               g1y = g1*yy
               g1z = g1*zz
               F(n,1) = xx*g0
               F(n,2) = yy*g0
               F(n,3) = zz*g0
               Gx(n,1) = g0+xx*g1x
               Gy(n,1) = xx*g1y
               Gz(n,1) = xx*g1z
               Gx(n,2) = yy*g1x
               Gy(n,2) = g0+yy*g1y
               Gz(n,2) = yy*g1z
               Gx(n,3) = zz*g1x
               Gy(n,3) = zz*g1y
               Gz(n,3) = g0+zz*g1z
            end
         case default
            GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
            ff = .first_gaussian; lf = .last_gaussian
            fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
            nx  => GAUSSIAN_DATA::px(ff:lf)
            ny  => GAUSSIAN_DATA::py(ff:lf)
            nz  => GAUSSIAN_DATA::pz(ff:lf)
            bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
            gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               xx = x(n); yy = y(n); zz = z(n)
               ! Radial part, summed over primitives
               rr = r2(n)
               cc_exp_rr = .cc*exp(-.ex*rr)
               g0 = sum(cc_exp_rr)
               g1 = -TWO*sum(.ex*cc_exp_rr)
               ! Cartesian orbital part
               ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
               g1x = g1*xx
               g1y = g1*yy
               g1z = g1*zz
               xx_g1x = xx*g1x
               yy_g1y = yy*g1y
               zz_g1z = zz*g1z
               bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
               bx(1) = xx;          by(1) = yy;          bz(1) = zz
               bxb = xx;            byb = yy;            bzb = zz
               gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
               gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
               do b=2,.l
                 gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
                 gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
                 gzb(b) = (b*g0+zz_g1z) * bzb
                 bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
                 bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
               end
               ! Combine cartesian orbital powers with the exponential part
               do b = 1,.n_comp
                 nxb = nx(b)
                 nyb = ny(b)
                 nzb = nz(b)
                 facb = fac(b)         ! Basis fn. normalisation factor
                 bxb = bx(nxb)
                 byb = by(nyb)
                 bzb = bz(nzb)
                 by_bz = byb *  bzb
                 facb_bx = facb  *  bxb
                 F(n,b)   = facb_bx * by_bz * g0
                 Gx(n,b) = facb    * gxb(nxb) * by_bz
                 Gy(n,b) = facb_bx * gyb(nyb) * bzb
                 Gz(n,b) = facb_bx * byb      * gzb(nzb)
               end
            end
            gzb.destroy;  gyb.destroy;  gxb.destroy
            bz.destroy;   by.destroy;   bx.destroy
      end
      cc_exp_rr.destroy
   end

   make_nabla_grid(Gx,Gy,Gz,F0,skip_all,x,y,z,r2,cutoff)
   ! Return "Gj(i,n)", the value of the gradient with respect to coordinate "j"
   ! of the shell component "n", evaluated at grid point "i", given a set of
   ! grid points "pt(i,1:3)". Likewise, "F0(i,n)" is the value of the shell
   ! component "n" evaluated at grid point "i". It is more eficient to compute
   ! both "Gn" and "F" at once. The "Gn" are presented as separate components to
   ! allow contiguous memory access for the calling routine.  "x", "y", "z" are
   ! the differences between the points "pt" and the shell center, "r2" is an
   ! array for the square of the distance from the points "pt" to ".pos". These
   ! arrays can be efficiently precalculated under some circumstances, when
   ! shell belonging to a whole atom are being calculated.
      Gx,Gy,Gz,F0 :: MAT{REAL}, OUT
      skip_all :: VEC{BIN}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN
   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
   ENSURE(Gx.is_same_shape_as(F0),"Gx and F0 incompatible")
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      r2_max,xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz,facb_bx :: REAL
      n_pt = x.dim
      r2_max = .r2_max(cutoff)
      F0 = ZERO
      Gx = ZERO
      Gy = ZERO
      Gz = ZERO
      skip_all = TRUE
      cc_exp_rr.create(.n_cc)
      select case (.l)
         case (0)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               xx = x(n); yy = y(n); zz = z(n)
               rr = r2(n)
               if (rr>r2_max) cycle
               skip_all(1) = FALSE
               cc_exp_rr = .cc*exp(-.ex*rr)
               g0 = sum(cc_exp_rr)
               F0(n,1) = g0
               g1 = -TWO*sum(.ex*cc_exp_rr)
               Gx(n,1) = g1*xx
               Gy(n,1) = g1*yy
               Gz(n,1) = g1*zz
            end
         case (1)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               xx = x(n); yy = y(n); zz = z(n)
               rr = r2(n)
               if (rr>r2_max) cycle
               skip_all(1:3) = FALSE
               cc_exp_rr = .cc*exp(-.ex*rr)
               g0 = sum(cc_exp_rr)
               g1x = xx*g0
               g1y = yy*g0
               g1z = zz*g0
               F0(n,1) = g1x
               F0(n,2) = g1y
               F0(n,3) = g1z
               g1 = -TWO*sum(.ex*cc_exp_rr)
               g1x = g1*xx
               g1y = g1*yy
               g1z = g1*zz
               Gx(n,1) = g0+xx*g1x
               Gy(n,1) = xx*g1y
               Gz(n,1) = xx*g1z
               Gx(n,2) = yy*g1x
               Gy(n,2) = g0+yy*g1y
               Gz(n,2) = yy*g1z
               Gx(n,3) = zz*g1x
               Gy(n,3) = zz*g1y
               Gz(n,3) = g0+zz*g1z
            end
         case default
            GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
            ff = .first_gaussian; lf = .last_gaussian
            fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
            nx  => GAUSSIAN_DATA::px(ff:lf)
            ny  => GAUSSIAN_DATA::py(ff:lf)
            nz  => GAUSSIAN_DATA::pz(ff:lf)
            bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
            gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               xx = x(n); yy = y(n); zz = z(n)
               ! Radial part, summed over primitives
               rr = r2(n)
               if (rr>r2_max) cycle
               skip_all(1:.n_comp) = FALSE
               cc_exp_rr = .cc*exp(-.ex*rr)
               g0 = sum(cc_exp_rr)
               g1 = -TWO*sum(.ex*cc_exp_rr)
               ! Cartesian orbital part
               ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
               g1x = g1*xx
               g1y = g1*yy
               g1z = g1*zz
               xx_g1x = xx*g1x
               yy_g1y = yy*g1y
               zz_g1z = zz*g1z
               bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
               bx(1) = xx;          by(1) = yy;          bz(1) = zz
               bxb = xx;            byb = yy;            bzb = zz
               gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
               gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
               do b=2,.l
                 gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
                 gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
                 gzb(b) = (b*g0+zz_g1z) * bzb
                 bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
                 bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
               end
               ! Combine cartesian orbital powers with the exponential part
               do b = 1,.n_comp
                 nxb = nx(b)
                 nyb = ny(b)
                 nzb = nz(b)
                 facb = fac(b)         ! Basis fn. normalisation factor
                 bxb = bx(nxb)
                 byb = by(nyb)
                 bzb = bz(nzb)
                 by_bz = byb *  bzb
                 facb_bx = facb  *  bxb
                 g1      = facb_bx * by_bz * g0
                 F0(n,b) = g1
                 Gx(n,b) = facb    * gxb(nxb) * by_bz
                 Gy(n,b) = facb_bx * gyb(nyb) * bzb
                 Gz(n,b) = facb_bx * byb      * gzb(nzb)
               end
            end
            gzb.destroy;  gyb.destroy;  gxb.destroy
            bz.destroy;   by.destroy;   bx.destroy
      end
      cc_exp_rr.destroy
   end

!   make_nabla_grid(Gx,Gy,Gz,F0,ex,skip_all,x,y,z,r2,cutoff)
!   ! Return "Gj(i,n)", the value of the gradient with respect to coordinate "j"
!   ! of the shell component "n", evaluated at grid point "i", given a set of
!   ! grid points "pt(i,1:3)". Likewise, "F0(i,n)" is the value of the shell
!   ! component "n" evaluated at grid point "i". It is more eficient to compute
!   ! both "Gn" and "F" at once. The "Gn" are presented as separate components to
!   ! allow contiguous memory access for the calling routine.  "x", "y", "z" are
!   ! the differences between the points "pt" and the shell center, "r2" is an
!   ! array for the square of the distance from the points "pt" to ".pos". These
!   ! arrays can be efficiently precalculated under some circumstances, when
!   ! shell belonging to a whole atom are being calculated.
!      Gx,Gy,Gz,F0 :: MAT{REAL}, OUT
!      ex :: MAT{INT}, OUT
!      skip_all :: VEC{BIN}, OUT
!      x,y,z,r2 :: VEC{REAL}, IN
!      cutoff :: REAL, IN
!   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
!   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
!   ENSURE(Gx.is_same_shape_as(F0),"Gx and F0 incompatible")
!      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
!      nx,ny,nz :: VEC{INT}*
!      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
!      r2_max,xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
!      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz,facb_bx :: REAL
!      n_pt = x.dim
!      r2_max = .r2_max(cutoff)
!      F0 = ZERO
!      Gx = ZERO
!      Gy = ZERO
!      Gz = ZERO
!      ex = exponent(tiny(ONE)*10)
!      skip_all = TRUE
!      cc_exp_rr.create(.n_cc)
!      select case (.l)
!         case (0)
!            do n = 1,n_pt              ! Do the exponential part of the gaussian
!               xx = x(n); yy = y(n); zz = z(n)
!               rr = r2(n)
!               if (rr>r2_max) cycle
!               skip_all(1) = FALSE
!               cc_exp_rr = .cc*exp(-.ex*rr)
!               g0 = sum(cc_exp_rr)
!               F0(n,1) = g0
!               ex(n,1) = exponent(g0)
!               g1 = -TWO*sum(.ex*cc_exp_rr)
!               Gx(n,1) = g1*xx
!               Gy(n,1) = g1*yy
!               Gz(n,1) = g1*zz
!            end
!         case (1)
!            do n = 1,n_pt              ! Do the exponential part of the gaussian
!               xx = x(n); yy = y(n); zz = z(n)
!               rr = r2(n)
!               if (rr>r2_max) cycle
!               skip_all(1:3) = FALSE
!               cc_exp_rr = .cc*exp(-.ex*rr)
!               g0 = sum(cc_exp_rr)
!               g1x = xx*g0
!               g1y = yy*g0
!               g1z = zz*g0
!               F0(n,1) = g1x
!               F0(n,2) = g1y
!               F0(n,3) = g1z
!               ex(n,1) = exponent(g1x)
!               ex(n,2) = exponent(g1y)
!               ex(n,3) = exponent(g1z)
!               g1 = -TWO*sum(.ex*cc_exp_rr)
!               g1x = g1*xx
!               g1y = g1*yy
!               g1z = g1*zz
!               Gx(n,1) = g0+xx*g1x
!               Gy(n,1) = xx*g1y
!               Gz(n,1) = xx*g1z
!               Gx(n,2) = yy*g1x
!               Gy(n,2) = g0+yy*g1y
!               Gz(n,2) = yy*g1z
!               Gx(n,3) = zz*g1x
!               Gy(n,3) = zz*g1y
!               Gz(n,3) = g0+zz*g1z
!            end
!         case default
!            GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
!            ff = .first_gaussian; lf = .last_gaussian
!            fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
!            nx  => GAUSSIAN_DATA::px(ff:lf)
!            ny  => GAUSSIAN_DATA::py(ff:lf)
!            nz  => GAUSSIAN_DATA::pz(ff:lf)
!            bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
!            gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
!            do n = 1,n_pt              ! Do the exponential part of the gaussian
!               xx = x(n); yy = y(n); zz = z(n)
!               ! Radial part, summed over primitives
!               rr = r2(n)
!               if (rr>r2_max) cycle
!               skip_all(1:.n_comp) = FALSE
!               cc_exp_rr = .cc*exp(-.ex*rr)
!               g0 = sum(cc_exp_rr)
!               g1 = -TWO*sum(.ex*cc_exp_rr)
!               ! Cartesian orbital part
!               ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
!               g1x = g1*xx
!               g1y = g1*yy
!               g1z = g1*zz
!               xx_g1x = xx*g1x
!               yy_g1y = yy*g1y
!               zz_g1z = zz*g1z
!               bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
!               bx(1) = xx;          by(1) = yy;          bz(1) = zz
!               bxb = xx;            byb = yy;            bzb = zz
!               gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
!               gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
!               do b=2,.l
!                 gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
!                 gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
!                 gzb(b) = (b*g0+zz_g1z) * bzb
!                 bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
!                 bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
!               end
!               ! Combine cartesian orbital powers with the exponential part
!               do b = 1,.n_comp
!                 nxb = nx(b)
!                 nyb = ny(b)
!                 nzb = nz(b)
!                 facb = fac(b)         ! Basis fn. normalisation factor
!                 bxb = bx(nxb)
!                 byb = by(nyb)
!                 bzb = bz(nzb)
!                 by_bz = byb *  bzb
!                 facb_bx = facb  *  bxb
!                 g1      = facb_bx * by_bz * g0
!                 F0(n,b) = g1
!                 ex(n,b) = exponent(g1)
!                 Gx(n,b) = facb    * gxb(nxb) * by_bz
!                 Gy(n,b) = facb_bx * gyb(nyb) * bzb
!                 Gz(n,b) = facb_bx * byb      * gzb(nzb)
!               end
!            end
!            gzb.destroy;  gyb.destroy;  gxb.destroy
!            bz.destroy;   by.destroy;   bx.destroy
!      end
!      cc_exp_rr.destroy
!   end

   make_nabla_grid(Gx,Gy,Gz,F,x,y,z,r2,cutoff)
   ! Return "Gj(i,n)", the value of the gradient with respect to coordinate "j"
   ! of the shell component "n", evaluated at grid point "i", given a set of
   ! grid points "pt(i,1:3)". Likewise, "F(i,n)" is the value of the shell
   ! component "n" evaluated at grid point "i". It is more eficient to compute
   ! both "Gn" and "F" at once. The "Gn" are presented as separate components to
   ! allow contiguous memory access for the calling routine.  "x", "y", "z" are
   ! the differences between the points "pt" and the shell center, "r2" is an
   ! array for the square of the distance from the points "pt" to ".pos". These
   ! arrays can be efficiently precalculated under some circumstances, when
   ! shell belonging to a whole atom are being calculated.
      Gx,Gy,Gz,F :: MAT{REAL}, OUT
      x,y,z,r2 :: VEC{REAL}, IN
      cutoff :: REAL, IN
   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
   ENSURE(Gx.is_same_shape_as(F) ,"Gx and F incompatible")
      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,nxb,nyb,nzb, ff,lf :: INT
      r2_max,xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz,facb_bx :: REAL
      n_pt = x.dim
      r2_max = .r2_max(cutoff)
      F = ZERO
      Gx = ZERO
      Gy = ZERO
      Gz = ZERO
      cc_exp_rr.create(.n_cc)
      select case (.l)
         case (0)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               rr = r2(n)
               if (rr>r2_max) cycle
               xx = x(n); yy = y(n); zz = z(n)
               cc_exp_rr = .cc*exp(-.ex*rr)
               g1 = -TWO*sum(.ex*cc_exp_rr)
               F(n,1)  = sum(cc_exp_rr)
               Gx(n,1) = g1*xx
               Gy(n,1) = g1*yy
               Gz(n,1) = g1*zz
            end
         case (1)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               rr = r2(n)
               if (rr>r2_max) cycle
               xx = x(n); yy = y(n); zz = z(n)
               cc_exp_rr = .cc*exp(-.ex*rr)
               g0 = sum(cc_exp_rr)
               g1 = -TWO*sum(.ex*cc_exp_rr)
               g1x = g1*xx
               g1y = g1*yy
               g1z = g1*zz
               F(n,1) = xx*g0
               F(n,2) = yy*g0
               F(n,3) = zz*g0
               Gx(n,1) = g0+xx*g1x
               Gy(n,1) = xx*g1y
               Gz(n,1) = xx*g1z
               Gx(n,2) = yy*g1x
               Gy(n,2) = g0+yy*g1y
               Gz(n,2) = yy*g1z
               Gx(n,3) = zz*g1x
               Gy(n,3) = zz*g1y
               Gz(n,3) = g0+zz*g1z
            end
         case default
            GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
            ff = .first_gaussian; lf = .last_gaussian
            fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
            nx  => GAUSSIAN_DATA::px(ff:lf)
            ny  => GAUSSIAN_DATA::py(ff:lf)
            nz  => GAUSSIAN_DATA::pz(ff:lf)
            bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
            gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
            do n = 1,n_pt              ! Do the exponential part of the gaussian
               rr = r2(n)
               if (rr>r2_max) cycle
               xx = x(n); yy = y(n); zz = z(n)
               cc_exp_rr = .cc*exp(-.ex*rr)
               g0 = sum(cc_exp_rr)
               g1 = -TWO*sum(.ex*cc_exp_rr)
               ! Cartesian orbital part
               ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
               g1x = g1*xx
               g1y = g1*yy
               g1z = g1*zz
               xx_g1x = xx*g1x
               yy_g1y = yy*g1y
               zz_g1z = zz*g1z
               bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
               bx(1) = xx;          by(1) = yy;          bz(1) = zz
               bxb = xx;            byb = yy;            bzb = zz
               gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
               gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
               do b=2,.l
                 gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
                 gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
                 gzb(b) = (b*g0+zz_g1z) * bzb
                 bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
                 bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
               end
               ! Combine cartesian orbital powers with the exponential part
               do b = 1,.n_comp
                 nxb = nx(b)
                 nyb = ny(b)
                 nzb = nz(b)
                 facb = fac(b)         ! Basis fn. normalisation factor
                 bxb = bx(nxb)
                 byb = by(nyb)
                 bzb = bz(nzb)
                 by_bz = byb *  bzb
                 facb_bx = facb  *  bxb
                 F(n,b)   = facb_bx * by_bz * g0
                 Gx(n,b) = facb    * gxb(nxb) * by_bz
                 Gy(n,b) = facb_bx * gyb(nyb) * bzb
                 Gz(n,b) = facb_bx * byb      * gzb(nzb)
               end
            end
            gzb.destroy;  gyb.destroy;  gxb.destroy
            bz.destroy;   by.destroy;   bx.destroy
      end
      cc_exp_rr.destroy
   end

!   make_nabla_grid(Gx,Gy,Gz,F,x,y,z,r2,keep)
!   ! Return "Gj(i,n)", the value of the gradient with respect to coordinate "j"
!   ! of the shell component "n", evaluated at grid point "i", given a set of
!   ! grid points "pt(i,1:3)". Likewise, "F(i,n)" is the value of the shell
!   ! component "n" evaluated at grid point "i". It is more eficient to compute
!   ! both "Gn" and "F" at once. The "Gn" are presented as separate components to
!   ! allow contiguous memory access for the calling routine.  "x", "y", "z" are
!   ! the differences between the points "pt" and the shell center, "r2" is an
!   ! array for the square of the distance from the points "pt" to ".pos". These
!   ! arrays can be efficiently precalculated under some circumstances, when
!   ! shell belonging to a whole atom are being calculated.
!      Gx,Gy,Gz,F :: MAT{REAL}, OUT
!      x,y,z,r2 :: VEC{REAL}, IN
!      keep :: VEC{BIN}, IN
!   ENSURE(Gx.is_same_shape_as(Gy),"Gx and Gy incompatible")
!   ENSURE(Gx.is_same_shape_as(Gz),"Gx and Gz incompatible")
!   ENSURE(Gx.is_same_shape_as(F) ,"Gx and F incompatible")
!      fac,cc_exp_rr,bx,by,bz,gxb,gyb,gzb :: VEC{REAL}*
!      nx,ny,nz :: VEC{INT}*
!      n_pt,n,i,b,nxb,nyb,nzb, ff,lf :: INT
!      xx,yy,zz,rr,facb,xx_g1x,yy_g1y,zz_g1z :: REAL
!      g0,g1,g1x,g1y,g1z,bxb,byb,bzb,by_bz,facb_bx :: REAL
!      n_pt = x.dim
!      F = ZERO
!      Gx = ZERO
!      Gy = ZERO
!      Gz = ZERO
!      cc_exp_rr.create(.n_cc)
!      select case (.l)
!         case (0)
!            i = 0
!            do n = 1,n_pt              ! Do the exponential part of the gaussian
!               if (NOT keep(n)) cycle
!               i = i + 1
!               xx = x(n); yy = y(n); zz = z(n)
!               rr = r2(n)
!               cc_exp_rr = .cc*exp(-.ex*rr)
!               g1 = -TWO*sum(.ex*cc_exp_rr)
!               F(i,1)  = sum(cc_exp_rr)
!               Gx(i,1) = g1*xx
!               Gy(i,1) = g1*yy
!               Gz(i,1) = g1*zz
!            end
!         case (1)
!            i = 0
!            do n = 1,n_pt              ! Do the exponential part of the gaussian
!               if (NOT keep(n)) cycle
!               i = i + 1
!               xx = x(n); yy = y(n); zz = z(n)
!               rr = r2(n)
!               cc_exp_rr = .cc*exp(-.ex*rr)
!               g0 = sum(cc_exp_rr)
!               g1 = -TWO*sum(.ex*cc_exp_rr)
!               g1x = g1*xx
!               g1y = g1*yy
!               g1z = g1*zz
!               F(i,1) = xx*g0
!               F(i,2) = yy*g0
!               F(i,3) = zz*g0
!               Gx(i,1) = g0+xx*g1x
!               Gy(i,1) = xx*g1y
!               Gz(i,1) = xx*g1z
!               Gx(i,2) = yy*g1x
!               Gy(i,2) = g0+yy*g1y
!               Gz(i,2) = yy*g1z
!               Gx(i,3) = zz*g1x
!               Gy(i,3) = zz*g1y
!               Gz(i,3) = g0+zz*g1z
!            end
!         case default
!            GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
!            ff = .first_gaussian; lf = .last_gaussian
!            fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
!            nx  => GAUSSIAN_DATA::px(ff:lf)
!            ny  => GAUSSIAN_DATA::py(ff:lf)
!            nz  => GAUSSIAN_DATA::pz(ff:lf)
!            bx.create(0,.l);   by.create(0,.l);   bz.create(0,.l)
!            gxb.create(0,.l);  gyb.create(0,.l);  gzb.create(0,.l)
!            i = 0
!            do n = 1,n_pt              ! Do the exponential part of the gaussian
!               if (NOT keep(n)) cycle
!               i = i + 1
!               xx = x(n); yy = y(n); zz = z(n)
!               rr = r2(n)
!               ! Radial part, summed over primitives
!               cc_exp_rr = .cc*exp(-.ex*rr)
!               g0 = sum(cc_exp_rr)
!               g1 = -TWO*sum(.ex*cc_exp_rr)
!               ! Cartesian orbital part
!               ! gxb(b)=x**(b-1),  bx(b)=x**b for b=0,.l
!               g1x = g1*xx
!               g1y = g1*yy
!               g1z = g1*zz
!               xx_g1x = xx*g1x
!               yy_g1y = yy*g1y
!               zz_g1z = zz*g1z
!               bx(0) = ONE;         by(0) = ONE;         bz(0) = ONE
!               bx(1) = xx;          by(1) = yy;          bz(1) = zz
!               bxb = xx;            byb = yy;            bzb = zz
!               gxb(0) = g1x;        gyb(0) = g1y;        gzb(0) = g1z
!               gxb(1) = g0+xx_g1x;  gyb(1) = g0+yy_g1y;  gzb(1) = g0+zz_g1z
!               do b=2,.l
!                 gxb(b) = (b*g0+xx_g1x) * bxb          ! (n-1)th power
!                 gyb(b) = (b*g0+yy_g1y) * byb          ! of the xyz part
!                 gzb(b) = (b*g0+zz_g1z) * bzb
!                 bxb = bxb*xx;   byb = byb*yy;   bzb = bzb*zz
!                 bx(b) = bxb;    by(b) = byb;    bz(b) = bzb
!               end
!               ! Combine cartesian orbital powers with the exponential part
!               do b = 1,.n_comp
!                 nxb = nx(b)
!                 nyb = ny(b)
!                 nzb = nz(b)
!                 facb = fac(b)         ! Basis fn. normalisation factor
!                 bxb = bx(nxb)
!                 byb = by(nyb)
!                 bzb = bz(nzb)
!                 by_bz = byb *  bzb
!                 facb_bx = facb  *  bxb
!                 F(i,b)   = facb_bx * by_bz * g0
!                 Gx(i,b) = facb    * gxb(nxb) * by_bz
!                 Gy(i,b) = facb_bx * gyb(nyb) * bzb
!                 Gz(i,b) = facb_bx * byb      * gzb(nzb)
!               end
!            end
!            gzb.destroy;  gyb.destroy;  gxb.destroy
!            bz.destroy;   by.destroy;   bx.destroy
!      end
!      cc_exp_rr.destroy
!   end


!   make_nabla_grid_fdm(g,f,pt)
!   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
!   ! on grid point "i" given a set of grid points "pt(i,1:3)".
!   ! This nabla grid is produced using the finite difference method.  It is much
!   ! slower, but useful for checking.
!      f,pt :: MAT{REAL}
!      g :: MAT3{REAL}
!   ENSURE(size(pt,2)==3,"pt matrix incorrectly dimensioned")
!      f1,f2,pt1 :: MAT{REAL}*
!      comp :: VEC{REAL}*
!      alpha :: REAL
!      n_pt,i :: INT
!      n_pt = size(pt,1)
!      .make_grid(f,pt)
!      alpha = TOL(6)
!      pt1.create(n_pt,3)
!      f1.create(n_pt,.n_comp)
!      f2.create(n_pt,.n_comp)
!      do i=1,3
!        comp => pt1(:,i)
!        pt1 = pt
!        comp = comp + alpha
!        .make_grid(f1,pt1)
!        pt1 = pt
!        comp = comp - alpha
!        .make_grid(f2,pt1)
!        g(:,:,i) = HALF/alpha * (f2(:,:) - f1(:,:))
!      end
!      f2.destroy
!      f1.destroy
!      pt1.destroy
!   end

   make_laplacian_grid(g,pt)
   ! Return "g(i,n,1:3)", the value of the second derivatives
   ! (d/dx2,d/dy2,d/dz2) of the shell component "n" on grid point "i" given a
   ! set of grid points "pt(i,1:3)".
      pt :: MAT{REAL}
      g :: MAT3{REAL}
   ENSURE(size(pt,2)==3,"pt matrix incorrectly dimensioned")
      fac :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,p,j,nxb,nyb,nzb, ff,lf :: INT
      aa,x,y,z,rr,val :: REAL
      g0,g1,g2,g2x,g2y,g2z :: REAL
      gnbx,gnby,gnbz,x2,y2,z2 :: REAL
      gx0,gx1,gy0,gy1,gz0,gz1,facb,tn,tn2 :: REAL
      n_pt = size(pt,1)
      select case (.l)
        case (0)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              val = .cc(p)*exp(-aa*rr)
              g1 = g1 - aa*val
              g2 = g2 + aa*aa*val
            end
            g1 = g1 * TWO
            g2 = g2 * FOUR
            g(n,1,1) = g1 + g2*x2
            g(n,1,2) = g1 + g2*y2
            g(n,1,3) = g1 + g2*z2
          end
        case (1)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              val = .cc(p)*exp(-aa*rr)
              g1 = g1 - aa*val
              g2 = g2 + aa*aa*val
            end
            g1 = g1 * TWO
            g2 = g2 * FOUR
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2
            g(n,1,1) = x * (3 * g1 + g2x)
            g(n,1,2) = x * (g1 + g2y)
            g(n,1,3) = x * (g1 + g2z)
            g(n,2,1) = y * (g1 + g2x)
            g(n,2,2) = y * (3 * g1 + g2y)
            g(n,2,3) = y * (g1 + g2z)
            g(n,3,1) = z * (g1 + g2x)
            g(n,3,2) = z * (g1 + g2y)
            g(n,3,3) = z * (3 * g1 + g2z)
          end
        case default
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              val = .cc(p)*exp(-aa*rr)
              g0 = g0 +    val
              g1 = g1 - aa*val
              g2 = g2 + aa*aa*val
            end
            g1 = g1 * TWO
            g2 = g2 * FOUR
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2
            ! Some that are used multiple times.
            ! Taken out of loop over n_comp.
            gx0 = g1 + g2x
            gy0 = g1 + g2y
            gz0 = g1 + g2z
            gx1 = (THREE * g1 + g2x)*x  ! *x^1
            gy1 = (THREE * g1 + g2y)*y  ! *y^1
            gz1 = (THREE * g1 + g2z)*z  ! *z^1
            do b = 1,.n_comp        ! Loop over basis functions
                nxb = nx(b)
                nyb = ny(b)
                nzb = nz(b)
                select case (nxb)
                  case (0);     gnbx = gx0
                  case (1);     gnbx = gx1
                  case (2);     gnbx = g0+g0 + (5*g1 + g2x)*x*x
                  case default
                    tn2 = x**(nxb-2)
                    tn = tn2*x*x
                    gnbx = nxb*(nxb-1)*g0*tn2 + ((nxb+nxb+1)*g1 + g2x)*tn
                end
                select case (nyb)
                  case (0);     gnby = gy0
                  case (1);     gnby = gy1
                  case (2);     gnby = g0+g0 + (5*g1 + g2y)*y*y
                  case default
                    tn2 = y**(nyb-2)
                    tn = tn2*y*y
                    gnby = nyb*(nyb-1)*g0*tn2 + ((nyb+nyb+1)*g1 + g2y)*tn
                end
                select case (nzb)
                  case (0);     gnbz = gz0
                  case (1);     gnbz = gz1
                  case (2);     gnbz = g0+g0 + (5*g1 + g2z)*z*z
                  case default
                    tn2 = z**(nzb-2)
                    tn = tn2*z*z
                    gnbz = nzb*(nzb-1)*g0*tn2 + ((nzb+nzb+1)*g1 + g2z)*tn
                end
                do j = 1,nxb
                   gnby = x*gnby    ! Do the cartesian (x_i)^j, i/=k part of
                   gnbz = x*gnbz    ! gaussian power of the xyz part not equal
                end                 ! to deriv. component k
                do j = 1,nyb
                   gnbx = y*gnbx
                   gnbz = y*gnbz
                end
                do j = 1,nzb
                   gnbx = z*gnbx
                   gnby = z*gnby
                end
                facb = fac(b)
                g(n,b,1) = gnbx*facb ! Basis fn. normalisation factor
                g(n,b,2) = gnby*facb
                g(n,b,3) = gnbz*facb
             end
          end
      end
   end

   make_laplacian_grid(g,h,i,pt)
   ! Return "g(j,n,1:3)", the value of the second derivatives
   ! (d/dx2,d/dy2,d/dz2) of the shell component n on grid point j given a
   ! set of grid points "pt(j,1:3)". Also return "h(j,n,1:3)", the value of the
   ! first derivative, and return "i(n)", the value of the gaussian
      pt :: MAT{REAL}
      g,h :: MAT3{REAL}
      i :: MAT{REAL}
   ENSURE(size(pt,2)==3,"pt matrix incorrectly dimensioned")
      fac :: VEC{REAL}*
      nx,ny,nz :: VEC{INT}*
      n_pt,n,b,p,j,nxb,nyb,nzb, ff,lf :: INT
      aa,x,y,z,rr,val :: REAL
      g0,g1,g2,g2x,g2y,g2z :: REAL
      gnbx,gnby,gnbz,x2,y2,z2 :: REAL
      gx0,gx1,gy0,gy1,gz0,gz1,facb,inb :: REAL
      hnbx,hnby,hnbz,hx1,hy1,hz1,h1x,h1y,h1z :: REAL
      tn,tn1,tn2,twog0 :: REAL
      n_pt = size(pt,1)
      select case (.l)
        case (0)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              val = .cc(p)*exp(-aa*rr)
              g0 = g0 + val
              g1 = g1 - aa*val
              g2 = g2 + aa*aa*val
            end
            g1 = g1 * TWO
            g2 = g2 * FOUR
            g(n,1,1) = g1 + g2*x2
            g(n,1,2) = g1 + g2*y2
            g(n,1,3) = g1 + g2*z2
            h(n,1,1) = g1*x
            h(n,1,2) = g1*y
            h(n,1,3) = g1*z
            i(n,1)   = g0
          end
        case (1)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              val = .cc(p)*exp(-aa*rr)
              g0 = g0 + val
              g1 = g1 - aa*val
              g2 = g2 + aa*aa*val
            end
            g1 = g1 * TWO
            g2 = g2 * FOUR
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2
            g(n,1,1) = x * (3 * g1 + g2x)
            g(n,1,2) = x * (g1 + g2y)
            g(n,1,3) = x * (g1 + g2z)
            g(n,2,1) = y * (g1 + g2x)
            g(n,2,2) = y * (3 * g1 + g2y)
            g(n,2,3) = y * (g1 + g2z)
            g(n,3,1) = z * (g1 + g2x)
            g(n,3,2) = z * (g1 + g2y)
            g(n,3,3) = z * (3 * g1 + g2z)
            h1x = g1*x
            h1y = g1*y
            h1z = g1*z
            h(n,1,1) = g0+x2*g1
            h(n,1,2) = x*h1y
            h(n,1,3) = x*h1z
            h(n,2,1) = y*h1x
            h(n,2,2) = g0+y2*g1
            h(n,2,3) = y*h1z
            h(n,3,1) = z*h1x
            h(n,3,2) = z*h1y
            h(n,3,3) = g0+z2*g1
            i(n,1)   = g0*x
            i(n,2)   = g0*y
            i(n,3)   = g0*z
          end
        case default
          GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
          ff = .first_gaussian; lf = .last_gaussian
          fac => GAUSSIAN_DATA::normalising_factors(ff:lf)
          nx  => GAUSSIAN_DATA::px(ff:lf)
          ny  => GAUSSIAN_DATA::py(ff:lf)
          nz  => GAUSSIAN_DATA::pz(ff:lf)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              val = .cc(p)*exp(-aa*rr)
              g0 = g0 + val
              g1 = g1 - aa*val
              g2 = g2 + aa*aa*val
            end
            g1 = g1 * TWO
            g2 = g2 * FOUR
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2
            ! Some that are used multiple times.
            ! Taken out of loop over n_comp.
            gx0 = g1 + g2x
            gy0 = g1 + g2y
            gz0 = g1 + g2z
            gx1 = (THREE * g1 + g2x)*x  ! *x^1
            gy1 = (THREE * g1 + g2y)*y  ! *y^1
            gz1 = (THREE * g1 + g2z)*z  ! *z^1
            h1x = g1*x
            h1y = g1*y
            h1z = g1*z
            hx1 = g0 + x2*g1
            hy1 = g0 + y2*g1
            hz1 = g0 + z2*g1
            do b = 1,.n_comp        ! Loop over basis functions
                inb = g0
                nxb = nx(b)
                nyb = ny(b)
                nzb = nz(b)
                select case (nxb)
                  case (0);     gnbx = gx0
                                hnbx = h1x
                  case (1);     gnbx = gx1
                                hnbx = hx1
                  case (2)
                    tn = x*x
                    twog0 = g0+g0
                    gnbx = twog0 + (5*g1 + g2x)*tn
                    hnbx = twog0*x + h1x*tn
                  case default
                    tn2 = x**(nxb-2)
                    tn1 = tn2*x
                    tn = tn2*x*x
                    gnbx = nxb*(nxb-1)*g0*tn2 + ((2*nxb+1) * g1 + g2x)*tn
                    hnbx = nxb*g0*tn1 + h1x*tn
                end
                select case (nyb)
                  case (0);     gnby = gy0
                                hnby = h1y
                  case (1);     gnby = gy1
                                hnby = hy1
                  case (2)
                    tn = y*y
                    twog0 = g0+g0
                    gnby = twog0 + (5*g1 + g2y)*tn
                    hnby = twog0*y + h1y*tn
                  case default
                    tn2 = y**(nyb-2)
                    tn1 = tn2*y
                    tn = tn2*y*y
                    gnby = nyb*(nyb-1)*g0*tn2 + ((2*nyb+1) * g1 + g2y)*tn
                    hnby = nyb*g0*tn1 + h1y*tn
                end
                select case (nzb)
                  case (0);     gnbz = gz0
                                hnbz = h1z
                  case (1);     gnbz = gz1
                                hnbz = hz1
                  case (2)
                    tn = z*z
                    twog0 = g0+g0
                    gnbz = twog0 + (5*g1 + g2z)*tn
                    hnbz = twog0*z + h1z*tn
                  case default
                    tn2 = z**(nzb-2)
                    tn1 = tn2*z
                    tn = tn2*z*z
                    gnbz = nzb*(nzb-1)*g0*tn2 + ((2*nzb+1) * g1 + g2z)*tn
                    hnbz = nzb*g0*tn1 + h1z*tn
                end
                do j = 1,nxb
                   gnby = x*gnby    ! Do the cartesian (x_i)^j, i/=k part of
                   gnbz = x*gnbz    ! gaussian power of the xyz part not equal
                   hnby = x*hnby
                   hnbz = x*hnbz
                   inb  = x*inb
                end                 ! to deriv. component k
                do j = 1,nyb
                   gnbx = y*gnbx
                   gnbz = y*gnbz
                   hnbx = y*hnbx
                   hnbz = y*hnbz
                   inb  = y*inb
                end
                do j = 1,nzb
                   gnbx = z*gnbx
                   gnby = z*gnby
                   hnbx = z*hnbx
                   hnby = z*hnby
                   inb  = z*inb
                end
                facb = fac(b)
                g(n,b,1) = gnbx*facb ! Basis fn. normalisation factor
                g(n,b,2) = gnby*facb
                g(n,b,3) = gnbz*facb
                h(n,b,1) = hnbx*facb
                h(n,b,2) = hnby*facb
                h(n,b,3) = hnbz*facb
                i(n,b)   = inb *facb
             end
          end
      end
   end

   make_oscillator_orbital_mask(f,c,l,n,pt)
   ! Return "f(i)", the value of the cartesian part of an oscillator function
   ! centered at "c", of angular momentum "l" and component "n", evaluated on
   ! grid point "i", which is "pt(i,1:3)". 
      f  :: VEC{REAL}
      pt :: MAT{REAL}
      c :: VEC{REAL}(3)
      l,n :: INT
   ENSURE(n.is_in_range([1,SHELL1:n_comp(l)]),"inconsistent l, n value")
      nx,ny,nz :: VEC{INT}*
      nxn,nyn,nzn, ff,lf :: INT
      select case (l)
        case (0)
           f = ONE
        case (1)
           f = pt(:,n)-c(n)
      ! case (2)
      !    if      (n<=3) then; f = pt(:,n)-c(n)*c(n)
      !    else if (n==4) then; f = pt(:,n)-c(1)*c(2)
      !    else if (n==5) then; f = pt(:,n)-c(1)*c(3)
      !    else if (n==6) then; f = pt(:,n)-c(2)*c(3)
      !    end
      ! case (3)
      !    if      (n<=3)  then; f = pt(:,n)-c(n)*c(n)*c(n)
      !    else if (n==4)  then; f = pt(:,n)-c(1)*c(1)*c(2)
      !    else if (n==5)  then; f = pt(:,n)-c(1)*c(1)*c(3)
      !    else if (n==6)  then; f = pt(:,n)-c(2)*c(2)*c(1)
      !    else if (n==7)  then; f = pt(:,n)-c(2)*c(2)*c(3)
      !    else if (n==8)  then; f = pt(:,n)-c(3)*c(3)*c(1)
      !    else if (n==9)  then; f = pt(:,n)-c(3)*c(3)*c(2)
      !    else if (n==10) then; f = pt(:,n)-c(1)*c(2)*c(3)
      !    end
        case default
           GAUSSIAN_DATA:set_indices(.l)     ! Make sure indices are there
           ff = SHELL1::n_comp_up_to(l-1) + 1
           lf = SHELL1::n_comp_up_to(l) 
           nx  => GAUSSIAN_DATA::px(ff:lf)
           ny  => GAUSSIAN_DATA::py(ff:lf)
           nz  => GAUSSIAN_DATA::pz(ff:lf)
           nxn = nx(n); nyn = ny(n); nzn = nz(n)
           nz.destroy; ny.destroy; nx.destroy
           f = (pt(:,1)-c(1))**nxn * (pt(:,2)-c(2))**nyn * (pt(:,3)-c(3))**nzn
      end
   end

end
