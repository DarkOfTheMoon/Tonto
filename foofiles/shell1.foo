!-------------------------------------------------------------------------------
!
! SHELL1: For describing contracted cartesian gaussian shells with a position
! coordinate
!
! (c) Dylan Jayatilaka, november 1997
!
! $Id$
!
!-------------------------------------------------------------------------------
module SHELL1

   use TYPES
   use SYSTEM
   use STR
   use INT
   use IMAT
   use VEC
   use MAT
   use MAT3
   use TEXTFILE

   implicit none

#  include "macros"
#  include "shell1.int"

!   type shell1_type
!
!   INT :: l
!   ! l quantum number of the shell
!
!   INT :: n_comp
!   ! No. of components for the shell
!
!   INT :: n_cc
!   ! No. of contraction coefficients for the shell
!
!   VEC(3) :: pos
!   ! Position of the shell
!
!   VEC* :: ex
!   ! Exponent vector
!
!   VEC* :: cc
!   ! Contraction coefficient vector
!
!   end

contains

   create [leaky]
   ! Create a shell object
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(SHELL1_SIZE)
      .nullify_ptr_part
   end

   create(shell) [leaky]
   ! Create a shell object from another copy
      PTR :: self
      SHELL1, IN :: shell
      .create
      .copy(shell)
   end

   create(shell,pos) [leaky]
   ! Create a shell object from another copy
      PTR :: self
      SHELL, IN :: shell
      VEC(3), IN :: pos
      .create
      .copy(shell,pos)
   end

   destroy [leaky]
   ! Destroy a shell object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(SHELL1_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
     nullify(.ex)
     nullify(.cc)
   end

   destroy_ptr_part [leaky]
   ! Destroy pointer part of a shell object
      .ex.destroy
      .cc.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

  copy(shell,pos) [leaky]
  ! Make a shell1 object from the shell and its position.
  ! NOTE : ensure the ptr parts have been destroyed beforehand.
    SHELL :: shell
    VEC(3), IN :: pos
    .l = shell.l
    .n_comp = shell.n_comp
    .n_cc = shell.n_cc
    .pos = pos
  ! .ex.destroy
    .ex.create(.n_cc)
    .ex = shell.ex
  ! .cc.destroy
    .cc.create(.n_cc)
    .cc = shell.cc
  end

  copy(shell) [leaky]
  ! Make a shell1 object from a shell1 object.
  ! NOTE : ensure the ptr parts have been destroyed beforehand.
    SHELL1, IN :: shell
    .l = shell.l
    .n_comp = shell.n_comp
    .n_cc = shell.n_cc
    .pos = shell.pos
  ! .ex.destroy
    .ex.create(.n_cc)
    .ex = shell.ex
  ! .cc.destroy
    .cc.create(.n_cc)
    .cc = shell.cc
  end

   set(shell,pos)
   ! Set a shell1 object.
      VEC, optional :: pos
      SHELL, optional :: shell
      if (present(pos)) .pos = pos
      if (present(shell)) then
         .l = shell.l
         .n_comp = shell.n_comp
         .n_cc = shell.n_cc
         .ex => shell.ex
         .cc => shell.cc
      end
   end

   set(shell)
   ! Set a shell1 object
      SHELL1 :: shell
      .pos = shell.pos
      .l = shell.l
      .n_comp = shell.n_comp
      .n_cc = shell.n_cc
      .ex => shell.ex
      .cc => shell.cc
   end

   set_default [leaky]
      .l = 0
      .n_comp = 1
      .n_cc = 1
      .pos = ZERO
      .ex.create(1)
      .cc.create(1)
      .ex(1) = ONE
      .cc(1) = ONE
   end

   read_from_input(in)
   ! Read a contracted gaussian self from file "in"
      TEXTFILE :: in
      CHR :: l_c
      INT :: l,i
      in.read(.pos)
      in.read_chr(l_c)
      in.read(.n_cc)
      l_c.to_lower_case
      select case (l_c)
         case ("s"); l = 0
         case ("p"); l = 1
         case ("d"); l = 2
         case ("f"); l = 3
         case ("g"); l = 4
         case default;
            DIE_IF(l_c<"g","unknown angular momentum character:"//l_c)
            l = 4 + iachar(l_c)-iachar("g")
      end
      .l = l
      .n_comp = l.n_comp
      nullify(.ex)
      nullify(.cc)
      .ex.create(.n_cc)
      .cc.create(.n_cc)
      do i = 1,.n_cc
         in.read(.ex(i))
         in.read(.cc(i))
      end
   end

  put(out)
  ! put the shell1 information to file "out"
    TEXTFILE :: out
    INT :: i
    out.flush
    out.show("L quantum number = ", .l)
    out.dash(int_fields=1,dbl_fields=2)
    out.put("position = ", int_width=TRUE)
    do i=1,3
      out.put( .pos(i))
    end
    out.flush
    out.dash(int_fields=1,dbl_fields=2)
    out.put("N", int_width=TRUE)
    out.put("Exponents")
    out.put("Contraction")
    out.flush
    out.dash(int_fields=1,dbl_fields=2)
    do i = 1, .n_cc
      out.put(i)
      out.put( .ex(i))
      out.put( .cc(i), flush=1)
    end
    out.flush
  end

! ************
! The Routines
! ************

   l_chr result(res)
   ! Return a character representation for the angular mtm
      CHR :: res
      INT :: l
      l = .l
      select case (l)
         case (0); res="s"
         case (1); res="p"
         case (2); res="d"
         case (3); res="f"
         case (4); res="g"
         case default;
            DIE_IF(l>23,"angular momentum too large:"// trim(l.to_str))
            res = achar(l-4+iachar("g"))
      end select
   end

!   make_contraction_matrix(ccm)
!   ! Return the contraction coefficient matrix
!   ! Size of ccm is .n_prim,.n_comp.
!      MAT :: ccm
!      INT :: b,p,i
!      DBL :: f
!      VEC* :: fac
!!     ccm = ZERO
!      fac.create( .n_comp );   fac.normalizing_factors( .l )
!      do b = 1,.n_comp       ! do over basis components
!         p = b               ! primitive p
!         f = fac(b)
!         do i = 1,.n_cc      ! do over contractions
!            ccm(p,b) = f*.cc(i)
!            p = p + .n_comp
!         end
!      end
!      fac.destroy
!   end

   unnormalize
   ! Unnormalise self for cartesian component x^l.
   ! It is up to you to correct this factor with appropriate
   ! double factorial square roots for other components.
      .unnormalise
   end

   unnormalise
   ! Unnormalise self for cartesian component x^l.
   ! It is up to you to correct this factor with appropriate
   ! double factorial square roots for other components.
      INT :: i,j
      DBL :: sum,a,b,ab,pi2,norm,fac
      sum=0
      do i = 1,.n_cc
         a = .ex(i)
         do j = 1,i-1
            b = .ex(j)
            ab = TWO*sqrt(a*b)/(a+b);
            sum = sum + TWO*.cc(i)*.cc(j)*ab**(.l+ONE+HALF);
         end
         sum = sum + .cc(i)*.cc(i)
      end
   !  Take the normalization factor out of the primitive
      pi2 = (HALF/PI)**(THREE/FOUR)
      norm = pi2/sqrt(sum)
      do i = 1,.n_cc
         a = FOUR*.ex(i)
         fac = .l.double_factorial
         fac = ONE/sqrt(fac)
   !     this factor should be: fac = 1/sqrt(df(nx)*df(ny)*df(nz))
   !     where n are the cartesian powers of the basis component
         .cc(i) = .cc(i)*norm*fac*a**(HALF*.l+HALF+QUARTER)
      end
   end

  make_grid(g,pt)
  ! Return "g(i,n)", the value of the shell component "n" on grid point "i"
  ! given a set of grid points "pt(i,1:3)"
    MAT, target :: pt
    MAT, target :: g
    VEC* :: x,y,z
    x => pt(:,1); y => pt(:,2); z => pt(:,3)
    .make_grid(g,x,y,z)
  end

   make_grid(g,x,y,z)
   ! Return "g(i,n)", the value of the shell component "n" on grid point "i"
   ! given a set of grid points "(x(i),y(i),z(i))"
      VEC :: x,y,z
      MAT :: g
      VEC* :: fac
      IVEC* :: nx,ny,nz
      INT :: n_pt,n,b,j
      DBL :: rr,xx,yy,zz,posx,posy,posz,g0,gbn
      n_pt = size(x)
      posx = .pos(1); posy = .pos(2); posz = .pos(3)
      select case (.l)
        case (0)
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             g(n,1) = sum( .cc * exp( -rr * .ex ))      ! Sum over primitives
          end
        case (1)
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             g0 = sum( .cc * exp( -rr * .ex ))        ! Sum over primitives
             g(n,1) = xx*g0
             g(n,2) = yy*g0
             g(n,3) = zz*g0
          end
        case (2)
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             g0 = sum( .cc * exp( -rr * .ex ))    ! Sum over primitives
             g(n,1) = xx*xx*g0
             g(n,2) = yy*yy*g0
             g(n,3) = zz*zz*g0
             g(n,4) = xx*yy*sqrt(THREE)*g0
             g(n,5) = xx*zz*sqrt(THREE)*g0
             g(n,6) = yy*zz*sqrt(THREE)*g0
          end
        case default
          nx.create(.n_comp); ny.create(.n_comp); nz.create(.n_comp)
          .l.make_gaussian_xyz_powers(nx,ny,nz)
          fac.create( .n_comp );    fac.normalizing_factors( .l )
          do n = 1,n_pt
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz    ! Do exponential part of the gaussian
             g0 = sum( .cc * exp( -rr * .ex )) ! Sum over primitives
             do b = 1,.n_comp              ! Loop over all basis functions
                gbn = fac(b)*g0            ! Combine exponential and cartesian
                do j = 1,nx(b)             ! power of the x^j part
                   gbn = xx*gbn
                end
                do j = 1,ny(b)
                   gbn = yy*gbn
                end
                do j = 1,nz(b)
                   gbn = zz*gbn
                end
                g(n,b) = gbn
             end
          end
          fac.destroy
          nz.destroy; ny.destroy; nx.destroy
     end
   end

   make_nabla_grid(g,pt)
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      MAT :: pt
      MAT3 :: g
      VEC* :: fac
      IMAT* :: nn
      INT :: n_pt,n,b,p,j,nxb,nyb,nzb
      DBL :: aa,a2,xx,yy,zz,rr,val,gx,gy,gz,facb
      DBL :: g0,g1,g1x,g1y,g1z,gx1,gy1,gz1
      DIE_IF(size(pt,2)/=3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g1  = g1 - a2*val
             end
             g(n,1,1) = g1*xx
             g(n,1,2) = g1*yy
             g(n,1,3) = g1*zz
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0  + val
                g1  = g1 - a2*val
             end
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             g(n,1,1) = g0+xx*g1x
             g(n,1,2) = xx*g1y
             g(n,1,3) = xx*g1z
             g(n,2,1) = yy*g1x
             g(n,2,2) = g0+yy*g1y
             g(n,2,3) = yy*g1z
             g(n,3,1) = zz*g1x
             g(n,3,2) = zz*g1y
             g(n,3,3) = g0+zz*g1z
          end
        case default
          nn.create(3, .n_comp );   .l.make_gaussian_xyz_powers(nn)
          fac.create( .n_comp );    fac.normalizing_factors( .l )
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0 + val
                g1  = g1 - a2*val
             end
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             gx1 = g0+xx*g1x
             gy1 = g0+yy*g1y
             gz1 = g0+zz*g1z
             do b = 1,.n_comp               ! Loop over basis functions
                nxb = nn(1,b)
                nyb = nn(2,b)
                nzb = nn(3,b)
                select case (nxb)
                  case (0);      gx = g1x
                  case (1);      gx = gx1
                  case default;  gx = nxb*g0+xx*g1x
                    do j = 1,nxb-1          ! (n-1)th power of the xyz part
                       gx = xx*gx
                    end
                end
                select case (nyb)
                  case (0);      gy = g1y
                  case (1);      gy = gy1
                  case default;  gy = nyb*g0+yy*g1y
                    do j = 1,nyb-1          ! (n-1)th power of the xyz part
                       gy = yy*gy
                    end
                end
                select case (nzb)
                  case (0);      gz = g1z
                  case (1);      gz = gz1
                  case default;  gz = nzb*g0+zz*g1z
                    do j = 1,nzb-1          ! (n-1)th power of the xyz part
                       gz = zz*gz
                    end
                end
                do j = 1,nxb                ! power of the xyz part not equal
                   gy = xx*gy               ! to gradient component k
                   gz = xx*gz
                end
                do j = 1,nyb
                   gx = yy*gx
                   gz = yy*gz
                end
                do j = 1,nzb
                   gx = zz*gx
                   gy = zz*gy
                end
                facb = fac(b)
                g(n,b,1) = gx * facb         ! Basis fn. normalization factor
                g(n,b,2) = gy * facb
                g(n,b,3) = gz * facb
             end
          end
          fac.destroy
          nn.destroy
     end
   end

   make_nabla_grid_x(g,pt)
   ! Return "g(i,n)", the value of the gradient wrt x of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      MAT :: pt
      MAT :: g
      VEC* :: fac
      IMAT* :: nn
      INT :: n_pt,n,b,p,j,nxb,nyb,nzb
      DBL :: aa,a2,xx,yy,zz,rr,val,gx,facb
      DBL :: g0,g1,g1x,gx1
      DIE_IF(size(pt,2)/=3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g1  = g1 - a2*val
             end
             g(n,1) = g1*xx
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0  + val
                g1  = g1 - a2*val
             end
             g1x = g1*xx
             g(n,1) = g0+xx*g1x
             g(n,2) = yy*g1x
             g(n,3) = zz*g1x
          end
        case default
          nn.create(3, .n_comp );   .l.make_gaussian_xyz_powers(nn)
          fac.create( .n_comp );    fac.normalizing_factors( .l )
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0 + val
                g1  = g1 - a2*val
             end
             g1x = g1*xx
             gx1 = g0+xx*g1x
             do b = 1,.n_comp               ! Loop over basis functions
                nxb = nn(1,b)
                nyb = nn(2,b)
                nzb = nn(3,b)
                select case (nxb)
                  case (0);      gx = g1x
                  case (1);      gx = gx1
                  case default;  gx = nxb*g0+xx*g1x
                    do j = 1,nxb-1          ! (n-1)th power of the xyz part
                       gx = xx*gx
                    end
                end
                do j = 1,nyb
                   gx = yy*gx
                end
                do j = 1,nzb
                   gx = zz*gx
                end
                facb = fac(b)
                g(n,b) = gx * facb         ! Basis fn. normalization factor
             end
          end
          fac.destroy
          nn.destroy
     end
   end

   make_nabla_grid_y(g,pt)
   ! Return "g(i,n", the value of the gradient wrt y of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      MAT :: pt
      MAT :: g
      VEC* :: fac
      IMAT* :: nn
      INT :: n_pt,n,b,p,j,nyb
      DBL :: aa,a2,xx,yy,zz,rr,val,gy
      DBL :: g0,g1,g1y,gy1
      DIE_IF(size(pt,2)/=3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g1  = g1 - a2*val
             end
             g(n,1) = g1*yy
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0  + val
                g1  = g1 - a2*val
             end
             g1y = g1*yy
             g(n,1) = xx*g1y
             g(n,2) = g0+yy*g1y
             g(n,3) = zz*g1y
          end
        case default
          nn.create(3, .n_comp );   .l.make_gaussian_xyz_powers(nn)
          fac.create( .n_comp );    fac.normalizing_factors( .l )
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0 + val
                g1  = g1 - a2*val
             end
             g1y = g1*yy
             gy1 = g0+yy*g1y
             do b = 1,.n_comp               ! Loop over basis functions
                nyb = nn(2,b)
                select case (nyb)
                  case (0);      gy = g1y
                  case (1);      gy = gy1
                  case default;  gy = nyb*g0+yy*g1y
                    do j = 1,nyb-1          ! (n-1)th power of the xyz part
                       gy = yy*gy
                    end
                end
                do j = 1,nn(1,b)            ! power of the xyz part not equal
                   gy = xx*gy               ! to gradient component k
                end
                do j = 1,nn(3,b)
                   gy = zz*gy
                end
                g(n,b) = gy * fac(b)
             end
          end
          fac.destroy
          nn.destroy
     end
   end

   make_nabla_grid_z(g,pt)
   ! Return "g(i,n)", the value of the gradient wrt z of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      MAT :: pt
      MAT :: g
      VEC* :: fac
      IMAT* :: nn
      INT :: n_pt,n,b,p,j,nzb
      DBL :: aa,a2,xx,yy,zz,rr,val,gz
      DBL :: g0,g1,gz1,g1z
      DIE_IF(size(pt,2)/=3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g1  = g1 - a2*val
             end
             g(n,1) = g1*zz
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0  + val
                g1  = g1 - a2*val
             end
             g1z = g1*zz
             g(n,1) = xx*g1z
             g(n,2) = yy*g1z
             g(n,3) = g0+zz*g1z
          end
        case default
          nn.create(3, .n_comp );   .l.make_gaussian_xyz_powers(nn)
          fac.create( .n_comp );    fac.normalizing_factors( .l )
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0 + val
                g1  = g1 - a2*val
             end
             g1z = g1*zz
             gz1 = g0+zz*g1z
             do b = 1,.n_comp               ! Loop over basis functions
                nzb = nn(3,b)
                select case (nzb)
                  case (0);      gz = g1z
                  case (1);      gz = gz1
                  case default;  gz = nzb*g0+zz*g1z
                    do j = 1,nzb-1          ! (n-1)th power of the xyz part
                       gz = zz*gz
                    end
                end
                do j = 1,nn(1,b)
                   gz = xx*gz
                end
                do j = 1,nn(2,b)
                   gz = yy*gz
                end
                g(n,b) = gz * fac(b)
             end
          end
          fac.destroy
          nn.destroy
     end
   end

   make_nabla_grid(g,f,pt)
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
   ! Returns "f(i,n)", the value of the shell component "n" on grid point "i".
      MAT :: f,pt
      MAT3 :: g
      VEC* :: fac
      IMAT* :: nn
      INT :: n_pt,n,b,p,j,nxb,nyb,nzb
      DBL :: aa,a2,xx,yy,zz,rr,val,gx,gy,gz,facb
      DBL :: g0,g1,g1x,g1y,g1z,fbn,gx1,gy1,gz1
      DIE_IF(size(pt,2)/=3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
      select case (.l)
        case (0)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0 + val
                g1  = g1 - a2*val
             end
             f(n,1)   = g0
             g(n,1,1) = g1*xx
             g(n,1,2) = g1*yy
             g(n,1,3) = g1*zz
          end
        case (1)
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0 + val
                g1  = g1 - a2*val
             end
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             f(n,1) = xx*g0
             f(n,2) = yy*g0
             f(n,3) = zz*g0
             g(n,1,1) = g0+xx*g1x
             g(n,1,2) = xx*g1y
             g(n,1,3) = xx*g1z
             g(n,2,1) = yy*g1x
             g(n,2,2) = g0+yy*g1y
             g(n,2,3) = yy*g1z
             g(n,3,1) = zz*g1x
             g(n,3,2) = zz*g1y
             g(n,3,3) = g0+zz*g1z
          end
        case default
          nn.create(3, .n_comp );   .l.make_gaussian_xyz_powers(nn)
          fac.create( .n_comp );    fac.normalizing_factors( .l )
          do n = 1,n_pt              ! Do the exponential part of the gaussian
             g0 = ZERO
             g1 = ZERO
             xx=pt(n,1) - .pos(1); yy=pt(n,2) - .pos(2); zz=pt(n,3) - .pos(3)
             do p = 1,.n_cc                ! Loop over primitives
                aa = .ex(p)
                a2 = aa+aa
                rr = xx*xx + yy*yy + zz*zz
                val = .cc(p)*exp(-aa*rr)
                g0  = g0 + val
                g1  = g1 - a2*val
             end
             g1x = g1*xx
             g1y = g1*yy
             g1z = g1*zz
             gx1 = g0+xx*g1x
             gy1 = g0+yy*g1y
             gz1 = g0+zz*g1z
             do b = 1,.n_comp               ! Loop over basis functions
                nxb = nn(1,b)
                nyb = nn(2,b)
                nzb = nn(3,b)
                fbn = g0
                select case (nxb)
                  case (0);      gx = g1x
                  case (1);      gx = gx1
                  case default;  gx = nxb*g0+xx*g1x
                    do j = 1,nxb-1          ! (n-1)th power of the xyz part
                       gx = xx*gx
                    end
                end
                select case (nyb)
                  case (0);      gy = g1y
                  case (1);      gy = gy1
                  case default;  gy = nyb*g0+yy*g1y
                    do j = 1,nyb-1          ! (n-1)th power of the xyz part
                       gy = yy*gy
                    end
                end
                select case (nzb)
                  case (0);      gz = g1z
                  case (1);      gz = gz1
                  case default;  gz = nzb*g0+zz*g1z
                    do j = 1,nzb-1          ! (n-1)th power of the xyz part
                       gz = zz*gz
                    end
                end
                do j = 1,nxb                ! power of the xyz part not equal
                   gy = xx*gy               ! to gradient component k
                   gz = xx*gz
                   fbn = xx*fbn
                end
                do j = 1,nyb
                   gx = yy*gx
                   gz = yy*gz
                   fbn = yy*fbn
                end
                do j = 1,nzb
                   gx = zz*gx
                   gy = zz*gy
                   fbn = zz*fbn
                end
                facb = fac(b)
                f(n,b)   = fbn * facb
                g(n,b,1) = gx  * facb         ! Basis fn. normalization factor
                g(n,b,2) = gy  * facb
                g(n,b,3) = gz  * facb
             end
          end
          fac.destroy
          nn.destroy
     end
   end

   make_laplacian_grid(g,pt)
   ! Return "g(i,n,1:3)", the value of the second derivatives
   ! (d/dx2,d/dy2,d/dz2) of the shell component "n" on grid point "i" given a
   ! set of grid points "pt(i,1:3)".
      MAT :: pt
      MAT3 :: g
      VEC* :: fac
      IMAT* :: nn
      INT :: n_pt,n,b,p,j,nx,ny,nz
      DBL :: aa,a2,x,y,z,rr,val
      DBL :: g0,g1,g2,g2x,g2y,g2z
      DBL :: gnbx,gnby,gnbz,x2,y2,z2,x4,y4,z4
      DBL :: gx0,gx1,gy0,gy1,gz0,gz1,facb
      ENSURE(size(pt,2)==3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
   ! x^(n-2) has been factored out with x^2.
      select case (.l)
        case (0)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              a2 = aa+aa
              val = .cc(p)*exp(-aa*rr)
              g1 = g1 - a2*val
              g2 = g2 + a2*a2*val
            end
            g(n,1,1) = g1 + g2*x2
            g(n,1,2) = g1 + g2*y2
            g(n,1,3) = g1 + g2*z2
          end
        case (1)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              a2 = aa+aa
              val = .cc(p)*exp(-aa*rr)
              g1 = g1 - a2*val
              g2 = g2 + a2*a2*val
            end
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2
            g(n,1,1) = x * (3 * g1 + g2x)
            g(n,1,2) = x * (g1 + g2y)
            g(n,1,3) = x * (g1 + g2z)
            g(n,2,1) = y * (g1 + g2x)
            g(n,2,2) = y * (3 * g1 + g2y)
            g(n,2,3) = y * (g1 + g2z)
            g(n,3,1) = z * (g1 + g2x)
            g(n,3,2) = z * (g1 + g2y)
            g(n,3,3) = z * (3 * g1 + g2z)
          end
        case default
          nn.create(3,.n_comp);   .l.make_gaussian_xyz_powers(nn)
          fac.create(.n_comp);    fac.normalizing_factors(.l)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            x4 = x2*x2; y4 = y2*y2; z4 = z2*z2
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              a2 = aa+aa
              val = .cc(p)*exp(-aa*rr)
              g0 = g0 +    val
              g1 = g1 - a2*val
              g2 = g2 + a2*a2*val
            end
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2

            ! Some that are used multiple times.
            ! Taken out of loop over n_comp.
            gx0 = g1 + g2x
            gy0 = g1 + g2y
            gz0 = g1 + g2z
            gx1 = (THREE * g1 + g2x)*x  ! *x^1
            gy1 = (THREE * g1 + g2y)*y  ! *y^1
            gz1 = (THREE * g1 + g2z)*z  ! *z^1

            do b = 1,.n_comp        ! Loop over basis functions
                nx = nn(1,b)
                ny = nn(2,b)
                nz = nn(3,b)
    
                select case (nx)
                  case (0);     gnbx = gx0
                  case (1);     gnbx = gx1
                  case default; gnbx = nx*(nx-1)*g0/x2 + (2*nx+1) * g1 + g2x
                    do j = 1,nx                           ! *x^n
                      gnbx = x*gnbx
                    end
                end
                select case (ny)
                  case (0);     gnby = gy0
                  case (1);     gnby = gy1
                  case default; gnby = ny*(ny-1)*g0/y2 + (2*ny+1) * g1 + g2y
                    do j = 1,ny                           ! *y^n
                      gnby = y*gnby
                    end
                end
                select case (nz)
                  case (0);     gnbz = gz0
                  case (1);     gnbz = gz1
                  case default; gnbz = nz*(nz-1)*g0/z2 + (2*nz+1) * g1 + g2z
                    do j = 1,nz                           ! *z^n
                      gnbz = z*gnbz
                    end
                end

                do j = 1,nx
                   gnby = x*gnby    ! Do the cartesian (x_i)^j, i/=k part of
                   gnbz = x*gnbz    ! gaussian power of the xyz part not equal
                end                 ! to deriv. component k
                do j = 1,ny
                   gnbx = y*gnbx
                   gnbz = y*gnbz
                end
                do j = 1,nz
                   gnbx = z*gnbx
                   gnby = z*gnby
                end

                facb = fac(b)
                g(n,b,1) = gnbx*facb ! Basis fn. normalization factor
                g(n,b,2) = gnby*facb
                g(n,b,3) = gnbz*facb
             end
          end
          fac.destroy
          nn.destroy
      end
   end

   make_laplacian_grid(g,h,i,pt)
   ! Return "g(j,n,1:3)", the value of the second derivatives
   ! Return "h(j,n,1:3)", the value of the first derivative
   ! Return "i(n)", the value of the gaussian
   ! (d/dx2,d/dy2,d/dz2) of the shell component "n" on grid point "i" given a
   ! set of grid points "pt(i,1:3)".
      MAT :: pt
      MAT3 :: g,h
      MAT :: i
      VEC* :: fac
      IMAT* :: nn
      INT :: n_pt,n,b,p,j,nx,ny,nz
      DBL :: aa,a2,x,y,z,rr,val
      DBL :: g0,g1,g2,g2x,g2y,g2z
      DBL :: gnbx,gnby,gnbz,x2,y2,z2,x4,y4,z4
      DBL :: gx0,gx1,gy0,gy1,gz0,gz1,facb,inb
      DBL :: hnbx,hnby,hnbz,hx1,hy1,hz1,h1x,h1y,h1z
      ENSURE(size(pt,2)==3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
   ! x^(n-2) has been factored out with x^2.
      select case (.l)
        case (0)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              a2 = aa+aa
              val = .cc(p)*exp(-aa*rr)
              g0 = g0 + val
              g1 = g1 - a2*val
              g2 = g2 + a2*a2*val
            end
            g(n,1,1) = g1 + g2*x2
            g(n,1,2) = g1 + g2*y2
            g(n,1,3) = g1 + g2*z2
            h(n,1,1) = g1*x
            h(n,1,2) = g1*y
            h(n,1,3) = g1*z
            i(n,1)   = g0
          end
        case (1)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              a2 = aa+aa
              val = .cc(p)*exp(-aa*rr)
              g0 = g0 + val
              g1 = g1 - a2*val
              g2 = g2 + a2*a2*val
            end
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2
            g(n,1,1) = x * (3 * g1 + g2x)
            g(n,1,2) = x * (g1 + g2y)
            g(n,1,3) = x * (g1 + g2z)
            g(n,2,1) = y * (g1 + g2x)
            g(n,2,2) = y * (3 * g1 + g2y)
            g(n,2,3) = y * (g1 + g2z)
            g(n,3,1) = z * (g1 + g2x)
            g(n,3,2) = z * (g1 + g2y)
            g(n,3,3) = z * (3 * g1 + g2z)
            h1x = g1*x
            h1y = g1*y
            h1z = g1*z
            h(n,1,1) = g0+x2*g1
            h(n,1,2) = x*h1y
            h(n,1,3) = x*h1z
            h(n,2,1) = y*h1x
            h(n,2,2) = g0+y2*g1
            h(n,2,3) = y*h1z
            h(n,3,1) = z*h1x
            h(n,3,2) = z*h1y
            h(n,3,3) = g0+z2*g1
            i(n,1)   = g0*x
            i(n,2)   = g0*y
            i(n,3)   = g0*z
          end
        case default
          nn.create(3,.n_comp);   .l.make_gaussian_xyz_powers(nn)
          fac.create(.n_comp);    fac.normalizing_factors(.l)
          do n = 1,n_pt             ! Do the exponential part of the gaussian
            x=pt(n,1) - .pos(1); y=pt(n,2) - .pos(2); z=pt(n,3) - .pos(3)
            x2 = x*x;   y2 = y*y;   z2 = z*z
            x4 = x2*x2; y4 = y2*y2; z4 = z2*z2
            rr = x2 + y2 + z2
            g0 = ZERO
            g1 = ZERO
            g2 = ZERO
            do p = 1,.n_cc          ! Loop over primitives
              aa = .ex(p)
              a2 = aa+aa
              val = .cc(p)*exp(-aa*rr)
              g0 = g0 + val
              g1 = g1 - a2*val
              g2 = g2 + a2*a2*val
            end
            g2x = g2 * x2
            g2y = g2 * y2
            g2z = g2 * z2

            ! Some that are used multiple times.
            ! Taken out of loop over n_comp.
            gx0 = g1 + g2x
            gy0 = g1 + g2y
            gz0 = g1 + g2z
            gx1 = (THREE * g1 + g2x)*x  ! *x^1
            gy1 = (THREE * g1 + g2y)*y  ! *y^1
            gz1 = (THREE * g1 + g2z)*z  ! *z^1
            h1x = g1*x
            h1y = g1*y
            h1z = g1*z
            hx1 = g0 + x2*g1
            hy1 = g0 + y2*g1
            hz1 = g0 + z2*g1

            do b = 1,.n_comp        ! Loop over basis functions
                inb = g0
                nx = nn(1,b)
                ny = nn(2,b)
                nz = nn(3,b)
    
                select case (nx)
                  case (0);     gnbx = gx0
                                hnbx = h1x
                  case (1);     gnbx = gx1
                                hnbx = hx1
                  case default; gnbx = nx*(nx-1)*g0/x2 + (2*nx+1) * g1 + g2x
                                hnbx = nx*g0/x + h1x
                    do j = 1,nx                           ! *x^n
                      gnbx = x*gnbx
                      hnbx = x*hnbx
                    end
                end
                select case (ny)
                  case (0);     gnby = gy0
                                hnby = h1y
                  case (1);     gnby = gy1
                                hnby = hy1
                  case default; gnby = ny*(ny-1)*g0/y2 + (2*ny+1) * g1 + g2y
                                hnby = ny*g0/y + h1y
                    do j = 1,ny                           ! *y^n
                      gnby = y*gnby
                      hnby = y*hnby
                    end
                end
                select case (nz)
                  case (0);     gnbz = gz0
                                hnbz = h1z
                  case (1);     gnbz = gz1
                                hnbz = hz1
                  case default; gnbz = nz*(nz-1)*g0/z2 + (2*nz+1) * g1 + g2z
                                hnbz = nz*g0/z + h1z
                    do j = 1,nz                           ! *z^n
                      gnbz = z*gnbz
                      hnbz = z*hnbz
                    end
                end

                do j = 1,nx
                   gnby = x*gnby    ! Do the cartesian (x_i)^j, i/=k part of
                   gnbz = x*gnbz    ! gaussian power of the xyz part not equal
                   hnby = x*hnby
                   hnbz = x*hnbz
                   inb  = x*inb
                end                 ! to deriv. component k
                do j = 1,ny
                   gnbx = y*gnbx
                   gnbz = y*gnbz
                   hnbx = y*hnbx
                   hnbz = y*hnbz
                   inb  = y*inb
                end
                do j = 1,nz
                   gnbx = z*gnbx
                   gnby = z*gnby
                   hnbx = z*hnbx
                   hnby = z*hnby
                   inb  = z*inb
                end

                facb = fac(b)
                g(n,b,1) = gnbx*facb ! Basis fn. normalization factor
                g(n,b,2) = gnby*facb
                g(n,b,3) = gnbz*facb
                h(n,b,1) = hnbx*facb
                h(n,b,2) = hnby*facb
                h(n,b,3) = hnbz*facb
                i(n,b)   = inb *facb
             end
          end
          fac.destroy
          nn.destroy
      end
   end

!  ***************
!  Inquiry methods
!  ***************

   l result(res)
   ! Return the angular momentum l
      INT :: res
      res = .l
   end

   n_comp result(res)
   ! Return the number of components in the shell
      INT :: res
      res = .n_comp
   end

   n_cc result(res)
   ! Return the degree of contraction of the shell
      INT :: res
      res = .n_cc
   end

   n_prim result(res)
   ! Return the number of primitive gaussians in the shell
      INT :: res
      res = .n_comp*.n_cc
   end

   ex result(res)
   ! Return the exponent vector
      VEC(size(.ex)) :: res
      res = .ex
   end

   ex(i) result(res)
   ! Return the exponent
      INT :: i
      DBL :: res
      res = .ex(i)
   end

   cc result(res)
   ! Return the contraction coefficient vector
      VEC(size(.cc)) :: res
      res = .cc
   end

   cc(i) result(res)
   ! Return the contraction coefficient
      INT :: i
      DBL :: res
      res = .cc(i)
   end

   pos result(res)
   ! Return the position.
      VEC(3) :: res
      res = .pos
   end

end
