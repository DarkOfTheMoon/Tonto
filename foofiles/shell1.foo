!-------------------------------------------------------------------------------
!
! SHELL1: For describing contracted cartesian gaussian shells with a position
! coordinate
!
! (c) Dylan Jayatilaka, november 1997
!
! $Id$
!
!-------------------------------------------------------------------------------
module SHELL1

   use TYPES
   use STR
   use SYSTEM
   use INT
   use IMAT
   use VEC
   use MAT
   use MAT3
   use TEXTFILE

   implicit none

#  include "macros"
#  include "shell1.int"

!   type shell1_type
!
!   INT :: l
!   ! l quantum number of the shell
!
!   INT :: n_comp
!   ! No. of components for the shell
!
!   INT :: n_cc
!   ! No. of contraction coefficients for the shell
!
!   VEC(3) :: pos
!   ! Position of the shell
!
!   VEC, PTR :: ex DEFAULT_NULL
!   ! Exponent vector
!
!   VEC, PTR :: cc DEFAULT_NULL
!   ! Contraction coefficient vector
!
!   end

contains

   create [leaky]
   ! Create a shell object
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(SHELL1_SIZE)
      .nullify_ptr_part
   end

   create(shell) [leaky]
   ! Create a shell object from another copy
      PTR :: self
      SHELL1, IN :: shell
      .create
      .copy(shell)
   end

   create(shell,pos) [leaky]
   ! Create a shell object from another copy
      PTR :: self
      SHELL, IN :: shell
      VEC(3), IN :: pos
      .create
      .copy(shell,pos)
   end

   destroy [leaky]
   ! Destroy a shell object
      PTR :: self
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEM(SHELL1_SIZE)
      deallocate(self)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
     nullify(.ex)
     nullify(.cc)
   end

   destroy_ptr_part [leaky]
   ! Destroy pointer part of a shell object
      .ex.destroy
      .cc.destroy
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

  copy(shell,pos) [leaky]
  ! Make a shell1 object from the shell and its position.
    SHELL :: shell
    VEC(3), IN :: pos
    .l = shell.l
    .n_comp = shell.n_comp
    .n_cc = shell.n_cc
    .pos = pos
    .ex.destroy
    .ex.create(.n_cc)
    .ex = shell.ex
    .cc.destroy
    .cc.create(.n_cc)
    .cc = shell.cc
  end

  copy(shell) [leaky]
  ! Make a shell1 object from a shell1 object.
    SHELL1, IN :: shell
    .l = shell.l
    .n_comp = shell.n_comp
    .n_cc = shell.n_cc
    .pos = shell.pos
    .ex.destroy
    .ex.create(.n_cc)
    .ex = shell.ex
    .cc.destroy
    .cc.create(.n_cc)
    .cc = shell.cc
  end

   set(shell,pos)
   ! Set a shell1 object.
      VEC, optional :: pos
      SHELL, optional :: shell
      if (present(pos)) .pos = pos
      if (present(shell)) then
         .l = shell.l
         .n_comp = shell.n_comp
         .n_cc = shell.n_cc
         .ex => shell.ex
         .cc => shell.cc
      end
   end

   set(shell)
   ! Set a shell1 object
      SHELL1 :: shell
      .pos = shell.pos
      .l = shell.l
      .n_comp = shell.n_comp
      .n_cc = shell.n_cc
      .ex => shell.ex
      .cc => shell.cc
   end

   set_default
      .l = 0
      .n_comp = 1
      .n_cc = 1
      .pos = ZERO
      .ex.create(1)
      .cc.create(1)
      .ex(1) = ONE
      .cc(1) = ONE
   end

   read_from_input(in)
   ! Read a contracted gaussian self from file "in"
      TEXTFILE :: in
      CHR :: l_c
      INT :: l,i
      in.read(.pos)
      in.read_chr(l_c)
      in.read(.n_cc)
      l_c.to_lower_case
      select case (l_c)
         case ("s"); l = 0
         case ("p"); l = 1
         case ("d"); l = 2
         case ("f"); l = 3
         case ("g"); l = 4
         case default;
            DIE_IF(l_c<"g","unknown angular momentum character:"//l_c)
            l = 4 + iachar(l_c)-iachar("g")
      end
      .l = l
      .n_comp = l.n_comp
      nullify(.ex)
      nullify(.cc)
      .ex.create(.n_cc)
      .cc.create(.n_cc)
      do i = 1,.n_cc
         in.read(.ex(i))
         in.read(.cc(i))
      end
   end

  put(out)
  ! put the shell1 information to file "out"
    TEXTFILE :: out
    INT :: i
    out.flush
    out.show("L quantum number = ", .l)
    out.dash(int_fields=1,dbl_fields=2)
    out.put("position = ", int_width=TRUE)
    do i=1,3
      out.put( .pos(i))
    end
    out.flush
    out.dash(int_fields=1,dbl_fields=2)
    out.put("N", int_width=TRUE)
    out.put("Exponents")
    out.put("Contraction")
    out.flush
    out.dash(int_fields=1,dbl_fields=2)
    do i = 1, .n_cc
      out.put(i)
      out.put( .ex(i))
      out.put( .cc(i), flush=1)
    end
    out.flush
  end

!******************************************************************************
! The Routines
!******************************************************************************

   l_chr result(res)
   ! Return a character representation for the angular mtm
      CHR :: res
      INT :: l
      l = .l
      select case (l)
         case (0); res="s"
         case (1); res="p"
         case (2); res="d"
         case (3); res="f"
         case (4); res="g"
         case default;
            DIE_IF(l>23,"angular momentum too large:"// l.to_str.trim)
            res = achar(l-4+iachar("g"))
      end select
   end

!   make_contraction_matrix(ccm)
!   ! Return the contraction coefficient matrix
!   ! Size of ccm is .n_prim,.n_comp.
!      MAT :: ccm
!      INT :: b,p,i
!      DBL :: f
!      VEC, PTR :: fac
!!     ccm = ZERO
!      fac.create( .n_comp );   fac.normalizing_factors( .l )
!      do b = 1,.n_comp       ! do over basis components
!         p = b               ! primitive p
!         f = fac(b)
!         do i = 1,.n_cc      ! do over contractions
!            ccm(p,b) = f*.cc(i)
!            p = p + .n_comp
!         end
!      end
!      fac.destroy
!   end

   unnormalize
   ! Unnormalise self for cartesian component x^l.
   ! It is up to you to correct this factor with appropriate
   ! double factorial square roots for other components.
      .unnormalise
   end

   unnormalise
   ! Unnormalise self for cartesian component x^l.
   ! It is up to you to correct this factor with appropriate
   ! double factorial square roots for other components.
      INT :: i,j
      DBL :: sum,a,b,ab,pi2,norm,fac
      sum=0
      do i = 1,.n_cc
         a = .ex(i)
         do j = 1,i-1
            b = .ex(j)
            ab = TWO*sqrt(a*b)/(a+b);
            sum = sum + TWO*.cc(i)*.cc(j)*ab**(.l+ONE+HALF);
         end
         sum = sum + .cc(i)*.cc(i)
      end
   !  Take the normalization factor out of the primitive
      pi2 = (HALF/PI)**(THREE/FOUR)
      norm = pi2/sqrt(sum)
      do i = 1,.n_cc
         a = FOUR*.ex(i)
         fac = .l.double_factorial
         fac = ONE/sqrt(fac)
   !     this factor should be: fac = 1/sqrt(df(nx)*df(ny)*df(nz))
   !     where n are the cartesian powers of the basis component
         .cc(i) = .cc(i)*norm*fac*a**(HALF*.l+HALF+QUARTER)
      end
   end

  make_grid(g,pt)
  ! Return "g(i,n)", the value of the shell component "n" on grid point "i"
  ! given a set of grid points "pt(i,1:3)"
    MAT, target :: pt
    MAT, target :: g
    VEC, PTR :: x,y,z
    x => pt(:,1); y => pt(:,2); z => pt(:,3)
    .make_grid(g,x,y,z)
  end

   make_grid(g,x,y,z)
   ! Return "g(i,n)", the value of the shell component "n" on grid point "i"
   ! given a set of grid points "(x(i),y(i),z(i))"
      VEC :: x,y,z
      MAT, target :: g
      VEC, PTR :: grid_p,fac,gb
      IVEC, PTR :: nx,ny,nz
      INT :: n_pt,n,b,j
      DBL :: rr,xx,yy,zz,posx,posy,posz,temp
      n_pt = size(x)
      posx = .pos(1); posy = .pos(2); posz = .pos(3)
      select case (.l)
        case (0)
          do n = 1,n_pt               ! Do the exponential part of the gaussian
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             g(n,1) = sum( .cc * exp( -rr * .ex ))      ! Sum over primitives
          end
        case (1)
          do n = 1,n_pt               ! Do the exponential part of the gaussian
             xx=x(n) - posx; yy=y(n) - posy; zz=z(n) - posz
             rr = xx*xx + yy*yy + zz*zz
             temp = sum( .cc * exp( -rr * .ex ))        ! Sum over primitives
             g(n,1) = xx*temp
             g(n,2) = yy*temp
             g(n,3) = zz*temp
          end
        case default
          nullify(grid_p); grid_p.create(n_pt)
          x = x - posx        ! Make the grid relative to this atom center
          y = y - posy
          z = z - posz
          do n = 1,n_pt               ! Do the exponential part of the gaussian
             xx=x(n); yy=y(n); zz=z(n)
             rr = xx*xx + yy*yy + zz*zz
             grid_p(n) = sum( .cc * exp( -rr * .ex ))    ! Sum over primitives
          end

          nx.create(.n_comp); ny.create(.n_comp); nz.create(.n_comp)
          .l.make_gaussian_xyz_indices(nx,ny,nz)
          fac.create( .n_comp );    fac.normalizing_factors( .l )
          do b = 1,.n_comp             ! Loop over all basis functions
             gb => g(:,b)
             gb(:) = fac(b)*grid_p(:)  ! Combine exponential and cartesian part
             do j = 1,nx(b)            ! power of the x^j part
                gb = x*gb
             end
             do j = 1,ny(b)            ! power of the y^j part
                gb = y*gb
             end
             do j = 1,nz(b)            ! power of the z^j part
                gb = z*gb
             end
          end
          fac.destroy
          nz.destroy; ny.destroy; nx.destroy
          grid_p.destroy
          x = x + posx        ! Put back the grid points
          y = y + posy
          z = z + posz
     end
   end

   make_nabla_grid(g,pt)
   ! Return "g(i,n,1:3)", the value of the gradient of the shell component "n"
   ! on grid point "i" given a set of grid points "pt(i,1:3)".
      MAT :: pt
      MAT3 :: g
      VEC, PTR :: grid_p
      MAT, PTR :: grid_d
      VEC, PTR :: fac
      IMAT, PTR :: nn
      INT :: n_pt,n,b,p,i,j,k
      DBL :: aa,a2,ccp,x,y,z,rr,val
      DIE_IF(size(pt,2)/=3,"pt matrix incorrectly dimensioned")
      n_pt = size(pt,1)
      g = ZERO
      nullify(grid_p); grid_p.create(n_pt)
      nullify(grid_d); grid_d.create(n_pt,3)
      nn.create(3, .n_comp );   .l.make_gaussian_xyz_powers(nn)
      fac.create( .n_comp );  fac.normalizing_factors( .l )
      pt(:,1) = pt(:,1) - .pos(1)   ! Make the grid relative to this atom center
      pt(:,2) = pt(:,2) - .pos(2)
      pt(:,3) = pt(:,3) - .pos(3)
      grid_p = ZERO
      grid_d = ZERO
      do p = 1,.n_cc                ! Loop over primitives
         aa = .ex(p)
         a2 = aa+aa
         ccp = .cc(p)
         do n = 1,n_pt              ! Do the exponential part of the gaussian
            x=pt(n,1); y=pt(n,2); z=pt(n,3)
            rr = x*x + y*y + z*z
            val = ccp*exp(-aa*rr)
            grid_p(n)   = grid_p(n)   + val
            grid_d(n,1) = grid_d(n,1) - a2*x*val
            grid_d(n,2) = grid_d(n,2) - a2*y*val
            grid_d(n,3) = grid_d(n,3) - a2*z*val
         end
      end
      do b = 1,.n_comp                         ! Loop over basis functions
         do k = 1,3                            ! Loop over gradient component k
            if (nn(k,b)==0) then               ! Derivative d/d(x_k) (x_k)^j
               g(:,b,k) = grid_d(:,k)          ! (sum cc(p)*e^{-a(p) rr})
            else
               g(:,b,k) = nn(k,b)*grid_p(:)+pt(:,k)*grid_d(:,k)
               do j = 1,nn(k,b)-1              ! (n-1)th power of the xyz part
                  g(:,b,k) = pt(:,k)*g(:,b,k)
               end
            end
            g(:,b,k) = g(:,b,k)*fac(b)         ! Basis fn. normalization factor
            do i = 1,3                         ! Do the cartesian (x_i)^j, i/=k
               if (k==i) cycle                 ! part of the gaussian
               do j = 1,nn(i,b)                ! power of the xyz part not equal
                  g(:,b,k) = pt(:,i)*g(:,b,k)  ! to gradient component k
               end
            end
         end
      end
      fac.destroy
      nn.destroy
      grid_d.destroy
      grid_p.destroy
      pt(:,1) = pt(:,1) + .pos(1)              ! Put back the grid points
      pt(:,2) = pt(:,2) + .pos(2)
      pt(:,3) = pt(:,3) + .pos(3)
   end

!*****************
!  Inquiry methods
!*****************

   l result(res)
   ! Return the angular momentum l
      INT :: res
      res = .l
   end

   n_comp result(res)
   ! Return the number of components in the shell
      INT :: res
      res = .n_comp
   end

   n_cc result(res)
   ! Return the degree of contraction of the shell
      INT :: res
      res = .n_cc
   end

   n_prim result(res)
   ! Return the number of primitive gaussians in the shell
      INT :: res
      res = .n_comp*.n_cc
   end

   ex result(res)
   ! Return the exponent vector
      VEC(size(.ex)) :: res
      res = .ex
   end

   ex(i) result(res)
   ! Return the exponent
      INT :: i
      DBL :: res
      res = .ex(i)
   end

   cc result(res)
   ! Return the contraction coefficient vector
      VEC(size(.cc)) :: res
      res = .cc
   end

   cc(i) result(res)
   ! Return the contraction coefficient
      INT :: i
      DBL :: res
      res = .cc(i)
   end

   pos result(res)
   ! Return the position.
      VEC(3) :: res
      res = .pos
   end

end
