!---------------------------------------------------------------------------
!
! OBJECT: Generic object operations ...
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

virtual module OBJECT

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!*******************************************************************************
! Memory allocation stuff.
!*******************************************************************************

   create ::: leaky
   ! Create an object
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults
   end

   create ::: leaky
   ! Create an object. This version does not set defaults.
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
   end

   create ::: leaky
   ! Create an object. This version does not nullify point parts.
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .set_defaults
   end

   create ::: leaky
   ! Create an object. This does not nullify point parts or set
   ! defaults.
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
   end

   create_copy(object) ::: leaky
   ! Create a copy of object
      self :: PTR
      object :: OBJECT
      .create
      .copy(object)
   end

   destroy ::: leaky
   ! Destroy an object
      self :: PTR
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEMORY(SELF_TYPE_SIZE)
      deallocate(self)
   end

   destroy ::: leaky
   ! Destroy an object. This version does not destroy pointer parts.
      self :: PTR
      if (.destroyed) return
      DELETE_MEMORY(SELF_TYPE_SIZE)
      deallocate(self)
   end

   created result (res) ::: inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
      result = associated(self)
   end

   destroyed result (res) ::: inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
      result = NOT associated(self)
   end

   set(object)
   ! Set the object. Pointer parts are assigned not copied.
      object :: OBJECT
      self = object
   end

   set(val)
   ! Generic set
      val :: TYPE
      VAL = val
   end

   set_saved_self 
   ! Set saved_self
      self :: PTR
      saved_self => self
   end

   set_saved_self 
   ! Set saved_self. This version has self a target.
      self :: target
      saved_self => self
   end

!*******************************************************************************
! I/O routines.
!*******************************************************************************

   redirect ::: leaky
   ! Redirect input
      self :: PTR
      stdin.redirect(stdin.next_str)
   end

   revert ::: leaky
   ! Revert back to previous stdin file
      self :: PTR
      stdin.revert
   end

   redirect ::: leaky
   ! Redirect input. (This code is for non-pointer self objects).
      stdin.redirect(stdin.next_str)
   end

   revert ::: leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
      stdin.revert
   end

   read_keywords ::: recursive, leaky
   ! Read data from "stdin" using keyword style input.
   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")
      word :: STR

      ! Read the open braces {
      stdin.read(word)

      ! Echo keyword if requested
      if (tonto.keyword_echo) then
         stdout.flush
         stdout.text("keyword found --> " // trim(word))
      end

      do ! Loop over input keywords

         ! Read the keyword
         stdin.read(word)
         DIE_IF(stdin.reverted,"unexpected end of file while reading list keywords")
         word.to_lower_case

         ! Append any lonely = sign
         if (NOT stdin.buffer_exhausted) then 
         if (stdin.next_item=="=") then 
            stdin.skip_next_item
            word = trim(word) // "="
         end
         end

         ! Echo keyword if requested
         if (tonto.keyword_echo) then
            stdout.flush
            stdout.text("keyword found --> " // trim(word))
         end

         ! Exit if keyword is closing brace }
         if (word=="}")      exit

         ! Process the keyword 
         .process_keyword(word)

      end

   end

   read_keywords ::: recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")
      word :: STR

      ! Read the open braces {
      stdin.read(word)

      ! Echo keyword if requested
      if (tonto.keyword_echo) then
         stdout.flush
         stdout.text("keyword found --> " // trim(word))
      end

      do ! Loop over input keywords

         ! Read the keyword
         stdin.read(word)
         DIE_IF(stdin.reverted,"unexpected end of file while reading list keywords")
         word.to_lower_case

         ! Append any lonely = sign
         if (NOT stdin.buffer_exhausted) then 
         if (stdin.next_item=="=") then ! assume this is an attached = sign
            stdin.skip_next_item
            word = trim(word) // "="
         end
         end

         ! Echo keyword if requested
         if (tonto.keyword_echo) then
            stdout.flush
            stdout.text("keyword found --> " // trim(word))
         end

         ! Exit if keyword is closing brace }
         if (word=="}")      exit

         ! Process the keyword 
         .process_keyword(word)

      end

   end

   read_units ::: selfless
   ! Read a string which describes the units to be used
      stdin.set_default_units(stdin.next_str)
   end

   read_junk ::: selfless
   ! Read in a junk string, useful for ignoring a field
      stdin.skip_next_item
   end

   read_and_set
   ! Generic read and set
      val :: TYPE
      stdin.read(val)
      SET(val)
   end

   read_and_set
   ! Generic read and set a quantity with units
      val :: TYPE
      stdin.read_quantity(val)
      SET(val)
   end

   put_table_footer
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
      stdout.dash(width=.table_width)
   end

!*******************************************************************************
! Key related routines.
!*******************************************************************************

   read_keys
   ! Read the "keys".
      .clear_keys
      stdin.read_ptr(keys)
      IGNORE_MEMORY_LEAK(memory_blocks_gained=1)
   end

   process_keys ::: leaky
   ! Process each of the words in the "keys" list.
   ENSURE(keys.created,"no keys")
      k,l,n_key :: INT
      keyword :: STR
      keyword_echo :: BIN
      internal :: VEC{STR}*

      ! The number of keys
      n_key = size(keys)

      ! Keyword counter
      k = 0

      do ! Loop over keywords in "keys"

         ! Get the next keyword
         k = k + 1
         keyword = keys(k)

         ! Exit if close brace
         if (keyword=="}") exit

         if (keyword=="{") then ! embedded keyword

            ! Turn off keyword echo
            keyword_echo = tonto.keyword_echo
            tonto.keyword_echo = FALSE

            ! Find closing brace of embedded section
            l = keys(k:).index_of_matching_bracket("{")
            DIE_IF(l==0,"no matching closing brace in embedded keyword")

            ! Set internal array
            internal => keys(k:k+l-1)

            ! Process internalized keywords
            stdin.redirect(internal)
            .read_keywords
            stdin.revert

            ! Reset key counter
            k = k + l - 1

            ! Reset keyword echo
            tonto.keyword_echo = keyword_echo

         else ! plain-old keyword

            ! Process plain-old keyword
            .process_keyword(keyword)

         end

         ! Exit if no keys left
         if (k==n_key) exit

      end

   end

   keys_created result (res)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
      res = keys.created
   end

   set_keys(the_keys)
   ! This is for setting the "keys" externally.
      the_keys :: VEC{STR}
      .clear_keys
      keys.create_copy(the_keys)
      IGNORE_MEMORY_LEAK(memory_blocks_gained=1)
   end

   clear_keys
   ! This is for destroying the "keys" externally.
      if (keys.created) then
       keys.destroy
       IGNORE_MEMORY_LEAK(memory_blocks_gained=-1)
      end
   end

end
