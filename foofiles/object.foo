!---------------------------------------------------------------------------
!
! OBJECT: Generic object operations ...
!
! Copyright (C) Dylan Jayatilaka, 1997
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

virtual module OBJECT

   implicit none

contains

!*******************************************************************************
! Memory allocation stuff.
!*******************************************************************************

   create ::: leaky
   ! Create an object
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults
   end

   create ::: leaky
   ! Create an object. This version does not set defaults.
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
   end

   create ::: leaky
   ! Create an object. This version does not nullify point parts.
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .set_defaults
   end

   create ::: leaky
   ! Create an object. This does not nullify point parts or set
   ! defaults.
      self :: PTR
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
   end

   create_copy(object) ::: leaky
   ! Create a copy of object
      self :: PTR
      object :: OBJECT
      .create
      .copy(object)
   end

   create_and_copy(object) ::: leaky
   ! Create self and copy object
      self :: PTR
      object :: OBJECT
      .create
      .copy(object)
   end

   destroy_and_copy(object) ::: leaky
   ! Destroy and recreate self, and copy object
      self :: PTR
      object :: OBJECT
      .destroy
      .create
      .copy(object)
   end

   destroy ::: leaky
   ! Destroy an object
      self :: PTR
      if (.destroyed) return
      .destroy_ptr_part
      DELETE_MEMORY(SELF_TYPE_SIZE)
      deallocate(self)
   end

   destroy ::: leaky
   ! Destroy an object. This version does not destroy pointer parts.
      self :: PTR
      if (.destroyed) return
      DELETE_MEMORY(SELF_TYPE_SIZE)
      deallocate(self)
   end

   created result (res) ::: inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
      result = associated(self)
   end

   destroyed result (res) ::: inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
      result = NOT associated(self)
   end

   set(object)
   ! Set the object. Pointer parts are assigned not copied.
      object :: OBJECT
      self = object
   end

   set_saved_self 
   ! Set saved_self
      self :: PTR
      saved_self => self
   end

   set_saved_self 
   ! Set saved_self. This version has self a target.
      self :: target
      saved_self => self
   end

!*******************************************************************************
! I/O routines.
!*******************************************************************************

   redirect ::: leaky
   ! Redirect input
      self :: PTR
      stdin.redirect(stdin.next_str)
   end

   revert ::: leaky
   ! Revert back to previous stdin file
      self :: PTR
      stdin.revert
   end

   redirect ::: leaky
   ! Redirect input. (This code is for non-pointer self objects).
      stdin.redirect(stdin.next_str)
   end

   revert ::: leaky
   ! Revert back to previous stdin file. (This code is for non-pointer self
   ! objects).
      stdin.revert
   end

   read_keywords ::: recursive, leaky
   ! Read data from "stdin" using keyword style input.
   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")
      word :: STR
      stdin.read(word)
      if (tonto.keyword_echo) then
         stdout.flush
         stdout.text("keyword found --> " // trim(word))
      end
      do                 ! Loop over input keywords
         stdin.read(word)
         DIE_IF(stdin.reverted,"unexpected end of file while reading list keywords")
         word.to_lower_case
         if (NOT stdin.buffer_exhausted) then 
         if (stdin.next_item=="=") then ! assume this is an attached = sign
            stdin.skip_next_item
            word = trim(word) // "="
         end
         end
         if (tonto.keyword_echo) then
            stdout.flush
            stdout.text("keyword found --> " // trim(word))
         end
         if (word=="}")      exit
         .process_keyword(word)
      end
   end

   read_keywords ::: recursive, leaky
   ! Read data from "stdin" using keyword style input.
      self :: PTR
   ENSURE(stdin.next_item=="{","expecting open bracket symbol, {")
      word :: STR
      stdin.read(word)
      if (tonto.keyword_echo) then
         stdout.flush
         stdout.text("keyword found --> " // trim(word))
      end
      do                 ! Loop over input keywords
         stdin.read(word)
         DIE_IF(stdin.reverted,"unexpected end of file while reading list keywords")
         word.to_lower_case
         if (NOT stdin.buffer_exhausted) then 
         if (stdin.next_item=="=") then ! assume this is an attached = sign
            stdin.skip_next_item
            word = trim(word) // "="
         end
         end
         if (tonto.keyword_echo) then
            stdout.flush
            stdout.text("keyword found --> " // trim(word))
         end
         if (word=="}")      exit
         .process_keyword(word)
      end
   end

   read_units ::: selfless
   ! Read a string which describes the units to be used
      stdin.set_default_units(stdin.next_str)
   end

   read_junk ::: selfless
   ! Read in a junk string, useful for ignoring a field
      stdin.skip_next_item
   end

   put_table_footer
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
      stdout.dash(width=.table_width)
   end

!*******************************************************************************
! Key related routines.
!*******************************************************************************

   read_keys
   ! Read the "keys".
      .clear_keys
      stdin.read_ptr(keys)
      IGNORE_MEMORY_LEAK(memory_blocks_gained=1)
   end

   process_keys ::: leaky
   ! Process each of the words in the "keys" list.
   ENSURE(keys.created,"no keys")
      k,l,n_key :: INT
      keyword :: STR
      keyword_echo :: BIN
      internal :: VEC{STR}*
      n_key = size(keys)
      k = 0
      do
         k = k + 1
         keyword = keys(k)
         if (keyword=="}") exit
         if (keyword=="{") then               ! Brace-embedded keywords
            keyword_echo = tonto.keyword_echo
            tonto.keyword_echo = FALSE
            l = keys(k:).index_of_matching_bracket("{")
            ENSURE(l>0,"no matching closing brace, }")
            internal => keys(k:k+l-1)
            stdin.redirect(internal)
            .read_keywords
            stdin.revert
            k = k+l-1
            tonto.keyword_echo = keyword_echo
         else
            .process_keyword(keyword)
         end
         if (k==n_key) exit
      end
   end

   keys_created result (res)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
      res = keys.created
   end

   set_keys(the_keys)
   ! This is for setting the "keys" externally.
      the_keys :: VEC{STR}
      .clear_keys
      keys.create_copy(the_keys)
      IGNORE_MEMORY_LEAK(memory_blocks_gained=1)
   end

   clear_keys
   ! This is for destroying the "keys" externally.
      if (keys.created) then
       keys.destroy
       IGNORE_MEMORY_LEAK(memory_blocks_gained=-1)
      end
   end

end
