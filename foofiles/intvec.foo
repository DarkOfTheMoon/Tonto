!---------------------------------------------------------------------------
!
!  IVEC : Integer vector operations ...
!
!  (c) dylan jayatilaka, 1997
!
! $Id$
!---------------------------------------------------------------------------
module IVEC

   use TYPES
   use ERROR
   use MM
   use INT
   use DBL

   implicit none         

#  include "macros"
#  include "ivec.int"
   
contains

   create(dim)
   ! Create an ivec
      PTR :: self
      INT, IN :: dim
      ENSURE(dim>0, "dimension of array not 1 or greater")
      nullify(self)
      allocate(self(dim))
      std_mm.add(dim*INT_SIZE)
   end

   create(lb,ub)
   ! Create an ivec with lower bound "lb" and upper bound "ub"
      PTR :: self
      INT, IN :: lb,ub
      ENSURE(ub>lb, "dimension of array not 1 or greater")
      nullify(self)
      allocate(self(lb:ub))
      std_mm.add((ub-lb+1)*INT_SIZE)
   end

   create(bounds)
   ! Create an ivec with  given by the elements of "bounds"
      PTR :: self
      IVEC(2), IN :: bounds
      .create(bounds(1),bounds(2))
   end

   destroy
   ! Destroy an ivec
      PTR :: self
      if (.destroyed) return
      std_mm.delete(size(self)*INT_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end
   
   sum_elements result (res) [pure]
   ! Sums the elements of self.
      IN :: self
      DBL :: res
      res = sum(self)
   end 
   
   dot(v) result (res) [pure]
   ! Returns the dot product of self with v.
      IN :: self
      IVEC, IN :: v
      DBL :: res
      res = dot_product(self,v)
   end 
   
   minus(v)
   ! Subtracts v from self.
      IVEC, IN :: v
      self = self - v
   end
   
   plus(v)
   ! Adds v to self.
      IVEC, IN :: v
      self = self + v
   end
   
   set_to(v)
   ! Sets self to v.
      IVEC, IN :: v
      self = v
   end
   
   zero
   ! Sets all elements of self to zero.
      self = ZERO
   end
   
  to_str result(vecstring)
  ! returns the ivec as a comma delimited string
    STR :: vecstring
    INT :: count
    vecstring = ""
    vecstring = (self(1)).to_str
    do count = 2, size( self)
       vecstring = trim( vecstring) // "," // trim( (self(count)).to_str)
    end
  end  
  
  shrink(dim) [leaky]
  ! Shrinks self to dimension dim.  Contents are retained.
    PTR :: self
    IVEC, PTR :: old
    INT, IN :: dim
    old => self
    nullify(self)
    self.create(dim)
    self=old(1:dim)
    old.destroy
  end

  expand(dim) [leaky]
  ! Expands self to dimension dim.  Contents are retained.
  ! Elements added are set to zero.
    PTR :: self
    IVEC, PTR :: old
    INT, IN :: dim
    INT :: old_size
    old => self
    old_size=size(old)
    nullify(self)
    self.create(dim)
    self(1:old_size)=old
    self(old_size+1:dim)=0
    old.destroy
  end
  
  first_nonzero_component result(res) [pure]
  ! Returns the index of the first nonzero component of self.
    IN :: self
    INT :: res
    INT :: i
    res=0
    do i=1,size(self)
      if (self(i)/=0) then
        res=i
        exit
      end
    end
  end
  
  index_of_first_nonzero_value result(res) [pure]
  ! Returns the index of the first nonzero component of self.
    IN :: self
    INT :: res
    INT :: i
    res=0
    do i=1,size(self)
      if (self(i)/=0) then
        res=i
        exit
      end
    end
  end
  
  index_of_value(k) result(pos) [pure]
  ! Returns the first index in "self" which has the value "k", 
  ! or 0 if it is not present.
    IN :: self
    INT, IN :: k
    INT :: pos
    INT :: i
    pos = 0
    do i = 1,size(self)
       if (self(i)/=k) cycle
       pos = i
       exit
    end
  end

  same_as(compare) result(same) [pure]
  ! Returns .TRUE. if self and compare are the same IVEC
     IN :: self
     IVEC, IN :: compare
     INT :: i
     BIN :: same
     same = TRUE
     if (size(compare) == size(self)) then
        do i = 1, size(self)
           same = same AND (self(i) == compare(i))
        end
     else
       same = FALSE
     end
  end
  
  get_combination_matrix_from(k) result(C) [recursive] [leaky]
  ! Returns the combination matrix of all combs of k-length combs of self
    INT :: k, s, t
    IMAT, PTR :: C
    s = size(self)
    t = s - 1
    nullify(C)
    allocate( C( k, nint( s.choose(k),kind=INT_KIND)))
    if (k==1) C(1,:)=self(:)
    if ((s > k) AND (k/=1)) then
      C(1,     1 : nint( t.choose(k-1),kind=INT_KIND)) = self(1)
      C(2 : k, 1 : nint( t.choose(k-1),kind=INT_KIND)) = self(2:).get_combination_matrix_from( k-1)        
      C(:,nint( t.choose(k-1),kind=INT_KIND) + &
               1:nint( s.choose(k),kind=INT_KIND)) = self(2:).get_combination_matrix_from(k)
    end
    if (k==s) C(:,1)=self(:)
  end               

end
