!-------------------------------------------------------------------------------
!
! SHELL4 : Group of 4 contracted gaussian SHELL1's, used mainly for integrals
! (c) Daniel Grimwood, March 1998
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 5889-5897.
!
! $Id$
!-------------------------------------------------------------------------------

module SHELL4

  use TYPES
  use SYSTEM
  use INT
  use IVEC
  use IMAT
  use IMAT3
  use VEC
  use MAT
  use MAT3
  use MAT4
  use TEXTFILE
  use RYS
  use GAUSSIAN4
  use SHELL1
  use SHELL2

  implicit none         

#include "macros"
#include "shell4.int"

!   type shell4_type
!
!   SHELL1 :: a
!   ! Shell "a" of the quartet
!
!   SHELL1 :: b
!   ! Shell "b" of the quartet
!
!   SHELL1 :: c
!   ! Shell "c" of the quartet
!
!   SHELL1 :: d
!   ! Shell "d" of the quartet
!
!   end

contains

  create [leaky]
  ! Create a shell4 object, but no its component shells.
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SHELL4_SIZE)
    .nullify_ptr_part
  end

  create(shell_a,shell_b,shell_c,shell_d) [leaky]
  ! Create a shell4 object from copies of shell1s.
    PTR :: self
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .create
    .copy(shell_a,shell_b,shell_c,shell_d)
  end

  create(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) [leaky]
  ! Create a shell4 object from copies of shells and their positions.
    PTR :: self
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC(3), IN :: pos_a,pos_b,pos_c,pos_d
    .create
    .copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  end

  destroy [leaky]
  ! Destroy a shell4 object.
    PTR :: self
    if (associated(self)) then
      .destroy_ptr_part
      DELETE_MEM(SHELL4_SIZE)
      deallocate(self)
    end
  end

  created result(res)
  ! Returns true if self has been created
    PTR :: self
    BIN :: res
    res = associated(self)
  end

  destroyed result(res)
  ! Returns true if self has *not* been created
    PTR :: self
    BIN :: res
    res = NOT associated(self)
  end

  nullify_ptr_part
  ! Nullify the pointer parts of self
    .a.nullify_ptr_part
    .b.nullify_ptr_part
    .c.nullify_ptr_part
    .d.nullify_ptr_part
  end

  destroy_ptr_part [leaky]
  ! Destroy the pointer parts of self
    .a.destroy_ptr_part
    .b.destroy_ptr_part
    .c.destroy_ptr_part
    .d.destroy_ptr_part
  end

  destroy_ab [leaky]
  ! Destroy the shella and shellb pointer parts of self
    .a.destroy_ptr_part
    .b.destroy_ptr_part
  end

  destroy_cd [leaky]
  ! Destroy the shellc and shelld pointer parts of self
    .c.destroy_ptr_part
    .d.destroy_ptr_part
  end

  put(out)
  ! Put the shell4 information to file "out"
    TEXTFILE :: out
    out.put_text("Shell a:",flush=1)
    .a.put(out)
    out.put_text("Shell b:",flush=1)
    .b.put(out)
    out.put_text("Shell c:",flush=1)
    .c.put(out)
    out.put_text("Shell d:",flush=1)
    .d.put(out)
    out.flush
  end

  copy(shell_a,shell_b,shell_c,shell_d) [leaky]
  ! Copy the shell4 using from shell1 objects
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .a.copy(shell_a)
    .b.copy(shell_b)
    .c.copy(shell_c)
    .d.copy(shell_d)
  end

  copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) [leaky]
  ! Set the shell4 using shell objects and positions
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC, IN :: pos_a,pos_b,pos_c,pos_d
    .a.copy(shell_a,pos_a)
    .b.copy(shell_b,pos_b)
    .c.copy(shell_c,pos_c)
    .d.copy(shell_d,pos_d)
  end

  set(shell_a,shell_b,shell_c,shell_d)
  ! Set the shell4 using from shell1 objects
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .a.set(shell_a)
    .b.set(shell_b)
    .c.set(shell_c)
    .d.set(shell_d)
  end

  copy_ab(shell_a,shell_b,pos_a,pos_b) [leaky]
  ! Copy the a and b parts of the shell4 using from shell1 objects
    SHELL, IN :: shell_a,shell_b
    VEC, IN :: pos_a,pos_b
    .a.copy(shell_a,pos_a)
    .b.copy(shell_b,pos_b)
  end

  copy_cd(shell_c,shell_d,pos_c,pos_d) [leaky]
  ! Copy the c and d parts of the shell4 using from shell1 objects
    SHELL, IN :: shell_c,shell_d
    VEC, IN :: pos_c,pos_d
    .c.copy(shell_c,pos_c)
    .d.copy(shell_d,pos_d)
  end

  set(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  ! Set the shell4 using shell objects and positions
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC, IN :: pos_a,pos_b,pos_c,pos_d
    .a.set(shell_a,pos_a)
    .b.set(shell_b,pos_b)
    .c.set(shell_c,pos_c)
    .d.set(shell_d,pos_d)
  end

  unnormalize
  ! Unnormalize each shell in this shell quartet
    .a.unnormalize
    .b.unnormalize
    .c.unnormalize
    .d.unnormalize
  end

  max_k_ab result(res)
  ! Returns the maximum value of .a%cc * .b%cc * k_ab over all contractions of a
  ! and b.  k_ab is kappa_ab, for the two electron integrals.
    DBL :: res
    VEC(3) :: AB
    DBL :: r2ab,ex_a,ex_b,k_ab,cc_a,ex_a_r2ab,norm
    INT :: a,b

    AB = .a%pos - .b%pos
    r2ab=dot_product(AB,AB)
    res = ZERO
    do a = 1, .a%n_cc
      ex_a = .a%ex(a)
      cc_a = .a%cc(a)
      ex_a_r2ab = ex_a * r2ab
      do b = 1, .b%n_cc
        ex_b = .b%ex(b)
        k_ab = exp(-ex_a_r2ab * ex_b / (ex_a + ex_b))
        norm = abs(.b%cc(b) * cc_a * k_ab)
        if (norm > res) res = norm
      end
    end
  end

  max_k_cd result(res)
  ! Returns the maximum value of .c%cc * .d%cc * k_cd over all contractions of a
  ! and b.  k_cd is kappa_cd, for the two electron integrals.
    DBL :: res
    VEC(3) :: CD
    DBL :: r2cd,ex_c,ex_d,k_cd,cc_c,ex_c_r2cd,norm
    INT :: c,d

    CD = .c%pos - .d%pos
    r2cd=dot_product(CD,CD)
    res = ZERO
    do c = 1, .c%n_cc
      ex_c = .c%ex(c)
      cc_c = .c%cc(c)
      ex_c_r2cd = ex_c * r2cd
      do d = 1, .d%n_cc
        ex_d = .d%ex(d)
        k_cd = exp(-ex_c_r2cd * ex_d / (ex_c + ex_d))
        norm = abs(.d%cc(d) * cc_c * k_cd)
        if (norm > res) res = norm
      end
    end
  end

  skip_ERI result (res)
  ! Whether the ERI block will be less than a cutoff value.
    BIN :: res
    DBL :: max_ab,max_cd

    max_ab = .max_k_ab
    max_cd = .max_k_cd

    if (max_ab*max_cd > SHELL4_ERI_CUTOFF) then
      res = FALSE
    else
      res = TRUE
    end

  end

!  **********************
!  CADPAC-style integrals
!  **********************

   make_ERI_ints(I)
   ! Make the ERI integral matrix, using Gauss-Hermite quadrature, like in
   ! CADPAC.
   ! This is not expected to be as efficient as Daniel's code, below!
   ! But probably much easier to understand.
      MAT4 :: I
      MAT4, PTR :: II
      GAUSSIAN4 :: G
      INT :: a,b,c,d
      I = ZERO
      II.create(.a%n_comp,.b%n_comp,.c%n_comp,.d%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_ERI_ints(II)
         I = I + II*.a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
      end
      end
      end
      end
      II.destroy
      .to_normalize(I)
   end

   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
   ! Make the spin same orbit integrals, "Sx", ... , and the
   ! spin other orbit integrals "Ox", ... , using 
   ! Gauss-Hermite quadrature. Probably not the best implementation.
      MAT4 :: Sx,Sy,Sz,Ox,Oy,Oz
      MAT4, PTR :: SSx,SSy,SSz,OOx,OOy,OOz
      GAUSSIAN4 :: G
      INT :: a,b,c,d,na,nb,nc,nd
      DBL :: cc
      Sx = ZERO; Sy = ZERO; Sz = ZERO
      Ox = ZERO; Oy = ZERO; Oz = ZERO
      na = .a%n_comp; nb = .b%n_comp; nc =.c%n_comp; nd =.d%n_comp
      SSx.create(na,nb,nc,nd); SSy.create(na,nb,nc,nd); SSz.create(na,nb,nc,nd)
      OOx.create(na,nb,nc,nd); OOy.create(na,nb,nc,nd); OOz.create(na,nb,nc,nd)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_spin_orbit_ints(SSx,SSy,SSz,OOx,OOy,OOz)
         cc = .a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
         Sx = Sx + SSx*cc; Sy = Sy + SSy*cc; Sz = Sz + SSz*cc
         Ox = Ox + OOx*cc; Oy = Oy + OOy*cc; Oz = Oz + OOz*cc
      end 
      end
      end
      end
      OOz.destroy; OOy.destroy; OOx.destroy
      SSz.destroy; SSy.destroy; SSx.destroy
      .to_normalize(Sx); .to_normalize(Sy); .to_normalize(Sz)
      .to_normalize(Ox); .to_normalize(Oy); .to_normalize(Oz)
   end

   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
   ! Make the spin spin magnetic dipole integrals, "Dij"
   ! using Gauss-Hermite quadrature. For sure, not the 
   ! best implementation, but where else will you get em', eh?
      MAT4 :: Dxx,Dyy,Dzz,Dxy,Dxz,Dyz
      MAT4, PTR :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
      GAUSSIAN4 :: G
      INT :: a,b,c,d,na,nb,nc,nd
      DBL :: cc
      Dxx = ZERO; Dyy = ZERO; Dzz = ZERO
      Dxy = ZERO; Dxz = ZERO; Dyz = ZERO
      na = .a%n_comp; nb = .b%n_comp; nc =.c%n_comp; nd =.d%n_comp
      Mxx.create(na,nb,nc,nd); Myy.create(na,nb,nc,nd); Mzz.create(na,nb,nc,nd)
      Mxy.create(na,nb,nc,nd); Mxz.create(na,nb,nc,nd); Myz.create(na,nb,nc,nd)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_spin_spin_dipole_ints(Mxx,Myy,Mzz,Mxy,Mxz,Myz)
         cc = .a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
         Dxx = Dxx + Mxx*cc; Dyy = Dyy + Myy*cc; Dzz = Dzz + Mzz*cc
         Dxy = Dxy + Mxy*cc; Dxz = Dxz + Mxz*cc; Dyz = Dyz + Myz*cc
      end 
      end
      end
      end
      Myz.destroy; Mxz.destroy; Mxy.destroy
      Mzz.destroy; Myy.destroy; Mxx.destroy
      .to_normalize(Dxx); .to_normalize(Dyy); .to_normalize(Dzz)
      .to_normalize(Dxy); .to_normalize(Dxz); .to_normalize(Dyz)
   end

!  ****************************
!  Roland Lindh-style integrals
!  ****************************

  get_eri(abcd)
  ! The main routine to produce the block (ab|cd)
  ! (uses the transfer equation to make (ab|cd) from (es|fs))
  ! The routines are now all specialised, they will break if you use the wrong
  ! one.  Best to just use this main routine.
    IN :: self
    MAT4, OUT :: abcd
    INT :: n_e,n_f,opt,maxl

    maxl = max(.a.l,.b.l,.c.l,.d.l)
    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    select case (maxl)
      case (0)                                              ! max is s function
        .make_ssss(abcd)
      case (1)                                              ! max is p function
        if (n_e==0) opt = 1
        if (n_e==1) opt = 4
        if (n_e==2) opt = 7
        if (n_f==1) opt = opt + 1
        if (n_f==2) opt = opt + 2
        select case (opt)
!          case (9); .make_pppp(abcd)
!          case (8); .make_ppps(abcd)
!          case (7); .make_ppss(abcd)
!          case (6); .make_pspp(abcd)
!          case (5); .make_psps(abcd)
!          case (4); .make_psss(abcd)
!          case (3); .make_sspp(abcd)
!          case (2); .make_ssps(abcd)
          case (9); .make_abcd(abcd)
          case (8); .make_abcd(abcd)
          case (7); .make_abcd(abcd)
          case (6); .make_abcd(abcd)
          case (5); .make_psps(abcd)
          case (4); .make_psss(abcd)
          case (3); .make_sscd(abcd)
          case (2); .make_ssps(abcd)
         !case (1); .make_ssss(abcd)
        end
      case default                                          ! general
        if (n_e == 0) then;      .make_sscd(abcd)
        else if (n_f == 0) then; .make_abss(abcd)
        else;                    .make_abcd(abcd)
        end
    end
  end

  get_norm_ab(norm)
  ! Get the a%cc * b%cc * (zeta)^(-3/2) * kappa_ab factors for the ERI.
    MAT :: norm
    DBL :: normb,b_r2ab,r2ab,a,b,zinv,kab
    INT :: bg,ag
    VEC(3) :: AB
    AB   = .a%pos - .b%pos
    r2ab = dot_product(AB,AB)
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = .b%cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zinv = ONE / (a + b)
        kab  = exp(-a * b_r2ab * zinv)
        norm(ag,bg) = normb * .a%cc(ag) * zinv * sqrt(zinv) * kab
      end
    end
  end

  get_norm_cd(norm)
  ! Get the c%cc * d%cc * (eta)^(-3/2) * kappa_cd factors for the ERI.
    MAT :: norm
    DBL :: normd,d_r2cd,r2cd,c,d,einv,kcd
    INT :: dg,cg
    VEC(3) :: CD
    CD   = .c%pos - .d%pos
    r2cd = dot_product(CD,CD)
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = .d%cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        einv = ONE / (c + d)
        kcd  = exp(-c * d_r2cd * einv)
        norm(cg,dg) = normd * .c%cc(cg) * einv * sqrt(einv) * kcd
      end
    end
  end

  make_abcd(abcd)
  ! Makes the (ab|cd) integrals, summed over the primitives
  ! This is the general purpose routine.
    IN :: self
    MAT4, OUT :: abcd
    MAT3, PTR :: escd
    MAT, PTR :: esfs
    INT :: n_e,n_f,eub,fub,opt

    nullify(esfs)
    nullify(escd)
    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum
    esfs.create(eub,fub)
    .make_esfs(esfs)
    escd.create(eub, .c%n_comp, .d%n_comp)
    .transfer(esfs,escd)
    .transfer(escd,abcd)
    escd.destroy
    esfs.destroy
    .to_normalize(abcd)
  end

  make_esfs(esfs)
  ! Makes the initial (es|fs) integrals, summed over the primitives
    IN :: self
    MAT, OUT:: esfs
    MAT4, PTR :: Ix,Iy,Iz
    RYS, PTR :: rysa
    VEC(3) :: AB,PA,QC,QP
    INT :: ag,bg,cg,dg,nroots,eub,fub,dim1,dim2,n_e,n_f,cc_dd,minle,minlf,i,n_cc
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab
    DBL :: norma,normb,normd,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz
    MAT, PTR :: normcd

    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum
    minle=min(.a%l,.b%l)
    minlf=min(.c%l,.d%l)

    dim1 = n_e + 1
    dim2 = n_f + 1
    nroots = (dim1+dim2)/2
nroots = max(nroots,2)

    AB = .a%pos - .b%pos
    r2ab=dot_product(AB,AB)

    Ax = .a%pos(1);  Ay = .a%pos(2);  Az = .a%pos(3)
    Bx = .b%pos(1);  By = .b%pos(2);  Bz = .b%pos(3)
    Cx = .c%pos(1);  Cy = .c%pos(2);  Cz = .c%pos(3)
    Dx = .d%pos(1);  Dy = .d%pos(2);  Dz = .d%pos(3)
    if (.a%l > .b%l) then
      Atx = Ax;  Aty = Ay;  Atz = Az
    else
      Atx = Bx;  Aty = By;  Atz = Bz
    end
    if (.c%l > .d%l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    n_cc = .a%n_cc * .b%n_cc * .c%n_cc * .d%n_cc
    Ix.create(nroots,n_cc,dim1,dim2)
    Iy.create(nroots,n_cc,dim1,dim2)
    Iz.create(nroots,n_cc,dim1,dim2)

    normcd.create(.c%n_cc,.d%n_cc)
    .get_norm_cd(normcd)

    rysa.create(nroots)
    i = 0
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = TWOPI5ON2 * .b%cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a%cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        PA(1) = PAx
        PA(2) = PAy
        PA(3) = PAz
        do dg = 1, .d%n_cc
          d   = .d%ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c%n_cc
            i = i + 1
            c    = .c%ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho_zinv) * normcd(cg,dg)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rysa.get_weights(xx)
            QC = (/Qx - Ctx, Qy - Cty, Qz - Ctz/)
            QP = (/QPx,QPy,QPz/)
            rysa%w(:) = rysa%w(:) * norm
            .form_2d_ints(Ix,Iy,Iz,nroots,rysa,rho_zinv,rho_einv,zinv,einv,PA,QC,QP,n_e,n_f,i)
          end
        end
      end
    end
    rysa.destroy
    normcd.destroy

    .form_esfs(Ix,Iy,Iz,esfs,eub,fub,nroots,dim1,dim2,n_cc)
    Iz.destroy
    Iy.destroy
    Ix.destroy
  end

  form_2d_ints(Ixa,Iya,Iza,nroots,rys,rho_zinv,rho_einv,zinv,einv,PA,QC,QP,n_e,n_f,i)
  ! Forms the two dimentional integrals
  ! n_e and n_f MUST be greater than 0.
    IN :: self
    MAT4, target, OUT :: Ixa,Iya,Iza
    RYS, IN :: rys
    INT, IN :: nroots,n_e,n_f,i
    DBL, IN :: rho_zinv,rho_einv,zinv,einv
    VEC, IN :: PA,QC,QP
    MAT, PTR :: Ix,Iy,Iz
    DBL :: ce,cf,bb,ce1
    VEC, PTR :: Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22
    INT :: e,f,e1,f1,fp1,ep1,n
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,PAx,PAy,PAz
    DBL :: Ix12n,Iy12n,Iz12n,Ix21n,Iy21n,Iz21n
    DBL :: Ix1f1,Iy1f1,Iz1f1,Ix1f,Iy1f,Iz1f,Ix1fp1,Iy1fp1,Iz1fp1
    DBL :: Ix2f1,Iy2f1,Iz2f1,Ix2f,Iy2f,Iz2f,Ix2fp1,Iy2fp1,Iz2fp1
    DBL :: Ix22n,Iy22n,Iz22n
    DBL :: Ixe11,Iye11,Ize11,Ixe1,Iye1,Ize1,Ixep11,Iyep11,Izep11
    DBL :: Ixef,Iyef,Izef,Ixef1,Iyef1,Izef1
    DBL :: t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb,f1_cf,e1_ce

    half_zinv = HALF * zinv
    QPx = QP(1); QPy = QP(2); QPz = QP(3)
    PAx = PA(1); PAy = PA(2); PAz = PA(3)
    QCx = QC(1); QCy = QC(2); QCz = QC(3)
    if (n_f/=1) then                                     ! ab|cd integrals
      half_einv = HALF * einv
      do n=1,nroots
        Ix => Ixa(n,i,:,:)
        Iy => Iya(n,i,:,:)
        Iz => Iza(n,i,:,:)
        Ix(1,1) = ONE
        Iy(1,1) = ONE
        Iz(1,1) = ONE
        t2    = rys%r(n)
        t2_rz = t2 * rho_zinv
        t2_re = t2 * rho_einv
        bb    = t2_rz * half_einv
        cf    = (ONE - t2_re) * half_einv
        ce    = (ONE - t2_rz) * half_zinv
        Ix12n = QCx - t2_re * QPx
        Iy12n = QCy - t2_re * QPy
        Iz12n = QCz - t2_re * QPz
        Ix21n = PAx + t2_rz * QPx
        Iy21n = PAy + t2_rz * QPy
        Iz21n = PAz + t2_rz * QPz
        Ix22n = Ix12n * Ix21n + bb
        Iy22n = Iy12n * Iy21n + bb
        Iz22n = Iz12n * Iz21n + bb
if (n_f>0) then
Ix(1,2) = Ix12n; Iy(1,2) = Iy12n; Iz(1,2) = Iz12n
end
if (n_e>0) then
Ix(2,1) = Ix21n; Iy(2,1) = Iy21n; Iz(2,1) = Iz21n
end
if (n_e>0 AND n_f>0) then
Ix(2,2) = Ix22n; Iy(2,2) = Iy22n; Iz(2,2) = Iz22n
end
        Ix1f  = Ix12n; Iy1f  = Iy12n; Iz1f  = Iz12n
        Ix1f1 = ONE;   Iy1f1 = ONE;   Iz1f1 = ONE
        do f = 2,n_f
          fp1 = f + 1
          f1_cf = (f-1)*cf
          Ix1fp1 = Ix12n * Ix1f + f1_cf * Ix1f1
          Iy1fp1 = Iy12n * Iy1f + f1_cf * Iy1f1
          Iz1fp1 = Iz12n * Iz1f + f1_cf * Iz1f1
          Ix(1,fp1) = Ix1fp1; Iy(1,fp1) = Iy1fp1; Iz(1,fp1) = Iz1fp1
          Ix1f1 = Ix1f;   Iy1f1 = Iy1f;   Iz1f1 = Iz1f
          Ix1f  = Ix1fp1; Iy1f  = Iy1fp1; Iz1f  = Iz1fp1
        end
        Ixe1  = Ix21n; Iye1  = Iy21n; Ize1  = Iz21n
        Ixe11 = ONE;   Iye11 = ONE;   Ize11 = ONE
        do e = 2, n_e
          ep1 = e + 1
          e1_ce = (e-1) * ce
          Ixep11 = Ix21n * Ixe1 + e1_ce * Ixe11
          Iyep11 = Iy21n * Iye1 + e1_ce * Iye11
          Izep11 = Iz21n * Ize1 + e1_ce * Ize11
          Ix(ep1,1) = Ixep11; Iy(ep1,1) = Iyep11; Iz(ep1,1) = Izep11
          Ixe11 = Ixe1;   Iye11 = Iye1;   Ize11 = Ize1
          Ixe1  = Ixep11; Iye1  = Iyep11; Ize1  = Izep11
        end
        Ix2f  = Ix22n; Iy2f  = Iy22n; Iz2f  = Iz22n
        Ix2f1 = Ix21n; Iy2f1 = Iy21n; Iz2f1 = Iz21n
        do f=2,n_f
          fp1 = f + 1
          f1_cf = (f-1)*cf
          Ix2fp1 = Ix12n * Ix2f + f1_cf * Ix2f1 + bb * Ix(1,f)
          Iy2fp1 = Iy12n * Iy2f + f1_cf * Iy2f1 + bb * Iy(1,f)
          Iz2fp1 = Iz12n * Iz2f + f1_cf * Iz2f1 + bb * Iz(1,f)
if (n_e>0) then
          Ix(2,fp1) = Ix2fp1; Iy(2,fp1) = Iy2fp1; Iz(2,fp1) = Iz2fp1
end
          Ix2f1 = Ix2f;   Iy2f1 = Iy2f;   Iz2f1 = Iz2f
          Ix2f  = Ix2fp1; Iy2f  = Iy2fp1; Iz2f  = Iz2fp1
        end
        do e = 2, n_e
          e1  =e - 1
          ep1 =e + 1
          ce1 =e1 * ce
          Ixef1 = Ix(e,1); Iyef1 = Iy(e,1); Izef1 = Iz(e,1)
          do f=2, n_f+1
            f1_bb = (f-1)*bb
            Ixef  = Ix(e,f); Iyef  = Iy(e,f); Izef  = Iz(e,f)
            Ix(ep1,f) = Ix21n*Ixef + ce1*Ix(e1,f) + f1_bb*Ixef1
            Iy(ep1,f) = Iy21n*Iyef + ce1*Iy(e1,f) + f1_bb*Iyef1
            Iz(ep1,f) = Iz21n*Izef + ce1*Iz(e1,f) + f1_bb*Izef1
            Ixef1 = Ixef;   Iyef1 = Iyef;   Izef1 = Izef
          end
        end
        Iz(:,:) = rys%w(n) * Iz(:,:)    ! Merge the weights into Iz.
      end
    else                                              ! ab|ps integrals
      do n=1,nroots
        Ix => Ixa(n,i,:,:)
        Iy => Iya(n,i,:,:)
        Iz => Iza(n,i,:,:)
        Ix(1,1) = ONE
        Iy(1,1) = ONE
        Iz(1,1) = ONE
        t2    = rys%r(n)
        t2_rz = t2 * rho_zinv
        t2_re = t2 * rho_einv
        bb    = t2_re * half_zinv
        ce    = (ONE - t2_rz) * half_zinv
        Ix12n = QCx - t2_re * QPx
        Iy12n = QCy - t2_re * QPy
        Iz12n = QCz - t2_re * QPz
        Ix21n = PAx + t2_rz * QPx
        Iy21n = PAy + t2_rz * QPy
        Iz21n = PAz + t2_rz * QPz
if (n_f>0) then
Ix(1,2) = Ix12n; Iy(1,2) = Iy12n; Iz(1,2) = Iz12n
end
if (n_e>0) then
Ix(2,1) = Ix21n; Iy(2,1) = Iy21n; Iz(2,1) = Iz21n
end
if (n_e>0 AND n_f>0) then
        Ix(2,2) = Ix12n * Ix21n + bb
        Iy(2,2) = Iy12n * Iy21n + bb
        Iz(2,2) = Iz12n * Iz21n + bb
end
        do e = 2, n_e
          e1  =e - 1
          ep1 =e + 1
          ce1 = e1 * ce
          Ix(ep1,1) = Ix21n * Ix(e,1) + ce1 * Ix(e1,1)
          Iy(ep1,1) = Iy21n * Iy(e,1) + ce1 * Iy(e1,1)
          Iz(ep1,1) = Iz21n * Iz(e,1) + ce1 * Iz(e1,1)
          do f1=1, n_f
            f = f1 + 1
            f1_bb = f1*bb
            Ix(ep1,f) = Ix21n*Ix(e,f) + ce1*Ix(e1,f) + f1_bb*Ix(e,f1)
            Iy(ep1,f) = Iy21n*Iy(e,f) + ce1*Iy(e1,f) + f1_bb*Iy(e,f1)
            Iz(ep1,f) = Iz21n*Iz(e,f) + ce1*Iz(e1,f) + f1_bb*Iz(e,f1)
          end
        end
        Iz(:,:) = rys%w(n) * Iz(:,:)    ! Merge the weights into Iz.
      end
    end
  end

  form_esfs(Ix,Iy,Iz,esfs,eub,fub,nroots,dime,dimf,n_cc)
  ! Forms (es|fs) from the two dimensional integrals for a single
  ! set of primitives
    IN :: self
    MAT4, IN :: Ix,Iy,Iz
    MAT, OUT :: esfs
    INT, IN :: eub,fub,nroots,dime,dimf,n_cc
    IVEC, PTR :: e_x,e_y,e_z,f_x,f_y,f_z
    IMAT, PTR :: e_powers,f_powers,indexe,indexf
    INT :: e,f,n_e,n_f,zf,yf,xf,ze,ye,xe,dime1,dimf1,iie,iif,minle,minlf,opt
    DBL :: temp
    MAT4, PTR :: Ief
    MAT3, PTR :: I1

    e_powers.create(eub,3)
    f_powers.create(fub,3)
    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    e_x => e_powers(:,1); e_y => e_powers(:,2); e_z => e_powers(:,3)
    f_x => f_powers(:,1); f_y => f_powers(:,2); f_z => f_powers(:,3)
    max(.a%l,.b%l).make_gaussian_xyz_indices(e_x,e_y,e_z,n_e)
    max(.c%l,.d%l).make_gaussian_xyz_indices(f_x,f_y,f_z,n_f)

    opt = 0
    minle = min(.a%l,.b%l)
    minlf = min(.c%l,.d%l)
    if (minle > 1) opt = opt + 1
    if (minlf > 1) opt = opt + 2

    select case (opt)
      case (0)
        ! This version does not use the reduced multiplication scheme.
        do f=1,fub
          xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
          do e=1,eub
            xe = e_x(e);    ye = e_y(e);    ze = e_z(e)
            esfs(e,f) = sum(Ix(:,:,xe,xf) * Iy(:,:,ye,yf) * Iz(:,:,ze,zf))
          end
        end
      case (1)
        ! Apply the reduced multiplication scheme to merge the Iy and Iz 2d
        ! integrals into a single matrix (upper triangle).
        dime1 = dime+1
        I1.create(nroots,n_cc,dime*dime1/2)
        indexe.create(dime,dime) ! map ye,ze to iie
        iie = 0
        do ze=1,dime
          do ye=1,dime1-ze
            iie = iie + 1
            indexe(ye,ze) = iie
          end
        end
        do f=1,fub
          xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
          iie = 0
          do ze=1,dime
            do ye=1,dime1-ze
              iie = iie + 1
              I1(:,:,iie) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
            end
          end
          ! Now add in the Ix 2d integrals and sum over nroots
          do e=1,eub
            iie = indexe(e_y(e),e_z(e))
            esfs(e,f) = sum(Ix(:,:,e_x(e),xf) * I1(:,:,iie))
          end
        end
        indexe.destroy
        I1.destroy
      case (2)
        dimf1 = dimf+1
        I1.create(nroots,n_cc,dimf*dimf1/2)
        indexf.create(dimf,dimf)
        iif = 0
        do zf=1,dimf
          do yf=1,dimf1-zf
            iif = iif + 1
            indexf(yf,zf) = iif
          end
        end
        do e=1,eub
          xe = e_x(e);    ye = e_y(e);    ze = e_z(e)
          iif = 0
          do zf=1,dimf
            do yf=1,dimf1-zf
              iif = iif + 1
              I1(:,:,iif) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
            end
          end
          ! Now add in the Ix 2d integrals and sum over nroots
          do f=1,fub
            iif = indexf(f_y(f),f_z(f))
            esfs(e,f) = sum(Ix(:,:,xe,f_x(f)) * I1(:,:,iif))
          end
        end
        indexf.destroy
        I1.destroy
      case (3)
        dime1=dime+1
        dimf1=dimf+1
        Ief.create(nroots,n_cc,dime*dime1/2,dimf*dimf1/2)
        indexf.create(dimf,dimf) ! map yf,zf to iif
        indexe.create(dime,dime) ! map ye,ze to iie
        iie = 0
        do ze=1,dime
          do ye=1,dime1-ze
            iie = iie + 1
            indexe(ye,ze) = iie
          end
        end

        ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
        iif = 0
        do zf=1,dimf
          do yf=1,dimf1-zf
            iif = iif + 1
            indexf(yf,zf) = iif
            iie = 0
            do ze=1,dime
              do ye=1,dime1-ze
                iie = iie + 1
                Ief(:,:,iie,iif) = Iy(:,:,ye,yf) * Iz(:,:,ze,zf)
              end
            end
          end
        end
        ! Now add in the Ix 2d integrals and sum over nroots
        do f=1,fub
          xf = f_x(f)
          iif = indexf(f_y(f),f_z(f))
          do e=1,eub
            iie = indexe(e_y(e),e_z(e))
            esfs(e,f) = sum(Ix(:,:,e_x(e),xf) * Ief(:,:,iie,iif))
          end
        end
        Ief.destroy
        indexf.destroy
        indexe.destroy
    end
    e_powers.destroy
    f_powers.destroy
  end

  make_pppp(abcd)
  ! Make the (pp|pp) integrals, summed over the primitives
    IN :: self
    MAT4, target :: abcd
    MAT, PTR :: Iab
    RYS, PTR :: rys
    INT :: ag,bg,cg,dg,nroots,eub,fub,dim1,dim2,n_e,n_f,cc_dd,n
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab
    DBL :: norma,normb,normd,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz
    DBL :: ce,cf,bb,bb_2,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix13,Ix21,Ix22,Ix23,Ix31,Ix32,Ix33
    DBL :: Iy12,Iy13,Iy21,Iy22,Iy23,Iy31,Iy32,Iy33
    DBL :: Iz12,Iz13,Iz21,Iz22,Iz23,Iz31,Iz32,Iz33
    DBL :: ef11,ef21,ef31,ef41,ef51,ef61,ef71,ef81,ef91
    DBL :: ef12,ef22,ef32,ef42,ef52,ef62,ef72,ef82,ef92
    DBL :: ef13,ef23,ef33,ef43,ef53,ef63,ef73,ef83,ef93
    DBL :: ef14,ef24,ef34,ef44,ef54,ef64,ef74,ef84,ef94
    DBL :: ef15,ef25,ef35,ef45,ef55,ef65,ef75,ef85,ef95
    DBL :: ef16,ef26,ef36,ef46,ef56,ef66,ef76,ef86,ef96
    DBL :: ef17,ef27,ef37,ef47,ef57,ef67,ef77,ef87,ef97
    DBL :: ef18,ef28,ef38,ef48,ef58,ef68,ef78,ef88,ef98
    DBL :: ef19,ef29,ef39,ef49,ef59,ef69,ef79,ef89,ef99
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy13_Iz21,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy31_Iz12,Iy21_Iz13,Iy12_Iz31,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy13_w, Iy31_w, Iy32_w, Iy23_w
    DBL :: ecd1,ecd2,ecd3,ecd4,ecd5,ecd6,ecd7,ecd8,ecd9
    DBL :: BAx,BAy,BAz,DCx,DCy,DCz
    MAT, PTR :: normcd

    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum

    dim1 = n_e + 1
    dim2 = n_f + 1
    nroots = (dim1+dim2)/2

    ef11 = ZERO; ef21 = ZERO; ef31 = ZERO; ef41 = ZERO; ef51 = ZERO
    ef61 = ZERO; ef71 = ZERO; ef81 = ZERO; ef91 = ZERO
    ef12 = ZERO; ef22 = ZERO; ef32 = ZERO; ef42 = ZERO; ef52 = ZERO
    ef62 = ZERO; ef72 = ZERO; ef82 = ZERO; ef92 = ZERO
    ef13 = ZERO; ef23 = ZERO; ef33 = ZERO; ef43 = ZERO; ef53 = ZERO
    ef63 = ZERO; ef73 = ZERO; ef83 = ZERO; ef93 = ZERO
    ef14 = ZERO; ef24 = ZERO; ef34 = ZERO; ef44 = ZERO; ef54 = ZERO
    ef64 = ZERO; ef74 = ZERO; ef84 = ZERO; ef94 = ZERO
    ef15 = ZERO; ef25 = ZERO; ef35 = ZERO; ef45 = ZERO; ef55 = ZERO
    ef65 = ZERO; ef75 = ZERO; ef85 = ZERO; ef95 = ZERO
    ef16 = ZERO; ef26 = ZERO; ef36 = ZERO; ef46 = ZERO; ef56 = ZERO
    ef66 = ZERO; ef76 = ZERO; ef86 = ZERO; ef96 = ZERO
    ef17 = ZERO; ef27 = ZERO; ef37 = ZERO; ef47 = ZERO; ef57 = ZERO
    ef67 = ZERO; ef77 = ZERO; ef87 = ZERO; ef97 = ZERO
    ef18 = ZERO; ef28 = ZERO; ef38 = ZERO; ef48 = ZERO; ef58 = ZERO
    ef68 = ZERO; ef78 = ZERO; ef88 = ZERO; ef98 = ZERO
    ef19 = ZERO; ef29 = ZERO; ef39 = ZERO; ef49 = ZERO; ef59 = ZERO
    ef65 = ZERO; ef75 = ZERO; ef85 = ZERO; ef95 = ZERO

    Ax = .a.pos(1);  Ay = .a.pos(2);  Az = .a.pos(3)
    Bx = .b.pos(1);  By = .b.pos(2);  Bz = .b.pos(3)
    Cx = .c.pos(1);  Cy = .c.pos(2);  Cz = .c.pos(3)
    Dx = .d.pos(1);  Dy = .d.pos(2);  Dz = .d.pos(3)
    BAx = Bx - Ax;    BAy = By - Ay;    BAz = Bz - Az
    DCx = Dx - Cx;    DCy = Dy - Cy;    DCz = Dz - Cz
    r2ab = BAx*BAx + BAy*BAy + BAz*BAz
    Atx = Bx;  Aty = By;  Atz = Bz
    Ctx = Dx;  Cty = Dy;  Ctz = Dz

    normcd.create(.c%n_cc,.d%n_cc)
    .get_norm_cd(normcd)

    rys.create(nroots)
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = TWOPI5ON2 * .b%cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a%cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        do dg = 1, .d%n_cc
          d   = .d%ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c%n_cc
            c    = .c%ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho_zinv) * normcd(cg,dg)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            QCx = Qx - Ctx;   QCy = Qy - Cty;   QCz = Qz - Ctz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rys.get_weights(xx)
            half_zinv = HALF * zinv
            half_einv = HALF * einv
            do n=1,nroots
              t2    = rys.r(n)
              w     = rys.w(n) * norm
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              bb_2  = 2*bb
              cf    = (ONE - t2_re) * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13 = Iz12 * Iz12 + cf
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix23 = Ix12 * Ix22 + cf * Ix21 + bb * Ix12
              Iy23 = Iy12 * Iy22 + cf * Iy21 + bb * Iy12
              Iz23 = Iz12 * Iz22 + cf * Iz21 + bb * Iz12
              Ix32 = Ix21 * Ix22 + ce * Ix12 + bb * Ix21
              Iy32 = Iy21 * Iy22 + ce * Iy12 + bb * Iy21
              Iz32 = Iz21 * Iz22 + ce * Iz12 + bb * Iz21
              Ix33 = Ix21 * Ix23 + ce * Ix13 + bb_2 * Ix22
              Iy33 = Iy21 * Iy23 + ce * Iy13 + bb_2 * Iy22
              Iz33 = Iz21 * Iz23 + ce * Iz13 + bb_2 * Iz22

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz31 = Iz31 * w
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iz32 = Iz32 * w
              Iz13 = Iz13 * w
              Iz23 = Iz23 * w
              Iz33 = Iz33 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy12_Iz12 = Iy12 * Iz12
              Iy12_Iz22 = Iy12 * Iz22
              Iy12_Iz31 = Iy12 * Iz31
              Iy13_Iz21 = Iy13 * Iz21
              Iy21_Iz21 = Iy21 * Iz21
              Iy21_Iz22 = Iy21 * Iz22
              Iy21_Iz12 = Iy21 * Iz12
              Iy21_Iz13 = Iy21 * Iz13
              Iy31_Iz12 = Iy31 * Iz12
              Iy22_Iz12 = Iy22 * Iz12
              Iy22_Iz21 = Iy22 * Iz21
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w
              Iy13_w    = Iy13 * w
              Iy31_w    = Iy31 * w
              Iy32_w    = Iy32 * w
              Iy23_w    = Iy23 * w

              ef11 = ef11 + Ix22 *        w     ! 100|100  combine 2d ints.
              ef21 = ef21 + Ix12 * Iy21_w       ! 010|100
              ef31 = ef31 + Ix12 *        Iz21  ! 001|100
              ef41 = ef41 + Ix32 *        w     ! 200|100
              ef51 = ef51 + Ix12 * Iy31_w       ! 020|100
              ef61 = ef61 + Ix12 *        Iz31  ! 002|100
              ef71 = ef71 + Ix22 * Iy21_w       ! 110|100
              ef81 = ef81 + Ix22 *        Iz21  ! 101|100
              ef91 = ef91 + Ix12 * Iy21_Iz21    ! 011|100
              ef12 = ef12 + Ix21 * Iy12_w       ! 100|010
              ef22 = ef22 +        Iy22_w       ! 010|010
              ef32 = ef32 +        Iy12_Iz21    ! 001|010
              ef42 = ef42 + Ix31 * Iy12_w       ! 200|010
              ef52 = ef52 +        Iy32_w       ! 020|010
              ef62 = ef62 +        Iy12_Iz31    ! 002|010
              ef72 = ef72 + Ix21 * Iy22_w       ! 110|010
              ef82 = ef82 + Ix21 * Iy12_Iz21    ! 101|010
              ef92 = ef92 +        Iy22_Iz21    ! 011|010
              ef13 = ef13 + Ix21 *        Iz12  ! 100|001
              ef23 = ef23 +        Iy21_Iz12    ! 010|001
              ef33 = ef33 +               Iz22  ! 001|001
              ef43 = ef43 + Ix31 *        Iz12  ! 200|001
              ef53 = ef53 +        Iy31_Iz12    ! 020|001
              ef63 = ef63 +               Iz32  ! 002|001
              ef73 = ef73 + Ix21 * Iy21_Iz12    ! 110|001
              ef83 = ef83 + Ix21 *        Iz22  ! 101|001
              ef93 = ef93 +        Iy21_Iz22    ! 011|001
              ef14 = ef14 + Ix23 *        w     ! 100|200
              ef24 = ef24 + Ix13 * Iy21_w       ! 010|200
              ef34 = ef34 + Ix13 *        Iz21  ! 001|200
              ef44 = ef44 + Ix33 *        w     ! 200|200
              ef54 = ef54 + Ix13 * Iy31_w       ! 020|200
              ef64 = ef64 + Ix13 *        Iz31  ! 002|200
              ef74 = ef74 + Ix23 * Iy21_w       ! 110|200
              ef84 = ef84 + Ix23 *        Iz21  ! 101|200
              ef94 = ef94 + Ix13 * Iy21_Iz21    ! 011|200
              ef15 = ef15 + Ix21 * Iy13_w       ! 100|020
              ef25 = ef25 +        Iy23_w       ! 010|020
              ef35 = ef35 +        Iy13_Iz21    ! 001|020
              ef45 = ef45 + Ix31 * Iy13_w       ! 200|020
              ef55 = ef55 +        Iy33 * w     ! 020|020
              ef65 = ef65 +        Iy13 * Iz31  ! 002|020
              ef75 = ef75 + Ix21 * Iy23_w       ! 110|020
              ef85 = ef85 + Ix21 * Iy13_Iz21    ! 101|020
              ef95 = ef95 +        Iy23 * Iz21  ! 011|020
              ef16 = ef16 + Ix21 *        Iz13  ! 100|002
              ef26 = ef26 +        Iy21_Iz13    ! 010|002
              ef36 = ef36 +               Iz23  ! 001|002
              ef46 = ef46 + Ix31 *        Iz13  ! 200|002
              ef56 = ef56 +        Iy31 * Iz13  ! 020|002
              ef66 = ef66 +               Iz33  ! 002|002
              ef76 = ef76 + Ix21 * Iy21_Iz13    ! 110|002
              ef86 = ef86 + Ix21 *        Iz23  ! 101|002
              ef96 = ef96 +        Iy21 * Iz23  ! 011|002
              ef17 = ef17 + Ix22 * Iy12_w       ! 100|110
              ef27 = ef27 + Ix12 * Iy22_w       ! 010|110
              ef37 = ef37 + Ix12 * Iy12_Iz21    ! 001|110
              ef47 = ef47 + Ix32 * Iy12_w       ! 200|110
              ef57 = ef57 + Ix12 * Iy32_w       ! 020|110
              ef67 = ef67 + Ix12 * Iy12_Iz31    ! 002|110
              ef77 = ef77 + Ix22 * Iy22_w       ! 110|110
              ef87 = ef87 + Ix22 * Iy12_Iz21    ! 101|110
              ef97 = ef97 + Ix12 * Iy22_Iz21    ! 011|110
              ef18 = ef18 + Ix22 *        Iz12  ! 100|101
              ef28 = ef28 + Ix12 * Iy21_Iz12    ! 010|101
              ef38 = ef38 + Ix12 *        Iz22  ! 001|101
              ef48 = ef48 + Ix32 *        Iz12  ! 200|101
              ef58 = ef58 + Ix12 * Iy31_Iz12    ! 020|101
              ef68 = ef68 + Ix12 *        Iz32  ! 002|101
              ef78 = ef78 + Ix22 * Iy21_Iz12    ! 110|101
              ef88 = ef88 + Ix22 *        Iz22  ! 101|101
              ef98 = ef98 + Ix12 * Iy21_Iz22    ! 011|101
              ef19 = ef19 + Ix21 * Iy12_Iz12    ! 100|011
              ef29 = ef29 +        Iy22_Iz12    ! 010|011
              ef39 = ef39 +        Iy12_Iz22    ! 001|011
              ef49 = ef49 + Ix31 * Iy12_Iz12    ! 200|011
              ef59 = ef59 +        Iy32 * Iz12  ! 020|011
              ef69 = ef69 +        Iy12 * Iz32  ! 002|011
              ef79 = ef79 + Ix21 * Iy22_Iz12    ! 110|011
              ef89 = ef89 + Ix21 * Iy12_Iz22    ! 101|011
              ef99 = ef99 +        Iy22 * Iz22  ! 011|011
            end
          end
        end
      end
    end
    rys.destroy
    normcd.destroy

    ecd1 = ef14 + DCx * ef11
    ecd2 = ef24 + DCx * ef21
    ecd3 = ef34 + DCx * ef31
    ecd4 = ef44 + DCx * ef41
    ecd5 = ef54 + DCx * ef51
    ecd6 = ef64 + DCx * ef61
    ecd7 = ef74 + DCx * ef71
    ecd8 = ef84 + DCx * ef81
    ecd9 = ef94 + DCx * ef91
    Iab => abcd(:,:,1,1)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3

    ecd1 = ef17 + DCy * ef11
    ecd2 = ef27 + DCy * ef21
    ecd3 = ef37 + DCy * ef31
    ecd4 = ef47 + DCy * ef41
    ecd5 = ef57 + DCy * ef51
    ecd6 = ef67 + DCy * ef61
    ecd7 = ef77 + DCy * ef71
    ecd8 = ef87 + DCy * ef81
    ecd9 = ef97 + DCy * ef91
    Iab => abcd(:,:,2,1)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3

    ecd1 = ef18 + DCz * ef11
    ecd2 = ef28 + DCz * ef21
    ecd3 = ef38 + DCz * ef31
    ecd4 = ef48 + DCz * ef41
    ecd5 = ef58 + DCz * ef51
    ecd6 = ef68 + DCz * ef61
    ecd7 = ef78 + DCz * ef71
    ecd8 = ef88 + DCz * ef81
    ecd9 = ef98 + DCz * ef91
    Iab => abcd(:,:,3,1)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3

    ecd1 = ef17 + DCx * ef12
    ecd2 = ef27 + DCx * ef22
    ecd3 = ef37 + DCx * ef32
    ecd4 = ef47 + DCx * ef42
    ecd5 = ef57 + DCx * ef52
    ecd6 = ef67 + DCx * ef62
    ecd7 = ef77 + DCx * ef72
    ecd8 = ef87 + DCx * ef82
    ecd9 = ef97 + DCx * ef92
    Iab => abcd(:,:,1,2)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3

    ecd1 = ef15 + DCy * ef12
    ecd2 = ef25 + DCy * ef22
    ecd3 = ef35 + DCy * ef32
    ecd4 = ef45 + DCy * ef42
    ecd5 = ef55 + DCy * ef52
    ecd6 = ef65 + DCy * ef62
    ecd7 = ef75 + DCy * ef72
    ecd8 = ef85 + DCy * ef82
    ecd9 = ef95 + DCy * ef92
    Iab => abcd(:,:,2,2)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3

    ecd1 = ef19 + DCz * ef12
    ecd2 = ef29 + DCz * ef22
    ecd3 = ef39 + DCz * ef32
    ecd4 = ef49 + DCz * ef42
    ecd5 = ef59 + DCz * ef52
    ecd6 = ef69 + DCz * ef62
    ecd7 = ef79 + DCz * ef72
    ecd8 = ef89 + DCz * ef82
    ecd9 = ef99 + DCz * ef92
    Iab => abcd(:,:,3,2)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3

    ecd1 = ef18 + DCx * ef13
    ecd2 = ef28 + DCx * ef23
    ecd3 = ef38 + DCx * ef33
    ecd4 = ef48 + DCx * ef43
    ecd5 = ef58 + DCx * ef53
    ecd6 = ef68 + DCx * ef63
    ecd7 = ef78 + DCx * ef73
    ecd8 = ef88 + DCx * ef83
    ecd9 = ef98 + DCx * ef93
    Iab => abcd(:,:,1,3)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3

    ecd1 = ef19 + DCy * ef13
    ecd2 = ef29 + DCy * ef23
    ecd3 = ef39 + DCy * ef33
    ecd4 = ef49 + DCy * ef43
    ecd5 = ef59 + DCy * ef53
    ecd6 = ef69 + DCy * ef63
    ecd7 = ef79 + DCy * ef73
    ecd8 = ef89 + DCy * ef83
    ecd9 = ef99 + DCy * ef93
    Iab => abcd(:,:,2,3)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3

    ecd1 = ef16 + DCz * ef13
    ecd2 = ef26 + DCz * ef23
    ecd3 = ef36 + DCz * ef33
    ecd4 = ef46 + DCz * ef43
    ecd5 = ef56 + DCz * ef53
    ecd6 = ef66 + DCz * ef63
    ecd7 = ef76 + DCz * ef73
    ecd8 = ef86 + DCz * ef83
    ecd9 = ef96 + DCz * ef93
    Iab => abcd(:,:,3,3)
    Iab(1,1) = ecd4 + BAx * ecd1
    Iab(2,1) = ecd7 + BAy * ecd1
    Iab(3,1) = ecd8 + BAz * ecd1
    Iab(1,2) = ecd7 + BAx * ecd2
    Iab(2,2) = ecd5 + BAy * ecd2
    Iab(3,2) = ecd9 + BAz * ecd2
    Iab(1,3) = ecd8 + BAx * ecd3
    Iab(2,3) = ecd9 + BAy * ecd3
    Iab(3,3) = ecd6 + BAz * ecd3
  end

  make_ppps(abcd)
  ! Make the (pp|ps) integrals, summed over the primitives
    IN :: self
    MAT4, target :: abcd
    MAT3, PTR :: Iabf
    RYS, PTR :: rys
    INT :: ag,bg,cg,dg,nroots,eub,fub,dim1,dim2,n_e,n_f,cc_dd,n
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab
    DBL :: norma,normb,normd,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz
    DBL :: ce,bb,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix13,Ix21,Ix22,Ix23,Ix31,Ix32,Ix33
    DBL :: Iy12,Iy13,Iy21,Iy22,Iy23,Iy31,Iy32,Iy33
    DBL :: Iz12,Iz13,Iz21,Iz22,Iz23,Iz31,Iz32,Iz33
    DBL :: ef11,ef21,ef31,ef41,ef51,ef61,ef71,ef81,ef91
    DBL :: ef12,ef22,ef32,ef42,ef52,ef62,ef72,ef82,ef92
    DBL :: ef13,ef23,ef33,ef43,ef53,ef63,ef73,ef83,ef93
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy31_Iz12,Iy21_Iz13,Iy12_Iz31,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy31_w, Iy32_w
    DBL :: ecd1,ecd2,ecd3,ecd4,ecd5,ecd6,ecd7,ecd8,ecd9
    DBL :: BAx,BAy,BAz,DCx,DCy,DCz
    MAT, PTR :: normcd
    MAT, PTR :: Iab

    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum

    dim1 = n_e + 1
    dim2 = n_f + 1
    nroots = (dim1+dim2)/2

    ef11 = ZERO; ef21 = ZERO; ef31 = ZERO; ef41 = ZERO; ef51 = ZERO
    ef61 = ZERO; ef71 = ZERO; ef81 = ZERO; ef91 = ZERO
    ef12 = ZERO; ef22 = ZERO; ef32 = ZERO; ef42 = ZERO; ef52 = ZERO
    ef62 = ZERO; ef72 = ZERO; ef82 = ZERO; ef92 = ZERO
    ef13 = ZERO; ef23 = ZERO; ef33 = ZERO; ef43 = ZERO; ef53 = ZERO
    ef63 = ZERO; ef73 = ZERO; ef83 = ZERO; ef93 = ZERO

    Ax = .a.pos(1);  Ay = .a.pos(2);  Az = .a.pos(3)
    Bx = .b.pos(1);  By = .b.pos(2);  Bz = .b.pos(3)
    Cx = .c.pos(1);  Cy = .c.pos(2);  Cz = .c.pos(3)
    Dx = .d.pos(1);  Dy = .d.pos(2);  Dz = .d.pos(3)
    BAx = Bx - Ax;    BAy = By - Ay;    BAz = Bz - Az
    DCx = Dx - Cx;    DCy = Dy - Cy;    DCz = Dz - Cz
    r2ab = BAx*BAx + BAy*BAy + BAz*BAz
    Atx = Bx;  Aty = By;  Atz = Bz
    if (.c%l > .d%l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    normcd.create(.c%n_cc,.d%n_cc)
    .get_norm_cd(normcd)

    rys.create(nroots)
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = TWOPI5ON2 * .b%cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a%cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        do dg = 1, .d%n_cc
          d   = .d%ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c%n_cc
            c    = .c%ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho_zinv) * normcd(cg,dg)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            QCx = Qx - Ctx;   QCy = Qy - Cty;   QCz = Qz - Ctz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rys.get_weights(xx)
            half_zinv = HALF * zinv
            half_einv = HALF * einv
            do n=1,nroots
              t2    = rys.r(n)
              w     = rys.w(n) * norm
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix32 = Ix21 * Ix22 + ce * Ix12 + bb * Ix21
              Iy32 = Iy21 * Iy22 + ce * Iy12 + bb * Iy21
              Iz32 = Iz21 * Iz22 + ce * Iz12 + bb * Iz21

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz31 = Iz31 * w
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iz32 = Iz32 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy12_Iz12 = Iy12 * Iz12
              Iy12_Iz22 = Iy12 * Iz22
              Iy12_Iz31 = Iy12 * Iz31
              Iy21_Iz21 = Iy21 * Iz21
              Iy21_Iz22 = Iy21 * Iz22
              Iy21_Iz12 = Iy21 * Iz12
              Iy31_Iz12 = Iy31 * Iz12
              Iy22_Iz12 = Iy22 * Iz12
              Iy22_Iz21 = Iy22 * Iz21
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w
              Iy31_w    = Iy31 * w
              Iy32_w    = Iy32 * w

              ef11 = ef11 + Ix22 * w         ! 100|100  combine 2d ints.
              ef21 = ef21 + Ix12 * Iy21_w    ! 010|100
              ef31 = ef31 + Ix12 * Iz21      ! 001|100
              ef41 = ef41 + Ix32 * w         ! 200|100
              ef51 = ef51 + Ix12 * Iy31_w    ! 020|100
              ef61 = ef61 + Ix12 * Iz31      ! 002|100
              ef71 = ef71 + Ix22 * Iy21_w    ! 110|100
              ef81 = ef81 + Ix22 * Iz21      ! 101|100
              ef91 = ef91 + Ix12 * Iy21_Iz21 ! 011|100
              ef12 = ef12 + Ix21 * Iy12_w    ! 100|010
              ef22 = ef22 + Iy22_w           ! 010|010
              ef32 = ef32 + Iy12_Iz21        ! 001|010
              ef42 = ef42 + Ix31 * Iy12_w    ! 200|010
              ef52 = ef52 + Iy32_w           ! 020|010
              ef62 = ef62 + Iy12_Iz31        ! 002|010
              ef72 = ef72 + Ix21 * Iy22_w    ! 110|010
              ef82 = ef82 + Ix21 * Iy12_Iz21 ! 101|010
              ef92 = ef92 + Iy22_Iz21        ! 011|010
              ef13 = ef13 + Ix21 * Iz12      ! 100|001
              ef23 = ef23 + Iy21_Iz12        ! 010|001
              ef33 = ef33 + Iz22             ! 001|001
              ef43 = ef43 + Ix31 * Iz12      ! 200|001
              ef53 = ef53 + Iy31_Iz12        ! 020|001
              ef63 = ef63 + Iz32             ! 002|001
              ef73 = ef73 + Ix21 * Iy21_Iz12 ! 110|001
              ef83 = ef83 + Ix21 * Iz22      ! 101|001
              ef93 = ef93 + Iy21_Iz22        ! 011|001
            end
          end
        end
      end
    end
    rys.destroy
    normcd.destroy

    if (.c.l==0) then
      Iabf => abcd(:,:,1,:)
    else ! .d.l==0
      Iabf => abcd(:,:,:,1)
    end
    Iabf(1,1,1) = ef41 + BAx * ef11
    Iabf(1,1,2) = ef42 + BAx * ef12
    Iabf(1,1,3) = ef43 + BAx * ef13
    Iabf(2,1,1) = ef71 + BAy * ef11
    Iabf(2,1,2) = ef72 + BAy * ef12
    Iabf(2,1,3) = ef73 + BAy * ef13
    Iabf(3,1,1) = ef81 + BAz * ef11
    Iabf(3,1,2) = ef82 + BAz * ef12
    Iabf(3,1,3) = ef83 + BAz * ef13
    Iabf(1,2,1) = ef71 + BAx * ef21
    Iabf(1,2,2) = ef72 + BAx * ef22
    Iabf(1,2,3) = ef73 + BAx * ef23
    Iabf(2,2,1) = ef51 + BAy * ef21
    Iabf(2,2,2) = ef52 + BAy * ef22
    Iabf(2,2,3) = ef53 + BAy * ef23
    Iabf(3,2,1) = ef91 + BAz * ef21
    Iabf(3,2,2) = ef92 + BAz * ef22
    Iabf(3,2,3) = ef93 + BAz * ef23
    Iabf(1,3,1) = ef81 + BAx * ef31
    Iabf(1,3,2) = ef82 + BAx * ef32
    Iabf(1,3,3) = ef83 + BAx * ef33
    Iabf(2,3,1) = ef91 + BAy * ef31
    Iabf(2,3,2) = ef92 + BAy * ef32
    Iabf(2,3,3) = ef93 + BAy * ef33
    Iabf(3,3,1) = ef61 + BAz * ef31
    Iabf(3,3,2) = ef62 + BAz * ef32
    Iabf(3,3,3) = ef63 + BAz * ef33
  end

  make_pspp(abcd)
  ! Make the (ps|pp) integrals, summed over the primitives
    IN :: self
    MAT4, target :: abcd
    MAT3, PTR :: Iabf
    RYS, PTR :: rys
    INT :: ag,bg,cg,dg,nroots,eub,fub,dim1,dim2,n_e,n_f,cc_dd,n
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab
    DBL :: norma,normb,normd,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz
    DBL :: ce,cf,bb,bb_2,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix13,Ix21,Ix22,Ix23,Ix31,Ix32,Ix33
    DBL :: Iy12,Iy13,Iy21,Iy22,Iy23,Iy31,Iy32,Iy33
    DBL :: Iz12,Iz13,Iz21,Iz22,Iz23,Iz31,Iz32,Iz33
    DBL :: ef11,ef21,ef31,ef12,ef22,ef32,ef13,ef23,ef33
    DBL :: ef14,ef24,ef34,ef15,ef25,ef35,ef16,ef26,ef36
    DBL :: ef17,ef27,ef37,ef18,ef28,ef38,ef19,ef29,ef39
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy13_Iz21,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy31_Iz12,Iy21_Iz13,Iy12_Iz31,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy13_w, Iy31_w, Iy32_w, Iy23_w
    DBL :: ecd1,ecd2,ecd3,ecd4,ecd5,ecd6,ecd7,ecd8,ecd9
    DBL :: BAx,BAy,BAz,DCx,DCy,DCz
    MAT, PTR :: normcd

    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum

    dim1 = n_e + 1
    dim2 = n_f + 1
    nroots = (dim1+dim2)/2

    ef11 = ZERO; ef21 = ZERO; ef31 = ZERO
    ef12 = ZERO; ef22 = ZERO; ef32 = ZERO
    ef13 = ZERO; ef23 = ZERO; ef33 = ZERO
    ef14 = ZERO; ef24 = ZERO; ef34 = ZERO
    ef15 = ZERO; ef25 = ZERO; ef35 = ZERO
    ef16 = ZERO; ef26 = ZERO; ef36 = ZERO
    ef17 = ZERO; ef27 = ZERO; ef37 = ZERO
    ef18 = ZERO; ef28 = ZERO; ef38 = ZERO
    ef19 = ZERO; ef29 = ZERO; ef39 = ZERO

    Ax = .a.pos(1);  Ay = .a.pos(2);  Az = .a.pos(3)
    Bx = .b.pos(1);  By = .b.pos(2);  Bz = .b.pos(3)
    Cx = .c.pos(1);  Cy = .c.pos(2);  Cz = .c.pos(3)
    Dx = .d.pos(1);  Dy = .d.pos(2);  Dz = .d.pos(3)
    BAx = Bx - Ax;    BAy = By - Ay;    BAz = Bz - Az
    DCx = Dx - Cx;    DCy = Dy - Cy;    DCz = Dz - Cz
    r2ab = BAx*BAx + BAy*BAy + BAz*BAz
    Atx = Bx;  Aty = By;  Atz = Bz
    Ctx = Dx;  Cty = Dy;  Ctz = Dz

    normcd.create(.c%n_cc,.d%n_cc)
    .get_norm_cd(normcd)

    rys.create(nroots)
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = TWOPI5ON2 * .b%cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a%cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        do dg = 1, .d%n_cc
          d   = .d%ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c%n_cc
            c    = .c%ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho_zinv) * normcd(cg,dg)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            QCx = Qx - Ctx;   QCy = Qy - Cty;   QCz = Qz - Ctz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rys.get_weights(xx)
            half_zinv = HALF * zinv
            half_einv = HALF * einv
            do n=1,nroots
              t2    = rys.r(n)
              w     = rys.w(n) * norm
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              bb_2  = 2*bb
              cf    = (ONE - t2_re) * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13 = Iz12 * Iz12 + cf
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix23 = Ix12 * Ix22 + cf * Ix21 + bb * Ix12
              Iy23 = Iy12 * Iy22 + cf * Iy21 + bb * Iy12
              Iz23 = Iz12 * Iz22 + cf * Iz21 + bb * Iz12
              Ix32 = Ix21 * Ix22 + ce * Ix12 + bb * Ix21
              Iy32 = Iy21 * Iy22 + ce * Iy12 + bb * Iy21
              Iz32 = Iz21 * Iz22 + ce * Iz12 + bb * Iz21
              Ix33 = Ix21 * Ix23 + ce * Ix13 + bb_2 * Ix22
              Iy33 = Iy21 * Iy23 + ce * Iy13 + bb_2 * Iy22
              Iz33 = Iz21 * Iz23 + ce * Iz13 + bb_2 * Iz22

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz31 = Iz31 * w
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iz32 = Iz32 * w
              Iz13 = Iz13 * w
              Iz23 = Iz23 * w
              Iz33 = Iz33 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy12_Iz12 = Iy12 * Iz12
              Iy12_Iz22 = Iy12 * Iz22
              Iy12_Iz31 = Iy12 * Iz31
              Iy13_Iz21 = Iy13 * Iz21
              Iy21_Iz21 = Iy21 * Iz21
              Iy21_Iz22 = Iy21 * Iz22
              Iy21_Iz12 = Iy21 * Iz12
              Iy21_Iz13 = Iy21 * Iz13
              Iy31_Iz12 = Iy31 * Iz12
              Iy22_Iz12 = Iy22 * Iz12
              Iy22_Iz21 = Iy22 * Iz21
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w
              Iy13_w    = Iy13 * w
              Iy31_w    = Iy31 * w
              Iy32_w    = Iy32 * w
              Iy23_w    = Iy23 * w

              ef11 = ef11 + Ix22 *        w     ! 100|100  combine 2d ints.
              ef21 = ef21 + Ix12 * Iy21_w       ! 010|100
              ef31 = ef31 + Ix12 *        Iz21  ! 001|100
              ef12 = ef12 + Ix21 * Iy12_w       ! 100|010
              ef22 = ef22 +        Iy22_w       ! 010|010
              ef32 = ef32 +        Iy12_Iz21    ! 001|010
              ef13 = ef13 + Ix21 *        Iz12  ! 100|001
              ef23 = ef23 +        Iy21_Iz12    ! 010|001
              ef33 = ef33 +               Iz22  ! 001|001
              ef14 = ef14 + Ix23 *        w     ! 100|200
              ef24 = ef24 + Ix13 * Iy21_w       ! 010|200
              ef34 = ef34 + Ix13 *        Iz21  ! 001|200
              ef15 = ef15 + Ix21 * Iy13_w       ! 100|020
              ef25 = ef25 +        Iy23_w       ! 010|020
              ef35 = ef35 +        Iy13_Iz21    ! 001|020
              ef16 = ef16 + Ix21 *        Iz13  ! 100|002
              ef26 = ef26 +        Iy21_Iz13    ! 010|002
              ef36 = ef36 +               Iz23  ! 001|002
              ef17 = ef17 + Ix22 * Iy12_w       ! 100|110
              ef27 = ef27 + Ix12 * Iy22_w       ! 010|110
              ef37 = ef37 + Ix12 * Iy12_Iz21    ! 001|110
              ef18 = ef18 + Ix22 *        Iz12  ! 100|101
              ef28 = ef28 + Ix12 * Iy21_Iz12    ! 010|101
              ef38 = ef38 + Ix12 *        Iz22  ! 001|101
              ef19 = ef19 + Ix21 * Iy12_Iz12    ! 100|011
              ef29 = ef29 +        Iy22_Iz12    ! 010|011
              ef39 = ef39 +        Iy12_Iz22    ! 001|011
            end
          end
        end
      end
    end
    rys.destroy
    normcd.destroy

    if (.a.l==0) then
      Iabf => abcd(1,:,:,:)
    else ! .b.l==0
      Iabf => abcd(:,1,:,:)
    end
    Iabf(1,1,1) = ef14 + DCx * ef11
    Iabf(2,1,1) = ef24 + DCx * ef21
    Iabf(3,1,1) = ef34 + DCx * ef31
    Iabf(1,2,1) = ef17 + DCy * ef11
    Iabf(2,2,1) = ef27 + DCy * ef21
    Iabf(3,2,1) = ef37 + DCy * ef31
    Iabf(1,3,1) = ef18 + DCz * ef11
    Iabf(2,3,1) = ef28 + DCz * ef21
    Iabf(3,3,1) = ef38 + DCz * ef31
    Iabf(1,1,2) = ef17 + DCx * ef12
    Iabf(2,1,2) = ef27 + DCx * ef22
    Iabf(3,1,2) = ef37 + DCx * ef32
    Iabf(1,2,2) = ef15 + DCy * ef12
    Iabf(2,2,2) = ef25 + DCy * ef22
    Iabf(3,2,2) = ef35 + DCy * ef32
    Iabf(1,3,2) = ef19 + DCz * ef12
    Iabf(2,3,2) = ef29 + DCz * ef22
    Iabf(3,3,2) = ef39 + DCz * ef32
    Iabf(1,1,3) = ef18 + DCx * ef13
    Iabf(2,1,3) = ef28 + DCx * ef23
    Iabf(3,1,3) = ef38 + DCx * ef33
    Iabf(1,2,3) = ef19 + DCy * ef13
    Iabf(2,2,3) = ef29 + DCy * ef23
    Iabf(3,2,3) = ef39 + DCy * ef33
    Iabf(1,3,3) = ef16 + DCz * ef13
    Iabf(2,3,3) = ef26 + DCz * ef23
    Iabf(3,3,3) = ef36 + DCz * ef33
  end

  make_psps(abcd)
  ! Makes the (ps|ps) integrals, summed over the primitives
  ! Does ps|ps, ps|sp, sp|ps, sp|sp.
    IN :: self
    MAT4, OUT:: abcd
    MAT, PTR:: psps
    RYS, PTR :: rysa
    VEC(3) :: AB
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab
    INT :: ag,bg,cg,dg,eub,fub,dim1,dim2,n
    DBL :: norma,normb,normd,zinv,rho,einv,norm,half_zinv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,PAx,PAy,PAz
    DBL :: root,tmp2,tmp3,tmp4,weight,d_r2cd,b_r2ab
    DBL :: Iz11,Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,Qx,Qy,Qz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz,rho_zinv,rho_einv
    MAT, PTR :: normcd

    AB = .a%pos - .b%pos
    r2ab=dot_product(AB,AB)
    psps.create(3,3)

    Ax = .a%pos(1);  Ay = .a%pos(2);  Az = .a%pos(3)
    Bx = .b%pos(1);  By = .b%pos(2);  Bz = .b%pos(3)
    Cx = .c%pos(1);  Cy = .c%pos(2);  Cz = .c%pos(3)
    Dx = .d%pos(1);  Dy = .d%pos(2);  Dz = .d%pos(3)
    if (.a%l > .b%l) then
      Atx = Ax;  Aty = Ay;  Atz = Az
    else
      Atx = Bx;  Aty = By;  Atz = Bz
    end
    if (.c%l > .d%l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    rysa.create(2)
    normcd.create(.c%n_cc,.d%n_cc)
    .get_norm_cd(normcd)

    psps=ZERO
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = TWOPI5ON2 * .b%cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        half_zinv = HALF * zinv
        kab  = sqrt(zinv) * zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a%cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        do dg = 1, .d%n_cc
          d     = .d%ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c%n_cc
            c    = .c%ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            QCx  = Qx - Ctx;  QCy  = Qy - Cty;  QCz  = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho)*normcd(cg,dg)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rysa.get_weights(xx)
            do n=1,2
              root = rysa%r(n)
              tmp2 = root * rho_zinv
              tmp3 = root * rho_einv
              tmp4 = tmp3 * half_zinv
              Ix12 = QCx - tmp3 * QPx
              Iy12 = QCy - tmp3 * QPy
              Iz12 = QCz - tmp3 * QPz
              Ix21 = PAx + tmp2 * QPx
              Iy21 = PAy + tmp2 * QPy
              Iz21 = PAz + tmp2 * QPz
              Ix22 = Ix12 * Ix21 + tmp4
              Iy22 = Iy12 * Iy21 + tmp4
              Iz22 = Iz12 * Iz21 + tmp4
              weight = rysa%w(n) * norm      ! Merge the wieghts and
              Iz11 =        weight           ! normalization into Iz.
              Iz12 = Iz12 * weight
              Iz21 = Iz21 * weight
              Iz22 = Iz22 * weight
              psps(1,1) = psps(1,1) + (Ix22        * Iz11)
              psps(2,1) = psps(2,1) + (Ix12 * Iy21 * Iz11)
              psps(3,1) = psps(3,1) + (Ix12        * Iz21)
              psps(1,2) = psps(1,2) + (Ix21 * Iy12 * Iz11)
              psps(2,2) = psps(2,2) + (       Iy22 * Iz11)
              psps(3,2) = psps(3,2) + (       Iy12 * Iz21)
              psps(1,3) = psps(1,3) + (Ix21        * Iz12)
              psps(2,3) = psps(2,3) + (       Iy21 * Iz12)
              psps(3,3) = psps(3,3) + (              Iz22)
            end
          end
        end
      end
    end
    normcd.destroy
    rysa.destroy
    if (.a%l == 1) then
      if (.c%l ==1) then
        abcd(:,1,:,1) = psps
      else
        abcd(:,1,1,:) = psps
      end
    else
      if (.c%l ==1) then
        abcd(1,:,:,1) = psps
      else
        abcd(1,:,1,:) = psps
      end
    end
    psps.destroy
  end

  make_abss(abcd)
  ! Makes the (ab|ss) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT :: abcd
    VEC, PTR :: esss,esssadd
    MAT, PTR :: Ix,Iy,Iz,Iyz
    RYS, PTR :: rysa
    VEC(3) :: AB
    SHELL2, PTR :: sh
    DBL :: QP2,a,b,c,d,zeta,zinv,kab,eta,einv,rho,xx,r2ab
    INT :: ag,bg,cg,dg,n_e,nroots,eub,maxl,dim,minl
    DBL :: norma,normb,normd,norm,b_r2ab,rho_zinv,half_zinv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Atx,Aty,Atz,a_zinv,c_einv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    IMAT, PTR :: e_powers
    IVEC, PTR :: x,y,z
    DBL :: rzt,ce1,tmp,tmp2,rzthze
    INT :: e,e1,ep1,n
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3
    MAT, PTR :: normcd
    DBL :: Ixe,Ixe1,Iye,Iye1,Ize,Ize1,Ixep1,Iyep1,Izep1

    n_e = .a%l + .b%l
    maxl = max(.a%l,.b%l)
    minl = min(.a%l,.b%l)
    dim = n_e+1
    eub = n_e.n_comp_sum - (maxl-1).n_comp_sum

    nroots = (n_e + 2) / 2
    esss.create(eub)
    rysa.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*(dim+1)/2)
    esssadd.create(eub)

    e_powers.create(eub,3)
    x => e_powers(:,1); y => e_powers(:,2); z => e_powers(:,3)
    maxl.make_gaussian_xyz_indices(x,y,z,n_e)

    AB   = .a%pos - .b%pos
    r2ab = dot_product(AB,AB)
    Ax = .a%pos(1); Ay = .a%pos(2); Az = .a%pos(3)
    Bx = .b%pos(1); By = .b%pos(2); Bz = .b%pos(3)
    Cx = .c%pos(1); Cy = .c%pos(2); Cz = .c%pos(3)
    Dx = .d%pos(1); Dy = .d%pos(2); Dz = .d%pos(3)
    if (.a%l > .b%l) then
      Atx = Ax; Aty = Ay; Atz = Az
    else
      Atx = Bx; Aty = By; Atz = Bz
    end

    normcd.create(.c%n_cc,.d%n_cc)
    .get_norm_cd(normcd)

    esss = ZERO
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = TWOPI5ON2 * .b%cc(bg)
      b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a     = .a%ex(ag) 
        zeta  = a + b
        zinv  = ONE / zeta
        a_zinv = a * zinv
        half_zinv = HALF * zinv
        kab   = exp(- a_zinv * b_r2ab)
        norma = normb * .a%cc(ag) * kab * zinv
        Px    = b_Bx * zinv + a_zinv * Ax
        Py    = b_By * zinv + a_zinv * Ay
        Pz    = b_Bz * zinv + a_zinv * Az
        PAx = Px - Atx; PAy = Py - Aty; PAz = Pz - Atz
        do dg = 1, .d%n_cc
          d     = .d%ex(dg)
          d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
          do cg = 1, .c%n_cc
            c    = .c%ex(cg)
            eta  = c + d
            einv = ONE / eta
            c_einv = c * einv
            Qx   = d_Dx * einv + c_einv * Cx
            Qy   = d_Dy * einv + c_einv * Cy
            Qz   = d_Dz * einv + c_einv * Cz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            norm = norma * sqrt(rho_zinv) * normcd(cg,dg)
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            rysa%w = rysa%w * norm
            do n=1,nroots
              rzt      = rysa%r(n) * rho_zinv
              rzthze   = (ONE - rzt) * half_zinv
              Ix2 = PAx + rzt * QPx
              Iy2 = PAy + rzt * QPy
              Iz2 = PAz + rzt * QPz
              Ix3 = Ix2 * Ix2 + rzthze
              Iy3 = Iy2 * Iy2 + rzthze
              Iz3 = Iz2 * Iz2 + rzthze
              Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = ONE
              Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2
              Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3

              Ixe = Ix3;    Iye = Iy3;    Ize = Iz3
              Ixe1 = Ix2;   Iye1 = Iy2;   Ize1 = Iz2
              do ep1 = 4, n_e+1
                ce1 = (ep1-2) * rzthze
                Ixep1 = Ix2 * Ixe + ce1 * Ixe1
                Iyep1 = Iy2 * Iye + ce1 * Iye1
                Izep1 = Iz2 * Ize + ce1 * Ize1
                Ix(n,ep1) = Ixep1;   Iy(n,ep1) = Iyep1;   Iz(n,ep1) = Izep1;
                Ixe1 = Ixe;   Iye1 = Iye;   Ize1 = Ize    ! for next iteration
                Ixe = Ixep1;  Iye = Iyep1;  Ize = Izep1   ! for next iteration
              end
            end
            .form_esfs_0(Ix,Iy,Iz,Iyz,rysa%w,esssadd,x,y,z,dim,eub,nroots,minl)
            esss = esss + esssadd
          end
        end
      end
    end
    normcd.destroy
    e_powers.destroy
    esssadd.destroy
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rysa.destroy

    sh.create(.a,.b)
    sh.transfer(esss,abcd(:,:,1,1))
    sh.destroy
    esss.destroy
    .to_normalize(abcd)
  end

  make_sscd(abcd)
  ! Makes the (ss|cd) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    VEC, PTR :: ssfs,ssfsadd
    MAT, PTR :: Ix,Iy,Iz
    MAT, PTR :: Iyz
    SHELL2, PTR :: sh
    RYS, PTR :: rysa
    VEC(3) :: AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg,n_f,nroots,fub,maxl,dim,minl
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab,rho_einv,half_einv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,Ctx,Cty,Ctz,c_einv,a_zinv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    IMAT, PTR :: f_powers
    IVEC, PTR :: x,y,z
    DBL :: ret,cf1,tmp,tmp2,rethen
    INT :: f,f1,fp1,n
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3
    DBL :: Ixf,Ixf1,Iyf,Iyf1,Izf,Izf1,Ixfp1,Iyfp1,Izfp1
    MAT, PTR :: normab

    n_f = .c%l + .d%l
    maxl = max(.c%l,.d%l)
    minl = min(.c%l,.d%l)
    dim = n_f+1
    fub = n_f.n_comp_sum - (maxl-1).n_comp_sum

    nroots = (n_f+2)/2
    ssfs.create(fub)
    rysa.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*(dim+1)/2)
    ssfsadd.create(fub)

    f_powers.create(fub,3)
    x => f_powers(:,1); y => f_powers(:,2); z => f_powers(:,3)
    maxl.make_gaussian_xyz_indices(x,y,z,n_f)

    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    Ax = .a%pos(1); Ay = .a%pos(2); Az = .a%pos(3)
    Bx = .b%pos(1); By = .b%pos(2); Bz = .b%pos(3)
    Cx = .c%pos(1); Cy = .c%pos(2); Cz = .c%pos(3)
    Dx = .d%pos(1); Dy = .d%pos(2); Dz = .d%pos(3)
    if (.c%l > .d%l) then
      Ctx = Cx; Cty = Cy; Ctz = Cz
    else
      Ctx = Dx; Cty = Dy; Ctz = Dz
    end

    normab.create(.a%n_cc,.b%n_cc)
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = .b%cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = exp(-a * b_r2ab * zinv)
        normab(ag,bg) = normb * .a%cc(ag) * zinv * sqrt(zinv) * kab
      end
    end

    ssfs=ZERO
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        half_einv = HALF * einv
        c_einv = c * einv
        kcd  = exp(- c_einv * d_r2cd)
        normc = normd * .c%cc(cg) * kcd * einv
        Qx   = d_Dx * einv + c_einv * Cx
        Qy   = d_Dy * einv + c_einv * Cy
        Qz   = d_Dz * einv + c_einv * Cz
        QCx  = Qx - Ctx
        QCy  = Qy - Cty
        QCz  = Qz - Ctz
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            a_zinv = a * zinv
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            norm = normc * sqrt(rho_einv)*normab(ag,bg)
            Px    = b_Bx * zinv + a_zinv * Ax
            Py    = b_By * zinv + a_zinv * Ay
            Pz    = b_Bz * zinv + a_zinv * Az
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            rysa%w = rysa%w * norm
            do n=1,nroots
              ret     = rysa%r(n) * rho_einv
              rethen  = (ONE - ret) * half_einv
              Ix2 = QCx - ret * QPx
              Iy2 = QCy - ret * QPy
              Iz2 = QCz - ret * QPz
              Ix3 = Ix2 * Ix2 + rethen
              Iy3 = Iy2 * Iy2 + rethen
              Iz3 = Iz2 * Iz2 + rethen

              Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = ONE
              Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2
              Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3

              Ixf = Ix3;    Iyf = Iy3;    Izf = Iz3
              Ixf1 = Ix2;   Iyf1 = Iy2;   Izf1 = Iz2
              do fp1 = 4, n_f+1
                cf1 = (fp1-2) * rethen
                Ixfp1 = Ix2 * Ixf + cf1 * Ixf1
                Iyfp1 = Iy2 * Iyf + cf1 * Iyf1
                Izfp1 = Iz2 * Izf + cf1 * Izf1
                Ix(n,fp1) = Ixfp1;   Iy(n,fp1) = Iyfp1;   Iz(n,fp1) = Izfp1;
                Ixf1 = Ixf;   Iyf1 = Iyf;   Izf1 = Izf    ! for next iteration
                Ixf = Ixfp1;  Iyf = Iyfp1;  Izf = Izfp1   ! for next iteration
              end
            end
            .form_esfs_0(Ix,Iy,Iz,Iyz,rysa%w,ssfsadd,x,y,z,dim,fub,nroots,minl)
            ssfs = ssfs + ssfsadd
          end
        end
      end
    end
    normab.destroy
    f_powers.destroy
    ssfsadd.destroy
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rysa.destroy

    sh.create(.c,.d)
    sh.transfer(ssfs,abcd(1,1,:,:))
    sh.destroy
    ssfs.destroy
    .to_normalize(abcd)
  end

  form_esfs_0(Ix,Iy,Iz,Iyz,weights,esfsadd,fx,fy,fz,dim,fub,nroots,minl)
  ! Forms (es|fs) from the two dimensional integrals for a single
  ! set of primitives, where e = 0 or f = 0.
    IN :: self
    MAT, target :: Ix,Iy,Iz,Iyz
    VEC, IN :: weights
    VEC, OUT :: esfsadd
    IVEC, IN :: fx,fy,fz
    INT, IN :: dim,fub,nroots,minl
    INT :: f,x,y,z,n,dim1,dim2,ii
    DBL :: w,Iz_w
    VEC, PTR :: Izz

    ! Apply the reduced multiplication scheme to merge the Iy and Iz 2d
    ! integrals into a single matrix (upper triangle).
    if (minl > 2) then
      dim1 = dim+1
      dim2 = 2*dim1+1
      ii = 0
      do z=1,dim
        Izz => Iz(:,z)
        Izz(:) = Izz(:) * weights(:)  ! Merge the weights into Iz.
        do y=1,dim1-z
          ii = ii + 1
          Iyz(:,ii) = Izz * Iy(:,y)
        end
      end
      do f=1,fub
        x  = fx(f);  y = fy(f);  z = fz(f)
         ii = -dim1 + z*(dim2-z)/2 + y
        esfsadd(f)=sum(Ix(:,x) * Iyz(:,ii))
      end
    else
      do z=1,dim
        Izz => Iz(:,z)
        Izz(:) = Izz(:) * weights(:)  ! Merge the weights into Iz.
      end
      do f=1,fub
        x  = fx(f);  y = fy(f);  z = fz(f)
        esfsadd(f)=sum(Ix(:,x) * Iy(:,y) * Iz(:,z))
      end
    end
  end

  make_ppss(abcd)
  ! Creates the initial (pp|ss) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    RYS, PTR :: rysa
    VEC(3) :: CD
    DBL :: QP2,a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    DBL :: norma,normb,normd,norm,d_r2cd,b_r2ab,rho_zinv,half_zinv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Atx,Aty,Atz,a_zinv,c_einv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: rzt,ce1,tmp,tmp2,rzthze
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,w
    DBL :: ppss1,ppss2,ppss3,ppss4,ppss5,ppss6,ppss7,ppss8,ppss9
    DBL :: BAx,BAy,BAz
    INT :: ag,bg,cg,dg,n
    MAT, PTR :: normcd

    rysa.create(2)              ! nroots = 2

    CD   = .c%pos - .d%pos
    r2cd = dot_product(CD,CD)
    Ax = .a%pos(1); Ay = .a%pos(2); Az = .a%pos(3)
    Bx = .b%pos(1); By = .b%pos(2); Bz = .b%pos(3)
    Cx = .c%pos(1); Cy = .c%pos(2); Cz = .c%pos(3)
    Dx = .d%pos(1); Dy = .d%pos(2); Dz = .d%pos(3)
    BAx = Bx - Ax; BAy = By - Ay; BAz = Bz - Az;
    r2ab = BAx*BAx + BAy*BAy + BAz*BAz
    if (.a%l > .b%l) then
      Atx = Ax; Aty = Ay; Atz = Az
    else
      Atx = Bx; Aty = By; Atz = Bz
    end

    normcd.create(.c%n_cc,.d%n_cc)
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = .d%cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = exp(-c * d_r2cd * einv)
        normcd(cg,dg) = normd * .c%cc(cg) * einv * sqrt(einv) * kcd
      end
    end

    ppss1 = ZERO; ppss2 = ZERO; ppss3 = ZERO
    ppss4 = ZERO; ppss5 = ZERO; ppss6 = ZERO
    ppss7 = ZERO; ppss8 = ZERO; ppss9 = ZERO
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = TWOPI5ON2 * .b%cc(bg)
      b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a     = .a%ex(ag) 
        zeta  = a + b
        zinv  = ONE / zeta
        a_zinv = a * zinv
        half_zinv = HALF * zinv
        kab   = exp(- a_zinv * b_r2ab)
        norma = normb * .a%cc(ag) * kab * zinv
        Px    = b_Bx * zinv + a_zinv * Ax
        Py    = b_By * zinv + a_zinv * Ay
        Pz    = b_Bz * zinv + a_zinv * Az
        PAx = Px - Atx; PAy = Py - Aty; PAz = Pz - Atz
        do dg = 1, .d%n_cc
          d     = .d%ex(dg)
          d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
          do cg = 1, .c%n_cc
            c    = .c%ex(cg)
            eta  = c + d
            einv = ONE / eta
            c_einv = c * einv
            Qx   = d_Dx * einv + c_einv * Cx
            Qy   = d_Dy * einv + c_einv * Cy
            Qz   = d_Dz * einv + c_einv * Cz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            norm = norma * sqrt(rho_zinv) * normcd(cg,dg)
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            do n=1,2
              rzt      = rysa%r(n) * rho_zinv
              rzthze   = (ONE - rzt) * half_zinv
              Ix2 = PAx + rzt * QPx
              Iy2 = PAy + rzt * QPy
              Iz2 = PAz + rzt * QPz
              Ix3 = Ix2 * Ix2 + rzthze
              Iy3 = Iy2 * Iy2 + rzthze
              Iz3 = Iz2 * Iz2 + rzthze

              w = rysa%w(n) * norm
              Iz2 = Iz2 * w
              Iz3 = Iz3 * w

              ppss1 = ppss1 + (Ix2 *         w)   ! 100
              ppss2 = ppss2 + (      Iy2 *   w)   ! 010
              ppss3 = ppss3 + (            Iz2)   ! 001
              ppss4 = ppss4 + (Ix3 *         w)   ! 200
              ppss5 = ppss5 + (      Iy3 *   w)   ! 020
              ppss6 = ppss6 + (            Iz3)   ! 002
              ppss7 = ppss7 + (Ix2 * Iy2 *   w)   ! 110
              ppss8 = ppss8 + (Ix2 *       Iz2)   ! 101
              ppss9 = ppss9 + (      Iy2 * Iz2)   ! 011
            end
          end
        end
      end
    end
    normcd.destroy
    rysa.destroy

    ! Transfer equation.
    abcd(1,1,1,1) = ppss4 + BAx * ppss1 !  100|100 = 200|000 + x 100|000
    abcd(2,1,1,1) = ppss7 + BAx * ppss2 !  010|100 = 110|000 + x 010|000
    abcd(3,1,1,1) = ppss8 + BAx * ppss3 !  001|100 = 101|000 + x 001|000
    abcd(1,2,1,1) = ppss7 + BAy * ppss1 !  100|100 = 110|000 + y 100|000
    abcd(2,2,1,1) = ppss5 + BAy * ppss2 !  010|100 = 020|000 + y 010|000
    abcd(3,2,1,1) = ppss9 + BAy * ppss3 !  001|100 = 011|000 + y 001|000
    abcd(1,3,1,1) = ppss8 + BAz * ppss1 !  100|100 = 101|000 + z 100|000
    abcd(2,3,1,1) = ppss9 + BAz * ppss2 !  010|100 = 011|000 + z 010|000
    abcd(3,3,1,1) = ppss6 + BAz * ppss3 !  001|100 = 002|000 + z 001|000
  end

  make_sspp(abcd)
  ! Creates the (ss|pp) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    MAT, PTR :: Ix,Iy,Iz
    MAT, PTR :: Iyz
    RYS, PTR :: rysa
    VEC(3) :: AB
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab,rho_einv,half_einv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,Ctx,Cty,Ctz,c_einv,a_zinv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: ret,cf1,tmp,tmp2,rethen
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,w
    DBL :: sspp1,sspp2,sspp3,sspp4,sspp5,sspp6,sspp7,sspp8,sspp9
    DBL :: DCx,DCy,DCz
    INT :: ag,bg,cg,dg,n
    MAT, PTR :: normab

    rysa.create(2)

    AB   = .a%pos - .b%pos
    r2ab = dot_product(AB,AB)
    Ax = .a%pos(1); Ay = .a%pos(2); Az = .a%pos(3)
    Bx = .b%pos(1); By = .b%pos(2); Bz = .b%pos(3)
    Cx = .c%pos(1); Cy = .c%pos(2); Cz = .c%pos(3)
    Dx = .d%pos(1); Dy = .d%pos(2); Dz = .d%pos(3)
    DCx = Dx - Cx; DCy = Dy - Cy; DCz = Dz - Cz;
    r2cd = DCx*DCx + DCy*DCy + DCz*DCz
    if (.c%l > .d%l) then
      Ctx = Cx; Cty = Cy; Ctz = Cz
    else
      Ctx = Dx; Cty = Dy; Ctz = Dz
    end

    normab.create(.a%n_cc,.b%n_cc)
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = .b%cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = exp(-a * b_r2ab * zinv)
        normab(ag,bg) = normb * .a%cc(ag) * zinv * sqrt(zinv) * kab
      end
    end

    sspp1 = ZERO; sspp2 = ZERO; sspp3 = ZERO
    sspp4 = ZERO; sspp5 = ZERO; sspp6 = ZERO
    sspp7 = ZERO; sspp8 = ZERO; sspp9 = ZERO
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        half_einv = HALF * einv
        c_einv = c * einv
        kcd  = exp(- c_einv * d_r2cd)
        normc = normd * .c%cc(cg) * kcd * einv
        Qx   = d_Dx * einv + c_einv * Cx
        Qy   = d_Dy * einv + c_einv * Cy
        Qz   = d_Dz * einv + c_einv * Cz
        QCx  = Qx - Ctx
        QCy  = Qy - Cty
        QCz  = Qz - Ctz
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            a_zinv = a * zinv
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            norm = normc * sqrt(rho_einv)*normab(ag,bg)
            Px    = b_Bx * zinv + a_zinv * Ax
            Py    = b_By * zinv + a_zinv * Ay
            Pz    = b_Bz * zinv + a_zinv * Az
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            do n=1,2
              ret     = rysa%r(n) * rho_einv
              rethen  = (ONE - ret) * half_einv
              Ix2 = QCx - ret * QPx
              Iy2 = QCy - ret * QPy
              Iz2 = QCz - ret * QPz
              Ix3 = Ix2 * Ix2 + rethen
              Iy3 = Iy2 * Iy2 + rethen
              Iz3 = Iz2 * Iz2 + rethen
              w = rysa%w(n) * norm

              Iz2 = Iz2 * w
              Iz3 = Iz3 * w

              sspp1 = sspp1 + (Ix2 *         w)    ! 100|000
              sspp2 = sspp2 + (      Iy2 *   w)    ! 010|000
              sspp3 = sspp3 + (            Iz2)    ! 001|000
              sspp4 = sspp4 + (Ix3 *         w)    ! 200|000
              sspp5 = sspp5 + (      Iy3 *   w)    ! 020|000
              sspp6 = sspp6 + (            Iz3)    ! 002|000
              sspp7 = sspp7 + (Ix2 * Iy2 *   w)    ! 110|000
              sspp8 = sspp8 + (Ix2 *       Iz2)    ! 101|000
              sspp9 = sspp9 + (      Iy2 * Iz2)    ! 011|000
            end
          end
        end
      end
    end
    normab.destroy
    rysa.destroy

    ! Transfer equation.
    abcd(1,1,1,1) = sspp4 + DCx * sspp1 !  100|100 = 200|000 + x 100|000
    abcd(1,1,1,2) = sspp7 + DCx * sspp2 !  010|100 = 110|000 + x 010|000
    abcd(1,1,1,3) = sspp8 + DCx * sspp3 !  001|100 = 101|000 + x 001|000
    abcd(1,1,2,1) = sspp7 + DCy * sspp1 !  100|100 = 110|000 + y 100|000
    abcd(1,1,2,2) = sspp5 + DCy * sspp2 !  010|100 = 020|000 + y 010|000
    abcd(1,1,2,3) = sspp9 + DCy * sspp3 !  001|100 = 011|000 + y 001|000
    abcd(1,1,3,1) = sspp8 + DCz * sspp1 !  100|100 = 101|000 + z 100|000
    abcd(1,1,3,2) = sspp9 + DCz * sspp2 !  010|100 = 011|000 + z 010|000
    abcd(1,1,3,3) = sspp6 + DCz * sspp3 !  001|100 = 002|000 + z 001|000
  end

  make_psss(abcd)
  ! Creates the initial (ps|ss) or (sp|ss) integrals, summed over the
  ! primitives.
    IN :: self
    MAT4, OUT :: abcd
    RYS, PTR :: rysa
    VEC(3) :: AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd,rho_zinv
    INT :: ag,bg,cg,dg
    DBL :: norma,normb,normd,norm,rzt,d_r2cd,b_r2ab
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Atx,Aty,Atz,a_zinv,c_einv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: psss1,psss2,psss3
    MAT, PTR :: normcd

    rysa.create(1)

    AB   = .a%pos - .b%pos
    CD   = .c%pos - .d%pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)
    Ax = .a%pos(1); Ay = .a%pos(2); Az = .a%pos(3)
    Bx = .b%pos(1); By = .b%pos(2); Bz = .b%pos(3)
    Cx = .c%pos(1); Cy = .c%pos(2); Cz = .c%pos(3)
    Dx = .d%pos(1); Dy = .d%pos(2); Dz = .d%pos(3)
    if (.a%l > .b%l) then
      Atx = Ax; Aty = Ay; Atz = Az
    else
      Atx = Bx; Aty = By; Atz = Bz
    end

    normcd.create(.c%n_cc,.d%n_cc)
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = .d%cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = exp(-c * d_r2cd * einv)
        normcd(cg,dg) = normd * .c%cc(cg) * einv * sqrt(einv) * kcd
      end
    end

    psss1 = ZERO
    psss2 = ZERO
    psss3 = ZERO
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = TWOPI5ON2 * .b%cc(bg)
      b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a     = .a%ex(ag) 
        zeta  = a + b
        zinv  = ONE / zeta
        a_zinv = a * zinv
        kab   = exp(- a_zinv * b_r2ab)
        norma = normb * .a%cc(ag) * kab * zinv
        Px    = b_Bx * zinv + a_zinv * Ax
        Py    = b_By * zinv + a_zinv * Ay
        Pz    = b_Bz * zinv + a_zinv * Az
        PAx = Px - Atx; PAy = Py - Aty; PAz = Pz - Atz
        do dg = 1, .d%n_cc
          d     = .d%ex(dg)
          normd = norma * .d%cc(dg)
          d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
          d_r2cd = d * r2cd
          do cg = 1, .c%n_cc
            c    = .c%ex(cg)
            eta  = c + d
            einv = ONE / eta
            c_einv = c * einv
            Qx   = (d_Dx + c * Cx) * einv
            Qy   = (d_Dy + c * Cy) * einv
            Qz   = (d_Dz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            rzt = rysa%r(1) * rho_zinv
            norm = norma * sqrt(rho_zinv) * normcd(cg,dg) * rysa%w(1)
            psss1 = psss1 + norm * (PAx + rzt * QPx)
            psss2 = psss2 + norm * (PAy + rzt * QPy)
            psss3 = psss3 + norm * (PAz + rzt * QPz)
          end
        end
      end
    end
    normcd.destroy
    rysa.destroy
    abcd(1,1,1,1) = psss1
    if (.a%l == 1) then        ! psss
      abcd(2,1,1,1) = psss2
      abcd(3,1,1,1) = psss3
    else                       ! spss
      abcd(1,2,1,1) = psss2
      abcd(1,3,1,1) = psss3
    end
  end

  make_ssps(abcd)
  ! Creates the (ss|ps) or (ss|sp) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    RYS, PTR :: rysa
    VEC(3) :: P,Q,QC,QP,brb,drd,AB,CD,A_tmp,C_tmp
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd,ret
    INT :: ag,bg,cg,dg
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab,rho_einv,half_einv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,Ctx,Cty,Ctz,c_einv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: ssps1,ssps2,ssps3
    MAT, PTR :: normab

    rysa.create(1)

    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    Ax = .a%pos(1); Ay = .a%pos(2); Az = .a%pos(3)
    Bx = .b%pos(1); By = .b%pos(2); Bz = .b%pos(3)
    Cx = .c%pos(1); Cy = .c%pos(2); Cz = .c%pos(3)
    Dx = .d%pos(1); Dy = .d%pos(2); Dz = .d%pos(3)
    if (.c%l > .d%l) then
      Ctx = Cx; Cty = Cy; Ctz = Cz
    else
      Ctx = Dx; Cty = Dy; Ctz = Dz
    end

    normab.create(.a%n_cc,.b%n_cc)
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = .b%cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = exp(-a * b_r2ab * zinv)
        normab(ag,bg) = normb * .a%cc(ag) * zinv * sqrt(zinv) * kab
      end
    end

    ssps1=ZERO
    ssps2=ZERO
    ssps3=ZERO
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        c_einv = c * einv
        kcd  = exp(- c_einv * d_r2cd)
        normc = normd * .c%cc(cg) * kcd * einv
        Qx   = d_Dx * einv + c_einv * Cx
        Qy   = d_Dy * einv + c_einv * Cy
        Qz   = d_Dz * einv + c_einv * Cz
        QCx  = Qx - Ctx
        QCy  = Qy - Cty
        QCz  = Qz - Ctz
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
          do ag = 1, .a%n_cc
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            Px    = (b_Bx + a * Ax) * zinv
            Py    = (b_By + a * Ay) * zinv
            Pz    = (b_Bz + a * Az) * zinv
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            ret = rysa%r(1) * rho_einv
            norm = normc * sqrt(rho_einv)* normab(ag,bg) * rysa%w(1)
            ssps1 = ssps1 + norm * (QCx - ret * QPx)
            ssps2 = ssps2 + norm * (QCy - ret * QPy)
            ssps3 = ssps3 + norm * (QCz - ret * QPz)
          end
        end
      end
    end
    normab.destroy
    rysa.destroy

    abcd(1,1,1,1) = ssps1
    if (.c%l == 1) then           ! ssps
      abcd(1,1,2,1) = ssps2
      abcd(1,1,3,1) = ssps3
    else                          ! sssp
      abcd(1,1,1,2) = ssps2
      abcd(1,1,1,3) = ssps3
    end
  end

  make_ssss(abcd)
  ! Creates the (ss|ss) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT :: abcd
    DBL :: ssss
    RYS, PTR :: rysa
    VEC(3) :: P,Q,QP,brb,drd,AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg,i
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,Ctx,Cty,Ctz,c_einv,a_zinv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz,rho_einv
    VEC, PTR :: normab

    rysa.create(1)

    AB   = .a%pos - .b%pos
    CD   = .c%pos - .d%pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)
    Ax = .a%pos(1); Ay = .a%pos(2); Az = .a%pos(3)
    Bx = .b%pos(1); By = .b%pos(2); Bz = .b%pos(3)
    Cx = .c%pos(1); Cy = .c%pos(2); Cz = .c%pos(3)
    Dx = .d%pos(1); Dy = .d%pos(2); Dz = .d%pos(3)

    normab.create(.a%n_cc*.b%n_cc)
    i=0
    do bg = 1, .b%n_cc
      b     = .b%ex(bg)
      normb = .b%cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a%n_cc
        a    = .a%ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = exp(-a * b_r2ab * zinv)
        i=i+1
        normab(i) = normb * .a%cc(ag) * zinv * sqrt(zinv) * kab
      end
    end

    ssss = ZERO
    do dg = 1, .d%n_cc
      d     = .d%ex(dg)
      normd = TWOPI5ON2 * .d%cc(dg)
      d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
      d_r2cd = d * r2cd
      do cg = 1, .c%n_cc
        c    = .c%ex(cg)
        eta  = c + d
        einv = ONE / eta
        c_einv = c * einv
        kcd  = exp(- c_einv * d_r2cd)
        normc = normd * .c%cc(cg) * kcd * einv
        Qx   = d_Dx * einv + c_einv * Cx
        Qy   = d_Dy * einv + c_einv * Cy
        Qz   = d_Dz * einv + c_einv * Cz
        i = 0
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
          do ag = 1, .a%n_cc
            i=i+1
            a     = .a%ex(ag) 
            zeta  = a + b
            zinv  = ONE / zeta
            a_zinv = a * zinv
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            norm = normc * sqrt(rho_einv)* normab(i)
            Px    = (b_Bx + a * Ax) * zinv
            Py    = (b_By + a * Ay) * zinv
            Pz    = (b_Bz + a * Az) * zinv
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            ssss = ssss + norm * rysa%w(1)
          end
        end
      end
    end
    normab.destroy
    rysa.destroy
    abcd = ssss
  end

  transfer(esfs,escd)
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    if (.c%l > .d%l) then
      .transfer_l_c_highest(esfs,escd)
    else
      .transfer_l_d_highest(esfs,escd)
    end
  end

  transfer(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    if (.a%l > .b%l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

  transfer_l_c_highest(esfs,escd)
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3, PTR :: int_new,int_old
    IMAT, PTR :: components,components_c,components_d
    IMAT3, PTR :: index_c,index_d
    IVEC, PTR :: comp_to_use,component_to_use
    VEC(3) :: CD
    INT :: a,b,c,d,c1,c2,c3,d1,d2,d3,ld,aub,bub,cub,dub
    INT :: cx,cy,cz,dx,dy,dz,j,n_f,clb,dlb,tmp,e,eub
    DBL :: CDi,CDx,CDy,CDz,esfs_ec

    select case (.d%l)
      case (0)
        escd(:,:,1)=esfs

      case (1)
        clb = (.c%l-1).n_comp_sum
        eub = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        cub  = .c%n_comp

        components.create(3, n_f.n_comp_sum - clb)
        index_c.create(0,n_f,0,n_f,0,n_f)
        .c%l.make_gaussian_xyz_powers(components,n_f,index_c)

        CDx = CD(1); CDy = CD(2); CDz = CD(3)
        do c = 1, cub
          cx = components(1,c)
          cy = components(2,c)
          cz = components(3,c)
          c1 = index_c(cx+1,cy,cz)
          c2 = index_c(cx,cy+1,cz)
          c3 = index_c(cx,cy,cz+1)
          do e = 1, eub
            esfs_ec = esfs(e,c)
            escd(e,c,1) = esfs(e,c1) + CDx * esfs_ec
            escd(e,c,2) = esfs(e,c2) + CDy * esfs_ec
            escd(e,c,3) = esfs(e,c3) + CDz * esfs_ec
          end
        end
        components.destroy
        index_c.destroy

      case default
        clb  = (.c%l-1).n_comp_sum
        eub  = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        cub  = (n_f-1).n_comp_sum - clb

        index_c.create(0,n_f,0,n_f,0,n_f)
        index_d.create(0,n_f,0,n_f,0,n_f)
        components.create(3, n_f.n_comp_sum)
        comp_to_use.create( n_f.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_f,index_d,comp_to_use)
        .c%l.make_gaussian_xyz_power_index(index_c,n_f)
        components_c => components(:,clb+1:)

        nullify(int_new)
        int_new.create(eub,cub,3)

        CDx = CD(1); CDy = CD(2); CDz = CD(3)
        do c = 1, cub
          cx = components_c(1,c)
          cy = components_c(2,c)
          cz = components_c(3,c)
          c1 = index_c(cx+1,cy,cz)
          c2 = index_c(cx,cy+1,cz)
          c3 = index_c(cx,cy,cz+1)
          do e = 1, eub
            esfs_ec = esfs(e,c)
            int_new(e,c,1) = esfs(e,c1) + CDx * esfs_ec
            int_new(e,c,2) = esfs(e,c2) + CDy * esfs_ec
            int_new(e,c,3) = esfs(e,c3) + CDz * esfs_ec
          end
        end

        do ld=2, .d%l - 1
          dlb              = (ld-1).n_comp_sum
          dub              = ld.n_comp
          cub              = (n_f-ld).n_comp_sum - clb
          component_to_use => comp_to_use(dlb+1:dlb+dub)
          components_d     => components(:,dlb+1:dlb+dub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(eub,cub,dub)
          do d=1,dub
            dx = components_d(1,d)
            dy = components_d(2,d)
            dz = components_d(3,d)
            j=component_to_use(d)
            .subtract_from_component(dx,dy,dz,j)
            d1 = index_d(dx,dy,dz)
            CDi=CD(j)
            do c=1,cub
              cx = components_c(1,c)
              cy = components_c(2,c)
              cz = components_c(3,c)
              .add_to_component(cx,cy,cz,j)
              c1 = index_c(cx,cy,cz)
              do e=1,eub
                int_new(e,c,d)=int_old(e,c1,d1)+CDi*int_old(e,c,d1)
              end
            end
          end
          int_old.destroy
        end

        dlb              = (.d%l-1).n_comp_sum
        dub              = .d%n_comp
        cub              = .c%n_comp
        component_to_use => comp_to_use(dlb+1:dlb+dub)
        components_d     => components(:,dlb+1:dlb+dub)
        int_old          => int_new
        do d=1,dub
          dx = components_d(1,d)
          dy = components_d(2,d)
          dz = components_d(3,d)
          j=component_to_use(d)
          .subtract_from_component(dx,dy,dz,j)
          d1 = index_d(dx,dy,dz)
          CDi=CD(j)
          do c=1,cub
            cx = components_c(1,c)
            cy = components_c(2,c)
            cz = components_c(3,c)
            .add_to_component(cx,cy,cz,j)
            c1 = index_c(cx,cy,cz)
            do e=1,eub
              escd(e,c,d)=int_old(e,c1,d1)+CDi*int_old(e,c,d1)
            end
          end
        end
        int_old.destroy
        index_c.destroy
        index_d.destroy
        components.destroy
        comp_to_use.destroy
    end
  end

  transfer_l_d_highest(esfs,escd)
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3, PTR :: int_new,int_old
    IMAT, PTR :: components,components_c,components_d
    IMAT3, PTR :: index_c,index_d
    IVEC, PTR :: comp_to_use,component_to_use
    VEC(3) :: DC
    INT :: a,b,c,d,c1,c2,c3,d1,d2,d3,lc,aub,bub,cub,dub
    INT :: cx,cy,cz,dx,dy,dz,j,n_f,clb,dlb,tmp,e,eub
    DBL :: DCi,DCx,DCy,DCz,esfs_ed

    select case (.c%l)
      case (0)
        escd(:,1,:)=esfs

      case (1)
        dlb = (.d%l-1).n_comp_sum
        eub = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        DC   = .d%pos - .c%pos
        n_f  = .c%l + .d%l
        dub  = .d%n_comp

        components.create(3, n_f.n_comp_sum - dlb)
        index_d.create(0,n_f,0,n_f,0,n_f)
        .d%l.make_gaussian_xyz_powers(components,n_f,index_d)

        DCx=DC(1); DCy=DC(2); DCz=DC(3)
        do d=1,dub
          dx = components(1,d)
          dy = components(2,d)
          dz = components(3,d)
          d1 = index_d(dx+1,dy,dz)
          d2 = index_d(dx,dy+1,dz)
          d3 = index_d(dx,dy,dz+1)
          do e=1,eub
            esfs_ed = esfs(e,d)
            escd(e,1,d)=esfs(e,d1)+DCx*esfs_ed
            escd(e,2,d)=esfs(e,d2)+DCy*esfs_ed
            escd(e,3,d)=esfs(e,d3)+DCz*esfs_ed
          end
        end
        components.destroy
        index_d.destroy

      case default
        dlb = (.d%l-1).n_comp_sum
        eub = (.a%l+.b%l).n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
        DC   = .d%pos - .c%pos
        n_f  = .c%l + .d%l
        dub  = (n_f-1).n_comp_sum - dlb

        index_c.create(0,n_f,0,n_f,0,n_f)
        index_d.create(0,n_f,0,n_f,0,n_f)
        components.create(3, n_f.n_comp_sum)
        comp_to_use.create( n_f.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_f,index_c,comp_to_use)
        .d%l.make_gaussian_xyz_power_index(index_d,n_f)
        components_d => components(:,dlb+1:)

        nullify(int_new)
        int_new.create(eub,dub,3)
        DCx=DC(1); DCy=DC(2); DCz=DC(3)
        do d=1,dub
          dx = components_d(1,d)
          dy = components_d(2,d)
          dz = components_d(3,d)
          d1 = index_d(dx+1,dy,dz)
          d2 = index_d(dx,dy+1,dz)
          d3 = index_d(dx,dy,dz+1)
          do e=1,eub
            esfs_ed = esfs(e,d)
            int_new(e,d,1)=esfs(e,d1)+DCx*esfs_ed
            int_new(e,d,2)=esfs(e,d2)+DCy*esfs_ed
            int_new(e,d,3)=esfs(e,d3)+DCz*esfs_ed
          end
        end
        do lc=2, .c%l - 1
          clb              = (lc-1).n_comp_sum
          cub              = lc.n_comp
          dub              = (n_f-lc).n_comp_sum - dlb
          component_to_use => comp_to_use(clb+1:clb+cub)
          components_c     => components(:,clb+1:clb+cub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(eub,dub,cub)
          do c=1,cub
            cx = components_c(1,c)
            cy = components_c(2,c)
            cz = components_c(3,c)
            j=component_to_use(c)
            .subtract_from_component(cx,cy,cz,j)
            c1 = index_c(cx,cy,cz)
            DCi=DC(j)
            do d=1,dub
              dx = components_d(1,d)
              dy = components_d(2,d)
              dz = components_d(3,d)
              .add_to_component(dx,dy,dz,j)
              d1 = index_d(dx,dy,dz)
              do e=1,eub
                int_new(e,d,c)=int_old(e,d1,c1)+DCi*int_old(e,d,c1)
              end
            end
          end
          int_old.destroy
        end
        clb              = (.c%l-1).n_comp_sum
        cub              = .c%n_comp
        dub              = .d%n_comp
        component_to_use => comp_to_use(clb+1:clb+cub)
        components_c     => components(:,clb+1:clb+cub)
        int_old          => int_new
        do c=1,cub
          cx = components_c(1,c)
          cy = components_c(2,c)
          cz = components_c(3,c)
          j=component_to_use(c)
          .subtract_from_component(cx,cy,cz,j)
          c1 = index_c(cx,cy,cz)
          DCi=DC(j)
          do d=1,dub
            dx = components_d(1,d)
            dy = components_d(2,d)
            dz = components_d(3,d)
            .add_to_component(dx,dy,dz,j)
            d1 = index_d(dx,dy,dz)
            do e=1,eub
              escd(e,c,d)=int_old(e,d1,c1)+DCi*int_old(e,d,c1)
            end
          end
        end
        int_old.destroy
        index_c.destroy
        index_d.destroy
        components.destroy
        comp_to_use.destroy
    end
  end

  transfer_l_a_highest(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4, PTR :: int_new,int_old
    IMAT, PTR :: components,components_a,components_b
    IMAT3, PTR :: index_a,index_b
    VEC(3) :: AB
    INT :: a,b,c,d,a1,a2,a3,b1,b2,b3,lb,aub,bub,cub,dub
    INT :: ax,ay,az,bx,by,bz,j,n_e,alb,blb,tmp
    DBL :: ABi,ABx,ABy,ABz,escd_acd
    IVEC, PTR :: comp_to_use,component_to_use

    select case (.b%l)
      case (0)
        abcd(:,1,:,:)=escd

      case (1)
        alb = (.a%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        aub  = .a%n_comp
        cub  = .c%n_comp
        dub  = .d%n_comp

        components.create(3, n_e.n_comp_sum - alb)
        index_a.create(0,n_e,0,n_e,0,n_e)
        .a%l.make_gaussian_xyz_powers(components,n_e,index_a)

        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components(1,a)
          ay = components(2,a)
          az = components(3,a)
          a1 = index_a(ax+1,ay,az)
          a2 = index_a(ax,ay+1,az)
          a3 = index_a(ax,ay,az+1)
          do d=1,dub
            do c=1,cub
              escd_acd = escd(a,c,d)
              abcd(a,1,c,d)=escd(a1,c,d) + ABx * escd_acd
              abcd(a,2,c,d)=escd(a2,c,d) + ABy * escd_acd
              abcd(a,3,c,d)=escd(a3,c,d) + ABz * escd_acd
            end
          end
        end
        index_a.destroy
        components.destroy

      case default
        alb = (.a%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        aub  = (n_e-1).n_comp_sum - alb
        bub  = .b%n_comp
        cub  = .c%n_comp
        dub  = .d%n_comp

        index_b.create(0,n_e,0,n_e,0,n_e)
        index_a.create(0,n_e,0,n_e,0,n_e)
        components.create(3, n_e.n_comp_sum)
        comp_to_use.create( n_e.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_e,index_b,comp_to_use)
        tmp=.a%l; tmp.make_gaussian_xyz_power_index(index_a,n_e)
        components_a => components(:,alb+1:)

        nullify(int_new)
        int_new.create(dub,cub,bub,aub)
        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          a1 = index_a(ax+1,ay,az)
          a2 = index_a(ax,ay+1,az)
          a3 = index_a(ax,ay,az+1)
          do c=1,cub
            do d=1,dub
              escd_acd = escd(a,c,d)
              int_new(d,c,1,a)=escd(a1,c,d) + ABx * escd_acd
              int_new(d,c,2,a)=escd(a2,c,d) + ABy * escd_acd
              int_new(d,c,3,a)=escd(a3,c,d) + ABz * escd_acd
            end
          end
        end

        do lb=2, .b%l - 1
          blb              = (lb-1).n_comp_sum
          bub              = lb.n_comp
          aub              = (n_e-lb).n_comp_sum - alb
          component_to_use => comp_to_use(blb+1:blb+bub)
          components_b     => components(:,blb+1:blb+bub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(dub,cub,bub,aub)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            j = component_to_use(b)
            .subtract_from_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz)
            ABi=AB(j)
            do a=1,aub
              ax = components_a(1,a)
              ay = components_a(2,a)
              az = components_a(3,a)
              .add_to_component(ax,ay,az,j)
              a1 = index_a(ax,ay,az)
              int_new(:,:,b,a)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
            end
          end
          int_old.destroy
        end

        blb              = (.b%l-1).n_comp_sum
        bub              = .b%n_comp
        aub              = .a%n_comp
        component_to_use => comp_to_use(blb+1:blb+bub)
        components_b     => components(:,blb+1:blb+bub)
        int_old          => int_new
        do b=1,bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          j = component_to_use(b)
          .subtract_from_component(bx,by,bz,j)
          b1 = index_b(bx,by,bz)
          ABi=AB(j)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            .add_to_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az)
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=int_old(d,c,b1,a1) + ABi * int_old(d,c,b1,a)
            end
          end
        end
        int_old.destroy
        comp_to_use.destroy
        components.destroy
        index_a.destroy
        index_b.destroy
    end
  end

  transfer_l_b_highest(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4, PTR :: int_new,int_old
    IMAT, PTR :: components,components_a,components_b
    IMAT3, PTR :: index_a,index_b
    VEC(3) :: BA
    INT :: a,b,c,d,a1,a2,a3,b1,b2,b3,la,aub,bub,cub,dub
    INT :: ax,ay,az,bx,by,bz,j,n_e,alb,blb,tmp
    DBL :: BAi,BAx,BAy,BAz,escd_bcd
    IVEC, PTR :: comp_to_use,component_to_use

    select case (.a%l)
      case (0)
        abcd(1,:,:,:)=escd

      case (1)
        blb = (.b%l-1).n_comp_sum
        BA   = .b%pos - .a%pos
        n_e  = .a%l + .b%l
        bub  = .b%n_comp
        cub  = .c%n_comp
        dub  = .d%n_comp

        components.create(3, n_e.n_comp_sum - blb)
        index_b.create(0,n_e,0,n_e,0,n_e)
        .b%l.make_gaussian_xyz_powers(components,n_e,index_b)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components(1,b)
          by = components(2,b)
          bz = components(3,b)
          b1 = index_b(bx+1,by,bz)
          b2 = index_b(bx,by+1,bz)
          b3 = index_b(bx,by,bz+1)
          do d = 1, dub
            do c = 1, cub
              escd_bcd = escd(b,c,d)
              abcd(1,b,c,d) = escd(b1,c,d) + BAx * escd_bcd
              abcd(2,b,c,d) = escd(b2,c,d) + BAy * escd_bcd
              abcd(3,b,c,d) = escd(b3,c,d) + BAz * escd_bcd
            end
          end
        end

        components.destroy
        index_b.destroy

      case default
        blb = (.b%l-1).n_comp_sum
        BA   = .b%pos - .a%pos
        n_e  = .a%l + .b%l
        bub  = (n_e-1).n_comp_sum - blb
        aub  = .a%n_comp
        cub  = .c%n_comp
        dub  = .d%n_comp

        index_a.create(0,n_e,0,n_e,0,n_e)
        index_b.create(0,n_e,0,n_e,0,n_e)
        components.create(3, n_e.n_comp_sum)
        comp_to_use.create( n_e.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_e,index_a,comp_to_use)
        tmp=.b%l; tmp.make_gaussian_xyz_power_index(index_b,n_e)
        components_b => components(:,blb+1:)

        nullify(int_new)
        int_new.create(dub,cub,bub,aub)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          b1 = index_b(bx+1,by,bz)
          b2 = index_b(bx,by+1,bz)
          b3 = index_b(bx,by,bz+1)
          do d = 1, dub
            do c = 1, cub
              escd_bcd = escd(b,c,d)
              int_new(d,c,b,1) = escd(b1,c,d) + BAx * escd_bcd
              int_new(d,c,b,2) = escd(b2,c,d) + BAy * escd_bcd
              int_new(d,c,b,3) = escd(b3,c,d) + BAz * escd_bcd
            end
          end
        end

        do la=2, .a%l - 1
          alb              = (la-1).n_comp_sum
          aub              = la.n_comp
          bub              = (n_e-la).n_comp_sum - blb
          component_to_use => comp_to_use(alb+1:alb+aub)
          components_a     => components(:,alb+1:alb+aub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(dub,cub,bub,aub)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            j=component_to_use(a)
            .subtract_from_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az)
            BAi=BA(j)
            do b=1,bub
              bx = components_b(1,b)
              by = components_b(2,b)
              bz = components_b(3,b)
              .add_to_component(bx,by,bz,j)
              b1 = index_b(bx,by,bz)
              int_new(:,:,b,a)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
            end
          end
          int_old.destroy
        end

        alb              = (.a%l-1).n_comp_sum
        aub              = .a%n_comp
        bub              = .b%n_comp
        component_to_use => comp_to_use(alb+1:alb+aub)
        components_a     => components(:,alb+1:alb+aub)
        int_old          => int_new
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          j = component_to_use(a)
          .subtract_from_component(ax,ay,az,j)
          a1 = index_a(ax,ay,az)
          BAi=BA(j)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            .add_to_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz)
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=int_old(d,c,b1,a1) + BAi * int_old(d,c,b,a1)
            end
          end
        end
        int_old.destroy
        comp_to_use.destroy
        components.destroy
        index_b.destroy
        index_a.destroy
    end
  end

  add_to_component(x,y,z,j)
  ! Adds one to the component specified by j.  Used by transfer equation.
  ! j=1 => x=x+1, j=2 => y=y+1, j=3 => z=z+1.
    INT, INOUT :: x,y,z
    INT, IN :: j
    select case(j)
      case (1); x = x + 1
      case (2); y = y + 1
      case (3); z = z + 1
    end
  end

  subtract_from_component(x,y,z,j)
  ! Subtracts one from the component specified by j.  Used by transfer equation.
  ! j=1 => x=x-1, j=2 => y=y-1, j=3 => z=z-1.
    INT, INOUT :: x,y,z
    INT, IN :: j
    select case(j)
      case (1); x = x - 1
      case (2); y = y - 1
      case (3); z = z - 1
    end
  end

  to_normalize(abcd)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, b, c and d.
    IN :: self
    MAT4, target :: abcd
    VEC, PTR :: anorm,bnorm,cnorm,dnorm
    INT :: aub,bub,cub,dub,a,b,c,d,opt
    DBL :: normb,normc,normd
    MAT, PTR :: ab_cd

    opt = 0
    if (max(.a%l,.b%l) < 2) opt = opt + 1
    if (max(.c%l,.d%l) < 2) opt = opt + 2
    select case (opt)
      case (0)                                      ! The general routine.
        aub=.a%n_comp
        bub=.b%n_comp
        cub=.c%n_comp
        dub=.d%n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a%l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b%l )
        cnorm.create(cub);   cnorm.normalizing_factors( .c%l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d%l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            normc=normd*cnorm(c)
            ab_cd => abcd(:,:,c,d)
            do b=1,bub
              normb=normc*bnorm(b)
              ab_cd(:,b)=ab_cd(:,b)*normb*anorm(:)
            end
          end
        end
        anorm.destroy; bnorm.destroy; cnorm.destroy; dnorm.destroy
      case (1)                                      ! .a%l , .b%l either s or p
        cub = .c%n_comp
        dub = .d%n_comp
        cnorm.create(cub);   cnorm.normalizing_factors( .c%l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d%l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            abcd(:,:,c,d)=abcd(:,:,c,d)*normd*cnorm(c)
          end
        end
        cnorm.destroy; dnorm.destroy
      case (2)                                      ! .c%l , .d%l either s or p
        aub = .a%n_comp
        bub = .b%n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a%l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b%l )
        do b=1,bub
          normb=bnorm(b)
          do a=1,aub
            abcd(a,b,:,:)=abcd(a,b,:,:)*normb*anorm(a)
          end
        end
        anorm.destroy; bnorm.destroy
      case (3)                          ! .a%l , .b%l , .c%l , .d%l all s or p
        ! do nothing
    end
  end

  test(out)
    PTR :: self
    TEXTFILE :: out
    .create

    .a%n_cc = 1
    .a%ex.create(1);    .a%ex(1) = 20d0
    .a%cc.create(1);    .a%cc(1) = ONE
    .b%n_cc = 1
    .b%ex.create(1);    .b%ex(1) = 10d0
    .b%cc.create(1);    .b%cc(1) = ONE
    .c%n_cc = 1
    .c%ex.create(1);    .c%ex(1) = 5d0
    .c%cc.create(1);    .c%cc(1) = ONE
    .d%n_cc = 1
    .d%ex.create(1);    .d%ex(1) = 1d0
    .d%cc.create(1);    .d%cc(1) = ONE
    .a%pos = (/0.0d0,0.2d0,0.0d0/)
    .b%pos = (/0.3d0,-0.3d0,0.6d0/)
    .c%pos = (/0.8d0,0.5d0,0.2d0/)
    .d%pos = (/0.0d0,0.2d0,-0.3d0/)

    .a%l = 0
    .b%l = 0
    .c%l = 0
    .d%l = 0
    .put(out)

    out.set_dbl_precision(15)
    out.set_dbl_width(20)

    .a%l = 0;   .b%l = 0;   .c%l = 0;   .d%l = 0
    .compare_eri(out)

    .a%l = 1;   .b%l = 0;   .c%l = 0;   .d%l = 0
    .compare_eri(out)

    .destroy
  end

  compare_eri(out)
    TEXTFILE :: out
    MAT4, PTR :: I,J
    INT :: a,b,c,d,n_a,n_b,n_c,n_d
    DBL :: res,res2,tmp,tmp2
    n_a = .a%l.n_comp;   .a%n_comp = n_a
    n_b = .b%l.n_comp;   .b%n_comp = n_b
    n_c = .c%l.n_comp;   .c%n_comp = n_c
    n_d = .d%l.n_comp;   .d%n_comp = n_d
    I.create(n_a,n_b,n_c,n_d)
    J.create(n_a,n_b,n_c,n_d)
    .get_eri(I)
    .make_ERI_ints(J)

    res = ZERO
    res2 = ZERO
    do a=1,size(I,1)
    do b=1,size(I,2)
    do c=1,size(I,3)
    do d=1,size(I,4)
      tmp = abs(I(a,b,c,d)-J(a,b,c,d))
      if (tmp > res) res = tmp
      tmp2 = abs(I(a,b,c,d))
      if (tmp2 > res2) res2 = tmp2
    end
    end
    end
    end
    out.flush
    out.put(.a.l)
    out.put(.b.l)
    out.put(.c.l)
    out.put(.d.l,flush=1)
    out.put(res)
    out.put(res2,flush=1)

    J.destroy
    I.destroy
  end

end
