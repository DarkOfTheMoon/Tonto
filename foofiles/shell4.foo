!-------------------------------------------------------------------------------
!
! SHELL4 : Group of 4 contracted gaussian SHELL1's, used mainly for integrals
! (c) Daniel Grimwood, March 1998
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 5889-5897.
!
! $Id$
!-------------------------------------------------------------------------------

module SHELL4

  use TYPES
  use SYSTEM
  use INT
  use VEC
  use IVEC
  use IMAT
  use IMAT3
  use MAT
  use MAT3
  use MAT4
  use OUTPUT
  use SHELL1
  use RYS
  use GAUSSIAN4

  implicit none         

#include "macros"
#include "shell4.int"

! type shell4_type
!   SHELL1 :: a
!   SHELL1 :: b
!   SHELL1 :: c
!   SHELL1 :: d
! end

contains

  create
  ! Create a shell4 object, but no its component shells.
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SHELL4_SIZE)
    .nullify_ptr_part
  end

  create(shell_a,shell_b,shell_c,shell_d)
  ! Create a shell4 object from copies of shell1s.
    PTR :: self
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .create
    .copy(shell_a,shell_b,shell_c,shell_d)
  end

  create(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  ! Create a shell4 object from copies of shells and their positions.
    PTR :: self
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC(3), IN :: pos_a,pos_b,pos_c,pos_d
    .create
    .copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  end

  destroy
  ! Destroy a shell4 object.
    PTR :: self
    if (associated(self)) then
      .destroy_ptr_part
      DELETE_MEM(SHELL4_SIZE)
      deallocate(self)
    end
  end

  created result(res)
  ! Returns true if self has been created
    PTR :: self
    BIN :: res
    res = associated(self)
  end

  destroyed result(res)
  ! Returns true if self has *not* been created
    PTR :: self
    BIN :: res
    res = NOT associated(self)
  end

  nullify_ptr_part
  ! Nullify the pointer parts of self
    .a.nullify_ptr_part
    .b.nullify_ptr_part
    .c.nullify_ptr_part
    .d.nullify_ptr_part
  end

  destroy_ptr_part
  ! Destroy the pointer parts of self
    .a.destroy_ptr_part
    .b.destroy_ptr_part
    .c.destroy_ptr_part
    .d.destroy_ptr_part
  end

  put(out)
  ! Put the shell4 information to file "out"
    OUTPUT :: out
    out.put("Shell a:",flush=1)
    .a.put(out)
    out.put("Shell b:",flush=1)
    .b.put(out)
    out.put("Shell c:",flush=1)
    .c.put(out)
    out.put("Shell d:",flush=1)
    .d.put(out)
    out.flush
  end

  copy(shell_a,shell_b,shell_c,shell_d) [leaky]
  ! Copy the shell4 using from shell1 objects
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .a.copy(shell_a)
    .b.copy(shell_b)
    .c.copy(shell_c)
    .d.copy(shell_d)
  end

  copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) [leaky]
  ! Set the shell4 using shell objects and positions
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC, IN :: pos_a,pos_b,pos_c,pos_d
    .a.copy(shell_a,pos_a)
    .b.copy(shell_b,pos_b)
    .c.copy(shell_c,pos_c)
    .d.copy(shell_d,pos_d)
  end

  set(shell_a,shell_b,shell_c,shell_d)
  ! Set the shell4 using from shell1 objects
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .a.set(shell_a)
    .b.set(shell_b)
    .c.set(shell_c)
    .d.set(shell_d)
  end

  set(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  ! Set the shell4 using shell objects and positions
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC, IN :: pos_a,pos_b,pos_c,pos_d
    .a.set(shell_a,pos_a)
    .b.set(shell_b,pos_b)
    .c.set(shell_c,pos_c)
    .d.set(shell_d,pos_d)
  end

  unnormalize
  ! Unnormalize each shell in this shell quartet
    .a.unnormalize
    .b.unnormalize
    .c.unnormalize
    .d.unnormalize
  end

  ERI_block_size result(size)
     IVEC(4) :: size
     size(1) = .a%n_comp
     size(2) = .b%n_comp
     size(3) = .c%n_comp
     size(4) = .d%n_comp
  end

  skip_ERI result (res)
  ! Whether the ERI block will be less than a cutoff value.
    BIN :: res
    VEC(3) :: AB,CD
    DBL :: factor,r2ab,r2cd,ex_a,ex_b,ex_c,ex_d,k_ab,k_cd,cc_a,cc_b,cc_c
    INT :: a,b,c,d
    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    res = TRUE
    do a = 1, .a%n_cc
      ex_a = .a%ex(a)
      cc_a = .a%cc(a)
      do b = 1, .b%n_cc
        ex_b = .b%ex(b)
        cc_b = .b%cc(b) * cc_a
        k_ab = sign(ex_a * ex_b * r2ab / (ex_a + ex_b),-1.0d0)
        do c = 1, .c%n_cc
          ex_c = .c%ex(c)
          cc_c = .c%cc(c) * cc_b
          do d = 1, .d%n_cc
            ex_d = .d%ex(d)
            k_cd = sign(ex_c * ex_d * r2cd / (ex_c + ex_d),-1.0d0)
            factor = abs(exp(k_ab + k_cd) * cc_c * .d%cc(d))
            if (factor > SHELL4_ERI_CUTOFF) then
              res = FALSE
              return
            end
          end
        end
      end
    end
  end

!  **********************
!  CADPAC-style integrals
!  **********************

   make_ERI_ints(I)
   ! Make the ERI integral matrix, using Gauss-Hermite quadrature, like in CADPAC
   ! This is not expected to be as efficient as Daniel's code, below! But probably
   ! much easier to understand.
      MAT4 :: I
      MAT4, PTR :: II
      GAUSSIAN4 :: G
      INT :: a,b,c,d
      I = ZERO
      II.create(.a%n_comp,.b%n_comp,.c%n_comp,.d%n_comp)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_ERI_ints(II)
         I = I + II*.a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
      end
      end
      end
      end
      II.destroy
      .to_normalize(I)
   end

   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
   ! Make the spin same orbit integrals, "Sx", ... , and the
   ! spin other orbit integrals "Ox", ... , using 
   ! Gauss-Hermite quadrature. Probably not the best implementation.
      MAT4 :: Sx,Sy,Sz,Ox,Oy,Oz
      MAT4, PTR :: SSx,SSy,SSz,OOx,OOy,OOz
      GAUSSIAN4 :: G
      INT :: a,b,c,d,na,nb,nc,nd
      DBL :: cc
      Sx = ZERO; Sy = ZERO; Sz = ZERO
      Ox = ZERO; Oy = ZERO; Oz = ZERO
      na = .a%n_comp; nb = .b%n_comp; nc =.c%n_comp; nd =.d%n_comp
      SSx.create(na,nb,nc,nd); SSy.create(na,nb,nc,nd); SSz.create(na,nb,nc,nd)
      OOx.create(na,nb,nc,nd); OOy.create(na,nb,nc,nd); OOz.create(na,nb,nc,nd)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_spin_orbit_ints(SSx,SSy,SSz,OOx,OOy,OOz)
         cc = .a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
         Sx = Sx + SSx*cc; Sy = Sy + SSy*cc; Sz = Sz + SSz*cc
         Ox = Ox + OOx*cc; Oy = Oy + OOy*cc; Oz = Oz + OOz*cc
      end 
      end
      end
      end
      OOz.destroy; OOy.destroy; OOx.destroy
      SSz.destroy; SSy.destroy; SSx.destroy
      .to_normalize(Sx); .to_normalize(Sy); .to_normalize(Sz)
      .to_normalize(Ox); .to_normalize(Oy); .to_normalize(Oz)
   end

   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
   ! Make the spin spin magnetic dipole integrals, "Dij"
   ! using Gauss-Hermite quadrature. For sure, not the 
   ! best implementation, but where else will you get em', eh?
      MAT4 :: Dxx,Dyy,Dzz,Dxy,Dxz,Dyz
      MAT4, PTR :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
      GAUSSIAN4 :: G
      INT :: a,b,c,d,na,nb,nc,nd
      DBL :: cc
      Dxx = ZERO; Dyy = ZERO; Dzz = ZERO
      Dxy = ZERO; Dxz = ZERO; Dyz = ZERO
      na = .a%n_comp; nb = .b%n_comp; nc =.c%n_comp; nd =.d%n_comp
      Mxx.create(na,nb,nc,nd); Myy.create(na,nb,nc,nd); Mzz.create(na,nb,nc,nd)
      Mxy.create(na,nb,nc,nd); Mxz.create(na,nb,nc,nd); Myz.create(na,nb,nc,nd)
      G%l_a   = .a%l;   G%l_b   = .b%l;   G%l_c   = .c%l;   G%l_d   = .d%l
      G%pos_a = .a%pos; G%pos_b = .b%pos; G%pos_c = .c%pos; G%pos_d = .d%pos
      do a = 1,.a%n_cc
      do b = 1,.b%n_cc
      do c = 1,.c%n_cc
      do d = 1,.d%n_cc
         G%ex_a = .a%ex(a)
         G%ex_b = .b%ex(b)
         G%ex_c = .c%ex(c)
         G%ex_d = .d%ex(d)
         G.make_spin_spin_dipole_ints(Mxx,Myy,Mzz,Mxy,Mxz,Myz)
         cc = .a%cc(a)*.b%cc(b)*.c%cc(c)*.d%cc(d)
         Dxx = Dxx + Mxx*cc; Dyy = Dyy + Myy*cc; Dzz = Dzz + Mzz*cc
         Dxy = Dxy + Mxy*cc; Dxz = Dxz + Mxz*cc; Dyz = Dyz + Myz*cc
      end 
      end
      end
      end
      Myz.destroy; Mxz.destroy; Mxy.destroy
      Mzz.destroy; Myy.destroy; Mxx.destroy
      .to_normalize(Dxx); .to_normalize(Dyy); .to_normalize(Dzz)
      .to_normalize(Dxy); .to_normalize(Dxz); .to_normalize(Dyz)
   end

!  ****************************
!  Roland Lindh-style integrals
!  ****************************

  get_eri(abcd)
  ! The main routine to produce the block (ab|cd)
  ! (uses the transfer equation to make (ab|cd) from (es|fs))
    IN :: self
    MAT4, INOUT :: abcd
    MAT3, PTR :: escd
    MAT, PTR :: esfs
    INT :: n_e,n_f,eub,fub

    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    eub = n_e.n_comp_sum - (max(.a%l,.b%l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c%l,.d%l)-1).n_comp_sum

    nullify(esfs)
    nullify(escd)
    esfs.create(eub,fub)
    if (n_e==0 AND n_f==0) then
      .make_esfs_00(esfs)
    else if (n_e==0 OR n_f==0) then
      .make_esfs_0(esfs)
    else
      .make_esfs(esfs)
    end
    escd.create(eub, .c%n_comp, .d%n_comp)
    .transfer(esfs,escd)
    .transfer(escd,abcd)
    escd.destroy
    esfs.destroy
    .to_normalize(abcd)
  end

  make_esfs(esfs)
  ! Creates the initial (es|fs) integrals, summed over the primitives
    IN :: self
    MAT, INOUT:: esfs
    MAT, PTR :: esfsadd
    MAT3, PTR :: Ix,Iy,Iz
    RYS, PTR :: rysa
    VEC(3) :: P,Q,PA,QC,QP,ara,crc,AB,CD,C_tmp,A_tmp
    DBL :: QP2,a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg,n_e,n_f,nroots,eub,fub
    DBL :: norma,normb,normc,norm
    IMAT, PTR :: e_powers,f_powers
    IVEC, PTR :: e_x,e_y,e_z,f_x,f_y,f_z

    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    eub = size(esfs,1)
    fub = size(esfs,2)

    nroots = (n_e+n_f+2)/2
    rysa.create(nroots)
    Ix.create(nroots,n_e+1,n_f+1)
    Iy.create(nroots,n_e+1,n_f+1)
    Iz.create(nroots,n_e+1,n_f+1)
    esfsadd.create(eub,fub)

    e_powers.create(3,eub)
    e_powers.make_cartesian_components(max(.a%l,.b%l), n_e)
    e_powers = e_powers+1
    e_x => e_powers(1,:); e_y => e_powers(2,:); e_z => e_powers(3,:)
    f_powers.create(3,fub)
    f_powers.make_cartesian_components(max(.c%l,.d%l), n_f)
    f_powers = f_powers+1
    f_x => f_powers(1,:); f_y => f_powers(2,:); f_z => f_powers(3,:)

    esfs=ZERO
    AB = .a%pos - .b%pos
    CD = .c%pos - .d%pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    if (.a%l > .b%l) then
      A_tmp = .a%pos
    else
      A_tmp = .b%pos
    end
    if (.c%l > .d%l) then
      C_tmp = .c%pos
    else
      C_tmp = .d%pos
    end

    do ag = 1, .a%n_cc
      a     = .a%ex(ag) 
      norma = .a%cc(ag)
      ara   = a* .a%pos
      do bg = 1, .b%n_cc
        b     = .b%ex(bg)
        zeta  = a + b
        zinv  = ONE / zeta
        kab   = TWOPI5ON2 * (zinv**1.5) * exp(-a * b * r2ab * zinv)
        normb = norma * .b%cc(bg) * kab
        P     = (ara + b* .b%pos) * zinv
        PA    = P - A_tmp
        do cg = 1, .c%n_cc
          normc = normb * .c%cc(cg)
          c     = .c%ex(cg)
          crc   = c* .c%pos
          do dg = 1, .d%n_cc
            d    = .d%ex(dg)
            eta  = c + d
            einv = ONE / eta
            kcd  = exp(-c * d * r2cd * einv)
            Q    = (crc + d * .d%pos) * einv
            QC   = Q - C_tmp
            QP   = Q - P
            QP2  = dot_product(QP,QP)
            rho  = zeta * eta / (zeta + eta)
            xx   = rho * QP2
            rysa.get_weights(xx)
            .form_2d_ints(Ix,Iy,Iz,rysa%r,rho,zinv,einv,PA,QC,QP)
            .form_esfs(Ix,Iy,Iz,rysa%w,esfsadd,e_x,e_y,e_z,f_x,f_y,f_z,eub,fub)
            norm=normc* .d%cc(dg)*sqrt(rho*einv)*einv*kcd ! einv**1.5 simplified
            esfs=esfs+norm*esfsadd
          end
        end
      end
    end
    e_powers.destroy
    f_powers.destroy
    Ix.destroy
    Iy.destroy
    Iz.destroy
    esfsadd.destroy
    rysa.destroy
  end

  form_2d_ints(Ix,Iy,Iz,t2,rho,zinv,einv,PA,QC,QP) [pure]
  ! Forms the two dimentional integrals
    IN :: self
    MAT3, OUT :: Ix,Iy,Iz
    VEC, IN :: t2
    DBL, IN :: rho,zinv,einv
    VEC(3), IN :: PA,QC,QP
    VEC(size(t2)) :: ret,rzt,ce,cf,bb,ce1,cf1
    INT :: e,f,e1,f1,fp1,ep1,n_e,n_f
    n_e = .a%l + .b%l
    n_f = .c%l + .d%l
    Ix(:,1,1) = ONE
    Iy(:,1,1) = ONE
    Iz(:,1,1) = ONE
    if (n_e/=0 OR n_f/=0) then
      if (n_f>0) then
        ret = rho*t2*einv
        Ix(:,1,2) = QC(1) - ret(:) * QP(1)
        Iy(:,1,2) = QC(2) - ret(:) * QP(2)
        Iz(:,1,2) = QC(3) - ret(:) * QP(3)
        if (n_f>1) then
          cf = (ONE - ret) * HALF * einv
          do f = 2,n_f
            f1  = f - 1
            fp1 = f + 1
            cf1 = f1 * cf
            Ix(:,1,fp1) = Ix(:,1,2) * Ix(:,1,f) + cf1 * Ix(:,1,f1)
            Iy(:,1,fp1) = Iy(:,1,2) * Iy(:,1,f) + cf1 * Iy(:,1,f1)
            Iz(:,1,fp1) = Iz(:,1,2) * Iz(:,1,f) + cf1 * Iz(:,1,f1)
          end
        end
      end
      if (n_e>0) then
        rzt = rho * t2 * zinv
        Ix(:,2,1) = PA(1) + rzt(:) * QP(1)
        Iy(:,2,1) = PA(2) + rzt(:) * QP(2)
        Iz(:,2,1) = PA(3) + rzt(:) * QP(3)
        if (n_e>1) then
          ce = (ONE - rzt) * HALF * zinv
          do e = 2, n_e
            e1  = e - 1
            ep1 = e + 1
            ce1 = e1 * ce
            Ix(:,ep1,1) = Ix(:,2,1) * Ix(:,e,1) + ce1 * Ix(:,e1,1)
            Iy(:,ep1,1) = Iy(:,2,1) * Iy(:,e,1) + ce1 * Iy(:,e1,1)
            Iz(:,ep1,1) = Iz(:,2,1) * Iz(:,e,1) + ce1 * Iz(:,e1,1)
          end
        end
      end
      if (n_f>0 AND n_e>0) then
        bb = HALF*einv*rzt
        Ix(:,2,2)=Ix(:,1,2)*Ix(:,2,1)+bb
        Iy(:,2,2)=Iy(:,1,2)*Iy(:,2,1)+bb
        Iz(:,2,2)=Iz(:,1,2)*Iz(:,2,1)+bb
        if (n_f>1) then
          do f=2,n_f
            f1  = f - 1
            fp1 = f + 1
            cf1 = f1 * cf
            Ix(:,2,fp1) = Ix(:,1,2) * Ix(:,2,f) + cf1 * Ix(:,2,f1) + bb *Ix(:,1,f)
            Iy(:,2,fp1) = Iy(:,1,2) * Iy(:,2,f) + cf1 * Iy(:,2,f1) + bb *Iy(:,1,f)
            Iz(:,2,fp1) = Iz(:,1,2) * Iz(:,2,f) + cf1 * Iz(:,2,f1) + bb *Iz(:,1,f)
          end
        end
        if (n_e>1) then
          do e = 2, n_e
            e1  =e - 1
            ep1 =e + 1
            ce1 =e1 * ce
            do f=2, n_f + 1
              f1 = f - 1
              Ix(:,ep1,f) = Ix(:,2,1)*Ix(:,e,f)+ce1*Ix(:,e1,f)+f1*bb(:)*Ix(:,e,f1)
              Iy(:,ep1,f) = Iy(:,2,1)*Iy(:,e,f)+ce1*Iy(:,e1,f)+f1*bb(:)*Iy(:,e,f1)
              Iz(:,ep1,f) = Iz(:,2,1)*Iz(:,e,f)+ce1*Iz(:,e1,f)+f1*bb(:)*Iz(:,e,f1)
            end
          end
        end
      end
    end
  end

  form_esfs(Ix,Iy,Iz,W,esfsadd,e_x,e_y,e_z,f_x,f_y,f_z,eub,fub) [pure]
  ! Forms (es|fs) from the two dimensional integrals for a single
  ! set of primitives
    IN :: self
    MAT3, IN :: Ix,Iy,Iz
    VEC, IN :: W
    MAT, OUT :: esfsadd
    IVEC, IN :: e_x,e_y,e_z,f_x,f_y,f_z
    INT, IN :: eub,fub
    INT :: e,f

    do f=1,fub
      do e=1,eub
        esfsadd(e,f)=sum(Ix(:,e_x(e),f_x(f)) * &
                         Iy(:,e_y(e),f_y(f)) * &
                         Iz(:,e_z(e),f_z(f)) * W)
      end
    end
  end

  make_esfs_0(esfs)
  ! Creates the initial (es|fs) integrals, summed over the primitives, where
  ! e = 0 or f = 0.
    IN :: self
    MAT, INOUT:: esfs
    VEC, PTR :: esfsadd
    MAT, PTR :: Ix,Iy,Iz
    RYS, PTR :: rysa
    VEC(3) :: P,Q,PA,QC,QP,ara,crc,AB,CD,A_tmp,C_tmp
    DBL :: QP2,a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg,n_e,n_f,nroots
    DBL :: norma,normb,normc,norm
    IMAT, PTR :: powers
    IVEC, PTR :: x,y,z

    n_e = .a%l + .b%l
    n_f = .c%l + .d%l

    if (n_e==0) then
      nroots = (n_f+2)/2
      rysa.create(nroots)
      Ix.create(nroots,n_f+1)
      Iy.create(nroots,n_f+1)
      Iz.create(nroots,n_f+1)
      esfsadd.create(size(esfs,2))

      powers.create(3, size(esfs,2))
      powers.make_cartesian_components(max(.c%l,.d%l), n_f)
      powers = powers+1
      x => powers(1,:)
      y => powers(2,:)
      z => powers(3,:)

      esfs=ZERO
      AB = .a%pos - .b%pos
      CD = .c%pos - .d%pos
      r2ab=dot_product(AB,AB)
      r2cd=dot_product(CD,CD)
      if (.c%l > .d%l) then
        C_tmp = .c%pos
      else
        C_tmp = .d%pos
      end

      do ag = 1, .a%n_cc
        a     = .a%ex(ag) 
        norma = .a%cc(ag)
        ara   = a * .a%pos
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          zeta  = a + b
          zinv  = ONE / zeta
          kab   = TWOPI5ON2 * (zinv**1.5) * exp(-a * b * r2ab * zinv)
          normb = norma * .b%cc(bg) * kab
          P     = (ara + b * .b%pos) * zinv
          do cg = 1, .c%n_cc
            normc = normb * .c%cc(cg)
            c     = .c%ex(cg)
            crc   = c * .c%pos
            do dg = 1, .d%n_cc
              d    = .d%ex(dg)
              eta  = c + d
              einv = ONE / eta
              kcd  = exp(-c * d * r2cd * einv)
              Q    = (crc + d * .d%pos) * einv
              QC   = Q - C_tmp
              QP   = Q - P
              QP2  = dot_product(QP,QP)
              rho  = zeta * eta / (zeta + eta)
              norm = normc * .d%cc(dg) * sqrt(rho) * kcd * (einv**1.5)
              xx   = rho * QP2
              rysa.get_weights(xx)
              .form_2d_ints_0(Ix,Iy,Iz,rysa%r,rho,einv,QC,QP,n_f)
              .form_esfs_0(Ix,Iy,Iz,rysa%w,esfsadd,x,y,z)
              esfs(1,:) = esfs(1,:) + norm * esfsadd
            end
          end
        end
      end
      powers.destroy
      esfsadd.destroy
      Iz.destroy
      Iy.destroy
      Ix.destroy
      rysa.destroy
    else
      nroots = (n_e + 2) / 2
      rysa.create(nroots)
      Ix.create(nroots,n_e+1)
      Iy.create(nroots,n_e+1)
      Iz.create(nroots,n_e+1)
      esfsadd.create(size(esfs,1))

      powers.create(3, size(esfs,1))
      powers.make_cartesian_components(max(.a%l,.b%l), n_e)
      powers = powers+1
      x => powers(1,:)
      y => powers(2,:)
      z => powers(3,:)

      esfs = ZERO
      AB   = .a%pos - .b%pos
      CD   = .c%pos - .d%pos
      r2ab = dot_product(AB,AB)
      r2cd = dot_product(CD,CD)
      if (.a%l > .b%l) then
        A_tmp = .a%pos
      else
        A_tmp = .b%pos
      end

      do ag = 1, .a%n_cc
        a     = .a%ex(ag)
        norma = .a%cc(ag)
        ara   = a * .a%pos
        do bg = 1, .b%n_cc
          b     = .b%ex(bg)
          zeta  = a + b
          zinv  = ONE / zeta
          kab   = TWOPI5ON2 * (zinv**1.5) * exp(-a * b * r2ab * zinv)
          normb = norma * .b%cc(bg) * kab
          P     = (ara + b * .b%pos) * zinv
          PA    = P - A_tmp
          do cg = 1, .c%n_cc
            normc = normb * .c%cc(cg)
            c     = .c%ex(cg)
            crc   = c * .c%pos
            do dg = 1, .d%n_cc
              d    = .d%ex(dg)
              eta  = c + d
              einv = ONE / eta
              kcd  = exp(-c * d * r2cd * einv)
              Q    = (crc + d * .d%pos) * einv
              QP   = Q - P
              QP2  = dot_product(QP,QP)
              rho  = zeta * eta / (zeta + eta)
              norm = normc * .d%cc(dg) * sqrt(rho) * kcd * (einv**1.5)
              xx   = rho*QP2
              rysa.get_weights(xx)
              .form_2d_ints_0(Ix,Iy,Iz,rysa%r,rho,zinv,PA,-QP,n_e)
              .form_esfs_0(Ix,Iy,Iz,rysa%w,esfsadd,x,y,z)
              esfs(:,1) = esfs(:,1) + norm * esfsadd
            end
          end
        end
      end
      powers.destroy
      esfsadd.destroy
      Iz.destroy
      Iy.destroy
      Ix.destroy
      rysa.destroy
    end
  end

  form_2d_ints_0(Ix,Iy,Iz,t2,rho,einv,QC,QP,n_f) [pure]
  ! Forms the two dimentional integrals, where e = 0 or f = 0.
    IN :: self
    MAT, OUT :: Ix,Iy,Iz
    VEC, IN :: t2
    DBL, IN :: rho,einv
    INT, IN :: n_f
    VEC(3), IN :: QC,QP
    VEC(size(t2)) :: ret,c,cf1
    INT :: f,f1,fp1
    Ix(:,1) = ONE
    Iy(:,1) = ONE
    Iz(:,1) = ONE
    if (n_f/=0) then
      ret     = rho * t2 * einv
      Ix(:,2) = QC(1) - ret(:) * QP(1)
      Iy(:,2) = QC(2) - ret(:) * QP(2)
      Iz(:,2) = QC(3) - ret(:) * QP(3)
      if (n_f>1) then
        c = (ONE - ret) * HALF * einv
        do f = 2, n_f
          f1  = f - 1
          fp1 = f + 1
          cf1 = f1 * c
          Ix(:,fp1) = Ix(:,2) * Ix(:,f) + cf1 * Ix(:,f1)
          Iy(:,fp1) = Iy(:,2) * Iy(:,f) + cf1 * Iy(:,f1)
          Iz(:,fp1) = Iz(:,2) * Iz(:,f) + cf1 * Iz(:,f1)
        end
      end
    end
  end

  form_esfs_0(Ix,Iy,Iz,W,esfsadd,f_x,f_y,f_z) [pure]
  ! Forms (es|fs) from the two dimensional integrals for a single
  ! set of primitives, where e = 0 or f = 0.
    IN :: self
    MAT, IN :: Ix,Iy,Iz
    VEC, IN :: W
    VEC, OUT :: esfsadd
    IVEC, IN :: f_x,f_y,f_z
    INT :: f,fub

    fub=size(f_x)
    do f=1,fub
      esfsadd(f)=sum(Ix(:,f_x(f)) * Iy(:,f_y(f)) * Iz(:,f_z(f)) * W)
    end
  end

  make_esfs_00(esfs)
  ! Creates the initial (es|fs) integrals, summed over the primitives, where
  ! e = f = 0.
    IN :: self
    MAT, INOUT:: esfs
    RYS, PTR :: rysa
    VEC(3) :: P,Q,QP,ara,crc,AB,CD
    DBL :: QP2,a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    INT :: ag,bg,cg,dg
    DBL :: norma,normb,normc,norm
    DBL :: esfsadd

    rysa.create(1)

    esfsadd = ZERO
    AB   = .a%pos - .b%pos
    CD   = .c%pos - .d%pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)

    do ag = 1, .a%n_cc
      a     = .a%ex(ag) 
      norma = .a%cc(ag)
      ara   = a * .a%pos
      do bg = 1, .b%n_cc
        b     = .b%ex(bg)
        zeta  = a + b
        zinv  = ONE / zeta
        kab   = TWOPI5ON2 * (zinv**1.5) * exp(-a * b * r2ab * zinv)
        normb = norma * .b%cc(bg) * kab
        P     = (ara + b * .b%pos) * zinv
        do cg = 1, .c%n_cc
          normc = normb * .c%cc(cg)
          c     = .c%ex(cg)
          crc   = c * .c%pos
          do dg = 1, .d%n_cc
            d    = .d%ex(dg)
            eta  = c + d
            einv = ONE / eta
            kcd  = exp(-c * d * r2cd * einv)
            Q    = (crc + d * .d%pos) * einv
            QP   = Q - P
            QP2  = dot_product(QP,QP)
            rho  = zeta * eta / (zeta + eta)
!            norm = normc * .d%cc(dg) * sqrt(rho) * kcd * (einv**1.5)
            norm = normc * .d%cc(dg) * sqrt(rho*einv) * kcd * einv
            xx   = rho*QP2
            rysa.get_weights(xx)
            esfsadd = esfsadd + norm * sum(rysa%w)
          end
        end
      end
    end
    rysa.destroy
    esfs=esfsadd
  end

  transfer(esfs,escd) [pure]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    if (.c%l > .d%l) then
      .transfer_l_c_highest(esfs,escd)
    else
      .transfer_l_d_highest(esfs,escd)
    end
  end

  transfer(escd,abcd) [pure]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    if (.a%l > .b%l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

  transfer_l_c_highest(esfs,escd) [pure]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3, PTR :: int_new,int_old
    IMAT, allocatable :: momenta
    IMAT3, allocatable :: index
    IVEC(3) :: d_momenta,c_momenta
    VEC(3) :: CD
    INT :: c,d,ld,ld1_n_comp_sum,ld2_n_comp_sum,c1,d1,cub,dub
    INT :: z,n_f,fadd,e,eub
    DBL :: CDi

    select case (.d%l)
      case (0)
        escd(:,:,1)=esfs

      case (1)
        fadd = (.c%l-1).n_comp_sum
        eub  = size(esfs,1)
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        cub  = (n_f-1).n_comp_sum - fadd

        allocate(momenta(3, n_f.n_comp_sum))
        momenta.make_cartesian_components(0,n_f)
        allocate(index(0:n_f,0:n_f,0:n_f))
        index.make_index_of_components(momenta)

        do d = 1, 3
          z   = momenta(:,d+1).first_nonzero_component
          CDi = CD(z)
          do c = 1, cub
            c_momenta    = momenta(:,c+fadd)
            c_momenta(z) = c_momenta(z) + 1
            c1 = index(c_momenta(1),c_momenta(2),c_momenta(3)) - fadd
            do e = 1, eub
              escd(e,c,d) = esfs(e,c1) + CDi * esfs(e,c)
            end
          end
        end
        deallocate(momenta)
        deallocate(index)

      case default
        fadd = (.c%l-1).n_comp_sum
        eub  = size(esfs,1)
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        cub  = (n_f-1).n_comp_sum - fadd

        allocate(momenta(3, n_f.n_comp_sum))
        momenta.make_cartesian_components(0,n_f)
        allocate(index(0:n_f,0:n_f,0:n_f))
        index.make_index_of_components(momenta)

        nullify(int_new)
        allocate(int_new(eub,cub,3))
        do d=1,3
          z=momenta(:,d+1).first_nonzero_component
          CDi=CD(z)
          do c=1,cub
            c_momenta=momenta(:,c+fadd)
            c_momenta(z)=c_momenta(z)+1
            c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-fadd
            do e=1,eub
              int_new(e,c,d)=esfs(e,c1)+CDi*esfs(e,c)
            end
          end
        end
        do ld=2, .d%l - 1
          ld1_n_comp_sum = (ld-1).n_comp_sum
          ld2_n_comp_sum = (ld-2).n_comp_sum
          dub            = ld.n_comp
          cub            = (n_f-ld).n_comp_sum - fadd
          int_old=>int_new
          nullify(int_new)
          allocate(int_new(eub,cub,dub))
          do d=1,dub
            d_momenta=momenta(:,d+ld1_n_comp_sum)
            z=d_momenta.first_nonzero_component
            d_momenta(z)=d_momenta(z)-1
            d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-ld2_n_comp_sum
            CDi=CD(z)
            do c=1,cub
              c_momenta=momenta(:,c+fadd)
              c_momenta(z)=c_momenta(z)+1
              c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-fadd
              do e=1,eub
                int_new(e,c,d)=int_old(e,c1,d1)+CDi*int_old(e,c,d1)
              end
            end
          end
          deallocate(int_old)
        end

        ld1_n_comp_sum = (.d%l-1).n_comp_sum
        ld2_n_comp_sum = (.d%l-2).n_comp_sum
        dub            = .d%n_comp
        cub            = .c%n_comp
        int_old=>int_new
        do d=1,dub
          d_momenta=momenta(:,d+ld1_n_comp_sum)
          z=d_momenta.first_nonzero_component
          d_momenta(z)=d_momenta(z)-1
          d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-ld2_n_comp_sum
          CDi=CD(z)
          do c=1,cub
            c_momenta=momenta(:,c+fadd)
            c_momenta(z)=c_momenta(z)+1
            c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-fadd
            do e=1,eub
              escd(e,c,d)=int_old(e,c1,d1)+CDi*int_old(e,c,d1)
            end
          end
        end
        deallocate(int_old)
        deallocate(momenta)
        deallocate(index)
    end
  end

  transfer_l_d_highest(esfs,escd) [pure]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3, PTR :: int_new,int_old
    IMAT, allocatable :: momenta
    IMAT3, allocatable :: index
    IVEC(3) :: d_momenta,c_momenta
    VEC(3) :: CD
    INT :: c,d,lc,lc1_n_comp_sum,lc2_n_comp_sum,c1,d1,cub,dub
    INT :: z,n_f,fadd,e,eub
    DBL :: DCi

    select case (.c%l)
      case (0)
        escd(:,1,:)=esfs

      case (1)
        fadd = (.d%l-1).n_comp_sum
        eub  = size(esfs,1)
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        dub  = (n_f-1).n_comp_sum - fadd

        allocate(momenta(3, n_f.n_comp_sum))
        momenta.make_cartesian_components(0,n_f)
        allocate(index(0:n_f,0:n_f,0:n_f))
        index.make_index_of_components(momenta)

        do c=1,3
          z=momenta(:,c+1).first_nonzero_component
          DCi=-CD(z)
          do d=1,dub
            d_momenta=momenta(:,d+fadd)
            d_momenta(z)=d_momenta(z)+1
            d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-fadd
            do e=1,eub
              escd(e,c,d)=esfs(e,d1)+DCi*esfs(e,d)
            end
          end
        end
        deallocate(momenta)
        deallocate(index)

      case default
        fadd = (.d%l-1).n_comp_sum
        eub  = size(esfs,1)
        CD   = .c%pos - .d%pos
        n_f  = .c%l + .d%l
        dub  = (n_f-1).n_comp_sum - fadd

        allocate(momenta(3, n_f.n_comp_sum))
        momenta.make_cartesian_components(0,n_f)
        allocate(index(0:n_f,0:n_f,0:n_f))
        index.make_index_of_components(momenta)

        nullify(int_new)
        allocate(int_new(eub,3,dub))
        do c=1,3
          z=momenta(:,c+1).first_nonzero_component
          DCi=-CD(z)
          do d=1,dub
            d_momenta=momenta(:,d+fadd)
            d_momenta(z)=d_momenta(z)+1
            d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-fadd
            do e=1,eub
              int_new(e,c,d)=esfs(e,d1)+DCi*esfs(e,d)
            end
          end
        end
        do lc=2, .c%l - 1
          lc1_n_comp_sum = (lc-1).n_comp_sum
          lc2_n_comp_sum = (lc-2).n_comp_sum
          cub            = lc.n_comp
          dub            = (n_f-lc).n_comp_sum - fadd
          int_old=>int_new
          nullify(int_new)
          allocate(int_new(eub,cub,dub))
          do c=1,cub
            c_momenta=momenta(:,c+lc1_n_comp_sum)
            z=c_momenta.first_nonzero_component
            c_momenta(z)=c_momenta(z)-1
            c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-lc2_n_comp_sum
            DCi=-CD(z)
            do d=1,dub
              d_momenta=momenta(:,d+fadd)
              d_momenta(z)=d_momenta(z)+1
              d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-fadd
              do e=1,eub
                int_new(e,c,d)=int_old(e,c1,d1)+DCi*int_old(e,c1,d)
              end
            end
          end
          deallocate(int_old)
        end
        lc1_n_comp_sum = (.c%l-1).n_comp_sum
        lc2_n_comp_sum = (.c%l-2).n_comp_sum
        cub            = .c%n_comp
        dub            = .d%n_comp
        int_old=>int_new
        do c=1,cub
          c_momenta=momenta(:,c+lc1_n_comp_sum)
          z=c_momenta.first_nonzero_component
          c_momenta(z)=c_momenta(z)-1
          c1=index(c_momenta(1),c_momenta(2),c_momenta(3))-lc2_n_comp_sum
          DCi=-CD(z)
          do d=1,dub
            d_momenta=momenta(:,d+fadd)
            d_momenta(z)=d_momenta(z)+1
            d1=index(d_momenta(1),d_momenta(2),d_momenta(3))-fadd
            do e=1,eub
              escd(e,c,d)=int_old(e,c1,d1)+DCi*int_old(e,c1,d)
            end
          end
        end
        deallocate(int_old)
        deallocate(momenta)
        deallocate(index)
    end
  end

  transfer_l_a_highest(escd,abcd) [pure]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4, PTR :: int_new,int_old
    IMAT, allocatable :: momenta
    IMAT3, allocatable :: index
    IVEC(3) :: a_momenta,b_momenta
    VEC(3) :: AB
    INT :: a1,b1,lb1_n_comp_sum,lb2_n_comp_sum,a,b,c,d,lb,aub,bub
    INT :: z,n_e,eadd,cub,dub
    DBL :: ABi

    select case (.b%l)
      case (0)
        abcd(:,1,:,:)=escd

      case (1)
        eadd = (.a%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        aub  = (n_e-1).n_comp_sum - eadd
        cub  = .c%n_comp
        dub  = .d%n_comp

        allocate(momenta(3, n_e.n_comp_sum))
        momenta.make_cartesian_components(0,n_e)
        allocate(index(0:n_e,0:n_e,0:n_e))
        index.make_index_of_components(momenta)

        do b=1,3
          z=momenta(:,b+1).first_nonzero_component
          ABi=AB(z)
          do a=1,aub
            a_momenta=momenta(:,a+eadd)
            a_momenta(z)=a_momenta(z)+1
            a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=escd(a1,c,d) + ABi * escd(a,c,d)
            end
          end
        end
        deallocate(momenta)
        deallocate(index)

      case default
        eadd = (.a%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        aub  = (n_e-1).n_comp_sum - eadd
        bub  = .b%n_comp
        cub  = .c%n_comp
        dub  = .d%n_comp

        allocate(momenta(3, n_e.n_comp_sum))
        momenta.make_cartesian_components(0,n_e)
        allocate(index(0:n_e,0:n_e,0:n_e))
        index.make_index_of_components(momenta)

        nullify(int_new)
        allocate(int_new(aub,bub,cub,dub))
        do b=1,3
          z=momenta(:,b+1).first_nonzero_component
          ABi=AB(z)
          do a=1,aub
            a_momenta=momenta(:,a+eadd)
            a_momenta(z)=a_momenta(z)+1
            a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              int_new(a,b,c,d)=escd(a1,c,d) + ABi * escd(a,c,d)
            end
          end
        end

        do lb=2, .b%l - 1
          lb1_n_comp_sum = (lb-1).n_comp_sum
          lb2_n_comp_sum = (lb-2).n_comp_sum
          bub            = lb.n_comp
          aub            = (n_e-lb).n_comp_sum - eadd
          int_old=>int_new
          nullify(int_new)
          allocate(int_new(aub,bub,cub,dub))
          do b=1,bub
            b_momenta=momenta(:,b+lb1_n_comp_sum)
            z=b_momenta.first_nonzero_component
            b_momenta(z)=b_momenta(z)-1
            b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-lb2_n_comp_sum
            ABi=AB(z)
            do a=1,aub
              a_momenta=momenta(:,a+eadd)
              a_momenta(z)=a_momenta(z)+1
              a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-eadd
              forall (c=1:cub, d=1:dub)
                int_new(a,b,c,d)=int_old(a1,b1,c,d) + ABi * int_old(a,b1,c,d)
              end
            end
          end
          deallocate(int_old)
        end
        lb1_n_comp_sum = (.b%l-1).n_comp_sum
        lb2_n_comp_sum = (.b%l-2).n_comp_sum
        bub            = .b%n_comp
        aub            = .a%n_comp
        int_old=>int_new
        do b=1,bub
          b_momenta=momenta(:,b+lb1_n_comp_sum)
          z=b_momenta.first_nonzero_component
          b_momenta(z)=b_momenta(z)-1
          b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-lb2_n_comp_sum
          ABi=AB(z)
          do a=1,aub
            a_momenta=momenta(:,a+eadd)
            a_momenta(z)=a_momenta(z)+1
            a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=int_old(a1,b1,c,d) + ABi * int_old(a,b1,c,d)
            end
          end
        end
        deallocate(int_old)
        deallocate(momenta)
        deallocate(index)
    end
  end

  transfer_l_b_highest(escd,abcd) [pure]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4, PTR :: int_new,int_old
    IMAT, allocatable :: momenta
    IMAT3, allocatable :: index
    IVEC(3) :: a_momenta,b_momenta
    VEC(3) :: AB
    INT :: a1,b1,la1_n_comp_sum,la2_n_comp_sum,a,b,c,d,la,aub,bub
    INT :: z,n_e,eadd,cub,dub
    DBL :: BAi

    select case (.a%l)
      case (0)
        abcd(1,:,:,:)=escd

      case (1)
        eadd = (.b%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        bub  = (n_e-1).n_comp_sum - eadd
        cub  = .c%n_comp
        dub  = .d%n_comp

        allocate(momenta(3, n_e.n_comp_sum))
        momenta.make_cartesian_components(0,n_e)
        allocate(index(0:n_e,0:n_e,0:n_e))
        index.make_index_of_components(momenta)

        do a=1,3
          z=momenta(:,a+1).first_nonzero_component
          BAi=-AB(z)
          do b=1,bub
            b_momenta=momenta(:,b+eadd)
            b_momenta(z)=b_momenta(z)+1
            b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=escd(b1,c,d) + BAi * escd(b,c,d)
            end
          end
        end
        deallocate(momenta)
        deallocate(index)

      case default
        eadd = (.b%l-1).n_comp_sum
        AB   = .a%pos - .b%pos
        n_e  = .a%l + .b%l
        bub  = (n_e-1).n_comp_sum - eadd
        aub  = .a%n_comp
        cub  = .c%n_comp
        dub  = .d%n_comp

        allocate(momenta(3, n_e.n_comp_sum))
        momenta.make_cartesian_components(0,n_e)
        allocate(index(0:n_e,0:n_e,0:n_e))
        index.make_index_of_components(momenta)

        nullify(int_new)
        allocate(int_new(aub,bub,cub,dub))
        do a=1,3
          z=momenta(:,a+1).first_nonzero_component
          BAi=-AB(z)
          do b=1,bub
            b_momenta=momenta(:,b+eadd)
            b_momenta(z)=b_momenta(z)+1
            b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              int_new(a,b,c,d)=escd(b1,c,d) + BAi * escd(b,c,d)
            end
          end
        end

        do la=2, .a%l - 1
          la1_n_comp_sum = (la-1).n_comp_sum
          la2_n_comp_sum = (la-2).n_comp_sum
          aub            = la.n_comp
          bub            = (n_e-la).n_comp_sum - eadd
          int_old=>int_new
          nullify(int_new)
          allocate(int_new(aub,bub,cub,dub))
          do a=1,aub
            a_momenta=momenta(:,a+la1_n_comp_sum)
            z=a_momenta.first_nonzero_component
            a_momenta(z)=a_momenta(z)-1
            a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-la2_n_comp_sum
            BAi=-AB(z)
            do b=1,bub
              b_momenta=momenta(:,b+eadd)
              b_momenta(z)=b_momenta(z)+1
              b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-eadd
              forall (c=1:cub, d=1:dub)
                int_new(a,b,c,d)=int_old(a1,b1,c,d) + BAi * int_old(a1,b,c,d)
              end
            end
          end
          deallocate(int_old)
        end
        la1_n_comp_sum = (.a%l-1).n_comp_sum
        la2_n_comp_sum = (.a%l-2).n_comp_sum
        aub            = .a%n_comp
        bub            = .b%n_comp
        int_old=>int_new
        do a=1,aub
          a_momenta=momenta(:,a+la1_n_comp_sum)
          z=a_momenta.first_nonzero_component
          a_momenta(z)=a_momenta(z)-1
          a1=index(a_momenta(1),a_momenta(2),a_momenta(3))-la2_n_comp_sum
          BAi=-AB(z)
          do b=1,bub
            b_momenta=momenta(:,b+eadd)
            b_momenta(z)=b_momenta(z)+1
            b1=index(b_momenta(1),b_momenta(2),b_momenta(3))-eadd
            forall (c=1:cub, d=1:dub)
              abcd(a,b,c,d)=int_old(a1,b1,c,d) + BAi * int_old(a1,b,c,d)
            end
          end
        end
        deallocate(int_old)
        deallocate(momenta)
        deallocate(index)
    end
  end

  to_normalize(abcd)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, b, c and d.
    IN :: self
    MAT4, target :: abcd
    VEC, PTR :: anorm,bnorm,cnorm,dnorm
    INT :: aub,bub,cub,dub,a,b,c,d
    DBL :: normb,normc,normd

    if (.a%l + .b%l == 0) then
      if (.c%l + .d%l /= 0) then       ! ss|cd only loop over c and d.
        cub = .c%n_comp
        dub = .d%n_comp
        cnorm.create(cub);   cnorm.normalizing_factors( .c%l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d%l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            abcd(1,1,c,d)=abcd(1,1,c,d)*normd*cnorm(c)
          end
        end
        cnorm.destroy; dnorm.destroy
      end
    else if (.c%l + .d%l == 0) then    ! ab|ss only loop over a and b.
      aub = .a%n_comp
      bub = .b%n_comp
      anorm.create(aub);   anorm.normalizing_factors( .a%l )
      bnorm.create(bub);   bnorm.normalizing_factors( .b%l )
      do b=1,bub
        normb=bnorm(b)
        do a=1,aub
          abcd(a,b,1,1)=abcd(a,b,1,1)*normb*anorm(a)
        end
      end
      anorm.destroy; bnorm.destroy
    else
      aub=.a%n_comp                !    The general normalization routine.
      bub=.b%n_comp
      cub=.c%n_comp
      dub=.d%n_comp
      anorm.create(aub);   anorm.normalizing_factors( .a%l )
      bnorm.create(bub);   bnorm.normalizing_factors( .b%l )
      cnorm.create(cub);   cnorm.normalizing_factors( .c%l )
      dnorm.create(dub);   dnorm.normalizing_factors( .d%l )
      do d=1,dub
        normd=dnorm(d)
        do c=1,cub
          normc=normd*cnorm(c)
          do b=1,bub
            normb=normc*bnorm(b)
            do a=1,aub
              abcd(a,b,c,d)=abcd(a,b,c,d)*normb*anorm(a)
            end
          end
        end
      end
      anorm.destroy; bnorm.destroy; cnorm.destroy; dnorm.destroy
    end
  end

end
