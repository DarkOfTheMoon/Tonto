!*******************************************************************************
!
! SHELL4 : Group of 4 contracted gaussian SHELL1's, used mainly for integrals
! (c) Daniel Grimwood, March 1998
!
! $Id$
!*******************************************************************************

module SHELL4

  use TYPES
  use SYSTEM
  use INT
  use IVEC
  use IMAT
  use IMAT3, ONLY:create_,destroy_
  use VEC
  use MAT, ONLY:create_,destroy_
  use MAT3, ONLY:create_,destroy_
  use MAT4, ONLY:create_,destroy_
  use TEXTFILE
  use RYS
  use GAUSSIAN4
  use SHELL1
  use SHELL2

  implicit none

#include "macros"
#include "shell4.int"

!   type shell4_type
!
!   SHELL1 :: a
!   ! Shell "a" of the quartet
!
!   SHELL1 :: b
!   ! Shell "b" of the quartet
!
!   SHELL1 :: c
!   ! Shell "c" of the quartet
!
!   SHELL1 :: d
!   ! Shell "d" of the quartet
!
!   end

contains

  create [leaky]
  ! Create a shell4 object, but no its component shells.
    PTR :: self
    nullify(self)
    allocate(self)
    ADD_MEM(SHELL4_SIZE)
    .nullify_ptr_part
  end

  create(shell_a,shell_b,shell_c,shell_d) [leaky]
  ! Create a shell4 object from copies of shell1s.
    PTR :: self
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .create
    .copy(shell_a,shell_b,shell_c,shell_d)
  end

  create(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) [leaky]
  ! Create a shell4 object from copies of shells and their positions.
    PTR :: self
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC(3), IN :: pos_a,pos_b,pos_c,pos_d
    .create
    .copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  end

  destroy [leaky]
  ! Destroy a shell4 object.
    PTR :: self
    if (associated(self)) then
      .destroy_ptr_part
      DELETE_MEM(SHELL4_SIZE)
      deallocate(self)
    end
  end

  created result(res)
  ! Returns true if self has been created
    PTR :: self
    BIN :: res
    res = associated(self)
  end

  destroyed result(res)
  ! Returns true if self has *not* been created
    PTR :: self
    BIN :: res
    res = NOT associated(self)
  end

  nullify_ptr_part
  ! Nullify the pointer parts of self
    .a.nullify_ptr_part
    .b.nullify_ptr_part
    .c.nullify_ptr_part
    .d.nullify_ptr_part
  end

  destroy_ptr_part [leaky]
  ! Destroy the pointer parts of self
    .a.destroy_ptr_part
    .b.destroy_ptr_part
    .c.destroy_ptr_part
    .d.destroy_ptr_part
  end

  destroy_ab [leaky]
  ! Destroy the shella and shellb pointer parts of self
    .a.destroy_ptr_part
    .b.destroy_ptr_part
  end

  destroy_cd [leaky]
  ! Destroy the shellc and shelld pointer parts of self
    .c.destroy_ptr_part
    .d.destroy_ptr_part
  end

  put(out)
  ! Put the shell4 information to file "out"
    TEXTFILE :: out
    out.put_text("Shell a:",flush=1)
    .a.put(out)
    out.put_text("Shell b:",flush=1)
    .b.put(out)
    out.put_text("Shell c:",flush=1)
    .c.put(out)
    out.put_text("Shell d:",flush=1)
    .d.put(out)
    out.flush
  end

  copy(shell_a,shell_b,shell_c,shell_d) [leaky]
  ! Copy the shell4 using from shell1 objects
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .a.copy(shell_a)
    .b.copy(shell_b)
    .c.copy(shell_c)
    .d.copy(shell_d)
  end

  copy(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d) [leaky]
  ! Set the shell4 using shell objects and positions
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC, IN :: pos_a,pos_b,pos_c,pos_d
    .a.copy(shell_a,pos_a)
    .b.copy(shell_b,pos_b)
    .c.copy(shell_c,pos_c)
    .d.copy(shell_d,pos_d)
  end

  set(shell_a,shell_b,shell_c,shell_d)
  ! Set the shell4 using from shell1 objects
    SHELL1, IN :: shell_a,shell_b,shell_c,shell_d
    .a.set(shell_a)
    .b.set(shell_b)
    .c.set(shell_c)
    .d.set(shell_d)
  end

  copy_ab(shell_a,shell_b,pos_a,pos_b) [leaky]
  ! Copy the a and b parts of the shell4 using from shell1 objects
    SHELL, IN :: shell_a,shell_b
    VEC, IN :: pos_a,pos_b
    .a.copy(shell_a,pos_a)
    .b.copy(shell_b,pos_b)
  end

  copy_cd(shell_c,shell_d,pos_c,pos_d) [leaky]
  ! Copy the c and d parts of the shell4 using from shell1 objects
    SHELL, IN :: shell_c,shell_d
    VEC, IN :: pos_c,pos_d
    .c.copy(shell_c,pos_c)
    .d.copy(shell_d,pos_d)
  end

  set(shell_a,shell_b,shell_c,shell_d,pos_a,pos_b,pos_c,pos_d)
  ! Set the shell4 using shell objects and positions
    SHELL, IN :: shell_a,shell_b,shell_c,shell_d
    VEC, IN :: pos_a,pos_b,pos_c,pos_d
    .a.set(shell_a,pos_a)
    .b.set(shell_b,pos_b)
    .c.set(shell_c,pos_c)
    .d.set(shell_d,pos_d)
  end

  unnormalize
  ! Unnormalize each shell in this shell quartet
    .a.unnormalize
    .b.unnormalize
    .c.unnormalize
    .d.unnormalize
  end

  max_k_ab result(res) [private]
  ! Returns the maximum value of .a.cc * .b.cc * k_ab over all contractions of a
  ! and b.  k_ab is kappa_ab, for the two electron integrals.
    DBL :: res
    VEC(3) :: AB
    DBL :: r2ab,ex_a,ex_b,cc_a,ex_a_r2ab,norm
    INT :: a,b

    AB = .a.pos - .b.pos
    r2ab=dot_product(AB,AB)
    res = ZERO
    do a = 1, .a.n_cc
      ex_a = .a.ex(a)
      cc_a = .a.cc(a)
      ex_a_r2ab = ex_a * r2ab
      do b = 1, .b.n_cc
        ex_b = .b.ex(b)
        norm = abs(.b.cc(b) * cc_a * exp(-ex_a_r2ab * ex_b / (ex_a + ex_b)) )
        if (norm > res) res = norm
      end
    end
  end

  max_k_cd result(res) [private]
  ! Returns the maximum value of .c.cc * .d.cc * k_cd over all contractions of a
  ! and b.  k_cd is kappa_cd, for the two electron integrals.
    DBL :: res
    VEC(3) :: CD
    DBL :: r2cd,ex_c,ex_d,cc_c,ex_c_r2cd,norm
    INT :: c,d

    CD = .c.pos - .d.pos
    r2cd=dot_product(CD,CD)
    res = ZERO
    do c = 1, .c.n_cc
      ex_c = .c.ex(c)
      cc_c = .c.cc(c)
      ex_c_r2cd = ex_c * r2cd
      do d = 1, .d.n_cc
        ex_d = .d.ex(d)
        norm = abs(.d.cc(d) * cc_c * exp(-ex_c_r2cd * ex_d / (ex_c + ex_d)) )
        if (norm > res) res = norm
      end
    end
  end

  skip_ERI result (res)
  ! Whether the ERI block will be less than a cutoff value.
    BIN :: res
    DBL :: max_ab,max_cd

    max_ab = .max_k_ab
    max_cd = .max_k_cd

    if (max_ab*max_cd > SHELL4_ERI_CUTOFF) then
      res = FALSE
    else
      res = TRUE
    end

  end

!*******************************************************************************
!                            CADPAC-style integrals
!*******************************************************************************

!   make_ERI_ints(I)
!   ! Make the ERI integral matrix, using Gauss-Hermite quadrature, like in
!   ! CADPAC.
!   ! This is not expected to be as efficient as Daniel's code, below!
!   ! But probably much easier to understand.
!      MAT4 :: I
!      MAT4* :: II
!      GAUSSIAN4 :: G
!      INT :: a,b,c,d
!      I = ZERO
!      II.create(.a.n_comp,.b.n_comp,.c.n_comp,.d.n_comp)
!      G.l_a   = .a.l;   G.l_b   = .b.l;   G.l_c   = .c.l;   G.l_d   = .d.l
!      G.pos_a = .a.pos; G.pos_b = .b.pos; G.pos_c = .c.pos; G.pos_d = .d.pos
!      do a = 1,.a.n_cc
!      do b = 1,.b.n_cc
!      do c = 1,.c.n_cc
!      do d = 1,.d.n_cc
!         G.ex_a = .a.ex(a)
!         G.ex_b = .b.ex(b)
!         G.ex_c = .c.ex(c)
!         G.ex_d = .d.ex(d)
!         G.make_ERI_ints(II)
!         I = I + II*.a.cc(a)*.b.cc(b)*.c.cc(c)*.d.cc(d)
!      end
!      end
!      end
!      end
!      II.destroy
!      .to_normalize(I)
!   end

   make_spin_orbit_ints(S,O)
   ! Make the spin same orbit integrals, "Sx", ... , and the
   ! spin other orbit integrals "Ox", ... , using
   ! Gauss-Hermite quadrature. Probably not the best implementation.
      MAT5 :: S,O
      .make_spin_orbit_ints(S(:,:,:,:,1),S(:,:,:,:,2),S(:,:,:,:,3), &
                            O(:,:,:,:,1),O(:,:,:,:,2),O(:,:,:,:,3))
   end

   make_spin_orbit_ints(Sx,Sy,Sz,Ox,Oy,Oz)
   ! Make the spin same orbit integrals, "Sx", ... , and the
   ! spin other orbit integrals "Ox", ... , using
   ! Gauss-Hermite quadrature. Probably not the best implementation.
      MAT4 :: Sx,Sy,Sz,Ox,Oy,Oz
      MAT4* :: SSx,SSy,SSz,OOx,OOy,OOz
      GAUSSIAN4 :: G
      INT :: a,b,c,d,na,nb,nc,nd
      DBL :: cc
      Sx = ZERO; Sy = ZERO; Sz = ZERO
      Ox = ZERO; Oy = ZERO; Oz = ZERO
      na = .a.n_comp; nb = .b.n_comp; nc =.c.n_comp; nd =.d.n_comp
      SSx.create(na,nb,nc,nd); SSy.create(na,nb,nc,nd); SSz.create(na,nb,nc,nd)
      OOx.create(na,nb,nc,nd); OOy.create(na,nb,nc,nd); OOz.create(na,nb,nc,nd)
      G.l_a   = .a.l;   G.l_b   = .b.l;   G.l_c   = .c.l;   G.l_d   = .d.l
      G.pos_a = .a.pos; G.pos_b = .b.pos; G.pos_c = .c.pos; G.pos_d = .d.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
      do c = 1,.c.n_cc
      do d = 1,.d.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.ex_c = .c.ex(c)
         G.ex_d = .d.ex(d)
         G.make_spin_orbit_ints(SSx,SSy,SSz,OOx,OOy,OOz)
         cc = .a.cc(a)*.b.cc(b)*.c.cc(c)*.d.cc(d)
         Sx = Sx + SSx*cc; Sy = Sy + SSy*cc; Sz = Sz + SSz*cc
         Ox = Ox + OOx*cc; Oy = Oy + OOy*cc; Oz = Oz + OOz*cc
      end
      end
      end
      end
      OOz.destroy; OOy.destroy; OOx.destroy
      SSz.destroy; SSy.destroy; SSx.destroy
      .to_normalize(Sx); .to_normalize(Sy); .to_normalize(Sz)
      .to_normalize(Ox); .to_normalize(Oy); .to_normalize(Oz)
   end

   make_spin_spin_dipole_ints(Dxx,Dyy,Dzz,Dxy,Dxz,Dyz)
   ! Make the spin spin magnetic dipole integrals, "Dij"
   ! using Gauss-Hermite quadrature. For sure, not the
   ! best implementation, but where else will you get em', eh?
      MAT4 :: Dxx,Dyy,Dzz,Dxy,Dxz,Dyz
      MAT4* :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
      GAUSSIAN4 :: G
      INT :: a,b,c,d,na,nb,nc,nd
      DBL :: cc
      Dxx = ZERO; Dyy = ZERO; Dzz = ZERO
      Dxy = ZERO; Dxz = ZERO; Dyz = ZERO
      na = .a.n_comp; nb = .b.n_comp; nc =.c.n_comp; nd =.d.n_comp
      Mxx.create(na,nb,nc,nd); Myy.create(na,nb,nc,nd); Mzz.create(na,nb,nc,nd)
      Mxy.create(na,nb,nc,nd); Mxz.create(na,nb,nc,nd); Myz.create(na,nb,nc,nd)
      G.l_a   = .a.l;   G.l_b   = .b.l;   G.l_c   = .c.l;   G.l_d   = .d.l
      G.pos_a = .a.pos; G.pos_b = .b.pos; G.pos_c = .c.pos; G.pos_d = .d.pos
      do a = 1,.a.n_cc
      do b = 1,.b.n_cc
      do c = 1,.c.n_cc
      do d = 1,.d.n_cc
         G.ex_a = .a.ex(a)
         G.ex_b = .b.ex(b)
         G.ex_c = .c.ex(c)
         G.ex_d = .d.ex(d)
         G.make_spin_spin_dipole_ints(Mxx,Myy,Mzz,Mxy,Mxz,Myz)
         cc = .a.cc(a)*.b.cc(b)*.c.cc(c)*.d.cc(d)
         Dxx = Dxx + Mxx*cc; Dyy = Dyy + Myy*cc; Dzz = Dzz + Mzz*cc
         Dxy = Dxy + Mxy*cc; Dxz = Dxz + Mxz*cc; Dyz = Dyz + Myz*cc
      end
      end
      end
      end
      Myz.destroy; Mxz.destroy; Mxy.destroy
      Mzz.destroy; Myy.destroy; Mxx.destroy
      .to_normalize(Dxx); .to_normalize(Dyy); .to_normalize(Dzz)
      .to_normalize(Dxy); .to_normalize(Dxz); .to_normalize(Dyz)
   end

!*******************************************************************************
!                   Roland Lindh-style integrals
!
! Electron repulsion integrals from Lindh, Ryu and Liu,
! J. Chem. Phys 95(8) 5889-5897.
!
!*******************************************************************************

  get_eri(abcd)
  ! The main routine to produce the electron repulsion integral block (ab|cd).
  ! Use this routine only!
  ! The rest of the routines are now specialised, eg make_pppp will ONLY accept
  ! a pppp shell4.
    IN :: self
    MAT4, OUT :: abcd
    INT :: n_e,n_f,opt,maxl

    maxl = max(.a.l,.b.l,.c.l,.d.l)
    n_e = .a.l + .b.l
    n_f = .c.l + .d.l
    select case (maxl)
      case (0)                                              ! max is s function
        .make_ssss(abcd)
      case (1)                                              ! max is p function
        if (n_e==0) opt = 1
        if (n_e==1) opt = 4
        if (n_e==2) opt = 7
        if (n_f==1) opt = opt + 1
        if (n_f==2) opt = opt + 2
        select case (opt)
          case (9); .make_pppp(abcd)
          case (8); .make_ppps(abcd)
          case (7); .make_ppss(abcd)
          case (6); .make_pspp(abcd)
          case (5); .make_psps(abcd)
          case (4); .make_psss(abcd)
          case (3); .make_sspp(abcd)
          case (2); .make_ssps(abcd)
          case (1); .make_ssss(abcd)
        end
      case default                                          ! general
        if (n_e == 0) then;      .make_sscd(abcd)
        else if (n_f == 0) then; .make_abss(abcd)
        else;                    .make_abcd(abcd)
        end
    end
  end

  make_abcd(abcd) [private]
  ! Makes the (ab|cd) integrals, summed over the primitives
  ! (uses the transfer equation to make (ab|cd) from (es|fs))
    IN :: self
    MAT4, OUT :: abcd
    MAT3* :: escd
    MAT* :: esfs
    INT :: n_e,n_f,eub,fub
    nullify(esfs)
    nullify(escd)
    n_e = .a.l + .b.l
    n_f = .c.l + .d.l
    eub = n_e.n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c.l,.d.l)-1).n_comp_sum
    esfs.create(eub,fub)
    .make_esfs(esfs)
    escd.create(eub, .c.n_comp, .d.n_comp)
    .transfer_cd(esfs,escd)
    .transfer_ab(escd,abcd)
    escd.destroy
    esfs.destroy
    .to_normalize(abcd)
  end

  make_ascd(escd) [private]
  ! Makes the (as|cd) or (sb|cd) integrals, summed over the primitives.
    IN :: self
    MAT3, OUT :: escd
    MAT* :: esfs
    INT :: n_e,n_f,eub,fub
    nullify(esfs)
    n_e = .a.l + .b.l
    n_f = .c.l + .d.l
    eub = n_e.n_comp
    fub = n_f.n_comp_sum - (max(.c.l,.d.l)-1).n_comp_sum
    esfs.create(eub,fub)
    .make_esfs(esfs)
    .transfer_cd(esfs,escd)
    esfs.destroy
    if (.a.l==0) then
      .to_normalize_bcd(escd)
    else
      .to_normalize_acd(escd)
    end
  end

  make_abcs(abfs) [private]
  ! Makes the (ab|cs) or (ab|sd) integrals, summed over the primitives.
    IN :: self
    MAT3, OUT :: abfs
    MAT* :: esfs
    INT :: n_e,n_f,eub,fub
    nullify(esfs)
    n_e = .a.l + .b.l
    n_f = .c.l + .d.l
    eub = n_e.n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
    fub = n_f.n_comp
    esfs.create(eub,fub)
    .make_esfs(esfs)
    .transfer_ab(esfs,abfs)
    esfs.destroy
    if (.d.l==0) then
      .to_normalize_abc(abfs)
    else
      .to_normalize_abd(abfs)
    end
  end

  make_ascs(ac) [private]
  ! Makes the (as|cs) or (as|sd) or (sb|cs) or (sb|sd) integrals, summed over
  ! the primitives.
    IN :: self
    MAT, OUT :: ac
    SHELL2* :: sh
    INT :: n_e,n_f,eub,fub
    n_e = .a.l + .b.l
    n_f = .c.l + .d.l
    eub = n_e.n_comp
    fub = n_f.n_comp_sum - (max(.c.l,.d.l)-1).n_comp_sum
    .make_esfs(ac)
    if (.a.l==0) then
      if (.c.l==0) then; sh.create(.b,.d)
      else;              sh.create(.b,.c)
      end
    else
      if (.c.l==0) then; sh.create(.a,.d)
      else;              sh.create(.a,.c)
      end
    end
    sh.normalize(ac)
    sh.destroy
  end

  make_esfs(esfs) [private]
  ! Makes the initial (es|fs) integrals, summed over the primitives
    IN :: self
    MAT, OUT:: esfs
    MAT3* :: Ixa,Iya,Iza
    RYS* :: rys
    VEC(3) :: AB,CD,PA,QC,QP
    VEC* :: normcd
    MAT* :: Ix,Iy,Iz
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab,r2cd,d_r2cd
    DBL :: norma,normb,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz
    DBL :: ce,cf,bb,ce1,wt
    DBL :: Ix12,Iy12,Iz12,Ix21,Iy21,Iz21
    DBL :: Ix1f1,Iy1f1,Iz1f1,Ix1f,Iy1f,Iz1f,Ix1fp1,Iy1fp1,Iz1fp1
    DBL :: Ix2f1,Iy2f1,Iz2f1,Ix2f,Iy2f,Iz2f,Ix2fp1,Iy2fp1,Iz2fp1
    DBL :: Ix22,Iy22,Iz22
    DBL :: Ixe11,Iye11,Ize11,Ixe1,Iye1,Ize1,Ixep11,Iyep11,Izep11
    DBL :: Ixef,Iyef,Izef,Ixef1,Iyef1,Izef1
    DBL :: t2,t2_rz,t2_re,half_zinv,half_einv,f1_bb,f1_cf,e1_ce
    DBL :: Ixe12,Iye12,Ize12,Ixe2,Iye2,Ize2,Ixep12,Iyep12,Izep12
    INT :: ag,bg,cg,dg,nroots,eub,fub,dim1,dim2,n_e,n_f,minle,minlf
    INT :: e,f,e1,f1,fp1,ep1,n,i,j,n_sum

    n_e = .a.l + .b.l
    n_f = .c.l + .d.l
    eub = n_e.n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
    fub = n_f.n_comp_sum - (max(.c.l,.d.l)-1).n_comp_sum
    minle=min(.a.l,.b.l)
    minlf=min(.c.l,.d.l)

    dim1 = n_e + 1
    dim2 = n_f + 1
    nroots = (dim1+dim2)/2

    AB = .a.pos - .b.pos
    CD   = .c.pos - .d.pos
    r2ab=dot_product(AB,AB)
    r2cd = dot_product(CD,CD)

    Ax = .a.pos(1);  Ay = .a.pos(2);  Az = .a.pos(3)
    Bx = .b.pos(1);  By = .b.pos(2);  Bz = .b.pos(3)
    Cx = .c.pos(1);  Cy = .c.pos(2);  Cz = .c.pos(3)
    Dx = .d.pos(1);  Dy = .d.pos(2);  Dz = .d.pos(3)
    if (.a.l > .b.l) then
      Atx = Ax;  Aty = Ay;  Atz = Az
    else
      Atx = Bx;  Aty = By;  Atz = Bz
    end
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    ! number of elements to sum over
    n_sum = nroots * .a.n_cc * .b.n_cc * .c.n_cc * .d.n_cc
    Ixa.create(n_sum,dim1,dim2)
    Iya.create(n_sum,dim1,dim2)
    Iza.create(n_sum,dim1,dim2)

    normcd.create(.c.n_cc*.d.n_cc)
    j = 0
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      norm = .d.cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        c    = .c.ex(cg)
        j = j + 1
        einv = ONE / (c + d)
        normcd(j) = norm * .c.cc(cg) * einv * sqrt(einv) * exp(-c * d_r2cd * einv)
      end
    end

    rys.create(nroots)

    if (n_f==1) then ! ab|ps integrals then
      i = 0
      do bg = 1, .b.n_cc
        b     = .b.ex(bg)
        normb = TWOPI5ON2 * .b.cc(bg)
        bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
        b_r2ab = b * r2ab
        do ag = 1, .a.n_cc
          a    = .a.ex(ag)
          zeta = a + b
          zinv = ONE / zeta
          half_zinv = HALF * zinv
          kab  = zinv * exp(-a * b_r2ab * zinv)
          norma = normb * .a.cc(ag) * kab
          Px   = (bBx + a* Ax) * zinv
          Py   = (bBy + a* Ay) * zinv
          Pz   = (bBz + a* Az) * zinv
          PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
          j = 0
          do dg = 1, .d.n_cc
            d   = .d.ex(dg)
            dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
            do cg = 1, .c.n_cc
              j = j + 1
              c    = .c.ex(cg)
              eta  = c + d
              einv = ONE / eta
              Qx   = (dDx + c * Cx) * einv
              Qy   = (dDy + c * Cy) * einv
              Qz   = (dDz + c * Cz) * einv
              rho  = zeta * eta / (zeta + eta)
              rho_zinv = rho * zinv
              rho_einv = rho * einv
              norm = norma * sqrt(rho_zinv) * normcd(j)
              QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
              QCx  = Qx - Ctx;  QCy  = Qy - Cty;  QCz  = Qz - Ctz
              xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
              rys.get_weights(xx)
              rys.w(:) = rys.w(:) * norm
  
              ! Now make the 2 dimensional integrals.
              do n=1,nroots
                i = i + 1
                Ix => Ixa(i,:,:)
                Iy => Iya(i,:,:)
                Iz => Iza(i,:,:)
                wt=rys.w(n)
                Ix(1,1) = ONE
                Iy(1,1) = ONE
                Iz(1,1) = wt
                t2    = rys.r(n)
                t2_rz = t2 * rho_zinv
                t2_re = t2 * rho_einv
                bb    = t2_re * half_zinv
                ce    = (ONE - t2_rz) * half_zinv
                Ixe12 = QCx - t2_re * QPx
                Iye12 = QCy - t2_re * QPy
                Ize12 = QCz - t2_re * QPz
                Ix21 = PAx + t2_rz * QPx
                Iy21 = PAy + t2_rz * QPy
                Iz21 = PAz + t2_rz * QPz
                Ixe2 = Ixe12 * Ix21 + bb
                Iye2 = Iye12 * Iy21 + bb
                Ize2 = Ize12 * Iz21 + bb
                Ixe11 = ONE;     Iye11 = ONE;     Ize11 = ONE
                Ix(1,2) = Ixe12; Iy(1,2) = Iye12; Iz(1,2) = Ize12*wt
                Ix(2,1) = Ix21;  Iy(2,1) = Iy21;  Iz(2,1) = Iz21*wt
                Ix(2,2) = Ixe2;  Iy(2,2) = Iye2;  Iz(2,2) = Ize2*wt
                Ixe1 = Ix21;     Iye1 = Iy21;     Ize1 = Iz21
                do e = 2, n_e
                  e1  =e - 1
                  ep1 =e + 1
                  ce1 =e1 * ce
                  Ixep11 = Ix21*Ixe1 + ce1*Ixe11;            Ix(ep1,1) = Ixep11
                  Iyep11 = Iy21*Iye1 + ce1*Iye11;            Iy(ep1,1) = Iyep11
                  Izep11 = Iz21*Ize1 + ce1*Ize11;            Iz(ep1,1) = Izep11*wt
                  Ixep12 = Ix21*Ixe2 + ce1*Ixe12 + bb*Ixe1;  Ix(ep1,2) = Ixep12
                  Iyep12 = Iy21*Iye2 + ce1*Iye12 + bb*Iye1;  Iy(ep1,2) = Iyep12
                  Izep12 = Iz21*Ize2 + ce1*Ize12 + bb*Ize1;  Iz(ep1,2) = Izep12*wt
                  Ixe11 = Ixe1;   Iye11 = Iye1;   Ize11 = Ize1
                  Ixe12 = Ixe2;   Iye12 = Iye2;   Ize12 = Ize2
                  Ixe1 = Ixep11;  Iye1 = Iyep11;  Ize1 = Izep11
                  Ixe2 = Ixep12;  Iye2 = Iyep12;  Ize2 = Izep12
                end
              end
            end
          end
        end
      end
    else
      i = 0
      do bg = 1, .b.n_cc
        b     = .b.ex(bg)
        normb = TWOPI5ON2 * .b.cc(bg)
        bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
        b_r2ab = b * r2ab
        do ag = 1, .a.n_cc
          a    = .a.ex(ag)
          zeta = a + b
          zinv = ONE / zeta
          half_zinv = HALF * zinv
          kab  = zinv * exp(-a * b_r2ab * zinv)
          norma = normb * .a.cc(ag) * kab
          Px   = (bBx + a* Ax) * zinv
          Py   = (bBy + a* Ay) * zinv
          Pz   = (bBz + a* Az) * zinv
          PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
          j = 0
          do dg = 1, .d.n_cc
            d   = .d.ex(dg)
            dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
            do cg = 1, .c.n_cc
              j = j + 1
              c    = .c.ex(cg)
              eta  = c + d
              einv = ONE / eta
              Qx   = (dDx + c * Cx) * einv
              Qy   = (dDy + c * Cy) * einv
              Qz   = (dDz + c * Cz) * einv
              rho  = zeta * eta / (zeta + eta)
              rho_zinv = rho * zinv
              rho_einv = rho * einv
              norm = norma * sqrt(rho_zinv) * normcd(j)
              QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
              QCx  = Qx - Ctx;  QCy  = Qy - Cty;  QCz  = Qz - Ctz
              xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
              rys.get_weights(xx)
              rys.w(:) = rys.w(:) * norm
  
              ! Now make the 2 dimensional integrals.
              half_einv = HALF * einv
              do n=1,nroots
                i = i + 1
                Ix => Ixa(i,:,:)
                Iy => Iya(i,:,:)
                Iz => Iza(i,:,:)
                t2    = rys.r(n)
                t2_rz = t2 * rho_zinv
                t2_re = t2 * rho_einv
                bb    = t2_rz * half_einv
                cf    = (ONE - t2_re) * half_einv
                ce    = (ONE - t2_rz) * half_zinv
                Ix12 = QCx - t2_re * QPx
                Iy12 = QCy - t2_re * QPy
                Iz12 = QCz - t2_re * QPz
                Ix21 = PAx + t2_rz * QPx
                Iy21 = PAy + t2_rz * QPy
                Iz21 = PAz + t2_rz * QPz
                Ix22 = Ix12 * Ix21 + bb
                Iy22 = Iy12 * Iy21 + bb
                Iz22 = Iz12 * Iz21 + bb
                Ix(1,1) = ONE;  Iy(1,1) = ONE;  Iz(1,1) = ONE
                Ix(2,1) = Ix21; Iy(2,1) = Iy21; Iz(2,1) = Iz21
                Ix(1,2) = Ix12; Iy(1,2) = Iy12; Iz(1,2) = Iz12
                Ix(2,2) = Ix22; Iy(2,2) = Iy22; Iz(2,2) = Iz22
                Ix1f  = Ix12; Iy1f  = Iy12; Iz1f  = Iz12
                Ix1f1 = ONE;  Iy1f1 = ONE;  Iz1f1 = ONE
                do f = 2,n_f
                  fp1 = f + 1
                  f1_cf = (f-1)*cf
                  Ix1fp1 = Ix12 * Ix1f + f1_cf * Ix1f1
                  Iy1fp1 = Iy12 * Iy1f + f1_cf * Iy1f1
                  Iz1fp1 = Iz12 * Iz1f + f1_cf * Iz1f1
                  Ix(1,fp1) = Ix1fp1; Iy(1,fp1) = Iy1fp1; Iz(1,fp1) = Iz1fp1
                  Ix1f1 = Ix1f;   Iy1f1 = Iy1f;   Iz1f1 = Iz1f
                  Ix1f  = Ix1fp1; Iy1f  = Iy1fp1; Iz1f  = Iz1fp1
                end
                Ixe1  = Ix21; Iye1  = Iy21; Ize1  = Iz21
                Ixe11 = ONE;   Iye11 = ONE;   Ize11 = ONE
                do e = 2, n_e
                  ep1 = e + 1
                  e1_ce = (e-1) * ce
                  Ixep11 = Ix21 * Ixe1 + e1_ce * Ixe11
                  Iyep11 = Iy21 * Iye1 + e1_ce * Iye11
                  Izep11 = Iz21 * Ize1 + e1_ce * Ize11
                  Ix(ep1,1) = Ixep11; Iy(ep1,1) = Iyep11; Iz(ep1,1) = Izep11
                  Ixe11 = Ixe1;   Iye11 = Iye1;   Ize11 = Ize1
                  Ixe1  = Ixep11; Iye1  = Iyep11; Ize1  = Izep11
                end
                Ix2f  = Ix22; Iy2f  = Iy22; Iz2f  = Iz22
                Ix2f1 = Ix21; Iy2f1 = Iy21; Iz2f1 = Iz21
                do f=2,n_f
                  fp1 = f + 1
                  f1_cf = (f-1)*cf
                  Ix2fp1 = Ix12 * Ix2f + f1_cf * Ix2f1 + bb * Ix(1,f)
                  Iy2fp1 = Iy12 * Iy2f + f1_cf * Iy2f1 + bb * Iy(1,f)
                  Iz2fp1 = Iz12 * Iz2f + f1_cf * Iz2f1 + bb * Iz(1,f)
                  Ix(2,fp1) = Ix2fp1; Iy(2,fp1) = Iy2fp1; Iz(2,fp1) = Iz2fp1
                  Ix2f1 = Ix2f;   Iy2f1 = Iy2f;   Iz2f1 = Iz2f
                  Ix2f  = Ix2fp1; Iy2f  = Iy2fp1; Iz2f  = Iz2fp1
                end
                do e = 2, n_e
                  e1  =e - 1
                  ep1 =e + 1
                  ce1 =e1 * ce
                  Ixef1 = Ix(e,1); Iyef1 = Iy(e,1); Izef1 = Iz(e,1)
                  do f=2, n_f+1
                    f1_bb = (f-1)*bb
                    Ixef  = Ix(e,f); Iyef  = Iy(e,f); Izef  = Iz(e,f)
                    Ix(ep1,f) = Ix21*Ixef + ce1*Ix(e1,f) + f1_bb*Ixef1
                    Iy(ep1,f) = Iy21*Iyef + ce1*Iy(e1,f) + f1_bb*Iyef1
                    Iz(ep1,f) = Iz21*Izef + ce1*Iz(e1,f) + f1_bb*Izef1
                    Ixef1 = Ixef;   Iyef1 = Iyef;   Izef1 = Izef
                  end
                end
                Iz(:,:) = rys.w(n) * Iz(:,:)    ! Merge the weights into Iz.
              end
            end
          end
        end
      end
    end

    rys.destroy
    normcd.destroy

    .form_esfs(Ixa,Iya,Iza,esfs,eub,fub,n_sum)

    Iza.destroy
    Iya.destroy
    Ixa.destroy
  end

  form_esfs(Ix,Iy,Iz,esfs,eub,fub,n_sum) [private]
  ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
  ! This is the main routine, all the others are specialised and may break if
  ! given the wrong shell4.
    IN :: self
    MAT3, IN :: Ix,Iy,Iz
    MAT, OUT :: esfs
    INT, IN :: eub,fub,n_sum
    INT :: minle,minlf,n_e,n_f
    n_e = .a.l + .b.l
    n_f = .c.l + .d.l
    minle=min(.a.l,.b.l)
    minlf=min(.c.l,.d.l)
    if (n_e==1) then
      if (minlf < 2) then
        .form_psfs_1(Ix,Iy,Iz,esfs,eub,fub,n_sum)
      else
        .form_psfs(Ix,Iy,Iz,esfs,eub,fub,n_sum)
      end
    else if (n_f==1) then
      if (minle < 2) then
        .form_esps_1(Ix,Iy,Iz,esfs,eub,fub,n_sum)
      else
        .form_esps(Ix,Iy,Iz,esfs,eub,fub,n_sum)
      end
    else if (minle < 2 AND minlf < 2) then
      .form_esfs_1(Ix,Iy,Iz,esfs,eub,fub,n_sum)
    else
      .form_esfs_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum)
    end
  end

  form_esfs_rm(Ix,Iy,Iz,esfs,eub,fub,n_sum) [private]
  ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
  ! This version uses the reduced multiplication scheme.
    IN :: self
    MAT3, IN :: Ix,Iy,Iz
    MAT, OUT :: esfs
    INT, IN :: eub,fub,n_sum
    IVEC* :: e_x,e_y,e_z,f_x,f_y,f_z,ii_e_ivec,ii_f_ivec
    IMAT* :: e_powers,f_powers,indexe,indexf
    MAT3* :: Ief
    INT :: e,f,n_e,n_f,zf,yf,xf,ze,ye,xe,iie,iif,minle,minlf
    INT :: dime,dimf,dime1,dimf1,dime2,dimf2,maxab,maxcd

    n_e = .a.l + .b.l
    n_f = .c.l + .d.l
    maxab=max(.a.l,.b.l)
    maxcd=max(.c.l,.d.l)
    dime  = n_e+1
    dime1 = n_e+2
    dime2 = 2*dime1+1
    dimf  = n_f+1
    dimf1 = n_f+2
    dimf2 = 2*dimf1+1

    e_powers.create(eub,3)
    e_x => e_powers(:,1); e_y => e_powers(:,2); e_z => e_powers(:,3)
    maxab.make_gaussian_xyz_indices(e_x,e_y,e_z,n_e)
    ii_e_ivec.create(eub)
    do e=1,eub
      ze = e_z(e)
      ii_e_ivec(e) = -dime1 + ze*(dime2-ze)/2 + e_y(e)
    end

    if (maxcd==maxab AND n_e==n_f) then
     f_x => e_x
     ii_f_ivec => ii_e_ivec
    else
      f_powers.create(fub,3)
      f_x => f_powers(:,1); f_y => f_powers(:,2); f_z => f_powers(:,3)
      maxcd.make_gaussian_xyz_indices(f_x,f_y,f_z,n_f)
      ii_f_ivec.create(fub)
      do f=1,fub
        zf = f_z(f)
        ii_f_ivec(f) = -dimf1 + zf*(dimf2-zf)/2 + f_y(f)
      end
    end

    Ief.create(n_sum,dime*dime1/2,dimf*dimf1/2)

    ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
    iif = 0
    do zf=1,dimf
      do yf=1,dimf1-zf
        iif = iif + 1
        iie = 0
        do ze=1,dime
          do ye=1,dime1-ze
            iie = iie + 1
            Ief(:,iie,iif) = Iy(:,ye,yf) * Iz(:,ze,zf)
          end
        end
      end
    end
    ! Now add in the Ix 2d integrals and sum over contractions and roots
    do f=1,fub
      xf = f_x(f)
      iif = ii_f_ivec(f)
      do e=1,eub
        iie = ii_e_ivec(e)
        esfs(e,f) = sum(Ix(:,e_x(e),xf) * Ief(:,iie,iif))
      end
    end
    Ief.destroy
    if (NOT (maxcd==maxab AND n_e==n_f)) then
      ii_f_ivec.destroy
      f_powers.destroy
    end
    ii_e_ivec.destroy
    e_powers.destroy
  end

  form_esfs_1(Ix,Iy,Iz,esfs,eub,fub,n_sum) [private]
  ! Forms (es|fs) from the two dimensional integrals, summed over primitives.
  ! This version does not use the reduced multiplication scheme.
    IN :: self
    MAT3, IN :: Ix,Iy,Iz
    MAT, OUT :: esfs
    INT, IN :: eub,fub,n_sum
    IVEC* :: e_x,e_y,e_z,f_x,f_y,f_z
    IMAT* :: e_powers,f_powers
    INT :: e,f,n_e,n_f,zf,yf,xf,ze,ye,xe
 
    n_e = .a.l + .b.l
    n_f = .c.l + .d.l

    e_powers.create(eub,3)
    e_x => e_powers(:,1); e_y => e_powers(:,2); e_z => e_powers(:,3)
    max(.a.l,.b.l).make_gaussian_xyz_indices(e_x,e_y,e_z,n_e)

    if (n_e==n_f AND eub==fub) then
      f_x => e_x; f_y => e_y; f_z => e_z
    else
      f_powers.create(fub,3)
      f_x => f_powers(:,1); f_y => f_powers(:,2); f_z => f_powers(:,3)
      max(.c.l,.d.l).make_gaussian_xyz_indices(f_x,f_y,f_z,n_f)
    end

    do f=1,fub
      xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
      do e=1,eub
        xe = e_x(e);    ye = e_y(e);    ze = e_z(e)
        esfs(e,f) = sum(Ix(:,xe,xf) * Iy(:,ye,yf) * Iz(:,ze,zf))
      end
    end

    if (NOT (n_e==n_f AND eub==fub)) f_powers.destroy
    e_powers.destroy
  end

  form_esps_1(Ix,Iy,Iz,esfs,eub,fub,n_sum) [private]
  ! Forms (es|ps) from the two dimensional integrals, summed over primitives.
  ! This version does not use the reduced multiplication scheme.
    IN :: self
    MAT3, target :: Ix,Iy,Iz
    MAT, OUT :: esfs
    INT, IN :: eub,fub,n_sum
    IVEC* :: e_x,e_y,e_z
    IMAT* :: e_powers
    VEC* :: Ix1,Iy1,Iz1
    INT :: e,n_e,ze,ye,xe
    n_e = .a.l + .b.l
    e_powers.create(eub,3)
    e_x => e_powers(:,1); e_y => e_powers(:,2); e_z => e_powers(:,3)
    max(.a.l,.b.l).make_gaussian_xyz_indices(e_x,e_y,e_z,n_e)
    do e=1,eub
      xe = e_x(e);    ye = e_y(e);    ze = e_z(e)
      Ix1 => Ix(:,xe,1)
      Iy1 => Iy(:,ye,1)
      Iz1 => Iz(:,ze,1)
      esfs(e,1) = sum(Ix(:,xe,2)*Iy1*Iz1)
      esfs(e,2) = sum(Ix1*Iy(:,ye,2)*Iz1)
      esfs(e,3) = sum(Ix1*Iy1*Iz(:,ze,2))
    end
    e_powers.destroy
  end

  form_esps(Ix,Iy,Iz,esfs,eub,fub,n_sum) [private]
  ! Forms (es|ps) from the two dimensional integrals, summed over primitives.
  ! This version does uses the reduced multiplication scheme.
    IN :: self
    MAT3, target :: Ix,Iy,Iz
    MAT, OUT :: esfs
    INT, IN :: eub,fub,n_sum
    IVEC* :: e_x,e_y,e_z,f_x,f_y,f_z,ii_e_ivec,ii_f_ivec
    IMAT* :: e_powers,indexe
    VEC* :: Ix1,Iy1,Iz1
    MAT3* :: Ief
    INT :: e,f,n_e,ze,ye,xe,iie,iif,minle
    INT :: dime,dime1,dime2,maxab

    n_e = .a.l + .b.l
    maxab=max(.a.l,.b.l)
    dime  = n_e+1
    dime1 = n_e+2
    dime2 = 2*dime1+1

    e_powers.create(eub,3)
    e_x => e_powers(:,1); e_y => e_powers(:,2); e_z => e_powers(:,3)
    maxab.make_gaussian_xyz_indices(e_x,e_y,e_z,n_e)
    ii_e_ivec.create(eub)
    do e=1,eub
      ze = e_z(e)
      ii_e_ivec(e) = -dime1 + ze*(dime2-ze)/2 + e_y(e)
    end
    Ief.create(n_sum,dime*dime1/2,3)

    ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
    iie = 0
    do ze=1,dime
      do ye=1,dime1-ze
        iie = iie + 1
        Iy1 => Iy(:,ye,1)
        Iz1 => Iz(:,ze,1)
        Ief(:,iie,1) = Iy1 * Iz1
        Ief(:,iie,2) = Iy(:,ye,2) * Iz1
        Ief(:,iie,3) = Iy1 * Iz(:,ze,2)
      end
    end
    ! Now add in the Ix 2d integrals and sum over contractions and roots
    do e=1,eub
      iie = ii_e_ivec(e)
      xe = e_x(e)
      Ix1 => Ix(:,xe,1)
      esfs(e,1) = sum(Ix(:,xe,2) * Ief(:,iie,1))
      esfs(e,2) = sum(Ix1 * Ief(:,iie,2))
      esfs(e,3) = sum(Ix1 * Ief(:,iie,3))
    end
    Ief.destroy
    ii_e_ivec.destroy
    e_powers.destroy
  end

  form_psfs(Ix,Iy,Iz,esfs,eub,fub,n_sum) [private]
  ! Forms (ps|fs) from the two dimensional integrals, summed over primitives.
  ! This version does uses the reduced multiplication scheme.
    IN :: self
    MAT3, target :: Ix,Iy,Iz
    MAT, OUT :: esfs
    INT, IN :: eub,fub,n_sum
    IVEC* :: e_x,e_y,e_z,f_x,f_y,f_z,ii_e_ivec,ii_f_ivec
    IMAT* :: e_powers,f_powers,indexe,indexf
    MAT3* :: Ief
    VEC* :: Ix1,Iy1,Iz1
    INT :: e,f,n_e,n_f,zf,yf,xf,ze,ye,xe,iie,iif,minle,minlf,opt
    INT :: dime,dimf,dime1,dimf1,dime2,dimf2,maxab,maxcd

    n_f = .c.l + .d.l
    maxcd=max(.c.l,.d.l)
    dimf  = n_f+1
    dimf1 = n_f+2
    dimf2 = 2*dimf1+1

    f_powers.create(fub,3)
    f_x => f_powers(:,1); f_y => f_powers(:,2); f_z => f_powers(:,3)
    maxcd.make_gaussian_xyz_indices(f_x,f_y,f_z,n_f)
    ii_f_ivec.create(fub)
    do f=1,fub
      zf = f_z(f)
      ii_f_ivec(f) = -dimf1 + zf*(dimf2-zf)/2 + f_y(f)
    end

    Ief.create(n_sum,3,dimf*dimf1/2)

    ! Apply reduced multiplication scheme to Iy and Iz, store in triangle.
    iif = 0
    do zf=1,dimf
      do yf=1,dimf1-zf
        iif = iif + 1
        Iy1 => Iy(:,1,yf)
        Iz1 => Iz(:,1,zf)
        Ief(:,1,iif) = Iy1 * Iz1
        Ief(:,2,iif) = Iy(:,2,yf) * Iz1
        Ief(:,3,iif) = Iy1 * Iz(:,2,zf)
      end
    end
    ! Now add in the Ix 2d integrals and sum over contractions and roots
    do f=1,fub
      xf = f_x(f)
      iif = ii_f_ivec(f)
      Ix1 => Ix(:,1,xf)
      esfs(1,f) = sum(Ix(:,2,xf) * Ief(:,1,iif))
      esfs(2,f) = sum(Ix1 * Ief(:,2,iif))
      esfs(3,f) = sum(Ix1 * Ief(:,3,iif))
    end
    Ief.destroy
    ii_f_ivec.destroy
    f_powers.destroy
  end

  form_psfs_1(Ix,Iy,Iz,esfs,eub,fub,n_sum) [private]
  ! Forms (ps|fs) from the two dimensional integrals, summed over primitives.
  ! This version does not use the reduced multiplication scheme.
    IN :: self
    MAT3, target :: Ix,Iy,Iz
    MAT, OUT :: esfs
    INT, IN :: eub,fub,n_sum
    IVEC* :: f_x,f_y,f_z
    IMAT* :: f_powers,indexf
    VEC* :: Ix1,Iy1,Iz1
    INT :: f,n_f,zf,yf,xf
    n_f = .c.l + .d.l
    f_powers.create(fub,3)
    f_x => f_powers(:,1); f_y => f_powers(:,2); f_z => f_powers(:,3)
    max(.c.l,.d.l).make_gaussian_xyz_indices(f_x,f_y,f_z,n_f)
    do f=1,fub
      xf = f_x(f);    yf = f_y(f);    zf = f_z(f)
      Ix1 => Ix(:,1,xf)
      Iy1 => Iy(:,1,yf)
      Iz1 => Iz(:,1,zf)
      esfs(1,f) = sum(Ix(:,2,xf)*Iy1*Iz1)
      esfs(2,f) = sum(Ix1*Iy(:,2,yf)*Iz1)
      esfs(3,f) = sum(Ix1*Iy1*Iz(:,2,zf))
    end
    f_powers.destroy
  end

  make_pppp(abcd) [private]
  ! Make the (pp|pp) integrals, summed over primitives.
    IN :: self
    MAT4, target :: abcd
    MAT* :: Iab
    VEC* :: normcd
    RYS* :: rys
    VEC(3) :: CD
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab,d_r2cd,r2cd
    DBL :: norma,normb,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz
    DBL :: ce,cf,bb,bb_2,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix13,Ix21,Ix22,Ix23,Ix31,Ix32,Ix33
    DBL :: Iy12,Iy13,Iy21,Iy22,Iy23,Iy31,Iy32,Iy33
    DBL :: Iz12,Iz13,Iz21,Iz22,Iz23,Iz31,Iz32,Iz33
    DBL :: px__px_,py__px_,pz__px_
    DBL :: px__py_,py__py_,pz__py_
    DBL :: px__pz_,py__pz_,pz__pz_
    DBL :: px__dxx,py__dxx,pz__dxx
    DBL :: px__dyy,py__dyy,pz__dyy
    DBL :: px__dzz,py__dzz,pz__dzz
    DBL :: px__dxy,py__dxy,pz__dxy
    DBL :: px__dxz,py__dxz,pz__dxz
    DBL :: px__dyz,py__dyz,pz__dyz
    DBL :: dxx_px_,dyy_px_,dzz_px_,dxy_px_,dxz_px_,dyz_px_
    DBL :: dxx_py_,dyy_py_,dzz_py_,dxy_py_,dxz_py_,dyz_py_
    DBL :: dxx_pz_,dyy_pz_,dzz_pz_,dxy_pz_,dxz_pz_,dyz_pz_
    DBL :: dxx_dxx,dyy_dxx,dzz_dxx,dxy_dxx,dxz_dxx,dyz_dxx
    DBL :: dxx_dyy,dyy_dyy,dzz_dyy,dxy_dyy,dxz_dyy,dyz_dyy
    DBL :: dxx_dzz,dyy_dzz,dzz_dzz,dxy_dzz,dxz_dzz,dyz_dzz
    DBL :: dxx_dxy,dyy_dxy,dzz_dxy,dxy_dxy,dxz_dxy,dyz_dxy
    DBL :: dxx_dxz,dyy_dxz,dzz_dxz,dxy_dxz,dxz_dxz,dyz_dxz
    DBL :: dxx_dyz,dyy_dyz,dzz_dyz,dxy_dyz,dxz_dyz,dyz_dyz
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy13_Iz21,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy31_Iz12,Iy21_Iz13,Iy12_Iz31,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy13_w, Iy31_w, Iy32_w, Iy23_w
    DBL :: px_,py_,pz_,dxx_,dyy_,dzz_,dxy_,dxz_,dyz_
    DBL :: BAx,BAy,BAz,DCx,DCy,DCz
    INT :: ag,bg,cg,dg,n,nroots,i

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    dxx_px_ = ZERO; dyy_px_ = ZERO; dzz_px_ = ZERO
    dxy_px_ = ZERO; dxz_px_ = ZERO; dyz_px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    dxx_py_ = ZERO; dyy_py_ = ZERO; dzz_py_ = ZERO
    dxy_py_ = ZERO; dxz_py_ = ZERO; dyz_py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    dxx_pz_ = ZERO; dyy_pz_ = ZERO; dzz_pz_ = ZERO
    dxy_pz_ = ZERO; dxz_pz_ = ZERO; dyz_pz_ = ZERO
    px__dxx = ZERO; py__dxx = ZERO; pz__dxx = ZERO
    dxx_dxx = ZERO; dyy_dxx = ZERO; dzz_dxx = ZERO
    dxy_dxx = ZERO; dxz_dxx = ZERO; dyz_dxx = ZERO
    px__dyy = ZERO; py__dyy = ZERO; pz__dyy = ZERO
    dxx_dyy = ZERO; dyy_dyy = ZERO; dzz_dyy = ZERO
    dxy_dyy = ZERO; dxz_dyy = ZERO; dyz_dyy = ZERO
    px__dzz = ZERO; py__dzz = ZERO; pz__dzz = ZERO
    dxx_dzz = ZERO; dyy_dzz = ZERO; dzz_dzz = ZERO
    dxy_dzz = ZERO; dxz_dzz = ZERO; dyz_dzz = ZERO
    px__dxy = ZERO; py__dxy = ZERO; pz__dxy = ZERO
    dxx_dxy = ZERO; dyy_dxy = ZERO; dzz_dxy = ZERO
    dxy_dxy = ZERO; dxz_dxy = ZERO; dyz_dxy = ZERO
    px__dxz = ZERO; py__dxz = ZERO; pz__dxz = ZERO
    dxx_dxz = ZERO; dyy_dxz = ZERO; dzz_dxz = ZERO
    dxy_dxz = ZERO; dxz_dxz = ZERO; dyz_dxz = ZERO
    px__dyz = ZERO; py__dyz = ZERO; pz__dyz = ZERO
    dxx_dyz = ZERO; dyy_dyz = ZERO; dzz_dyz = ZERO
    dxy_dyy = ZERO; dxz_dyy = ZERO; dyz_dyy = ZERO
    dxy_dyz = ZERO; dxz_dyz = ZERO; dyz_dyz = ZERO

    Ax = .a.pos(1);  Ay = .a.pos(2);  Az = .a.pos(3)
    Bx = .b.pos(1);  By = .b.pos(2);  Bz = .b.pos(3)
    Cx = .c.pos(1);  Cy = .c.pos(2);  Cz = .c.pos(3)
    Dx = .d.pos(1);  Dy = .d.pos(2);  Dz = .d.pos(3)
    BAx = Bx - Ax;   BAy = By - Ay;   BAz = Bz - Az
    DCx = Dx - Cx;   DCy = Dy - Cy;   DCz = Dz - Cz
    r2ab = BAx*BAx + BAy*BAy + BAz*BAz
    Atx = Bx;  Aty = By;  Atz = Bz
    Ctx = Dx;  Cty = Dy;  Ctz = Dz

    CD   = .c.pos - .d.pos
    r2cd = dot_product(CD,CD)

    normcd.create(.c.n_cc*.d.n_cc)
    i = 0
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      norm = .d.cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        i = i + 1
        c    = .c.ex(cg)
        einv = ONE / (c + d)
        normcd(i) = norm * .c.cc(cg) * einv * sqrt(einv) * exp(-c * d_r2cd * einv)
      end
    end

    rys.create(3)
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = TWOPI5ON2 * .b.cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        a    = .a.ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a.cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        i = 0
        do dg = 1, .d.n_cc
          d   = .d.ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c.n_cc
            i = i + 1
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho_zinv) * normcd(i)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            QCx = Qx - Ctx;   QCy = Qy - Cty;   QCz = Qz - Ctz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rys.get_weights(xx)
            half_zinv = HALF * zinv
            half_einv = HALF * einv
            do n=1,3
              t2    = rys.r(n)
              w     = rys.w(n) * norm
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              bb_2  = TWO*bb
              cf    = (ONE - t2_re) * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13 = Iz12 * Iz12 + cf
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix23 = Ix12 * Ix22 + cf * Ix21 + bb * Ix12
              Iy23 = Iy12 * Iy22 + cf * Iy21 + bb * Iy12
              Iz23 = Iz12 * Iz22 + cf * Iz21 + bb * Iz12
              Ix32 = Ix21 * Ix22 + ce * Ix12 + bb * Ix21
              Iy32 = Iy21 * Iy22 + ce * Iy12 + bb * Iy21
              Iz32 = Iz21 * Iz22 + ce * Iz12 + bb * Iz21
              Ix33 = Ix21 * Ix23 + ce * Ix13 + bb_2 * Ix22
              Iy33 = Iy21 * Iy23 + ce * Iy13 + bb_2 * Iy22
              Iz33 = Iz21 * Iz23 + ce * Iz13 + bb_2 * Iz22

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz31 = Iz31 * w
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iz32 = Iz32 * w
              Iz13 = Iz13 * w
              Iz23 = Iz23 * w
              Iz33 = Iz33 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy12_Iz12 = Iy12 * Iz12
              Iy12_Iz22 = Iy12 * Iz22
              Iy12_Iz31 = Iy12 * Iz31
              Iy13_Iz21 = Iy13 * Iz21
              Iy21_Iz21 = Iy21 * Iz21
              Iy21_Iz22 = Iy21 * Iz22
              Iy21_Iz12 = Iy21 * Iz12
              Iy21_Iz13 = Iy21 * Iz13
              Iy31_Iz12 = Iy31 * Iz12
              Iy22_Iz12 = Iy22 * Iz12
              Iy22_Iz21 = Iy22 * Iz21
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w
              Iy13_w    = Iy13 * w
              Iy31_w    = Iy31 * w
              Iy32_w    = Iy32 * w
              Iy23_w    = Iy23 * w

              px__px_ = px__px_ + Ix22 * w     !  combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12 * Iz21
              dxx_px_ = dxx_px_ + Ix32 * w
              dyy_px_ = dyy_px_ + Ix12 * Iy31_w
              dzz_px_ = dzz_px_ + Ix12 * Iz31
              dxy_px_ = dxy_px_ + Ix22 * Iy21_w
              dxz_px_ = dxz_px_ + Ix22 * Iz21
              dyz_px_ = dyz_px_ + Ix12 * Iy21_Iz21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              dxx_py_ = dxx_py_ + Ix31 * Iy12_w
              dyy_py_ = dyy_py_ + Iy32_w
              dzz_py_ = dzz_py_ + Iy12_Iz31
              dxy_py_ = dxy_py_ + Ix21 * Iy22_w
              dxz_py_ = dxz_py_ + Ix21 * Iy12_Iz21
              dyz_py_ = dyz_py_ + Iy22_Iz21
              px__pz_ = px__pz_ + Ix21 * Iz12
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22
              dxx_pz_ = dxx_pz_ + Ix31 * Iz12
              dyy_pz_ = dyy_pz_ + Iy31_Iz12
              dzz_pz_ = dzz_pz_ + Iz32
              dxy_pz_ = dxy_pz_ + Ix21 * Iy21_Iz12
              dxz_pz_ = dxz_pz_ + Ix21 * Iz22
              dyz_pz_ = dyz_pz_ + Iy21_Iz22
              px__dxx = px__dxx + Ix23 * w
              py__dxx = py__dxx + Ix13 * Iy21_w
              pz__dxx = pz__dxx + Ix13 * Iz21
              dxx_dxx = dxx_dxx + Ix33 * w
              dyy_dxx = dyy_dxx + Ix13 * Iy31_w
              dzz_dxx = dzz_dxx + Ix13 * Iz31
              dxy_dxx = dxy_dxx + Ix23 * Iy21_w
              dxz_dxx = dxz_dxx + Ix23 * Iz21
              dyz_dxx = dyz_dxx + Ix13 * Iy21_Iz21
              px__dyy = px__dyy + Ix21 * Iy13_w
              py__dyy = py__dyy + Iy23_w
              pz__dyy = pz__dyy + Iy13_Iz21
              dxx_dyy = dxx_dyy + Ix31 * Iy13_w
              dyy_dyy = dyy_dyy + Iy33 * w
              dzz_dyy = dzz_dyy + Iy13 * Iz31
              dxy_dyy = dxy_dyy + Ix21 * Iy23_w
              dxz_dyy = dxz_dyy + Ix21 * Iy13_Iz21
              dyz_dyy = dyz_dyy + Iy23 * Iz21
              px__dzz = px__dzz + Ix21 * Iz13
              py__dzz = py__dzz + Iy21_Iz13
              pz__dzz = pz__dzz + Iz23
              dxx_dzz = dxx_dzz + Ix31 * Iz13
              dyy_dzz = dyy_dzz + Iy31 * Iz13
              dzz_dzz = dzz_dzz + Iz33
              dxy_dzz = dxy_dzz + Ix21 * Iy21_Iz13
              dxz_dzz = dxz_dzz + Ix21 * Iz23
              dyz_dzz = dyz_dzz + Iy21 * Iz23
              px__dxy = px__dxy + Ix22 * Iy12_w
              py__dxy = py__dxy + Ix12 * Iy22_w
              pz__dxy = pz__dxy + Ix12 * Iy12_Iz21
              dxx_dxy = dxx_dxy + Ix32 * Iy12_w
              dyy_dxy = dyy_dxy + Ix12 * Iy32_w
              dzz_dxy = dzz_dxy + Ix12 * Iy12_Iz31
              dxy_dxy = dxy_dxy + Ix22 * Iy22_w
              dxz_dxy = dxz_dxy + Ix22 * Iy12_Iz21
              dyz_dxy = dyz_dxy + Ix12 * Iy22_Iz21
              px__dxz = px__dxz + Ix22 * Iz12
              py__dxz = py__dxz + Ix12 * Iy21_Iz12
              pz__dxz = pz__dxz + Ix12 * Iz22
              dxx_dxz = dxx_dxz + Ix32 * Iz12
              dyy_dxz = dyy_dxz + Ix12 * Iy31_Iz12
              dzz_dxz = dzz_dxz + Ix12 * Iz32
              dxy_dxz = dxy_dxz + Ix22 * Iy21_Iz12
              dxz_dxz = dxz_dxz + Ix22 * Iz22
              dyz_dxz = dyz_dxz + Ix12 * Iy21_Iz22
              px__dyz = px__dyz + Ix21 * Iy12_Iz12
              py__dyz = py__dyz + Iy22_Iz12
              pz__dyz = pz__dyz + Iy12_Iz22
              dxx_dyz = dxx_dyz + Ix31 * Iy12_Iz12
              dyy_dyz = dyy_dyz + Iy32 * Iz12
              dzz_dyz = dzz_dyz + Iy12 * Iz32
              dxy_dyz = dxy_dyz + Ix21 * Iy22_Iz12
              dxz_dyz = dxz_dyz + Ix21 * Iy12_Iz22
              dyz_dyz = dyz_dyz + Iy22 * Iz22
            end
          end
        end
      end
    end
    rys.destroy
    normcd.destroy

    px_  = px__dxx + DCx * px__px_
    py_  = py__dxx + DCx * py__px_
    pz_  = pz__dxx + DCx * pz__px_
    dxx_ = dxx_dxx + DCx * dxx_px_
    dyy_ = dyy_dxx + DCx * dyy_px_
    dzz_ = dzz_dxx + DCx * dzz_px_
    dxy_ = dxy_dxx + DCx * dxy_px_
    dxz_ = dxz_dxx + DCx * dxz_px_
    dyz_ = dyz_dxx + DCx * dyz_px_
    Iab => abcd(:,:,1,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxy + DCy * px__px_
    py_  = py__dxy + DCy * py__px_
    pz_  = pz__dxy + DCy * pz__px_
    dxx_ = dxx_dxy + DCy * dxx_px_
    dyy_ = dyy_dxy + DCy * dyy_px_
    dzz_ = dzz_dxy + DCy * dzz_px_
    dxy_ = dxy_dxy + DCy * dxy_px_
    dxz_ = dxz_dxy + DCy * dxz_px_
    dyz_ = dyz_dxy + DCy * dyz_px_
    Iab => abcd(:,:,2,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxz + DCz * px__px_
    py_  = py__dxz + DCz * py__px_
    pz_  = pz__dxz + DCz * pz__px_
    dxx_ = dxx_dxz + DCz * dxx_px_
    dyy_ = dyy_dxz + DCz * dyy_px_
    dzz_ = dzz_dxz + DCz * dzz_px_
    dxy_ = dxy_dxz + DCz * dxy_px_
    dxz_ = dxz_dxz + DCz * dxz_px_
    dyz_ = dyz_dxz + DCz * dyz_px_
    Iab => abcd(:,:,3,1)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxy + DCx * px__py_
    py_  = py__dxy + DCx * py__py_
    pz_  = pz__dxy + DCx * pz__py_
    dxx_ = dxx_dxy + DCx * dxx_py_
    dyy_ = dyy_dxy + DCx * dyy_py_
    dzz_ = dzz_dxy + DCx * dzz_py_
    dxy_ = dxy_dxy + DCx * dxy_py_
    dxz_ = dxz_dxy + DCx * dxz_py_
    dyz_ = dyz_dxy + DCx * dyz_py_
    Iab => abcd(:,:,1,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyy + DCy * px__py_
    py_  = py__dyy + DCy * py__py_
    pz_  = pz__dyy + DCy * pz__py_
    dxx_ = dxx_dyy + DCy * dxx_py_
    dyy_ = dyy_dyy + DCy * dyy_py_
    dzz_ = dzz_dyy + DCy * dzz_py_
    dxy_ = dxy_dyy + DCy * dxy_py_
    dxz_ = dxz_dyy + DCy * dxz_py_
    dyz_ = dyz_dyy + DCy * dyz_py_
    Iab => abcd(:,:,2,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyz + DCz * px__py_
    py_  = py__dyz + DCz * py__py_
    pz_  = pz__dyz + DCz * pz__py_
    dxx_ = dxx_dyz + DCz * dxx_py_
    dyy_ = dyy_dyz + DCz * dyy_py_
    dzz_ = dzz_dyz + DCz * dzz_py_
    dxy_ = dxy_dyz + DCz * dxy_py_
    dxz_ = dxz_dyz + DCz * dxz_py_
    dyz_ = dyz_dyz + DCz * dyz_py_
    Iab => abcd(:,:,3,2)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dxz + DCx * px__pz_
    py_  = py__dxz + DCx * py__pz_
    pz_  = pz__dxz + DCx * pz__pz_
    dxx_ = dxx_dxz + DCx * dxx_pz_
    dyy_ = dyy_dxz + DCx * dyy_pz_
    dzz_ = dzz_dxz + DCx * dzz_pz_
    dxy_ = dxy_dxz + DCx * dxy_pz_
    dxz_ = dxz_dxz + DCx * dxz_pz_
    dyz_ = dyz_dxz + DCx * dyz_pz_
    Iab => abcd(:,:,1,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dyz + DCy * px__pz_
    py_  = py__dyz + DCy * py__pz_
    pz_  = pz__dyz + DCy * pz__pz_
    dxx_ = dxx_dyz + DCy * dxx_pz_
    dyy_ = dyy_dyz + DCy * dyy_pz_
    dzz_ = dzz_dyz + DCy * dzz_pz_
    dxy_ = dxy_dyz + DCy * dxy_pz_
    dxz_ = dxz_dyz + DCy * dxz_pz_
    dyz_ = dyz_dyz + DCy * dyz_pz_
    Iab => abcd(:,:,2,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_

    px_  = px__dzz + DCz * px__pz_
    py_  = py__dzz + DCz * py__pz_
    pz_  = pz__dzz + DCz * pz__pz_
    dxx_ = dxx_dzz + DCz * dxx_pz_
    dyy_ = dyy_dzz + DCz * dyy_pz_
    dzz_ = dzz_dzz + DCz * dzz_pz_
    dxy_ = dxy_dzz + DCz * dxy_pz_
    dxz_ = dxz_dzz + DCz * dxz_pz_
    dyz_ = dyz_dzz + DCz * dyz_pz_
    Iab => abcd(:,:,3,3)
    Iab(1,1) = dxx_ + BAx * px_
    Iab(2,1) = dxy_ + BAy * px_
    Iab(3,1) = dxz_ + BAz * px_
    Iab(1,2) = dxy_ + BAx * py_
    Iab(2,2) = dyy_ + BAy * py_
    Iab(3,2) = dyz_ + BAz * py_
    Iab(1,3) = dxz_ + BAx * pz_
    Iab(2,3) = dyz_ + BAy * pz_
    Iab(3,3) = dzz_ + BAz * pz_
  end

  make_ppps(abcd) [private]
  ! Make the (pp|ps) integrals, summed over primitives.
    IN :: self
    MAT4, OUT :: abcd
    MAT3* :: Iabf
    Iabf.create(3,3,3)
    .make_ppps(Iabf)
    if (.c.l==0) then
      abcd(:,:,1,:) = Iabf
    else ! .d.l==0
      abcd(:,:,:,1) = Iabf
    end
    Iabf.destroy
  end

  make_ppps(Iabf) [private]
  ! Make the (pp|ps) integrals, summed over primitives.
    IN :: self
    MAT3, OUT :: Iabf
    RYS* :: rys
    VEC* :: normcd
    VEC(3) :: CD
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab,d_r2cd,r2cd
    DBL :: norma,normb,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz
    DBL :: ce,bb,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix21,Ix22,Ix31,Ix32
    DBL :: Iy12,Iy21,Iy22,Iy31,Iy32
    DBL :: Iz12,Iz21,Iz22,Iz31,Iz32
    DBL :: px__px_,py__px_,pz__px_
    DBL :: px__py_,py__py_,pz__py_
    DBL :: px__pz_,py__pz_,pz__pz_
    DBL :: dxx_px_,dyy_px_,dzz_px_,dxy_px_,dxz_px_,dyz_px_
    DBL :: dxx_py_,dyy_py_,dzz_py_,dxy_py_,dxz_py_,dyz_py_
    DBL :: dxx_pz_,dyy_pz_,dzz_pz_,dxy_pz_,dxz_pz_,dyz_pz_
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy31_Iz12,Iy12_Iz31,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy31_w, Iy32_w
    DBL :: BAx,BAy,BAz,DCx,DCy,DCz
    INT :: ag,bg,cg,dg,nroots,n,i

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    dxx_px_ = ZERO; dyy_px_ = ZERO; dzz_px_ = ZERO
    dxy_px_ = ZERO; dxz_px_ = ZERO; dyz_px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    dxx_py_ = ZERO; dyy_py_ = ZERO; dzz_py_ = ZERO
    dxy_py_ = ZERO; dxz_py_ = ZERO; dyz_py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    dxx_pz_ = ZERO; dyy_pz_ = ZERO; dzz_pz_ = ZERO
    dxy_pz_ = ZERO; dxz_pz_ = ZERO; dyz_pz_ = ZERO

    Ax = .a.pos(1);  Ay = .a.pos(2);  Az = .a.pos(3)
    Bx = .b.pos(1);  By = .b.pos(2);  Bz = .b.pos(3)
    Cx = .c.pos(1);  Cy = .c.pos(2);  Cz = .c.pos(3)
    Dx = .d.pos(1);  Dy = .d.pos(2);  Dz = .d.pos(3)
    BAx = Bx - Ax;   BAy = By - Ay;   BAz = Bz - Az
    DCx = Dx - Cx;   DCy = Dy - Cy;   DCz = Dz - Cz
    r2ab = BAx*BAx + BAy*BAy + BAz*BAz
    Atx = Bx;  Aty = By;  Atz = Bz
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    CD   = .c.pos - .d.pos
    r2cd = dot_product(CD,CD)

    normcd.create(.c.n_cc*.d.n_cc)
    i = 0
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      norm = .d.cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        i = i + 1
        c    = .c.ex(cg)
        einv = ONE / (c + d)
        normcd(i) = norm * .c.cc(cg) * einv * sqrt(einv) * exp(-c * d_r2cd * einv)
      end
    end

    nroots = (.a.l+.b.l+.c.l+.d.l+2)/2
    rys.create(nroots)
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = TWOPI5ON2 * .b.cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        a    = .a.ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a.cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        i = 0
        do dg = 1, .d.n_cc
          d   = .d.ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c.n_cc
            i = i + 1
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho_zinv) * normcd(i)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            QCx = Qx - Ctx;   QCy = Qy - Cty;   QCz = Qz - Ctz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rys.get_weights(xx)
            half_zinv = HALF * zinv
            half_einv = HALF * einv
            do n=1,nroots
              t2    = rys.r(n)
              w     = rys.w(n) * norm
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              ce    = (ONE - t2_rz) * half_zinv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix31 = Ix21 * Ix21 + ce
              Iy31 = Iy21 * Iy21 + ce
              Iz31 = Iz21 * Iz21 + ce
              Ix32 = Ix21 * Ix22 + ce * Ix12 + bb * Ix21
              Iy32 = Iy21 * Iy22 + ce * Iy12 + bb * Iy21
              Iz32 = Iz21 * Iz22 + ce * Iz12 + bb * Iz21

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz31 = Iz31 * w
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iz32 = Iz32 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy12_Iz12 = Iy12 * Iz12
              Iy12_Iz22 = Iy12 * Iz22
              Iy12_Iz31 = Iy12 * Iz31
              Iy21_Iz21 = Iy21 * Iz21
              Iy21_Iz22 = Iy21 * Iz22
              Iy21_Iz12 = Iy21 * Iz12
              Iy31_Iz12 = Iy31 * Iz12
              Iy22_Iz12 = Iy22 * Iz12
              Iy22_Iz21 = Iy22 * Iz21
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w
              Iy31_w    = Iy31 * w
              Iy32_w    = Iy32 * w

              px__px_ = px__px_ + Ix22 * w         ! combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12 * Iz21
              dxx_px_ = dxx_px_ + Ix32 * w
              dyy_px_ = dyy_px_ + Ix12 * Iy31_w
              dzz_px_ = dzz_px_ + Ix12 * Iz31
              dxy_px_ = dxy_px_ + Ix22 * Iy21_w
              dxz_px_ = dxz_px_ + Ix22 * Iz21
              dyz_px_ = dyz_px_ + Ix12 * Iy21_Iz21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              dxx_py_ = dxx_py_ + Ix31 * Iy12_w
              dyy_py_ = dyy_py_ + Iy32_w
              dzz_py_ = dzz_py_ + Iy12_Iz31
              dxy_py_ = dxy_py_ + Ix21 * Iy22_w
              dxz_py_ = dxz_py_ + Ix21 * Iy12_Iz21
              dyz_py_ = dyz_py_ + Iy22_Iz21
              px__pz_ = px__pz_ + Ix21 * Iz12
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22
              dxx_pz_ = dxx_pz_ + Ix31 * Iz12
              dyy_pz_ = dyy_pz_ + Iy31_Iz12
              dzz_pz_ = dzz_pz_ + Iz32
              dxy_pz_ = dxy_pz_ + Ix21 * Iy21_Iz12
              dxz_pz_ = dxz_pz_ + Ix21 * Iz22
              dyz_pz_ = dyz_pz_ + Iy21_Iz22
            end
          end
        end
      end
    end
    rys.destroy
    normcd.destroy

    Iabf(1,1,1) = dxx_px_ + BAx * px__px_
    Iabf(1,1,2) = dxx_py_ + BAx * px__py_
    Iabf(1,1,3) = dxx_pz_ + BAx * px__pz_
    Iabf(2,1,1) = dxy_px_ + BAy * px__px_
    Iabf(2,1,2) = dxy_py_ + BAy * px__py_
    Iabf(2,1,3) = dxy_pz_ + BAy * px__pz_
    Iabf(3,1,1) = dxz_px_ + BAz * px__px_
    Iabf(3,1,2) = dxz_py_ + BAz * px__py_
    Iabf(3,1,3) = dxz_pz_ + BAz * px__pz_
    Iabf(1,2,1) = dxy_px_ + BAx * py__px_
    Iabf(1,2,2) = dxy_py_ + BAx * py__py_
    Iabf(1,2,3) = dxy_pz_ + BAx * py__pz_
    Iabf(2,2,1) = dyy_px_ + BAy * py__px_
    Iabf(2,2,2) = dyy_py_ + BAy * py__py_
    Iabf(2,2,3) = dyy_pz_ + BAy * py__pz_
    Iabf(3,2,1) = dyz_px_ + BAz * py__px_
    Iabf(3,2,2) = dyz_py_ + BAz * py__py_
    Iabf(3,2,3) = dyz_pz_ + BAz * py__pz_
    Iabf(1,3,1) = dxz_px_ + BAx * pz__px_
    Iabf(1,3,2) = dxz_py_ + BAx * pz__py_
    Iabf(1,3,3) = dxz_pz_ + BAx * pz__pz_
    Iabf(2,3,1) = dyz_px_ + BAy * pz__px_
    Iabf(2,3,2) = dyz_py_ + BAy * pz__py_
    Iabf(2,3,3) = dyz_pz_ + BAy * pz__pz_
    Iabf(3,3,1) = dzz_px_ + BAz * pz__px_
    Iabf(3,3,2) = dzz_py_ + BAz * pz__py_
    Iabf(3,3,3) = dzz_pz_ + BAz * pz__pz_
  end

  make_pspp(abcd) [private]
  ! Make the (ps|pp) integrals, summed over primitives.
    IN :: self
    MAT4, OUT :: abcd
    MAT3* :: Iabf
    Iabf.create(3,3,3)
    .make_pspp(Iabf)
    if (.a.l==0) then
      abcd(1,:,:,:) = Iabf
    else ! .b.l==0
      abcd(:,1,:,:) = Iabf
    end
    Iabf.destroy
  end

  make_pspp(Iabf) [private]
  ! Make the (ps|pp) integrals, summed over primitives.
    IN :: self
    MAT3, OUT :: Iabf
    RYS* :: rys
    VEC* :: normcd
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab,d_r2cd,r2cd
    DBL :: norma,normb,norm,zinv,rho,einv,b_r2ab,rho_zinv,rho_einv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Qx,Qy,Qz,QCx,QCy,QCz
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz
    DBL :: cf,bb,t2,t2_rz,t2_re,w,half_zinv,half_einv
    DBL :: Ix12,Ix13,Ix21,Ix22,Ix23
    DBL :: Iy12,Iy13,Iy21,Iy22,Iy23
    DBL :: Iz12,Iz13,Iz21,Iz22,Iz23
    DBL :: px__px_,py__px_,pz__px_
    DBL :: px__py_,py__py_,pz__py_
    DBL :: px__pz_,py__pz_,pz__pz_
    DBL :: px__dxx,py__dxx,pz__dxx
    DBL :: px__dyy,py__dyy,pz__dyy
    DBL :: px__dzz,py__dzz,pz__dzz
    DBL :: px__dxy,py__dxy,pz__dxy
    DBL :: px__dxz,py__dxz,pz__dxz
    DBL :: px__dyz,py__dyz,pz__dyz
    DBL :: Iy12_Iz21,Iy12_Iz12,Iy13_Iz21,Iy21_Iz21,Iy21_Iz22
    DBL :: Iy21_Iz12,Iy21_Iz13,Iy12_Iz22
    DBL :: Iy22_Iz12,Iy22_Iz21
    DBL :: Iy12_w, Iy21_w, Iy22_w, Iy13_w, Iy23_w
    DBL :: BAx,BAy,BAz,DCx,DCy,DCz
    INT :: ag,bg,cg,dg,nroots,n,i

    px__px_ = ZERO; py__px_ = ZERO; pz__px_ = ZERO
    px__py_ = ZERO; py__py_ = ZERO; pz__py_ = ZERO
    px__pz_ = ZERO; py__pz_ = ZERO; pz__pz_ = ZERO
    px__dxx = ZERO; py__dxx = ZERO; pz__dxx = ZERO
    px__dyy = ZERO; py__dyy = ZERO; pz__dyy = ZERO
    px__dzz = ZERO; py__dzz = ZERO; pz__dzz = ZERO
    px__dxy = ZERO; py__dxy = ZERO; pz__dxy = ZERO
    px__dxz = ZERO; py__dxz = ZERO; pz__dxz = ZERO
    px__dyz = ZERO; py__dyz = ZERO; pz__dyz = ZERO

    Ax = .a.pos(1);  Ay = .a.pos(2);  Az = .a.pos(3)
    Bx = .b.pos(1);  By = .b.pos(2);  Bz = .b.pos(3)
    Cx = .c.pos(1);  Cy = .c.pos(2);  Cz = .c.pos(3)
    Dx = .d.pos(1);  Dy = .d.pos(2);  Dz = .d.pos(3)
    BAx = Bx - Ax;   BAy = By - Ay;   BAz = Bz - Az
    DCx = Dx - Cx;   DCy = Dy - Cy;   DCz = Dz - Cz
    r2ab = BAx*BAx + BAy*BAy + BAz*BAz
    if (.a.l > .b.l) then
      Atx = Ax;  Aty = Ay;  Atz = Az
    else
      Atx = Bx;  Aty = By;  Atz = Bz
    end
    Ctx = Dx;  Cty = Dy;  Ctz = Dz

    r2cd = DCx*DCx + DCy*DCy + DCz*DCz

    normcd.create(.c.n_cc*.d.n_cc)
    i = 0
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      norm = .d.cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        i = i + 1
        c    = .c.ex(cg)
        einv = ONE / (c + d)
        normcd(i) = norm * .c.cc(cg) * einv * sqrt(einv) * exp(-c * d_r2cd * einv)
      end
    end

    nroots = (.a.l+.b.l+.c.l+.d.l+2)/2
    rys.create(nroots)
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = TWOPI5ON2 * .b.cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        a    = .a.ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a.cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        i = 0
        do dg = 1, .d.n_cc
          d   = .d.ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c.n_cc
            i = i + 1
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho_zinv) * normcd(i)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            QCx = Qx - Ctx;   QCy = Qy - Cty;   QCz = Qz - Ctz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rys.get_weights(xx)
            half_zinv = HALF * zinv
            half_einv = HALF * einv
            do n=1,nroots
              t2    = rys.r(n)
              w     = rys.w(n) * norm
              t2_rz = t2 * rho_zinv
              t2_re = t2 * rho_einv
              bb    = t2_rz * half_einv
              cf    = (ONE - t2_re) * half_einv
              Ix12 = QCx - t2_re * QPx           ! form 2 dimensional integrals.
              Iy12 = QCy - t2_re * QPy
              Iz12 = QCz - t2_re * QPz
              Ix21 = PAx + t2_rz * QPx
              Iy21 = PAy + t2_rz * QPy
              Iz21 = PAz + t2_rz * QPz
              Ix22 = Ix12 * Ix21 + bb
              Iy22 = Iy12 * Iy21 + bb
              Iz22 = Iz12 * Iz21 + bb
              Ix13 = Ix12 * Ix12 + cf
              Iy13 = Iy12 * Iy12 + cf
              Iz13 = Iz12 * Iz12 + cf
              Ix23 = Ix12 * Ix22 + cf * Ix21 + bb * Ix12
              Iy23 = Iy12 * Iy22 + cf * Iy21 + bb * Iy12
              Iz23 = Iz12 * Iz22 + cf * Iz21 + bb * Iz12

              Iz21 = Iz21 * w    ! Merge the weights and reduce multiplications.
              Iz12 = Iz12 * w
              Iz22 = Iz22 * w
              Iz13 = Iz13 * w
              Iz23 = Iz23 * w
              Iy12_Iz21 = Iy12 * Iz21
              Iy12_Iz12 = Iy12 * Iz12
              Iy12_Iz22 = Iy12 * Iz22
              Iy13_Iz21 = Iy13 * Iz21
              Iy21_Iz21 = Iy21 * Iz21
              Iy21_Iz22 = Iy21 * Iz22
              Iy21_Iz12 = Iy21 * Iz12
              Iy21_Iz13 = Iy21 * Iz13
              Iy22_Iz12 = Iy22 * Iz12
              Iy22_Iz21 = Iy22 * Iz21
              Iy12_w    = Iy12 * w
              Iy21_w    = Iy21 * w
              Iy22_w    = Iy22 * w
              Iy13_w    = Iy13 * w
              Iy23_w    = Iy23 * w

              px__px_ = px__px_ + Ix22 * w     ! combine 2d ints.
              py__px_ = py__px_ + Ix12 * Iy21_w
              pz__px_ = pz__px_ + Ix12 * Iz21
              px__py_ = px__py_ + Ix21 * Iy12_w
              py__py_ = py__py_ + Iy22_w
              pz__py_ = pz__py_ + Iy12_Iz21
              px__pz_ = px__pz_ + Ix21 * Iz12
              py__pz_ = py__pz_ + Iy21_Iz12
              pz__pz_ = pz__pz_ + Iz22
              px__dxx = px__dxx + Ix23 * w
              py__dxx = py__dxx + Ix13 * Iy21_w
              pz__dxx = pz__dxx + Ix13 * Iz21
              px__dyy = px__dyy + Ix21 * Iy13_w
              py__dyy = py__dyy + Iy23_w
              pz__dyy = pz__dyy + Iy13_Iz21
              px__dzz = px__dzz + Ix21 * Iz13
              py__dzz = py__dzz + Iy21_Iz13
              pz__dzz = pz__dzz + Iz23
              px__dxy = px__dxy + Ix22 * Iy12_w
              py__dxy = py__dxy + Ix12 * Iy22_w
              pz__dxy = pz__dxy + Ix12 * Iy12_Iz21
              px__dxz = px__dxz + Ix22 * Iz12
              py__dxz = py__dxz + Ix12 * Iy21_Iz12
              pz__dxz = pz__dxz + Ix12 * Iz22
              px__dyz = px__dyz + Ix21 * Iy12_Iz12
              py__dyz = py__dyz + Iy22_Iz12
              pz__dyz = pz__dyz + Iy12_Iz22
            end
          end
        end
      end
    end
    rys.destroy
    normcd.destroy

    Iabf(1,1,1) = px__dxx + DCx * px__px_
    Iabf(2,1,1) = py__dxx + DCx * py__px_
    Iabf(3,1,1) = pz__dxx + DCx * pz__px_
    Iabf(1,2,1) = px__dxy + DCy * px__px_
    Iabf(2,2,1) = py__dxy + DCy * py__px_
    Iabf(3,2,1) = pz__dxy + DCy * pz__px_
    Iabf(1,3,1) = px__dxz + DCz * px__px_
    Iabf(2,3,1) = py__dxz + DCz * py__px_
    Iabf(3,3,1) = pz__dxz + DCz * pz__px_
    Iabf(1,1,2) = px__dxy + DCx * px__py_
    Iabf(2,1,2) = py__dxy + DCx * py__py_
    Iabf(3,1,2) = pz__dxy + DCx * pz__py_
    Iabf(1,2,2) = px__dyy + DCy * px__py_
    Iabf(2,2,2) = py__dyy + DCy * py__py_
    Iabf(3,2,2) = pz__dyy + DCy * pz__py_
    Iabf(1,3,2) = px__dyz + DCz * px__py_
    Iabf(2,3,2) = py__dyz + DCz * py__py_
    Iabf(3,3,2) = pz__dyz + DCz * pz__py_
    Iabf(1,1,3) = px__dxz + DCx * px__pz_
    Iabf(2,1,3) = py__dxz + DCx * py__pz_
    Iabf(3,1,3) = pz__dxz + DCx * pz__pz_
    Iabf(1,2,3) = px__dyz + DCy * px__pz_
    Iabf(2,2,3) = py__dyz + DCy * py__pz_
    Iabf(3,2,3) = pz__dyz + DCy * pz__pz_
    Iabf(1,3,3) = px__dzz + DCz * px__pz_
    Iabf(2,3,3) = py__dzz + DCz * py__pz_
    Iabf(3,3,3) = pz__dzz + DCz * pz__pz_
  end

  make_psps(abcd) [private]
  ! Makes the (ps|ps) integrals, summed over primitives.
    IN :: self
    MAT4, OUT:: abcd
    MAT(3,3) :: psps
    .make_psps(psps)
    if (.a.l == 1) then
      if (.c.l ==1) then
        abcd(:,1,:,1) = psps ! psps
      else
        abcd(:,1,1,:) = psps ! pssp
      end
    else
      if (.c.l ==1) then
        abcd(1,:,:,1) = psps ! spps
      else
        abcd(1,:,1,:) = psps ! spsp
      end
    end
  end

  make_psps(psps) [private]
  ! Makes the (ps|ps) integrals, summed over primitives.
  ! Does ps|ps, ps|sp, sp|ps, sp|sp.
    IN :: self
    MAT, OUT:: psps
    RYS* :: rysa
    VEC* :: normcd
    VEC(3) :: AB,CD
    DBL :: a,b,c,d,zeta,kab,eta,xx,r2ab,d_r2cd,r2cd
    DBL :: norma,normb,zinv,rho,einv,norm,half_zinv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,PAx,PAy,PAz
    DBL :: root,tmp2,tmp3,tmp4,weight,b_r2ab
    DBL :: Iz11,Ix12,Iy12,Iz12,Ix21,Iy21,Iz21,Ix22,Iy22,Iz22
    DBL :: Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: Px,Py,Pz,Qx,Qy,Qz,bBx,bBy,bBz,dDx,dDy,dDz
    DBL :: Ctx,Cty,Ctz,Atx,Aty,Atz,rho_zinv,rho_einv
    DBL :: psps11,psps12,psps13,psps21,psps22,psps23,psps31,psps32,psps33
    INT :: ag,bg,cg,dg,n,i


    AB = .a.pos - .b.pos
    CD   = .c.pos - .d.pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)

    Ax = .a.pos(1);  Ay = .a.pos(2);  Az = .a.pos(3)
    Bx = .b.pos(1);  By = .b.pos(2);  Bz = .b.pos(3)
    Cx = .c.pos(1);  Cy = .c.pos(2);  Cz = .c.pos(3)
    Dx = .d.pos(1);  Dy = .d.pos(2);  Dz = .d.pos(3)
    if (.a.l > .b.l) then
      Atx = Ax;  Aty = Ay;  Atz = Az
    else
      Atx = Bx;  Aty = By;  Atz = Bz
    end
    if (.c.l > .d.l) then
      Ctx = Cx;  Cty = Cy;  Ctz = Cz
    else
      Ctx = Dx;  Cty = Dy;  Ctz = Dz
    end

    rysa.create(2)

    normcd.create(.c.n_cc*.d.n_cc)
    i = 0
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      norm = .d.cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        i = i + 1
        c    = .c.ex(cg)
        einv = ONE / (c + d)
        normcd(i) = norm * .c.cc(cg) * einv * sqrt(einv) * exp(-c * d_r2cd * einv)
      end
    end

    psps11=ZERO; psps12=ZERO; psps13=ZERO
    psps21=ZERO; psps22=ZERO; psps23=ZERO
    psps31=ZERO; psps32=ZERO; psps33=ZERO
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = TWOPI5ON2 * .b.cc(bg)
      bBx   = b*Bx;  bBy  = b*By;  bBz  = b*Bz
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        a    = .a.ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        half_zinv = HALF * zinv
        kab  = sqrt(zinv) * zinv * exp(-a * b_r2ab * zinv)
        norma = normb * .a.cc(ag) * kab
        Px   = (bBx + a* Ax) * zinv
        Py   = (bBy + a* Ay) * zinv
        Pz   = (bBz + a* Az) * zinv
        PAx  = Px - Atx;  PAy  = Py - Aty;  PAz  = Pz - Atz
        i = 0
        do dg = 1, .d.n_cc
          d     = .d.ex(dg)
          dDx = d*Dx; dDy = d*Dy; dDz = d*Dz
          do cg = 1, .c.n_cc
            i = i + 1
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE / eta
            Qx   = (dDx + c * Cx) * einv
            Qy   = (dDy + c * Cy) * einv
            Qz   = (dDz + c * Cz) * einv
            QCx  = Qx - Ctx;  QCy  = Qy - Cty;  QCz  = Qz - Ctz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            rho_einv = rho * einv
            norm = norma * sqrt(rho)*normcd(i)
            QPx  = Qx - Px;   QPy  = Qy - Py;   QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)  ! xx = rho QP^2
            rysa.get_weights(xx)
            do n=1,2
              root = rysa.r(n)
              tmp2 = root * rho_zinv
              tmp3 = root * rho_einv
              tmp4 = tmp3 * half_zinv
              Ix12 = QCx - tmp3 * QPx
              Iy12 = QCy - tmp3 * QPy
              Iz12 = QCz - tmp3 * QPz
              Ix21 = PAx + tmp2 * QPx
              Iy21 = PAy + tmp2 * QPy
              Iz21 = PAz + tmp2 * QPz
              Ix22 = Ix12 * Ix21 + tmp4
              Iy22 = Iy12 * Iy21 + tmp4
              Iz22 = Iz12 * Iz21 + tmp4
              weight = rysa.w(n) * norm      ! Merge the wieghts and
              Iz11 =        weight           ! normalization into Iz.
              Iz12 = Iz12 * weight
              Iz21 = Iz21 * weight
              Iz22 = Iz22 * weight
              psps11 = psps11 + (Ix22        * Iz11)
              psps21 = psps21 + (Ix12 * Iy21 * Iz11)
              psps31 = psps31 + (Ix12        * Iz21)
              psps12 = psps12 + (Ix21 * Iy12 * Iz11)
              psps22 = psps22 + (       Iy22 * Iz11)
              psps32 = psps32 + (       Iy12 * Iz21)
              psps13 = psps13 + (Ix21        * Iz12)
              psps23 = psps23 + (       Iy21 * Iz12)
              psps33 = psps33 + (              Iz22)
            end
          end
        end
      end
    end
    psps(1,1) = psps11
    psps(2,1) = psps21
    psps(3,1) = psps31
    psps(1,2) = psps12
    psps(2,2) = psps22
    psps(3,2) = psps32
    psps(1,3) = psps13
    psps(2,3) = psps23
    psps(3,3) = psps33
    normcd.destroy
    rysa.destroy
  end

  make_abss(abcd) [private]
  ! Makes the (ab|ss) integrals, summed over primitives.
    IN :: self
    MAT4, OUT:: abcd
    MAT* :: abss
    abss.create(size(abcd,1),size(abcd,2))
    .make_abss(abss)
    abcd(:,:,1,1) = abss(:,:)
    abss.destroy
  end

  make_abss(abcd)
  ! Makes the (ab|ss) integrals, summed over primitives.
    IN :: self
    MAT, OUT :: abcd
    VEC* :: esss
    SHELL2* :: sh
    INT :: n_e,eub
    n_e = .a.l + .b.l
    eub = n_e.n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
    esss.create(eub)
    .make_esss(esss)
    sh.create(.a,.b)
    sh.transfer(esss,abcd)
    sh.normalize(abcd)
    sh.destroy
    esss.destroy
  end

  make_asss(asss) [private]
  ! Makes the (as|ss) or (sb|ss) integrals, summed over primitives.
    VEC, OUT :: asss
    VEC* :: norm
    INT :: n_e,eub
    n_e = .a.l + .b.l
    eub = n_e.n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
    .make_esss(asss)
    if (n_e > 1) then
      norm.create(eub);   norm.normalizing_factors(n_e)
      asss = asss * norm
      norm.destroy
    end
  end

  make_esss(esss) [private]
  ! Makes the (es|ss) integrals, summed over primitives.
    IN :: self
    VEC, OUT :: esss
    VEC* :: Izz,normcd
    MAT* :: Ix,Iy,Iz,Iyz
    IMAT* :: e_powers
    IVEC* :: ex,ey,ez,ii_ivec
    RYS* :: rysa
    VEC(3) :: AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,rho,xx,r2ab,d_r2cd,r2cd
    DBL :: norma,normb,norm,b_r2ab,rho_zinv,half_zinv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Atx,Aty,Atz,a_zinv,c_einv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: rzt,ce1,rzthze
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,wt
    DBL :: Ixe,Ixe1,Iye,Iye1,Ize,Ize1,Ixep1,Iyep1,Izep1
    INT :: ag,bg,cg,dg,n_e,nroots,eub,maxl,dim,minl
    INT :: ep1,n,dim1,dim2,x,y,z,ii,e,i
    BIN :: apply_rms

    n_e = .a.l + .b.l
    maxl = max(.a.l,.b.l)
    minl = min(.a.l,.b.l)
    dim = n_e+1
    dim1 = n_e+2
    dim2 = 2*dim1+1
    eub = n_e.n_comp_sum - (maxl-1).n_comp_sum

    nroots = (dim1) / 2
    rysa.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*dim1/2)

    e_powers.create(eub,3)
    ex => e_powers(:,1); ey => e_powers(:,2); ez => e_powers(:,3)
    maxl.make_gaussian_xyz_indices(ex,ey,ez,n_e)
    apply_rms = minl > 2
    if (apply_rms) then
      ii_ivec.create(eub)
      do e=1,eub
        z = ez(e)
        ii_ivec(e) = -dim1 + z*(dim2-z)/2 + ey(e)
      end
    end

    AB   = .a.pos - .b.pos
    r2ab = dot_product(AB,AB)
    CD   = .c.pos - .d.pos
    r2cd = dot_product(CD,CD)
    Ax = .a.pos(1); Ay = .a.pos(2); Az = .a.pos(3)
    Bx = .b.pos(1); By = .b.pos(2); Bz = .b.pos(3)
    Cx = .c.pos(1); Cy = .c.pos(2); Cz = .c.pos(3)
    Dx = .d.pos(1); Dy = .d.pos(2); Dz = .d.pos(3)
    if (.a.l > .b.l) then
      Atx = Ax; Aty = Ay; Atz = Az
    else
      Atx = Bx; Aty = By; Atz = Bz
    end

    normcd.create(.c.n_cc*.d.n_cc)
    i = 0
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      norm = .d.cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        c    = .c.ex(cg)
        einv = ONE / (c + d)
        i = i + 1
        normcd(i) = norm * .c.cc(cg) * einv * sqrt(einv) * exp(-c * d_r2cd * einv)
      end
    end

    esss = ZERO
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = TWOPI5ON2 * .b.cc(bg)
      b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        a     = .a.ex(ag)
        zeta  = a + b
        zinv  = ONE / zeta
        a_zinv = a * zinv
        half_zinv = HALF * zinv
        kab   = exp(- a_zinv * b_r2ab)
        norma = normb * .a.cc(ag) * kab * zinv
        Px    = b_Bx * zinv + a_zinv * Ax
        Py    = b_By * zinv + a_zinv * Ay
        Pz    = b_Bz * zinv + a_zinv * Az
        PAx = Px - Atx; PAy = Py - Aty; PAz = Pz - Atz
        i = 0
        do dg = 1, .d.n_cc
          d     = .d.ex(dg)
          d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
          do cg = 1, .c.n_cc
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE / eta
            c_einv = c * einv
            Qx   = d_Dx * einv + c_einv * Cx
            Qy   = d_Dy * einv + c_einv * Cy
            Qz   = d_Dz * einv + c_einv * Cz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            i = i + 1
            norm = norma * sqrt(rho_zinv) * normcd(i)
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            rysa.w = rysa.w * norm

            ! Form the 2 dimensional integrals
            do n=1,nroots
              wt = rysa.w(n)
              rzt      = rysa.r(n) * rho_zinv
              rzthze   = (ONE - rzt) * half_zinv
              Ix2 = PAx + rzt * QPx
              Iy2 = PAy + rzt * QPy
              Iz2 = PAz + rzt * QPz
              Ix3 = Ix2 * Ix2 + rzthze
              Iy3 = Iy2 * Iy2 + rzthze
              Iz3 = Iz2 * Iz2 + rzthze
              Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = wt
              Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2 * wt
              Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3 * wt

              Ixe = Ix3;    Iye = Iy3;    Ize = Iz3
              Ixe1 = Ix2;   Iye1 = Iy2;   Ize1 = Iz2
              do ep1 = 4, n_e+1
                ce1 = (ep1-2) * rzthze
                Ixep1 = Ix2 * Ixe + ce1 * Ixe1
                Iyep1 = Iy2 * Iye + ce1 * Iye1
                Izep1 = Iz2 * Ize + ce1 * Ize1
                Ix(n,ep1) = Ixep1;   Iy(n,ep1) = Iyep1;   Iz(n,ep1) = Izep1 * wt
                Ixe1 = Ixe;   Iye1 = Iye;   Ize1 = Ize    ! for next iteration
                Ixe = Ixep1;  Iye = Iyep1;  Ize = Izep1   ! for next iteration
              end
            end

            if (apply_rms) then
              ! Apply the reduced multiplication scheme.
              ii = 0
              do z=1,dim
                Izz => Iz(:,z)
                do y=1,dim1-z
                  ii = ii + 1
                  Iyz(:,ii) = Izz * Iy(:,y)
                end
              end
              do e=1,eub
                esss(e) = esss(e) + sum(Ix(:,ex(e)) * Iyz(:,ii_ivec(e)))
              end
            else
              do e=1,eub
                esss(e) = esss(e) + sum(Ix(:,ex(e)) * Iy(:,ey(e)) * Iz(:,ez(e)))
              end
            end
          end
        end
      end
    end
    normcd.destroy
    if (apply_rms) ii_ivec.destroy
    e_powers.destroy
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rysa.destroy
  end

  make_sscd(abcd) [private]
  ! Makes the (ss|cd) integrals, summed over primitives.
    IN :: self
    MAT4, OUT:: abcd
    MAT* :: sscd
    sscd.create(size(abcd,3),size(abcd,4))
    .make_sscd(sscd)
    abcd(1,1,:,:) = sscd(:,:)
    sscd.destroy
  end

  make_sscd(sscd) [private]
  ! Makes the (ss|cd) integrals, summed over primitives.
    IN :: self
    MAT, OUT:: sscd
    VEC* :: ssfs
    SHELL2* :: sh
    INT :: n_f,fub
    n_f = .c.l + .d.l
    fub = n_f.n_comp_sum - (max(.c.l,.d.l)-1).n_comp_sum
    ssfs.create(fub)
    .make_ssfs(ssfs)
    sh.create(.c,.d)
    sh.transfer(ssfs,sscd)
    sh.normalize(sscd)
    sh.destroy
    ssfs.destroy
  end

  make_sscs(sscs) [private]
  ! Makes the (ss|cs) or (ss|sd) integrals, summed over primitives.
    IN :: self
    VEC, OUT:: sscs
    VEC* :: norm
    INT :: n_f,fub
    n_f = .c.l + .d.l
    fub = n_f.n_comp
    .make_ssfs(sscs)
    if (n_f > 1) then
      norm.create(fub);   norm.normalizing_factors(n_f)
      sscs = sscs * norm
      norm.destroy
    end
  end

  make_ssfs(ssfs) [private]
  ! Makes the (ss|cd) integrals, summed over primitives.
    IN :: self
    VEC, OUT:: ssfs
    VEC* :: Izz,normab
    MAT* :: Ix,Iy,Iz,Iyz
    RYS* :: rysa
    IMAT* :: f_powers
    IVEC* :: fx,fy,fz,ii_ivec
    VEC(3) :: AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab,rho_einv,half_einv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,Ctx,Cty,Ctz,c_einv,a_zinv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3
    DBL :: Ixf,Ixf1,Iyf,Iyf1,Izf,Izf1,Ixfp1,Iyfp1,Izfp1
    DBL :: ret,cf1,rethen,wt,ssfs_f
    INT :: ag,bg,cg,dg,n_f,nroots,fub,maxl,dim,minl,f,x,y,z
    INT :: fp1,n,xf,yf,zf,ii,dim1,dim2,i
    BIN :: apply_rms

    n_f = .c.l + .d.l
    maxl = max(.c.l,.d.l)
    minl = min(.c.l,.d.l)
    dim = n_f+1
    dim1 = n_f+2
    dim2 = 2*dim1+1
    fub = n_f.n_comp_sum - (maxl-1).n_comp_sum

    nroots = dim1/2
    rysa.create(nroots)
    Ix.create(nroots,dim)
    Iy.create(nroots,dim)
    Iz.create(nroots,dim)
    Iyz.create(nroots,dim*dim1/2)

    f_powers.create(fub,3)
    fx => f_powers(:,1); fy => f_powers(:,2); fz => f_powers(:,3)
    maxl.make_gaussian_xyz_indices(fx,fy,fz,n_f)
    apply_rms = minl > 2
    if (apply_rms) then
      ii_ivec.create(fub)
      do f=1,fub
        z = fz(f)
        ii_ivec(f) = -dim1 + z*(dim2-z)/2 + fy(f)
      end
    end

    AB = .a.pos - .b.pos
    CD = .c.pos - .d.pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    Ax = .a.pos(1); Ay = .a.pos(2); Az = .a.pos(3)
    Bx = .b.pos(1); By = .b.pos(2); Bz = .b.pos(3)
    Cx = .c.pos(1); Cy = .c.pos(2); Cz = .c.pos(3)
    Dx = .d.pos(1); Dy = .d.pos(2); Dz = .d.pos(3)
    if (.c.l > .d.l) then
      Ctx = Cx; Cty = Cy; Ctz = Cz
    else
      Ctx = Dx; Cty = Dy; Ctz = Dz
    end

    normab.create(.a.n_cc*.b.n_cc)
    i = 0
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = .b.cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        i = i + 1
        a    = .a.ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = exp(-a * b_r2ab * zinv)
        normab(i) = normb * .a.cc(ag) * zinv * sqrt(zinv) * kab
      end
    end

    ssfs=ZERO
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      normd = TWOPI5ON2 * .d.cc(dg)
      d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        c    = .c.ex(cg)
        eta  = c + d
        einv = ONE / eta
        half_einv = HALF * einv
        c_einv = c * einv
        kcd  = exp(- c_einv * d_r2cd)
        normc = normd * .c.cc(cg) * kcd * einv
        Qx   = d_Dx * einv + c_einv * Cx
        Qy   = d_Dy * einv + c_einv * Cy
        Qz   = d_Dz * einv + c_einv * Cz
        QCx  = Qx - Ctx
        QCy  = Qy - Cty
        QCz  = Qz - Ctz
        i = 0
        do bg = 1, .b.n_cc
          b     = .b.ex(bg)
          b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
          do ag = 1, .a.n_cc
            i = i + 1
            a     = .a.ex(ag)
            zeta  = a + b
            zinv  = ONE / zeta
            a_zinv = a * zinv
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            norm = normc * sqrt(rho_einv)*normab(i)
            Px    = b_Bx * zinv + a_zinv * Ax
            Py    = b_By * zinv + a_zinv * Ay
            Pz    = b_Bz * zinv + a_zinv * Az
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)

            ! Form the 2 dimensional integrals.
            do n=1,nroots
              ret     = rysa.r(n) * rho_einv
              rethen  = (ONE - ret) * half_einv
              Ix2 = QCx - ret * QPx
              Iy2 = QCy - ret * QPy
              Iz2 = QCz - ret * QPz
              Ix3 = Ix2 * Ix2 + rethen
              Iy3 = Iy2 * Iy2 + rethen
              Iz3 = Iz2 * Iz2 + rethen
              wt = rysa.w(n) * norm

              Ix(n,1) = ONE; Iy(n,1) = ONE; Iz(n,1) = wt
              Ix(n,2) = Ix2; Iy(n,2) = Iy2; Iz(n,2) = Iz2 * wt
              Ix(n,3) = Ix3; Iy(n,3) = Iy3; Iz(n,3) = Iz3 * wt

              Ixf = Ix3;    Iyf = Iy3;    Izf = Iz3
              Ixf1 = Ix2;   Iyf1 = Iy2;   Izf1 = Iz2
              do fp1 = 4, n_f+1
                cf1 = (fp1-2) * rethen
                Ixfp1 = Ix2 * Ixf + cf1 * Ixf1
                Iyfp1 = Iy2 * Iyf + cf1 * Iyf1
                Izfp1 = Iz2 * Izf + cf1 * Izf1
                Ix(n,fp1) = Ixfp1;   Iy(n,fp1) = Iyfp1;   Iz(n,fp1) = Izfp1 * wt
                Ixf1 = Ixf;   Iyf1 = Iyf;   Izf1 = Izf    ! for next iteration
                Ixf = Ixfp1;  Iyf = Iyfp1;  Izf = Izfp1   ! for next iteration
              end
            end

            if (apply_rms) then
              ! Apply the reduced multiplication scheme.
              ii = 0
              do z=1,dim
                Izz => Iz(:,z)
                do y=1,dim1-z
                  ii = ii + 1
                  Iyz(:,ii) = Izz * Iy(:,y)
                end
              end
              do f=1,fub
                ssfs(f) = ssfs(f) + sum(Ix(:,fx(f)) * Iyz(:,ii_ivec(f)))
              end
            else
              do f=1,fub
                ssfs(f) = ssfs(f) + sum(Ix(:,fx(f)) * Iy(:,fy(f)) * Iz(:,fz(f)))
              end
            end
          end
        end
      end
    end
    normab.destroy
    if (apply_rms) ii_ivec.destroy
    f_powers.destroy
    Iyz.destroy
    Iz.destroy
    Iy.destroy
    Ix.destroy
    rysa.destroy
  end

  make_ppss(abcd) [private]
  ! Creates the initial (pp|ss) integrals, summed over primitives.
    IN :: self
    MAT4, OUT:: abcd
    MAT(3,3) :: abss
    .make_ppss(abss)
    abcd(:,:,1,1) = abss(:,:)
  end

  make_ppss(abss) [private]
  ! Creates the initial (pp|ss) integrals, summed over primitives.
    IN :: self
    MAT, OUT:: abss
    RYS* :: rysa
    VEC* :: normcd
    VEC(3) :: CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,rho,xx,r2ab,r2cd
    DBL :: norma,normb,normd,norm,d_r2cd,b_r2ab,rho_zinv,half_zinv
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Atx,Aty,Atz,a_zinv,c_einv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: rzt,rzthze
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,w
    DBL :: px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyx_s
    DBL :: BAx,BAy,BAz
    INT :: ag,bg,cg,dg,n,i

    rysa.create(2)              ! nroots = 2

    CD   = .c.pos - .d.pos
    r2cd = dot_product(CD,CD)
    Ax = .a.pos(1); Ay = .a.pos(2); Az = .a.pos(3)
    Bx = .b.pos(1); By = .b.pos(2); Bz = .b.pos(3)
    Cx = .c.pos(1); Cy = .c.pos(2); Cz = .c.pos(3)
    Dx = .d.pos(1); Dy = .d.pos(2); Dz = .d.pos(3)
    BAx = Bx - Ax; BAy = By - Ay; BAz = Bz - Az;
    r2ab = BAx*BAx + BAy*BAy + BAz*BAz
    if (.a.l > .b.l) then
      Atx = Ax; Aty = Ay; Atz = Az
    else
      Atx = Bx; Aty = By; Atz = Bz
    end

    normcd.create(.c.n_cc*.d.n_cc)
    i = 0
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      normd = .d.cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        i = i + 1
        c    = .c.ex(cg)
        eta  = c + d
        einv = ONE / eta
        normcd(i) = normd * .c.cc(cg) * einv * sqrt(einv) * exp(-c * d_r2cd * einv)
      end
    end

    px_s  = ZERO; py_s  = ZERO; pz_s  = ZERO
    dxx_s = ZERO; dyy_s = ZERO; dzz_s = ZERO
    dxy_s = ZERO; dxz_s = ZERO; dyx_s = ZERO
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = TWOPI5ON2 * .b.cc(bg)
      b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        a     = .a.ex(ag)
        zeta  = a + b
        zinv  = ONE / zeta
        a_zinv = a * zinv
        half_zinv = HALF * zinv
        kab   = exp(- a_zinv * b_r2ab)
        norma = normb * .a.cc(ag) * kab * zinv
        Px    = b_Bx * zinv + a_zinv * Ax
        Py    = b_By * zinv + a_zinv * Ay
        Pz    = b_Bz * zinv + a_zinv * Az
        PAx = Px - Atx; PAy = Py - Aty; PAz = Pz - Atz
        i = 0
        do dg = 1, .d.n_cc
          d     = .d.ex(dg)
          d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
          do cg = 1, .c.n_cc
            i = i + 1
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE / eta
            c_einv = c * einv
            Qx   = d_Dx * einv + c_einv * Cx
            Qy   = d_Dy * einv + c_einv * Cy
            Qz   = d_Dz * einv + c_einv * Cz
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            norm = norma * sqrt(rho_zinv) * normcd(i)
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            do n=1,2
              rzt      = rysa.r(n) * rho_zinv
              rzthze   = (ONE - rzt) * half_zinv
              Ix2 = PAx + rzt * QPx
              Iy2 = PAy + rzt * QPy
              Iz2 = PAz + rzt * QPz
              Ix3 = Ix2 * Ix2 + rzthze
              Iy3 = Iy2 * Iy2 + rzthze
              Iz3 = Iz2 * Iz2 + rzthze

              w = rysa.w(n) * norm
              Iz2 = Iz2 * w
              Iz3 = Iz3 * w

              px_s  = px_s  + (Ix2 *         w)
              py_s  = py_s  + (      Iy2 *   w)
              pz_s  = pz_s  + (            Iz2)
              dxx_s = dxx_s + (Ix3 *         w)
              dyy_s = dyy_s + (      Iy3 *   w)
              dzz_s = dzz_s + (            Iz3)
              dxy_s = dxy_s + (Ix2 * Iy2 *   w)
              dxz_s = dxz_s + (Ix2 *       Iz2)
              dyx_s = dyx_s + (      Iy2 * Iz2)
            end
          end
        end
      end
    end
    normcd.destroy
    rysa.destroy

    ! Transfer equation.
    abss(1,1) = dxx_s + BAx * px_s
    abss(1,2) = dxy_s + BAx * py_s
    abss(1,3) = dxz_s + BAx * pz_s
    abss(2,1) = dxy_s + BAy * px_s
    abss(2,2) = dyy_s + BAy * py_s
    abss(2,3) = dyx_s + BAy * pz_s
    abss(3,1) = dxz_s + BAz * px_s
    abss(3,2) = dyx_s + BAz * py_s
    abss(3,3) = dzz_s + BAz * pz_s
  end

  make_sspp(abcd) [private]
  ! Creates the (ss|pp) integrals, summed over primitives.
    IN :: self
    MAT4, OUT:: abcd
    MAT(3,3) :: sscd
    .make_sspp(sscd)
    abcd(1,1,:,:) = sscd(:,:)
  end

  make_sspp(sscd) [private]
  ! Creates the (ss|pp) integrals, summed over primitives.
    IN :: self
    MAT, OUT:: sscd
    RYS* :: rysa
    VEC* :: normab
    VEC(3) :: AB
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab,rho_einv,half_einv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,Ctx,Cty,Ctz,c_einv,a_zinv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: ret,rethen
    DBL :: Ix2,Iy2,Iz2,Ix3,Iy3,Iz3,w
    DBL :: px_s,py_s,pz_s,dxx_s,dyy_s,dzz_s,dxy_s,dxz_s,dyz_s
    DBL :: DCx,DCy,DCz
    INT :: ag,bg,cg,dg,n,i

    rysa.create(2)

    AB   = .a.pos - .b.pos
    r2ab = dot_product(AB,AB)
    Ax = .a.pos(1); Ay = .a.pos(2); Az = .a.pos(3)
    Bx = .b.pos(1); By = .b.pos(2); Bz = .b.pos(3)
    Cx = .c.pos(1); Cy = .c.pos(2); Cz = .c.pos(3)
    Dx = .d.pos(1); Dy = .d.pos(2); Dz = .d.pos(3)
    DCx = Dx - Cx; DCy = Dy - Cy; DCz = Dz - Cz;
    r2cd = DCx*DCx + DCy*DCy + DCz*DCz
    if (.c.l > .d.l) then
      Ctx = Cx; Cty = Cy; Ctz = Cz
    else
      Ctx = Dx; Cty = Dy; Ctz = Dz
    end

    normab.create(.a.n_cc*.b.n_cc)
    i = 0
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = .b.cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        i = i + 1
        a    = .a.ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        normab(i) = normb * .a.cc(ag) * zinv * sqrt(zinv) * exp(-a * b_r2ab * zinv)
      end
    end

    px_s  = ZERO; py_s  = ZERO; pz_s  = ZERO
    dxx_s = ZERO; dyy_s = ZERO; dzz_s = ZERO
    dxy_s = ZERO; dxz_s = ZERO; dyz_s = ZERO
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      normd = TWOPI5ON2 * .d.cc(dg)
      d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        c    = .c.ex(cg)
        eta  = c + d
        einv = ONE / eta
        half_einv = HALF * einv
        c_einv = c * einv
        kcd  = exp(- c_einv * d_r2cd)
        normc = normd * .c.cc(cg) * kcd * einv
        Qx   = d_Dx * einv + c_einv * Cx
        Qy   = d_Dy * einv + c_einv * Cy
        Qz   = d_Dz * einv + c_einv * Cz
        QCx  = Qx - Ctx
        QCy  = Qy - Cty
        QCz  = Qz - Ctz
        i = 0
        do bg = 1, .b.n_cc
          b     = .b.ex(bg)
          b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
          do ag = 1, .a.n_cc
            i = i + 1
            a     = .a.ex(ag)
            zeta  = a + b
            zinv  = ONE / zeta
            a_zinv = a * zinv
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            norm = normc * sqrt(rho_einv)*normab(i)
            Px    = b_Bx * zinv + a_zinv * Ax
            Py    = b_By * zinv + a_zinv * Ay
            Pz    = b_Bz * zinv + a_zinv * Az
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            do n=1,2
              ret     = rysa.r(n) * rho_einv
              rethen  = (ONE - ret) * half_einv
              Ix2 = QCx - ret * QPx
              Iy2 = QCy - ret * QPy
              Iz2 = QCz - ret * QPz
              Ix3 = Ix2 * Ix2 + rethen
              Iy3 = Iy2 * Iy2 + rethen
              Iz3 = Iz2 * Iz2 + rethen
              w = rysa.w(n) * norm

              Iz2 = Iz2 * w
              Iz3 = Iz3 * w

              px_s  = px_s  + (Ix2 *         w)
              py_s  = py_s  + (      Iy2 *   w)
              pz_s  = pz_s  + (            Iz2)
              dxx_s = dxx_s + (Ix3 *         w)
              dyy_s = dyy_s + (      Iy3 *   w)
              dzz_s = dzz_s + (            Iz3)
              dxy_s = dxy_s + (Ix2 * Iy2 *   w)
              dxz_s = dxz_s + (Ix2 *       Iz2)
              dyz_s = dyz_s + (      Iy2 * Iz2)
            end
          end
        end
      end
    end
    normab.destroy
    rysa.destroy

    ! Transfer equation.
    sscd(1,1) = dxx_s + DCx * px_s
    sscd(1,2) = dxy_s + DCx * py_s
    sscd(1,3) = dxz_s + DCx * pz_s
    sscd(2,1) = dxy_s + DCy * px_s
    sscd(2,2) = dyy_s + DCy * py_s
    sscd(2,3) = dyz_s + DCy * pz_s
    sscd(3,1) = dxz_s + DCz * px_s
    sscd(3,2) = dyz_s + DCz * py_s
    sscd(3,3) = dzz_s + DCz * pz_s
  end

  make_psss(abcd) [private]
  ! Creates the (ps|ss) or (sp|ss) integrals, summed over  primitives.
    IN :: self
    MAT4, OUT:: abcd
    VEC(3) :: psss
    .make_psss(psss)
    abcd(1,1,1,1) = psss(1)
    if (.a.l == 1) then           ! psss
      abcd(2,1,1,1) = psss(2)
      abcd(3,1,1,1) = psss(3)
    else                          ! spss
      abcd(1,2,1,1) = psss(2)
      abcd(1,3,1,1) = psss(3)
    end
  end

  make_psss(psss) [private]
  ! Creates the initial (ps|ss) or (sp|ss) integrals, summed over the
  ! primitives.
    IN :: self
    VEC, OUT :: psss
    RYS* :: rysa
    VEC* :: normcd
    VEC(3) :: AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd,rho_zinv
    DBL :: norma,normb,normd,norm,rzt,d_r2cd,b_r2ab
    DBL :: QPx,QPy,QPz,PAx,PAy,PAz,Atx,Aty,Atz,a_zinv,c_einv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: psss1,psss2,psss3
    INT :: ag,bg,cg,dg,i

    rysa.create(1)

    AB   = .a.pos - .b.pos
    CD   = .c.pos - .d.pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)
    Ax = .a.pos(1); Ay = .a.pos(2); Az = .a.pos(3)
    Bx = .b.pos(1); By = .b.pos(2); Bz = .b.pos(3)
    Cx = .c.pos(1); Cy = .c.pos(2); Cz = .c.pos(3)
    Dx = .d.pos(1); Dy = .d.pos(2); Dz = .d.pos(3)
    if (.a.l > .b.l) then
      Atx = Ax; Aty = Ay; Atz = Az
    else
      Atx = Bx; Aty = By; Atz = Bz
    end

    normcd.create(.c.n_cc*.d.n_cc)
    i = 0
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      normd = .d.cc(dg)
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        i = i + 1
        c    = .c.ex(cg)
        eta  = c + d
        einv = ONE / eta
        kcd  = exp(-c * d_r2cd * einv)
        normcd(i) = normd * .c.cc(cg) * einv * sqrt(einv) * kcd
      end
    end

    psss1 = ZERO
    psss2 = ZERO
    psss3 = ZERO
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = TWOPI5ON2 * .b.cc(bg)
      b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        a     = .a.ex(ag)
        zeta  = a + b
        zinv  = ONE / zeta
        a_zinv = a * zinv
        kab   = exp(- a_zinv * b_r2ab)
        norma = normb * .a.cc(ag) * kab * zinv
        Px    = b_Bx * zinv + a_zinv * Ax
        Py    = b_By * zinv + a_zinv * Ay
        Pz    = b_Bz * zinv + a_zinv * Az
        PAx = Px - Atx; PAy = Py - Aty; PAz = Pz - Atz
        i = 0
        do dg = 1, .d.n_cc
          d     = .d.ex(dg)
          normd = norma * .d.cc(dg)
          d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
          d_r2cd = d * r2cd
          do cg = 1, .c.n_cc
            i = i + 1
            c    = .c.ex(cg)
            eta  = c + d
            einv = ONE / eta
            c_einv = c * einv
            Qx   = (d_Dx + c * Cx) * einv
            Qy   = (d_Dy + c * Cy) * einv
            Qz   = (d_Dz + c * Cz) * einv
            rho  = zeta * eta / (zeta + eta)
            rho_zinv = rho * zinv
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            rzt = rysa.r(1) * rho_zinv
            norm = norma * sqrt(rho_zinv) * normcd(i) * rysa.w(1)
            psss1 = psss1 + norm * (PAx + rzt * QPx)
            psss2 = psss2 + norm * (PAy + rzt * QPy)
            psss3 = psss3 + norm * (PAz + rzt * QPz)
          end
        end
      end
    end
    normcd.destroy
    rysa.destroy
    psss(1) = psss1
    psss(2) = psss2
    psss(3) = psss3
  end

  make_ssps(abcd) [private]
  ! Creates the (ss|ps) or (ss|sp) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT:: abcd
    VEC(3) :: ssps
    .make_ssps(ssps)
    abcd(1,1,1,1) = ssps(1)
    if (.c.l == 1) then           ! ssps
      abcd(1,1,2,1) = ssps(2)
      abcd(1,1,3,1) = ssps(3)
    else                          ! sssp
      abcd(1,1,1,2) = ssps(2)
      abcd(1,1,1,3) = ssps(3)
    end
  end

  make_ssps(ssps) [private]
  ! Creates the (ss|ps) or (ss|sp) integrals, summed over the primitives.
    IN :: self
    VEC, OUT:: ssps
    RYS* :: rysa
    VEC* :: normab
    VEC(3) :: AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd,ret
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab,rho_einv
    DBL :: QPx,QPy,QPz,QCx,QCy,QCz,Ctx,Cty,Ctz,c_einv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz
    DBL :: ssps1,ssps2,ssps3
    INT :: ag,bg,cg,dg,i

    rysa.create(1)

    AB = .a.pos - .b.pos
    CD = .c.pos - .d.pos
    r2ab=dot_product(AB,AB)
    r2cd=dot_product(CD,CD)
    Ax = .a.pos(1); Ay = .a.pos(2); Az = .a.pos(3)
    Bx = .b.pos(1); By = .b.pos(2); Bz = .b.pos(3)
    Cx = .c.pos(1); Cy = .c.pos(2); Cz = .c.pos(3)
    Dx = .d.pos(1); Dy = .d.pos(2); Dz = .d.pos(3)
    if (.c.l > .d.l) then
      Ctx = Cx; Cty = Cy; Ctz = Cz
    else
      Ctx = Dx; Cty = Dy; Ctz = Dz
    end

    normab.create(.a.n_cc*.b.n_cc)
    i = 0
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = .b.cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        i = i + 1
        a    = .a.ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        normab(i) = normb * .a.cc(ag) * zinv * sqrt(zinv) * exp(-a * b_r2ab * zinv)
      end
    end

    ssps1=ZERO
    ssps2=ZERO
    ssps3=ZERO
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      normd = TWOPI5ON2 * .d.cc(dg)
      d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        c    = .c.ex(cg)
        eta  = c + d
        einv = ONE / eta
        c_einv = c * einv
        kcd  = exp(- c_einv * d_r2cd)
        normc = normd * .c.cc(cg) * kcd * einv
        Qx   = d_Dx * einv + c_einv * Cx
        Qy   = d_Dy * einv + c_einv * Cy
        Qz   = d_Dz * einv + c_einv * Cz
        QCx  = Qx - Ctx
        QCy  = Qy - Cty
        QCz  = Qz - Ctz
        i = 0
        do bg = 1, .b.n_cc
          b     = .b.ex(bg)
          b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
          do ag = 1, .a.n_cc
            i = i + 1
            a     = .a.ex(ag)
            zeta  = a + b
            zinv  = ONE / zeta
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            Px    = (b_Bx + a * Ax) * zinv
            Py    = (b_By + a * Ay) * zinv
            Pz    = (b_Bz + a * Az) * zinv
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            ret = rysa.r(1) * rho_einv
            norm = normc * sqrt(rho_einv)* normab(i) * rysa.w(1)
            ssps1 = ssps1 + norm * (QCx - ret * QPx)
            ssps2 = ssps2 + norm * (QCy - ret * QPy)
            ssps3 = ssps3 + norm * (QCz - ret * QPz)
          end
        end
      end
    end
    normab.destroy
    rysa.destroy
    ssps(1) = ssps1
    ssps(2) = ssps2
    ssps(3) = ssps3
  end

  make_ssss(abcd) [private]
  ! Creates the (ss|ss) integrals, summed over the primitives.
    IN :: self
    MAT4, OUT :: abcd
    DBL :: ssss
    .make_ssss(ssss)
    abcd(1,1,1,1) = ssss
  end

  make_ssss(ssss) [private]
  ! Creates the (ss|ss) integrals, summed over the primitives.
    IN :: self
    DBL, OUT :: ssss
    RYS* :: rysa
    VEC* :: normab
    VEC(3) :: AB,CD
    DBL :: a,b,c,d,zeta,zinv,kab,eta,einv,kcd,rho,xx,r2ab,r2cd
    DBL :: normb,normc,normd,norm,d_r2cd,b_r2ab
    DBL :: QPx,QPy,QPz,c_einv,a_zinv
    DBL :: Qx,Qy,Qz,Px,Py,Pz,Ax,Ay,Az,Bx,By,Bz,Cx,Cy,Cz,Dx,Dy,Dz
    DBL :: d_Dx,d_Dy,d_Dz,b_Bx,b_By,b_Bz,rho_einv
    INT :: ag,bg,cg,dg,i

    rysa.create(1)

    AB   = .a.pos - .b.pos
    CD   = .c.pos - .d.pos
    r2ab = dot_product(AB,AB)
    r2cd = dot_product(CD,CD)
    Ax = .a.pos(1); Ay = .a.pos(2); Az = .a.pos(3)
    Bx = .b.pos(1); By = .b.pos(2); Bz = .b.pos(3)
    Cx = .c.pos(1); Cy = .c.pos(2); Cz = .c.pos(3)
    Dx = .d.pos(1); Dy = .d.pos(2); Dz = .d.pos(3)

    normab.create(.a.n_cc*.b.n_cc)
    i=0
    do bg = 1, .b.n_cc
      b     = .b.ex(bg)
      normb = .b.cc(bg)
      b_r2ab = b * r2ab
      do ag = 1, .a.n_cc
        a    = .a.ex(ag)
        zeta = a + b
        zinv = ONE / zeta
        kab  = exp(-a * b_r2ab * zinv)
        i=i+1
        normab(i) = normb * .a.cc(ag) * zinv * sqrt(zinv) * kab
      end
    end

    ssss = ZERO
    do dg = 1, .d.n_cc
      d     = .d.ex(dg)
      normd = TWOPI5ON2 * .d.cc(dg)
      d_Dx = d * Dx; d_Dy = d * Dy; d_Dz = d * Dz
      d_r2cd = d * r2cd
      do cg = 1, .c.n_cc
        c    = .c.ex(cg)
        eta  = c + d
        einv = ONE / eta
        c_einv = c * einv
        kcd  = exp(- c_einv * d_r2cd)
        normc = normd * .c.cc(cg) * kcd * einv
        Qx   = d_Dx * einv + c_einv * Cx
        Qy   = d_Dy * einv + c_einv * Cy
        Qz   = d_Dz * einv + c_einv * Cz
        i = 0
        do bg = 1, .b.n_cc
          b     = .b.ex(bg)
          b_Bx = b * Bx; b_By = b * By; b_Bz = b * Bz
          do ag = 1, .a.n_cc
            i = i + 1
            a     = .a.ex(ag)
            zeta  = a + b
            zinv  = ONE / zeta
            a_zinv = a * zinv
            rho  = zeta * eta / (zeta + eta)
            rho_einv = rho * einv
            norm = normc * sqrt(rho_einv)* normab(i)
            Px   = (b_Bx + a * Ax) * zinv
            Py   = (b_By + a * Ay) * zinv
            Pz   = (b_Bz + a * Az) * zinv
            QPx  = Qx - Px; QPy  = Qy - Py; QPz  = Qz - Pz
            xx   = rho * (QPx*QPx + QPy*QPy + QPz*QPz)       ! xx = rho QP^2
            rysa.get_weights(xx)
            ssss = ssss + norm * rysa.w(1)
          end
        end
      end
    end
    normab.destroy
    rysa.destroy
  end

  transfer_cd(esfs,escd)
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    if (.c.l > .d.l) then
      .transfer_l_c_highest(esfs,escd)
    else
      .transfer_l_d_highest(esfs,escd)
    end
  end

  transfer_ab(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    if (.a.l > .b.l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

  transfer_ab(escd,abcd)
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT, IN :: escd
    MAT3, OUT :: abcd
    if (.a.l > .b.l) then
      .transfer_l_a_highest(escd,abcd)
    else
      .transfer_l_b_highest(escd,abcd)
    end
  end

  transfer_l_c_highest(esfs,escd) [private]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3* :: int_new,int_old
    IMAT* :: components,components_c,components_d
    IMAT3* :: index_c,index_d
    IVEC* :: comp_to_use,component_to_use
    VEC(3) :: CD
    INT :: c,d,c1,c2,c3,d1,ld,cub,dub
    INT :: cx,cy,cz,dx,dy,dz,j,n_f,clb,dlb,tmp,e,eub
    DBL :: CDi,CDx,CDy,CDz,esfs_ec

    select case (.d.l)
      case (0)
        escd(:,:,1)=esfs

      case (1)
        clb = (.c.l-1).n_comp_sum
        eub = (.a.l+.b.l).n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
        CD   = .c.pos - .d.pos
        n_f  = .c.l + .d.l
        cub  = .c.n_comp

        components.create(3, n_f.n_comp_sum - clb)
        index_c.create(0,n_f,0,n_f,0,n_f)
        .c.l.make_gaussian_xyz_powers(components,n_f,index_c)

        CDx = CD(1); CDy = CD(2); CDz = CD(3)
        do c = 1, cub
          cx = components(1,c)
          cy = components(2,c)
          cz = components(3,c)
          c1 = index_c(cx+1,cy,cz)
          c2 = index_c(cx,cy+1,cz)
          c3 = index_c(cx,cy,cz+1)
          do e = 1, eub
            esfs_ec = esfs(e,c)
            escd(e,c,1) = esfs(e,c1) + CDx * esfs_ec
            escd(e,c,2) = esfs(e,c2) + CDy * esfs_ec
            escd(e,c,3) = esfs(e,c3) + CDz * esfs_ec
          end
        end
        components.destroy
        index_c.destroy

      case default
        clb  = (.c.l-1).n_comp_sum
        eub  = (.a.l+.b.l).n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
        CD   = .c.pos - .d.pos
        n_f  = .c.l + .d.l
        cub  = (n_f-1).n_comp_sum - clb

        index_c.create(0,n_f,0,n_f,0,n_f)
        index_d.create(0,n_f,0,n_f,0,n_f)
        components.create(3, n_f.n_comp_sum)
        comp_to_use.create( n_f.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_f,index_d,comp_to_use)
        .c.l.make_gaussian_xyz_power_index(index_c,n_f)
        components_c => components(:,clb+1:)

        nullify(int_new)
        int_new.create(eub,cub,3)

        CDx = CD(1); CDy = CD(2); CDz = CD(3)
        do c = 1, cub
          cx = components_c(1,c)
          cy = components_c(2,c)
          cz = components_c(3,c)
          c1 = index_c(cx+1,cy,cz)
          c2 = index_c(cx,cy+1,cz)
          c3 = index_c(cx,cy,cz+1)
          do e = 1, eub
            esfs_ec = esfs(e,c)
            int_new(e,c,1) = esfs(e,c1) + CDx * esfs_ec
            int_new(e,c,2) = esfs(e,c2) + CDy * esfs_ec
            int_new(e,c,3) = esfs(e,c3) + CDz * esfs_ec
          end
        end

        do ld=2, .d.l - 1
          dlb              = (ld-1).n_comp_sum
          dub              = ld.n_comp
          cub              = (n_f-ld).n_comp_sum - clb
          component_to_use => comp_to_use(dlb+1:dlb+dub)
          components_d     => components(:,dlb+1:dlb+dub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(eub,cub,dub)
          do d=1,dub
            dx = components_d(1,d)
            dy = components_d(2,d)
            dz = components_d(3,d)
            j=component_to_use(d)
            .subtract_from_component(dx,dy,dz,j)
            d1 = index_d(dx,dy,dz)
            CDi=CD(j)
            do c=1,cub
              cx = components_c(1,c)
              cy = components_c(2,c)
              cz = components_c(3,c)
              .add_to_component(cx,cy,cz,j)
              c1 = index_c(cx,cy,cz)
              int_new(:,c,d)=int_old(:,c1,d1)+CDi*int_old(:,c,d1)
            end
          end
          int_old.destroy
        end

        dlb              = (.d.l-1).n_comp_sum
        dub              = .d.n_comp
        cub              = .c.n_comp
        component_to_use => comp_to_use(dlb+1:dlb+dub)
        components_d     => components(:,dlb+1:dlb+dub)
        int_old          => int_new
        do d=1,dub
          dx = components_d(1,d)
          dy = components_d(2,d)
          dz = components_d(3,d)
          j=component_to_use(d)
          .subtract_from_component(dx,dy,dz,j)
          d1 = index_d(dx,dy,dz)
          CDi=CD(j)
          do c=1,cub
            cx = components_c(1,c)
            cy = components_c(2,c)
            cz = components_c(3,c)
            .add_to_component(cx,cy,cz,j)
            c1 = index_c(cx,cy,cz)
            escd(:,c,d)=int_old(:,c1,d1)+CDi*int_old(:,c,d1)
          end
        end
        int_old.destroy
        index_c.destroy
        index_d.destroy
        components.destroy
        comp_to_use.destroy
    end
  end

  transfer_l_d_highest(esfs,escd) [private]
  ! Applies the transfer equation to (es|fs) to give (es|cd)
    IN :: self
    MAT, IN :: esfs
    MAT3, OUT :: escd
    MAT3* :: int_new,int_old
    IMAT* :: components,components_c,components_d
    IMAT3* :: index_c,index_d
    IVEC* :: comp_to_use,component_to_use
    VEC(3) :: DC
    INT :: c,d,c1,d1,d2,d3,lc,cub,dub
    INT :: cx,cy,cz,dx,dy,dz,j,n_f,clb,dlb,tmp,e,eub
    DBL :: DCi,DCx,DCy,DCz,esfs_ed

    select case (.c.l)
      case (0)
        escd(:,1,:)=esfs

      case (1)
        dlb = (.d.l-1).n_comp_sum
        eub = (.a.l+.b.l).n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
        DC   = .d.pos - .c.pos
        n_f  = .c.l + .d.l
        dub  = .d.n_comp

        components.create(3, n_f.n_comp_sum - dlb)
        index_d.create(0,n_f,0,n_f,0,n_f)
        .d.l.make_gaussian_xyz_powers(components,n_f,index_d)

        DCx=DC(1); DCy=DC(2); DCz=DC(3)
        do d=1,dub
          dx = components(1,d)
          dy = components(2,d)
          dz = components(3,d)
          d1 = index_d(dx+1,dy,dz)
          d2 = index_d(dx,dy+1,dz)
          d3 = index_d(dx,dy,dz+1)
            escd(:,1,d)=esfs(:,d1)+DCx*esfs(:,d)
            escd(:,2,d)=esfs(:,d2)+DCy*esfs(:,d)
            escd(:,3,d)=esfs(:,d3)+DCz*esfs(:,d)
        end
        components.destroy
        index_d.destroy

      case default
        dlb = (.d.l-1).n_comp_sum
        eub = (.a.l+.b.l).n_comp_sum - (max(.a.l,.b.l)-1).n_comp_sum
        DC   = .d.pos - .c.pos
        n_f  = .c.l + .d.l
        dub  = (n_f-1).n_comp_sum - dlb

        index_c.create(0,n_f,0,n_f,0,n_f)
        index_d.create(0,n_f,0,n_f,0,n_f)
        components.create(3, n_f.n_comp_sum)
        comp_to_use.create( n_f.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_f,index_c,comp_to_use)
        .d.l.make_gaussian_xyz_power_index(index_d,n_f)
        components_d => components(:,dlb+1:)

        nullify(int_new)
        int_new.create(eub,dub,3)
        DCx=DC(1); DCy=DC(2); DCz=DC(3)
        do d=1,dub
          dx = components_d(1,d)
          dy = components_d(2,d)
          dz = components_d(3,d)
          d1 = index_d(dx+1,dy,dz)
          d2 = index_d(dx,dy+1,dz)
          d3 = index_d(dx,dy,dz+1)
            int_new(:,d,1)=esfs(:,d1)+DCx*esfs(:,d)
            int_new(:,d,2)=esfs(:,d2)+DCy*esfs(:,d)
            int_new(:,d,3)=esfs(:,d3)+DCz*esfs(:,d)
        end
        do lc=2, .c.l - 1
          clb              = (lc-1).n_comp_sum
          cub              = lc.n_comp
          dub              = (n_f-lc).n_comp_sum - dlb
          component_to_use => comp_to_use(clb+1:clb+cub)
          components_c     => components(:,clb+1:clb+cub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(eub,dub,cub)
          do c=1,cub
            cx = components_c(1,c)
            cy = components_c(2,c)
            cz = components_c(3,c)
            j=component_to_use(c)
            .subtract_from_component(cx,cy,cz,j)
            c1 = index_c(cx,cy,cz)
            DCi=DC(j)
            do d=1,dub
              dx = components_d(1,d)
              dy = components_d(2,d)
              dz = components_d(3,d)
              .add_to_component(dx,dy,dz,j)
              d1 = index_d(dx,dy,dz)
              int_new(:,d,c)=int_old(:,d1,c1)+DCi*int_old(:,d,c1)
            end
          end
          int_old.destroy
        end
        clb              = (.c.l-1).n_comp_sum
        cub              = .c.n_comp
        dub              = .d.n_comp
        component_to_use => comp_to_use(clb+1:clb+cub)
        components_c     => components(:,clb+1:clb+cub)
        int_old          => int_new
        do c=1,cub
          cx = components_c(1,c)
          cy = components_c(2,c)
          cz = components_c(3,c)
          j=component_to_use(c)
          .subtract_from_component(cx,cy,cz,j)
          c1 = index_c(cx,cy,cz)
          DCi=DC(j)
          do d=1,dub
            dx = components_d(1,d)
            dy = components_d(2,d)
            dz = components_d(3,d)
            .add_to_component(dx,dy,dz,j)
            d1 = index_d(dx,dy,dz)
            escd(:,c,d)=int_old(:,d1,c1)+DCi*int_old(:,d,c1)
          end
        end
        int_old.destroy
        index_c.destroy
        index_d.destroy
        components.destroy
        comp_to_use.destroy
    end
  end

  transfer_l_a_highest(escd,abcd) [private]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4* :: int_new,int_old
    IMAT* :: components,components_a,components_b
    IMAT3* :: index_a,index_b
    VEC(3) :: AB
    INT :: a,b,c,d,a1,a2,a3,b1,lb,aub,bub,cub,dub
    INT :: ax,ay,az,bx,by,bz,j,n_e,alb,blb,tmp
    DBL :: ABi,ABx,ABy,ABz,escd_acd
    IVEC* :: comp_to_use,component_to_use

    select case (.b.l)
      case (0)
        abcd(:,1,:,:)=escd

      case (1)
        alb = (.a.l-1).n_comp_sum
        AB   = .a.pos - .b.pos
        n_e  = .a.l + .b.l
        aub  = .a.n_comp
        cub  = .c.n_comp
        dub  = .d.n_comp

        components.create(3, n_e.n_comp_sum - alb)
        index_a.create(0,n_e,0,n_e,0,n_e)
        .a.l.make_gaussian_xyz_powers(components,n_e,index_a)

        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components(1,a)
          ay = components(2,a)
          az = components(3,a)
          a1 = index_a(ax+1,ay,az)
          a2 = index_a(ax,ay+1,az)
          a3 = index_a(ax,ay,az+1)
          do d=1,dub
            do c=1,cub
              escd_acd = escd(a,c,d)
              abcd(a,1,c,d)=escd(a1,c,d) + ABx * escd_acd
              abcd(a,2,c,d)=escd(a2,c,d) + ABy * escd_acd
              abcd(a,3,c,d)=escd(a3,c,d) + ABz * escd_acd
            end
          end
        end
        index_a.destroy
        components.destroy

      case default
        alb = (.a.l-1).n_comp_sum
        AB   = .a.pos - .b.pos
        n_e  = .a.l + .b.l
        aub  = (n_e-1).n_comp_sum - alb
        bub  = .b.n_comp
        cub  = .c.n_comp
        dub  = .d.n_comp

        index_b.create(0,n_e,0,n_e,0,n_e)
        index_a.create(0,n_e,0,n_e,0,n_e)
        components.create(3, n_e.n_comp_sum)
        comp_to_use.create( n_e.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_e,index_b,comp_to_use)
        tmp=.a.l; tmp.make_gaussian_xyz_power_index(index_a,n_e)
        components_a => components(:,alb+1:)

        nullify(int_new)
        int_new.create(cub,dub,bub,aub)
        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          a1 = index_a(ax+1,ay,az)
          a2 = index_a(ax,ay+1,az)
          a3 = index_a(ax,ay,az+1)
          do d=1,dub
            do c=1,cub
              escd_acd = escd(a,c,d)
              int_new(c,d,1,a)=escd(a1,c,d) + ABx * escd_acd
              int_new(c,d,2,a)=escd(a2,c,d) + ABy * escd_acd
              int_new(c,d,3,a)=escd(a3,c,d) + ABz * escd_acd
            end
          end
        end

        do lb=2, .b.l - 1
          blb              = (lb-1).n_comp_sum
          bub              = lb.n_comp
          aub              = (n_e-lb).n_comp_sum - alb
          component_to_use => comp_to_use(blb+1:blb+bub)
          components_b     => components(:,blb+1:blb+bub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(cub,dub,bub,aub)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            j = component_to_use(b)
            .subtract_from_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz)
            ABi=AB(j)
            do a=1,aub
              ax = components_a(1,a)
              ay = components_a(2,a)
              az = components_a(3,a)
              .add_to_component(ax,ay,az,j)
              a1 = index_a(ax,ay,az)
              int_new(:,:,b,a)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
            end
          end
          int_old.destroy
        end

        blb              = (.b.l-1).n_comp_sum
        bub              = .b.n_comp
        aub              = .a.n_comp
        component_to_use => comp_to_use(blb+1:blb+bub)
        components_b     => components(:,blb+1:blb+bub)
        int_old          => int_new
        do b=1,bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          j = component_to_use(b)
          .subtract_from_component(bx,by,bz,j)
          b1 = index_b(bx,by,bz)
          ABi=AB(j)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            .add_to_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az)
            abcd(a,b,:,:)=int_old(:,:,b1,a1) + ABi * int_old(:,:,b1,a)
          end
        end
        int_old.destroy
        comp_to_use.destroy
        components.destroy
        index_a.destroy
        index_b.destroy
    end
  end

  transfer_l_b_highest(escd,abcd) [private]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT3, IN :: escd
    MAT4, OUT :: abcd
    MAT4* :: int_new,int_old
    IMAT* :: components,components_a,components_b
    IMAT3* :: index_a,index_b
    VEC(3) :: BA
    INT :: a,b,c,d,a1,b1,b2,b3,la,aub,bub,cub,dub
    INT :: ax,ay,az,bx,by,bz,j,n_e,alb,blb,tmp
    DBL :: BAi,BAx,BAy,BAz,escd_bcd
    IVEC* :: comp_to_use,component_to_use

    select case (.a.l)
      case (0)
        abcd(1,:,:,:)=escd

      case (1)
        blb = (.b.l-1).n_comp_sum
        BA   = .b.pos - .a.pos
        n_e  = .a.l + .b.l
        bub  = .b.n_comp
        cub  = .c.n_comp
        dub  = .d.n_comp

        components.create(3, n_e.n_comp_sum - blb)
        index_b.create(0,n_e,0,n_e,0,n_e)
        .b.l.make_gaussian_xyz_powers(components,n_e,index_b)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components(1,b)
          by = components(2,b)
          bz = components(3,b)
          b1 = index_b(bx+1,by,bz)
          b2 = index_b(bx,by+1,bz)
          b3 = index_b(bx,by,bz+1)
          do d = 1, dub
            do c = 1, cub
              escd_bcd = escd(b,c,d)
              abcd(1,b,c,d) = escd(b1,c,d) + BAx * escd_bcd
              abcd(2,b,c,d) = escd(b2,c,d) + BAy * escd_bcd
              abcd(3,b,c,d) = escd(b3,c,d) + BAz * escd_bcd
            end
          end
        end

        components.destroy
        index_b.destroy

      case default
        blb = (.b.l-1).n_comp_sum
        BA   = .b.pos - .a.pos
        n_e  = .a.l + .b.l
        bub  = (n_e-1).n_comp_sum - blb
        aub  = .a.n_comp
        cub  = .c.n_comp
        dub  = .d.n_comp

        index_a.create(0,n_e,0,n_e,0,n_e)
        index_b.create(0,n_e,0,n_e,0,n_e)
        components.create(3, n_e.n_comp_sum)
        comp_to_use.create( n_e.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_e,index_a,comp_to_use)
        tmp=.b.l; tmp.make_gaussian_xyz_power_index(index_b,n_e)
        components_b => components(:,blb+1:)

        nullify(int_new)
        int_new.create(cub,dub,bub,aub)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          b1 = index_b(bx+1,by,bz)
          b2 = index_b(bx,by+1,bz)
          b3 = index_b(bx,by,bz+1)
          do c = 1, cub
            do d = 1, dub
              escd_bcd = escd(b,c,d)
              int_new(c,d,b,1) = escd(b1,c,d) + BAx * escd_bcd
              int_new(c,d,b,2) = escd(b2,c,d) + BAy * escd_bcd
              int_new(c,d,b,3) = escd(b3,c,d) + BAz * escd_bcd
            end
          end
        end

        do la=2, .a.l - 1
          alb              = (la-1).n_comp_sum
          aub              = la.n_comp
          bub              = (n_e-la).n_comp_sum - blb
          component_to_use => comp_to_use(alb+1:alb+aub)
          components_a     => components(:,alb+1:alb+aub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(cub,dub,bub,aub)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            j=component_to_use(a)
            .subtract_from_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az)
            BAi=BA(j)
            do b=1,bub
              bx = components_b(1,b)
              by = components_b(2,b)
              bz = components_b(3,b)
              .add_to_component(bx,by,bz,j)
              b1 = index_b(bx,by,bz)
              int_new(:,:,b,a)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
            end
          end
          int_old.destroy
        end

        alb              = (.a.l-1).n_comp_sum
        aub              = .a.n_comp
        bub              = .b.n_comp
        component_to_use => comp_to_use(alb+1:alb+aub)
        components_a     => components(:,alb+1:alb+aub)
        int_old          => int_new
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          j = component_to_use(a)
          .subtract_from_component(ax,ay,az,j)
          a1 = index_a(ax,ay,az)
          BAi=BA(j)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            .add_to_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz)
            abcd(a,b,:,:)=int_old(:,:,b1,a1) + BAi * int_old(:,:,b,a1)
          end
        end
        int_old.destroy
        comp_to_use.destroy
        components.destroy
        index_b.destroy
        index_a.destroy
    end
  end

  transfer_l_a_highest(escd,abcd) [private]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT, IN :: escd
    MAT3, OUT :: abcd
    MAT3* :: int_new,int_old
    IMAT* :: components,components_a,components_b
    IMAT3* :: index_a,index_b
    VEC(3) :: AB
    INT :: a,b,f,a1,a2,a3,b1,lb,aub,bub,fub
    INT :: ax,ay,az,bx,by,bz,j,n_e,alb,blb,tmp
    DBL :: ABi,ABx,ABy,ABz,escd_acd
    IVEC* :: comp_to_use,component_to_use

    select case (.b.l)
      case (0)
        abcd(:,1,:)=escd

      case (1)
        alb = (.a.l-1).n_comp_sum
        AB   = .a.pos - .b.pos
        n_e  = .a.l + .b.l
        aub  = .a.n_comp
        fub  = size(escd,2)

        components.create(3, n_e.n_comp_sum - alb)
        index_a.create(0,n_e,0,n_e,0,n_e)
        .a.l.make_gaussian_xyz_powers(components,n_e,index_a)

        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components(1,a)
          ay = components(2,a)
          az = components(3,a)
          a1 = index_a(ax+1,ay,az)
          a2 = index_a(ax,ay+1,az)
          a3 = index_a(ax,ay,az+1)
          do f=1,fub
            escd_acd = escd(a,f)
            abcd(a,1,f)=escd(a1,f) + ABx * escd_acd
            abcd(a,2,f)=escd(a2,f) + ABy * escd_acd
            abcd(a,3,f)=escd(a3,f) + ABz * escd_acd
          end
        end
        index_a.destroy
        components.destroy

      case default
        alb = (.a.l-1).n_comp_sum
        AB   = .a.pos - .b.pos
        n_e  = .a.l + .b.l
        aub  = (n_e-1).n_comp_sum - alb
        bub  = .b.n_comp
        fub  = size(escd,2)

        index_b.create(0,n_e,0,n_e,0,n_e)
        index_a.create(0,n_e,0,n_e,0,n_e)
        components.create(3, n_e.n_comp_sum)
        comp_to_use.create( n_e.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_e,index_b,comp_to_use)
        tmp=.a.l; tmp.make_gaussian_xyz_power_index(index_a,n_e)
        components_a => components(:,alb+1:)

        nullify(int_new)
        int_new.create(fub,bub,aub)
        ABx=AB(1); ABy=AB(2); ABz=AB(3)
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          a1 = index_a(ax+1,ay,az)
          a2 = index_a(ax,ay+1,az)
          a3 = index_a(ax,ay,az+1)
          do f=1,fub
            escd_acd = escd(a,f)
            int_new(f,1,a)=escd(a1,f) + ABx * escd_acd
            int_new(f,2,a)=escd(a2,f) + ABy * escd_acd
            int_new(f,3,a)=escd(a3,f) + ABz * escd_acd
          end
        end

        do lb=2, .b.l - 1
          blb              = (lb-1).n_comp_sum
          bub              = lb.n_comp
          aub              = (n_e-lb).n_comp_sum - alb
          component_to_use => comp_to_use(blb+1:blb+bub)
          components_b     => components(:,blb+1:blb+bub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(fub,bub,aub)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            j = component_to_use(b)
            .subtract_from_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz)
            ABi=AB(j)
            do a=1,aub
              ax = components_a(1,a)
              ay = components_a(2,a)
              az = components_a(3,a)
              .add_to_component(ax,ay,az,j)
              a1 = index_a(ax,ay,az)
              int_new(:,b,a)=int_old(:,b1,a1) + ABi * int_old(:,b1,a)
            end
          end
          int_old.destroy
        end

        blb              = (.b.l-1).n_comp_sum
        bub              = .b.n_comp
        aub              = .a.n_comp
        component_to_use => comp_to_use(blb+1:blb+bub)
        components_b     => components(:,blb+1:blb+bub)
        int_old          => int_new
        do b=1,bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          j = component_to_use(b)
          .subtract_from_component(bx,by,bz,j)
          b1 = index_b(bx,by,bz)
          ABi=AB(j)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            .add_to_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az)
            do f=1,fub
              abcd(a,b,f)=int_old(f,b1,a1) + ABi * int_old(f,b1,a)
            end
          end
        end
        int_old.destroy
        comp_to_use.destroy
        components.destroy
        index_a.destroy
        index_b.destroy
    end
  end

  transfer_l_b_highest(escd,abcd) [private]
  ! Applies the transfer equation to (es|cd) to give (ab|cd)
    IN :: self
    MAT, IN :: escd
    MAT3, OUT :: abcd
    MAT3* :: int_new,int_old
    IMAT* :: components,components_a,components_b
    IMAT3* :: index_a,index_b
    VEC(3) :: BA
    INT :: a,b,f,a1,b1,b2,b3,la,aub,bub,fub
    INT :: ax,ay,az,bx,by,bz,j,n_e,alb,blb,tmp
    DBL :: BAi,BAx,BAy,BAz,escd_bcd
    IVEC* :: comp_to_use,component_to_use

    select case (.a.l)
      case (0)
        abcd(1,:,:)=escd

      case (1)
        blb = (.b.l-1).n_comp_sum
        BA   = .b.pos - .a.pos
        n_e  = .a.l + .b.l
        bub  = .b.n_comp
        fub  = size(escd,2)

        components.create(3, n_e.n_comp_sum - blb)
        index_b.create(0,n_e,0,n_e,0,n_e)
        .b.l.make_gaussian_xyz_powers(components,n_e,index_b)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components(1,b)
          by = components(2,b)
          bz = components(3,b)
          b1 = index_b(bx+1,by,bz)
          b2 = index_b(bx,by+1,bz)
          b3 = index_b(bx,by,bz+1)
          do f = 1, fub
            escd_bcd = escd(b,f)
            abcd(1,b,f) = escd(b1,f) + BAx * escd_bcd
            abcd(2,b,f) = escd(b2,f) + BAy * escd_bcd
            abcd(3,b,f) = escd(b3,f) + BAz * escd_bcd
          end
        end

        components.destroy
        index_b.destroy

      case default
        blb = (.b.l-1).n_comp_sum
        BA   = .b.pos - .a.pos
        n_e  = .a.l + .b.l
        bub  = (n_e-1).n_comp_sum - blb
        aub  = .a.n_comp
        fub  = size(escd,2)

        index_a.create(0,n_e,0,n_e,0,n_e)
        index_b.create(0,n_e,0,n_e,0,n_e)
        components.create(3, n_e.n_comp_sum)
        comp_to_use.create( n_e.n_comp_sum )
        tmp=0; tmp.make_gaussian_xyz_powers(components,n_e,index_a,comp_to_use)
        tmp=.b.l; tmp.make_gaussian_xyz_power_index(index_b,n_e)
        components_b => components(:,blb+1:)

        nullify(int_new)
        int_new.create(fub,bub,aub)

        BAx = BA(1);    BAy = BA(2);    BAz = BA(3)
        do b = 1, bub
          bx = components_b(1,b)
          by = components_b(2,b)
          bz = components_b(3,b)
          b1 = index_b(bx+1,by,bz)
          b2 = index_b(bx,by+1,bz)
          b3 = index_b(bx,by,bz+1)
          do f = 1, fub
            escd_bcd = escd(b,f)
            int_new(f,b,1) = escd(b1,f) + BAx * escd_bcd
            int_new(f,b,2) = escd(b2,f) + BAy * escd_bcd
            int_new(f,b,3) = escd(b3,f) + BAz * escd_bcd
          end
        end

        do la=2, .a.l - 1
          alb              = (la-1).n_comp_sum
          aub              = la.n_comp
          bub              = (n_e-la).n_comp_sum - blb
          component_to_use => comp_to_use(alb+1:alb+aub)
          components_a     => components(:,alb+1:alb+aub)
          int_old          => int_new
          nullify(int_new)
          int_new.create(fub,bub,aub)
          do a=1,aub
            ax = components_a(1,a)
            ay = components_a(2,a)
            az = components_a(3,a)
            j=component_to_use(a)
            .subtract_from_component(ax,ay,az,j)
            a1 = index_a(ax,ay,az)
            BAi=BA(j)
            do b=1,bub
              bx = components_b(1,b)
              by = components_b(2,b)
              bz = components_b(3,b)
              .add_to_component(bx,by,bz,j)
              b1 = index_b(bx,by,bz)
              int_new(:,b,a)=int_old(:,b1,a1) + BAi * int_old(:,b,a1)
            end
          end
          int_old.destroy
        end

        alb              = (.a.l-1).n_comp_sum
        aub              = .a.n_comp
        bub              = .b.n_comp
        component_to_use => comp_to_use(alb+1:alb+aub)
        components_a     => components(:,alb+1:alb+aub)
        int_old          => int_new
        do a=1,aub
          ax = components_a(1,a)
          ay = components_a(2,a)
          az = components_a(3,a)
          j = component_to_use(a)
          .subtract_from_component(ax,ay,az,j)
          a1 = index_a(ax,ay,az)
          BAi=BA(j)
          do b=1,bub
            bx = components_b(1,b)
            by = components_b(2,b)
            bz = components_b(3,b)
            .add_to_component(bx,by,bz,j)
            b1 = index_b(bx,by,bz)
            do f=1,fub
              abcd(a,b,f)=int_old(f,b1,a1) + BAi * int_old(f,b,a1)
            end
          end
        end
        int_old.destroy
        comp_to_use.destroy
        components.destroy
        index_b.destroy
        index_a.destroy
    end
  end

  add_to_component(x,y,z,j) [private]
  ! Adds one to the component specified by j.  Used by transfer equation.
  ! j=1 => x=x+1, j=2 => y=y+1, j=3 => z=z+1.
    INT, INOUT :: x,y,z
    INT, IN :: j
    select case(j)
      case (1); x = x + 1
      case (2); y = y + 1
      case (3); z = z + 1
    end
  end

  subtract_from_component(x,y,z,j) [private]
  ! Subtracts one from the component specified by j.  Used by transfer equation.
  ! j=1 => x=x-1, j=2 => y=y-1, j=3 => z=z-1.
    INT, INOUT :: x,y,z
    INT, IN :: j
    select case(j)
      case (1); x = x - 1
      case (2); y = y - 1
      case (3); z = z - 1
    end
  end

!*******************************************************************************
!                  Normalisation routines.
!*******************************************************************************

  to_normalize(abcd)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, b, c and d.
    IN :: self
    MAT4, target :: abcd
    VEC* :: anorm,bnorm,cnorm,dnorm
    INT :: aub,bub,cub,dub,a,b,c,d,opt
    DBL :: normb,normc,normd
    MAT* :: ab_cd

    opt = 0
    if (max(.a.l,.b.l) < 2) opt = opt + 1
    if (max(.c.l,.d.l) < 2) opt = opt + 2
    select case (opt)
      case (0)                                      ! The general routine.
        aub=.a.n_comp
        bub=.b.n_comp
        cub=.c.n_comp
        dub=.d.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a.l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b.l )
        cnorm.create(cub);   cnorm.normalizing_factors( .c.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d.l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            normc=normd*cnorm(c)
            ab_cd => abcd(:,:,c,d)
            do b=1,bub
              normb=normc*bnorm(b)
              ab_cd(:,b)=ab_cd(:,b)*normb*anorm(:)
            end
          end
        end
        anorm.destroy; bnorm.destroy; cnorm.destroy; dnorm.destroy
      case (1)                                      ! .a.l , .b.l either s or p
        cub = .c.n_comp
        dub = .d.n_comp
        cnorm.create(cub);   cnorm.normalizing_factors( .c.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d.l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            abcd(:,:,c,d)=abcd(:,:,c,d)*normd*cnorm(c)
          end
        end
        cnorm.destroy; dnorm.destroy
      case (2)                                      ! .c.l , .d.l either s or p
        aub = .a.n_comp
        bub = .b.n_comp
        cub = .c.n_comp
        dub = .d.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a.l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b.l )
        do d=1,dub
          do c=1,cub
            do b=1,bub
              abcd(:,b,c,d)=abcd(:,b,c,d)*bnorm(b)*anorm(:)
            end
          end
        end
        anorm.destroy; bnorm.destroy
      case (3)                          ! .a.l , .b.l , .c.l , .d.l all s or p
        ! do nothing
    end
  end

  to_normalize_bcd(bcd)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, b, c and d.
    IN :: self
    MAT3 :: bcd
    VEC* :: bnorm,cnorm,dnorm
    INT :: bub,cub,dub,b,c,d,opt
    DBL :: normb,normc,normd

    opt = 0
    if (.b.l < 2) opt = opt + 1
    if (max(.c.l,.d.l) < 2) opt = opt + 2
    select case (opt)
      case (0)                                      ! The general routine.
        bub=.b.n_comp
        cub=.c.n_comp
        dub=.d.n_comp
        bnorm.create(bub);   bnorm.normalizing_factors( .b.l )
        cnorm.create(cub);   cnorm.normalizing_factors( .c.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d.l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            bcd(:,c,d)=bcd(:,c,d)*bnorm(:)*normd*cnorm(c)
          end
        end
        bnorm.destroy; cnorm.destroy; dnorm.destroy
      case (1)                                      ! .b.l either s or p
        cub = .c.n_comp
        dub = .d.n_comp
        cnorm.create(cub);   cnorm.normalizing_factors( .c.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d.l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            bcd(:,c,d)=bcd(:,c,d)*normd*cnorm(c)
          end
        end
        cnorm.destroy; dnorm.destroy
      case (2)                                      ! .c.l , .d.l either s or p
        bub = .b.n_comp
        cub = .c.n_comp
        dub = .d.n_comp
        bnorm.create(bub);   bnorm.normalizing_factors( .b.l )
        do d=1,dub
          do c=1,cub
            bcd(:,c,d)=bcd(:,c,d)*bnorm(:)
          end
        end
        bnorm.destroy
      case (3)                                  ! .b.l , .c.l , .d.l all s or p
        ! do nothing
    end
  end

  to_normalize_acd(acd)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, c and d.
    IN :: self
    MAT3 :: acd
    VEC* :: anorm,cnorm,dnorm
    INT :: aub,cub,dub,a,c,d,opt
    DBL :: normd

    opt = 0
    if (.a.l < 2) opt = opt + 1
    if (max(.c.l,.d.l) < 2) opt = opt + 2
    select case (opt)
      case (0)                                      ! The general routine.
        aub=.a.n_comp
        cub=.c.n_comp
        dub=.d.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a.l )
        cnorm.create(cub);   cnorm.normalizing_factors( .c.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d.l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            acd(:,c,d)=acd(:,c,d)*normd*cnorm(c)*anorm(:)
          end
        end
        anorm.destroy; cnorm.destroy; dnorm.destroy
      case (1)                                      ! .a.l , either s or p
        cub = .c.n_comp
        dub = .d.n_comp
        cnorm.create(cub);   cnorm.normalizing_factors( .c.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d.l )
        do d=1,dub
          normd=dnorm(d)
          do c=1,cub
            acd(:,c,d)=acd(:,c,d)*normd*cnorm(c)
          end
        end
        cnorm.destroy; dnorm.destroy
      case (2)                                      ! .c.l , .d.l either s or p
        aub = .a.n_comp
        cub = .c.n_comp
        dub = .d.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a.l )
        do d=1,dub
          do c=1,cub
            acd(:,c,d)=acd(:,c,d)*anorm(:)
          end
        end
        anorm.destroy
      case (3)                                  ! .a.l , .c.l , .d.l all s or p
        ! do nothing
    end
  end

  to_normalize_abc(abc)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, b and c.
    IN :: self
    MAT3 :: abc
    VEC* :: anorm,bnorm,cnorm
    INT :: aub,bub,cub,a,b,c,opt
    DBL :: normc

    opt = 0
    if (.c.l < 2) opt = opt + 1
    if (max(.a.l,.b.l) < 2) opt = opt + 2
    select case (opt)
      case (0)                                      ! The general routine.
        aub=.a.n_comp
        bub=.b.n_comp
        cub=.c.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a.l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b.l )
        cnorm.create(cub);   cnorm.normalizing_factors( .c.l )
        do c=1,cub
          normc=cnorm(c)
          do b=1,bub
            abc(:,b,c)=abc(:,b,c)*normc*bnorm(b)*anorm(:)
          end
        end
        anorm.destroy; bnorm.destroy; cnorm.destroy
      case (1)                                      ! .c.l , either s or p
        aub = .a.n_comp
        bub = .b.n_comp
        cub=.c.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a.l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b.l )
        do c=1,cub
          do b=1,bub
            abc(:,b,c)=abc(:,b,c)*bnorm(b)*anorm(:)
          end
        end
        anorm.destroy; bnorm.destroy
      case (2)                                      ! .a.l , .b.l either s or p
        cub = .c.n_comp
        cnorm.create(cub);   cnorm.normalizing_factors( .c.l )
        do c=1,cub
          abc(:,:,c)=abc(:,:,c)*cnorm(c)
        end
        cnorm.destroy
      case (3)                                  ! .a.l , .b.l , .c.l all s or p
        ! do nothing
    end
  end

  to_normalize_abd(abd)
  ! Multiply the matrix by the orbital normalization coefficients
  ! for the orbitals a, b and d.
    IN :: self
    MAT3 :: abd
    VEC* :: anorm,bnorm,dnorm
    INT :: aub,bub,dub,a,b,d,opt
    DBL :: normd

    opt = 0
    if (.d.l < 2) opt = opt + 1
    if (max(.a.l,.b.l) < 2) opt = opt + 2
    select case (opt)
      case (0)                                      ! The general routine.
        aub=.a.n_comp
        bub=.b.n_comp
        dub=.d.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a.l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b.l )
        dnorm.create(dub);   dnorm.normalizing_factors( .d.l )
        do d=1,dub
          normd=dnorm(d)
          do b=1,bub
            abd(:,b,d)=abd(:,b,d)*normd*bnorm(b)*anorm(:)
          end
        end
        anorm.destroy; bnorm.destroy; dnorm.destroy
      case (1)                                      ! .d.l , either s or p
        aub = .a.n_comp
        bub = .b.n_comp
        dub=.d.n_comp
        anorm.create(aub);   anorm.normalizing_factors( .a.l )
        bnorm.create(bub);   bnorm.normalizing_factors( .b.l )
        do d=1,dub
          do b=1,bub
            abd(:,b,d)=abd(:,b,d)*bnorm(b)*anorm(:)
          end
        end
        anorm.destroy; bnorm.destroy
      case (2)                                      ! .a.l , .b.l either s or p
        dub = .d.n_comp
        dnorm.create(dub);   dnorm.normalizing_factors( .d.l )
        do d=1,dub
          abd(:,:,d)=abd(:,:,d)*dnorm(d)
        end
        dnorm.destroy
      case (3)                                  ! .a.l , .b.l , .d.l all s or p
        ! do nothing
    end
  end

!*******************************************************************************
!       make the J and K contributions from the shell4 and density matrix.
!*******************************************************************************

  make_r_JK(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld)
  ! Make the restricted part of the J and K matrices from the density elements
  ! in P, and the two electron integrals calculated from self.
    IN :: self
    MAT, INOUT :: J,K
    MAT, IN :: P
    DBL, IN :: factor
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    INT :: maxl,n_e,n_f,opt
    opt = 0
    if (.d.l==0) opt = opt + 1
    if (.c.l==0) opt = opt + 2
    if (.b.l==0) opt = opt + 4
    if (.a.l==0) opt = opt + 8
    select case (opt)
      case (0);  .make_r_JK_abcd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! abcd
      case (1);  .make_r_JK_abcs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! abcs
      case (2);  .make_r_JK_absd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! absd
      case (3);  .make_r_JK_abss(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! abss
      case (4);  .make_r_JK_ascd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! ascd
      case (5);  .make_r_JK_ascs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! ascs
      case (6);  .make_r_JK_assd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! assd
      case (7);  .make_r_JK_asss(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! asss
      case (8);  .make_r_JK_sbcd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! sbcd
      case (9);  .make_r_JK_sbcs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! sbcs
      case (10); .make_r_JK_sbsd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! sbsd
      case (11); .make_r_JK_sbss(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! sbss
      case (12); .make_r_JK_sscd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! sscd
      case (13); .make_r_JK_sscs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! sscs
      case (14); .make_r_JK_sssd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! sssd
      case (15); .make_r_JK_ssss(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) ! ssss
    end
  end

  make_r_JK_ssss(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For an ssss shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    DBL :: I0,I_abcd
    .make_ssss(I0)
    I_abcd = factor * I0
    J(fa,fb) = J(fa,fb) + I_abcd*P(fd,fc)
    J(fc,fd) = J(fc,fd) + I_abcd*P(fb,fa)
    K(fa,fc) = K(fa,fc) + I_abcd*P(fd,fb)
    K(fa,fd) = K(fa,fd) + I_abcd*P(fc,fb)
    K(fb,fc) = K(fb,fc) + I_abcd*P(fd,fa)
    K(fb,fd) = K(fb,fd) + I_abcd*P(fc,fa)
  end
 
  make_r_JK_abcd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For any shell4!
    MAT, IN :: P
    MAT, target :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT4* :: I4
    VEC* :: Kc,Kd
    DBL :: P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd
    INT :: a,b,c,d
    I4.create(fa,la,fb,lb,fc,lc,fd,ld)
    if (.a.l==1 AND .b.l==1 AND .c.l==1 AND .d.l==1) then
      .make_pppp(I4)
    else
      .make_abcd(I4)
    end
    if (factor > 0.9) then
      do d = fd,ld
        Kd => K(:,d)
        do c = fc,lc
          P_dc = P(d,c)
          Kc => K(:,c)
          Jcd = ZERO
          do b = fb,lb
            P_db = P(d,b)
            P_cb = P(c,b)
            Kbc = ZERO
            Kbd = ZERO
            do a = fa,la
              I_abcd = I4(a,b,c,d)
              J(a,b) = J(a,b) + I_abcd*P_dc
              Kc(a)  = Kc(a)  + I_abcd*P_db
              Kd(a)  = Kd(a)  + I_abcd*P_cb
              Jcd    = Jcd    + I_abcd*P(b,a)
              Kbc    = Kbc    + I_abcd*P(d,a)
              Kbd    = Kbd    + I_abcd*P(c,a)
            end
            Kc(b) = Kc(b) + Kbc
            Kd(b) = Kd(b) + Kbd
          end
          J(c,d) = J(c,d) + Jcd
        end
      end
    else if (.a.l<2) then
      do d = fd,ld
        Kd => K(:,d)
        do c = fc,lc
          P_dc = P(d,c)
          Kc => K(:,c)
          Jcd = ZERO
          do b = fb,lb
            P_db = P(d,b)
            P_cb = P(c,b)
            Kbc = ZERO
            Kbd = ZERO
            do a = fa,la
              I_abcd = factor*I4(a,b,c,d)
              J(a,b) = J(a,b) + I_abcd*P_dc
              Kc(a)  = Kc(a)  + I_abcd*P_db
              Kd(a)  = Kd(a)  + I_abcd*P_cb
              Jcd    = Jcd    + I_abcd*P(b,a)
              Kbc    = Kbc    + I_abcd*P(d,a)
              Kbd    = Kbd    + I_abcd*P(c,a)
            end
            Kc(b) = Kc(b) + Kbc
            Kd(b) = Kd(b) + Kbd
          end
          J(c,d) = J(c,d) + Jcd
        end
      end
    else
      do d = fd,ld
        Kd => K(:,d)
        do c = fc,lc
          P_dc = factor*P(d,c)
          Kc => K(:,c)
          Jcd = ZERO
          do b = fb,lb
            P_db = factor*P(d,b)
            P_cb = factor*P(c,b)
            Kbc = ZERO
            Kbd = ZERO
            do a = fa,la
              I_abcd = I4(a,b,c,d)
              J(a,b) = J(a,b) + I_abcd*P_dc
              Kc(a)  = Kc(a)  + I_abcd*P_db
              Kd(a)  = Kd(a)  + I_abcd*P_cb
              Jcd    = Jcd    + I_abcd*P(b,a)
              Kbc    = Kbc    + I_abcd*P(d,a)
              Kbd    = Kbd    + I_abcd*P(c,a)
            end
            Kc(b) = Kc(b) + factor*Kbc
            Kd(b) = Kd(b) + factor*Kbd
          end
          J(c,d) = J(c,d) + factor*Jcd
        end
      end
    end
    I4.destroy
  end

  make_r_JK_sscd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For an sscd shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT* :: I2
    DBL :: P_db,P_da,P_ba,Kbd,Kad,Jab,I_abcd
    INT :: c,d
    I2.create(fc,lc,fd,ld)
    if (.c.l==1 AND .d.l==1) then
      .make_sspp(I2)
    else
      .make_sscd(I2)
    end
    if (factor > 0.9) then
      Jab = ZERO
      P_ba = P(fb,fa)
      do d = fd,ld
        Kad = ZERO
        Kbd = ZERO
        P_da = P(d,fa)
        P_db = P(d,fb)
        do c = fc,lc
          I_abcd = I2(c,d)
          Jab     = Jab     + I_abcd*P(d,c)
          J(c,d)  = J(c,d)  + I_abcd*P_ba
          K(fa,c) = K(fa,c) + I_abcd*P_db
          K(fb,c) = K(fb,c) + I_abcd*P_da
          Kad     = Kad     + I_abcd*P(c,fb)
          Kbd     = Kbd     + I_abcd*P(c,fa)
        end
        K(fa,d) = K(fa,d) + Kad
        K(fb,d) = K(fb,d) + Kbd
      end
      J(fa,fb) = J(fa,fb) + Jab
    else if (.c.l<2) then
      Jab = ZERO
      P_ba = P(fb,fa)
      do d = fd,ld
        Kad = ZERO
        Kbd = ZERO
        P_da = P(d,fa)
        P_db = P(d,fb)
        do c = fc,lc
          I_abcd = factor*I2(c,d)
          Jab     = Jab     + I_abcd*P(d,c)
          J(c,d)  = J(c,d)  + I_abcd*P_ba
          K(fa,c) = K(fa,c) + I_abcd*P_db
          K(fb,c) = K(fb,c) + I_abcd*P_da
          Kad     = Kad     + I_abcd*P(c,fb)
          Kbd     = Kbd     + I_abcd*P(c,fa)
        end
        K(fa,d) = K(fa,d) + Kad
        K(fb,d) = K(fb,d) + Kbd
      end
      J(fa,fb) = J(fa,fb) + Jab
    else
      Jab = ZERO
      P_ba = factor*P(fb,fa)
      do d = fd,ld
        Kad = ZERO
        Kbd = ZERO
        P_da = factor*P(d,fa)
        P_db = factor*P(d,fb)
        do c = fc,lc
          I_abcd = I2(c,d)
          Jab     = Jab     + I_abcd*P(d,c)
          J(c,d)  = J(c,d)  + I_abcd*P_ba
          K(fa,c) = K(fa,c) + I_abcd*P_db
          K(fb,c) = K(fb,c) + I_abcd*P_da
          Kad     = Kad     + I_abcd*P(c,fb)
          Kbd     = Kbd     + I_abcd*P(c,fa)
        end
        K(fa,d) = K(fa,d) + factor*Kad
        K(fb,d) = K(fb,d) + factor*Kbd
      end
      J(fa,fb) = J(fa,fb) + factor*Jab
    end
    I2.destroy
  end
 
  make_r_JK_abcs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For an abcs shell4!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT3* :: I3
    DBL :: P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd
    INT :: a,b,c
    I3.create(fa,la,fb,lb,fc,lc)
    if (.a.l==1 AND .b.l==1 AND .c.l==1) then
      .make_ppps(I3)
    else
      .make_abcs(I3)
    end
    if (factor > 0.9) then
      do c = fc,lc
        P_dc = P(fd,c)
        Jcd = ZERO
        do b = fb,lb
          P_db = P(fd,b)
          P_cb = P(c,b)
          Kbc = ZERO
          Kbd = ZERO
          do a = fa,la
            I_abcd  = I3(a,b,c)
            J(a,b)  = J(a,b)  + I_abcd*P_dc
            Jcd     = Jcd     + I_abcd*P(b,a)
            K(a,c)  = K(a,c)  + I_abcd*P_db
            K(a,fd) = K(a,fd) + I_abcd*P_cb
            Kbc     = Kbc     + I_abcd*P(fd,a)
            Kbd     = Kbd     + I_abcd*P(c,a)
          end
          K(b,c)  = K(b,c)  + Kbc
          K(b,fd) = K(b,fd) + Kbd
        end
        J(c,fd) = J(c,fd) + Jcd
      end
    else if (.a.l<2) then
      do c = fc,lc
        P_dc = P(fd,c)
        Jcd = ZERO
        do b = fb,lb
          P_db = P(fd,b)
          P_cb = P(c,b)
          Kbc = ZERO
          Kbd = ZERO
          do a = fa,la
            I_abcd  = factor*I3(a,b,c)
            J(a,b)  = J(a,b)  + I_abcd*P_dc
            Jcd     = Jcd     + I_abcd*P(b,a)
            K(a,c)  = K(a,c)  + I_abcd*P_db
            K(a,fd) = K(a,fd) + I_abcd*P_cb
            Kbc     = Kbc     + I_abcd*P(fd,a)
            Kbd     = Kbd     + I_abcd*P(c,a)
          end
          K(b,c)  = K(b,c)  + Kbc
          K(b,fd) = K(b,fd) + Kbd
        end
        J(c,fd) = J(c,fd) + Jcd
      end
    else
      do c = fc,lc
        P_dc = factor*P(fd,c)
        Jcd = ZERO
        do b = fb,lb
          P_db = factor*P(fd,b)
          P_cb = factor*P(c,b)
          Kbc = ZERO
          Kbd = ZERO
          do a = fa,la
            I_abcd  = I3(a,b,c)
            J(a,b)  = J(a,b)  + I_abcd*P_dc
            Jcd     = Jcd     + I_abcd*P(b,a)
            K(a,c)  = K(a,c)  + I_abcd*P_db
            K(a,fd) = K(a,fd) + I_abcd*P_cb
            Kbc     = Kbc     + I_abcd*P(fd,a)
            Kbd     = Kbd     + I_abcd*P(c,a)
          end
          K(b,c)  = K(b,c)  + factor*Kbc
          K(b,fd) = K(b,fd) + factor*Kbd
        end
        J(c,fd) = J(c,fd) + factor*Jcd
      end
    end
    I3.destroy
  end

  make_r_JK_absd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For an absd shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT3* :: I3
    DBL :: P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd
    INT :: a,b,d
    I3.create(fa,la,fb,lb,fd,ld)
    if (.a.l==1 AND .b.l==1 AND .d.l==1) then
      .make_ppps(I3)
    else
      .make_abcs(I3)
    end
    if (factor > 0.9) then
      do d = fd,ld
        P_dc = P(d,fc)
        Jcd = ZERO
        do b = fb,lb
          P_db = P(d,b)
          P_cb = P(fc,b)
          Kbc = ZERO
          Kbd = ZERO
          do a = fa,la
            I_abcd  = I3(a,b,d)
            J(a,b)  = J(a,b)  + I_abcd*P_dc
            Jcd     = Jcd     + I_abcd*P(b,a)
            K(a,fc) = K(a,fc) + I_abcd*P_db
            K(a,d)  = K(a,d)  + I_abcd*P_cb
            Kbc     = Kbc     + I_abcd*P(d,a)
            Kbd     = Kbd     + I_abcd*P(fc,a)
          end
          K(b,fc) = K(b,fc) + Kbc
          K(b,d)  = K(b,d)  + Kbd
        end
        J(fc,d) = J(fc,d) + Jcd
      end
    else if (.a.l<2) then
      do d = fd,ld
        P_dc = P(d,fc)
        Jcd = ZERO
        do b = fb,lb
          P_db = P(d,b)
          P_cb = P(fc,b)
          Kbc = ZERO
          Kbd = ZERO
          do a = fa,la
            I_abcd  = factor*I3(a,b,d)
            J(a,b)  = J(a,b)  + I_abcd*P_dc
            Jcd     = Jcd     + I_abcd*P(b,a)
            K(a,fc) = K(a,fc) + I_abcd*P_db
            K(a,d)  = K(a,d)  + I_abcd*P_cb
            Kbc     = Kbc     + I_abcd*P(d,a)
            Kbd     = Kbd     + I_abcd*P(fc,a)
          end
          K(b,fc) = K(b,fc) + Kbc
          K(b,d)  = K(b,d)  + Kbd
        end
        J(fc,d) = J(fc,d) + Jcd
      end
    else
      do d = fd,ld
        P_dc = factor*P(d,fc)
        Jcd = ZERO
        do b = fb,lb
          P_db = factor*P(d,b)
          P_cb = factor*P(fc,b)
          Kbc = ZERO
          Kbd = ZERO
          do a = fa,la
            I_abcd  = I3(a,b,d)
            J(a,b)  = J(a,b)  + I_abcd*P_dc
            Jcd     = Jcd     + I_abcd*P(b,a)
            K(a,fc) = K(a,fc) + I_abcd*P_db
            K(a,d)  = K(a,d)  + I_abcd*P_cb
            Kbc     = Kbc     + I_abcd*P(d,a)
            Kbd     = Kbd     + I_abcd*P(fc,a)
          end
          K(b,fc) = K(b,fc) + factor*Kbc
          K(b,d)  = K(b,d)  + factor*Kbd
        end
        J(fc,d) = J(fc,d) + factor*Jcd
      end
    end
    I3.destroy
  end

  make_r_JK_sbcd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For a spcd shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT3* :: I3
    DBL :: Jab,P_ba,Kad,Kbd,P_da,P_db,I_abcd
    INT :: b,c,d
    I3.create(fb,lb,fc,lc,fd,ld)
    if (.b.l==1 AND .c.l==1 AND .d.l==1) then
      .make_pspp(I3)
    else
      .make_ascd(I3)
    end
    if (factor > 0.9) then
      do b=fb,lb
        Jab = ZERO
        P_ba = P(b,fa)
        do d = fd,ld
          Kad = ZERO
          Kbd = ZERO
          P_da = P(d,fa)
          P_db = P(d,b)
          do c = fc,lc
            I_abcd  = I3(b,c,d)
            Jab     = Jab     + I_abcd*P(d,c)
            J(c,d)  = J(c,d)  + I_abcd*P_ba
            K(fa,c) = K(fa,c) + I_abcd*P_db
            K(b,c)  = K(b,c)  + I_abcd*P_da
            Kad     = Kad     + I_abcd*P(c,b)
            Kbd     = Kbd     + I_abcd*P(c,fa)
          end
          K(fa,d) = K(fa,d) + Kad
          K(b,d)  = K(b,d)  + Kbd
        end
        J(fa,b) = J(fa,b) + Jab
      end
    else if (.c.l<2) then
      do b=fb,lb
        Jab = ZERO
        P_ba = P(b,fa)
        do d = fd,ld
          Kad = ZERO
          Kbd = ZERO
          P_da = P(d,fa)
          P_db = P(d,b)
          do c = fc,lc
            I_abcd  = factor*I3(b,c,d)
            Jab     = Jab     + I_abcd*P(d,c)
            J(c,d)  = J(c,d)  + I_abcd*P_ba
            K(fa,c) = K(fa,c) + I_abcd*P_db
            K(b,c)  = K(b,c)  + I_abcd*P_da
            Kad     = Kad     + I_abcd*P(c,b)
            Kbd     = Kbd     + I_abcd*P(c,fa)
          end
          K(fa,d) = K(fa,d) + Kad
          K(b,d)  = K(b,d)  + Kbd
        end
        J(fa,b) = J(fa,b) + Jab
      end
    else
      do b=fb,lb
        Jab = ZERO
        P_ba = factor*P(b,fa)
        do d = fd,ld
          Kad = ZERO
          Kbd = ZERO
          P_da = factor*P(d,fa)
          P_db = factor*P(d,b)
          do c = fc,lc
            I_abcd  = I3(b,c,d)
            Jab     = Jab     + I_abcd*P(d,c)
            J(c,d)  = J(c,d)  + I_abcd*P_ba
            K(fa,c) = K(fa,c) + I_abcd*P_db
            K(b,c)  = K(b,c)  + I_abcd*P_da
            Kad     = Kad     + I_abcd*P(c,b)
            Kbd     = Kbd     + I_abcd*P(c,fa)
          end
          K(fa,d) = K(fa,d) + factor*Kad
          K(b,d)  = K(b,d)  + factor*Kbd
        end
        J(fa,b) = J(fa,b) + factor*Jab
      end
    end
    I3.destroy
  end

  make_r_JK_ascd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For a pscd shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT3* :: I3
    DBL :: Jab,P_ba,Kad,Kbd,P_da,P_db,I_abcd
    INT :: a,c,d
    I3.create(fa,la,fc,lc,fd,ld)
    if (.a.l==1 AND .c.l==1 AND .d.l==1) then
      .make_pspp(I3)
    else
      .make_ascd(I3)
    end
    if (factor > 0.9) then
      do a=fa,la
        Jab = ZERO
        P_ba = P(fb,a)
        do d = fd,ld
          Kad = ZERO
          Kbd = ZERO
          P_da = P(d,a)
          P_db = P(d,fb)
          do c = fc,lc
            I_abcd  = I3(a,c,d)
            Jab     = Jab     + I_abcd*P(d,c)
            J(c,d)  = J(c,d)  + I_abcd*P_ba
            K(a,c)  = K(a,c)  + I_abcd*P_db
            K(fb,c) = K(fb,c) + I_abcd*P_da
            Kad     = Kad     + I_abcd*P(c,fb)
            Kbd     = Kbd     + I_abcd*P(c,a)
          end
          K(a,d)  = K(a,d)  + Kad
          K(fb,d) = K(fb,d) + Kbd
        end
        J(a,fb) = J(a,fb) + Jab
      end
    else if (.c.l<2) then
      do a=fa,la
        Jab = ZERO
        P_ba = P(fb,a)
        do d = fd,ld
          Kad = ZERO
          Kbd = ZERO
          P_da = P(d,a)
          P_db = P(d,fb)
          do c = fc,lc
            I_abcd  = factor*I3(a,c,d)
            Jab     = Jab     + I_abcd*P(d,c)
            J(c,d)  = J(c,d)  + I_abcd*P_ba
            K(a,c)  = K(a,c)  + I_abcd*P_db
            K(fb,c) = K(fb,c) + I_abcd*P_da
            Kad     = Kad     + I_abcd*P(c,fb)
            Kbd     = Kbd     + I_abcd*P(c,a)
          end
          K(a,d)  = K(a,d)  + Kad
          K(fb,d) = K(fb,d) + Kbd
        end
        J(a,fb) = J(a,fb) + Jab
      end
    else
      do a=fa,la
        Jab = ZERO
        P_ba = factor*P(fb,a)
        do d = fd,ld
          Kad = ZERO
          Kbd = ZERO
          P_da = factor*P(d,a)
          P_db = factor*P(d,fb)
          do c = fc,lc
            I_abcd  = I3(a,c,d)
            Jab     = Jab     + I_abcd*P(d,c)
            J(c,d)  = J(c,d)  + I_abcd*P_ba
            K(a,c)  = K(a,c)  + I_abcd*P_db
            K(fb,c) = K(fb,c) + I_abcd*P_da
            Kad     = Kad     + I_abcd*P(c,fb)
            Kbd     = Kbd     + I_abcd*P(c,a)
          end
          K(a,d)  = K(a,d)  + factor*Kad
          K(fb,d) = K(fb,d) + factor*Kbd
        end
        J(a,fb) = J(a,fb) + factor*Jab
      end
    end
    I3.destroy
  end

  make_r_JK_abss(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For an abss shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT* :: I2
    DBL :: P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd
    INT :: a,b
    I2.create(fa,la,fb,lb)
    if (.a.l==1 AND .b.l==1) then
      .make_ppss(I2)
    else
      .make_abss(I2)
    end
    if (factor > 0.9) then
      Jcd = ZERO
      P_dc = P(fd,fc)
      do b = fb,lb
        Kbc = ZERO
        Kbd = ZERO
        P_db = P(fd,b)
        P_cb = P(fc,b)
        do a = fa,la
          I_abcd = I2(a,b)
          J(a,b) = J(a,b) + I_abcd*P_dc
          Jcd    = Jcd    + I_abcd*P(b,a)
          K(a,fc) = K(a,fc) + I_abcd*P_db
          K(a,fd) = K(a,fd) + I_abcd*P_cb
          Kbc    = Kbc    + I_abcd*P(fd,a)
          Kbd    = Kbd    + I_abcd*P(fc,a)
        end
        K(b,fc) = K(b,fc) + Kbc
        K(b,fd) = K(b,fd) + Kbd
      end
      J(fc,fd) = J(fc,fd) + Jcd
    else if (.a.l<2) then
      Jcd = ZERO
      P_dc = P(fd,fc)
      do b = fb,lb
        Kbc = ZERO
        Kbd = ZERO
        P_db = P(fd,b)
        P_cb = P(fc,b)
        do a = fa,la
          I_abcd = factor*I2(a,b)
          J(a,b) = J(a,b) + I_abcd*P_dc
          Jcd    = Jcd    + I_abcd*P(b,a)
          K(a,fc) = K(a,fc) + I_abcd*P_db
          K(a,fd) = K(a,fd) + I_abcd*P_cb
          Kbc    = Kbc    + I_abcd*P(fd,a)
          Kbd    = Kbd    + I_abcd*P(fc,a)
        end
        K(b,fc) = K(b,fc) + Kbc
        K(b,fd) = K(b,fd) + Kbd
      end
      J(fc,fd) = J(fc,fd) + Jcd
    else
      Jcd = ZERO
      P_dc = factor*P(fd,fc)
      do b = fb,lb
        Kbc = ZERO
        Kbd = ZERO
        P_db = factor*P(fd,b)
        P_cb = factor*P(fc,b)
        do a = fa,la
          I_abcd = I2(a,b)
          J(a,b) = J(a,b) + I_abcd*P_dc
          Jcd    = Jcd    + I_abcd*P(b,a)
          K(a,fc) = K(a,fc) + I_abcd*P_db
          K(a,fd) = K(a,fd) + I_abcd*P_cb
          Kbc    = Kbc    + I_abcd*P(fd,a)
          Kbd    = Kbd    + I_abcd*P(fc,a)
        end
        K(b,fc) = K(b,fc) + factor*Kbc
        K(b,fd) = K(b,fd) + factor*Kbd
      end
      J(fc,fd) = J(fc,fd) + factor*Jcd
    end
    I2.destroy
  end

  make_r_JK_ascs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For a ascs shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT* :: I2
    DBL :: P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd
    INT :: a,c
    I2.create(fa,la,fc,lc)
    if (.a.l==1 AND .c.l==1) then
      .make_psps(I2)
    else
      .make_ascs(I2)
    end
    if (factor > 0.9) then
      P_db = P(fd,fb)
      Kbd = ZERO
      do c = fc,lc
        P_dc = P(fd,c)
        P_cb = P(c,fb)
        Jcd = ZERO
        Kbc = ZERO
        do a = fa,la
          I_abcd  = I2(a,c)
          J(a,fb) = J(a,fb) + I_abcd*P_dc
          Jcd     = Jcd     + I_abcd*P(fb,a)
          K(a,c)  = K(a,c)  + I_abcd*P_db
          K(a,fd) = K(a,fd) + I_abcd*P_cb
          Kbc     = Kbc     + I_abcd*P(fd,a)
          Kbd     = Kbd     + I_abcd*P(c,a)
        end
        K(fb,c) = K(fb,c) + Kbc
        J(c,fd) = J(c,fd) + Jcd
      end
      K(fb,fd) = K(fb,fd) + Kbd
    else if (.a.l<2) then
      P_db = P(fd,fb)
      Kbd = ZERO
      do c = fc,lc
        P_dc = P(fd,c)
        P_cb = P(c,fb)
        Jcd = ZERO
        Kbc = ZERO
        do a = fa,la
          I_abcd  = factor*I2(a,c)
          J(a,fb) = J(a,fb) + I_abcd*P_dc
          Jcd     = Jcd     + I_abcd*P(fb,a)
          K(a,c)  = K(a,c)  + I_abcd*P_db
          K(a,fd) = K(a,fd) + I_abcd*P_cb
          Kbc     = Kbc     + I_abcd*P(fd,a)
          Kbd     = Kbd     + I_abcd*P(c,a)
        end
        K(fb,c) = K(fb,c) + Kbc
        J(c,fd) = J(c,fd) + Jcd
      end
      K(fb,fd) = K(fb,fd) + Kbd
    else
      P_db = factor*P(fd,fb)
      Kbd = ZERO
      do c = fc,lc
        P_dc = factor*P(fd,c)
        P_cb = factor*P(c,fb)
        Jcd = ZERO
        Kbc = ZERO
        do a = fa,la
          I_abcd  = I2(a,c)
          J(a,fb) = J(a,fb) + I_abcd*P_dc
          Jcd     = Jcd     + I_abcd*P(fb,a)
          K(a,c)  = K(a,c)  + I_abcd*P_db
          K(a,fd) = K(a,fd) + I_abcd*P_cb
          Kbc     = Kbc     + I_abcd*P(fd,a)
          Kbd     = Kbd     + I_abcd*P(c,a)
        end
        K(fb,c) = K(fb,c) + factor*Kbc
        J(c,fd) = J(c,fd) + factor*Jcd
      end
      K(fb,fd) = K(fb,fd) + factor*Kbd
    end
    I2.destroy
  end

  make_r_JK_assd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For a assd shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT* :: I2
    DBL :: P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd
    INT :: a,d
    I2.create(fa,la,fd,ld)
    if (.a.l==1 AND .d.l==1) then
      .make_psps(I2)
    else
      .make_ascs(I2)
    end
    if (factor > 0.9) then
      P_cb = P(fc,fb)
      Kbc = ZERO
      do d = fd,ld
        P_dc = P(d,fc)
        P_db = P(d,fb)
        Jcd = ZERO
        Kbd = ZERO
        do a = fa,la
          I_abcd  = I2(a,d)
          Jcd     = Jcd     + I_abcd*P(fb,a)
          Kbc     = Kbc     + I_abcd*P(d,a)
          Kbd     = Kbd     + I_abcd*P(fc,a)
          J(a,fb) = J(a,fb) + I_abcd*P_dc
          K(a,fc) = K(a,fc) + I_abcd*P_db
          K(a,d)  = K(a,d)  + I_abcd*P_cb
        end
        K(fb,d) = K(fb,d) + Kbd
        J(fc,d) = J(fc,d) + Jcd
      end
      K(fb,fc) = K(fb,fc) + Kbc
    else if (.a.l<2) then
      P_cb = P(fc,fb)
      Kbc = ZERO
      do d = fd,ld
        P_dc = P(d,fc)
        P_db = P(d,fb)
        Jcd = ZERO
        Kbd = ZERO
        do a = fa,la
          I_abcd  = factor*I2(a,d)
          Jcd     = Jcd     + I_abcd*P(fb,a)
          Kbc     = Kbc     + I_abcd*P(d,a)
          Kbd     = Kbd     + I_abcd*P(fc,a)
          J(a,fb) = J(a,fb) + I_abcd*P_dc
          K(a,fc) = K(a,fc) + I_abcd*P_db
          K(a,d)  = K(a,d)  + I_abcd*P_cb
        end
        K(fb,d) = K(fb,d) + Kbd
        J(fc,d) = J(fc,d) + Jcd
      end
      K(fb,fc) = K(fb,fc) + Kbc
    else
      P_cb = factor*P(fc,fb)
      Kbc = ZERO
      do d = fd,ld
        P_dc = factor*P(d,fc)
        P_db = factor*P(d,fb)
        Jcd = ZERO
        Kbd = ZERO
        do a = fa,la
          I_abcd  = I2(a,d)
          Jcd     = Jcd     + I_abcd*P(fb,a)
          Kbc     = Kbc     + I_abcd*P(d,a)
          Kbd     = Kbd     + I_abcd*P(fc,a)
          J(a,fb) = J(a,fb) + I_abcd*P_dc
          K(a,fc) = K(a,fc) + I_abcd*P_db
          K(a,d)  = K(a,d)  + I_abcd*P_cb
        end
        K(fb,d) = K(fb,d) + factor*Kbd
        J(fc,d) = J(fc,d) + factor*Jcd
      end
      K(fb,fc) = K(fb,fc) + factor*Kbc
    end
    I2.destroy
  end

  make_r_JK_sbcs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For a sbcs shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT* :: I2
    DBL :: P_dc,Jcd,P_da,P_ca,Kac,Kad,I_abcd
    INT :: b,c
    I2.create(fb,lb,fc,lc)
    if (.b.l==1 AND .c.l==1) then
      .make_psps(I2)
    else
      .make_ascs(I2)
    end
    if (factor > 0.9) then
      Kad = ZERO
      P_da = P(fd,fa)
      do c = fc,lc
        P_dc = P(fd,c)
        P_ca = P(c,fa)
        Jcd = ZERO
        Kac = ZERO
        do b = fb,lb
          I_abcd  = I2(b,c)
          Jcd     = Jcd     + I_abcd*P(b,fa)
          Kac     = Kac     + I_abcd*P(fd,b)
          Kad     = Kad     + I_abcd*P(c,b)
          J(fa,b) = J(fa,b) + I_abcd*P_dc
          K(b,c)  = K(b,c)  + I_abcd*P_da
          K(b,fd) = K(b,fd) + I_abcd*P_ca
        end
        K(fa,c) = K(fa,c) + Kac
        J(c,fd) = J(c,fd) + Jcd
      end
      K(fa,fd) = K(fa,fd) + Kad
    else if (.b.l<2) then
      Kad = ZERO
      P_da = P(fd,fa)
      do c = fc,lc
        P_dc = P(fd,c)
        P_ca = P(c,fa)
        Jcd = ZERO
        Kac = ZERO
        do b = fb,lb
          I_abcd  = factor*I2(b,c)
          Jcd     = Jcd     + I_abcd*P(b,fa)
          Kac     = Kac     + I_abcd*P(fd,b)
          Kad     = Kad     + I_abcd*P(c,b)
          J(fa,b) = J(fa,b) + I_abcd*P_dc
          K(b,c)  = K(b,c)  + I_abcd*P_da
          K(b,fd) = K(b,fd) + I_abcd*P_ca
        end
        K(fa,c) = K(fa,c) + Kac
        J(c,fd) = J(c,fd) + Jcd
      end
      K(fa,fd) = K(fa,fd) + Kad
    else
      Kad = ZERO
      P_da = factor*P(fd,fa)
      do c = fc,lc
        P_dc = factor*P(fd,c)
        P_ca = factor*P(c,fa)
        Jcd = ZERO
        Kac = ZERO
        do b = fb,lb
          I_abcd  = I2(b,c)
          Jcd     = Jcd     + I_abcd*P(b,fa)
          Kac     = Kac     + I_abcd*P(fd,b)
          Kad     = Kad     + I_abcd*P(c,b)
          J(fa,b) = J(fa,b) + I_abcd*P_dc
          K(b,c)  = K(b,c)  + I_abcd*P_da
          K(b,fd) = K(b,fd) + I_abcd*P_ca
        end
        K(fa,c) = K(fa,c) + factor*Kac
        J(c,fd) = J(c,fd) + factor*Jcd
      end
      K(fa,fd) = K(fa,fd) + factor*Kad
    end
    I2.destroy
  end

  make_r_JK_sbsd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For a sbsd shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    MAT* :: I2
    DBL :: P_ca,Jcd,P_dc,P_da,Kac,Kad,I_abcd
    INT :: b,d
    I2.create(fb,lb,fd,ld)
    if (.b.l==1 AND .d.l==1) then
      .make_psps(I2)
    else
      .make_ascs(I2)
    end
    if (factor > 0.9) then
      P_ca = P(fc,fa)
      Kac = ZERO
      do d = fd,ld
        Kad = ZERO
        Jcd = ZERO
        P_dc = P(d,fc)
        P_da = P(d,fa)
        do b = fb,lb
          I_abcd  = I2(b,d)
          Jcd     = Jcd     + I_abcd*P(b,fa)
          Kac     = Kac     + I_abcd*P(d,b)
          Kad     = Kad     + I_abcd*P(fc,b)
          J(fa,b) = J(fa,b) + I_abcd*P_dc
          K(b,fc) = K(b,fc) + I_abcd*P_da
          K(b,d)  = K(b,d)  + I_abcd*P_ca
        end
        K(fa,d) = K(fa,d) + Kad
        J(fc,d) = J(fc,d) + Jcd
      end
      K(fa,fc) = K(fa,fc) + Kac
    else if (.b.l<2) then
      P_ca = P(fc,fa)
      Kac = ZERO
      do d = fd,ld
        Kad = ZERO
        Jcd = ZERO
        P_dc = P(d,fc)
        P_da = P(d,fa)
        do b = fb,lb
          I_abcd  = factor*I2(b,d)
          Jcd     = Jcd     + I_abcd*P(b,fa)
          Kac     = Kac     + I_abcd*P(d,b)
          Kad     = Kad     + I_abcd*P(fc,b)
          J(fa,b) = J(fa,b) + I_abcd*P_dc
          K(b,fc) = K(b,fc) + I_abcd*P_da
          K(b,d)  = K(b,d)  + I_abcd*P_ca
        end
        K(fa,d) = K(fa,d) + Kad
        J(fc,d) = J(fc,d) + Jcd
      end
      K(fa,fc) = K(fa,fc) + Kac
    else
      P_ca = factor*P(fc,fa)
      Kac = ZERO
      do d = fd,ld
        Kad = ZERO
        Jcd = ZERO
        P_dc = factor*P(d,fc)
        P_da = factor*P(d,fa)
        do b = fb,lb
          I_abcd  = I2(b,d)
          Jcd     = Jcd     + I_abcd*P(b,fa)
          Kac     = Kac     + I_abcd*P(d,b)
          Kad     = Kad     + I_abcd*P(fc,b)
          J(fa,b) = J(fa,b) + I_abcd*P_dc
          K(b,fc) = K(b,fc) + I_abcd*P_da
          K(b,d)  = K(b,d)  + I_abcd*P_ca
        end
        K(fa,d) = K(fa,d) + factor*Kad
        J(fc,d) = J(fc,d) + factor*Jcd
      end
      K(fa,fc) = K(fa,fc) + factor*Kac
    end
    I2.destroy
  end

  make_r_JK_asss(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For a asss shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    VEC(fa:la) :: I
    DBL :: P_dc,Jcd,P_db,P_cb,Kbc,Kbd,I_abcd
    INT :: a
    if (.a.l==1) then
      .make_psss(I)
      P_cb = P(fc,fb)
      P_dc = P(fd,fc)
      P_db = P(fd,fb)
      Kbc = ZERO
      Jcd = ZERO
      Kbd = ZERO
      do a = fa,la
        I_abcd  = factor*I(a)
        Jcd     = Jcd     + I_abcd*P(fb,a)
        Kbc     = Kbc     + I_abcd*P(fd,a)
        Kbd     = Kbd     + I_abcd*P(fc,a)
        J(a,fb) = J(a,fb) + I_abcd*P_dc
        K(a,fc) = K(a,fc) + I_abcd*P_db
        K(a,fd) = K(a,fd) + I_abcd*P_cb
      end
      K(fb,fd) = K(fb,fd) + Kbd
      J(fc,fd) = J(fc,fd) + Jcd
      K(fb,fc) = K(fb,fc) + Kbc
    else
      .make_asss(I)
      P_cb = factor*P(fc,fb)
      P_dc = factor*P(fd,fc)
      P_db = factor*P(fd,fb)
      Kbc = ZERO
      Jcd = ZERO
      Kbd = ZERO
      do a = fa,la
        I_abcd  = I(a)
        Jcd     = Jcd     + I_abcd*P(fb,a)
        Kbc     = Kbc     + I_abcd*P(fd,a)
        Kbd     = Kbd     + I_abcd*P(fc,a)
        J(a,fb) = J(a,fb) + I_abcd*P_dc
        K(a,fc) = K(a,fc) + I_abcd*P_db
        K(a,fd) = K(a,fd) + I_abcd*P_cb
      end
      K(fb,fd) = K(fb,fd) + factor*Kbd
      J(fc,fd) = J(fc,fd) + factor*Jcd
      K(fb,fc) = K(fb,fc) + factor*Kbc
    end
  end

  make_r_JK_sbss(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For a sbss shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    VEC(fb:lb) :: I
    DBL :: P_ca,Jcd,P_dc,P_da,Kac,Kad,I_abcd
    INT :: b
    if (.b.l==1) then
      .make_psss(I)
      P_ca = P(fc,fa)
      P_dc = P(fd,fc)
      P_da = P(fd,fa)
      Kac = ZERO
      Kad = ZERO
      Jcd = ZERO
      do b = fb,lb
        I_abcd  = factor*I(b)
        Jcd     = Jcd     + I_abcd*P(b,fa)
        Kac     = Kac     + I_abcd*P(fd,b)
        Kad     = Kad     + I_abcd*P(fc,b)
        J(fa,b) = J(fa,b) + I_abcd*P_dc
        K(b,fc) = K(b,fc) + I_abcd*P_da
        K(b,fd) = K(b,fd) + I_abcd*P_ca
      end
      K(fa,fd) = K(fa,fd) + Kad
      J(fc,fd) = J(fc,fd) + Jcd
      K(fa,fc) = K(fa,fc) + Kac
    else
      .make_asss(I)
      P_ca = factor*P(fc,fa)
      P_dc = factor*P(fd,fc)
      P_da = factor*P(fd,fa)
      Kac = ZERO
      Kad = ZERO
      Jcd = ZERO
      do b = fb,lb
        I_abcd  = I(b)
        Jcd     = Jcd     + I_abcd*P(b,fa)
        Kac     = Kac     + I_abcd*P(fd,b)
        Kad     = Kad     + I_abcd*P(fc,b)
        J(fa,b) = J(fa,b) + I_abcd*P_dc
        K(b,fc) = K(b,fc) + I_abcd*P_da
        K(b,fd) = K(b,fd) + I_abcd*P_ca
      end
      K(fa,fd) = K(fa,fd) + factor*Kad
      J(fc,fd) = J(fc,fd) + factor*Jcd
      K(fa,fc) = K(fa,fc) + factor*Kac
    end
  end

  make_r_JK_sscs(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For an sscs shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    VEC* :: I
    DBL :: P_db,P_da,P_ba,Kbd,Kad,Jab,I_abcd
    INT :: c
    I.create(fc,lc)
    if (.c.l==1) then
      .make_ssps(I)
      P_db = P(fd,fb)
      P_da = P(fd,fa)
      P_ba = P(fb,fa)
      Kbd = ZERO
      Kad = ZERO
      Jab = ZERO
      do c = fc,lc
        I_abcd = factor*I(c)
        Jab      = Jab     + I_abcd*P(fd,c)
        J(c,fd)  = J(c,fd) + I_abcd*P_ba
        K(fa,c)  = K(fa,c) + I_abcd*P_db
        Kad      = Kad     + I_abcd*P(c,fb)
        K(fb,c)  = K(fb,c) + I_abcd*P_da
        Kbd      = Kbd     + I_abcd*P(c,fa)
      end
      J(fa,fb) = J(fa,fb) + Jab
      K(fa,fd) = K(fa,fd) + Kad
      K(fb,fd) = K(fb,fd) + Kbd
    else
      .make_sscs(I)
      P_db = factor*P(fd,fb)
      P_da = factor*P(fd,fa)
      P_ba = factor*P(fb,fa)
      Kbd = ZERO
      Kad = ZERO
      Jab = ZERO
      do c = fc,lc
        I_abcd = I(c)
        Jab      = Jab     + I_abcd*P(fd,c)
        J(c,fd)  = J(c,fd) + I_abcd*P_ba
        K(fa,c)  = K(fa,c) + I_abcd*P_db
        Kad      = Kad     + I_abcd*P(c,fb)
        K(fb,c)  = K(fb,c) + I_abcd*P_da
        Kbd      = Kbd     + I_abcd*P(c,fa)
      end
      J(fa,fb) = J(fa,fb) + factor*Jab
      K(fa,fd) = K(fa,fd) + factor*Kad
      K(fb,fd) = K(fb,fd) + factor*Kbd
    end
    I.destroy
  end
 
  make_r_JK_sssd(J,K,P,factor,fa,la,fb,lb,fc,lc,fd,ld) [private]
  ! Make the J and K contribution due to self and P and add it in.
  ! For an sssd shell4 only!
    MAT, IN :: P
    MAT, INOUT :: J,K
    INT, IN :: fa,la,fb,lb,fc,lc,fd,ld
    DBL, IN :: factor
    VEC* :: I
    DBL :: Jab,P_cb,P_ca,P_ba,Kbc,Kac,I_abcd
    INT :: d
    I.create(fd,ld)
    if (.d.l==1) then
      .make_ssps(I)
      P_cb = P(fc,fb)
      P_ca = P(fc,fa)
      P_ba = P(fb,fa)
      Jab = ZERO
      Kac = ZERO
      Kbc = ZERO
      do d = fd,ld
        I_abcd = factor*I(d)
        Jab     = Jab     + I_abcd*P(d,fc)
        J(fc,d) = J(fc,d) + I_abcd*P_ba
        Kac     = Kac     + I_abcd*P(d,fb)
        K(fa,d) = K(fa,d) + I_abcd*P_cb
        Kbc     = Kbc     + I_abcd*P(d,fa)
        K(fb,d) = K(fb,d) + I_abcd*P_ca
      end
      K(fb,fc) = K(fb,fc) + Kbc
      K(fa,fc) = K(fa,fc) + Kac
      J(fa,fb) = J(fa,fb) + Jab
    else
      .make_sscs(I)
      P_cb = factor*P(fc,fb)
      P_ca = factor*P(fc,fa)
      P_ba = factor*P(fb,fa)
      Jab = ZERO
      Kac = ZERO
      Kbc = ZERO
      do d = fd,ld
        I_abcd = I(d)
        Jab     = Jab     + I_abcd*P(d,fc)
        J(fc,d) = J(fc,d) + I_abcd*P_ba
        Kac     = Kac     + I_abcd*P(d,fb)
        K(fa,d) = K(fa,d) + I_abcd*P_cb
        Kbc     = Kbc     + I_abcd*P(d,fa)
        K(fb,d) = K(fb,d) + I_abcd*P_ca
      end
      K(fb,fc) = K(fb,fc) + factor*Kbc
      K(fa,fc) = K(fa,fc) + factor*Kac
      J(fa,fb) = J(fa,fb) + factor*Jab
    end
    I.destroy
  end
 
end
