!---------------------------------------------------------------------------
!
! CPX: Complex numbers
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module CPX

   implicit none

contains

! *****************
! String conversion
! *****************

   to_str(format) result(string) ::: pure
   ! Change self to a "string" using default format, or the specified fortran
   ! "format", if present.
      self :: IN
      format :: STR, IN, optional
      string :: STR
      string = " "
      if (present(format)) then; write(string,fmt="("//trim(format)//")") self
      else;                      write(string,fmt=*) self
      end
      string.left_justify
   end

! ****************
! Equality testing
! ****************

   equals(c,eps) result (res) ::: pure
   ! Test to see if "self" is the same as "c"
      self :: IN
      c :: CPX, IN
      eps :: REAL, IN, optional
      res :: BIN
      res = .same_as(c,eps)
   end

   same_as(c,eps) result (res) ::: pure
   ! Test to see if "self" is the same as "c"
      self :: IN
      c :: CPX, IN
      eps :: REAL, IN, optional
      res :: BIN
      tol :: REAL
      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self-c) < tol
   end

   is_zero(eps) result (res) ::: pure
   ! Return TRUE if self is near enough zero. If present, "eps" defines how
   ! close to zero before the number is considered zero.
      self :: IN
      eps :: REAL, IN, optional
      res :: BIN
      tol :: REAL
      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self) < tol
   end

   is_one(eps) result (res) ::: pure
   ! Return TRUE if self is near enough one. If present, "eps" defines how
   ! close to one before the number is considered zero.
      self :: IN
      eps :: REAL, IN, optional
      res :: BIN
      tol :: REAL
      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self-ONE) < tol
   end

   is_minus_one(eps) result (res) ::: pure
   ! Return TRUE if self is near enough minus one. If present, "eps" defines how
   ! close to minus one before the number is considered zero.
      self :: IN
      eps :: REAL, IN, optional
      res :: BIN
      tol :: REAL
      tol = REAL_EPSILON
      if (present(eps)) tol = abs(eps)
      res = abs(self+ONE) < tol
   end

end
