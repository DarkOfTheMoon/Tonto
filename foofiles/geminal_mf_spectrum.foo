!-------------------------------------------------------------------------------
!
! GEMINAL_MF_SPECTRUM
!
! Copyright (C) Patrick Cassam-Chena√Ø and Dylan Jayatilaka, 2003
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!-------------------------------------------------------------------------------

module GEMINAL_MF_SPECTRUM

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

!   indices :: MAT{INT}(100,3), save
!   ind :: INT, save

contains

!*******************************************************************************
!                             Create and Destroy Routines
!*******************************************************************************

   create(n_geminals,n_bf,n_bas,use_hf_default) ::: leaky
   ! Create the geminals with "n_geminal" geminals, and each geminal having
   ! coeficients matrix of dimension "n_bf".
      self :: PTR
      n_geminals,n_bf :: INT
      n_bas :: INT, optional
      use_hf_default :: BIN, optional
      hf_default :: BIN
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults(n_geminals,n_bf,use_hf_default)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      nullify(.bra)
      nullify(.ket)
      nullify(.special_ket)
   end

   destroy_ptr_part  ::: leaky
   ! Destroy the pointer parts of self
      .bra.destroy
      .ket.destroy
      .special_ket.destroy
   end

   create_copy(b) ::: leaky
   ! Create a copy of "b".
     b :: GEMINAL_MF_SPECTRUM, IN
     self :: PTR
     .create(b.n_geminals,b.n_bf,b.n_bas)
     .copy(b)
   end

   copy(b) ::: leaky
   ! Copy a basis "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
      b :: GEMINAL_MF_SPECTRUM, IN
      self = b
      if (b.bra.created) .bra.create_copy(b.bra)
      if (b.ket.created) .ket.create_copy(b.ket)
      if (b.special_ket.created) .special_ket.create_copy(b.special_ket)
      if (b.contraction_wfs.created) .contraction_wfs.create_copy(b.contraction_wfs)
      if (b.contraction_energies.created) .contraction_energies.create_copy(b.contraction_energies)
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   set_defaults(n_geminals,n_bf,use_hf_default) ::: leaky
   ! Create a default object.
     n_geminals,n_bf :: INT
     use_hf_default :: BIN, optional
     ENSURE(n_geminals<n_bf,"n_geminals not less than n_bf")
     hf_default :: BIN
     i,j,k :: INT
     n_bfsq :: INT
!debug
     R,S,T,U :: MAT{REAL}*
     V,eigenvalues :: VEC{REAL}*
     l :: INT
     val :: REAL
!debug
     hf_default = FALSE
     if (present(use_hf_default)) hf_default = use_hf_default
     .n_geminals = n_geminals
     .n_bf = n_bf
      n_bfsq=n_bf*n_bf
     if (hf_default) then
       .n_bas = n_bfsq-(2*n_bf-n_geminals+1)*(n_geminals-1) ! avoid the ground state orbitals
     else                                                       ! of the other contractions
       .n_bas = n_bfsq
     end
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do i = 1,n_geminals     ! create ground state bras and kets
        .bra(i).element.create(n_bf,n_bf)
        .ket(i).element.create(n_bf,n_bf)
        .special_ket(i).element.create(2)
        .ket(i).element = ZERO
        .bra(i).element = ZERO
        if (hf_default) then
          .special_ket(i).element = i
          .bra(i)[i,i] = ONE
          .ket(i)[i,i] = ONE
       else
          .special_ket(i).element = ZERO
       end
     end
     do i = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(i).element.create(n_bf,n_bf)
       .contraction_wfs(i).element = ZERO
       .contraction_energies(i)= ZERO
     end
     if (hf_default) then
       i = 1
       do j = 1, n_bf
       do k = 1, n_bf
         if (1<j AND j <= n_geminals OR 1<k AND k <= n_geminals ) cycle 
         .contraction_wfs(i)[j,k] = ONE
         i = i + 1
       end
       end
     end
     DIE_IF(i/=.n_bas+1,"i not equal to .n_bas+1") 
!debug      write(*,*) ".n_bas",.n_bas
!debug      stdout.text(".contraction_wfs(1)[:,:]")
!debug      stdout.put(.contraction_wfs(1)[:,:])
!debug      stdout.text(".contraction_wfs(2)[:,:]")
!debug      stdout.put(.contraction_wfs(2)[:,:])
!debug      stdout.text(std_time.time_taken("geminal job "))
!debug      stdout.text(std_time.cpu_time_taken("geminal job "))
      ! Rotate
      do i = 1,n_geminals
        .special_ket(i).element = ZERO
      end
      S.create(n_bf,n_bf)
      R.create(n_bf,n_bf)
      eigenvalues.create(n_bf)
      do i = 1,n_bf
      do j = 1,i
         call random_number(val)
         S(i,j) = val
         S(j,i) = val
      end
      end
      S.solve_eigenproblem(eigenvalues,R)
    !  stdout.text("R")
    !  stdout.put(R)
      S=matmul(R,transpose(R))
      stdout.show("is unit matrix =",S.is_unit_matrix)
      V.create(n_bf)
      do i = 1,.n_bas
        do j=1,n_bf
        V=.contraction_wfs(i)[j,:]
        .contraction_wfs(i)[j,:].to_product_of(R,V)
        end
        do k=1,n_bf
        V=.contraction_wfs(i)[:,k]
        .contraction_wfs(i)[:,k].to_product_of(R,V)
        end
!        val = ZERO
!        do j=1,n_bf
!        do k=1,n_bf
!          val=val+ .contraction_wfs(i)[j,k]*.contraction_wfs(i)[j,k]
!        end
!        end
!        write(*,*) "i",i,val
      end
      do i = .n_bas+1,.n_bas+n_geminals-1
        do j=1,n_bf
         V=.ket(i-.n_bas+1)[j,:]
        .ket(i-.n_bas+1)[j,:].to_product_of(R,V)
         V=.bra(i-.n_bas+1)[j,:]
        .bra(i-.n_bas+1)[j,:].to_product_of(R,V)
        end
        do k=1,n_bf
        V=.ket(i-.n_bas+1)[:,k]
        .ket(i-.n_bas+1)[:,k].to_product_of(R,V)
        V=.bra(i-.n_bas+1)[:,k]
        .bra(i-.n_bas+1)[:,k].to_product_of(R,V)
        end
!        val = ZERO
!        do j=1,n_bf
!        do k=1,n_bf
!          val=val+ .bra(i-.n_bas+1)[j,k]*.bra(i-.n_bas+1)[j,k]
!        end
!        end
!        write(*,*) "i",i,val
      end
!      R.destroy
!      R.create(.n_bas,.n_bas)
!      S.destroy
!      S.create(.n_bas,.n_bas)
!      T.destroy
!      T.create(.n_bas,.n_bas)
!      U.destroy
!      U.create(.n_bas,.n_bas)
!      R=matmul(transpose(.bra(2)[:,:]),.bra(2)[:,:])
!      S=matmul(.bra(2)[:,:],transpose(.bra(2)[:,:]))
!      do i = 1,.n_bas
!      T=matmul(.contraction_wfs(i)[:,:],R)+matmul(S,.contraction_wfs(i)[:,:])
!        write(*,*) "T(1,1)",T(1,1)
!        write(*,*) "T(2,1)",T(2,1)
!        write(*,*) "T(1,2)",T(1,2)
!        write(*,*) "T(2,2)",T(2,2)
!      !    S=matmul(transpose(.contraction_wfs(i)[:,:]),.contraction_wfs(i)[:,:])
!      U=matmul(transpose(.contraction_wfs(i)[:,:]),T)
!          val=U.trace
!        write(*,*) "i,trace",i,val
!      end
!!      V.create(n_bfsq)
!!      do i = 1,.n_bas
!!        V.to_product_of(R,reshape(.contraction_wfs(i).element,[n_bfsq]))
!!        .contraction_wfs(i).element = reshape(V,[n_bf,n_bf])
!!        val = ZERO
!!        do j=1,n_bf
!!        do k=1,n_bf
!!          val=val+ .contraction_wfs(i)[j,k]*.contraction_wfs(i)[j,k]
!!        end
!!        end
!!        write(*,*) "i",i,val
!!      end
!!      do i = .n_bas+1,n_bfsq
!!        V.to_product_of(R,reshape(.ket(i-.n_bas+1).element,[n_bfsq]))
!!        .ket(i-.n_bas+1).element = reshape(V,[n_bf,n_bf])
!!        V.to_product_of(R,reshape(.bra(i-.n_bas+1).element,[n_bfsq]))
!!        .bra(i-.n_bas+1).element = reshape(V,[n_bf,n_bf])
!!        val = ZERO
!!        do j=1,n_bf
!!        do k=1,n_bf
!!          val=val+ .bra(i-.n_bas+1)[j,k]*.bra(i-.n_bas+1)[j,k]
!!        end
!!        end
!!        write(*,*) "i",i,val
!!      end
!!      .n_bas = ONE    
!      V.destroy
      eigenvalues.destroy
      R.destroy
      S.destroy
      T.destroy
      U.destroy
      stdout.text(std_time.time_taken("geminal job "))
      stdout.text(std_time.cpu_time_taken("geminal job "))
           !.ket(3)[1,1] = ZERO ! to be removed, used for testing
           !.ket(2)[2,2] = ZERO ! to be removed, used for testing
           !.ket(3)[3,3] = ZERO ! to be removed, used for testing
           !.ket(4)[4,4] = ZERO ! to be removed, used for testing
           !.ket(5)[5,5] = ZERO ! to be removed, used for testing
           !.ket(1)[4,3] = ONE! to be removed, used for testing
           !.ket(2)[1,4] = ONE! to be removed, used for testing
           !.ket(3)[2,5] = ONE! to be removed, used for testing
           !.ket(4)[5,1] = ONE! to be removed, used for testing
           !.ket(5)[3,2] = ONE ! to be removed, used for testing
           !.bra(3)[5,5] = ONE ! to be removed, used for testing
           !.bra(3)[5,3] = ONE ! to be removed, used for testing
           !.bra(5)[3,5] = ONE ! to be removed, used for testing
           !.bra(5)[5,5] = ZERO ! to be removed, used for testing
           !.bra(3)[3,3] = ZERO ! to be removed, used for testing
           !.bra(5)[6,6] = ONE ! to be removed, used for testing
   !stop
   end

!  ************
!  I/O Routines
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
       case ("do_overlap              "); .do_overlap
       case ("junk=                   "); .read_junk
       case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       case ("units=                  "); .read_units
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT)
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT)
   ! Read in a junk string, useful for ignoring a field
   end

   read_n_bf ::: leaky
   ! Read in a new value of ".n_bf", which must be smaller than the initial
   ! basis set size. Truncate the coefficient matrices.
   ENSURE(.bra.created,"no bra")
   ENSURE(.bra(1).element.created,"no bra elements")
   ENSURE(.ket.created,"no ket")
   ENSURE(.ket(1).element.created,"no ket elements")
      n_bf,i :: INT
      stdin.read(n_bf)
      ENSURE(n_bf<=.n_bf,"new size is not smaller")
      .n_bf = n_bf
      do i = 1,.n_geminals
         .bra(i).element.shrink(.n_bf,.n_bf)
         .ket(i).element.shrink(.n_bf,.n_bf)
      end
   end

!  ********************
!  Key related routines
!  ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
     the_keys :: VEC{STR}
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")
     word :: STR
     width,k :: INT
     width = .table_width
     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case default; DIE("unknown option")
         end
         if (k==size(keys)) then
           stdout.flush ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
     res :: INT
   ENSURE(keys.created,"no keys")
     int_dash,real_dash,k :: INT
     word :: STR
     int_dash = 0
     real_dash = 0
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}                "); ! exit surrounding loop
         case ("put_configuration"); real_dash = real_dash + 1
         case ("put_label        "); int_dash = int_dash + 1
         case ("put_n_shells     "); int_dash = int_dash + 1
         case ("put_n_bf         "); int_dash = int_dash + 1
         case ("put_n_prim       "); int_dash = int_dash + 1
         case ("flush            "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  ***************
!  Inquiry methods
!  ***************

   same_as(b) result(res) 
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      self :: IN
      b :: GEMINAL_MF_SPECTRUM, IN
      res :: BIN
      res = FALSE
   end

!  ***************
!  Integal methods
!  ***************

   do_overlap
   ! Evaluate the overlap integrals and print the result
      res :: MAT{REAL}(.n_bas,.n_bas)
   !debug   write(*,*) ".n_bas",.n_bas,".n_bf",.n_bf
      res = .overlap
    !  stdout.text("The overlap matrix is ")
    !  stdout.put(res)
   end

   overlap result (res)
   ! Evaluate the overlap integrals
      res :: MAT{REAL}(.n_bas,.n_bas)
   ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
      i :: INT
      reorder :: VEC{INT}*
      reorder.create(.n_geminals)
      reorder = [ (i, i=1,.n_geminals) ]
      !reorder.create(2)
      !reorder(1)=1
      !reorder(2)=2
     ! res(1,1) = .overlap_for(reorder,1,1)
      !stdout.show("1,1",res(1,1))
      res = .overlap_for(reorder)
      res = (res + transpose(res))/TWO 
      stdout.show("overlap is the unit matrix:",res.is_unit_matrix)
      stdout.show("1,1",res(1,1))
      stdout.show("1,2",res(1,2))
      stdout.show("2,1",res(2,1))
      stdout.show("2,2",res(2,2))
   !   reorder = [ (i, i=1,.n_geminals) ]
   !   .special_ket(.n_geminals)[1]=5
   !   .special_ket(.n_geminals)[2]=5
   !   res = .special_overlap_spin_ab_for(reorder,row_ind,col_ind,5,5)
   !   stdout.show("overlap ab55 is the unit matrix:",res.is_unit_matrix)
   !  reorder = [ (i, i=1,.n_geminals) ]
   !   .special_ket(.n_geminals)[1]=5
   !   .special_ket(.n_geminals)[2]=6
   !   res = .special_overlap_spin_aa_for(reorder,row_ind,col_ind,5,6)
   !   stdout.show("overlap aa56 is the unit matrix:",res.is_unit_matrix)
      reorder.destroy
   end

   overlap_for(order) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix between
   ! mean field (Sz=0)-geminals (upper triangle only is evaluated)
!comments:
!1) Because of the special_overlap_spin_aa_for function i=1 can be a special ket 
!so we need to test that col_ind is ZERO AND i==1 to start looping on col_ind.
!2) special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     order :: VEC{INT}
     res :: MAT{REAL}(.n_bas,.n_bas)

     ENSURE(order.dim>0,"dim negative or zero")
     ENSURE(.special_ket(1)[1]==0,".special_ket(1) already set")
      
     ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,row_ind,col_ind :: INT
     fac :: REAL
     reorder :: VEC{INT}*
     dim = order.dim

     res = ZERO
      
     if (dim==1) then
       ! case 1
       i = order(1)
       if (i/=1 ) DIE("dim=1 and i/=1")
       do  col_ind=1,.n_bas
         do  row_ind=1,col_ind 
           fac = sum(.contraction_wfs(row_ind)[:,:]*.contraction_wfs(col_ind)[:,:])
           if (NOT fac.is_zero) then
             res(row_ind,col_ind) = fac
           end
         end
       end
       return
        ! no Case 2 when dim =1
     else
     ! dim > 1
       do ii = dim,1,-1
         i = order(ii)
         if (i==1) then
           do  col_ind=1,.n_bas
           ! Case 1
             fac = sum(.bra(dim)[:,:]*.contraction_wfs(col_ind)[:,:])
             if (NOT fac.is_zero) then
               reorder.create(dim-1)
               reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
               reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
               res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
               reorder.destroy
             end
          ! Case 2
             do jj = dim,ii+1,-1
               j = order(jj)
               if (.special_ket(j)[1]>0) then
               ! Case 2, only j special
                 bj1 = .special_ket(j)[1]
                 bj2 = .special_ket(j)[2]
                 do bi2 = 1,.n_bf
                   fac = ZERO
                   if (bi2==bj2) then
                     do bi1 = 1,bj1-1
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                     do bi1 = bj1+1,.n_bf
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                     fac = fac+ TWO*.contraction_wfs(col_ind)[bj1,bi2]*.bra(dim)[bj1,bj2]
                   else
                     do bi1 = 1,.n_bf
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                   end
                   if (NOT fac.is_zero) then
                     reorder.create(dim-1)
                     reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                     reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                     reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                     reorder(dim-1) = j 
                  !  .special_ket(j)[1] = bj1 
                     .special_ket(j)[2] = bi2 
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3       .special_ket(j)[1] = 0 ! j=reorder(dim-1)
!test3       .special_ket(j)[2] = 0 ! j=reorder(dim-1)
! seems safer to put back the value bj1 and bj2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                     .special_ket(j)[2] = bj2
                     reorder.destroy
                   end
                 end
               else 
               !  Case 2, NONE SPECIAL
                 do bi2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = ZERO
                   do bi1 = 1,.n_bf
                   do bj2 = 1,.n_bf
                     fac = fac + (.contraction_wfs(col_ind)[bi1,bi2]*.ket(j)[bj1,bj2] +  &
                            .contraction_wfs(col_ind)[bj1,bj2]*.ket(j)[bi1,bi2])* .bra(dim)[bi1,bj2]
                   end
                   end
                   if (NOT fac.is_zero) then
                     reorder.create(dim-1)
                     reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                     reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                     reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                     reorder(dim-1) = j 
                     .special_ket(j)[1] = bj1 
                     .special_ket(j)[2] = bi2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
                     .special_ket(j)[1] = 0 
                     .special_ket(j)[2] = 0
                     reorder.destroy
                   end
                 end
                 end
               end
             end
           end
         else !i>1
           ! case 1
           if (.special_ket(i)[1]>0) then
             bi1 = .special_ket(i)[1]
             bi2 = .special_ket(i)[2]
             fac = .bra(dim)[bi1,bi2]
           else
             fac = sum(.bra(dim)[:,:]*.ket(i)[:,:])
           end
           if (NOT fac.is_zero) then
             reorder.create(dim-1)
             reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
             reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
             res = res + .overlap_for(reorder) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
             reorder.destroy
           end
           ! Case 2
           do jj = dim,ii+1,-1
             j = order(jj)
!test2 it is enough to have only   if (.special_ket(i)[1]>0 ) then
! however safer to have full test, specially if we generalise the routine
! in the future
             if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
             !  Case 2, i special, j special
               bi1 = .special_ket(i)[1]
               bi2 = .special_ket(i)[2]
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               fac = .bra(dim)[bi1,bj2]
               if (bi1==bj1 AND bi2==bj2)  fac=TWO * fac
               reorder.create(dim-1)
               reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
               reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
               reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
               reorder(dim-1) = i 
               .special_ket(i)[1] = bj1 ! i=reorder(dim-1)
             ! .special_ket(i)[2] = bi2 
               res = res - .overlap_for(reorder) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
               .special_ket(i)[1] = bi1
               reorder.destroy
!test2 it is enough to have only  else if (.special_ket(j)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
             ! Case 2, only j special
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               do bi2 = 1,.n_bf
                 fac = ZERO
                 if (bi2==bj2) then
                   do bi1 = 1,bj1-1
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   do bi1 = bj1+1,.n_bf
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   fac = fac+ TWO*.ket(i)[bj1,bi2]*.bra(dim)[bj1,bj2]
                 else
                   do bi1 = 1,.n_bf
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                 end
                 if (NOT fac.is_zero) then
                   reorder.create(dim-1)
                   reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                   reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                   reorder(dim-1) = j 
               !   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2 ! j=reorder(dim-1)
                   res = res - .overlap_for(reorder) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                   .special_ket(j)[2] = bj2
                   reorder.destroy
                 end
               end
!test2 it is enough to have only  else 
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
             !  Case 2, NONE SPECIAL
               do bi2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = ZERO
                 do bi1 = 1,.n_bf
                 do bj2 = 1,.n_bf
                   fac = fac + (.ket(i)[bi1,bi2]*.ket(j)[bj1,bj2]+.ket(i)[bj1,bj2]*.ket(j)[bi1,bi2])*.bra(dim)[bi1,bj2]
                 end
                 end
                 if (NOT fac.is_zero) then
                   reorder.create(dim-1)
                   reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                   reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                   reorder(dim-1) = j 
                   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2
                   res = res - .overlap_for(reorder) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
                   .special_ket(j)[1] = 0 
                   .special_ket(j)[2] = 0 
                   reorder.destroy
                 end 
               end
               end
!test2 next 3 lines not needed
! however safer to have full test, specially if we generalise the routine
! in the future
             else 
               DIE("i special ket but not j !")
             end
           end  ! for do jj=dim,ii+1,-1
         end ! end for the if(i==1) else
       end  ! for do ii=dim,1,-1
     end ! for if(dim==1)
   end

   overlap_for(order,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals column
   ! vector specified by col_ind between mean field (Sz=0)-geminals 
   ! upper half only is evaluated.
!comments:
!1) Because of the special_overlap_spin_aa_for function i=1 can be a special ket 
!so we need to test that col_ind is ZERO AND i==1 to start looping on col_ind.
!2) special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     col_ind :: INT
     order :: VEC{INT}
     res :: VEC{REAL}(.n_bas)
     ENSURE(order.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,row_ind :: INT
     fac :: REAL
     reorder :: VEC{INT}*
     dim = order.dim

     res = ZERO
      
     if (dim==1) then
       ! case 1
       i = order(1)
       if (.special_ket(1)[1]/=0 AND i==1 ) DIE("dim=1, i=1 but .special_ket(1) not set!") 
       do  row_ind=1,col_ind
         if (.special_ket(i)[1]>0) then             
           bi1 = .special_ket(i)[1]                 
           bi2 = .special_ket(i)[2]                
           fac = .contraction_wfs(row_ind)[bi1,bi2]
         else
           fac = sum(.contraction_wfs(row_ind)[:,:]*.ket(i)[:,:])
         end
         if (NOT fac.is_zero) then
           res(row_ind) = fac
         end
       end
       return
       ! no Case 2 when dim =1
     else
     ! dim > 1
       do ii = dim,1,-1
         i = order(ii)
         if (.special_ket(1)[1]/=0 AND i==1 ) DIE("dim=1, i=1 but .special_ket(1) not set!") 
         ! case 1
         if (.special_ket(i)[1]>0) then
            bi1 = .special_ket(i)[1]
            bi2 = .special_ket(i)[2]
            fac = .bra(dim)[bi1,bi2]
         else
            fac = sum(.bra(dim)[:,:]*.ket(i)[:,:])
         end
         if (NOT fac.is_zero) then
           reorder.create(dim-1)
           reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
           reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
           res = res + .overlap_for(reorder,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
           reorder.destroy
         end
         ! Case 2
         do jj = dim,ii+1,-1
           j = order(jj)
!test2 it is enough to have only   if (.special_ket(i)[1]>0 ) then
! however safer to have full test, specially if we generalise the routine
! in the future
           if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
           !  Case 2, i special, j special
             bi1 = .special_ket(i)[1]
             bi2 = .special_ket(i)[2]
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             fac = .bra(dim)[bi1,bj2]
             if (bi1==bj1 AND bi2==bj2)  fac=TWO * fac
             reorder.create(dim-1)
             reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
             reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
             reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
             reorder(dim-1) = i 
             .special_ket(i)[1] = bj1 ! i=reorder(dim-1)
           ! .special_ket(i)[2] = bi2 
             res = res - .overlap_for(reorder,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
             .special_ket(i)[1] = bi1
             reorder.destroy
!test2 it is enough to have only  else if (.special_ket(j)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
           ! Case 2, only j special
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             do bi2 = 1,.n_bf
               fac = ZERO
               if (bi2==bj2) then
                 do bi1 = 1,bj1-1
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
                 do bi1 = bj1+1,.n_bf
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
                 fac = fac+ TWO*.ket(i)[bj1,bi2]*.bra(dim)[bj1,bj2]
               else
                 do bi1 = 1,.n_bf
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
               end
               if (NOT fac.is_zero) then
                 reorder.create(dim-1)
                 reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                 reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                 reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                 reorder(dim-1) = j 
             !   .special_ket(j)[1] = bj1 
                 .special_ket(j)[2] = bi2 ! j=reorder(dim-1)
                 res = res - .overlap_for(reorder,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3  seems safer to put back the value bj1 and bj2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                 .special_ket(j)[2] = bj2
                 reorder.destroy
               end
             end
!test2 it is enough to have only  else 
! however safer to have full test, specially if we generalise the routine
! in the future
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
           !  Case 2, NONE SPECIAL
             do bi2 = 1,.n_bf
             do bj1 = 1,.n_bf
               fac = ZERO
               do bi1 = 1,.n_bf
               do bj2 = 1,.n_bf
                 fac = fac + (.ket(i)[bi1,bi2]*.ket(j)[bj1,bj2]+.ket(i)[bj1,bj2]*.ket(j)[bi1,bi2])*.bra(dim)[bi1,bj2]
               end
               end
               if (NOT fac.is_zero) then
                 reorder.create(dim-1)
                 reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                 reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                 reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                 reorder(dim-1) = j 
                 .special_ket(j)[1] = bj1 
                 .special_ket(j)[2] = bi2
                 res = res - .overlap_for(reorder,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
                 .special_ket(j)[1] = 0 
                 .special_ket(j)[2] = 0 
                 reorder.destroy
               end 
             end
             end
!test2 next 3 lines not needed
! however safer to have full test, specially if we generalise the routine
! in the future
           else 
             DIE("i special ket but not j !")
           end
         end  ! for do jj=dim,ii+1,-1
       end  ! for do ii=dim,1,-1
     end ! for if(dim==1)
   end

   overlap_for(order,row_ind,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix
   ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!comments:
!1) Because of the special_overlap_spin_aa_for function i=1 can be a special ket 
!so we need to test that col_ind is ZERO AND i==1 to start looping on col_ind.
!2) special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     row_ind, col_ind :: INT
     order :: VEC{INT}
     res :: REAL
     ENSURE(order.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2 :: INT
     fac :: REAL
     reorder :: VEC{INT}*
     dim = order.dim

     res = ZERO
      
     if (dim==1) then
       ! case 1
       i = order(1)
       if (.special_ket(i)[1]>0) then             
         bi1 = .special_ket(i)[1]                 
         bi2 = .special_ket(i)[2]                
!debug       write(*,*)"coucou1",i,bi1,bi2
         fac = .contraction_wfs(row_ind)[bi1,bi2]
       else if(.special_ket(i)[1]==0 AND i==1) then
         fac = sum(.contraction_wfs(row_ind)[:,:]*.contraction_wfs(col_ind)[:,:])
       else if (.special_ket(i)[1]==0 AND i/=1) then
         fac = sum(.contraction_wfs(row_ind)[:,:]*.ket(i)[:,:])
       end
       if (NOT fac.is_zero) then
          res = fac
!debug       write(*,*)"res",res
       end
       return
        ! no Case 2 when dim =1
     else
     ! dim > 1
       do ii = dim,1,-1
         i = order(ii)
         if (i==1) then
!debug         write(*,*)"coucou2",ii
         ! Case 1
           if (.special_ket(1)[1]>0) then             
             bi1 = .special_ket(1)[1]
             bi2 = .special_ket(1)[2]
             fac = .bra(dim)[bi1,bi2]
           else
             fac = sum(.bra(dim)[:,:]*.contraction_wfs(col_ind)[:,:])
           end
           if (NOT fac.is_zero) then
             reorder.create(dim-1)
             reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
             reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
             res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
             reorder.destroy
           end
        ! Case 2
           do jj = dim,ii+1,-1
             j = order(jj)
!debug             write(*,*) "dim,j",dim,j
!test2 it is enough to have only  else if (.special_ket(1)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
             if (.special_ket(1)[1]>0 AND .special_ket(j)[1]>0) then
             !  Case 2, 1 special, j special
               bi1 = .special_ket(1)[1]
               bi2 = .special_ket(1)[2]
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               fac = .bra(dim)[bi1,bj2]
               if (bi1==bj1 AND bi2==bj2)  fac=TWO * fac
               reorder.create(dim-1)
               reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
               reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
               reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
               reorder(dim-1) = 1 
               .special_ket(i)[1] = bj1 ! i=reorder(dim-1)
             ! .special_ket(i)[2] = bi2 
               res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3 seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
               .special_ket(i)[1] = bi1
               reorder.destroy
!test2 it is enough to have only  else if (.special_ket(j)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(1)[1]==0 AND .special_ket(j)[1]>0) then
             ! Case 2, only j special
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               do bi2 = 1,.n_bf
                 fac = ZERO
                 if (bi2==bj2) then
                   do bi1 = 1,bj1-1
                     fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   do bi1 = bj1+1,.n_bf
                     fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   fac = fac+ TWO*.contraction_wfs(col_ind)[bj1,bi2]*.bra(dim)[bj1,bj2]
                 else
                   do bi1 = 1,.n_bf
                     fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                 end
                 if (NOT fac.is_zero) then
                   reorder.create(dim-1)
                   reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                   reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                   reorder(dim-1) = j 
                !  .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2 
                   res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3 seems safer to put back the value bj1 and bj2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                   .special_ket(j)[2] = bj2
                   reorder.destroy
                 end
               end
             else 
             !  Case 2, NONE SPECIAL
!debug               write(*,*) "coucou Case 2, NONE SPECIAL"
!debug               write(*,*) "row_ind,col_ind,dim",row_ind,col_ind,dim
!debug      stdout.text(".contraction_wfs(col_ind)[:,:]")
!debug      stdout.put(.contraction_wfs(col_ind)[:,:])
             !debug  stdout.put(.contraction_wfs(col_ind)[:,:])
               do bi2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = ZERO
                 do bi1 = 1,.n_bf
                 do bj2 = 1,.n_bf
! double matrix multiplication, can be made faster
                   fac = fac + (.contraction_wfs(col_ind)[bi1,bi2]*.ket(j)[bj1,bj2] + &
                        .contraction_wfs(col_ind)[bj1,bj2]*.ket(j)[bi1,bi2])* .bra(dim)[bi1,bj2]
                 end
                 end
                 if (NOT fac.is_zero) then
!debug                   write(*,*) "bj1,bi2,fac",bj1,bi2,fac
                   reorder.create(dim-1)
                   reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                   reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                   reorder(dim-1) = j 
                   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2
                   res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
                   .special_ket(j)[1] = 0 
                   .special_ket(j)[2] = 0
                   reorder.destroy
                 end
               end
               end
             end  ! if (.special_ket(j)
           end !do jj
         else if( i>1) then
       ! simple case 1
           if (.special_ket(i)[1]>0) then
              bi1 = .special_ket(i)[1]
              bi2 = .special_ket(i)[2]
              fac = .bra(dim)[bi1,bi2]
           else
              fac = sum(.bra(dim)[:,:]*.ket(i)[:,:])
           end
           if (NOT fac.is_zero) then
               reorder.create(dim-1)
               reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
               reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
               res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
               reorder.destroy
           end
           ! Case 2
           do jj = dim,ii+1,-1
             j = order(jj)
!test2 it is enough to have only   if (.special_ket(i)[1]>0 ) then
! however safer to have full test, specially if we generalise the routine
! in the future
             if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
             !  Case 2, i special, j special
               bi1 = .special_ket(i)[1]
               bi2 = .special_ket(i)[2]
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               fac = .bra(dim)[bi1,bj2]
               if (bi1==bj1 AND bi2==bj2)  fac=TWO * fac
               reorder.create(dim-1)
               reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
               reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
               reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
               reorder(dim-1) = i 
               .special_ket(i)[1] = bj1 ! i=reorder(dim-1)
             ! .special_ket(i)[2] = bi2 
               res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3 seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
               .special_ket(i)[1] = bi1
               reorder.destroy
!test2 it is enough to have only  else if (.special_ket(j)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
             ! Case 2, only j special
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               do bi2 = 1,.n_bf
                 fac = ZERO
                 if (bi2==bj2) then
                   do bi1 = 1,bj1-1
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   do bi1 = bj1+1,.n_bf
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                     fac = fac+ TWO*.ket(i)[bj1,bi2]*.bra(dim)[bj1,bj2]
                 else
                   do bi1 = 1,.n_bf
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                 end
                 if (NOT fac.is_zero) then
                   reorder.create(dim-1)
                   reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                   reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                   reorder(dim-1) = j 
               !   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2 ! j=reorder(dim-1)
                   res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!test3 seems safer to put back the value bj1 and bj2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                   .special_ket(j)[2] = bj2
                   reorder.destroy
                 end
               end
!test2 it is enough to have only  else 
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
             !  Case 2, NONE SPECIAL
               do bi2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = ZERO
                 do bi1 = 1,.n_bf
                 do bj2 = 1,.n_bf
                   fac = fac + (.ket(i)[bi1,bi2]*.ket(j)[bj1,bj2]+.ket(i)[bj1,bj2]*.ket(j)[bi1,bi2])*.bra(dim)[bi1,bj2]
                 end
                 end
                 if (NOT fac.is_zero) then
                   reorder.create(dim-1)
                   reorder(1:ii-1)   = [ (order(k), k=1,ii-1) ]
                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                   reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                   reorder(dim-1) = j 
                   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2
                   res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
                   .special_ket(j)[1] = 0 
                   .special_ket(j)[2] = 0 
                   reorder.destroy
                 end 
               end
               end
!test2 next 3 lines not needed
! however safer to have full test, specially if we generalise the routine
! in the future
             else 
               DIE("i special ket but not j !")
             end
           end  ! for do jj=dim,ii+1,-1
         end ! end for the if(i==1) else
       end  ! for do ii=dim,1,-1
     end ! for if(dim==1)
   end


!temp-debug   special_overlap_spin_ab_for(order,row_ind,col_ind,b1,b2) result (res)
!temp-debug   ! Special function which evaluates the overlap integrals between
!temp-debug   ! mean field (Sz=0)-geminals when .bra(dim) is a special bra
!temp-debug   ENSURE(order.dim>0,"dimension zero or negative")
!temp-debug   ENSURE(.special_ket(order.dim)[2]>0,"no special ket matching special bra")
!temp-debug      row_ind,col_ind,b1,b2 :: INT
!temp-debug      order :: VEC{INT}
!temp-debug      res :: MAT{REAL}(.n_bas,.n_bas)
!temp-debug      ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2 :: INT
!temp-debug      fac :: REAL
!temp-debug      reorder :: VEC{INT}*
!temp-debug      dim = order.dim
!temp-debug     !debug write(*,*) "dim =",dim
!temp-debug
!temp-debug      res = ZERO
!temp-debug      
!temp-debug      if (dim==1) then
!temp-debug         ii=1
!temp-debug         i = order(ii)
!temp-debug        !debug   write(*,*) "i =",i
!temp-debug         if (.special_ket(i)[1]==b1 AND .special_ket(i)[2]==b2 ) res = ONE
!temp-debug         return
!temp-debug      end
!temp-debug      ! dim > 1
!temp-debug      do ii = dim,2,-1
!temp-debug         i = order(ii)
!temp-debug         ! The simple case 1
!temp-debug         if (.special_ket(i)[1]>0) then
!temp-debug           bi1 = .special_ket(i)[1]
!temp-debug           bi2 = .special_ket(i)[2]
!temp-debug      !debug   write(*,*) "i =",i
!temp-debug           if (bi1==b1 AND bi2==b2 ) then
!temp-debug             reorder.create(dim-1)
!temp-debug             reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug             reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug              res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug              reorder.destroy
!temp-debug           end
!temp-debug         else
!temp-debug           fac = .ket(i)[b1,b2]
!temp-debug           if (NOT fac.is_zero) then
!temp-debug             reorder.create(dim-1)
!temp-debug             reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug             reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug              res = res + .overlap_for(reorder,row_ind,col_ind)*fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug              reorder.destroy
!temp-debug           end
!temp-debug         end
!temp-debug         ! Case 2
!temp-debug         do jj = dim,ii+1,-1
!temp-debug           j = order(jj)
!temp-debug           if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
!temp-debug!test2           if (.special_ket(i)[1]>0 ) then
!temp-debug           !  Case 2, i special, j special
!temp-debug             bi1 = .special_ket(i)[1]
!temp-debug             bi2 = .special_ket(i)[2]
!temp-debug             bj1 = .special_ket(j)[1]
!temp-debug             bj2 = .special_ket(j)[2]
!temp-debug             if (bi1==b1 AND bj2==b2) then
!temp-debug               fac = ONE
!temp-debug               if (bi1==bj1 AND bi2==bj2)  fac=TWO 
!temp-debug               reorder.create(dim-1)
!temp-debug               reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug               reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug               reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
!temp-debug               reorder(dim-1) = i 
!temp-debug               .special_ket(i)[1] = bj1 ! i=reorder(dim-1)
!temp-debug             ! .special_ket(i)[2] = bi2 
!temp-debug           !debug  stdout.text("Case 2, i special, j special")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  stdout.show("j =",j)
!temp-debug           !debug  stdout.show("bi1 =",bi1)
!temp-debug           !debug  stdout.show("bj2 =",bj2)
!temp-debug           !debug  stdout.show("bj1 =",bj1)
!temp-debug           !debug  stdout.show("bi2 =",bi2)
!temp-debug             !debug stdout.text("reorder:")
!temp-debug             !debug stdout.put(reorder)
!temp-debug             !debug stdout.text("special_ket:")
!temp-debug             !debug stdout.put(.special_ket)
!temp-debug           !debug  write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug               res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug       !debug  write(*,*) "returned from recursion, dim =",dim
!temp-debug!test3         .special_ket(i)[2] = 0 
!temp-debug               .special_ket(i)[1] = bi1
!temp-debug               reorder.destroy
!temp-debug             end
!temp-debug           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
!temp-debug             ! Case 2, only j special
!temp-debug             bj1 = .special_ket(j)[1]
!temp-debug             bj2 = .special_ket(j)[2]
!temp-debug             if (bj2 == b2 ) then
!temp-debug               do bi2 = 1,.n_bf
!temp-debug                 if (bi2==bj2 AND b1==bj1 ) then
!temp-debug                     fac =  TWO*.ket(i)[b1,bi2]
!temp-debug                 else
!temp-debug                     fac =  .ket(i)[b1,bi2]
!temp-debug                 end
!temp-debug                 if (NOT fac.is_zero) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                   reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
!temp-debug                   reorder(dim-1) = j 
!temp-debug          !debug           stdout.text("reorder:")
!temp-debug          !debug           stdout.put(reorder)
!temp-debug               !   .special_ket(j)[1] = bj1 
!temp-debug                   .special_ket(j)[2] = bi2 ! j=reorder(dim-1)
!temp-debug          !debug stdout.text("Case 2, only j special")
!temp-debug          !debug stdout.show("i =",i)
!temp-debug          !debug stdout.show("j =",j)
!temp-debug          !debug stdout.show("bi1 =",bi1)
!temp-debug          !debug stdout.show("bj2 =",bj2)
!temp-debug          !debug stdout.show("bj1 =",bj1)
!temp-debug          !debug stdout.show("bi2 =",bi2)
!temp-debug          !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug         !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug!test3                   .special_ket(j)[1] = 0 ! j=reorder(dim-1)
!temp-debug                   .special_ket(j)[2] = bj2
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
!temp-debug           !  Case 2, NONE SPECIAL
!temp-debug             do bi2 = 1,.n_bf
!temp-debug             do bj1 = 1,.n_bf
!temp-debug               fac = .ket(i)[b1,bi2]*.ket(j)[bj1,b2]+.ket(i)[bj1,b2]*.ket(j)[b1,bi2]
!temp-debug               if (NOT fac.is_zero) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                 reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                 reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
!temp-debug                 reorder(dim-1) = j 
!temp-debug               !debug   stdout.text("Case 2, NONE SPECIAL")
!temp-debug               !debug   stdout.show("i =",i)
!temp-debug               !debug   stdout.show("j =",j)
!temp-debug               !debug   stdout.show("bi1 =",bi1)
!temp-debug               !debug   stdout.show("bi2 =",bi2)
!temp-debug               !debug   stdout.show("bj1 =",bj1)
!temp-debug               !debug   stdout.show("bj2 =",bj2)
!temp-debug                 !debug    stdout.text("reorder:")
!temp-debug                 !debug    stdout.put(reorder)
!temp-debug                 !debug    stdout.text("Before set ....")
!temp-debug                 !debug    stdout.text("special_ket:")
!temp-debug                 !debug    stdout.put(.special_ket)
!temp-debug                 .special_ket(j)[1] = bj1 ! j=reorder(dim-1)
!temp-debug                 .special_ket(j)[2] = bi2 ! j=reorder(dim-1)
!temp-debug           !debug  write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res - .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug        !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug                 .special_ket(j)[1] = 0 ! j=reorder(dim-1)
!temp-debug                 .special_ket(j)[2] = 0 ! j=reorder(dim-1)
!temp-debug                 reorder.destroy
!temp-debug               end 
!temp-debug             end
!temp-debug             end
!temp-debug           end
!temp-debug         end
!temp-debug      end
!temp-debug   end
!temp-debug
!temp-debug   special_overlap_spin_bb_for(order,row_ind,col_ind,b1,b2) result (res)
!temp-debug   ! Special function which evaluates the overlap integrals between
!temp-debug   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
!temp-debug   ! special bra which are (Sz=-1)-geminals.
!temp-debug   ENSURE(order.dim>0,"dimension zero or negative")
!temp-debug   ENSURE(.special_ket(order.dim)[2]>0,"no special ket matching special bra")
!temp-debug      row_ind,col_ind,b1,b2 :: INT
!temp-debug      order :: VEC{INT}
!temp-debug      res :: MAT{REAL}(.n_bas,.n_bas)
!temp-debug      ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,b3,b4 :: INT
!temp-debug      fac :: REAL
!temp-debug      reorder :: VEC{INT}*
!temp-debug      dim = order.dim
!temp-debug     !debug write(*,*) "dim =",dim
!temp-debug
!temp-debug      res = ZERO
!temp-debug      
!temp-debug      ! test for identical spinorbitals
!temp-debug      i = order(dim)
!temp-debug      b3 = .special_ket(i)[1]
!temp-debug      b4 = .special_ket(i)[2]
!temp-debug      if (b3==b4 OR b1==b2 ) return
!temp-debug      
!temp-debug      ! Case 1
!temp-debug      if (dim==1) then
!temp-debug        !debug   write(*,*) "i =",i
!temp-debug         if (b3==b1 AND b4==b2 ) res = ONE
!temp-debug         if (b3==b2 AND b4==b1 ) res = -ONE
!temp-debug         return
!temp-debug      end
!temp-debug      ! dim>1 Case 1
!temp-debug      if (b3==b1 AND b4==b2 ) then
!temp-debug        reorder.create(dim-1)
!temp-debug        reorder(1:dim-1)   = [ (order(j), j=1,dim-1) ]
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug         res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug         reorder.destroy
!temp-debug      end
!temp-debug      if (b3==b2 AND b4==b1 ) then
!temp-debug        reorder.create(dim-1)
!temp-debug        reorder(1:dim-1)   = [ (order(j), j=1,dim-1) ]
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug        res = res - .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug        reorder.destroy
!temp-debug      end
!temp-debug      ! this loop does something only if dim > 1
!temp-debug      do ii = dim-1,1,-1
!temp-debug         i = order(ii)
!temp-debug         if(col_ind==0 AND i==1) then
!temp-debug           do col_ind=1,.n_bas
!temp-debug             ! Case 2
!temp-debug             if (b4==b2 ) then
!temp-debug               do bi1=1,.n_bf
!temp-debug                 fac = - .contraction_wfs(col_ind)[bi1,b1]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = 1
!temp-debug                   .special_ket(1)[2] = b3 
!temp-debug                   .special_ket(1)[1] = bi1 
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(1)[1] = ZERO
!temp-debug                   .special_ket(1)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug             if (b4==b1 ) then
!temp-debug               do bi1=1,.n_bf
!temp-debug                 fac =  .contraction_wfs(col_ind)[bi1,b2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = 1
!temp-debug                   .special_ket(1)[2] = b3 
!temp-debug                   .special_ket(1)[1] = bi1 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(1)[1] = ZERO
!temp-debug                   .special_ket(1)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug             if (b3==b2 ) then
!temp-debug               do bi1=1,.n_bf
!temp-debug                 fac =  .contraction_wfs(col_ind)[bi1,b1]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = 1
!temp-debug                   .special_ket(1)[2] = b4 
!temp-debug                   .special_ket(1)[1] = bi1 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(1)[1] = ZERO
!temp-debug                   .special_ket(1)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug             if (b3==b1 ) then
!temp-debug               do bi1=1,.n_bf
!temp-debug                 fac = - .contraction_wfs(col_ind)[bi1,b2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = 1
!temp-debug                   .special_ket(1)[2] = b4 
!temp-debug                   .special_ket(1)[1] = bi1 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(1)[1] = ZERO
!temp-debug                   .special_ket(1)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug             ! Case 3
!temp-debug             ! only do something if dim>2
!temp-debug             do jj = dim-1,ii+1,-1
!temp-debug               j = order(jj)
!temp-debug               if (.special_ket(j)[1]>0) then
!temp-debug               ! Case 3, only j special
!temp-debug                 bj2 = .special_ket(j)[2]
!temp-debug                 if (bj2==b2) then
!temp-debug               !   bj1 = .special_ket(j)[1]
!temp-debug                   do bi1 = 1,.n_bf
!temp-debug                     fac = .contraction_wfs(col_ind)[bi1,b1]
!temp-debug                     if (NOT fac.is_zero ) then
!temp-debug                       reorder.create(dim-1)
!temp-debug                       reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                       reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                       reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                       reorder(dim-2) = 1 
!temp-debug                       reorder(dim-1) = j 
!temp-debug              !debug           stdout.text("reorder:")
!temp-debug              !debug           stdout.put(reorder)
!temp-debug                       .special_ket(1)[2] = b3 
!temp-debug                       .special_ket(1)[1] = bi1 
!temp-debug                       .special_ket(j)[2] = b4
!temp-debug                    !   .special_ket(j)[2] = bj2 unchanged
!temp-debug              !debug stdout.text("Case 2, only j special")
!temp-debug              !debug stdout.show("i =",i)
!temp-debug              !debug stdout.show("j =",j)
!temp-debug              !debug stdout.show("bi1 =",bi1)
!temp-debug              !debug stdout.show("bj2 =",bj2)
!temp-debug              !debug stdout.show("bj1 =",bj1)
!temp-debug              !debug stdout.show("bi2 =",bi2)
!temp-debug              !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                       res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug             !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug    !test3             .special_ket(j)[1] = bj1 unchanged
!temp-debug                       .special_ket(1)[1] = ZERO 
!temp-debug                       .special_ket(1)[2] = ZERO 
!temp-debug                       .special_ket(j)[2] = bj2
!temp-debug                       reorder.destroy
!temp-debug                     end
!temp-debug                   end
!temp-debug                 end
!temp-debug                 if (bj2==b1) then
!temp-debug               !   bj1 = .special_ket(j)[1]
!temp-debug                   do bi1 = 1,.n_bf
!temp-debug                     fac = - .contraction_wfs(col_ind)[bi1,b2]
!temp-debug                     if (NOT fac.is_zero ) then
!temp-debug                       reorder.create(dim-1)
!temp-debug                       reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                       reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                       reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                       reorder(dim-2) = 1 
!temp-debug                       reorder(dim-1) = j 
!temp-debug              !debug           stdout.text("reorder:")
!temp-debug              !debug           stdout.put(reorder)
!temp-debug                       .special_ket(1)[2] = b3 
!temp-debug                       .special_ket(1)[1] = bi1 
!temp-debug                       .special_ket(j)[2] = b4
!temp-debug                    !   .special_ket(j)[1] = bj1 unchanged
!temp-debug              !debug stdout.text("Case 2, only j special")
!temp-debug              !debug stdout.show("i =",i)
!temp-debug              !debug stdout.show("j =",j)
!temp-debug              !debug stdout.show("bi1 =",bi1)
!temp-debug              !debug stdout.show("bj2 =",bj2)
!temp-debug              !debug stdout.show("bj1 =",bj1)
!temp-debug              !debug stdout.show("bi2 =",bi2)
!temp-debug              !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                       res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug             !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug    !test3             .special_ket(j)[1] = bj1 unchanged
!temp-debug                       .special_ket(1)[1] = ZERO 
!temp-debug                       .special_ket(1)[2] = ZERO 
!temp-debug                       .special_ket(j)[2] = bj2
!temp-debug                       reorder.destroy
!temp-debug                     end
!temp-debug                   end
!temp-debug                 end
!temp-debug               else 
!temp-debug               !  Case 3, NONE SPECIAL
!temp-debug                 do bi1 = 1,.n_bf
!temp-debug                 do bj1 = 1,.n_bf
!temp-debug                   fac = .contraction_wfs(col_ind)[bi1,b1]*.ket(j)[bj1,b2]-.contraction_wfs(col_ind)[bi1,b2]*.ket(j)[bj1,b1]
!temp-debug                   if (NOT fac.is_zero ) then
!temp-debug                     reorder.create(dim-1)
!temp-debug                     reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                     reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                     reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                     reorder(dim-2) = 1 
!temp-debug                     reorder(dim-1) = j 
!temp-debug              !debug           stdout.text("reorder:")
!temp-debug              !debug           stdout.put(reorder)
!temp-debug                     .special_ket(1)[2] = b3 
!temp-debug                     .special_ket(1)[1] = bi1 
!temp-debug                     .special_ket(j)[2] = b4
!temp-debug                     .special_ket(j)[1] = bj1 
!temp-debug              !debug stdout.text("Case 2, only j special")
!temp-debug              !debug stdout.show("i =",i)
!temp-debug              !debug stdout.show("j =",j)
!temp-debug              !debug stdout.show("bi1 =",bi1)
!temp-debug              !debug stdout.show("bj2 =",bj2)
!temp-debug              !debug stdout.show("bj1 =",bj1)
!temp-debug              !debug stdout.show("bi2 =",bi2)
!temp-debug              !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                     res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug             !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug                     .special_ket(1)[1] = ZERO 
!temp-debug                     .special_ket(1)[2] = ZERO 
!temp-debug                     .special_ket(j)[1] = ZERO
!temp-debug                     .special_ket(j)[2] = ZERO
!temp-debug                     reorder.destroy
!temp-debug                   end
!temp-debug                 end
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug!test1
!temp-debug           col_ind=0
!temp-debug         else
!temp-debug           ! Case 2
!temp-debug           if (b4==b2 ) then
!temp-debug             if (.special_ket(i)[1]>0) then
!temp-debug               bi2 = .special_ket(i)[2]
!temp-debug               if (bi2==b1 ) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                 reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                 reorder(dim-1) = i
!temp-debug                 .special_ket(i)[2] = b3 
!temp-debug                 ! .special_ket(i)[2] = bi2 unchanged 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res - .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug  !test3         .special_ket(i)[1] = bi1 unchanged 
!temp-debug                 .special_ket(i)[2] = bi2 
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else
!temp-debug               do bi1=1,.n_bf
!temp-debug                 fac = - .ket(i)[bi1,b1]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = i
!temp-debug                   .special_ket(i)[2] = b3 
!temp-debug                   .special_ket(i)[1] = bi1 
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(i)[1] = ZERO
!temp-debug                   .special_ket(i)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug           if (b4==b1 ) then
!temp-debug             if (.special_ket(i)[1]>0) then
!temp-debug               bi2 = .special_ket(i)[2]
!temp-debug               if (bi2==b2 ) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                 reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                 reorder(dim-1) = i
!temp-debug                 .special_ket(i)[2] = b3 
!temp-debug                 ! .special_ket(i)[1] = bi1 unchanged 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug  !test3         .special_ket(i)[1] = bi1
!temp-debug                 .special_ket(i)[2] = bi2
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else
!temp-debug               do bi1=1,.n_bf
!temp-debug                 fac =  .ket(i)[bi1,b2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = i
!temp-debug                   .special_ket(i)[2] = b3 
!temp-debug                   .special_ket(i)[1] = bi1 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(i)[1] = ZERO
!temp-debug                   .special_ket(i)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug           if (b3==b2 ) then
!temp-debug             if (.special_ket(i)[1]>0) then
!temp-debug               bi2 = .special_ket(i)[2]
!temp-debug               if (bi2==b1 ) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                 reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                 reorder(dim-1) = i
!temp-debug                 .special_ket(i)[2] = b4 
!temp-debug                 ! .special_ket(i)[1] = bi1 unchanged 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug  !test3         .special_ket(i)[1] = bi1
!temp-debug                 .special_ket(i)[2] = bi2
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else
!temp-debug               do bi1=1,.n_bf
!temp-debug                 fac =  .ket(i)[bi1,b1]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = i
!temp-debug                   .special_ket(i)[2] = b4 
!temp-debug                   .special_ket(i)[1] = bi1 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(i)[1] = ZERO
!temp-debug                   .special_ket(i)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug           if (b3==b1 ) then
!temp-debug             if (.special_ket(i)[1]>0) then
!temp-debug               bi2 = .special_ket(i)[2]
!temp-debug               if (bi2==b2 ) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                 reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                 reorder(dim-1) = i
!temp-debug                 .special_ket(i)[2] = b4 
!temp-debug                 ! .special_ket(i)[1] = bi1 unchanged 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res - .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug  !test3         .special_ket(i)[1] = bi1
!temp-debug                 .special_ket(i)[2] = bi2
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else
!temp-debug               do bi1=1,.n_bf
!temp-debug                 fac = - .ket(i)[bi1,b2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = i
!temp-debug                   .special_ket(i)[2] = b4 
!temp-debug                   .special_ket(i)[1] = bi1 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(i)[1] = ZERO
!temp-debug                   .special_ket(i)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug           ! Case 3
!temp-debug           ! only do something if dim>2
!temp-debug           do jj = dim-1,ii+1,-1
!temp-debug             j = order(jj)
!temp-debug             if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
!temp-debug             !  Case 3, i special, j special
!temp-debug               bi2 = .special_ket(i)[2]
!temp-debug             !  bi1 = .special_ket(i)[1] unchanged
!temp-debug               bj2 = .special_ket(j)[2]
!temp-debug             !  bj1 = .special_ket(j)[1] unchanged
!temp-debug               if (bi2==b1 AND bj2==b2) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                 reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                 reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                 reorder(dim-2) = i 
!temp-debug                 reorder(dim-1) = j 
!temp-debug                 .special_ket(i)[2] = b3 
!temp-debug               ! .special_ket(i)[1] = bi1 unchanged 
!temp-debug                 .special_ket(j)[2] = b4 
!temp-debug               ! .special_ket(j)[1] = bj1  unchanged
!temp-debug             !debug  stdout.text("Case 3, i special, j special")
!temp-debug             !debug  stdout.show("i =",i)
!temp-debug             !debug  stdout.show("j =",j)
!temp-debug             !debug  stdout.show("bi1 =",bi1)
!temp-debug             !debug  stdout.show("bj2 =",bj2)
!temp-debug             !debug  stdout.show("bj1 =",bj1)
!temp-debug             !debug  stdout.show("bi2 =",bi2)
!temp-debug               !debug stdout.text("reorder:")
!temp-debug               !debug stdout.put(reorder)
!temp-debug               !debug stdout.text("special_ket:")
!temp-debug               !debug stdout.put(.special_ket)
!temp-debug             !debug  write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug         !debug  write(*,*) "returned from recursion, dim =",dim
!temp-debug  !test3         .special_ket(i)[1] = bi1
!temp-debug                 .special_ket(i)[2] = bi2 
!temp-debug                 .special_ket(j)[2] = bj2
!temp-debug  !test3         .special_ket(j)[1] = bj1
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug               if (bi2==b2 AND bj2==b1) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                 reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                 reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                 reorder(dim-2) = i 
!temp-debug                 reorder(dim-1) = j 
!temp-debug                 .special_ket(i)[2] = b3 
!temp-debug               ! .special_ket(i)[1] = bi1 unchanged 
!temp-debug                 .special_ket(j)[2] = b4 
!temp-debug               ! .special_ket(j)[1] = bj1  unchanged
!temp-debug             !debug  stdout.text("Case 3, i special, j special")
!temp-debug             !debug  stdout.show("i =",i)
!temp-debug             !debug  stdout.show("j =",j)
!temp-debug             !debug  stdout.show("bi1 =",bi1)
!temp-debug             !debug  stdout.show("bj2 =",bj2)
!temp-debug             !debug  stdout.show("bj1 =",bj1)
!temp-debug             !debug  stdout.show("bi2 =",bi2)
!temp-debug               !debug stdout.text("reorder:")
!temp-debug               !debug stdout.put(reorder)
!temp-debug               !debug stdout.text("special_ket:")
!temp-debug               !debug stdout.put(.special_ket)
!temp-debug             !debug  write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res - .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug         !debug  write(*,*) "returned from recursion, dim =",dim
!temp-debug  !test3         .special_ket(i)[1] = bi1
!temp-debug                 .special_ket(i)[2] = bi2 
!temp-debug                 .special_ket(j)[2] = bj2
!temp-debug  !test3         .special_ket(j)[1] = bj1
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
!temp-debug             ! Case 3, only j special
!temp-debug               bj2 = .special_ket(j)[2]
!temp-debug               if (bj2==b2) then
!temp-debug             !   bj1 = .special_ket(j)[1]
!temp-debug                 do bi1 = 1,.n_bf
!temp-debug                   fac = .ket(i)[bi1,b1]
!temp-debug                   if (NOT fac.is_zero ) then
!temp-debug                     reorder.create(dim-1)
!temp-debug                     reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                     reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                     reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                     reorder(dim-2) = i 
!temp-debug                     reorder(dim-1) = j 
!temp-debug            !debug           stdout.text("reorder:")
!temp-debug            !debug           stdout.put(reorder)
!temp-debug                     .special_ket(i)[2] = b3 
!temp-debug                     .special_ket(i)[1] = bi1 
!temp-debug                     .special_ket(j)[2] = b4
!temp-debug                  !   .special_ket(j)[1] = bj1 unchanged
!temp-debug            !debug stdout.text("Case 2, only j special")
!temp-debug            !debug stdout.show("i =",i)
!temp-debug            !debug stdout.show("j =",j)
!temp-debug            !debug stdout.show("bi1 =",bi1)
!temp-debug            !debug stdout.show("bj2 =",bj2)
!temp-debug            !debug stdout.show("bj1 =",bj1)
!temp-debug            !debug stdout.show("bi2 =",bi2)
!temp-debug            !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                     res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug           !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug  !test3             .special_ket(j)[1] = bj1 unchanged
!temp-debug                     .special_ket(i)[1] = ZERO 
!temp-debug                     .special_ket(i)[2] = ZERO 
!temp-debug                     .special_ket(j)[2] = bj2
!temp-debug                     reorder.destroy
!temp-debug                   end
!temp-debug                 end
!temp-debug               end
!temp-debug               if (bj2==b1) then
!temp-debug             !   bj1 = .special_ket(j)[1]
!temp-debug                 do bi1 = 1,.n_bf
!temp-debug                   fac = - .ket(i)[bi1,b2]
!temp-debug                   if (NOT fac.is_zero ) then
!temp-debug                     reorder.create(dim-1)
!temp-debug                     reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                     reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                     reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                     reorder(dim-2) = i 
!temp-debug                     reorder(dim-1) = j 
!temp-debug            !debug           stdout.text("reorder:")
!temp-debug            !debug           stdout.put(reorder)
!temp-debug                     .special_ket(i)[2] = b3 
!temp-debug                     .special_ket(i)[1] = bi1 
!temp-debug                     .special_ket(j)[2] = b4
!temp-debug                  !   .special_ket(j)[1] = bj1 unchanged
!temp-debug            !debug stdout.text("Case 2, only j special")
!temp-debug            !debug stdout.show("i =",i)
!temp-debug            !debug stdout.show("j =",j)
!temp-debug            !debug stdout.show("bi1 =",bi1)
!temp-debug            !debug stdout.show("bj2 =",bj2)
!temp-debug            !debug stdout.show("bj1 =",bj1)
!temp-debug            !debug stdout.show("bi2 =",bi2)
!temp-debug            !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                     res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug           !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug  !test3             .special_ket(j)[1] = bj1 unchanged
!temp-debug                     .special_ket(i)[1] = ZERO 
!temp-debug                     .special_ket(i)[2] = ZERO 
!temp-debug                     .special_ket(j)[2] = bj2
!temp-debug                     reorder.destroy
!temp-debug                   end
!temp-debug                 end
!temp-debug               end
!temp-debug             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
!temp-debug             !  Case 3, NONE SPECIAL
!temp-debug               do bi1 = 1,.n_bf
!temp-debug               do bj1 = 1,.n_bf
!temp-debug                 fac = .ket(i)[bi1,b1]*.ket(j)[bj1,b2]-.ket(i)[bi1,b2]*.ket(j)[bj1,b1]
!temp-debug                 if (NOT fac.is_zero ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                   reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                   reorder(dim-2) = i 
!temp-debug                   reorder(dim-1) = j 
!temp-debug            !debug           stdout.text("reorder:")
!temp-debug            !debug           stdout.put(reorder)
!temp-debug                   .special_ket(i)[2] = b3 
!temp-debug                   .special_ket(i)[1] = bi1 
!temp-debug                   .special_ket(j)[2] = b4
!temp-debug                   .special_ket(j)[1] = bj1 
!temp-debug            !debug stdout.text("Case 2, only j special")
!temp-debug            !debug stdout.show("i =",i)
!temp-debug            !debug stdout.show("j =",j)
!temp-debug            !debug stdout.show("bi1 =",bi1)
!temp-debug            !debug stdout.show("bj2 =",bj2)
!temp-debug            !debug stdout.show("bj1 =",bj1)
!temp-debug            !debug stdout.show("bi2 =",bi2)
!temp-debug            !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug           !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug                   .special_ket(i)[1] = ZERO 
!temp-debug                   .special_ket(i)[2] = ZERO 
!temp-debug                   .special_ket(j)[1] = ZERO
!temp-debug                   .special_ket(j)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug         end
!temp-debug      end
!temp-debug   end
!temp-debug
!temp-debug   special_overlap_spin_aa_for(order,row_ind,col_ind,b1,b2) result (res)
!temp-debug   ! Special function which evaluates the overlap integrals between
!temp-debug   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
!temp-debug   ! special bra which are (Sz=1)-geminals.
!temp-debug   ENSURE(order.dim>0,"dimension zero or negative")
!temp-debug   ENSURE(.special_ket(order.dim)[2]>0,"no special ket matching special bra")
!temp-debug      row_ind,col_ind,b1,b2 :: INT
!temp-debug      order :: VEC{INT}
!temp-debug      res :: MAT{REAL}(.n_bas,.n_bas)
!temp-debug      ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,b3,b4 :: INT
!temp-debug      fac :: REAL
!temp-debug      reorder :: VEC{INT}*
!temp-debug      dim = order.dim
!temp-debug     !debug write(*,*) "dim =",dim
!temp-debug
!temp-debug      res = ZERO
!temp-debug      
!temp-debug      ! test for identical spinorbitals
!temp-debug      i = order(dim)
!temp-debug      b3 = .special_ket(i)[1]
!temp-debug      b4 = .special_ket(i)[2]
!temp-debug      if (b3==b4 OR b1==b2 ) return
!temp-debug      
!temp-debug      ! Case 1
!temp-debug      if (dim==1) then
!temp-debug        !debug   write(*,*) "i =",i
!temp-debug         if (b3==b1 AND b4==b2 ) res = ONE
!temp-debug         if (b3==b2 AND b4==b1 ) res = -ONE
!temp-debug         return
!temp-debug      end
!temp-debug      if (b3==b1 AND b4==b2 ) then
!temp-debug        reorder.create(dim-1)
!temp-debug        reorder(1:dim-1)   = [ (order(j), j=1,dim-1) ]
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug         res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug         reorder.destroy
!temp-debug      end
!temp-debug      if (b3==b2 AND b4==b1 ) then
!temp-debug        reorder.create(dim-1)
!temp-debug        reorder(1:dim-1)   = [ (order(j), j=1,dim-1) ]
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug        res = res - .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug        reorder.destroy
!temp-debug      end
!temp-debug      ! this loop does something only if dim > 1
!temp-debug      do ii = dim-1,1,-1
!temp-debug         i = order(ii)
!temp-debug         if(col_ind==0 AND i==1) then
!temp-debug           do col_ind=1,.n_bas
!temp-debug             ! Case 2
!temp-debug             if (b4==b2 ) then
!temp-debug               do bi2=1,.n_bf
!temp-debug                 fac = - .contraction_wfs(col_ind)[b1,bi2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = 1
!temp-debug                   .special_ket(1)[1] = b3 
!temp-debug                   .special_ket(1)[2] = bi2 
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(1)[1] = ZERO
!temp-debug                   .special_ket(1)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug             if (b4==b1 ) then
!temp-debug               do bi2=1,.n_bf
!temp-debug                 fac =  .contraction_wfs(col_ind)[b2,bi2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = 1
!temp-debug                   .special_ket(1)[1] = b3 
!temp-debug                   .special_ket(1)[2] = bi2 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(1)[1] = ZERO
!temp-debug                   .special_ket(1)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug             if (b3==b2 ) then
!temp-debug               do bi2=1,.n_bf
!temp-debug                 fac =  .contraction_wfs(col_ind)[b1,bi2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = 1
!temp-debug                   .special_ket(1)[1] = b4 
!temp-debug                   .special_ket(1)[2] = bi2 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(1)[1] = ZERO
!temp-debug                   .special_ket(1)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug             if (b3==b1 ) then
!temp-debug               do bi2=1,.n_bf
!temp-debug                 fac = - .contraction_wfs(col_ind)[b2,bi2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = 1
!temp-debug                   .special_ket(1)[1] = b4 
!temp-debug                   .special_ket(1)[2] = bi2 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(1)[1] = ZERO
!temp-debug                   .special_ket(1)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug             ! Case 3
!temp-debug             ! only do something if dim>2
!temp-debug             do jj = dim-1,ii+1,-1
!temp-debug               j = order(jj)
!temp-debug               if (.special_ket(j)[1]>0) then
!temp-debug               ! Case 3, only j special
!temp-debug                 bj1 = .special_ket(j)[1]
!temp-debug                 if (bj1==b2) then
!temp-debug               !   bj2 = .special_ket(j)[2]
!temp-debug                   do bi2 = 1,.n_bf
!temp-debug                     fac = .contraction_wfs(col_ind)[b1,bi2]
!temp-debug                     if (NOT fac.is_zero ) then
!temp-debug                       reorder.create(dim-1)
!temp-debug                       reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                       reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                       reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                       reorder(dim-2) = 1 
!temp-debug                       reorder(dim-1) = j 
!temp-debug              !debug           stdout.text("reorder:")
!temp-debug              !debug           stdout.put(reorder)
!temp-debug                       .special_ket(1)[1] = b3 
!temp-debug                       .special_ket(1)[2] = bi2 
!temp-debug                       .special_ket(j)[1] = b4
!temp-debug                    !   .special_ket(j)[2] = bj2 unchanged
!temp-debug              !debug stdout.text("Case 2, only j special")
!temp-debug              !debug stdout.show("i =",i)
!temp-debug              !debug stdout.show("j =",j)
!temp-debug              !debug stdout.show("bi1 =",bi1)
!temp-debug              !debug stdout.show("bj2 =",bj2)
!temp-debug              !debug stdout.show("bj1 =",bj1)
!temp-debug              !debug stdout.show("bi2 =",bi2)
!temp-debug              !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                       res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug             !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug    !test3             .special_ket(j)[2] = bj2 unchanged
!temp-debug                       .special_ket(1)[1] = ZERO 
!temp-debug                       .special_ket(1)[2] = ZERO 
!temp-debug                       .special_ket(j)[1] = bj1
!temp-debug                       reorder.destroy
!temp-debug                     end
!temp-debug                   end
!temp-debug                 end
!temp-debug                 if (bj1==b1) then
!temp-debug               !   bj2 = .special_ket(j)[2]
!temp-debug                   do bi2 = 1,.n_bf
!temp-debug                     fac = - .contraction_wfs(col_ind)[b2,bi2]
!temp-debug                     if (NOT fac.is_zero ) then
!temp-debug                       reorder.create(dim-1)
!temp-debug                       reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                       reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                       reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                       reorder(dim-2) = 1 
!temp-debug                       reorder(dim-1) = j 
!temp-debug              !debug           stdout.text("reorder:")
!temp-debug              !debug           stdout.put(reorder)
!temp-debug                       .special_ket(1)[1] = b3 
!temp-debug                       .special_ket(1)[2] = bi2 
!temp-debug                       .special_ket(j)[1] = b4
!temp-debug                    !   .special_ket(j)[2] = bj2 unchanged
!temp-debug              !debug stdout.text("Case 2, only j special")
!temp-debug              !debug stdout.show("i =",i)
!temp-debug              !debug stdout.show("j =",j)
!temp-debug              !debug stdout.show("bi1 =",bi1)
!temp-debug              !debug stdout.show("bj2 =",bj2)
!temp-debug              !debug stdout.show("bj1 =",bj1)
!temp-debug              !debug stdout.show("bi2 =",bi2)
!temp-debug              !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                       res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug             !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug    !test3             .special_ket(j)[2] = bj2 unchanged
!temp-debug                       .special_ket(1)[1] = ZERO 
!temp-debug                       .special_ket(1)[2] = ZERO 
!temp-debug                       .special_ket(j)[1] = bj1
!temp-debug                       reorder.destroy
!temp-debug                     end
!temp-debug                   end
!temp-debug                 end
!temp-debug               else 
!temp-debug               !  Case 3, NONE SPECIAL
!temp-debug                 do bi2 = 1,.n_bf
!temp-debug                 do bj2 = 1,.n_bf
!temp-debug                   fac = .contraction_wfs(col_ind)[b1,bi2]*.ket(j)[b2,bj2]-.contraction_wfs(col_ind)[b2,bi2]*.ket(j)[b1,bj2]
!temp-debug                   if (NOT fac.is_zero ) then
!temp-debug                     reorder.create(dim-1)
!temp-debug                     reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                     reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                     reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                     reorder(dim-2) = 1 
!temp-debug                     reorder(dim-1) = j 
!temp-debug              !debug           stdout.text("reorder:")
!temp-debug              !debug           stdout.put(reorder)
!temp-debug                     .special_ket(1)[1] = b3 
!temp-debug                     .special_ket(1)[2] = bi2 
!temp-debug                     .special_ket(j)[1] = b4
!temp-debug                     .special_ket(j)[2] = bj2 
!temp-debug              !debug stdout.text("Case 2, only j special")
!temp-debug              !debug stdout.show("i =",i)
!temp-debug              !debug stdout.show("j =",j)
!temp-debug              !debug stdout.show("bi1 =",bi1)
!temp-debug              !debug stdout.show("bj2 =",bj2)
!temp-debug              !debug stdout.show("bj1 =",bj1)
!temp-debug              !debug stdout.show("bi2 =",bi2)
!temp-debug              !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                     res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug             !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug                     .special_ket(1)[1] = ZERO 
!temp-debug                     .special_ket(1)[2] = ZERO 
!temp-debug                     .special_ket(j)[1] = ZERO
!temp-debug                     .special_ket(j)[2] = ZERO
!temp-debug                     reorder.destroy
!temp-debug                   end
!temp-debug                 end
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug!test1
!temp-debug           col_ind=ZERO
!temp-debug         else
!temp-debug           ! Case 2
!temp-debug           if (b4==b2 ) then
!temp-debug             if (.special_ket(i)[1]>0) then
!temp-debug               bi1 = .special_ket(i)[1]
!temp-debug               if (bi1==b1 ) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                 reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                 reorder(dim-1) = i
!temp-debug                 .special_ket(i)[1] = b3 
!temp-debug                 ! .special_ket(i)[2] = bi2 unchanged 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res - .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug  !test3         .special_ket(i)[2] = bi2 unchanged 
!temp-debug                 .special_ket(i)[1] = bi1 
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else
!temp-debug               do bi2=1,.n_bf
!temp-debug                 fac = - .ket(i)[b1,bi2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = i
!temp-debug                   .special_ket(i)[1] = b3 
!temp-debug                   .special_ket(i)[2] = bi2 
!temp-debug         !debug  stdout.text("Case 1")
!temp-debug         !debug  stdout.show("i =",i)
!temp-debug         !debug  if (.special_ket(i)[1]>0) then
!temp-debug         !debug     stdout.show("bi1 =",bi1)
!temp-debug         !debug     stdout.show("bi2 =",bi2)
!temp-debug         !debug  end
!temp-debug         !debug  stdout.show("fac =",fac)
!temp-debug         !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(i)[1] = ZERO
!temp-debug                   .special_ket(i)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug           if (b4==b1 ) then
!temp-debug             if (.special_ket(i)[1]>0) then
!temp-debug               bi1 = .special_ket(i)[1]
!temp-debug               if (bi1==b2 ) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                 reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                 reorder(dim-1) = i
!temp-debug                 .special_ket(i)[1] = b3 
!temp-debug                 ! .special_ket(i)[2] = bi2 unchanged 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug  !test3              .special_ket(i)[2] = bi2
!temp-debug                 .special_ket(i)[1] = bi1
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else
!temp-debug               do bi2=1,.n_bf
!temp-debug                 fac =  .ket(i)[b2,bi2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = i
!temp-debug                   .special_ket(i)[1] = b3 
!temp-debug                   .special_ket(i)[2] = bi2 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(i)[1] = ZERO
!temp-debug                   .special_ket(i)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug           if (b3==b2 ) then
!temp-debug             if (.special_ket(i)[1]>0) then
!temp-debug               bi1 = .special_ket(i)[1]
!temp-debug               if (bi1==b1 ) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                 reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                 reorder(dim-1) = i
!temp-debug                 .special_ket(i)[1] = b4 
!temp-debug                 ! .special_ket(i)[2] = bi2 unchanged 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug  !test3         .special_ket(i)[2] = bi2
!temp-debug                 .special_ket(i)[1] = bi1
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else
!temp-debug               do bi2=1,.n_bf
!temp-debug                 fac =  .ket(i)[b1,bi2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = i
!temp-debug                   .special_ket(i)[1] = b4 
!temp-debug                   .special_ket(i)[2] = bi2 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(i)[1] = ZERO
!temp-debug                   .special_ket(i)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug           if (b3==b1 ) then
!temp-debug             if (.special_ket(i)[1]>0) then
!temp-debug               bi1 = .special_ket(i)[1]
!temp-debug               if (bi1==b2 ) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                 reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                 reorder(dim-1) = i
!temp-debug                 .special_ket(i)[1] = b4 
!temp-debug                 ! .special_ket(i)[2] = bi2 unchanged 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res - .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug  !test3         .special_ket(i)[2] = bi2
!temp-debug                 .special_ket(i)[1] = bi1
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else
!temp-debug               do bi2=1,.n_bf
!temp-debug                 fac = - .ket(i)[b2,bi2]
!temp-debug                 if (NOT fac==ZERO ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
!temp-debug                   reorder(ii:dim-2) = [ (order(j), j=ii+1,dim-1) ]
!temp-debug                   reorder(dim-1) = i
!temp-debug                   .special_ket(i)[1] = b4 
!temp-debug                   .special_ket(i)[2] = bi2 
!temp-debug           !debug  stdout.text("Case 1")
!temp-debug           !debug  stdout.show("i =",i)
!temp-debug           !debug  if (.special_ket(i)[1]>0) then
!temp-debug           !debug     stdout.show("bi1 =",bi1)
!temp-debug           !debug     stdout.show("bi2 =",bi2)
!temp-debug           !debug  end
!temp-debug           !debug  stdout.show("fac =",fac)
!temp-debug           !debug    write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind)*fac  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug                   .special_ket(i)[1] = ZERO
!temp-debug                   .special_ket(i)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug           ! Case 3
!temp-debug           ! only do something if dim>2
!temp-debug           do jj = dim-1,ii+1,-1
!temp-debug             j = order(jj)
!temp-debug             if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
!temp-debug             !  Case 3, i special, j special
!temp-debug               bi1 = .special_ket(i)[1]
!temp-debug             !  bi2 = .special_ket(i)[2] unchanged
!temp-debug               bj1 = .special_ket(j)[1]
!temp-debug             !  bj2 = .special_ket(j)[2] unchanged
!temp-debug               if (bi1==b1 AND bj1==b2) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                 reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                 reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                 reorder(dim-2) = i 
!temp-debug                 reorder(dim-1) = j 
!temp-debug                 .special_ket(i)[1] = b3 
!temp-debug               ! .special_ket(i)[2] = bi2 unchanged 
!temp-debug                 .special_ket(j)[1] = b4 
!temp-debug               ! .special_ket(j)[2] = bj2  unchanged
!temp-debug             !debug  stdout.text("Case 3, i special, j special")
!temp-debug             !debug  stdout.show("i =",i)
!temp-debug             !debug  stdout.show("j =",j)
!temp-debug             !debug  stdout.show("bi1 =",bi1)
!temp-debug             !debug  stdout.show("bj2 =",bj2)
!temp-debug             !debug  stdout.show("bj1 =",bj1)
!temp-debug             !debug  stdout.show("bi2 =",bi2)
!temp-debug               !debug stdout.text("reorder:")
!temp-debug               !debug stdout.put(reorder)
!temp-debug               !debug stdout.text("special_ket:")
!temp-debug               !debug stdout.put(.special_ket)
!temp-debug             !debug  write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res + .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug         !debug  write(*,*) "returned from recursion, dim =",dim
!temp-debug  !test3         .special_ket(i)[2] = bi2
!temp-debug                 .special_ket(i)[1] = bi1 
!temp-debug                 .special_ket(j)[1] = bj1
!temp-debug  !test3         .special_ket(j)[2] = bj2
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug               if (bi1==b2 AND bj1==b1) then
!temp-debug                 reorder.create(dim-1)
!temp-debug                 reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                 reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                 reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                 reorder(dim-2) = i 
!temp-debug                 reorder(dim-1) = j 
!temp-debug                 .special_ket(i)[1] = b3 
!temp-debug               ! .special_ket(i)[2] = bi2 unchanged 
!temp-debug                 .special_ket(j)[1] = b4 
!temp-debug               ! .special_ket(j)[2] = bj2  unchanged
!temp-debug             !debug  stdout.text("Case 3, i special, j special")
!temp-debug             !debug  stdout.show("i =",i)
!temp-debug             !debug  stdout.show("j =",j)
!temp-debug             !debug  stdout.show("bi1 =",bi1)
!temp-debug             !debug  stdout.show("bj2 =",bj2)
!temp-debug             !debug  stdout.show("bj1 =",bj1)
!temp-debug             !debug  stdout.show("bi2 =",bi2)
!temp-debug               !debug stdout.text("reorder:")
!temp-debug               !debug stdout.put(reorder)
!temp-debug               !debug stdout.text("special_ket:")
!temp-debug               !debug stdout.put(.special_ket)
!temp-debug             !debug  write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                 res = res - .overlap_for(reorder,row_ind,col_ind)  ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug         !debug  write(*,*) "returned from recursion, dim =",dim
!temp-debug  !test3         .special_ket(i)[2] = bi2
!temp-debug                 .special_ket(i)[1] = bi1 
!temp-debug                 .special_ket(j)[1] = bj1
!temp-debug  !test3         .special_ket(j)[2] = bj2
!temp-debug                 reorder.destroy
!temp-debug               end
!temp-debug             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
!temp-debug             ! Case 3, only j special
!temp-debug               bj1 = .special_ket(j)[1]
!temp-debug               if (bj1==b2) then
!temp-debug             !   bj2 = .special_ket(j)[2]
!temp-debug                 do bi2 = 1,.n_bf
!temp-debug                   fac = .ket(i)[b1,bi2]
!temp-debug                   if (NOT fac.is_zero ) then
!temp-debug                     reorder.create(dim-1)
!temp-debug                     reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                     reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                     reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                     reorder(dim-2) = i 
!temp-debug                     reorder(dim-1) = j 
!temp-debug            !debug           stdout.text("reorder:")
!temp-debug            !debug           stdout.put(reorder)
!temp-debug                     .special_ket(i)[1] = b3 
!temp-debug                     .special_ket(i)[2] = bi2 
!temp-debug                     .special_ket(j)[1] = b4
!temp-debug                  !   .special_ket(j)[2] = bj2 unchanged
!temp-debug            !debug stdout.text("Case 2, only j special")
!temp-debug            !debug stdout.show("i =",i)
!temp-debug            !debug stdout.show("j =",j)
!temp-debug            !debug stdout.show("bi1 =",bi1)
!temp-debug            !debug stdout.show("bj2 =",bj2)
!temp-debug            !debug stdout.show("bj1 =",bj1)
!temp-debug            !debug stdout.show("bi2 =",bi2)
!temp-debug            !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                     res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug           !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug  !test3             .special_ket(j)[2] = bj2 unchanged
!temp-debug                     .special_ket(i)[1] = ZERO 
!temp-debug                     .special_ket(i)[2] = ZERO 
!temp-debug                     .special_ket(j)[1] = bj1
!temp-debug                     reorder.destroy
!temp-debug                   end
!temp-debug                 end
!temp-debug               end
!temp-debug               if (bj1==b1) then
!temp-debug             !   bj2 = .special_ket(j)[2]
!temp-debug                 do bi2 = 1,.n_bf
!temp-debug                   fac = - .ket(i)[b2,bi2]
!temp-debug                   if (NOT fac.is_zero ) then
!temp-debug                     reorder.create(dim-1)
!temp-debug                     reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                     reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                     reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                     reorder(dim-2) = i 
!temp-debug                     reorder(dim-1) = j 
!temp-debug            !debug           stdout.text("reorder:")
!temp-debug            !debug           stdout.put(reorder)
!temp-debug                     .special_ket(i)[1] = b3 
!temp-debug                     .special_ket(i)[2] = bi2 
!temp-debug                     .special_ket(j)[1] = b4
!temp-debug                  !   .special_ket(j)[2] = bj2 unchanged
!temp-debug            !debug stdout.text("Case 2, only j special")
!temp-debug            !debug stdout.show("i =",i)
!temp-debug            !debug stdout.show("j =",j)
!temp-debug            !debug stdout.show("bi1 =",bi1)
!temp-debug            !debug stdout.show("bj2 =",bj2)
!temp-debug            !debug stdout.show("bj1 =",bj1)
!temp-debug            !debug stdout.show("bi2 =",bi2)
!temp-debug            !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                     res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug           !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug  !test3             .special_ket(j)[2] = bj2 unchanged
!temp-debug                     .special_ket(i)[1] = ZERO 
!temp-debug                     .special_ket(i)[2] = ZERO 
!temp-debug                     .special_ket(j)[1] = bj1
!temp-debug                     reorder.destroy
!temp-debug                   end
!temp-debug                 end
!temp-debug               end
!temp-debug             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
!temp-debug             !  Case 3, NONE SPECIAL
!temp-debug               do bi2 = 1,.n_bf
!temp-debug               do bj2 = 1,.n_bf
!temp-debug                 fac = .ket(i)[b1,bi2]*.ket(j)[b2,bj2]-.ket(i)[b2,bi2]*.ket(j)[b1,bj2]
!temp-debug                 if (NOT fac.is_zero ) then
!temp-debug                   reorder.create(dim-1)
!temp-debug                   reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
!temp-debug                   reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
!temp-debug                   reorder(jj-1:dim-3) = [ (order(k), k=jj+1,dim-1) ]
!temp-debug                   reorder(dim-2) = i 
!temp-debug                   reorder(dim-1) = j 
!temp-debug            !debug           stdout.text("reorder:")
!temp-debug            !debug           stdout.put(reorder)
!temp-debug                   .special_ket(i)[1] = b3 
!temp-debug                   .special_ket(i)[2] = bi2 
!temp-debug                   .special_ket(j)[1] = b4
!temp-debug                   .special_ket(j)[2] = bj2 
!temp-debug            !debug stdout.text("Case 2, only j special")
!temp-debug            !debug stdout.show("i =",i)
!temp-debug            !debug stdout.show("j =",j)
!temp-debug            !debug stdout.show("bi1 =",bi1)
!temp-debug            !debug stdout.show("bj2 =",bj2)
!temp-debug            !debug stdout.show("bj1 =",bj1)
!temp-debug            !debug stdout.show("bi2 =",bi2)
!temp-debug            !debug write(*,*) "recursing here, dim,row_ind,col_ind=",dim,row_ind,col_ind
!temp-debug                   res = res + .overlap_for(reorder,row_ind,col_ind) * fac ! <<<<<<<<<<<<<<<<<<<<<<<
!temp-debug           !debug    write(*,*) "returned from recursion, dim =",dim
!temp-debug                   .special_ket(i)[1] = ZERO 
!temp-debug                   .special_ket(i)[2] = ZERO 
!temp-debug                   .special_ket(j)[1] = ZERO
!temp-debug                   .special_ket(j)[2] = ZERO
!temp-debug                   reorder.destroy
!temp-debug                 end
!temp-debug               end
!temp-debug               end
!temp-debug             end
!temp-debug           end
!temp-debug         end
!temp-debug      end
!temp-debug   end

!  **************
!  Output methods
!  **************

   put
   ! Print out the object
      i :: INT
      stdout.text("GEMINAL_MF_SPECTRUM:")
      stdout.flush
      stdout.show("n_geminals =",.n_geminals)
      stdout.show("n_bf       =",.n_bf)
      stdout.show("n_bas       =",.n_bas)
      stdout.flush
      stdout.text("Bra:")
      do i = 1,.n_geminals
         stdout.text("Bra "//i.to_str.trim)
         stdout.put(.bra(i).element)
      end
      stdout.text("Ket:")
      do i = 1,.n_geminals
         stdout.text("Special ket "//i.to_str.trim)
         stdout.put(.special_ket(i).element)
         stdout.text("Ket "//i.to_str.trim)
         stdout.put(.ket(i).element)
      end
   end

end
