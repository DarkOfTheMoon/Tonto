!-------------------------------------------------------------------------------
!
! GEMINAL_MF_SPECTRUM
!
! Copyright (C) Patrick Cassam-Chenaï and Dylan Jayatilaka, 2003
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!-------------------------------------------------------------------------------

module GEMINAL_MF_SPECTRUM

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

contains

!*******************************************************************************
!                             Create and Destroy Routines
!*******************************************************************************

   create(name,nuc,n_geminals,i_geminals,n_bf) ::: leaky
   ! Create the geminal contraction "i_geminals" and the ground state geminal
   ! for the spectator contractions,  each geminal having
   ! coeficients matrix of dimension "n_bf".
      self :: PTR
      name :: STR
      nuc :: REAL
      n_geminals,i_geminals,n_bf :: INT
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
!10-07-09      .two_orthogonality = FALSE
      .tol=REAL_EPSILON
      .ld_tol=LINEAR_DEPENDENCE_TOL
      .ig_tol=INTERNAL_GEMINAL_TOL
      .set_defaults(n_geminals,i_geminals,n_bf,name,nuc)
      .set_singlet_defaults
   !   .set_singlet_agp
    !  .set_singlet_random
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      nullify(.contraction_wfs)
      nullify(.contraction_energies)
      nullify(.bra)
      nullify(.ket)
      nullify(.special_ket)
   end

   destroy_ptr_part  ::: leaky
   ! Destroy the pointer parts of self
      .bra.destroy
      .ket.destroy
      .special_ket.destroy
   end

   create_copy(b) ::: leaky
   ! Create a copy of "b".
     b :: GEMINAL_MF_SPECTRUM, IN
     self :: PTR
     !.create(b.name,b.nuclear_energy,b.n_geminals,b.i_geminals,b.n_bf,b.n_bas)
     .create(b.name,b.nuclear_energy,b.n_geminals,b.i_geminals,b.n_bf)
     .copy(b)
   end

   copy(b) ::: leaky
   ! Copy a basis "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
      b :: GEMINAL_MF_SPECTRUM, IN
      self = b
      if (b.bra.created) .bra.create_copy(b.bra)
      if (b.ket.created) .ket.create_copy(b.ket)
      if (b.special_ket.created) .special_ket.create_copy(b.special_ket)
      if (b.contraction_wfs.created) .contraction_wfs.create_copy(b.contraction_wfs)
      if (b.contraction_energies.created) .contraction_energies.create_copy(b.contraction_energies)
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

   set_defaults(n_geminals,i_geminals,n_bf,name,nuclear_energy,n_bas) 
   ! Set values to a geminal_mf_spectrum object.
     n_geminals,i_geminals,n_bf,n_bas :: INT, optional
     name :: STR, optional
     nuclear_energy :: REAL, optional

     if (present(n_geminals)) .n_geminals = n_geminals
     if (present(i_geminals)) .i_geminals = i_geminals
     if (present(n_bf)) .n_bf = n_bf
     if (present(name)) .name = name
     if (present(nuclear_energy)) .nuclear_energy = nuclear_energy
     if (present(n_bas)) .n_bas = n_bas
   end

   set_singlet_agp ::: leaky
   ! Create a default object with singlet geminals only. 
   ! the HF wave function is used in AGP form
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf :: INT
     j,k,counter :: INT
     n_nonzero :: INT

     i_geminals = .i_geminals
     n_geminals = .n_geminals
     n_bf = .n_bf
     n_nonzero = (n_bf-n_geminals+1)*(n_bf-n_geminals+2)/2 ! avoid the ground state orbitals
     .n_bas=n_bf*(n_bf+1)/2
     .n_dependent=.n_bas-n_nonzero
      if (.bra.created) .bra.destroy
      if (.ket.created) .ket.destroy
      if (.special_ket.created) .special_ket.destroy
      if (.contraction_wfs.created) .contraction_wfs.destroy
      if (.contraction_energies.created) .contraction_energies.destroy
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,n_geminals     ! create ground state bras and kets
        .bra(j).element.create(n_bf,n_bf)
        .ket(j).element.create(n_bf,n_bf)
        .special_ket(j).element.create(2)
        .ket(j).element = ZERO
        .bra(j).element = ZERO
        .special_ket(j).element = 0
     end
     counter=1
     do j = 1,n_geminals     ! set ground state bras and kets
       if(j==i_geminals)cycle
       counter=counter+1
       do k=1,n_geminals
        .bra(counter)[k,k] = ONE/real(counter-1)
        .ket(counter)[k,k] = ONE/real(counter-1)
       end
     end
     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
     do k=1,n_geminals
       .bra(2)[k,k] = ONE/sqrt(real(n_geminals))
       .ket(2)[k,k] = ONE/sqrt(real(n_geminals))
     end
     do j = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
       .contraction_energies(j)= ZERO
     end
     counter=1
     do j=1,n_geminals
       .contraction_wfs(counter)[j,j] = ONE/sqrt(real(n_geminals))
     end
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = j-1,1,-1
       if ( 1<=k AND k <= n_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     k = i_geminals
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     DIE_IF(counter/=n_nonzero,"counter not equal to n_nonzero") 
     do j =1, n_geminals
       if ( j==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = n_geminals,1,-1
       if ( k==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     do j = 1,n_geminals
     do k = j-1,1,-1
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     DIE_IF(counter/=.n_bas,"counter not equal to .n_bas")
   end

   set_singlet_random ::: leaky
   ! Create a default object with singlet geminals only. 
   ! a random rotation of the HF canonical orbitals is performed
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf :: INT
     j,k,counter :: INT
     n_nonzero :: INT
     R,S,T,U :: MAT{REAL}*
     V,eigenvalues :: VEC{REAL}*
     i,l :: INT
     val :: REAL

     i_geminals = .i_geminals
     n_geminals = .n_geminals
     n_bf = .n_bf
     n_nonzero = (n_bf-n_geminals+1)*(n_bf-n_geminals+2)/2 ! avoid the ground state orbitals
     .n_bas=n_bf*(n_bf+1)/2
     .n_dependent=.n_bas-n_nonzero
      if (.bra.created) .bra.destroy
      if (.ket.created) .ket.destroy
      if (.special_ket.created) .special_ket.destroy
      if (.contraction_wfs.created) .contraction_wfs.destroy
      if (.contraction_energies.created) .contraction_energies.destroy
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,n_geminals     ! create ground state bras and kets
        .bra(j).element.create(n_bf,n_bf)
        .ket(j).element.create(n_bf,n_bf)
        .special_ket(j).element.create(2)
        .ket(j).element = ZERO
        .bra(j).element = ZERO
        .special_ket(j).element = 0
     end
     counter=1
     do j = 1,n_geminals     ! set ground state bras and kets
       if(j==i_geminals)cycle
       counter=counter+1
       .ket(counter)[j,j] = ONE
       .bra(counter)[j,j] = ONE
     end
     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
     do j = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
       .contraction_energies(j)= ZERO
     end
     counter=1
     .contraction_wfs(counter)[i_geminals,i_geminals] = ONE
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = j-1,1,-1
       if ( 1<=k AND k <= n_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     k = i_geminals
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     DIE_IF(counter/=n_nonzero,"counter not equal to n_nonzero") 
     do j =1, n_geminals
       if ( j==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = n_geminals,1,-1
       if ( k==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     do j = 1,n_geminals
     do k = j-1,1,-1
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     DIE_IF(counter/=.n_bas,"counter not equal to .n_bas")
!debug      write(*,*) ".n_bas",.n_bas
!debug      stdout.text(".contraction_wfs(1)[:,:]")
!debug      stdout.put(.contraction_wfs(1)[:,:])
!debug      stdout.text(".contraction_wfs(2)[:,:]")
!debug      stdout.put(.contraction_wfs(2)[:,:])
!debug      stdout.text(std_time.elapsed_time_message("geminal job "))
!debug      stdout.text(std_time.elapsed_cpu_time_message("geminal job "))
      ! Rotate
      U.create(.n_geminals,.n_geminals)
      T.create(.n_geminals,.n_geminals)
      S.create(n_bf,n_bf)
      R.create(n_bf,n_bf)
      eigenvalues.create(n_bf)
      do i = 1,n_geminals
      do j = 1,i
         call random_number(val)
         T(i,j) = val
         T(j,i) = val
      end
      end
      T.solve_eigenproblem(eigenvalues,U)
      R=ZERO
      do i = 1,n_geminals
      do j = 1,i
         R(i,j) = U(i,j)
         R(j,i) = U(j,i)
      end
      end
      do i = n_geminals+1, n_bf
         R(i,i) = ONE
      end
      U.destroy
      T.destroy
    !  stdout.text("R")
    !  stdout.put(R)
      S=matmul(R,transpose(R))
      stdout.show("is unit matrix =",S.is_unit_matrix)
      V.create(n_bf)
      do i = 1,.n_bas
        do j=1,n_bf
        V=.contraction_wfs(i)[j,:]
        .contraction_wfs(i)[j,:].to_product_of(R,V)
        end
        do k=1,n_bf
        V=.contraction_wfs(i)[:,k]
        .contraction_wfs(i)[:,k].to_product_of(R,V)
        end
!        val = ZERO
!        do j=1,n_bf
!        do k=1,n_bf
!          val=val+ .contraction_wfs(i)[j,k]*.contraction_wfs(i)[j,k]
!        end
!        end
!        write(*,*) "i",i,val
      end
      do i = .n_bas+1,.n_bas+n_geminals-1
        do j=1,n_bf
         V=.ket(i-.n_bas+1)[j,:]
        .ket(i-.n_bas+1)[j,:].to_product_of(R,V)
         V=.bra(i-.n_bas+1)[j,:]
        .bra(i-.n_bas+1)[j,:].to_product_of(R,V)
        end
        do k=1,n_bf
        V=.ket(i-.n_bas+1)[:,k]
        .ket(i-.n_bas+1)[:,k].to_product_of(R,V)
        V=.bra(i-.n_bas+1)[:,k]
        .bra(i-.n_bas+1)[:,k].to_product_of(R,V)
        end
!        val = ZERO
!        do j=1,n_bf
!        do k=1,n_bf
!          val=val+ .bra(i-.n_bas+1)[j,k]*.bra(i-.n_bas+1)[j,k]
!        end
!        end
!        write(*,*) "i",i,val
      end
!      R.destroy
!      R.create(.n_bas,.n_bas)
!      S.destroy
!      S.create(.n_bas,.n_bas)
!      T.destroy
!      T.create(.n_bas,.n_bas)
!      U.destroy
!      U.create(.n_bas,.n_bas)
!      R=matmul(transpose(.bra(2)[:,:]),.bra(2)[:,:])
!      S=matmul(.bra(2)[:,:],transpose(.bra(2)[:,:]))
!      do i = 1,.n_bas
!      T=matmul(.contraction_wfs(i)[:,:],R)+matmul(S,.contraction_wfs(i)[:,:])
!        write(*,*) "T(1,1)",T(1,1)
!        write(*,*) "T(2,1)",T(2,1)
!        write(*,*) "T(1,2)",T(1,2)
!        write(*,*) "T(2,2)",T(2,2)
!      !    S=matmul(transpose(.contraction_wfs(i)[:,:]),.contraction_wfs(i)[:,:])
!      U=matmul(transpose(.contraction_wfs(i)[:,:]),T)
!          val=U.trace
!        write(*,*) "i,trace",i,val
!      end
!!      V.create(n_bfsq)
!!      do i = 1,.n_bas
!!        V.to_product_of(R,reshape(.contraction_wfs(i).element,[n_bfsq]))
!!        .contraction_wfs(i).element = reshape(V,[n_bf,n_bf])
!!        val = ZERO
!!        do j=1,n_bf
!!        do k=1,n_bf
!!          val=val+ .contraction_wfs(i)[j,k]*.contraction_wfs(i)[j,k]
!!        end
!!        end
!!        write(*,*) "i",i,val
!!      end
!!      do i = .n_bas+1,n_bfsq
!!        V.to_product_of(R,reshape(.ket(i-.n_bas+1).element,[n_bfsq]))
!!        .ket(i-.n_bas+1).element = reshape(V,[n_bf,n_bf])
!!        V.to_product_of(R,reshape(.bra(i-.n_bas+1).element,[n_bfsq]))
!!        .bra(i-.n_bas+1).element = reshape(V,[n_bf,n_bf])
!!        val = ZERO
!!        do j=1,n_bf
!!        do k=1,n_bf
!!          val=val+ .bra(i-.n_bas+1)[j,k]*.bra(i-.n_bas+1)[j,k]
!!        end
!!        end
!!        write(*,*) "i",i,val
!!      end
!!      .n_bas = ONE    
!      V.destroy
      eigenvalues.destroy
      R.destroy
      S.destroy
      V.destroy
!pcc      stdout.text(std_time.elapsed_time_message("geminal job "))
!pcc      stdout.text(std_time.elapsed_cpu_time_message("geminal job "))
   end

   set_singlet_mono ::: leaky
   ! Create a default object with singlet geminals monoexcited with respect to
   ! HFguess. 
   ! a random rotation of the HF canonical orbitals is performed
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf :: INT
     j,k,counter :: INT
     R,S,T,U :: MAT{REAL}*
     V,eigenvalues :: VEC{REAL}*
     i,l :: INT
     val :: REAL

     i_geminals = .i_geminals
     n_geminals = .n_geminals
     n_bf = .n_bf
     .n_dependent=0
     .n_bas=n_bf-n_geminals+1
     .bra.destroy
     .ket.destroy
     .special_ket.destroy
     .contraction_wfs.destroy
     .contraction_energies.destroy
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,n_geminals     ! create ground state bras and kets
        .bra(j).element.create(n_bf,n_bf)
        .ket(j).element.create(n_bf,n_bf)
        .special_ket(j).element.create(2)
        .ket(j).element = ZERO
        .bra(j).element = ZERO
        .special_ket(j).element = 0
     end
     counter=1
     do j = 1,n_geminals     ! set ground state bras and kets
       if(j==i_geminals)cycle
       counter=counter+1
       .ket(counter)[j,j] = ONE
       .bra(counter)[j,j] = ONE
     end
     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
     do j = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
       .contraction_energies(j)= ZERO
     end
     counter=1
     .contraction_wfs(counter)[i_geminals,i_geminals] = ONE
     k = i_geminals
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     DIE_IF(counter/=.n_bas,"counter not equal to .n_bas")
! Rotate
      U.create(.n_geminals,.n_geminals)
      T.create(.n_geminals,.n_geminals)
      S.create(n_bf,n_bf)
      R.create(n_bf,n_bf)
      eigenvalues.create(n_bf)
      do i = 1,n_geminals
      do j = 1,i
         call random_number(val)
         T(i,j) = val
         T(j,i) = val
      end
      end
      T.solve_eigenproblem(eigenvalues,U)
      R=ZERO
      do i = 1,n_geminals
      do j = 1,i
         R(i,j) = U(i,j)
         R(j,i) = U(j,i)
      end
      end
      do i = n_geminals+1, n_bf
         R(i,i) = ONE
      end
      U.destroy
      T.destroy
    !  stdout.text("R")
    !  stdout.put(R)
      R.to_unit_matrix
      S=matmul(R,transpose(R))
      stdout.show("is unit matrix =",S.is_unit_matrix)
      V.create(n_bf)
      do i = 1,.n_bas
        do j=1,n_bf
        V=.contraction_wfs(i)[j,:]
        .contraction_wfs(i)[j,:].to_product_of(R,V)
        end
        do k=1,n_bf
        V=.contraction_wfs(i)[:,k]
        .contraction_wfs(i)[:,k].to_product_of(R,V)
        end
      end
      do i = .n_bas+1,.n_bas+n_geminals-1
        do j=1,n_bf
         V=.ket(i-.n_bas+1)[j,:]
        .ket(i-.n_bas+1)[j,:].to_product_of(R,V)
         V=.bra(i-.n_bas+1)[j,:]
        .bra(i-.n_bas+1)[j,:].to_product_of(R,V)
        end
        do k=1,n_bf
        V=.ket(i-.n_bas+1)[:,k]
        .ket(i-.n_bas+1)[:,k].to_product_of(R,V)
        V=.bra(i-.n_bas+1)[:,k]
        .bra(i-.n_bas+1)[:,k].to_product_of(R,V)
        end
      end
      eigenvalues.destroy
      R.destroy
      S.destroy
      V.destroy
!pcc      stdout.text(std_time.elapsed_time_message("geminal job "))
!pcc      stdout.text(std_time.elapsed_cpu_time_message("geminal job "))
   end

   set_singlet_defaults ::: leaky
   ! Create a default object with singlet geminals only. 
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf :: INT
     j,k,counter :: INT
     n_nonzero :: INT

     i_geminals = .i_geminals
     n_geminals = .n_geminals
     n_bf = .n_bf
     n_nonzero = (n_bf-n_geminals+1)*(n_bf-n_geminals+2)/2 ! avoid the ground state orbitals
     .n_bas=n_bf*(n_bf+1)/2
     .n_dependent=.n_bas-n_nonzero
      if (.bra.created) .bra.destroy
      if (.ket.created) .ket.destroy
      if (.special_ket.created) .special_ket.destroy
      if (.contraction_wfs.created) .contraction_wfs.destroy
      if (.contraction_energies.created) .contraction_energies.destroy
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,n_geminals     ! create ground state bras and kets
        .bra(j).element.create(n_bf,n_bf)
        .ket(j).element.create(n_bf,n_bf)
        .special_ket(j).element.create(2)
        .ket(j).element = ZERO
        .bra(j).element = ZERO
        .special_ket(j).element = 0
     end
     counter=1
     do j = 1,n_geminals     ! set ground state bras and kets
       if(j==i_geminals)cycle
       counter=counter+1
       .special_ket(counter).element = j
       .bra(counter)[j,j] = ONE
     end
     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
     do j = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
       .contraction_energies(j)= ZERO
     end
     counter=1
     .contraction_wfs(counter)[i_geminals,i_geminals] = ONE
!temp
!debug     if (i_geminals == 1) .contraction_wfs(counter)[2,2] = ONE
!temp
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = j-1,1,-1
       if ( 1<=k AND k <= n_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     k = i_geminals
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     DIE_IF(counter/=n_nonzero,"counter not equal to n_nonzero") 
     do j =1, n_geminals
       if ( j==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = n_geminals,1,-1
       if ( k==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     do j = 1,n_geminals
     do k = j-1,1,-1
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     DIE_IF(counter/=.n_bas,"counter not equal to .n_bas")
   end

   set_rassolov_defaults ::: leaky
   ! Create a default object with singlet geminals only. 
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf :: INT
     j,k,counter :: INT
     n_nonzero :: INT

     i_geminals = .i_geminals
     n_geminals = .n_geminals
     n_bf = .n_bf
     n_nonzero = (n_bf-n_geminals+1)*(n_bf-n_geminals+2)/2 ! avoid the ground state orbitals
     .n_bas=n_bf*(n_bf+1)/2
     .n_dependent=.n_bas-n_nonzero
      if (.bra.created) .bra.destroy
      if (.ket.created) .ket.destroy
      if (.special_ket.created) .special_ket.destroy
      if (.contraction_wfs.created) .contraction_wfs.destroy
      if (.contraction_energies.created) .contraction_energies.destroy
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,n_geminals     ! create ground state bras and kets
        .bra(j).element.create(n_bf,n_bf)
        .ket(j).element.create(n_bf,n_bf)
        .special_ket(j).element.create(2)
        .ket(j).element = ZERO
        .bra(j).element = ZERO
        .special_ket(j).element = 0
     end
     counter=1
     do j = 1,n_geminals     ! set ground state bras and kets
       if(j==i_geminals)cycle
       counter=counter+1
       .ket(counter)[j,j] = ONE/sqrt(TWO)
       .ket(counter)[j,j+2] = HALF
       .ket(counter)[j+2,j] = HALF
       .bra(counter)[j,j] = ONE/sqrt(TWO)
       .bra(counter)[j,j+2] = HALF
       .bra(counter)[j+2,j] = HALF
     end
     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
     do j = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
       .contraction_energies(j)= ZERO
     end
     counter=1
     .contraction_wfs(counter)[i_geminals,i_geminals] = ONE
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = j-1,1,-1
       if ( 1<=k AND k <= n_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     k = i_geminals
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     DIE_IF(counter/=n_nonzero,"counter not equal to n_nonzero") 
     do j =1, n_geminals
       if ( j==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = n_geminals,1,-1
       if ( k==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     do j = 1,n_geminals
     do k = j-1,1,-1
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     DIE_IF(counter/=.n_bas,"counter not equal to .n_bas")
   end

   set_singlet_extremals ::: leaky
   ! read singlet extremal geminals from archive and 
   ! set them as guess gemoinals
     n_bas :: INT
     extremal_gem :: MAT{REAL}*
     extremal_archive :: ARCHIVE
!WARNING .i_geminal must match that used when making the archive
     n_bas=.n_bas
     extremal_gem.create(n_bas,n_bas)
     extremal_archive.set(.name,"extremals")
     extremal_archive.read(extremal_gem)
     .contraction_wfs.change_basis_using(extremal_gem,TRUE)
     extremal_gem.destroy
 !specific to LiH .i_geminal = 1 in sto3G
     .set_to_zero_special_ket
     .bra(2).element=.contraction_wfs(20).element
     .ket(2).element=.contraction_wfs(20).element
     .contraction_wfs(1).element=.contraction_wfs(21).element
     .n_bas=1
     .n_dependent=20

   end

   make_singlet_extremals ::: leaky
   ! Create singlet guess geminals by diagonalising the 2 electron
   ! reduced Hamiltonian of Bopp or electronic repulsion only
   ! depending on add-core flag in read_gmf_scheme and archive them. 
     n_bas :: INT
     rhm :: MAT{REAL}*
     extremal_gem :: MAT{REAL}*
     extremal_val :: VEC{REAL}*
     extremal_archive :: ARCHIVE

     .set_singlet_defaults
     n_bas=.n_bas
     rhm.create(n_bas,n_bas)
     .make_RHM(rhm)
     extremal_gem.create(n_bas,n_bas)
     extremal_val.create(n_bas)
     stdout.text(" ")
     stdout.text(" ")
     stdout.text("RHM ")
     stdout.text(" ")
     stdout.put(rhm)
     rhm.solve_eigenproblem(extremal_val,extremal_gem)
     stdout.text("RHM eigenvalues")
     stdout.text(" ")
     stdout.put(extremal_val)
     stdout.text(" ")
     stdout.text(" ")
     stdout.text("RHM eigenvectors")
     stdout.text(" ")
     stdout.put(extremal_gem)
     extremal_archive.set(.name,"extremals")
     extremal_archive.write(extremal_gem)
     rhm.destroy
     extremal_gem.destroy
     extremal_val.destroy
     stop

   end

!carmela1122   set_singlet_handmade ::: leaky
!carmela1122   ! Create a handmade object with singlet geminals only. 
!carmela1122     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
!carmela1122     i_geminals :: INT
!carmela1122     n_geminals,n_bf :: INT
!carmela1122     j,k,counter :: INT
!carmela1122     n_nonzero :: INT
!carmela1122
!carmela1122     i_geminals = .i_geminals
!carmela1122     n_geminals = .n_geminals
!carmela1122     n_bf = .n_bf
!carmela1122    !n_nonzero = (n_bf-n_geminals+1)*(n_bf-n_geminals+2)/2 ! avoid the ground state orbitals
!carmela1122      n_nonzero=1
!carmela1122      .n_bas=1
!carmela1122     !.n_bas=n_bf*(n_bf+1)/2
!carmela1122     .n_dependent=.n_bas-n_nonzero
!carmela1122      if (.bra.created) .bra.destroy
!carmela1122      if (.ket.created) .ket.destroy
!carmela1122      if (.special_ket.created) .special_ket.destroy
!carmela1122      if (.contraction_wfs.created) .contraction_wfs.destroy
!carmela1122      if (.contraction_energies.created) .contraction_energies.destroy
!carmela1122     .bra.create(n_geminals) ! create bra and ket arrays
!carmela1122     .ket.create(n_geminals)
!carmela1122     .special_ket.create(n_geminals)
!carmela1122     .contraction_wfs.create(.n_bas)
!carmela1122     .contraction_energies.create(.n_bas)
!carmela1122     .contraction_energies = ZERO
!carmela1122     do j = 1,n_geminals     ! create ground state bras and kets
!carmela1122        .bra(j).element.create(n_bf,n_bf)
!carmela1122        .ket(j).element.create(n_bf,n_bf)
!carmela1122        .special_ket(j).element.create(2)
!carmela1122        .ket(j).element = ZERO
!carmela1122        .bra(j).element = ZERO
!carmela1122        .special_ket(j).element = 0
!carmela1122     end
!carmela1122     counter=1
!carmela1122     do j = 1,n_geminals     ! set ground state bras and kets
!carmela1122       if(j==i_geminals)cycle
!carmela1122       counter=counter+1
!carmela1122     !  .special_ket(counter).element = j
!carmela1122 !      .bra(counter)[j,j] = ONE
!carmela1122      .ket(counter)[1,2] =  -0.02710d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[1,3] =   0.01592d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[1,4] =   0.00154d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[1,5] =  -0.01532d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[2,3] =  -0.00294d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[2,4] =   0.00204d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[2,5] =  -0.00091d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[3,4] =  -0.67668d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[3,5] =   0.00381d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[4,5] =  -0.00058d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[2,1] =  -0.02710d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[3,1] =   0.01592d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[4,1] =   0.00154d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[5,1] =  -0.01532d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[3,2] =  -0.00294d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[4,2] =   0.00204d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[5,2] =  -0.00091d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[4,3] =  -0.67668d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[5,3] =   0.00381d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[5,4] =  -0.00058d0 /sqrt(TWO)     
!carmela1122      .ket(counter)[1,1] =  -0.00062d0
!carmela1122      .ket(counter)[2,2] =  -0.73471d0
!carmela1122      .ket(counter)[3,3] =   0.00226d0
!carmela1122      .ket(counter)[4,4] =   0.02884d0
!carmela1122      .ket(counter)[5,5] =   0.01488d0
!carmela1122      .bra(counter)[1,2] =  -0.02710d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[1,3] =   0.01592d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[1,4] =   0.00154d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[1,5] =  -0.01532d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[2,3] =  -0.00294d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[2,4] =   0.00204d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[2,5] =  -0.00091d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[3,4] =  -0.67668d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[3,5] =   0.00381d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[4,5] =  -0.00058d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[2,1] =  -0.02710d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[3,1] =   0.01592d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[4,1] =   0.00154d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[5,1] =  -0.01532d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[3,2] =  -0.00294d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[4,2] =   0.00204d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[5,2] =  -0.00091d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[4,3] =  -0.67668d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[5,3] =   0.00381d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[5,4] =  -0.00058d0 /sqrt(TWO)     
!carmela1122      .bra(counter)[1,1] =  -0.00062d0
!carmela1122      .bra(counter)[2,2] =  -0.73471d0
!carmela1122      .bra(counter)[3,3] =   0.00226d0
!carmela1122      .bra(counter)[4,4] =   0.02884d0
!carmela1122      .bra(counter)[5,5] =   0.01488d0
!carmela1122     end
!carmela1122     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
!carmela1122     do j = 1,.n_bas     ! create coeficient matrices
!carmela1122       .contraction_wfs(j).element.create(n_bf,n_bf)
!carmela1122       .contraction_wfs(j).element = ZERO
!carmela1122       .contraction_energies(j)= ZERO
!carmela1122     end
!carmela1122!canoniques     .contraction_wfs(1)[13,1] = ONE/sqrt(TWO)
!carmela1122!canoniques     .contraction_wfs(1)[1,13] = ONE/sqrt(TWO)
!carmela1122!canoniques     .contraction_wfs(2)[1,14] = ONE/sqrt(TWO)
!carmela1122!canoniques     .contraction_wfs(2)[14,1] = ONE/sqrt(TWO)
!carmela1122!canoniques     .contraction_wfs(3)[13,15] = ONE/sqrt(TWO)
!carmela1122!canoniques     .contraction_wfs(3)[15,13] = ONE/sqrt(TWO)
!carmela1122!canoniques     .contraction_wfs(4)[14,15] = ONE/sqrt(TWO)
!carmela1122!canoniques     .contraction_wfs(4)[15,14] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(1)[13,1] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(1)[1,13] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(2)[1,16] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(2)[16,1] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(3)[14,13] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(3)[13,14] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(4)[13,15] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(4)[15,13] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(5)[13,18] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(5)[18,13] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(6)[14,16] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(6)[16,14] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(7)[15,16] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(7)[16,15] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(8)[18,16] = ONE/sqrt(TWO)
!carmela1122!old     .contraction_wfs(8)[16,18] = ONE/sqrt(TWO)
!carmela1122      .contraction_wfs(1)[1,2] = -0.05598d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[1,3] =  0.01230d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[1,4] = -0.00001d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[1,5] =  0.00000d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[2,3] = -0.00077d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[2,4] =  0.00001d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[2,5] = -0.00027d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[3,4] =  0.00026d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[3,5] =  0.00007d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[4,5] =  0.14971d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[2,1] = -0.05598d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[3,1] =  0.01230d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[4,1] = -0.00001d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[5,1] =  0.00000d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[3,2] = -0.00077d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[4,2] =  0.00001d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[5,2] = -0.00027d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[4,3] =  0.00026d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[5,3] =  0.00007d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[5,4] =  0.14971d0   /sqrt(TWO)     
!carmela1122      .contraction_wfs(1)[1,1] =  0.98706d0  
!carmela1122      .contraction_wfs(1)[2,2] =  0.00119d0  
!carmela1122      .contraction_wfs(1)[3,3] =  0.00007d0  
!carmela1122      .contraction_wfs(1)[4,4] = -0.00001d0  
!carmela1122      .contraction_wfs(1)[5,5] =  0.00212d0  
!carmela1122   end

!carmella1212s   set_singlet_handmade ::: leaky
!carmella1212s   ! Create a handmade object with singlet geminals only. 
!carmella1212s     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
!carmella1212s     i_geminals :: INT
!carmella1212s     n_geminals,n_bf :: INT
!carmella1212s     j,k,counter :: INT
!carmella1212s     n_nonzero :: INT
!carmella1212s
!carmella1212s     i_geminals = .i_geminals
!carmella1212s     n_geminals = .n_geminals
!carmella1212s     n_bf = .n_bf
!carmella1212s    !n_nonzero = (n_bf-n_geminals+1)*(n_bf-n_geminals+2)/2 ! avoid the ground state orbitals
!carmella1212s      n_nonzero=1
!carmella1212s      .n_bas=1
!carmella1212s     !.n_bas=n_bf*(n_bf+1)/2
!carmella1212s     .n_dependent=.n_bas-n_nonzero
!carmella1212s      if (.bra.created) .bra.destroy
!carmella1212s      if (.ket.created) .ket.destroy
!carmella1212s      if (.special_ket.created) .special_ket.destroy
!carmella1212s      if (.contraction_wfs.created) .contraction_wfs.destroy
!carmella1212s      if (.contraction_energies.created) .contraction_energies.destroy
!carmella1212s     .bra.create(n_geminals) ! create bra and ket arrays
!carmella1212s     .ket.create(n_geminals)
!carmella1212s     .special_ket.create(n_geminals)
!carmella1212s     .contraction_wfs.create(.n_bas)
!carmella1212s     .contraction_energies.create(.n_bas)
!carmella1212s     .contraction_energies = ZERO
!carmella1212s     do j = 1,n_geminals     ! create ground state bras and kets
!carmella1212s        .bra(j).element.create(n_bf,n_bf)
!carmella1212s        .ket(j).element.create(n_bf,n_bf)
!carmella1212s        .special_ket(j).element.create(2)
!carmella1212s        .ket(j).element = ZERO
!carmella1212s        .bra(j).element = ZERO
!carmella1212s        .special_ket(j).element = 0
!carmella1212s     end
!carmella1212s     counter=1
!carmella1212s     do j = 1,n_geminals     ! set ground state bras and kets
!carmella1212s       if(j==i_geminals)cycle
!carmella1212s       counter=counter+1
!carmella1212s     !  .special_ket(counter).element = j
!carmella1212s !      .bra(counter)[j,j] = ONE
!carmella1212s      .ket(counter)[1,2] =  0.99780d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[1,3] =  0.00135d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[1,4] =  0.00043d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[1,5] =  0.00054d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[2,3] =  0.01609d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[2,4] = -0.00003d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[2,5] = -0.00005d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[3,4] = -0.00730d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[3,5] =  0.00003d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[4,5] =  0.01405d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[2,1] =  0.99780d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[3,1] =  0.00135d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[4,1] =  0.00043d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[5,1] =  0.00054d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[3,2] =  0.01609d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[4,2] = -0.00003d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[5,2] = -0.00005d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[4,3] = -0.00730d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[5,3] =  0.00003d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[5,4] =  0.01405d0   /sqrt(TWO)     
!carmella1212s      .ket(counter)[1,1] =  0.05449d0  
!carmella1212s      .ket(counter)[2,2] = -0.03012d0  
!carmella1212s      .ket(counter)[3,3] = -0.00007d0  
!carmella1212s      .ket(counter)[4,4] =  0.00060d0  
!carmella1212s      .ket(counter)[5,5] =  0.00175d0  
!carmella1212s      .bra(counter)[1,2] =  0.99780d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[1,3] =  0.00135d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[1,4] =  0.00043d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[1,5] =  0.00054d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[2,3] =  0.01609d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[2,4] = -0.00003d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[2,5] = -0.00005d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[3,4] = -0.00730d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[3,5] =  0.00003d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[4,5] =  0.01405d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[2,1] =  0.99780d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[3,1] =  0.00135d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[4,1] =  0.00043d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[5,1] =  0.00054d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[3,2] =  0.01609d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[4,2] = -0.00003d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[5,2] = -0.00005d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[4,3] = -0.00730d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[5,3] =  0.00003d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[5,4] =  0.01405d0   /sqrt(TWO)     
!carmella1212s      .bra(counter)[1,1] =  0.05449d0  
!carmella1212s      .bra(counter)[2,2] = -0.03012d0  
!carmella1212s      .bra(counter)[3,3] = -0.00007d0  
!carmella1212s      .bra(counter)[4,4] =  0.00060d0  
!carmella1212s      .bra(counter)[5,5] =  0.00175d0  
!carmella1212s     end
!carmella1212s     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
!carmella1212s     do j = 1,.n_bas     ! create coeficient matrices
!carmella1212s       .contraction_wfs(j).element.create(n_bf,n_bf)
!carmella1212s       .contraction_wfs(j).element = ZERO
!carmella1212s       .contraction_energies(j)= ZERO
!carmella1212s     end
!carmella1212s!canoniques     .contraction_wfs(1)[13,1] = ONE/sqrt(TWO)
!carmella1212s!canoniques     .contraction_wfs(1)[1,13] = ONE/sqrt(TWO)
!carmella1212s!canoniques     .contraction_wfs(2)[1,14] = ONE/sqrt(TWO)
!carmella1212s!canoniques     .contraction_wfs(2)[14,1] = ONE/sqrt(TWO)
!carmella1212s!canoniques     .contraction_wfs(3)[13,15] = ONE/sqrt(TWO)
!carmella1212s!canoniques     .contraction_wfs(3)[15,13] = ONE/sqrt(TWO)
!carmella1212s!canoniques     .contraction_wfs(4)[14,15] = ONE/sqrt(TWO)
!carmella1212s!canoniques     .contraction_wfs(4)[15,14] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(1)[13,1] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(1)[1,13] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(2)[1,16] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(2)[16,1] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(3)[14,13] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(3)[13,14] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(4)[13,15] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(4)[15,13] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(5)[13,18] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(5)[18,13] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(6)[14,16] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(6)[16,14] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(7)[15,16] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(7)[16,15] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(8)[18,16] = ONE/sqrt(TWO)
!carmella1212s!old     .contraction_wfs(8)[16,18] = ONE/sqrt(TWO)
!carmella1212s      .contraction_wfs(1)[1,2] =  0.99780d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[1,3] =  0.00135d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[1,4] =  0.00043d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[1,5] =  0.00054d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[2,3] =  0.01609d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[2,4] = -0.00003d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[2,5] = -0.00005d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[3,4] = -0.00730d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[3,5] =  0.00003d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[4,5] =  0.01405d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[2,1] =  0.99780d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[3,1] =  0.00135d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[4,1] =  0.00043d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[5,1] =  0.00054d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[3,2] =  0.01609d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[4,2] = -0.00003d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[5,2] = -0.00005d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[4,3] = -0.00730d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[5,3] =  0.00003d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[5,4] =  0.01405d0  /sqrt(TWO)     
!carmella1212s      .contraction_wfs(1)[1,1] =  0.05449d0 
!carmella1212s      .contraction_wfs(1)[2,2] = -0.03012d0 
!carmella1212s      .contraction_wfs(1)[3,3] = -0.00007d0 
!carmella1212s      .contraction_wfs(1)[4,4] =  0.00060d0 
!carmella1212s      .contraction_wfs(1)[5,5] =  0.00175d0 
!carmella1212s   end

!for O3   set_singlet_ ::: leaky
!for O3   ! Create a  object with singlet geminals only. 
!for O3     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
!for O3     i_geminals :: INT
!for O3     n_geminals,n_bf :: INT
!for O3     j,k,counter :: INT
!for O3     n_nonzero :: INT
!for O3
!for O3     i_geminals = .i_geminals
!for O3     n_geminals = .n_geminals
!for O3     n_bf = .n_bf
!for O3   !  n_nonzero = (n_bf-n_geminals+1)*(n_bf-n_geminals+2)/2 ! avoid the ground state orbitals
!for O3      n_nonzero=8
!for O3      .n_bas=8
!for O3   !  .n_bas=n_bf*(n_bf+1)/2
!for O3     .n_dependent=.n_bas-n_nonzero
!for O3      if (.bra.created) .bra.destroy
!for O3      if (.ket.created) .ket.destroy
!for O3      if (.special_ket.created) .special_ket.destroy
!for O3      if (.contraction_wfs.created) .contraction_wfs.destroy
!for O3      if (.contraction_energies.created) .contraction_energies.destroy
!for O3     .bra.create(n_geminals) ! create bra and ket arrays
!for O3     .ket.create(n_geminals)
!for O3     .special_ket.create(n_geminals)
!for O3     .contraction_wfs.create(.n_bas)
!for O3     .contraction_energies.create(.n_bas)
!for O3     .contraction_energies = ZERO
!for O3     do j = 1,n_geminals     ! create ground state bras and kets
!for O3        .bra(j).element.create(n_bf,n_bf)
!for O3        .ket(j).element.create(n_bf,n_bf)
!for O3        .special_ket(j).element.create(2)
!for O3        .ket(j).element = ZERO
!for O3        .bra(j).element = ZERO
!for O3        .special_ket(j).element = 0
!for O3     end
!for O3     counter=1
!for O3     do j = 1,n_geminals     ! set ground state bras and kets
!for O3       if(j==i_geminals)cycle
!for O3       counter=counter+1
!for O3       .special_ket(counter).element = j
!for O3       .bra(counter)[j,j] = ONE
!for O3     end
!for O3     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
!for O3     do j = 1,.n_bas     ! create coeficient matrices
!for O3       .contraction_wfs(j).element.create(n_bf,n_bf)
!for O3       .contraction_wfs(j).element = ZERO
!for O3       .contraction_energies(j)= ZERO
!for O3     end
!for O3!canoniques     .contraction_wfs(1)[13,1] = ONE/sqrt(TWO)
!for O3!canoniques     .contraction_wfs(1)[1,13] = ONE/sqrt(TWO)
!for O3!canoniques     .contraction_wfs(2)[1,14] = ONE/sqrt(TWO)
!for O3!canoniques     .contraction_wfs(2)[14,1] = ONE/sqrt(TWO)
!for O3!canoniques     .contraction_wfs(3)[13,15] = ONE/sqrt(TWO)
!for O3!canoniques     .contraction_wfs(3)[15,13] = ONE/sqrt(TWO)
!for O3!canoniques     .contraction_wfs(4)[14,15] = ONE/sqrt(TWO)
!for O3!canoniques     .contraction_wfs(4)[15,14] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(1)[13,1] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(1)[1,13] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(2)[1,16] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(2)[16,1] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(3)[14,13] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(3)[13,14] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(4)[13,15] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(4)[15,13] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(5)[13,18] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(5)[18,13] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(6)[14,16] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(6)[16,14] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(7)[15,16] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(7)[16,15] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(8)[18,16] = ONE/sqrt(TWO)
!for O3     .contraction_wfs(8)[16,18] = ONE/sqrt(TWO)
!for O3   end

   set_singlet_handmade ::: leaky
   ! Create a handmade object with singlet geminals only. 
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf :: INT
     j,k,counter :: INT
     n_nonzero :: INT

     i_geminals = .i_geminals
     n_geminals = .n_geminals
     n_bf = .n_bf
    ! n_nonzero = (n_bf-n_geminals+1)*(n_bf-n_geminals+2)/2 ! avoid the ground state orbitals
!carmella1212antisym      n_nonzero=1
!carmella1212antisym      .n_bas=1
     .n_bas=n_bf*(n_bf+1)/2
     n_nonzero = 1
     .n_dependent=.n_bas-n_nonzero
      if (.bra.created) .bra.destroy
      if (.ket.created) .ket.destroy
      if (.special_ket.created) .special_ket.destroy
      if (.contraction_wfs.created) .contraction_wfs.destroy
      if (.contraction_energies.created) .contraction_energies.destroy
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,n_geminals     ! create ground state bras and kets
        .bra(j).element.create(n_bf,n_bf)
        .ket(j).element.create(n_bf,n_bf)
        .special_ket(j).element.create(2)
        .ket(j).element = ZERO
        .bra(j).element = ZERO
        .special_ket(j).element = 0
     end
!carmella1212antisym    counter=1
!carmella1212antisym     do j = 1,n_geminals     ! set ground state bras and kets
!carmella1212antisym       if(j==i_geminals)cycle
!carmella1212antisym       counter=counter+1
     !  .special_ket(counter).element = j
 !      .bra(counter)[j,j] = ONE
     if (.i_geminals==1) then
       .ket(2)[3,3] = 0.99501989d0
       .ket(2)[4,4] = -0.09967658d0
       .ket(3)[5,5] = 0.99444975d0
       .ket(3)[6,6] = -0.10521260d0
       .ket(4)[7,7] = 0.98972076d0
       .ket(4)[8,8] = -0.14301336d0
       .ket(5)[9,9] = 0.98972067d0
       .ket(5)[10,10] = -0.14301397d0
       .bra(2)[3,3] = 0.99501989d0
       .bra(2)[4,4] = -0.09967658d0
       .bra(3)[5,5] = 0.99444975d0
       .bra(3)[6,6] = -0.10521260d0
       .bra(4)[7,7] = 0.98972076d0
       .bra(4)[8,8] = -0.14301336d0
       .bra(5)[9,9] = 0.98972067d0
       .bra(5)[10,10] = -0.14301397d0
!H8-rassolov       .ket(2)[3,3] = 0.99490020d0
!H8-rassolov       .ket(2)[4,4] = -0.10086422d0
!H8-rassolov       .ket(3)[5,5] = 0.98972164d0
!H8-rassolov       .ket(3)[6,6] = -0.14300724d0
!H8-rassolov       .ket(4)[7,7] = 0.98972107d0
!H8-rassolov       .ket(4)[8,8] = -0.14301121d0
!H8-rassolov       .bra(2)[3,3] = 0.99490020d0
!H8-rassolov       .bra(2)[4,4] = -0.10086422d0
!H8-rassolov       .bra(3)[5,5] = 0.98972164d0
!H8-rassolov       .bra(3)[6,6] = -0.14300724d0
!H8-rassolov       .bra(4)[7,7] = 0.98972107d0
!H8-rassolov       .bra(4)[8,8] = -0.14301121d0
!H6-vtz-rassolov       .ket(2)[7,7] = .99008302d0
!H6-vtz-rassolov       .ket(2)[8,8] = -.135015005d0
!H6-vtz-rassolov       .ket(2)[9,9] = -.03711262d0
!H6-vtz-rassolov       .ket(2)[10,10] = -.00949263d0
!H6-vtz-rassolov       .ket(2)[11,11] = -.00578688d0
!H6-vtz-rassolov       .ket(2)[12,12] = -0.00237005d0
!H6-vtz-rassolov       .ket(3)[13,13] = .99008302d0
!H6-vtz-rassolov       .ket(3)[14,14] = -.135015005d0
!H6-vtz-rassolov       .ket(3)[15,15] = -.03711262d0
!H6-vtz-rassolov       .ket(3)[16,16] = -.00949263d0
!H6-vtz-rassolov       .ket(3)[17,17] = -.00578688d0
!H6-vtz-rassolov       .ket(3)[18,18] = -0.00237005d0
!H6-vtz-rassolov       .bra(2)[7,7] = .99008302d0
!H6-vtz-rassolov       .bra(2)[8,8] = -.135015005d0
!H6-vtz-rassolov       .bra(2)[9,9] = -.03711262d0
!H6-vtz-rassolov       .bra(2)[10,10] = -.00949263d0
!H6-vtz-rassolov       .bra(2)[11,11] = -.00578688d0
!H6-vtz-rassolov       .bra(2)[12,12] = -0.00237005d0
!H6-vtz-rassolov       .bra(3)[13,13] = .99008302d0
!H6-vtz-rassolov       .bra(3)[14,14] = -.135015005d0
!H6-vtz-rassolov       .bra(3)[15,15] = -.03711262d0
!H6-vtz-rassolov       .bra(3)[16,16] = -.00949263d0
!H6-vtz-rassolov       .bra(3)[17,17] = -.00578688d0
!H6-vtz-rassolov       .bra(3)[18,18] = -0.00237005d0
!H6-631G-rassolov       .ket(2)[5,5] = 0.990716d0
!H6-631G-rassolov       .ket(2)[6,6] = -0.13117356d0
!H6-631G-rassolov       .ket(2)[7,7] = -0.034102345d0
!H6-631G-rassolov       .ket(2)[8,8] = -0.010598615d0
!H6-631G-rassolov       .ket(3)[9,9] = 0.990716d0
!H6-631G-rassolov       .ket(3)[10,10] = -0.13117356d0
!H6-631G-rassolov       .ket(3)[11,11] = -0.034102345d0
!H6-631G-rassolov       .ket(3)[12,12] = -0.010598615d0
!H6-631G-rassolov       .bra(2)[5,5] = 0.990716d0
!H6-631G-rassolov       .bra(2)[6,6] = -0.13117356d0
!H6-631G-rassolov       .bra(2)[7,7] = -0.034102345d0
!H6-631G-rassolov       .bra(2)[8,8] = -0.010598615d0
!H6-631G-rassolov       .bra(3)[9,9] = 0.990716d0
!H6-631G-rassolov       .bra(3)[10,10] = -0.13117356d0
!H6-631G-rassolov       .bra(3)[11,11] = -0.034102345d0
!H6-631G-rassolov       .bra(3)[12,12] = -0.010598615d0
!H6sto3G-rassolov       .ket(2)[3,3] = 0.98960605d0
!H6sto3G-rassolov       .ket(2)[4,4] = -0.14380498d0
!H6sto3G-rassolov       .ket(3)[5,5] = 0.98960605d0
!H6sto3G-rassolov       .ket(3)[6,6] = -0.14380497d0
!H6sto3G-rassolov       .bra(2)[3,3] = 0.98960605d0
!H6sto3G-rassolov       .bra(2)[4,4] = -0.14380498d0
!H6sto3G-rassolov       .bra(3)[5,5] = 0.98960605d0
!H6sto3G-rassolov       .bra(3)[6,6] = -0.14380497d0
!Li2-rassolov       .ket(2)[2,2] = 0.99999597d0
!Li2-rassolov       .ket(2)[3,3] = -0.00222610d0
!Li2-rassolov       .ket(2)[4,4] = -0.00124473d0
!Li2-rassolov       .ket(2)[5,5] = -0.00124473d0
!Li2-rassolov       .ket(3)[6,6] = 0.95501290d0
!Li2-rassolov       .ket(3)[7,7] = -0.16187685d0
!Li2-rassolov       .ket(3)[8,8] = -0.16102061d0
!Li2-rassolov       .ket(3)[9,9] = -0.16102061d0
!Li2-rassolov       .ket(3)[10,10] = -0.09945338d0
!Li2-rassolov       .bra(2)[2,2] = 0.99999597d0
!Li2-rassolov       .bra(2)[3,3] = -0.00222610d0
!Li2-rassolov       .bra(2)[4,4] = -0.00124473d0
!Li2-rassolov       .bra(2)[5,5] = -0.00124473d0
!Li2-rassolov       .bra(3)[6,6] = 0.95501290d0
!Li2-rassolov       .bra(3)[7,7] = -0.16187685d0
!Li2-rassolov       .bra(3)[8,8] = -0.16102061d0
!Li2-rassolov       .bra(3)[9,9] = -0.16102061d0
!Li2-rassolov       .bra(3)[10,10] = -0.09945338d0
!BeH2-rassolov       .ket(2)[2,2] = 0.99469201d0
!BeH2-rassolov       .ket(2)[3,3] = -0.09317530d0
!BeH2-rassolov       .ket(2)[4,4] = -0.03087208d0
!BeH2-rassolov       .ket(2)[5,5] = -0.03087208d0
!BeH2-rassolov       .ket(3)[6,6] = 0.99531238d0
!BeH2-rassolov       .ket(3)[7,7] = -0.09671227d0
!BeH2-rassolov       .bra(2)[2,2] = 0.99469201d0
!BeH2-rassolov       .bra(2)[3,3] = -0.09317530d0
!BeH2-rassolov       .bra(2)[4,4] = -0.03087208d0
!BeH2-rassolov       .bra(2)[5,5] = -0.03087208d0
!BeH2-rassolov       .bra(3)[6,6] = 0.99531238d0
!BeH2-rassolov       .bra(3)[7,7] = -0.09671227d0
!LiH-rassolov       .ket(2)[3,3] = 0.98863491d0
!LiH-rassolov       .ket(2)[4,4] = -0.14519098d0
!LiH-rassolov       .ket(2)[5,5] = -0.02757341d0
!LiH-rassolov       .ket(2)[6,6] = -0.02757341d0
!LiH-rassolov       .bra(2)[3,3] = 0.98863491d0
!LiH-rassolov       .bra(2)[4,4] = -0.14519098d0
!LiH-rassolov       .bra(2)[5,5] = -0.02757341d0
!LiH-rassolov       .bra(2)[6,6] = -0.02757341d0
!Be-rassolov       .ket(2)[2,2] = 0.94638259d0
!Be-rassolov       .ket(2)[3,3] = -0.18651183d0
!Be-rassolov       .ket(2)[4,4] = -0.18651183d0
!Be-rassolov       .ket(2)[5,5] = -0.18651183d0
!Be-rassolov       .bra(2)[2,2] = 0.94638259d0
!Be-rassolov       .bra(2)[3,3] = -0.18651183d0
!Be-rassolov       .bra(2)[4,4] = -0.18651183d0
!Be-rassolov       .bra(2)[5,5] = -0.18651183d0
!Be2-rassolov       .ket(2)[2,2] = ONE
!Be2-rassolov       .bra(2)[2,2] = ONE
!Be2-rassolov       .ket(3)[3,3] = 0.95953727d0
!Be2-rassolov       .ket(3)[4,4] = -0.183733265d0
!Be2-rassolov       .ket(3)[5,5] = -0.183733265d0
!Be2-rassolov       .ket(3)[6,6] = -0.10850071d0
!Be2-rassolov       .bra(3)[3,3] = 0.95953727d0
!Be2-rassolov       .bra(3)[4,4] = -0.183733265d0
!Be2-rassolov       .bra(3)[5,5] = -0.183733265d0
!Be2-rassolov       .bra(3)[6,6] = -0.10850071d0
!Be2-rassolov       .ket(4)[7,7] = 0.95666344d0
!Be2-rassolov       .ket(4)[8,8] = -0.181750915d0
!Be2-rassolov       .ket(4)[9,9] = -0.181750915d0
!Be2-rassolov       .ket(4)[10,10] = -0.13685130d0
!Be2-rassolov       .bra(4)[7,7] = 0.95666344d0
!Be2-rassolov       .bra(4)[8,8] = -0.181750915d0
!Be2-rassolov       .bra(4)[9,9] = -0.181750915d0
!Be2-rassolov       .bra(4)[10,10] = -0.13685130d0
!BH-rassolov      .ket(2)[2,2] = 0.99479034d0 
!BH-rassolov      .ket(2)[4,4] = -0.10194202d0
!BH-rassolov      .ket(3)[3,3] = -0.96537469d0
!BH-rassolov      .ket(3)[5,5] = 0.18446099d0
!BH-rassolov      .ket(3)[6,6] = 0.18446099d0
!BH-rassolov      .bra(2)[2,2] = 0.99479034d0
!BH-rassolov      .bra(2)[4,4] = -0.10194202d0
!BH-rassolov      .bra(3)[3,3] = -0.96537469d0
!BH-rassolov      .bra(3)[5,5] = 0.184460995d0
!BH-rassolov      .bra(3)[6,6] = 0.184460995d0
     elseif(.i_geminals==2) then 
       .ket(2)[1,1] = 0.99501996d0
       .ket(2)[2,2] = -0.09967584d0
       .ket(3)[5,5] = 0.99444975d0
       .ket(3)[6,6] = -0.10521260d0
       .ket(4)[7,7] = 0.98972076d0
       .ket(4)[8,8] = -0.14301336d0
       .ket(5)[9,9] = 0.98972067d0
       .ket(5)[10,10] = -0.14301397d0
       .bra(2)[1,1] = 0.99501996d0
       .bra(2)[2,2] = -0.09967584d0
       .bra(3)[5,5] = 0.99444975d0
       .bra(3)[6,6] = -0.10521260d0
       .bra(4)[7,7] = 0.98972076d0
       .bra(4)[8,8] = -0.14301336d0
       .bra(5)[9,9] = 0.98972067d0
       .bra(5)[10,10] = -0.14301397d0
!H8-rassolov       .ket(2)[1,1] = 0.99490083d0
!H8-rassolov       .ket(2)[2,2] = -0.10085802d0
!H8-rassolov       .ket(3)[5,5] = 0.98972164d0
!H8-rassolov       .ket(3)[6,6] = -0.14300724d0
!H8-rassolov       .ket(4)[7,7] = 0.98972107d0
!H8-rassolov       .ket(4)[8,8] = -0.14301121d0
!H8-rassolov       .bra(2)[1,1] = 0.99490083d0
!H8-rassolov       .bra(2)[2,2] = -0.10085802d0
!H8-rassolov       .bra(3)[5,5] = 0.98972164d0
!H8-rassolov       .bra(3)[6,6] = -0.14300724d0
!H8-rassolov       .bra(4)[7,7] = 0.98972107d0
!H8-rassolov       .bra(4)[8,8] = -0.14301121d0
!H6-vtz-rassolov       .ket(2)[1,1] = 0.99503479d0
!H6-vtz-rassolov       .ket(2)[2,2] = -0.09402345d0
!H6-vtz-rassolov       .ket(2)[3,3] = -0.03147794d0
!H6-vtz-rassolov       .ket(2)[4,4] = -0.00639177d0
!H6-vtz-rassolov       .ket(2)[5,5] = -0.00574110d0
!H6-vtz-rassolov       .ket(2)[6,6] = -0.00082265d0
!H6-vtz-rassolov       .ket(3)[13,13] = .99008302d0
!H6-vtz-rassolov       .ket(3)[14,14] = -.135015005d0
!H6-vtz-rassolov       .ket(3)[15,15] = -.03711262d0
!H6-vtz-rassolov       .ket(3)[16,16] = -.00949263d0
!H6-vtz-rassolov       .ket(3)[17,17] = -.00578688d0
!H6-vtz-rassolov       .ket(3)[18,18] = -0.00237005d0
!H6-vtz-rassolov       .bra(2)[1,1] = 0.99503479d0
!H6-vtz-rassolov       .bra(2)[2,2] = -0.09402345d0
!H6-vtz-rassolov       .bra(2)[3,3] = -0.03147794d0
!H6-vtz-rassolov       .bra(2)[4,4] = -0.00639177d0
!H6-vtz-rassolov       .bra(2)[5,5] = -0.00574110d0
!H6-vtz-rassolov       .bra(2)[6,6] = -0.00082265d0
!H6-vtz-rassolov       .bra(3)[13,13] = .99008302d0
!H6-vtz-rassolov       .bra(3)[14,14] = -.135015005d0
!H6-vtz-rassolov       .bra(3)[15,15] = -.03711262d0
!H6-vtz-rassolov       .bra(3)[16,16] = -.00949263d0
!H6-vtz-rassolov       .bra(3)[17,17] = -.00578688d0
!H6-vtz-rassolov       .bra(3)[18,18] = -0.00237005d0
!H6-631G-rassolov       .ket(2)[1,1] = 0.99520974d0
!H6-631G-rassolov       .ket(2)[2,2] = -0.09246186d0
!H6-631G-rassolov       .ket(2)[3,3] = -0.03126043d0
!H6-631G-rassolov       .ket(2)[4,4] = -0.00558288d0
!H6-631G-rassolov       .ket(3)[9,9] = 0.990716d0
!H6-631G-rassolov       .ket(3)[10,10] = -0.13117356d0
!H6-631G-rassolov       .ket(3)[11,11] = -0.034102345d0
!H6-631G-rassolov       .ket(3)[12,12] = -0.010598615d0
!H6-631G-rassolov       .bra(2)[1,1] = 0.99520974d0
!H6-631G-rassolov       .bra(2)[2,2] = -0.09246186d0
!H6-631G-rassolov       .bra(2)[3,3] = -0.03126043d0
!H6-631G-rassolov       .bra(2)[4,4] = -0.00558288d0
!H6-631G-rassolov       .bra(3)[9,9] = 0.990716d0
!H6-631G-rassolov       .bra(3)[10,10] = -0.13117356d0
!H6-631G-rassolov       .bra(3)[11,11] = -0.034102345d0
!H6-631G-rassolov       .bra(3)[12,12] = -0.010598615d0
!H6sto3G-rassolov       .ket(2)[1,1] = 0.99530316d0
!H6sto3G-rassolov       .ket(2)[2,2] = -0.09680716d0
!H6sto3G-rassolov       .ket(3)[5,5] = 0.98960605d0
!H6sto3G-rassolov       .ket(3)[6,6] = -0.14380497d0
!H6sto3G-rassolov       .bra(2)[1,1] = 0.99530316d0
!H6sto3G-rassolov       .bra(2)[2,2] = -0.09680716d0
!H6sto3G-rassolov       .bra(3)[5,5] = 0.98960605d0
!H6sto3G-rassolov       .bra(3)[6,6] = -0.14380497d0
!Li2-rassolov       .ket(2)[1,1] = ONE
!Li2-rassolov       .ket(3)[6,6] = 0.95501290d0
!Li2-rassolov       .ket(3)[7,7] = -0.16187685d0
!Li2-rassolov       .ket(3)[8,8] = -0.16102061d0
!Li2-rassolov       .ket(3)[9,9] = -0.16102061d0
!Li2-rassolov       .ket(3)[10,10] = -0.09945338d0
!Li2-rassolov       .bra(2)[1,1] = ONE
!Li2-rassolov       .bra(3)[6,6] = 0.95501290d0
!Li2-rassolov       .bra(3)[7,7] = -0.16187685d0
!Li2-rassolov       .bra(3)[8,8] = -0.16102061d0
!Li2-rassolov       .bra(3)[9,9] = -0.16102061d0
!Li2-rassolov       .bra(3)[10,10] = -0.09945338d0
!BeH2-rassolov       .ket(2)[1,1] = ONE
!BeH2-rassolov       .ket(3)[6,6] = 0.99531238d0
!BeH2-rassolov       .ket(3)[7,7] = -0.09671227d0
!BeH2-rassolov       .bra(2)[1,1] = ONE
!BeH2-rassolov       .bra(3)[6,6] = 0.99531238d0
!BeH2-rassolov       .bra(3)[7,7] = -0.09671227d0
!LiH-rassolov       .ket(2)[1,1] = 0.99999557d0
!LiH-rassolov       .ket(2)[2,2] = -0.00297797d0
!LiH-rassolov       .bra(2)[1,1] = 0.99999557d0
!LiH-rassolov       .bra(2)[2,2] = -0.00297797d0
!Be-rassolov       .ket(2)[1,1] = ONE
!Be-rassolov       .bra(2)[1,1] = ONE
!Be2-rassolov       .ket(2)[1,1] = ONE
!Be2-rassolov       .bra(2)[1,1] = ONE
!Be2-rassolov       .ket(3)[3,3] = 0.95953727d0
!Be2-rassolov       .ket(3)[4,4] = -0.183733265d0
!Be2-rassolov       .ket(3)[5,5] = -0.183733265d0
!Be2-rassolov       .ket(3)[6,6] = -0.10850071d0
!Be2-rassolov       .bra(3)[3,3] = 0.95953727d0
!Be2-rassolov       .bra(3)[4,4] = -0.183733265d0
!Be2-rassolov       .bra(3)[5,5] = -0.183733265d0
!Be2-rassolov       .bra(3)[6,6] = -0.10850071d0
!Be2-rassolov       .ket(4)[7,7] = 0.95666344d0
!Be2-rassolov       .ket(4)[8,8] = -0.181750915d0
!Be2-rassolov       .ket(4)[9,9] = -0.181750915d0
!Be2-rassolov       .ket(4)[10,10] = -0.13685130d0
!Be2-rassolov       .bra(4)[7,7] = 0.95666344d0
!Be2-rassolov       .bra(4)[8,8] = -0.181750915d0
!Be2-rassolov       .bra(4)[9,9] = -0.181750915d0
!Be2-rassolov       .bra(4)[10,10] = -0.13685130d0
!BH-rassolov      .ket(2)[1,1] = 1.0d0 
!BH-rassolov      .ket(3)[3,3] = -0.96537469d0
!BH-rassolov      .ket(3)[5,5] = 0.18446099d0
!BH-rassolov      .ket(3)[6,6] = 0.18446099d0
!BH-rassolov      .bra(2)[1,1] = 1.0d0
!BH-rassolov      .bra(3)[3,3] = -0.96537469d0
!BH-rassolov      .bra(3)[5,5] = 0.184460995d0
!BH-rassolov      .bra(3)[6,6] = 0.184460995d0
     elseif(.i_geminals==3) then 
       .ket(2)[1,1] = 0.99501996d0
       .ket(2)[2,2] = -0.09967584d0
       .ket(3)[3,3] = 0.99501989d0
       .ket(3)[4,4] = -0.09967658d0
       .ket(4)[7,7] = 0.98972076d0
       .ket(4)[8,8] = -0.14301336d0
       .ket(5)[9,9] = 0.98972067d0
       .ket(5)[10,10] = -0.14301397d0
       .bra(2)[1,1] = 0.99501996d0
       .bra(2)[2,2] = -0.09967584d0
       .bra(3)[3,3] = 0.99501989d0
       .bra(3)[4,4] = -0.09967658d0
       .bra(4)[7,7] = 0.98972076d0
       .bra(4)[8,8] = -0.14301336d0
       .bra(5)[9,9] = 0.98972067d0
       .bra(5)[10,10] = -0.14301397d0
!H8-rassolov       .ket(2)[1,1] = 0.99490083d0
!H8-rassolov       .ket(2)[2,2] = -0.10085802d0
!H8-rassolov       .ket(3)[3,3] =  0.99490020d0
!H8-rassolov       .ket(3)[4,4] = -0.10086422d0
!H8-rassolov       .ket(4)[7,7] = 0.98972107d0
!H8-rassolov       .ket(4)[8,8] = -0.14301121d0
!H8-rassolov       .bra(2)[1,1] = 0.99490083d0
!H8-rassolov       .bra(2)[2,2] = -0.10085802d0
!H8-rassolov       .bra(3)[3,3] =  0.99490020d0
!H8-rassolov       .bra(3)[4,4] = -0.10086422d0
!H8-rassolov       .bra(4)[7,7] = 0.98972107d0
!H8-rassolov       .bra(4)[8,8] = -0.14301121d0
!H6-vtz-rassolov       .ket(2)[1,1] = 0.99503479d0
!H6-vtz-rassolov       .ket(2)[2,2] = -0.09402345d0
!H6-vtz-rassolov       .ket(2)[3,3] = -0.03147794d0
!H6-vtz-rassolov       .ket(2)[4,4] = -0.00639177d0
!H6-vtz-rassolov       .ket(2)[5,5] = -0.00574110d0
!H6-vtz-rassolov       .ket(2)[6,6] = -0.00082265d0
!H6-vtz-rassolov       .ket(3)[7,7] = .99008302d0
!H6-vtz-rassolov       .ket(3)[8,8] = -.135015005d0
!H6-vtz-rassolov       .ket(3)[9,9] = -.03711262d0
!H6-vtz-rassolov       .ket(3)[10,10] = -.00949263d0
!H6-vtz-rassolov       .ket(3)[11,11] = -.00578688d0
!H6-vtz-rassolov       .ket(3)[12,12] = -0.00237005d0
!H6-vtz-rassolov       .bra(2)[1,1] = 0.99503479d0
!H6-vtz-rassolov       .bra(2)[2,2] = -0.09402345d0
!H6-vtz-rassolov       .bra(2)[3,3] = -0.03147794d0
!H6-vtz-rassolov       .bra(2)[4,4] = -0.00639177d0
!H6-vtz-rassolov       .bra(2)[5,5] = -0.00574110d0
!H6-vtz-rassolov       .bra(2)[6,6] = -0.00082265d0
!H6-vtz-rassolov       .bra(3)[7,7] = .99008302d0
!H6-vtz-rassolov       .bra(3)[8,8] = -.135015005d0
!H6-vtz-rassolov       .bra(3)[9,9] = -.03711262d0
!H6-vtz-rassolov       .bra(3)[10,10] = -.00949263d0
!H6-vtz-rassolov       .bra(3)[11,11] = -.00578688d0
!H6-vtz-rassolov       .bra(3)[12,12] = -0.00237005d0
!H6-631G-rassolov       .ket(2)[1,1] = 0.99520974d0
!H6-631G-rassolov       .ket(2)[2,2] = -0.09246186d0
!H6-631G-rassolov       .ket(2)[3,3] = -0.03126043d0
!H6-631G-rassolov       .ket(2)[4,4] = -0.00558288d0
!H6-631G-rassolov       .ket(3)[5,5] = 0.990716d0
!H6-631G-rassolov       .ket(3)[6,6] = -0.13117356d0
!H6-631G-rassolov       .ket(3)[7,7] = -0.034102345d0
!H6-631G-rassolov       .ket(3)[8,8] = -0.010598615d0
!H6-631G-rassolov       .bra(2)[1,1] = 0.99520974d0
!H6-631G-rassolov       .bra(2)[2,2] = -0.09246186d0
!H6-631G-rassolov       .bra(2)[3,3] = -0.03126043d0
!H6-631G-rassolov       .bra(2)[4,4] = -0.00558288d0
!H6-631G-rassolov       .bra(3)[5,5] = 0.990716d0
!H6-631G-rassolov       .bra(3)[6,6] = -0.13117356d0
!H6-631G-rassolov       .bra(3)[7,7] = -0.034102345d0
!H6-631G-rassolov       .bra(3)[8,8] = -0.010598615d0
!H6sto3G-rassolov       .ket(2)[1,1] = 0.99530316d0
!H6sto3G-rassolov       .ket(2)[2,2] = -0.09680716d0
!H6sto3G-rassolov       .ket(3)[3,3] = 0.98960605d0
!H6sto3G-rassolov       .ket(3)[4,4] = -0.14380498d0
!H6sto3G-rassolov       .bra(2)[1,1] = 0.99530316d0
!H6sto3G-rassolov       .bra(2)[2,2] = -0.09680716d0
!H6sto3G-rassolov       .bra(3)[3,3] = 0.98960605d0
!H6sto3G-rassolov       .bra(3)[4,4] = -0.14380498d0
!Li2-rassolov       .ket(2)[2,2] = 0.99999597d0
!Li2-rassolov       .ket(2)[3,3] = -0.00222610d0
!Li2-rassolov       .ket(2)[4,4] = -0.00124473d0
!Li2-rassolov       .ket(2)[5,5] = -0.00124473d0
!Li2-rassolov       .ket(3)[1,1] = ONE
!Li2-rassolov       .bra(2)[2,2] = 0.99999597d0
!Li2-rassolov       .bra(2)[3,3] = -0.00222610d0
!Li2-rassolov       .bra(2)[4,4] = -0.00124473d0
!Li2-rassolov       .bra(2)[5,5] = -0.00124473d0
!Li2-rassolov       .bra(3)[1,1] = ONE
!BeH2-rassolov       .ket(2)[2,2] = 0.99469201d0
!BeH2-rassolov       .ket(2)[3,3] = -0.09317530d0
!BeH2-rassolov       .ket(2)[4,4] = -0.03087208d0
!BeH2-rassolov       .ket(2)[5,5] = -0.03087208d0
!BeH2-rassolov       .ket(3)[1,1] = ONE
!BeH2-rassolov       .bra(2)[2,2] = 0.99469201d0
!BeH2-rassolov       .bra(2)[3,3] = -0.09317530d0
!BeH2-rassolov       .bra(2)[4,4] = -0.03087208d0
!BeH2-rassolov       .bra(2)[5,5] = -0.03087208d0
!BeH2-rassolov       .bra(3)[1,1] = ONE
!Be2-rassolov       .ket(2)[2,2] = ONE
!Be2-rassolov       .bra(2)[2,2] = ONE
!Be2-rassolov       .ket(3)[1,1] = ONE
!Be2-rassolov       .bra(3)[1,1] = ONE
!Be2-rassolov       .ket(4)[7,7] = 0.95666344d0
!Be2-rassolov       .ket(4)[8,8] = -0.181750915d0
!Be2-rassolov       .ket(4)[9,9] = -0.181750915d0
!Be2-rassolov       .ket(4)[10,10] = -0.13685130d0
!Be2-rassolov       .bra(4)[7,7] = 0.95666344d0
!Be2-rassolov       .bra(4)[8,8] = -0.181750915d0
!Be2-rassolov       .bra(4)[9,9] = -0.181750915d0
!Be2-rassolov       .bra(4)[10,10] = -0.13685130d0
!BH-rassolov      .ket(2)[2,2] = 0.99479034d0 
!BH-rassolov      .ket(2)[4,4] = -0.10194202d0
!BH-rassolov      .ket(3)[1,1] = 1.0d0
!BH-rassolov      .bra(2)[2,2] = 0.99479034d0
!BH-rassolov      .bra(2)[4,4] = -0.10194202d0
!BH-rassolov      .bra(3)[1,1] = 1.0d0
     elseif(.i_geminals==4) then 
       .ket(2)[1,1] = 0.99501996d0
       .ket(2)[2,2] = -0.09967584d0
       .ket(3)[3,3] = 0.99501989d0
       .ket(3)[4,4] = -0.09967658d0
       .ket(4)[5,5] = 0.994449759d0
       .ket(4)[6,6] = -0.10521260d0
       .ket(5)[9,9] = 0.98972067d0
       .ket(5)[10,10] = -0.14301397d0
       .bra(2)[1,1] = 0.99501996d0
       .bra(2)[2,2] = -0.09967584d0
       .bra(3)[3,3] = 0.99501989d0
       .bra(3)[4,4] = -0.09967658d0
       .bra(4)[5,5] = 0.994449759d0
       .bra(4)[6,6] = -0.10521260d0
       .bra(5)[9,9] = 0.98972067d0
       .bra(5)[10,10] = -0.14301397d0
!H8-rassolov       .ket(2)[1,1] = 0.99490083d0
!H8-rassolov       .ket(2)[2,2] = -0.10085802d0
!H8-rassolov       .ket(3)[3,3] =  0.99490020d0
!H8-rassolov       .ket(3)[4,4] = -0.10086422d0
!H8-rassolov       .ket(4)[5,5] = 0.98972164d0
!H8-rassolov       .ket(4)[6,6] = -0.14300724d0
!H8-rassolov       .bra(2)[1,1] = 0.99490083d0
!H8-rassolov       .bra(2)[2,2] = -0.10085802d0
!H8-rassolov       .bra(3)[3,3] =  0.99490020d0
!H8-rassolov       .bra(3)[4,4] = -0.10086422d0
!H8-rassolov       .bra(4)[5,5] = 0.98972164d0
!H8-rassolov       .bra(4)[6,6] = -0.14300724d0
!Be2-rassolov       .ket(2)[2,2] = ONE
!Be2-rassolov       .bra(2)[2,2] = ONE
!Be2-rassolov       .ket(3)[3,3] = 0.95953727d0
!Be2-rassolov       .ket(3)[4,4] = -0.183733265d0
!Be2-rassolov       .ket(3)[5,5] = -0.183733265d0
!Be2-rassolov       .ket(3)[6,6] = -0.10850071d0
!Be2-rassolov       .bra(3)[3,3] = 0.95953727d0
!Be2-rassolov       .bra(3)[4,4] = -0.183733265d0
!Be2-rassolov       .bra(3)[5,5] = -0.183733265d0
!Be2-rassolov       .bra(3)[6,6] = -0.10850071d0
!Be2-rassolov       .ket(4)[1,1] = ONE
!Be2-rassolov       .bra(4)[1,1] = ONE
     elseif(.i_geminals==5) then 
       .ket(2)[1,1] = 0.99501996d0
       .ket(2)[2,2] = -0.09967584d0
       .ket(3)[3,3] = 0.99501989d0
       .ket(3)[4,4] = -0.09967658d0
       .ket(4)[5,5] = 0.994449759d0
       .ket(4)[6,6] = -0.10521260d0
       .ket(5)[7,7] = 0.98972076d0
       .ket(5)[8,8] = -0.14301336d0
       .bra(2)[1,1] = 0.99501996d0
       .bra(2)[2,2] = -0.09967584d0
       .bra(3)[3,3] = 0.99501989d0
       .bra(3)[4,4] = -0.09967658d0
       .bra(4)[5,5] = 0.994449759d0
       .bra(4)[6,6] = -0.10521260d0
       .bra(5)[7,7] = 0.98972076d0
       .bra(5)[8,8] = -0.14301336d0
     else
       stdout.text("wrong value for i_geminals")
       stop
     end
!carmella1212antisym
!carmella1212antisym      .ket(counter)[1,2] =  0.99560d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[1,3] = -0.00206d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[1,4] = -0.00156d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[1,5] = -0.00007d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[2,3] = -0.09366d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[2,4] =  0.00010d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[2,5] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[3,4] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[3,5] =  0.00002d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[4,5] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[2,1] =  0.99560d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[3,1] = -0.00206d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[4,1] = -0.00156d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[5,1] = -0.00007d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[3,2] = -0.09366d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[4,2] =  0.00010d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[5,2] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[4,3] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[5,3] =  0.00002d0   /sqrt(TWO)     
!carmella1212antisym      .ket(counter)[5,4] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[1,2] =  0.99560d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[1,3] = -0.00206d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[1,4] = -0.00156d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[1,5] = -0.00007d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[2,3] = -0.09366d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[2,4] =  0.00010d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[2,5] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[3,4] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[3,5] =  0.00002d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[4,5] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[2,1] =  0.99560d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[3,1] = -0.00206d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[4,1] = -0.00156d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[5,1] = -0.00007d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[3,2] = -0.09366d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[4,2] =  0.00010d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[5,2] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[4,3] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[5,3] =  0.00002d0   /sqrt(TWO)     
!carmella1212antisym      .bra(counter)[5,4] =  0.00000d0   /sqrt(TWO)     
!carmella1212antisym     end
!carmella1212antisym     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
     do j = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
     end
     if (.i_geminals==1) then
       .contraction_wfs(1)[1,1] = 0.99501996d0
       .contraction_wfs(1)[2,2] = -0.09967584d0
!H8-rassolov       .contraction_wfs(1)[1,1] = 0.99490083d0
!H8-rassolov       .contraction_wfs(1)[2,2] = -0.10085802d0
!H6-vtz-rassolov       .contraction_wfs(1)[1,1] = 0.99503479d0
!H6-vtz-rassolov       .contraction_wfs(1)[2,2] = -0.09402345d0
!H6-vtz-rassolov       .contraction_wfs(1)[3,3] = -0.03147794d0
!H6-vtz-rassolov       .contraction_wfs(1)[4,4] = -0.00639177d0
!H6-vtz-rassolov       .contraction_wfs(1)[5,5] = -0.00574110d0
!H6-vtz-rassolov       .contraction_wfs(1)[6,6] = -0.00082265d0
!H6-631G-rassolov       .contraction_wfs(1)[1,1] = 0.99520974d0
!H6-631G-rassolov       .contraction_wfs(1)[2,2] = -0.09246186d0
!H6-631G-rassolov       .contraction_wfs(1)[3,3] = -0.03126043d0
!H6-631G-rassolov       .contraction_wfs(1)[4,4] = -0.00558288d0
!H6sto3G-rassolov       .contraction_wfs(1)[1,1] = 0.99530316d0
!H6sto3G-rassolov       .contraction_wfs(1)[2,2] = -0.09680716d0
!Li2-rassolov       .contraction_wfs(1)[1,1] = ONE 
!BeH2-rassolov       .contraction_wfs(1)[1,1] = ONE 
!LiH-rassolov       .contraction_wfs(1)[1,1] = 0.99999557d0
!LiH-rassolov       .contraction_wfs(1)[2,2] = -0.00297797d0
!Be2-rassolov     .contraction_wfs(1)[1,1] = ONE 
!Be-rassolov     .contraction_wfs(1)[1,1] = ONE 
!BH-rassolov     .contraction_wfs(1)[1,1] = ONE 
     elseif(.i_geminals==2) then 
       .contraction_wfs(1)[3,3] = 0.99501989d0
       .contraction_wfs(1)[4,4] = -0.09967658d0
!H8-rassolov       .contraction_wfs(1)[3,3] =  0.99490020d0
!H8-rassolov       .contraction_wfs(1)[4,4] = -0.10086422d0
!H6-vtz-rassolov       .contraction_wfs(1)[7,7] = .99008302d0
!H6-vtz-rassolov       .contraction_wfs(1)[8,8] = -.135015005d0
!H6-vtz-rassolov       .contraction_wfs(1)[9,9] = -.03711262d0
!H6-vtz-rassolov       .contraction_wfs(1)[10,10] = -.00949263d0
!H6-vtz-rassolov       .contraction_wfs(1)[11,11] = -.00578688d0
!H6-vtz-rassolov       .contraction_wfs(1)[12,12] = -0.00237005d0
!H6-631G-rassolov       .contraction_wfs(1)[5,5] = 0.990716d0
!H6-631G-rassolov       .contraction_wfs(1)[6,6] = -0.13117356d0
!H6-631G-rassolov       .contraction_wfs(1)[7,7] = -0.034102345d0
!H6-631G-rassolov       .contraction_wfs(1)[8,8] = -0.010598615d0
!H6sto3G-rassolov       .contraction_wfs(1)[3,3] = 0.98960605d0
!H6sto3G-rassolov       .contraction_wfs(1)[4,4] = -0.14380498d0
!Li2-rassolov       .contraction_wfs(1)[2,2] = 0.99999597d0
!Li2-rassolov       .contraction_wfs(1)[3,3] = -0.00222610d0
!Li2-rassolov       .contraction_wfs(1)[4,4] = -0.00124473d0
!Li2-rassolov       .contraction_wfs(1)[5,5] = -0.00124473d0
!BeH2-rassolov       .contraction_wfs(1)[2,2] = 0.99469201d0
!BeH2-rassolov       .contraction_wfs(1)[3,3] = -0.09317530d0
!BeH2-rassolov       .contraction_wfs(1)[4,4] = -0.03087208d0
!BeH2-rassolov       .contraction_wfs(1)[5,5] = -0.03087208d0
!LiH-rassolov       .contraction_wfs(1)[3,3] = 0.98863491d0
!LiH-rassolov       .contraction_wfs(1)[4,4] = -0.14519098d0
!LiH-rassolov       .contraction_wfs(1)[5,5] = -0.02757341d0
!LiH-rassolov       .contraction_wfs(1)[6,6] = -0.02757341d0
!Be-rassolov     .contraction_wfs(1)[2,2] = 0.94638259d0
!Be-rassolov     .contraction_wfs(1)[3,3] = -0.18651183d0
!Be-rassolov     .contraction_wfs(1)[4,4] = -0.18651183d0
!Be-rassolov     .contraction_wfs(1)[5,5] = -0.18651183d0
!BH-rassolov     .contraction_wfs(1)[2,2] = 0.99479034d0 
!BH-rassolov     .contraction_wfs(1)[4,4] = -0.10194202d0
     elseif(.i_geminals==3) then 
       .contraction_wfs(1)[5,5] = 0.994449759d0
       .contraction_wfs(1)[6,6] = -0.10521260d0
!H8-rassolov       .contraction_wfs(1)[5,5] = 0.98972164d0
!H8-rassolov       .contraction_wfs(1)[6,6] = -0.14300724d0
!H6-vtz-rassolov       .contraction_wfs(1)[13,13] = .99008302d0
!H6-vtz-rassolov       .contraction_wfs(1)[14,14] = -.135015005d0
!H6-vtz-rassolov       .contraction_wfs(1)[15,15] = -.03711262d0
!H6-vtz-rassolov       .contraction_wfs(1)[16,16] = -.00949263d0
!H6-vtz-rassolov       .contraction_wfs(1)[17,17] = -.00578688d0
!H6-vtz-rassolov       .contraction_wfs(1)[18,18] = -0.00237005d0
!H6-631G-rassolov       .contraction_wfs(1)[9,9] = 0.990716d0
!H6-631G-rassolov       .contraction_wfs(1)[10,10] = -0.13117356d0
!H6-631G-rassolov       .contraction_wfs(1)[11,11] = -0.034102345d0
!H6-631G-rassolov       .contraction_wfs(1)[12,12] = -0.010598615d0
!H6sto3G-rassolov       .contraction_wfs(1)[5,5] = 0.98960605d0
!H6sto3G-rassolov       .contraction_wfs(1)[6,6] = -0.14380498d0
!Li2-rassolov       .contraction_wfs(1)[6,6] = 0.95501290d0
!Li2-rassolov       .contraction_wfs(1)[7,7] = -0.16187685d0
!Li2-rassolov       .contraction_wfs(1)[8,8] = -0.16102061d0
!Li2-rassolov       .contraction_wfs(1)[9,9] = -0.16102061d0
!Li2-rassolov       .contraction_wfs(1)[10,10] = -0.09945338d0
!BeH2-rassolov       .contraction_wfs(1)[6,6] = 0.99531238d0
!BeH2-rassolov       .contraction_wfs(1)[7,7] = -0.09671227d0
!Be2-rassolov       .contraction_wfs(1)[3,3] = 0.95953727d0
!Be2-rassolov       .contraction_wfs(1)[4,4] = -0.183733265d0
!Be2-rassolov       .contraction_wfs(1)[5,5] = -0.183733265d0
!Be2-rassolov       .contraction_wfs(1)[6,6] = -0.10850071d0
!BH-rassolov     .contraction_wfs(1)[3,3] = -0.96537469d0
!BH-rassolov     .contraction_wfs(1)[5,5] = 0.18446099d0
!BH-rassolov     .contraction_wfs(1)[6,6] = 0.18446099d0
     elseif(.i_geminals==4) then 
       .contraction_wfs(1)[7,7] = 0.98972076d0
       .contraction_wfs(1)[8,8] = -0.14301336d0
!H8-rassolov       .contraction_wfs(1)[7,7] = 0.98972107d0
!H8-rassolov       .contraction_wfs(1)[8,8] = -0.14301121d0
!Be2-rassolov       .contraction_wfs(1)[7,7] = 0.95666344d0
!Be2-rassolov       .contraction_wfs(1)[8,8] = -0.181750915d0
!Be2-rassolov       .contraction_wfs(1)[9,9] = -0.181750915d0
!Be2-rassolov       .contraction_wfs(1)[10,10] = -0.13685130d0
     elseif(.i_geminals==5) then 
       .contraction_wfs(1)[9,9] = 0.98972067d0
       .contraction_wfs(1)[10,10] = -0.14301397d0
     else
       stdout.text("wrong value for i_geminals")
       stop
     end
     counter=1
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = j-1,1,-1
       if ( 1<=k AND k <= n_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     k = i_geminals
     do j = n_geminals+1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     do j =1, n_geminals
       if ( j==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = n_geminals+1, n_bf
     do k = n_geminals,1,-1
       if ( k==i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     do j = 1,n_geminals
     do k = j-1,1,-1
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     DIE_IF(counter/=.n_bas,"counter not equal to .n_bas")
!carmella1212antisym      .contraction_wfs(1)[1,2] =  0.99560d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[1,3] = -0.00206d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[1,4] = -0.00156d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[1,5] = -0.00007d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[2,3] = -0.09366d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[2,4] =  0.00010d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[2,5] =  0.00000d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[3,4] =  0.00000d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[3,5] =  0.00002d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[4,5] =  0.00000d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[2,1] =  0.99560d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[3,1] = -0.00206d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[4,1] = -0.00156d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[5,1] = -0.00007d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[3,2] = -0.09366d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[4,2] =  0.00010d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[5,2] =  0.00000d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[4,3] =  0.00000d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[5,3] =  0.00002d0  /sqrt(TWO)     
!carmella1212antisym      .contraction_wfs(1)[5,4] =  0.00000d0  /sqrt(TWO)     
   end

   set_singlet_wfs ::: leaky
   ! Create a default object with singlet geminals only. 
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf,n_bas :: INT
     j,k,counter :: INT

     n_geminals = .n_geminals
     n_bf = .n_bf
     n_bas=n_bf*(n_bf+1)/2
     .n_bas=n_bas
     .n_dependent = 0
      if (.contraction_wfs.created) then
        .contraction_wfs.destroy
      end
      if (.contraction_energies.created) .contraction_energies.destroy
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
       .contraction_energies(j)= ZERO
     end
     counter=0
     do j = 1, n_bf
       counter=counter+1
       .contraction_wfs(counter)[j,j] = ONE
     end
     do j = 1, n_bf
     do k = 1,j-1
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE
       .contraction_wfs(counter)[k,j] = ONE
       !.contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       !.contraction_wfs(counter)[k,j] = ONE/sqrt(TWO)
     end
     end
     DIE_IF(counter/=n_bas,"counter not equal to n_bas") 
   end

   set_triplet_defaults ::: leaky
   ! Create triplet default wfs and ground state spectator wave functions.
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf :: INT
     counter,j,k :: INT

     n_geminals = .n_geminals
     i_geminals = .i_geminals
     n_bf = .n_bf
     .n_bas = (n_bf-n_geminals+1)*(n_bf-n_geminals)/2 ! avoid the ground state orbitals
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,n_geminals     ! create ground state bras and kets
        .bra(j).element.create(n_bf,n_bf)
        .ket(j).element.create(n_bf,n_bf)
        .special_ket(j).element.create(2)
        .ket(j).element = ZERO
        .bra(j).element = ZERO
        .special_ket(j).element = 0
     end
     counter=1
     do j = 1,n_geminals     ! set ground state bras and kets
       if(j==i_geminals)cycle
       counter=counter+1
       .special_ket(counter).element = j
       .bra(counter)[j,j] = ONE
!       .ket(counter)[j,j] = ONE !debug
     end
     DIE_IF(NOT counter==n_geminals,"counter not equal to n_geminals")
     do j = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
       .contraction_energies(j)= ZERO
     end
     counter=0
     do j = n_geminals+1, n_bf
     do k = 1, j-1
       if ( 1<=k AND k <= n_geminals AND k/=i_geminals ) cycle 
       counter=counter+1
       .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
       .contraction_wfs(counter)[k,j] = -ONE/sqrt(TWO)
     end
     end
     DIE_IF(counter/=.n_bas,"counter not equal to .n_bas") 
!debug      write(*,*) ".n_bas",.n_bas
!debug      stdout.text(".contraction_wfs(1)[:,:]")
!debug      stdout.put(.contraction_wfs(1)[:,:])
!debug      stdout.text(".contraction_wfs(2)[:,:]")
!debug      stdout.put(.contraction_wfs(2)[:,:])
!debug      stdout.text(std_time.elapsed_time_message("geminal job "))
!debug      stdout.text(std_time.elapsed_cpu_time_message("geminal job "))
!debug      ! Rotate
!debug      do i = 1,n_geminals
!debug        .special_ket(i).element = 0
!debug      end
!debug      U.create(.n_geminals,.n_geminals)
!debug      T.create(.n_geminals,.n_geminals)
!debug      S.create(n_bf,n_bf)
!debug      R.create(n_bf,n_bf)
!debug      eigenvalues.create(n_bf)
!debug      do i = 1,n_geminals
!debug      do j = 1,i
!debug         call random_number(val)
!debug         T(i,j) = val
!debug         T(j,i) = val
!debug      end
!debug      end
!debug      T.solve_eigenproblem(eigenvalues,U)
!debug      R=ZERO
!debug      do i = 1,n_geminals
!debug      do j = 1,i
!debug         R(i,j) = U(i,j)
!debug         R(j,i) = U(j,i)
!debug      end
!debug      end
!debug      do i = n_geminals+1, n_bf
!debug         R(i,i) = ONE
!debug      end
!debug      U.destroy
!debug      T.destroy
!debug    !  stdout.text("R")
!debug    !  stdout.put(R)
!debug      S=matmul(R,transpose(R))
!debug      stdout.show("is unit matrix =",S.is_unit_matrix)
!debug      V.create(n_bf)
!debug      do i = 1,.n_bas
!debug        do j=1,n_bf
!debug        V=.contraction_wfs(i)[j,:]
!debug        .contraction_wfs(i)[j,:].to_product_of(R,V)
!debug        end
!debug        do k=1,n_bf
!debug        V=.contraction_wfs(i)[:,k]
!debug        .contraction_wfs(i)[:,k].to_product_of(R,V)
!debug        end
!debug!        val = ZERO
!debug!        do j=1,n_bf
!debug!        do k=1,n_bf
!debug!          val=val+ .contraction_wfs(i)[j,k]*.contraction_wfs(i)[j,k]
!debug!        end
!debug!        end
!debug!        write(*,*) "i",i,val
!debug      end
!debug      do i = .n_bas+1,.n_bas+n_geminals-1
!debug        do j=1,n_bf
!debug         V=.ket(i-.n_bas+1)[j,:]
!debug        .ket(i-.n_bas+1)[j,:].to_product_of(R,V)
!debug         V=.bra(i-.n_bas+1)[j,:]
!debug        .bra(i-.n_bas+1)[j,:].to_product_of(R,V)
!debug        end
!debug        do k=1,n_bf
!debug        V=.ket(i-.n_bas+1)[:,k]
!debug        .ket(i-.n_bas+1)[:,k].to_product_of(R,V)
!debug        V=.bra(i-.n_bas+1)[:,k]
!debug        .bra(i-.n_bas+1)[:,k].to_product_of(R,V)
!debug        end
!debug!        val = ZERO
!debug!        do j=1,n_bf
!debug!        do k=1,n_bf
!debug!          val=val+ .bra(i-.n_bas+1)[j,k]*.bra(i-.n_bas+1)[j,k]
!debug!        end
!debug!        end
!debug!        write(*,*) "i",i,val
!debug      end
!debug!      R.destroy
!debug!      R.create(.n_bas,.n_bas)
!debug!      S.destroy
!debug!      S.create(.n_bas,.n_bas)
!debug!      T.destroy
!debug!      T.create(.n_bas,.n_bas)
!debug!      U.destroy
!debug!      U.create(.n_bas,.n_bas)
!debug!      R=matmul(transpose(.bra(2)[:,:]),.bra(2)[:,:])
!debug!      S=matmul(.bra(2)[:,:],transpose(.bra(2)[:,:]))
!debug!      do i = 1,.n_bas
!debug!      T=matmul(.contraction_wfs(i)[:,:],R)+matmul(S,.contraction_wfs(i)[:,:])
!debug!        write(*,*) "T(1,1)",T(1,1)
!debug!        write(*,*) "T(2,1)",T(2,1)
!debug!        write(*,*) "T(1,2)",T(1,2)
!debug!        write(*,*) "T(2,2)",T(2,2)
!debug!      !    S=matmul(transpose(.contraction_wfs(i)[:,:]),.contraction_wfs(i)[:,:])
!debug!      U=matmul(transpose(.contraction_wfs(i)[:,:]),T)
!debug!          val=U.trace
!debug!        write(*,*) "i,trace",i,val
!debug!      end
!debug!!      V.create(n_bfsq)
!debug!!      do i = 1,.n_bas
!debug!!        V.to_product_of(R,reshape(.contraction_wfs(i).element,[n_bfsq]))
!debug!!        .contraction_wfs(i).element = reshape(V,[n_bf,n_bf])
!debug!!        val = ZERO
!debug!!        do j=1,n_bf
!debug!!        do k=1,n_bf
!debug!!          val=val+ .contraction_wfs(i)[j,k]*.contraction_wfs(i)[j,k]
!debug!!        end
!debug!!        end
!debug!!        write(*,*) "i",i,val
!debug!!      end
!debug!!      do i = .n_bas+1,n_bfsq
!debug!!        V.to_product_of(R,reshape(.ket(i-.n_bas+1).element,[n_bfsq]))
!debug!!        .ket(i-.n_bas+1).element = reshape(V,[n_bf,n_bf])
!debug!!        V.to_product_of(R,reshape(.bra(i-.n_bas+1).element,[n_bfsq]))
!debug!!        .bra(i-.n_bas+1).element = reshape(V,[n_bf,n_bf])
!debug!!        val = ZERO
!debug!!        do j=1,n_bf
!debug!!        do k=1,n_bf
!debug!!          val=val+ .bra(i-.n_bas+1)[j,k]*.bra(i-.n_bas+1)[j,k]
!debug!!        end
!debug!!        end
!debug!!        write(*,*) "i",i,val
!debug!!      end
!debug!!      .n_bas = ONE    
!debug!      V.destroy
!debug!     .special_ket(5)[1] = 5
!debug!     .special_ket(5)[2] = 6
!debug!     .bra(5).element = ZERO
!debug!     .bra(5)[5,6] = ONE
!debug      eigenvalues.destroy
!debug      R.destroy
!debug      S.destroy
!debug      T.destroy
!debug      U.destroy
!debug      stdout.text(std_time.elapsed_time_message("geminal job "))
!debug      stdout.text(std_time.elapsed_cpu_time_message("geminal job "))
   end

   set_triplet_wfs ::: leaky
   ! Create triplet default wfs but not ground state spectator wave functions.
     ENSURE(.n_geminals<.n_bf,"n_geminals not less than n_bf")
     i_geminals :: INT
     n_geminals,n_bf :: INT
     counter,j,k :: INT

     n_geminals = .n_geminals
     i_geminals = .i_geminals
     n_bf = .n_bf
     .n_bas = (n_bf-1)*n_bf/2 
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do j = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(j).element.create(n_bf,n_bf)
       .contraction_wfs(j).element = ZERO
       .contraction_energies(j)= ZERO
     end
     counter=0
     do j = 1, n_bf-1
       do k = j+1,n_bf
         counter=counter+1
         .contraction_wfs(counter)[j,k] = ONE/sqrt(TWO)
         .contraction_wfs(counter)[k,j] = -ONE/sqrt(TWO)
       end
     end
     DIE_IF(counter/=.n_bas,"counter not equal to .n_bas") 
   end

   set_to_zero_special_ket
   ! set to zero special_ket
     j :: INT
     do j = 1,.n_geminals    
       .special_ket(j).element = 0
     end
   end

   set_to_zero_ket
   ! set to zero ket
     j :: INT
     do j = 1,.n_geminals    
       .ket(j).element = ZERO
     end
   end

   set_to_zero_bra
   ! set to zero bra
     j :: INT
     do j = 1,.n_geminals    
       .bra(j).element = ZERO
     end
   end

   set_to_zero_contraction_wfs
   ! set to zero contraction_wfs
     j :: INT
     do j = 1,.n_geminals    
       .contraction_wfs(j).element = ZERO
     end
   end

   set_to_zero_energies
   ! set to zero contraction_energies
     .contraction_energies = ZERO
   end

!  ***************
!  INPUT Routines
!  ***************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
       case ("do_overlap              "); .do_overlap
       case ("do_hamiltonian          "); .do_hamiltonian
       case ("junk=                   "); .read_junk
       case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       case ("units=                  "); .read_units
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT)
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT)
   ! Read in a junk string, useful for ignoring a field
   end

   read_n_bf ::: leaky
   ! Read in a new value of ".n_bf", which must be smaller than the initial
   ! basis set size. Truncate the coefficient matrices.
   ENSURE(.bra.created,"no bra")
   ENSURE(.bra(1).element.created,"no bra elements")
   ENSURE(.ket.created,"no ket")
   ENSURE(.ket(1).element.created,"no ket elements")
      n_bf,i :: INT
      stdin.read(n_bf)
      ENSURE(n_bf<=.n_bf,"new size is not smaller")
      .n_bf = n_bf
      do i = 1,.n_geminals
         .bra(i).element.shrink(.n_bf,.n_bf)
         .ket(i).element.shrink(.n_bf,.n_bf)
      end
   end

   get_wfs ::: leaky
   ! get wave functions from an archive file
     wfs_archive :: ARCHIVE
     name :: STR
     j :: INT
     
     name="wfs_"//.i_geminals.to_str.trim
     wfs_archive.set(.name,name)
     .get_max_bas
     if(.contraction_energies.created) then
       .contraction_energies.destroy
       .contraction_wfs.destroy
     end
     .contraction_energies.create(.n_bas)
     .set_to_zero_energies
     .contraction_wfs.create(.n_bas)
     do j=1,.n_bas
       .contraction_wfs(j).element.create(.n_bf,.n_bf)
     end
     wfs_archive.read(.contraction_wfs)
   end

   get_ground_state
   ! get ground state wave function from an archive file
     ground_state_archive :: ARCHIVE
     name :: STR
     
     name="ground_state_"//.i_geminals.to_str.trim
     ground_state_archive.set(.name,name)
     ground_state_archive.read(.bra(.i_geminals).element)
     .ket(.i_geminals).element=.bra(.i_geminals).element
   end

   get_max_bas
   ! get number of basis functions from an archive file
     max_bas_archive :: ARCHIVE
     name :: STR
     
     name="max_bas_"//.i_geminals.to_str.trim
     max_bas_archive.set(.name,name)
     max_bas_archive.read(.n_bas)
   end

!  ***************
!  other Routines
!  ***************

   gs_permutation
   ! permute ground state wave functions of contractions 1 and i_geminals 
     ENSURE(.bra(.i_geminals).element.created,".bra(.i_geminals) not created")
     ENSURE(.bra(1).element.created,".bra(1) not created")
     ENSURE(.ket(1).element.created,".ket(1) not created")
     temp :: MAT{REAL}*
     
     temp=>.bra(.i_geminals).element
     .ket(.i_geminals).element=>.ket(1).element
     .bra(.i_geminals).element=>.bra(1).element
     .ket(1).element=>temp
     .bra(1).element=>temp
     nullify(temp)
   end

!  ********************
!  Key related routines
!  ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")
     word :: STR
     width,k :: INT
     width = .table_width
     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case default; DIE("unknown option")
         end
         if (k==size(keys)) then
           stdout.text(" ") ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
     res :: INT
   ENSURE(keys.created,"no keys")
     int_dash,real_dash,k :: INT
     word :: STR
     int_dash = 0
     real_dash = 0
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}                "); ! exit surrounding loop
         case ("put_configuration"); real_dash = real_dash + 1
         case ("put_label        "); int_dash = int_dash + 1
         case ("put_n_shells     "); int_dash = int_dash + 1
         case ("put_n_bf         "); int_dash = int_dash + 1
         case ("put_n_prim       "); int_dash = int_dash + 1
         case ("flush            "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  ***************
!  Inquiry methods
!  ***************

   same_as(b) result(res) 
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      self :: IN
      b :: GEMINAL_MF_SPECTRUM, IN
      res :: BIN
      res = FALSE
   end

!  **************
!  Output methods
!  **************

   put
   ! Print out the object
      i,j,k :: INT
      stdout.text("GEMINAL_MF_SPECTRUM:")
      stdout.text(" ")
      stdout.show("i_geminals =",.i_geminals)
!      stdout.show("n_bf       =",.n_bf)
      stdout.show("n_bas       =",.n_bas)
      stdout.text(" ")
      stdout.text("Bra:")
      do i = 2,.n_geminals
         stdout.text("Bra "//i.to_str.trim//" non zero elements")
!         stdout.put(.bra(i).element)
! could use a while loop
        do j=1,.n_bf
        do k=1,.n_bf
          if (NOT .bra(i)[j,k].is_zero) then
            write(6,*)"j,k,element:",j,k,.bra(i)[j,k]
            !stdout.show("j,k,element:",[j,k,.bra(i)[j,k]])
          end
        end
        end
      end
      stdout.text("Ket:")
      do i = 2,.n_geminals
         stdout.text("Special ket "//i.to_str.trim)
         stdout.put(.special_ket(i).element)
         stdout.text("Ket "//i.to_str.trim//" non zero elements")
!         stdout.put(.ket(i).element)
        do j=1,.n_bf
        do k=1,.n_bf
          if (NOT .ket(i)[j,k].is_zero) then
            write(6,*)"j,k,element:",j,k,.ket(i)[j,k]
            !stdout.show("j,k,element:",[j,k,.ket(i)[j,k]])
          end
        end
        end
      end
      stdout.text("Contraction 1:")
      do i = 1,.n_bas
        stdout.text("Wave function "//i.to_str.trim//" non zero elements")
        do j=1,.n_bf
        do k=1,.n_bf
          if (NOT .contraction_wfs(i)[j,k].is_zero) then
            write(6,*)"j,k,element:",j,k,.contraction_wfs(i)[j,k]
            !stdout.show("j,k,element:",[j,k,.contraction_wfs(i)[j,k]])
          end
        end
        end
      end
   end

   put_ground_state_geminals
   ! Print out the object
      i,j,k :: INT
      stdout.text("ground state geminals:")
      stdout.text(" ")
      stdout.show("i_geminals =",.i_geminals)
      stdout.text(" ")
      stdout.text("Spectators:")
      do i = 2,.n_geminals
         stdout.text("Spectator"//i.to_str.trim//" non zero elements")
! could use a while loop
        do j=1,.n_bf
        do k=1,.n_bf
          if (NOT .bra(i)[j,k].is_zero) then
            write(6,*)"j,k,element:",j,k,.bra(i)[j,k]
            !stdout.show("j,k,element:",[j,k,.bra(i)[j,k]])
          end
        end
        end
      end
      stdout.text("Active:")
      do j=1,.n_bf
      do k=1,.n_bf
        if (NOT .contraction_wfs(1)[j,k].is_zero) then
          write(6,*)"j,k,element:",j,k,.contraction_wfs(1)[j,k]
        end
      end
      end
      stdout.text(" ")
   end

   put_wfs
   ! save wave functions in an archive file
     wfs_archive :: ARCHIVE
     name :: STR
     
     name="wfs_"//.i_geminals.to_str.trim
     wfs_archive.set(.name,name)
     .put_max_bas
     wfs_archive.write(.contraction_wfs(1:.n_bas))
   end

   put_ground_state
   ! save ground state wave function in an archive file
     ground_state_archive :: ARCHIVE
     name :: STR
     
     name="ground_state_"//.i_geminals.to_str.trim
     ground_state_archive.set(.name,name)
     ground_state_archive.write(.contraction_wfs(1).element)
   end

   put_max_bas
   ! save number of basis functions in an archive file
     max_bas_archive :: ARCHIVE
     name :: STR
     
     name="max_bas_"//.i_geminals.to_str.trim
     max_bas_archive.set(.name,name)
     max_bas_archive.write(.n_bas)
   end

!  ***************
!  Integral methods
!  ***************

!todolater   do_2rdm(ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l)
!todolater   ! Evaluate the 2 electron density matrix element in a geminal induced basis set
!todolater   ! built over orthonormal orbitals
!todolater     ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l :: INT
!todolater     res :: MAT{REAL}(.n_bas,.n_bas)
!todolater   !debug   write(*,*) ".n_bas",.n_bas,".n_bf",.n_bf
!todolater      res = .two_rdm(ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l)
!todolater      stdout.text("The 2 electron density matrix element is ")
!todolater      stdout.put(res)
!todolater   end
! seems difficult to store all the 2RDM matrix elements 
! for the .n_bas*.n_bas pairs of functions of contraction 1

  
   hamiltonian result (res)
   ! Evaluate the hamiltonian matrix for a given geminal contraction
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     reorder_ket :: VEC{INT}*
     i,j :: INT

     eri_archive.set(.name,"h_integrals")
     v.create(.n_bf,.n_bf,.n_bf,.n_bf)
     eri_archive.read(v)
     reorder_ket.create(.n_geminals)
     reorder_ket = [ (i, i=1,.n_geminals) ]
     res=ZERO
     res = .hamiltonian_for(v,reorder_ket) 
     do i=1,.n_bas
     do j=1,i-1
     res(i,j) = res(j,i)
     end
 !    res(i,i) = res(i,i) + .nuclear_energy
     end
     reorder_ket.destroy
     v.destroy
   end

   hamiltonian(i) result (res)
   ! Evaluate the hamiltonian matrix for a given geminal contraction
     i :: INT
     res :: VEC{REAL}(.n_bas)
     ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     reorder_ket :: VEC{INT}*

     eri_archive.set(.name,"h_integrals")
     v.create(.n_bf,.n_bf,.n_bf,.n_bf)
     eri_archive.read(v)
     reorder_ket.create(.n_geminals)
     reorder_ket = [ (i, i=1,.n_geminals) ]
   !  res.create(.n_bas)
     res=ZERO
     res = .hamiltonian_for(v,reorder_ket,i)
  !   if(i==j) res = res +.nuclear_energy
     reorder_ket.destroy
     v.destroy
   end

   hamiltonian(i,j) result (res)
   ! Evaluate the hamiltonian matrix for a given geminal contraction
     i,j :: INT
     res :: REAL
     ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     reorder_ket :: VEC{INT}*

     eri_archive.set(.name,"h_integrals")
     v.create(.n_bf,.n_bf,.n_bf,.n_bf)
     eri_archive.read(v)
     reorder_ket.create(.n_geminals)
     reorder_ket = [ (i, i=1,.n_geminals) ]
     res=ZERO
     res = .hamiltonian_for(v,reorder_ket,j,i)
  !   if(i==j) res = res +.nuclear_energy
     reorder_ket.destroy
     v.destroy
   end

   hamiltonian_matrix_gio(res)
   ! Evaluate the hamiltonian matrix for giovanni
     res :: MAT{REAL}(2,2)
     ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
     i,j :: INT
     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     reorder_ket :: VEC{INT}*

     eri_archive.set(.name,"h_integrals")
     v.create(.n_bf,.n_bf,.n_bf,.n_bf)
     eri_archive.read(v)
     reorder_ket.create(.n_geminals)
     reorder_ket = [ (i, i=1,.n_geminals) ]
     .n_bas=1
     res=ZERO
     .set_to_zero_contraction_wfs
     .set_to_zero_special_ket
     .set_to_zero_ket
     .set_to_zero_bra
     .contraction_wfs(1)[3,7] = ONE/sqrt(TWO)
     .contraction_wfs(1)[7,3] = ONE/sqrt(TWO)
     .special_ket(2)[1] = 1
     .special_ket(2)[2] = 1
     .special_ket(3)[1] = 2
     .special_ket(3)[2] = 2
     .bra(2)[1,1] = ONE
     .bra(3)[2,2] = ONE
     res(1,1) = .hamiltonian_for(v,reorder_ket,1,1)
     .set_to_zero_contraction_wfs
     .set_to_zero_special_ket
     .set_to_zero_ket
     .set_to_zero_bra
     .contraction_wfs(1)[1,7] = ONE/sqrt(TWO)
     .contraction_wfs(1)[7,1] = ONE/sqrt(TWO)
     .special_ket(2)[1] = 3
     .special_ket(2)[2] = 3
     .special_ket(3)[1] = 2
     .special_ket(3)[2] = 2
     .bra(2)[3,3] = ONE
     .bra(3)[2,2] = ONE
     res(2,2) = .hamiltonian_for(v,reorder_ket,1,1)
     .n_bas=2
     .set_to_zero_contraction_wfs
     .set_to_zero_special_ket
     .set_to_zero_ket
     .set_to_zero_bra
     .contraction_wfs(1)[3,1] = -ONE
     .contraction_wfs(2)[3,3] = ONE
     .special_ket(2)[1] = 1
     .special_ket(2)[2] = 7
     .special_ket(3)[1] = 2
     .special_ket(3)[2] = 2
     .bra(2)[1,7] = ONE
     .bra(3)[2,2] = ONE
     res(1,2) = .hamiltonian_for(v,reorder_ket,1,2)
     stdout.show("res(1,2)",res(1,2))
     .set_to_zero_contraction_wfs
     .set_to_zero_special_ket
     .set_to_zero_ket
     .set_to_zero_bra
     .contraction_wfs(1)[1,7] = -ONE
     .contraction_wfs(2)[7,3] = -ONE
     .special_ket(2)[1] = 3
     .special_ket(2)[2] = 1
     .special_ket(3)[1] = 2
     .special_ket(3)[2] = 2
     .bra(2)[3,1] = ONE
     .bra(3)[2,2] = ONE
     res(1,2) = res(1,2)+.hamiltonian_for(v,reorder_ket,1,2)
     .set_to_zero_contraction_wfs
     .set_to_zero_special_ket
     .set_to_zero_ket
     .set_to_zero_bra
     .contraction_wfs(1)[7,1] = -ONE
     .contraction_wfs(2)[3,7] = -ONE
     .special_ket(2)[1] = 1
     .special_ket(2)[2] = 3
     .special_ket(3)[1] = 2
     .special_ket(3)[2] = 2
     .bra(2)[1,3] = ONE
     .bra(3)[2,2] = ONE
     res(2,1) = .hamiltonian_for(v,reorder_ket,1,2)
     stdout.show("res(2,1)",res(2,1))
     .set_to_zero_contraction_wfs
     .set_to_zero_special_ket
     .set_to_zero_ket
     .set_to_zero_bra
     .contraction_wfs(1)[1,3] = ONE
     .contraction_wfs(2)[3,3] = -ONE
     .special_ket(2)[1] = 7
     .special_ket(2)[2] = 1
     .special_ket(3)[1] = 2
     .special_ket(3)[2] = 2
     .bra(2)[7,1] = ONE
     .bra(3)[2,2] = ONE
     res(2,1) = res(2,1)+.hamiltonian_for(v,reorder_ket,1,2)
  !   if(i==j) res = res +.nuclear_energy
     stdout.text("res")
     stdout.put(res)
     reorder_ket.destroy
     v.destroy
   end

   make_RHM(rhm)
    ! make reduced hamiltonian matrix 
     rhm ::  MAT{REAL}*
     v :: MAT4{REAL}*
     i,j,k,l,m,n :: INT
     eri_archive :: ARCHIVE
     rhm = ZERO
     eri_archive.set(.name,"h_integrals")
     v.create(.n_bf,.n_bf,.n_bf,.n_bf)
     eri_archive.read(v)
     do i=1,.n_bas
       do k=1,.n_bf
       do l=1,.n_bf
         if(NOT .contraction_wfs(i)[k,l].is_zero)then
           do j=1,.n_bas
             do m=1,.n_bf
             do n=1,.n_bf
               if(NOT .contraction_wfs(j)[m,n].is_zero)then
                 rhm(i,j)=rhm(i,j)+.contraction_wfs(i)[k,l]*.contraction_wfs(j)[m,n]*v(k,l,m,n)
               end
             end
             end
           end
         end
       end
       end
     end
     v.destroy
   end

!to do one day ...: fix the indentation of the tests if(NOT fac.is_zero(.tol)) in
!Hamiltonian_for functions
! change .n_bf into n_bf after adding n_bf=.n_bf at the beginning of the
! recursive functions

   hamiltonian_for(v,order_ket) result (res) ::: recursive
   ! Standard recursive function which evaluates the hamiltonian integrals matrix
   ! between mean field (Sz=0)-geminals 
   ! v is the array containing the hf integrals of the 2-electron Hamiltonian.
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     order_ket :: VEC{INT}, IN
     v :: MAT4{REAL}, target, IN
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     row_ind, col_ind :: INT
     ii,jj,kk,i,j,k,l,dim,bi1,bi2,bj1,bj2,bk1,bk2,bq1,bq2 :: INT
     fac :: REAL
     reorder_ket,reorder_bra :: VEC{INT}*
     temp_bra_q :: MAT{REAL}*
     temp_bra_i :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_h2_q ::  MAT{REAL}*
     temp_qa_h2 :: MAT4{REAL}*
     temp_qb_h2 :: MAT4{REAL}*
     temp_qa_h2_ja :: MAT4{REAL}*
     temp_qa_h2_ja_ex :: MAT4{REAL}*
     temp_qb_h2_jb :: MAT4{REAL}*
     temp_qb_h2_jb_ex :: MAT4{REAL}*
     temp_qa_h2_jb :: MAT4{REAL}*
     temp_qb_h2_ja :: MAT4{REAL}*
     temp_qa_h2_ja_kb :: MAT4{REAL}*
     temp_qa_h2_jb_ka :: MAT4{REAL}*
     temp_qb_h2_jb_ka :: MAT4{REAL}*
     temp_qb_h2_ja_kb :: MAT4{REAL}*
     temp_qa_h2_ja_ka :: MAT4{REAL}*
     temp_qb_h2_jb_kb :: MAT4{REAL}*
     temp_qa_h2_ja_ex_ka :: MAT4{REAL}*
     temp_qb_h2_jb_ex_kb :: MAT4{REAL}*
     temp_qb_jb :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_q_h2_ja_kb :: MAT{REAL}*
     temp_q_h2_jb_ka :: MAT{REAL}*
     temp_qa_h2_j :: MAT{REAL}*
     temp_qb_h2_j :: MAT{REAL}*

     nullify(temp_qa_h2_ja)
     nullify(temp_qb_h2_jb)
     nullify(temp_qa_h2_jb)
     nullify(temp_qb_h2_ja)
     nullify(temp_qa_h2_ja_ex)
     nullify(temp_qb_h2_jb_ex)
     nullify(temp_qa_ja)
     nullify(temp_qb_jb)
     nullify(temp_q_h2_ja_kb)
     nullify(temp_q_h2_jb_ka)
     nullify(temp_qb_h2_jb_kb)
     nullify(temp_qb_h2_jb_ex_kb)
     nullify(temp_qa_h2_ja_ka)
     nullify(temp_qa_h2_ja_ex_ka)
     nullify(temp_qa_h2_ja_kb)
     nullify(temp_qb_h2_jb_ka)
     nullify(temp_qa_h2_jb_ka)
     nullify(temp_qb_h2_ja_kb)
     dim = order_ket.dim
     res = ZERO
      
     if (dim==1) then ! case 1.2 only
       j = order_ket(1)
       DIE_IF(j/=1,"dim=1 but j not 1")
       temp_h2_q.create(.n_bf,.n_bf)
       do col_ind=1,.n_bas
         do bj2=1,.n_bf
         do bj1=1,.n_bf
           temp_h2_q(bj1,bj2) = sum(v(bj1,bj2,:,:)*.contraction_wfs(col_ind)[:,:])
         end
         end
         do row_ind=1,col_ind
           res(row_ind,col_ind) = sum(.contraction_wfs(row_ind)[:,:]*temp_h2_q)
         end
       end
       temp_h2_q.destroy
    !debug           write(*,*) 'case 1.2',dim,res
       return
     else ! dim > 1
       temp_bra_q => .bra(dim)[:,:]
       reorder_ket.create(dim-1)
!the next two arrays are created here because they are small and used in all
!cases
       temp_qa_h2_j.create(.n_bf,.n_bf)
       temp_qb_h2_j.create(.n_bf,.n_bf)
       temp_qa_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
       temp_qb_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
       do bj2=1,.n_bf
       do bj1=1,.n_bf
       do bq2=1,.n_bf
       do bq1=1,.n_bf
! respect the bra/ket nature of the indices
         temp_qa_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(:,bq2)*v(:,bq1,bj1,bj2))
         temp_qb_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(bq1,:)*v(bq2,:,bj1,bj2))
       end
       end
       end
       end
       do jj = dim,1,-1
         j = order_ket(jj)
!debug   write(*,*) "jj,j",jj,j
         if (j==1) then !ket from contraction 1
           DIE_IF(jj/=1,"j is 1 but jj not 1")
           do col_ind=1,.n_bas
             temp_ket_j => .contraction_wfs(col_ind)[:,:]
             if(temp_qa_h2_ja.destroyed) then
               temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
  !the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
  ! in case of memory shortage they can be created later but then the loop on kk 
  !must be done for each subcase.
               temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qa_ja.create(.n_bf,.n_bf)
               temp_qb_jb.create(.n_bf,.n_bf)
             end
             do bj2=1,.n_bf
             do bq2=1,.n_bf
               temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
               temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
             end
             end
             do bj2=1,.n_bf
             do bj1=1,.n_bf
             do bq2=1,.n_bf
             do bq1=1,.n_bf
! respect the bra/ket nature of the indices
               temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
               temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
               temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
               temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
               temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
               temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
             end
             end
             end
             end
!case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk) !cannot be 1
!debug                write(*,*) "kk,k",kk,k
               DIE_IF(k<2,"k cannot be 1")  !debug
               reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) =  k
               if (.special_ket(k)[1]==0) then !k not special
                 temp_ket_k => .ket(k)[:,:]
!case 2.3
                 if(temp_qa_h2_ja_kb.destroyed) then
                   temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
                   temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
                   temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
                   temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
                 end
!case 2.3.1 call special overlap ab
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                   temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                   temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                   temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                 end
                 end
                 end
                 end
                 reorder_bra.create(dim-2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,.n_bf
                     .special_ket(k)[2] = bj2
                     do bk1=1,.n_bf
                       .special_ket(k)[1] = bk1 
                       do bq1=1,.n_bf
                       do bi2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                            + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                            + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                            + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                         if( NOT fac.is_zero(.tol)) then
                           res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2)*fac
                         end 
                       end 
                       end
                     end
                   end
                 end !do ii, the case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do row_ind = 1, col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bj2=1,.n_bf
                     .special_ket(k)[2] = bj2
                     do bk1=1,.n_bf
                       .special_ket(k)[1] = bk1 
                       do bi2=1,.n_bf
                       do bq1=1,.n_bf
                         fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                            + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                            + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                            + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                         if( NOT fac.is_zero(.tol)) then
                           res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac 
                         end 
                       end 
                       end
                     end
                   end
                 end
!debug                 write(*,*) 'case 2.3.1',dim,res
!case 2.3.2 call special overlap aa
                 temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
                 temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                   temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                 end
                 end
                 end
                 end
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bk1=1,.n_bf
                     .special_ket(k)[2] = bk1
                     do bj1=1,.n_bf
                       .special_ket(k)[1] = bj1 
                       do bi1=1,.n_bf
                       do bq1=1,.n_bf
                         fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                            + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                         if( NOT fac.is_zero(.tol)) then
                           res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac 
                         end 
                       end 
                       end
                     end
                   end
                 end !do ii , case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bk1=1,.n_bf
                     .special_ket(k)[2] = bk1
                     do bj1=1,.n_bf
                       .special_ket(k)[1] = bj1 
                       do bi1=1,.n_bf
                       do bq1=1,.n_bf
                         fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                            + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                         if( NOT fac.is_zero(.tol)) then
                           res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <
                         end 
                       end 
                       end
                     end
                   end
                 end
!debug                 write(*,*) 'case 2.3.2',dim,res
!case 2.3.3 call special overlap bb
                 temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
                 temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                   temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                 end
                 end
                 end
                 end
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bk2=1,.n_bf
                     .special_ket(k)[2] = bk2
                     do bj2=1,.n_bf
                       .special_ket(k)[1] = bj2 
                       do bi2=1,.n_bf
                       do bq2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                            + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                         if( NOT fac.is_zero(.tol)) then
                           res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! <<
                         end 
                       end 
                       end
                     end
                   end
                 end !do ii , case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bk2=1,.n_bf
                     .special_ket(k)[2] = bk2
                     do bj2=1,.n_bf
                       .special_ket(k)[1] = bj2 
                       do bi2=1,.n_bf
                       do bq2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                            + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                         if( NOT fac.is_zero(.tol)) then
                           res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
                         end 
                       end 
                       end
                     end
                   end
                 end
                 reorder_bra.destroy
!debug                 write(*,*) 'case 2.3.3',dim,res
!case 2.2
                ! if(temp_q_h2_ja_kb.destroyed) then
                !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
                !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
                ! end
                ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
                ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
                     temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
                     fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                       .special_ket(k)[1] = bk1 
                       res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac 
                     end 
                   end 
                 end
!debug                 write(*,*) 'case 2.2',dim,res
!case 2.1
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
                     if( NOT fac.is_zero(.tol)) then
                       .special_ket(k)[1] = bk1 
                       res(:,col_ind) = res(:,col_ind) - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                     end 
                   end 
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
!debug                 write(*,*) 'case 2.1',dim,res
               else !k special
                 bk1=.special_ket(k)[1]
                 bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
                 !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
                 !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
                 !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 reorder_bra.create(dim-2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,bk2-1
                !    .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
                       end 
                     end
                     end
                   end
                   do bj2=bk2+1,.n_bf
                   ! .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <
                       end 
                     end 
                     end 
                   end
                   .special_ket(k)[2] = bk2 
                   do bj1=1,bk1-1
                     .special_ket(k)[1] = bj1 
                !    .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
                       end 
                     end 
                     end
                   end
                   do bj1=bk1+1,.n_bf
                     .special_ket(k)[1] = bj1 
                 !   .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
                       end 
                     end 
                     end
                   end
                   .special_ket(k)[1] = bk1 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2
                     if( NOT fac.is_zero(.tol)) then
                       res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end 
                   end 
                 end !do ii, the case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bj2=1,bk2-1
                !    .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                       end 
                     end
                     end
                   end
                   do bj2=bk2+1,.n_bf
                   ! .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                       end 
                     end 
                     end 
                   end
                   .special_ket(k)[2] = bk2 
                   do bj1=1,bk1-1
                     .special_ket(k)[1] = bj1 
                !    .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                       end 
                     end 
                     end
                   end
                   do bj1=bk1+1,.n_bf
                     .special_ket(k)[1] = bj1 
                 !   .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                       end 
                     end 
                     end
                   end
                   .special_ket(k)[1] = bk1 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end 
                   end 
                 end 
                 .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!debug                 write(*,*) 'case 2.3.1',dim,res
!case 2.3.2 call special overlap aa
                !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
                !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
               !     .special_ket(k)[2] = bk1
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                       if( NOT fac.is_zero(.tol)) then
                         res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac ! <
                       end 
                     end 
                     end
                   end
                 end !do ii , case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
                 !   .special_ket(k)[2] = bk1
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                       if( NOT fac.is_zero(.tol)) then
                         res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                       end 
                     end 
                     end
                   end
                 end
                 .special_ket(k)[2] = bk2 
!debug                 write(*,*) 'case 2.3.2',dim,res
!case 2.3.3 call special overlap bb
               !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
               !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                 !   .special_ket(k)[2] = bk2
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                          + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(:,col_ind) = res(:,col_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! <<
                       end 
                     end 
                     end
                   end
                 end !do ii , case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                  !  .special_ket(k)[2] = bk2
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                          + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                       if( NOT fac.is_zero(.tol)) then
                         res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
                       end 
                     end 
                     end
                   end
                 end
                 .special_ket(k)[1] = bk1 
                 reorder_bra.destroy
!debug                 write(*,*) 'case 2.3.3',dim,res
!case 2.2
                 !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 do bj2=1,bk2-1
                   temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                   fac= temp_q_h2_ja_kb.trace
                   if( NOT fac.is_zero(.tol)) then
                 !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! 
                   end 
                 end
                 do bj2=bk2+1,.n_bf
                   temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                   fac= temp_q_h2_ja_kb.trace
                   if( NOT fac.is_zero(.tol)) then
                 !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! 
                   end 
                 end
                 .special_ket(k)[2] = bk2
                 !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 do bj1=1,bk1-1
                   temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                   fac= temp_q_h2_jb_ka.trace
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                !   .special_ket(k)[2] = bk2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! 
                   end 
                 end
                 do bj1=bk1+1,.n_bf
                   temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                   fac= temp_q_h2_jb_ka.trace
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                !   .special_ket(k)[2] = bk2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! 
                   end 
                 end
                 .special_ket(k)[1] = bk1 
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
                 fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                 if( NOT fac.is_zero(.tol)) then
             !    .special_ket(k)[1] = bk1 
             !    .special_ket(k)[2] = bk2
                   res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! 
                 end 
!debug                 write(*,*) 'case 2.2',dim,res
!case 2.1
                 do bj2=1,bk2-1
                   fac= temp_qa_ja(bk2,bj2)
                   if( NOT fac.is_zero(.tol)) then
                  !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res(:,col_ind) = res(:,col_ind) - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                   end 
                 end
                 do bj2=bk2+1,.n_bf
                   fac= temp_qa_ja(bk2,bj2)
                   if( NOT fac.is_zero(.tol)) then
                  !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res(:,col_ind) = res(:,col_ind) - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                   end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   fac= temp_qb_jb(bk1,bj1)
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                   ! .special_ket(k)[2] = bk2
                     res(:,col_ind) = res(:,col_ind) - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                   end 
                 end
                 do bj1=bk1+1,.n_bf
                   fac= temp_qb_jb(bk1,bj1)
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                   ! .special_ket(k)[2] = bk2
                     res(:,col_ind) = res(:,col_ind) - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                   end 
                 end
                 .special_ket(k)[1] = bk1 
                 fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
                 if( NOT fac.is_zero(.tol)) then
                 !  .special_ket(k)[1] = bk1 
                 !  .special_ket(k)[2] = bk2
                   res(:,col_ind) = res(:,col_ind) - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                 end
!debug                 write(*,*) 'case 2.1',dim,res
               end !k special
             end !do kk
             nullify(temp_q_h2_ja_kb)
             nullify(temp_q_h2_jb_ka)
             temp_qb_h2_jb_ka.destroy
             nullify(temp_qb_h2_jb_kb)
             nullify(temp_qb_h2_jb_ex_kb)
             temp_qa_h2_ja_kb.destroy
             nullify(temp_qa_h2_ja_ka)
             nullify(temp_qa_h2_ja_ex_ka)
             temp_qa_h2_jb_ka.destroy
             temp_qb_h2_ja_kb.destroy
!case 1.3
             temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
             temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
             !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
             !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
          !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!debug             stdout.put(reorder_ket)
             reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
             reorder_bra.create(dim-2)
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                 if( NOT fac.is_zero(.tol)) then
                   res(:,col_ind) = res(:,col_ind) - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
                 end 
               end
               end
             end !ii case ii=1 remains 
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do row_ind=1,col_ind
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                 if( NOT fac.is_zero(.tol)) then
                   res(row_ind,col_ind) = res(row_ind,col_ind) - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
               end
               end
             end
             reorder_bra.destroy
!debug                 write(*,*) 'case 1.3',dim,res
!case 1.2
             fac=temp_qb_h2_j.trace
             if( NOT fac.is_zero(.tol)) then
               res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! 
             end 
!debug                 write(*,*) 'case 1.2',dim,res
!case 1.1
             fac=temp_qb_jb.trace
             if( NOT fac.is_zero(.tol)) then
               res(:,col_ind) = res(:,col_ind) + .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
             end 
!debug                 write(*,*) 'case 1.1',dim,res
           end !do col_ind
         else !j>1
           if (.special_ket(j)[1]==0) then !j not special
             temp_ket_j => .ket(j)[:,:]
             if(temp_qa_h2_ja.destroyed) then
               temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
               temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qa_ja.create(.n_bf,.n_bf)
               temp_qb_jb.create(.n_bf,.n_bf)
             end
             do bj2=1,.n_bf
             do bq2=1,.n_bf
               temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
               temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
             end
             end
             do bj2=1,.n_bf
             do bj1=1,.n_bf
             do bq2=1,.n_bf
             do bq1=1,.n_bf
! respect the bra/ket nature of the indices
               temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
               temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
               temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
               temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
               temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
               temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
             end
             end
             end
             end
!case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk) !cannot be 1
!debug               write(*,*) 'kk,k',kk,k
               DIE_IF(k<2,"k cannot be 1")  !debug
               reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) =  k
               if (.special_ket(k)[1]==0) then !k not special
                 temp_ket_k => .ket(k)[:,:]
!case 2.3
                 if(temp_qa_h2_ja_kb.destroyed) then
                   temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
                   temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
                   temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
                   temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
                 end
!case 2.3.1 call special overlap ab
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                   temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                   temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                   temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                 end
                 end
                 end
                 end
                 reorder_bra.create(dim-2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,.n_bf
                     .special_ket(k)[2] = bj2
                     do bk1=1,.n_bf
                       .special_ket(k)[1] = bk1 
                       do bq1=1,.n_bf
                       do bi2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                            + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                            + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                            + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                         if( NOT fac.is_zero(.tol)) then
                           res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
                         end 
                       end 
                       end
                     end
                   end
                 end !do ii, the case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do col_ind=1,.n_bas
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bj2=1,.n_bf
                     .special_ket(k)[2] = bj2
                     do bk1=1,.n_bf
                       .special_ket(k)[1] = bk1 
                       do bi2=1,.n_bf
                       do bq1=1,.n_bf
                         fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                            + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                            + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                            + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                         if( NOT fac.is_zero(.tol)) then
                           res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
                         end 
                       end 
                       end
                     end
                   end
                 end
                 end
!debug               write(*,*) 'case 2.3.1',dim,res
!case 2.3.2 call special overlap aa
                 temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
                 temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                   temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                 end
                 end
                 end
                 end
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bk1=1,.n_bf
                     .special_ket(k)[2] = bk1
                     do bj1=1,.n_bf
                       .special_ket(k)[1] = bj1 
                       do bi1=1,.n_bf
                       do bq1=1,.n_bf
                         fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                            + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                         if( NOT fac.is_zero(.tol)) then
                           res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,bi1,bq1) * fac ! <<
                         end 
                       end 
                       end
                     end
                   end
                 end !do ii , case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do col_ind=1,.n_bas
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bk1=1,.n_bf
                     .special_ket(k)[2] = bk1
                     do bj1=1,.n_bf
                       .special_ket(k)[1] = bj1 
                       do bi1=1,.n_bf
                       do bq1=1,.n_bf
                         fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                            + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                         if( NOT fac.is_zero(.tol)) then
                           res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                         end 
                       end 
                       end
                     end
                   end
                 end
                 end
!debug              write(*,*) 'case 2.3.2',dim,res
!case 2.3.3 call special overlap bb
                 temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
                 temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                   temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                 end
                 end
                 end
                 end
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bk2=1,.n_bf
                     .special_ket(k)[2] = bk2
                     do bj2=1,.n_bf
                       .special_ket(k)[1] = bj2 
                       do bi2=1,.n_bf
                       do bq2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                            + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                         if( NOT fac.is_zero(.tol)) then
                           res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,bi2,bq2) * fac ! <
                         end 
                       end 
                       end
                     end
                   end
                 end !do ii , case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do col_ind=1,.n_bas
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bk2=1,.n_bf
                     .special_ket(k)[2] = bk2
                     do bj2=1,.n_bf
                       .special_ket(k)[1] = bj2 
                       do bi2=1,.n_bf
                       do bq2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                            + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                         if( NOT fac.is_zero(.tol)) then
                           res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                         end 
                       end 
                       end
                     end
                   end
                 end
                 end
                 reorder_bra.destroy
!debug               write(*,*) 'case 2.3.3',dim,res
!case 2.2
                ! if(temp_q_h2_ja_kb.destroyed) then
                !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
                !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
                ! end
                ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
                ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
                     temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
                     fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                       .special_ket(k)[1] = bk1 
                       res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
                   end 
                 end
!debug               write(*,*) 'case 2.2',dim,res
!case 2.1
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
                     if( NOT fac.is_zero(.tol)) then
                       .special_ket(k)[1] = bk1 
                       res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                     end 
                   end 
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
!debug               write(*,*) 'case 2.1',dim,res
               else !k special
                 bk1=.special_ket(k)[1]
                 bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
                 !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
                 !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
                 !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 reorder_bra.create(dim-2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,bk2-1
                !    .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
                       end 
                     end
                     end
                   end
                   do bj2=bk2+1,.n_bf
                   ! .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
                       end 
                     end 
                     end 
                   end
                   .special_ket(k)[2] = bk2 
                   do bj1=1,bk1-1
                     .special_ket(k)[1] = bj1 
                !    .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                       if( NOT fac.is_zero(.tol)) then
                         res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
                       end 
                     end 
                     end
                   end
                   do bj1=bk1+1,.n_bf
                     .special_ket(k)[1] = bj1 
                 !   .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
                     end 
                     end 
                     end
                   end
                   .special_ket(k)[1] = bk1 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! <<
                     end 
                   end 
                   end 
                 end !do ii, the case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do col_ind=1,.n_bas
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bj2=1,bk2-1
                !    .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end
                     end
                   end
                   do bj2=bk2+1,.n_bf
                   ! .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end 
                     end 
                   end
                   .special_ket(k)[2] = bk2 
                   do bj1=1,bk1-1
                     .special_ket(k)[1] = bj1 
                !    .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end 
                     end
                   end
                   do bj1=bk1+1,.n_bf
                     .special_ket(k)[1] = bj1 
                 !   .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end 
                     end
                   end
                   .special_ket(k)[1] = bk1 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2
                     res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                   end 
                   end 
                 end 
                 end 
                 .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!debug               write(*,*) 'case 2.3.1',dim,res
!case 2.3.2 call special overlap aa
                !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
                !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
               !     .special_ket(k)[2] = bk1
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,bi1,bq1) * fac ! 
                     end 
                     end 
                     end
                   end
                 end !do ii , case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do col_ind=1,.n_bas
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
                 !   .special_ket(k)[2] = bk1
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                     end 
                     end
                   end
                 end
                 end
                 .special_ket(k)[2] = bk2 
!debug               write(*,*) 'case 2.3.2',dim,res
!case 2.3.3 call special overlap bb
               !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
               !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                 !   .special_ket(k)[2] = bk2
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                          + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,bi2,bq2) * fac ! <<
                     end 
                     end 
                     end
                   end
                 end !do ii , case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do col_ind=1,.n_bas
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                  !  .special_ket(k)[2] = bk2
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                          + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                     end 
                     end
                   end
                 end
                 end
                 .special_ket(k)[1] = bk1 
                 reorder_bra.destroy
!debug               write(*,*) 'case 2.3.3',dim,res
!case 2.2
                 !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 do bj2=1,bk2-1
                   temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                   fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
                 end
                 do bj2=bk2+1,.n_bf
                   temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                   fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
                 end
                 .special_ket(k)[2] = bk2
                 !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 do bj1=1,bk1-1
                   temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                   fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                !  .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
                 end
                 do bj1=bk1+1,.n_bf
                   temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                   fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                !  .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
                 end
                 .special_ket(k)[1] = bk1 
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
                 fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
             !    .special_ket(k)[1] = bk1 
             !    .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
!debug               write(*,*) 'case 2.2',dim,res
!case 2.1
                 do bj2=1,bk2-1
                   fac= temp_qa_ja(bk2,bj2)
                   if( NOT fac.is_zero(.tol)) then
                  !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                   end 
                 end
                 do bj2=bk2+1,.n_bf
                   fac= temp_qa_ja(bk2,bj2)
                   if( NOT fac.is_zero(.tol)) then
                  !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                   end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   fac= temp_qb_jb(bk1,bj1)
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                   ! .special_ket(k)[2] = bk2
                     res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                   end 
                 end
                 do bj1=bk1+1,.n_bf
                   fac= temp_qb_jb(bk1,bj1)
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                   ! .special_ket(k)[2] = bk2
                     res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                   end 
                 end
                 .special_ket(k)[1] = bk1 
                 fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
                 if( NOT fac.is_zero(.tol)) then
                 !  .special_ket(k)[1] = bk1 
                 !  .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                 end
!debug               write(*,*) 'case 2.1',dim,res
               end !k special
             end !do kk
             nullify(temp_q_h2_ja_kb)
             nullify(temp_q_h2_jb_ka)
             temp_qb_h2_jb_ka.destroy
             nullify(temp_qb_h2_jb_kb)
             nullify(temp_qb_h2_jb_ex_kb)
             temp_qa_h2_ja_kb.destroy
             nullify(temp_qa_h2_ja_ka)
             nullify(temp_qa_h2_ja_ex_ka)
             temp_qa_h2_jb_ka.destroy
             temp_qb_h2_ja_kb.destroy
!case 1.3
             temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
             temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
             !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
             !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
             ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!debug             stdout.put(reorder_ket)
             reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
             reorder_bra.create(dim-2)
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
                 res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
                     end 
               end
               end
             end !ii case ii=1 remains 
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do col_ind=1,.n_bas
             do row_ind=1,col_ind
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                 if( NOT fac.is_zero(.tol)) then
                   res(row_ind,col_ind) = res(row_ind,col_ind) - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
               end
               end
             end
             end
             reorder_bra.destroy
!debug               write(*,*) 'case 1.3',dim,res
!case 1.2
             fac=temp_qb_h2_j.trace
             if( NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_ket) * fac 
             end 
!debug               write(*,*) 'case 1.2',dim,res
!case 1.1
             fac=temp_qb_jb.trace
             if( NOT fac.is_zero(.tol)) then
               res = res + .hamiltonian_for(v,reorder_ket) * fac ! 
             end 
!debug               write(*,*) 'case 1.1',dim,res
           else ! j is a special ket
! warning: we have not changed the structure with respect to the case "not a
! special ket", therefore more space than needed is used and large parts of the
! arrays are dangerously not initialized.
             bj1=.special_ket(j)[1]
             bj2=.special_ket(j)[2]
!case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk) !cannot be 1
!debug               write(*,*) 'kk,k',kk,k
               DIE_IF(k<2,"k cannot be 1")  !debug
               reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) =  k
               DIE_IF(.special_ket(k)[1]==0,"j special ket but not k") 
               bk1=.special_ket(k)[1]
               bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
               !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               reorder_bra.create(dim-2)
               if(bj2/=bk2 OR bj1/=bk1) then
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! <<
                     end 
                   end
                   end
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! <<
                     end 
                   end
                   end
                   .special_ket(k)[1] = bk1 
                 end !do ii, the case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do col_ind=1,.n_bas
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end
                   end
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end
                   end
                   .special_ket(k)[1] = bk1 
                 end
                 end
               else !bj1==bk1 AND bj2==bk2
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                !     .special_ket(k)[1] = bk1 
                !     .special_ket(k)[2] = bk2
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! <<
                     end 
                   end 
                   end 
                 end !do ii, the case ii=1 is left
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do col_ind=1,.n_bas
                 do row_ind=1,col_ind
                   temp_bra_i => .contraction_wfs(row_ind)[:,:]
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                !     .special_ket(k)[1] = bk1 
                !     .special_ket(k)[2] = bk2
                     res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end 
                   end 
                 end 
                 end 
               end !bj1==bk1 AND bj2==bk2
               .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!debug               write(*,*) 'case 2.3.1',dim,res
!case 2.3.2 call special overlap aa
              !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
              !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
               .special_ket(k)[1] = bj1 
             ! .special_ket(k)[2] = bk1
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bi1=1,.n_bf
                 do bq1=1,.n_bf
                   fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
                      + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,bi1,bq1) * fac ! 
                     end 
                 end
                 end
               end !do ii , case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do col_ind=1,.n_bas
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bi1=1,.n_bf
                 do bq1=1,.n_bf
                   fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
                      + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                   res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                 end
                 end
               end
               end
!debug               write(*,*) 'case 2.3.2',dim,res
!case 2.3.3 call special overlap bb
             !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
             !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
               .special_ket(k)[2] = bk2 
               .special_ket(k)[1] = bj2 
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bi2=1,.n_bf
                 do bq2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
                      + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,bi2,bq2) * fac ! 
                     end 
                 end 
                 end
               end !do ii , case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do col_ind=1,.n_bas
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bi2=1,.n_bf
                 do bq2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
                      + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                   res(row_ind,col_ind) = res(row_ind,col_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
                     end 
                 end 
                 end
               end
               end
               reorder_bra.destroy
               .special_ket(k)[1] = bk1 
!debug               write(*,*) 'case 2.3.3',dim,res
!case 2.2
               if(bj2/=bk2 OR bj1/=bk1) then
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
                 fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
               !  .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
                 .special_ket(k)[2] = bk2
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
                 fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1 
              !   .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
                 .special_ket(k)[1] = bk1 
               else !bj2==bk2 AND bj1==bk1
                 temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
                 temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
                 fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
           !     .special_ket(k)[1] = bk1 
           !     .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket) * fac ! 
                     end 
               end !bj2==bk2 AND bj1==bk1
!debug               write(*,*) 'case 2.2',dim,res
!case 2.1
               if(bj2/=bk2 OR bj1/=bk1) then
                 fac= temp_bra_q(bj1,bk2)
                 if( NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                   .special_ket(k)[2] = bk2 
                 end 
                 fac= temp_bra_q(bk1,bj2)
                 if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                   .special_ket(k)[1] = bk1 
                 end 
               else !bj2==bk2 AND bj1==bk1
                 fac= temp_bra_q(bk1,bj2) + temp_bra_q(bj1,bk2)
                 if( NOT fac.is_zero(.tol)) then
               !   .special_ket(k)[1] = bk1 
               !   .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket) * fac ! 
                 end
               end !bj2==bk2 AND bj1==bk1
!debug               write(*,*) 'case 2.1',dim,res
             end !do kk
             !nullify(temp_q_h2_ja_kb)
             !nullify(temp_q_h2_jb_ka)
             !temp_qb_h2_jb_ka.destroy
             !nullify(temp_qb_h2_jb_kb)
             !nullify(temp_qb_h2_jb_ex_kb)
             !temp_qa_h2_ja_kb.destroy
             !nullify(temp_qa_h2_ja_ka)
             !nullify(temp_qa_h2_ja_ex_ka)
             !temp_qa_h2_jb_ka.destroy
             !temp_qb_h2_ja_kb.destroy
!case 1.3
             temp_qa_h2_j=temp_qa_h2(:,:,bj1,bj2)
             temp_qb_h2_j=temp_qb_h2(:,:,bj1,bj2)
             !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
             !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
             ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
             reorder_bra.create(dim-2)
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
                 res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,bq1,bi2) * fac ! 
                     end 
               end
               end
             end !ii case ii=1 remains 
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do col_ind=1,.n_bas
             do row_ind=1,col_ind
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
                 res(row_ind,col_ind) = res(row_ind,col_ind) - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
               end
               end
             end
             end
             reorder_bra.destroy
!debug               write(*,*) 'case 1.3',dim,res
!case 1.2
             fac=temp_qb_h2_j.trace
                     if( NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_ket) * fac ! 
                     end 
!debug               write(*,*) 'case 1.2',dim,res
!case 1.1
             fac=temp_bra_q(bj1,bj2)
                     if( NOT fac.is_zero(.tol)) then
             res = res + .hamiltonian_for(v,reorder_ket) * fac ! 
                     end 
!debug               write(*,*) 'case 1.1',dim,res
           end !j special ket
         end !if j=1
       end !do jj
       if(temp_qa_h2_ja.created) then
         temp_qa_h2_ja.destroy
         temp_qb_h2_jb.destroy
         temp_qa_h2_jb.destroy
         temp_qb_h2_ja.destroy
         temp_qa_h2_ja_ex.destroy
         temp_qb_h2_jb_ex.destroy
         temp_qa_ja.destroy
         temp_qb_jb.destroy
       end
       temp_qa_h2_j.destroy
       temp_qb_h2_j.destroy
       temp_qa_h2.destroy
       temp_qb_h2.destroy
       reorder_ket.destroy
     end !if dim=1
   end

   hamiltonian_for(v,order_ket,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the hamiltonian integrals matrix
   ! column vector between mean field (Sz=0)-geminals 
   ! v is the array containing the hf integrals of the 2-electron Hamiltonian.
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     order_ket :: VEC{INT}, IN
     v :: MAT4{REAL}, target, IN
     col_ind :: INT, IN
     res :: VEC{REAL}(.n_bas)
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     row_ind :: INT
     ii,jj,kk,i,j,k,l,dim,bi1,bi2,bj1,bj2,bk1,bk2,bq1,bq2 :: INT
     fac :: REAL
     reorder_ket,reorder_bra :: VEC{INT}*
     temp_bra_q :: MAT{REAL}*
     temp_bra_i :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_h2_q ::  MAT{REAL}*
     temp_qa_h2 :: MAT4{REAL}*
     temp_qb_h2 :: MAT4{REAL}*
     temp_qa_h2_ja :: MAT4{REAL}*
     temp_qa_h2_ja_ex :: MAT4{REAL}*
     temp_qb_h2_jb :: MAT4{REAL}*
     temp_qb_h2_jb_ex :: MAT4{REAL}*
     temp_qa_h2_jb :: MAT4{REAL}*
     temp_qb_h2_ja :: MAT4{REAL}*
     temp_qa_h2_ja_kb :: MAT4{REAL}*
     temp_qa_h2_jb_ka :: MAT4{REAL}*
     temp_qb_h2_jb_ka :: MAT4{REAL}*
     temp_qb_h2_ja_kb :: MAT4{REAL}*
     temp_qa_h2_ja_ka :: MAT4{REAL}*
     temp_qb_h2_jb_kb :: MAT4{REAL}*
     temp_qa_h2_ja_ex_ka :: MAT4{REAL}*
     temp_qb_h2_jb_ex_kb :: MAT4{REAL}*
     temp_qb_jb :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_q_h2_ja_kb :: MAT{REAL}*
     temp_q_h2_jb_ka :: MAT{REAL}*
     temp_qa_h2_j :: MAT{REAL}*
     temp_qb_h2_j :: MAT{REAL}*

     nullify(temp_qa_ja)
     nullify(temp_qb_jb)
     nullify(temp_qa_h2_ja_ex)
     nullify(temp_qb_h2_jb_ex)
     nullify(temp_qa_h2_ja)
     nullify(temp_qb_h2_jb)
     nullify(temp_qa_h2_jb)
     nullify(temp_qb_h2_ja)
     nullify(temp_q_h2_ja_kb)
     nullify(temp_q_h2_jb_ka)
     nullify(temp_qb_h2_jb_kb)
     nullify(temp_qb_h2_jb_ex_kb)
     nullify(temp_qa_h2_ja_ka)
     nullify(temp_qa_h2_ja_ex_ka)
     nullify(temp_qa_h2_ja_kb)
     nullify(temp_qb_h2_jb_ka)
     nullify(temp_qa_h2_jb_ka)
     nullify(temp_qb_h2_ja_kb)
     dim = order_ket.dim
     res = ZERO
      
     if (dim==1) then ! case 1.2 only
       j = order_ket(1)
       DIE_IF(j==1,"j is 1")
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         do row_ind=1,col_ind
           res(row_ind) = sum(.contraction_wfs(row_ind)[:,:]*v(:,:,bj1,bj2))
         end
       else
         temp_h2_q.create(.n_bf,.n_bf)
         do bj2=1,.n_bf
         do bj1=1,.n_bf
           temp_h2_q(bj1,bj2) = sum(v(bj1,bj2,:,:)*.ket(j)[:,:])
         end
         end
         do row_ind=1,col_ind
           res(row_ind) = sum(.contraction_wfs(row_ind)[:,:]*temp_h2_q)
         end
         temp_h2_q.destroy
       end
    !debug           write(*,*) 'case 1.2',dim,res
       return
     else ! dim > 1
       temp_bra_q => .bra(dim)[:,:]
       reorder_ket.create(dim-1)
!the next two arrays are created here because they are small and used in all
!cases
       temp_qa_h2_j.create(.n_bf,.n_bf)
       temp_qb_h2_j.create(.n_bf,.n_bf)
       temp_qa_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
       temp_qb_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
       do bj2=1,.n_bf
       do bj1=1,.n_bf
       do bq2=1,.n_bf
       do bq1=1,.n_bf
! respect the bra/ket nature of the indices
         temp_qa_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(:,bq2)*v(:,bq1,bj1,bj2))
         temp_qb_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(bq1,:)*v(bq2,:,bj1,bj2))
       end
       end
       end
       end
       do jj = dim,1,-1
         j = order_ket(jj)
!debug    write(*,*) "jj,j",jj,j
         DIE_IF(j==1,"j is 1 ")
         if (.special_ket(j)[1]==0) then !j not special
           temp_ket_j => .ket(j)[:,:]
           if(temp_qa_h2_ja.destroyed) then
             temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
             temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qa_ja.create(.n_bf,.n_bf)
             temp_qb_jb.create(.n_bf,.n_bf)
           end
           do bj2=1,.n_bf
           do bq2=1,.n_bf
             temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
             temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
           end
           end
           do bj2=1,.n_bf
           do bj1=1,.n_bf
           do bq2=1,.n_bf
           do bq1=1,.n_bf
! respect the bra/ket nature of the indices
             temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
             temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
             temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
             temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
             temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
             temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
           end
           end
           end
           end
!case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk) !cannot be 1
!debug               write(*,*) 'kk,k',kk,k
             DIE_IF(k<2,"k cannot be 1")  !debug
             reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) =  k
             if (.special_ket(k)[1]==0) then !k not special
               temp_ket_k => .ket(k)[:,:]
!case 2.3
               if(temp_qa_h2_ja_kb.destroyed) then
                 temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
                 temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
                 temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
                 temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               end
!case 2.3.1 call special overlap ab
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                 temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                 temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                 temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
               end
               end
               end
               end
               reorder_bra.create(dim-2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     .special_ket(k)[1] = bk1 
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                          + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
                     end 
                     end 
                     end
                   end
                 end
               end !do ii, the case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     .special_ket(k)[1] = bk1 
                     do bi2=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                          + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
                     end 
                     end 
                     end
                   end
                 end
               end
!debug               write(*,*) 'case 2.3.1',dim,res
!case 2.3.2 call special overlap aa
               temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
               temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                 temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
               end
               end
               end
               end
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bk1=1,.n_bf
                   .special_ket(k)[2] = bk1
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac ! <<
                     end 
                     end 
                     end
                   end
                 end
               end !do ii , case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bk1=1,.n_bf
                   .special_ket(k)[2] = bk1
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind) = res(row_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                     end 
                     end
                   end
                 end
               end
!debug              write(*,*) 'case 2.3.2',dim,res
!case 2.3.3 call special overlap bb
               temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
               temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                 temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
               end
               end
               end
               end
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bk2=1,.n_bf
                   .special_ket(k)[2] = bk2
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                          + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! <
                     end 
                     end 
                     end
                   end
                 end
               end !do ii , case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bk2=1,.n_bf
                   .special_ket(k)[2] = bk2
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                          + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                       res(row_ind) = res(row_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                     end 
                     end
                   end
                 end
               end
               reorder_bra.destroy
!debug               write(*,*) 'case 2.3.3',dim,res
!case 2.2
              ! if(temp_q_h2_ja_kb.destroyed) then
              !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
              !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
              ! end
              ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
              ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
               do bj2=1,.n_bf
                 .special_ket(k)[2] = bj2
                 do bk1=1,.n_bf
                   temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
                   temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
                   fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bk1 
                   res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
                     end 
                 end 
               end
!debug               write(*,*) 'case 2.2',dim,res
!case 2.1
               do bj2=1,.n_bf
                 .special_ket(k)[2] = bj2
                 do bk1=1,.n_bf
                   fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bk1 
                     res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                   end 
                 end 
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
!debug               write(*,*) 'case 2.1',dim,res
             else !k special
               bk1=.special_ket(k)[1]
               bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
               !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               reorder_bra.create(dim-2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,bk2-1
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
                     end 
                   end
                   end
                 end
                 do bj2=bk2+1,.n_bf
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
                     end 
                   end 
                   end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   .special_ket(k)[1] = bj1 
              !    .special_ket(k)[2] = bk2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
                     end 
                   end 
                   end
                 end
                 do bj1=bk1+1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
                     end 
                   end 
                   end
                 end
                 .special_ket(k)[1] = bk1 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                !   .special_ket(k)[1] = bk1 
                !   .special_ket(k)[2] = bk2
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end 
                 end 
               end !do ii, the case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bj2=1,bk2-1
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                   end
                   end
                 end
                 do bj2=bk2+1,.n_bf
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                   end 
                   end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   .special_ket(k)[1] = bj1 
              !    .special_ket(k)[2] = bk2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                   end 
                   end
                 end
                 do bj1=bk1+1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                   end 
                   end
                 end
                 .special_ket(k)[1] = bk1 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                !   .special_ket(k)[1] = bk1 
                !   .special_ket(k)[2] = bk2
                   res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                 end 
                 end 
               end 
               .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!debug               write(*,*) 'case 2.3.1',dim,res
!case 2.3.2 call special overlap aa
              !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
              !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj1=1,.n_bf
                   .special_ket(k)[1] = bj1 
             !     .special_ket(k)[2] = bk1
                   do bi1=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                        + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac ! 
                     end 
                   end 
                   end
                 end
               end !do ii , case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bj1=1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk1
                   do bi1=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                        + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                     res(row_ind) = res(row_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                   end 
                   end
                 end
               end
               .special_ket(k)[2] = bk2 
!debug               write(*,*) 'case 2.3.2',dim,res
!case 2.3.3 call special overlap bb
             !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
             !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[1] = bj2 
               !   .special_ket(k)[2] = bk2
                   do bi2=1,.n_bf
                   do bq2=1,.n_bf
                     fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                        + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! <<
                     end 
                   end 
                   end
                 end
               end !do ii , case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bj2=1,.n_bf
                   .special_ket(k)[1] = bj2 
                !  .special_ket(k)[2] = bk2
                   do bi2=1,.n_bf
                   do bq2=1,.n_bf
                     fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                        + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                     res(row_ind) = res(row_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                   end 
                   end
                 end
               end
               .special_ket(k)[1] = bk1 
               reorder_bra.destroy
!debug               write(*,*) 'case 2.3.3',dim,res
!case 2.2
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               do bj2=1,bk2-1
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                 fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
               ! .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
                     end 
               end
               do bj2=bk2+1,.n_bf
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                 fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
               ! .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
                     end 
               end
               .special_ket(k)[2] = bk2
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               do bj1=1,bk1-1
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                 fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1 
              !  .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
                     end 
               end
               do bj1=bk1+1,.n_bf
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                 fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1 
              !  .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
                     end 
               end
               .special_ket(k)[1] = bk1 
               temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
               temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
               fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
           !    .special_ket(k)[1] = bk1 
           !    .special_ket(k)[2] = bk2
               res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
                     end 
!debug               write(*,*) 'case 2.2',dim,res
!case 2.1
               do bj2=1,bk2-1
                 fac= temp_qa_ja(bk2,bj2)
                 if( NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                 end 
               end
               do bj2=bk2+1,.n_bf
                 fac= temp_qa_ja(bk2,bj2)
                 if( NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                 end 
               end
               .special_ket(k)[2] = bk2 
               do bj1=1,bk1-1
                 fac= temp_qb_jb(bk1,bj1)
                 if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                 end 
               end
               do bj1=bk1+1,.n_bf
                 fac= temp_qb_jb(bk1,bj1)
                 if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                 end 
               end
               .special_ket(k)[1] = bk1 
               fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
               if( NOT fac.is_zero(.tol)) then
               !  .special_ket(k)[1] = bk1 
               !  .special_ket(k)[2] = bk2
                 res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
               end
!debug               write(*,*) 'case 2.1',dim,res
             end !k special
           end !do kk
           nullify(temp_q_h2_ja_kb)
           nullify(temp_q_h2_jb_ka)
           temp_qb_h2_jb_ka.destroy
           nullify(temp_qb_h2_jb_kb)
           nullify(temp_qb_h2_jb_ex_kb)
           temp_qa_h2_ja_kb.destroy
           nullify(temp_qa_h2_ja_ka)
           nullify(temp_qa_h2_ja_ex_ka)
           temp_qa_h2_jb_ka.destroy
           temp_qb_h2_ja_kb.destroy
!case 1.3
           temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
           temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
           !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
           !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
           !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
           reorder_bra.create(dim-2)
           do ii=dim-1,2,-1
             temp_bra_i => .bra(ii)[:,:]
             reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
             reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
               res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
                     end 
             end
             end
           end !ii case ii=1 remains 
           reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
           do row_ind=1,col_ind
             temp_bra_i => .contraction_wfs(row_ind)[:,:]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
               res(row_ind) = res(row_ind) - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
             end
             end
           end
           reorder_bra.destroy
!debug               write(*,*) 'case 1.3',dim,res
!case 1.2
           fac=temp_qb_h2_j.trace
                     if( NOT fac.is_zero(.tol)) then
           res = res + .overlap_for(reorder_ket,col_ind) * fac ! 
                     end 
!debug               write(*,*) 'case 1.2',dim,res
!case 1.1
           fac=temp_qb_jb.trace
                     if( NOT fac.is_zero(.tol)) then
           res = res + .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                     end 
!debug               write(*,*) 'case 1.1',dim,res
         else ! j is a special ket
! warning: we have not changed the structure with respect to the case "not a
! special ket", therefore more space than needed is used and large parts of the
! arrays are dangerously not initialized.
           bj1=.special_ket(j)[1]
           bj2=.special_ket(j)[2]
!case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk) !cannot be 1
!debug               write(*,*) 'kk,k',kk,k
             DIE_IF(k<2,"k cannot be 1")  !debug
             reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) =  k
             DIE_IF(.special_ket(k)[1]==0,"j special ket but not k") 
             bk1=.special_ket(k)[1]
             bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
             !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
             !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
             !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
             !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
             reorder_bra.create(dim-2)
             if(bj2/=bk2 OR bj1/=bk1) then
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
            !    .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end
                 end
                 .special_ket(k)[1] = bj1 
                 .special_ket(k)[2] = bk2 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end
                 end
                 .special_ket(k)[1] = bk1 
               end !do ii, the case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
            !    .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end
                 end
                 .special_ket(k)[1] = bj1 
                 .special_ket(k)[2] = bk2 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end
                 end
                 .special_ket(k)[1] = bk1 
               end
             else !bj1==bk1 AND bj2==bk2
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
              !     .special_ket(k)[1] = bk1 
              !     .special_ket(k)[2] = bk2
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end 
                 end 
               end !do ii, the case ii=1 is left
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do row_ind=1,col_ind
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
              !     .special_ket(k)[1] = bk1 
              !     .special_ket(k)[2] = bk2
                   res(row_ind) = res(row_ind) + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end 
                 end 
               end 
             end !bj1==bk1 AND bj2==bk2
             .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!debug               write(*,*) 'case 2.3.1',dim,res
!case 2.3.2 call special overlap aa
            !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
            !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
             .special_ket(k)[1] = bj1 
           ! .special_ket(k)[2] = bk1
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi1=1,.n_bf
               do bq1=1,.n_bf
                 fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
                    + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                 res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,col_ind,bi1,bq1) * fac ! 
                     end 
               end
               end
             end !do ii , case ii=1 is left
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do row_ind=1,col_ind
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               do bi1=1,.n_bf
               do bq1=1,.n_bf
                 fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
                    + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
                 if( NOT fac.is_zero(.tol)) then
                   res(row_ind) = res(row_ind) + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                 end 
               end
               end
             end
!debug               write(*,*) 'case 2.3.2',dim,res
!case 2.3.3 call special overlap bb
           !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
           !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
             .special_ket(k)[2] = bk2 
             .special_ket(k)[1] = bj2 
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi2=1,.n_bf
               do bq2=1,.n_bf
                 fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
                    + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
                 if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,col_ind,bi2,bq2) * fac ! 
                 end 
               end 
               end
             end !do ii , case ii=1 is left
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do row_ind=1,col_ind
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               do bi2=1,.n_bf
               do bq2=1,.n_bf
                 fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
                    + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
                 if( NOT fac.is_zero(.tol)) then
                   res(row_ind) = res(row_ind) + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
                 end 
               end 
               end
             end
             reorder_bra.destroy
             .special_ket(k)[1] = bk1 
!debug               write(*,*) 'case 2.3.3',dim,res
!case 2.2
             if(bj2/=bk2 OR bj1/=bk1) then
             !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
               fac= temp_q_h2_ja_kb.trace
               if( NOT fac.is_zero(.tol)) then
             !   .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
               end 
               .special_ket(k)[2] = bk2
             !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
               fac= temp_q_h2_jb_ka.trace
               if( NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1 
            !    .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
               end 
               .special_ket(k)[1] = bk1 
             else !bj2==bk2 AND bj1==bk1
               temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
               temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
               fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
               if( NOT fac.is_zero(.tol)) then
         !       .special_ket(k)[1] = bk1 
         !       .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! 
               end 
             end !bj2==bk2 AND bj1==bk1
!debug               write(*,*) 'case 2.2',dim,res
!case 2.1
             if(bj2/=bk2 OR bj1/=bk1) then
               fac= temp_bra_q(bj1,bk2)
               if( NOT fac.is_zero(.tol)) then
              !  .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                 .special_ket(k)[2] = bk2 
               end 
               fac= temp_bra_q(bk1,bj2)
               if( NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1 
               ! .special_ket(k)[2] = bk2
                 res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
                 .special_ket(k)[1] = bk1 
               end 
             else !bj2==bk2 AND bj1==bk1
               fac= temp_bra_q(bk1,bj2) + temp_bra_q(bj1,bk2)
               if( NOT fac.is_zero(.tol)) then
             !   .special_ket(k)[1] = bk1 
             !   .special_ket(k)[2] = bk2
                 res = res - .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
               end
             end !bj2==bk2 AND bj1==bk1
!debug               write(*,*) 'case 2.1',dim,res
           end !do kk
         !  nullify(temp_q_h2_ja_kb)
         !  nullify(temp_q_h2_jb_ka)
         !  temp_qb_h2_jb_ka.destroy
         !  nullify(temp_qb_h2_jb_kb)
         !  nullify(temp_qb_h2_jb_ex_kb)
         !  temp_qa_h2_ja_kb.destroy
         !  nullify(temp_qa_h2_ja_ka)
         !  nullify(temp_qa_h2_ja_ex_ka)
         !  temp_qa_h2_jb_ka.destroy
         !  temp_qb_h2_ja_kb.destroy
!case 1.3
           temp_qa_h2_j=temp_qa_h2(:,:,bj1,bj2)
           temp_qb_h2_j=temp_qb_h2(:,:,bj1,bj2)
           !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
           !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
           !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
           reorder_bra.create(dim-2)
           do ii=dim-1,2,-1
             temp_bra_i => .bra(ii)[:,:]
             reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
             reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
               if( NOT fac.is_zero(.tol)) then
                 res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,col_ind,bq1,bi2) * fac ! 
               end 
             end
             end
           end !ii case ii=1 remains 
           reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
           do row_ind=1,col_ind
             temp_bra_i => .contraction_wfs(row_ind)[:,:]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
               if( NOT fac.is_zero(.tol)) then
                 res(row_ind) = res(row_ind) - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
               end 
             end
             end
           end
           reorder_bra.destroy
!debug               write(*,*) 'case 1.3',dim,res
!case 1.2
           fac=temp_qb_h2_j.trace
           if( NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_ket,col_ind) * fac ! 
           end 
!debug               write(*,*) 'case 1.2',dim,res
!case 1.1
           fac=temp_bra_q(bj1,bj2)
           if( NOT fac.is_zero(.tol)) then
             res = res + .hamiltonian_for(v,reorder_ket,col_ind) * fac ! 
           end 
!debug               write(*,*) 'case 1.1',dim,res
         end !j special ket
       end !do jj
       temp_qa_ja.destroy
       temp_qb_jb.destroy
       temp_qa_h2_ja_ex.destroy
       temp_qb_h2_jb_ex.destroy
       temp_qa_h2_ja.destroy
       temp_qb_h2_jb.destroy
       temp_qa_h2_jb.destroy
       temp_qb_h2_ja.destroy
       temp_qa_h2_j.destroy
       temp_qb_h2_j.destroy
       temp_qa_h2.destroy
       temp_qb_h2.destroy
       reorder_ket.destroy
     end !if dim=1
   end

   hamiltonian_for(v,order_ket,row_ind,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the hamiltonian integrals matrix
   ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
   ! v is the array containing the hf integrals of the 2-electron Hamiltonian.
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     row_ind, col_ind :: INT, IN
     order_ket :: VEC{INT}, IN
     v :: MAT4{REAL}, target, IN
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     ii,jj,kk,i,j,k,l,dim,bi1,bi2,bj1,bj2,bk1,bk2,bq1,bq2 :: INT
     fac :: REAL
     reorder_ket,reorder_bra :: VEC{INT}*
     temp_bra_q :: MAT{REAL}*
     temp_bra_i :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_q_h2 ::  MAT{REAL}*
     temp_qa_h2 :: MAT4{REAL}*
     temp_qb_h2 :: MAT4{REAL}*
     temp_qa_h2_ja :: MAT4{REAL}*
     temp_qa_h2_ja_ex :: MAT4{REAL}*
     temp_qb_h2_jb :: MAT4{REAL}*
     temp_qb_h2_jb_ex :: MAT4{REAL}*
     temp_qa_h2_jb :: MAT4{REAL}*
     temp_qb_h2_ja :: MAT4{REAL}*
     temp_qa_h2_ja_kb :: MAT4{REAL}*
     temp_qa_h2_jb_ka :: MAT4{REAL}*
     temp_qb_h2_jb_ka :: MAT4{REAL}*
     temp_qb_h2_ja_kb :: MAT4{REAL}*
     temp_qa_h2_ja_ka :: MAT4{REAL}*
     temp_qb_h2_jb_kb :: MAT4{REAL}*
     temp_qa_h2_ja_ex_ka :: MAT4{REAL}*
     temp_qb_h2_jb_ex_kb :: MAT4{REAL}*
     temp_qb_jb :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_q_h2_ja_kb :: MAT{REAL}*
     temp_q_h2_jb_ka :: MAT{REAL}*
     temp_qa_h2_j :: MAT{REAL}*
     temp_qb_h2_j :: MAT{REAL}*

     nullify(temp_qa_ja)
     nullify(temp_qb_jb)
     nullify(temp_qa_h2_ja_ex)
     nullify(temp_qb_h2_jb_ex)
     nullify(temp_qa_h2_ja)
     nullify(temp_qb_h2_jb)
     nullify(temp_qa_h2_jb)
     nullify(temp_qb_h2_ja)
     nullify(temp_q_h2_ja_kb)
     nullify(temp_q_h2_jb_ka)
     nullify(temp_qb_h2_jb_kb)
     nullify(temp_qb_h2_jb_ex_kb)
     nullify(temp_qa_h2_ja_ka)
     nullify(temp_qa_h2_ja_ex_ka)
     nullify(temp_qa_h2_ja_kb)
     nullify(temp_qb_h2_jb_ka)
     nullify(temp_qa_h2_jb_ka)
     nullify(temp_qb_h2_ja_kb)
     dim = order_ket.dim
     res = ZERO
      
     if (dim==1) then ! case 1.2 only
       j = order_ket(1)
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         fac = sum(.contraction_wfs(row_ind)[:,:]*v(:,:,bj1,bj2))
       else
         temp_q_h2.create(.n_bf,.n_bf)
         do bj2=1,.n_bf
         do bj1=1,.n_bf
           temp_q_h2(bj1,bj2) = sum(.contraction_wfs(row_ind)[:,:]*v(:,:,bj1,bj2))
         end
         end
         if(j==1) then
           fac = sum(temp_q_h2*.contraction_wfs(col_ind)[:,:])
         else 
           fac = sum(temp_q_h2*.ket(j)[:,:])
         end
         temp_q_h2.destroy
       end
       res = fac
!debug
!debug write(*,*)"jj,j",1,j
!debug write(*,*)"case 1.2, dim", dim
!debug write(*,*)res
!debug
       return
     else ! dim > 1
       temp_bra_q => .bra(dim)[:,:]
       reorder_ket.create(dim-1)
!the next two arrays are created here because they are small and used in all
!cases
       temp_qa_h2_j.create(.n_bf,.n_bf)
       temp_qb_h2_j.create(.n_bf,.n_bf)
       temp_qa_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
       temp_qb_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
       do bj2=1,.n_bf
       do bj1=1,.n_bf
       do bq2=1,.n_bf
       do bq1=1,.n_bf
! respect the bra/ket nature of the indices
         temp_qa_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(:,bq2)*v(:,bq1,bj1,bj2))
         temp_qb_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(bq1,:)*v(bq2,:,bj1,bj2))
       end
       end
       end
       end
       do jj = dim,1,-1
         j = order_ket(jj)
!debug    
!debug write(*,*) "jj,j",jj,j
!debug    
         if (j==1) then !ket from contraction 1
           temp_ket_j => .contraction_wfs(col_ind)[:,:]
           if(temp_qa_h2_ja.destroyed) then
             temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
             temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qa_ja.create(.n_bf,.n_bf)
             temp_qb_jb.create(.n_bf,.n_bf)
           end
           do bj2=1,.n_bf
           do bq2=1,.n_bf
             temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
             temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
           end
           end
           do bj2=1,.n_bf
           do bj1=1,.n_bf
           do bq2=1,.n_bf
           do bq1=1,.n_bf
! respect the bra/ket nature of the indices
             temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
             temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
             temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
             temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
             temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
             temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
           end
           end
           end
           end
!case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk) !cannot be 1
!debug              
!debug write(*,*) "kk,k",kk,k
!debug              
             DIE_IF(k<2,"k cannot be 1")  !debug
             reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) =  k
!debug
!debug     do l=1,dim-1
!debug       stdout.show("l=",l)
!debug       stdout.show("reorder_ket(l)=",reorder_ket(l))
!debug       stdout.show("special_ket(reorder_ket(l))-in",.special_ket(reorder_ket(l)).element)
!debug     end
!debug
             if (.special_ket(k)[1]==0) then !k not special
               temp_ket_k => .ket(k)[:,:]
!case 2.3
               if(temp_qa_h2_ja_kb.destroyed) then
                 temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
                 temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
                 temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
                 temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               end
!case 2.3.1 call special overlap ab
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                 temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                 temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                 temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
               end
               end
               end
               end
               reorder_bra.create(dim-2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     .special_ket(k)[1] = bk1 
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                          + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!debug
!debug write(*,*)"case 2.3.1, dim, ii", dim, ii
!debug write(*,*)res
!debug
                     end 
                     end 
                     end
                   end
                 end
               end !do ii, the case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bj2=1,.n_bf
                 .special_ket(k)[2] = bj2
                 do bk1=1,.n_bf
                   .special_ket(k)[1] = bk1 
                   do bi2=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!debug
!debug write(*,*)"case 2.3.1 ii=1, dim", dim
!debug write(*,*)res
!debug
                     end 
                   end 
                   end
                 end
               end
!debug              
!debug write(*,*) 'case 2.3.1',dim,res
!debug              
!case 2.3.2 call special overlap aa
               temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
               temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                 temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
               end
               end
               end
               end
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bk1=1,.n_bf
                   .special_ket(k)[2] = bk1
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <<
                     end 
                     end 
                     end
                   end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bk1=1,.n_bf
                 .special_ket(k)[2] = bk1
                 do bj1=1,.n_bf
                   .special_ket(k)[1] = bj1 
                   do bi1=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                        + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <
                     end 
                   end 
                   end
                 end
               end
!debug               
!debug write(*,*) 'case 2.3.2',dim,res
!debug              
!case 2.3.3 call special overlap bb
               temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
               temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                 temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
               end
               end
               end
               end
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bk2=1,.n_bf
                   .special_ket(k)[2] = bk2
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                          + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                     end 
                     end
                   end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bk2=1,.n_bf
                 .special_ket(k)[2] = bk2
                 do bj2=1,.n_bf
                   .special_ket(k)[1] = bj2 
                   do bi2=1,.n_bf
                   do bq2=1,.n_bf
                     fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                        + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
                     end 
                   end 
                   end
                 end
               end
               reorder_bra.destroy
!debug               
!debug write(*,*) 'case 2.3.3',dim,res
!debug              
!case 2.2
              ! if(temp_q_h2_ja_kb.destroyed) then
              !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
              !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
              ! end
              ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
              ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
               do bj2=1,.n_bf
                 .special_ket(k)[2] = bj2
                 do bk1=1,.n_bf
                   temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
                   temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
                   fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bk1 
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                 end 
               end
!debug             
!debug write(*,*) 'case 2.2',dim,res
!debug              
!case 2.1
               do bj2=1,.n_bf
                 .special_ket(k)[2] = bj2
                 do bk1=1,.n_bf
                   fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bk1 
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end 
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
!debug               
!debug write(*,*) 'case 2.1',dim,res
!debug              
             else !k special
               bk1=.special_ket(k)[1]
               bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
               !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               reorder_bra.create(dim-2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,bk2-1
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!debug
                     end 
                   end
                   end
                 end
                 do bj2=bk2+1,.n_bf
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!debug
                     end 
                   end 
                   end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   .special_ket(k)[1] = bj1 
              !    .special_ket(k)[2] = bk2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!debug
                     end 
                   end 
                   end
                 end
                 do bj1=bk1+1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!debug
                     end 
                   end 
                   end
                 end
                 .special_ket(k)[1] = bk1 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                !   .special_ket(k)[1] = bk1 
                !   .special_ket(k)[2] = bk2
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug write(*,*)"ii,bq1,bi2,fac,res",ii,bq1,bi2,fac,res
!debug
                     end 
                 end 
                 end 
               end !do ii, the case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bj2=1,bk2-1
            !    .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!debug
                     end 
                 end
                 end
               end
               do bj2=bk2+1,.n_bf
               ! .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!debug
                     end 
                 end 
                 end 
               end
               .special_ket(k)[2] = bk2 
               do bj1=1,bk1-1
                 .special_ket(k)[1] = bj1 
            !    .special_ket(k)[2] = bk2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!debug
                     end 
                 end 
                 end
               end
               do bj1=bk1+1,.n_bf
                 .special_ket(k)[1] = bj1 
             !   .special_ket(k)[2] = bk2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
!debug
!debug stdout.show("special_ket(k)-out",.special_ket(k).element)
!debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!debug
                     end 
                 end 
                 end
               end
               .special_ket(k)[1] = bk1 
               do bq1=1,.n_bf
               do bi2=1,.n_bf
                 fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                    + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                    + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                    + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
              !   .special_ket(k)[1] = bk1 
              !   .special_ket(k)[2] = bk2
!debug
!debug stdout.show("special_ket(k)-in",.special_ket(k).element)
!debug
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
!debug
!debug stdout.show("special_ket(k)-out",.special_ket(k).element)
!debug write(*,*)"bq1,bi2,fac,res",bq1,bi2,fac,res
!debug
                     end 
               end 
               end 
               .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!debug               
!debug write(*,*) 'case 2.3.1',dim,res
!debug              
!case 2.3.2 call special overlap aa
              !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
              !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj1=1,.n_bf
                   .special_ket(k)[1] = bj1 
             !     .special_ket(k)[2] = bk1
                   do bi1=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                        + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <
                     end 
                   end 
                   end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bj1=1,.n_bf
                 .special_ket(k)[1] = bj1 
             !   .special_ket(k)[2] = bk1
                 do bi1=1,.n_bf
                 do bq1=1,.n_bf
                   fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                      + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                 end 
                 end
               end
               .special_ket(k)[2] = bk2 
!debug               
!debug write(*,*) 'case 2.3.2',dim,res
!debug              
!case 2.3.3 call special overlap bb
             !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
             !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[1] = bj2 
               !   .special_ket(k)[2] = bk2
                   do bi2=1,.n_bf
                   do bq2=1,.n_bf
                     fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                        + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                   end 
                   end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
           !debug    write(*,*) 'coucou1'
           !debug    stdout.put(temp_bra_i)
               do bj2=1,.n_bf
                 .special_ket(k)[1] = bj2 
              !  .special_ket(k)[2] = bk2
                 do bi2=1,.n_bf
                 do bq2=1,.n_bf
                   fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                      + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
                     end 
           !debug    if(NOT fac.is_zero(.tol)) then
           !debug    write(*,*) 'bj2,bk2,bi2,bq2,fac',bj2,bk2,bi2,bq2,fac
           !debug    end
                 end 
                 end
               end
               .special_ket(k)[1] = bk1 
               reorder_bra.destroy
!debug               
!debug write(*,*) 'case 2.3.3',dim,res
!debug              
!case 2.2
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               do bj2=1,bk2-1
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                 fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
               !  .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
               end
               do bj2=bk2+1,.n_bf
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                 fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
               !  .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
               end
               .special_ket(k)[2] = bk2
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               do bj1=1,bk1-1
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                 fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1 
              !   .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
               end
               do bj1=bk1+1,.n_bf
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                 fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1 
              !   .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
               end
               .special_ket(k)[1] = bk1 
               temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
               temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
               fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
           !    .special_ket(k)[1] = bk1 
           !    .special_ket(k)[2] = bk2
               res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
!debug               
!debug write(*,*) 'case 2.2',dim,res
!debug              
!case 2.1
               do bj2=1,bk2-1
                 fac= temp_qa_ja(bk2,bj2)
                 if( NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
               do bj2=bk2+1,.n_bf
                 fac= temp_qa_ja(bk2,bj2)
                 if( NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
               .special_ket(k)[2] = bk2 
               do bj1=1,bk1-1
                 fac= temp_qb_jb(bk1,bj1)
                 if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
               do bj1=bk1+1,.n_bf
                 fac= temp_qb_jb(bk1,bj1)
                 if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
               .special_ket(k)[1] = bk1 
               fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
               if( NOT fac.is_zero(.tol)) then
               !  .special_ket(k)[1] = bk1 
               !  .special_ket(k)[2] = bk2
                 res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
               end
!debug               
!debug write(*,*) 'case 2.1',dim,res
!debug              
             end !k special
           end !do kk
           nullify(temp_q_h2_ja_kb)
           nullify(temp_q_h2_jb_ka)
           temp_qb_h2_jb_ka.destroy
           nullify(temp_qb_h2_jb_kb)
           nullify(temp_qb_h2_jb_ex_kb)
           temp_qa_h2_ja_kb.destroy
           nullify(temp_qa_h2_ja_ka)
           nullify(temp_qa_h2_ja_ex_ka)
           temp_qa_h2_jb_ka.destroy
           temp_qb_h2_ja_kb.destroy
!case 1.3
           temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
           temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
           !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
           !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
           !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
           reorder_bra.create(dim-2)
           do ii=dim-1,2,-1
             temp_bra_i => .bra(ii)[:,:]
             reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
             reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
               res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
             end
             end
           end !ii case ii=1 remains 
           temp_bra_i => .contraction_wfs(row_ind)[:,:]
           reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
           do bi2=1,.n_bf
           do bq1=1,.n_bf
             fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
             res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
           end
           end
           reorder_bra.destroy
!debug               
!debug write(*,*) 'case 1.3',dim,res
!debug              
!case 1.2
           fac=temp_qb_h2_j.trace
                     if( NOT fac.is_zero(.tol)) then
           res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
!debug               
!debug write(*,*) 'case 1.2',dim,res
!debug              
!case 1.1
           fac=temp_qb_jb.trace
                     if( NOT fac.is_zero(.tol)) then
           res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                     end 
!debug               
!debug write(*,*) 'case 1.1',dim,res
!debug              
         else !j>1
           if (.special_ket(j)[1]==0) then !j not special
             temp_ket_j => .ket(j)[:,:]
             if(temp_qa_h2_ja.destroyed) then
               temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
               temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qa_ja.create(.n_bf,.n_bf)
               temp_qb_jb.create(.n_bf,.n_bf)
             end
             do bj2=1,.n_bf
             do bq2=1,.n_bf
               temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
               temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
             end
             end
             do bj2=1,.n_bf
             do bj1=1,.n_bf
             do bq2=1,.n_bf
             do bq1=1,.n_bf
! respect the bra/ket nature of the indices
               temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
               temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
               temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
               temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
               temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
               temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
             end
             end
             end
             end
!case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk) !cannot be 1
!debug               
!debug write(*,*) 'kk,k',kk,k
!debug               
               DIE_IF(k<2,"k cannot be 1")  !debug
               reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) =  k
               if (.special_ket(k)[1]==0) then !k not special
                 temp_ket_k => .ket(k)[:,:]
!case 2.3
                 if(temp_qa_h2_ja_kb.destroyed) then
                   temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
                   temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
                   temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
                   temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
                 end
!case 2.3.1 call special overlap ab
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                   temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                   temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                   temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                 end
                 end
                 end
                 end
                 reorder_bra.create(dim-2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,.n_bf
                     .special_ket(k)[2] = bj2
                     do bk1=1,.n_bf
                       .special_ket(k)[1] = bk1 
                       do bq1=1,.n_bf
                       do bi2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                            + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                            + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                            + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                         res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                       end 
                       end
                     end
                   end
                 end !do ii, the case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     .special_ket(k)[1] = bk1 
                     do bi2=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                          + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
                     end 
                     end 
                     end
                   end
                 end
!debug               
!debug write(*,*) 'case 2.3.1',dim,res
!debug              
!case 2.3.2 call special overlap aa
                 temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
                 temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                   temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                 end
                 end
                 end
                 end
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bk1=1,.n_bf
                     .special_ket(k)[2] = bk1
                     do bj1=1,.n_bf
                       .special_ket(k)[1] = bj1 
                       do bi1=1,.n_bf
                       do bq1=1,.n_bf
                         fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                            + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                         res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <<
                     end 
                       end 
                       end
                     end
                   end
                 end !do ii , case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bk1=1,.n_bf
                   .special_ket(k)[2] = bk1
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb_kb(bi1,:,bj1,bk1)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                     end 
                     end
                   end
                 end
!debug               
!debug write(*,*) 'case 2.3.2',dim,res
!debug              
!case 2.3.3 call special overlap bb
                 temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
                 temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                   temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                 end
                 end
                 end
                 end
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bk2=1,.n_bf
                     .special_ket(k)[2] = bk2
                     do bj2=1,.n_bf
                       .special_ket(k)[1] = bj2 
                       do bi2=1,.n_bf
                       do bq2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                            + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                         res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
                     end 
                       end 
                       end
                     end
                   end
                 end !do ii , case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bk2=1,.n_bf
                   .special_ket(k)[2] = bk2
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex_ka(:,bq2,bj2,bk2)*temp_bra_i(:,bi2))     &
                          + sum(temp_qa_h2_ja_ka(:,bi2,bj2,bk2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                     end 
                     end
                   end
                 end
                 reorder_bra.destroy
!debug               
!debug write(*,*) 'case 2.3.3',dim,res
!debug              
!case 2.2
                ! if(temp_q_h2_ja_kb.destroyed) then
                !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
                !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
                ! end
                ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
                ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
                     temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
                     fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bk1 
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                   end 
                 end
!debug               
!debug write(*,*) 'case 2.2',dim,res
!debug              
!case 2.1
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
                     if( NOT fac.is_zero(.tol)) then
                       .special_ket(k)[1] = bk1 
                       res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                   end 
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
!debug               
!debug write(*,*) 'case 2.1',dim,res
!debug              
               else !k special
                 bk1=.special_ket(k)[1]
                 bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
                 !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
                 !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
                 !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 reorder_bra.create(dim-2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,bk2-1
                !    .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end
                     end
                   end
                   do bj2=bk2+1,.n_bf
                   ! .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end 
                     end 
                   end
                   .special_ket(k)[2] = bk2 
                   do bj1=1,bk1-1
                     .special_ket(k)[1] = bj1 
                !    .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end 
                     end
                   end
                   do bj1=bk1+1,.n_bf
                     .special_ket(k)[1] = bj1 
                 !   .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end 
                     end
                   end
                   .special_ket(k)[1] = bk1 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end 
                   end 
                 end !do ii, the case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bj2=1,bk2-1
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                 end
                 end
                 end
                 do bj2=bk2+1,.n_bf
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                 end 
                 end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   .special_ket(k)[1] = bj1 
              !    .special_ket(k)[2] = bk2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                 end 
                 end
                 end
                 do bj1=bk1+1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                 end 
                 end
                 end
                 .special_ket(k)[1] = bk1 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                !   .special_ket(k)[1] = bk1 
                !   .special_ket(k)[2] = bk2
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                 end 
                 end 
                 .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!debug               
!debug write(*,*) 'case 2.3.1',dim,res
!debug              
!case 2.3.2 call special overlap aa
                !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
                !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
               !     .special_ket(k)[2] = bk1
                   do bi1=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                        + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                   end 
                   end
                   end
                 end !do ii , case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bj1=1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk1
                 do bi1=1,.n_bf
                 do bq1=1,.n_bf
                   fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                      + sum(temp_qb_h2_jb(bi1,:,bj1,bk2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                 end 
                 end
                 end
                 .special_ket(k)[2] = bk2 
!debug               
!debug write(*,*) 'case 2.3.2',dim,res
!debug              
!case 2.3.3 call special overlap bb
               !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
               !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                 !   .special_ket(k)[2] = bk2
                   do bi2=1,.n_bf
                   do bq2=1,.n_bf
                     fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                        + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                   end 
                   end
                   end
                 end !do ii , case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[1] = bj2 
                !  .special_ket(k)[2] = bk2
                 do bi2=1,.n_bf
                 do bq2=1,.n_bf
                   fac= sum(temp_qa_h2_ja_ex(:,bq2,bk1,bj2)*temp_bra_i(:,bi2))     &
                      + sum(temp_qa_h2_ja(:,bi2,bk1,bj2)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                 end 
                 end
                 end
                 .special_ket(k)[1] = bk1 
                 reorder_bra.destroy
!debug               
!debug write(*,*) 'case 2.3.3',dim,res
!debug              
!case 2.2
                 !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 do bj2=1,bk2-1
                   temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                   fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                 end
                 do bj2=bk2+1,.n_bf
                   temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                   fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                 end
                 .special_ket(k)[2] = bk2
                 !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 do bj1=1,bk1-1
                   temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                   fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                !  .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                 end
                 do bj1=bk1+1,.n_bf
                   temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                   fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                !  .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                 end
                 .special_ket(k)[1] = bk1 
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
                 fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
             !    .special_ket(k)[1] = bk1 
             !    .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
!debug               
!debug write(*,*) 'case 2.2',dim,res
!debug              
!case 2.1
                 do bj2=1,bk2-1
                   fac= temp_qa_ja(bk2,bj2)
                   if( NOT fac.is_zero(.tol)) then
                  !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
                 do bj2=bk2+1,.n_bf
                   fac= temp_qa_ja(bk2,bj2)
                   if( NOT fac.is_zero(.tol)) then
                  !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   fac= temp_qb_jb(bk1,bj1)
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                   ! .special_ket(k)[2] = bk2
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
                 do bj1=bk1+1,.n_bf
                   fac= temp_qb_jb(bk1,bj1)
                   if( NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                   ! .special_ket(k)[2] = bk2
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
                 .special_ket(k)[1] = bk1 
                 fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
                 if( NOT fac.is_zero(.tol)) then
                 !  .special_ket(k)[1] = bk1 
                 !  .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end
!debug               
!debug write(*,*) 'case 2.1',dim,res
!debug              
               end !k special
             end !do kk
             nullify(temp_q_h2_ja_kb)
             nullify(temp_q_h2_jb_ka)
             temp_qb_h2_jb_ka.destroy
             nullify(temp_qb_h2_jb_kb)
             nullify(temp_qb_h2_jb_ex_kb)
             temp_qa_h2_ja_kb.destroy
             nullify(temp_qa_h2_ja_ka)
             nullify(temp_qa_h2_ja_ex_ka)
             temp_qa_h2_jb_ka.destroy
             temp_qb_h2_ja_kb.destroy
!case 1.3
             temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
             temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
             !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
             !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
             !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
             reorder_bra.create(dim-2)
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
                 res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
               end
               end
             end !ii case ii=1 remains 
             temp_bra_i => .contraction_wfs(row_ind)[:,:]
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
               res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
             end
             end
             reorder_bra.destroy
!debug               
!debug write(*,*) 'case 1.3',dim,res
!debug              
!case 1.2
             fac=temp_qb_h2_j.trace
                     if( NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
!debug               
!debug write(*,*) 'case 1.2',dim,res
!debug              
!case 1.1
             fac=temp_qb_jb.trace
                     if( NOT fac.is_zero(.tol)) then
             res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                     end 
!debug               
!debug write(*,*) 'case 1.1',dim,res
!debug              
           else ! j is a special ket
! warning: we have not changed the structure with respect to the case "not a
! special ket", therefore more space than needed is used and large parts of the
! arrays are dangerously not initialized.
             bj1=.special_ket(j)[1]
             bj2=.special_ket(j)[2]
!case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk) !cannot be 1
!debug               
!debug write(*,*) 'kk,k',kk,k
!debug               
               DIE_IF(k<2,"k cannot be 1")  !debug
               reorder_ket(jj:kk-2)  = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) =  k
               DIE_IF(.special_ket(k)[1]==0,"j special ket but not k") 
               bk1=.special_ket(k)[1]
               bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
               !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               reorder_bra.create(dim-2)
               if(bj2/=bk2 OR bj1/=bk1) then
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end
                   end
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end
                   end
                   .special_ket(k)[1] = bk1 
                 end !do ii, the case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
            !    .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end
                 end
                 .special_ket(k)[1] = bj1 
                 .special_ket(k)[2] = bk2 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end
                 end
                 .special_ket(k)[1] = bk1 
               else !bj1==bk1 AND bj2==bk2
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
                !     .special_ket(k)[1] = bk1 
                !     .special_ket(k)[2] = bk2
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                   end 
                   end 
                 end !do ii, the case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     if( NOT fac.is_zero(.tol)) then
              !     .special_ket(k)[1] = bk1 
              !     .special_ket(k)[2] = bk2
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                 end 
                 end 
               end !bj1==bk1 AND bj2==bk2
               .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!debug               
!debug write(*,*) 'case 2.3.1',dim,res
!debug              
!case 2.3.2 call special overlap aa
              !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
              !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
               .special_ket(k)[1] = bj1 
             ! .special_ket(k)[2] = bk1
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bi1=1,.n_bf
                 do bq1=1,.n_bf
                   fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
                      + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                 end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bi1=1,.n_bf
               do bq1=1,.n_bf
                 fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
                    + sum(temp_qb_h2(bi1,:,bk2,bj2)*temp_bra_i(bq1,:))       
                     if( NOT fac.is_zero(.tol)) then
                 res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
               end
               end
!debug               
!debug write(*,*) 'case 2.3.2',dim,res
!debug              
!case 2.3.3 call special overlap bb
             !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
             !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
               .special_ket(k)[2] = bk2 
               .special_ket(k)[1] = bj2 
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bi2=1,.n_bf
                 do bq2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
                      + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                   res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
                     end 
                 end 
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bi2=1,.n_bf
               do bq2=1,.n_bf
                 fac= sum(temp_qa_h2(:,bq2,bk1,bj1)*temp_bra_i(:,bi2))     &
                    + sum(temp_qa_h2(:,bi2,bj1,bk1)*temp_bra_i(:,bq2))       
                     if( NOT fac.is_zero(.tol)) then
                 res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
                     end 
               end 
               end
               .special_ket(k)[1] = bk1 
               reorder_bra.destroy
!debug               
!debug write(*,*) 'case 2.3.3',dim,res
!debug              
!case 2.2
               if(bj2/=bk2 OR bj1/=bk1) then
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
                 fac= temp_q_h2_ja_kb.trace
                     if( NOT fac.is_zero(.tol)) then
               !  .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                 .special_ket(k)[2] = bk2
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
                 fac= temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1 
              !   .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                 .special_ket(k)[1] = bk1 
               else !bj2==bk2 AND bj1==bk1
                 temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
                 temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
                 fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     if( NOT fac.is_zero(.tol)) then
           !     .special_ket(k)[1] = bk1 
           !     .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
               end !bj2==bk2 AND bj1==bk1
!debug               
!debug write(*,*) 'case 2.2',dim,res
!debug              
!case 2.1
               if(bj2/=bk2 OR bj1/=bk1) then
                 fac= temp_bra_q(bj1,bk2)
                 if( NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   .special_ket(k)[2] = bk2 
                 end 
                 fac= temp_bra_q(bk1,bj2)
                 if( NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   .special_ket(k)[1] = bk1 
                 end 
               else !bj2==bk2 AND bj1==bk1
                 fac= temp_bra_q(bk1,bj2) + temp_bra_q(bj1,bk2)
                 if( NOT fac.is_zero(.tol)) then
               !   .special_ket(k)[1] = bk1 
               !   .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end
               end !bj2==bk2 AND bj1==bk1
!debug               
!debug write(*,*) 'case 2.1',dim,res
!debug              
             end !do kk
!             nullify(temp_q_h2_ja_kb)
!             nullify(temp_q_h2_jb_ka)
!             temp_qb_h2_jb_ka.destroy
!             nullify(temp_qb_h2_jb_kb)
!             nullify(temp_qb_h2_jb_ex_kb)
!             temp_qa_h2_ja_kb.destroy
!             nullify(temp_qa_h2_ja_ka)
!             nullify(temp_qa_h2_ja_ex_ka)
!             temp_qa_h2_jb_ka.destroy
!             temp_qb_h2_ja_kb.destroy
!case 1.3
             temp_qa_h2_j=temp_qa_h2(:,:,bj1,bj2)
             temp_qb_h2_j=temp_qb_h2(:,:,bj1,bj2)
             !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
             !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
             !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1)  = order_ket(jj+1:dim) 
             reorder_bra.create(dim-2)
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
                 res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
               end
               end
             end !ii case ii=1 remains 
             temp_bra_i => .contraction_wfs(row_ind)[:,:]
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                     if( NOT fac.is_zero(.tol)) then
               res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
             end
             end
             reorder_bra.destroy
!debug               
!debug write(*,*) 'case 1.3',dim,res
!debug              
  !case 1.2
             fac=temp_qb_h2_j.trace
                     if( NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                     end 
!debug               
!debug write(*,*) 'case 1.2',dim,res
!debug              
  !case 1.1
             fac=temp_bra_q(bj1,bj2)
                     if( NOT fac.is_zero(.tol)) then
             res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                     end 
!debug               
!debug write(*,*) 'case 1.1',dim,res
!debug              
           end !j special ket
         end !if j=1
       end !do jj
       temp_qa_h2_ja.destroy
       temp_qb_h2_jb.destroy
       temp_qa_h2_jb.destroy
       temp_qb_h2_ja.destroy
       temp_qa_h2_ja_ex.destroy
       temp_qb_h2_jb_ex.destroy
       temp_qa_ja.destroy
       temp_qb_jb.destroy
       temp_qa_h2_j.destroy
       temp_qb_h2_j.destroy
       temp_qa_h2.destroy
       temp_qb_h2.destroy
       reorder_ket.destroy
     end !if dim=1
   end

   overlap_for(order_bra,order_ket) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix between
   ! mean field (Sz=0)-geminals (upper triangle only is evaluated)
!comments:
!special_ket are always created at the end so that if jj is a special ket,
!than kk>jj is also a special ket.
     order_bra, order_ket :: VEC{INT}, IN
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(.special_ket(1)[1]==0,".special_ket(1) already set")
     ENSURE(order_ket.dim==order_bra.dim,"dim of bra not equal to dim of ket")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     row_ind,col_ind :: INT
     q,jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
     reorder_ket :: VEC{INT}*
     reorder_bra :: VEC{INT}*
     fac :: REAL
     temp_bra_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_qb_jb :: MAT{REAL}*

     dim = order_ket.dim
     q=order_bra(dim)
     res = ZERO
      
     if (dim==1) then ! only Case 1
       j = order_ket(1)
       DIE_IF(j/=1,"dim is 1 but j is not 1")
       DIE_IF(q/=1,"dim is 1 but q is not 1")
       do col_ind=1,.n_bas 
         temp_ket_j => .contraction_wfs(col_ind)[:,:]
         do row_ind=1,col_ind
           fac = sum(.contraction_wfs(row_ind)[:,:]*temp_ket_j)
           if (NOT fac.is_zero(.tol)) then
             res(row_ind,col_ind)=fac !permit to set to zero numbers below a threshold
           end
         end
       end
       return
     else ! dim > 1
       DIE_IF(q==1,"q=1 but dim is more than 1")
       reorder_bra.create(dim-1)
       reorder_bra(1:dim-1)   = [ (order_bra(l), l=1,dim-1) ]
       temp_bra_q => .bra(q)[:,:]
       reorder_ket.create(dim-1)
       temp_qa_ja.create(.n_bf,.n_bf)
       temp_qb_jb.create(.n_bf,.n_bf)
       do jj = dim,1,-1
         j = order_ket(jj)
         if (j==1) then ! 1 not special
           do col_ind=1,.n_bas
             temp_ket_j => .contraction_wfs(col_ind)[:,:]
             do bj1=1,.n_bf
             do bq1=1,.n_bf
               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
             end
             end
  ! Case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               if (.special_ket(k)[1]>0) then ! k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 do bj1 = 1,bk1-1
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj1 = bk1+1,.n_bf
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj2 = 1,bk2-1
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 do bj2 = bk2+1,.n_bf
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                 end
               else ! k not special
                 temp_ket_k => .ket(k)[:,:]
                 do bk2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                     .special_ket(k)[2] = bk2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                   end
                 end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
               end  ! if (.special_ket(k)
             end !do kk
  ! Case 1
             !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_qb_jb.trace
             if (NOT fac.is_zero(.tol)) then
               res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
             end
           end !do col_ind
         else ! j>1 
           if (.special_ket(j)[1]>0) then
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
! Case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!debug              if(.special_ket(k)[1]==0) then
!debug     write(*,*) "j special but not k"
!debug     stdout.show("dim=",dim)
!debug     do l=1,dim
!debug       stdout.show("l=",l)
!debug       stdout.show("order_ket(l)=",order_ket(l))
!debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!debug     end
!debug     stop
!debug     end
!assume special_ket's are also ordered at the end in the initial guess
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if(bj1/=bk1 OR bj2/=bk2) then
                 fac=temp_bra_q(bk1,bj2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
                 fac=temp_bra_q(bj1,bk2)
                 if (NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               else ! bj1==bk1 AND bj2==bk2
                 fac=TWO * temp_bra_q(bk1,bk2)
                 if (NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                 end
               end ! bj1==bk1 AND bj2==bk2
             end !do kk
! Case 1
             !reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_bra_q(bj1,bj2)
             if (NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_bra,reorder_ket) * fac ! <<
             end
           else !j not special
             temp_ket_j => .ket(j)[:,:]
             do bj1=1,.n_bf
             do bq1=1,.n_bf
               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
             end
             end
! Case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               if (.special_ket(k)[1]>0) then ! k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 do bj1 = 1,bk1-1
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj1 = bk1+1,.n_bf
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj2 = 1,bk2-1
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 do bj2 = bk2+1,.n_bf
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                 end
               else ! k not special
                 temp_ket_k => .ket(k)[:,:]
                 do bk2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                     .special_ket(k)[2] = bk2
                     res = res - .overlap_for(reorder_bra,reorder_ket) * fac ! <<
                   end
                 end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
               end  ! if (.special_ket(k)
             end !do kk
! Case 1
            ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_qb_jb.trace
             if (NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_bra,reorder_ket) * fac ! <<
             end
           end !j not special
         end !if(j==1 AND .special_ket(1)==0) else
       end  !do jj=dim,1,-1
     temp_qa_ja.destroy
     temp_qb_jb.destroy
     reorder_ket.destroy
     end ! if(dim==1)
     reorder_bra.destroy
   end

   overlap_for(order_bra,order_ket,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals column
   ! vector specified by col_ind between mean field (Sz=0)-geminals 
   ! upper half only is evaluated.
!comments:
!special_ket are always created at the end so that if jj is a special ket,
!than kk>jj is also a special ket. 
     col_ind :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: VEC{REAL}(.n_bas)
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim==order_bra.dim,"dim of bra not equal to dim of ket")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     row_ind :: INT
     q,jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
     reorder_ket :: VEC{INT}*
     reorder_bra :: VEC{INT}*
     fac :: REAL
     temp_bra_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_qb_jb :: MAT{REAL}*

     dim = order_ket.dim
     q=order_bra(dim)
     res=ZERO

     if (dim==1) then ! only Case 1
       j = order_ket(1)
       DIE_IF(q/=1,"dim is 1 but q is not 1")
       DIE_IF(j==1,"ket of contraction 1 has already appeared")
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         do row_ind=1,col_ind
           fac = .contraction_wfs(row_ind)[bj1,bj2]
           if (NOT fac.is_zero(.tol)) then
             res(row_ind)=fac !permit to set to zero numbers below a threshold
           end
         end
       else 
         temp_ket_j => .ket(j)[:,:]
         do row_ind=1,col_ind
           fac = sum(.contraction_wfs(row_ind)[:,:]*temp_ket_j)
           if (NOT fac.is_zero(.tol)) then
             res(row_ind)=fac !permit to set to zero numbers below a threshold
           end
         end
       end
       return
     else ! dim > 1
       DIE_IF(q==1,"q=1 but dim is more than 1")
       reorder_bra.create(dim-1)
       reorder_bra(1:dim-1)   = [ (order_bra(l), l=1,dim-1) ]
       temp_bra_q => .bra(q)[:,:]
       reorder_ket.create(dim-1)
       temp_qa_ja.create(.n_bf,.n_bf)
       temp_qb_jb.create(.n_bf,.n_bf)
       do jj = dim,1,-1
         j = order_ket(jj)
         DIE_IF(j==1,"ket of contraction 1 has already appeared")
         if (.special_ket(j)[1]>0) then
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! Case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk)
!debug             if(.special_ket(k)[1]==0)then
!debug               write(*,*) "j special but not k"
!debug               stdout.show("dim=",dim)
!debug               do l=1,dim
!debug                 stdout.show("l=",l)
!debug                 stdout.show("order_ket(l)=",order_ket(l))
!debug                 stdout.show("special_ket(order_ket(l))",.special_ket(order_ket(l)).element)
!debug               end
!debug               write(*,*) "kk,k",kk,k
!debug               write(*,*) "jj,j",jj,j
!debug               stop
!debug             end
             DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!assume special_ket's are also ordered at the end in the initial guess
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) = k 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
             if(bj1/=bk1 OR bj2/=bk2) then
               fac=temp_bra_q(bk1,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                 .special_ket(k)[1] = bk1
               end
               fac=temp_bra_q(bj1,bk2)
               if (NOT fac.is_zero(.tol)) then
              !  .special_ket(k)[1] = bk1
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                 .special_ket(k)[2] = bk2
               end
             else ! bj1==bk1 AND bj2==bk2
               fac=TWO * temp_bra_q(bk1,bk2)
               if (NOT fac.is_zero(.tol)) then
              !  .special_ket(k)[1] = bk1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
               end
             end ! bj1==bk1 AND bj2==bk2
           end !do kk
! Case 1
         !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
           fac = temp_bra_q(bj1,bj2)
           if (NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
           end
         else !j not special
           temp_ket_j => .ket(j)[:,:]
           do bj1=1,.n_bf
           do bq1=1,.n_bf
             temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
             temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
           end
           end
! Case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk)
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) = k 
             if (.special_ket(k)[1]>0) then ! k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               do bj1 = 1,bk1-1
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj1 = bk1+1,.n_bf
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj2 = 1,bk2-1
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               do bj2 = bk2+1,.n_bf
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
               if (NOT fac.is_zero(.tol)) then
               ! .special_ket(k)[1] = bk1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
               end
             else ! k not special
               temp_ket_k => .ket(k)[:,:]
               do bk2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
                 end
               end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end  ! if (.special_ket(k)
           end !do kk
! Case 1
         !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
           fac = temp_qb_jb.trace
           if (NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_bra,reorder_ket,col_ind) * fac ! <<
           end
         end !j not special
       end  !do jj=dim,1,-1
     temp_qa_ja.destroy
     temp_qb_jb.destroy
     reorder_ket.destroy
     end ! if(dim==1)
     reorder_bra.destroy
   end

   overlap_for(order_bra,order_ket,row_ind,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix
   ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!comments:
!special_ket are always created at the end so that if jj is a special ket,
!than kk>jj is also a special ket.
     row_ind, col_ind :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim==order_bra.dim,"dim of bra not equal to dim of ket")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     q,jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
     reorder_ket :: VEC{INT}*
     reorder_bra :: VEC{INT}*
     fac :: REAL
     temp_bra_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_qb_jb :: MAT{REAL}*

     dim = order_ket.dim
     q=order_bra(dim)
     if(q==1) then
       temp_bra_q => .contraction_wfs(row_ind)[:,:]
     else
       temp_bra_q => .bra(q)[:,:]
     end
     reorder_bra.create(dim-1)
     reorder_bra(1:dim-1)   = [ (order_bra(l), l=1,dim-1) ]
     res = ZERO
      
     if (dim==1) then ! only Case 1
       j = order_ket(1)
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         fac = temp_bra_q(bj1,bj2)
       else if(.special_ket(j)[1]==0 AND j==1) then
         fac = sum(temp_bra_q*.contraction_wfs(col_ind)[:,:])
       else if (.special_ket(j)[1]==0 AND j/=1) then
         fac = sum(temp_bra_q*.ket(j)[:,:])
       end
       if (NOT fac.is_zero(.tol)) then
          res = fac
       end
       return
     else ! dim > 1
       reorder_ket.create(dim-1)
       temp_qa_ja.create(.n_bf,.n_bf)
       temp_qb_jb.create(.n_bf,.n_bf)
       do jj = dim,1,-1
         j = order_ket(jj)
         if (j==1 AND .special_ket(1)[1]==0) then ! 1 not special
           temp_ket_j => .contraction_wfs(col_ind)[:,:]
           do bj1=1,.n_bf
           do bq1=1,.n_bf
             temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
             temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
           end
           end
! Case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk)
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) = k 
             if (.special_ket(k)[1]>0) then ! k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               do bj1 = 1,bk1-1
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj1 = bk1+1,.n_bf
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj2 = 1,bk2-1
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               do bj2 = bk2+1,.n_bf
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
               if (NOT fac.is_zero(.tol)) then
               ! .special_ket(k)[1] = bk1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
               end
             else ! k not special
               temp_ket_k => .ket(k)[:,:]
               do bk2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end  ! if (.special_ket(k)
           end !do kk
! Case 1
         !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
           fac = temp_qb_jb.trace
           if (NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
           end
         else ! j>1 or 1 special
           if (.special_ket(j)[1]>0) then
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
! Case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!debug              if(.special_ket(k)[1]==0) then
!debug     write(*,*) "j special but not k"
!debug     stdout.show("dim=",dim)
!debug     do l=1,dim
!debug       stdout.show("l=",l)
!debug       stdout.show("order_ket(l)=",order_ket(l))
!debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!debug     end
!debug     stop
!debug     end
!assume special_ket's are also ordered at the end in the initial guess
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if(bj1/=bk1 OR bj2/=bk2) then
                 fac=temp_bra_q(bk1,bj2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
                 fac=temp_bra_q(bj1,bk2)
                 if (NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               else ! bj1==bk1 AND bj2==bk2
                 fac=TWO * temp_bra_q(bk1,bk2)
                 if (NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               end ! bj1==bk1 AND bj2==bk2
             end !do kk
! Case 1
        !     reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_bra_q(bj1,bj2)
             if (NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
             end
           else !j not special
             temp_ket_j => .ket(j)[:,:]
             do bj1=1,.n_bf
             do bq1=1,.n_bf
               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
             end
             end
! Case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               if (.special_ket(k)[1]>0) then ! k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 do bj1 = 1,bk1-1
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj1 = bk1+1,.n_bf
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj2 = 1,bk2-1
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 do bj2 = bk2+1,.n_bf
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               else ! k not special
                 temp_ket_k => .ket(k)[:,:]
                 do bk2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                     .special_ket(k)[2] = bk2
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   end
                 end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
               end  ! if (.special_ket(k)
             end !do kk
! Case 1
           !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_qb_jb.trace
             if (NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
             end
           end !j not special
         end !if(j==1 AND .special_ket(1)==0) else
       end  !do jj=dim,1,-1
     temp_qa_ja.destroy
     temp_qb_jb.destroy
     reorder_ket.destroy
     end ! if(dim==1)
     reorder_bra.destroy
   end

!It is possible to speed up a bit the
!special_overlap_spin_xy_for(order_bra,order_ket,row_ind,col_ind,b1,b2) routines
!by taking into account the fact that the bra and ket of contraction 1 have already been
!found when it is called when performing an Hamiltonian matrix calculation,
!however the routine won't work afterwards when only a single Hamiltonian matrix
!element is calculated with hamiltonian_for(v,order_ket,row_ind,col_ind).

   special_overlap_spin_ab_for(order_bra,order_ket,b1,b2) result (res) ::: recursive
   ! Special function which evaluates the overlap integrals matrix between
   ! mean field (Sz=0)-geminals when .bra(dim) is a special bra
!comments: should not be called if dim=1 because row_ind would
! be already defined.
     b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(1)[2]==0,"special ket already set for contraction 1")
     col_ind :: INT
     dim,bq1,bq2,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     DIE_IF(q==1,"ket of contraction 1 not in place")
     res = ZERO
     
     if(.special_ket(q)[2]==0) then !not a special ket
       temp_ket_q => .ket(q)[:,:]
       do bq1=1,.n_bf
         .special_ket(q)[1]=bq1
         do bq2=1,.n_bf
           if (NOT temp_ket_q(bq1,bq2).is_zero) then
             .special_ket(q)[2]=bq2
             res=res+.special_overlap_spin_ab_for(order_bra,order_ket,b1,b2) &
                   *temp_ket_q(bq1,bq2) 
           end
         end
       end
       .special_ket(q)[1]=0
       .special_ket(q)[2]=0
       return
     end
! at this stage q is necessarily a special ket and dim>1
     reorder_ket.create(dim-1)
     do jj = dim,1,-1
        j = order_ket(jj)
        reorder_ket(1:jj-1)   = order_ket(1:jj)
        reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
        if (.special_ket(j)[1]>0) then  !j special
          bj1 = .special_ket(j)[1]
          bj2 = .special_ket(j)[2]
! The simple case 1
          if (bj1==b1 AND bj2==b2 ) then
            res = res + .overlap_for(order_bra,reorder_ket)  ! <<
          end
! Case 2
          do kk = dim,jj+1,-1
            k = order_ket(kk)
            DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!debug              if(.special_ket(k)[1]==0) then
!debug                write(*,*) 'j special but not k'
!debug                stop
!debug              end
            bk1 = .special_ket(k)[1]
            bk2 = .special_ket(k)[2]
      !      reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
            reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
            reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
            reorder_ket(dim-1) = k 
            fac = ZERO
            if (bj1==b1 AND bk2==b2 AND (bj2/=b2 OR bk1/=b1)) then
              fac = ONE
            ! .special_ket(k)[1] = bk1 ! 
              .special_ket(k)[2] = bj2 
            else if((bj1/=b1 OR bk2/=b2) AND bj2==b2 AND bk1==b1) then
              fac = ONE
              .special_ket(k)[1] = bj1 ! 
            ! .special_ket(k)[2] = bk2 
            else if(bj1==b1 AND bk2==b2 AND bj2==b2 AND bk1==b1) then
               fac=TWO 
            ! .special_ket(k)[1] = bk1  
            ! .special_ket(k)[2] = bk2 
            end
            res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
            .special_ket(k)[1] = bk1
            .special_ket(k)[2] = bk2
          end !do kk
        else ! j not special
          if(j==1)then
         !   reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
            do col_ind=1,.n_bas
              temp_ket_j => .contraction_wfs(col_ind)[:,:]
! Case 1
              reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
              fac = temp_ket_j(b1,b2)
              if (NOT fac.is_zero(.tol)) then
                res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind)*fac ! <<
              end
! Case 2
              do kk = dim,jj+1,-1
                k = order_ket(kk)
!3-04-05               reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
                reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
                reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
                reorder_ket(dim-1) = k 
                if (.special_ket(k)[1]>0) then
! Case 2, k special
                  bk1 = .special_ket(k)[1]
                  bk2 = .special_ket(k)[2]
                  if (bk2 == b2 AND bk1 /= b1) then
                    do bj2 = 1,.n_bf
                      fac = temp_ket_j(b1,bj2)
                      if (NOT fac.is_zero(.tol)) then
                    !   .special_ket(k)[1] = bk1 
                        .special_ket(k)[2] = bj2
                        res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                      end
                    end
                    .special_ket(k)[2] = bk2
                  else if (bk2 /= b2 AND bk1 == b1) then   
                    do bj1 = 1,.n_bf
                      fac = temp_ket_j(bj1,b2)
                      if (NOT fac.is_zero(.tol)) then
                        .special_ket(k)[1] = bj1 
                     !  .special_ket(k)[2] = bk2
                        res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                      end
                    end
                    .special_ket(k)[1] = bk1
                  else if (bk2 == b2 AND bk1 == b1) then   
                    do bj1 = 1,b1-1
                      fac = temp_ket_j(bj1,b2)
                      if (NOT fac.is_zero(.tol)) then
                        .special_ket(k)[1] = bj1 
                     !  .special_ket(k)[2] = bk2
                        res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                      end
                    end
                    do bj1 = b1+1,.n_bf
                      fac = temp_ket_j(bj1,b2)
                      if (NOT fac.is_zero(.tol)) then
                        .special_ket(k)[1] = bj1 
                     !  .special_ket(k)[2] = bk2
                        res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                      end
                    end
                    .special_ket(k)[1] = bk1
                    do bj2 = 1,b2-1
                      fac = temp_ket_j(b1,bj2)
                      if (NOT fac.is_zero(.tol)) then
                    !   .special_ket(k)[1] = bk1 
                        .special_ket(k)[2] = bj2
                        res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                      end
                    end
                    do bj2 = b2+1,.n_bf
                      fac = temp_ket_j(b1,bj2)
                      if (NOT fac.is_zero(.tol)) then
                    !   .special_ket(k)[1] = bk1 
                        .special_ket(k)[2] = bj2
                        res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                      end
                    end
                    .special_ket(k)[2] = bk2
                    fac = TWO*temp_ket_j(b1,b2)
                    if (NOT fac.is_zero(.tol)) then
                    !   .special_ket(k)[1] = bk1 
                    !   .special_ket(k)[2] = bk2 
                      res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                    end
                  end !else if (bk2 == b2 AND bk1 == b1)
                else !  Case 2, NONE SPECIAL
                  temp_ket_k => .ket(k)[:,:]
                  do bj2 = 1,.n_bf
                  do bk1 = 1,.n_bf
                    fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
                    if (NOT fac.is_zero(.tol)) then
                      .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                    end 
                  end
                  end
                  .special_ket(k)[1] = 0 
                  .special_ket(k)[2] = 0
                end ! if k special
              end !do kk
            end !do col_ind
          else !j/=1
            temp_ket_j => .ket(j)[:,:]
! Case 1
!3-04-05            reorder_ket(1:jj-1) = order_ket(1:jj-1) 
!3-04-05            reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
            fac = temp_ket_j(b1,b2)
            if (NOT fac.is_zero(.tol)) then
              res = res + .overlap_for(order_bra,reorder_ket)*fac ! <<
            end
  ! Case 2
            do kk = dim,jj+1,-1
              k = order_ket(kk)
              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
              reorder_ket(dim-1) = k 
              if (.special_ket(k)[1]>0) then
  ! Case 2, k special
                bk1 = .special_ket(k)[1]
                bk2 = .special_ket(k)[2]
                if (bk2 == b2 AND bk1 /= b1) then
                  do bj2 = 1,.n_bf
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
                    end
                  end
                  .special_ket(k)[2] = bk2
                else if (bk2 /= b2 AND bk1 == b1) then   
                  do bj1 = 1,.n_bf
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero(.tol)) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
                    end
                  end
                  .special_ket(k)[1] = bk1
                else if (bk2 == b2 AND bk1 == b1) then   
                  do bj1 = 1,b1-1
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero(.tol)) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
                    end
                  end
                  do bj1 = b1+1,.n_bf
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero(.tol)) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
                    end
                  end
                  .special_ket(k)[1] = bk1
                  do bj2 = 1,b2-1
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
                    end
                  end
                  do bj2 = b2+1,.n_bf
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
                    end
                  end
                  .special_ket(k)[2] = bk2
                  fac = TWO*temp_ket_j(b1,b2)
                  if (NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2 
                    res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
                  end
                end !else if (bk2 == b2 AND bk1 == b1)
              else !  Case 2, NONE SPECIAL
                temp_ket_k => .ket(k)[:,:]
                do bj2 = 1,.n_bf
                do bk1 = 1,.n_bf
                  fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
                  if (NOT fac.is_zero(.tol)) then
                    .special_ket(k)[1] = bk1 
                    .special_ket(k)[2] = bj2
                    res = res - .overlap_for(order_bra,reorder_ket) * fac ! <<
                  end 
                end
                end
                .special_ket(k)[1] = 0 
                .special_ket(k)[2] = 0
              end ! if k special
            end !do kk
          end !j==1
        end! if j special
     end !do jj
     reorder_ket.destroy
   end

   special_overlap_spin_ab_for(order_bra,order_ket,col_ind,b1,b2) result (res) ::: recursive
   ! Special function which evaluates the overlap integrals column vector
   ! specified by col_ind between mean field (Sz=0)-geminals when .bra(dim) is a special bra
!comments: should not be called if dim=1 because row_ind would be already defined.
     col_ind,b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: VEC{REAL}(.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     dim,bq1,bq2,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     DIE_IF(q==1,"ket of contraction 1 not in place")
     res = ZERO
     
     if(.special_ket(q)[2]==0) then !not a special ket
       temp_ket_q => .ket(q)[:,:]
       do bq1=1,.n_bf
         .special_ket(q)[1]=bq1
         do bq2=1,.n_bf
           if (NOT temp_ket_q(bq1,bq2).is_zero) then
             .special_ket(q)[2]=bq2
             res=res+.special_overlap_spin_ab_for(order_bra,order_ket,col_ind,b1,b2) &
                   *temp_ket_q(bq1,bq2) 
           end
         end
       end
       .special_ket(q)[1]=0
       .special_ket(q)[2]=0
       return
     end
! at this stage q is necessarily a special ket and dim>1
     reorder_ket.create(dim-1)
     do jj = dim,1,-1
        reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
        reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
        j = order_ket(jj)
        DIE_IF(j==1,"ket of contraction 1 has already appeared")
        if (.special_ket(j)[1]>0) then  !j special
          bj1 = .special_ket(j)[1]
          bj2 = .special_ket(j)[2]
! The simple case 1
          if (bj1==b1 AND bj2==b2 ) then
            res = res + .overlap_for(order_bra,reorder_ket,col_ind)  ! <<
          end
! Case 2
          do kk = dim,jj+1,-1
            k = order_ket(kk)
            DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!debug              if(.special_ket(k)[1]==0) then
!debug                write(*,*) 'j special but not k'
!debug                stop
!debug              end
            bk1 = .special_ket(k)[1]
            bk2 = .special_ket(k)[2]
      !      reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
            reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
            reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
            reorder_ket(dim-1) = k 
            fac = ZERO
            if (bj1==b1 AND bk2==b2 AND (bj2/=b2 OR bk1/=b1)) then
              fac = ONE
            ! .special_ket(k)[1] = bk1 ! 
              .special_ket(k)[2] = bj2 
            else if((bj1/=b1 OR bk2/=b2) AND bj2==b2 AND bk1==b1) then
              fac = ONE
              .special_ket(k)[1] = bj1 ! 
            ! .special_ket(k)[2] = bk2 
            else if(bj1==b1 AND bk2==b2 AND bj2==b2 AND bk1==b1) then
               fac=TWO 
            ! .special_ket(k)[1] = bk1  
            ! .special_ket(k)[2] = bk2 
            end
            res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
            .special_ket(k)[1] = bk1
            .special_ket(k)[2] = bk2
          end !do kk
        else ! j not special
          temp_ket_j => .ket(j)[:,:]
! Case 1
          fac = temp_ket_j(b1,b2)
          if (NOT fac.is_zero(.tol)) then
            res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac ! <<
          end
! Case 2
          do kk = dim,jj+1,-1
            k = order_ket(kk)
!3-04-05            reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
            reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
            reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
            reorder_ket(dim-1) = k 
            if (.special_ket(k)[1]>0) then
! Case 2, k special
              bk1 = .special_ket(k)[1]
              bk2 = .special_ket(k)[2]
              if (bk2 == b2 AND bk1 /= b1) then
                do bj2 = 1,.n_bf
                  fac = temp_ket_j(b1,bj2)
                  if (NOT fac.is_zero(.tol)) then
                !   .special_ket(k)[1] = bk1 
                    .special_ket(k)[2] = bj2
                    res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                  end
                end
                .special_ket(k)[2] = bk2
              else if (bk2 /= b2 AND bk1 == b1) then   
                do bj1 = 1,.n_bf
                  fac = temp_ket_j(bj1,b2)
                  if (NOT fac.is_zero(.tol)) then
                    .special_ket(k)[1] = bj1 
                 !  .special_ket(k)[2] = bk2
                    res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                  end
                end
                .special_ket(k)[1] = bk1
              else if (bk2 == b2 AND bk1 == b1) then   
                do bj1 = 1,b1-1
                  fac = temp_ket_j(bj1,b2)
                  if (NOT fac.is_zero(.tol)) then
                    .special_ket(k)[1] = bj1 
                 !  .special_ket(k)[2] = bk2
                    res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                  end
                end
                do bj1 = b1+1,.n_bf
                  fac = temp_ket_j(bj1,b2)
                  if (NOT fac.is_zero(.tol)) then
                    .special_ket(k)[1] = bj1 
                 !  .special_ket(k)[2] = bk2
                    res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                  end
                end
                .special_ket(k)[1] = bk1
                do bj2 = 1,b2-1
                  fac = temp_ket_j(b1,bj2)
                  if (NOT fac.is_zero(.tol)) then
                !   .special_ket(k)[1] = bk1 
                    .special_ket(k)[2] = bj2
                    res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                  end
                end
                do bj2 = b2+1,.n_bf
                  fac = temp_ket_j(b1,bj2)
                  if (NOT fac.is_zero(.tol)) then
                !   .special_ket(k)[1] = bk1 
                    .special_ket(k)[2] = bj2
                    res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                  end
                end
                .special_ket(k)[2] = bk2
                fac = TWO*temp_ket_j(b1,b2)
                if (NOT fac.is_zero(.tol)) then
                !   .special_ket(k)[1] = bk1 
                !   .special_ket(k)[2] = bk2 
                  res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                end
              end !else if (bk2 == b2 AND bk1 == b1)
            else !  Case 2, NONE SPECIAL
              temp_ket_k => .ket(k)[:,:]
              do bj2 = 1,.n_bf
              do bk1 = 1,.n_bf
                fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
                if (NOT fac.is_zero(.tol)) then
                  .special_ket(k)[1] = bk1 
                  .special_ket(k)[2] = bj2
                  res = res - .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                end 
              end
              end
              .special_ket(k)[1] = 0 
              .special_ket(k)[2] = 0
            end ! if k special
          end !do kk
        end! if j special
     end !do jj
     reorder_ket.destroy
   end

   special_overlap_spin_ab_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res) ::: recursive
   ! Special function which evaluates the overlap integrals matrix element
   ! specified by row_ind and col_ind between mean field (Sz=0)-geminals when .bra(dim) is a special bra
     row_ind,col_ind,b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: REAL
!     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     dim,bq1,bq2,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
!debug
!debug do i=1,dim
!debug  write(*,*)"i=",i
!debug j=order_ket(i)
!debug  stdout.show("order_ket-in",order_ket(i))
!debug  stdout.show("special_ket(j)-in",.special_ket(j).element)
!debug enddo
!debug
     
     if(.special_ket(q)[2]==0) then !not a special ket
       if(q==1) then
         DIE_IF(dim/=1,"order(dim>1)=1")
         temp_ket_q => .contraction_wfs(col_ind)[:,:]
       else
         temp_ket_q => .ket(q)[:,:]
       end
       do bq1=1,.n_bf
         .special_ket(q)[1]=bq1
         do bq2=1,.n_bf
           if (NOT temp_ket_q(bq1,bq2).is_zero) then
             .special_ket(q)[2]=bq2
             res=res+.special_overlap_spin_ab_for(order_bra,order_ket,row_ind,col_ind,b1,b2) &
                   *temp_ket_q(bq1,bq2) 
           end
         end
       end
       .special_ket(q)[1]=0
       .special_ket(q)[2]=0
       return
     end
! at this stage q is necessarily a special ket
     if(dim==1) then
       if (.special_ket(q)[1]==b1 AND .special_ket(q)[2]==b2 ) res = ONE
       return
     else ! q special ket and dim>1
       reorder_ket.create(dim-1)
       do jj = dim,1,-1
          reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
          reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
          j = order_ket(jj)
          if (.special_ket(j)[1]>0) then  !j special
            bj1 = .special_ket(j)[1]
            bj2 = .special_ket(j)[2]
! The simple case 1
            if (bj1==b1 AND bj2==b2 ) then
              res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)  ! <<
!debug
!debug write(*,*)"res11 in special_overlap_ab",res
!debug
            end
! Case 2
            do kk = dim,jj+1,-1
              k = order_ket(kk)
              DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
!debug              if(.special_ket(k)[1]==0) then
!debug                write(*,*) 'j special but not k'
!debug                stop
!debug              end
              bk1 = .special_ket(k)[1]
              bk2 = .special_ket(k)[2]
          !    reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
              reorder_ket(dim-1) = k 
!the following line was forgotten, the bug has been fixed in Nice 
              fac = ZERO
              if (bj1==b1 AND bk2==b2 AND (bj2/=b2 OR bk1/=b1)) then
                fac = ONE
              ! .special_ket(k)[1] = bk1 ! 
                .special_ket(k)[2] = bj2 
              else if((bj1/=b1 OR bk2/=b2) AND bj2==b2 AND bk1==b1) then
                fac = ONE
                .special_ket(k)[1] = bj1 ! 
              ! .special_ket(k)[2] = bk2 
              else if(bj1==b1 AND bk2==b2 AND bj2==b2 AND bk1==b1) then
                 fac=TWO 
              ! .special_ket(k)[1] = bk1  
              ! .special_ket(k)[2] = bk2 
              end
              res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res10 in special_overlap_ab",res
!debug
              .special_ket(k)[1] = bk1
              .special_ket(k)[2] = bk2
            end !do kk
          else ! j not special
            if(j==1)then
              temp_ket_j => .contraction_wfs(col_ind)[:,:]
            else
              temp_ket_j => .ket(j)[:,:]
            end
! Case 1
            fac = temp_ket_j(b1,b2)
            if (NOT fac.is_zero(.tol)) then
              res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac ! <<
!debug
!debug write(*,*)"res9 in special_overlap_ab",res
!debug
            end
! Case 2
            do kk = dim,jj+1,-1
              k = order_ket(kk)
!3-04-05            reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
              reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
              reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
              reorder_ket(dim-1) = k 
              if (.special_ket(k)[1]>0) then
! Case 2, k special
                bk1 = .special_ket(k)[1]
                bk2 = .special_ket(k)[2]
                if (bk2 == b2 AND bk1 /= b1) then
                  do bj2 = 1,.n_bf
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res8 in special_overlap_ab",res
!debug
                    end
                  end
                  .special_ket(k)[2] = bk2
                else if (bk2 /= b2 AND bk1 == b1) then   
                  do bj1 = 1,.n_bf
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero(.tol)) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res7 in special_overlap_ab",res
!debug
                    end
                  end
                  .special_ket(k)[1] = bk1
                else if (bk2 == b2 AND bk1 == b1) then   
                  do bj1 = 1,b1-1
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero(.tol)) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res6 in special_overlap_ab",res
!debug
                    end
                  end
                  do bj1 = b1+1,.n_bf
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero(.tol)) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res5 in special_overlap_ab",res
!debug
                    end
                  end
                  .special_ket(k)[1] = bk1
                  do bj2 = 1,b2-1
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res4 in special_overlap_ab",res
!debug
                    end
                  end
                  do bj2 = b2+1,.n_bf
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res3 in special_overlap_ab",res
!debug
                    end
                  end
                  .special_ket(k)[2] = bk2
                  fac = TWO*temp_ket_j(b1,b2)
                  if (NOT fac.is_zero(.tol)) then
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2 
                    res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res2 in special_overlap_ab",res
!debug
                  end
                end !else if (bk2 == b2 AND bk1 == b1)
              else !  Case 2, NONE SPECIAL
                temp_ket_k => .ket(k)[:,:]
                do bj2 = 1,.n_bf
                do bk1 = 1,.n_bf
                  fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
                  if (NOT fac.is_zero(.tol)) then
                    .special_ket(k)[1] = bk1 
                    .special_ket(k)[2] = bj2
                    res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
!debug
!debug write(*,*)"res1 in special_overlap_ab",res
!debug
                  end 
                end
                end
                .special_ket(k)[1] = 0 
                .special_ket(k)[2] = 0
              end ! if k special
            end !do kk
          end! if j special
       end !do jj
       reorder_ket.destroy
     end ! q special ket and dim>1
!debug
!debug write(*,*)"res in special_overlap_ab",res
!debug
   end

   special_overlap_spin_bb_for(order_bra,order_ket,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals between
   ! mean field (Sz=0)-geminals except .special_ket(order_ket(dim)) and the corresponding
   ! special bra which are (Sz=-1)-geminals.
!comments: should not be called if dim=1 because row_ind and col_ind would
! be already defined.

     b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(1)[2]==0,"special ket already set for contraction 1")
     ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no special ket matching special bra")
     row_ind,col_ind :: INT
     dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
      
     ! test for identical spinorbitals
     b3 = .special_ket(q)[1]
     b4 = .special_ket(q)[2]
     if (b3==b4 OR b1==b2 ) return
      
     if(dim==1) then ! only Case 0
       if (b3==b1 AND b4==b2 ) res = ONE
       if (b3==b2 AND b4==b1 ) res = -ONE
       return
     else !dim>1
       reorder_ket.create(dim-1)
! Case 0
       reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
       if (b3==b1 AND b4==b2 ) then
         res = res + .overlap_for(order_bra,reorder_ket) 
       else if (b3==b2 AND b4==b1 ) then
         res = res - .overlap_for(order_bra,reorder_ket)
       end
       do jj = dim-1,1,-1
         j = order_ket(jj)
         reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
         reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
         if (.special_ket(j)[1]>0) then  !j special
           DIE_IF(j==1,"1 special") 
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! The simple case 1
           if (bj2==b1 AND b4==b2 ) then
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b3
             res = res - .overlap_for(order_bra,reorder_ket) 
           else if (bj2==b2 AND b4==b1 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b3
             res = res + .overlap_for(order_bra,reorder_ket) 
           else if (bj2==b1 AND b3==b2 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b4
             res = res + .overlap_for(order_bra,reorder_ket) 
           else if (bj2==b2 AND b3==b1 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b4
             res = res - .overlap_for(order_bra,reorder_ket) 
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
!3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (bj2==b1 AND bk2==b2 ) then
               .special_ket(k)[1]=bj1
               .special_ket(k)[2]=b3
               .special_ket(q)[1]=bk1
               .special_ket(q)[2]=b4
               res = res + .overlap_for(order_bra,reorder_ket) 
             else if (bj2==b2 AND bk2==b1 ) then
               .special_ket(k)[1]=bj1
               .special_ket(k)[2]=b3
               .special_ket(q)[1]=bk1
               .special_ket(q)[2]=b4
               res = res - .overlap_for(order_bra,reorder_ket) 
             end
             .special_ket(k)[1]=bk1
             .special_ket(k)[2]=bk2
           end ! do kk 
         else !j not special  
           if(j==1)then
             do col_ind=1,.n_bas
!3-04-05               reorder_ket(1:jj-1)   = [ (order_ket(i), i=1,jj-1) ]
               reorder_ket(jj:dim-1) = [ (order_ket(i), i=jj+1,dim) ] !reorder(dim-1)=q
               temp_ket_j => .contraction_wfs(col_ind)[:,:]
    ! Case 1
               if (b4==b2 ) then
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b1)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=bj1
                     .special_ket(q)[2]=b3
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind)*fac
                   end
                 end
               else if (b4==b1 ) then        
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=bj1
                     .special_ket(q)[2]=b3
                     res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               end
               if (b3==b2 ) then        
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b1)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=bj1
                     .special_ket(q)[2]=b4
                     res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               else if (b3==b1 ) then        
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=bj1
                     .special_ket(q)[2]=b4
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               end
! Case 2
               do kk = dim-1,jj+1,-1
                 k = order_ket(kk)
!3-04-05                 reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
                 reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
                 reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
                 reorder_ket(dim-2) = k 
                 reorder_ket(dim-1) = q 
                 if (.special_ket(k)[1]>0) then ! Case 2, k special
                   bk1 = .special_ket(k)[1]
                   bk2 = .special_ket(k)[2]
                   if (bk2==b2 ) then
                     .special_ket(k)[2]=b3
                     .special_ket(q)[1]=bk1
                     .special_ket(q)[2]=b4
                     do bj1=1,.n_bf
                       fac = temp_ket_j(bj1,b1)
                       if (NOT fac.is_zero(.tol)) then
                         .special_ket(k)[1]=bj1
                         res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                       end
                     end
                   else if (bk2==b1 ) then
                     .special_ket(k)[2]=b3
                     .special_ket(q)[1]=bk1
                     .special_ket(q)[2]=b4
                     do bj1=1,.n_bf
                       fac = temp_ket_j(bj1,b2)
                       if (NOT fac.is_zero(.tol)) then
                         .special_ket(k)[1]=bj1
                         res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                       end
                     end
                   end
                   .special_ket(k)[1]=bk1
                   .special_ket(k)[2]=bk2
                 else !k not special
                   temp_ket_k => .ket(k)[:,:]
                   .special_ket(k)[2]=b3
                   .special_ket(q)[2]=b4
                   do bj1 = 1,.n_bf
                     .special_ket(k)[1]=bj1
                     do bk1 = 1,.n_bf
                       fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
                       if (NOT fac.is_zero(.tol)) then
                         .special_ket(q)[1]=bk1
                         res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                       end 
                     end
                   end
                   .special_ket(k)[1] = 0 
                   .special_ket(k)[2] = 0
                 end !k special
               end ! do kk 
             end ! do col_ind
           else ! j/=1
             temp_ket_j => .ket(j)[:,:]
  ! Case 1
             if (b4==b2 ) then
               do bj1=1,.n_bf
                 fac = temp_ket_j(bj1,b1)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(q)[1]=bj1
                   .special_ket(q)[2]=b3
                   res = res - .overlap_for(order_bra,reorder_ket)*fac
                 end
               end
             else if (b4==b1 ) then        
               do bj1=1,.n_bf
                 fac = temp_ket_j(bj1,b2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(q)[1]=bj1
                   .special_ket(q)[2]=b3
                   res = res + .overlap_for(order_bra,reorder_ket)*fac 
                 end
               end
             end
             if (b3==b2 ) then        
               do bj1=1,.n_bf
                 fac = temp_ket_j(bj1,b1)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(q)[1]=bj1
                   .special_ket(q)[2]=b4
                   res = res + .overlap_for(order_bra,reorder_ket)*fac 
                 end
               end
             else if (b3==b1 ) then        
               do bj1=1,.n_bf
                 fac = temp_ket_j(bj1,b2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(q)[1]=bj1
                   .special_ket(q)[2]=b4
                   res = res - .overlap_for(order_bra,reorder_ket)*fac 
                 end
               end
             end
! Case 2
             do kk = dim-1,jj+1,-1
               k = order_ket(kk)
!3-04-05               reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
               reorder_ket(dim-2) = k 
               reorder_ket(dim-1) = q 
               if (.special_ket(k)[1]>0) then ! Case 2, k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 if (bk2==b2 ) then
                   .special_ket(k)[2]=b3
                   .special_ket(q)[1]=bk1
                   .special_ket(q)[2]=b4
                   do bj1=1,.n_bf
                     fac = temp_ket_j(bj1,b1)
                     if (NOT fac.is_zero(.tol)) then
                       .special_ket(k)[1]=bj1
                       res = res + .overlap_for(order_bra,reorder_ket)*fac 
                     end
                   end
                 else if (bk2==b1 ) then
                   .special_ket(k)[2]=b3
                   .special_ket(q)[1]=bk1
                   .special_ket(q)[2]=b4
                   do bj1=1,.n_bf
                     fac = temp_ket_j(bj1,b2)
                     if (NOT fac.is_zero(.tol)) then
                       .special_ket(k)[1]=bj1
                       res = res - .overlap_for(order_bra,reorder_ket)*fac 
                     end
                   end
                 end
                 .special_ket(k)[1]=bk1
                 .special_ket(k)[2]=bk2
               else !k not special
                 temp_ket_k => .ket(k)[:,:]
                 .special_ket(k)[2]=b3
                 .special_ket(q)[2]=b4
                 do bj1 = 1,.n_bf
                   .special_ket(k)[1]=bj1
                   do bk1 = 1,.n_bf
                     fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
                     if (NOT fac.is_zero(.tol)) then
                       .special_ket(q)[1]=bk1
                       res = res + .overlap_for(order_bra,reorder_ket) * fac ! <<
                     end 
                   end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
               end !k special
             end ! do kk 
           end ! j==1
         end !j special
       end ! do jj 
       .special_ket(q)[1]=b3
       .special_ket(q)[2]=b4
       reorder_ket.destroy
     end !dim>1
   end

   special_overlap_spin_bb_for(order_bra,order_ket,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals column vector
   ! specified by col_ind between mean field (Sz=0)-geminals except 
   ! .special_ket(order_ket(dim)) and the corresponding special bra which are (Sz=-1)-geminals.
!comments: should not be called if dim=1 because row_ind would be already defined.
     col_ind,b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: VEC{REAL}(.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     row_ind :: INT
     dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
      
     ! test for identical spinorbitals
     b3 = .special_ket(q)[1]
     b4 = .special_ket(q)[2]
     if (b3==b4 OR b1==b2 ) return
      
     if(dim==1) then ! only Case 0
       if (b3==b1 AND b4==b2 ) res = ONE
       if (b3==b2 AND b4==b1 ) res = -ONE
       return
     else !dim>1
       reorder_ket.create(dim-1)
! Case 0
       reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
       if (b3==b1 AND b4==b2 ) then
         res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
       else if (b3==b2 AND b4==b1 ) then
         res = res - .overlap_for(order_bra,reorder_ket,col_ind)
       end
       do jj = dim-1,1,-1
         reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
         reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
         j = order_ket(jj)
         DIE_IF(j==1,"ket of contraction 1 has already appeared") 
         if (.special_ket(j)[1]>0) then  !j special
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! The simple case 1
           if (bj2==b1 AND b4==b2 ) then
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b3
             res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
           else if (bj2==b2 AND b4==b1 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b3
             res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
           else if (bj2==b1 AND b3==b2 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b4
             res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
           else if (bj2==b2 AND b3==b1 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b4
             res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
!3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (bj2==b1 AND bk2==b2 ) then
               .special_ket(k)[1]=bj1
               .special_ket(k)[2]=b3
               .special_ket(q)[1]=bk1
               .special_ket(q)[2]=b4
               res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
             else if (bj2==b2 AND bk2==b1 ) then
               .special_ket(k)[1]=bj1
               .special_ket(k)[2]=b3
               .special_ket(q)[1]=bk1
               .special_ket(q)[2]=b4
               res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
             end
             .special_ket(k)[1]=bk1
             .special_ket(k)[2]=bk2
           end ! do kk 
         else !j not special  
           temp_ket_j => .ket(j)[:,:]
! Case 1
           if (b4==b2 ) then
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b1)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b3
                 res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac
               end
             end
           else if (b4==b1 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b3
                 res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
               end
             end
           end
           if (b3==b2 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b1)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b4
                 res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
               end
             end
           else if (b3==b1 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b4
                 res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
               end
             end
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
!3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (.special_ket(k)[1]>0) then ! Case 2, k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if (bk2==b2 ) then
                 .special_ket(k)[2]=b3
                 .special_ket(q)[1]=bk1
                 .special_ket(q)[2]=b4
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b1)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1]=bj1
                     res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               else if (bk2==b1 ) then
                 .special_ket(k)[2]=b3
                 .special_ket(q)[1]=bk1
                 .special_ket(q)[2]=b4
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1]=bj1
                     res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               end
               .special_ket(k)[1]=bk1
               .special_ket(k)[2]=bk2
             else !k not special
               temp_ket_k => .ket(k)[:,:]
               .special_ket(k)[2]=b3
               .special_ket(q)[2]=b4
               do bj1 = 1,.n_bf
                 .special_ket(k)[1]=bj1
                 do bk1 = 1,.n_bf
                   fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=bk1
                     res = res + .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                   end 
                 end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end !k special
           end ! do kk 
         end !j special
       end ! do jj 
       .special_ket(q)[1]=b3
       .special_ket(q)[2]=b4
       reorder_ket.destroy
     end !dim>1
   end

   special_overlap_spin_bb_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals between
   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
   ! special bra which are (Sz=-1)-geminals.
     row_ind,col_ind,b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
      
     ! test for identical spinorbitals
     b3 = .special_ket(q)[1]
     b4 = .special_ket(q)[2]
     if (b3==b4 OR b1==b2 ) return
      
     if(dim==1) then ! only Case 0
       if (b3==b1 AND b4==b2 ) res = ONE
       if (b3==b2 AND b4==b1 ) res = -ONE
       return
     else !dim>1
       reorder_ket.create(dim-1)
! Case 0
       reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
       if (b3==b1 AND b4==b2 ) then
         res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
       else if (b3==b2 AND b4==b1 ) then
         res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)
       end
       do jj = dim-1,1,-1
         reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
         reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
         j = order_ket(jj)
         if (.special_ket(j)[1]>0) then  !j special
           DIE_IF(j==1,"1 special") 
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! The simple case 1
           if (bj2==b1 AND b4==b2 ) then
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b3
             res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj2==b2 AND b4==b1 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b3
             res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj2==b1 AND b3==b2 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b4
             res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj2==b2 AND b3==b1 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b4
             res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
!3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (bj2==b1 AND bk2==b2 ) then
               .special_ket(k)[1]=bj1
               .special_ket(k)[2]=b3
               .special_ket(q)[1]=bk1
               .special_ket(q)[2]=b4
               res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
             else if (bj2==b2 AND bk2==b1 ) then
               .special_ket(k)[1]=bj1
               .special_ket(k)[2]=b3
               .special_ket(q)[1]=bk1
               .special_ket(q)[2]=b4
               res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
             end
             .special_ket(k)[1]=bk1
             .special_ket(k)[2]=bk2
           end ! do kk 
         else !j not special  
           if(j==1)then
             temp_ket_j => .contraction_wfs(col_ind)[:,:]
           else
             temp_ket_j => .ket(j)[:,:]
           end
! Case 1
           if (b4==b2 ) then
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b1)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b3
                 res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac
               end
             end
           else if (b4==b1 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b3
                 res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           end
           if (b3==b2 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b1)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b4
                 res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           else if (b3==b1 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b4
                 res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
!3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (.special_ket(k)[1]>0) then ! Case 2, k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if (bk2==b2 ) then
                 .special_ket(k)[2]=b3
                 .special_ket(q)[1]=bk1
                 .special_ket(q)[2]=b4
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b1)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1]=bj1
                     res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
                   end
                 end
               else if (bk2==b1 ) then
                 .special_ket(k)[2]=b3
                 .special_ket(q)[1]=bk1
                 .special_ket(q)[2]=b4
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1]=bj1
                     res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
                   end
                 end
               end
               .special_ket(k)[1]=bk1
               .special_ket(k)[2]=bk2
             else !k not special
               temp_ket_k => .ket(k)[:,:]
               .special_ket(k)[2]=b3
               .special_ket(q)[2]=b4
               do bj1 = 1,.n_bf
                 .special_ket(k)[1]=bj1
                 do bk1 = 1,.n_bf
                   fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=bk1
                     res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   end 
                 end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end !k special
           end ! do kk 
         end !j special
       end ! do jj 
       .special_ket(q)[1]=b3
       .special_ket(q)[2]=b4
       reorder_ket.destroy
     end !dim>1
   end

   special_overlap_spin_aa_for(order_bra,order_ket,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals between
   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
   ! special bra which are (Sz=-1)-geminals.
!comments: should not be called if dim=1 because row_ind and col_ind would
! be already defined.
     b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(1)[2]==0,"special ket already set for contraction 1")
     ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no special ket matching special bra")
     row_ind,col_ind :: INT
     dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
      
! test for identical spinorbitals
     b3 = .special_ket(q)[1]
     b4 = .special_ket(q)[2]
     if (b3==b4 OR b1==b2 ) return
      
     if(dim==1) then ! only Case 0
       if (b3==b1 AND b4==b2 ) res = ONE
       if (b3==b2 AND b4==b1 ) res = -ONE
       return
     else !dim>1
       reorder_ket.create(dim-1)
! Case 0
       reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
       if (b3==b1 AND b4==b2 ) then
         res = res + .overlap_for(order_bra,reorder_ket) 
       else if (b3==b2 AND b4==b1 ) then
         res = res - .overlap_for(order_bra,reorder_ket)
       end
       do jj = dim-1,1,-1
         j = order_ket(jj)
         reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
         reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
         if (.special_ket(j)[1]>0) then  !j special
           DIE_IF(j==1,"1 special") 
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! The simple case 1
           if (bj1==b1 AND b4==b2 ) then
             .special_ket(q)[1]=b3
             .special_ket(q)[2]=bj2
             res = res - .overlap_for(order_bra,reorder_ket) 
           else if (bj1==b2 AND b4==b1 ) then        
             .special_ket(q)[1]=b3
             .special_ket(q)[2]=bj2
             res = res + .overlap_for(order_bra,reorder_ket) 
           else if (bj1==b1 AND b3==b2 ) then        
             .special_ket(q)[1]=b4
             .special_ket(q)[2]=bj2
             res = res + .overlap_for(order_bra,reorder_ket) 
           else if (bj1==b2 AND b3==b1 ) then        
             .special_ket(q)[1]=b4
             .special_ket(q)[2]=bj2
             res = res - .overlap_for(order_bra,reorder_ket) 
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
!3-04-05             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (bj1==b1 AND bk1==b2 ) then
               .special_ket(k)[1]=b3
               .special_ket(k)[2]=bj2
               .special_ket(q)[1]=b4
               .special_ket(q)[2]=bk2
               res = res + .overlap_for(order_bra,reorder_ket) 
             else if (bj1==b2 AND bk1==b1 ) then
               .special_ket(k)[1]=b3
               .special_ket(k)[2]=bj2
               .special_ket(q)[1]=b4
               .special_ket(q)[2]=bk2
               res = res - .overlap_for(order_bra,reorder_ket) 
             end
             .special_ket(k)[1]=bk1
             .special_ket(k)[2]=bk2
           end ! do kk 
         else !j not special  
           if(j==1)then
             do col_ind =1,.n_bas
!3-04-05               reorder_ket(1:jj-1)   = [ (order_ket(i), i=1,jj-1) ]
               reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
               temp_ket_j => .contraction_wfs(col_ind)[:,:]
               if (b4==b2 ) then
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b1,bj2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=b3
                     .special_ket(q)[2]=bj2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind)*fac
                   end
                 end
               else if (b4==b1 ) then        
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=b3
                     .special_ket(q)[2]=bj2
                     res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               end
               if (b3==b2 ) then        
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b1,bj2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=b4
                     .special_ket(q)[2]=bj2
                     res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               else if (b3==b1 ) then        
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[1]=b4
                     .special_ket(q)[2]=bj2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               end
    ! Case 2
               do kk = dim-1,jj+1,-1
                 k = order_ket(kk)
!3-04-05                 reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
                 reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
                 reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
                 reorder_ket(dim-2) = k 
                 reorder_ket(dim-1) = q 
                 if (.special_ket(k)[1]>0) then ! Case 2, k special
                   bk1 = .special_ket(k)[1]
                   bk2 = .special_ket(k)[2]
                   if (bk1==b2 ) then
                     .special_ket(k)[1]=b3
                     .special_ket(q)[1]=b4
                     .special_ket(q)[2]=bk2
                     do bj2=1,.n_bf
                       fac = temp_ket_j(b1,bj2)
                       if (NOT fac.is_zero(.tol)) then
                         .special_ket(k)[2]=bj2
                         res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                       end
                     end
                   else if (bk1==b1 ) then
                     .special_ket(k)[1]=b3
                     .special_ket(q)[1]=b4
                     .special_ket(q)[2]=bk2
                     do bj2=1,.n_bf
                       fac = temp_ket_j(b2,bj2)
                       if (NOT fac.is_zero(.tol)) then
                         .special_ket(k)[2]=bj2
                         res(:,col_ind) = res(:,col_ind) - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                       end
                     end
                   end
                   .special_ket(k)[1]=bk1
                   .special_ket(k)[2]=bk2
                 else !k not special
                   temp_ket_k => .ket(k)[:,:]
                   .special_ket(k)[1]=b3
                   .special_ket(q)[1]=b4
                   do bj2 = 1,.n_bf
                     .special_ket(k)[2]=bj2
                     do bk2 = 1,.n_bf
                       fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
                       if (NOT fac.is_zero(.tol)) then
                         .special_ket(q)[2]=bk2
                         res(:,col_ind) = res(:,col_ind) + .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                       end 
                     end
                   end
                   .special_ket(k)[1] = 0 
                   .special_ket(k)[2] = 0
                 end !k special
               end ! do kk 
             end ! do  col_ind
           else ! j/=1
             temp_ket_j => .ket(j)[:,:]
             if (b4==b2 ) then
               do bj2=1,.n_bf
                 fac = temp_ket_j(b1,bj2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(q)[1]=b3
                   .special_ket(q)[2]=bj2
                   res = res - .overlap_for(order_bra,reorder_ket)*fac
                 end
               end
             else if (b4==b1 ) then        
               do bj2=1,.n_bf
                 fac = temp_ket_j(b2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(q)[1]=b3
                   .special_ket(q)[2]=bj2
                   res = res + .overlap_for(order_bra,reorder_ket)*fac 
                 end
               end
             end
             if (b3==b2 ) then        
               do bj2=1,.n_bf
                 fac = temp_ket_j(b1,bj2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(q)[1]=b4
                   .special_ket(q)[2]=bj2
                   res = res + .overlap_for(order_bra,reorder_ket)*fac 
                 end
               end
             else if (b3==b1 ) then        
               do bj2=1,.n_bf
                 fac = temp_ket_j(b2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(q)[1]=b4
                   .special_ket(q)[2]=bj2
                   res = res - .overlap_for(order_bra,reorder_ket)*fac 
                 end
               end
             end
! Case 2
             do kk = dim-1,jj+1,-1
               k = order_ket(kk)
!3-04-05               reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
               reorder_ket(dim-2) = k 
               reorder_ket(dim-1) = q 
               if (.special_ket(k)[1]>0) then ! Case 2, k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 if (bk1==b2 ) then
                   .special_ket(k)[1]=b3
                   .special_ket(q)[1]=b4
                   .special_ket(q)[2]=bk2
                   do bj2=1,.n_bf
                     fac = temp_ket_j(b1,bj2)
                     if (NOT fac.is_zero(.tol)) then
                       .special_ket(k)[2]=bj2
                       res = res + .overlap_for(order_bra,reorder_ket)*fac 
                     end
                   end
                 else if (bk1==b1 ) then
                   .special_ket(k)[1]=b3
                   .special_ket(q)[1]=b4
                   .special_ket(q)[2]=bk2
                   do bj2=1,.n_bf
                     fac = temp_ket_j(b2,bj2)
                     if (NOT fac.is_zero(.tol)) then
                       .special_ket(k)[2]=bj2
                       res = res - .overlap_for(order_bra,reorder_ket)*fac 
                     end
                   end
                 end
                 .special_ket(k)[1]=bk1
                 .special_ket(k)[2]=bk2
               else !k not special
                 temp_ket_k => .ket(k)[:,:]
                 .special_ket(k)[1]=b3
                 .special_ket(q)[1]=b4
                 do bj2 = 1,.n_bf
                   .special_ket(k)[2]=bj2
                   do bk2 = 1,.n_bf
                     fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
                     if (NOT fac.is_zero(.tol)) then
                       .special_ket(q)[2]=bk2
                       res = res + .overlap_for(order_bra,reorder_ket) * fac ! <<
                     end 
                   end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
               end !k special
             end ! do kk 
           end !j==1
         end !j special
       end ! do jj 
       .special_ket(q)[1]=b3
       .special_ket(q)[2]=b4
       reorder_ket.destroy
     end !dim>1
   end

   special_overlap_spin_aa_for(order_bra,order_ket,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals column vector
   ! specified by col_ind between mean field (Sz=0)-geminals except 
   ! .special_ket(order_ket(dim)) and the corresponding special bra which are (Sz=1)-geminals.
!comments: should not be called if dim=1 because row_ind would be already defined.
     col_ind,b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: VEC{REAL}(.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     row_ind :: INT
     dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
      
! test for identical spinorbitals
     b3 = .special_ket(q)[1]
     b4 = .special_ket(q)[2]
     if (b3==b4 OR b1==b2 ) return
      
     if(dim==1) then ! only Case 0
       if (b3==b1 AND b4==b2 ) res = ONE
       if (b3==b2 AND b4==b1 ) res = -ONE
       return
     else !dim>1
       reorder_ket.create(dim-1)
! Case 0
       reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
       if (b3==b1 AND b4==b2 ) then
         res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
       else if (b3==b2 AND b4==b1 ) then
         res = res - .overlap_for(order_bra,reorder_ket,col_ind)
       end
       do jj = dim-1,1,-1
         reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
         reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
         j = order_ket(jj)
         DIE_IF(j==1,"ket for contraction 1 has already appeared") 
         if (.special_ket(j)[1]>0) then  !j special
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! The simple case 1
           if (bj1==b1 AND b4==b2 ) then
             .special_ket(q)[1]=b3
             .special_ket(q)[2]=bj2
             res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
           else if (bj1==b2 AND b4==b1 ) then        
             .special_ket(q)[1]=b3
             .special_ket(q)[2]=bj2
             res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
           else if (bj1==b1 AND b3==b2 ) then        
             .special_ket(q)[1]=b4
             .special_ket(q)[2]=bj2
             res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
           else if (bj1==b2 AND b3==b1 ) then        
             .special_ket(q)[1]=b4
             .special_ket(q)[2]=bj2
             res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
      !       reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (bj1==b1 AND bk1==b2 ) then
               .special_ket(k)[1]=b3
               .special_ket(k)[2]=bj2
               .special_ket(q)[1]=b4
               .special_ket(q)[2]=bk2
               res = res + .overlap_for(order_bra,reorder_ket,col_ind) 
             else if (bj1==b2 AND bk1==b1 ) then
               .special_ket(k)[1]=b3
               .special_ket(k)[2]=bj2
               .special_ket(q)[1]=b4
               .special_ket(q)[2]=bk2
               res = res - .overlap_for(order_bra,reorder_ket,col_ind) 
             end
             .special_ket(k)[1]=bk1
             .special_ket(k)[2]=bk2
           end ! do kk 
         else !j not special  
           temp_ket_j => .ket(j)[:,:]
           if (b4==b2 ) then
             do bj2=1,.n_bf
               fac = temp_ket_j(b1,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=b3
                 .special_ket(q)[2]=bj2
                 res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac
               end
             end
           else if (b4==b1 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b2,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=b3
                 .special_ket(q)[2]=bj2
                 res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
               end
             end
           end
           if (b3==b2 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b1,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bj2
                 res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
               end
             end
           else if (b3==b1 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b2,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bj2
                 res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
               end
             end
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             !reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (.special_ket(k)[1]>0) then ! Case 2, k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if (bk1==b2 ) then
                 .special_ket(k)[1]=b3
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bk2
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b1,bj2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[2]=bj2
                     res = res + .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               else if (bk1==b1 ) then
                 .special_ket(k)[1]=b3
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bk2
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[2]=bj2
                     res = res - .overlap_for(order_bra,reorder_ket,col_ind)*fac 
                   end
                 end
               end
               .special_ket(k)[1]=bk1
               .special_ket(k)[2]=bk2
             else !k not special
               temp_ket_k => .ket(k)[:,:]
               .special_ket(k)[1]=b3
               .special_ket(q)[1]=b4
               do bj2 = 1,.n_bf
                 .special_ket(k)[2]=bj2
                 do bk2 = 1,.n_bf
                   fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[2]=bk2
                     res = res + .overlap_for(order_bra,reorder_ket,col_ind) * fac ! <<
                   end 
                 end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end !k special
           end ! do kk 
         end !j special
       end ! do jj 
       .special_ket(q)[1]=b3
       .special_ket(q)[2]=b4
       reorder_ket.destroy
     end !dim>1
   end

   special_overlap_spin_aa_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals between
   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
   ! special bra which are (Sz=-1)-geminals.
     row_ind,col_ind,b1,b2 :: INT, IN
     order_bra, order_ket :: VEC{INT}, IN
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
      
! test for identical spinorbitals
     b3 = .special_ket(q)[1]
     b4 = .special_ket(q)[2]
     if (b3==b4 OR b1==b2 ) return
      
     if(dim==1) then ! only Case 0
       if (b3==b1 AND b4==b2 ) res = ONE
       if (b3==b2 AND b4==b1 ) res = -ONE
       return
     else !dim>1
       reorder_ket.create(dim-1)
! Case 0
       reorder_ket(1:dim-1)   = order_ket(1:dim-1) 
       if (b3==b1 AND b4==b2 ) then
         res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
       else if (b3==b2 AND b4==b1 ) then
         res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)
       end
       do jj = dim-1,1,-1
         reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
         reorder_ket(jj:dim-1) = order_ket(jj+1:dim)  !reorder(dim-1)=q
         j = order_ket(jj)
         if (.special_ket(j)[1]>0) then  !j special
           DIE_IF(j==1,"1 special") 
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! The simple case 1
           if (bj1==b1 AND b4==b2 ) then
             .special_ket(q)[1]=b3
             .special_ket(q)[2]=bj2
             res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj1==b2 AND b4==b1 ) then        
             .special_ket(q)[1]=b3
             .special_ket(q)[2]=bj2
             res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj1==b1 AND b3==b2 ) then        
             .special_ket(q)[1]=b4
             .special_ket(q)[2]=bj2
             res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj1==b2 AND b3==b1 ) then        
             .special_ket(q)[1]=b4
             .special_ket(q)[2]=bj2
             res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
     !        reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (bj1==b1 AND bk1==b2 ) then
               .special_ket(k)[1]=b3
               .special_ket(k)[2]=bj2
               .special_ket(q)[1]=b4
               .special_ket(q)[2]=bk2
               res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
             else if (bj1==b2 AND bk1==b1 ) then
               .special_ket(k)[1]=b3
               .special_ket(k)[2]=bj2
               .special_ket(q)[1]=b4
               .special_ket(q)[2]=bk2
               res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
             end
             .special_ket(k)[1]=bk1
             .special_ket(k)[2]=bk2
           end ! do kk 
         else !j not special  
           if(j==1)then
             temp_ket_j => .contraction_wfs(col_ind)[:,:]
           else
             temp_ket_j => .ket(j)[:,:]
           end
           if (b4==b2 ) then
             do bj2=1,.n_bf
               fac = temp_ket_j(b1,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=b3
                 .special_ket(q)[2]=bj2
                 res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac
               end
             end
           else if (b4==b1 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b2,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=b3
                 .special_ket(q)[2]=bj2
                 res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           end
           if (b3==b2 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b1,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bj2
                 res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           else if (b3==b1 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b2,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bj2
                 res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             !reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-3) = order_ket(kk+1:dim-1) 
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (.special_ket(k)[1]>0) then ! Case 2, k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if (bk1==b2 ) then
                 .special_ket(k)[1]=b3
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bk2
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b1,bj2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[2]=bj2
                     res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
                   end
                 end
               else if (bk1==b1 ) then
                 .special_ket(k)[1]=b3
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bk2
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[2]=bj2
                     res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
                   end
                 end
               end
               .special_ket(k)[1]=bk1
               .special_ket(k)[2]=bk2
             else !k not special
               temp_ket_k => .ket(k)[:,:]
               .special_ket(k)[1]=b3
               .special_ket(q)[1]=b4
               do bj2 = 1,.n_bf
                 .special_ket(k)[2]=bj2
                 do bk2 = 1,.n_bf
                   fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(q)[2]=bk2
                     res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   end 
                 end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end !k special
           end ! do kk 
         end !j special
       end ! do jj 
       .special_ket(q)[1]=b3
       .special_ket(q)[2]=b4
       reorder_ket.destroy
     end !dim>1
   end

   overlap result (res)
   ! Evaluate the overlap matrix for a given geminal contraction
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
     i,row_ind,col_ind :: INT
     reorder_ket :: VEC{INT}*
     reorder_ket.create(.n_geminals)
     reorder_ket = [ (i, i=1,.n_geminals) ]
     res = .overlap_for(reorder_ket)
!debug     stdout.text("after overlap_for ")
!debug     do col_ind=1,.n_bas
!debug     do row_ind=1,col_ind
!debug       res(row_ind,col_ind)=.overlap_for(reorder_ket,row_ind,col_ind)
!debug       reorder_ket = [ (i, i=1,.n_geminals) ]
!debug     end
!debug     end
!debug     .put
     do col_ind=2,.n_bas
     do row_ind=1,col_ind-1
       res(col_ind,row_ind)=res(row_ind,col_ind)
     end
     end
     reorder_ket.destroy
   end

   overlap_for(order_ket) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix between
   ! mean field (Sz=0)-geminals (upper triangle only is evaluated)
!comments:
!special_ket are always created at the end so that if jj is a special ket,
!than kk>jj is also a special ket.
     order_ket :: VEC{INT}, IN
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(.special_ket(1)[1]==0,".special_ket(1) already set")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     row_ind,col_ind :: INT
     jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_bra_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_qb_jb :: MAT{REAL}*

     dim = order_ket.dim
     res = ZERO
      
!debug     stdout.text("before overlap_for ")
!debug     .put
!debug     stdout.show("dim=",dim)
!debug     do l=1,dim
!debug       stdout.show("l=",l)
!debug       stdout.show("order_ket(l)=",order_ket(l))
!debug     end
     if (dim==1) then ! only Case 1
       j = order_ket(1)
       DIE_IF(j/=1,"dim is 1 but j is not 1")
       do col_ind=1,.n_bas 
         temp_ket_j => .contraction_wfs(col_ind)[:,:]
         do row_ind=1,col_ind
           fac = sum(.contraction_wfs(row_ind)[:,:]*temp_ket_j)
           if (NOT fac.is_zero(.tol)) then
             res(row_ind,col_ind)=fac !permit to set to zero numbers below a threshold
           end
         end
       end
       nullify(temp_ket_j)
       return
     else ! dim > 1
       temp_bra_q => .bra(dim)[:,:]
       reorder_ket.create(dim-1)
       temp_qa_ja.create(.n_bf,.n_bf)
       temp_qb_jb.create(.n_bf,.n_bf)
       do jj = dim,1,-1
         j = order_ket(jj)
         if (j==1) then ! 1 not special
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do col_ind=1,.n_bas
             temp_ket_j => .contraction_wfs(col_ind)[:,:]
             do bj1=1,.n_bf
             do bq1=1,.n_bf
               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
             end
             end
  ! Case 2
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               if (.special_ket(k)[1]>0) then ! k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 do bj1 = 1,bk1-1
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj1 = bk1+1,.n_bf
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj2 = 1,bk2-1
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 do bj2 = bk2+1,.n_bf
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                 end
               else ! k not special
                 temp_ket_k => .ket(k)[:,:]
                 do bk2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                     .special_ket(k)[2] = bk2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                   end
                 end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
                 nullify(temp_ket_k)
               end  ! if (.special_ket(k)
             end !do kk
  ! Case 1
          !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_qb_jb.trace
             if (NOT fac.is_zero(.tol)) then
               res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
             end
           end !do col_ind
           nullify(temp_ket_j)
         else ! j>1 
           if (.special_ket(j)[1]>0) then
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
! Case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!debug              if(.special_ket(k)[1]==0) then
!debug     write(*,*) "j special but not k"
!debug     stdout.show("dim=",dim)
!debug     do l=1,dim
!debug       stdout.show("l=",l)
!debug       stdout.show("order_ket(l)=",order_ket(l))
!debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!debug     end
!debug     stop
!debug     end
!assume special_ket's are also ordered at the end in the initial guess
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if(bj1/=bk1 OR bj2/=bk2) then
                 fac=temp_bra_q(bk1,bj2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
                 fac=temp_bra_q(bj1,bk2)
                 if (NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               else ! bj1==bk1 AND bj2==bk2
                 fac=TWO * temp_bra_q(bk1,bk2)
                 if (NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket) * fac ! <<
                 end
               end ! bj1==bk1 AND bj2==bk2
             end !do kk
! Case 1
          !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_bra_q(bj1,bj2)
             if (NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_ket) * fac ! <<
             end
           else !j not special
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             temp_ket_j => .ket(j)[:,:]
             do bj1=1,.n_bf
             do bq1=1,.n_bf
               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
             end
             end
! Case 2
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               if (.special_ket(k)[1]>0) then ! k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 do bj1 = 1,bk1-1
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_ket) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj1 = bk1+1,.n_bf
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_ket) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj2 = 1,bk2-1
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_ket) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 do bj2 = bk2+1,.n_bf
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_ket) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket) * fac ! <<
                 end
               else ! k not special
                 temp_ket_k => .ket(k)[:,:]
                 do bk2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                     .special_ket(k)[2] = bk2
                     res = res - .overlap_for(reorder_ket) * fac ! <<
                   end
                 end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
                 nullify(temp_ket_k)
               end  ! if (.special_ket(k)
             end !do kk
! Case 1
         !    reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_qb_jb.trace
             if (NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_ket) * fac ! <<
             end
             nullify(temp_ket_j)
           end !j not special
         end !if(j==1 AND .special_ket(1)==0) else
       end  !do jj=dim,1,-1
     temp_qa_ja.destroy
     temp_qb_jb.destroy
     reorder_ket.destroy
     nullify(temp_bra_q)
     end ! if(dim==1)
     
   end

   overlap_for(order_ket,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals column
   ! vector specified by col_ind between mean field (Sz=0)-geminals 
   ! upper half only is evaluated.
!comments:
!special_ket are always created at the end so that if jj is a special ket,
!than kk>jj is also a special ket. 
     col_ind :: INT, IN
     order_ket :: VEC{INT}, IN
     res :: VEC{REAL}(.n_bas)
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     row_ind :: INT
     jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_bra_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_qb_jb :: MAT{REAL}*

     dim = order_ket.dim
     res=ZERO

     if (dim==1) then ! only Case 1
       j = order_ket(1)
       DIE_IF(j==1,"ket of contraction 1 has already appeared")
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         do row_ind=1,col_ind
           fac = .contraction_wfs(row_ind)[bj1,bj2]
           if (NOT fac.is_zero(.tol)) then
             res(row_ind)=fac !permit to set to zero numbers below a threshold
           end
         end
       else 
         temp_ket_j => .ket(j)[:,:]
         do row_ind=1,col_ind
           fac = sum(.contraction_wfs(row_ind)[:,:]*temp_ket_j)
           if (NOT fac.is_zero(.tol)) then
             res(row_ind)=fac !permit to set to zero numbers below a threshold
           end
         end
         nullify(temp_ket_j)
       end
       return
     else ! dim > 1
       temp_bra_q => .bra(dim)[:,:]
       reorder_ket.create(dim-1)
       temp_qa_ja.create(.n_bf,.n_bf)
       temp_qb_jb.create(.n_bf,.n_bf)
       do jj = dim,1,-1
         j = order_ket(jj)
         DIE_IF(j==1,"ket of contraction 1 has already appeared")
         if (.special_ket(j)[1]>0) then
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! Case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!debug              if(.special_ket(k)[1]==0) then
!debug     write(*,*) "j special but not k"
!debug     stdout.show("dim=",dim)
!debug     do l=1,dim
!debug       stdout.show("l=",l)
!debug       stdout.show("order_ket(l)=",order_ket(l))
!debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!debug     end
!debug     stop
!debug     end
!assume special_ket's are also ordered at the end in the initial guess
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) = k 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
             if(bj1/=bk1 OR bj2/=bk2) then
               fac=temp_bra_q(bk1,bj2)
               if (NOT fac.is_zero(.tol)) then
                 .special_ket(k)[1] = bj1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                 .special_ket(k)[1] = bk1
               end
               fac=temp_bra_q(bj1,bk2)
               if (NOT fac.is_zero(.tol)) then
              !  .special_ket(k)[1] = bk1
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                 .special_ket(k)[2] = bk2
               end
             else ! bj1==bk1 AND bj2==bk2
               fac=TWO * temp_bra_q(bk1,bk2)
               if (NOT fac.is_zero(.tol)) then
              !  .special_ket(k)[1] = bk1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
               end
             end ! bj1==bk1 AND bj2==bk2
           end !do kk
! Case 1
         !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
           fac = temp_bra_q(bj1,bj2)
           if (NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
           end
         else !j not special
           temp_ket_j => .ket(j)[:,:]
           do bj1=1,.n_bf
           do bq1=1,.n_bf
             temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
             temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
           end
           end
! Case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk)
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) = k 
             if (.special_ket(k)[1]>0) then ! k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               do bj1 = 1,bk1-1
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj1 = bk1+1,.n_bf
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj2 = 1,bk2-1
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               do bj2 = bk2+1,.n_bf
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
               if (NOT fac.is_zero(.tol)) then
               ! .special_ket(k)[1] = bk1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
               end
             else ! k not special
               temp_ket_k => .ket(k)[:,:]
               do bk2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                 end
               end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
               nullify(temp_ket_k)
             end  ! if (.special_ket(k)
           end !do kk
! Case 1
         !  reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
           fac = temp_qb_jb.trace
           if (NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
           end
           nullify(temp_ket_j)
         end !j not special
       end  !do jj=dim,1,-1
     temp_qa_ja.destroy
     temp_qb_jb.destroy
     reorder_ket.destroy
     nullify(temp_bra_q)
     end ! if(dim==1)
   end

   overlap_for(order_ket,row_ind,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix
   ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     row_ind, col_ind :: INT, IN
     order_ket :: VEC{INT}, IN
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_bra_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_qb_jb :: MAT{REAL}*

     dim = order_ket.dim
     res = ZERO

     if (dim==1) then ! Only Case 1
       j = order_ket(1)
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         fac = .contraction_wfs(row_ind)[bj1,bj2]
       else if(.special_ket(j)[1]==0 AND j==1) then
         fac = sum(.contraction_wfs(row_ind)[:,:]*.contraction_wfs(col_ind)[:,:])
       else if (.special_ket(j)[1]==0 AND j/=1) then
         fac = sum(.contraction_wfs(row_ind)[:,:]*.ket(j)[:,:])
       end
       if (NOT fac.is_zero(.tol)) then
          res = fac
!debug       write(*,*)'coucou5',res
       end
       return
     else ! dim > 1
       temp_bra_q => .bra(dim)[:,:]
       reorder_ket.create(dim-1)
       temp_qa_ja.create(.n_bf,.n_bf)
       temp_qb_jb.create(.n_bf,.n_bf)
       do jj = dim,1,-1
         j = order_ket(jj)
!debug    write(*,*) 'jj,j',jj,j
         if (j==1 AND .special_ket(1)[1]==0) then ! 1 not special
           temp_ket_j => .contraction_wfs(col_ind)[:,:]
           do bj1=1,.n_bf
           do bq1=1,.n_bf
             temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
             temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
           end
           end
! Case 2
           reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
           do kk = dim,jj+1,-1
             k = order_ket(kk)
!debug    write(*,*) 'kk,k',kk,k
             reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
             reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
             reorder_ket(dim-1) = k 
             if (.special_ket(k)[1]>0) then ! k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               do bj1 = 1,bk1-1
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj1 = bk1+1,.n_bf
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj2 = 1,bk2-1
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               do bj2 = bk2+1,.n_bf
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
               if (NOT fac.is_zero(.tol)) then
               ! .special_ket(k)[1] = bk1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
               end
!debug                 write(*,*) 'case 2 kspecial',dim,res
             else ! k not special
               temp_ket_k => .ket(k)[:,:]
               do bk2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               end
               end
!debug           write(*,*) 'case 2 k not special',dim,res
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
               nullify(temp_ket_k)
             end  ! if (.special_ket(k)
           end !do kk
! Case 1
        !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
           fac = temp_qb_jb.trace
           if (NOT fac.is_zero(.tol)) then
             res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
           end
!debug      write(*,*) 'case 1 j=1 not special',dim,fac,res
           nullify(temp_ket_j)
         else ! j>1 or 1 special
           if (.special_ket(j)[1]>0) then
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
! Case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk)
!debug    write(*,*) 'kk,k',kk,k
               DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!debug              if(.special_ket(k)[1]==0) then
!debug     write(*,*) "j special but not k"
!debug     stdout.show("dim=",dim)
!debug     do l=1,dim
!debug       stdout.show("l=",l)
!debug       stdout.show("order_ket(l)=",order_ket(l))
!debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!debug     end
!debug     stop
!debug     end
!assume special_ket's are also ordered at the end in the initial guess
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if(bj1/=bk1 OR bj2/=bk2) then
                 fac=temp_bra_q(bk1,bj2)
                 if (NOT fac.is_zero(.tol)) then
                   .special_ket(k)[1] = bj1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
                 fac=temp_bra_q(bj1,bk2)
                 if (NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               else ! bj1==bk1 AND bj2==bk2
   !res should be zero if any of the two equalities hold, then and the
   !expression simplified accordingly and testing suggested by Thierry
   !less necessary
                 fac=TWO * temp_bra_q(bk1,bk2)
                 if (NOT fac.is_zero(.tol)) then
                !  .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               end ! bj1==bk1 AND bj2==bk2
!debug      write(*,*) 'case 2 j et k special',dim,res
             end !do kk
! Case 1
            ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_bra_q(bj1,bj2)
             if (NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
             end
!debug      write(*,*) 'case 1 j special',dim,res
           else !j not special
             temp_ket_j => .ket(j)[:,:]
             do bj1=1,.n_bf
             do bq1=1,.n_bf
               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
             end
             end
! Case 2
             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
             do kk = dim,jj+1,-1
               k = order_ket(kk)
!debug    write(*,*) 'kk,k',kk,k
               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
               reorder_ket(dim-1) = k 
               if (.special_ket(k)[1]>0) then ! k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 do bj1 = 1,bk1-1
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj1 = bk1+1,.n_bf
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj2 = 1,bk2-1
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 do bj2 = bk2+1,.n_bf
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero(.tol)) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
                 if (NOT fac.is_zero(.tol)) then
                 ! .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                 end
!debug      write(*,*) 'case 2 k  special',dim,res
               else ! k not special
                 temp_ket_k => .ket(k)[:,:]
                 do bk2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                   if (NOT fac.is_zero(.tol)) then
                     .special_ket(k)[1] = bj1 
                     .special_ket(k)[2] = bk2
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   end
                 end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
                 nullify(temp_ket_k)
               end  ! if (.special_ket(k)
!debug      write(*,*) 'case 2 k not special',dim,res
             end !do kk
! Case 1
          !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
             fac = temp_qb_jb.trace
!debug      write(*,*) 'avant'
!debug      write(*,*) 'case 1 j not special',dim,fac,res
             if (NOT fac.is_zero(.tol)) then
               res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
             end
!debug      write(*,*) 'apres'
!debug      write(*,*) 'case 1 j not special',dim,fac,res
             nullify(temp_ket_j)
           end !j not special
         end !if(j==1 AND .special_ket(1)==0) else
       end  !do jj=dim,1,-1
       temp_qa_ja.destroy
       temp_qb_jb.destroy
       reorder_ket.destroy
       nullify(temp_bra_q)
     end ! if(dim==1)
   end

!  ********************
!  geminal MFCI methods
!  ********************

!   make_int_archives(v)
!   ! make intermediate integrals needed several times by the hamiltoinian_for
!   ! function and archive them.
!!WARNING we supposed H real
!! afterwards should put the name of the molecule in the type so as to have:
!!    eri_archive.set(.name,"h_integrals")
!     v :: MAT4{REAL} 
!     w :: MAT4{REAL}* 
!     temp_i :: MAT{REAL}*
!     temp_j :: MAT{REAL}*
!     temp :: MAT{REAL}(.n_bf,.n_bf)
!     string :: STR
!     int_archive :: ARCHIVE
!     i,j,k,l,bi1,bi2,bj1,bj2 :: INT
!
!     w.create(.n_bf,.n_bf,.n_bf,.n_bf)
!     do i = 2,.n_geminals
!       if (.special_ket(i)[1]>0) then
!         bi1= .special_ket(i)[1] 
!         bi2= .special_ket(i)[2] 
!         do j = i+1,.n_geminals
!           string="int_gs"//j.to_str.trim//i.to_str.trim
!           int_archive.set("h2o",string)
!           if (.special_ket(j)[1]>0) then
!             bj1= .special_ket(j)[1] 
!             bj2= .special_ket(j)[2] 
!             DIE_IF(bi1==bj1 OR bi2==bj2,"same spinorbital in too different special_kets") 
!!             if(bi2>bj2) then
!!               k=bi2
!!               bi2=bj2
!!               bj2=k
!!             end
!!             do k=1,bi2-1
!!               do l=1,.n_bf
!!                 v(:,:,l,k)=ZERO
!!               end
!!             end
!!             do k=bi2+1,bj2-1
!!               do l=1,.n_bf
!!                 v(:,:,l,k)=ZERO
!!               end
!!             end
!!             do k=bj2+1,.n_bf
!!               do l=1,.n_bf
!!                 v(:,:,l,k)=ZERO
!!               end
!!             end
!!             do l=1,bj1-1
!!               v(:,:,l,bi2)=ZERO
!!             end
!!             do l=bj1+1,.n_bf
!!               v(:,:,l,bi2)=ZERO
!!             end
!!             do l=1,bi1-1
!!               v(:,:,l,bj2)=ZERO
!!             end
!!             do l=bi1+1,.n_bf
!!               v(:,:,l,bj2)=ZERO
!!             end
!             w=ZERO
!             w(:,:,bj1,bi2)=v(:,:,bj1,bi2)
!             w(:,:,bi1,bj2)=v(:,:,bi1,bj2)
!             int_archive.write(w)
!           else
!           !  temp_j => .ket(j)[:]
!            DIE("case i special_ket but not j not implemented, should not arise")
!           end
!         end
!       else
!         temp_i => .ket(i)[:,:] 
!         do j = i+1,.n_geminals
!           DIE_IF(.special_ket(j)[1]>0, "case j special_ket but not i not implemented, should not arise") 
!           temp_j => .ket(j)[:,:]
!           string="int_gs"//j.to_str.trim//i.to_str.trim
!           int_archive.set("h2o",string)
!           do bi2=1,.n_bf
!           do bj1=1,.n_bf
!           do bj2=1,.n_bf
!           do bi1=1,.n_bf
!               w(bi1,bj2,bj1,bi2)=temp_i(bi1,bi2)*temp_j(bj1,bj2)+temp_j(bi1,bi2)*temp_i(bj1,bj2)
!           end
!           end
!           end
!           end
!           do bi2=1,.n_bf
!           do bj1=1,.n_bf
!             do bj2=1,.n_bf
!             do bi1=1,.n_bf
!               temp(bi1,bj2)=sum(v(:,:,bi1,bj2)*w(:,:,bj1,bi2))
!             end
!             end
!             w(:,:,bj1,bi2)=temp
!           end
!           end
!           int_archive.write(w)
!         end
!       end         
!     end
!     do i = 1,.n_bas
!       temp_i => .contraction_wfs(i)[:,:] 
!       do j = 2,.n_geminals
!         string="int_c1-"//j.to_str.trim//"-"//i.to_str.trim
!         int_archive.set("h2o",string)
!         if (.special_ket(j)[1]>0) then
!           bj1= .special_ket(j)[1] 
!           bj2= .special_ket(j)[2] 
!           w=ZERO
!           do bi2=1,.n_bf
!             do bi1=1,.n_bf
!               w(:,:,bj1,bi2)=w(:,:,bj1,bi2)+temp_i(bi1,bi2)*v(:,:,bi1,bj2)
!             end
!           end
!           do bi1=1,.n_bf
!             do bi2=1,.n_bf
!               w(:,:,bi1,bj2)=w(:,:,bi1,bj2)+temp_i(bi1,bi2)*v(:,:,bj1,bi2)
!             end
!           end
!           int_archive.write(w)
!         else
!           temp_j => .ket(j)[:,:]
!           do bi2=1,.n_bf
!           do bj1=1,.n_bf
!           do bj2=1,.n_bf
!           do bi1=1,.n_bf
!               w(bi1,bj2,bj1,bi2)=temp_i(bi1,bi2)*temp_j(bj1,bj2)+temp_j(bi1,bi2)*temp_i(bj1,bj2)
!           end
!           end
!           end
!           end
!           do bi2=1,.n_bf
!           do bj1=1,.n_bf
!             do bj2=1,.n_bf
!             do bi1=1,.n_bf
!               temp(bi1,bj2)=sum(v(:,:,bi1,bj2)*w(:,:,bj1,bi2))
!             end
!             end
!             w(:,:,bj1,bi2)=temp
!           end
!           end
!           int_archive.write(w)
!         end
!       end          
!     end
!     w.destroy
!   end

   do_hamiltonian(print_hamiltonian)
   ! Evaluate the hamiltonian in a geminal induced basis set
   ! built over orthonormal orbitals, and  print it if print_hamiltonian is true.
     print_hamiltonian :: BIN, optional, IN
     !res :: MAT{REAL}(.n_bas,.n_bas)
     res :: MAT{REAL}*
     eigenvalues :: VEC{REAL}* !temp
     R :: MAT{REAL}* !temp
     print_default :: BIN
     print_default = FALSE
     if (present(print_hamiltonian)) print_default = print_hamiltonian
   !  .n_bas=.n_bf-.n_geminals+1 !temp
     res.create(.n_bas,.n_bas)
     res = .hamiltonian
     if(print_default) then
       stdout.text(" ")
       stdout.text("The Hamiltonian is ")
       stdout.put(res)
     end
     eigenvalues.create(.n_bas) !temp
     R.create(.n_bas,.n_bas) !temp
     res.solve_eigenproblem(eigenvalues,R) !temp
     stdout.text(" ")
     stdout.text("eigenvalues") !temp
     stdout.put(eigenvalues) !temp
     eigenvalues.destroy !temp
     R.destroy !temp
     res.destroy !temp
   end

   do_overlap
   ! Evaluate the 1-electron overlap integrals in a geminal induced basis set
   ! built over orthonormal orbitals and print the result
      res :: MAT{REAL}(.n_bas,.n_bas)
      res = .overlap
      stdout.text(" ")
      stdout.text("The overlap matrix is ")
      stdout.put(res)
   end

   do_step_0(use_brillouin,print_hamiltonian,truncation_threshold) 
   ! implement step 0 of geminal scf
     use_brillouin :: BIN, IN
     print_hamiltonian :: BIN, IN
     truncation_threshold :: REAL, IN
     ham :: MAT{REAL}*
     indices :: VEC{INT}*
     increasing_vec :: VEC{MAT_{REAL}}*
     increasing_values :: VEC{REAL}*
     j,k :: INT
     n_nonzero,n_total :: INT
     n_bas,n_geminals,n_bf :: INT
     eigenvec :: MAT{REAL}*
     new_wfs :: VEC{MAT_{REAL}}*
     n_geminals=.n_geminals
     n_bf=.n_bf
     .put
     stdout.text(" ")
     n_total=.n_bas
     n_nonzero=n_total-.n_dependent
     if(use_brillouin) then
       n_bas=n_nonzero-n_bf+n_geminals 
     else
       n_bas=n_nonzero
     end
     .n_bas=n_bas
     ham.create(n_bas,n_bas)
     ham=ZERO
     ham = .hamiltonian
     if(print_hamiltonian) then
       stdout.text(" ")
       stdout.text("The Hamiltonian is ")
       stdout.text(" ")
       stdout.put(ham)
       stdout.text(" ")
     end
     eigenvec.create(n_bas,n_bas)
     ham.solve_eigenproblem(.contraction_energies(1:n_bas),eigenvec) 
     ham.destroy 
     if(print_hamiltonian) then
       stdout.text(" ")
       stdout.text("eigenvectors") 
       stdout.text(" ")
       stdout.put(eigenvec) 
       stdout.text(" ")
     end
     new_wfs.create(n_bas)
     do j=1,n_bas
       new_wfs(j).element.create(n_bf,n_bf)
     end
     new_wfs.to_product_of(eigenvec,.contraction_wfs(1:n_bas),TRUE)
     eigenvec.destroy 
     do j=1,n_bas
       .contraction_wfs(j).element=new_wfs(j).element
     end
     new_wfs.destroy 
     if(use_brillouin) then
       .n_bas=n_nonzero
       do j=n_nonzero-n_bf+n_geminals+1,n_nonzero
         .contraction_energies(j)=.hamiltonian(j,j)
       end
     end
     .contraction_energies=.contraction_energies+.nuclear_energy
!sorting eigenvalues and eigenvectors
     indices.create(n_total)
     .contraction_energies.quick_sort(indices)
     increasing_vec.create(n_total)
     increasing_values.create(n_total)
     do j=1,n_total
       increasing_vec(j).element.create(n_bf,n_bf)
       increasing_vec(j).element = .contraction_wfs(indices(j)).element
       increasing_values(j) = .contraction_energies(indices(j))
     end
     indices.destroy
     do j=1,n_total
       .contraction_wfs(j).element=increasing_vec(j).element
     end
     .contraction_energies=increasing_values
     increasing_vec.destroy 
     increasing_values.destroy 
!printing eigenvalues and eigenvectors
       stdout.text(" ")
     stdout.text("eigenvalues") 
     stdout.text(" ")
     stdout.put(.contraction_energies) 
     stdout.text(" ")
     if(truncation_threshold==ZERO) then
       .n_bas=n_total
     else
       stdout.show("truncation threshold for this step",truncation_threshold)
       .n_bas=maxloc(.contraction_energies,1,mask= &
         .contraction_energies < truncation_threshold)
     end
     stdout.show("number of states saved at this step",.n_bas)
     stdout.show("the tolerance was",.tol,precision=12)
     stdout.text(" ")
     .put_max_bas
     .put_wfs
     .put_ground_state
   end

!   remove_dependencies(use_2_orthogonality,print_hamiltonian) ::: leaky
!   ! remove linear dependencies in the contraction basis set
!   !  leaky because of the set_singlet_wfs
!   ! take advantage of the possible truncation of the basis set
!     use_2_orthogonality :: BIN, IN
!     print_hamiltonian :: BIN, IN
!     i,j,n_bas,n_bf :: INT
!     ov :: MAT{REAL}*
!     norms :: VEC{REAL}*
!     .get_wfs
!     n_bf=.n_bf
!     n_bas=.n_bas
!     if(print_hamiltonian) then
!       stdout.text(" ")
!       stdout.text("before orthonomalise ")
!       .put
!     end
!     if(use_2_orthogonality) then
!       .contraction_wfs(2:).weak_two_orthonormalise(.bra(2:))
!     end
!     ov.create(n_bas,n_bas)
!     ov= .overlap
!     if(print_hamiltonian) then
!       stdout.text("The overlap matrix is ")
!       stdout.text(" ")
!       stdout.put(ov)
!       stdout.text(" ")
!     end
!     norms.create(n_bas)
!     .contraction_wfs.schmidt_orthonormalise(ov,norms,.n_dependent) 
!     ov.destroy 
!     if(print_hamiltonian) then
!       stdout.text(" ")
!       stdout.text("The scaling values are ")
!       stdout.text(" ")
!       stdout.put(norms)
!       stdout.text(" ")
!     end
!     norms.destroy 
!     .put_max_bas
!     .put_wfs
!     if(print_hamiltonian) then
!       stdout.text(" ")
!       stdout.text("after sorting ")
!       .put
!     end
!     .n_bas=.n_bas-.n_dependent !supposed set as such by calling routine
!     if(print_hamiltonian) then
!       ov.create(.n_bas,.n_bas)
!       ov= .overlap
!       stdout.text(" ")
!       stdout.show("is unit matrix =",ov.is_unit_matrix(TOL(6)))
!       stdout.text(" ")
!       ov.destroy
!     end
!   end

   remove_dependencies(orthogonality_type,print_hamiltonian) ::: leaky
   ! remove linear dependencies in the contraction basis set
   !  leaky because of the set_singlet_wfs
   ! take advantage of the possible truncation of the basis set
     orthogonality_type :: STR, IN
     print_hamiltonian :: BIN, IN
     word :: STR
     i,j,k :: INT
     n_bas,n_bf :: INT
     ov :: MAT{REAL}*
     norms :: VEC{REAL}*
     keep,int_vec :: VEC{MAT_{REAL}}*
     RDM,eigenvectors :: MAT{REAL}*
     order_ket :: VEC{INT}*
     old_dim,new_dim :: INT
     n_geminals :: INT
     n_singlet :: INT
     .get_wfs
     n_bf=.n_bf
     n_singlet=n_bf*(n_bf+1)/2
     n_bas=.n_bas
     n_geminals=.n_geminals
     if(n_bas==1) then 
       stdout.text(" ")
       stdout.text("n_bas=1, just normalizes")
       ov.create(n_bas,n_bas)
       ov= .overlap
       if(print_hamiltonian) then
         stdout.text("The overlap matrix is ")
         stdout.text(" ")
         stdout.put(ov)
         stdout.text(" ")
       end
       .contraction_wfs(1).element=.contraction_wfs(1).element/ov(1,1) 
       ov.destroy 
       .put_max_bas
       .put_wfs
       return
     end
     keep.create(1,n_bas)
     do i=1,n_bas
       keep(i).element.create(n_bf,n_bf)
       keep(i).element=.contraction_wfs(i).element
     end
     if(print_hamiltonian) then
       stdout.text(" ")
       stdout.text("before orthonomalise ")
       .put
     end
     word = orthogonality_type
     word.to_lower_case
     select case (word)
       case ("one_orthogonality       ")
         stdout.text(" ")
         stdout.text("use one_orthogonality")
         stdout.text(" ")
         stdout.text("not implemented yet")
         stop
!pcc       case ("strong_two_orthogonality       ")
!pcc         stdout.text(" ")
!pcc         stdout.text("use two_orthogonality with respect to the ground state")
!pcc         stdout.text(" ")
!pcc         order_ket.create(n_geminals)
!pcc         do i=1,n_geminals
!pcc           order_ket(i)=i
!pcc         end
!pcc         .make_2_internal_space(order_ket,eigenvectors,.ig_tol,print_hamiltonian)
!pcc         order_ket.destroy
!pcc         if(print_hamiltonian) then
!pcc           stdout.text(" ")
!pcc           stdout.text("internal eigenvectors ")
!pcc           stdout.text(" ")
!pcc           stdout.put(transpose(eigenvectors))
!pcc         end
!pcc         .contraction_wfs(2:).two_orthonormalise(eigenvectors)
!pcc         eigenvectors.destroy
!pcc         if(print_hamiltonian) then
!pcc           stdout.text(" ")
!pcc           stdout.text("after strong_two_orthonormalise ")
!pcc           stdout.text(" ")
!pcc           .put
!pcc         end
!pcc       case ("spec_two_orthogonality       ")
!pcc         stdout.text(" ")
!pcc         stdout.text("use two_orthogonality with respect to spectator product")
!pcc         stdout.text(" ")
!pcc         n_geminals=n_geminals-1
!pcc         order_ket.create(n_geminals)
!pcc         do i=1,n_geminals
!pcc           order_ket(i)=i+1
!pcc         end
!pcc         .make_2_internal_space(order_ket,eigenvectors,.ig_tol,print_hamiltonian)
!pcc!pcc         .spectator_2_internal_space(order_ket,eigenvectors,print_hamiltonian)
!pcc         order_ket.destroy
!pcc         if(print_hamiltonian) then
!pcc           stdout.text(" ")
!pcc!pcc           stdout.text("external eigenvectors ")
!pcc           stdout.text("internal eigenvectors ")
!pcc           stdout.text(" ")
!pcc           stdout.put(transpose(eigenvectors))
!pcc         end
!pcc!pcc         .contraction_wfs(2:).strong_two_orthonormalise(eigenvectors)
!pcc         .contraction_wfs(2:).two_orthonormalise(eigenvectors)
!pcc         eigenvectors.destroy
!pcc         if(print_hamiltonian) then
!pcc           stdout.text(" ")
!pcc           stdout.text("after two_orthonormalise ")
!pcc           stdout.text(" ")
!pcc           .put
!pcc         end
       case ("SP_two_orthogonality  ")
         stdout.text(" ")
         stdout.text("use two_orthogonality with respect to each spectator geminal")
         stdout.text("and each pair of spectator geminal product")
         stdout.text(" ")
!10-07-09         .two_orthogonality = TRUE
         old_dim=n_geminals-1
         int_vec.create(old_dim)
         do k=1,old_dim
           int_vec(k).element.create(n_bf,n_bf)
           int_vec(k).element=.bra(k+1).element
         end
         order_ket.create(2)
         do i=2,n_geminals-1
           order_ket(1)=i
           do j=i+1,n_geminals
             order_ket(2)=j
!pcc    .make_2_internal_space(order_ket,eigenvectors,.ig_tol,print_hamiltonian)
             RDM.create(n_singlet,n_singlet)
             .make_2RDM_singlet(order_ket,RDM)
         !    RDM=matmul(RDM,transpose(RDM))
             RDM.internal_vectors(eigenvectors,.ig_tol,print_hamiltonian)
             RDM.destroy
             if(print_hamiltonian) then
               stdout.text(" ")
               stdout.text("internal eigenvectors ")
               stdout.text(" ")
               stdout.put(transpose(eigenvectors))
             end
             new_dim=eigenvectors.dim1+old_dim
             int_vec.expand(new_dim)
             eigenvectors.unflatten(int_vec(old_dim+1:new_dim))
             old_dim=new_dim
             eigenvectors.destroy
           end
         end
!temp         if (n_geminals>2) then
!temp           ov.create(old_dim,old_dim)
!temp           do i=1,old_dim 
!temp             do j=1,i-1
!temp               ov(i,j)=sum(int_vec(i).element(:,:)*int_vec(j).element(:,:))
!temp               ov(j,i)=ov(i,j)
!temp             end
!temp             ov(i,i)=sum(int_vec(i).element(:,:)*int_vec(i).element(:,:))
!temp           end
!temp           int_vec.schmidt_orthonormalise(ov,keep,norms,.n_dependent,.ld_tol)
!temp           ov.destroy
!temp         else
!temp           .n_dependent=0
!temp         end
         .contraction_wfs(2:).weak_two_orthonormalise(int_vec)
         int_vec.destroy
         order_ket.destroy
         if(print_hamiltonian) then
           stdout.text(" ")
           stdout.text("after two_orthonormalise ")
           stdout.text(" ")
           .put
         end
       case ("SF_two_orthogonality  ")
         stdout.text(" ")
         stdout.text("use two_orthogonality with respect to each spectator geminal")
         stdout.text(" ")
         .contraction_wfs(2:).weak_two_orthonormalise(.bra(2:))
       case  default 
         stdout.text(" ")
         stdout.text("no orthogonality enforced")
         stdout.text(" ")
     end
     ov.create(n_bas,n_bas)
     ov= .overlap
     if(print_hamiltonian) then
       stdout.text("The overlap matrix is ")
       stdout.text(" ")
       stdout.put(ov)
       stdout.text(" ")
     end
     norms.create(n_bas)
  !   .contraction_wfs.schmidt_orthonormalise(ov,norms,.n_dependent,.ld_tol) 
     .contraction_wfs.schmidt_orthonormalise(ov,keep,norms,.n_dependent,.ld_tol)
     !keep not necessary in fact if no orthogonality enforced
     ov.destroy 
     keep.destroy 
     if(print_hamiltonian) then
       stdout.text(" ")
       stdout.text("The scaling values are ")
       stdout.text(" ")
       stdout.put(norms)
       stdout.text(" ")
     end
     norms.destroy 
     .put_max_bas
     .put_wfs
     if(print_hamiltonian) then
       stdout.text(" ")
       stdout.text("after sorting ")
       .put
     end
     .n_bas=.n_bas-.n_dependent !supposed set as such by calling routine
     if(print_hamiltonian) then
       ov.create(.n_bas,.n_bas)
       ov= .overlap
       stdout.text(" ")
       stdout.show("is unit matrix =",ov.is_unit_matrix(TOL(6)))
       stdout.text(" ")
!       stdout.text("The overlap matrix for debug is ")
!       stdout.text(" ")
!       stdout.put(ov)
!       stdout.text(" ")
       ov.destroy
       stdout.show("n_dependent =",.n_dependent)
     end
   end

!pcc   remove_dependencies_fast(orthogonality_type,print_hamiltonian) ::: leaky
!pcc   ! remove linear dependencies in the contraction basis set
!pcc   !  leaky because of the set_singlet_wfs
!pcc     orthogonality_type :: STR, IN
!pcc     print_hamiltonian :: BIN, IN
!pcc     i,j,n_bas,n_bf :: INT
!pcc     ov :: MAT{REAL}*
!pcc     norms :: VEC{REAL}*
!pcc     unorthovec :: MAT{REAL}*
!pcc     word :: STR
!pcc     .set_singlet_wfs
!pcc     n_bf=.n_bf
!pcc     n_bas=.n_bas
!pcc     ov.create(n_bas,n_bas)
!pcc     ov= .overlap
!pcc     if(print_hamiltonian) then
!pcc       stdout.text("The overlap matrix is ")
!pcc       stdout.text(" ")
!pcc       stdout.put(ov)
!pcc       stdout.text(" ")
!pcc     end
!pcc   !  .get_max_bas
!pcc     .get_wfs
!pcc     norms.create(.n_bas)
!pcc     unorthovec.create(.n_bas,n_bas)
!pcc     unorthovec=ZERO
!pcc     .contraction_wfs.flatten(unorthovec) 
!pcc     if(print_hamiltonian) then
!pcc       stdout.text(" ")
!pcc       stdout.text("before orthonomalise ")
!pcc       .put
!pcc     end
!pcc    ! word=orthogonality_type.to_lower_case
!pcc     word=orthogonality_type
!pcc     if(word == "weak_two_orthogonality  ") then
!pcc!try     unorthovec.hybrid_2orthonormalise(ov,norms,.n_dependent,.bra) 
!pcc       unorthovec.schmidt_2orthonormalise(ov,norms,.n_dependent,.bra) 
!pcc     else
!pcc!try     unorthovec.hybrid_orthonormalise(ov,norms,.n_dependent) 
!pcc       unorthovec.schmidt_orthonormalise(ov,norms,.n_dependent) 
!pcc     end
!pcc     ov.destroy 
!pcc     if(print_hamiltonian) then
!pcc       stdout.text(" ")
!pcc       stdout.text("The scaling values are ")
!pcc       stdout.text(" ")
!pcc       stdout.put(norms)
!pcc       stdout.text(" ")
!pcc     end
!pcc     norms.destroy 
!pcc!6/6/2007 unflatten was probably wrong b4 this date because 
!pcc! non diagonal element coef were not divided by in unflatten
!pcc! beware calculations performed b4 this date
!pcc     unorthovec.unflatten(.contraction_wfs)
!pcc     unorthovec.destroy
!pcc     .put_max_bas
!pcc     .put_wfs
!pcc     if(print_hamiltonian) then
!pcc       stdout.text(" ")
!pcc       stdout.text("after sorting ")
!pcc       .put
!pcc     end
!pcc     .n_bas=.n_bas-.n_dependent !supposed set as such by calling routine
!pcc     if(print_hamiltonian) then
!pcc       ov.create(.n_bas,.n_bas)
!pcc       ov= .overlap
!pcc       stdout.text(" ")
!pcc       stdout.show("is unit matrix =",ov.is_unit_matrix(TOL(6)))
!pcc!       stdout.text("Check: overlap matrix is ")
!pcc!       stdout.text(" ")
!pcc!       stdout.put(ov)
!pcc       stdout.text(" ")
!pcc       ov.destroy
!pcc     end
!pcc   end

   remove_triplet_dependencies(print_hamiltonian) ::: leaky 
   ! remove linear dependencies in the contraction basis set
   !  leaky because of the set_triplet_wfs
     print_hamiltonian :: BIN, IN
     i,n_bas :: INT
     ov :: MAT{REAL}*
     eigenvalues :: VEC{REAL}*
     orthovec :: MAT{REAL}*
   !  unorthovec :: MAT{REAL}*
     .set_triplet_wfs
!debug     .set_to_zero_bra
!debug     .set_to_zero_ket
!debug     .bra(2)[1,3]=ONE/sqrt(TWO)
!debug     .bra(2)[3,1]=ONE/sqrt(TWO)
!debug     .ket(2)[1,3]=ONE/sqrt(TWO)
!debug     .ket(2)[3,1]=ONE/sqrt(TWO)
     n_bas=.n_bas
     ov.create(n_bas,n_bas)
     ov= .overlap
     if(print_hamiltonian) then
       stdout.text(" ")
       stdout.text("before orthonomalise ")
       .put
       stdout.text("The overlap matrix is ")
       stdout.text(" ")
       stdout.put(ov)
       stdout.text(" ")
     end
     eigenvalues.create(n_bas)
     eigenvalues=ZERO
     orthovec.create(n_bas,n_bas)
     orthovec=ZERO
     ov.solve_eigenproblem(eigenvalues,orthovec) 
!     ov.destroy 
     if(print_hamiltonian) then
       stdout.text(" ")
       stdout.text("The overlap matrix eigenvalues are ")
       stdout.text(" ")
       stdout.put(eigenvalues)
       stdout.text(" ")
     end
!     unorthovec.create(n_bas,n_bas)
!     .contraction_wfs.flatten_triplet(unorthovec) 
     orthovec=transpose(orthovec)
     do i=1,orthovec.dim1
       orthovec(i,:)=orthovec(i,:)/sqrt(eigenvalues(i))
     end
     orthovec.unflatten_triplets(.contraction_wfs) 
     orthovec.destroy
     eigenvalues.destroy 
     if(print_hamiltonian) then
       stdout.text(" ")
       stdout.text("after sorting ")
       .put
!     .n_bas=.n_bas-.n_dependent
!     ov.create(.n_bas,.n_bas)
       ov= .overlap
       stdout.text(" ")
       stdout.show("is unit matrix =",ov.is_unit_matrix(TOL(6)))
!       stdout.text("Check: overlap matrix is ")
!       stdout.text(" ")
!       stdout.put(ov)
       stdout.text(" ")
     end
     ov.destroy
   end

 !  make_two_internal_matrix_singlet(order_ket,res)
 !  !calculate the 2 internal matrix in a singlet basis set
   make_2RDM_singlet(order_ket,res)
   !calculate the 2nd order RDM  in a singlet basis set
     order_ket :: VEC{INT}, IN
     res :: MAT{REAL}(.n_bf*(.n_bf+1)/2,.n_bf*(.n_bf+1)/2)
     ENSURE(order_ket.dim==2,"routine not implemented for product of more than 2 geminals")
     int1,int2 :: MAT{REAL}(.n_bf,.n_bf)
     b1,b2,b3,b4 :: INT
     count1,count2 :: INT
     n_bf :: INT
     n_bf=.n_bf
     count1=0
     do b1=1,n_bf
       count1=count1+1
       int1= .interior_product_by_geminal_ab_singlet(order_ket,b1,b1)
       count2=0
       do b3=1,n_bf
         count2=count2+1
         int2= .interior_product_by_geminal_ab_singlet(order_ket,b3,b3)
         res(count1,count2)=sum(int1*int2)
       end
       do b3=2,n_bf
         do b4=1,b3-1
           count2=count2+1
           int2= .interior_product_by_geminal_ab_singlet(order_ket,b3,b4)
           res(count1,count2)=sum(int1*int2)
         end
       end
     end
     do b1=2,n_bf
       do b2=1,b1-1
         count1=count1+1
         int1= .interior_product_by_geminal_ab_singlet(order_ket,b1,b2)
         count2=0
         do b3=1,n_bf
           count2=count2+1
           int2= .interior_product_by_geminal_ab_singlet(order_ket,b3,b3)
           res(count1,count2)=sum(int1*int2)
         end
         do b3=2,n_bf
           do b4=1,b3-1
             count2=count2+1
             int2= .interior_product_by_geminal_ab_singlet(order_ket,b3,b4)
             res(count1,count2)=sum(int1*int2)
           end
         end
       end
     end
     DIE_IF(count1/=n_bf*(n_bf+1)/2,"count1 not equal to n_bf*(n_bf+1)/2")
     DIE_IF(count2/=n_bf*(n_bf+1)/2,"count2 not equal to n_bf*(n_bf+1)/2")
   end


   interior_product_by_special_geminal_ab(order_ket,b1,b2) result(res) 
   ! Evaluate the interior product of the product of two geminals
   ! by an alpha-beta special geminal b1, b2 and put the result in res
     res :: MAT{REAL}(.n_bf,.n_bf)
     order_ket :: VEC{INT}, IN
     b1,b2 :: INT, IN
     ENSURE(order_ket.dim==2,"interior product not implemented for product of more than 2 geminals")
     g1,g2 :: MAT{REAL}*
     n_bf :: INT
     b3,b4 :: INT
     n_bf=.n_bf
     g1=>.ket(order_ket(1)).element
     g2=>.ket(order_ket(2)).element
     res=ZERO
     res=res+g1(b1,b2)*g2
     res=res+g2(b1,b2)*g1
     do b3=1,n_bf
       do b4=1,n_bf
         res(b3,b4)=res(b3,b4)-g1(b1,b4)*g2(b3,b2)-g2(b1,b4)*g1(b3,b2)
       end
     end
     nullify(g1)
     nullify(g2)
   end

   interior_product_by_geminal_ab_singlet(order_ket,b1,b2) result(res) 
   ! Evaluate the interior product of the product of two singlet geminals
   ! by an alpha-beta normalized singlet geminal b1, b2 and put the result in res
     res :: MAT{REAL}(.n_bf,.n_bf)
     order_ket :: VEC{INT}, IN
     b1,b2 :: INT, IN
     ENSURE(order_ket.dim==2,"interior product not implemented for product of more than 2 geminals")
     g1,g2 :: MAT{REAL}*
     n_bf :: INT
     b3,b4 :: INT
     n_bf=.n_bf
     g1=>.ket(order_ket(1)).element
     g2=>.ket(order_ket(2)).element
     res=ZERO
     if(b1==b2) then
       res=res+g1(b1,b1)*g2
       res=res+g2(b1,b1)*g1
       do b3=1,n_bf
         res(b3,b3)=res(b3,b3)-g1(b1,b3)*g2(b3,b1)-g2(b1,b3)*g1(b3,b1)
         do b4=1,b3-1
           res(b3,b4)=res(b3,b4)-g1(b1,b4)*g2(b3,b1)-g2(b1,b4)*g1(b3,b1)
           res(b4,b3)=res(b3,b4)
         end
       end
     else
     !  res=res+(g1(b1,b2)*g2+g1(b2,b1)*g2+g2(b1,b2)*g1+g2(b2,b1)*g1)/sqrt(TWO)
       res=res+(g1(b1,b2)*g2+g2(b1,b2)*g1)*sqrt(TWO)
       do b3=1,n_bf
         !res(b3,b3)=res(b3,b3)-(g1(b1,b3)*g2(b3,b2)+g1(b2,b3)*g2(b3,b1)+ &
         !g2(b1,b3)*g1(b3,b2)+g2(b2,b3)*g1(b3,b1))/sqrt(TWO)
         res(b3,b3)=res(b3,b3)-(g1(b1,b3)*g2(b3,b2)+g1(b2,b3)*g2(b3,b1))*sqrt(TWO)
         do b4=1,b3-1
           res(b3,b4)=res(b3,b4)-(g1(b1,b4)*g2(b3,b2)+g1(b2,b4)*g2(b3,b1)+ &
           g2(b1,b4)*g1(b3,b2)+g2(b2,b4)*g1(b3,b1))/sqrt(TWO)
           res(b4,b3)=res(b3,b4)
         end
       end
     end
     nullify(g1)
     nullify(g2)
   end

!routines T. Combot

!pcc
!pcc   spectator_2_internal_space(order_ket,eigenvectors2,print_hamiltonian,spin_sym) ::: leaky
!pcc   ! Evaluate tA.A where A is the 2-internal matrix of the 
!pcc   ! spectator geminals product and solve its eigenproblem
!pcc     order_ket :: VEC{INT}, IN
!pcc     eigenvectors2 :: MAT{REAL}*
!pcc     print_hamiltonian :: BIN, optional
!pcc     spin_sym :: BIN, optional
!pcc     eigenvalues :: VEC{REAL}* !temp
!pcc     eigenvectors :: MAT{REAL}*
!pcc     res :: MAT{REAL}*
!pcc     R :: MAT5{REAL}* !temp
!pcc     n_geminals :: INT
!pcc     i,h,l1,l2 :: INT
!pcc     dim :: INT
!pcc     print_default :: BIN
!pcc     spin_sym_default :: BIN
!pcc     print_default = FALSE
!pcc     spin_sym_default = TRUE
!pcc     if (present(print_hamiltonian)) print_default = print_hamiltonian
!pcc     if (present(spin_sym)) spin_sym_default = spin_sym
!pcc     n_geminals=size(order_ket)
!pcc     if (NOT spin_sym_default) then
!pcc       dim=.n_bf*.n_bf
!pcc       R.create(dim,n_geminals,n_geminals,.n_bf,.n_bf)
!pcc       R=ZERO
!pcc       .spectator_2_internal_matrix(order_ket,R)
!pcc     else
!pcc       dim=(.n_bf+1)*.n_bf/2
!pcc       R.create(dim,n_geminals,n_geminals,.n_bf,.n_bf)
!pcc       R=ZERO
!pcc       .spectator_2_internal_matrix_singlet(order_ket,R)
!pcc     end
!pcc     res.create(dim,dim)
!pcc     do l1=1,dim
!pcc       do l2=1,dim
!pcc          res(l1,l2)=sum(R(l1,:,:,:,:)*R(l2,:,:,:,:))
!pcc       end
!pcc     end
!pcc     R.destroy !temp
!pcc     eigenvalues.create(dim)
!pcc     eigenvectors.create(dim,dim)
!pcc     res.solve_eigenproblem(eigenvalues,eigenvectors)
!pcc     res.destroy !temp
!pcc     if (print_default) then
!pcc       stdout.text( " ")
!pcc       stdout.text( "spectator 2-internal matrix eigenvalues")
!pcc       stdout.text( " ")
!pcc       stdout.put(eigenvalues)
!pcc     end
!pcc     h=0
!pcc     do i=1,dim
!pcc  !pcc  if ( eigenvalues(i).is_zero(.tol)) then
!pcc       if (NOT eigenvalues(i).is_zero(.tol)) then
!pcc  !avr07    if (NOT eigenvalues(i).is_zero(TOL(3))) then
!pcc         h=h+1
!pcc       end
!pcc     end
!pcc     eigenvectors2.create(h,dim)
!pcc     stdout.text( " ")
!pcc !pcc    stdout.show("dimension of spectator 2-external space",h)
!pcc     stdout.show("dimension of spectator 2-internal space",h)
!pcc     stdout.text( " ")
!pcc     h=0
!pcc     do i=1,dim
!pcc !pcc      if ( eigenvalues(i).is_zero(.tol)) then
!pcc       if (NOT eigenvalues(i).is_zero(.tol)) then
!pcc !avr07      if (NOT eigenvalues(i).is_zero(TOL(3))) then
!pcc         h=h+1
!pcc         eigenvectors2(h,:)=eigenvectors(:,i)
!pcc       end
!pcc     end
!pcc     eigenvalues.destroy !temp
!pcc     eigenvectors.destroy !temp
!pcc   end
!pcc
!pcc   make_2_internal_space_old(order_ket,eigenvectors2,print_hamiltonian,spin_sym) ::: leaky
!pcc   ! Evaluate tA.A where A is the 2-internal matrix of the 
!pcc   ! spectator geminals product and solve its eigenproblem
!pcc     order_ket :: VEC{INT}, IN
!pcc     eigenvectors2 :: MAT{REAL}*
!pcc     print_hamiltonian :: BIN, optional
!pcc     spin_sym :: BIN, optional
!pcc     eigenvalues :: VEC{REAL}* !temp
!pcc     eigenvectors :: MAT{REAL}*
!pcc     res :: MAT{REAL}*
!pcc     R :: MAT5{REAL}* !temp
!pcc     n_geminals,n_bf :: INT
!pcc     i,h,l1,l2 :: INT
!pcc     dim :: INT
!pcc     print_default :: BIN
!pcc     spin_sym_default :: BIN
!pcc     print_default = FALSE
!pcc     spin_sym_default = TRUE
!pcc     if (present(print_hamiltonian)) print_default = print_hamiltonian
!pcc     if (present(spin_sym)) spin_sym_default = spin_sym
!pcc     n_geminals=size(order_ket)
!pcc     n_bf=.n_bf
!pcc     if (NOT spin_sym_default) then
!pcc       dim=n_bf*n_bf
!pcc       R.create(dim,n_geminals,n_geminals,n_bf,n_bf)
!pcc       R=ZERO
!pcc       .make_2_internal_matrix(order_ket,R)
!pcc     else
!pcc       dim=(n_bf+1)*n_bf/2
!pcc       R.create(dim,n_geminals,n_geminals,n_bf,n_bf)
!pcc       R=ZERO
!pcc       .make_2_internal_matrix_singlet(order_ket,R)
!pcc     end
!pcc     res.create(dim,dim)
!pcc     do l1=1,dim
!pcc       do l2=1,dim
!pcc          res(l1,l2)=sum(R(l1,:,:,:,:)*R(l2,:,:,:,:))
!pcc       end
!pcc     end
!pcc     R.destroy !temp
!pcc     eigenvalues.create(dim)
!pcc     eigenvectors.create(dim,dim)
!pcc     res.solve_eigenproblem(eigenvalues,eigenvectors)
!pcc     res.destroy !temp
!pcc     if (print_default) then
!pcc       stdout.text( " ")
!pcc       stdout.text( "2-internal matrix eigenvalues")
!pcc       stdout.text( " ")
!pcc       stdout.put(eigenvalues)
!pcc     end
!pcc     h=0
!pcc     do i=1,dim
!pcc !avr07      if (NOT eigenvalues(i).is_zero(.tol)) then
!pcc       if (NOT eigenvalues(i).is_zero(TOL(4))) then
!pcc         h=h+1
!pcc       end
!pcc     end
!pcc     eigenvectors2.create(h,dim)
!pcc     stdout.text( " ")
!pcc     stdout.show("dimension of 2-internal space",h)
!pcc     stdout.text( " ")
!pcc     h=0
!pcc     do i=1,dim
!pcc !avr07      if (NOT eigenvalues(i).is_zero(.tol)) then
!pcc       if (NOT eigenvalues(i).is_zero(TOL(4))) then
!pcc         h=h+1
!pcc         eigenvectors2(h,:)=eigenvectors(:,i)
!pcc       end
!pcc     end
!pcc     eigenvalues.destroy !temp
!pcc     eigenvectors.destroy !temp
!pcc   end
!pcc
!pcc   make_2_internal_space(order_ket,eigenvectors2,ig_tol,print_hamiltonian,spin_sym) ::: leaky
!pcc   ! Evaluate tA.A where A is the 2-internal matrix of the 
!pcc   ! spectator geminals product and solve its eigenproblem
!pcc     order_ket :: VEC{INT}, IN
!pcc     eigenvectors2 :: MAT{REAL}*
!pcc     ig_tol :: REAL, optional
!pcc     print_hamiltonian :: BIN, optional
!pcc     spin_sym :: BIN, optional
!pcc     eigenvalues :: VEC{REAL}* !temp
!pcc     eigenvectors :: MAT{REAL}*
!pcc     res :: MAT{REAL}*
!pcc     R :: MAT5{REAL}* !temp
!pcc     tol :: REAL
!pcc     n_geminals,n_bf :: INT
!pcc     i,h,l1,l2 :: INT
!pcc     dim :: INT
!pcc     print_default :: BIN
!pcc     spin_sym_default :: BIN
!pcc     tol=INTERNAL_GEMINAL_TOL
!pcc     print_default = FALSE
!pcc     spin_sym_default = TRUE
!pcc     if (present(ig_tol)) tol = ig_tol
!pcc     if (present(print_hamiltonian)) print_default = print_hamiltonian
!pcc     if (present(spin_sym)) spin_sym_default = spin_sym
!pcc     n_geminals=size(order_ket)
!pcc     n_bf=.n_bf
!pcc     if (NOT spin_sym_default) then
!pcc       dim=n_bf*n_bf
!pcc       R.create(dim,n_geminals,n_geminals,n_bf,n_bf)
!pcc       R=ZERO
!pcc       .make_2_internal_matrix(order_ket,R)
!pcc     else
!pcc       dim=(n_bf+1)*n_bf/2
!pcc       R.create(dim,n_geminals,n_geminals,n_bf,n_bf)
!pcc       R=ZERO
!pcc       .make_2_internal_matrix_singlet(order_ket,R)
!pcc     end
!pcc     res.create(dim,dim)
!pcc     do l1=1,dim
!pcc       do l2=1,dim
!pcc          res(l1,l2)=sum(R(l1,:,:,:,:)*R(l2,:,:,:,:))
!pcc       end
!pcc     end
!pcc     R.destroy !temp
!pcc     eigenvalues.create(dim)
!pcc     eigenvectors.create(dim,dim)
!pcc     res.solve_eigenproblem(eigenvalues,eigenvectors)
!pcc     res.destroy !temp
!pcc     if (print_default) then
!pcc       stdout.text( " ")
!pcc       stdout.text( "2-internal matrix eigenvalues")
!pcc       stdout.text( " ")
!pcc       stdout.put(eigenvalues)
!pcc     end
!pcc     h=count(mask= eigenvalues >tol)
!pcc     eigenvectors2.create(h,dim)
!pcc     stdout.text( " ")
!pcc     stdout.show("dimension of 2-internal space",h)
!pcc     stdout.text( " ")
!pcc     h=0
!pcc     do i=1,dim
!pcc       if (NOT eigenvalues(i).is_zero(tol)) then
!pcc         h=h+1
!pcc         eigenvectors2(h,:)=eigenvectors(:,i)
!pcc       end
!pcc     end
!pcc     eigenvalues.destroy !temp
!pcc     eigenvectors.destroy !temp
!pcc   end
!pcc
!pcc   spectator_2_internal_matrix_singlet(order_ket,res2)
!pcc   !calculate the singlet part of the 2 internal matrix elements 
!pcc     order_ket :: VEC{INT}, IN
!pcc     res2 :: MAT5{REAL}*
!pcc     res :: MAT5{REAL}*
!pcc     order_vec :: VEC{INT}*
!pcc     i,h,j,k,b1,b4,m :: INT
!pcc     n_geminals :: INT
!pcc     norm :: REAL
!pcc 
!pcc     n_geminals =size(order_ket)
!pcc     norm=ONE/sqrt(TWO)
!pcc     res.create(.n_bf*.n_bf,n_geminals,n_geminals,.n_bf,.n_bf)
!pcc     .spectator_2_internal_matrix(order_ket,res)
!pcc     do i=1,.n_bf
!pcc       do j=1,i-1
!pcc         res((i-1)*.n_bf+j,:,:,:,:)=norm*(res((i-1)*.n_bf+j,:,:,:,:)+res((j-1)*.n_bf+i,:,:,:,:))
!pcc       end
!pcc     end
!pcc     order_vec.create((.n_bf+1)*.n_bf/2)
!pcc     h=1
!pcc     do i=1,.n_bf
!pcc       do j=1,i
!pcc         order_vec(h)=(i-1)*.n_bf + j
!pcc         h=h+1
!pcc       end
!pcc     end 
!pcc     res2 = res(order_vec,:,:,:,:)
!pcc     res.destroy
!pcc     order_vec.destroy
!pcc   end
!pcc
!pcc   make_2_internal_matrix_singlet_old(order_ket,res2)
!pcc   !calculate the singlet part of the 2 internal matrix elements 
!pcc     order_ket :: VEC{INT}, IN
!pcc     res2 :: MAT5{REAL}*
!pcc     res :: MAT5{REAL}*
!pcc     order_vec :: VEC{INT}*
!pcc     i,h,j,k,b1,b4,m :: INT
!pcc     n_geminals :: INT
!pcc     norm :: REAL
!pcc 
!pcc     n_geminals =size(order_ket)
!pcc     norm=ONE/sqrt(TWO)
!pcc     res.create(.n_bf*.n_bf,n_geminals,n_geminals,.n_bf,.n_bf)
!pcc     .make_2_internal_matrix(order_ket,res)
!pcc     do i=1,.n_bf
!pcc       do j=1,i-1
!pcc         res((i-1)*.n_bf+j,:,:,:,:)=norm*(res((i-1)*.n_bf+j,:,:,:,:)+res((j-1)*.n_bf+i,:,:,:,:))
!pcc       end
!pcc     end
!pcc     order_vec.create((.n_bf+1)*.n_bf/2)
!pcc     h=1
!pcc     do i=1,.n_bf
!pcc       do j=1,i
!pcc         order_vec(h)=(i-1)*.n_bf + j
!pcc         h=h+1
!pcc       end
!pcc     end 
!pcc     res2 = res(order_vec,:,:,:,:)
!pcc     res.destroy
!pcc     order_vec.destroy
!pcc   end
!pcc
!pcc   make_2_internal_matrix_singlet(order_ket,res2)
!pcc   !calculate the singlet part of the 2 internal matrix elements 
!pcc     order_ket :: VEC{INT}, IN
!pcc     res2 :: MAT5{REAL}*
!pcc     res :: MAT5{REAL}*
!pcc     order_vec :: VEC{INT}*
!pcc     h,i,j,k :: INT
!pcc     n_geminals,n_bf :: INT
!pcc     norm :: REAL
!pcc 
!pcc     n_geminals =size(order_ket)
!pcc     n_bf=.n_bf
!pcc     norm=ONE/sqrt(TWO)
!pcc     res.create(n_bf*n_bf,n_geminals,n_geminals,n_bf,n_bf)
!pcc     .make_2_internal_matrix(order_ket,res)
!pcc     do i=1,n_bf
!pcc       k=i-1
!pcc       do j=1,k
!pcc         res(k*n_bf+j,:,:,:,:)=norm*(res(k*n_bf+j,:,:,:,:)+res((j-1)*n_bf+i,:,:,:,:))
!pcc       end
!pcc     end
!pcc     order_vec.create((n_bf+1)*n_bf/2)
!pcc     h=1
!pcc     do i=1,n_bf
!pcc       k=i-1
!pcc       do j=1,i
!pcc         order_vec(h)=k*n_bf + j
!pcc         h=h+1
!pcc       end
!pcc     end 
!pcc     res2 = res(order_vec,:,:,:,:)
!pcc     res.destroy
!pcc     order_vec.destroy
!pcc   end
!pcc
!pcc   spectator_2_internal_matrix(order_ket,res)
!pcc   !calculate the 2 internal matrix elements 
!pcc     order_ket :: VEC{INT}, IN
!pcc     res :: MAT5{REAL}, INOUT
!pcc     bra2 :: VEC{MAT_{REAL}}*
!pcc     h,j,k,b1,b4,m :: INT
!pcc     n_geminals :: INT
!pcc
!pcc     n_geminals =size(order_ket)
!pcc   !  res.create(.n_bf*.n_bf,n_geminals,n_geminals,.n_bf,.n_bf)
!pcc     res=ZERO
!pcc     bra2.create(n_geminals+1)
!pcc     do k=1,n_geminals+1
!pcc       bra2(k).element.create(.n_bf,.n_bf)
!pcc       bra2(k)[:,:]=.bra(k)[:,:]
!pcc     end
!pcc     do k = 1,n_geminals
!pcc       do j = 1,k
!pcc         h=1
!pcc         do m=1,n_geminals
!pcc           if (m/=k OR m/=j) then
!pcc             .bra(h)[:,:] = .ket(order_ket(m))[:,:]
!pcc              h=h+1
!pcc           end
!pcc         end
!pcc         if ( j == k ) then
!pcc           .overlap_for_spectator2(order_ket,res(:,j,k,1,1))
!pcc         else
!pcc           do b1= 1,.n_bf
!pcc             do b4 = 1,.n_bf
!pcc               .bra(n_geminals-1)[:,:]=ZERO 
!pcc               .bra(n_geminals-1)[b1,b4]=ONE
!pcc               .overlap_for_spectator2(order_ket,res(:,j,k,b1,b4))
!pcc             end
!pcc           end
!pcc         end
!pcc       end
!pcc     end
!pcc     do k=1,n_geminals+1
!pcc       .bra(k)[:,:]=bra2(k)[:,:]
!pcc     end
!pcc     bra2.destroy
!pcc   end
!pcc
!pcc   make_2_internal_matrix_old(order_ket,res)
!pcc   !calculate the 2 internal matrix elements 
!pcc     order_ket :: VEC{INT}, IN
!pcc     res :: MAT5{REAL}, INOUT
!pcc     bra2 :: VEC{MAT_{REAL}}*
!pcc     h,j,k,b1,b4,m :: INT
!pcc     n_geminals :: INT
!pcc
!pcc     n_geminals =size(order_ket)
!pcc     res=ZERO
!pcc     bra2.create(n_geminals)
!pcc     do k=1,n_geminals
!pcc       bra2(k).element.create(.n_bf,.n_bf)
!pcc       bra2(k)[:,:]=.bra(k)[:,:]
!pcc     end
!pcc     do k = 1,n_geminals
!pcc       do j = 1,k
!pcc         h=1
!pcc         do m=1,n_geminals
!pcc           if (m/=k OR m/=j) then
!pcc             .bra(h)[:,:] = .ket(order_ket(m))[:,:]
!pcc              h=h+1
!pcc           end
!pcc         end
!pcc         if ( j == k ) then
!pcc           .overlap_for_spectator2(order_ket,res(:,j,k,1,1))
!pcc         else
!pcc           do b1= 1,.n_bf
!pcc             do b4 = 1,.n_bf
!pcc               .bra(n_geminals-1)[:,:]=ZERO 
!pcc               .bra(n_geminals-1)[b1,b4]=ONE
!pcc               .overlap_for_spectator2(order_ket,res(:,j,k,b1,b4))
!pcc             end
!pcc           end
!pcc         end
!pcc       end
!pcc     end
!pcc     do k=1,n_geminals
!pcc       .bra(k)[:,:]=bra2(k)[:,:]
!pcc     end
!pcc     bra2.destroy
!pcc   end
!pcc
!pcc   make_2_internal_matrix(order_ket,res)
!pcc   !calculate the 2 internal matrix elements 
!pcc     order_ket :: VEC{INT}, IN
!pcc     res :: MAT5{REAL}, INOUT
!pcc     bra2 :: VEC{MAT_{REAL}}*
!pcc     h,j,k,b1,b4,m :: INT
!pcc     n_geminals,n_bf :: INT
!pcc
!pcc     n_geminals =size(order_ket)
!pcc     n_bf=.n_bf
!pcc     res=ZERO
!pcc     bra2.create(n_geminals)
!pcc     do k=1,n_geminals
!pcc       bra2(k).element.create(n_bf,n_bf)
!pcc       bra2(k)[:,:]=.bra(k)[:,:]
!pcc     end
!pcc     do k = 1,n_geminals
!pcc       do j = 1,k
!pcc         h=1
!pcc         do m=1,n_geminals
!pcc           if (m/=k OR m/=j) then
!pcc             .bra(h)[:,:] = .ket(order_ket(m))[:,:]
!pcc              h=h+1
!pcc           end
!pcc         end
!pcc         if ( j == k ) then
!pcc           .overlap_for_spectator2(order_ket,res(:,j,k,1,1))
!pcc         else
!pcc           do b1= 1,n_bf
!pcc             do b4 = 1,n_bf
!pcc               .bra(n_geminals-1)[:,:]=ZERO 
!pcc               .bra(n_geminals-1)[b1,b4]=ONE
!pcc               .overlap_for_spectator2(order_ket,res(:,j,k,b1,b4))
!pcc             end
!pcc           end
!pcc         end
!pcc       end
!pcc     end
!pcc     do k=1,n_geminals
!pcc       .bra(k)[:,:]=bra2(k)[:,:]
!pcc     end
!pcc     bra2.destroy
!pcc   end
!pcc
!pcc   overlap_for_spectator2(order_ket,res) 
!pcc   ! 
!pcc!comments:
!pcc!special_ket are always created at the end so that if ii is a special ket,
!pcc!than jj>ii is also a special ket. This allows some simplifications but may be a
!pcc!bit limitative in the future.
!pcc     order_ket :: VEC{INT}, IN
!pcc    ! res :: VEC{REAL}(.n_bf*.n_bf)
!pcc     res :: VEC{REAL}
!pcc     ENSURE(order_ket.dim>0,"dim negative or zero")
!pcc     jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2,i,h,ll :: INT
!pcc     reorder_ket :: VEC{INT}*
!pcc     fac :: VEC{REAL}*
!pcc     temp_qa_ja :: MAT3{REAL}*
!pcc     temp_qb_jb :: MAT3{REAL}*
!pcc     matemp :: MAT{REAL}*
!pcc     bra :: VEC{REAL}*
!pcc!write(*,*) 'overlap'
!pcc     dim = order_ket.dim
!pcc     res(:) = ZERO
!pcc!     write(*,*) 'dimension',dim,.n_bf
!pcc     if (dim==1) then ! Only Case 1
!pcc       j = order_ket(1)
!pcc       if (.special_ket(j)[1]>0) then
!pcc!       write(*,*) 'special'             
!pcc         bj1 = .special_ket(j)[1]                 
!pcc         bj2 = .special_ket(j)[2]
!pcc         res((bj1-1)*.n_bf+bj2)=ONE                
!pcc       else
!pcc         do k=1,.n_bf
!pcc           do i=1,.n_bf
!pcc             res((i-1)*.n_bf+k)=.ket(j)[i,k]
!pcc           end
!pcc         end
!pcc       end 
!pcc       return
!pcc     else ! dim > 1
!pcc       bra.create(.n_bf*.n_bf)
!pcc       fac.create(.n_bf*.n_bf)
!pcc       reorder_ket.create(dim-1)
!pcc       temp_qa_ja.create(.n_bf*.n_bf,.n_bf,.n_bf)
!pcc       temp_qb_jb.create(.n_bf*.n_bf,.n_bf,.n_bf)
!pcc       do jj = dim,1,-1
!pcc         j = order_ket(jj)
!pcc !   write(*,*) 'jj,j',jj,j
!pcc
!pcc
!pcc           if (.special_ket(j)[1]>0) then
!pcc             bj1 = .special_ket(j)[1]
!pcc             bj2 = .special_ket(j)[2]
!pcc! Case 2
!pcc             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!pcc             do kk = dim,jj+1,-1
!pcc               k = order_ket(kk)
!pcc!    write(*,*) 'special','kk,k',kk,k
!pcc               DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!pcc!assume special_ket's are also ordered at the end in the initial guess
!pcc               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!pcc               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!pcc               reorder_ket(dim-1) = k 
!pcc               bk1 = .special_ket(k)[1]
!pcc               bk2 = .special_ket(k)[2]
!pcc!write(*,*) k,bj1,bk2,bj2,bk2
!pcc               if(bj1/=bk1 OR bj2/=bk2) then
!pcc                 bra(:)=ZERO
!pcc                 bra((bk1-1)*.n_bf+bj2)=ONE
!pcc                 fac=bra
!pcc                 if (NOT fac.is_zero(.tol)) then
!pcc                   .special_ket(k)[1] = bj1
!pcc                 ! .special_ket(k)[2] = bk2
!pcc                   res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                   .special_ket(k)[1] = bk1
!pcc                 end
!pcc                 bra(:)=ZERO
!pcc                 bra((bj1-1)*.n_bf+bk2)=ONE
!pcc                 fac=bra
!pcc                 if (NOT fac.is_zero(.tol)) then
!pcc                !  .special_ket(k)[1] = bk1
!pcc                   .special_ket(k)[2] = bj2
!pcc                   res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                   .special_ket(k)[2] = bk2
!pcc                 end
!pcc               else ! bj1==bk1 AND bj2==bk2
!pcc                 bra(:)=ZERO
!pcc                 bra((bk1-1)*.n_bf+bk2)=ONE
!pcc                 fac=TWO*bra
!pcc                 if (NOT fac.is_zero(.tol)) then
!pcc                !  .special_ket(k)[1] = bk1
!pcc                 ! .special_ket(k)[2] = bk2
!pcc                   res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                 end
!pcc               end ! bj1==bk1 AND bj2==bk2
!pcc   !   write(*,*) 'case 2 j et k special',dim
!pcc             end !do kk
!pcc! Case 1
!pcc            ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!pcc             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!pcc             bra(:)=ZERO
!pcc             bra((bj1-1)*.n_bf+bj2)=ONE
!pcc             fac=bra
!pcc             if (NOT fac.is_zero(.tol)) then
!pcc               res = res + .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc             end
!pcc   !   write(*,*) 'case 1 j special',dim
!pcc           else !j not special
!pcc             do bj1=1,.n_bf
!pcc             do bq1=1,.n_bf
!pcc               bra=ZERO
!pcc               do ll=1,.n_bf
!pcc                 bra((ll-1)*.n_bf+bq1)=.ket(j)[ll,bj1]
!pcc               end
!pcc               temp_qa_ja(:,bq1,bj1)=bra
!pcc               bra=ZERO
!pcc               do ll=1,.n_bf
!pcc                 bra((bq1-1)*.n_bf+ll)=.ket(j)[bj1,ll]
!pcc               end
!pcc               temp_qb_jb(:,bq1,bj1)=bra(:)
!pcc             end
!pcc             end
!pcc! Case 2
!pcc             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!pcc             do kk = dim,jj+1,-1
!pcc               k = order_ket(kk)
!pcc  !  write(*,*) 'case 2 kk,k',kk,k
!pcc               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!pcc               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!pcc               reorder_ket(dim-1) = k
!pcc               if (.special_ket(k)[1]>0) then ! k special
!pcc                 bk1 = .special_ket(k)[1]
!pcc                 bk2 = .special_ket(k)[2]
!pcc                 do bj1 = 1,.n_bf
!pcc                   fac=temp_qb_jb(:,bk1,bj1)
!pcc                   if (NOT fac.is_zero(.tol) AND bj1 /= bk1) then
!pcc                   ! .special_ket(k)[2] = bk2
!pcc                     .special_ket(k)[1] = bj1
!pcc                     res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                     .special_ket(k)[1] = bk1
!pcc                   end
!pcc                 end
!pcc                 do bj2 = 1,.n_bf
!pcc                   fac=temp_qa_ja(:,bk2,bj2)
!pcc                   if (NOT fac.is_zero(.tol) AND bj2 /= bk2) then
!pcc                   ! .special_ket(k)[1] = bk1
!pcc                     .special_ket(k)[2] = bj2
!pcc                     res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                     .special_ket(k)[2] = bk2
!pcc                   end
!pcc                 end
!pcc                 fac=temp_qb_jb(:,bk1,bk1)+temp_qa_ja(:,bk2,bk2)
!pcc                 if (NOT fac.is_zero(.tol)) then
!pcc                 ! .special_ket(k)[1] = bk1
!pcc                 ! .special_ket(k)[2] = bk2
!pcc                   res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                 end
!pcc               else ! k not special
!pcc                 do bk2 = 1,.n_bf
!pcc                 do bj1 = 1,.n_bf
!pcc                   do h=1,.n_bf*.n_bf
!pcc                   fac(h)=sum(temp_qb_jb(h,:,bj1)*.ket(k)[:,bk2]+temp_qa_ja(h,:,bk2)*.ket(k)[bj1,:])
!pcc                   end
!pcc                   if (NOT fac.is_zero(.tol)) then
!pcc                     .special_ket(k)[1] = bj1 
!pcc                     .special_ket(k)[2] = bk2
!pcc                     res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                   end
!pcc                 end
!pcc                 end
!pcc                 .special_ket(k)[1] = 0 
!pcc                 .special_ket(k)[2] = 0
!pcc               end  ! if (.special_ket(k)
!pcc    !  write(*,*) 'case 2 k not special',dim
!pcc             end !do kk
!pcc! Case 1
!pcc          !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!pcc             reorder_ket(jj:dim-1) = order_ket(jj+1:dim)
!pcc             do h=1,.n_bf*.n_bf
!pcc             matemp => temp_qb_jb(h,:,:) 
!pcc             fac(h) = matemp.trace
!pcc             end
!pcc    !  write(*,*) 'case 1 j not special',dim
!pcc             if (NOT fac.is_zero(.tol)) then
!pcc               res = res + .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc             end
!pcc    !  write(*,*) 'case 1 j not special',dim
!pcc           end !j not special
!pcc       end  !do jj=dim,1,-1
!pcc       temp_qa_ja.destroy
!pcc       temp_qb_jb.destroy
!pcc       reorder_ket.destroy
!pcc       bra.destroy
!pcc       fac.destroy
!pcc       nullify(matemp)
!pcc     end ! if(dim==1)
!pcc   end
!pcc
!pcc   overlap_for_spectator(order_ket) result (res) ::: recursive
!pcc   ! Standard recursive function which evaluates the overlap integrals matrix
!pcc   ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!pcc!comments:
!pcc!special_ket are always created at the end so that if ii is a special ket,
!pcc!than jj>ii is also a special ket. This allows some simplifications but may be a
!pcc!bit limitative in the future.
!pcc     order_ket :: VEC{INT}, IN
!pcc     res :: REAL
!pcc     ENSURE(order_ket.dim>0,"dim negative or zero")
!pcc     jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
!pcc     reorder_ket :: VEC{INT}*
!pcc     fac :: REAL
!pcc     temp_bra_q :: MAT{REAL}*
!pcc     temp_qa_ja :: MAT{REAL}*
!pcc     temp_qb_jb :: MAT{REAL}*
!pcc
!pcc     dim = order_ket.dim
!pcc     res = ZERO
!pcc!write(*,*) dim
!pcc     if (dim==1) then ! Only Case 1
!pcc       j = order_ket(1)
!pcc       if (.special_ket(j)[1]>0) then             
!pcc         bj1 = .special_ket(j)[1]                 
!pcc         bj2 = .special_ket(j)[2]                
!pcc         fac = .bra(1)[bj1,bj2]
!pcc       else
!pcc         fac = sum(.bra(1)[:,:]*.ket(j)[:,:])
!pcc       end
!pcc       if (NOT fac.is_zero(.tol)) then
!pcc          res = fac
!pcc!       write(*,*)'overlap'
!pcc       end
!pcc       return
!pcc     else ! dim > 1
!pcc       temp_bra_q => .bra(dim)[:,:]
!pcc       reorder_ket.create(dim-1)
!pcc       temp_qa_ja.create(.n_bf,.n_bf)
!pcc       temp_qb_jb.create(.n_bf,.n_bf)
!pcc       do jj = dim,1,-1
!pcc         j = order_ket(jj)
!pcc!debug    write(*,*) 'jj,j',jj,j
!pcc           if (.special_ket(j)[1]>0) then
!pcc             bj1 = .special_ket(j)[1]
!pcc             bj2 = .special_ket(j)[2]
!pcc! Case 2
!pcc             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!pcc             do kk = dim,jj+1,-1
!pcc               k = order_ket(kk)
!pcc!debug    write(*,*) 'kk,k',kk,k
!pcc               DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!pcc!debug              if(.special_ket(k)[1]==0) then
!pcc!debug     write(*,*) "j special but not k"
!pcc!debug     stdout.show("dim=",dim)
!pcc!debug     do l=1,dim
!pcc!debug       stdout.show("l=",l)
!pcc!debug       stdout.show("order_ket(l)=",order_ket(l))
!pcc!debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!pcc!debug     end
!pcc!debug     stop
!pcc!debug     end
!pcc!assume special_ket's are also ordered at the end in the initial guess
!pcc               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!pcc               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!pcc               reorder_ket(dim-1) = k 
!pcc               bk1 = .special_ket(k)[1]
!pcc               bk2 = .special_ket(k)[2]
!pcc               if(bj1/=bk1 OR bj2/=bk2) then
!pcc                 fac=temp_bra_q(bk1,bj2)
!pcc                 if (NOT fac.is_zero(.tol)) then
!pcc                   .special_ket(k)[1] = bj1
!pcc                 ! .special_ket(k)[2] = bk2
!pcc                   res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                   .special_ket(k)[1] = bk1
!pcc                 end
!pcc                 fac=temp_bra_q(bj1,bk2)
!pcc                 if (NOT fac.is_zero(.tol)) then
!pcc                !  .special_ket(k)[1] = bk1
!pcc                   .special_ket(k)[2] = bj2
!pcc                   res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                   .special_ket(k)[2] = bk2
!pcc                 end
!pcc               else ! bj1==bk1 AND bj2==bk2
!pcc                 fac=TWO * temp_bra_q(bk1,bk2)
!pcc                 if (NOT fac.is_zero(.tol)) then
!pcc                !  .special_ket(k)[1] = bk1
!pcc                 ! .special_ket(k)[2] = bk2
!pcc                   res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                 end
!pcc               end ! bj1==bk1 AND bj2==bk2
!pcc!debug      write(*,*) 'case 2 j et k special',dim,res
!pcc             end !do kk
!pcc! Case 1
!pcc            ! reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!pcc             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!pcc             fac = temp_bra_q(bj1,bj2)
!pcc             if (NOT fac.is_zero(.tol)) then
!pcc               res = res + .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc             end
!pcc!debug      write(*,*) 'case 1 j special',dim,res
!pcc           else !j not special
!pcc             do bj1=1,.n_bf
!pcc             do bq1=1,.n_bf
!pcc               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*.ket(j)[:,bj1])
!pcc               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*.ket(j)[bj1,:])
!pcc             end
!pcc             end
!pcc! Case 2
!pcc             reorder_ket(1:jj-1)   = order_ket(1:jj-1) 
!pcc             do kk = dim,jj+1,-1
!pcc               k = order_ket(kk)
!pcc!debug    write(*,*) 'kk,k',kk,k
!pcc               reorder_ket(jj:kk-2) = order_ket(jj+1:kk-1) 
!pcc               reorder_ket(kk-1:dim-2) = order_ket(kk+1:dim) 
!pcc               reorder_ket(dim-1) = k 
!pcc               if (.special_ket(k)[1]>0) then ! k special
!pcc                 bk1 = .special_ket(k)[1]
!pcc                 bk2 = .special_ket(k)[2]
!pcc                 do bj1 = 1,.n_bf
!pcc                   fac=temp_qb_jb(bk1,bj1)
!pcc                   if (NOT fac.is_zero(.tol) AND bj1 /= bk1) then
!pcc                   ! .special_ket(k)[2] = bk2
!pcc                     .special_ket(k)[1] = bj1
!pcc                     res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                     .special_ket(k)[1] = bk1
!pcc                   end
!pcc                 end
!pcc                 do bj2 = 1,.n_bf
!pcc                   fac=temp_qa_ja(bk2,bj2)
!pcc                   if (NOT fac.is_zero(.tol) AND bj2 /= bk2) then
!pcc                   ! .special_ket(k)[1] = bk1
!pcc                     .special_ket(k)[2] = bj2
!pcc                     res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                     .special_ket(k)[2] = bk2
!pcc                   end
!pcc                 end
!pcc                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
!pcc                 if (NOT fac.is_zero(.tol)) then
!pcc                 ! .special_ket(k)[1] = bk1
!pcc                 ! .special_ket(k)[2] = bk2
!pcc                   res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                 end
!pcc               else ! k not special
!pcc                 do bk2 = 1,.n_bf
!pcc                 do bj1 = 1,.n_bf
!pcc                   fac =sum(temp_qb_jb(:,bj1)*.ket(k)[:,bk2]+temp_qa_ja(:,bk2)*.ket(k)[bj1,:])
!pcc                   if (NOT fac.is_zero(.tol)) then
!pcc                     .special_ket(k)[1] = bj1 
!pcc                     .special_ket(k)[2] = bk2
!pcc                     res = res - .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc                   end
!pcc                 end
!pcc                 end
!pcc                 .special_ket(k)[1] = 0 
!pcc                 .special_ket(k)[2] = 0
!pcc               end  ! if (.special_ket(k)
!pcc!debug      write(*,*) 'case 2 k not special',dim,res
!pcc             end !do kk
!pcc! Case 1
!pcc          !   reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
!pcc             reorder_ket(jj:dim-1) = order_ket(jj+1:dim) 
!pcc             fac = temp_qb_jb.trace
!pcc!debug      write(*,*) 'avant'
!pcc!debug      write(*,*) 'case 1 j not special',dim,fac,res
!pcc             if (NOT fac.is_zero(.tol)) then
!pcc               res = res + .overlap_for_spectator(reorder_ket) * fac ! <<
!pcc             end
!pcc!debug      write(*,*) 'apres'
!pcc!debug      write(*,*) 'case 1 j not special',dim,fac,res
!pcc           end !j not special
!pcc       end  !do jj=dim,1,-1
!pcc       temp_qa_ja.destroy
!pcc       temp_qb_jb.destroy
!pcc       reorder_ket.destroy
!pcc       nullify(temp_bra_q)
!pcc     end ! if(dim==1)
!pcc   end
!pcc
end
