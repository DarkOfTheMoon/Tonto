!-------------------------------------------------------------------------------
!
! GEMINAL_MF_SPECTRUM
!
! Copyright (C) Patrick Cassam-Chena√Ø and Dylan Jayatilaka, 2003
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!-------------------------------------------------------------------------------

module GEMINAL_MF_SPECTRUM

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

!   indices :: MAT{INT}(100,3), save
!   ind :: INT, save

contains

!*******************************************************************************
!                             Create and Destroy Routines
!*******************************************************************************

   create(n_geminals,n_bf,n_bas,use_hf_default) ::: leaky
   ! Create the geminals with "n_geminal" geminals, and each geminal having
   ! coeficients matrix of dimension "n_bf".
      self :: PTR
      n_geminals,n_bf,n_bas :: INT
      use_hf_default :: BIN, optional
      hf_default :: BIN
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults(n_geminals,n_bf,use_hf_default)
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      nullify(.bra)
      nullify(.ket)
      nullify(.special_ket)
   end

   destroy_ptr_part  ::: leaky
   ! Destroy the pointer parts of self
      .bra.destroy
      .ket.destroy
      .special_ket.destroy
   end

   create_copy(b) ::: leaky
   ! Create a copy of "b".
     b :: GEMINAL_MF_SPECTRUM, IN
     self :: PTR
     .create(b.n_geminals,b.n_bf,b.n_bas)
     .copy(b)
   end

   copy(b) ::: leaky
   ! Copy a basis "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
      b :: GEMINAL_MF_SPECTRUM, IN
      self = b
      if (b.bra.created) .bra.create_copy(b.bra)
      if (b.ket.created) .ket.create_copy(b.ket)
      if (b.special_ket.created) .special_ket.create_copy(b.special_ket)
      if (b.contraction_wfs.created) .contraction_wfs.create_copy(b.contraction_wfs)
      if (b.contraction_energies.created) .contraction_energies.create_copy(b.contraction_energies)
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   set_defaults(n_geminals,n_bf,use_hf_default) ::: leaky
   ! Create a default object.
     n_geminals,n_bf :: INT
     use_hf_default :: BIN, optional
     ENSURE(n_geminals<n_bf,"new size is not smaller")
     hf_default :: BIN
     i,j,k :: INT
     hf_default = FALSE
     if (present(use_hf_default)) hf_default = use_hf_default
     .n_geminals = n_geminals
     .n_bf = n_bf
     if (hf_default) then
       .n_bas = n_bf*n_bf-n_geminals+1 ! avoid the ground state basis functions
     else                              ! of the other contractions
       .n_bas = n_bf*n_bf
     end
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do i = 1,n_geminals     ! create ground state bras and kets
        .bra(i).element.create(n_bf,n_bf)
        .ket(i).element.create(n_bf,n_bf)
        .special_ket(i).element.create(2)
        .ket(i).element = ZERO
        .bra(i).element = ZERO
        if (hf_default) then
          .special_ket(i).element = i
          .bra(i)[i,i] = ONE
        else
          .special_ket(i).element = ZERO
        end
     end
     j = 1
     k = 1
     do i = 1,.n_bas     ! create coeficient matrices
        .contraction_wfs(i).element.create(n_bf,n_bf)
        .contraction_wfs(i).element = ZERO
        .contraction_energies(i)= ZERO
        if (hf_default) then
          .contraction_wfs(i)[j,k] = ONE
          if ( k == n_bf) then
            j = j + 1
            k = 1
          else
            k = k + 1
            if (k == j AND j <= n_geminals) then
              k = k + 1
            end
          end
        end
      end
           !.ket(3)[1,1] = ZERO ! to be removed, used for testing
           !.ket(2)[2,2] = ZERO ! to be removed, used for testing
           !.ket(3)[3,3] = ZERO ! to be removed, used for testing
           !.ket(4)[4,4] = ZERO ! to be removed, used for testing
           !.ket(5)[5,5] = ZERO ! to be removed, used for testing
           !.ket(1)[4,3] = ONE! to be removed, used for testing
           !.ket(2)[1,4] = ONE! to be removed, used for testing
           !.ket(3)[2,5] = ONE! to be removed, used for testing
           !.ket(4)[5,1] = ONE! to be removed, used for testing
           !.ket(5)[3,2] = ONE ! to be removed, used for testing
           !.bra(3)[5,5] = ONE ! to be removed, used for testing
           !.bra(3)[5,3] = ONE ! to be removed, used for testing
           !.bra(5)[3,5] = ONE ! to be removed, used for testing
           !.bra(5)[5,5] = ZERO ! to be removed, used for testing
           !.bra(3)[3,3] = ZERO ! to be removed, used for testing
           !.bra(5)[6,6] = ONE ! to be removed, used for testing
   end

!  ************
!  I/O Routines
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
       case ("do_overlap              "); .do_overlap
       case ("junk=                   "); .read_junk
       case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       case ("units=                  "); .read_units
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_units ::: get_from(OBJECT)
   ! Read a string which describes the units to be used
   end

   read_junk ::: get_from(OBJECT)
   ! Read in a junk string, useful for ignoring a field
   end

   read_n_bf ::: leaky
   ! Read in a new value of ".n_bf", which must be smaller than the initial
   ! basis set size. Truncate the coefficient matrices.
   ENSURE(.bra.created,"no bra")
   ENSURE(.bra(1).element.created,"no bra elements")
   ENSURE(.ket.created,"no ket")
   ENSURE(.ket(1).element.created,"no ket elements")
      n_bf,i :: INT
      stdin.read(n_bf)
      ENSURE(n_bf<=.n_bf,"new size is not smaller")
      .n_bf = n_bf
      do i = 1,.n_geminals
         .bra(i).element.shrink(.n_bf,.n_bf)
         .ket(i).element.shrink(.n_bf,.n_bf)
      end
   end

!  ********************
!  Key related routines
!  ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
     the_keys :: VEC{STR}
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")
     word :: STR
     width,k :: INT
     width = .table_width
     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case default; DIE("unknown option")
         end
         if (k==size(keys)) then
           stdout.flush ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
     res :: INT
   ENSURE(keys.created,"no keys")
     int_dash,real_dash,k :: INT
     word :: STR
     int_dash = 0
     real_dash = 0
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}                "); ! exit surrounding loop
         case ("put_configuration"); real_dash = real_dash + 1
         case ("put_label        "); int_dash = int_dash + 1
         case ("put_n_shells     "); int_dash = int_dash + 1
         case ("put_n_bf         "); int_dash = int_dash + 1
         case ("put_n_prim       "); int_dash = int_dash + 1
         case ("flush            "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  ***************
!  Inquiry methods
!  ***************

   same_as(b) result(res) 
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      self :: IN
      b :: GEMINAL_MF_SPECTRUM, IN
      res :: BIN
      res = FALSE
   end

!  ***************
!  Integal methods
!  ***************

   do_overlap
   ! Evaluate the overlap integrals
      res :: MAT{REAL}(.n_bas,.n_bas)
      res = .overlap
      stdout.text("The overlap matrix is ")
      stdout.put(res)
   end

   overlap result (res)
   ! Evaluate the overlap integrals
      res :: MAT{REAL}(.n_bas,.n_bas)
   ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
      i :: INT
      row_ind :: INT
      col_ind :: INT
      reorder :: VEC{INT}*
      row_ind = 0
      col_ind = 0
      reorder.create(.n_geminals)
      reorder = [ (i, i=1,.n_geminals) ]
      res = .overlap_for(reorder,row_ind,col_ind)
      reorder.destroy
   end

   overlap_for(order,row_ind,col_ind) result (res) ::: recursive
   ! Evaluate the overlap integrals
      row_ind :: INT
      col_ind :: INT
      order :: VEC{INT}
      res :: MAT{REAL}(.n_bas,.n_bas)
      ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2 :: INT
      fac,this,this1,this2 :: REAL
      reorder :: VEC{INT}*
      dim = order.dim
     !debug write(*,*) "dim =",dim

      res = ZERO
      
      if (dim==0) then
         res(row_ind,col_ind) = ONE
         res(col_ind,row_ind) = ONE
         return
      end
      if (dim==1) then
         ii=1
         i = order(ii)
        !debug   write(*,*) "i =",i
        if (i==1 AND col_ind==0 ) then
          do  col_ind=1,.n_bas
          do  row_ind=1,col_ind
        ! The simple case 1
             this = sum(.contraction_wfs(row_ind)[:,:]*.contraction_wfs(col_ind)[:,:])
             if (NOT this.is_zero) then
               reorder.create(0)
              !debug stdout.show("i =",i)
              !debug stdout.show("dim =",dim)
              !debug stdout.show("this =",this)
               res = res + .overlap_for(reorder,row_ind,col_ind) * this ! <<<<<<<<<<<<<<<<<<<<<<<
               reorder.destroy
             end
           end
           end
        else
          do  row_ind=1,col_ind
            if (.special_ket(i)[1]>0) then             
              bi1 = .special_ket(i)[1]                 
              bi2 = .special_ket(i)[2]                
              this = .contraction_wfs(row_ind)[bi1,bi2]
            else
              this = sum(.contraction_wfs(row_ind)[:,:]*.ket(i)[:,:])
            end
            if (NOT this.is_zero) then
              reorder.create(0)
            ! reorder.create(dim-1)
            ! reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
            ! reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
            !debug  stdout.show("i =",i)
            !debug  stdout.show("dim =",dim)
            !debug  if (.special_ket(i)[1]>0) then   
            !debug    stdout.show("bi1 =",bi1) 
            !debug    stdout.show("bi2 =",bi2) 
            !debug  end                              
            !debug  stdout.show("this =",this)
              res = res + .overlap_for(reorder,row_ind,col_ind) * this ! <<<<<<<<<<<<<<<<<<<<<<<
              reorder.destroy
            end
          end
        end
        ! no Case 2 when dim =1
      end
      ! this loop does something only if dim > 1
      do ii = dim,2,-1
         i = order(ii)
      !debug   write(*,*) "i =",i
         if (i==1 AND col_ind==0) then
           do  col_ind=1,row_ind
             this = sum(.bra(dim)[:,:]*.contraction_wfs(col_ind)[:,:])
             if (NOT this.is_zero) then
               reorder.create(dim-1)
               reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
               reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
               !debug  stdout.show("i =",i)
               !debug  stdout.show("dim =",dim)
          !debug if (.special_ket(i)[1]>0) then
               !debug  stdout.show("bi1 =",bi1)
               !debug  stdout.show("bi2 =",bi2)
          !debug end
               !debug  stdout.show("this =",this)
               res = res + .overlap_for(reorder,row_ind,col_ind) * this ! <<<<<<<<<<<<<<<<<<<<<<<
               reorder.destroy
             end
             do jj = dim,ii+1,-1
               j = order(jj)
               if (.special_ket(j)[1]>0) then
                 ! stdout.text("Case 2, only j special")
                 bj1 = .special_ket(j)[1]
                 bj2 = .special_ket(j)[2]
                 do bi1 = 1,.n_bf
                 do bi2 = 1,.n_bf
                   fac = .contraction_wfs(col_ind)[bi1,bi2]
                   if (NOT fac.is_zero) then
                   ! two cases
                     this1 = fac * .bra(dim)[bi1,bj2]
                     this2 = fac * .bra(dim)[bj1,bi2]
                     if (NOT this1.is_zero OR NOT this2.is_zero) then
                       reorder.create(dim-1)
                       reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
                       reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                       reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                       reorder(dim-1) = j ! This is not used, put to have same dim as in case 1
                       if (NOT this1.is_zero) then
          !debug           stdout.text("reorder:")
          !debug           stdout.put(reorder)
                  !     .special_ket(j)[1] = bj1 
                        .special_ket(j)[2] = bi2 ! j=reorder(dim-1)
                  !debug  stdout.show("i =",i)
                  !debug  stdout.show("j =",j)
                  !debug  stdout.show("dim =",dim)
                  !debug  stdout.show("bi1 =",bi1)
                  !debug  stdout.show("bj2 =",bj2)
                  !debug  stdout.show("this1 =",this1)
         !debug   write(*,*) "again 4, dim =",dim
         !debug            stdout.text("AFter assignment ...")
         !debug            stdout.show("i =",i)
         !debug            stdout.show("j =",j)
         !debug            stdout.show("bj1 =",.special_ket(j)[1])
         !debug            stdout.show("bj2 =",.special_ket(j)[2])
         !debug            stdout.text("reorder:")
         !debug            stdout.put(reorder)
         !debug   write(*,*) "A. recursing here, dim =",dim
                        res = res - .overlap_for(reorder,row_ind,col_ind) * this1 ! <<<<<<<<<<<<<<<<<<<<<<<
         !debug   write(*,*) "returned from recursion, dim =",dim
                       end  
                       if (NOT this2.is_zero) then
                        .special_ket(j)[1] = bi1 ! j=reorder(dim-1)
                  !     .special_ket(j)[2] = bj2 
                  !debug  stdout.show("i =",i)
                  !debug  stdout.show("j =",j)
                  !debug  stdout.show("dim =",dim)
                  !debug  stdout.show("bj1 =",bj1)
                  !debug  stdout.show("bi2 =",bi2)
                  !debug  stdout.show("this2 =",this2)
         !debug   write(*,*) "B. recursing here, dim =",dim
                        res = res - .overlap_for(reorder,row_ind,col_ind) * this2 ! <<<<<<<<<<<<<<<<<<<<<<<
         !debug   write(*,*) "returned from recursion, dim =",dim
                       end
                       .special_ket(j)[1] = 0 ! j=reorder(dim-1)
                       .special_ket(j)[2] = 0 ! j=reorder(dim-1)
                       reorder.destroy
                     end
                   end
                 end
                 end
                 else 
                 !  stdout.text("Case 2, NONE SPECIAL")
                 do bi1 = 1,.n_bf
                 do bi2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                 do bj2 = 1,.n_bf
                   fac = .contraction_wfs(col_ind)[bi1,bi2]*.ket(j)[bj1,bj2]
                   if (NOT fac.is_zero) then
                  !  two cases
                     this1 = fac * .bra(dim)[bi1,bj2]
                     this2 = fac * .bra(dim)[bj1,bi2]
                     if (NOT this1.is_zero OR NOT this2.is_zero) then
                       reorder.create(dim-1)
                       reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
                       reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                       reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                       reorder(dim-1) = j ! This is not used, put to have same dim as in case 1
                 !debug    stdout.show("i =",i)
                 !debug    stdout.show("j =",j)
                 !debug    stdout.show("bi1 =",bi1)
                 !debug    stdout.show("bi2 =",bi2)
                 !debug    stdout.show("bj1 =",bj1)
                 !debug    stdout.show("bj2 =",bj2)
                 !debug    stdout.text("reorder:")
                 !debug    stdout.put(reorder)
                 !debug    stdout.text("Before set ....")
                 !debug    stdout.text("special_ket:")
                 !debug    stdout.put(.special_ket)

                       if (NOT this1.is_zero) then
                        .special_ket(j)[1] = bj1 ! j=reorder(dim-1)
                        .special_ket(j)[2] = bi2 ! j=reorder(dim-1)
                   !debug stdout.show("i =",i)
                   !debug stdout.show("j =",j)
                   !debug stdout.show("dim =",dim)
                   !debug stdout.show("bi1 =",bi1)
                   !debug stdout.show("bj2 =",bj2)
                   !debug stdout.show("this1 =",this1)
                  !debug   stdout.text("After set ....")
                  !debug   stdout.text("special_ket:")
                  !debug   stdout.put(.special_ket)
        !debug    write(*,*) "A. recursing here, dim =",dim
                        res = res - .overlap_for(reorder,row_ind,col_ind) * this1 ! <<<<<<<<<<<<<<<<<<<<<<<
        !debug    write(*,*) "returned from recursion, dim =",dim
                       end
                       if (NOT this2.is_zero) then
                        .special_ket(j)[1] = bi1 ! j=reorder(dim-1)
                        .special_ket(j)[2] = bj2 ! j=reorder(dim-1)
                   !debug stdout.show("i =",i)
                   !debug stdout.show("j =",j)
                   !debug stdout.show("dim =",dim)
                   !debug stdout.show("bj1 =",bj1)
                   !debug stdout.show("bi2 =",bi2)
                   !debug stdout.show("this2 =",this2)
         !debug   write(*,*) "B. recursing here, dim =",dim
                        res = res - .overlap_for(reorder,row_ind,col_ind) * this2 ! <<<<<<<<<<<<<<<<<<<<<<<
         !debug   write(*,*) "returned from recursion, dim =",dim
                       end
                       .special_ket(j)[1] = 0 ! j=reorder(dim-1)
                       .special_ket(j)[2] = 0 ! j=reorder(dim-1)
                       reorder.destroy
                     end
                   end 
                 end
                 end
                 end
                 end
               end
             end
           end
         else
           ! The simple case 1
           if (.special_ket(i)[1]>0) then
              bi1 = .special_ket(i)[1]
              bi2 = .special_ket(i)[2]
              this = .bra(dim)[bi1,bi2]
           else
              this = sum(.bra(dim)[:,:]*.ket(i)[:,:])
           end
           if (NOT this.is_zero) then
       !debug write(*,*) "again, dim =",dim
               reorder.create(dim-1)
               reorder(1:ii-1)   = [ (order(j), j=1,ii-1) ]
               reorder(ii:dim-1) = [ (order(j), j=ii+1,dim) ]
         !debug  stdout.show("i =",i)
         !debug  stdout.show("dim =",dim)
         !debug  if (.special_ket(i)[1]>0) then
         !debug     stdout.show("bi1 =",bi1)
         !debug     stdout.show("bi2 =",bi2)
         !debug  end
         !debug  stdout.show("this =",this)
               res = res + .overlap_for(reorder,row_ind,col_ind) * this ! <<<<<<<<<<<<<<<<<<<<<<<
               reorder.destroy
           end
           ! Case 2
           do jj = dim,ii+1,-1
             j = order(jj)
             if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
              !       stdout.text("Case 2, i special, j special")
                  bi1 = .special_ket(i)[1]
                  bi2 = .special_ket(i)[2]
                  bj1 = .special_ket(j)[1]
                  bj2 = .special_ket(j)[2]
                  this1 = .bra(dim)[bi1,bj2]
                  this2 = .bra(dim)[bj1,bi2]
                  if (NOT this1.is_zero OR NOT this2.is_zero) then
                    reorder.create(dim-1)
                    reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
                    reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                    reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                    reorder(dim-1) = i ! This is not used, put to have same dim as in case 1
                    if (NOT this1.is_zero) then
                      .special_ket(i)[1] = bj1 ! i=reorder(dim-1)
                  !   .special_ket(i)[2] = bi2 
                !debug stdout.show("i =",i)
                !debug stdout.show("j =",j)
                !debug stdout.show("dim =",dim)
                !debug stdout.show("bi1 =",bi1)
                !debug stdout.show("bj2 =",bj2)
                !debug stdout.show("this1 =",this1)
        !debug write(*,*) "again 4, dim =",dim
             !debug     stdout.text("AFter assignment ...")
             !debug     stdout.show("i =",i)
             !debug     stdout.show("j =",j)
             !debug     stdout.show("bi1 =",.special_ket(i)[1])
             !debug     stdout.show("bi2 =",.special_ket(i)[2])
             !debug     stdout.text("reorder:")
             !debug     stdout.put(reorder)
             !debug     stdout.text("special_ket:")
             !debug     stdout.put(.special_ket)
       !debug  write(*,*) "A. recursing here, dim =",dim
                  res = res - .overlap_for(reorder,row_ind,col_ind) * this1 ! <<<<<<<<<<<<<<<<<<<<<<<
       !debug  write(*,*) "returned from recursion, dim =",dim
                    end 
                    if (NOT this2.is_zero) then
                  !   .special_ket(i)[1] = bi1
                      .special_ket(i)[2] = bj2 !  i=reorder(dim-1)
               !debug  stdout.show("i =",i)
               !debug  stdout.show("j =",j)
               !debug  stdout.show("dim =",dim)
               !debug  stdout.show("bj1 =",bj1)
               !debug  stdout.show("bi2 =",bi2)
               !debug  stdout.show("this2 =",this2)
        !debug write(*,*) "B. recursing here, dim =",dim
                  res = res - .overlap_for(reorder,row_ind,col_ind) * this2 ! <<<<<<<<<<<<<<<<<<<<<<<
        !debug write(*,*) "returned from recursion, dim =",dim
                    end
                    .special_ket(i)[1] = 0 ! i=reorder(dim-1)
                    .special_ket(i)[2] = 0 ! i=reorder(dim-1)
                    reorder.destroy
                  end
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
                  ! stdout.text("Case 2, only j special")
                   bj1 = .special_ket(j)[1]
                   bj2 = .special_ket(j)[2]
               do bi1 = 1,.n_bf
               do bi2 = 1,.n_bf
                  ! two cases?
                  fac = .ket(i)[bi1,bi2]
                 if (NOT fac.is_zero) then
                  this1 = fac * .bra(dim)[bi1,bj2]
                  this2 = fac * .bra(dim)[bj1,bi2]
                  if (NOT this1.is_zero OR NOT this2.is_zero) then
         !debug write(*,*) "again 1, dim =",dim
                    reorder.create(dim-1)
                    reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
                    reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                    reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                    reorder(dim-1) = j ! This is not used, put to have same dim as in case 1
   
                    if (NOT this1.is_zero) then
          !debug           stdout.text("reorder:")
          !debug           stdout.put(reorder)
                  !   .special_ket(j)[1] = bj1 
                      .special_ket(j)[2] = bi2 ! j=reorder(dim-1)
               !debug  stdout.show("i =",i)
               !debug  stdout.show("j =",j)
               !debug  stdout.show("dim =",dim)
               !debug  stdout.show("bi1 =",bi1)
               !debug  stdout.show("bj2 =",bj2)
               !debug  stdout.show("this1 =",this1)
         !debug   write(*,*) "again 4, dim =",dim
         !debug            stdout.text("AFter assignment ...")
         !debug            stdout.show("i =",i)
         !debug            stdout.show("j =",j)
         !debug            stdout.show("bj1 =",.special_ket(j)[1])
         !debug            stdout.show("bj2 =",.special_ket(j)[2])
         !debug            stdout.text("reorder:")
         !debug            stdout.put(reorder)
         !debug   write(*,*) "A. recursing here, dim =",dim
                  res = res - .overlap_for(reorder,row_ind,col_ind) * this1 ! <<<<<<<<<<<<<<<<<<<<<<<
         !debug   write(*,*) "returned from recursion, dim =",dim
                    end  
                    if (NOT this2.is_zero) then
                     .special_ket(j)[1] = bi1 ! j=reorder(dim-1)
                  !  .special_ket(j)[2] = bj2 
               !debug  stdout.show("i =",i)
               !debug  stdout.show("j =",j)
               !debug  stdout.show("dim =",dim)
               !debug  stdout.show("bj1 =",bj1)
               !debug  stdout.show("bi2 =",bi2)
               !debug  stdout.show("this2 =",this2)
         !debug   write(*,*) "B. recursing here, dim =",dim
                  res = res - .overlap_for(reorder,row_ind,col_ind) * this2 ! <<<<<<<<<<<<<<<<<<<<<<<
         !debug   write(*,*) "returned from recursion, dim =",dim
                    end
                  .special_ket(j)[1] = 0 ! j=reorder(dim-1)
                  .special_ket(j)[2] = 0 ! j=reorder(dim-1)
                  reorder.destroy
                  end
                 end
               end
               end
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
                 !  stdout.text("Case 2, NONE SPECIAL")
               do bi1 = 1,.n_bf
               do bi2 = 1,.n_bf
               do bj1 = 1,.n_bf
               do bj2 = 1,.n_bf
                  fac = .ket(i)[bi1,bi2]*.ket(j)[bj1,bj2]
                  if (NOT fac.is_zero) then
                  ! two cases
                    this1 = fac * .bra(dim)[bi1,bj2]
                    this2 = fac * .bra(dim)[bj1,bi2]
                    if (NOT this1.is_zero OR NOT this2.is_zero) then
   
                      reorder.create(dim-1)
                      reorder(1:ii-1) = [ (order(k), k=1,ii-1) ]
                      reorder(ii:jj-2) = [ (order(k), k=ii+1,jj-1) ]
                      reorder(jj-1:dim-2) = [ (order(k), k=jj+1,dim) ]
                      reorder(dim-1) = j ! This is not used, put to have same dim as in case 1
                 !debug    stdout.show("i =",i)
                 !debug    stdout.show("j =",j)
                 !debug    stdout.show("bi1 =",bi1)
                 !debug    stdout.show("bi2 =",bi2)
                 !debug    stdout.show("bj1 =",bj1)
                 !debug    stdout.show("bj2 =",bj2)
                 !debug    stdout.text("reorder:")
                 !debug    stdout.put(reorder)
                 !debug    stdout.text("Before set ....")
                 !debug    stdout.text("special_ket:")
                 !debug    stdout.put(.special_ket)

                      if (NOT this1.is_zero) then
                        .special_ket(j)[1] = bj1 ! j=reorder(dim-1)
                        .special_ket(j)[2] = bi2 ! j=reorder(dim-1)

                !debug stdout.show("i =",i)
                !debug stdout.show("j =",j)
                !debug stdout.show("dim =",dim)
                !debug stdout.show("bi1 =",bi1)
                !debug stdout.show("bj2 =",bj2)
                !debug stdout.show("this1 =",this1)
                  !debug   stdout.text("After set ....")
                  !debug   stdout.text("special_ket:")
                  !debug   stdout.put(.special_ket)
        !debug    write(*,*) "A. recursing here, dim =",dim
                  res = res - .overlap_for(reorder,row_ind,col_ind) * this1 ! <<<<<<<<<<<<<<<<<<<<<<<
        !debug    write(*,*) "returned from recursion, dim =",dim
                      end
                      if (NOT this2.is_zero) then
                        .special_ket(j)[1] = bi1 ! j=reorder(dim-1)
                        .special_ket(j)[2] = bj2 ! j=reorder(dim-1)
                !debug stdout.show("i =",i)
                !debug stdout.show("j =",j)
                !debug stdout.show("dim =",dim)
                !debug stdout.show("bj1 =",bj1)
                !debug stdout.show("bi2 =",bi2)
                !debug stdout.show("this2 =",this2)
         !debug   write(*,*) "B. recursing here, dim =",dim
                  res = res - .overlap_for(reorder,row_ind,col_ind) * this2 ! <<<<<<<<<<<<<<<<<<<<<<<
         !debug   write(*,*) "returned from recursion, dim =",dim
                      end
                      .special_ket(j)[1] = 0 ! j=reorder(dim-1)
                      .special_ket(j)[2] = 0 ! j=reorder(dim-1)
                      reorder.destroy
                    end
                  end 
               end
               end
               end
               end
             end
         end
         end
      end
   end

!  **************
!  Output methods
!  **************

   put
   ! Print out the object
      i :: INT
      stdout.text("GEMINAL_MF_SPECTRUM:")
      stdout.flush
      stdout.show("n_geminals =",.n_geminals)
      stdout.show("n_bf       =",.n_bf)
      stdout.show("n_bas       =",.n_bas)
      stdout.flush
      stdout.text("Bra:")
      do i = 1,.n_geminals
         stdout.text("Bra "//i.to_str.trim)
         stdout.put(.bra(i).element)
      end
      stdout.text("Ket:")
      do i = 1,.n_geminals
         stdout.text("Special ket "//i.to_str.trim)
         stdout.put(.special_ket(i).element)
         stdout.text("Ket "//i.to_str.trim)
         stdout.put(.ket(i).element)
      end
   end

end
