!-------------------------------------------------------------------------------
!
! GEMINAL_MF_SPECTRUM
!
! Copyright (C) Patrick Cassam-Chena√Ø and Dylan Jayatilaka, 2003
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!
!-------------------------------------------------------------------------------

module GEMINAL_MF_SPECTRUM

   implicit none

   keys :: VEC{STR}*, private DEFAULT_NULL

!   indices :: MAT{INT}(100,3), save
!   ind :: INT, save

contains

!*******************************************************************************
!                             Create and Destroy Routines
!*******************************************************************************

   create(name,nuc,n_geminals,n_bf,n_bas,use_hf_default) ::: leaky
   ! Create the geminals with "n_geminal" geminals, and each geminal having
   ! coeficients matrix of dimension "n_bf".
      self :: PTR
      name :: STR
      nuc :: REAL
      n_geminals,n_bf :: INT
      n_bas :: INT, optional
      use_hf_default :: BIN, optional
      hf_default :: BIN
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set_defaults(n_geminals,n_bf,use_hf_default)
      .name = name
      .nuclear_energy = nuc
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
      self :: PTR
   end

   nullify_ptr_part
   ! Nullify the pointer parts of self
      nullify(.bra)
      nullify(.ket)
      nullify(.special_ket)
   end

   destroy_ptr_part  ::: leaky
   ! Destroy the pointer parts of self
      .bra.destroy
      .ket.destroy
      .special_ket.destroy
   end

   create_copy(b) ::: leaky
   ! Create a copy of "b".
     b :: GEMINAL_MF_SPECTRUM, IN
     self :: PTR
     .create(b.name,b.nuclear_energy,b.n_geminals,b.n_bf,b.n_bas)
     .copy(b)
   end

   copy(b) ::: leaky
   ! Copy a basis "b" to "self". Make sure pointer parts are first
   ! destroyed or nullified, as you want.
      b :: GEMINAL_MF_SPECTRUM, IN
      self = b
      if (b.bra.created) .bra.create_copy(b.bra)
      if (b.ket.created) .ket.create_copy(b.ket)
      if (b.special_ket.created) .special_ket.create_copy(b.special_ket)
      if (b.contraction_wfs.created) .contraction_wfs.create_copy(b.contraction_wfs)
      if (b.contraction_energies.created) .contraction_energies.create_copy(b.contraction_energies)
   end

   created result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result(res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end

   set_defaults(n_geminals,n_bf,use_hf_default) ::: leaky
   ! Create a default object.
     n_geminals,n_bf :: INT
     use_hf_default :: BIN, optional
     ENSURE(n_geminals<n_bf,"n_geminals not less than n_bf")
     hf_default :: BIN
     i,j,k :: INT
     n_bfsq :: INT
!debug
!debug     R,S,T,U :: MAT{REAL}*
!debug     V,eigenvalues :: VEC{REAL}*
!debug     l :: INT
!debug     val :: REAL
!debug
     hf_default = FALSE
     if (present(use_hf_default)) hf_default = use_hf_default
     .n_geminals = n_geminals
     .n_bf = n_bf
      n_bfsq=n_bf*n_bf
     if (hf_default) then
       .n_bas = n_bfsq-(2*n_bf-n_geminals+1)*(n_geminals-1) ! avoid the ground state orbitals
     else                                                       ! of the other contractions
       .n_bas = n_bfsq
     end
     .bra.create(n_geminals) ! create bra and ket arrays
     .ket.create(n_geminals)
     .special_ket.create(n_geminals)
     .contraction_wfs.create(.n_bas)
     .contraction_energies.create(.n_bas)
     .contraction_energies = ZERO
     do i = 1,n_geminals     ! create ground state bras and kets
        .bra(i).element.create(n_bf,n_bf)
        .ket(i).element.create(n_bf,n_bf)
        .special_ket(i).element.create(2)
        .ket(i).element = ZERO
        .bra(i).element = ZERO
        .special_ket(i).element = 0
     end
     if (hf_default) then
       do i = 2,n_geminals     ! set ground state bras and kets
          .special_ket(i).element = i
          .bra(i)[i,i] = ONE
     !     .ket(i)[i,i] = ONE
       end
     end
     do i = 1,.n_bas     ! create coeficient matrices
       .contraction_wfs(i).element.create(n_bf,n_bf)
       .contraction_wfs(i).element = ZERO
       .contraction_energies(i)= ZERO
     end
     if (hf_default) then
       i = 1
       do j = 1, n_bf
       do k = 1, n_bf
         if (1<j AND j <= n_geminals OR 1<k AND k <= n_geminals ) cycle 
         .contraction_wfs(i)[j,k] = ONE
         i = i + 1
       end
       end
     end
     DIE_IF(i/=.n_bas+1,"i not equal to .n_bas+1") 
!debug      write(*,*) ".n_bas",.n_bas
!debug      stdout.text(".contraction_wfs(1)[:,:]")
!debug      stdout.put(.contraction_wfs(1)[:,:])
!debug      stdout.text(".contraction_wfs(2)[:,:]")
!debug      stdout.put(.contraction_wfs(2)[:,:])
!debug      stdout.text(std_time.time_taken("geminal job "))
!debug      stdout.text(std_time.cpu_time_taken("geminal job "))
      ! Rotate
      !do i = 1,n_geminals
      !  .special_ket(i).element = 0
      !end
!debug      S.create(n_bf,n_bf)
!debug      R.create(n_bf,n_bf)
!debug      eigenvalues.create(n_bf)
!debug      do i = 1,n_bf
!debug      do j = 1,i
!debug         call random_number(val)
!debug         S(i,j) = val
!debug         S(j,i) = val
!debug      end
!debug      end
!debug      S.solve_eigenproblem(eigenvalues,R)
!debug    !  stdout.text("R")
!debug    !  stdout.put(R)
!debug      S=matmul(R,transpose(R))
!debug      stdout.show("is unit matrix =",S.is_unit_matrix)
!debug      V.create(n_bf)
!debug      do i = 1,.n_bas
!debug        do j=1,n_bf
!debug        V=.contraction_wfs(i)[j,:]
!debug        .contraction_wfs(i)[j,:].to_product_of(R,V)
!debug        end
!debug        do k=1,n_bf
!debug        V=.contraction_wfs(i)[:,k]
!debug        .contraction_wfs(i)[:,k].to_product_of(R,V)
!debug        end
!debug!        val = ZERO
!debug!        do j=1,n_bf
!debug!        do k=1,n_bf
!debug!          val=val+ .contraction_wfs(i)[j,k]*.contraction_wfs(i)[j,k]
!debug!        end
!debug!        end
!debug!        write(*,*) "i",i,val
!debug      end
!debug      do i = .n_bas+1,.n_bas+n_geminals-1
!debug        do j=1,n_bf
!debug         V=.ket(i-.n_bas+1)[j,:]
!debug        .ket(i-.n_bas+1)[j,:].to_product_of(R,V)
!debug         V=.bra(i-.n_bas+1)[j,:]
!debug        .bra(i-.n_bas+1)[j,:].to_product_of(R,V)
!debug        end
!debug        do k=1,n_bf
!debug        V=.ket(i-.n_bas+1)[:,k]
!debug        .ket(i-.n_bas+1)[:,k].to_product_of(R,V)
!debug        V=.bra(i-.n_bas+1)[:,k]
!debug        .bra(i-.n_bas+1)[:,k].to_product_of(R,V)
!debug        end
!debug!        val = ZERO
!debug!        do j=1,n_bf
!debug!        do k=1,n_bf
!debug!          val=val+ .bra(i-.n_bas+1)[j,k]*.bra(i-.n_bas+1)[j,k]
!debug!        end
!debug!        end
!debug!        write(*,*) "i",i,val
!debug      end
!debug!      R.destroy
!debug!      R.create(.n_bas,.n_bas)
!debug!      S.destroy
!debug!      S.create(.n_bas,.n_bas)
!debug!      T.destroy
!debug!      T.create(.n_bas,.n_bas)
!debug!      U.destroy
!debug!      U.create(.n_bas,.n_bas)
!debug!      R=matmul(transpose(.bra(2)[:,:]),.bra(2)[:,:])
!debug!      S=matmul(.bra(2)[:,:],transpose(.bra(2)[:,:]))
!debug!      do i = 1,.n_bas
!debug!      T=matmul(.contraction_wfs(i)[:,:],R)+matmul(S,.contraction_wfs(i)[:,:])
!debug!        write(*,*) "T(1,1)",T(1,1)
!debug!        write(*,*) "T(2,1)",T(2,1)
!debug!        write(*,*) "T(1,2)",T(1,2)
!debug!        write(*,*) "T(2,2)",T(2,2)
!debug!      !    S=matmul(transpose(.contraction_wfs(i)[:,:]),.contraction_wfs(i)[:,:])
!debug!      U=matmul(transpose(.contraction_wfs(i)[:,:]),T)
!debug!          val=U.trace
!debug!        write(*,*) "i,trace",i,val
!debug!      end
!debug!!      V.create(n_bfsq)
!debug!!      do i = 1,.n_bas
!debug!!        V.to_product_of(R,reshape(.contraction_wfs(i).element,[n_bfsq]))
!debug!!        .contraction_wfs(i).element = reshape(V,[n_bf,n_bf])
!debug!!        val = ZERO
!debug!!        do j=1,n_bf
!debug!!        do k=1,n_bf
!debug!!          val=val+ .contraction_wfs(i)[j,k]*.contraction_wfs(i)[j,k]
!debug!!        end
!debug!!        end
!debug!!        write(*,*) "i",i,val
!debug!!      end
!debug!!      do i = .n_bas+1,n_bfsq
!debug!!        V.to_product_of(R,reshape(.ket(i-.n_bas+1).element,[n_bfsq]))
!debug!!        .ket(i-.n_bas+1).element = reshape(V,[n_bf,n_bf])
!debug!!        V.to_product_of(R,reshape(.bra(i-.n_bas+1).element,[n_bfsq]))
!debug!!        .bra(i-.n_bas+1).element = reshape(V,[n_bf,n_bf])
!debug!!        val = ZERO
!debug!!        do j=1,n_bf
!debug!!        do k=1,n_bf
!debug!!          val=val+ .bra(i-.n_bas+1)[j,k]*.bra(i-.n_bas+1)[j,k]
!debug!!        end
!debug!!        end
!debug!!        write(*,*) "i",i,val
!debug!!      end
!debug!!      .n_bas = ONE    
!debug!      V.destroy
!     .special_ket(5)[1] = 5
!     .special_ket(5)[2] = 6
!     .bra(5).element = ZERO
!     .bra(5)[5,6] = ONE
!debug      eigenvalues.destroy
!debug      R.destroy
!debug      S.destroy
!debug      T.destroy
!debug      U.destroy
!debug      stdout.text(std_time.time_taken("geminal job "))
!debug      stdout.text(std_time.cpu_time_taken("geminal job "))
!debug           !.ket(3)[1,1] = ZERO ! to be removed, used for testing
!debug           !.ket(2)[2,2] = ZERO ! to be removed, used for testing
!debug           !.ket(3)[3,3] = ZERO ! to be removed, used for testing
!debug           !.ket(4)[4,4] = ZERO ! to be removed, used for testing
!debug           !.ket(5)[5,5] = ZERO ! to be removed, used for testing
!debug           !.ket(1)[4,3] = ONE! to be removed, used for testing
!debug           !.ket(2)[1,4] = ONE! to be removed, used for testing
!debug           !.ket(3)[2,5] = ONE! to be removed, used for testing
!debug           !.ket(4)[5,1] = ONE! to be removed, used for testing
!debug           !.ket(5)[3,2] = ONE ! to be removed, used for testing
!debug           !.bra(3)[5,5] = ONE ! to be removed, used for testing
!debug           !.bra(3)[5,3] = ONE ! to be removed, used for testing
!debug           !.bra(5)[3,5] = ONE ! to be removed, used for testing
!debug           !.bra(5)[5,5] = ZERO ! to be removed, used for testing
!debug           !.bra(3)[3,3] = ZERO ! to be removed, used for testing
!debug           !.bra(5)[6,6] = ONE ! to be removed, used for testing
!debug   !stop
   end

!  ************
!  I/O Routines
!  ************

   read_keywords ::: get_from(OBJECT), recursive, leaky
   ! Read data from "stdin" using keyword style input.
   end

   process_keyword(keyword) ::: leaky
   ! Process command "keyword". Any required data needed by the "keyword" is
   ! inputted from "stdin".
     keyword :: STR, IN
     word :: STR
     word = keyword
     word.to_lower_case
     select case (word)
       case ("-- Regular options --   ")
       case ("}                       "); ! exit surrounding loop
       case ("do_overlap              "); .do_overlap
       case ("do_hamiltonian          "); .do_hamiltonian
       case ("n_bf=                   "); .read_n_bf
       case ("put                     "); .put
       ! These are only for making custom tables for the list type
       case ("-- Options for tables --")
       case  default ;      UNKNOWN(word)
     end
   end

   read_n_bf ::: leaky
   ! Read in a new value of ".n_bf", which must be smaller than the initial
   ! basis set size. Truncate the coefficient matrices.
   ENSURE(.bra.created,"no bra")
   ENSURE(.bra(1).element.created,"no bra elements")
   ENSURE(.ket.created,"no ket")
   ENSURE(.ket(1).element.created,"no ket elements")
      n_bf,i :: INT
      stdin.read(n_bf)
      ENSURE(n_bf<=.n_bf,"new size is not smaller")
      .n_bf = n_bf
      do i = 1,.n_geminals
         .bra(i).element.shrink(.n_bf,.n_bf)
         .ket(i).element.shrink(.n_bf,.n_bf)
      end
   end

!  ********************
!  Key related routines
!  ********************

   read_keys ::: get_from(OBJECT)
   ! Read the "keys".
   end

   process_keys ::: get_from(OBJECT), leaky
   ! Process each of the words in the "keys" list.
   end

   keys_created result (res) ::: get_from(OBJECT)
   ! Return TRUE if the list-element keys are created.
      res :: BIN
   end

   set_keys(the_keys) ::: get_from(OBJECT)
   ! This is for setting the "keys" externally.
     the_keys :: VEC{STR}
   end

   clear_keys ::: get_from(OBJECT)
   ! This is for destroying the "keys" externally.
   end

   put_table_footer ::: get_from(OBJECT)
   ! Output a table footer from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   end

   put_table_header
   ! Output a table header from the list of "keys". NOTE: not all keywords need
   ! contribute to the banner - any unrecognised keyword is skipped.
   ENSURE(keys.created,"no keys")
     word :: STR
     width,k :: INT
     width = .table_width
     if (width > 0) then
       stdout.dash(width=width)
       do k = 1,size(keys)
         word = keys(k)
         word.to_lower_case
         select case (word)
           case default; DIE("unknown option")
         end
         if (k==size(keys)) then
           stdout.flush ! In case they didn't write one.
           WARN("no flush keyword - you may later overrun the output buffer")
         end
       end
       stdout.dash(width=width)
     end
   end

   table_width result (res)
   ! Return the table width in characters, based on "keys".  Note that not all
   ! keywords need to contribute to the banner - if a keyword is not recognised,
   ! then it is skipped.
     res :: INT
   ENSURE(keys.created,"no keys")
     int_dash,real_dash,k :: INT
     word :: STR
     int_dash = 0
     real_dash = 0
     do k = 1,size(keys)
       word = keys(k)
       word.to_lower_case
       select case (word)
         case ("}                "); ! exit surrounding loop
         case ("put_configuration"); real_dash = real_dash + 1
         case ("put_label        "); int_dash = int_dash + 1
         case ("put_n_shells     "); int_dash = int_dash + 1
         case ("put_n_bf         "); int_dash = int_dash + 1
         case ("put_n_prim       "); int_dash = int_dash + 1
         case ("flush            "); exit
         case default
       end
     end
     res = int_dash * stdout.int_width + real_dash * stdout.real_width
   end

!  ***************
!  Inquiry methods
!  ***************

   same_as(b) result(res) 
   ! Return TRUE if the basis set "self" is the same as "b". Only the
   ! shell vector is compared to see if they are "really" the same.
      self :: IN
      b :: GEMINAL_MF_SPECTRUM, IN
      res :: BIN
      res = FALSE
   end

!  ***************
!  Integal methods
!  ***************

!todolater   do_2rdm(ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l)
!todolater   ! Evaluate the 2 electron density matrix element in a geminal induced basis set
!todolater   ! built over orthonormal orbitals
!todolater     ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l :: INT
!todolater     res :: MAT{REAL}(.n_bas,.n_bas)
!todolater   !debug   write(*,*) ".n_bas",.n_bas,".n_bf",.n_bf
!todolater      res = .two_rdm(ind_i,spin_i,ind_j,spin_j,ind_k,spin_k,ind_l,spin_l)
!todolater      stdout.text("The 2 electron density matrix element is ")
!todolater      stdout.put(res)
!todolater   end
! seems difficult to store all the 2RDM matrix elements 
! for the .n_bas*.n_bas pairs of functions of contraction 1

   make_int_archives(v)
   ! make intermediate integrals needed several times by the hamiltoinian_for
   ! function and archive them.
!WARNING we supposed H real
! afterwards should put the name of the molecule in the type so as to have:
!    eri_archive.set(.name,"h_integrals")
     v :: MAT4{REAL} 
     w :: MAT4{REAL}* 
     temp_i :: MAT{REAL}*
     temp_j :: MAT{REAL}*
     temp :: MAT{REAL}(.n_bf,.n_bf)
     string :: STR
     int_archive :: ARCHIVE
     i,j,k,l,bi1,bi2,bj1,bj2 :: INT

     w.create(.n_bf,.n_bf,.n_bf,.n_bf)
     do i = 2,.n_geminals
       if (.special_ket(i)[1]>0) then
         bi1= .special_ket(i)[1] 
         bi2= .special_ket(i)[2] 
         do j = i+1,.n_geminals
           string="int_gs"//j.to_str.trim//i.to_str.trim
           int_archive.set("h2o",string)
           if (.special_ket(j)[1]>0) then
             bj1= .special_ket(j)[1] 
             bj2= .special_ket(j)[2] 
             DIE_IF(bi1==bj1 OR bi2==bj2,"same spinorbital in too different special_kets") 
!             if(bi2>bj2) then
!               k=bi2
!               bi2=bj2
!               bj2=k
!             end
!             do k=1,bi2-1
!               do l=1,.n_bf
!                 v(:,:,l,k)=ZERO
!               end
!             end
!             do k=bi2+1,bj2-1
!               do l=1,.n_bf
!                 v(:,:,l,k)=ZERO
!               end
!             end
!             do k=bj2+1,.n_bf
!               do l=1,.n_bf
!                 v(:,:,l,k)=ZERO
!               end
!             end
!             do l=1,bj1-1
!               v(:,:,l,bi2)=ZERO
!             end
!             do l=bj1+1,.n_bf
!               v(:,:,l,bi2)=ZERO
!             end
!             do l=1,bi1-1
!               v(:,:,l,bj2)=ZERO
!             end
!             do l=bi1+1,.n_bf
!               v(:,:,l,bj2)=ZERO
!             end
             w=ZERO
             w(:,:,bj1,bi2)=v(:,:,bj1,bi2)
             w(:,:,bi1,bj2)=v(:,:,bi1,bj2)
             int_archive.write(w)
           else
           !  temp_j => .ket(j)[:]
            DIE("case i special_ket but not j not implemented, should not arise")
           end
         end
       else
         temp_i => .ket(i)[:,:] 
         do j = i+1,.n_geminals
           DIE_IF(.special_ket(j)[1]>0, "case j special_ket but not i not implemented, should not arise") 
           temp_j => .ket(j)[:,:]
           string="int_gs"//j.to_str.trim//i.to_str.trim
           int_archive.set("h2o",string)
           do bi2=1,.n_bf
           do bj1=1,.n_bf
           do bj2=1,.n_bf
           do bi1=1,.n_bf
               w(bi1,bj2,bj1,bi2)=temp_i(bi1,bi2)*temp_j(bj1,bj2)+temp_j(bi1,bi2)*temp_i(bj1,bj2)
           end
           end
           end
           end
           do bi2=1,.n_bf
           do bj1=1,.n_bf
             do bj2=1,.n_bf
             do bi1=1,.n_bf
               temp(bi1,bj2)=sum(v(:,:,bi1,bj2)*w(:,:,bj1,bi2))
             end
             end
             w(:,:,bj1,bi2)=temp
           end
           end
           int_archive.write(w)
         end
       end         
     end
     do i = 1,.n_bas
       temp_i => .contraction_wfs(i)[:,:] 
       do j = 2,.n_geminals
         string="int_c1-"//j.to_str.trim//"-"//i.to_str.trim
         int_archive.set("h2o",string)
         if (.special_ket(j)[1]>0) then
           bj1= .special_ket(j)[1] 
           bj2= .special_ket(j)[2] 
           w=ZERO
           do bi2=1,.n_bf
             do bi1=1,.n_bf
               w(:,:,bj1,bi2)=w(:,:,bj1,bi2)+temp_i(bi1,bi2)*v(:,:,bi1,bj2)
             end
           end
           do bi1=1,.n_bf
             do bi2=1,.n_bf
               w(:,:,bi1,bj2)=w(:,:,bi1,bj2)+temp_i(bi1,bi2)*v(:,:,bj1,bi2)
             end
           end
           int_archive.write(w)
         else
           temp_j => .ket(j)[:,:]
           do bi2=1,.n_bf
           do bj1=1,.n_bf
           do bj2=1,.n_bf
           do bi1=1,.n_bf
               w(bi1,bj2,bj1,bi2)=temp_i(bi1,bi2)*temp_j(bj1,bj2)+temp_j(bi1,bi2)*temp_i(bj1,bj2)
           end
           end
           end
           end
           do bi2=1,.n_bf
           do bj1=1,.n_bf
             do bj2=1,.n_bf
             do bi1=1,.n_bf
               temp(bi1,bj2)=sum(v(:,:,bi1,bj2)*w(:,:,bj1,bi2))
             end
             end
             w(:,:,bj1,bi2)=temp
           end
           end
           int_archive.write(w)
         end
       end          
     end
     w.destroy
   end
  

   do_hamiltonian
   ! Evaluate the hamiltonian in a geminal induced basis set
   ! built over orthonormal orbitals and print it
     res :: MAT{REAL}(.n_bas,.n_bas)
   !debug   write(*,*) ".n_bas",.n_bas,".n_bf",.n_bf
      res = .hamiltonian
      stdout.text("The Hamiltonian is ")
      stdout.put(res)
   end

   hamiltonian result (res)
   ! Evaluate the hamiltonian integrals
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
     v :: MAT4{REAL}*
     eri_archive :: ARCHIVE
     i,row_ind,col_ind :: INT
     reorder_ket :: VEC{INT}*
     eri_archive.set(.name,"h_integrals")
     v.create(.n_bf,.n_bf,.n_bf,.n_bf)
     eri_archive.read(v)
 !   .make_int_archives(v)
      !reorder_ket.create(2)
      !reorder_ket(1)=1
      !reorder_ket(2)=2
      ! res(1,1) = .overlap_for(reorder_ket,1,1)
      !stdout.show("1,1",res(1,1))
     reorder_ket.create(.n_geminals)
     reorder_ket = [ (i, i=1,.n_geminals) ]
      !.special_ket(.n_geminals)[1]=5
      !.special_ket(.n_geminals)[2]=5
     !res = .overlap_for(reorder_ket)
     !.special_ket(1)[1]=0
     !.special_ket(1)[2]=0
    ! stdout.show("special_ket(1)-out",.special_ket(1).element)
     stdout.show("v(1,1,1,1)",v(1,1,1,1))
     res=ZERO
     res(1,1) = .hamiltonian_for(v,reorder_ket,1,1) +.nuclear_energy
 !debug    do col_ind=1,.n_bas
 !debug    do row_ind=1,col_ind-1
 !debug      res(col_ind,row_ind)=res(row_ind,col_ind)
 !debug    end
 !debug    end
      stdout.show("1,1",res(1,1))
      !stdout.show("1,2",res(1,2))
      !stdout.show("2,1",res(2,1))
      !stdout.show("2,2",res(2,2))
     reorder_ket.destroy
     v.destroy
   end

   hamiltonian_for(v,order_ket,row_ind,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the hamiltonian integrals matrix
   ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
   ! v is the array containing the hf integrals of the 2-electron Hamiltonian.
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     row_ind, col_ind :: INT
     order_ket :: VEC{INT}
     v :: MAT4{REAL}, target
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     ii,jj,kk,i,j,k,l,dim,bi1,bi2,bj1,bj2,bk1,bk2,bq1,bq2 :: INT
     fac :: REAL
     reorder_ket,reorder_bra :: VEC{INT}*
     temp_bra_q :: MAT{REAL}*
     temp_bra_i :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_q_h2 ::  MAT{REAL}*
     temp_qa_h2 :: MAT4{REAL}*
     temp_qb_h2 :: MAT4{REAL}*
     temp_qa_h2_ja :: MAT4{REAL}*
     temp_qa_h2_ja_ex :: MAT4{REAL}*
     temp_qb_h2_jb :: MAT4{REAL}*
     temp_qb_h2_jb_ex :: MAT4{REAL}*
     temp_qa_h2_jb :: MAT4{REAL}*
     temp_qb_h2_ja :: MAT4{REAL}*
     temp_qa_h2_ja_kb :: MAT4{REAL}*
     temp_qa_h2_jb_ka :: MAT4{REAL}*
     temp_qb_h2_jb_ka :: MAT4{REAL}*
     temp_qb_h2_ja_kb :: MAT4{REAL}*
     temp_qa_h2_ja_ka :: MAT4{REAL}*
     temp_qb_h2_jb_kb :: MAT4{REAL}*
     temp_qa_h2_ja_ex_ka :: MAT4{REAL}*
     temp_qb_h2_jb_ex_kb :: MAT4{REAL}*
     temp_qb_jb :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_q_h2_ja_kb :: MAT{REAL}*
     temp_q_h2_jb_ka :: MAT{REAL}*
     temp_qa_h2_j :: MAT{REAL}*
     temp_qb_h2_j :: MAT{REAL}*

     dim = order_ket.dim
     res = ZERO
      
     if (dim==1) then ! case 1.2 only
       j = order_ket(1)
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         fac = sum(.contraction_wfs(row_ind)[:,:]*v(:,:,bj1,bj2))
       else
         temp_q_h2.create(.n_bf,.n_bf)
         do bj2=1,.n_bf
         do bj1=1,.n_bf
           temp_q_h2(bj1,bj2) = sum(.contraction_wfs(row_ind)[:,:]*v(:,:,bj1,bj2))
         end
         end
         if(j==1) then
           fac = sum(temp_q_h2*.contraction_wfs(col_ind)[:,:])
         else 
           fac = sum(temp_q_h2*.ket(j)[:,:])
         end
         temp_q_h2.destroy
       end
       res = fac
       return
     else ! dim > 1
       temp_bra_q => .bra(dim)[:,:]
       reorder_ket.create(dim-1)
!the next two arrays are created here because they are small and used in all
!cases
       temp_qa_h2_j.create(.n_bf,.n_bf)
       temp_qb_h2_j.create(.n_bf,.n_bf)
       temp_qa_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
       temp_qb_h2.create(.n_bf,.n_bf,.n_bf,.n_bf)
       do bj2=1,.n_bf
       do bj1=1,.n_bf
       do bq2=1,.n_bf
       do bq1=1,.n_bf
! respect the bra/ket nature of the indices
         temp_qa_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(:,bq2)*v(:,bq1,bj1,bj2))
         temp_qb_h2(bq1,bq2,bj1,bj2)=sum(temp_bra_q(bq1,:)*v(bq2,:,bj1,bj2))
       end
       end
       end
       end
       do jj = dim,1,-1
         j = order_ket(jj)
    write(*,*) "jj,j",jj,j
         if (j==1) then !ket from contraction 1
           temp_ket_j => .contraction_wfs(col_ind)[:,:]
           if(temp_qa_h2_ja.destroyed) then
             temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
             temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
             temp_qa_ja.create(.n_bf,.n_bf)
             temp_qb_jb.create(.n_bf,.n_bf)
           end
           do bj2=1,.n_bf
           do bq2=1,.n_bf
             temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
             temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
           end
           end
           do bj2=1,.n_bf
           do bj1=1,.n_bf
           do bq2=1,.n_bf
           do bq1=1,.n_bf
! respect the bra/ket nature of the indices
             temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
             temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
             temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
             temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
             temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
             temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
           end
           end
           end
           end
!case 2
           do kk = dim,jj+1,-1
             k = order_ket(kk) !cannot be 1
              write(*,*) "kk,k",kk,k
             DIE_IF(k<2,"k cannot be 1")  !debug
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:kk-1)  = [ (order_ket(l), l=jj+1,kk-1) ]
             reorder_ket(kk:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
             reorder_ket(dim-1) =  k
             if (.special_ket(k)[1]==0) then !k not special
               temp_ket_k => .ket(k)[:,:]
!case 2.3
               if(temp_qa_h2_ja_kb.destroyed) then
                 temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
                 temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
                 temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
                 temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               end
!case 2.3.1 call special overlap ab
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                 temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                 temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                 temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
               end
               end
               end
               end
               reorder_bra.create(dim-2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     .special_ket(k)[1] = bk1 
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                          + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                     end 
                     end
                   end
                 end
               end !do ii, the case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bj2=1,.n_bf
                 .special_ket(k)[2] = bj2
                 do bk1=1,.n_bf
                   .special_ket(k)[1] = bk1 
                   do bi2=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                   end 
                   end
                 end
               end
!case 2.3.2 call special overlap aa
               temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
               temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                 temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
               end
               end
               end
               end
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bk1=1,.n_bf
                   .special_ket(k)[2] = bk1
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))       
                       res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <<
                     end 
                     end
                   end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bk1=1,.n_bf
                 .special_ket(k)[2] = bk1
                 do bj1=1,.n_bf
                   .special_ket(k)[1] = bj1 
                   do bi1=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                        + sum(temp_qb_h2_jb_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))       
                     res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <
                   end 
                   end
                 end
               end
!case 2.3.3 call special overlap bb
               temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
               temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
               do bj1=1,.n_bf
               do bj2=1,.n_bf
               do bq2=1,.n_bf
               do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                 temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                 temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
               end
               end
               end
               end
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bk2=1,.n_bf
                   .special_ket(k)[2] = bk2
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex_ka(bq2,:,bj2,bk2)*temp_bra_i(bi2,:))     &
                          + sum(temp_qa_h2_ja_ka(bq2,:,bj2,bk2)*temp_bra_i(bi2,:))       
                       res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                     end
                   end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bk2=1,.n_bf
                 .special_ket(k)[2] = bk2
                 do bj2=1,.n_bf
                   .special_ket(k)[1] = bj2 
                   do bi2=1,.n_bf
                   do bq2=1,.n_bf
                     fac= sum(temp_qa_h2_ja_ex_ka(bq2,:,bj2,bk2)*temp_bra_i(bi2,:))     &
                        + sum(temp_qa_h2_ja_ka(bq2,:,bj2,bk2)*temp_bra_i(bi2,:))       
                     res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
                   end 
                   end
                 end
               end
               reorder_bra.destroy
!case 2.2
              ! if(temp_q_h2_ja_kb.destroyed) then
              !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
              !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
              ! end
              ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
              ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
               do bj2=1,.n_bf
                 .special_ket(k)[2] = bj2
                 do bk1=1,.n_bf
                   temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
                   temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
                   fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                   .special_ket(k)[1] = bk1 
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
!case 2.1
               do bj2=1,.n_bf
                 .special_ket(k)[2] = bj2
                 do bk1=1,.n_bf
                   fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
                   if( NOT fac.is_zero) then
                     .special_ket(k)[1] = bk1 
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end 
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             else !k special
               bk1=.special_ket(k)[1]
               bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
               !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               reorder_bra.create(dim-2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,bk2-1
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                   end
                   end
                 end
                 do bj2=bk2+1,.n_bf
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
                   end 
                   end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   .special_ket(k)[1] = bj1 
              !    .special_ket(k)[2] = bk2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                   end 
                   end
                 end
                 do bj1=bk1+1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                   end 
                   end
                 end
                 .special_ket(k)[1] = bk1 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                !   .special_ket(k)[1] = bk1 
                !   .special_ket(k)[2] = bk2
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                 end 
                 end 
               end !do ii, the case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bj2=1,bk2-1
            !    .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end
                 end
               end
               do bj2=bk2+1,.n_bf
               ! .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
                 end 
               end
               .special_ket(k)[2] = bk2 
               do bj1=1,bk1-1
                 .special_ket(k)[1] = bj1 
            !    .special_ket(k)[2] = bk2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
                 end
               end
               do bj1=bk1+1,.n_bf
                 .special_ket(k)[1] = bj1 
             !   .special_ket(k)[2] = bk2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
                 end
               end
               .special_ket(k)[1] = bk1 
               do bq1=1,.n_bf
               do bi2=1,.n_bf
                 fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                    + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                    + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                    + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
              !   .special_ket(k)[1] = bk1 
              !   .special_ket(k)[2] = bk2
                 res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
               end 
               end 
               .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!case 2.3.2 call special overlap aa
              !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
              !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj1=1,.n_bf
                   .special_ket(k)[1] = bj1 
             !     .special_ket(k)[2] = bk1
                   do bi1=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))       
                     res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <
                   end 
                   end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bj1=1,.n_bf
                 .special_ket(k)[1] = bj1 
             !   .special_ket(k)[2] = bk1
                 do bi1=1,.n_bf
                 do bq1=1,.n_bf
                   fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))       
                   res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                 end 
                 end
               end
               .special_ket(k)[2] = bk2 
!case 2.3.3 call special overlap bb
             !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
             !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[1] = bj2 
               !   .special_ket(k)[2] = bk2
                   do bi2=1,.n_bf
                   do bq2=1,.n_bf
                     fac= sum(temp_qa_h2_ja_ex(bq2,:,bk1,bj2)*temp_bra_i(bi2,:))     &
                        + sum(temp_qa_h2_ja(bq2,:,bk1,bj2)*temp_bra_i(bi2,:))       
                     res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                   end 
                   end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bj2=1,.n_bf
                 .special_ket(k)[1] = bj2 
              !  .special_ket(k)[2] = bk2
                 do bi2=1,.n_bf
                 do bq2=1,.n_bf
                   fac= sum(temp_qa_h2_ja_ex(bq2,:,bk1,bj2)*temp_bra_i(bi2,:))     &
                      + sum(temp_qa_h2_ja(bq2,:,bk1,bj2)*temp_bra_i(bi2,:))       
                   res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
                 end 
                 end
               end
               .special_ket(k)[1] = bk1 
               reorder_bra.destroy
!case 2.2
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               do bj2=1,bk2-1
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                 fac= temp_q_h2_ja_kb.trace
               !  .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
               end
               do bj2=bk2+1,.n_bf
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                 fac= temp_q_h2_ja_kb.trace
               !  .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
               end
               .special_ket(k)[2] = bk2
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               do bj1=1,bk1-1
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                 fac= temp_q_h2_jb_ka.trace
                 .special_ket(k)[1] = bj1 
              !   .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
               end
               do bj1=bk1+1,.n_bf
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                 fac= temp_q_h2_jb_ka.trace
                 .special_ket(k)[1] = bj1 
              !   .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
               end
               .special_ket(k)[1] = bk1 
               temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
               temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
               fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
           !    .special_ket(k)[1] = bk1 
           !    .special_ket(k)[2] = bk2
               res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!case 2.1
               do bj2=1,bk2-1
                 fac= temp_qa_ja(bk2,bj2)
                 if( NOT fac.is_zero) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
               do bj2=bk2+1,.n_bf
                 fac= temp_qa_ja(bk2,bj2)
                 if( NOT fac.is_zero) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
               .special_ket(k)[2] = bk2 
               do bj1=1,bk1-1
                 fac= temp_qb_jb(bk1,bj1)
                 if( NOT fac.is_zero) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
               do bj1=bk1+1,.n_bf
                 fac= temp_qb_jb(bk1,bj1)
                 if( NOT fac.is_zero) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end 
               end
               .special_ket(k)[1] = bk1 
               fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
               if( NOT fac.is_zero) then
               !  .special_ket(k)[1] = bk1 
               !  .special_ket(k)[2] = bk2
                 res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
               end
             end !k special
           end !do kk
           nullify(temp_q_h2_ja_kb)
           nullify(temp_q_h2_jb_ka)
           temp_qb_h2_jb_ka.destroy
           nullify(temp_qb_h2_jb_kb)
           nullify(temp_qb_h2_jb_ex_kb)
           temp_qa_h2_ja_kb.destroy
           nullify(temp_qa_h2_ja_ka)
           nullify(temp_qa_h2_ja_ex_ka)
           temp_qa_h2_jb_ka.destroy
           temp_qb_h2_ja_kb.destroy
!case 1.3
           temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
           temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
           !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
           !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
           reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1)  = [ (order_ket(l), l=jj+1,dim) ]
           reorder_bra.create(dim-2)
           do ii=dim-1,2,-1
             temp_bra_i => .bra(ii)[:,:]
             reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
             reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
               res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
             end
             end
           end !ii case ii=1 remains 
           temp_bra_i => .contraction_wfs(row_ind)[:,:]
           reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
           do bi2=1,.n_bf
           do bq1=1,.n_bf
             fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
             res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
           end
           end
           reorder_bra.destroy
!case 1.2
           fac=temp_qb_h2_j.trace
           res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!case 1.1
           fac=temp_qb_jb.trace
           res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
         else !j>1
           if (.special_ket(j)[1]==0) then !j not special
             temp_ket_j => .ket(j)[:,:]
             if(temp_qa_h2_ja.destroyed) then
               temp_qa_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qa_h2_jb.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_ja.create(.n_bf,.n_bf,.n_bf,.n_bf)
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
               temp_qa_h2_ja_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qb_h2_jb_ex.create(.n_bf,.n_bf,.n_bf,.n_bf)
               temp_qa_ja.create(.n_bf,.n_bf)
               temp_qb_jb.create(.n_bf,.n_bf)
             end
             do bj2=1,.n_bf
             do bq2=1,.n_bf
               temp_qa_ja(bq2,bj2)=sum(temp_bra_q(:,bq2)*temp_ket_j(:,bj2))
               temp_qb_jb(bq2,bj2)=sum(temp_bra_q(bq2,:)*temp_ket_j(bj2,:))
             end
             end
             do bj2=1,.n_bf
             do bj1=1,.n_bf
             do bq2=1,.n_bf
             do bq1=1,.n_bf
! respect the bra/ket nature of the indices
               temp_qa_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
               temp_qa_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
               temp_qb_h2_ja(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj1)*temp_ket_j(:,bj2))
               temp_qb_h2_jb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,bj2,:)*temp_ket_j(bj1,:))
!the next two are not needed for 2.3.1, one is for 2.3.2 and one for 2.3.3
! in case of memory shortage they can be created later but then the loop on kk 
!must be done for each subcase.
               temp_qa_h2_ja_ex(bq1,bq2,bj1,bj2)=sum(temp_qa_h2(bq1,bq2,bj1,:)*temp_ket_j(:,bj2))
               temp_qb_h2_jb_ex(bq1,bq2,bj1,bj2)=sum(temp_qb_h2(bq1,bq2,:,bj2)*temp_ket_j(bj1,:))
             end
             end
             end
             end
!case 2
             do kk = dim,jj+1,-1
               k = order_ket(kk) !cannot be 1
               DIE_IF(k<2,"k cannot be 1")  !debug
               reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
               reorder_ket(jj:kk-1)  = [ (order_ket(l), l=jj+1,kk-1) ]
               reorder_ket(kk:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
               reorder_ket(dim-1) =  k
               if (.special_ket(k)[1]==0) then !k not special
                 temp_ket_k => .ket(k)[:,:]
!case 2.3
                 if(temp_qa_h2_ja_kb.destroyed) then
                   temp_qa_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction
                   temp_qb_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf) !used also in 2.2 after contraction 
                   temp_qa_h2_jb_ka.create(.n_bf,.n_bf,.n_bf,.n_bf)
                   temp_qb_h2_ja_kb.create(.n_bf,.n_bf,.n_bf,.n_bf)
                 end
!case 2.3.1 call special overlap ab
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qa_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                   temp_qa_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                   temp_qb_h2_ja_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_ja(bq1,bq2,:,bj2)*temp_ket_k(bj1,:))
                   temp_qb_h2_jb_ka(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(:,bj2))
                 end
                 end
                 end
                 end
                 reorder_bra.create(dim-2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,.n_bf
                     .special_ket(k)[2] = bj2
                     do bk1=1,.n_bf
                       .special_ket(k)[1] = bk1 
                       do bq1=1,.n_bf
                       do bi2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                            + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                            + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                            + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                         res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                       end 
                       end
                     end
                   end
                 end !do ii, the case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     .special_ket(k)[1] = bk1 
                     do bi2=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qa_h2_ja_kb(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qa_h2_jb_ka(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_ja_kb(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))     &  
                          + sum(temp_qb_h2_jb_ka(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <
                     end 
                     end
                   end
                 end
!case 2.3.2 call special overlap aa
                 temp_qb_h2_jb_kb => temp_qb_h2_ja_kb
                 temp_qb_h2_jb_ex_kb => temp_qa_h2_jb_ka
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qb_h2_jb_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                   temp_qb_h2_jb_ex_kb(bq1,bq2,bj1,bj2)=sum(temp_qb_h2_jb_ex(bq1,bq2,bj1,:)*temp_ket_k(bj2,:))
                 end
                 end
                 end
                 end
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bk1=1,.n_bf
                     .special_ket(k)[2] = bk1
                     do bj1=1,.n_bf
                       .special_ket(k)[1] = bj1 
                       do bi1=1,.n_bf
                       do bq1=1,.n_bf
                         fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                            + sum(temp_qb_h2_jb_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))       
                         res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! <<
                       end 
                       end
                     end
                   end
                 end !do ii , case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bk1=1,.n_bf
                   .special_ket(k)[2] = bk1
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
                     do bi1=1,.n_bf
                     do bq1=1,.n_bf
                       fac= sum(temp_qb_h2_jb_ex_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))     &
                          + sum(temp_qb_h2_jb_kb(bq1,:,bj1,bk1)*temp_bra_i(bi1,:))       
                       res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                     end 
                     end
                   end
                 end
!case 2.3.3 call special overlap bb
                 temp_qa_h2_ja_ka => temp_qb_h2_ja_kb
                 temp_qa_h2_ja_ex_ka => temp_qa_h2_jb_ka
                 do bj1=1,.n_bf
                 do bj2=1,.n_bf
                 do bq2=1,.n_bf
                 do bq1=1,.n_bf
! respect the bra/ket nature of the indices
                   temp_qa_h2_ja_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                   temp_qa_h2_ja_ex_ka(bq1,bq2,bj1,bj2)=sum(temp_qa_h2_ja_ex(bq1,bq2,:,bj1)*temp_ket_k(:,bj2))
                 end
                 end
                 end
                 end
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bk2=1,.n_bf
                     .special_ket(k)[2] = bk2
                     do bj2=1,.n_bf
                       .special_ket(k)[1] = bj2 
                       do bi2=1,.n_bf
                       do bq2=1,.n_bf
                         fac= sum(temp_qa_h2_ja_ex_ka(bq2,:,bj2,bk2)*temp_bra_i(bi2,:))     &
                            + sum(temp_qa_h2_ja_ka(bq2,:,bj2,bk2)*temp_bra_i(bi2,:))       
                         res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <
                       end 
                       end
                     end
                   end
                 end !do ii , case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bk2=1,.n_bf
                   .special_ket(k)[2] = bk2
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                     do bi2=1,.n_bf
                     do bq2=1,.n_bf
                       fac= sum(temp_qa_h2_ja_ex_ka(bq2,:,bj2,bk2)*temp_bra_i(bi2,:))     &
                          + sum(temp_qa_h2_ja_ka(bq2,:,bj2,bk2)*temp_bra_i(bi2,:))       
                       res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                     end 
                     end
                   end
                 end
                 reorder_bra.destroy
!case 2.2
                ! if(temp_q_h2_ja_kb.destroyed) then
                !   temp_q_h2_ja_kb.create(.n_bf,.n_bf)
                !   temp_q_h2_jb_ka.create(.n_bf,.n_bf)
                ! end
                ! temp_qa_h2_ja_kb.partial_trace(1,2,temp_q_h2_ja_kb) !no gain by storing that
                ! temp_qb_h2_jb_ka.partial_trace(1,2,temp_q_h2_jb_ka) !but convenient
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     temp_q_h2_ja_kb => temp_qa_h2_ja_kb(:,:,bk1,bj2)
                     temp_q_h2_jb_ka => temp_qb_h2_jb_ka(:,:,bk1,bj2)
                     fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
                     .special_ket(k)[1] = bk1 
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
!case 2.1
                 do bj2=1,.n_bf
                   .special_ket(k)[2] = bj2
                   do bk1=1,.n_bf
                     fac= sum(temp_qa_ja(:,bj2)*temp_ket_k(bk1,:))+sum(temp_qb_jb(:,bk1)*temp_ket_k(:,bj2))
                     if( NOT fac.is_zero) then
                       .special_ket(k)[1] = bk1 
                       res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                     end 
                   end 
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
               else !k special
                 bk1=.special_ket(k)[1]
                 bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
                 !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
                 !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
                 !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 reorder_bra.create(dim-2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,bk2-1
                !    .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end
                     end
                   end
                   do bj2=bk2+1,.n_bf
                   ! .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                          + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end 
                   end
                   .special_ket(k)[2] = bk2 
                   do bj1=1,bk1-1
                     .special_ket(k)[1] = bj1 
                !    .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end
                   end
                   do bj1=bk1+1,.n_bf
                     .special_ket(k)[1] = bj1 
                 !   .special_ket(k)[2] = bk2
                     do bq1=1,.n_bf
                     do bi2=1,.n_bf
                       fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                       res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                     end 
                     end
                   end
                   .special_ket(k)[1] = bk1 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                   end 
                   end 
                 end !do ii, the case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bj2=1,bk2-1
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end
                 end
                 end
                 do bj2=bk2+1,.n_bf
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bj2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bj2)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
                 end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   .special_ket(k)[1] = bj1 
              !    .special_ket(k)[2] = bk2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
                 end
                 end
                 do bj1=bk1+1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2_jb(:,bi2,bj1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk1)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
                 end
                 end
                 .special_ket(k)[1] = bk1 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2_ja(:,bi2,bk2,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2_jb(:,bi2,bk1,bk1)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2_ja(bq1,:,bk2,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2_jb(bq1,:,bk1,bk1)*temp_bra_i(:,bi2))       
                !   .special_ket(k)[1] = bk1 
                !   .special_ket(k)[2] = bk2
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
                 end 
                 end 
                 .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!case 2.3.2 call special overlap aa
                !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
                !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj1=1,.n_bf
                     .special_ket(k)[1] = bj1 
               !     .special_ket(k)[2] = bk1
                   do bi1=1,.n_bf
                   do bq1=1,.n_bf
                     fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                        + sum(temp_qb_h2_jb(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))       
                     res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                   end 
                   end
                   end
                 end !do ii , case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bj1=1,.n_bf
                   .special_ket(k)[1] = bj1 
               !   .special_ket(k)[2] = bk1
                 do bi1=1,.n_bf
                 do bq1=1,.n_bf
                   fac= sum(temp_qb_h2_jb_ex(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))     &
                      + sum(temp_qb_h2_jb(bq1,:,bj1,bk2)*temp_bra_i(bi1,:))       
                   res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                 end 
                 end
                 end
                 .special_ket(k)[2] = bk2 
!case 2.3.3 call special overlap bb
               !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
               !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bj2=1,.n_bf
                     .special_ket(k)[1] = bj2 
                 !   .special_ket(k)[2] = bk2
                   do bi2=1,.n_bf
                   do bq2=1,.n_bf
                     fac= sum(temp_qa_h2_ja_ex(bq2,:,bk1,bj2)*temp_bra_i(bi2,:))     &
                        + sum(temp_qa_h2_ja(bq2,:,bk1,bj2)*temp_bra_i(bi2,:))       
                     res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                   end 
                   end
                   end
                 end !do ii , case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bj2=1,.n_bf
                   .special_ket(k)[1] = bj2 
                !  .special_ket(k)[2] = bk2
                 do bi2=1,.n_bf
                 do bq2=1,.n_bf
                   fac= sum(temp_qa_h2_ja_ex(bq2,:,bk1,bj2)*temp_bra_i(bi2,:))     &
                      + sum(temp_qa_h2_ja(bq2,:,bk1,bj2)*temp_bra_i(bi2,:))       
                   res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! <<
                 end 
                 end
                 end
                 .special_ket(k)[1] = bk1 
                 reorder_bra.destroy
!case 2.2
                 !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 do bj2=1,bk2-1
                   temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                   fac= temp_q_h2_ja_kb.trace
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                 end
                 do bj2=bk2+1,.n_bf
                   temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bj2)
                   fac= temp_q_h2_ja_kb.trace
                 ! .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                 end
                 .special_ket(k)[2] = bk2
                 !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 do bj1=1,bk1-1
                   temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                   fac= temp_q_h2_jb_ka.trace
                   .special_ket(k)[1] = bj1 
                !  .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                 end
                 do bj1=bk1+1,.n_bf
                   temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bj1,bk1)
                   fac= temp_q_h2_jb_ka.trace
                   .special_ket(k)[1] = bj1 
                !  .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                 end
                 .special_ket(k)[1] = bk1 
                 temp_q_h2_jb_ka => temp_qb_h2_jb(:,:,bk1,bk1)
                 temp_q_h2_ja_kb => temp_qa_h2_ja(:,:,bk2,bk2)
                 fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
             !    .special_ket(k)[1] = bk1 
             !    .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!case 2.1
                 do bj2=1,bk2-1
                   fac= temp_qa_ja(bk2,bj2)
                   if( NOT fac.is_zero) then
                  !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
                 do bj2=bk2+1,.n_bf
                   fac= temp_qa_ja(bk2,bj2)
                   if( NOT fac.is_zero) then
                  !  .special_ket(k)[1] = bk1 
                     .special_ket(k)[2] = bj2
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
                 .special_ket(k)[2] = bk2 
                 do bj1=1,bk1-1
                   fac= temp_qb_jb(bk1,bj1)
                   if( NOT fac.is_zero) then
                     .special_ket(k)[1] = bj1 
                   ! .special_ket(k)[2] = bk2
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
                 do bj1=bk1+1,.n_bf
                   fac= temp_qb_jb(bk1,bj1)
                   if( NOT fac.is_zero) then
                     .special_ket(k)[1] = bj1 
                   ! .special_ket(k)[2] = bk2
                     res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   end 
                 end
                 .special_ket(k)[1] = bk1 
                 fac= temp_qb_jb(bk1,bk1) + temp_qa_ja(bk2,bk2)
                 if( NOT fac.is_zero) then
                 !  .special_ket(k)[1] = bk1 
                 !  .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end
               end !k special
             end !do kk
             nullify(temp_q_h2_ja_kb)
             nullify(temp_q_h2_jb_ka)
             temp_qb_h2_jb_ka.destroy
             nullify(temp_qb_h2_jb_kb)
             nullify(temp_qb_h2_jb_ex_kb)
             temp_qa_h2_ja_kb.destroy
             nullify(temp_qa_h2_ja_ka)
             nullify(temp_qa_h2_ja_ex_ka)
             temp_qa_h2_jb_ka.destroy
             temp_qb_h2_ja_kb.destroy
!case 1.3
             temp_qb_h2_jb.partial_trace(3,4,temp_qb_h2_j)
             temp_qa_h2_ja.partial_trace(3,4,temp_qa_h2_j)
             !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
             !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1)  = [ (order_ket(l), l=jj+1,dim) ]
             reorder_bra.create(dim-2)
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                 res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
               end
               end
             end !ii case ii=1 remains 
             temp_bra_i => .contraction_wfs(row_ind)[:,:]
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
               res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
             end
             end
             reorder_bra.destroy
!case 1.2
             fac=temp_qb_h2_j.trace
             res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
!case 1.1
             fac=temp_qb_jb.trace
             res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
           else ! j is a special ket
! warning: we have not changed the structure with respect to the case "not a
! special ket", therefore more space than needed is used and large parts of the
! arrays are dangerously not initialized.
             bj1=.special_ket(j)[1]
             bj2=.special_ket(j)[2]
!case 2
             do kk = dim,jj+1,-1
               k = order_ket(kk) !cannot be 1
               DIE_IF(k<2,"k cannot be 1")  !debug
               reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
               reorder_ket(jj:kk-1)  = [ (order_ket(l), l=jj+1,kk-1) ]
               reorder_ket(kk:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
               reorder_ket(dim-1) =  k
               DIE_IF(.special_ket(k)[1]==0,"j special ket but not k") 
               bk1=.special_ket(k)[1]
               bk2=.special_ket(k)[2]
!case 2.3
!case 2.3.1 call special overlap ab
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
               !  temp_qa_h2_jb_ka(:,:,:,bk2) => temp_qa_h2_jb(:,:,:,bk1)
               !  temp_qb_h2_ja_kb(:,:,bk1,:) => temp_qb_h2_ja(:,:,bk2,:)
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
               reorder_bra.create(dim-2)
               if(bj2/=bk2 OR bj1/=bk1) then
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
              !    .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                   end
                   end
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2 
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                          + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                   end
                   end
                   .special_ket(k)[1] = bk1 
                 end !do ii, the case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
            !    .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                 end
                 end
                 .special_ket(k)[1] = bj1 
                 .special_ket(k)[2] = bk2 
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                 end
                 end
                 .special_ket(k)[1] = bk1 
               else !bj1==bk1 AND bj2==bk2
                 do ii=dim-1,2,-1
                   temp_bra_i => .bra(ii)[:,:]
                   reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                   reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                   do bq1=1,.n_bf
                   do bi2=1,.n_bf
                     fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                        + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                        + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
                        + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
                !     .special_ket(k)[1] = bk1 
                !     .special_ket(k)[2] = bk2
                     res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                   end 
                   end 
                 end !do ii, the case ii=1 is left
                 temp_bra_i => .contraction_wfs(row_ind)[:,:]
                 reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
                 do bq1=1,.n_bf
                 do bi2=1,.n_bf
                   fac= sum(temp_qa_h2(:,bi2,bj1,bk2)*temp_bra_i(bq1,:))     &
                      + sum(temp_qa_h2(:,bi2,bk1,bj2)*temp_bra_i(bq1,:))     &  
                      + sum(temp_qb_h2(bq1,:,bj1,bk2)*temp_bra_i(:,bi2))     &  
                      + sum(temp_qb_h2(bq1,:,bk1,bj2)*temp_bra_i(:,bi2))       
              !     .special_ket(k)[1] = bk1 
              !     .special_ket(k)[2] = bk2
                   res = res + .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! <<
                 end 
                 end 
               end !bj1==bk1 AND bj2==bk2
               .special_ket(k)[2] = bk1 !this is not an error, this setting is constant in the following loops
!case 2.3.2 call special overlap aa
              !   temp_qb_h2_jb_kb(:,:,:,bk1) => temp_qb_h2_jb(:,:,:,bk2)
              !   temp_qb_h2_jb_ex_kb(:,:,:,bk1) => temp_qb_h2_jb_ex(:,:,:,bk2)
               .special_ket(k)[1] = bj1 
             ! .special_ket(k)[2] = bk1
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bi1=1,.n_bf
                 do bq1=1,.n_bf
                   fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
                      + sum(temp_qb_h2(bq1,:,bk2,bj2)*temp_bra_i(bi1,:))       
                   res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
                 end
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bi1=1,.n_bf
               do bq1=1,.n_bf
                 fac= sum(temp_qb_h2(bq1,:,bj2,bk2)*temp_bra_i(bi1,:))     &
                    + sum(temp_qb_h2(bq1,:,bk2,bj2)*temp_bra_i(bi1,:))       
                 res = res + .special_overlap_spin_aa_for(reorder_bra,reorder_ket,row_ind,col_ind,bi1,bq1) * fac ! 
               end
               end
!case 2.3.3 call special overlap bb
             !  temp_qa_h2_ja_ka(:,:,:,bk2) => temp_qa_h2_ja(:,:,bk1,:)
             !  temp_qa_h2_ja_ex_ka(:,:,:,bk2) => temp_qa_h2_ja_ex(:,:,bk1,:)
               .special_ket(k)[2] = bk2 
               .special_ket(k)[1] = bj2 
               do ii=dim-1,2,-1
                 temp_bra_i => .bra(ii)[:,:]
                 reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
                 reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
                 do bi2=1,.n_bf
                 do bq2=1,.n_bf
                   fac= sum(temp_qa_h2(bq2,:,bk1,bj1)*temp_bra_i(bi2,:))     &
                      + sum(temp_qa_h2(bq2,:,bj1,bk1)*temp_bra_i(bi2,:))       
                   res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
                 end 
                 end
               end !do ii , case ii=1 is left
               temp_bra_i => .contraction_wfs(row_ind)[:,:]
               reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
               do bi2=1,.n_bf
               do bq2=1,.n_bf
                 fac= sum(temp_qa_h2(bq2,:,bk1,bj1)*temp_bra_i(bi2,:))     &
                    + sum(temp_qa_h2(bq2,:,bj1,bk1)*temp_bra_i(bi2,:))       
                 res = res + .special_overlap_spin_bb_for(reorder_bra,reorder_ket,row_ind,col_ind,bi2,bq2) * fac ! 
               end 
               end
               .special_ket(k)[1] = bk1 
               reorder_bra.destroy
!case 2.2
               if(bj2/=bk2 OR bj1/=bk1) then
               !  temp_qa_h2_ja_kb(:,:,bk1,:) => temp_qa_h2_ja(:,:,bk2,:)
                 temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
                 fac= temp_q_h2_ja_kb.trace
               !  .special_ket(k)[1] = bk1 
                 .special_ket(k)[2] = bj2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                 .special_ket(k)[2] = bk2
               !  temp_qb_h2_jb_ka(:,:,:,bk2) => temp_qb_h2_jb(:,:,:,bk1)
                 temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
                 fac= temp_q_h2_jb_ka.trace
                 .special_ket(k)[1] = bj1 
              !   .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
                 .special_ket(k)[1] = bk1 
               else !bj2==bk2 AND bj1==bk1
                 temp_q_h2_jb_ka => temp_qb_h2(:,:,bk1,bj2)
                 temp_q_h2_ja_kb => temp_qa_h2(:,:,bj1,bk2)
                 fac= temp_q_h2_ja_kb.trace+temp_q_h2_jb_ka.trace
           !     .special_ket(k)[1] = bk1 
           !     .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
               end !bj2==bk2 AND bj1==bk1
!case 2.1
               if(bj2/=bk2 OR bj1/=bk1) then
                 fac= temp_bra_q(bj1,bk2)
                 if( NOT fac.is_zero) then
                !  .special_ket(k)[1] = bk1 
                   .special_ket(k)[2] = bj2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   .special_ket(k)[2] = bk2 
                 end 
                 fac= temp_bra_q(bk1,bj2)
                 if( NOT fac.is_zero) then
                   .special_ket(k)[1] = bj1 
                 ! .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                   .special_ket(k)[1] = bk1 
                 end 
               else !bj2==bk2 AND bj1==bk1
                 fac= temp_bra_q(bk1,bj2) + temp_bra_q(bj1,bk2)
                 if( NOT fac.is_zero) then
               !   .special_ket(k)[1] = bk1 
               !   .special_ket(k)[2] = bk2
                   res = res - .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
                 end
               end !bj2==bk2 AND bj1==bk1
             end !do kk
             nullify(temp_q_h2_ja_kb)
             nullify(temp_q_h2_jb_ka)
             temp_qb_h2_jb_ka.destroy
             nullify(temp_qb_h2_jb_kb)
             nullify(temp_qb_h2_jb_ex_kb)
             temp_qa_h2_ja_kb.destroy
             nullify(temp_qa_h2_ja_ka)
             nullify(temp_qa_h2_ja_ex_ka)
             temp_qa_h2_jb_ka.destroy
             temp_qb_h2_ja_kb.destroy
!case 1.3
             temp_qa_h2_j=temp_qa_h2(:,:,bj1,bj2)
             temp_qb_h2_j=temp_qb_h2(:,:,bj1,bj2)
             !  temp_qa_h2_j = temp_qa_h2_ja(v2,bq2,:,:).trace
             !  temp_qb_h2_j = temp_qb_h2_jb(bq1,v1,:,:).trace
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1)  = [ (order_ket(l), l=jj+1,dim) ]
             reorder_bra.create(dim-2)
             do ii=dim-1,2,-1
               temp_bra_i => .bra(ii)[:,:]
               reorder_bra(1:ii-1)   = [ (l , l=1,ii-1) ]
               reorder_bra(ii:dim-2) = [ (l , l=ii+1,dim-1) ]
               do bi2=1,.n_bf
               do bq1=1,.n_bf
                 fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
                 res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
               end
               end
             end !ii case ii=1 remains 
             temp_bra_i => .contraction_wfs(row_ind)[:,:]
             reorder_bra(1:dim-2) = [ (l , l=2,dim-1) ]
             do bi2=1,.n_bf
             do bq1=1,.n_bf
               fac=sum(temp_qb_h2_j(bq1,:)*temp_bra_i(:,bi2))+sum(temp_qa_h2_j(:,bi2)*temp_bra_i(bq1,:))
               res = res - .special_overlap_spin_ab_for(reorder_bra,reorder_ket,row_ind,col_ind,bq1,bi2) * fac ! 
             end
             end
             reorder_bra.destroy
  !case 1.2
             fac=temp_qb_h2_j.trace
             res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! 
  !case 1.1
             fac=temp_bra_q(bj1,bj2)
             res = res + .hamiltonian_for(v,reorder_ket,row_ind,col_ind) * fac ! 
           end !j special ket
         end !if j=1
       end !do jj
       temp_qb_h2_jb.destroy
       temp_qb_h2_jb_ex.destroy
       temp_qa_h2_ja.destroy
       temp_qa_h2_ja_ex.destroy
       temp_qa_h2_jb.destroy
       temp_qb_h2_ja.destroy
       temp_qa_ja.destroy
       temp_qb_jb.destroy
       temp_qa_h2.destroy
       temp_qb_h2.destroy
       reorder_ket.destroy
     end !if dim=1
   end

   overlap_for(order_bra,order_ket) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix between
   ! mean field (Sz=0)-geminals (upper triangle only is evaluated)
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     order_bra, order_ket :: VEC{INT}
     res :: MAT{REAL}(.n_bas,.n_bas)

     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(.special_ket(1)[1]==0,".special_ket(1) already set")
      
     ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,row_ind,col_ind :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*
     dim = order_ket.dim

     res = ZERO
      
     if (dim==1) then
       ! case 1
       i = order_ket(1)
       if (i/=1 ) DIE("dim=1 and i/=1")
       do  col_ind=1,.n_bas
         do row_ind=1,col_ind 
           fac = sum(.contraction_wfs(row_ind)[:,:]*.contraction_wfs(col_ind)[:,:])
           if (NOT fac.is_zero) then
             res(row_ind,col_ind) = fac
           end
         end
       end
       return
        ! no Case 2 when dim =1
     else
     ! dim > 1
       do ii = dim,1,-1
         i = order_ket(ii)
         if (i==1) then
           do  col_ind=1,.n_bas
           ! Case 1
             fac = sum(.bra(dim)[:,:]*.contraction_wfs(col_ind)[:,:])
             if (NOT fac.is_zero) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
               res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
               reorder_ket.destroy
             end
          ! Case 2
             do jj = dim,ii+1,-1
               j = order_ket(jj)
               if (.special_ket(j)[1]>0) then
               ! Case 2, only j special
                 bj1 = .special_ket(j)[1]
                 bj2 = .special_ket(j)[2]
                 do bi2 = 1,.n_bf
                   fac = ZERO
                   if (bi2==bj2) then
                     do bi1 = 1,bj1-1
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                     do bi1 = bj1+1,.n_bf
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                     fac = fac+ TWO*.contraction_wfs(col_ind)[bj1,bi2]*.bra(dim)[bj1,bj2]
                   else
                     do bi1 = 1,.n_bf
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                   end
                   if (NOT fac.is_zero) then
                     reorder_ket.create(dim-1)
                     reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                     reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                     reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                     reorder_ket(dim-1) = j 
                  !  .special_ket(j)[1] = bj1 
                     .special_ket(j)[2] = bi2 
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3       .special_ket(j)[1] = 0 ! j=reorder_ket(dim-1)
!test3       .special_ket(j)[2] = 0 ! j=reorder_ket(dim-1)
! seems safer to put back the value bj1 and bj2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                     .special_ket(j)[2] = bj2
                     reorder_ket.destroy
                   end
                 end
               else 
               !  Case 2, NONE SPECIAL
                 do bi2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = ZERO
                   do bi1 = 1,.n_bf
                   do bj2 = 1,.n_bf
                     fac = fac + (.contraction_wfs(col_ind)[bi1,bi2]*.ket(j)[bj1,bj2] +  &
                            .contraction_wfs(col_ind)[bj1,bj2]*.ket(j)[bi1,bi2])* .bra(dim)[bi1,bj2]
                   end
                   end
                   if (NOT fac.is_zero) then
                     reorder_ket.create(dim-1)
                     reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                     reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                     reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                     reorder_ket(dim-1) = j 
                     .special_ket(j)[1] = bj1 
                     .special_ket(j)[2] = bi2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                     .special_ket(j)[1] = 0 
                     .special_ket(j)[2] = 0
                     reorder_ket.destroy
                   end
                 end
                 end
               end
             end
           end
         else !i>1
           ! case 1
           if (.special_ket(i)[1]>0) then
             bi1 = .special_ket(i)[1]
             bi2 = .special_ket(i)[2]
             fac = .bra(dim)[bi1,bi2]
           else
             fac = sum(.bra(dim)[:,:]*.ket(i)[:,:])
           end
           if (NOT fac.is_zero) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
             reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
             res = res + .overlap_for(reorder_ket) * fac ! <<
             reorder_ket.destroy
           end
           ! Case 2
           do jj = dim,ii+1,-1
             j = order_ket(jj)
!test2 it is enough to have only   if (.special_ket(i)[1]>0 ) then
! however safer to have full test, specially if we generalise the routine
! in the future
             if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
             !  Case 2, i special, j special
               bi1 = .special_ket(i)[1]
               bi2 = .special_ket(i)[2]
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               fac = .bra(dim)[bi1,bj2]
               if (bi1==bj1 AND bi2==bj2)  fac=TWO * fac
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
               reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
               reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
               reorder_ket(dim-1) = i 
               .special_ket(i)[1] = bj1 ! i=reorder_ket(dim-1)
             ! .special_ket(i)[2] = bi2 
               res = res - .overlap_for(reorder_ket) * fac ! <<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
               .special_ket(i)[1] = bi1
               reorder_ket.destroy
!test2 it is enough to have only  else if (.special_ket(j)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
             ! Case 2, only j special
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               do bi2 = 1,.n_bf
                 fac = ZERO
                 if (bi2==bj2) then
                   do bi1 = 1,bj1-1
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   do bi1 = bj1+1,.n_bf
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   fac = fac+ TWO*.ket(i)[bj1,bi2]*.bra(dim)[bj1,bj2]
                 else
                   do bi1 = 1,.n_bf
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                 end
                 if (NOT fac.is_zero) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                   reorder_ket(dim-1) = j 
               !   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                   res = res - .overlap_for(reorder_ket) * fac ! <<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                   .special_ket(j)[2] = bj2
                   reorder_ket.destroy
                 end
               end
!test2 it is enough to have only  else 
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
             !  Case 2, NONE SPECIAL
               do bi2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = ZERO
                 do bi1 = 1,.n_bf
                 do bj2 = 1,.n_bf
                   fac = fac + (.ket(i)[bi1,bi2]*.ket(j)[bj1,bj2]+.ket(i)[bj1,bj2]*.ket(j)[bi1,bi2])*.bra(dim)[bi1,bj2]
                 end
                 end
                 if (NOT fac.is_zero) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                   reorder_ket(dim-1) = j 
                   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2
                   res = res - .overlap_for(reorder_ket) * fac ! <<
                   .special_ket(j)[1] = 0 
                   .special_ket(j)[2] = 0 
                   reorder_ket.destroy
                 end 
               end
               end
!test2 next 3 lines not needed
! however safer to have full test, specially if we generalise the routine
! in the future
             else 
               DIE("i special ket but not j !")
             end
           end  ! for do jj=dim,ii+1,-1
         end ! end for the if(i==1) else
       end  ! for do ii=dim,1,-1
     end ! for if(dim==1)
   end

   overlap_for(order_bra,order_ket,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals column
   ! vector specified by col_ind between mean field (Sz=0)-geminals 
   ! upper half only is evaluated.
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     col_ind :: INT
     order_bra, order_ket :: VEC{INT}
     res :: VEC{REAL}(.n_bas)
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,row_ind :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*

     dim = order_ket.dim
     res = ZERO
      
     if (dim==1) then
       ! case 1
       i = order_ket(1)
       DIE_IF(i==1 AND .special_ket(1)[1]==0,"dim=1, i=1 but .special_ket(1) not set!") 
       do row_ind=1,col_ind
         if (.special_ket(i)[1]>0) then             
           bi1 = .special_ket(i)[1]                 
           bi2 = .special_ket(i)[2]                
           fac = .contraction_wfs(row_ind)[bi1,bi2]
         else
           fac = sum(.contraction_wfs(row_ind)[:,:]*.ket(i)[:,:])
         end
         if (NOT fac.is_zero) then
           res(row_ind) = fac
         end
       end
       return
       ! no Case 2 when dim =1
     else
     ! dim > 1
       do ii = dim,1,-1
         i = order_ket(ii)
         DIE_IF(i==1 AND .special_ket(1)[1]==0,"i=1 but .special_ket(1) not set!") 
         ! case 1
         if (.special_ket(i)[1]>0) then
            bi1 = .special_ket(i)[1]
            bi2 = .special_ket(i)[2]
            fac = .bra(dim)[bi1,bi2]
         else
            fac = sum(.bra(dim)[:,:]*.ket(i)[:,:])
         end
         if (NOT fac.is_zero) then
           reorder_ket.create(dim-1)
           reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
           reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
           res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
           reorder_ket.destroy
         end
         ! Case 2
         do jj = dim,ii+1,-1
           j = order_ket(jj)
!test2 it is enough to have only   if (.special_ket(i)[1]>0 ) then
! however safer to have full test, specially if we generalise the routine
! in the future
           if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
           !  Case 2, i special, j special
             bi1 = .special_ket(i)[1]
             bi2 = .special_ket(i)[2]
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             fac = .bra(dim)[bi1,bj2]
             if (bi1==bj1 AND bi2==bj2)  fac=TWO * fac
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
             reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
             reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
             reorder_ket(dim-1) = i 
             .special_ket(i)[1] = bj1 ! i=reorder_ket(dim-1)
           ! .special_ket(i)[2] = bi2 
             res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
             .special_ket(i)[1] = bi1
             reorder_ket.destroy
!test2 it is enough to have only  else if (.special_ket(j)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
           ! Case 2, only j special
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             do bi2 = 1,.n_bf
               fac = ZERO
               if (bi2==bj2) then
                 do bi1 = 1,bj1-1
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
                 do bi1 = bj1+1,.n_bf
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
                 fac = fac+ TWO*.ket(i)[bj1,bi2]*.bra(dim)[bj1,bj2]
               else
                 do bi1 = 1,.n_bf
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
               end
               if (NOT fac.is_zero) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                 reorder_ket(dim-1) = j 
             !   .special_ket(j)[1] = bj1 
                 .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3  seems safer to put back the value bj1 and bj2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                 .special_ket(j)[2] = bj2
                 reorder_ket.destroy
               end
             end
!test2 it is enough to have only  else 
! however safer to have full test, specially if we generalise the routine
! in the future
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
           !  Case 2, NONE SPECIAL
             do bi2 = 1,.n_bf
             do bj1 = 1,.n_bf
               fac = ZERO
               do bi1 = 1,.n_bf
               do bj2 = 1,.n_bf
                 fac = fac + (.ket(i)[bi1,bi2]*.ket(j)[bj1,bj2]+.ket(i)[bj1,bj2]*.ket(j)[bi1,bi2])*.bra(dim)[bi1,bj2]
               end
               end
               if (NOT fac.is_zero) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                 reorder_ket(dim-1) = j 
                 .special_ket(j)[1] = bj1 
                 .special_ket(j)[2] = bi2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                 .special_ket(j)[1] = 0 
                 .special_ket(j)[2] = 0 
                 reorder_ket.destroy
               end 
             end
             end
!test2 next 3 lines not needed
! however safer to have full test, specially if we generalise the routine
! in the future
           else 
             DIE("i special ket but not j !")
           end
         end  ! for do jj=dim,ii+1,-1
       end  ! for do ii=dim,1,-1
     end ! for if(dim==1)
   end

   overlap_for(order_bra,order_ket,row_ind,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix
   ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     row_ind, col_ind :: INT
     order_bra, order_ket :: VEC{INT}
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim==order_bra.dim,"dim of bra not equal to dim of ket")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     q,jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
     reorder_ket :: VEC{INT}*
     reorder_bra :: VEC{INT}*
     fac :: REAL
     temp_bra_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_qb_jb :: MAT{REAL}*

     dim = order_ket.dim
     q=order_bra(dim)
     if(q==1) then
       temp_bra_q => .contraction_wfs(row_ind)[:,:]
     else
       temp_bra_q => .bra(q)[:,:]
     end
     reorder_bra.create(dim-1)
     reorder_bra(1:dim-1)   = [ (order_bra(l), l=1,dim-1) ]
     res = ZERO
      
     if (dim==1) then ! only Case 1
       j = order_ket(1)
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         fac = temp_bra_q(bj1,bj2)
       else if(.special_ket(j)[1]==0 AND j==1) then
         fac = sum(temp_bra_q*.contraction_wfs(col_ind)[:,:])
       else if (.special_ket(j)[1]==0 AND j/=1) then
         fac = sum(temp_bra_q*.ket(j)[:,:])
       end
       if (NOT fac.is_zero) then
          res = fac
       end
       return
     else ! dim > 1
       reorder_ket.create(dim-1)
       temp_qa_ja.create(.n_bf,.n_bf)
       temp_qb_jb.create(.n_bf,.n_bf)
       do jj = dim,1,-1
         j = order_ket(jj)
         if (j==1 AND .special_ket(1)[1]==0) then ! 1 not special
           temp_ket_j => .contraction_wfs(col_ind)[:,:]
           do bj1=1,.n_bf
           do bq1=1,.n_bf
             temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
             temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
           end
           end
! Case 2
           do kk = dim,jj+1,-1
             k = order_ket(kk)
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:kk-2) = [ (order_ket(l), l=jj+1,kk-1) ]
             reorder_ket(kk-1:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
             reorder_ket(dim-1) = k 
             if (.special_ket(k)[1]>0) then ! k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               do bj1 = 1,bk1-1
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj1 = bk1+1,.n_bf
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj2 = 1,bk2-1
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               do bj2 = bk2+1,.n_bf
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
               if (NOT fac.is_zero) then
               ! .special_ket(k)[1] = bk1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
               end
             else ! k not special
               temp_ket_k => .ket(k)[:,:]
               do bk2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                 if (NOT fac.is_zero) then
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end  ! if (.special_ket(k)
           end !do kk
! Case 1
           reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1) = [ (order_ket(l), l=jj+1,dim) ]
           fac = temp_qb_jb.trace
           if (NOT fac.is_zero) then
             res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
           end
         else ! j>1 or 1 special
           if (.special_ket(j)[1]>0) then
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
! Case 2
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!debug              if(.special_ket(k)[1]==0) then
!debug     write(*,*) "j special but not k"
!debug     stdout.show("dim=",dim)
!debug     do l=1,dim
!debug       stdout.show("l=",l)
!debug       stdout.show("order_ket(l)=",order_ket(l))
!debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!debug     end
!debug     stop
!debug     end
!assume special_ket's are also ordered at the end in the initial guess
               reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
               reorder_ket(jj:kk-2) = [ (order_ket(l), l=jj+1,kk-1) ]
               reorder_ket(kk-1:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
               reorder_ket(dim-1) = k 
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if(bj1/=bk1 OR bj2/=bk2) then
                 fac=temp_bra_q(bk1,bj2)
                 if (NOT fac.is_zero) then
                   .special_ket(k)[1] = bj1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
                 fac=temp_bra_q(bj1,bk2)
                 if (NOT fac.is_zero) then
                !  .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               else ! bj1==bk1 AND bj2==bk2
                 fac=TWO * temp_bra_q(bk1,bk2)
                 if (NOT fac.is_zero) then
                !  .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               end ! bj1==bk1 AND bj2==bk2
             end !do kk
! Case 1
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = [ (order_ket(l), l=jj+1,dim) ]
             fac = temp_bra_q(bj1,bj2)
             if (NOT fac.is_zero) then
               res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
             end
           else !j not special
             temp_ket_j => .ket(j)[:,:]
             do bj1=1,.n_bf
             do bq1=1,.n_bf
               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
             end
             end
! Case 2
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
               reorder_ket(jj:kk-2) = [ (order_ket(l), l=jj+1,kk-1) ]
               reorder_ket(kk-1:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
               reorder_ket(dim-1) = k 
               if (.special_ket(k)[1]>0) then ! k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 do bj1 = 1,bk1-1
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj1 = bk1+1,.n_bf
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj2 = 1,bk2-1
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 do bj2 = bk2+1,.n_bf
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               else ! k not special
                 temp_ket_k => .ket(k)[:,:]
                 do bk2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                   if (NOT fac.is_zero) then
                     .special_ket(k)[1] = bj1 
                     .special_ket(k)[2] = bk2
                     res = res - .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   end
                 end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
               end  ! if (.special_ket(k)
             end !do kk
! Case 1
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = [ (order_ket(l), l=jj+1,dim) ]
             fac = temp_qb_jb.trace
             if (NOT fac.is_zero) then
               res = res + .overlap_for(reorder_bra,reorder_ket,row_ind,col_ind) * fac ! <<
             end
           end !j not special
         end !if(j==1 AND .special_ket(1)==0) else
       end  !do jj=dim,1,-1
     temp_qa_ja.destroy
     temp_qb_jb.destroy
     reorder_ket.destroy
     end ! if(dim==1)
     reorder_bra.destroy
   end


   special_overlap_spin_ab_for(order_bra,order_ket,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals matrix between
   ! mean field (Sz=0)-geminals when .bra(dim) is a special bra
!comments: should not be called if dim=1 because row_ind and col_ind would
! be already defined.

     b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(1)[2]==0,"special ket already set for contraction 1")
     ENSURE(.special_ket(order_ket.dim)[2]>0,"no special ket matching special bra")
     ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,col_ind :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*

     dim = order_ket.dim
     res = ZERO
      
     ! dim > 1
     do ii = dim,1,-1
       i = order_ket(ii)
       if (i==1) then
!debug        write(*,*) "coucou1,ii,i",ii,i
         ! Case 1
         do col_ind=1,.n_bas
           fac = .contraction_wfs(col_ind)[b1,b2]
           if (NOT fac.is_zero) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
             res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac ! <<
              reorder_ket.destroy
           end
         ! Case 2
           do jj = dim,ii+1,-1
             j = order_ket(jj)
             if (.special_ket(j)[1]>0) then
               ! Case 2, only j special
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               if (bj2 == b2 ) then
                 do bi2 = 1,.n_bf
                   if (bi2==bj2 AND b1==bj1 ) then
                       fac =  TWO*.contraction_wfs(col_ind)[b1,bi2]
                   else
                       fac =  .contraction_wfs(col_ind)[b1,bi2]
                   end
                   if (NOT fac.is_zero) then
                     reorder_ket.create(dim-1)
                     reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                     reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                     reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                     reorder_ket(dim-1) = j 
                 !   .special_ket(j)[1] = bj1 
                     .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3                   .special_ket(j)[1] = 0 ! j=reorder_ket(dim-1)
                     .special_ket(j)[2] = bj2
                     reorder_ket.destroy
                   end
                 end
               end
             else if (.special_ket(j)[1]==0) then
             !  Case 2, NONE SPECIAL
               do bi2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = .contraction_wfs(col_ind)[b1,bi2]*.ket(j)[bj1,b2]+.contraction_wfs(col_ind)[bj1,b2]*.ket(j)[b1,bi2]
                 if (NOT fac.is_zero) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                   reorder_ket(dim-1) = j 
                   .special_ket(j)[1] = bj1 ! j=reorder_ket(dim-1)
                   .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                   res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                   .special_ket(j)[1] = 0 ! j=reorder_ket(dim-1)
                   .special_ket(j)[2] = 0 ! j=reorder_ket(dim-1)
                   reorder_ket.destroy
                 end 
               end
               end
             end !else if (.special_ket(j)[1]==0) then
           end   ! do jj=1,
         end  !do col_ind
       else !if (i/=1)
!debug        write(*,*) "coucou2,ii,i",ii,i
         ! Case 1
         if (.special_ket(i)[1]>0) then
           bi1 = .special_ket(i)[1]
           bi2 = .special_ket(i)[2]
           if (bi1==b1 AND bi2==b2 ) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
              res = res + .overlap_for(reorder_ket)  ! <<
              reorder_ket.destroy
           end
         else
           fac = .ket(i)[b1,b2]
           if (NOT fac.is_zero) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
             res = res + .overlap_for(reorder_ket)*fac ! <<
             reorder_ket.destroy
           end
         end
         ! Case 2
         do jj = dim,ii+1,-1
           j = order_ket(jj)
!debug        write(*,*) "coucou22,jj,j",jj,j
           if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
!test2           if (.special_ket(i)[1]>0 ) then
           !  Case 2, i special, j special
             bi1 = .special_ket(i)[1]
             bi2 = .special_ket(i)[2]
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             if (bi1==b1 AND bj2==b2) then
               fac = ONE
               if (bi1==bj1 AND bi2==bj2)  fac=TWO 
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
               reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
               reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
               reorder_ket(dim-1) = i 
               .special_ket(i)[1] = bj1 ! i=reorder_ket(dim-1)
             ! .special_ket(i)[2] = bi2 
               res = res - .overlap_for(reorder_ket) * fac ! <<
!test3         .special_ket(i)[2] = 0 
               .special_ket(i)[1] = bi1
               reorder_ket.destroy
             end
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
             ! Case 2, only j special
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             if (bj2 == b2 ) then
               do bi2 = 1,.n_bf
                 if (bi2==bj2 AND b1==bj1 ) then
                     fac =  TWO*.ket(i)[b1,bi2]
                 else
                     fac =  .ket(i)[b1,bi2]
                 end
                 if (NOT fac.is_zero) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                   reorder_ket(dim-1) = j 
               !   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                   res = res - .overlap_for(reorder_ket) * fac ! <<
!test3             .special_ket(j)[1] = 0 ! j=reorder_ket(dim-1)
                   .special_ket(j)[2] = bj2
                   reorder_ket.destroy
                 end
               end
             end
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
           !  Case 2, NONE SPECIAL
             do bi2 = 1,.n_bf
             do bj1 = 1,.n_bf
               fac = .ket(i)[b1,bi2]*.ket(j)[bj1,b2]+.ket(i)[bj1,b2]*.ket(j)[b1,bi2]
               if (NOT fac.is_zero) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                 reorder_ket(dim-1) = j 
                 .special_ket(j)[1] = bj1 ! j=reorder_ket(dim-1)
                 .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                 res = res - .overlap_for(reorder_ket) * fac ! <<
                 .special_ket(j)[1] = 0 ! j=reorder_ket(dim-1)
                 .special_ket(j)[2] = 0 ! j=reorder_ket(dim-1)
                 reorder_ket.destroy
               end 
             end
             end
           end !else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
         end  ! do jj=dim,ii+1
       end !if(i==1) else
     end !do ii
   end

   special_overlap_spin_ab_for(order_bra,order_ket,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals column vector
   ! specified by col_ind between mean field (Sz=0)-geminals when .bra(dim) is a special bra
!comments: should not be called if dim=1 because row_ind would be already defined.
     col_ind,b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: VEC{REAL}(.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(order_ket.dim)[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
      ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2 :: INT
      fac :: REAL
      reorder_ket :: VEC{INT}*
      dim = order_ket.dim

      res = ZERO
      
      ! dim > 1
      do ii = dim,1,-1
         i = order_ket(ii)
         ! The simple case 1
         if (.special_ket(i)[1]>0) then
           bi1 = .special_ket(i)[1]
           bi2 = .special_ket(i)[2]
           if (bi1==b1 AND bi2==b2 ) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
             res = res + .overlap_for(reorder_ket,col_ind)  ! <<
             reorder_ket.destroy
           end
         else
! not necessary, but safer that way
           DIE_IF(i==1,"special ket not set for contraction 1")
           fac = .ket(i)[b1,b2]
           if (NOT fac.is_zero) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
             res = res + .overlap_for(reorder_ket,col_ind)*fac ! <<
             reorder_ket.destroy
           end
         end
         ! Case 2
         do jj = dim,ii+1,-1
           j = order_ket(jj)
           if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
!test2           if (.special_ket(i)[1]>0 ) then
           !  Case 2, i special, j special
             bi1 = .special_ket(i)[1]
             bi2 = .special_ket(i)[2]
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             if (bi1==b1 AND bj2==b2) then
               fac = ONE
               if (bi1==bj1 AND bi2==bj2)  fac=TWO 
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
               reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
               reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
               reorder_ket(dim-1) = i 
               .special_ket(i)[1] = bj1 ! i=reorder_ket(dim-1)
             ! .special_ket(i)[2] = bi2 
               res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3         .special_ket(i)[2] = 0 
               .special_ket(i)[1] = bi1
               reorder_ket.destroy
             end
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
             ! Case 2, only j special
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             if (bj2 == b2 ) then
               do bi2 = 1,.n_bf
                 if (bi2==bj2 AND b1==bj1 ) then
                     fac =  TWO*.ket(i)[b1,bi2]
                 else
                     fac =  .ket(i)[b1,bi2]
                 end
                 if (NOT fac.is_zero) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                   reorder_ket(dim-1) = j 
               !   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                   res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3             .special_ket(j)[1] = 0 ! j=reorder_ket(dim-1)
                   .special_ket(j)[2] = bj2
                   reorder_ket.destroy
                 end
               end
             end
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
           !  Case 2, NONE SPECIAL
             do bi2 = 1,.n_bf
             do bj1 = 1,.n_bf
               fac = .ket(i)[b1,bi2]*.ket(j)[bj1,b2]+.ket(i)[bj1,b2]*.ket(j)[b1,bi2]
               if (NOT fac.is_zero) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                 reorder_ket(dim-1) = j 
                 .special_ket(j)[1] = bj1 ! j=reorder_ket(dim-1)
                 .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                 .special_ket(j)[1] = 0 ! j=reorder_ket(dim-1)
                 .special_ket(j)[2] = 0 ! j=reorder_ket(dim-1)
                 reorder_ket.destroy
               end 
             end
             end
           end
         end
      end
   end

   special_overlap_spin_ab_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res) ::: recursive
   ! Special function which evaluates the overlap integrals matrix element
   ! specified by row_ind and col_ind between mean field (Sz=0)-geminals when .bra(dim) is a special bra
     row_ind,col_ind,b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: REAL
!     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     dim,bq1,bq2,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
     
     if(.special_ket(q)[2]==0) then !not a special ket
       if(q==1) then
         DIE_IF(dim/=1,"order(dim>1)=1")
         temp_ket_q => .contraction_wfs(col_ind)[:,:]
       else
         temp_ket_q => .ket(q)[:,:]
       end
       do bq1=1,.n_bf
         .special_ket(q)[1]=bq1
         do bq2=1,.n_bf
           if (NOT temp_ket_q(bq1,bq2).is_zero) then
             .special_ket(q)[2]=bq2
             res=res+.special_overlap_spin_ab_for(order_bra,order_ket,row_ind,col_ind,b1,b2) &
                   *temp_ket_q(bq1,bq2) 
           end
         end
       end
       .special_ket(q)[1]=0
       .special_ket(q)[2]=0
       return
     end
! at this stage q is necessarily a special ket
     if(dim==1) then
       if (.special_ket(q)[1]==b1 AND .special_ket(q)[2]==b2 ) res = ONE
       return
     else ! q special ket and dim>1
       reorder_ket.create(dim-1)
       do jj = dim,1,-1
          reorder_ket(1:jj-1)   = [ (order_ket(i), i=1,jj-1) ]
          reorder_ket(jj:dim-1) = [ (order_ket(i), i=jj+1,dim) ]
          j = order_ket(jj)
          if (.special_ket(j)[1]>0) then  !j special
            bj1 = .special_ket(j)[1]
            bj2 = .special_ket(j)[2]
! The simple case 1
            if (bj1==b1 AND bj2==b2 ) then
              res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)  ! <<
            end
! Case 2
            do kk = dim,jj+1,-1
              k = order_ket(kk)
              DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
              bk1 = .special_ket(k)[1]
              bk2 = .special_ket(k)[2]
              reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
              reorder_ket(jj:kk-2) = [ (order_ket(i), i=jj+1,kk-1) ]
              reorder_ket(kk-1:dim-2) = [ (order_ket(i), i=kk+1,dim) ]
              reorder_ket(dim-1) = k 
              if (bj1==b1 AND bk2==b2 AND (bj2/=b2 OR bk1/=b1)) then
                fac = ONE
              ! .special_ket(k)[1] = bk1 ! 
                .special_ket(k)[2] = bj2 
              else if((bj1/=b1 OR bk2/=b2) AND bj2==b2 AND bk1==b1) then
                fac = ONE
                .special_ket(k)[1] = bj1 ! 
              ! .special_ket(k)[2] = bk2 
              else if(bj1==b1 AND bk2==b2 AND bj2==b2 AND bk1==b1) then
                 fac=TWO 
              ! .special_ket(k)[1] = bk1  
              ! .special_ket(k)[2] = bk2 
              end
              res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
              .special_ket(k)[1] = bk1
              .special_ket(k)[2] = bk2
            end !do kk
          else ! j not special
            if(j==1)then
              temp_ket_j => .contraction_wfs(col_ind)[:,:]
            else
              temp_ket_j => .ket(j)[:,:]
            end
! Case 1
            fac = temp_ket_j(b1,b2)
            if (NOT fac.is_zero) then
              res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac ! <<
            end
! Case 2
            do kk = dim,jj+1,-1
              k = order_ket(kk)
              reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
              reorder_ket(jj:kk-2) = [ (order_ket(i), i=jj+1,kk-1) ]
              reorder_ket(kk-1:dim-2) = [ (order_ket(i), i=kk+1,dim) ]
              reorder_ket(dim-1) = k 
              if (.special_ket(k)[1]>0) then
! Case 2, k special
                bk1 = .special_ket(k)[1]
                bk2 = .special_ket(k)[2]
                if (bk2 == b2 AND bk1 /= b1) then
                  do bj2 = 1,.n_bf
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                    end
                  end
                  .special_ket(k)[2] = bk2
                else if (bk2 /= b2 AND bk1 == b1) then   
                  do bj1 = 1,.n_bf
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                    end
                  end
                  .special_ket(k)[1] = bk1
                else if (bk2 == b2 AND bk1 == b1) then   
                  do bj1 = 1,b1-1
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                    end
                  end
                  do bj1 = b1+1,.n_bf
                    fac = temp_ket_j(bj1,b2)
                    if (NOT fac.is_zero) then
                      .special_ket(k)[1] = bj1 
                   !  .special_ket(k)[2] = bk2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                    end
                  end
                  .special_ket(k)[1] = bk1
                  do bj2 = 1,b2-1
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                    end
                  end
                  do bj2 = b2+1,.n_bf
                    fac = temp_ket_j(b1,bj2)
                    if (NOT fac.is_zero) then
                  !   .special_ket(k)[1] = bk1 
                      .special_ket(k)[2] = bj2
                      res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                    end
                  end
                  .special_ket(k)[2] = bk2
                  fac = TWO*temp_ket_j(b1,b2)
                  if (NOT fac.is_zero) then
                  !   .special_ket(k)[1] = bk1 
                  !   .special_ket(k)[2] = bk2 
                    res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                  end
                end !else if (bk2 == b2 AND bk1 == b1)
              else !  Case 2, NONE SPECIAL
                temp_ket_k => .ket(k)[:,:]
                do bj2 = 1,.n_bf
                do bk1 = 1,.n_bf
                  fac = temp_ket_j(b1,bj2)*temp_ket_k(bk1,b2)+temp_ket_j(bk1,b2)*temp_ket_k(b1,bj2)
                  if (NOT fac.is_zero) then
                    .special_ket(k)[1] = bk1 
                    .special_ket(k)[2] = bj2
                    res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                  end 
                end
                end
                .special_ket(k)[1] = 0 
                .special_ket(k)[2] = 0
              end ! if k special
            end !do kk
          end! if j special
       end !do jj
       reorder_ket.destroy
     end ! q special ket and dim>1
   end

   special_overlap_spin_bb_for(order_bra,order_ket,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals between
   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
   ! special bra which are (Sz=-1)-geminals.
!comments: should not be called if dim=1 because row_ind and col_ind would
! be already defined.

     b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(1)[2]==0,"special ket already set for contraction 1")
     ENSURE(.special_ket(order_ket.dim)[2]>0,"no special ket matching special bra")
     row_ind,col_ind,ii,jj,i,j,k,dim,bi1,bi2,bj1,bj2,b3,b4 :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*

     dim = order_ket.dim
     res = ZERO
      
     ! test for identical spinorbitals
     i = order_ket(dim)
     b3 = .special_ket(i)[1]
     b4 = .special_ket(i)[2]
     if (b3==b4 OR b1==b2 ) return
      
     ! dim>1 Case 1
     if (b3==b1 AND b4==b2 ) then
       reorder_ket.create(dim-1)
       reorder_ket(1:dim-1)   = [ (order_ket(j), j=1,dim-1) ]
       res = res + .overlap_for(reorder_ket)  ! <<
       reorder_ket.destroy
     end
     if (b3==b2 AND b4==b1 ) then
       reorder_ket.create(dim-1)
       reorder_ket(1:dim-1)   = [ (order_ket(j), j=1,dim-1) ]
       res = res - .overlap_for(reorder_ket)  ! <<
       reorder_ket.destroy
     end
     ! this loop does something only if dim > 1
     do ii = dim-1,1,-1
        i = order_ket(ii)
        if(i==1) then
          do col_ind=1,.n_bas
            ! Case 2
            if (b4==b2 ) then
              do bi1=1,.n_bf
                fac = - .contraction_wfs(col_ind)[bi1,b1]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = 1
                  .special_ket(1)[2] = b3 
                  .special_ket(1)[1] = bi1 
                  res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                  .special_ket(1)[1] = 0
                  .special_ket(1)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
            if (b4==b1 ) then
              do bi1=1,.n_bf
                fac =  .contraction_wfs(col_ind)[bi1,b2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = 1
                  .special_ket(1)[2] = b3 
                  .special_ket(1)[1] = bi1 
                  res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                  .special_ket(1)[1] = 0
                  .special_ket(1)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
            if (b3==b2 ) then
              do bi1=1,.n_bf
                fac =  .contraction_wfs(col_ind)[bi1,b1]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = 1
                  .special_ket(1)[2] = b4 
                  .special_ket(1)[1] = bi1 
                  res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                  .special_ket(1)[1] = 0
                  .special_ket(1)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
            if (b3==b1 ) then
              do bi1=1,.n_bf
                fac = - .contraction_wfs(col_ind)[bi1,b2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = 1
                  .special_ket(1)[2] = b4 
                  .special_ket(1)[1] = bi1 
                  res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                  .special_ket(1)[1] = 0
                  .special_ket(1)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
            ! Case 3
            ! only do something if dim>2
            do jj = dim-1,ii+1,-1
              j = order_ket(jj)
              if (.special_ket(j)[1]>0) then
              ! Case 3, only j special
                bj2 = .special_ket(j)[2]
                if (bj2==b2) then
              !   bj1 = .special_ket(j)[1]
                  do bi1 = 1,.n_bf
                    fac = .contraction_wfs(col_ind)[bi1,b1]
                    if (NOT fac.is_zero ) then
                      reorder_ket.create(dim-1)
                      reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                      reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                      reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                      reorder_ket(dim-2) = 1 
                      reorder_ket(dim-1) = j 
                      .special_ket(1)[2] = b3 
                      .special_ket(1)[1] = bi1 
                      .special_ket(j)[2] = b4
                    ! .special_ket(j)[2] = bj2 unchanged
                      res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3                .special_ket(j)[1] = bj1 unchanged
                      .special_ket(1)[1] = 0 
                      .special_ket(1)[2] = 0 
                      .special_ket(j)[2] = bj2
                      reorder_ket.destroy
                    end
                  end
                end
                if (bj2==b1) then
               !  bj1 = .special_ket(j)[1]
                  do bi1 = 1,.n_bf
                    fac = - .contraction_wfs(col_ind)[bi1,b2]
                    if (NOT fac.is_zero ) then
                      reorder_ket.create(dim-1)
                      reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                      reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                      reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                      reorder_ket(dim-2) = 1 
                      reorder_ket(dim-1) = j 
                      .special_ket(1)[2] = b3 
                      .special_ket(1)[1] = bi1 
                      .special_ket(j)[2] = b4
                    ! .special_ket(j)[1] = bj1 unchanged
                      res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3                .special_ket(j)[1] = bj1 unchanged
                      .special_ket(1)[1] = 0 
                      .special_ket(1)[2] = 0 
                      .special_ket(j)[2] = bj2
                      reorder_ket.destroy
                    end
                  end
                end
              else 
              !  Case 3, NONE SPECIAL
                do bi1 = 1,.n_bf
                do bj1 = 1,.n_bf
                  fac = .contraction_wfs(col_ind)[bi1,b1]*.ket(j)[bj1,b2]-.contraction_wfs(col_ind)[bi1,b2]*.ket(j)[bj1,b1]
                  if (NOT fac.is_zero ) then
                    reorder_ket.create(dim-1)
                    reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                    reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                    reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                    reorder_ket(dim-2) = 1 
                    reorder_ket(dim-1) = j 
                    .special_ket(1)[2] = b3 
                    .special_ket(1)[1] = bi1 
                    .special_ket(j)[2] = b4
                    .special_ket(j)[1] = bj1 
                    res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
                    .special_ket(1)[1] = 0 
                    .special_ket(1)[2] = 0 
                    .special_ket(j)[1] = 0
                    .special_ket(j)[2] = 0
                    reorder_ket.destroy
                  end
                end
                end
              end !if for case 3
            end  !do jj
          end !do col_ind
        else  !if (is/==1)
          ! Case 2
          if (b4==b2 ) then
            if (.special_ket(i)[1]>0) then
              bi2 = .special_ket(i)[2]
              if (bi2==b1 ) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                reorder_ket(dim-1) = i
                .special_ket(i)[2] = b3 
                ! .special_ket(i)[2] = bi2 unchanged 
                res = res - .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[1] = bi1 unchanged 
                .special_ket(i)[2] = bi2 
                reorder_ket.destroy
              end
            else
              do bi1=1,.n_bf
                fac = - .ket(i)[bi1,b1]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = i
                  .special_ket(i)[2] = b3 
                  .special_ket(i)[1] = bi1 
                  res = res + .overlap_for(reorder_ket)*fac  ! <<
                  .special_ket(i)[1] = 0
                  .special_ket(i)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
          end
          if (b4==b1 ) then
            if (.special_ket(i)[1]>0) then
              bi2 = .special_ket(i)[2]
              if (bi2==b2 ) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                reorder_ket(dim-1) = i
                .special_ket(i)[2] = b3 
              ! .special_ket(i)[1] = bi1 unchanged 
                res = res + .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[1] = bi1
                .special_ket(i)[2] = bi2
                reorder_ket.destroy
              end
            else
              do bi1=1,.n_bf
                fac =  .ket(i)[bi1,b2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = i
                  .special_ket(i)[2] = b3 
                  .special_ket(i)[1] = bi1 
                  res = res + .overlap_for(reorder_ket)*fac  ! <<
                  .special_ket(i)[1] = 0
                  .special_ket(i)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
          end
          if (b3==b2 ) then
            if (.special_ket(i)[1]>0) then
              bi2 = .special_ket(i)[2]
              if (bi2==b1 ) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                reorder_ket(dim-1) = i
                .special_ket(i)[2] = b4 
              ! .special_ket(i)[1] = bi1 unchanged 
                res = res + .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[1] = bi1
                .special_ket(i)[2] = bi2
                reorder_ket.destroy
              end
            else
              do bi1=1,.n_bf
                fac =  .ket(i)[bi1,b1]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = i
                  .special_ket(i)[2] = b4 
                  .special_ket(i)[1] = bi1 
                  res = res + .overlap_for(reorder_ket)*fac  ! <<
                  .special_ket(i)[1] = 0
                  .special_ket(i)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
          end
          if (b3==b1 ) then
            if (.special_ket(i)[1]>0) then
              bi2 = .special_ket(i)[2]
              if (bi2==b2 ) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                reorder_ket(dim-1) = i
                .special_ket(i)[2] = b4 
              ! .special_ket(i)[1] = bi1 unchanged 
                res = res - .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[1] = bi1
                .special_ket(i)[2] = bi2
                reorder_ket.destroy
              end
            else
              do bi1=1,.n_bf
                fac = - .ket(i)[bi1,b2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = i
                  .special_ket(i)[2] = b4 
                  .special_ket(i)[1] = bi1 
                  res = res + .overlap_for(reorder_ket)*fac  ! <<
                  .special_ket(i)[1] = 0
                  .special_ket(i)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
          end
          ! Case 3
          ! only do something if dim>2
          do jj = dim-1,ii+1,-1
            j = order_ket(jj)
            if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
            ! Case 3, i special, j special
              bi2 = .special_ket(i)[2]
            ! bi1 = .special_ket(i)[1] unchanged
              bj2 = .special_ket(j)[2]
            ! bj1 = .special_ket(j)[1] unchanged
              if (bi2==b1 AND bj2==b2) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                reorder_ket(dim-2) = i 
                reorder_ket(dim-1) = j 
                .special_ket(i)[2] = b3 
              ! .special_ket(i)[1] = bi1 unchanged 
                .special_ket(j)[2] = b4 
              ! .special_ket(j)[1] = bj1  unchanged
                res = res + .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[1] = bi1
                .special_ket(i)[2] = bi2 
                .special_ket(j)[2] = bj2
!test3          .special_ket(j)[1] = bj1
                reorder_ket.destroy
              end
              if (bi2==b2 AND bj2==b1) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                reorder_ket(dim-2) = i 
                reorder_ket(dim-1) = j 
                .special_ket(i)[2] = b3 
              ! .special_ket(i)[1] = bi1 unchanged 
                .special_ket(j)[2] = b4 
              ! .special_ket(j)[1] = bj1  unchanged
                res = res - .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[1] = bi1
                .special_ket(i)[2] = bi2 
                .special_ket(j)[2] = bj2
 !test3         .special_ket(j)[1] = bj1
                reorder_ket.destroy
              end
            else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
            ! Case 3, only j special
              bj2 = .special_ket(j)[2]
              if (bj2==b2) then
            !   bj1 = .special_ket(j)[1]
                do bi1 = 1,.n_bf
                  fac = .ket(i)[bi1,b1]
                  if (NOT fac.is_zero ) then
                    reorder_ket.create(dim-1)
                    reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                    reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                    reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                    reorder_ket(dim-2) = i 
                    reorder_ket(dim-1) = j 
                    .special_ket(i)[2] = b3 
                    .special_ket(i)[1] = bi1 
                    .special_ket(j)[2] = b4
                !   .special_ket(j)[1] = bj1 unchanged
                    res = res + .overlap_for(reorder_ket) * fac ! <<
!test3              .special_ket(j)[1] = bj1 unchanged
                    .special_ket(i)[1] = 0 
                    .special_ket(i)[2] = 0 
                    .special_ket(j)[2] = bj2
                    reorder_ket.destroy
                  end
                end
              end
              if (bj2==b1) then
            !   bj1 = .special_ket(j)[1]
                do bi1 = 1,.n_bf
                  fac = - .ket(i)[bi1,b2]
                  if (NOT fac.is_zero ) then
                    reorder_ket.create(dim-1)
                    reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                    reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                    reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                    reorder_ket(dim-2) = i 
                    reorder_ket(dim-1) = j 
                    .special_ket(i)[2] = b3 
                    .special_ket(i)[1] = bi1 
                    .special_ket(j)[2] = b4
                !   .special_ket(j)[1] = bj1 unchanged
                    res = res + .overlap_for(reorder_ket) * fac ! <<
!test3              .special_ket(j)[1] = bj1 unchanged
                    .special_ket(i)[1] = 0 
                    .special_ket(i)[2] = 0 
                    .special_ket(j)[2] = bj2
                    reorder_ket.destroy
                  end
                end
              end
            else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
            !  Case 3, NONE SPECIAL
              do bi1 = 1,.n_bf
              do bj1 = 1,.n_bf
                fac = .ket(i)[bi1,b1]*.ket(j)[bj1,b2]-.ket(i)[bi1,b2]*.ket(j)[bj1,b1]
                if (NOT fac.is_zero ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                  reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                  reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                  reorder_ket(dim-2) = i 
                  reorder_ket(dim-1) = j 
                  .special_ket(i)[2] = b3 
                  .special_ket(i)[1] = bi1 
                  .special_ket(j)[2] = b4
                  .special_ket(j)[1] = bj1 
                  res = res + .overlap_for(reorder_ket) * fac ! <<
                  .special_ket(i)[1] = 0 
                  .special_ket(i)[2] = 0 
                  .special_ket(j)[1] = 0
                  .special_ket(j)[2] = 0
                  reorder_ket.destroy
                end
              end
              end
            end ! if Case 3
          end !do jj
        end  !if (i/=1)
     end !do ii
   end

   special_overlap_spin_bb_for(order_bra,order_ket,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals column vector
   ! specified by col_ind between mean field (Sz=0)-geminals except 
   ! .special_ket(dim) and the corresponding special bra which are (Sz=-1)-geminals.
!comments: should not be called if dim=1 because row_ind would be already defined.
     col_ind,b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: VEC{REAL}(.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(order_ket.dim)[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     row_ind,ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,b3,b4 :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*

     dim = order_ket.dim
     res = ZERO
    
     ! test for identical spinorbitals
     i = order_ket(dim)
     b3 = .special_ket(i)[1]
     b4 = .special_ket(i)[2]
     if (b3==b4 OR b1==b2 ) return
      
      ! dim>1 
      ! Case 1
      if (b3==b1 AND b4==b2 ) then
        reorder_ket.create(dim-1)
        reorder_ket(1:dim-1)   = [ (order_ket(j), j=1,dim-1) ]
        res = res + .overlap_for(reorder_ket,col_ind)  ! <<
        reorder_ket.destroy
      end
      if (b3==b2 AND b4==b1 ) then
        reorder_ket.create(dim-1)
        reorder_ket(1:dim-1)   = [ (order_ket(j), j=1,dim-1) ]
        res = res - .overlap_for(reorder_ket,col_ind)  ! <<
        reorder_ket.destroy
      end
      ! this loop does something only if dim > 1
      do ii = dim-1,1,-1
         i = order_ket(ii)
         DIE_IF(i==1 AND .special_ket(1)[1]==0,"special ket not set for contraction 1")
         ! Case 2
         if (b4==b2 ) then
           if (.special_ket(i)[1]>0) then
             bi2 = .special_ket(i)[2]
             if (bi2==b1 ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
               reorder_ket(dim-1) = i
               .special_ket(i)[2] = b3 
             ! .special_ket(i)[2] = bi2 unchanged 
               res = res - .overlap_for(reorder_ket,col_ind)  ! <<
!test3         .special_ket(i)[1] = bi1 unchanged 
               .special_ket(i)[2] = bi2 
               reorder_ket.destroy
             end
           else
             do bi1=1,.n_bf
               fac = - .ket(i)[bi1,b1]
               if (NOT fac==ZERO ) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                 reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                 reorder_ket(dim-1) = i
                 .special_ket(i)[2] = b3 
                 .special_ket(i)[1] = bi1 
                 res = res + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                 .special_ket(i)[1] = 0
                 .special_ket(i)[2] = 0
                 reorder_ket.destroy
               end
             end
           end
         end
         if (b4==b1 ) then
           if (.special_ket(i)[1]>0) then
             bi2 = .special_ket(i)[2]
             if (bi2==b2 ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
               reorder_ket(dim-1) = i
               .special_ket(i)[2] = b3 
               ! .special_ket(i)[1] = bi1 unchanged 
               res = res + .overlap_for(reorder_ket,col_ind)  ! <<
!test3         .special_ket(i)[1] = bi1
               .special_ket(i)[2] = bi2
               reorder_ket.destroy
             end
           else
             do bi1=1,.n_bf
               fac =  .ket(i)[bi1,b2]
               if (NOT fac==ZERO ) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                 reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                 reorder_ket(dim-1) = i
                 .special_ket(i)[2] = b3 
                 .special_ket(i)[1] = bi1 
                 res = res + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                 .special_ket(i)[1] = 0
                 .special_ket(i)[2] = 0
                 reorder_ket.destroy
               end
             end
           end
         end
         if (b3==b2 ) then
           if (.special_ket(i)[1]>0) then
             bi2 = .special_ket(i)[2]
             if (bi2==b1 ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
               reorder_ket(dim-1) = i
               .special_ket(i)[2] = b4 
               ! .special_ket(i)[1] = bi1 unchanged 
               res = res + .overlap_for(reorder_ket,col_ind)  ! <<
!test3         .special_ket(i)[1] = bi1
               .special_ket(i)[2] = bi2
               reorder_ket.destroy
             end
           else
             do bi1=1,.n_bf
               fac =  .ket(i)[bi1,b1]
               if (NOT fac==ZERO ) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                 reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                 reorder_ket(dim-1) = i
                 .special_ket(i)[2] = b4 
                 .special_ket(i)[1] = bi1 
                 res = res + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                 .special_ket(i)[1] = 0
                 .special_ket(i)[2] = 0
                 reorder_ket.destroy
               end
             end
           end
         end
         if (b3==b1 ) then
           if (.special_ket(i)[1]>0) then
             bi2 = .special_ket(i)[2]
             if (bi2==b2 ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
               reorder_ket(dim-1) = i
               .special_ket(i)[2] = b4 
               ! .special_ket(i)[1] = bi1 unchanged 
               res = res - .overlap_for(reorder_ket,col_ind)  ! <<
!test3         .special_ket(i)[1] = bi1
               .special_ket(i)[2] = bi2
               reorder_ket.destroy
             end
           else
             do bi1=1,.n_bf
               fac = - .ket(i)[bi1,b2]
               if (NOT fac==ZERO ) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                 reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                 reorder_ket(dim-1) = i
                 .special_ket(i)[2] = b4 
                 .special_ket(i)[1] = bi1 
                 res = res + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                 .special_ket(i)[1] = 0
                 .special_ket(i)[2] = 0
                 reorder_ket.destroy
               end
             end
           end
         end
         ! Case 3
         ! only do something if dim>2
         do jj = dim-1,ii+1,-1
           j = order_ket(jj)
           if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
           !  Case 3, i special, j special
             bi2 = .special_ket(i)[2]
           !  bi1 = .special_ket(i)[1] unchanged
             bj2 = .special_ket(j)[2]
           !  bj1 = .special_ket(j)[1] unchanged
             if (bi2==b1 AND bj2==b2) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
               reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
               reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
               reorder_ket(dim-2) = i 
               reorder_ket(dim-1) = j 
               .special_ket(i)[2] = b3 
             ! .special_ket(i)[1] = bi1 unchanged 
               .special_ket(j)[2] = b4 
             ! .special_ket(j)[1] = bj1  unchanged
               res = res + .overlap_for(reorder_ket,col_ind)  ! <<
!test3         .special_ket(i)[1] = bi1
               .special_ket(i)[2] = bi2 
               .special_ket(j)[2] = bj2
!test3         .special_ket(j)[1] = bj1
               reorder_ket.destroy
             end
             if (bi2==b2 AND bj2==b1) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
               reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
               reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
               reorder_ket(dim-2) = i 
               reorder_ket(dim-1) = j 
               .special_ket(i)[2] = b3 
             ! .special_ket(i)[1] = bi1 unchanged 
               .special_ket(j)[2] = b4 
             ! .special_ket(j)[1] = bj1  unchanged
               res = res - .overlap_for(reorder_ket,col_ind)  ! <<
!test3         .special_ket(i)[1] = bi1
               .special_ket(i)[2] = bi2 
               .special_ket(j)[2] = bj2
!test3         .special_ket(j)[1] = bj1
               reorder_ket.destroy
             end
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
           ! Case 3, only j special
             bj2 = .special_ket(j)[2]
             if (bj2==b2) then
           !   bj1 = .special_ket(j)[1]
               do bi1 = 1,.n_bf
                 fac = .ket(i)[bi1,b1]
                 if (NOT fac.is_zero ) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                   reorder_ket(dim-2) = i 
                   reorder_ket(dim-1) = j 
                   .special_ket(i)[2] = b3 
                   .special_ket(i)[1] = bi1 
                   .special_ket(j)[2] = b4
                !   .special_ket(j)[1] = bj1 unchanged
                   res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3             .special_ket(j)[1] = bj1 unchanged
                   .special_ket(i)[1] = 0 
                   .special_ket(i)[2] = 0 
                   .special_ket(j)[2] = bj2
                   reorder_ket.destroy
                 end
               end
             end
             if (bj2==b1) then
           !   bj1 = .special_ket(j)[1]
               do bi1 = 1,.n_bf
                 fac = - .ket(i)[bi1,b2]
                 if (NOT fac.is_zero ) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                   reorder_ket(dim-2) = i 
                   reorder_ket(dim-1) = j 
                   .special_ket(i)[2] = b3 
                   .special_ket(i)[1] = bi1 
                   .special_ket(j)[2] = b4
                !   .special_ket(j)[1] = bj1 unchanged
                   res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3             .special_ket(j)[1] = bj1 unchanged
                   .special_ket(i)[1] = 0 
                   .special_ket(i)[2] = 0 
                   .special_ket(j)[2] = bj2
                   reorder_ket.destroy
                 end
               end
             end
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
           !  Case 3, NONE SPECIAL
             do bi1 = 1,.n_bf
             do bj1 = 1,.n_bf
               fac = .ket(i)[bi1,b1]*.ket(j)[bj1,b2]-.ket(i)[bi1,b2]*.ket(j)[bj1,b1]
               if (NOT fac.is_zero ) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                 reorder_ket(dim-2) = i 
                 reorder_ket(dim-1) = j 
                 .special_ket(i)[2] = b3 
                 .special_ket(i)[1] = bi1 
                 .special_ket(j)[2] = b4
                 .special_ket(j)[1] = bj1 
                 res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
                 .special_ket(i)[1] = 0 
                 .special_ket(i)[2] = 0 
                 .special_ket(j)[1] = 0
                 .special_ket(j)[2] = 0
                 reorder_ket.destroy
               end
             end
             end
           end !if case 3
         end  !do jj
      end !do ii
   end

   special_overlap_spin_bb_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals between
   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
   ! special bra which are (Sz=-1)-geminals.
     row_ind,col_ind,b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
      
     ! test for identical spinorbitals
     b3 = .special_ket(q)[1]
     b4 = .special_ket(q)[2]
     if (b3==b4 OR b1==b2 ) return
      
     if(dim==1) then ! only Case 0
       if (b3==b1 AND b4==b2 ) res = ONE
       if (b3==b2 AND b4==b1 ) res = -ONE
       return
     else !dim>1
       reorder_ket.create(dim-1)
! Case 0
       reorder_ket(1:dim-1)   = [ (order_ket(i), i=1,dim-1) ]
       if (b3==b1 AND b4==b2 ) then
         res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
       else if (b3==b2 AND b4==b1 ) then
         res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)
       end
       do jj = dim-1,1,-1
         reorder_ket(1:jj-1)   = [ (order_ket(i), i=1,jj-1) ]
         reorder_ket(jj:dim-1) = [ (order_ket(i), i=jj+1,dim) ] !reorder(dim-1)=q
         j = order_ket(jj)
         if (.special_ket(j)[1]>0) then  !j special
           DIE_IF(j==1,"1 special") 
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! The simple case 1
           if (bj2==b1 AND b4==b2 ) then
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b3
             res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj2==b2 AND b4==b1 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b3
             res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj2==b1 AND b3==b2 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b4
             res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj2==b2 AND b3==b1 ) then        
             .special_ket(q)[1]=bj1
             .special_ket(q)[2]=b4
             res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = [ (order_ket(i), i=jj+1,kk-1) ]
             reorder_ket(kk-1:dim-3) = [ (order_ket(i), i=kk+1,dim-1) ]
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (bj2==b1 AND bk2==b2 ) then
               .special_ket(k)[1]=bj1
               .special_ket(k)[2]=b3
               .special_ket(q)[1]=bk1
               .special_ket(q)[2]=b4
               res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
             else if (bj2==b2 AND bk2==b1 ) then
               .special_ket(k)[1]=bj1
               .special_ket(k)[2]=b3
               .special_ket(q)[1]=bk1
               .special_ket(q)[2]=b4
               res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
             end
             .special_ket(k)[1]=bk1
             .special_ket(k)[2]=bk2
           end ! do kk 
         else !j not special  
           if(j==1)then
             temp_ket_j => .contraction_wfs(col_ind)[:,:]
           else
             temp_ket_j => .ket(j)[:,:]
           end
! Case 1
           if (b4==b2 ) then
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b1)
               if (NOT fac.is_zero) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b3
                 res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac
               end
             end
           else if (b4==b1 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b2)
               if (NOT fac.is_zero) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b3
                 res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           end
           if (b3==b2 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b1)
               if (NOT fac.is_zero) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b4
                 res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           else if (b3==b1 ) then        
             do bj1=1,.n_bf
               fac = temp_ket_j(bj1,b2)
               if (NOT fac.is_zero) then
                 .special_ket(q)[1]=bj1
                 .special_ket(q)[2]=b4
                 res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = [ (order_ket(i), i=jj+1,kk-1) ]
             reorder_ket(kk-1:dim-3) = [ (order_ket(i), i=kk+1,dim-1) ]
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (.special_ket(k)[1]==0) then ! Case 2, k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if (bk2==b2 ) then
                 .special_ket(k)[2]=b3
                 .special_ket(q)[1]=bk1
                 .special_ket(q)[2]=b4
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b1)
                   if (NOT fac.is_zero) then
                     .special_ket(k)[1]=bj1
                     res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
                   end
                 end
               else if (bk2==b1 ) then
                 .special_ket(k)[2]=b3
                 .special_ket(q)[1]=bk1
                 .special_ket(q)[2]=b4
                 do bj1=1,.n_bf
                   fac = temp_ket_j(bj1,b2)
                   if (NOT fac.is_zero) then
                     .special_ket(k)[1]=bj1
                     res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
                   end
                 end
               end
               .special_ket(k)[1]=bk1
               .special_ket(k)[2]=bk2
             else !k not special
               temp_ket_k => .ket(k)[:,:]
               .special_ket(k)[2]=b3
               .special_ket(q)[2]=b4
               do bj1 = 1,.n_bf
                 .special_ket(k)[1]=bj1
                 do bk1 = 1,.n_bf
                   fac = temp_ket_j(bj1,b1)*temp_ket_k(bk1,b2)-temp_ket_j(bj1,b2)*temp_ket_k(bk1,b1)
                   if (NOT fac.is_zero) then
                     .special_ket(q)[1]=bk1
                     res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   end 
                 end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end !k special
           end ! do kk 
         end !j special
       end ! do jj 
       .special_ket(q)[1]=b3
       .special_ket(q)[2]=b4
       reorder_ket.destroy
     end !dim>1
   end

   special_overlap_spin_aa_for(order_bra,order_ket,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals between
   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
   ! special bra which are (Sz=1)-geminals.
!comments: should not be called if dim=1 because row_ind and col_ind would
! be already defined.
     b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(1)[2]==0,"special ket already set for contraction 1")
     ENSURE(.special_ket(order_ket.dim)[2]>0,"no special ket matching special bra")
     row_ind,col_ind,ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,b3,b4 :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*

     dim = order_ket.dim
     res = ZERO
      
     ! test for identical spinorbitals
     i = order_ket(dim)
     b3 = .special_ket(i)[1]
     b4 = .special_ket(i)[2]
     if (b3==b4 OR b1==b2 ) return

     ! Case 1 
     if (b3==b1 AND b4==b2 ) then
       reorder_ket.create(dim-1)
       reorder_ket(1:dim-1)   = [ (order_ket(j), j=1,dim-1) ]
       res = res + .overlap_for(reorder_ket)  ! <<
        reorder_ket.destroy
     end
     if (b3==b2 AND b4==b1 ) then
       reorder_ket.create(dim-1)
       reorder_ket(1:dim-1)   = [ (order_ket(j), j=1,dim-1) ]
       res = res - .overlap_for(reorder_ket)  ! <<
       reorder_ket.destroy
     end
     ! this loop does something only if dim > 1
     do ii = dim-1,1,-1
        i = order_ket(ii)
        if(i==1) then
          do col_ind=1,.n_bas
            ! Case 2
            if (b4==b2 ) then
              do bi2=1,.n_bf
                fac = - .contraction_wfs(col_ind)[b1,bi2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = 1
                  .special_ket(1)[1] = b3 
                  .special_ket(1)[2] = bi2 
                  res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                  .special_ket(1)[1] = 0
                  .special_ket(1)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
            if (b4==b1 ) then
              do bi2=1,.n_bf
                fac =  .contraction_wfs(col_ind)[b2,bi2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = 1
                  .special_ket(1)[1] = b3 
                  .special_ket(1)[2] = bi2 
                  res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                  .special_ket(1)[1] = 0
                  .special_ket(1)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
            if (b3==b2 ) then
              do bi2=1,.n_bf
                fac =  .contraction_wfs(col_ind)[b1,bi2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = 1
                  .special_ket(1)[1] = b4 
                  .special_ket(1)[2] = bi2 
                  res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                  .special_ket(1)[1] = 0
                  .special_ket(1)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
            if (b3==b1 ) then
              do bi2=1,.n_bf
                fac = - .contraction_wfs(col_ind)[b2,bi2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = 1
                  .special_ket(1)[1] = b4 
                  .special_ket(1)[2] = bi2 
                  res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind)*fac  ! <<
                  .special_ket(1)[1] = 0
                  .special_ket(1)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
            ! Case 3
            ! only do something if dim>2
            do jj = dim-1,ii+1,-1
              j = order_ket(jj)
              if (.special_ket(j)[1]>0) then
              ! Case 3, only j special
                bj1 = .special_ket(j)[1]
                if (bj1==b2) then
              !   bj2 = .special_ket(j)[2]
                  do bi2 = 1,.n_bf
                    fac = .contraction_wfs(col_ind)[b1,bi2]
                    if (NOT fac.is_zero ) then
                      reorder_ket.create(dim-1)
                      reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                      reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                      reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                      reorder_ket(dim-2) = 1 
                      reorder_ket(dim-1) = j 
                      .special_ket(1)[1] = b3 
                      .special_ket(1)[2] = bi2 
                      .special_ket(j)[1] = b4
                  !   .special_ket(j)[2] = bj2 unchanged
                      res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3                .special_ket(j)[2] = bj2 unchanged
                      .special_ket(1)[1] = 0 
                      .special_ket(1)[2] = 0 
                      .special_ket(j)[1] = bj1
                      reorder_ket.destroy
                    end
                  end
                end
                if (bj1==b1) then
              !   bj2 = .special_ket(j)[2]
                  do bi2 = 1,.n_bf
                    fac = - .contraction_wfs(col_ind)[b2,bi2]
                    if (NOT fac.is_zero ) then
                      reorder_ket.create(dim-1)
                      reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                      reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                      reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                      reorder_ket(dim-2) = 1 
                      reorder_ket(dim-1) = j 
                      .special_ket(1)[1] = b3 
                      .special_ket(1)[2] = bi2 
                      .special_ket(j)[1] = b4
                  !   .special_ket(j)[2] = bj2 unchanged
                      res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3                .special_ket(j)[2] = bj2 unchanged
                      .special_ket(1)[1] = 0 
                      .special_ket(1)[2] = 0 
                      .special_ket(j)[1] = bj1
                      reorder_ket.destroy
                    end
                  end
                end
              else 
              !  Case 3, NONE SPECIAL
                do bi2 = 1,.n_bf
                do bj2 = 1,.n_bf
                  fac = .contraction_wfs(col_ind)[b1,bi2]*.ket(j)[b2,bj2]-.contraction_wfs(col_ind)[b2,bi2]*.ket(j)[b1,bj2]
                  if (NOT fac.is_zero ) then
                    reorder_ket.create(dim-1)
                    reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                    reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                    reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                    reorder_ket(dim-2) = 1 
                    reorder_ket(dim-1) = j 
                    .special_ket(1)[1] = b3 
                    .special_ket(1)[2] = bi2 
                    .special_ket(j)[1] = b4
                    .special_ket(j)[2] = bj2 
                    res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
                    .special_ket(1)[1] = 0 
                    .special_ket(1)[2] = 0 
                    .special_ket(j)[1] = 0
                    .special_ket(j)[2] = 0
                    reorder_ket.destroy
                  end
                end
                end
              end !if case 3
            end !do jj
          end !do col_ind
        else !if (i/=1)
          ! Case 2
          if (b4==b2 ) then
            if (.special_ket(i)[1]>0) then
              bi1 = .special_ket(i)[1]
              if (bi1==b1 ) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                reorder_ket(dim-1) = i
                .special_ket(i)[1] = b3 
              ! .special_ket(i)[2] = bi2 unchanged 
                res = res - .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[2] = bi2 unchanged 
                .special_ket(i)[1] = bi1 
                reorder_ket.destroy
              end
            else
              do bi2=1,.n_bf
                fac = - .ket(i)[b1,bi2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = i
                  .special_ket(i)[1] = b3 
                  .special_ket(i)[2] = bi2 
                  res = res + .overlap_for(reorder_ket)*fac  ! <<
                  .special_ket(i)[1] = 0
                  .special_ket(i)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
          end
          if (b4==b1 ) then
            if (.special_ket(i)[1]>0) then
              bi1 = .special_ket(i)[1]
              if (bi1==b2 ) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                reorder_ket(dim-1) = i
                .special_ket(i)[1] = b3 
              ! .special_ket(i)[2] = bi2 unchanged 
                res = res + .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[2] = bi2
                .special_ket(i)[1] = bi1
                reorder_ket.destroy
              end
            else
              do bi2=1,.n_bf
                fac =  .ket(i)[b2,bi2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = i
                  .special_ket(i)[1] = b3 
                  .special_ket(i)[2] = bi2 
                  res = res + .overlap_for(reorder_ket)*fac  ! <<
                  .special_ket(i)[1] = 0
                  .special_ket(i)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
          end
          if (b3==b2 ) then
            if (.special_ket(i)[1]>0) then
              bi1 = .special_ket(i)[1]
              if (bi1==b1 ) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                reorder_ket(dim-1) = i
                .special_ket(i)[1] = b4 
              ! .special_ket(i)[2] = bi2 unchanged 
                res = res + .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[2] = bi2
                .special_ket(i)[1] = bi1
                reorder_ket.destroy
              end
            else
              do bi2=1,.n_bf
                fac =  .ket(i)[b1,bi2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = i
                  .special_ket(i)[1] = b4 
                  .special_ket(i)[2] = bi2 
                  res = res + .overlap_for(reorder_ket)*fac  ! <<
                  .special_ket(i)[1] = 0
                  .special_ket(i)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
          end
          if (b3==b1 ) then
            if (.special_ket(i)[1]>0) then
              bi1 = .special_ket(i)[1]
              if (bi1==b2 ) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                reorder_ket(dim-1) = i
                .special_ket(i)[1] = b4 
              ! .special_ket(i)[2] = bi2 unchanged 
                res = res - .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[2] = bi2
                .special_ket(i)[1] = bi1
                reorder_ket.destroy
              end
            else
              do bi2=1,.n_bf
                fac = - .ket(i)[b2,bi2]
                if (NOT fac==ZERO ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
                  reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
                  reorder_ket(dim-1) = i
                  .special_ket(i)[1] = b4 
                  .special_ket(i)[2] = bi2 
                  res = res + .overlap_for(reorder_ket)*fac  ! <<
                  .special_ket(i)[1] = 0
                  .special_ket(i)[2] = 0
                  reorder_ket.destroy
                end
              end
            end
          end
          ! Case 3
          ! only do something if dim>2
          do jj = dim-1,ii+1,-1
            j = order_ket(jj)
            if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
            ! Case 3, i special, j special
              bi1 = .special_ket(i)[1]
            ! bi2 = .special_ket(i)[2] unchanged
              bj1 = .special_ket(j)[1]
            ! bj2 = .special_ket(j)[2] unchanged
              if (bi1==b1 AND bj1==b2) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                reorder_ket(dim-2) = i 
                reorder_ket(dim-1) = j 
                .special_ket(i)[1] = b3 
              ! .special_ket(i)[2] = bi2 unchanged 
                .special_ket(j)[1] = b4 
              ! .special_ket(j)[2] = bj2  unchanged
                res = res + .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[2] = bi2
                .special_ket(i)[1] = bi1 
                .special_ket(j)[1] = bj1
 !test3         .special_ket(j)[2] = bj2
                reorder_ket.destroy
              end
              if (bi1==b2 AND bj1==b1) then
                reorder_ket.create(dim-1)
                reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                reorder_ket(dim-2) = i 
                reorder_ket(dim-1) = j 
                .special_ket(i)[1] = b3 
              ! .special_ket(i)[2] = bi2 unchanged 
                .special_ket(j)[1] = b4 
              ! .special_ket(j)[2] = bj2  unchanged
                res = res - .overlap_for(reorder_ket)  ! <<
!test3          .special_ket(i)[2] = bi2
                .special_ket(i)[1] = bi1 
                .special_ket(j)[1] = bj1
!test3          .special_ket(j)[2] = bj2
                reorder_ket.destroy
              end
            else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
            ! Case 3, only j special
              bj1 = .special_ket(j)[1]
              if (bj1==b2) then
            !   bj2 = .special_ket(j)[2]
                do bi2 = 1,.n_bf
                  fac = .ket(i)[b1,bi2]
                  if (NOT fac.is_zero ) then
                    reorder_ket.create(dim-1)
                    reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                    reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                    reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                    reorder_ket(dim-2) = i 
                    reorder_ket(dim-1) = j 
                    .special_ket(i)[1] = b3 
                    .special_ket(i)[2] = bi2 
                    .special_ket(j)[1] = b4
                !   .special_ket(j)[2] = bj2 unchanged
                    res = res + .overlap_for(reorder_ket) * fac ! <<
!test3              .special_ket(j)[2] = bj2 unchanged
                    .special_ket(i)[1] = 0 
                    .special_ket(i)[2] = 0 
                    .special_ket(j)[1] = bj1
                    reorder_ket.destroy
                  end
                end
              end
              if (bj1==b1) then
            !   bj2 = .special_ket(j)[2]
                do bi2 = 1,.n_bf
                  fac = - .ket(i)[b2,bi2]
                  if (NOT fac.is_zero ) then
                    reorder_ket.create(dim-1)
                    reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                    reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                    reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                    reorder_ket(dim-2) = i 
                    reorder_ket(dim-1) = j 
                    .special_ket(i)[1] = b3 
                    .special_ket(i)[2] = bi2 
                    .special_ket(j)[1] = b4
                 !  .special_ket(j)[2] = bj2 unchanged
                    res = res + .overlap_for(reorder_ket) * fac ! <<
!test3              .special_ket(j)[2] = bj2 unchanged
                    .special_ket(i)[1] = 0 
                    .special_ket(i)[2] = 0 
                    .special_ket(j)[1] = bj1
                    reorder_ket.destroy
                  end
                end
              end
            else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
            !  Case 3, NONE SPECIAL
              do bi2 = 1,.n_bf
              do bj2 = 1,.n_bf
                fac = .ket(i)[b1,bi2]*.ket(j)[b2,bj2]-.ket(i)[b2,bi2]*.ket(j)[b1,bj2]
                if (NOT fac.is_zero ) then
                  reorder_ket.create(dim-1)
                  reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                  reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                  reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                  reorder_ket(dim-2) = i 
                  reorder_ket(dim-1) = j 
                  .special_ket(i)[1] = b3 
                  .special_ket(i)[2] = bi2 
                  .special_ket(j)[1] = b4
                  .special_ket(j)[2] = bj2 
                  res = res + .overlap_for(reorder_ket) * fac ! <<
                  .special_ket(i)[1] = 0 
                  .special_ket(i)[2] = 0 
                  .special_ket(j)[1] = 0
                  .special_ket(j)[2] = 0
                  reorder_ket.destroy
                end
              end
              end
            end
          end
        end
     end
   end

   special_overlap_spin_aa_for(order_bra,order_ket,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals column vector
   ! specified by col_ind between mean field (Sz=0)-geminals except 
   ! .special_ket(dim) and the corresponding special bra which are (Sz=1)-geminals.
!comments: should not be called if dim=1 because row_ind would be already defined.
     col_ind,b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: VEC{REAL}(.n_bas)
     ENSURE(order_ket.dim>1,"dimension less than two")
     ENSURE(.special_ket(order_ket.dim)[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     row_ind,ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,b3,b4 :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*

     dim = order_ket.dim
     res = ZERO
      
     ! test for identical spinorbitals
     i = order_ket(dim)
     b3 = .special_ket(i)[1]
     b4 = .special_ket(i)[2]
     if (b3==b4 OR b1==b2 ) return

     ! Case 1 
     if (b3==b1 AND b4==b2 ) then
       reorder_ket.create(dim-1)
       reorder_ket(1:dim-1)   = [ (order_ket(j), j=1,dim-1) ]
       res = res + .overlap_for(reorder_ket,col_ind)  ! <<
       reorder_ket.destroy
     end
     if (b3==b2 AND b4==b1 ) then
       reorder_ket.create(dim-1)
       reorder_ket(1:dim-1)   = [ (order_ket(j), j=1,dim-1) ]
       res = res - .overlap_for(reorder_ket,col_ind)  ! <<
       reorder_ket.destroy
     end
     ! this loop does something only if dim > 1
     do ii = dim-1,1,-1
       i = order_ket(ii)
       DIE_IF(i==1 AND .special_ket(1)[1]==0,"special ket not set for contraction 1")
       ! Case 2
       if (b4==b2 ) then
         if (.special_ket(i)[1]>0) then
           bi1 = .special_ket(i)[1]
           if (bi1==b1 ) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
             reorder_ket(dim-1) = i
             .special_ket(i)[1] = b3 
           ! .special_ket(i)[2] = bi2 unchanged 
             res = res - .overlap_for(reorder_ket,col_ind)  ! <<
!test3       .special_ket(i)[2] = bi2 unchanged 
             .special_ket(i)[1] = bi1 
             reorder_ket.destroy
           end
         else
           do bi2=1,.n_bf
             fac = - .ket(i)[b1,bi2]
             if (NOT fac==ZERO ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
               reorder_ket(dim-1) = i
               .special_ket(i)[1] = b3 
               .special_ket(i)[2] = bi2 
               res = res + .overlap_for(reorder_ket,col_ind)*fac  ! <<
               .special_ket(i)[1] = 0
               .special_ket(i)[2] = 0
               reorder_ket.destroy
             end
           end
         end
       end
       if (b4==b1 ) then
         if (.special_ket(i)[1]>0) then
           bi1 = .special_ket(i)[1]
           if (bi1==b2 ) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
             reorder_ket(dim-1) = i
             .special_ket(i)[1] = b3 
           ! .special_ket(i)[2] = bi2 unchanged 
             res = res + .overlap_for(reorder_ket,col_ind)  ! <<
!test3       .special_ket(i)[2] = bi2
             .special_ket(i)[1] = bi1
             reorder_ket.destroy
           end
         else
           do bi2=1,.n_bf
             fac =  .ket(i)[b2,bi2]
             if (NOT fac==ZERO ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
               reorder_ket(dim-1) = i
               .special_ket(i)[1] = b3 
               .special_ket(i)[2] = bi2 
               res = res + .overlap_for(reorder_ket,col_ind)*fac  ! <<
               .special_ket(i)[1] = 0
               .special_ket(i)[2] = 0
               reorder_ket.destroy
             end
           end
         end
       end
       if (b3==b2 ) then
         if (.special_ket(i)[1]>0) then
           bi1 = .special_ket(i)[1]
           if (bi1==b1 ) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
             reorder_ket(dim-1) = i
             .special_ket(i)[1] = b4 
           ! .special_ket(i)[2] = bi2 unchanged 
             res = res + .overlap_for(reorder_ket,col_ind)  ! <<
!test3       .special_ket(i)[2] = bi2
             .special_ket(i)[1] = bi1
             reorder_ket.destroy
           end
         else
           do bi2=1,.n_bf
             fac =  .ket(i)[b1,bi2]
             if (NOT fac==ZERO ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
               reorder_ket(dim-1) = i
               .special_ket(i)[1] = b4 
               .special_ket(i)[2] = bi2 
               res = res + .overlap_for(reorder_ket,col_ind)*fac  ! <<
               .special_ket(i)[1] = 0
               .special_ket(i)[2] = 0
               reorder_ket.destroy
             end
           end
         end
       end
       if (b3==b1 ) then
         if (.special_ket(i)[1]>0) then
           bi1 = .special_ket(i)[1]
           if (bi1==b2 ) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
             reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
             reorder_ket(dim-1) = i
             .special_ket(i)[1] = b4 
           ! .special_ket(i)[2] = bi2 unchanged 
             res = res - .overlap_for(reorder_ket,col_ind)  ! <<
!test3       .special_ket(i)[2] = bi2
             .special_ket(i)[1] = bi1
             reorder_ket.destroy
           end
         else
           do bi2=1,.n_bf
             fac = - .ket(i)[b2,bi2]
             if (NOT fac==ZERO ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-2) = [ (order_ket(j), j=ii+1,dim-1) ]
               reorder_ket(dim-1) = i
               .special_ket(i)[1] = b4 
               .special_ket(i)[2] = bi2 
               res = res + .overlap_for(reorder_ket,col_ind)*fac  ! <<
               .special_ket(i)[1] = 0
               .special_ket(i)[2] = 0
               reorder_ket.destroy
             end
           end
         end
       end
       ! Case 3
       ! only do something if dim>2
       do jj = dim-1,ii+1,-1
         j = order_ket(jj)
         if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
        !  Case 3, i special, j special
           bi1 = .special_ket(i)[1]
        !  bi2 = .special_ket(i)[2] unchanged
           bj1 = .special_ket(j)[1]
        !  bj2 = .special_ket(j)[2] unchanged
           if (bi1==b1 AND bj1==b2) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
             reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
             reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
             reorder_ket(dim-2) = i 
             reorder_ket(dim-1) = j 
             .special_ket(i)[1] = b3 
           ! .special_ket(i)[2] = bi2 unchanged 
             .special_ket(j)[1] = b4 
           ! .special_ket(j)[2] = bj2  unchanged
             res = res + .overlap_for(reorder_ket,col_ind)  ! <<
!test3       .special_ket(i)[2] = bi2
             .special_ket(i)[1] = bi1 
             .special_ket(j)[1] = bj1
!test3       .special_ket(j)[2] = bj2
             reorder_ket.destroy
           end
           if (bi1==b2 AND bj1==b1) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
             reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
             reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
             reorder_ket(dim-2) = i 
             reorder_ket(dim-1) = j 
             .special_ket(i)[1] = b3 
           ! .special_ket(i)[2] = bi2 unchanged 
             .special_ket(j)[1] = b4 
           ! .special_ket(j)[2] = bj2  unchanged
             res = res - .overlap_for(reorder_ket,col_ind)  ! <<
!test3       .special_ket(i)[2] = bi2
             .special_ket(i)[1] = bi1 
             .special_ket(j)[1] = bj1
!test3       .special_ket(j)[2] = bj2
             reorder_ket.destroy
           end
         else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
         ! Case 3, only j special
           bj1 = .special_ket(j)[1]
           if (bj1==b2) then
         !   bj2 = .special_ket(j)[2]
             do bi2 = 1,.n_bf
               fac = .ket(i)[b1,bi2]
               if (NOT fac.is_zero ) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                 reorder_ket(dim-2) = i 
                 reorder_ket(dim-1) = j 
                 .special_ket(i)[1] = b3 
                 .special_ket(i)[2] = bi2 
                 .special_ket(j)[1] = b4
             !   .special_ket(j)[2] = bj2 unchanged
                 res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3           .special_ket(j)[2] = bj2 unchanged
                 .special_ket(i)[1] = 0 
                 .special_ket(i)[2] = 0 
                 .special_ket(j)[1] = bj1
                 reorder_ket.destroy
               end
             end
           end
           if (bj1==b1) then
         !   bj2 = .special_ket(j)[2]
             do bi2 = 1,.n_bf
               fac = - .ket(i)[b2,bi2]
               if (NOT fac.is_zero ) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
                 reorder_ket(dim-2) = i 
                 reorder_ket(dim-1) = j 
                 .special_ket(i)[1] = b3 
                 .special_ket(i)[2] = bi2 
                 .special_ket(j)[1] = b4
              !  .special_ket(j)[2] = bj2 unchanged
                 res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3           .special_ket(j)[2] = bj2 unchanged
                 .special_ket(i)[1] = 0 
                 .special_ket(i)[2] = 0 
                 .special_ket(j)[1] = bj1
                 reorder_ket.destroy
               end
             end
           end
         else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
         !  Case 3, NONE SPECIAL
           do bi2 = 1,.n_bf
           do bj2 = 1,.n_bf
             fac = .ket(i)[b1,bi2]*.ket(j)[b2,bj2]-.ket(i)[b2,bi2]*.ket(j)[b1,bj2]
             if (NOT fac.is_zero ) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1) = [ (order_ket(k), k=1,ii-1) ]
               reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
               reorder_ket(jj-1:dim-3) = [ (order_ket(k), k=jj+1,dim-1) ]
               reorder_ket(dim-2) = i 
               reorder_ket(dim-1) = j 
               .special_ket(i)[1] = b3 
               .special_ket(i)[2] = bi2 
               .special_ket(j)[1] = b4
               .special_ket(j)[2] = bj2 
               res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
               .special_ket(i)[1] = 0 
               .special_ket(i)[2] = 0 
               .special_ket(j)[1] = 0
               .special_ket(j)[2] = 0
               reorder_ket.destroy
             end
           end
           end
         end !if case 3
       end !do jj
     end !do ii
   end

   special_overlap_spin_aa_for(order_bra,order_ket,row_ind,col_ind,b1,b2) result (res)
   ! Special function which evaluates the overlap integrals between
   ! mean field (Sz=0)-geminals except .special_ket(dim) and the corresponding
   ! special bra which are (Sz=-1)-geminals.
     row_ind,col_ind,b1,b2 :: INT
     order_bra, order_ket :: VEC{INT}
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(.special_ket(order_ket(order_ket.dim))[2]>0,"no special ket matching special bra")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     dim,b3,b4,q,jj,bj1,bj2,j,kk,bk1,bk2,k,i :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*

     dim = order_ket.dim
     q=order_ket(dim)
     res = ZERO
      
!     if(.special_ket(order_ket.dim)[2]==0)then
!       write(*,*) "no special ket matching special bra"
!     stdout.show("dim=",dim)
!     do i=1,dim
!       stdout.show("i=",i)
!       stdout.show("order_ket(i)=",order_ket(i))
!       stdout.show("special_ket(order_ket(i))-in",.special_ket(order_ket(i)).element)
!     end
!     stop
!     end
     ! test for identical spinorbitals
     b3 = .special_ket(q)[1]
     b4 = .special_ket(q)[2]
     if (b3==b4 OR b1==b2 ) return
      
     if(dim==1) then ! only Case 0
       if (b3==b1 AND b4==b2 ) res = ONE
       if (b3==b2 AND b4==b1 ) res = -ONE
       return
     else !dim>1
       reorder_ket.create(dim-1)
! Case 0
       reorder_ket(1:dim-1)   = [ (order_ket(i), i=1,dim-1) ]
       if (b3==b1 AND b4==b2 ) then
         res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
       else if (b3==b2 AND b4==b1 ) then
         res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)
       end
       do jj = dim-1,1,-1
         reorder_ket(1:jj-1)   = [ (order_ket(i), i=1,jj-1) ]
         reorder_ket(jj:dim-1) = [ (order_ket(i), i=jj+1,dim) ] !reorder(dim-1)=q
         j = order_ket(jj)
         if (.special_ket(j)[1]>0) then  !j special
           DIE_IF(j==1,"1 special") 
           bj1 = .special_ket(j)[1]
           bj2 = .special_ket(j)[2]
! The simple case 1
           if (bj1==b1 AND b4==b2 ) then
             .special_ket(q)[1]=b3
             .special_ket(q)[2]=bj2
             res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj1==b2 AND b4==b1 ) then        
             .special_ket(q)[1]=b3
             .special_ket(q)[2]=bj2
             res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj1==b1 AND b3==b2 ) then        
             .special_ket(q)[1]=b4
             .special_ket(q)[2]=bj2
             res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           else if (bj1==b2 AND b3==b1 ) then        
             .special_ket(q)[1]=b4
             .special_ket(q)[2]=bj2
             res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             DIE_IF(.special_ket(k)[1]==0,"j special but not k") 
             bk1 = .special_ket(k)[1]
             bk2 = .special_ket(k)[2]
             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = [ (order_ket(i), i=jj+1,kk-1) ]
             reorder_ket(kk-1:dim-3) = [ (order_ket(i), i=kk+1,dim-1) ]
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (bj1==b1 AND bk1==b2 ) then
               .special_ket(k)[1]=b3
               .special_ket(k)[2]=bj2
               .special_ket(q)[1]=b4
               .special_ket(q)[2]=bk2
               res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
             else if (bj1==b2 AND bk1==b1 ) then
               .special_ket(k)[1]=b3
               .special_ket(k)[2]=bj2
               .special_ket(q)[1]=b4
               .special_ket(q)[2]=bk2
               res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind) 
             end
             .special_ket(k)[1]=bk1
             .special_ket(k)[2]=bk2
           end ! do kk 
         else !j not special  
           if(j==1)then
             temp_ket_j => .contraction_wfs(col_ind)[:,:]
           else
             temp_ket_j => .ket(j)[:,:]
           end
           if (b4==b2 ) then
             do bj2=1,.n_bf
               fac = temp_ket_j(b1,bj2)
               if (NOT fac.is_zero) then
                 .special_ket(q)[1]=b3
                 .special_ket(q)[2]=bj2
                 res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac
               end
             end
           else if (b4==b1 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b2,bj2)
               if (NOT fac.is_zero) then
                 .special_ket(q)[1]=b3
                 .special_ket(q)[2]=bj2
                 res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           end
           if (b3==b2 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b1,bj2)
               if (NOT fac.is_zero) then
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bj2
                 res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           else if (b3==b1 ) then        
             do bj2=1,.n_bf
               fac = temp_ket_j(b2,bj2)
               if (NOT fac.is_zero) then
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bj2
                 res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
               end
             end
           end
! Case 2
           do kk = dim-1,jj+1,-1
             k = order_ket(kk)
             reorder_ket(1:jj-1) = [ (order_ket(i), i=1,jj-1) ]
             reorder_ket(jj:kk-2) = [ (order_ket(i), i=jj+1,kk-1) ]
             reorder_ket(kk-1:dim-3) = [ (order_ket(i), i=kk+1,dim-1) ]
             reorder_ket(dim-2) = k 
             reorder_ket(dim-1) = q 
             if (.special_ket(k)[1]==0) then ! Case 2, k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if (bk1==b2 ) then
                 .special_ket(k)[1]=b3
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bk2
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b1,bj2)
                   if (NOT fac.is_zero) then
                     .special_ket(k)[2]=bj2
                     res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
                   end
                 end
               else if (bk1==b1 ) then
                 .special_ket(k)[1]=b3
                 .special_ket(q)[1]=b4
                 .special_ket(q)[2]=bk2
                 do bj2=1,.n_bf
                   fac = temp_ket_j(b2,bj2)
                   if (NOT fac.is_zero) then
                     .special_ket(k)[2]=bj2
                     res = res - .overlap_for(order_bra,reorder_ket,row_ind,col_ind)*fac 
                   end
                 end
               end
               .special_ket(k)[1]=bk1
               .special_ket(k)[2]=bk2
             else !k not special
               temp_ket_k => .ket(k)[:,:]
               .special_ket(k)[1]=b3
               .special_ket(q)[1]=b4
               do bj2 = 1,.n_bf
                 .special_ket(k)[2]=bj2
                 do bk2 = 1,.n_bf
                   fac = temp_ket_j(b1,bj2)*temp_ket_k(b2,bk2)-temp_ket_j(b2,bj2)*temp_ket_k(b1,bk2)
                   if (NOT fac.is_zero) then
                     .special_ket(q)[2]=bk2
                     res = res + .overlap_for(order_bra,reorder_ket,row_ind,col_ind) * fac ! <<
                   end 
                 end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end !k special
           end ! do kk 
         end !j special
       end ! do jj 
       .special_ket(q)[1]=b3
       .special_ket(q)[2]=b4
       reorder_ket.destroy
     end !dim>1
   end

   do_overlap
   ! Evaluate the 2 electron overlap integrals in a geminal induced basis set
   ! built over orthonormal orbitals and print the result
      res :: MAT{REAL}(.n_bas,.n_bas)
   !debug   write(*,*) ".n_bas",.n_bas,".n_bf",.n_bf
      res = .overlap
      stdout.text("The overlap matrix is ")
      stdout.put(res)
   end

   overlap result (res)
   ! Evaluate the overlap integrals
     res :: MAT{REAL}(.n_bas,.n_bas)
     ENSURE(.bra.dim==.ket.dim,"Bra and ket have different sizes!")
     i,row_ind,col_ind :: INT
     reorder_ket :: VEC{INT}*
      !reorder_ket.create(2)
      !reorder_ket(1)=1
      !reorder_ket(2)=2
      ! res(1,1) = .overlap_for(reorder_ket,1,1)
      !stdout.show("1,1",res(1,1))
     reorder_ket.create(.n_geminals)
     reorder_ket = [ (i, i=1,.n_geminals) ]
      !.special_ket(.n_geminals)[1]=5
      !.special_ket(.n_geminals)[2]=5
      res = .overlap_for(reorder_ket)
     !res = .special_overlap_spin_aa_for(reorder_ket,5,6)
     !do col_ind=1,.n_bas
     !do row_ind=1,col_ind-1
     !  res(col_ind,row_ind)=res(row_ind,col_ind)
     !end
     !end
      !res = (res + transpose(res))/TWO 
      !stdout.show("overlap is the unit matrix:",res.is_unit_matrix)
      !stdout.show("overlap bb55 is the unit matrix:",res.is_unit_matrix)
      !stdout.show("1,1",res(1,1))
      !stdout.show("1,2",res(1,2))
      !stdout.show("2,1",res(2,1))
      !stdout.show("2,2",res(2,2))
   !   .special_ket(.n_geminals)[1]=5
   !   .special_ket(.n_geminals)[2]=5
   !   res = .special_overlap_spin_ab_for(reorder_ket,row_ind,col_ind,5,5)
   !   stdout.show("overlap ab55 is the unit matrix:",res.is_unit_matrix)
   !  reorder_ket = [ (i, i=1,.n_geminals) ]
   !   .special_ket(.n_geminals)[1]=5
   !   .special_ket(.n_geminals)[2]=6
   !   res = .special_overlap_spin_aa_for(reorder_ket,row_ind,col_ind,5,6)
   !   stdout.show("overlap aa56 is the unit matrix:",res.is_unit_matrix)
     reorder_ket.destroy
   end

   overlap_for(order_ket) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix between
   ! mean field (Sz=0)-geminals (upper triangle only is evaluated)
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     order_ket :: VEC{INT}
     res :: MAT{REAL}(.n_bas,.n_bas)

     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(.special_ket(1)[1]==0,".special_ket(1) already set")
      
     ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,row_ind,col_ind :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*
     dim = order_ket.dim

     res = ZERO
      
     if (dim==1) then
       ! case 1
       i = order_ket(1)
       if (i/=1 ) DIE("dim=1 and i/=1")
       do  col_ind=1,.n_bas
         do row_ind=1,col_ind 
           fac = sum(.contraction_wfs(row_ind)[:,:]*.contraction_wfs(col_ind)[:,:])
           if (NOT fac.is_zero) then
             res(row_ind,col_ind) = fac
           end
         end
       end
       return
        ! no Case 2 when dim =1
     else
     ! dim > 1
       do ii = dim,1,-1
         i = order_ket(ii)
         if (i==1) then
           do  col_ind=1,.n_bas
           ! Case 1
             fac = sum(.bra(dim)[:,:]*.contraction_wfs(col_ind)[:,:])
             if (NOT fac.is_zero) then
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(j), j=1,ii-1) ]
               reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
               res(:,col_ind) = res(:,col_ind) + .overlap_for(reorder_ket,col_ind) * fac ! <<
               reorder_ket.destroy
             end
          ! Case 2
             do jj = dim,ii+1,-1
               j = order_ket(jj)
               if (.special_ket(j)[1]>0) then
               ! Case 2, only j special
                 bj1 = .special_ket(j)[1]
                 bj2 = .special_ket(j)[2]
                 do bi2 = 1,.n_bf
                   fac = ZERO
                   if (bi2==bj2) then
                     do bi1 = 1,bj1-1
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                     do bi1 = bj1+1,.n_bf
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                     fac = fac+ TWO*.contraction_wfs(col_ind)[bj1,bi2]*.bra(dim)[bj1,bj2]
                   else
                     do bi1 = 1,.n_bf
                       fac = fac+ .contraction_wfs(col_ind)[bi1,bi2]*.bra(dim)[bi1,bj2]
                     end
                   end
                   if (NOT fac.is_zero) then
                     reorder_ket.create(dim-1)
                     reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                     reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                     reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                     reorder_ket(dim-1) = j 
                  !  .special_ket(j)[1] = bj1 
                     .special_ket(j)[2] = bi2 
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3       .special_ket(j)[1] = 0 ! j=reorder_ket(dim-1)
!test3       .special_ket(j)[2] = 0 ! j=reorder_ket(dim-1)
! seems safer to put back the value bj1 and bj2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                     .special_ket(j)[2] = bj2
                     reorder_ket.destroy
                   end
                 end
               else 
               !  Case 2, NONE SPECIAL
                 do bi2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = ZERO
                   do bi1 = 1,.n_bf
                   do bj2 = 1,.n_bf
                     fac = fac + (.contraction_wfs(col_ind)[bi1,bi2]*.ket(j)[bj1,bj2] +  &
                            .contraction_wfs(col_ind)[bj1,bj2]*.ket(j)[bi1,bi2])* .bra(dim)[bi1,bj2]
                   end
                   end
                   if (NOT fac.is_zero) then
                     reorder_ket.create(dim-1)
                     reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                     reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                     reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                     reorder_ket(dim-1) = j 
                     .special_ket(j)[1] = bj1 
                     .special_ket(j)[2] = bi2
                     res(:,col_ind) = res(:,col_ind) - .overlap_for(reorder_ket,col_ind) * fac ! <<
                     .special_ket(j)[1] = 0 
                     .special_ket(j)[2] = 0
                     reorder_ket.destroy
                   end
                 end
                 end
               end
             end
           end
         else !i>1
           ! case 1
           if (.special_ket(i)[1]>0) then
             bi1 = .special_ket(i)[1]
             bi2 = .special_ket(i)[2]
             fac = .bra(dim)[bi1,bi2]
           else
             fac = sum(.bra(dim)[:,:]*.ket(i)[:,:])
           end
           if (NOT fac.is_zero) then
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
             reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
             res = res + .overlap_for(reorder_ket) * fac ! <<
             reorder_ket.destroy
           end
           ! Case 2
           do jj = dim,ii+1,-1
             j = order_ket(jj)
!test2 it is enough to have only   if (.special_ket(i)[1]>0 ) then
! however safer to have full test, specially if we generalise the routine
! in the future
             if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
             !  Case 2, i special, j special
               bi1 = .special_ket(i)[1]
               bi2 = .special_ket(i)[2]
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               fac = .bra(dim)[bi1,bj2]
               if (bi1==bj1 AND bi2==bj2)  fac=TWO * fac
               reorder_ket.create(dim-1)
               reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
               reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
               reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
               reorder_ket(dim-1) = i 
               .special_ket(i)[1] = bj1 ! i=reorder_ket(dim-1)
             ! .special_ket(i)[2] = bi2 
               res = res - .overlap_for(reorder_ket) * fac ! <<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
               .special_ket(i)[1] = bi1
               reorder_ket.destroy
!test2 it is enough to have only  else if (.special_ket(j)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
             ! Case 2, only j special
               bj1 = .special_ket(j)[1]
               bj2 = .special_ket(j)[2]
               do bi2 = 1,.n_bf
                 fac = ZERO
                 if (bi2==bj2) then
                   do bi1 = 1,bj1-1
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   do bi1 = bj1+1,.n_bf
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                   fac = fac+ TWO*.ket(i)[bj1,bi2]*.bra(dim)[bj1,bj2]
                 else
                   do bi1 = 1,.n_bf
                     fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                   end
                 end
                 if (NOT fac.is_zero) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                   reorder_ket(dim-1) = j 
               !   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                   res = res - .overlap_for(reorder_ket) * fac ! <<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                   .special_ket(j)[2] = bj2
                   reorder_ket.destroy
                 end
               end
!test2 it is enough to have only  else 
! however safer to have full test, specially if we generalise the routine
! in the future
             else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
             !  Case 2, NONE SPECIAL
               do bi2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = ZERO
                 do bi1 = 1,.n_bf
                 do bj2 = 1,.n_bf
                   fac = fac + (.ket(i)[bi1,bi2]*.ket(j)[bj1,bj2]+.ket(i)[bj1,bj2]*.ket(j)[bi1,bi2])*.bra(dim)[bi1,bj2]
                 end
                 end
                 if (NOT fac.is_zero) then
                   reorder_ket.create(dim-1)
                   reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                   reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                   reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                   reorder_ket(dim-1) = j 
                   .special_ket(j)[1] = bj1 
                   .special_ket(j)[2] = bi2
                   res = res - .overlap_for(reorder_ket) * fac ! <<
                   .special_ket(j)[1] = 0 
                   .special_ket(j)[2] = 0 
                   reorder_ket.destroy
                 end 
               end
               end
!test2 next 3 lines not needed
! however safer to have full test, specially if we generalise the routine
! in the future
             else 
               DIE("i special ket but not j !")
             end
           end  ! for do jj=dim,ii+1,-1
         end ! end for the if(i==1) else
       end  ! for do ii=dim,1,-1
     end ! for if(dim==1)
   end

   overlap_for(order_ket,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals column
   ! vector specified by col_ind between mean field (Sz=0)-geminals 
   ! upper half only is evaluated.
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     col_ind :: INT
     order_ket :: VEC{INT}
     res :: VEC{REAL}(.n_bas)
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ii,jj,i,j,k,dim, bi1,bi2,bj1,bj2,row_ind :: INT
     fac :: REAL
     reorder_ket :: VEC{INT}*

     dim = order_ket.dim
     res = ZERO
      
     if (dim==1) then
       ! case 1
       i = order_ket(1)
       DIE_IF(i==1 AND .special_ket(1)[1]==0,"dim=1, i=1 but .special_ket(1) not set!") 
       do row_ind=1,col_ind
         if (.special_ket(i)[1]>0) then             
           bi1 = .special_ket(i)[1]                 
           bi2 = .special_ket(i)[2]                
           fac = .contraction_wfs(row_ind)[bi1,bi2]
         else
           fac = sum(.contraction_wfs(row_ind)[:,:]*.ket(i)[:,:])
         end
         if (NOT fac.is_zero) then
           res(row_ind) = fac
         end
       end
       return
       ! no Case 2 when dim =1
     else
     ! dim > 1
       do ii = dim,1,-1
         i = order_ket(ii)
         DIE_IF(i==1 AND .special_ket(1)[1]==0,"i=1 but .special_ket(1) not set!") 
         ! case 1
         if (.special_ket(i)[1]>0) then
            bi1 = .special_ket(i)[1]
            bi2 = .special_ket(i)[2]
            fac = .bra(dim)[bi1,bi2]
         else
            fac = sum(.bra(dim)[:,:]*.ket(i)[:,:])
         end
         if (NOT fac.is_zero) then
           reorder_ket.create(dim-1)
           reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
           reorder_ket(ii:dim-1) = [ (order_ket(j), j=ii+1,dim) ]
           res = res + .overlap_for(reorder_ket,col_ind) * fac ! <<
           reorder_ket.destroy
         end
         ! Case 2
         do jj = dim,ii+1,-1
           j = order_ket(jj)
!test2 it is enough to have only   if (.special_ket(i)[1]>0 ) then
! however safer to have full test, specially if we generalise the routine
! in the future
           if (.special_ket(i)[1]>0 AND .special_ket(j)[1]>0) then
           !  Case 2, i special, j special
             bi1 = .special_ket(i)[1]
             bi2 = .special_ket(i)[2]
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             fac = .bra(dim)[bi1,bj2]
             if (bi1==bj1 AND bi2==bj2)  fac=TWO * fac
             reorder_ket.create(dim-1)
             reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
             reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
             reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
             reorder_ket(dim-1) = i 
             .special_ket(i)[1] = bj1 ! i=reorder_ket(dim-1)
           ! .special_ket(i)[2] = bi2 
             res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3  seems safer to put back the value bi1 and bi2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
             .special_ket(i)[1] = bi1
             reorder_ket.destroy
!test2 it is enough to have only  else if (.special_ket(j)[1]>0) then
! however safer to have full test, specially if we generalise the routine
! in the future
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]>0) then
           ! Case 2, only j special
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
             do bi2 = 1,.n_bf
               fac = ZERO
               if (bi2==bj2) then
                 do bi1 = 1,bj1-1
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
                 do bi1 = bj1+1,.n_bf
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
                 fac = fac+ TWO*.ket(i)[bj1,bi2]*.bra(dim)[bj1,bj2]
               else
                 do bi1 = 1,.n_bf
                   fac = fac+ .ket(i)[bi1,bi2]*.bra(dim)[bi1,bj2]
                 end
               end
               if (NOT fac.is_zero) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                 reorder_ket(dim-1) = j 
             !   .special_ket(j)[1] = bj1 
                 .special_ket(j)[2] = bi2 ! j=reorder_ket(dim-1)
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
!test3  seems safer to put back the value bj1 and bj2, works nevertheless for any value
! because .special_ket(j) is not reused in the loop
                 .special_ket(j)[2] = bj2
                 reorder_ket.destroy
               end
             end
!test2 it is enough to have only  else 
! however safer to have full test, specially if we generalise the routine
! in the future
           else if (.special_ket(i)[1]==0 AND .special_ket(j)[1]==0) then
           !  Case 2, NONE SPECIAL
             do bi2 = 1,.n_bf
             do bj1 = 1,.n_bf
               fac = ZERO
               do bi1 = 1,.n_bf
               do bj2 = 1,.n_bf
                 fac = fac + (.ket(i)[bi1,bi2]*.ket(j)[bj1,bj2]+.ket(i)[bj1,bj2]*.ket(j)[bi1,bi2])*.bra(dim)[bi1,bj2]
               end
               end
               if (NOT fac.is_zero) then
                 reorder_ket.create(dim-1)
                 reorder_ket(1:ii-1)   = [ (order_ket(k), k=1,ii-1) ]
                 reorder_ket(ii:jj-2) = [ (order_ket(k), k=ii+1,jj-1) ]
                 reorder_ket(jj-1:dim-2) = [ (order_ket(k), k=jj+1,dim) ]
                 reorder_ket(dim-1) = j 
                 .special_ket(j)[1] = bj1 
                 .special_ket(j)[2] = bi2
                 res = res - .overlap_for(reorder_ket,col_ind) * fac ! <<
                 .special_ket(j)[1] = 0 
                 .special_ket(j)[2] = 0 
                 reorder_ket.destroy
               end 
             end
             end
!test2 next 3 lines not needed
! however safer to have full test, specially if we generalise the routine
! in the future
           else 
             DIE("i special ket but not j !")
           end
         end  ! for do jj=dim,ii+1,-1
       end  ! for do ii=dim,1,-1
     end ! for if(dim==1)
   end

   overlap_for(order_ket,row_ind,col_ind) result (res) ::: recursive
   ! Standard recursive function which evaluates the overlap integrals matrix
   ! element specified by col_ind and row_ind between mean field (Sz=0)-geminals 
!comments:
!special_ket are always created at the end so that if ii is a special ket,
!than jj>ii is also a special ket. This allows some simplifications but may be a
!bit limitative in the future.
     row_ind, col_ind :: INT
     order_ket :: VEC{INT}
     res :: REAL
     ENSURE(.special_ket(1)[1]==0,"1 special")
     ENSURE(order_ket.dim>0,"dim negative or zero")
     ENSURE(col_ind>0 AND col_ind<=.n_bas,"col_ind out of range")
     ENSURE(row_ind>0 AND row_ind<=.n_bas,"row_ind out of range")
     jj,j,kk,k,dim,l,bq1,bq2,bj1,bj2,bk1,bk2 :: INT
     reorder_ket :: VEC{INT}*
     fac :: REAL
     temp_bra_q :: MAT{REAL}*
     temp_ket_j :: MAT{REAL}*
     temp_ket_k :: MAT{REAL}*
     temp_qa_ja :: MAT{REAL}*
     temp_qb_jb :: MAT{REAL}*

     dim = order_ket.dim
     res = ZERO

     if (dim==1) then ! Only Case 1
       j = order_ket(1)
       if (.special_ket(j)[1]>0) then             
         bj1 = .special_ket(j)[1]                 
         bj2 = .special_ket(j)[2]                
         fac = .contraction_wfs(row_ind)[bj1,bj2]
       else if(.special_ket(j)[1]==0 AND j==1) then
         fac = sum(.contraction_wfs(row_ind)[:,:]*.contraction_wfs(col_ind)[:,:])
       else if (.special_ket(j)[1]==0 AND j/=1) then
         fac = sum(.contraction_wfs(row_ind)[:,:]*.ket(j)[:,:])
       end
       if (NOT fac.is_zero) then
          res = fac
       end
       return
     else ! dim > 1
       temp_bra_q => .bra(dim)[:,:]
       reorder_ket.create(dim-1)
       temp_qa_ja.create(.n_bf,.n_bf)
       temp_qb_jb.create(.n_bf,.n_bf)
       do jj = dim,1,-1
         j = order_ket(jj)
         if (j==1 AND .special_ket(1)[1]==0) then ! 1 not special
           temp_ket_j => .contraction_wfs(col_ind)[:,:]
           do bj1=1,.n_bf
           do bq1=1,.n_bf
             temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
             temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
           end
           end
! Case 2
           do kk = dim,jj+1,-1
             k = order_ket(kk)
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:kk-2) = [ (order_ket(l), l=jj+1,kk-1) ]
             reorder_ket(kk-1:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
             reorder_ket(dim-1) = k 
             if (.special_ket(k)[1]>0) then ! k special
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               do bj1 = 1,bk1-1
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj1 = bk1+1,.n_bf
                 fac=temp_qb_jb(bk1,bj1)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[2] = bk2
                   .special_ket(k)[1] = bj1
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
               end
               do bj2 = 1,bk2-1
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               do bj2 = bk2+1,.n_bf
                 fac=temp_qa_ja(bk2,bj2)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               end
               fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
               if (NOT fac.is_zero) then
               ! .special_ket(k)[1] = bk1
               ! .special_ket(k)[2] = bk2
                 res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
               end
             else ! k not special
               temp_ket_k => .ket(k)[:,:]
               do bk2 = 1,.n_bf
               do bj1 = 1,.n_bf
                 fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                 if (NOT fac.is_zero) then
                   .special_ket(k)[1] = bj1 
                   .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               end
               end
               .special_ket(k)[1] = 0 
               .special_ket(k)[2] = 0
             end  ! if (.special_ket(k)
           end !do kk
! Case 1
           reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
           reorder_ket(jj:dim-1) = [ (order_ket(l), l=jj+1,dim) ]
           fac = temp_qb_jb.trace
           if (NOT fac.is_zero) then
             res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
           end
         else ! j>1 or 1 special
           if (.special_ket(j)[1]>0) then
             bj1 = .special_ket(j)[1]
             bj2 = .special_ket(j)[2]
! Case 2
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               DIE_IF(.special_ket(k)[1]==0,"j special but not k")
!debug              if(.special_ket(k)[1]==0) then
!debug     write(*,*) "j special but not k"
!debug     stdout.show("dim=",dim)
!debug     do l=1,dim
!debug       stdout.show("l=",l)
!debug       stdout.show("order_ket(l)=",order_ket(l))
!debug       stdout.show("special_ket(order_ket(l))-in",.special_ket(order_ket(l)).element)
!debug     end
!debug     stop
!debug     end
!assume special_ket's are also ordered at the end in the initial guess
               reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
               reorder_ket(jj:kk-2) = [ (order_ket(l), l=jj+1,kk-1) ]
               reorder_ket(kk-1:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
               reorder_ket(dim-1) = k 
               bk1 = .special_ket(k)[1]
               bk2 = .special_ket(k)[2]
               if(bj1/=bk1 OR bj2/=bk2) then
                 fac=temp_bra_q(bk1,bj2)
                 if (NOT fac.is_zero) then
                   .special_ket(k)[1] = bj1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[1] = bk1
                 end
                 fac=temp_bra_q(bj1,bk2)
                 if (NOT fac.is_zero) then
                !  .special_ket(k)[1] = bk1
                   .special_ket(k)[2] = bj2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   .special_ket(k)[2] = bk2
                 end
               else ! bj1==bk1 AND bj2==bk2
                 fac=TWO * temp_bra_q(bk1,bk2)
                 if (NOT fac.is_zero) then
                !  .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               end ! bj1==bk1 AND bj2==bk2
             end !do kk
! Case 1
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = [ (order_ket(l), l=jj+1,dim) ]
             fac = temp_bra_q(bj1,bj2)
             if (NOT fac.is_zero) then
               res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
             end
           else !j not special
             temp_ket_j => .ket(j)[:,:]
             do bj1=1,.n_bf
             do bq1=1,.n_bf
               temp_qa_ja(bq1,bj1)=sum(temp_bra_q(:,bq1)*temp_ket_j(:,bj1))
               temp_qb_jb(bq1,bj1)=sum(temp_bra_q(bq1,:)*temp_ket_j(bj1,:))
             end
             end
! Case 2
             do kk = dim,jj+1,-1
               k = order_ket(kk)
               reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
               reorder_ket(jj:kk-2) = [ (order_ket(l), l=jj+1,kk-1) ]
               reorder_ket(kk-1:dim-2) = [ (order_ket(l), l=kk+1,dim) ]
               reorder_ket(dim-1) = k 
               if (.special_ket(k)[1]>0) then ! k special
                 bk1 = .special_ket(k)[1]
                 bk2 = .special_ket(k)[2]
                 do bj1 = 1,bk1-1
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj1 = bk1+1,.n_bf
                   fac=temp_qb_jb(bk1,bj1)
                   if (NOT fac.is_zero) then
                   ! .special_ket(k)[2] = bk2
                     .special_ket(k)[1] = bj1
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[1] = bk1
                   end
                 end
                 do bj2 = 1,bk2-1
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 do bj2 = bk2+1,.n_bf
                   fac=temp_qa_ja(bk2,bj2)
                   if (NOT fac.is_zero) then
                   ! .special_ket(k)[1] = bk1
                     .special_ket(k)[2] = bj2
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                     .special_ket(k)[2] = bk2
                   end
                 end
                 fac=temp_qb_jb(bk1,bk1)+temp_qa_ja(bk2,bk2)
                 if (NOT fac.is_zero) then
                 ! .special_ket(k)[1] = bk1
                 ! .special_ket(k)[2] = bk2
                   res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                 end
               else ! k not special
                 temp_ket_k => .ket(k)[:,:]
                 do bk2 = 1,.n_bf
                 do bj1 = 1,.n_bf
                   fac = sum(temp_qb_jb(:,bj1)*temp_ket_k(:,bk2))+sum(temp_qa_ja(:,bk2)*temp_ket_k(bj1,:))
                   if (NOT fac.is_zero) then
                     .special_ket(k)[1] = bj1 
                     .special_ket(k)[2] = bk2
                     res = res - .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
                   end
                 end
                 end
                 .special_ket(k)[1] = 0 
                 .special_ket(k)[2] = 0
               end  ! if (.special_ket(k)
             end !do kk
! Case 1
             reorder_ket(1:jj-1)   = [ (order_ket(l), l=1,jj-1) ]
             reorder_ket(jj:dim-1) = [ (order_ket(l), l=jj+1,dim) ]
             fac = temp_qb_jb.trace
             if (NOT fac.is_zero) then
               res = res + .overlap_for(reorder_ket,row_ind,col_ind) * fac ! <<
             end
           end !j not special
         end !if(j==1 AND .special_ket(1)==0) else
       end  !do jj=dim,1,-1
     temp_qa_ja.destroy
     temp_qb_jb.destroy
     reorder_ket.destroy
     end ! if(dim==1)
   end

!  **************
!  Output methods
!  **************

   put
   ! Print out the object
      i,j,k :: INT
      stdout.text("GEMINAL_MF_SPECTRUM:")
      stdout.flush
      stdout.show("n_geminals =",.n_geminals)
      stdout.show("n_bf       =",.n_bf)
      stdout.show("n_bas       =",.n_bas)
      stdout.flush
      stdout.text("Bra:")
      do i = 2,.n_geminals
         stdout.text("Bra "//i.to_str.trim//" non zero elements")
!         stdout.put(.bra(i).element)
! could use a while loop
        do j=1,.n_bf
        do k=1,.n_bf
          if (NOT .bra(i)[j,k].is_zero) then
            write(*,*)"j,k,element:",j,k,.bra(i)[j,k]
          end
        end
        end
      end
      stdout.text("Ket:")
      do i = 2,.n_geminals
         stdout.text("Special ket "//i.to_str.trim)
         stdout.put(.special_ket(i).element)
         stdout.text("Ket "//i.to_str.trim//" non zero elements")
!         stdout.put(.ket(i).element)
        do j=1,.n_bf
        do k=1,.n_bf
          if (NOT .ket(i)[j,k].is_zero) then
            write(*,*)"j,k,element:",j,k,.ket(i)[j,k]
          end
        end
        end
      end
      stdout.text("Contraction 1:")
      do i = 1,.n_bas
        stdout.text("Wave function "//i.to_str.trim//" non zero elements")
        do j=1,.n_bf
        do k=1,.n_bf
          if (NOT .contraction_wfs(i)[j,k].is_zero) then
            write(*,*)"j,k,element:",j,k,.contraction_wfs(i)[j,k]
        !    stdout.put(j,k,.contraction_wfs(i)[j,k])
        !    stdout.show("j,k,element:",j,k,.contraction_wfs(i)[j,k])
          end
        end
        end
      end
   end

end
