!-------------------------------------------------------------------------------
!
! ARCHIVE: For archiving tonto objects to disk
!
! A polymorphic file object which can store ascii or binary format.
! Archives with the string "ascii" somewhere in their name are assumed to be
! ascii files, otherwise they are binary files.
!
! An archive can't be used for input and output at the same time.
!
! Read and write routines are used to deal with entire single objects.
! The archive is closed after the requested IO operation.
!
! If the above behaviour is not what is needed, the archive can be opened
! for multiple object I/O in one archive (say, a list of integral blocks)
! and you can deal by hand with appropriate component of the archive.
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module ARCHIVE

   implicit none

contains

   create(root_name,name,genre,format)
   ! Create an archive object with main name "root_name" and sub name "name".
   ! "genre" is used to identify components of OPMATRIX and OPVECTOR objects.
   ! "format" is used to identify file format (e.g. ascii). The default is
   ! binary.
      self :: PTR
      root_name,name :: STR, optional
      genre,format :: STR, optional
      nullify(self)
      allocate(self)
      ADD_MEMORY(SELF_TYPE_SIZE)
      .nullify_ptr_part
      .set(root_name,name,genre,format)
   end

   copy(archive) ::: leaky
   ! Make a copy
     archive :: ARCHIVE
     self = archive
     .nullify_ptr_part
     if (archive.file.created) .file.create_copy(archive.file)
   end

   destroy
   ! Destroy an opmatrix object
      self :: PTR
      if ( .destroyed) return
      .destroy_ptr_part
      deallocate(self)
      DELETE_MEMORY(SELF_TYPE_SIZE)
   end

   nullify_ptr_part
   ! Nullify the pointer parts of the opmatrix object
      nullify(.file)
      nullify(.textfile)
   end

   destroy_ptr_part
   ! Destroy the pointer parts of the opmatrix object
      .file.destroy
      .textfile.destroy
   end

!   created result(res)
!   ! Returns true if self has been created
!      self :: PTR
!      res :: BIN
!      res = associated(self)
!   end

!   destroyed result(res)
!   ! Returns true if self has not been created
!      self :: PTR
!      res :: BIN
!      res = NOT associated(self)
!   end

   set_defaults
   ! Set up a default archive object
      .root_name = "unknown"
      .name      = "unknown"
      .genre      = " " ! generic genre
      .format    = " " ! assume binary format
   end

   set(root_name,name,genre,format)
   ! Reset an archive to have main name "root_name", sub name "name"
   ! "genre" (if present) is used to identify components of OPMATRIX and OPVECTOR
   ! objects.
   ! "format" (if present) is used to identify file format (e.g. ascii). The
   ! default is binary.
   ! Otherwise use defaults.
      root_name,name :: STR, optional
      genre,format :: STR, optional
      .set_defaults
      if (present(root_name)) .root_name = root_name
      if (present(name))      .name      = name
      if (present(genre))      .genre      = genre
      if (present(format))    .format    = format
   end

   set_root_name(root_name)
   ! Set an archive to have sub name "name".
      root_name :: STR
      .destroy_ptr_part
      .root_name = root_name
   end

   set_root(root_name)
   ! Set an archive to have sub name "name".
      root_name :: STR
      .destroy_ptr_part
      .root_name = root_name
   end

   set_name(name)
   ! Set an archive to have sub name "name".
      name :: STR
      .destroy_ptr_part
      .name = name
   end

   set_genre(genre)
   ! Set an archive to have genre "genre".
      genre :: STR
      .destroy_ptr_part
      .genre = genre
   end

   set_format(format)
   ! Set an archive to have format "format".
      format :: STR
      .destroy_ptr_part
      .format = format
   end

   file_name(genre) result(res)
   ! Return the archive file name from string ".root_name" by prepending the
   ! archive header ".name". If present "genre" is also appended. If present,
   ! ".format" is also appended.
      genre :: STR, optional
      res :: STR
      k :: STR
      res = trim(.root_name) // "." // .name
      k = .genre
      if (present(genre)) k = genre
      if (k/=" ")       res = trim(res) // "," // trim(k)
      if (.format/=" ") res = trim(res) // "," // .format
   end

   is_a_text_file result(res) ::: private
   ! Return true if the file is a text file
      res :: BIN
      res = .format.includes("ascii")
   end

   exists(genre) result(res)
   ! Return TRUE if the archive exists in some form on disk.
      genre :: STR, optional
      res :: BIN
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         res = .textfile.exists
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         res = .file.exists
         .file.destroy
      end
   end

   open(for,buffered,type,genre) ::: leaky
   ! Open archive file
      for :: STR
      type :: STR, optional
      buffered :: BIN, optional
      genre :: STR, optional
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         .textfile.open(for)
      else
         .file.create(trim(.file_name(genre)))
         .file.open(for,buffered,type)
      end
   end

   close ::: leaky
   ! Close *and* destroy the archive file part.
      if (.textfile.created) then
          .textfile.close
          .textfile.destroy
      end
      if (.file.created) then
          .file.close
          .file.destroy
      end
   end

   delete(genre)
   ! Delete archive file if it exists, *and* destroy the archive file part
      genre :: STR, optional
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         if (.textfile.exists) .textfile.delete
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         if (.file.exists) .file.delete
         .file.destroy
      end
   end

   delete_all_genres
   ! Delete all genres of archive file, if they exists.
      .delete
      .delete("restricted")
      .delete("unrestricted")
      .delete("alpha")
      .delete("beta")
      .delete("general")
      .delete("restricted_complex")
      .delete("unrestricted_complex")
      .delete("alpha_complex")
      .delete("beta_complex")
      .delete("general_complex")
      .delete("complex_restricted")
      .delete("complex_unrestricted")
      .delete("complex_alpha")
      .delete("complex_beta")
      .delete("complex_general")
   end

!  ************************************
!  Read routines: read an entire object
!  ************************************

   read(item,genre) ::: template
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         ENSURE(.textfile.exists,"no text archive "// trim(.name))
         .textfile.open(for="read")
         .textfile.read(item)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         ENSURE(.file.exists,"no binary archive "// trim(.name))
         .file.open(for="read-only",buffered=TRUE,type="int")
         .file.read(item)
         .file.close
         .file.destroy
      end
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>INT)
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>REAL)
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{REAL})
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{CPX})
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item,genre,order) ::: template
   ! Read a matrix "item" from the archive. If present, "order" is the input
   ! order for the matrix.
      item :: ITEM_TYPE
      genre,order :: STR, optional
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         ENSURE(.textfile.exists,"no text archive "// trim(.textfile.name))
         .textfile.open(for="read")
         .textfile.read(item,order)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         ENSURE(.file.exists,"no binary archive "// trim(.file.name))
         .file.open(for="read-only",buffered=TRUE,type="real")
         .file.read(item)
         .file.close
         .file.destroy
      end
   end

   read(item,genre,order) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{REAL})
   ! Read a matrix "item" from the archive. If present, "order" is the input
   ! order for the matrix.
      item :: ITEM_TYPE
      genre,order :: STR, optional
   end

   read(item,genre,order) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{CPX})
   ! Read a matrix "item" from the archive. If present, "order" is the input
   ! order for the matrix.
      item :: ITEM_TYPE
      genre,order :: STR, optional
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{REAL})
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{CPX})
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{REAL})
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{CPX})
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT5{CPX})
   ! Read from the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   read(item1,item2) ::: template
   ! Read from the archive, "item1" followed by "item2"
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name))
         ENSURE(.textfile.exists,"no text archive "// trim(.file_name))
         .textfile.open(for="read")
         .textfile.read(item1)
         .textfile.read(item2)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name))
         if (NOT .file.exists) &
            DIE("no binary archive "// trim(.file_name))
         .file.open(for="read-only",buffered=TRUE,type="real")
         .file.read(item1)
         .file.read(item2)
         .file.close
         .file.destroy
      end
   end

   read(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>VEC{REAL})
   ! Read from the archive, "item1" followed by "item2"
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
   end

   read(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>MAT{REAL})
   ! Read from the archive, "item1" followed by "item2"
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
   end

   read(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>VEC{REAL})
   ! Read from the archive, "item1" followed by "item2"
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
   end

   read(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>MAT{REAL})
   ! Read from the archive, "item1" followed by "item2"
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
   end

   read(item,genre) ::: leaky
   ! Read from the archive operator vector "item". If present, "genre" is the
   ! genre of "item" to be read in.
      item :: OPVECTOR
      genre :: STR, optional
      itemgenre :: STR
      if (present(genre) ) then;  itemgenre = genre
      else if (.genre/=" ") then; itemgenre = .genre
      else;                      itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted")
            item.destroy("restricted")
            item.create("restricted")
            .read( item.restricted,genre="restricted")
         case ("unrestricted")
            item.destroy("unrestricted")
            item.create("unrestricted")
            .read( item.alpha,genre="alpha")
            .read( item.beta,genre="beta")
         case ("alpha")
            item.destroy("alpha")
            item.create("alpha")
            .read( item.alpha,genre="alpha")
         case ("beta")
            item.destroy("beta")
            item.create("beta")
            .read( item.beta,genre="beta")
         case ("general")
            item.destroy("general")
            item.create("general")
            .read( item.general,genre="general")
         case default
            DIE("unknown genre, "//trim(itemgenre))
      end
!      if (.is_a_text_file) .write(item,itemgenre)
   end

   read(item,genre,order) ::: leaky
   ! Read from the archive operator matrix "item". If present, "genre" is the
   ! genre of "item" to be read in. "order" indicated the input order for ascii
   ! files.
      item :: OPMATRIX
      genre,order :: STR, optional
      itemgenre :: STR
      if (present(genre))   then; itemgenre = genre
      else if (.genre/=" ") then; itemgenre = .genre
      else;                      itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted")
            item.destroy("restricted")
            item.create("restricted")
            .read( item.restricted,"restricted",order)
         case ("unrestricted")
            item.destroy("unrestricted")
            item.create("unrestricted")
            .read( item.alpha,"alpha",order)
            .read( item.beta,"beta",order)
         case ("alpha")
            item.destroy("alpha")
            item.create("alpha")
            .read( item.alpha,"alpha",order)
         case ("beta")
            item.destroy("beta")
            item.create("beta")
            .read( item.beta,"beta",order)
         case ("general")
            item.destroy("general")
            item.create("general")
            .read( item.general,"general",order)
         case ("restricted_complex","complex_restricted")
            item.destroy("restricted_complex")
            item.create("restricted_complex")
            .read( item.restricted_complex,"restricted_complex",order)
         case ("unrestricted_complex","complex_unrestricted")
            item.destroy("unrestricted_complex")
            item.create("unrestricted_complex")
            .read( item.alpha_complex,"alpha_complex",order)
            .read( item.beta_complex,"beta_complex",order)
         case ("alpha_complex","complex_alpha")
            item.destroy("alpha_complex")
            item.create("alpha_complex")
            .read( item.alpha_complex,"alpha_complex",order)
         case ("beta_complex","complex_beta")
            item.destroy("beta_complex")
            item.create("beta_complex")
            .read( item.beta_complex,"beta_complex",order)
         case ("general_complex","complex_general")
            item.destroy("general_complex")
            item.create("general_complex")
            .read( item.general_complex,"general_complex",order)
         case default
            DIE("unknown genre, "//trim(itemgenre))
      end
!      if (.is_a_text_file) .write(item,genre,order)
   end

!  **************
!  Write routines
!  **************

   write(item,genre) ::: template
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         .textfile.open(for="write")
         .textfile.set_use_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.put(item)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item)
         .file.close
         .file.destroy
      end
   end

   write(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>INT, TYPE=>"int")
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   write(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>REAL, TYPE=>"real")
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   write(item,genre,format) ::: template
   ! Write to the archive, a single vector or matrix "item".
      item :: ITEM_TYPE
      genre,format :: STR, optional
      fmt :: STR
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name(genre)))
         .textfile.open(for="write")
         .textfile.set_use_labels(FALSE)
         .textfile.set_real_style("e")
         fmt = "row"; if (present(format)) fmt = format
         .textfile.put(item,fmt)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name(genre)))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item)
         .file.close
         .file.destroy
      end
   end

   write(item,genre,format) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, a single vector or matrix "item".
      item :: ITEM_TYPE
      genre,format :: STR, optional
   end

   write(item,genre,format) ::: get_from(ARCHIVE, ITEM_TYPE=>VEC{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single matrix or vector "item".
      item :: ITEM_TYPE
      genre,format :: STR, optional
   end

   write(item,genre,format) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, a single matrix or vector "item".
      item :: ITEM_TYPE
      genre,format :: STR, optional
   end

   write(item,genre,format) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single matrix or vector "item".
      item :: ITEM_TYPE
      genre,format :: STR, optional
   end

   write(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{REAL}, TYPE=>"real")
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   write(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT3{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   write(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{REAL}, TYPE=>"real")
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   write(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT4{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   write(item,genre) ::: get_from(ARCHIVE, ITEM_TYPE=>MAT5{CPX}, TYPE=>"cpx")
   ! Write to the archive, a single "item".
      item :: ITEM_TYPE
      genre :: STR, optional
   end

   write(item1,item2) ::: template
   ! Write to the archive, "item1" followed by "item2".
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
      if (.is_a_text_file) then
         .textfile.create(trim(.file_name))
         .textfile.set_use_labels(FALSE)
         .textfile.set_real_style("e")
         .textfile.open(for="write")
         .textfile.set_use_labels(FALSE)
         .textfile.put(item1)
         .textfile.put(item2)
         .textfile.close
         .textfile.destroy
      else
         .file.create(trim(.file_name))
         .file.open(for="write-only",buffered=TRUE,type=TYPE)
         .file.write_buffered(item1)
         .file.write_buffered(item2)
         .file.close
         .file.destroy
      end
   end

   write(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
   end

   write(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>VEC{REAL}, ITEM2_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
   end

   write(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>VEC{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
   end

   write(item1,item2) ::: get_from(ARCHIVE, ITEM1_TYPE=>MAT{REAL}, ITEM2_TYPE=>MAT{REAL}, TYPE=>"real")
   ! Write to the archive, "item1" followed by "item2".
      item1 :: ITEM1_TYPE
      item2 :: ITEM2_TYPE
   end

   write(item,genre,order)
   ! Write to the archive operator vector "item". "order" indicated the output
   ! order for ascii files.
      item :: OPVECTOR
      genre,order :: STR, optional
      itemgenre :: STR
      if (present(genre)) then; itemgenre = genre
      else;                    itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted  "); .write( item.restricted,"restricted",order)
         case ("unrestricted"); .write( item.alpha,"alpha",order)
                                .write( item.beta,"beta",order)
         case ("alpha       "); .write( item.alpha,"alpha",order)
         case ("beta        "); .write( item.beta,"beta",order)
         case ("general     "); .write( item.general,"general",order)
         case default;          UNKNOWN(itemgenre)
      end
   end

   write(item,genre,order)
   ! Write to the archive operator vector "item". "order" indicates the output
   ! order for ascii files.
      item :: OPMATRIX
      genre,order :: STR, optional
      itemgenre :: STR
      if (present(genre)) then; itemgenre = genre
      else;                    itemgenre = item.spinorbital_kind
      end
      select case (itemgenre)
         case ("restricted");           .write(item.restricted,"restricted",order)
         case ("unrestricted");         .write(item.alpha,"alpha",order)
                                        .write(item.beta,"beta",order)
         case ("alpha");                .write(item.alpha,"alpha",order)
         case ("beta");                 .write(item.beta,"beta",order)
         case ("general");              .write(item.general,"general",order)
         case ("restricted_complex");   .write(item.restricted_complex,"restricted_complex",order)
         case ("unrestricted_complex"); .write(item.alpha_complex,"alpha_complex",order)
                                        .write(item.beta_complex,"beta_complex",order)
         case ("alpha_complex");        .write(item.alpha_complex,"alpha_complex",order)
         case ("beta_complex");         .write(item.beta_complex,"beta_complex",order)
         case ("general_complex");      .write(item.general_complex,"general_complex",order)
         case default;                  DIE("unknown genre, "//trim(itemgenre))
      end
   end

!  **********************
!  Write gnuplot routines
!  **********************

   write_gnuplot(density,n_x,n_y,n_z)
   ! Write a "density" vector corresponding to a grid with dimensions "n_x",
   ! "n_y", "n_z" in gnuplot format (suitable for an splot).
      density :: VEC{REAL}
      n_x,n_y,n_z :: INT
   ENSURE(.is_a_text_file,"must open a ascii file")
      n,x,y,z :: INT
      .open(for="writing")
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)
      n = 1
      do z = 1,n_z
         if (n_z>1) .textfile.show(" z = ",z)
         do y = 1,n_y
         do x = 1,n_x
            .textfile.put(density(n),flush=1)
            n = n+1
         end
         .textfile.flush
         end
      end
      .close
   end

   write_gnuplot(j,n_x,n_y,n_z,norm,normalise)
   ! Write a current density vector "j" corresponding to a grid with dimensions
   ! "n_x", "n_y", "n_z" in gnuplot format (suitable for an splot).
   ! If "norm" is present and TRUE write the norm of the vector field
   ! If "normalise" is present and TRUE write the normalised of the vector field
       j :: MAT{REAL}
      n_x,n_y,n_z :: INT
      norm,normalise :: BIN, optional
   ENSURE(.is_a_text_file,"must open a ascii file")
      n,x,y,z :: INT
      write_norm,write_normalised :: BIN
       v :: VEC{REAL}(3)
      .open(for="writing")
      .textfile.set_real_style("e")
      .textfile.set_real_width(30)
      .textfile.set_real_precision(15)
      write_norm = FALSE; if (present(norm)) write_norm = norm
      write_normalised = FALSE; if (present(normalise)) write_normalised = normalise
      n = 1
      do z = 1,n_z
         if (n_z>1) then
            .textfile.put(" z = ")
            .textfile.put(z)
            .textfile.flush
         end
         do y = 1,n_y
         do x = 1,n_x
            v = j(n,:)
            if (write_norm) then
               .textfile.put( v.norm)
            else
               if (write_normalised) v.normalise
               .textfile.put(v(1))
               .textfile.put(v(2))
               .textfile.put(v(3))
            end
            .textfile.flush
            n = n+1
         end
         .textfile.flush
         end
      end
      .close
   end

end
