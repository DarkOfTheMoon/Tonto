! $Id$
!---------------------------------------------------------------------------
!
!  IMAT: Integer matrix operations ...
!
!  (c) dylan jayatilaka, 1996
!
!---------------------------------------------------------------------------
module IMAT

   use TYPES
   use SYSTEM

   implicit none         

#include "macros"
#include "imat.int"
   
contains

   create(dim1,dim2)
   ! Create an integer matrix with the specified dimensions
      PTR :: self
      INT, IN :: dim1,dim2
      nullify(self)
      allocate(self(dim1,dim2))
      ADD_MEM(dim1*dim2*INT_SIZE)
   end

   create(lb1,ub1,lb2,ub2)
   ! Create an integer matrix with the specified bounds
      PTR :: self
      INT, IN :: lb1,ub1,lb2,ub2
      nullify(self)
      allocate(self(lb1:ub1,lb2:ub2))
      ADD_MEM((ub1-lb1+1)*(ub2-lb2+1)*INT_SIZE)
   end

   create(bounds1,bounds2)
   ! Create an integer matrix with the specified bounds for each dimension
      PTR :: self
      IVEC, IN :: bounds1,bounds2
      .create(bounds1(1),bounds1(2),bounds2(1),bounds2(2))
   end

   destroy
   ! Destroy the matrix
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(size(self)*INT_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   to_product(a,b,transpose_a,transpose_b)
   ! Set self to the product of "a" and "b"
      IMAT, IN :: a, b
      BIN, optional, IN :: transpose_a, transpose_b
      if (present(transpose_a)) then
        if (present(transpose_b)) then
          self = matmul(transpose(a),transpose(b))
        else
          self = matmul(transpose(a),b)
        end
      else
        if (present(transpose_b)) then
          self = matmul(a,transpose(b))
        else
          self = matmul(a,b)
        end
      end
   end

   to_scaled_product(fac,a,b,transpose_a,transpose_b)
   ! Set self to the scaled product of "a" and "b"
      IMAT, IN :: a, b
      DBL, IN :: fac
      BIN, optional, IN :: transpose_a, transpose_b
      if (present(transpose_a)) then
        if (present(transpose_b)) then
          self = fac*matmul(transpose(a),transpose(b))
        else
          self = fac*matmul(transpose(a),b)
        end
      else
        if (present(transpose_b)) then
          self = fac*matmul(a,transpose(b))
        else
          self = fac*matmul(a,b)
        end
      end
   end
      
   plus_product(a,b,transpose_a,transpose_b)
   ! Add to self the product of "a" and "b"
      IMAT, IN :: a, b
      BIN, optional, IN :: transpose_a, transpose_b
      if (present(transpose_a)) then
        if (present(transpose_b)) then
          self = self+matmul(transpose(a),transpose(b))
        else
          self = self+matmul(transpose(a),b)
        end
      else
        if (present(transpose_b)) then
          self = self+matmul(a,transpose(b))
        else
          self = self+matmul(a,b)
        end
      end
   end
      
   plus_scaled_product(fac,a,b,transpose_a,transpose_b)
   ! Add to self the scaled product of "a" and "b"
      IMAT, IN :: a, b
      DBL, IN :: fac
      BIN, optional, IN :: transpose_a, transpose_b
      if (present(transpose_a)) then
        if (present(transpose_b)) then
          self = self+fac*matmul(transpose(a),transpose(b))
        else
          self = self+fac*matmul(transpose(a),b)
        end
      else
        if (present(transpose_b)) then
          self = self+fac*matmul(a,transpose(b))
        else
          self = self+fac*matmul(a,b)
        end
      end
   end

   trace result (res)
   ! Return the trace of self
      INT :: res
      INT :: dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      res = 0
      do i = 1,dim1
         res = res + self(i,i)
      end
   end
      
   trace_of_product(b) result (res)
   ! Return the trace of the product of self with "b"
      IMAT, IN :: b
      INT :: res
      INT :: a1,a2,b1,b2,i,j
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(a2/=b1 AND a1/=b2,"incompatible dimensions")
      res = 0 
      do i = 1,a1
      do j = 1,a2
         res = res + self(i,j)*b(j,i)
      end
      end
   end
      
   swap_columns(col1,col2)
   ! Swap columns "col1" and "col2" of self
      INT, IN :: col1,col2
      INT :: a1,a2,i
      INT :: val
      a1 = size(self,1)
      a2 = size(self,2)
      DIE_IF(col1>a2 OR col2>a2,"columns exceed dimesions")
      do i = 1,a1
         val = self(i,col1)
         self(i,col1) = self(i,col2)
         self(i,col2) = val
      end
   end
      
   set_to(b)
   ! Set self to "b"
      IMAT, IN :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = b
   end
      
   plus(b)
   ! Add to self matrix "b"
      IMAT, IN :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = self+b
   end
      
   minus(b)
   ! Subtract from self matrix "b"
      IMAT, IN :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = self-b
   end
      
   to_scaled_imat(fac,b)
   ! Set self to the scaled matrix "b"
      IMAT, IN :: b
      INT, IN :: fac
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = fac*b
   end
      
   plus_scaled_imat(fac,b)
   ! Add to self the scaled matrix "b"
      IMAT, IN :: b
      INT, IN :: fac
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = self+fac*b
   end
      
   zero
   ! Set self to zero
      self = 0
   end
      
   symmetric_fold
   ! Set the lower half of self to the sum of itself with its upper half
      INT :: dim1,dim2,i,j
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,dim1
      do j = 1,i-1
         self(i,j) = self(i,j)+self(j,i)
      end
      end
   end
      
   antisymmetric_fold
   ! Set the lower half of self to the sum of itself minus its upper half
      INT :: dim1,dim2,i,j
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,dim1
      do j = 1,i-1
         self(i,j) = self(i,j)-self(j,i)
      end
      end
   end
      
   to_unit_imat
   ! Set self to the unit matrix
      INT :: dim1,dim2,i
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      self = 0
      do i = 1,dim1
         self(i,i) = 1
      end
   end
      
   weight_diagonal(fac)
   ! Weight the diagonals of self by "fac"
      INT, IN :: fac
      INT :: dim1,dim2,i
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,dim1
         self(i,i) = fac*self(i,i)
      end
   end
      
   get_diagonal(diag)
   ! Return the diagonal of self in "diag"
      IVEC, INOUT :: diag
      INT :: dim1,dim2,dim,i
      dim1 = size(self,1); dim2 = size(self,2); dim  = size(diag)
      DIE_IF(dim/=min(dim1,dim2),"size of diagonal vector is incompatible")
      do i = 1,dim
         diag(i) = self(i,i)
      end
   end
      
   symmetric_reflect
   ! Set the upper half of self to the lower half
      INT :: dim1,dim2,i,j
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,dim1
      do j = 1,i-1
         self(j,i) = self(i,j)
      end
      end
   end
      
   antisymmetric_reflect
   ! Set the upper half of self to the negative of the lower half.
   ! The diagonals are set to zero
      INT :: dim1,dim2,i,j
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,j
         do j = 0,i-1
            self(j,i) = -self(i,j)
         end
      end
      do i = 1,dim1
         self(i,i) = 0
      end
   end

  make_cartesian_components(l) [pure]
  ! Returns the cartesian components of the angular momentum "l".
  ! Size of self is [3,l.n_comp].
    INT, IN :: l
    OUT :: self
    INT :: a,b,c,ind
    ind=1
    do a = l,floor((l+2)/3.0),-1
      do b = min(l-a,a),floor((l-a+1)/2.0),-1
        c = l-a-b
        if (a==b AND b==c) then
          self(1:3,ind)   = (/a,a,a/)
          ind = ind+1
        else if (a>b AND b==c) then
          self(1:3,ind)   = (/a,b,b/)
          self(1:3,ind+1) = (/b,a,b/)
          self(1:3,ind+2) = (/b,b,a/)
          ind = ind+3
        else if (a==b AND b>c) then
          self(1:3,ind)   = (/a,a,c/)
          self(1:3,ind+1) = (/a,c,a/)
          self(1:3,ind+2) = (/c,a,a/)
          ind = ind+3
        else
          self(1:3,ind)   = (/a,b,c/)
          self(1:3,ind+1) = (/a,c,b/)
          self(1:3,ind+2) = (/b,a,c/)
          self(1:3,ind+3) = (/c,a,b/)
          self(1:3,ind+4) = (/b,c,a/)
          self(1:3,ind+5) = (/c,b,a/)
          ind = ind+6
        end
      end
    end
  end

  make_cartesian_components(minl,maxl) [pure]
  ! Returns the cartesian components of all angular momenta between "minl"
  ! and "maxl".
  ! Size of self is [3, maxl.n_comp_sum - (minl-1).n_comp_sum )].
    INT, IN :: minl,maxl
    OUT :: self
    INT :: a,b,c,ind,j
    ind=1
    do j=minl,maxl
      do a = j,floor((j+2)/3.0),-1
        do b = min(j-a,a),floor((j-a+1)/2.0),-1
          c = j-a-b
          if (a==b AND b==c) then
            self(1:3,ind)   = (/a,a,a/)
            ind = ind+1
          else if (a>b AND b==c) then
            self(1:3,ind)   = (/a,b,b/)
            self(1:3,ind+1) = (/b,a,b/)
            self(1:3,ind+2) = (/b,b,a/)
            ind = ind+3
          else if (a==b AND b>c) then
            self(1:3,ind)   = (/a,a,c/)
            self(1:3,ind+1) = (/a,c,a/)
            self(1:3,ind+2) = (/c,a,a/)
            ind = ind+3
          else
            self(1:3,ind)   = (/a,b,c/)
            self(1:3,ind+1) = (/a,c,b/)
            self(1:3,ind+2) = (/b,a,c/)
            self(1:3,ind+3) = (/c,a,b/)
            self(1:3,ind+4) = (/b,c,a/)
            self(1:3,ind+5) = (/c,b,a/)
            ind = ind+6
          end
        end
      end
    end
  end


end
