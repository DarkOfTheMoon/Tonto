! $Id$
!---------------------------------------------------------------------------
!
!  IMAT: Integer matrix operations ...
!
!  (c) dylan jayatilaka, 1996
!
!---------------------------------------------------------------------------
module IMAT

   use TYPES
   use SYSTEM

   implicit none         

#include "macros"
#include "imat.int"
   
contains

   create(dim1,dim2)
   ! Create an integer matrix with the specified dimensions
      PTR :: self
      INT, IN :: dim1,dim2
      nullify(self)
      allocate(self(dim1,dim2))
      ADD_MEM(dim1*dim2*INT_SIZE)
   end

   create(lb1,ub1,lb2,ub2)
   ! Create an integer matrix with the specified bounds
      PTR :: self
      INT, IN :: lb1,ub1,lb2,ub2
      nullify(self)
      allocate(self(lb1:ub1,lb2:ub2))
      ADD_MEM((ub1-lb1+1)*(ub2-lb2+1)*INT_SIZE)
   end

   create(bounds1,bounds2)
   ! Create an integer matrix with the specified bounds for each dimension
      PTR :: self
      IVEC, IN :: bounds1,bounds2
      .create(bounds1(1),bounds1(2),bounds2(1),bounds2(2))
   end

   destroy
   ! Destroy the matrix
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(size(self)*INT_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

  shrink(dim1,dim2) [leaky]
  ! Shrinks self to dimension dim1xdim2.  Contents are retained.
    PTR :: self
    IMAT, PTR :: old
    INT, IN :: dim1,dim2
    ENSURE( .created, "matrix not allocated")
    ENSURE(dim1<=size(self,1), "1st dimension given is too small.")
    ENSURE(dim2<=size(self,2), "2nd dimension given is too small.")
    old => self
    nullify(self)
    self.create(dim1,dim2)
    self=old(1:dim1,1:dim2)
    old.destroy
  end

  expand(dim1,dim2) [leaky]
  ! Expands self to dimension dim1xdim2.  Contents are retained.
  ! Elements added are set to zero.
    PTR :: self
    IMAT, PTR :: old
    INT, IN :: dim1,dim2
    INT :: old_size1,old_size2
    ENSURE( .created, "matrix not allocated")
    old => self
    old_size1=size(old,1)
    old_size2=size(old,2)
    ENSURE(dim1>=old_size1, "1st dimension given is too large.")
    ENSURE(dim2>=old_size2, "2nd dimension given is too large.")
    nullify(self)
    self.create(dim1,dim2)
    self(1:old_size1,1:old_size2)=old
    self(old_size1+1:dim1,:)=0
    self(:,old_size2+1:dim2)=0
    old.destroy
  end

   to_product(a,b,transpose_a,transpose_b)
   ! Set self to the product of "a" and "b"
      IMAT, IN :: a, b
      BIN, optional, IN :: transpose_a, transpose_b
      if (present(transpose_a)) then
        if (present(transpose_b)) then
          self = matmul(transpose(a),transpose(b))
        else
          self = matmul(transpose(a),b)
        end
      else
        if (present(transpose_b)) then
          self = matmul(a,transpose(b))
        else
          self = matmul(a,b)
        end
      end
   end

   to_scaled_product(fac,a,b,transpose_a,transpose_b)
   ! Set self to the scaled product of "a" and "b"
      IMAT, IN :: a, b
      DBL, IN :: fac
      BIN, optional, IN :: transpose_a, transpose_b
      if (present(transpose_a)) then
        if (present(transpose_b)) then
          self = fac*matmul(transpose(a),transpose(b))
        else
          self = fac*matmul(transpose(a),b)
        end
      else
        if (present(transpose_b)) then
          self = fac*matmul(a,transpose(b))
        else
          self = fac*matmul(a,b)
        end
      end
   end
      
   plus_product(a,b,transpose_a,transpose_b)
   ! Add to self the product of "a" and "b"
      IMAT, IN :: a, b
      BIN, optional, IN :: transpose_a, transpose_b
      if (present(transpose_a)) then
        if (present(transpose_b)) then
          self = self+matmul(transpose(a),transpose(b))
        else
          self = self+matmul(transpose(a),b)
        end
      else
        if (present(transpose_b)) then
          self = self+matmul(a,transpose(b))
        else
          self = self+matmul(a,b)
        end
      end
   end
      
   plus_scaled_product(fac,a,b,transpose_a,transpose_b)
   ! Add to self the scaled product of "a" and "b"
      IMAT, IN :: a, b
      DBL, IN :: fac
      BIN, optional, IN :: transpose_a, transpose_b
      if (present(transpose_a)) then
        if (present(transpose_b)) then
          self = self+fac*matmul(transpose(a),transpose(b))
        else
          self = self+fac*matmul(transpose(a),b)
        end
      else
        if (present(transpose_b)) then
          self = self+fac*matmul(a,transpose(b))
        else
          self = self+fac*matmul(a,b)
        end
      end
   end

   trace result (res)
   ! Return the trace of self
      INT :: res
      INT :: dim1,dim2,i
      dim1 = size(self,1)
      dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      res = 0
      do i = 1,dim1
         res = res + self(i,i)
      end
   end
      
   trace_of_product(b) result (res)
   ! Return the trace of the product of self with "b"
      IMAT, IN :: b
      INT :: res
      INT :: a1,a2,b1,b2,i,j
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(a2/=b1 AND a1/=b2,"incompatible dimensions")
      res = 0 
      do i = 1,a1
      do j = 1,a2
         res = res + self(i,j)*b(j,i)
      end
      end
   end
      
   swap_columns(col1,col2)
   ! Swap columns "col1" and "col2" of self
      INT, IN :: col1,col2
      INT :: a1,a2,i
      INT :: val
      a1 = size(self,1)
      a2 = size(self,2)
      DIE_IF(col1>a2 OR col2>a2,"columns exceed dimesions")
      do i = 1,a1
         val = self(i,col1)
         self(i,col1) = self(i,col2)
         self(i,col2) = val
      end
   end
      
   set_to(b)
   ! Set self to "b"
      IMAT, IN :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = b
   end
      
   plus(b)
   ! Add to self matrix "b"
      IMAT, IN :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = self+b
   end
      
   minus(b)
   ! Subtract from self matrix "b"
      IMAT, IN :: b
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = self-b
   end
      
   to_scaled_imat(fac,b)
   ! Set self to the scaled matrix "b"
      IMAT, IN :: b
      INT, IN :: fac
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = fac*b
   end
      
   plus_scaled_imat(fac,b)
   ! Add to self the scaled matrix "b"
      IMAT, IN :: b
      INT, IN :: fac
      INT :: a1,a2,b1,b2
      a1 = size(self,1); a2 = size(self,2)
      b1 = size(b,1); b2 = size(b,2)
      DIE_IF(b1/=a1 OR b2/=a2,"error in limits")
      self = self+fac*b
   end
      
   zero
   ! Set self to zero
      self = 0
   end
      
   symmetric_fold
   ! Set the lower half of self to the sum of itself with its upper half
      INT :: dim1,dim2,i,j
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,dim1
      do j = 1,i-1
         self(i,j) = self(i,j)+self(j,i)
      end
      end
   end
      
   antisymmetric_fold
   ! Set the lower half of self to the sum of itself minus its upper half
      INT :: dim1,dim2,i,j
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,dim1
      do j = 1,i-1
         self(i,j) = self(i,j)-self(j,i)
      end
      end
   end
      
   to_unit_imat
   ! Set self to the unit matrix
      INT :: dim1,dim2,i
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      self = 0
      do i = 1,dim1
         self(i,i) = 1
      end
   end
      
   weight_diagonal(fac)
   ! Weight the diagonals of self by "fac"
      INT, IN :: fac
      INT :: dim1,dim2,i
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,dim1
         self(i,i) = fac*self(i,i)
      end
   end
      
   get_diagonal(diag)
   ! Return the diagonal of self in "diag"
      IVEC, INOUT :: diag
      INT :: dim1,dim2,dim,i
      dim1 = size(self,1); dim2 = size(self,2); dim  = size(diag)
      DIE_IF(dim/=min(dim1,dim2),"size of diagonal vector is incompatible")
      do i = 1,dim
         diag(i) = self(i,i)
      end
   end
      
   symmetric_reflect
   ! Set the upper half of self to the lower half
      INT :: dim1,dim2,i,j
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,dim1
      do j = 1,i-1
         self(j,i) = self(i,j)
      end
      end
   end
      
   antisymmetric_reflect
   ! Set the upper half of self to the negative of the lower half.
   ! The diagonals are set to zero
      INT :: dim1,dim2,i,j
      dim1 = size(self,1); dim2 = size(self,2)
      DIE_IF(dim1/=dim2,"non-square matrix")
      do i = 1,j
         do j = 0,i-1
            self(j,i) = -self(i,j)
         end
      end
      do i = 1,dim1
         self(i,i) = 0
      end
   end

end
