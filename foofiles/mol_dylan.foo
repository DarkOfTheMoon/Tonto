!-------------------------------------------------------------------------------
!
! MOL_dylan: dylan's test routines
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_DYLAN

   use TYPES
   use SYSTEM
   use TIME
   use STR
   use INT
   use DBL

   use STRVEC
   use BINVEC
   use IVEC
   use IVECVEC
   use IMAT
   use IMAT3
   use IMAT4
   use VEC
   use VECVEC
   use MAT
   use MAT3
   use MAT4
   use MAT5
   use MATVEC
   use MAT3VEC

   use CVEC
   use CMAT
   use CMAT3
   use CMAT4
   use CMAT5
   use OPVEC
   use OPMAT

   use UNITNUMBER
   use TEXTFILE
   use ARCHIVE

   use VECDIIS

   use RYS
   use GAUSSIAN
   use GAUSSIAN2
   use GAUSSIAN4
   use SHELL
   use SHELL1
   use SHELL2
   use SHELL4
   use SHELLVEC

   use BASISVEC

   use ATOM
   use ATOMVEC

   use IRREP
   use IRREPVEC
   use SPACEGROUP

   use CRYSTAL

   use PLOTGRID
   use DFTGRID

   use MOL

   implicit none

#  include "macros"
#  include "mol_dylan.int"

contains

  make_pcc_structure_factors
     MAT, PTR :: S
     MAT, PTR :: mo,Smo
     TEXTFILE, PTR :: in
     MAT, PTR :: k_pts
     CMAT3, PTR :: ftnew,ft
     CMAT, PTR :: W
     CMAT4, PTR :: ftnew_nabla,ft_nabla
     SHELL2, PTR :: shell
     INT :: n_refl,q,i,j
     INT :: fa,la,fb,lb,a,b
     DBL :: fac
     mo.create(160,4)
     in.create("mo35")
     in.open_for_read
     in.read(mo,order="by_column")
     stdout.text("mo")
     stdout.put(mo)

     S.create(160,160)
     .get_overlap_matrix(S)

     Smo.create(4,4)
     Smo.create(4,4)
     S.change_basis(Smo,mo)
     stdout.text("Smo")
     stdout.put(Smo)

     n_refl = .crystal%n_refl

     k_pts.create(n_refl,3)
     .crystal.make_k_pts(k_pts)

     shell.create
     ftnew.create(4,4,1)
     ftnew = ZERO
     do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft.create(n_refl,shell%a%n_comp,shell%b%n_comp)
         shell.make_ft(ft,k_pts)
         fac = ONE
         if (a==b) fac = HALF
         do i = 1,n_refl
            ftnew(:,:,i) = ftnew(:,:,i) + &
               fac*matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) + &
               fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft(i,:,:),mo(fb:lb,:))) )
         end
         ft.destroy
         shell.destroy_ptr_part
     end

     do i = 1,n_refl
        stdout.put(ftnew(:,:,i))
     end
     ftnew.destroy

     ftnew_nabla.create(4,4,3,1)
     ftnew_nabla = ZERO
     do q = 1,.n_shell_pairs
         .get_shell_pair(q,shell,a,b,fa,la,fb,lb)
         ft_nabla.create(n_refl,shell%a%n_comp,shell%b%n_comp,3)
         shell.make_ft_nabla(ft_nabla,k_pts)
         fac = ONE
         if (a==b) fac = HALF
         do i = 1,n_refl
         do j = 1,3
            ftnew_nabla(:,:,j,i) = ftnew_nabla(:,:,j,i) + &
               fac*matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) - &
               fac* transpose( matmul( transpose(mo(fa:la,:)), matmul(ft_nabla(i,:,:,j),mo(fb:lb,:))) )
         end
         end
         ft_nabla.destroy
         shell.destroy_ptr_part
     end

     do i = 1,n_refl
     do j = 1,3
         stdout.show("component =",j)
         stdout.put(ftnew_nabla(:,:,j,i))
     end
     end
     ftnew_nabla.destroy
     shell.destroy
  end

  make_pcc_L_matrices
     MAT, PTR :: S
     MAT, PTR :: mo,Smo
     MAT, PTR :: Lx,Ly,Lz
     MAT, PTR :: Lxmo,Lymo,Lzmo
     TEXTFILE, PTR :: in
     mo.create(160,4)
     in.create("mo35")
     in.open_for_read
     in.read(mo,order="by_column")
     stdout.text("mo")
     stdout.put(mo)

     S.create(160,160)
     .get_overlap_matrix(S)

     Smo.create(4,4)
     Smo.create(4,4)
     S.change_basis(Smo,mo)
     stdout.text("Smo")
     stdout.put(Smo)

     Lx.create(.n_bf,.n_bf); Lx = ZERO
     Ly.create(.n_bf,.n_bf); Ly = ZERO
     Lz.create(.n_bf,.n_bf); Lz = ZERO
     .make_L_matrices(Lx,Ly,Lz)

   ! std_output.text("Lx")
   ! std_output.put(Lx)
   ! std_output.text("Ly")
   ! std_output.put(Ly)
   ! std_output.text("Lz")
   ! std_output.put(Lz)

     Lxmo.create(4,4)
     Lymo.create(4,4)
     Lzmo.create(4,4)
     Lx.change_basis(Lxmo,mo)
     Ly.change_basis(Lymo,mo)
     Lz.change_basis(Lzmo,mo)

     stdout.text("Lxmo")
     stdout.put(Lxmo)
     stdout.text("Lymo")
     stdout.put(Lymo)
     stdout.text("Lzmo")
     stdout.put(Lzmo)
     S.destroy
     Smo.destroy
     Lxmo.destroy; Lymo.destroy; Lzmo.destroy
     Lx.destroy; Ly.destroy; Lz.destroy
  end


  test_spin_orbit_B_matrices
     MAT, PTR :: Lx,Ly,Lz
     DBL :: fac
     fac = (TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)/G_FACTOR
     Lx.create(.n_bf,.n_bf)
     Ly.create(.n_bf,.n_bf)
     Lz.create(.n_bf,.n_bf)
     .make_spin_orbit_B_matrices(Lx,Ly,Lz)
     stdout.text("x")
     stdout.put( Lx)
     stdout.text("y")
     stdout.put( Ly)
     stdout.text("z")
     stdout.put( Lz)
     .make_SOB_matrices(Lx,Ly,Lz)
     stdout.text("x")
     stdout.put( Lx)
     stdout.text("y")
     stdout.put( Ly)
     stdout.text("z")
     stdout.put( Lz)
     Lx.destroy; Ly.destroy; Lz.destroy
  end

  make_SOB_matrices(SOBx,SOBy,SOBz)
  ! Calculate the gauge modified (B field) spin orbit matrices "SOBx" "SOBy" and "SOBz"
     MAT :: SOBx,SOBy,SOBz
     MAT, PTR :: Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz,Qx,Qy,Qz,Qss
     INT :: q,c,a,b,fa,la,fb,lb,atom_a,atom_b
     DBL :: fac,Z
     SHELL2 :: shell
     ARCHIVE :: archive
     BIN :: debug
     INT :: n_a,n_b
     ENSURE( .atom.created,  "no atom list")
     ENSURE( .atom.bases_are_all_resolved, "no basis set")
     fac = G_FACTOR/(TWO*EIGHT*(SPEED_OF_LIGHT_AU)**2)
     SOBx = ZERO; SOBy = ZERO; SOBz = ZERO
     do q=1,.n_shell_pairs
        .get_shell_pair(q,shell,fa,la,fb,lb)
        n_a = shell%a%n_comp; n_b = shell%b%n_comp
        Qss.create(n_a,n_b)
        Qx.create(n_a,n_b);  Qy.create(n_a,n_b);  Qz.create(n_a,n_b)
        Qxx.create(n_a,n_b); Qxy.create(n_a,n_b); Qxz.create(n_a,n_b)
        Qyx.create(n_a,n_b); Qyy.create(n_a,n_b); Qyz.create(n_a,n_b)
        Qzx.create(n_a,n_b); Qzy.create(n_a,n_b); Qzz.create(n_a,n_b)
        do c = 1,.n_atom
           Z = .atom(c)%atomic_number
           shell.make_spin_orbit_B_ints(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, .atom(c)%pos, .gauge_origin)
           Qss = Qxx + Qyy + Qzz
           Qx = Qss*.B_field(1) - Qxx*.B_field(1) - Qxy*.B_field(2) - Qxz*.B_field(3)
           Qy = Qss*.B_field(2) - Qyx*.B_field(1) - Qyy*.B_field(2) - Qyz*.B_field(3)
           Qz = Qss*.B_field(3) - Qzx*.B_field(1) - Qzy*.B_field(2) - Qzz*.B_field(3)
           SOBx(fa:la,fb:lb) = SOBx(fa:la,fb:lb) - Z*Qx
           SOBy(fa:la,fb:lb) = SOBy(fa:la,fb:lb) - Z*Qy
           SOBz(fa:la,fb:lb) = SOBz(fa:la,fb:lb) - Z*Qz
        end
        shell.destroy_ptr_part
        Qzz.destroy; Qzy.destroy; Qzx.destroy
        Qyz.destroy; Qyy.destroy; Qyx.destroy
        Qxz.destroy; Qxy.destroy; Qxx.destroy
        Qz.destroy;  Qy.destroy;  Qx.destroy;  Qss.destroy
     end
     SOBx.make_symmetric
     SOBy.make_symmetric
     SOBz.make_symmetric
   ! archive.set(.name,"SOB_x_matrix"); archive.write(SOBx)
   ! archive.set(.name,"SOB_y_matrix"); archive.write(SOBy)
   ! archive.set(.name,"SOB_z_matrix"); archive.write(SOBz)
  end

  make_pcc_densities
  ! Calculate pcc's densities for the paper
     MAT, PTR :: mo
     VEC, PTR :: mo35,mo48,mo49,mo50
     VEC, PTR :: p35,p48,p49,p50
     MAT, PTR :: g35,g48,g49,g50
     MAT, PTR :: j,s
     TEXTFILE, PTR :: in
     INT :: n_pt,k
     DBL :: mu,nu,rt3,fac
     ARCHIVE :: archive

     mo35.create(160)
     mo48.create(160)
     mo49.create(160)
     mo50.create(160)
     in.create("mo35")
     in.open_for_read
     in.read(mo35)
     in.read(mo48)
     in.read(mo49)
     in.read(mo50)

     n_pt = .grid%n_pt
     p35.create(n_pt); g35.create(n_pt,3)
     p48.create(n_pt); g48.create(n_pt,3)
     p49.create(n_pt); g49.create(n_pt,3)
     p50.create(n_pt); g50.create(n_pt,3)
     .make_orbital_grid(p35,mo35)
     .make_orbital_grid(p48,mo48)
     .make_orbital_grid(p49,mo49)
     .make_orbital_grid(p50,mo50)
     .make_nabla_orbital_grid(g35,mo35)
     .make_nabla_orbital_grid(g48,mo48)
     .make_nabla_orbital_grid(g49,mo49)
     .make_nabla_orbital_grid(g50,mo50)

     j.create(n_pt,3)
     s.create(n_pt,3)
     nu = 0.15578d0
     mu = 0.19107d0
     rt3 = ONE/sqrt(THREE)
     fac = ONE/(ONE+mu*mu+nu*nu)
     do k = 1,3
        j(:,k) =      nu*(p35(:)*g48(:,k) - p48(:)*g35(:,k)) &
               + HALF*mu*(p50(:)*g49(:,k) - p49(:)*g50(:,k))
     end
     j = fac*j

     s(:,1) = -rt3*mu * (p35(:)*p49(:) - nu*p48(:)*p50(:))
     s(:,2) = -rt3*mu * (p35(:)*p50(:) - nu*p48(:)*p49(:))
     s(:,3) = (ONE+mu*mu/THREE) * p48(:)*p48(:) &
            + (ONE+nu*nu+mu*mu/SIX) * (p49(:)*p49(:)+p50(:)*p50(:)) &
            + (nu*nu+mu*mu/THREE) * p35(:)*p35(:)
     s(:,3) = HALF*s(:,3)

     archive.set(.name,"current_density")
     archive.write(j)
     archive.set(.name,"current_density,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z)
     archive.set(.name,"current_norm_density,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
     archive.set(.name,"current_density,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(j, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)

     archive.set(.name,"spin_density")
     archive.write(s)
     archive.set(.name,"spin_density,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z)
     archive.set(.name,"spin_norm_density,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z, norm=TRUE)
     archive.set(.name,"spin_density,normalized,gnuplot",format="ascii")
     archive.write_gnuplot(s, .grid%n_x, .grid%n_y, .grid%n_z, normalise=TRUE)

     s.destroy
     j.destroy
     g50.destroy; p50.destroy
     g49.destroy; p49.destroy
     g48.destroy; p48.destroy
     g35.destroy; p35.destroy
     in.close
     in.destroy
     mo50.destroy
     mo49.destroy
     mo48.destroy
     mo35.destroy
  end

  make_weak_force_energy_shift
  ! Make the expectation value of the parity-violating energy shift.
  ! Requires some archived molecular orbitals, general_complex kind.
  ! Reference: R. Zanasi and P. Lazzeretti, CPL 286, 240 (1998)
      MAT, PTR  :: pt
      CVEC, PTR :: Pa,Pb
      CMAT, PTR :: Na,Nb
      VEC, PTR  :: PV,NN
      INT :: n, x,y,z
      DBL :: Gamma
      CDBL :: I
      ARCHIVE :: archive
      ENSURE( .atom.bases_are_all_resolved, "no basis set")
      .molecular_orbitals.destroy_ptr_part
      archive.set(.name,"molecular_orbitals")
      archive.read(.molecular_orbitals, kind="general_complex")
      Gamma = 5.73416d-17
      PV.create(.n_atom)
      pt.create(.n_atom,3)
      .atom.get_coordinates(pt)
      Pa.create(.n_atom);   Pb.create(.n_atom)
      Na.create(.n_atom,3); Nb.create(.n_atom,3)
      I = (ZERO,ONE)
      stdout.set_dbl_style("d")
      x = 1; y = 2; z = 3
      PV = ZERO
      do n = 1,.n_e
         .make_orbital_grid(Pa,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
         .make_orbital_grid(Pb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
         .make_nabla_orbital_grid(Na,.molecular_orbitals%general_complex(      1:  .n_bf,n), pt)
         .make_nabla_orbital_grid(Nb,.molecular_orbitals%general_complex(.n_bf+1:2*.n_bf,n), pt)
         PV(:) = PV(:) &
               + I*conjg(Nb(:,x))*Pa(:) + I*conjg(Na(:,x))*Pb(:) &
               - I*conjg(Pb(:))*Na(:,x) - I*conjg(Pa(:))*Nb(:,x) &
               +   conjg(Nb(:,y))*Pa(:) -   conjg(Na(:,y))*Pb(:) &
               +   conjg(Pb(:))*Na(:,y) -   conjg(Pa(:))*Nb(:,y) &
               + I*conjg(Na(:,z))*Pa(:) - I*conjg(Nb(:,z))*Pb(:) &
               - I*conjg(Pa(:))*Na(:,z) + I*conjg(Pb(:))*Nb(:,z)
      end
      PV = -HALF*Gamma*PV
      Nb.destroy; Na.destroy
      Pb.destroy; Pa.destroy
      pt.destroy
      NN.create(.n_atom)
      .atom.get_mean_neutron_numbers(NN)
      PV = PV*NN

      stdout.set_dbl_style("d")
      stdout.flush
      stdout.text("Contributions (by nucleus) to the parity-violating weak force energy shift term:")
      stdout.flush
      stdout.put(PV, format="column")
      stdout.flush
      stdout.show("Total contribution =", sum(PV) )
      stdout.flush
      stdout.text("Neutron numbers:")
      stdout.flush
      stdout.put(NN, format="column")
      stdout.set_dbl_style("f")
      NN.destroy
      PV.destroy
      .molecular_orbitals.destroy_ptr_part
  end

  put_g_tensor_information
  ! Put the g-tensor shift information to the output.
  ! Reference: Jayatilaka, JCP 108, 7587 (1998)
     MAT, PTR :: S, Lx,Ly,Lz, Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz, T
     CMAT, PTR :: HH,P
     DBL :: Sx,Sy,Sz,SS_net, Mx,My,Mz,MM_net
     DBL :: Qx,Qy,Qz,QQ_net, Tx,Ty,Tz,TT_net
     DBL :: Sx_ppm,Sy_ppm,Sz_ppm, Mx_ppm,My_ppm,Mz_ppm
     DBL :: Qx_ppm,Qy_ppm,Qz_ppm, Tx_ppm,Ty_ppm,Tz_ppm
     DBL :: fac, fx,fy,fz, total
     CDBL :: I
     INT :: m
     BIN :: int_width
     ARCHIVE :: archive
     .density_matrix.destroy_ptr_part
     archive.set(.name,"density_matrix")
     archive.read(.density_matrix, kind="general_complex")
     P => .density_matrix%general_complex
     HH.create(2*.n_bf,2*.n_bf)
     I = (ZERO,ONE)
     ! Spin contribution
     S.create(.n_bf,.n_bf)
     .get_overlap_matrix(S)
     fac = G_FACTOR/FOUR
     HH = ZERO
     HH.beta_alpha_plus(S,factor=fac)
     HH.alpha_beta_plus(S,factor=fac)
     Sx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(S,factor=fac*I)
     HH.alpha_beta_plus(S,factor=-fac*I)
     Sy = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(S,factor=fac)
     HH.beta_beta_plus(S,factor=-fac)
     Sz = HH.trace_of_product(P)
     S.destroy
     m = .n_a - .n_b
     fx = m*fac*.quantization_axis(1)
     fy = m*fac*.quantization_axis(2)
     fz = m*fac*.quantization_axis(3)
     Sx_ppm = (Sx-fx)*4000000/m
     Sy_ppm = (Sy-fy)*4000000/m
     Sz_ppm = (Sz-fz)*4000000/m
     SS_net = Sx_ppm*.quantization_axis(1) + Sy_ppm*.quantization_axis(2) + Sz_ppm*.quantization_axis(3)
     ! L contribution
     Lx.create(.n_bf,.n_bf)
     Ly.create(.n_bf,.n_bf)
     Lz.create(.n_bf,.n_bf)
     .get_L_matrices(Lx,Ly,Lz)
     fac = HALF
     HH = ZERO
     HH.alpha_alpha_plus(Lx,factor=fac*I)
     HH.beta_beta_plus(Lx,factor=fac*I)
     Mx = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Ly,factor=fac*I)
     HH.beta_beta_plus(Ly,factor=fac*I)
     My = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Lz,factor=fac*I)
     HH.beta_beta_plus(Lz,factor=fac*I)
     Mz = HH.trace_of_product(P)
     Lz.destroy; Ly.destroy; Lx.destroy
     Mx_ppm = Mx*4000000/m
     My_ppm = My*4000000/m
     Mz_ppm = Mz*4000000/m
     MM_net = Mx_ppm*.quantization_axis(1) + My_ppm*.quantization_axis(2) + Mz_ppm*.quantization_axis(3)
     ! 1 electron LS gauge contribution
     Qxx.create(.n_bf,.n_bf); Qxy.create(.n_bf,.n_bf); Qxz.create(.n_bf,.n_bf)
     Qyx.create(.n_bf,.n_bf); Qyy.create(.n_bf,.n_bf); Qyz.create(.n_bf,.n_bf)
     Qzx.create(.n_bf,.n_bf); Qzy.create(.n_bf,.n_bf); Qzz.create(.n_bf,.n_bf)
     .get_spin_orbit_Q_matrices(Qxx,Qxy,Qxz,Qyx,Qyy,Qyz,Qzx,Qzy,Qzz)
     fac = G_FACTOR/(TWO*EIGHT*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
     HH = ZERO
     HH.beta_alpha_plus(Qyy,factor=fac)
     HH.beta_alpha_plus(Qzz,factor=fac)
     HH.beta_alpha_plus(Qyx,factor=-I*fac)
     HH.alpha_alpha_plus(Qzx,factor=-fac)
     HH.beta_beta_plus(Qzx,factor=+fac)
     HH.make_hermitian
     Qx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(Qxx,factor=I*fac)
     HH.beta_alpha_plus(Qzz,factor=I*fac)
     HH.beta_alpha_plus(Qxy,factor=-fac)
     HH.alpha_alpha_plus(Qzy,factor=-fac)
     HH.beta_beta_plus(Qzy,factor=+fac)
     HH.make_hermitian
     Qy = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(Qxx,factor=fac)
     HH.alpha_alpha_plus(Qyy,factor=fac)
     HH.beta_beta_plus(Qxx,factor=-fac)
     HH.beta_beta_plus(Qyy,factor=-fac)
     HH.beta_alpha_plus(Qxz,factor=-fac)
     HH.beta_alpha_plus(Qyz,factor=-I*fac)
     HH.make_hermitian
     Qz = HH.trace_of_product(P)
     Qzz.destroy; Qzy.destroy; Qzx.destroy
     Qyz.destroy; Qyy.destroy; Qyx.destroy
     Qxz.destroy; Qxy.destroy; Qxx.destroy
     Qx_ppm = Qx*4000000/m
     Qy_ppm = Qy*4000000/m
     Qz_ppm = Qz*4000000/m
     QQ_net = Qx_ppm*.quantization_axis(1) + Qy_ppm*.quantization_axis(2) + Qz_ppm*.quantization_axis(3)
     ! Relativistic kinetic energy contribution
     T.create(.n_bf,.n_bf)
     .get_kinetic_matrix(T)
     fac = -G_FACTOR/(FOUR*SPEED_OF_LIGHT_AU*SPEED_OF_LIGHT_AU)
     HH = ZERO
     HH.beta_alpha_plus(T,factor=fac)
     HH.alpha_beta_plus(T,factor=fac)
     Tx = HH.trace_of_product(P)
     HH = ZERO
     HH.beta_alpha_plus(T,factor=I*fac)
     HH.alpha_beta_plus(T,factor=-I*fac)
     Ty = HH.trace_of_product(P)
     HH = ZERO
     HH.alpha_alpha_plus(T,factor=fac)
     HH.beta_beta_plus(T,factor=-fac)
     Tz = HH.trace_of_product(P)
     T.destroy
     HH.destroy
     .density_matrix.destroy_ptr_part
     Tx_ppm = Tx*4000000/m
     Ty_ppm = Ty*4000000/m
     Tz_ppm = Tz*4000000/m
     TT_net = Tx_ppm*.quantization_axis(1) + Ty_ppm*.quantization_axis(2) + Tz_ppm*.quantization_axis(3)

     stdout.set_dbl_style("d")
     stdout.flush
     stdout.text("Contribution to g-tensor shift:")
     stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.tab(int_fields=1); stdout.put("<value>");
     stdout.put("shift/ppm"); stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.text("Spin term:")
     stdout.put("S_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sx)
     stdout.set_dbl_style("f"); stdout.put(Sx_ppm); stdout.flush
     stdout.put("S_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sy)
     stdout.set_dbl_style("f"); stdout.put(Sy_ppm); stdout.flush
     stdout.put("S_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Sz);
     stdout.set_dbl_style("f"); stdout.put(Sz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(SS_net); stdout.flush
     stdout.text("Angular momentum term:")
     stdout.put("L_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Mx);
     stdout.set_dbl_style("f"); stdout.put(Mx_ppm); stdout.flush
     stdout.put("L_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(My);
     stdout.set_dbl_style("f"); stdout.put(My_ppm); stdout.flush
     stdout.put("L_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Mz);
     stdout.set_dbl_style("f"); stdout.put(Mz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(MM_net); stdout.flush
     stdout.text("1-electron L:S gauge term:")
     stdout.put("Q_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qx);
     stdout.set_dbl_style("f"); stdout.put(Qx_ppm); stdout.flush
     stdout.put("Q_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qy);
     stdout.set_dbl_style("f"); stdout.put(Qy_ppm); stdout.flush
     stdout.put("Q_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Qz);
     stdout.set_dbl_style("f"); stdout.put(Qz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(QQ_net); stdout.flush
     stdout.text("Relativistic B:S kinetic term:")
     stdout.put("T_x",int_width)
     stdout.set_dbl_style("d"); stdout.put(Tx)
     stdout.set_dbl_style("f"); stdout.put(Tx_ppm); stdout.flush
     stdout.put("T_y",int_width)
     stdout.set_dbl_style("d"); stdout.put(Ty);
     stdout.set_dbl_style("f"); stdout.put(Ty_ppm); stdout.flush
     stdout.put("T_z",int_width)
     stdout.set_dbl_style("d"); stdout.put(Tz);
     stdout.set_dbl_style("f"); stdout.put(Tz_ppm); stdout.flush
     stdout.put("Net",int_width); stdout.tab(dbl_fields=1);
     stdout.put(TT_net); stdout.flush
     total = SS_net + MM_net + QQ_net + TT_net
     stdout.flush
     stdout.put("Total:",int_width); stdout.tab(dbl_fields=1); stdout.put(total)
     stdout.flush
     stdout.dash(int_fields=1,dbl_fields=2)
     stdout.set_dbl_style("f")
  end

   integrate_property(make_property_grid) result (res)
   ! Integrate a scalar molecular property, which is represented by a subroutine
   ! "make_property_grid" which returns "values" of the property in a vector,
   ! given "mol" as the molecule, and "pts" as a set of points. The result of
   ! the integration is "res".
      interface
         make_property_grid(mol,values,pts)
            use TYPES
            MOL :: mol
            VEC :: values
            MAT :: pts
         end
      end
      DBL :: res
      ENSURE( .dftgrid.created,"no DFT grid information!")
!      res = .dftgrid.integrate_molecular_property(make_property_grid,self)
      res = ZERO
   end

!  integrate_rho_numerically
!  ! Integrate the density numerically
!     DBL :: res
!     res = .integrate_property(make_density_grid_1)
!     stdout.show("numerically integrated charge =",res)
!  end

   put_atom_kind_map
   ! Check the atom kind map routine
      DBL :: res
      IVEC, PTR :: atom_kind,unique_atom
      INT :: n_atom,n_kind
      n_atom = .n_atom
      atom_kind.create(n_atom)
      .atom.make_atom_kind_list(atom_kind,n_kind)
      stdout.text("atom kind")
      stdout.put(atom_kind,"column")
      unique_atom.create(n_kind)
      .atom.make_unique_atom_list(unique_atom)
      stdout.text("unique atom list")
      stdout.put(unique_atom,"column")
      unique_atom.destroy
      atom_kind.destroy
   end

end
