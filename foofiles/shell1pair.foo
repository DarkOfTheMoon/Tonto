!-------------------------------------------------------------------------------
!
! SHELL1PAIR : pair of gaussian SHELL1's, incorporating stored intermediate data
! valuable for integral evaluation.
!
! Copyright (C) Dylan Jayatilaka, 2000
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!-------------------------------------------------------------------------------

module SHELL1PAIR

   implicit none

contains

   create ::: get_from(OBJECT), leaky
   ! Create an object. This version does not set defaults.
   end

   destroy ::: get_from(OBJECT), leaky
   ! Destroy an object
   end
 
!   create(shell_a,shell_b) ::: leaky
!   ! Create a copy of a shell1 objects
!     self :: PTR
!     shell_a,shell_b :: SHELL, IN
!     .create
!     .copy(shell_a,shell_b)
!   end
 
   nullify_ptr_part
   ! Nullify the pointer parts of self
      .a.nullify_ptr_part
      .b.nullify_ptr_part
      nullify(.exponent_sum)
      nullify(.exponent_inv)
      nullify(.cc_prefactor)
      nullify(.cc_s_prefactor)
      nullify(.cc_p_prefactor)
      nullify(.normalising_factors)
      nullify(.pair_center)
      nullify(.center_diff)
   ! nullify(.hrr_comp_to_use)
   ! nullify(.hrr_components)
   ! nullify(.hrr_index_smaller)
   ! nullify(.hrr_index_larger)
   ! nullify(.form_3dints_x_indices)
   ! nullify(.form_3dints_y_indices)
   ! nullify(.form_3dints_z_indices)
   ! nullify(.form_3dints_yz_rms_indices)
   end
 
   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self
      .a.destroy_ptr_part
      .b.destroy_ptr_part
      .exponent_sum.destroy
      .exponent_inv.destroy
      .cc_prefactor.destroy
      .cc_s_prefactor.destroy
      .cc_p_prefactor.destroy
      .normalising_factors.destroy
      .pair_center.destroy
      .center_diff.destroy
   ! .hrr_comp_to_use.destroy
   ! .hrr_components.destroy
   ! .hrr_index_smaller.destroy
   ! .hrr_index_larger.destroy
   ! .form_3dints_x_indices.destroy
   ! .form_3dints_y_indices.destroy
   ! .form_3dints_z_indices.destroy
   ! .form_3dints_yz_rms_indices.destroy
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
      self :: PTR
      res :: BIN
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
      self :: PTR
      res :: BIN
   end
 
   create_copy(ab) ::: leaky
   ! Create a copy of the "ab" shellpair
      self :: PTR
      ab :: SHELL1PAIR, IN
      .create
      .copy(ab)
   end
 
   copy(ab) ::: leaky
   ! Copy the using shellpair "ab" and also set precalculated data.
   ! NOTE : ensure the ptr parts have been destroyed beforehand.
      ab :: SHELL1PAIR, IN
      self = ab
      .nullify_ptr_part
      .a.copy(ab.a)
      .b.copy(ab.b)
      if (ab.exponent_sum.created)        .exponent_sum.create_copy(ab.exponent_sum)
      if (ab.exponent_inv.created)        .exponent_inv.create_copy(ab.exponent_inv)
      if (ab.cc_prefactor.created)        .cc_prefactor.create_copy(ab.cc_prefactor)
      if (ab.cc_s_prefactor.created)      .cc_s_prefactor.create_copy(ab.cc_s_prefactor)
      if (ab.cc_p_prefactor.created)      .cc_p_prefactor.create_copy(ab.cc_p_prefactor)
      if (ab.normalising_factors.created) .normalising_factors.create_copy(ab.normalising_factors)
      if (ab.pair_center.created)         .pair_center.create_copy(ab.pair_center)
      if (ab.center_diff.created)         .center_diff.create_copy(ab.center_diff)
   end
 
   copy_a(shell_a) ::: leaky
   ! Copy the "a" shell1 of the shell2 objects from "shell_a"
      shell_a :: SHELL1, IN
      .a.copy(shell_a)
   end
 
   copy_b(shell_b) ::: leaky
   ! Copy the "b" shell1 of the shell2 objects from "shell_b"
      shell_b :: SHELL1, IN
      .b.copy(shell_b)
   end
 
   copy_a(shell_a) ::: leaky
   ! Copy the "a" shell of the shell2 objects from "shell_a"
      shell_a :: SHELL, IN
      .a.copy(shell_a)
   end
 
   copy_b(shell_b) ::: leaky
   ! Copy the "b" shell of the shell2 objects from "shell_b"
      shell_b :: SHELL, IN
      .b.copy(shell_b)
   end
 
   unnormalise
   ! Unnormalise each shell
      .a.unnormalise
      .b.unnormalise
   end
 
   make_precalculated_data ::: leaky
   ! Precalculate some data for the 1/r_{12} electron repulsion integrals
   ENSURE(GAUSSIAN_DATA::normalising_factors.created,"no normalising factors")
      b_cc,a,b,ab_sum,ab_inv,cc_prefac :: REAL
      ag,bg,i,fa,la,fb,lb :: INT
      anorm,bnorm :: VEC{REAL}*
      .l_max = max(.a.l,.b.l)
      .l_min = min(.a.l,.b.l)
      .l_sum = .a.l + .b.l
      .first_gaussian = SHELL1PAIR::n_comp_up_to(.l_max-1) + 1
      .last_gaussian  = SHELL1PAIR::n_comp_up_to(.l_sum)
      .n_gaussian = .last_gaussian - .first_gaussian + 1
      .n_gaussian_pairs = .a.n_cc*.b.n_cc
      .exponent_sum.create(.n_gaussian_pairs)
      .exponent_inv.create(.n_gaussian_pairs)
      .cc_prefactor.create(.n_gaussian_pairs)
      .pair_center.create(3,.n_gaussian_pairs)
      i = 0
      do bg = 1,.b.n_cc
       b      = .b.ex(bg)
       b_cc   = .b.cc(bg)
       do ag = 1,.a.n_cc
         a = .a.ex(ag)
         ab_sum = a + b
         ab_inv = ONE/ab_sum
         cc_prefac = b_cc*.a.cc(ag)*ab_inv*sqrt(ab_inv) ! *exp(-a*b*ab_inv)
      !  if (cc_prefac<pair_cutoff) cycle
         i = i + 1
         .exponent_sum(i)   = ab_sum
         .exponent_inv(i)   = ab_inv
         .cc_prefactor(i)   = cc_prefac
         .pair_center(:,i)  = (a*.a.pos + b*.b.pos)*ab_inv
       end
      end
      .n_comp_pairs = .a.n_comp*.b.n_comp
      .n_sph_pairs = .a.n_sph*.b.n_sph
      .normalising_factors.create(.n_comp_pairs)
      fa = .a.first_gaussian; la = .a.last_gaussian
      fb = .b.first_gaussian; lb = .b.last_gaussian
      anorm => GAUSSIAN_DATA::normalising_factors(fa:la)
      bnorm => GAUSSIAN_DATA::normalising_factors(fb:lb)
      i = 0
      do bg = 1,.b.n_comp
      do ag = 1,.a.n_comp
        i = i + 1
        .normalising_factors(i) = anorm(ag)*bnorm(bg)
      end
      end
 
!    Old reduced multiplication scheme using compressed trangle 2d arrays

!    ub = .l_sum.n_comp_sum - (.l_max-1).n_comp_sum
!  ! .hrr_index_larger.create(0,.l_sum,0,.l_sum,0,.l_sum)
!  ! .hrr_index_smaller.create(0,.l_sum,0,.l_sum,0,.l_sum)
!  ! .hrr_components.create(3,.l_sum.n_comp_sum)
!  ! .hrr_comp_to_use.create(.l_sum.n_comp_sum)
!    .form_3dints_x_indices.create(ub)
!    .form_3dints_y_indices.create(ub)
!    .form_3dints_z_indices.create(ub)
!  ! i=0;
!  ! i.make_gaussian_xyz_powers(.hrr_components,.l_sum,.hrr_index_smaller,.hrr_comp_to_use)
!    .make_gaussian_xyz_indices(.form_3dints_x_indices,.form_3dints_y_indices,.form_3dints_z_indices,.l_max,.l_sum)
!    .form_3dints_yz_rms_indices.create(ub)
!    do i=1,ub
!      j = .form_3dints_z_indices(i)
!      .form_3dints_yz_rms_indices(i) = -.l_sum - 2 + j*(2*.l_sum+5-j)/2 + &
!                                  .form_3dints_y_indices(i)
!    end
   end

!   make_gaussian_xyz_indices(nx,ny,nz,l_min,l_max) ::: private, always_pure
!   ! Make the xyz powers "nx", "ny", "nz" for a cartesian gaussian with angular
!   ! momentum from "lmin" to "lmax".  (actually adds one to each power to avoid
!   ! 0 as lower bound).
!     self :: IN
!     l_min,l_max :: INT, IN
!     nx,ny,nz :: VEC{INT}, OUT
!     a,b,c,i,j,a1,b1,c1 :: INT
!     i = 1
!     do j = l_min,l_max
!       do a = j,floor((j+2)*THIRD),-1
!          do b = min(j-a,a),floor((j-a+1)*HALF),-1
!            c = j - a - b
!            if (a==b AND b==c) then
!              a1=a+1
!              nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = a1
!              i = i+1
!            else if (a>b AND b==c) then
!              a1=a+1
!              b1=b+1
!              nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = b1
!              nx(i+1) = b1; ny(i+1) = a1; nz(i+1) = b1
!              nx(i+2) = b1; ny(i+2) = b1; nz(i+2) = a1
!              i = i+3
!            else if (a==b AND b>c) then
!              a1=a+1
!              c1=c+1
!              nx(i  ) = a1; ny(i  ) = a1; nz(i  ) = c1
!              nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = a1
!              nx(i+2) = c1; ny(i+2) = a1; nz(i+2) = a1
!              i = i+3
!            else
!              a1=a+1
!              b1=b+1
!              c1=c+1
!              nx(i  ) = a1; ny(i  ) = b1; nz(i  ) = c1
!              nx(i+1) = a1; ny(i+1) = c1; nz(i+1) = b1
!              nx(i+2) = b1; ny(i+2) = a1; nz(i+2) = c1
!              nx(i+3) = c1; ny(i+3) = a1; nz(i+3) = b1
!              nx(i+4) = b1; ny(i+4) = c1; nz(i+4) = a1
!              nx(i+5) = c1; ny(i+5) = b1; nz(i+5) = a1
!              i = i+6
!            end
!         end
!       end
!     end
!   end

   n_comp_up_to(l) result (res) ::: selfless, private, always_pure
   ! No. of gaussian cartesian component functions up to and including the shell
   ! with momentum "l".
      l :: INT, IN
      res :: INT
      res = (l+1)*(l+2)*(l+3)/6
   end

end
