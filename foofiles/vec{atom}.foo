!---------------------------------------------------------------------------
!
! VEC{ATOM}: ATOM vectors
!
! Copyright (C) Dylan Jayatilaka, 1998
!
! This library is free software; you can redistribute it and/or
! modify it under the terms of the GNU Library General Public
! License as published by the Free Software Foundation; either
! version 2 of the License, or (at your option) any later version.
!
! This library is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
! Library General Public License for more details.
!
! You should have received a copy of the GNU Library General Public
! License along with this library; if not, write to the
! Free Software Foundation, Inc., 59 Temple Place - Suite 330,
! Boston, MA  02111-1307, USA.
!
! $Id$
!---------------------------------------------------------------------------

module VEC{ATOM}

   implicit none

   ! Index information arrays; the strange "4" stands for "for" and prevents a
   ! name clash with a procedure of the same name.

   saved_self :: VEC{ATOM}*, private  DEFAULT_NULL

!   index_info_created :: BIN, private DEFAULT(FALSE)
!   atom_4_shell :: VEC{INT}*, private DEFAULT_NULL
!   atom_shell_4_shell :: VEC{INT}*, private DEFAULT_NULL
!   first_shell_4_atom :: VEC{INT}*, private DEFAULT_NULL
!   first_basis_fn_4_shell :: VEC{INT}*, private DEFAULT_NULL
!   last_basis_fn_4_shell  :: VEC{INT}*, private DEFAULT_NULL
!   angular_moment_4_shell :: VEC{INT}*, private DEFAULT_NULL
!   first_basis_fn_4_atom  :: VEC{INT}*, private DEFAULT_NULL
!   last_basis_fn_4_atom   :: VEC{INT}*, private DEFAULT_NULL

   ! Atom connection table, to save work
   connections_for :: VEC{VEC_{INT}}*, private DEFAULT_NULL

contains

!  ******************
!  Allocation methods
!  ******************

   create(dim) ::: get_from(VEC{OBJECT}), leaky
   ! Create space for object
   end

   destroy ::: get_from(VEC{OBJECT}), leaky
   ! Destroy space for object
   end

   create_copy(vec) ::: get_from(VEC{OBJECT}), leaky
   ! Create a replica copy of "vec".
   end

   copy(vec) ::: get_from(VEC{OBJECT}), leaky
   ! Copy "vec".
   end

   nullify_ptr_part ::: get_from(VEC{OBJECT})
   ! Nullify the pointer parts of self
   end

   nullify_bases
   ! Nullify all the bases 
      .nullify_basis_part
      .nullify_slaterbasis_part
      .nullify_coppensbasis_part
   end

   nullify_basis_part
   ! Nullify the basis parts of self
      a :: INT
      do a = 1,.dim
         nullify(self(a).basis)
      end
   end

   nullify_slaterbasis_part
   ! Nullify the slaterbasis parts of self
      a :: INT
      do a = 1,.dim
         nullify(self(a).slaterbasis)
      end
   end

   nullify_coppensbasis_part
   ! Nullify the coppensbasis parts of self
      a :: INT
      do a = 1,.dim
         nullify(self(a).coppensbasis)
      end
   end

   destroy_ptr_part ::: leaky
   ! Destroy the pointer parts of self
      a :: INT
   !  .destroy_interpolator_part
      .nullify_bases
      do a = 1,.dim ! Now we can safely destroy everything .....
         self(a).destroy_ptr_part
      end
   end

   created result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has been created
   end

   destroyed result (res) ::: get_from(OBJECT), inlined_by_foo
   ! Returns true if self has *not* been created
   end

!  **************
!  Set properties
!  **************

   set_defaults ::: get_from(VEC{OBJECT})
   ! Set default values
   end

   set_labels_and_atomic_numbers(labels)
   ! Set "labels" for the atoms and also their atomic numbers.
      labels :: VEC{STR}
      ENSURE(labels.dim==.dim,"wrong length for labels")
      n :: INT
      do n = 1,.dim
        self(n).set_label_and_atomic_number(labels(n))
      end
   end

   set_labels(labels)
   ! Set the "labels" ONLY for the atoms; use the above routine to set the
   ! atomic numbers as well.
      labels :: VEC{STR}
   ENSURE(labels.dim==.dim,"wrong length for labels")
      self.label = labels
   end

   set_recognised_labels(list) ::: leaky
   ! Set "list" to be the list of recognised labels. If all labels are
   ! recognised then "list" is not created.
      list :: VEC{INT}*
      n :: INT
      nullify(list)
      do n = 1,.dim
         if (NOT self(n).has_recognised_label) cycle
         list.append(n)
      end
      if (list.dim==.dim) list.destroy
   end

   set_use_interpolators(use_interp)
   ! Read whether to use interpolators for spherical atom densities
      use_interp :: BIN, IN
      a :: INT

      .use_interpolator = use_interp

      if (.has_all_slater_bases)  then
         do a = 1,.dim
            self(a).slaterbasis.use_interpolator = use_interp
         end
      end

      if (.has_all_coppens_bases) then
         do a = 1,.dim
            self(a).coppensbasis.use_interpolator = use_interp
         end
      end

   end

   set_unique_tags
   ! Set the unqie tags.

      atom_kind :: VEC{VEC_{INT}}*
      a,k,n :: INT

      if (.has_unique_labels) then

         self.tag = self.label

      else

         ! Get the atom kinds
         .make_atom_kind_list(atom_kind)

         ! Label atoms consecutively by kind and number
         do k = 1,atom_kind.dim
         do n = 1,atom_kind(k).element.dim
            a = atom_kind(k)[n]
            if (self(a).is_a_dummy_atom) cycle
            self(a).tag = trim(self(a).chemical_symbol) // trim(n.to_str)
         end
         end

         ! Clean
         atom_kind.destroy

      end

   end

!  ****************************
!  ADP and position/ADP setting
!  ****************************

   set_positions_and_ADPs_to(par)
   ! Set the positional and ADP parameters from "par" of length
   ! 9*n_atoms comprising for each atom positions in the first 3
   ! slots, and ADPs (Uxx, Uyy, Uzz, Uxy, Uxz, Uyz) in the next 6
   ! slots. 
      par :: VEC{REAL}(9*.dim), IN

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 9
         self(a).set_position_and_ADPs_to(par(f:l))
      end

   end

   get_positions_and_ADPs_in(par)
   ! Get the positional and ADP parameters in "par" of length
   ! 9*n_atoms comprising for each atom positions in the first 3
   ! slots, and ADPs (Uxx, Uyy, Uzz, Uxy, Uxz, Uyz) in the next 6
   ! slots. 
      par :: VEC{REAL}(9*.dim), OUT

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 9
         self(a).get_position_and_ADPs_in(par(f:l))
      end

   end

   set_position_and_ADP_errors_to(err)
   ! Set the positional and ADP errors from "err" of length
   ! 9*n_atoms comprising for each atom positions in the first 3
   ! slots, and ADPs (Uxx, Uyy, Uzz, Uxy, Uxz, Uyz) in the next 6
   ! slots. 
      err :: VEC{REAL}(9*.dim), IN

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 9
         self(a).set_position_and_ADP_errors_to(err(f:l))
      end

   end

   get_position_and_ADP_errors_in(err)
   ! Get the positional and ADP errors in "err" of length
   ! 9*n_atoms comprising for each atom positions in the first 3
   ! slots, and ADPs (Uxx, Uyy, Uzz, Uxy, Uxz, Uyz) in the next 6
   ! slots. 
      err :: VEC{REAL}(9*.dim), OUT

      a,f,l :: INT

      l = 0
      do a = 1,.dim
         f = l + 1
         l = l + 9
         self(a).get_position_and_ADP_errors_in(err(f:l))
      end

   end

!  **********************
!  Shrink, expand, append
!  **********************

   shrink(dim)
   ! Shrink the atomvec to dimension "dim", retaining contents.
      self :: PTR
      dim :: INT, IN
      ENSURE(.created,"no self array")
      ENSURE(dim<=.dim,"dim too large")
      old :: VEC{ATOM}*
      n :: INT
      if (dim==.dim) return
      old => self
      nullify(self)
      self.create(dim)
      do n=1,dim
       self(n).copy(old(n))
      end
      old.nullify_basis_part
      old.destroy
   end

   expand(dim) ::: get_from(VEC{OBJECT}), leaky
   ! Expand the vector "self" to "dim". New slots are left undefined.
   end

   append(v) ::: get_from(VEC{OBJECT}), leaky
   ! Expands self and appends the contents of vector "v".
   end

   append(value) ::: get_from(VEC{OBJECT}), leaky
   ! Expands self by 1, and appends the single scalar "value" onto the end.
   end

   prune_element(k) ::: get_from(VEC{OBJECT}), leaky
   ! Removes the single element at position "k" from the vector.
   ! The order of the elements is unchanged.
   end

!  ***********************
!  List-based I/O Routines
!  ***********************

   read_list_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! Read in and process list-based keywords from "stdin". List-based keywords
   ! are those that are intended to apply to each individual element of the list
   ! through a list of "keys" stored in the associated list-element type module.
   ! NOTE: this routine will create the list, if required.
   end

   process_list_keyword(keyword) ::: get_from(VEC{OBJECT}), leaky
   ! Process a list-type "keyword", common to all list-type objects.
   end

   read_data(ignore_braces) ::: get_from(VEC{OBJECT}), leaky
   ! Process the keywords list to read data or commands. If "ignore_braces" is
   ! present then the opening and closing braces, which are normally required,
   ! are ignored.
   end

   data_length result (length) ::: get_from(VEC{OBJECT})
   ! Read ahead in stdin to get the "length" of the data list, i.e. the number
   ! of data items in the list. The data must begin with the first data item,
   ! *not* a "{" symbol.  The order of data items comprising the list is given
   ! by keys defined in the associated list-element type module. The data list
   ! must be terminated by a "}" symbol.
   end

   read_altered_data ::: get_from(VEC{OBJECT}), leaky
   ! Read in a sublist of the complete list, and alter the data for that
   ! sublist.  The order of the data items in the sublist is given by the "keys"
   ! defined in the associated list-element type module.
   end

   read_append_data ::: get_from(VEC{OBJECT}), leaky
   ! Read in a set of data to append to an existing set.
   end

   process_keys ::: get_from(VEC{OBJECT}), leaky
   ! Process the "keys" on each element of the list.
   end

   process_keys_once ::: get_from(VEC{OBJECT})
   ! Process the "keys" just once on an anonymous object. This is useful if the
   ! "keys" set global variables in the list module (e.g. the default order of
   ! lists *within* the list data) as opposed to being keys pertaining to each
   ! element of the list.
   end

   keys_created result (res) ::: get_from(VEC{OBJECT})
   ! Return TRUE if the list-element keys are created.
   end

   set_keys(the_keys) ::: get_from(VEC{OBJECT})
   ! This is for setting the "keys" externally.
   end

   clear_keys ::: get_from(VEC{OBJECT})
   ! This is for destroying the "keys" externally.
   end

   read_keys ::: get_from(VEC{OBJECT})
   ! Read a new set of keys
   end

   put_keys_table ::: get_from(VEC{OBJECT})
   ! Output a generic table based on the "keys"
   end

   put_table_header ::: get_from(VEC{OBJECT})
   ! Put out a table header based on "keys"
   end

   put_table_footer ::: get_from(VEC{OBJECT})
   ! Put out a table footer based on "keys"
   end

   redirect ::: get_from(OBJECT), leaky
   ! Redirect input
   end

   revert ::: get_from(OBJECT), leaky
   ! Revert back to previous stdin file
   end

!  ***************************
!  Non-list based I/O routines
!  ***************************

   read_keywords ::: get_from(VEC{OBJECT}), recursive, leaky
   ! Read in and process normal (non list-type) keywords from "stdin".
   end

   process_keyword(keyword) ::: leaky
   ! Process a normal (non list-type) "keyword".
      self :: PTR
      keyword :: STR
      word :: STR
      word = keyword
      word.to_lower_case
      select case (word)
       case("}") ! do nothing.
       case("find_n_terminal_atoms         "); .find_N_terminal_atoms
       case("find_protein_backbone         "); .find_protein_backbone
       case("put                           "); .put
       case("put_bond_angle_table          "); .put_bond_angle_table
       case("put_bond_length_table         "); .put_bond_length_table
       case("put_coordinates               "); .put_coordinates
       case("put_coordinates_and_charges   "); .put_coordinates_and_charges
       case("put_invariom_labels           "); .put_invariom_labels
       case("put_smiles_invariom_labels    "); .put_smiles_invariom_labels
       case("put_mm_info                   "); .put_mm_info
       case("put_coordinates_and_adps      "); .put_coordinates_and_ADPs
       case("put_torsion_angle_table       "); .put_torsion_angle_table
       case("put_protein_sequence          "); .put_protein_sequence
       case("put_restraint_atoms           "); .put_restraint_atoms
       case("read_cif                      "); .read_CIF
       case("redirect                      "); .redirect
       case("revert                        "); .revert
       case("set_covalent_radii_ccdc       "); ATOM:set_covalent_radii_ccdc
       case("use_interpolators=            "); .read_use_interpolators
       case default;               UNKNOWN(word)
      end
   end

   read_CIF ::: leaky
   ! Read information from a Crystallographic Information File whose name is
   ! read from "stdin".
      self :: PTR
      cif :: CIF*
      found :: BIN
      name :: STR

      ! Read name frxd_geo_220K.cifom stdin
      stdin.read(name)

      ! Create CIF and find data
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(name) ::: leaky
   ! Read information from a Crystallographic Information File "name"
      self :: PTR
      name :: STR, IN

      cif :: CIF*
      found :: BIN

      ! Create the CIF and find data
      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 

      ! Read
      .read_CIF(cif)

      ! Clean
      cif.destroy

   end

   read_CIF(cif) ::: leaky
   ! Read information from a Crystallographic Information File, "cif".
   ! It is an error if there are no atom coordinates in the file.
   ! It is NOT an error if the ADP (thermal) tensors are missing.
   ! NOTE: self is destroyed and created from this file!
      self :: PTR
      cif :: CIF

      fs,fc,fd,fo,fi,fu,fl,fail :: BIN
      IDs,labels,symbols :: VEC{STR}*
      disorder_group :: MAT{STR}*
      dg    :: STR
      i,ind :: INT
      pos,U :: MAT{REAL}*
      U_iso :: VEC{REAL}*
      unit_cell :: UNIT_CELL
      fac,a,b,c :: REAL

      ! Read the site labels FIRST because these seem to correlate with
      ! the anisotropic U's.
      nullify(symbols)
      nullify(labels)
      cif.read_looped_item("_atom_site_type_symbol",symbols,fs)
      cif.read_looped_item("_atom_site_label",labels,fl)
      ENSURE(fs OR fl,"no atom site label information in CIF file")

      ! Destroy the old atom list (if there)
      .destroy

      ! Create the new atom list
      if (symbols.created) then
         .create(symbols.dim)
         .set_labels_and_atomic_numbers(symbols) ! For Z's
         if (labels.created) .set_labels(labels) ! For U's
      else if (labels.created) then
         .create(labels.dim)
         .set_labels_and_atomic_numbers(labels)  ! This may not work
      end
      labels.destroy
      symbols.destroy

      ! Read the site coordinates, and possibly occupancies
      cif.find_looped_item("_atom_site_occupancy",fo)
      if (fo) then
         IDs.create(4)
         IDs = ["_atom_site_fract_x  ", &
                "_atom_site_fract_y  ", &
                "_atom_site_fract_z  ", &
                "_atom_site_occupancy"]
         cif.read_looped_items(IDs,pos,found=fc)
      else
         IDs.create(3)
         IDs = ["_atom_site_fract_x  ", &
                "_atom_site_fract_y  ", &
                "_atom_site_fract_z  "]
         cif.read_looped_items(IDs,pos,found=fc)
      end
      IDs.destroy
      ENSURE(fc,"no atom coordinate information in CIF file")

      ! Assign the CIF info to the atom list
      self.axis_system = "crystal"
      self.position(1) = pos(1,:)
      self.position(2) = pos(2,:)
      self.position(3) = pos(3,:)
      if (fo) self.site_occupancy = pos(4,:)
      pos.destroy

      ! Read the disorder, group if there
      cif.find_looped_item("_atom_site_disorder_group",fd)
      if (fd) then
         IDs.create(1)
         IDs = ["_atom_site_disorder_group"]
         cif.read_looped_items(IDs,disorder_group)
         ENSURE(disorder_group.dim2==.dim,"inconsistent # of _atom_site_disorder_groups")
         do i = 1,disorder_group.dim2
            dg = disorder_group(1,i)
            if (dg==".") then
               self(i).site_disorder_group = 0
            else if (dg.is_int) then
               self(i).site_disorder_group = dg.to_int
            end
         end
         disorder_group.destroy
         IDs.destroy
      end

      ! Read the U_iso values if there
      cif.read_looped_item("_atom_site_U_iso_or_equiv",U_iso,found=fi)
      if (fi) then
         ! Change units if required 
         if (cif.U_iso_is_B_iso) then
            fac = ONE/(EIGHT*PI*PI)
            U_iso = fac*U_iso
         end
         U_iso.convert_from("angstrom^2")
         self.U_iso = U_iso
         self.ADP_axis_system = "crystal"
         U_iso.destroy
      end

      ! Now read U tensor if it is there ...
      IDs.create(6)
      IDs = ["_atom_site_aniso_U_11", &
             "_atom_site_aniso_U_22", &
             "_atom_site_aniso_U_33", &
             "_atom_site_aniso_U_12", &
             "_atom_site_aniso_U_13", &
             "_atom_site_aniso_U_23"]
      cif.read_looped_item("_atom_site_aniso_label",labels,fl)
      cif.read_looped_items(IDs,U,found=fu)

      if (fl AND fu) then

         ! Change U type, if requested
         if (cif.U_is_B) then
            fac = ONE/(EIGHT*PI*PI)
            U = fac*U
         else if (cif.U_is_beta) then
            unit_cell.read_CIF(cif)
            a = unit_cell.length(1)
            b = unit_cell.length(2)
            c = unit_cell.length(3)
            fac = ONE/(TWO*PI*PI)
            U = fac*U
            do i = 1,.dim
               U(1,i) = U(1,i)/(a*a)
               U(2,i) = U(1,i)/(b*b)
               U(3,i) = U(1,i)/(c*c)
               U(4,i) = U(1,i)/(a*b)
               U(5,i) = U(1,i)/(a*c)
               U(6,i) = U(1,i)/(b*c)
            end
         end

         ! Change U units to au^2
         U.convert_from("angstrom^2")

         ! Distinct labels?
         DIE_IF(self(:).label.no_of_unique_elements/=.dim,"the ADPs have non-unique site symbols!")

         ! Match the anisotropic U labels and assign the U tensors
         fail = FALSE
         do i = 1,labels.dim

            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            if (ind<=0) then
               WARN("label "//labels(i).trim//" can't be found, failed to read U's")
               fail = TRUE 
               exit
            end

            ! Assign ADP
            self(ind).ADP_tensor(1,1) = U(1,i)
            self(ind).ADP_tensor(2,2) = U(2,i)
            self(ind).ADP_tensor(3,3) = U(3,i)
            self(ind).ADP_tensor(1,2) = U(4,i)
            self(ind).ADP_tensor(2,1) = U(4,i)
            self(ind).ADP_tensor(1,3) = U(5,i)
            self(ind).ADP_tensor(3,1) = U(5,i)
            self(ind).ADP_tensor(2,3) = U(6,i)
            self(ind).ADP_tensor(3,2) = U(6,i)

         end

         if (NOT fail) then
            self.ADP_axis_system = "crystal"
         else
            do i = 1,labels.dim
            self(i).ADP_tensor = ZERO
            end
         end
      
      end

      if (fu) U.destroy
      if (fl) labels.destroy
      IDs.destroy

   end

   read_CIF_ADPs(name) ::: leaky
   ! Read ADP information from a Crystallographic Information File
   ! called "name"
      self :: PTR
      name :: STR, IN

      cif :: CIF*
      found :: BIN

      cif.create(name)
      cif.open
      cif.find_crystal_data_block(found)
      ENSURE(found,"no crystal data block found") 

      .read_CIF_ADPs(cif)

      cif.destroy

   end

   read_CIF_ADPs(cif) ::: leaky
   ! Read information from a Crystallographic Information File, "cif".
   ! It is an error if there are no atom coordinates in the file.
   ! It is NOT an error if the ADP (thermal) tensors are missing.
   ! NOTE: self is destroyed and created from this file!
      self :: PTR
      cif :: CIF

      fi,fu,fl,fail :: BIN
      IDs,labels :: VEC{STR}*
      i,ind :: INT
      U :: MAT{REAL}*
      U_iso :: VEC{REAL}*
      unit_cell :: UNIT_CELL
      fac,a,b,c :: REAL

      ! Read the U_iso values if there
      cif.read_looped_item("_atom_site_U_iso_or_equiv",U_iso,found=fi)
      if (fi) then
         ! Change units if required 
         if (cif.U_iso_is_B_iso) then
            fac = ONE/(EIGHT*PI*PI)
            U_iso = fac*U_iso
         end
         U_iso.convert_from("angstrom^2")
         self.U_iso = U_iso
         self.ADP_axis_system = "crystal"
         U_iso.destroy
      end

      ! Now read U tensor if it is there ...
      IDs.create(6)
      IDs = ["_atom_site_aniso_U_11", &
             "_atom_site_aniso_U_22", &
             "_atom_site_aniso_U_33", &
             "_atom_site_aniso_U_12", &
             "_atom_site_aniso_U_13", &
             "_atom_site_aniso_U_23"]
      cif.read_looped_item("_atom_site_aniso_label",labels,fl)
      cif.read_looped_items(IDs,U,found=fu)

      if (fl AND fu) then

         ! Change units if required 
         if (cif.U_is_B) then
            fac = ONE/(EIGHT*PI*PI)
            U = fac*U
         else if (cif.U_is_beta) then
            unit_cell.read_CIF(cif)
            a = unit_cell.length(1)
            b = unit_cell.length(2)
            c = unit_cell.length(3)
            fac = ONE/(TWO*PI*PI)
            U = fac*U
            do i = 1,.dim
               U(1,i) = U(1,i)/(a*a)
               U(2,i) = U(1,i)/(b*b)
               U(3,i) = U(1,i)/(c*c)
               U(4,i) = U(1,i)/(a*b)
               U(5,i) = U(1,i)/(a*c)
               U(6,i) = U(1,i)/(b*c)
            end
         end
         U.convert_from("angstrom^2")

         ! Check if distinct labels
         DIE_IF(self(:).label.no_of_unique_elements/=.dim,"for the ADP's, every site symbol must be distinct!")

         ! Match the anisotropic U labels and assign the U tensors
         fail = FALSE
         do i = 1,labels.dim

            ! Find matching index "ind"
            ind = self(:).label.index_of(labels(i))
            if (ind<=0) then
               WARN("label "//labels(i).trim//" can't be found, failed to read U's")
               fail = TRUE 
               exit
            end

            ! Assign ADP
            self(ind).ADP_tensor(1,1) = U(1,i)
            self(ind).ADP_tensor(2,2) = U(2,i)
            self(ind).ADP_tensor(3,3) = U(3,i)
            self(ind).ADP_tensor(1,2) = U(4,i)
            self(ind).ADP_tensor(2,1) = U(4,i)
            self(ind).ADP_tensor(1,3) = U(5,i)
            self(ind).ADP_tensor(3,1) = U(5,i)
            self(ind).ADP_tensor(2,3) = U(6,i)
            self(ind).ADP_tensor(3,2) = U(6,i)

         end

         if (NOT fail) then
            self.ADP_axis_system = "crystal"
         else
            do i = 1,labels.dim
            self(i).ADP_tensor = ZERO
            end
         end
      
      end

      if (fu) U.destroy
      if (fl) labels.destroy
      IDs.destroy

   end

   read_use_interpolators 
   ! Read whether to use interpolators for spherical atom densities
      self :: PTR
      use_interp :: BIN

      stdin.read(use_interp)

      if (.destroyed) return

      .set_use_interpolators(use_interp)

   end

!  *************
!  Resolve bases
!  *************

   resolve_bases(basis,suffix) 
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.  
      basis :: VEC{BASIS}*
      suffix :: STR, optional

      a :: INT

      do a = 1,.dim
         self(a).resolve_basis(basis,suffix)
      end

   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS=>SLATERBASIS)
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.  
   end

   resolve_bases(basis,suffix) ::: get_from(VEC{ATOM}, BASIS=>COPPENSBASIS)
   ! Resolve the basis sets for each atom -- by pointer assigning its basis to
   ! the element in "basis" which matches either the atoms .basis_label, or else
   ! matches a label constructed in a standard way, by joining the atom chemical
   ! symbol with the ":suffix" string.  
   end

!  **************
!  Output methods
!  **************

   put
   ! Output atom information, without full basis set info

      stdout.flush
      stdout.text("*********************")
      stdout.text("Atom list information")
      stdout.text("*********************")
      stdout.flush

      stdout.show("Chemical Formula       =",trim(.chemical_formula(with_spaces=TRUE)))
      stdout.show("No of atoms            =",size(self))
      stdout.show("No of electrons        =",.no_of_electrons)

      if (.has_residue_codes) then; .put_mm_info
      else;                         .put_coordinate_info
      end
      if (.has_restraints)          .put_restraint_atoms

   end

   put_coordinate_info
   ! Output atom coordinate information, including bond lengths, angles
      .put_coordinates
      if (.has_ADP_tensors) .put_ADPs
      .put_bond_length_table
      .put_bond_angle_table
      .put_torsion_angle_table
   end

!  Coordinate information

   put_coordinates
   ! Output the atom coordinates information.
      if (NOT .has_disorder) then; .put_coords_disorder_n
      else;                        .put_coords_disorder_y
      end
   end

   put_coords_disorder_n ::: private
   ! Output the atom coordinates information without disorder

      fac :: REAL
      xyz :: MAT{REAL}*
      Z  :: VEC{REAL}*
      ID :: VEC{STR}*
      table :: VEC{TABLE_COLUMN}*

      ! Use angstroms
      fac = STR:conversion_factor("angstrom")

      ! Get table column data
      ID.create(.dim);    ID  = self.tag
      Z.create(.dim);     Z   = self.nuclear_charge
      xyz.create(.dim,3); .get_geometry(xyz); xyz = xyz * fac

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      stdout.flush
      stdout.show("No. of atoms =",.dim)
      stdout.flush

      ! Table headings
      table.create(5)
      table(1).set_heading("ID")
      table(2).set_heading("Z")
      table(2).set_subheading("/au")
      table(2).set_real_precision(1)
      table(3).set_heading("x")
      table(4).set_heading("y")
      table(4).set_subheading(trim("/A"))
      table(5).set_heading("z")

      ! Set table column data
      table(1).set_values(ID)
      table(2).set_values(Z)
      table(3).set_values(xyz(:,1))
      table(4).set_values(xyz(:,2))
      table(5).set_values(xyz(:,3))

      ! Make the table
      table.put

      ! Clean
      table.destroy
      xyz.destroy
      Z.destroy
      ID.destroy

   end

   put_coords_disorder_y ::: private
   ! Output the atom coordinates information with disorder

      fac :: REAL
      xyz :: MAT{REAL}*
      Z,occ  :: VEC{REAL}*
      ID :: VEC{STR}*
      grp :: VEC{INT}*
      table :: VEC{TABLE_COLUMN}*

      ! Use angstroms
      fac = STR:conversion_factor("angstrom")

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("================")
      stdout.text("Atom coordinates")
      stdout.text("================")
      stdout.flush
      stdout.show("No. of atoms =",.dim)
      stdout.flush

      ! Get table column data
      ID.create(.dim);    ID  = self.tag
      Z.create(.dim);     Z   = self.nuclear_charge
      grp.create(.dim);   grp = self.site_disorder_group
      occ.create(.dim);   occ = self.site_occupancy
      xyz.create(.dim,3); .get_geometry(xyz); xyz = xyz * fac

      ! Table headings
      table.create(7)
      table(1).set_heading("ID")
      table(2).set_heading("Z")
      table(2).set_subhead("/au")
      table(2).set_real_precision(1)
      table(3).set_heading("Disorder")
      table(3).set_subhead("group #")
      table(4).set_heading("Site")
      table(4).set_subhead("occupancy")
      table(5).set_heading("x")
      table(6).set_heading("y")
      table(6).set_subhead(trim("/A"))
      table(7).set_heading("z")

      ! Set table column data
      table(1).set_values(ID)
      table(2).set_values(Z)
      table(3).set_values(grp)
      table(4).set_values(occ)
      table(5).set_values(xyz(:,1))
      table(6).set_values(xyz(:,2))
      table(7).set_values(xyz(:,3))

      ! Make the table
      table.put

      ! Clean
      table.destroy
      xyz.destroy
      occ.destroy
      grp.destroy
      Z.destroy
      ID.destroy

   end

   put_ADPs
   ! Output the ADP information
   ! Output position and ADP errors if there.
   ! Always use Angstrom units for display.

      fac,fac2 :: REAL
      ID :: VEC{STR}*
      Uxx,Uyy,Uzz,Uxy,Uxz,Uyz :: VEC{REAL}*
      Dxx,Dyy,Dzz,Dxy,Dxz,Dyz :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom")
      fac2 = fac*fac

      ! Create columns
      ID.create(.dim)
      Uxx.create(.dim); Uyy.create(.dim); Uzz.create(.dim)
      Uxy.create(.dim); Uxz.create(.dim); Uyz.create(.dim)
      Dxx.create(.dim); Dyy.create(.dim); Dzz.create(.dim)
      Dxy.create(.dim); Dxz.create(.dim); Dyz.create(.dim)

      ! Get table column data
      ID  = .tag
      Uxx = fac2*.ADP_tensor(1,1); Dxx = fac2*.ADP_error(1)
      Uyy = fac2*.ADP_tensor(2,2); Dyy = fac2*.ADP_error(2)
      Uzz = fac2*.ADP_tensor(3,3); Dzz = fac2*.ADP_error(3)
      Uxy = fac2*.ADP_tensor(1,2); Dxy = fac2*.ADP_error(4)
      Uxz = fac2*.ADP_tensor(1,3); Dxz = fac2*.ADP_error(5)
      Uyz = fac2*.ADP_tensor(2,3); Dyz = fac2*.ADP_error(6)

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("=====================================")
      stdout.text("Atomic displacement parameters (ADPs)")
      stdout.text("=====================================")
      stdout.flush
      stdout.text("The ADPs are referred cartesian axes.")
      stdout.flush

      ! Set table headings & data
      table.create(7)
      table.set_spacing(2)

      if (NOT (.has_position_errors OR .has_ADP_errors)) then

         table(1).set_heading("ID");  table(1).set_values(ID)
         table(2).set_heading("Uxx"); table(2).set_values(Uxx)
         table(3).set_heading("Uyy"); table(3).set_values(Uyy)
         table(4).set_heading("Uzz"); table(4).set_values(Uzz)
         table(5).set_heading("Uxy"); table(5).set_values(Uxy)
         table(6).set_heading("Uxz"); table(6).set_values(Uxz)
         table(7).set_heading("Uyz"); table(7).set_values(Uyz)

      else ! have position/ADP errors

         table(1).set_heading("ID");  table(1).set_values(ID)
         table(2).set_heading("Uxx"); table(2).set_values_and_errors(Uxx,Dxx)
         table(3).set_heading("Uyy"); table(3).set_values_and_errors(Uyy,Dyy)
         table(4).set_heading("Uzz"); table(4).set_values_and_errors(Uzz,Dzz)
         table(5).set_heading("Uxy"); table(5).set_values_and_errors(Uxy,Dxy)
         table(6).set_heading("Uxz"); table(6).set_values_and_errors(Uxz,Dxz)
         table(7).set_heading("Uyz"); table(7).set_values_and_errors(Uyz,Dyz)

      end
   
      ! Units headings
      table(4).set_subhead(trim("/A^2"))

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      Dyz.destroy; Dxz.destroy; Dxy.destroy
      Dzz.destroy; Dyy.destroy; Dxx.destroy
      Uyz.destroy; Uxz.destroy; Uxy.destroy
      Uzz.destroy; Uyy.destroy; Uxx.destroy
      ID.destroy

   end

   put_coordinates_and_ADPs(no_header)
   ! Output the atom coordinates and ADP information
   ! Output position and ADp errors if there.
   ! Always use Angstrom units for display.
      no_header :: BIN, optional, IN

      fac,fac2 :: REAL
      ID :: VEC{STR}*
      xx,yy,zz :: VEC{REAL}*
      dx,dy,dz :: VEC{REAL}*
      Uxx,Uyy,Uzz,Uxy,Uxz,Uyz :: VEC{REAL}*
      Dxx,Dyy,Dzz,Dxy,Dxz,Dyz :: VEC{REAL}*
      table :: VEC{TABLE_COLUMN}*
      header :: BIN

      header = TRUE
      if (present(no_header)) header = NOT no_header

      ! Use angstroms/angstrom^2
      fac  = STR:conversion_factor("angstrom")
      fac2 = fac*fac

      ! Create columns
      ID.create(.dim)
      xx.create(.dim); yy.create(.dim); zz.create(.dim)
      dx.create(.dim); dy.create(.dim); dz.create(.dim)
      Uxx.create(.dim); Uyy.create(.dim); Uzz.create(.dim)
      Uxy.create(.dim); Uxz.create(.dim); Uyz.create(.dim)
      Dxx.create(.dim); Dyy.create(.dim); Dzz.create(.dim)
      Dxy.create(.dim); Dxz.create(.dim); Dyz.create(.dim)

      ! Get table column data
      ID  = .tag
      xx  = fac*.position(1);  dx  = fac *.position_error(1)
      yy  = fac*.position(2);  dy  = fac *.position_error(2)
      zz  = fac*.position(3);  dz  = fac *.position_error(3)
      Uxx = fac2*.ADP_tensor(1,1); Dxx = fac2*.ADP_error(1)
      Uyy = fac2*.ADP_tensor(2,2); Dyy = fac2*.ADP_error(2)
      Uzz = fac2*.ADP_tensor(3,3); Dzz = fac2*.ADP_error(3)
      Uxy = fac2*.ADP_tensor(1,2); Dxy = fac2*.ADP_error(4)
      Uxz = fac2*.ADP_tensor(1,3); Dxz = fac2*.ADP_error(5)
      Uyz = fac2*.ADP_tensor(2,3); Dyz = fac2*.ADP_error(6)

      ! Title
      if (header) then
      stdout.flush
      stdout.flush
      stdout.text("=========================")
      stdout.text("Atom coordinates and ADPs")
      stdout.text("=========================")
      stdout.flush
      stdout.text("The coordinates and ADPs are referred to cartesian axes.")
      stdout.flush
      stdout.show("No. of atoms =",.dim)
      stdout.flush
      end

      ! Set table headings & data
      table.create(10)
      table.set_spacing(2)

      if (NOT (.has_position_errors OR .has_ADP_errors)) then

          table(1).set_heading("ID");   table(1).set_values(ID)
          table(2).set_heading("x");    table(2).set_values(xx)
          table(3).set_heading("y");    table(3).set_values(yy)
          table(4).set_heading("z");    table(4).set_values(zz)
          table(5).set_heading("Uxx");  table(5).set_values(Uxx)
          table(6).set_heading("Uyy");  table(6).set_values(Uyy)
          table(7).set_heading("Uzz");  table(7).set_values(Uzz)
          table(8).set_heading("Uxy");  table(8).set_values(Uxy)
          table(9).set_heading("Uxz");  table(9).set_values(Uxz)
         table(10).set_heading("Uyz"); table(10).set_values(Uyz)

      else ! have position/ADP errors

          table(1).set_heading("ID");   table(1).set_values(ID)
          table(2).set_heading("x");    table(2).set_values_and_errors(xx,dx)
          table(3).set_heading("y");    table(3).set_values_and_errors(yy,dy)
          table(4).set_heading("z");    table(4).set_values_and_errors(zz,dz)
          table(5).set_heading("Uxx");  table(5).set_values_and_errors(Uxx,Dxx)
          table(6).set_heading("Uyy");  table(6).set_values_and_errors(Uyy,Dyy)
          table(7).set_heading("Uzz");  table(7).set_values_and_errors(Uzz,Dzz)
          table(8).set_heading("Uxy");  table(8).set_values_and_errors(Uxy,Dxy)
          table(9).set_heading("Uxz");  table(9).set_values_and_errors(Uxz,Dxz)
         table(10).set_heading("Uyz"); table(10).set_values_and_errors(Uyz,Dyz)

      end
   
      ! Units headings
      table(3).set_subhead(trim("/A"))
      table(7).set_subhead(trim("/A^2"))

      ! Make the table
      table.put

      ! Clean
      table.clear_columns
      table.destroy
      Dyz.destroy; Dxz.destroy; Dxy.destroy
      Dzz.destroy; Dyy.destroy; Dxx.destroy
      Uyz.destroy; Uxz.destroy; Uxy.destroy
      Uzz.destroy; Uyy.destroy; Uxx.destroy
      dz.destroy; dy.destroy; dx.destroy
      zz.destroy; yy.destroy; xx.destroy
      ID.destroy

   end

   put_pdb(pdbfile)
   ! Output the atoms in pdb file format to "pdbfile" (blame Birger)
      pdbfile :: TEXTFILE*

      i,in,ic,ip,len_code,len_pnum,element_len :: INT
      label,element_name,residue_number,code,three_letter_code,position_symbol,position_number :: STR

      ! Save PDB settings for later
      pdbfile.save

      ! Loop over atoms
      do i = 1,.dim

         ! The ATOM number
         pdbfile.put("ATOM",width=4)
         pdbfile.put(i,width=7)

         ! Start to analyse the atom label 
         label = self(i).label
       ! print *,"label =",trim(label)

         ! Get start of atom index, hence the element name
         label.replace_all("(",'')
         label.replace_all(")",'')
         in = label.index_of_digit  
         DIE_IF(in==0,"no atom index in atom label: "//trim(label))
         ! Get rid of left bracket
         element_name = label(1:in-1)
       ! print *,"in =",in
       ! print *,"element_name =",trim(element_name)

         ! Get start of residue code, hence the residue number
         ic = label(in:).index_of_nondigit 
         DIE_IF(ic==0,"no residue code in atom label: "//trim(label))
         ic = ic + in - 1
         residue_number = label(in:ic-1)
       ! print *,"ic =",ic
       ! print *,"residue_number =",trim(residue_number)

         ! Get start of position symbol, hence residue code, position
         ! symbol and position number (could be blank)
         ! position symbols are alpha (a)
         ! position symbols are beta (b)
         ! position symbols are gamma (c,g)
         ! position symbols are delta (d)
         ! position symbols are epsilon (e)
         ! position symbols are nu (n)
         ! position symbols are terminal (t)
         ! position symbols are zeta (z)
         ! position symbols are peptide bond (')

         ip = label(ic:).index_of_character_in("'abcgdentz")
         if (ip/=0) then
            ip = ip + ic - 1
            code = label(ic:ip-1)
            position_symbol = label(ip:ip)
            position_number = label(ip+1:)
         else
            code = label(ic:)
            position_symbol = " "
            position_number = " "
         end
       ! print *,"ip =",ip
       ! print *,"code =",trim(code)
       ! print *,"position_symbol =",trim(position_symbol)
       ! print *,"position_number =",trim(position_number)

         ! Do some checks ...
         len_code = len_trim(code)
         DIE_IF(NOT (len_code==1 OR len_code==3),"residue code must be 1 or 3 characters: "//trim(label))
         len_pnum = len_trim(position_number)
         DIE_IF(len_pnum>1,"position number code cannot exceed 1 character: "//trim(label))
         if (position_number/=" ") then
         DIE_IF(NOT position_number.is_included_in("123456789"),"unknown position number: "//trim(label))
         end

         ! If the code is a one letter code, convert it
         if (len_code == 3) then
            select case (code)
               case ("UNK","AIB","IVA","WAT","EOH","TER","DLE","DVA","FOR","ETA")
               case ("ALA","ARG","GLN","GLY","VAL","LEU","ILE","SER","THR","CYS")
               case ("MET","PRO","HIS","ASN","GLU","ASP","PHE","TRP","TYR","LYS")
               case ("ACD","HSE","ACE","HYP","HYL","ALB","ALI","ABU","ARO","ORN")
               case ("ASX","PCA","BAS","SAR","BET","TAU","THY","GLX","HET")
               case default; DIE("unknown three letter residue code: "//trim(code))
            end 
            three_letter_code = code
         else if (len_code == 1) then
            select case (code)
               case ("X"); three_letter_code = "UNK"
               case ("~"); three_letter_code = "WAT"
               case ("_"); three_letter_code = "EOH"
               case ("B"); three_letter_code = "DLE"
               case ("O"); three_letter_code = "DVA"
               case ("U"); three_letter_code = "AIB"
               case ("A"); three_letter_code = "ALA"
               case ("R"); three_letter_code = "ARG"
               case ("Q"); three_letter_code = "GLN"
               case ("G"); three_letter_code = "GLY"
               case ("V"); three_letter_code = "VAL"
               case ("L"); three_letter_code = "LEU"
               case ("I"); three_letter_code = "ILE"
               case ("J"); three_letter_code = "IVA"
               case ("S"); three_letter_code = "SER"
               case ("T"); three_letter_code = "THR"
               case ("C"); three_letter_code = "CYS"
               case ("M"); three_letter_code = "MET"
               case ("P"); three_letter_code = "PRO"
               case ("H"); three_letter_code = "HIS"
               case ("N"); three_letter_code = "ASN"
               case ("E"); three_letter_code = "GLU"
               case ("D"); three_letter_code = "ASP"
               case ("F"); three_letter_code = "PHE"
               case ("W"); three_letter_code = "TRP"
               case ("Y"); three_letter_code = "TYR"
               case ("K"); three_letter_code = "LYS"
               case ("Z"); three_letter_code = "TER"
               case default; DIE("unknown one letter residue code: "//trim(code))
            end 
         else
            DIE("code must be one or three characters")
         end 

         ! Print the new atom label from one read in
         pdbfile.tab(width=1)
         if (position_number==" ") then
         pdbfile.tab(width=1)
         else
         pdbfile.put(position_number,width=1,left=TRUE)
         end
         pdbfile.put(element_name,width=len_trim(element_name),left=TRUE)
         if (position_symbol.is_included_in("'abcgdentz")) then 
         position_symbol.to_upper_case
         pdbfile.put(position_symbol,width=1,left=TRUE)
         pdbfile.tab(width=1)
         else
         pdbfile.tab(width=2)
         end
         element_len = len_trim(element_name)
         if (element_len == 1) then
         pdbfile.tab(width=1)
         end
         pdbfile.put(three_letter_code,width=3,left=TRUE)
         pdbfile.tab(width=2)
         pdbfile.put(residue_number,width=4)
         pdbfile.tab(width=4)
         pdbfile.set_real_precision(3)
         pdbfile.set_real_width(8)
         pdbfile.put(self(i).position(1).to_units("angstrom"))
         pdbfile.put(self(i).position(2).to_units("angstrom"))
         pdbfile.put(self(i).position(3).to_units("angstrom"))
         pdbfile.set_real_precision(2)
         pdbfile.set_real_width(6)
         pdbfile.put(self(i).site_occupancy)
         pdbfile.put(8*PI*PI*self(i).U_iso)
         pdbfile.put(self(i).chemical_symbol,width=12)
         pdbfile.flush

         ! Print Anisotropic U's if non-hydrogen
         if (self(i).atomic_number==1) cycle

         pdbfile.put("ANISOU",width=6)
         pdbfile.put(i,width=5)
         pdbfile.tab(width=1)
         if (position_number==" ") then
         pdbfile.tab(width=1)
         else
         pdbfile.put(position_number,width=1,left=TRUE)
         end
         pdbfile.put(element_name,width=len_trim(element_name),left=TRUE)
         if (position_symbol.is_included_in("'ABCGDENTZ")) then 
         position_symbol.to_upper_case
         pdbfile.put(position_symbol,width=1,left=TRUE)
         pdbfile.tab(width=1)
         else
         pdbfile.tab(width=2)
         end
         element_len = len_trim(element_name)
         if (element_len == 1) then
         pdbfile.tab(width=1)
         end
         pdbfile.put(three_letter_code,width=3,left=TRUE)
         pdbfile.tab(width=2)
         pdbfile.put(residue_number,width=4)
         pdbfile.tab(width=2)
         pdbfile.set_int_width(7)

         ! Order for the ADP's .......
         ! u11 u22 u33 u12 u13 u23 XD-format
         ! u11 u22 u33 u12 u23 u13 SHELX
         ! u11 u22 u33 u13 u23 u12 PDB-format
         pdbfile.put(nint(self(i).ADP_tensor(1,1).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(2,2).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(3,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(1,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(2,3).to_units("angstrom^2")*10000))
         pdbfile.put(nint(self(i).ADP_tensor(1,2).to_units("angstrom^2")*10000))

         ! Last thing on line, chemical symbol
         pdbfile.put(self(i).chemical_symbol,width=8)

         ! Flush the line
         pdbfile.flush 

      end
      pdbfile.unsave
   end

   put_coordinates_and_charges
   ! Output the atom coordinate information
      .put_coords_and_charges
      .put_coords_and_charges(angstrom=TRUE)
   end

   put_coords_and_charges(angstrom) ::: private
   ! Output the atom coordinates and charges
      angstrom :: BIN, optional
      i :: INT
      in_angstrom :: BIN
      in_angstrom = FALSE
      if (present(angstrom)) in_angstrom = angstrom
      stdout.flush
      if (NOT in_angstrom) then
      stdout.text("Atom list information:")
      else
      stdout.text("Atom list information (in angstrom):")
      end
      stdout.dash(int_fields=3,real_fields=4)
      stdout.put("#",int_width=TRUE)
      stdout.put("ID",int_width=TRUE)
      stdout.put("Z",int_width=TRUE)
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("charge")
      stdout.flush
      stdout.dash(int_fields=3,real_fields=4)
      do i = 1,.dim
         stdout.put(i)
         stdout.put(self(i).label,int_width=TRUE)
         stdout.put(self(i).nuclear_charge,int_width=TRUE)
         if (NOT in_angstrom) then
         stdout.put(self(i).position(1))
         stdout.put(self(i).position(2))
         stdout.put(self(i).position(3))
         else
         stdout.put(self(i).position(1).to_units("angstrom"))
         stdout.put(self(i).position(2).to_units("angstrom"))
         stdout.put(self(i).position(3).to_units("angstrom"))
         end
         stdout.put(self(i).charge)
         stdout.flush
      end
      stdout.dash(int_fields=3,real_fields=4)
   end

!  Bond lengths

   put_bond_length_table
   ! Output the bond length table.

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      has_unique_labels :: BIN
      n_kind,k1,k2,n_bonds :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist :: VEC{REAL}*
      pair :: MAT{INT}*

      ! Anything to do?
      if (.dim<2) return
      if (.no_of_bonds<1) return

      ! Has unique labels?
      has_unique_labels = .has_unique_labels

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("============")
      stdout.text("Bond lengths")
      stdout.text("============")
      stdout.flush
      stdout.text(". The bond-detection criteria is the same as used")
      stdout.text("  by the Cambridge Structural Database (CSD).")
      stdout.flush
      if (has_unique_labels) then
      stdout.text(". Unique labels have been set for each atom.")
      stdout.text("  Those labels are used below.")
      else
      stdout.text(". Unique labels have not been set for each atom.")
      stdout.text("  Therefore, atom number tags are used below.")
      end
      stdout.flush
      stdout.show("No. of bonds =",.no_of_bonds)
      stdout.flush

      ! Get atom kind list
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(7)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self.tag)

      table(5).set_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/A")
      table(7).set_width_from(ONE)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,atom_kind,k1,k2)
         dist = dist*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         table(7).set_values(dist)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      atom_kind.destroy

   end

   put_bond_length_table(covariance,parentheses)
   ! Output the bond length table with errors, given the "covariance"
   ! matrix between all atomic positions. Set "paretheses" FALSE if
   ! you want errors without them.
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, IN, optional

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      n_kind,k1,k2,n_bonds :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      dist,esds :: VEC{REAL}*
      pair :: MAT{INT}*
      use_brackets :: BIN

      ! Anything to do?
      if (.dim<2) return
      if (.no_of_bonds<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("============")
      stdout.text("Bond lengths")
      stdout.text("============")
      stdout.flush
      stdout.show("No. of bonds =",.no_of_bonds)
      stdout.flush
      stdout.text("The bond-detection criteria is the same as used")
      stdout.text("by the Cambridge Structural Database (CSD).")
      stdout.flush
      if (.has_unique_labels) then
      stdout.text("You have set unique labels for each atom.")
      stdout.text("Those labels are used below.")
      else
      stdout.text("You have not set unique lables for each atom.")
      stdout.text("Therefore, atom number tags are used below.")
      end
      stdout.flush

      ! Get atom kind list
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(7)
      else;                   table.create(8)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(self.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_heading("B")
      table(3).set_width(table(1).width)
      table(3).set_left_justify(TRUE)

      table(4).set_heading("A")
      table(4).set_width_from(self.tag)

      table(5).set_spacing(0)
      table(5).set_heading("--")
      table(5).set_width(2)

      table(6).set_heading("B")
      table(6).set_width(table(4).width)
      table(6).set_left_justify(TRUE)

      table(7).set_heading("R(A--B)")
      table(7).set_subheading("/A")
      table(7).set_width_from(ONE)

      if (NOT use_brackets) then
      table(8).set_heading("Error")
      table(8).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = k1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_atoms(pair,dist,esds,atom_kind,k1,k2,covariance) ! leaky
         dist = dist*ANGSTROM_PER_BOHR
         esds = esds*ANGSTROM_PER_BOHR

         ! No of bonds in this class
         n_bonds = dist.dim
         if (n_bonds==0) then
            esds.destroy
            dist.destroy
            pair.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_bonds,2)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol

         ! Labels
         labels.create(n_bonds,2)
         labels(:,1) = self(pair(:,1)).tag
         labels(:,2) = self(pair(:,2)).tag

         ! Dashes
         dash.create(n_bonds)
         dsh1.create(n_bonds)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table(1).set_values(symbols(:,1))
         table(2).set_values(dsh1)
         table(3).set_values(symbols(:,2))
         table(4).set_values(labels(:,1))
         table(5).set_values(dash)
         table(6).set_values(labels(:,2))
         if (use_brackets) then
         table(7).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(7).set_values_and_errors(dist,esds)
         else
         table(7).set_values(dist)
         table(8).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         dist.destroy
         pair.destroy

      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.clear_columns
      table.destroy
      atom_kind.destroy

   end

   get_bonded_atoms(pair,dist,atom_kind,k1,k2) ::: leaky, private
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them. The pair has "atom_kind" of "k1" and "k2", respectively.
      pair :: MAT{INT}*
      dist :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2 :: INT, IN

      i1,i2,a1,a2, n :: INT

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2<=a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2<=a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   = .bond_distance(a1,a2)

         end
      end

   end

   get_bonded_atoms(pair,dist,esds,atom_kind,k1,k2,covariance) ::: leaky, private
   ! Get the bonded-atom "pair"s, and the distances "dist" between
   ! them, and the associated "esds". The pair has "atom_kind" of "k1"
   ! and "k2", respectively. The "covariance" matrix for *all* atom
   ! coordinates is also given.
      pair :: MAT{INT}*
      dist,esds :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2 :: INT, IN
      covariance :: MAT{REAL}

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,a1,a2, n :: INT
      err :: REAL
      der :: VEC{REAL}(6)
      cov :: MAT{REAL}(6,6)

      ! How many pairs, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2<=a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            ! Count
            n = n + 1

         end
      end

      ! Allocate
      pair.create(n,2)
      dist.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2<=a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            ! Extract covariances for atom a, b positions
            covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2])

            ! Make error
            .bond_distance_deriv(a1,a2,der)
            err = dot_product(der,matmul(cov,der))
            err = sqrt(err)
            err.convert_to("angstrom")

            ! Add the data
            n = n + 1
            pair(n,1) = a1
            pair(n,2) = a2
            dist(n)   = .bond_distance(a1,a2)
            esds(n)   = err

         end
      end

   end

!  Bond angles

   put_bond_angle_table
   ! Output the bond angle table.

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      n_kind,k1,k2,k3,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      triple :: MAT{INT}*
      angle :: VEC{REAL}*
      val :: STR

      if (.dim<3) return
      if (.no_of_bonds<1) return

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===========")
      stdout.text("Bond Angles")
      stdout.text("===========")
      stdout.flush
      stdout.text(". Atom B of Angle(A--B--C) is the middle atom.")
      stdout.flush
      if (.has_unique_labels) then
      stdout.text(". You have set unique labels for each atom.")
      stdout.text("  Those labels are used below.")
      else
      stdout.text(". You have not set unique labels for each atom.")
      stdout.text("  Therefore, atom number tags are used below.")
      end
      stdout.flush
      stdout.show("No. of angles =",.no_of_angles)
      stdout.flush

      ! Get atom kind list 
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(11)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width(table(2).width)
      table(5).set_left_justify(TRUE)

      table(6).set_heading("A")
      table(6).set_width_from(self(.angle_outer_atoms).tag)

      table(7).set_spacing(0)
      table(7).set_heading("--")
      table(7).set_width(2)

      table(8).set_spacing(0)
      table(8).set_heading("B")
      table(8).set_width_from(self(.angle_center_atoms).tag)
      w = table(8).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(8).set_heading(val(1:w))

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("C")
      table(10).set_width_from(self(.angle_outer_atoms).tag)
      table(10).set_left_justify(TRUE)

      table(11).set_heading("Angle(A--B--C)")
      table(11).set_subheading("/degree")
      table(11).set_width_from(ONE)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,atom_kind,k1,k2,k3)
         angle = angle*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol
         symbols(1,3) = self(atom_kind(k3)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,3)
         labels(:,1) = self(triple(:,1)).tag
         labels(:,2) = self(triple(:,2)).tag
         labels(:,3) = self(triple(:,3)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(labels(:,1))
         table( 7).set_values(dash)
         table( 8).set_values(labels(:,2))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,3))
         table(11).set_values(angle)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      atom_kind.destroy

   end

   put_bond_angle_table(covariance,parentheses)
   ! Output the bond angle table with errors given the "covariance"
   ! matrix between all atomic positions. Set "parentheses" FALSE if
   ! you don't want them for errors.
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, IN, optional

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      n_kind,k1,k2,k3,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      angle,esds :: VEC{REAL}*
      triple :: MAT{INT}*
      val :: STR
      use_brackets :: BIN

      if (.dim<3) return
      if (.no_of_bonds<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("===========")
      stdout.text("Bond Angles")
      stdout.text("===========")
      stdout.flush
      stdout.show("No. of angles =",.no_of_angles)
      stdout.flush
      stdout.text("Atom B of Angle(A--B--C) is the middle atom.")
      stdout.flush
      if (.has_unique_labels) then
      stdout.text("You have set unique labels for each atom.")
      stdout.text("Those labels are used below.")
      else
      stdout.text("You have not set unique labels for each atom.")
      stdout.text("Therefore, atom number tags are used below.")
      end
      stdout.flush

      ! Get atom kind list 
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(11)
      else;                   table.create(12)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width(table(2).width)
      table(5).set_left_justify(TRUE)

      table(6).set_heading("A")
      table(6).set_width_from(self(.angle_outer_atoms).tag)

      table(7).set_spacing(0)
      table(7).set_heading("--")
      table(7).set_width(2)

      table(8).set_spacing(0)
      table(8).set_heading("B")
      table(8).set_width_from(self(.angle_center_atoms).tag)
      w = table(8).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(8).set_heading(val(1:w))

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("C")
      table(10).set_width_from(self(.angle_outer_atoms).tag)
      table(10).set_left_justify(TRUE)

      table(11).set_heading("Angle(A--B--C)")
      table(11).set_subheading("/degree")
      table(11).set_width_from(ONE)

      if (NOT use_brackets) then
      table(12).set_heading("Error")
      table(12).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_angles(triple,angle,esds,atom_kind,k1,k2,k3,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  = esds *DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            triple.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,3)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol
         symbols(1,3) = self(atom_kind(k3)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,3)
         labels(:,1) = self(triple(:,1)).tag
         labels(:,2) = self(triple(:,2)).tag
         labels(:,3) = self(triple(:,3)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(labels(:,1))
         table( 7).set_values(dash)
         table( 8).set_values(labels(:,2))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,3))
         if (use_brackets) then
         table(11).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(11).set_values_and_errors(angle,esds)
         else
         table(11).set_values(angle)
         table(12).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         triple.destroy

      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      atom_kind.destroy

   end

   get_bonded_angles(triple,angle,atom_kind,k1,k2,k3) ::: leaky, private
   ! Get the bonded-atom "triple"s, and the "angles" between them. The
   ! triple has "atom_kind" of "k1", "k2", and "k3", respectively.
      triple :: MAT{INT}*
      angle :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2,k3 :: INT, IN

      i1,i2,i3,a1,a2,a3, n :: INT

      ! How many triples, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (a3<a1) cycle

               ! Count
               n = n + 1

            end
         end
      end

      ! Allocate
      triple.create(n,3)
      angle.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (a3<a1) cycle

               ! Add data
               n = n + 1
               triple(n,1) = a1
               triple(n,2) = a2
               triple(n,3) = a3
               angle(n) = .bond_angle(a1,a2,a3)

            end
         end
      end

   end

   get_bonded_angles(triple,angle,esds,atom_kind,k1,k2,k3,covariance) ::: leaky, private
   ! Get the bonded-atom "triple"s, and the "angles" between them, and
   ! the associated "esds". The triple has "atom_kind" of "k1", "k2",
   ! and "k3", respectively. The "covariance" matrix between *all*
   ! atom coordinates is also given.
      triple :: MAT{INT}*
      angle,esds :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2,k3 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,i3,a1,a2,a3, n :: INT
      err :: REAL
      der :: VEC{REAL}(9)
      cov :: MAT{REAL}(9,9)

      ! How many triples, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (a3<a1) cycle

               ! Count
               n = n + 1

            end
         end
      end

      ! Allocate
      triple.create(n,3)
      angle.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle
               if (a3<a1) cycle

               ! Extract covariances for atoms a, b, c
               covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3])

               ! Make error
               .bond_angle_deriv(a1,a2,a3,der)
               err = dot_product(der,matmul(cov,der))
               if (err<ZERO) then
                  err = ZERO
               end
               err = sqrt(err)

               ! Add data
               n = n + 1
               triple(n,1) = a1
               triple(n,2) = a2
               triple(n,3) = a3
               angle(n)    = .bond_angle(a1,a2,a3)
               esds(n)     = err

            end
         end
      end

   end

!  Torsions angles

   put_torsion_angle_table
   ! Output the torsion angle table.

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      n_kind,k1,k2,k3,k4,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      quad :: MAT{INT}*
      angle :: VEC{REAL}*
      val :: STR

      if (.dim<4) return
      if (.no_of_torsion_angles<1) return

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============")
      stdout.text("Torsion angles")
      stdout.text("==============")
      stdout.flush
      stdout.show("No. of angles =",.no_of_torsion_angles)
      stdout.flush
      stdout.text("The angle shown is the one that looking down B->C")
      stdout.text("i.e. it's the one between r(A)-r(B) and r(D)-r(C).")
      stdout.flush
      stdout.text("The angle is +ve if r(D)-r(C) is clockwise of r(A)-r(B).")
      if (.has_unique_labels) then
      stdout.flush
      stdout.text("You have set unique labels for each atom.")
      stdout.text("Those labels are used below.")
      else
      stdout.text("You have not set unique labels for each atom.")
      stdout.text("Therefore, atom number tags are used below.")
      end
      stdout.flush

      ! Get atom kind list 
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      table.create(15)

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width_from(.chemical_symbols)

      table(6).set_spacing(0)
      table(6).set_heading("--")
      table(6).set_width(2)

      table(7).set_spacing(0)
      table(7).set_heading("D")
      table(7).set_width(table(2).width)
      table(7).set_left_justify(TRUE)

      table(8).set_heading("A")
      table(8).set_width_from(self(.torsion_angle_1st_atoms).tag)

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("B")
      table(10).set_width_from(self(.torsion_angle_2nd_atoms).tag)
      w = table(10).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(10).set_heading(val(1:w))

      table(11).set_spacing(0)
      table(11).set_heading("--")
      table(11).set_width(2)

      table(12).set_spacing(0)
      table(12).set_heading("C")
      table(12).set_width_from(self(.torsion_angle_3rd_atoms).tag)
      w = table(12).width
      val = "C"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(12).set_heading(val(1:w))

      table(13).set_spacing(0)
      table(13).set_heading("--")
      table(13).set_width(2)

      table(14).set_spacing(0)
      table(14).set_heading("D")
      table(14).set_width_from(self(.torsion_angle_4th_atoms).tag)
      table(14).set_left_justify(TRUE)

      table(15).set_heading("Angle(A--B--C--D)")
      table(15).set_subheading("/degree")
      table(15).set_width_from(ONE)

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,atom_kind,k1,k2,k3,k4)
         angle = angle*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol
         symbols(1,3) = self(atom_kind(k3)[1]).chemical_symbol
         symbols(1,4) = self(atom_kind(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)
         labels(:,3).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(dsh1)
         table( 7).set_values(symbols(:,4))

         table( 8).set_values(labels(:,1))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,2))
         table(11).set_values(dash)
         table(12).set_values(labels(:,3))
         table(13).set_values(dash)
         table(14).set_values(labels(:,4))

         table(15).set_values(angle)

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      atom_kind.destroy

   end

   put_torsion_angle_table(covariance,parentheses)
   ! Output the torsion angle table with errors given the "covariance"
   ! matrix between all atomic positions. Set "parentheses" FALSE if
   ! ypou don't want them for errors.
      covariance :: MAT{REAL}, IN
      parentheses :: BIN, IN, optional

      table :: VEC{TABLE_COLUMN}*
      atom_kind :: VEC{VEC_{INT}}*
      n_kind,k1,k2,k3,k4,n_angles,w :: INT
      symbols,labels :: MAT{STR}*
      dash,dsh1 :: VEC{STR}*
      angle,esds :: VEC{REAL}*
      quad :: MAT{INT}*
      val :: STR
      use_brackets :: BIN

      if (.dim<4) return
      if (.no_of_torsion_angles<1) return

      ! Parentheses
      use_brackets = TRUE
      if (present(parentheses)) use_brackets = parentheses

      ! Title
      stdout.flush
      stdout.flush
      stdout.text("==============")
      stdout.text("Torsion angles")
      stdout.text("==============")
      stdout.flush
      stdout.show("No. of angles =",.no_of_torsion_angles)
      stdout.flush
      stdout.text("The angle shown is the one that looking down B->C")
      stdout.text("i.e. it's the one between r(A)-r(B) and r(D)-r(C).")
      stdout.flush
      stdout.text("The angle is +ve if r(D)-r(C) is clockwise of r(A)-r(B).")
      if (.has_unique_labels) then
      stdout.flush
      stdout.text("You have set unique labels for each atom.")
      stdout.text("Those labels are used below.")
      else
      stdout.text("You have not set unique labels for each atom.")
      stdout.text("Therefore, atom number tags are used below.")
      end
      stdout.flush

      ! Get atom kind list 
      .make_atom_kind_list(atom_kind)

      ! Skip dummy atoms
      n_kind = atom_kind.dim
      if (self(atom_kind(n_kind)[1]).atomic_number==0) n_kind = n_kind - 1

      ! Create table
      if (use_brackets) then; table.create(15)
      else;                   table.create(16)
      end

      ! Set the table headings
      table(1).set_heading("A")
      table(1).set_width_from(.chemical_symbols)

      table(2).set_spacing(0)
      table(2).set_heading("--")
      table(2).set_width(2)

      table(3).set_spacing(0)
      table(3).set_heading("B")
      table(3).set_width_from(.chemical_symbols)

      table(4).set_spacing(0)
      table(4).set_heading("--")
      table(4).set_width(2)

      table(5).set_spacing(0)
      table(5).set_heading("C")
      table(5).set_width_from(.chemical_symbols)

      table(6).set_spacing(0)
      table(6).set_heading("--")
      table(6).set_width(2)

      table(7).set_spacing(0)
      table(7).set_heading("D")
      table(7).set_width(table(2).width)
      table(7).set_left_justify(TRUE)

      table(8).set_heading("A")
      table(8).set_width_from(self(.torsion_angle_1st_atoms).tag)

      table(9).set_spacing(0)
      table(9).set_heading("--")
      table(9).set_width(2)

      table(10).set_spacing(0)
      table(10).set_heading("B")
      table(10).set_width_from(self(.torsion_angle_2nd_atoms).tag)
      w = table(10).width
      val = "B"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(10).set_heading(val(1:w))

      table(11).set_spacing(0)
      table(11).set_heading("--")
      table(11).set_width(2)

      table(12).set_spacing(0)
      table(12).set_heading("C")
      table(12).set_width_from(self(.torsion_angle_3rd_atoms).tag)
      w = table(12).width
      val = "C"
      val(1:w).center_justify
      val(1:w).replace_all(" ","-")
      table(12).set_heading(val(1:w))

      table(13).set_spacing(0)
      table(13).set_heading("--")
      table(13).set_width(2)

      table(14).set_spacing(0)
      table(14).set_heading("D")
      table(14).set_width_from(self(.torsion_angle_4th_atoms).tag)
      table(14).set_left_justify(TRUE)

      table(15).set_heading("Angle(A--B--C--D)")
      table(15).set_subheading("/degree")
      table(15).set_width_from(ONE)

      if (NOT use_brackets) then
      table(16).set_heading("Error")
      table(16).set_width_from(ONE)
      end

      ! Put out the headings
      table.put_headings(label_rows=FALSE,no_flush=TRUE)

      ! Loop over atom kind classes
      do k1 = 1,n_kind
      do k2 = 1,n_kind
      do k3 = 1,n_kind
      do k4 = 1,n_kind

         ! Get the bonded atoms per kind
         .get_bonded_torsions(quad,angle,esds,atom_kind,k1,k2,k3,k4,covariance)
         angle = angle*DEGREE_PER_RADIAN
         esds  =  esds*DEGREE_PER_RADIAN

         ! No of bonds in this class
         n_angles = angle.dim
         if (n_angles==0) then
            esds.destroy
            angle.destroy
            quad.destroy
            cycle
         end

         ! Element symbols
         symbols.create(n_angles,4)
         symbols = " "
         symbols(1,1) = self(atom_kind(k1)[1]).chemical_symbol
         symbols(1,2) = self(atom_kind(k2)[1]).chemical_symbol
         symbols(1,3) = self(atom_kind(k3)[1]).chemical_symbol
         symbols(1,4) = self(atom_kind(k4)[1]).chemical_symbol

         ! Labels
         labels.create(n_angles,4)
         labels(:,1) = self(quad(:,1)).tag
         labels(:,2) = self(quad(:,2)).tag
         labels(:,3) = self(quad(:,3)).tag
         labels(:,4) = self(quad(:,4)).tag

         labels(:,2).pad_with("-",width=w,prepad=TRUE)
         labels(:,3).pad_with("-",width=w,prepad=TRUE)

         ! Dashes
         dash.create(n_angles)
         dsh1.create(n_angles)
         dash    = "--"
         dsh1    = "  "
         dsh1(1) = "--"

         ! Set table data
         table( 1).set_values(symbols(:,1))
         table( 2).set_values(dsh1)
         table( 3).set_values(symbols(:,2))
         table( 4).set_values(dsh1)
         table( 5).set_values(symbols(:,3))
         table( 6).set_values(dsh1)
         table( 7).set_values(symbols(:,4))

         table( 8).set_values(labels(:,1))
         table( 9).set_values(dash)
         table(10).set_values(labels(:,2))
         table(11).set_values(dash)
         table(12).set_values(labels(:,3))
         table(13).set_values(dash)
         table(14).set_values(labels(:,4))

         if (use_brackets) then
         table(15).set_real_precision(stdout.real_precision) ! Must do, for every block
         table(15).set_values_and_errors(angle,esds)
         else
         table(15).set_values(angle)
         table(16).set_values(esds)
         end

         ! Put body
         stdout.flush
         table.put_body(label_rows=FALSE)

         ! Put spacer if not last block
         if (NOT (k1==n_kind AND k2==n_kind AND k3==n_kind AND k4==n_kind)) stdout.flush

         ! Clean
         table.clear_columns
         dsh1.destroy
         dash.destroy
         labels.destroy
         symbols.destroy
         esds.destroy
         angle.destroy
         quad.destroy

      end
      end
      end
      end

      ! Table footer
      table.put_footer(label_rows=FALSE)

      ! Clean
      table.destroy
      atom_kind.destroy

   end

   get_bonded_torsions(quad,angle,atom_kind,k1,k2,k3,k4) ::: leaky, private
   ! Get the bonded-atom "quad"ruples, and the "angles" between them.
   ! The quadruple has "atom_kind" of "k1", "k2", and "k3", respectively.
      quad :: MAT{INT}*
      angle :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2,k3,k4 :: INT, IN

      i1,i2,i3,i4,a1,a2,a3,a4, n :: INT

      ! How many quadruples, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,atom_kind(k4).element.dim
                  a4 = atom_kind(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Count
                  n = n + 1

               end
            end
         end
      end

      ! Allocate
      quad.create(n,4)
      angle.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,atom_kind(k4).element.dim
                  a4 = atom_kind(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Add data
                  n = n + 1
                  quad(n,1) = a1
                  quad(n,2) = a2
                  quad(n,3) = a3
                  quad(n,4) = a4
                  angle(n)  = .torsion_angle(a1,a2,a3,a4)

               end
            end
         end
      end

   end

   get_bonded_torsions(quad,angle,esds,atom_kind,k1,k2,k3,k4,covariance) ::: leaky, private
   ! Get the bonded-atom "quad"ruples, and the "angles" between them.
   ! The quadruple has "atom_kind" of "k1", "k2", and "k3", respectively.
      quad :: MAT{INT}*
      angle,esds :: VEC{REAL}*
      atom_kind :: VEC{VEC_{INT}}, IN
      k1,k2,k3,k4 :: INT, IN
      covariance :: MAT{REAL}, IN

   ENSURE(covariance.is_square,"covariance: not square")
   ENSURE(covariance.dim1==3*.dim,"covariance: wrong size")

      i1,i2,i3,i4,a1,a2,a3,a4, n :: INT
      err :: REAL
      der :: VEC{REAL}(12)
      cov :: MAT{REAL}(12,12)

      ! How many quadruples, n, are there?
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,atom_kind(k4).element.dim
                  a4 = atom_kind(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Count
                  n = n + 1

               end
            end
         end
      end

      ! Allocate
      quad.create(n,4)
      angle.create(n)
      esds.create(n)

      ! Make the list
      n = 0
      do i1 = 1,atom_kind(k1).element.dim
         a1 = atom_kind(k1)[i1]

         do i2 = 1,atom_kind(k2).element.dim
            a2 = atom_kind(k2)[i2]

            if (a2==a1) cycle
            if (NOT .bonded(a1,a2)) cycle

            do i3 = 1,atom_kind(k3).element.dim
               a3 = atom_kind(k3)[i3]

               if (a3==a1 OR a3==a2) cycle
               if (NOT .bonded(a2,a3)) cycle

               do i4 = 1,atom_kind(k4).element.dim
                  a4 = atom_kind(k4)[i4]

                  if (a4==a1 OR a4==a2 OR a4==a3) cycle
                  if (NOT .bonded(a3,a4)) cycle
                  if (a4<a1) cycle

                  ! Extract covariances for atoms a, b, c
                  covariance.put_blocks_to(cov,block_dim=3,block_list=[a1,a2,a3,a4])
   
                  ! Make error
                  .torsion_angle_deriv(a1,a2,a3,a4,der)
                  err = ZERO
                  err = dot_product(der,matmul(cov,der))
                  if (err<ZERO) then
                     err = ZERO
                  end
                  err = sqrt(err)

                  ! Add data
                  n = n + 1
                  quad(n,1) = a1
                  quad(n,2) = a2
                  quad(n,3) = a3
                  quad(n,4) = a4
                  angle(n)  = .torsion_angle(a1,a2,a3,a4)
                  esds(n)   = err

               end
            end
         end
      end

   end

!  ADP's
!
!   put_ADPs(cell)
!   ! Output the ADP (thermal) tensors. If present, "cell" is used to change the
!   ! ADP tensors to the crystal axis system and then print them out; the
!   ! ADP tensors are changed back afterwards.
!      cell :: UNIT_CELL, IN
!
!   ENSURE(.has_cartesian_ADP_axes,"ADP tensors are not in cartesian system")
!
!      if (NOT .has_ADP_tensors) return
!
!      stdout.flush
!      stdout.flush
!      stdout.text("Anisotropic ADP's (crystal axes):")
!      .change_ADP_axis_system_to("crystal",cell)
!      .put_ADP_helper(units="angstrom^2")
!      .change_ADP_axis_system_to("cartesian",cell)
!
!   end
!
!   put_ADP_helper(units) ::: private
!   ! Output the ADP tensors -- helper routine. 
!      units :: STR, optional
!
!      fac :: REAL
!      Uis,Uxx,Uyy,Uzz,Uxy,Uxz,Uyz :: VEC{REAL}*
!      table :: VEC{TABLE_COLUMN}*
!
!      fac = ONE
!      if (present(units)) fac.convert_to(units)
!
!      ! Data
!      Uis.create(.dim)
!      Uxx.create(.dim); Uyy.create(.dim); Uzz.create(.dim)
!      Uxy.create(.dim); Uxz.create(.dim); Uyz.create(.dim)
!      Uis = fac*.U_iso
!      Uxx = fac*.ADP_tensor(1,1)
!      Uyy = fac*.ADP_tensor(2,2)
!      Uzz = fac*.ADP_tensor(3,3)
!      Uxy = fac*.ADP_tensor(1,2)
!      Uxz = fac*.ADP_tensor(1,3)
!      Uyz = fac*.ADP_tensor(2,3)
!
!      ! Table
!      table.create(7)
!      table.set_spacing(2)
!      table(1).set_heading("Uiso"); table(1).set_values(Uis)
!      table(2).set_heading("U_xx"); table(2).set_values(Uxx)
!      table(3).set_heading("U_yy"); table(3).set_values(Uyy)
!      table(4).set_heading("U_zz"); table(4).set_values(Uzz)
!      table(5).set_heading("U_xy"); table(5).set_values(Uxy)
!      table(6).set_heading("U_xz"); table(6).set_values(Uxz)
!      table(7).set_heading("U_yz"); table(7).set_values(Uyz)
!      table(1).set_subhead("/A^2")
!      table(4).set_subhead("/A^2")
!      table.put
!
!      ! Clean
!      table.clear_columns
!      table.destroy
!      Uyz.destroy; Uxz.destroy; Uxy.destroy
!      Uzz.destroy; Uyy.destroy; Uxx.destroy
!      Uis.destroy
!      
!   end

   put_mm_info ::: private
   ! Output a table of the residue names, sequence numbers, charges, but
   ! no basis sets. This is in PDB input format.
      i :: INT
      stdout.flush
      stdout.text("Residue information:")
      stdout.flush
      stdout.dash(width=42)
      stdout.put(" ",width=4)
      stdout.put("#",width=7)
      stdout.put("Name",width=4)
      stdout.put("Residue",width=5)
      stdout.put("Sequence",width=6)
      stdout.put("x",width=3)
      stdout.put("y",width=3)
      stdout.put("z",width=3)
      stdout.put("Charge",width=3)
      stdout.put("Element",width=4)
      stdout.flush
      stdout.dash(width=42)
      stdout.dash(int_fields=6,real_fields=5)
      do i = 1,size(self)
         stdout.put("ATOM",width=4)
         stdout.put(i,width=7)
         stdout.put(self(i).residue_atom_code,width=4)
         stdout.put(self(i).residue_code,width=5)
         stdout.put(self(i).residue_sequence_number,width=6)
         stdout.put(self(i).position(1),width=8,precision=3)
         stdout.put(self(i).position(2),width=8,precision=3)
         stdout.put(self(i).position(3),width=8,precision=3)
         stdout.put(self(i).mm_charge,width=7,precision=3)
         stdout.put(self(i).label,width=4)
         stdout.flush
      end
      stdout.dash(width=42)
   end

   put_restraint_atoms ::: private
   ! Output a table of the atom names, residue names and restraint atom
   ! information
      i :: INT
      stdout.text("Restraint atoms:")
      stdout.save
      stdout.set_int_width(9)
      stdout.set_real_width(9)
      stdout.set_real_precision(3)
      stdout.dash(int_fields=5,real_fields=3)
      stdout.put(" ",int_width=TRUE)
      stdout.put("Atom",int_width=TRUE)
      stdout.put("Residue",int_width=TRUE)
      stdout.put("Sequence")
      stdout.put("x")
      stdout.put("y")
      stdout.put("z")
      stdout.put("Force",int_width=TRUE)
      stdout.flush
      stdout.dash(int_fields=5,real_fields=3)
      do i = 1,size(self)
         if (self(i).restraining_force_constant.is_zero) cycle
         stdout.put(" ",int_width=TRUE)
         stdout.put(self(i).residue_atom_code,int_width=TRUE)
         stdout.put(self(i).residue_code,int_width=TRUE)
         stdout.put(self(i).residue_sequence_number)
         stdout.put(self(i).restraining_position(1))
         stdout.put(self(i).restraining_position(2))
         stdout.put(self(i).restraining_position(3))
         stdout.put(self(i).restraining_force_constant)
         stdout.flush
      end
      stdout.dash(int_fields=5,real_fields=3)
      stdout.unsave
   end

   put_principal_axes
   ! Put out the principal axis information
      pm,pn :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN
      .make_principal_moments(pm,pa,reorder)
      pn = pm/maxval(pm) ! normalised moments
      stdout.flush
      stdout.text("Principal moments and axes:")
      stdout.flush
      stdout.show("Centre of mass    =",.centre_of_mass)
      stdout.show("Principal moments =",pm)
      stdout.show("Spherical top?    =",.is_spherical_top(pn))
      stdout.show("Symmetric top?    =",.is_symmetric_top(pn))
      stdout.show("Prolate top?      =",.is_prolate_top(pn))
      stdout.show("Oblate top?       =",.is_oblate_top(pn))
      stdout.flush
      stdout.text("Principal axes:")
      stdout.put(pa)
   end

! VRML

   put_vrml(out)
   ! Put vrml version of the atomvec to the file in object "out".
      out :: TEXTFILE
      out.set_real_precision(5)
      out.set_real_width(12)

      stdout.text("Generating VRML atoms...")
      .put_vrml_header(out)
      .put_vrml_atoms(out)
      .put_vrml_bonds(out)
      stdout.text("done VRML atoms")
      stdout.flush
   end

   put_vrml_header(out) ::: private
   ! Put vrml header, and prototype bond and spheres, to the file.
      out :: TEXTFILE

      self = self

      out.text("PROTO Atom " // achar(91))
      out.text("   field SFColor col 1 0 0")
      out.text("   field SFFloat rad 1")
      out.text("   field SFVec3f pos 0 0 0")
      out.text(achar(93))
      out.text("{")
      out.text("   Transform {")
      out.text("      translation IS pos")
      out.text("      children " // achar(91))
      out.text("         Shape {")
      out.text("            appearance Appearance {")
      out.text("               material Material {")
      out.text("                  diffuseColor IS col")
      out.text("               }")
      out.text("            }")
      out.text("            geometry Sphere {")
      out.text("              radius IS rad")
      out.text("            }")
      out.text("         }")
      out.text("      " // achar(93))
      out.text("   }")
      out.text("}")

      out.flush

      out.text("PROTO Bond " // achar(91))
      out.text("   field SFColor col 1 0 0")
      out.text("   field SFFloat hgt 1")
      out.text("   field SFVec3f pos 0 0 0")
      out.text("   field SFRotation rot 1 0 0 0")
      out.text(achar(93))
      out.text("{")
      out.text("   Transform {")
      out.text("      translation IS pos")
      out.text("      rotation IS rot")
      out.text("      children " // achar(91))
      out.text("         Shape {")
      out.text("            appearance Appearance {")
      out.text("               material Material {")
      out.text("                 diffuseColor IS col")
      out.text("               }")
      out.text("            }")
      out.text("            geometry Cylinder {")
      out.text("               radius 0.304245979")
      out.text("               height IS hgt")
      out.text("               top    FALSE")
      out.text("               bottom FALSE")
      out.text("            }")
      out.text("         }")
      out.text("      " // achar(93))
      out.text("   }")
      out.text("}")

      out.flush

   end

   put_vrml_atoms(out) ::: private
   ! Put spheres for the atoms to view as vrml.
      out :: TEXTFILE
      colour :: VEC{REAL}(3)
      label :: STR(2)
      radius :: REAL
      n,Z :: INT
      do n = 1,.dim
       Z = self(n).atomic_number
       label = self(n).chemical_symbol
       select case (label)
         case ("H ");                     colour = (/191,196,192/)
         case ("He","Rn");                colour = (/88,196,160/)
         case ("Li","Be","Na","Mg");      colour = (/144,149,145/)
         case ("B ");                     colour = (/187,4,187/)
         case ("C ");                     colour = (/160,80,17/)
         case ("N ","Al");                colour = (/126,169,176/)
         case ("Si");                     colour = (/192,172,137/)
         case ("S ");                     colour = (/192,165,0/)
         case ("Cl");                     colour = (/0,165,0/)
         case ("O ","Ca","Ge","As");      colour = (/192,12,8/)
         case ("Se","Br","Sr","I ");      colour = (/192,12,8/)
         case default;                    colour = (/192,148,25/)
       end
       select case (Z)
         case (1:54);     radius = self(n).bragg_slater_radius
         case default;    radius = 1.30d0
       end
       colour = colour / 256
       out.text("Atom {")
       out.text(" col " // trim(colour.to_concatenated_str("f15.8",separator=", ")))
       out.text(" pos " // trim(self(n).position.to_concatenated_str("f15.8",separator=", ")))
       out.text(" rad " // trim(radius.to_str("f15.8")))
       out.text("}")
      end
   end

   put_vrml_bonds(out) ::: private
   ! Put bonds for the atoms to view as vrml.
      out :: TEXTFILE
      col_a,col_b,posa,posb,pos1,pos2,AB,centre :: VEC{REAL}(3)
      rot :: VEC{REAL}(4)
      hgta,hgtb,rada,radb :: REAL
      a,b :: INT
      do a = 1,.dim
       do b = 1,a-1
         if (.bonded(a,b)) then
           posa = self(a).position
           posb = self(b).position
           AB = posb-posa
           AB.normalise
           rada = self(a).bragg_slater_radius
           radb = self(b).bragg_slater_radius
           centre = HALF*(posa+rada*AB + posb-radb*AB)
           hgta = (centre - posa).norm
           hgtb = (posb - centre).norm
           pos1 = HALF*(centre + posa)
           pos2 = HALF*(centre + posb)
           rot(4) = PI
           rot(1:3) = AB + (/ZERO,ONE,ZERO/)
           rot(1:3).normalise
           select case (self(a).chemical_symbol)
             case ("H ");                     col_a = (/191,196,192/)
             case ("He","Rn");                col_a = (/88,196,160/)
             case ("Li","Be","Na","Mg");      col_a = (/144,149,145/)
             case ("B ");                     col_a = (/187,4,187/)
             case ("C ");                     col_a = (/160,80,17/)
             case ("N ","Al");                col_a = (/126,169,176/)
             case ("Si");                     col_a = (/192,172,137/)
             case ("S ");                     col_a = (/192,165,0/)
             case ("Cl");                     col_a = (/0,165,0/)
             case ("O ","Ca","Ge","As");      col_a = (/192,12,8/)
             case ("Se","Br","Sr","I ");      col_a = (/192,12,8/)
             case default;                    col_a = (/192,148,25/)
           end
           select case (self(b).chemical_symbol)
             case ("H ");                     col_b = (/191,196,192/)
             case ("He","Rn");                col_b = (/88,196,160/)
             case ("Li","Be","Na","Mg");      col_b = (/144,149,145/)
             case ("B ");                     col_b = (/187,4,187/)
             case ("C ");                     col_b = (/160,80,17/)
             case ("N ","Al");                col_b = (/126,169,176/)
             case ("Si");                     col_b = (/192,172,137/)
             case ("S ");                     col_b = (/192,165,0/)
             case ("Cl");                     col_b = (/0,165,0/)
             case ("O ","Ca","Ge","As");      col_b = (/192,12,8/)
             case ("Se","Br","Sr","I ");      col_b = (/192,12,8/)
             case default;                    col_b = (/192,148,25/)
           end
           col_a = col_a / 256
           col_b = col_b / 256
           out.text("Bond {")
           out.text(" col " //  trim(col_a.to_concatenated_str("f15.8",separator=", ")))
           out.text(" pos " //  trim(pos1.to_concatenated_str("f15.8",separator=", ")))
           out.text(" rot " //  trim(rot.to_concatenated_str("f15.8",separator=", ")))
           out.text(" hgt " //  trim(hgta.to_str("f15.8")))
           out.text("}")
           out.text("Bond {")
           out.text(" col " //  trim(col_b.to_concatenated_str("f15.8",separator=", ")))
           out.text(" pos " //  trim(pos2.to_concatenated_str("f15.8",separator=", ")))
           out.text(" rot " //  trim(rot.to_concatenated_str("f15.8",separator=", ")))
           out.text(" hgt " //  trim(hgtb.to_str("f15.8")))
           out.text("}")
         end
       end
      end
   end

   put_atom_groups
   ! Put out the atom group information
   ENSURE(.groups_defined,"no atom group information")
      n,i :: INT
      list :: VEC{VEC_{INT}}*
      .make_atom_group_list(list)
      stdout.save
      stdout.set_int_width(3)
      stdout.set_n_fields_per_line(25)
      stdout.set_using_array_labels(FALSE)
      stdout.flush
      stdout.text("Atom group information")
      stdout.flush
      stdout.show("n_groups =",list.dim)
      do n = 1,list.dim
         stdout.put("group "// trim(n.to_str) //"  =")
         do i = 1,list(n).element.dim
            stdout.put(list(n).element(i))
         end
         stdout.flush
      end
      stdout.unsave
      list.destroy
   end

   put_CX(label,angstrom)
   ! Outputs some information for the Crystal Explorer program
      label :: STR
      angstrom :: BIN, optional

      a :: INT
      pos :: VEC{REAL}(3)
      angst :: BIN

      angst = FALSE
      if (present(angstrom)) angst = angstrom

      ! Print atom_coords
      stdout.flush
      stdout.text("begin atom_coords " // label.trim)
      do a = 1,.dim
         stdout.put(self(a).label)
         stdout.put(self(a).chemical_symbol)
         pos = self(a).position
         if (angst) pos = ANGSTROM_PER_BOHR*pos
         stdout.put(pos(1))
         stdout.put(pos(2))
         stdout.put(pos(3))
         stdout.put(" IN")
         stdout.put(self(a).site_disorder_group)
         stdout.put(self(a).site_occupancy)
         stdout.flush
      end
      stdout.text("end atom_coords")

   end

!  ****************
!  Put cif routines
!  ****************

   put_cif
   ! Output the atoms in CIF format to "stdout"

      i :: INT

      ! Save CIF settings for later
      stdout.save
      stdout.set_real_precision(4)
      stdout.set_real_width(8)

      ! CIF coordinate header
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")
      
      ! Loop over atoms, put coordinates
      do i = 1,.dim
         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
         stdout.put(self(i).position(1),width=0,left=TRUE) ! put with space in front
         stdout.put(self(i).position(2),width=0,left=TRUE)
         stdout.put(self(i).position(3),width=0,left=TRUE)
         stdout.put("Uani",width=0,left=TRUE)
         stdout.put(self(i).site_occupancy,width=0,left=TRUE)
         stdout.flush
      end

      stdout.flush 
      stdout.flush 

      ! CIF ADP header
      stdout.text("loop_")
      stdout.text("_atom_site_aniso_label")
      stdout.text("_atom_site_aniso_U_11")
      stdout.text("_atom_site_aniso_U_22")
      stdout.text("_atom_site_aniso_U_33")
      stdout.text("_atom_site_aniso_U_12")
      stdout.text("_atom_site_aniso_U_13")
      stdout.text("_atom_site_aniso_U_23")

      ! Put ADP's in angtsrom
      do i = 1,.dim
         ! Order for the ADP's .......
         ! u11 u22 u33 u12 u13 u23 XD-format
         ! u11 u22 u33 u12 u23 u13 SHELX
         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag))
         stdout.put(self(i).ADP_tensor(1,1).to_units("angstrom^2"),width=0,left=TRUE)
         stdout.put(self(i).ADP_tensor(2,2).to_units("angstrom^2"),width=0,left=TRUE)
         stdout.put(self(i).ADP_tensor(3,3).to_units("angstrom^2"),width=0,left=TRUE)
         stdout.put(self(i).ADP_tensor(1,2).to_units("angstrom^2"),width=0,left=TRUE)
         stdout.put(self(i).ADP_tensor(1,3).to_units("angstrom^2"),width=0,left=TRUE)
         stdout.put(self(i).ADP_tensor(2,3).to_units("angstrom^2"),width=0,left=TRUE)
         stdout.flush 
      end

      stdout.unsave

   end

   put_cif_with_errors(delta_p)
   ! Output the atoms in CIF format to "stdout"
   ! WARNING: Errors "delta_p" must be given in the crystal axis system.
      delta_p :: VEC{REAL}

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      err :: VEC{REAL}(6)

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Reset precision for errors
      stdout.save
      stdout.set_real_width(stdout.saved.real_width+3)
      stdout.set_real_precision(stdout.saved.real_precision+3)

      ! CIF coordinate header
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")

      ! Loop over atoms
      k = 0
      do i = 1,.dim
         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)
         err(1:3) = delta_p(k+1:k+3)
         stdout.put(self(i).position(1),err(1),width=0,left=TRUE) ! Unitless
         stdout.put(self(i).position(2),err(2),width=0,left=TRUE)
         stdout.put(self(i).position(3),err(3),width=0,left=TRUE)
         stdout.put("Uani")
         stdout.put(self(i).site_occupancy,width=0,left=TRUE)
         stdout.flush         
         k = k + 9
      end

      ! CIF ADP header
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_aniso_label")
      stdout.text("_atom_site_aniso_U_11")
      stdout.text("_atom_site_aniso_U_22")
      stdout.text("_atom_site_aniso_U_33")
      stdout.text("_atom_site_aniso_U_12")
      stdout.text("_atom_site_aniso_U_13")
      stdout.text("_atom_site_aniso_U_23")

      ! Put ADP's in angtsrom
      k = 0
      do i = 1,.dim
         ! Order for the ADP's .......
         ! u11 u22 u33 u12 u13 u23 XD-format
         ! u11 u22 u33 u12 u23 u13 SHELX
         stdout.put(self(i).tag.trim,width=len_trim(self(i).tag),left=TRUE)

         ! Get values and errors
         ADP = fac * self(i).ADP_tensor
         err = fac * delta_p(k+4:k+9)

         ! Put quantity q with error e in format q(e)
         stdout.put(ADP(1,1),err(1),width=0,left=TRUE)
         stdout.put(ADP(2,2),err(2),width=0,left=TRUE)
         stdout.put(ADP(3,3),err(3),width=0,left=TRUE)
         stdout.put(ADP(1,2),err(4),width=0,left=TRUE)
         stdout.put(ADP(1,3),err(5),width=0,left=TRUE)
         stdout.put(ADP(2,3),err(6),width=0,left=TRUE)
         stdout.flush         

         k = k + 9

      end

      stdout.unsave

   end

   put_accurate_cif(covariance)
   ! Output the atoms in CIF format to "stdout".  If present, the full
   ! (symmetric) cartesian "covariance" matrix is printed out.
      covariance :: MAT{REAL}, optional, IN

      i :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Reset accuracy
      stdout.save
      stdout.set_real_style("e")
      stdout.set_real_width(18)
      stdout.set_real_precision(10)

      ! CIF coordinate header
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_label")
      stdout.text("_atom_site_fract_x")
      stdout.text("_atom_site_fract_y")
      stdout.text("_atom_site_fract_z")
      stdout.text("_atom_site_adp_type")
      stdout.text("_atom_site_occupancy")

      ! Loop over atoms
      do i = 1,.dim
         stdout.put(self(i).label.trim,width=len_trim(self(i).label))
         stdout.put(self(i).position(1))
         stdout.put(self(i).position(2))
         stdout.put(self(i).position(3))
         stdout.put("Uani")
         stdout.put(self(i).site_occupancy)
         stdout.flush         
      end

      ! CIF ADP header
      stdout.flush
      stdout.text("loop_")
      stdout.text("_atom_site_aniso_label")
      stdout.text("_atom_site_aniso_U_11")
      stdout.text("_atom_site_aniso_U_22")
      stdout.text("_atom_site_aniso_U_33")
      stdout.text("_atom_site_aniso_U_12")
      stdout.text("_atom_site_aniso_U_13")
      stdout.text("_atom_site_aniso_U_23")

      ! Put ADP's in angtsrom
      do i = 1,.dim
         ! Order for the ADP's .......
         ! u11 u22 u33 u12 u13 u23 XD-format
         ! u11 u22 u33 u12 u23 u13 SHELX
         stdout.put(self(i).label.trim,width=len_trim(self(i).label))

         ! Get values and errors
         ADP =  fac * self(i).ADP_tensor

         ! Print ADP
         stdout.put(ADP(1,1))
         stdout.put(ADP(2,2))
         stdout.put(ADP(3,3))
         stdout.put(ADP(1,2))
         stdout.put(ADP(1,3))
         stdout.put(ADP(2,3))

         stdout.flush         

      end

      ! Covariance matrix
      if (present(covariance)) then
      stdout.flush
      stdout.text("# NOTE: Cartesian 9Nx9N covariance matrix")
      stdout.text("# Elements 1-3 cartesian position in bohr")
      stdout.text("# Elements 4-9 U11,U22,U33,U12,U13,U23 in bohr^2")
      stdout.flush
      stdout.text("_covariance_matrix")
      stdout.put(covariance,by_row=TRUE)
      end

      ! Revert
      stdout.unsave

   end

   put_NKA_with_errors(T_sequence_no)
   ! Output the atom positions, ADP's, ADP sigmas in NKA file format
   ! to "stdout". 
      T_sequence_no :: INT

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      pos :: VEC{REAL}(3)
      err :: VEC{REAL}(6)

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Coordinates and ADP's in A^2
      stdout.flush
      do i = 1,.dim

         stdout.put(self(i).chemical_symbol,width=3)

         ! Coordinates in crystal or cartesian system
         pos = ANGSTROM_PER_BOHR * self(i).position
         stdout.put(pos(1))
         stdout.put(pos(2))
         stdout.put(pos(3))
         stdout.put(1,width=2)
         stdout.put(T_sequence_no,width=3)
         stdout.flush

         ! Get values and errors
         ADP =  fac * self(i).ADP_tensor

         ! ADP's always in cartesians and A^2
         stdout.put(ADP(1,1))
         stdout.put(ADP(2,2))
         stdout.put(ADP(3,3))
         stdout.put(ADP(1,2))
         stdout.put(ADP(1,3))
         stdout.put(ADP(2,3))

         stdout.flush

      end

      ! Now the ADP errors
      stdout.flush
      k = -9
      do i = 1,.dim

         k = k + 9

         stdout.put("SIG",width=3)
         stdout.put(self(i).chemical_symbol,width=3)
         stdout.put(T_sequence_no,width=3)

         ! Get values and errors
         err = fac * self(i).ADP_error

         ! Print ADPs
         stdout.put(err(1))
         stdout.put(err(2))
         stdout.put(err(3))
         stdout.put(err(4))
         stdout.put(err(5))
         stdout.put(err(6))

         stdout.flush

      end

   end

   put_excel_with_errors(esd,temperature)
   ! Output the atoms in Excel file format to "stdout"
   ! This should be in the crystal coordinate system.
      esd :: VEC{REAL}
      temperature :: REAL

   ENSURE(self(1).axis_system=="crystal","must be in crystal axis system")

      i,k :: INT
      fac :: REAL
      ADP :: MAT{REAL}(3,3)
      err :: VEC{REAL}(6)
      lab :: STR

      ! Unit conversion for ADP's
      fac =  ANGSTROM_PER_BOHR*ANGSTROM_PER_BOHR

      ! Coordinates in crystal axis system
      stdout.show("Coordinates refined at T =",temperature)
      stdout.flush
      k = 0
      do i = 1,.dim

         stdout.put("x")
         stdout.put(self(i).position(1))
         stdout.put(esd(k+1))
         stdout.put(self(i).label)
         stdout.flush

         stdout.put("y")
         stdout.put(self(i).position(2))
         stdout.put(esd(k+2))
         stdout.put(self(i).label)
         stdout.flush

         stdout.put("z")
         stdout.put(self(i).position(3))
         stdout.put(esd(k+3))
         stdout.put(self(i).label)
         stdout.flush

         k = k + 9

      end

      ! ADP's in crystal (CIF) axis system, angstrom^2 units
      stdout.show("ADP's refined at T =",temperature)
      stdout.flush
      k = 0
      do i = 1,.dim

         ! Get values and errors
         ADP = fac * self(i).ADP_tensor
         err = fac * esd(k+4:k+9)
         lab = self(i).label

         ! Print
         stdout.put("U11"); stdout.put(ADP(1,1)); stdout.put(err(1)); stdout.put(lab); stdout.flush
         stdout.put("U22"); stdout.put(ADP(2,2)); stdout.put(err(2)); stdout.put(lab); stdout.flush
         stdout.put("U33"); stdout.put(ADP(3,3)); stdout.put(err(3)); stdout.put(lab); stdout.flush
         stdout.put("U12"); stdout.put(ADP(1,2)); stdout.put(err(4)); stdout.put(lab); stdout.flush
         stdout.put("U13"); stdout.put(ADP(1,3)); stdout.put(err(5)); stdout.put(lab); stdout.flush
         stdout.put("U23"); stdout.put(ADP(2,3)); stdout.put(err(6)); stdout.put(lab); stdout.flush

         k = k + 9

      end

   end

   initialise_local_H_modes(L)
   ! Initialise local H modes as columns. These come in triples.
   ! The first is the XH stretch. The next two are the two XH bends.
      L :: MAT{REAL}

   ENSURE(L.dim1==3*.dim,"wrong size, dim1")
   ENSURE(L.dim2==3*count(self.atomic_number==1),"wrong size, dim2")

      unit :: MAT{REAL}(3,3)
      r1,r2,r3 :: VEC{REAL}(3)
      h,i,x, fh,lh :: INT

      ! Make the connection table
      .make_connection_table
      
      ! Initialise L
      L = ZERO

      ! Set unit vectors
      unit.to_unit_matrix

      ! Make the H modes
      i  = 0
      lh = 0

      do h = 1,.dim

         fh = lh + 1
         lh = lh + 3

         ! Only look for a = H atom
         if(self(h).atomic_number>1) cycle

         ! Make sure H atom connects one other
         if (connections_for(h).element.dim>1) then
            DIE("H atom connected tomore than one other")
         end

         ! Get XH vector
         x  = connections_for(h)[1]
         r1 = self(h).position - self(x).position
         r1.normalise

         ! Get the two perpendicular vectors
         r2.to_cross_product_of(r1,unit(:,1))
         if (r2.is_zero) &
         r2.to_cross_product_of(r1,unit(:,2))
         r2.normalise
         r3.to_cross_product_of(r1,r2)

         ! Set L
         L(fh:lh,i+1) = r1
         L(fh:lh,i+2) = r2
         L(fh:lh,i+3) = r3

         ! Next H mode
         i = i + 3

      end

      ! Clean
      connections_for.destroy

   end

!  ********************
!  Geometry conversions
!  ********************

   resolve_axis_system(cell)
   ! Change the atom axis systems to cartesian, from crystal, if required.
      cell :: UNIT_CELL, IN
      a :: INT
      do a = 1,.dim
         self(a).resolve_axis_system(cell)
      end
   end

   change_axis_system_to(axiskind,cell)
   ! Change the axis system "axiskind" to "cartesian" or "crystal".
      axiskind :: STR
      cell :: UNIT_CELL, IN
      a :: INT
      do a = 1,.dim
         self(a).change_axis_system_to(axiskind,cell)
      end
   end

   change_coord_axis_system_to(axiskind,cell)
   ! Change the coordinate axis system "axiskind" to "cartesian" or "crystal".
      axiskind :: STR
      cell :: UNIT_CELL, IN
      a :: INT
      do a = 1,.dim
         self(a).change_coord_axis_system_to(axiskind,cell)
      end
   end

   change_ADP_axis_system_to(axiskind,cell)
   ! Change the ADP (thermal) tensor axis system "axiskind" to "cartesian"
   ! or "crystal".
      axiskind :: STR
      cell :: UNIT_CELL, IN
      a :: INT
      do a = 1,.dim
         self(a).change_ADP_axis_system_to(axiskind,cell)
      end
   end

   convert_from_angstrom
   ! Convert atom positions to A.U. from Angstroms
       a :: INT
      do a = 1,.dim
         self(a).position = self(a).position*BOHR_PER_ANGSTROM
      end
   end

   convert_to_angstrom
   ! Convert atom positions to Angstroms from A.U.
       a :: INT
      do a = 1,.dim
         self(a).position = self(a).position*ANGSTROM_PER_BOHR
      end
   end

!  ***************
!  Change geometry
!  ***************

   extend_bond_lengths(z1,z2,factor) 
   ! Uniformly extend the bond lengths between all BONDED atoms with atomic
   ! number "z1" and "z2" by a "factor". Only the coordinates of the atoms with
   ! atomic number "z2" are altered.
      z1,z2 :: INT, IN
      factor :: REAL, IN

      atom_kind :: VEC{INT}*
      n_kind,z1_pos,z2_pos,z1_kind,z2_kind,a1,a2 :: INT
      r :: VEC{REAL}(3)

      if (all(self(:).atomic_number/=z1) OR all(self(:).atomic_number/=z2)) return

      z1_pos = self(:).atomic_number.index_of_value(z1)
      z2_pos = self(:).atomic_number.index_of_value(z2)

      atom_kind.create(.dim)
      .make_atom_kind_list(atom_kind,n_kind)
      z1_kind = atom_kind(z1_pos)
      z2_kind = atom_kind(z2_pos)

      do a1 = z1_pos,.dim
         if (atom_kind(a1)/=z1_kind) cycle
         do a2 = z2_pos,.dim
            if (atom_kind(a2)/=z2_kind) cycle
            if (NOT .bonded(a1,a2)) cycle
            r = self(a2).position - self(a1).position
            self(a2).position = self(a1).position + factor*r 
         end
      end

      atom_kind.destroy

   end

   set_bond_lengths(z1,z2,length) 
   ! Uniformly set the bond lengths between all BONDED atoms with atomic number
   ! "z1" and "z2" to be "length". Only the coordinates of the atoms with atomic
   ! number "z2" are altered.
      z1,z2 :: INT, IN
      length :: REAL, IN

      atom_kind :: VEC{INT}*
      n_kind,z1_pos,z2_pos,z1_kind,z2_kind,a1,a2 :: INT
      r :: VEC{REAL}(3)

      if (all(self(:).atomic_number/=z1) OR all(self(:).atomic_number/=z2)) return

      z1_pos = self(:).atomic_number.index_of_value(z1)
      z2_pos = self(:).atomic_number.index_of_value(z2)

      atom_kind.create(.dim)
      .make_atom_kind_list(atom_kind,n_kind)
      z1_kind = atom_kind(z1_pos)
      z2_kind = atom_kind(z2_pos)

      do a1 = z1_pos,.dim
         if (atom_kind(a1)/=z1_kind) cycle
         do a2 = z2_pos,.dim
            if (atom_kind(a2)/=z2_kind) cycle
            if (NOT .bonded(a1,a2)) cycle
            r = self(a2).position - self(a1).position
            r.normalise
            self(a2).position = self(a1).position + length*r 
         end
      end

      atom_kind.destroy

   end

!  *******************
!  Information methods
!  *******************

   no_of_dummy_atoms result (res) ::: pure
   ! Return the number of dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_dummy_atom(self))
   end

   dummy_atoms result (ind) ::: pure
   ! Return the list of dummy atoms
      self :: IN
      ind :: VEC{INT}(.no_of_dummy_atoms)
      i :: INT
      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:is_a_dummy_atom(self))
   end

   no_of_nondummy_atoms result (res) ::: pure
   ! Return the number of non-dummy atoms
      self :: IN
      res :: INT
      res = count(ATOM:is_a_nondummy_atom(self))
   end

   nondummy_atoms result (ind) ::: leaky
   ! Return TRUE if all atoms have unique labels
      self :: IN
      ind :: VEC{INT}*
      i :: INT
      i =0
      ind.create(.no_of_nondummy_atoms)
      ind = pack([(i, i=1,.dim)],mask=ATOM:is_a_nondummy_atom(self))
   end

   no_of_atoms_with_bases result (res) ::: pure
   ! Return the number of atoms with bases
      self :: IN
      res :: INT
      res = count(ATOM:has_basis(self))
   end

   atoms_with_bases result (ind) ::: pure
   ! Return TRUE if all atoms have unique labels
      self :: IN
      ind :: VEC{INT}(.no_of_atoms_with_bases)
      i :: INT
      i = 0
      ind = pack([(i, i=1,.dim)],mask=ATOM:has_basis(self))
   end

   chemical_formula(with_spaces) result (res)
   ! Return the chemical formula for the molecule, as a string, in
   ! alphabetical order of elements
      with_spaces :: BIN, optional
      res :: STR

      a,na :: INT
      spaces :: BIN
      symbol :: VEC{STR}*

      ! Do we want spaces between the elements?
      spaces = FALSE
      if (present(with_spaces)) spaces = with_spaces

      ! Get alphabetical list of chemical symbols
      symbol.create(.dim)
      do a = 1,.dim
         symbol(a) = self(a).chemical_symbol
      end
      symbol.quick_sort

      ! Make the chemical symbol
      res = " "
      a = 1
      do
         na = count(symbol==symbol(a))
         if (spaces AND res/=" ") then; res = trim(res) // " " // trim(symbol(a))
         else;                          res = trim(res) //        trim(symbol(a))
         end
         if (na>1) &
         res = trim(res) // trim(na.to_str)
         a = a + na
         if (a>.dim) exit
      end

      ! Clean up
      symbol.destroy

   end

   molecular_weight result (res)
   ! Return the molceular weight for this atomvec
      res :: REAL
      a :: INT
      res = ZERO
      do a = 1,.dim
         res = res + self(a).mass
      end
   end

   get_mean_neutron_numbers(NN)
   ! Get the atom coordinates in a matrix object "coord"
      NN :: VEC{REAL}
       a :: INT
      do a = 1,.dim
         NN(a) = self(a).mean_neutron_number
      end
   end

! Symbols, labels, tags

   unique_tags result (res) ::: leaky
   ! Return the unique tags
      res :: VEC{STR}*
      res.create(.dim)
      res = self.tag
   end

   chemical_symbols result (res)
   ! Return an array of the chemical symbols for each atom
      res :: VEC{STR}(size(self))
      res = ATOM:chemical_symbol(self)
   end

!   numbered_chemical_symbols result (res)
!   ! Return an array of the chemical symbols for each atom with a number
!   ! at the end in brackets, which is the number of the atom in thge list.
!      res :: VEC{STR}(size(self))
!      a :: INT
!      res = ATOM:chemical_symbol(self)
!      do a = 1,.dim
!         res(a) = trim(res(a))//"("//trim(a.to_str)//")"
!      end
!   end

   has_dummy_labels result (res) 
   ! Return TRUE if any atom has a dummy charge labels
      self :: IN
      res :: BIN
      res = any(ATOM:has_a_dummy_label(self))
   end

   position_ADP_label(par_index) result (res)
   ! Return the standard symbol for a positional-ADP parameter with
   ! index "par_index"
      par_index :: INT
      res :: STR

      a,ind :: INT

      a   = int((par_index-1)/9)
      ind = par_index - 9*a

      res = self(a+1).position_ADP_label(ind)

   end

   position_ADP_labels result (res) ::: leaky
   ! Return the standard symbols for all positional-ADP parameters
      res :: VEC{STR}*

      i :: INT

      ! Leaky
      res.create(.dim)

      ! Get the labels
      do i = 1,.dim
         res(i) = .position_ADP_label(i)
      end

   end

   position_ADP_labels(par_indices) result (res) ::: leaky
   ! Return the standard symbols for a positional-ADP parameter with
   ! index "par_index"
      par_indices :: VEC{INT}
      res :: VEC{STR}*

      i :: INT

      ! Create the label arrays (leaky)
      res.create(par_indices.dim)

      ! Get the labels
      do i = 1,par_indices.dim
         res(i) = .position_ADP_label(par_indices(i))
      end

   end

! Nuclear energies

   sum_of_nuclear_charges result (res)
   ! Return the sum of the nuclear_charges
   ! Note: dummy atoms may have non-zero nuclear charge
      res :: REAL
      res = sum(self(:).nuclear_charge)
   end

   nuclear_repulsion_energy result (res)
   ! Return the nuclear repulsion energy.
      res :: REAL

      i,j :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)


      res = ZERO
      do i = 1,.dim
         qi = self(i).nuclear_charge
         do j = 1,i-1
            qj = self(j).nuclear_charge
            r =  self(j).position - self(i).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end

   end

   nuclear_repulsion_energy(atoms) result (res)
   ! Return the nuclear repulsion energy felt by the group of atoms "a" in
   ! the field of all the nuclei in "self"
      atoms :: VEC{INT}
      res :: REAL

      a,i,j :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)

      res = ZERO

      do i = 1,atoms.dim
         a = atoms(i)
         qi = self(a).nuclear_charge
         do j = 1,.dim
            if (any(atoms==j)) cycle
            qj = self(j).nuclear_charge
            r =  self(j).position - self(a).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end

      res = HALF*res ! only count half the interaction energy
      res = res + self(atoms).nuclear_repulsion_energy

   end

   nuclear_repulsion_energy(atoms,nuclei) result (res)
   ! Return the nuclear repulsion energy felt by the group of atoms "a" in
   ! the field of all the nuclei in "nuclei"
      atoms, nuclei :: VEC{INT}
      res :: REAL

      a, i,j,k, n_atoms, n_field :: INT
      qi,qj :: REAL
      r :: VEC{REAL}(3)


      res = ZERO
      n_atoms = size(atoms)
      n_field = size(nuclei)
      do i=1,n_atoms
         a = atoms(i)
         qi = self(a).nuclear_charge
         do k=1,n_field
            j = nuclei(k)
            if (any(atoms==j)) cycle
            qj = self(j).nuclear_charge
            r =  self(j).position - self(a).position
            res = res + qi*qj/sqrt(dot_product(r,r))
         end
      end
      res = res + self(atoms).nuclear_repulsion_energy

   end

! Center of mass & shape

   centre_of_mass result(centre)
   ! Return the centre of mass
      centre :: VEC{REAL}(3)
      a :: INT
      mw :: REAL
      mw = ONE/.molecular_weight
      centre = ZERO
      do a = 1,.dim
         centre = centre + self(a).position*self(a).mass*mw
      end
   end

   move_origin_to_centre_of_mass
   ! Move the origin to the centre of mass
      .translate_by(-.centre_of_mass)
   end

   change_to_principal_axes
   ! Move the origin to the centre of mass and change the coordinates to be with
   ! respect to the principal axes
      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      .translate_by(-.centre_of_mass)
      .make_principal_moments(pm,pa)
      .change_coordinate_axes(pa)
   end

   change_to_principal_top_axes
   ! Move the origin to the centre of mass and change the coordinates to be with
   ! respect to the principal top axes i.e. in the case of symmetric tops the
   ! last axis is the unique axes.
      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN
      .translate_by(-.centre_of_mass)
      .make_principal_moments(pm,pa,reorder)
      .change_coordinate_axes(pa)
   end

   change_coordinate_axes(axes)
   ! Change the coordinates of the atoms to be with respect to the columns of
   ! "axes", which must be an orthogonal matrix.
      axes :: MAT{REAL}(3,3)
      a :: INT
      do a = 1,.dim
         self(a).change_coordinate_axes(axes)
      end
   end

   mass result (res)
   ! Return the mass of the molecule
      res :: REAL

      a :: INT

      res = ZERO
      do a = 1,.dim
         res = res + self(a).mass
      end

   end

   reduced_mass result(mu)
   ! Return the centre of mass
      mu :: REAL
      a :: INT
      mu = ZERO
      do a = 1,.dim
         mu = mu + ONE / self(a).mass
      end
      mu = ONE/mu
   end

   make_inertia_tensor(it)
   ! Make the moment of inertia tensor wrt the centre of mass
      it :: MAT{REAL}(3,3)
      m :: MAT{REAL}(3,3)
      com,r :: VEC{REAL}(3)
      trace :: REAL
      a :: INT
      com = .centre_of_mass
      it = ZERO
      do a = 1,.dim
         r = self(a).position - com
         m = spread(r,dim=1,ncopies=3)*spread(r,dim=2,ncopies=3)
         m = self(a).mass * m
         trace = m.trace
         m = -m
         m.increment_diagonal_by(trace)
         it = it + m
      end
   end

   make_principal_moments(pm,pa,reorder)
   ! Make the principal moments "pm" and principal axes "pm" wrt the centre of
   ! mass.  If "reorder" is present then the principal axes are made to be right
   ! handed. Also:
   ! - For sperical tops, the local x,y,z axes are the pricipal axes
   ! - For symmetric tops, the C axis is unique
   ! - For asymmetric tops, the pricipal axes are aligned close to the local
   !    x,y,z axes
      pm :: VEC{REAL}(3)
      pa :: MAT{REAL}(3,3)
      reorder :: BIN, optional
      pn :: VEC{REAL}(3)
      it :: MAT{REAL}(3,3)
      .make_inertia_tensor(it)                  ! Make the inertia tensor and axes
      it.solve_eigenproblem(pm,pa)
      if (NOT present(reorder)) return
      where (pm<TOL(6))                         ! Set small moments to zero
         pm = ZERO
      end
      if (abs(pa(1,2)) > abs(pa(1,1))) then     ! Make principal axes close to x,y,z
         pa.swap_columns(1,2)
         pm.swap_elements(1,2)
      end
      if (abs(pa(1,3)) > abs(pa(1,1))) then
         pa.swap_columns(1,3)
         pm.swap_elements(1,3)
      end
      if (abs(pa(2,3)) > abs(pa(2,2))) then
         pa.swap_columns(2,3)
         pm.swap_elements(2,3)
      end
    ! pn = pm
      pn = pm/maxval(abs(pm))                   ! Use normalised moments for now
      if (.is_spherical_top(pn)) then           ! Spherical top? ... axes are x,y,z
            pa.to_unit_matrix         
      else if (.is_symmetric_top(pn)) then      ! Symmetric top? ... C axis is unique
         if (abs(pn(1)-pn(3)) < TOL(2)) then 
            pa.swap_columns(2,3)
            pm.swap_elements(2,3)
         else if (abs(pn(2)-pn(3)) < TOL(2)) then
            pa.swap_columns(1,3)
            pm.swap_elements(1,3)
         end
      end
      if (pa(1,1)<ZERO AND pa(2,2)<ZERO) then   ! Make positive diagonals
         pa(:,1) = -pa(:,1)
         pa(:,2) = -pa(:,2)
      end
      if (pa.determinant>ZERO) return           ! Ensure axes are right handed
      if (abs(pm(1)-pm(2)) < TOL(6)) then       ! Swap columns 1,2 if equal moments
         pm.swap_elements(1,2)
         pa.swap_columns(1,2)
      else if (abs (pm(2)-pm(3)) < TOL(6)) then ! Swap columns 2,3 if equal moments
         pm.swap_elements(2,3)
         pa.swap_columns(2,3)
      else                                      ! Reverse all C axis
         pa(:,3) = -pa(:,3)
      end
   end

   make_shape_tensor(st)
   ! Make the shape tensor "st" wrt the centre of atoms. This is the same as the
   ! moment of inertia tensor except that each atom is assumed to have unit mass.
      st :: MAT{REAL}(3,3)
      m :: MAT{REAL}(3,3)
      c,r :: VEC{REAL}(3)
      a :: INT
      c = .centre_of_atoms
      st = ZERO
      do a = 1,.dim
         r = self(a).position - c
         m = spread(r,dim=1,ncopies=3)*spread(r,dim=2,ncopies=3)
         m.increment_diagonal_by(-m.trace)
         st = st - m
      end
   end

   make_shape_moments(sm,sa)
   ! Make the shape moments "sm" and principal shape axes "sa" wrt the centre of
   ! atoms. The shape axes are the same as the principal moment of inertia axes
   ! except that each atom is assumed to have unit mass. The principal shape
   ! axes are made right handed.
      sm :: VEC{REAL}(3)
      sa :: MAT{REAL}(3,3)
      st :: MAT{REAL}(3,3)
      .make_shape_tensor(st)
      st.solve_eigenproblem(sm,sa)
      if (abs(sa(1,2)) > abs(sa(1,1))) then ! make axes are close to x,y,z
         sa.swap_columns(1,2)
         sm.swap_elements(1,2)
      end
      if (abs(sa(1,3)) > abs(sa(1,1))) then
         sa.swap_columns(1,3)
         sm.swap_elements(1,3)
      end
      if (abs(sa(2,3)) > abs(sa(2,2))) then
         sa.swap_columns(2,3)
         sm.swap_elements(2,3)
      end
      if (sa(1,1)<ZERO)        sa(:,1) = -sa(:,1)  ! make axes +ve
      if (sa(2,2)<ZERO)        sa(:,2) = -sa(:,2)
      if (sa.determinant<ZERO) sa(:,3) = -sa(:,3)
   end

! Shape tests

   is_linear(pm) result (res) ::: private
   ! Return TRUE if the geometry is linear.
   ! Needs principal moments of inertia "pm"
      res :: BIN
      pm :: VEC{REAL}(3)

      self = self
      res = any(pm==ZERO)

   end

   is_spherical_top(pm) result (res) ::: private
   ! Return TRUE if the geometry is a spherical top
   ! Needs principal moments of inertia "pm"
      res :: BIN
      pm :: VEC{REAL}(3)
      res = .no_of_same_principal_moments(pm)==3
   end

   is_symmetric_top(pm) result (res) ::: private
   ! Return TRUE if the geometry is a symmetric top
   ! Needs principal moments of inertia "pm"
      res :: BIN
      pm :: VEC{REAL}(3)
      res = .no_of_same_principal_moments(pm)==1
   end

   is_prolate_top(pm) result (res) ::: private
   ! Return TRUE if the geometry is a prolate top
   ! Needs principal moments of inertia "pm" after alignment
      res :: BIN
      pm :: VEC{REAL}(3)
      res = .is_symmetric_top(pm) AND (pm(3)<pm(1))
   end

   is_oblate_top(pm) result (res) ::: private
   ! Return TRUE if the geometry is a oblate top
   ! Needs principal moments of inertia "pm" after alignment
      res :: BIN
      pm :: VEC{REAL}(3)
      res = .is_symmetric_top(pm) AND (pm(3)>pm(1))
   end

   is_asymmetric_top(pm) result (res) ::: private
   ! Return TRUE if the geometry is a asymmetric top
   ! Needs principal moments of inertia "pm"
      res :: BIN
      pm :: VEC{REAL}(3)
      res = .no_of_same_principal_moments(pm)==0
   end

   no_of_same_principal_moments(pm) result(same)
   ! Return the number of "same" pairs of principal moments of inertia.
   ! Needs principal moments of inertia "pm"
      same :: INT
      pm :: VEC{REAL}(3)
      i,j :: INT

      self = self

      same = 0
      do i = 1,3
      do j = 1,i-1
         if (abs(pm(i)-pm(j))<=TOL(2)) then
            same = same + 1
         end
      end
      end

   end

! Box centering

   centre_of_atoms(axes) result(centre)
   ! Return the centroid of the atom positions in "centre". If "axes" is present
   ! then the "centre" is expressed with respect to the new "axes", where the
   ! columns of "axes" are the coordinates of the new axes in terms of the old.
      centre :: VEC{REAL}(3)
      axes :: MAT{REAL}(3,3), optional
      a :: INT
      centre = ZERO
      do a = 1,.dim
         centre = centre + self(a).position
      end
      centre = centre/.dim
      if (present(axes)) centre = matmul(transpose(axes),centre)
   end

   move_origin_to_centre_of_atoms
   ! Move the origin to the centre of atoms
      .translate_by(-.centre_of_atoms)
   end

   bounding_cube_width result(width)
   ! Return "width" which is a width of a side of a cube in which the molecule
   ! nicely sits.
   ! Suitable for generating plot widths.
      width :: REAL
      centre,dist :: VEC{REAL}(3)
      length :: REAL
      a :: INT
      width = ZERO
      centre = .centre_of_atoms
      do a = 1,.dim
         dist = self(a).position - centre
         length = dist.norm + self(a).bragg_slater_radius*BOHR_PER_ANGSTROM*TWO
         length = max(length, dist.norm*TWO)
         width = max(width,length)
      end
      width = TWO*width
   end

   bounding_box(axes) result(box)
   ! Return "box" which are three widths of a side of a box in which the
   ! molecule nicely sits. If "axes" is present, the "box" coordinates are
   ! expressed in terms of the new "axes", where the columns of "axes" are the
   ! coordinates of the new axes in terms of the old. These "axes" may be
   ! (typically) the principal moment axes. This routine is suitable for
   ! generating plot widths.
      axes :: MAT{REAL}(3,3), optional
      box :: VEC{REAL}(3)
      centre,dist :: VEC{REAL}(3)
      a :: INT
      box = ZERO
      centre = .centre_of_atoms
      do a = 1,.dim
         dist = self(a).position - centre
         dist = abs(dist)
         if (present(axes)) then
           dist = matmul(transpose(axes),dist) ! coordinates in new axis system
           dist = abs(dist)
         end
         dist = dist + self(a).bragg_slater_radius*BOHR_PER_ANGSTROM*TWO
         box  = max(box,dist)
      end
      box = FOUR*box
   end

! Presence/absence of features and properties

   has_sequence_numbers result (res)
   ! Return TRUE if any atom in the list has a non zero sequence number
      res :: BIN
      res = any(self.residue_sequence_number > 1)
   end

   has_ADP_tensors result (res)
   ! Return TRUE if any atom has a non-zero ADP tensor
      res :: BIN
      i :: INT

      res = FALSE
      do i = 1,.dim
         if (all(self(i).ADP_tensor==ZERO)) cycle
         res = TRUE 
         exit
      end  

   end

   has_ADP_errors result (res)
   ! Return TRUE if any atom has a non-zero ADP errors
      res :: BIN
      i :: INT

      res = FALSE

      do i = 1,.dim
         if (all(self(i).ADP_error==ZERO)) cycle
         res = TRUE 
         exit
      end  

   end

   has_position_errors result (res)
   ! Return TRUE if any atom has a non-zero position errors
      res :: BIN
      i :: INT

      res = FALSE

      do i = 1,.dim
         if (all(self(i).position_error==ZERO)) cycle
         res = TRUE 
         exit
      end  

   end

   has_U_iso result (res)
   ! Return TRUE if any atom in the list has a non zero U_iso
      res :: BIN
      res = any(self.U_iso>ZERO)
   end

   has_thermal_factors result (res)
   ! Return TRUE if any atom in the list has a non zero ADP tensor
   ! OR non zero isotropic thermal factor.
      res :: BIN
      res = .has_ADP_tensors OR .has_U_iso
   end

   has_residue_codes result (res)
   ! Return TRUE if any atom in the list has a residue names
      res :: BIN
      res = any(self(:).residue_code /= " " )
   end

   has_restraints result (res)
   ! Return TRUE if any atom in the list has a restrained position
   ! or restrained force constants
      res :: BIN
      res = any(self(:).restraining_force_constant/=ZERO)
   end

   has_dipoles result (has)
   ! Return TRUE if any of the atoms have dipoles
      self :: IN
      has :: BIN
      a :: INT
      has = FALSE
      do a = 1,.dim
         has = self(a).has_dipole
         if (has) exit
      end
   end

   has_polarisabilities result (has)
   ! Return TRUE if any of the atoms have polarisabilities
      self :: IN
      has :: BIN
      a :: INT
      has = FALSE
      do a = 1,.dim
         has = self(a).has_polarisability
         if (has) exit
      end
   end

! Geometry info

   get_coordinates(coord)
   ! Get the atom coordinates in a matrix object "coord"
      coord :: MAT{REAL}
      .get_geometry(coord)
   end

   coordinates result (coord)
   ! Get the atom coordinates in a matrix object "coord"
      coord :: MAT{REAL}(3,.dim)
      .get_geometry(coord)
   end

   geometry(skip_dummies) result (g) ::: leaky
   ! Return the geometry "g" in a matrix
      self :: IN
      g :: MAT{REAL}*
      skip_dummies :: BIN, IN, optional

      n_atom :: INT
      skip :: BIN

      skip = FALSE
      if (present(skip_dummies)) skip = skip_dummies

      if (skip) then
         n_atom = .no_of_nondummy_atoms
         g.create(3,n_atom)
         .get_geometry(g,skip_dummies=TRUE)
      else
         g.create(3,.dim)
         .get_geometry(g)
      end

   end

   get_geometry(g,skip_dummies)
   ! Return the geometry "g" in a matrix
      self :: IN
      g :: MAT{REAL}, OUT
      skip_dummies :: BIN, IN, optional

      n_atom,i,n :: INT
      skip :: BIN

      skip = FALSE
      if (present(skip_dummies)) skip = skip_dummies

      if (NOT skip) then

         if (g.dim1==3 AND g.dim2==.dim) then
            do n = 1,.dim
               g(:,n) = self(n).position
            end
         else if (g.dim1==.dim AND g.dim2==3) then
            do n = 1,.dim
               g(n,:) = self(n).position
            end
         else
            DIE("incorrectly sized geometry array")
         end

      else

         n_atom = .no_of_nondummy_atoms

         if (g.dim1==3 AND g.dim2==n_atom) then
            i = 0
            do n = 1,.dim
               if (self(n).is_a_dummy_atom) cycle
               i = i + 1
               g(:,i) = self(n).position
            end
         else if (g.dim1==n_atom AND g.dim==3) then
            i = 0
            do n = 1,.dim
               if (self(n).is_a_dummy_atom) cycle
               i = i + 1
               g(i,:) = self(n).position
            end
         else
            DIE("incorrectly sized geometry array")
         end

      end

   end

   get_geometry_vector(g)
   ! Return the geometry "g" as a flat vector where the xyz positions increment
   ! fastest, useful for optimisations
      g :: VEC{REAL}
   ENSURE(g.dim==3*.dim,"wrong size, g")
      k,i :: INT
      k = 0
      do i = 1,.dim
        g(k+1) = self(i).position(1)
        g(k+2) = self(i).position(2)
        g(k+3) = self(i).position(3)
        k = k + 3
      end
   end

   geometry_vector result (g)
   ! Return the geometry "g" as a flat vector where the xyz positions increment
   ! fastest, useful for optimisations
      g :: VEC{REAL}(3*size(self))
      k,i :: INT
      k = 0
      do i = 1,.dim
        g(k+1) = self(i).position(1)
        g(k+2) = self(i).position(2)
        g(k+3) = self(i).position(3)
        k = k + 3
      end
   end

   set_geometry_from_vector(g)
   ! Set the geometry from "g", a flat vector, where the xyz positions
   ! increment fastest
      g :: VEC{REAL}
   ENSURE(g.dim==3*.dim,"wrong size, g")
      k,i :: INT
      k = 0
      do i = 1,.dim
        self(i).position(1) = g(k+1)
        self(i).position(2) = g(k+2)
        self(i).position(3) = g(k+3)
        k = k + 3
      end
   end

! Bases and labels

   has_unique_labels result (has)
   ! Return TRUE if all atoms with bases have unique labels
   ! The basis test should eliminate all dummy atoms.
      self :: IN
      has :: BIN
      dum :: VEC{INT}*
      dum => .nondummy_atoms
      has = NOT self(dum).label.has_repetitions
      dum.destroy
   end

   has_all_ANO_data result(has)
   ! Return TRUE if all atom ANO data exists
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).has_ANO_data
         if (NOT has) exit
      end
   end

   has_all_bases result(has)
   ! Return TRUE if all atoms have a basis on one kind or another.
      self :: IN
      has :: BIN
      has = .has_all_gaussian_bases OR .has_all_slater_bases OR .has_all_coppens_bases
   end

   has_all_gaussian_bases result(has)
   ! Return TRUE if all atom gaussian basis data exists
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).basis.created
         if (NOT has) exit
      end
   end

   has_all_slater_bases result(has)
   ! Return TRUE if all atom slater basis data exists
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).slaterbasis.created
         if (NOT has) exit
      end
   end

   has_all_coppens_bases result(has)
   ! Return TRUE if all atom slater basis data exists
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).coppensbasis.created
         if (NOT has) exit
      end
   end

   has_all_density_data result(has)
   ! Return TRUE if all atoms have some kind of atom density data, either
   ! slaterbasis, coppensbasis or gausian ANO data. This routine does NOT check
   ! that they are all the same kind of data!
      self :: IN
      has :: BIN
      has = .has_all_slater_bases OR .has_all_coppens_bases OR .has_all_ANO_data
   end

   has_all_interpolators result(has)
   ! Return TRUE if all atoms have slaterbases which have interpolators, or all
   ! atoms have coppensbases with interpolators.
      self :: IN
      has :: BIN
      has = .has_all_atom_interpolators OR .has_all_slater_interpolators OR .has_all_coppens_interpolators
   end

   has_all_atom_interpolators result(has)
   ! Return TRUE if all atoms have interpolators.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).interpolator.created
         if (NOT has) exit
      end
   end

   has_all_slater_interpolators result(has)
   ! Return TRUE if all atoms have slaterbases which have interpolators.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).slaterbasis.created
         if (NOT has) exit
         has = self(a).slaterbasis.interpolator.created
         if (NOT has) exit
      end
   end

   has_all_coppens_interpolators result(has)
   ! Return TRUE if all atoms have coppensbases which have interpolators.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).coppensbasis.created
         if (NOT has) exit
         has = self(a).coppensbasis.interpolator.created
         if (NOT has) exit
      end
   end

   basis_labels result (labels) ::: leaky
   ! Return a list of basis set "labels". Missing labels are returned blank.
      labels :: VEC{STR}*
      i :: INT
      labels.create(size(self))
      do i = 1,size(self)
         if (self(i).basis_label/=" ") then; labels(i) = self(i).basis_label
         else;                               labels(i) = " "
         end
      end
   end

   library_basis_labels(suffix) result (labels) ::: leaky
   ! Return a list of library basis set labels, the atoms element name with
   ! ":suffix" appended to it. Only a unique list of basis labels is returned.
      suffix :: STR
      labels :: VEC{STR}*
      i :: INT
      labels.create(.dim)
      do i = 1,.dim
         labels(i) = self(i).library_basis_label(suffix)
      end
      labels.remove_repetitions
   end

   library_basis_labels(Z_max,suffix) result (labels) ::: selfless, leaky
   ! Return a list of library basis set labels, for the atoms with
   ! atomic numbers up to "Z_max", with ":suffix" appended to it. Only
   ! a unique list of basis labels is returned.
      Z_max :: INT
      suffix :: STR
      labels :: VEC{STR}*
      Z :: INT
      labels.create(Z_max)
      do Z = 1,Z_max
         labels(Z) = ATOM:library_basis_label(Z,suffix)
      end
   end

!   library_basis_labels(suffix) result (labels) ::: leaky
!   ! Return a list of library basis set labels. The label is either the atoms
!   ! own .basis_label (if it contains the colon character, the indicator of a
!   ! library basis set), or else it is the atoms element name with ":suffix"
!   ! appended to it. Only a unique list of basis labels is returned.
!      suffix :: STR
!      labels :: VEC{STR}*
!      i :: INT
!      labels.create(size(self))
!      do i = 1,size(self)
!         if (self(i).basis_label.includes(":")) then
!            labels(i) = self(i).basis_label
!         else
!            labels(i) = self(i).library_basis_label(suffix)
!         end
!      end
!      labels.remove_repetitions
!   end

   minimum_basis_exponents result (res)
   ! Return the minimum exponent in the basis.
      res :: VEC{REAL}(.dim)
      i :: INT
      do i = 1,.dim
        res(i) = self(i).minimum_basis_exponent
      end
   end

! Axes and disorder

   has_cartesian_ADP_axes result(has)
   ! Return TRUE if all atom ADP (thermal) tensors are in the cartesian axis system.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).ADP_axis_system=="cartesian"
         if (NOT has) exit
      end
   end

   has_crystal_ADP_axes result(has)
   ! Return TRUE if all atom ADP (thermal) tensors are in the crystal axis system.
      self :: IN
      has :: BIN
      a :: INT
      has = TRUE
      do a = 1,.dim
         has = self(a).ADP_axis_system=="crystal"
         if (NOT has) exit
      end
   end

   has_disorder result (has)
   ! Return TRUE if any atom has disorder i.e. an occupancy which is not one.
      self :: IN
      has :: BIN
      has = NOT self(:).site_occupancy.are_all_equal_to(ONE)
   end

   atom_index_from_position(pos) result (res)
   ! Return the index of atom from its position "pos"
      pos :: VEC{REAL}(3)
      res :: INT
      a :: INT
      found :: BIN
      found = FALSE
      do a = 1,.dim
         found = pos.same_as(self(a).position)
         if (found) exit
      end
      res = a
      ENSURE(found,"no atom for this position")
   end

! Radii

   covalent_radii_ccdc result (res) 
   ! Returns the CCDC covalent radius for this atom
      res :: VEC{REAL}(.dim)
      a :: INT
      do a = 1,.dim
         res(a) = self(a).covalent_radius_ccdc
      end
   end

   vdw_radii_ccdc result (res) 
   ! Returns the CCDC vdw radius for this atom
      res :: VEC{REAL}(.dim)
      a :: INT
      do a = 1,.dim
         res(a) = self(a).vdw_radius_ccdc
      end
   end

   get_covalent_radii_ccdc(radii) 
   ! Returns the CCDC covalent radius for this atom
      radii :: VEC{REAL}(.dim)
      a :: INT
      do a = 1,.dim
         radii(a) = self(a).covalent_radius_ccdc
      end
   end

   get_vdw_radii_ccdc(radii) 
   ! Returns the CCDC vdw radius for this atom
      radii :: VEC{REAL}(.dim)
      a :: INT
      do a = 1,.dim
         radii(a) = self(a).vdw_radius_ccdc
      end
   end

!  ********************************
!  Moments, fields, field gradients
!  ********************************

   nuclear_dipole_moment result (res)
   ! Return the dipole moment obtained from the atomic numbers.
   ! Dummy nuclear charges are not included
      res :: VEC{REAL}(3)
      a :: INT
      res = ZERO
      do a = 1,.dim
         res = res + self(a).atomic_number*self(a).position
      end
   end

   nuclear_quadrupole_moment result (res)
   ! Return the quadrupole moment obtained from the nuclear charges
   ! as a vector, in the order: xx, yy, zz, xy, xz, yz
   ! Dummy nuclear charges are not included
      res :: VEC{REAL}(6)
       Z :: REAL
       a :: INT
      res = ZERO
      do a = 1,.dim
         Z = self(a).atomic_number
         res(1) = res(1) + Z * self(a).position(1) * self(a).position(1)
         res(2) = res(2) + Z * self(a).position(2) * self(a).position(2)
         res(3) = res(3) + Z * self(a).position(3) * self(a).position(3)
         res(4) = res(4) + Z * self(a).position(1) * self(a).position(2)
         res(5) = res(5) + Z * self(a).position(1) * self(a).position(3)
         res(6) = res(6) + Z * self(a).position(2) * self(a).position(3)
      end
   end

   nuclear_octupole_moment result (res)
   ! Return the octupole moment obtained from the nuclear charges as a vector,
   ! in the order: xxx, yyy, zzz, xxy, xxz, yyx, yyz, zzx, zzy, xyz
   ! Dummy nuclear charges are not included
      res :: VEC{REAL}(10)
      Z :: REAL
      a :: INT
      res = ZERO
      do a = 1,.dim
         Z = self(a).atomic_number
         res(1)  = res(1)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(1)
         res(2)  = res(2)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(2)
         res(3)  = res(3)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(3)
         res(4)  = res(4)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(2)
         res(5)  = res(5)  + Z * self(a).position(1) * self(a).position(1) * self(a).position(3)
         res(6)  = res(6)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(1)
         res(7)  = res(7)  + Z * self(a).position(2) * self(a).position(2) * self(a).position(3)
         res(8)  = res(8)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(1)
         res(9)  = res(9)  + Z * self(a).position(3) * self(a).position(3) * self(a).position(2)
         res(10) = res(10) + Z * self(a).position(1) * self(a).position(2) * self(a).position(3)
      end
   end

   nuclear_E_field_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields
   ! at the nuclei as a (3 x .dim) array
      res :: MAT{REAL}(3,size(self))
      Z,r :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)
      res = ZERO
      do a = 1,.dim
         do b = 1,.dim
            if (b==a) cycle
            Z  = self(b).nuclear_charge
            ab = self(a).position - self(b).position
            r  = ab.norm
            res(:,a) = res(:,a) + Z*ab/(r*r*r)
         end
      end
   end

   nuclear_EFG_at_nuclei result (res)
   ! Return the nuclear contribution to the electric fields gradient
   ! (EFG) at the nuclei as a (6 x .dim) array
      res :: MAT{REAL}(6,size(self))
      Z,r,r3,r5 :: REAL
      a,b :: INT
      ab :: VEC{REAL}(3)
      res = ZERO
      do a = 1,.dim
         do b = 1,.dim
            if (b==a) cycle
            Z  = self(b).nuclear_charge
            ab = self(a).position - self(b).position
            r  = ab.norm
            r3 = r*r*r
            r5 = r3*r*r
            res(1,a) = res(1,a) - Z * (THREE*ab(1)*ab(1)/r5 - ONE/r3)
            res(2,a) = res(2,a) - Z * (THREE*ab(2)*ab(2)/r5 - ONE/r3)
            res(3,a) = res(3,a) - Z * (THREE*ab(3)*ab(3)/r5 - ONE/r3)
            res(4,a) = res(4,a) - Z * (THREE*ab(1)*ab(2)/r5)
            res(5,a) = res(5,a) - Z * (THREE*ab(1)*ab(3)/r5)
            res(6,a) = res(6,a) - Z * (THREE*ab(2)*ab(3)/r5)
         end
      end
   end

!  ************************
!  Atom kinds, unique atoms
!  ************************

   same_kind_of_atoms(a,b) result (res)
   ! Return true if atoms "a" and "b" are the same kind
      a,b :: INT
      res :: BIN
      res = self(a).same_kind_as(self(b))
   end

   make_atom_kind_count(cnt,n_kind) ::: leaky
   ! Return an array "cnt" in which each element represents an atom,
   ! and the value of that array element is a count of the number of
   ! atoms of that kind.  Later atoms (i.e. array elements) which are
   ! of the same kind as earlier atoms have a count equal to the minus
   ! of the index of the earlier atom they are equivalent to. The
   ! number of different kinds is returned in "n_kind".
      cnt :: VEC{INT}*
      n_kind :: INT

      n,l,n_atom :: INT

      n_atom = .dim

      cnt.create(n_atom)
      cnt = 1

      do n = 1,n_atom
         if (cnt(n)<0) cycle
         do l = n+1,n_atom
            if (cnt(l)<0) cycle
            if (NOT .same_kind_of_atoms(l,n)) cycle
            cnt(n) = cnt(n)+1
            cnt(l) = -n
         end
      end

      n_kind = count(cnt>0)

   end

   make_atom_kind_list(atom_kind) ::: leaky
   ! Make the atom kind list ... atom_kind(k).element(c) is the c-th
   ! atom of the same kind as atom k, which is a unique kind.
      atom_kind :: VEC{VEC_{INT}}*

      cnt :: VEC{INT}*
      n,l,k,c,n_atom :: INT

      .make_atom_kind_count(cnt,n)

      nullify(atom_kind)
      atom_kind.create(n)

      n_atom = .dim

      k = 0
      do n = 1,n_atom
         if (cnt(n)<0) cycle
         k = k+1
         c = 1
         atom_kind(k).element.create(cnt(n))
         atom_kind(k).element(c) = n
         do l = n+1,n_atom
            if (cnt(l)/=-n) cycle
            c = c+1
            atom_kind(k).element(c) = l
         end
      end

      cnt.destroy

      ! Now sort into descending atomic number
    ! indices.create(atom_kind.dim)
    ! self(atom_kind.element(1)).atomic_number.quick_sort(indices,decreasing_order=TRUE)
    ! atom_kind = atom_kind(indices)
    ! indices.destroy

   end

   make_atom_kind_list(atom_kind,n_kind)
   ! Make a different atom kind list ... atom_kind(k) is the kind
   ! index of the k-th atom. (Same effect as the make_atom_kind_map
   ! routine).
      atom_kind :: VEC{INT}
      n_kind :: INT

   ENSURE(atom_kind.dim==.dim,"atom_kind is incorrectly dimensioned")

      n_atom,n,l :: INT

      n_atom = .dim
      atom_kind = [ (n, n=1,n_atom) ]

      n_kind = 0
      do n = 1,n_atom

         if (atom_kind(n)<=n_kind) cycle

         n_kind = n_kind + 1
         atom_kind(n) = n_kind
         do l = n+1,n_atom
            if (atom_kind(l)<=n_kind) cycle
            if (NOT .same_kind_of_atoms(l,n)) cycle
            atom_kind(l) = n_kind
         end

      end

   end

   make_unique_atom_list(unique_atom)
   ! "unique_atom(k)" is the index of the first atom which represents all the
   ! the atoms which are of the same kind, k.
      unique_atom :: VEC{INT}

      atom_kind :: VEC{INT}*
      n_kind,k,pos :: INT

      ! Make the atom kind list
      atom_kind.create(.dim)
      .make_atom_kind_list(atom_kind,n_kind)

      ! Check size
      DIE_IF(unique_atom.dim/=n_kind,"unique atom incorrectly dimensioned")

      ! Make the list
      do k = 1,n_kind
         pos = atom_kind.index_of_value(k)
         ENSURE(pos/=0,"atom kind "// trim(k.to_str) //" does not exist!")
         unique_atom(k) = pos
      end

      ! Clean
      atom_kind.destroy

   end

   make_atom_kind_map(map)
   ! Make an atom kind array "map", where map(a) is the unique atom kind
   ! corresponding to atom index a.
      map :: VEC{INT}*
      atom_kind :: VEC{VEC_{INT}}*
      n_k,k,kk :: INT
      map.create(size(self))
      .make_atom_kind_list(atom_kind)
      n_k = size(atom_kind)
      do k  = 1,n_k
      do kk = 1,size(atom_kind(k).element)
         map(atom_kind(k).element(kk)) = k
      end
      end
      atom_kind.destroy
   end

   are_distinct(a,b) result (res)
   ! Return true if atoms "a" and "b" are crystallographically
   ! distinct based on occupancy and atomic number
      a,b :: INT
      res :: BIN
      res = self(a).atomic_number      /=self(b).atomic_number &
        OR  self(a).site_occupancy     /=self(b).site_occupancy &
        OR  self(a).site_disorder_group/=self(b).site_disorder_group 
   end

!  ***********
!  Atom groups
!  ***********

   groups_defined result (res)
   ! Return TRUE if any atom groups have been defined
   ! This only counts if there is more than one group!
      res :: BIN
      if (any(self(:).group>1)) then; res = TRUE
      else;                           res = FALSE
      end
   end

   find_connected_groups
   ! This routine searches through the list of atoms as assigns each atom the
   ! same group number if the atom is a part of the same connected molecule.
      n,a,b :: INT
      found :: BIN
      n = 1
      a = 1
      self(a).group = n  ! atom 1 is in group 1
      do a = 2,.dim
         found = FALSE
         do b = 1,a-1
            if (NOT self(a).is_bonded_to(self(b))) cycle
            found = TRUE
            exit
         end
         if (found) then
            self(a).group = self(b).group
         else
            n = n + 1
            self(a).group = n
         end
      end
   end

   make_atom_group_list(atom_group) ::: leaky
   ! This routine finds all the atoms in the same group and makes
   ! their indices as a atom_group of integers. The result is a
   ! "atom_group" of atom_group of integers. NOTE that "atom_group" is
   ! created.
      atom_group :: VEC{VEC_{INT}}*

      n_group,g,n,i :: INT
      group_indices :: VEC{INT}*

      ! Extract the group indices
      group_indices.create(.dim)
      group_indices = self.group
      n_group = group_indices.no_of_unique_elements

      ! Create the atom_group list of indices
      atom_group.create(n_group)

      ! All atoms in one group, size .dim
      if (n_group==1) then
         atom_group(1).element.create(.dim)
         atom_group(1).element = [ (i, i=1,.dim) ]
      ! Atoms in different groups, size n_group
      else
        do g = 1,n_group
           n = count(group_indices==g)
           DIE_IF(n==0,"group indices are not sequential!")
           atom_group(g).element.create(n)
           atom_group(g).element = pack( [ (i, i=1,.dim) ], group_indices==g)
        end
      end

      ! Clean
      group_indices.destroy

   end

!  *************************
!  Shell information methods
!  *************************

   make_shell_limits(first,last,momentum) ::: leaky
   ! Get the shell function limit vectors "first" and "last" for
   ! corresponding to the concatenated vector of atomvec shells. Also
   ! get the angular "momentum" for the shell.
      first,last,momentum :: VEC{INT}*

      a,as,n,ss,f,l :: INT

      nullify(first);    first.create(.n_shell)
      nullify(last);     last.create(.n_shell)
      nullify(momentum); momentum.create(.n_shell)

      ss = 0; l = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         do as = 1,n
            ss = ss + 1
            f = l + 1
            l = f + self(a).basis.shell(as).n_bf - 1
            first(ss) = f
            last(ss)  = l
            momentum(ss) = self(a).basis.shell(as).l
         end
      end
   end

   make_atom_basis_fn_limits(first,last) ::: leaky
   ! Get the first and last basis functions for the atoms
      first,last :: VEC{INT}*

      a,as,n,l :: INT

      nullify(first); first.create(.dim)
      nullify(last);  last.create(.dim)

      l = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         first(a) = l + 1
         do as = 1,n
            l = l + self(a).basis.shell(as).n_bf
         end
         last(a) = l
      end

   end

   make_primitive_limits(frst,last,atom,lmom,expo) ::: leaky
   ! Get the primitive function limit vectors "frst" and "last" and
   ! other data pertaining to the primitive function corresponding to
   ! the concatenated bases of all the atoms. 
      frst,last,atom,lmom :: VEC{INT}*
      expo :: VEC{REAL}*
      basis :: BASIS*
      shell :: SHELL*
      nps,a,as,ap,p,f,l :: INT
      nps = .no_of_primitive_shells
      frst.create(nps)
      last.create(nps)
      atom.create(nps)
      lmom.create(nps)
      expo.create(nps)
      p = 0; l = 0
      do a = 1,.dim
         basis => self(a).basis
         do as = 1,basis.n_shell
            shell => basis.shell(as)
            do ap = 1,shell.n_cc
               p = p + 1
               f = l + 1
               l = l + shell.n_bf
               frst(p) = f
               last(p) = l
               atom(p) = a
               lmom(p) = shell.l
               expo(p) = shell.exponent(ap)
            end
         end
      end
   end

!  ******************************
!  Atom-shell information methods
!  ******************************

   atom_for_shell(s) result(a)
   ! Return the *atom* number "a" corresponding to the
   ! *atomvec* shell number "s"
      a,s :: INT
      ss,n :: INT
      ss = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         ss = ss + n
         if (s<=ss) exit
      end
   end

   atom_for_shell result (res) ::: leaky
   ! Return a vector of *atom* numbers corresponding to the
   ! vector of *atomvec* shell numbers
      res :: VEC{INT}*
      a,ss,n :: INT
      nullify(res); res.create(.n_shell)
      ss = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         res(ss+1:ss+n) = a
         ss = ss + n
      end
   end

   atom_shell_for_shell(s) result(as)
   ! Return the *atom* shell number "as" corresponding to the
   ! *atomvec* shell number "s"
      s :: INT
      as :: INT

   ENSURE(.dim>0,"no atoms")

      a,ss,n :: INT

      n = 0
      ss = 0
      do a = 1,.dim
         ENSURE(self(a).basis.created,"no basis for atom "//trim(a.to_str))
         n = self(a).basis.n_shell
         ss = ss + n
         if (s<=ss) exit
      end

      as = s - ss + n

   end

   atom_shell_for_shell result (res) ::: leaky
   ! Return a vector of *atom* shell numbers corresponding to the
   ! *atomvec* shell number vector
      res :: VEC{INT}*
      a,ss,n,as :: INT
      nullify(res); res.create(.n_shell)
      ss = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         do as = 1,n
            res(ss+as) = as
         end
         ss = ss + n
      end
   end

   first_shell_for_atom(a) result (res)
   ! Return the index of the first shell for atom "a" in the atomvec
      a,res :: INT
      at,n :: INT
      res = 1
      do at = 1,(a-1)
         n = self(a).basis.n_shell
         res = res + n
      end
   end

   make_shell_for_atom_limits(first,last)
   ! Return the indices of the first and last shell for each atom in the atomvec
      first,last :: VEC{INT}
      ss,a,n :: INT
      ss = 0
      do a = 1,.dim
         first(a) = ss + 1
         n = self(a).basis.n_shell
         ss = ss + n
         last(a) = ss
      end
   end

   first_shell_for_atom result (res) ::: leaky
   ! Return the indices of the first shell for an atom in the atomvec
      res :: VEC{INT}*
      ss,a,n :: INT
      nullify(res); res.create(size(self))
      ss = 0
      do a = 1,.dim
         n = self(a).basis.n_shell
         res(a) = ss + 1
         ss = ss + n
      end
   end

!  ***************
!  Invariom labels
!  ***************

   neighbours_of(a,range_factor) result (res) ::: leaky
   ! Return the list of atoms bonded to atom "a".
      a :: INT
      range_factor :: REAL, optional
      res :: VEC{INT}*
      b :: INT
      nullify(res)
      do b = 1,.dim
         if (b==a) cycle
         if (NOT .bonded(a,b,range_factor)) cycle 
         res.append(b)
      end
   end

   is_next_neighbour_chiral(a) result (res) ::: leaky
   ! Return TRUE if there are four next nearest neighbours for the
   ! atom "a", and if they are all different.
      a :: INT
      res :: BIN
      neighbour :: VEC{INT}*
      Z :: VEC{INT}(4)
      neighbour => .neighbours_of(a)
      if (neighbour.destroyed) then
         res = FALSE
      else if (neighbour.dim==4) then
         Z = self(neighbour).atomic_number
         res = NOT Z.has_repetitions
      else
         res = FALSE
      end
      neighbour.destroy
   end

   next_neighbour_handedness_of(a) result (res) ::: leaky
   ! Return the handedness of the atom "a" based only on the four
   ! connecting atoms around it.
      a :: INT
      res :: STR
      n :: INT
      p2,p3,p4,pc :: VEC{REAL}(3)
      Z,order :: VEC{INT}(4)
      neighbour :: VEC{INT}*

      neighbour => .neighbours_of(a)
      DIE_IF(neighbour.destroyed,"there are no neighbours")
      n = neighbour.dim
      DIE_IF(neighbour.dim/=4,"must have four neighbours, n = "//trim(n.to_str))
    ! stdout.show("neighbours =",neighbour)

      Z = self(neighbour).atomic_number
      Z.quick_sort(order)
      neighbour = neighbour(order)
    ! stdout.show("sorted neighbours =",neighbour)

      p2 = self(neighbour(2)).position - self(a).position
      p3 = self(neighbour(3)).position - self(a).position
      p4 = self(neighbour(4)).position - self(a).position
      pc = p4.cross(p3)
      if (p2.dot(pc)>ZERO) then; res = "R"
      else;                      res = "S"
      end

      neighbour.destroy

   end


   invariom_labels result (res) ::: leaky
   ! Return the invariom label for the atom "a"
      res :: VEC{STR}*
      a :: INT
      res.create(.dim)
      do a = 1,.dim
         res(a) = .invariom_label_of(a)
      end
   end

   invariom_label_of(a) result (res)
   ! Return the invariom label for the atom "a"
      a :: INT
      res :: STR

      special_Z :: VEC{INT}(3) = [1,15,16]
      i,j,n,m,f2,l2,p :: INT
      Z,bond,order,neighbour,Z2,bond2,order2,neighbour2 :: VEC{INT}*
      bonds,bonds2,mesomer,ZZ :: VEC{STR}*
      special,do_2nd_neighbour :: BIN
      symbol :: STR

      ! Start with the R or S symbol, if the atom is chiral
      if (.is_next_neighbour_chiral(a)) then; res = trim(.next_neighbour_handedness_of(a))//"-"
      else;                                   res = " "
      end

      ! Start with "a" atoms chemical symbol
      res = trim(res)//self(a).chemical_symbol

      ! Get indices of the nearest neighbours; return if no neighbours
      neighbour => .neighbours_of(a)
      if (neighbour.destroyed) return
      neighbour.prune(a)
      if (neighbour.dim==0) return

      ! Create arrays to store the bond order (times 10) and string
      ! form of bond order
      n = neighbour.dim
      bond.create(n)
      bonds.create(n)

      ! Get the atomic numbers Z of neighbors and order them in 
      ! decreasing bond-order/atomic number
      Z.create(n)
      order.create(n)
      Z = self(neighbour).atomic_number
      .allred_rochow_bond_orders(a,neighbour,bond,bonds)
      Z = 1000*bond + Z
      Z.quick_sort(order,decreasing_order=TRUE)
      neighbour = neighbour(order)
      bond  = bond(order)
      bonds = bonds(order)
      order.destroy; Z.destroy

      ! If special Z atoms switch on next nearest neighbour
      f2 = 0
      special = FALSE

      if (any(special_Z==self(a).atomic_number)) then
         f2 = 1
         l2 = bond.dim
         special = TRUE

      ! Find out how many mesomeric bonds there are
      else
         f2 = bond.index_of_value(15)
         l2 = 0
         if (f2>0) then
            if      (f2==bond.dim) then;       l2 = f2
            else if (bond(bond.dim)==15) then; l2 = bond.dim
            else;                              l2 = bond(f2+1:).index_of_value_ne_to(15)
                                               l2 = f2 + l2 - 1
            end
         end
      end

      do_2nd_neighbour = f2>0 AND l2>=f2

      nullify(mesomer)

      ! If we should do second nearest neighbours ...
      if (do_2nd_neighbour) then

         mesomer.create(f2,l2); mesomer = " "
         ZZ.create(f2,l2);      ZZ = "0"

         ! Loop over second nearest neighbour atoms or mesomeric atoms
         do i = f2,l2

            ! Get indices of the 2nd nearest neighbours; return if no neighbours
            neighbour2 => .neighbours_of(neighbour(i))
            DIE_IF(neighbour2.destroyed,"mesomeric atom has no neighbours")

            ! We don't want the original first neighbour
            neighbour2.prune(a)
            if (neighbour2.dim==0) then
               neighbour2.destroy
               cycle
            end

            ! Order the 2nd nearest neighbours in decreasing bond-order/atomic number
            m = neighbour2.dim
            bond2.create(m)
            bonds2.create(m)
            Z2.create(m)
            order2.create(m)
            Z2 = self(neighbour2).atomic_number
            .allred_rochow_bond_orders(neighbour(i),neighbour2,bond2,bonds2)
            Z2 = 1000*bond2 + Z2
            Z2.quick_sort(order2,decreasing_order=TRUE)
            neighbour2 = neighbour2(order2)
            Z2 = Z2(order2)
            bond2 = bond2(order2)
            bonds2 = bonds2(order2)

           ! Make and store the unsorted mesomer 2nd nearest neighbour invariom names
            mesomer(i) = achar(91)
            do j = 1,m
               symbol = self(neighbour2(j)).chemical_symbol
               mesomer(i) = trim(mesomer(i))// &
                            trim(bonds2(j))// &
                            trim(symbol.lower_cased)
            end
            mesomer(i) = trim(mesomer(i))//achar(93)

            ! Make the 2nd nearest neighbour ordering string ZZ
            p = 1
            do j = 1,m
               ZZ(i)(p:p+3) = trim(Z2(j).to_str)
               p = p + 4
            end

            order2.destroy
            Z2.destroy
            bonds2.destroy
            bond2.destroy
            neighbour2.destroy
         end

         ! Now reorder the mesomer strings according to ZZ
         if (l2>f2) then
            order.create(f2,l2)
            ZZ.quick_sort(order,decreasing_order=TRUE)
            order = order + f2 - 1
            neighbour(f2:l2) = neighbour(order)
            mesomer(f2:l2) = mesomer(order)
            order.destroy
         end

         ZZ.destroy

      end

      ! Now everything is sorted; just make the invariom label
      res = res.trim_blanks_from_start
      do i = 1,n
         symbol = self(neighbour(i)).chemical_symbol
         res = trim(res)//trim(bonds(i))//trim(symbol.lower_cased)
         if (bond(i)==15 OR special) then
            res = trim(res)//trim(mesomer(i))
         end
      end

      mesomer.destroy; bonds.destroy; bond.destroy; neighbour.destroy
   end

   put_invariom_labels
   ! Print out the invariom labels
      a :: INT
      do a = 1,.dim
         stdout.show("label for atom "//trim(a.to_str)//" = ",.invariom_label_of(a))
      end
   end

   allred_rochow_bond_orders(a,neighbours,bond,bonds)
   ! Given at atom "a" and its "neighbours" return the allred-rochow
   ! bond distinguishing parameters "bond" (times 10) and the
   ! cooresponding string form.
      a :: INT, IN
      neighbours :: VEC{INT}, IN
      bond :: VEC{INT}, OUT
      bonds :: VEC{STR}, OUT

   ENSURE(0<a AND a <=.dim,"index a out of range")
   ENSURE(bond.dim==neighbours.dim,"bond array, wrong size")
   ENSURE(bonds.dim==neighbours.dim,"bond array, wrong size")

      i,b :: INT
      br :: REAL

      do i = 1,neighbours.dim
         b = .bond_distinguisher(a,neighbours(i))
         bond(i) = b
         if (b==15) then
            br = b/TEN
            bonds(i) = br.to_str("f3.1")
         else
            b = b/10
            bonds(i) = b.to_str
         end
      end
   end

   bond_distinguisher(a,b) result (res)
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      a,b :: INT, IN
      res :: INT

      d,chi,cra,crb,ena,enb :: REAL

      d = .bond_distance(a,b)*ANGSTROM_PER_BOHR

      cra = self(a).invariom_covalent_radius 
      crb = self(b).invariom_covalent_radius 

      ena = self(a).allred_rochow_en
      enb = self(b).allred_rochow_en

      chi = cra + crb - 0.08 * abs(ena-enb) - d

      res = 0
           if (chi <= 0.0847 ) then; res = 10
      else if (chi <= 0.184 )  then; res = 15
      else if (chi <= 0.27 )   then; res = 20
      else if (chi >  0.27 )   then; res = 30
      end

   end


   smiles_invariom_labels result (res) ::: leaky
   ! Return the invariom label for the atom "a"
      res :: VEC{STR}*
      a :: INT
      res.create(.dim)
      do a = 1,.dim
         res(a) = .smiles_invariom_label_of(a)
      end
   end

   smiles_invariom_label_of(a) result (res)
   ! Return the invariom label for the atom "a"
      a :: INT
      res :: STR

      special_Z :: VEC{INT}(3) = [1,15,16]
      i,j,n,m,f2,l2,p :: INT
      Z,bond,order,neighbour,Z2,bond2,order2,neighbour2 :: VEC{INT}*
      bonds,bonds2,mesomer,ZZ :: VEC{STR}*
      special,do_2nd_neighbour :: BIN
      symbol :: STR

      ! Start with the R or S symbol, if the atom is chiral
      if (.is_next_neighbour_chiral(a)) then; res = trim(.next_neighbour_handedness_of(a))//"-"
      else;                                   res = " "
      end

      ! Start with "a" atoms chemical symbol
      res = trim(res)//self(a).chemical_symbol

      ! Get indices of the nearest neighbours; return if no neighbours
      neighbour => .neighbours_of(a)
      if (neighbour.destroyed) return
      neighbour.prune(a)
      if (neighbour.dim==0) return

      ! Create arrays to store the bond order (times 10) and string
      ! form of bond order
      n = neighbour.dim
      bond.create(n)
      bonds.create(n)

      ! Get the atomic numbers Z of neighbors and order them in 
      ! decreasing bond-order/atomic number
      Z.create(n)
      order.create(n)
      Z = self(neighbour).atomic_number
      .smiles_bond_orders(a,neighbour,bond,bonds)
      Z = 1000*bond + Z
      Z.quick_sort(order,decreasing_order=TRUE)
      neighbour = neighbour(order)
      bond  = bond(order)
      bonds = bonds(order)
      order.destroy; Z.destroy

      ! If special Z atoms switch on next nearest neighbour
      f2 = 0
      special = FALSE

      if (any(special_Z==self(a).atomic_number)) then
         f2 = 1
         l2 = bond.dim
         special = TRUE

      ! Find out how many mesomeric bonds there are
      else
         f2 = bond.index_of_value(15)
         l2 = 0
         if (f2>0) then
            if      (f2==bond.dim) then;       l2 = f2
            else if (bond(bond.dim)==15) then; l2 = bond.dim
            else;                              l2 = bond(f2+1:).index_of_value_ne_to(15)
                                               l2 = f2 + l2 - 1
            end
         end
      end

      do_2nd_neighbour = f2>0 AND l2>=f2

      nullify(mesomer)

      ! If we should do second nearest neighbours ...
      if (do_2nd_neighbour) then

         mesomer.create(f2,l2); mesomer = " "
         ZZ.create(f2,l2);      ZZ = "0"

         ! Loop over second nearest neighbour atoms or mesomeric atoms
         do i = f2,l2

            ! Get indices of the 2nd nearest neighbours; return if no neighbours
            neighbour2 => .neighbours_of(neighbour(i))
            DIE_IF(neighbour2.destroyed,"mesomeric atom has no neighbours")

            ! We don't want the original first neighbour
            neighbour2.prune(a)
            if (neighbour2.dim==0) then
               neighbour2.destroy
               cycle
            end

            ! Order the 2nd nearest neighbours in decreasing bond-order/atomic number
            m = neighbour2.dim
            bond2.create(m)
            bonds2.create(m)
            Z2.create(m)
            order2.create(m)
            Z2 = self(neighbour2).atomic_number
            .smiles_bond_orders(neighbour(i),neighbour2,bond2,bonds2)
            Z2 = 1000*bond2 + Z2
            Z2.quick_sort(order2,decreasing_order=TRUE)
            neighbour2 = neighbour2(order2)
            Z2 = Z2(order2)
            bond2 = bond2(order2)
            bonds2 = bonds2(order2)

           ! Make and store the unsorted mesomer 2nd nearest neighbour invariom names
            mesomer(i) = "("
            do j = 1,m
               symbol = self(neighbour2(j)).chemical_symbol
               mesomer(i) = trim(mesomer(i))// &
                            trim(bonds2(j))// &
                            trim(symbol.lower_cased)
            end
            mesomer(i) = trim(mesomer(i))//")"

            ! Make the 2nd nearest neighbour ordering string ZZ
            p = 1
            do j = 1,m
               ZZ(i)(p:p+3) = trim(Z2(j).to_str)
               p = p + 4
            end

            order2.destroy
            Z2.destroy
            bonds2.destroy
            bond2.destroy
            neighbour2.destroy
         end

         ! Now reorder the mesomer strings according to ZZ
         if (l2>f2) then
            order.create(f2,l2)
            ZZ.quick_sort(order,decreasing_order=TRUE)
            order = order + f2 - 1
            neighbour(f2:l2) = neighbour(order)
            mesomer(f2:l2) = mesomer(order)
            order.destroy
         end

         ZZ.destroy

      end

      ! Now everything is sorted; just make the invariom label
      res = res.trim_blanks_from_start
      res = trim(res)//"("
      do i = 1,n
         symbol = self(neighbour(i)).chemical_symbol
         res = trim(res)//trim(bonds(i))//trim(symbol.lower_cased)
         if (bond(i)==15 OR special) then
            res = trim(res)//trim(mesomer(i))
         end
      end
      res = trim(res)//")"

      mesomer.destroy; bonds.destroy; bond.destroy; neighbour.destroy

   end

   put_smiles_invariom_labels
   ! Print out the invariom labels
      a :: INT
      do a = 1,.dim
         stdout.show("label for atom "//trim(a.to_str)//" = ",.smiles_invariom_label_of(a))
      end
   end

   smiles_bond_orders(a,neighbours,bond,bonds)
   ! Given at atom "a" and its "neighbours" return the allred-rochow
   ! bond distinguishing parameters "bond" (times 10) and the
   ! cooresponding string form.
      a :: INT, IN
      neighbours :: VEC{INT}, IN
      bond :: VEC{INT}, OUT
      bonds :: VEC{STR}, OUT

   ENSURE(0<a AND a <=.dim,"index a out of range")
   ENSURE(bond.dim==neighbours.dim,"bond array, wrong size")
   ENSURE(bonds.dim==neighbours.dim,"bond array, wrong size")

      i,b :: INT

      do i = 1,neighbours.dim
         b = .bond_distinguisher(a,neighbours(i))
         bond(i) = b
         select case (b)
         case (10);    bonds(i) = "-"
         case (15);    bonds(i) = ":"
         case (20);    bonds(i) = "="
         case (25);    bonds(i) = "%"
         case (30);    bonds(i) = "#"
         case default; bonds(i) = "?"
         end
      end
   end


!  *****************
!  Protein detection
!  *****************

   find_N_terminal_atoms
   ! Print the indices of the N terminal atoms.
      list :: VEC{INT}* 
      .make_connection_table(skip_hydrogen=TRUE)
      .find_N_terminal_atoms(list) 
      stdout.text("List of N terminal atoms:")
      stdout.put(list)
      list.destroy
      connections_for.destroy
   end

   find_N_terminal_atoms(list) ::: leaky
   ! Print the indices of the protein backbone atoms.
      list :: VEC{INT}* 
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
      N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT
      N_terminal :: BIN
      list.create(0)                           
      do N = 1,.dim                           
        if (self(N).atomic_number/=7) cycle
        Cp0 = 0
        if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) cycle
        if (NOT N_terminal) cycle
        list.append(N)
      end
   end


   find_protein_backbone
   ! Return the of indices of the N terminal atoms.
      backbone :: VEC{VEC_{INT}}* 
      .make_connection_table(skip_hydrogen=TRUE)
      .find_protein_backbone(backbone) 
      backbone.destroy
      connections_for.destroy
   end

   find_protein_backbone(backbone) ::: leaky
   ! Return the "backbone" of atom indices in each protein backbone.
      backbone :: VEC{VEC_{INT}}* 

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      terminal :: VEC{INT}*
      N_terminal :: BIN
      i, N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT

      .find_N_terminal_atoms(terminal)

      backbone.create(terminal.dim,1)

      do i = 1,terminal.dim

        N = terminal(i)
        backbone(i)[1] = N
        Cp0 = 0

        do
           if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) exit
           if      (Ot/=0) then
              backbone(i).element.append([Ca,Cp,Ot])
              exit
           else if (Ct/=0) then
              backbone(i).element.append([Ca,Cp,Ct])
              exit
           else
              backbone(i).element.append([Ca,Cp,N1])
              N = N1
              Cp0 = Cp
           end
        end

        stdout.show("Backbone for protein strand =",i)
        stdout.put(backbone(i)[:])
      end

      terminal.destroy

   end

!   find_protein_backbone_from_N(N,C,found,Ca,Cc,N1,Ot)
!   ! Given the index "N" of a nitrogen atom and possibly the index "C"
!   ! of a connected carbon atom, return "found" as TRUE if that
!   ! nitrogen atom is part of a protein backbone. Also return the
!   ! index "Ca" of the C-alpha carbon, the index "Cc" of the C-carboxy
!   ! carbon, and either "N1" the next nitrogen in the backbone, or
!   ! "Ot" the terminal oxygen in the backbone. This assumes a
!   ! connection table has been made.
!     N,C :: INT, IN
!     found :: BIN, OUT
!     Ca,Cc,N1,Ot :: INT, OUT
!
!   ENSURE(connections_for.created,"no connection table")
!   ENSURE(connections_for.dim==.dim,"wrong size connection table")
!   ENSURE(N>0 AND N<=.dim,"N index out of range")
!   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
!   ENSURE(C>=0 AND C<=.dim,"C index out of range")
!
!     nn,na,ia,nc,ic,O2,X :: INT
!
!     ! Set defaults
!     found = FALSE
!     Ca = 0; Cc = 0; N1 = 0; Ot = 0
!
!     ! Check if C is bonded to N
!     if (C>0) then
!        DIE_IF(NOT self(N).is_bonded_to(self(C)),"N is not bonded to C")
!     end
!
!     ! # of connections for N
!     nn = connections_for(N).element.dim                  
!
!     ! A backbone N must have 1 connection and can't have 
!     ! more than 2 connections
!     if (nn<=0) return
!     if (nn >2) return
!
!     ! Get the index of C-alpha atom
!     Ca = connections_for(N)[1]                         
!     if (Ca==C) then
!        DIE_IF(nn<2,"not enough connections to N = "//trim(N.to_str))
!        Ca = connections_for(N)[2]                         
!     end
!
!     ! C-alpha must be a carbon
!     if (self(Ca).atomic_number/=6) return
!
!     ! # of  connections for C-alpha
!     na = connections_for(Ca).element.dim 
!
!     ! C-alpha must have 2 connections (GLY) or 3 connections
!     if (na/=3 AND na/=2) return
!
!     ! Now find C-carboxy carbon
!     do ia = 1,na 
!        Cc = connections_for(Ca)[ia]          ! Index of C-carboxy
!        if (Cc==N) cycle                      ! Cc can't be the first N
!        if (self(Cc).atomic_number/=6) cycle  ! Cc must be a carbon
!        nc = connections_for(Cc).element.dim
!        if (nc/=3) cycle                      ! C-carboxy must have 3 connections
!        O2 = 0                                ! It must have a =O
!        N1 = 0                                ! It must have a -N, or
!        Ot = 0                                ! It must have a terminal -OH
!        do ic = 1,nc
!           X = connections_for(Cc)[ic]
!           if (X==Ca) cycle
!           if (self(X).atomic_number==7) N1 = X
!           if (self(X).atomic_number==8) then
!              if (Ot==0) then; O2 = X
!              else;            Ot = X
!              end
!           end
!        end
!        found = O2/=0 AND (N1/=0 OR Ot/=0)
!        if (found) exit
!     end
!   end


   is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try) result (res)
   ! Return TRUE if "N" is the index of a nitrogen atom in the
   ! backbone of a protein, Cp0-N-Ca-Cp-(N1,Ot,Ct), given also
   ! (possibly) the index "Cp0" of a connected C prime carbon atom.
   ! Return the index "Ca" of the C-alpha carbon, the index of the
   ! beta carbon "Cb" (if it exists), the index "Cp" of the next C
   ! prime carboxy carbon, and either "N1" the next nitrogen in the
   ! backbone, or "Ot" the terminal oxygen in the backbone. If "N" is
   ! an N-terminal atom, return "N_terminal" as TRUE. This assumes a
   ! connection table has been made.
      N,Cp0 :: INT, IN
      Ca,Cb,Cp,N1,Ot,Ct :: INT, OUT
      N_terminal :: BIN, OUT
      try :: BIN, optional
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(N>0 AND N<=.dim,"N index out of range")
   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
   ENSURE(Cp0>=0 AND Cp0<=.dim,"Cp0 index out of range")

      C1,C2,C3,O1, O11,Ca1,N11 :: INT

      res = FALSE
      N_terminal = FALSE

      ! One connection to N: Terminal N-Ca connection
      if (.has_1_connection(N,6,Ca)) then                                         
        res = .is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct)
        N_terminal = TRUE

      ! Two connections to N: Backbone or terminal PRO C1-N-C2 connection
      else if (.has_2_connections(N,6,6,C1,C2)) then                                         

        Ca = 0
        if      (C1==Cp0) then; Ca = C2
        else if (C2==Cp0) then; Ca = C1
        end

        ! We found Cp0, so we know Ca 
        if (Ca/=0) then 
           res = .is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct)

        ! Find which of C1 and C2 is Ca. If requested, determine which
        ! of C1 and C2 is NOT a Cp, which implies N_terminal. Also
        ! check for a terminal proline.
        else 
           if      (.is_protein_C_alpha(C1,N,Cb,Cp,O1,N1,Ot,Ct)) then
              res = TRUE
              Ca = C1
              if (.has_ring(N,C2,[6,6,6])) N_terminal = TRUE
              if (NOT N_terminal AND present(try)) &
                 N_terminal = NOT .is_protein_C_prime_carbon(C2,N,O11,Ca1,N11)
           else if (.is_protein_C_alpha(C2,N,Cb,Cp,O1,N1,Ot,Ct)) then
              res = TRUE
              Ca = C2
              if (.has_ring(N,C1,[6,6,6])) N_terminal = TRUE
              if (NOT N_terminal AND present(try)) &
                 N_terminal = NOT .is_protein_C_prime_carbon(C1,N,O11,Ca1,N11)
           end

        end

      ! Three connections to N: Backbone PRO N-C1C2C3 connection
      ! NOTE: this only works if Cp0 is given
      else if (.has_3_connections(N,6,6,6,C1,C2,C3)) then                                         
        if      (C1==Cp0) then; C1 = C2; C2 = C3; C3 = 0
        else if (C2==Cp0) then; C2 = C3; C3 = 0
        else if (C3==Cp0) then; C3 = 0
        end
        if (C3==0) then
           if      (.is_protein_C_alpha(C1,N,Cb,Cp,O1,N1,Ot,Ct)) then
              if (.has_ring(N,C2,[6,6,6])) then
                 Ca = C1
                 res = TRUE
              end
           else if (.is_protein_C_alpha(C2,N,Cb,Cp,O1,N1,Ot,Ct)) then
              if (.has_ring(N,C1,[6,6,6])) then
                 Ca = C2
                 res = TRUE
              end
           end
        end
      end

   end

   is_protein_C_alpha(Ca,N,Cb,Cp,O1,N1,Ot,Ct) result (res)
   ! Return TRUE if "Ca" is the index of a C-alpha atom in the
   ! backbone of a protein. You must supply the connected nitrogen
   ! atom "N". Returned are the index of the beta carbon "Cb", the
   ! index of the next C prime carboxy carbon "Cp", the connected
   ! oxygen atom "O1", and either the next nitrogen in the
   ! backbone "N1", or "Ot" the terminal oxygen in the backbone. 
   ! NOTE: this is useful for travelling from N terminal to C terminal
   ! Diagram: N-CaCb-Cp=O1-(N1,Ot,Ct)
      Ca,N :: INT, IN
      Cb,Cp,O1,N1,Ot,Ct :: INT, OUT
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(N>0 AND N<=.dim,"N index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")

      C1,C2,C3 :: INT

      res = FALSE

      ! GLY N-Ca-Cp connection
      if (.has_2_connections(Ca,N,6,Cp)) then    
        if      (.is_CCOO_carbon(Cp,Ca,Ot,O1)) then ! two terminal oxygens
           N1 = 0
           Ct = 0
           Cb = 0
           res = TRUE
        else if (.is_CCON_carbon(Cp,Ca,O1,N1)) then ! Cp has =O and next nitrogen
           Ot = 0
           Ct = 0
           Cb = 0
           res = TRUE
        else if (.is_CCOC_carbon(Cp,Ca,O1,Ct)) then ! terminal methyl
           N1 = 0
           Ot = 0
           Cb = 0
           res = TRUE
        else if (.has_2_connections(Cp,Ca,7,N1)) then ! Cp has no oxygen
           Ot = 0
           Ct = 0
           Cb = 0
           res = TRUE
        end

      ! Any other residue, which of C1 and C2 is Cp?
      else if (.has_3_connections(Ca,N,6,6,C1,C2)) then  
        if      (.is_CCOO_carbon(C1,Ca,Ot,O1)) then ! two terminal oxygens
           Cp = C1
           Cb = C2
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C1,Ca,O1,N1)) then ! Cp=C1 has =O and next nitrogen
           Cp = C1
           Cb = C2
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C1,Ca,O1,Ct)) then ! terminal methyl
           Cp = C1
           Cb = C2
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C2,Ca,Ot,O1)) then
           Cp = C2
           Cb = C1
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C2,Ca,O1,N1)) then
           Cp = C2
           Cb = C1
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C2,Ca,O1,Ct)) then ! terminal methyl
           Cp = C2
           Cb = C1
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.has_2_connections(C1,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C1
           Cb = C2
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C2,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C2
           Cb = C1
           Ot = 0
           Ct = 0
           res = TRUE
        end

      ! For non-standard branched residues, which of C1, C2, C3 is Cp?
      else if (.has_4_connections(Ca,N,6,C1,C2,C3)) then  
        if      (.is_CCOO_carbon(C1,Ca,Ot,O1)) then
           Cp = C1
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C1,Ca,O1,N1)) then
           Cp = C1
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C1,Ca,O1,Ct)) then ! terminal methyl
           Cp = C1
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C2,Ca,Ot,O1)) then
           Cp = C2
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C2,Ca,O1,N1)) then
           Cp = C2
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C2,Ca,O1,Ct)) then ! terminal methyl
           Cp = C2
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.is_CCOO_carbon(C3,Ca,Ot,O1)) then
           Cp = C3
           Cb = 0
           N1 = 0
           Ct = 0
           res = TRUE
        else if (.is_CCON_carbon(C3,Ca,O1,N1)) then
           Cp = C3
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.is_CCOC_carbon(C3,Ca,O1,Ct)) then ! terminal methyl
           Cp = C3
           Cb = 0
           N1 = 0
           Ot = 0
           res = TRUE

        else if (.has_2_connections(C1,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C1
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C2,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C2
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        else if (.has_2_connections(C3,Ca,7,N1)) then ! Cp has no oxygen
           Cp = C3
           Cb = 0
           Ot = 0
           Ct = 0
           res = TRUE
        end
      end
   end

   is_protein_C_prime_carbon(Cp,N,O,Ca,N1) result (res)
   ! Return TRUE if "Cp" is the index of a N-Cp-Ca-N1 carbon, where
   ! "N" is the index of a nitrogen bonded to "Cp". If TRUE, "O",
   ! "Ca" and "N1" are returned as the index of the bonded oxygen,
   ! alpha Carbon and previous nitrogen respectively.
      Cp,N :: INT, IN
      O,Ca,N1 :: INT, OUT
      res :: BIN
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE( N>=0 AND  N<=.dim," N index out of range")
      Cb,Cb1,s,x,i :: INT
      list :: VEC{INT}*
      x = 6
      s = 7
      O  = 0
      Ca = 0
      N1 = 0
      res = FALSE
      if (.has_3_connections(Cp,N,8,6,O,Ca)) then      ! Cp=ON connection
        res =  .has_1_connection(O,Cp) &
          AND (.has_2_connections(Ca,Cp,7,N1) &
          OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
          OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1))
      else if (.has_a_connection(Cp,N)) then           ! Cp has no O connection
       if (.has_Z_connections(Cp,6,list)) then
          do i = 1,list.dim
             Ca = list(i)
             res = .has_2_connections(Ca,Cp,7,N1) &
              OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
              OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1)
              if (res) exit
          end
          list.destroy
       end
      end
   end

   is_NCOC_carbon(Cp,N,O,Ca,N1) result (res)
   ! Return TRUE if "Cp" is the index of a N-Cp=O-Ca-N1 carbon, where
   ! "N" is the index of a nitrogen bonded to "Cp". If TRUE, "O",
   ! "Ca" and "N1" are returned as the index of the bonded oxygen,
   ! alpha Carbon and next nitrogen respectively.
      Cp,N :: INT, IN
      O,Ca,N1 :: INT, OUT
      res :: BIN
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE( N>=0 AND  N<=.dim," N index out of range")
      Cb,Cb1,s,x :: INT
      x = 6
      s = 7
      N1 = 0
      if (.has_3_connections(Cp,N,8,6,O,Ca)) then      ! Cp=ON connection
        res =  .has_1_connection(O,Cp) &
          AND (.has_2_connections(Ca,Cp,7,N1) &
          OR   .has_3_connections(Ca,Cp,7,6,N1,Cb) &
          OR   .has_4_connections(Ca,Cp,s,x,x,N1,Cb,Cb1))
      else
        res = FALSE
      end
   end

   is_CCOO_carbon(Cp,Ca,O1,O2) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=OO carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "O2" are returned as the indices of the bonded oxygens.
      Cp,Ca :: INT, IN
      O1,O2 :: INT, OUT
      res :: BIN
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")
      if (.has_3_connections(Cp,Ca,8,8,O1,O2)) then      ! Cp=O1O2 connection
        res = .has_1_connection(O1,Cp) AND .has_1_connection(O2,Cp)
      else
        res = FALSE
      end
   end

   is_CCOC_carbon(Cp,Ca,O1,C) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=OC carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "C" are returned as the indices of the bonded oxygen and terminal
   ! methyl.
      Cp,Ca :: INT, IN
      O1,C :: INT, OUT
      res :: BIN
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"Cp index out of range")
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")
      if (.has_3_connections(Cp,Ca,8,6,O1,C)) then      ! Cp=O1C connection
        res = .has_1_connection(O1,Cp) AND .has_1_connection(C,Cp)
      else
        res = FALSE
      end
   end

   is_CCON_carbon(Cp,Ca,O1,N1) result (res)
   ! Return TRUE if "Cp" is the index of a Ca-Cp=ON carbon, where "Ca"
   ! is the index of an (alpha) carbon bonded to "Cp". If TRUE, "O1" and
   ! "N1" are returned as the indices of the bonded oxygen and
   ! nitrogen atom.
      Cp,Ca :: INT, IN
      O1,N1 :: INT, OUT
      res :: BIN
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(Cp>=0 AND Cp<=.dim,"C index out of range")
      res = .has_3_connections(Cp,Ca,8,7,O1,N1)
   end

!  *****************
!  Connection tables
!  *****************

   make_connection_table(skip_hydrogen) ::: leaky
   ! Make the atom connection table "connections_for".  If
   ! "skip_hydrogen" is present and TRUE, connections are not made to
   ! any hydrogen atom.
      skip_hydrogen :: BIN, optional
      r :: REAL
      if (connections_for.created) return
      r = 0.5d0
      r.convert_from("angstrom")
      ATOM:set_atom_bonded_range_factor(r)
      .make_connection_table(connections_for,skip_hydrogen)
   end

   make_connection_table(connections_for,skip_hydrogen) ::: leaky
   ! Make the atom connection table "connections_for".  If
   ! "skip_hydrogen" is present and TRUE, connections are not made to
   ! any hydrogen atom.
      connections_for :: VEC{VEC_{INT}}* 
      skip_hydrogen :: BIN, optional
      i,j :: INT
      skip_H :: BIN
      skip_H = FALSE
      if (present(skip_hydrogen)) skip_H = skip_hydrogen
      connections_for.create(.dim,0)
      do i = 1,.dim
        if (skip_H) then
           if (self(i).atomic_number==1) cycle
        end
        do j = i+1,.dim
           if (skip_H) then
              if (self(j).atomic_number==1) cycle
           end
           if (NOT self(i).is_bonded_to(self(j))) cycle
           connections_for(i).element.append(j)
           connections_for(j).element.append(i)
        end
      end
   end

!  *********************
!  Atom connection tests
!  *********************

   has_a_connection(X,W) result (res)
   ! Returns TRUE if the atom with index "X" is connected to the atom
   ! with index "W".
      X,W :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = any(connections_for(X)[:]==W)

   end

   has_Z_connection(X,Z) result (res)
   ! Returns TRUE if the atom with index "X" is connected to an atom
   ! with atomic number "Z".
      X,Z :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = any(self(connections_for(X)[:]).atomic_number==Z)

   end

   has_Z_connections(X,Z,list) result (res) ::: leaky
   ! Return "TRUE" if atom "X" has connections to atoms with atomic
   ! number "Z", and if so, return a "list" of the atom indices.
      X,Z :: INT, IN
      list :: VEC{INT}*
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      nx,i,Y :: INT

      res = FALSE
      nx = connections_for(X).element.dim

      if (nx==0) return

      list.create(0)
      do i = 1,nx
        Y = connections_for(X)[i]            ! Index of atom connected to X
        if (self(Y).atomic_number/=Z) cycle  ! Y must have atomic number Z
        list.append(Y)
      end

      res = list.created

   end

   has_0_connections(X) result (res)
   ! Returns TRUE if the atom with index "X" no connection
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      self = self
      res = connections_for(X).element.dim == 0

   end

   has_1_connection(X) result (res)
   ! Returns TRUE if the atom with index "X" only has one connection
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      self = self
      res = connections_for(X).element.dim == 1

   end

   has_1_connection(X,Y) result (res)
   ! Returns TRUE if the atom with index "X" only has one connection
   ! to an atom with index "Y".
      X,Y :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")
   ENSURE(Y>0 AND Y<=.dim,"Y index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = connections_for(X).element.dim == 1
      if (NOT res) return
      res = connections_for(X)[1] == Y

   end

   has_1_connection(X,Z,Y) result (res)
   ! Returns TRUE if the atom with index "X" only has one connection
   ! to an atom with atomic number "Z".If there is a connection, return
   ! the index of the connected atom in "Y".
      X,Z :: INT, IN
      Y   :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      nx :: INT

      res = FALSE
      nx = connections_for(X).element.dim
      if (nx/=1) return

      Y = connections_for(X)[1] 
      if (self(Y).atomic_number/=Z) then
        Y = 0
      else
        res = TRUE
      end

   end

   has_2_connections(X) result (res)
   ! Returns TRUE if the atom with index "X" has two connections
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      self = self
      res = connections_for(X).element.dim == 2

   end

   has_2_connections(X,Y1,Y2) result (res)
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to the atom with index "Y1", the other to the atom with 
   ! index "Y2".
      X,Y1,Y2 :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = connections_for(X).element.dim == 2
      if (NOT res) return
      res = (connections_for(X)[1]==Y1 AND connections_for(X)[2]==Y2) &
         OR (connections_for(X)[2]==Y1 AND connections_for(X)[1]==Y2) 
   end

   has_2_connections(X,Z1,Z2,Y1,Y2) result (res)
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to an atom with atomic number "Z1", the other to an atom with
   ! atomic number "Z2". If there are connectons, return the indices
   ! of these atoms as "Y1" and "Y2" respectively.
      X,Z1,Z2 :: INT, IN
      Y1,Y2 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      A1,A2 :: INT

      Y1 = 0
      Y2 = 0
      res = FALSE
      if (connections_for(X).element.dim/=2) return

      A1 = connections_for(X)[1]
      A2 = connections_for(X)[2]
      if      (self(A1).atomic_number==Z1 AND self(A2).atomic_number==Z2) then
        Y1 = A1
        Y2 = A2
        res = TRUE
      else if (self(A2).atomic_number==Z1 AND self(A1).atomic_number==Z2) then
        Y1 = A2
        Y2 = A1
        res = TRUE
      end
   end

   has_2_connections(X,W,Z,Y) result (res)
   ! Returns TRUE if the atom with index "X" has two connections:
   ! one to the atom with index "W", the other to an atom with atomic
   ! number "Z".If there is a latter connection, return the index of 
   ! atom with atomic number "Z" in "Y".
      X,W,Z :: INT, IN
      Y :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      nx,Y1,Y2 :: INT

      Y = 0
      res = FALSE
      nx = connections_for(X).element.dim
      if (nx/=2) return

      Y1 = connections_for(X)[1] 
      Y2 = connections_for(X)[2] 
      if      (Y1==W AND self(Y2).atomic_number==Z) then
        Y = Y2
        res = TRUE
      else if (Y2==W AND self(Y1).atomic_number==Z) then
        Y = Y1
        res = TRUE
      end
   end

   has_3_connections(X) result (res)
   ! Returns TRUE if the atom with index "X" has three connections
      X :: INT, IN
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      self = self
      res = connections_for(X).element.dim==3

   end

   has_3_connections(X,Z1,Z2,Z3,Y1,Y2,Y3) result (res)
   ! Returns TRUE if the atom with index "X" has three connections:
   ! to atoms with atomic numbers "Z1", "Z2" and "Z3" with the atom
   ! indices returned in "Y1", "Y2" and "Y3".
      X,Z1,Z2,Z3 :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      A1,A2,A3,N1,N2,N3 :: INT

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1] 
      A2 = connections_for(X)[2] 
      A3 = connections_for(X)[3] 

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (Z1==N1 AND Z2==N2 AND Z3==N3) then; Y1=A1; Y2=A2; Y3=A3; res = TRUE
      else if (Z1==N1 AND Z2==N3 AND Z3==N2) then; Y1=A1; Y2=A3; Y3=A2; res = TRUE
      else if (Z1==N2 AND Z2==N1 AND Z3==N3) then; Y1=A2; Y2=A1; Y3=A3; res = TRUE
      else if (Z1==N2 AND Z2==N3 AND Z3==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      else if (Z1==N3 AND Z2==N1 AND Z3==N2) then; Y1=A3; Y2=A1; Y3=A2; res = TRUE
      else if (Z1==N3 AND Z2==N2 AND Z3==N1) then; Y1=A3; Y2=A2; Y3=A1; res = TRUE
      end

   end

   has_3_connections(X,W,Z1,Z2,Y1,Y2) result (res)
   ! Returns TRUE if the atom with index "X" has three connections:
   ! one to the atom with index "W", the other two to atoms with atomic
   ! numbers "Z1" and "Z2".If there are these latter connections,
   ! return the indices of atoms with atomic numbers "Z1" and "Z2" 
   ! in "Y1" and "Y2".
      X,W,Z1,Z2 :: INT, IN
      Y1,Y2 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      A1,A2,A3,N1,N2,N3 :: INT

      Y1 = 0
      Y2 = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1] 
      A2 = connections_for(X)[2] 
      A3 = connections_for(X)[3] 

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (A1==W AND Z1==N2 AND Z2==N3) then; Y1=A2; Y2=A3; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N2) then; Y1=A3; Y2=A2; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N3) then; Y1=A1; Y2=A3; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N1) then; Y1=A3; Y2=A1; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N2) then; Y1=A1; Y2=A2; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N1) then; Y1=A2; Y2=A1; res = TRUE
      end

   end

   has_3_connections(X,V,W,Z,Y) result (res)
   ! Returns TRUE if the atom with index "X" has three connections:
   ! two to atoms "V" and "W", and one to an atom with atomic
   ! numbers "Z".If there is this latter connection, return the
   ! index of this atom in "Y".
      X,V,W,Z :: INT, IN
      Y :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(V>0 AND V<=.dim,"V index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      A1,A2,A3,N1,N2,N3 :: INT

      Y = 0
      res = FALSE

      if (connections_for(X).element.dim/=3) return

      A1 = connections_for(X)[1] 
      A2 = connections_for(X)[2] 
      A3 = connections_for(X)[3] 

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number

      if      (A1==V AND A2==W  AND Z==N1) then; Y=A1; res = TRUE
      else if (A1==W AND A2==V  AND Z==N1) then; Y=A1; res = TRUE
      else if (A1==V AND A2==W  AND Z==N2) then; Y=A2; res = TRUE
      else if (A1==W AND A2==V  AND Z==N2) then; Y=A2; res = TRUE
      else if (A1==V AND A2==W  AND Z==N3) then; Y=A3; res = TRUE
      else if (A1==W AND A2==V  AND Z==N3) then; Y=A3; res = TRUE
      end

   end

   has_4_connections(X) result (res)
   ! Returns TRUE if the atom with index "X" has four connections
      X :: INT, IN
      res :: BIN

   DIE_IF(X<1 OR X>.dim,"X index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      res = connections_for(X).element.dim==4

   end

   has_4_connections(X,W,Z1,Z2,Z3,Y1,Y2,Y3) result (res)
   ! Returns TRUE if the atom with index "X" has four connections: one
   ! to the atom with index "W", the other three to atoms with atomic
   ! numbers "Z1", "Z2" and "Z3".If there are these latter
   ! connections, return the indices of atoms with thse atomic numbers 
   ! in "Y1", "Y2" and "Y3" respectively.
      X,W,Z1,Z2,Z3 :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      A1,A2,A3,A4,N1,N2,N3,N4 :: INT

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=4) return

      A1 = connections_for(X)[1] 
      A2 = connections_for(X)[2] 
      A3 = connections_for(X)[3] 
      A4 = connections_for(X)[4] 

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number
      N4 = self(A4).atomic_number

      if      (A1==W AND Z1==N2 AND Z2==N3 AND Z3==N4) then; Y1=A2; Y2=A3; Y3=A4; res = TRUE
      else if (A1==W AND Z1==N2 AND Z2==N4 AND Z3==N3) then; Y1=A2; Y2=A4; Y3=A3; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N2 AND Z3==N4) then; Y1=A3; Y2=A2; Y3=A4; res = TRUE
      else if (A1==W AND Z1==N3 AND Z2==N4 AND Z3==N2) then; Y1=A3; Y2=A4; Y3=A2; res = TRUE
      else if (A1==W AND Z1==N4 AND Z2==N2 AND Z3==N3) then; Y1=A4; Y2=A2; Y3=A3; res = TRUE
      else if (A1==W AND Z1==N4 AND Z2==N3 AND Z3==N2) then; Y1=A4; Y2=A3; Y3=A2; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N3 AND Z3==N4) then; Y1=A1; Y2=A3; Y3=A4; res = TRUE
      else if (A2==W AND Z1==N1 AND Z2==N4 AND Z3==N3) then; Y1=A1; Y2=A4; Y3=A3; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N1 AND Z3==N4) then; Y1=A3; Y2=A1; Y3=A4; res = TRUE
      else if (A2==W AND Z1==N3 AND Z2==N4 AND Z3==N1) then; Y1=A3; Y2=A4; Y3=A1; res = TRUE
      else if (A2==W AND Z1==N4 AND Z2==N1 AND Z3==N3) then; Y1=A4; Y2=A1; Y3=A3; res = TRUE
      else if (A2==W AND Z1==N4 AND Z2==N3 AND Z3==N1) then; Y1=A4; Y2=A3; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N1 AND Z3==N4) then; Y1=A2; Y2=A1; Y3=A4; res = TRUE
      else if (A3==W AND Z1==N2 AND Z2==N4 AND Z3==N1) then; Y1=A2; Y2=A4; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N2 AND Z3==N4) then; Y1=A1; Y2=A2; Y3=A4; res = TRUE
      else if (A3==W AND Z1==N1 AND Z2==N4 AND Z3==N2) then; Y1=A1; Y2=A4; Y3=A2; res = TRUE
      else if (A3==W AND Z1==N4 AND Z2==N2 AND Z3==N1) then; Y1=A4; Y2=A2; Y3=A1; res = TRUE
      else if (A3==W AND Z1==N4 AND Z2==N1 AND Z3==N2) then; Y1=A4; Y2=A1; Y3=A2; res = TRUE
      else if (A4==W AND Z1==N2 AND Z2==N3 AND Z3==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      else if (A4==W AND Z1==N2 AND Z2==N1 AND Z3==N3) then; Y1=A2; Y2=A1; Y3=A3; res = TRUE
      else if (A4==W AND Z1==N3 AND Z2==N2 AND Z3==N1) then; Y1=A3; Y2=A2; Y3=A1; res = TRUE
      else if (A4==W AND Z1==N3 AND Z2==N1 AND Z3==N2) then; Y1=A3; Y2=A1; Y3=A2; res = TRUE
      else if (A4==W AND Z1==N1 AND Z2==N2 AND Z3==N3) then; Y1=A1; Y2=A2; Y3=A3; res = TRUE
      else if (A4==W AND Z1==N1 AND Z2==N3 AND Z3==N2) then; Y1=A1; Y2=A3; Y3=A2; res = TRUE
      end

   end

   has_4_connections(X,W,Z,Y1,Y2,Y3) result (res)
   ! Returns TRUE if the atom with index "X" has four connections: one
   ! to the atom with index "W", the other three to atoms with atomic
   ! number "Z".If there are these latter connections, return the
   ! indices of atoms with this atomic number in "Y1", "Y2" and "Y3"
   ! respectively.
      X,W,Z :: INT, IN
      Y1,Y2,Y3 :: INT, OUT
      res :: BIN

   ENSURE(X>0 AND X<=.dim,"X index out of range")
   ENSURE(W>0 AND W<=.dim,"W index out of range")
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")

      A1,A2,A3,A4,N1,N2,N3,N4 :: INT

      Y1 = 0
      Y2 = 0
      Y3 = 0
      res = FALSE

      if (connections_for(X).element.dim/=4) return

      A1 = connections_for(X)[1] 
      A2 = connections_for(X)[2] 
      A3 = connections_for(X)[3] 
      A4 = connections_for(X)[4] 

      N1 = self(A1).atomic_number
      N2 = self(A2).atomic_number
      N3 = self(A3).atomic_number
      N4 = self(A4).atomic_number

      if      (A1==W AND Z==N2 AND Z==N3 AND Z==N4) then; Y1=A2; Y2=A3; Y3=A4; res = TRUE
      else if (A2==W AND Z==N1 AND Z==N3 AND Z==N4) then; Y1=A1; Y2=A3; Y3=A4; res = TRUE
      else if (A3==W AND Z==N2 AND Z==N1 AND Z==N4) then; Y1=A2; Y2=A1; Y3=A4; res = TRUE
      else if (A4==W AND Z==N2 AND Z==N3 AND Z==N1) then; Y1=A2; Y2=A3; Y3=A1; res = TRUE
      end

   end

   has_ring(A,B,Z,R) result (res)
   ! Return TRUE if the atoms with indices "A" and "B" form part of a
   ! single connection ring of atoms whose atomic numbers after atom
   ! "B" are given in "Z". NOTE: "A" need not be single connected.
      A,B :: INT, IN
      Z :: VEC{INT}, IN
      R :: VEC{INT}, OUT, optional
      res :: BIN
   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(A>=0 AND A<=.dim,"A index out of range")
   ENSURE(B>=0 AND B<=.dim,"A index out of range")
   ENSURE(Z.dim>0,"Z array too small")
      i,W,X,Y :: INT
      W = A
      X = B
      do i = 1,Z.dim
        res = .has_2_connections(X,W,Z(i),Y)
        if (NOT res) return
        if (present(R)) R(i) = Y
        W = X
        X = Y
      end
      res = .has_a_connection(X,A)
   end

   has_chain(A,B,Z,C) result (res)
   ! Return TRUE if the atoms with indices "A" and "B" form part of a
   ! single connection chain of atoms whose atomic numbers after atom
   ! "B" are given in "Z". 
      A,B :: INT, IN
      Z :: VEC{INT}, IN
      C :: VEC{INT}, OUT, optional
      res :: BIN

   ENSURE(connections_for.created,"no connection table")
   ENSURE(connections_for.dim==.dim,"wrong size connection table")
   ENSURE(A>=0 AND A<=.dim,"A index out of range")
   ENSURE(B>=0 AND B<=.dim,"A index out of range")
   ENSURE(Z.dim>0,"Z array too small")

      i,W,X,Y :: INT

      res = FALSE

      W = A
      X = B
      do i = 1,Z.dim
        res = .has_2_connections(X,W,Z(i),Y)
        if (NOT res) return
        if (present(C)) C(i) = Y
        W = X
        X = Y
      end

   end

!  ********************
!  Amino acid detectors
!  ********************

   put_protein_sequence ::: leaky
   ! Return the "backbone" of atom indices in each protein backbone.

      backbone :: VEC{VEC_{INT}}* 
      terminal :: VEC{INT}*
      N_terminal :: BIN
      i, N,Cp0,Ca,Cb,Cp,N1,Ot,Ct :: INT

      .make_connection_table(skip_hydrogen=TRUE)

      .find_N_terminal_atoms(terminal)

      backbone.create(terminal.dim,1)

      do i = 1,terminal.dim

        N = terminal(i)
        backbone(i)[1] = N
        Cp0 = 0

        stdout.show("Sequence for protein strand =",i)

        do

           if (NOT .is_protein_backbone_N(N,Cp0,Ca,Cb,Cp,N1,Ot,Ct,N_terminal,try=TRUE)) exit

           if      (Ot/=0) then
              backbone(i).element.append([Ca,Cp,Ot])
              exit
           else if (Ct/=0) then
              backbone(i).element.append([Ca,Cp,Ct])
              exit
           else
              backbone(i).element.append([Ca,Cp,N1])
              N = N1
              Cp0 = Cp
           end

           if (Cb==0) then; stdout.text("GLY")
           else;            stdout.text(.protein_side_chain_3_code(Ca,Cb))
           end

        end

      end

      terminal.destroy
      backbone.destroy
      connections_for.destroy

   end

!   find_protein_backbone_from_N(N,C,found,Ca,Cc,N1,Ot)
!   ! Given the index "N" of a nitrogen atom and possibly the index "C"
!   ! of a connected carbon atom, return "found" as TRUE if that
!   ! nitrogen atom is part of a protein backbone. Also return the
!   ! index "Ca" of the C-alpha carbon, the index "Cc" of the C-carboxy
!   ! carbon, and either "N1" the next nitrogen in the backbone, or
!   ! "Ot" the terminal oxygen in the backbone. This assumes a
!   ! connection table has been made.
!     N,C :: INT, IN
!     found :: BIN, OUT
!     Ca,Cc,N1,Ot :: INT, OUT
!
!   ENSURE(connections_for.created,"no connection table")
!   ENSURE(connections_for.dim==.dim,"wrong size connection table")
!   ENSURE(N>0 AND N<=.dim,"N index out of range")
!   ENSURE(self(N).atomic_number==7,"N is not the index of a nitrogen atom")
!   ENSURE(C>=0 AND C<=.dim,"C index out of range")
!
!     nn,na,ia,nc,ic,O2,X :: INT
!
!     ! Set defaults
!     found = FALSE
!     Ca = 0; Cc = 0; N1 = 0; Ot = 0
!
!     ! Check if C is bonded to N
!     if (C>0) then
!        DIE_IF(NOT self(N).is_bonded_to(self(C)),"N is not bonded to C")
!     end
!
!     ! # of connections for N
!     nn = connections_for(N).element.dim                  
!
!     ! A backbone N must have 1 connection and can't have 
!     ! more than 2 connections
!     if (nn<=0) return
!     if (nn >2) return
!
!     ! Get the index of C-alpha atom
!     Ca = connections_for(N)[1]                         
!     if (Ca==C) then
!        DIE_IF(nn<2,"not enough connections to N = "//trim(N.to_str))
!        Ca = connections_for(N)[2]                         
!     end
!
!     ! C-alpha must be a carbon
!     if (self(Ca).atomic_number/=6) return
!
!     ! # of  connections for C-alpha
!     na = connections_for(Ca).element.dim 
!
!     ! C-alpha must have 2 connections (GLY) or 3 connections
!     if (na/=3 AND na/=2) return
!
!     ! Now find C-carboxy carbon
!     do ia = 1,na 
!        Cc = connections_for(Ca)[ia]          ! Index of C-carboxy
!        if (Cc==N) cycle                      ! Cc can't be the first N
!        if (self(Cc).atomic_number/=6) cycle  ! Cc must be a carbon
!        nc = connections_for(Cc).element.dim
!        if (nc/=3) cycle                      ! C-carboxy must have 3 connections
!        O2 = 0                                ! It must have a =O
!        N1 = 0                                ! It must have a -N, or
!        Ot = 0                                ! It must have a terminal -OH
!        do ic = 1,nc
!           X = connections_for(Cc)[ic]
!           if (X==Ca) cycle
!           if (self(X).atomic_number==7) N1 = X
!           if (self(X).atomic_number==8) then
!              if (Ot==0) then; O2 = X
!              else;            Ot = X
!              end
!           end
!        end
!        found = O2/=0 AND (N1/=0 OR Ot/=0)
!        if (found) exit
!     end
!   end

   protein_side_chain_3_code(Ca,Cb) result (res)
   ! Returns the 3 letter code for a side chain connected at carbon
   ! atoms "Ca" and "Cb".
      Ca,Cb :: INT, IN
      res :: STR
   ENSURE(Ca>=0 AND Ca<=.dim,"Ca index out of range")
   ENSURE(Cb>=0 AND Cb<=.dim,"Cb index out of range")
   ENSURE(self(Ca).atomic_number==6,"must suppy index of alpha carbon atom")
   ENSURE(self(Cb).atomic_number==6,"must suppy index of beta carbon atom")
      if      (.has_ALA(Ca,Cb)) then; res = "ALA"
      else if (.has_ARG(Ca,Cb)) then; res = "ARG"
      else if (.has_ASN(Ca,Cb)) then; res = "ASN"
      else if (.has_ASP(Ca,Cb)) then; res = "ASP"
      else if (.has_CYS(Ca,Cb)) then; res = "CYS"
      else if (.has_GLN(Ca,Cb)) then; res = "GLN"
      else if (.has_GLU(Ca,Cb)) then; res = "GLU"
      else if (.has_HIS(Ca,Cb)) then; res = "HIS"
      else if (.has_ILE(Ca,Cb)) then; res = "ILE"
      else if (.has_LEU(Ca,Cb)) then; res = "LEU"
      else if (.has_LYS(Ca,Cb)) then; res = "LYS"
      else if (.has_MET(Ca,Cb)) then; res = "MET"
      else if (.has_PHE(Ca,Cb)) then; res = "PHE"
      else if (.has_SER(Ca,Cb)) then; res = "SER"
      else if (.has_THR(Ca,Cb)) then; res = "THR"
      else if (.has_TRP(Ca,Cb)) then; res = "TRP"
      else if (.has_TYR(Ca,Cb)) then; res = "TYR"
      else if (.has_VAL(Ca,Cb)) then; res = "VAL"
      else;                           res = "UNK"
      end
   end

   has_ALA(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ALA
      Ca,Cb :: INT, IN
      res :: BIN
      res = .has_1_connection(Cb,Ca)
   end

   has_ARG(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ARG
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      Nz1,Nz2 :: INT
      res = .has_chain(Ca,Cb,[6,6,7,6],C)
      if (NOT res) return
      res = .has_3_connections(C(4),C(3),7,7,Nz1,Nz2)
      if (NOT res) return
      res = .has_1_connection(Nz1,C(4))
      if (NOT res) return
      res = .has_1_connection(Nz2,C(4))
   end

   has_ASN(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ASN
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og,Ng :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Og,Ng)
      if (NOT res) return
      res = .has_1_connection(Og,Cg)
      if (NOT res) return
      res = .has_1_connection(Ng,Cg)
   end

   has_ASP(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ASP
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og1,Og2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Og1,Og2)
      if (NOT res) return
      res = .has_1_connection(Og1,Cg)
      if (NOT res) return
      res = .has_1_connection(Og2,Cg)
   end

   has_CYS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes CYS
      Ca,Cb :: INT, IN
      res :: BIN
      Sg :: INT
      res = .has_2_connections(Cb,Ca,16,Sg)
      if (NOT res) return
      res = .has_1_connection(Sg,Cb)
   end

   has_GLN(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes GLN
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(2)
      Ne,Oe :: INT
      res = .has_chain(Ca,Cb,[6,6],C)
      if (NOT res) return
      res = .has_3_connections(C(2),C(1),8,7,Oe,Ne)
      if (NOT res) return
      res = .has_1_connection(Ne,C(2))
      if (NOT res) return
      res = .has_1_connection(Oe,C(2))
   end

   has_GLU(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes GLU
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(2)
      Oe1,Oe2 :: INT
      res = .has_chain(Ca,Cb,[6,6],C)
      if (NOT res) return
      res = .has_3_connections(C(2),C(1),8,8,Oe1,Oe2)
      if (NOT res) return
      res = .has_1_connection(Oe1,C(2))
      if (NOT res) return
      res = .has_1_connection(Oe2,C(2))
   end

   has_HIS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes HIS
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Nd,Cd :: INT
      res = .has_2_connections(Cb,Ca,16,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,7,6,Nd,Cd)
      if (NOT res) return
      res = .has_ring(Cg,Nd,[6,7,6])
   end

   has_ILE(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes ILE
      Ca,Cb :: INT, IN
      res :: BIN
      Cg1,Cg2,Cd :: INT
      res = .has_3_connections(Cb,Ca,6,6,Cg1,Cg2)
      if (NOT res) return
      if      (.has_1_connection(Cg1,Cb)) then
        res = .has_2_connections(Cg2,Cb,6,Cd)
        if (NOT res) return
        res = .has_1_connection(Cd,Cg2)
      else if (.has_1_connection(Cg2,Cb)) then
        res = .has_2_connections(Cg1,Cb,6,Cd)
        if (NOT res) return
        res = .has_1_connection(Cd,Cg1)
      else
        res = FALSE
      end
   end

   has_LEU(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes LEU
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,7,Cd1,Cd2)
      if (NOT res) return
      res = .has_1_connection(Cd1,Cg)
      if (NOT res) return
      res = .has_1_connection(Cd2,Cg)
   end

   has_LYS(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes LYS
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      res = .has_chain(Ca,Cb,[6,6,6,7],C)
      if (NOT res) return
      res = .has_1_connection(C(4),C(3))
   end

   has_MET(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes MET
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(3)
      res = .has_chain(Ca,Cb,[6,16,6],C)
      if (NOT res) return
      res = .has_1_connection(C(3),C(2))
   end

   has_PHE(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes PHE
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      res = .has_ring(Cg,Cd1,[6,6,6,6])
   end

   has_SER(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes SER
      Ca,Cb :: INT, IN
      res :: BIN
      Og :: INT
      res = .has_2_connections(Cb,Ca,8,Og)
      if (NOT res) return
      res = .has_1_connection(Og,Cb)
   end

   has_THR(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes THR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Og :: INT
      res = .has_3_connections(Cb,Ca,6,8,Cg,Og)
      if (NOT res) return
      res = .has_1_connection(Cg,Cb)
      if (NOT res) return
      res = .has_1_connection(Og,Cb)
   end

   has_TRP(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes TRP
      Ca,Cb :: INT, IN
      res :: BIN
      C :: VEC{INT}(4)
      Cg,Cd1,Cd2,Ne,Ce1,Cf1 :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      if      (.has_2_connections(Cd1,Cg,7,Ne)) then
        res = .has_2_connections(Ne,Cd1,6,Ce1)
        if (NOT res) return
        res = .has_3_connections(Ce1,Ne,Cd2,6,Cf1)
        if (NOT res) return
        res = .has_chain(Ce1,Cf1,[6,6,6,6],C)
        if (NOT res) return
        res = C(4)==Cd2
      else if (.has_2_connections(Cd2,Cg,7,Ne)) then
        res = .has_2_connections(Ne,Cd2,6,Ce1)
        if (NOT res) return
        res = .has_3_connections(Ce1,Ne,Cd1,6,Cf1)
        if (NOT res) return
        res = .has_chain(Ce1,Cf1,[6,6,6,6],C)
        if (NOT res) return
        res = C(4)==Cd1
      else
        res = FALSE
      end
   end

   has_TYR(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes TYR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg,Cd1,Cd2,Ce1,Ce2,Cz,Oz :: INT
      res = .has_2_connections(Cb,Ca,6,Cg)
      if (NOT res) return
      res = .has_3_connections(Cg,Cb,6,6,Cd1,Cd2)
      if (NOT res) return
      res = .has_2_connections(Cd1,Cg,6,Ce1)
      if (NOT res) return
      res = .has_2_connections(Cd2,Cg,6,Ce2)
      if (NOT res) return
      res = .has_2_connections(Ce1,Cg,6,Cz)
      if (NOT res) return
      res = .has_2_connections(Ce2,Cg,6,Cz)
      if (NOT res) return
      res = .has_3_connections(Cz,Ce1,Ce2,8,Oz)
      if (NOT res) return
      res = .has_1_connection(Oz,Cz)
   end

   has_VAL(Ca,Cb) result (res)
   ! Returns TRUE if the side chain at the alpha and beta carbon
   ! "Ca" and "Cb" describes THR
      Ca,Cb :: INT, IN
      res :: BIN
      Cg1,Cg2 :: INT
      res = .has_3_connections(Cb,Ca,6,6,Cg1,Cg2)
      if (NOT res) return
      res = .has_1_connection(Cg1,Cb)
      if (NOT res) return
      res = .has_1_connection(Cg2,Cb)
   end

!  ************************
!  Bonds, distances, angles
!  ************************

   bonded(a,b,range_factor) result (res) ::: pure
   ! Return true if "self" is bonded to "b".  If present, "range_factor" is used
   ! to determine the distance range in which the atoms are regarded as bonded.
   ! This uses the CCDC method, as documented on their web page.
      self :: IN
      a,b :: INT, IN
      range_factor :: REAL, IN, optional
      res :: BIN
      res = self(a).is_bonded_to(self(b),range_factor)
   end

   vdw_bonded(a,b,range_factor,vdw_range_pc) result (res)
   ! Return true if "a" is vdw bonded to "b". Atoms which are
   ! covalently bonded are not vand-der-waals bonded.  If present,
   ! "range_factor" is used to determine the distance range in which
   ! the atoms are regarded as covalent bonded. If present
   ! "vdw_range_pc" is the percentage increase in the vdw radius to be
   ! tolerated while still regarding the atoms vdw bonded (default
   ! 10%). This uses the CCDC method, as documented on their web page.
      a,b :: INT, IN
      range_factor,vdw_range_pc :: REAL, optional, IN
      res :: BIN
      res = self(a).is_vdw_bonded_to(self(b),range_factor,vdw_range_pc)
   end

   are_nearby(a,b,dist) result (res)
   ! Return whether atoms "a" and "b" are nearby, i.e. within length "dist".
      a,b :: INT, IN
      dist :: REAL, IN
      res :: BIN

      tmp :: VEC{REAL}(3)
      r2 :: REAL

      tmp = self(a).position - self(b).position
      tmp = abs(tmp)
      if      (tmp(1)>dist) then; res = FALSE
      else if (tmp(2)>dist) then; res = FALSE
      else if (tmp(3)>dist) then; res = FALSE
      else
         r2 = dot_product(tmp,tmp)
         res = (r2 < dist*dist)
      end

   end

   connected(a,b,c,d) result (res)
   ! Return true if atoms "a" "b" "c" and "d" are connected together
      a,b,c,d :: INT, IN
      res :: BIN

      res = .bonded(a,b) OR .bonded(a,c) OR .bonded(a,d)
      res = res AND ( .bonded(b,a) OR .bonded(b,c) OR .bonded(b,d) )
      res = res AND ( .bonded(c,a) OR .bonded(c,b) OR .bonded(c,d) )
      res = res AND ( .bonded(d,a) OR .bonded(d,b) OR .bonded(d,c) )

   end


   no_of_bonds result (res)
   ! Return the number of bonded atoms
      res :: INT
      a,b :: INT
      res = 0
      do a = 1,.dim
      do b = 1,a-1
         if (.bonded(a,b)) res = res + 1
      end
      end
   end

   bond_distance(a,b,angstrom) result (res)
   ! Return the bond distance between atoms "a" and "b"
      a,b :: INT, IN
      res :: REAL
      angstrom :: BIN, optional, IN

      rab :: VEC{REAL}(3)
      change :: BIN

      rab = self(b).position - self(a).position
      res = sqrt(rab(1)*rab(1) + rab(2)*rab(2) + rab(3)*rab(3))

      change = FALSE
      if (present (angstrom)) change = angstrom
      if (change) res = res * STR:conversion_factor("angstrom")

   end


   no_of_angles result (res) ::: pure
   ! Return the number of angles within bond contact distance
      self :: IN
      res :: INT

      n,a,b,c :: INT

      n = .dim

      res = 0

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            res = res + 1

         end

      end
      end

   end

   bond_angle(a,b,c,degrees) result (res)
   ! Return the bond angle between atoms "a" , "b" and "c".
   ! The central atom is "b". The angle is calculated as
   ! arccos(nba.nbc) . If "degrees" is present and TRUE,
   ! result is in degrees.
      a,b,c :: INT, IN
      degrees :: BIN, optional, IN

      res :: REAL
      rba,rbc :: VEC{REAL}(3)
      change :: BIN

      rba = self(a).position - self(b).position
      rbc = self(c).position - self(b).position
      rba.normalise
      rbc.normalise
      res = rba.dot(rbc)
      res = res.arccos

      change = FALSE
      if (present (degrees)) change = degrees
      if (change) res = res * STR:conversion_factor("degree")

   end

   no_of_angle_center_atoms result (res) ::: pure
   ! Return the number of list of atom indices B which belong to
   ! angles centers angle(ABC)
      self :: IN
      res :: INT

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(b) = TRUE

         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   angle_center_atoms result (res) ::: pure
   ! Return the list of atom indices B which belong to angles centers
   ! angle(ABC)
      self :: IN
      res :: VEC{INT}(.no_of_angle_center_atoms)

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(b) = TRUE

         end

      end
      end

      res = pack([( a, a=1,n)],mask=cnt)

      deallocate(cnt)

   end

   no_of_angle_outer_atoms result (res) ::: pure
   ! Return the number of list of atoms which are outer angle atoms
      self :: IN
      res :: INT

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(a) = TRUE
            cnt(c) = TRUE

         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   angle_outer_atoms result (res) ::: pure
   ! Return the list of atoms which are outer angle atoms
      self :: IN
      res :: VEC{INT}(.no_of_angle_outer_atoms)

      n,a,b,c :: INT
      cnt :: VEC{BIN}*

      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      do a = 1,n
      do b = 1,n

         if (b==a) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (c==a OR c==b) cycle
            if (NOT .bonded(b,c)) cycle
            if (c<a) cycle

            cnt(a) = TRUE
            cnt(c) = TRUE

         end

      end
      end

      res = pack([( a, a=1,n)],mask=cnt)

      deallocate(cnt)

   end


   no_of_torsion_angles result (res) ::: pure
   ! Return the number of torsion angles within bond contact distance
      self :: IN
      res :: INT

      n,a,b,c,d :: INT

      n = .dim

      res = 0

      do a = 1,n
      do b = 1,n

         if (a==b) cycle
         if (NOT .bonded(a,b)) cycle

         do c = 1,n

            if (a==c OR b==c) cycle
            if (NOT .bonded(b,c)) cycle

            do d = 1,n

               if (a==d OR b==d OR c==d) cycle
               if (NOT .bonded(c,d)) cycle

               res = res + 1

            end
         end

      end
      end

      res = res/2

   end

   torsion_angle(a,b,c,d,abc_colinear,bcd_colinear,degrees) result (res)
   ! Return the torsion angle between atoms "a", "b", "c" and "d". The
   ! atoms are assumed connected like a--b--c--d and the angle
   ! returned is that between vectors (a-b) and (d-c) i.e. the torsion
   ! angle looking down the b--c bond.  torsion is positive if (a-b)
   ! is counterclockwise of (d-c). If "degrees" is present and
   ! TRUE, result is in degrees.  NOTE: If the result is -ONE, either
   ! a--b--c or b--c--d are colinear, and the variables
   ! "abc_colinear" and "bcd_colinear" are set.
   ! See Tuzun et al (2000) J. Comp. Chem 21 p. 553-561
      a,b,c,d :: INT, IN
      abc_colinear,bcd_colinear :: BIN, optional, OUT
      degrees :: BIN, optional, IN
      res :: REAL

      change :: BIN
      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dot :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE
      if (present(bcd_colinear)) bcd_colinear = FALSE

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position
      rba.normalise
      rcb.normalise
      rdc.normalise

      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rcb,rdc)

      ! Collinear test
      res = ZERO
      if (abs(tba.norm)<TOL(5)) then
         res = -ONE
         if (present(abc_colinear)) abc_colinear = TRUE
      end
      if (abs(tdc.norm)<TOL(5)) then
         res = -ONE
         if (present(bcd_colinear)) bcd_colinear = TRUE
      end
      if (res<ZERO) return

      tba.normalise
      tdc.normalise
      res = tba.dot(tdc)
      res = res.arccos

      ! Sign of angle: see Tozun et al eq. (11)
      ! And also Figure 1
      dot = -rdc.dot(tba)
      if (dot<ZERO) res = -res

      change = FALSE
      if (present (degrees)) change = degrees
      if (change) res = res * STR:conversion_factor("degree")

   end

   no_of_torsion_angle_1st_atoms result (res) ::: pure
   ! Return the number of list of indices of 1st atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a1) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_1st_atoms result (res) ::: pure
   ! Return the list of indices of 1st atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_1st_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a1) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_2nd_atoms result (res) ::: pure
   ! Return the number of list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a2) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_2nd_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_2nd_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a2) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_3rd_atoms result (res) ::: pure
   ! Return the number of list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a3) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_3rd_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_3rd_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a3) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end

   no_of_torsion_angle_4th_atoms result (res) ::: pure
   ! Return the umber list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: INT

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a4) = TRUE

            end
         end

      end
      end

      res = count(cnt)

      deallocate(cnt)

   end

   torsion_angle_4th_atoms result (res) ::: pure
   ! Return the list of indices of 2nd atoms in a torsion angle
      self :: IN
      res :: VEC{INT}(.no_of_torsion_angle_4th_atoms)

      cnt :: VEC{BIN}*
      a1,a2,a3,a4, n :: INT

      ! Length
      n = .dim

      allocate(cnt(n))
      cnt = FALSE

      ! Loop and store first atoms
      do a1 = 1,n
      do a2 = 1,n

         if (a2==a1) cycle
         if (NOT .bonded(a1,a2)) cycle

         do a3 = 1,n

            if (a3==a1 OR a3==a2) cycle
            if (NOT .bonded(a2,a3)) cycle

            do a4 = 1,n

               if (a4==a1 OR a4==a2 OR a4==a3) cycle
               if (NOT .bonded(a3,a4)) cycle
               if (a4<a1) cycle

               cnt(a4) = TRUE

            end
         end

      end
      end

      res = pack([ (a1, a1=1,n) ],mask=cnt)

      deallocate(cnt)

   end


   has_all_Hs_single_bonded(has_Hs) result (res)
   ! Return TRUE if "self" has all H atom single bonded. If there are
   ! no H's then the result is TRUE but "has_Hs" is set FALSE..
      res :: BIN
      has_Hs :: BIN, OUT

      a,b,n :: INT

      res = TRUE
      has_Hs = FALSE

      do a = 1,.dim

         if (self(a).atomic_number/=1) cycle

         has_Hs = TRUE
         
         n = 0
         do b = 1,.dim
            if (self(b).atomic_number<=1) cycle
            if (NOT self(a).is_bonded_to(self(b))) cycle
            n = n + 1
            if (n>1) exit
         end

         res = n==1
         if (NOT res) exit

      end

   end

!  ************************************************
!  Position derivatives of bonds, distances, angles
!  ************************************************

   bond_distance_deriv(a,b,deriv)
   ! Return the bond distance derivatives "deriv" wrt cartesian
   ! positions between atoms "a" and "b". The bond vector is rb - ra
      a,b :: INT, IN
      deriv :: VEC{REAL}(6)

      rab :: VEC{REAL}(3)
      dab :: REAL

      ! Vector rab and (inverse) length
      rab = self(b).position - self(a).position
      dab = sqrt(rab(1)*rab(1) + rab(2)*rab(2) + rab(3)*rab(3))
      dab = ONE/dab

      ! Derivative
      deriv(1:3) = -rab*dab ! wrt a
      deriv(4:6) =  rab*dab ! wrt b

   end

   bond_angle_deriv(a,b,c,deriv,abc_colinear)
   ! Return the bond angle derivatives "deriv" between atoms "a" , "b"
   ! and "c".  The central atom is "b". The angle is calculated as
   ! arccos(nba.nbc). See Tuzun et al (2000) J. Comp. Chem 21 p.
   ! 553-561 equation (6).
      a,b,c :: INT
      deriv :: VEC{REAL}(9)
      abc_colinear :: BIN, OUT, optional

      rba,rbc,rx,ry :: VEC{REAL}(3)
      dba,dbc,cs,sn :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE

      ! Vectors
      rba = self(a).position - self(b).position
      rbc = self(c).position - self(b).position

      ! Get lengths and normalise
      dba = ONE/rba.norm; rba = rba*dba
      dbc = ONE/rbc.norm; rbc = rbc*dbc

      ! sin part
      cs = dot_product(rba,rbc)
      sn = sqrt((ONE-cs)*(ONE+cs))
      if (abs(sn)<TOL(5)) then
         deriv = ZERO
         if (present(abc_colinear)) abc_colinear = TRUE
         return
      else
         sn = ONE/sn
      end

      ! I checked the formula below myself

      ! Derivtive wrt c: see (6b)
      ! NOTE: this equation is actually -Nabla1
      rx.to_cross_product_of(rbc,rba)
      ry.to_cross_product_of(rba,rx)
      deriv(1:3) = ry*dba

      ! Derivative wrt a: see (6a)
      ! NOTE: this equation is actually Nabla3
      rx.to_cross_product_of(rba,rbc)
      ry.to_cross_product_of(rbc,rx)
      deriv(7:9) = ry*dbc

      ! Derivative wrt b: use translational invariance
      deriv(4:6) = - deriv(1:3) - deriv(7:9)

      ! Divide by sin: see (6c)
      deriv = -sn*deriv

   end

   torsion_angle_deriv(a,b,c,d,deriv,abc_colinear,bcd_colinear) 
   ! Return the torsion angle derivative "deriv" between atoms "a",
   ! "b", "c" and "d". NOTE: If the result is -ONE, either a--b--c or
   ! b--c--d are colinear, and the variables "abc_colinear" and
   ! "bcd_colinear" are set.  See Tuzun et al (2000) J. Comp. Chem 21
   ! p. 553-561 equation (9).
      a,b,c,d :: INT, IN
      deriv :: VEC{REAL}(12)
      abc_colinear,bcd_colinear :: BIN, optional, OUT

      rba,rcb,rdc,tba,tdc :: VEC{REAL}(3)
      dba,dcb,ddc, sin_abc,sin_bcd,cos_abc,cos_bcd, cc,bb :: REAL

      if (present(abc_colinear)) abc_colinear = FALSE
      if (present(bcd_colinear)) bcd_colinear = FALSE

      ! Vectors point from d -> c -> b -> a
      rba = self(a).position - self(b).position
      rcb = self(b).position - self(c).position
      rdc = self(c).position - self(d).position

      ! Lengths and normalise
      dba = rba.norm; rba = rba/dba
      dcb = rcb.norm; rcb = rcb/dcb
      ddc = rdc.norm; rdc = rdc/ddc

      ! Normals to planes
      tba.to_cross_product_of(rba,rcb)
      tdc.to_cross_product_of(rdc,rcb)

      ! Collinear test
      if (abs(tba.norm)<TOL(5)) then
         deriv = ZERO
         if (present(abc_colinear)) abc_colinear = TRUE
         return
      end
      if (abs(tdc.norm)<TOL(5)) then
         deriv = ZERO
         if (present(bcd_colinear)) bcd_colinear = TRUE
         return
      end

      ! sin's and cos's
      sin_abc = ONE/tba.norm
      sin_bcd = ONE/tdc.norm
      cos_abc = -dot_product(rba,rcb)
      cos_bcd = -dot_product(rcb,rdc)


      ! Gradient's
      deriv( 1: 3) = -tba*sin_abc*sin_abc/dba    ! wrt a: see (9a)
      deriv(10:12) = -tdc*sin_bcd*sin_bcd/ddc    ! wrt d: see (9b)
      cc = dba*cos_abc/dcb - ONE                 ! wrt b: see (9d)
      bb = ddc*cos_bcd/dcb
      deriv( 4: 6) = cc*deriv(1:3) - bb*deriv(10:12)
      deriv( 7: 9) = -deriv(1:3)-deriv(4:6)-deriv(10:12)

   end

!  ************************
!  Size information methods
!  ************************

!   n_atom result (res) ::: pure
!   ! Return the number of atoms in the atom vector
!      self :: IN
!      res :: INT
!      res = size(self)
!   end

   no_of_electrons result (res) ::: pure
   ! Work out and return the number of electrons in the list of atoms
   ! assuming that it is neutrally charged.
      self :: IN
      res :: INT
      res = sum(self(:).atomic_number)
   end

   no_of_occupied_ANOs(ANOkind,tol) result (res)
   ! Returns the number of non-zero occupied atomic natural orbitals. For this
   ! purpose, zero is defined to be "tol" if present, or TOL(7) otherwise
      ANOkind :: STR, optional
      tol :: REAL, optional
      res :: INT
   ENSURE(self(1).occupation_numbers.created,"no occupation numbers")
      a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).no_of_occupied_NOs(ANOkind,tol)
      end
   end

!  ******************************
!  Basis size information methods
!  ******************************

   no_of_shells result (res) ::: pure
   ! Work out and return the number of gaussian shells in the basis set for the
   ! molecule
      self :: IN
      res :: INT
      a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_shells
      end
   end

   n_shell result (res) ::: pure
   ! Work out and return the number of gaussian shells in the basis set for the
   ! molecule
      self :: IN
      res :: INT
      a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.n_shell
      end
   end

   n_shell_pairs result (res) ::: pure
   ! Return the number of shell pairs in the basis set for the molecule
      self :: IN
      res :: INT
      n_shell :: INT
      n_shell = .n_shell
      res = n_shell*(n_shell+1)/2
   end

!   n_shell_for_atom(i) result (res) ::: pure
!   ! Work out and return the number of gaussian shells in the basis set for the
!   ! molecule
!      self :: IN
!       i :: INT, IN
!      res :: INT
!      res = self(i).basis.n_shell
!   end

   no_of_primitive_shells result (res) ::: pure
   ! Work out and return the number of primitive gaussian shells in
   ! the concatenated basis sets
      self :: IN
      res :: INT
      a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_primitive_shells
      end
   end

   no_of_basis_functions result (res) ::: pure
   ! Work out and return the number of basis functions in the concatenated
   ! basis set for the atom list.
      self :: IN
      res :: INT
      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_basis_functions
      end

   end

   no_of_sph_basis_functions result (res) ::: pure
   ! Work out and return the number of spherical basis functions in
   ! the concatenated basis set for the atom list.
      self :: IN
      res :: INT
      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_sph_basis_functions
      end

   end

   n_bf result (res) ::: pure
   ! Work out and return the number of basis functions in the concatenated
   ! basis set for the atom list.
      self :: IN
      res :: INT
      a :: INT

      res = 0
      do a = 1,.dim
         res = res + self(a).basis.n_bf
      end

   end

   no_of_primitives result (res) ::: pure
   ! Work out and return the number of primitives in the concatenated
   ! basis sets.
      self :: IN
      res :: INT
       a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_primitives
      end
   end

   no_of_sph_primitives result (res) ::: pure
   ! Work out and return the number of spherical primitives in the
   ! concatenated basis sets.
      self :: IN
      res :: INT
       a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.no_of_sph_primitives
      end
   end

   n_prim result (res) ::: pure
   ! Work out and return the number of primitives in the concatenated
   ! basis sets.
      self :: IN
      res :: INT
       a :: INT
      res = 0
      do a = 1,.dim
         res = res + self(a).basis.n_prim
      end
   end

!  *******************************
!  Basis set existence information
!  *******************************

   bases_are_resolved result (res)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
      res :: BIN
      a :: INT
      res = TRUE
      do a = 1,.dim
         if (self(a).basis.is_created_and_resolved) cycle
         if (self(a).has_a_dummy_label) cycle
         res = FALSE
         exit
      end
   end

   slaterbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, basis=>slaterbasis)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   coppensbases_are_resolved result (res) ::: get_from(VEC{ATOM}:bases_are_resolved, basis=>coppensbasis)
   ! Return TRUE if all basis sets are associated AND their shell list
   ! parts are also associated, dummy-atoms excepted
   end

   bases_are_all_labeled result (res)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
      res :: BIN
      a :: INT
      res = TRUE
      do a = 1,.dim
         if (self(a).basis.is_created_and_has_label) cycle
         if (self(a).has_a_dummy_label) cycle
         res = FALSE
         exit
      end
   end

   slaterbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, basis=>slaterbasis)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end

   coppensbases_are_all_labeled result (res) ::: get_from(VEC{ATOM}:bases_are_all_labeled, basis=>coppensbasis)
   ! Return TRUE if all basis set labels exist (i.e. are not blank)
   ! Note: If a dummy atom has a basis it should have a label
   end


   get_distance_from(atomvec,distance,t1,t2)
   ! Calculates the shortest distance between an atom in self and one in
   ! atomvec.  Will set the distance to zero if calculated to less than 10^-6.
   ! If present, t1 and t2 are the indices of the two closest atoms.
      atomvec :: VEC{ATOM}, IN
      self :: IN
      distance :: REAL
      t1,t2 :: INT, optional
      dist :: REAL
      i,j,dim1,dim2 :: INT
      difference :: VEC{REAL}(3)

      dim1 = .dim
      dim2 = size(atomvec)
      ENSURE(present(t1) EQV present(t2),"need 0 or 2 optional arguments")

      ! Do the first pair explicitly to set a starting distance.
      ! We also work with distance^2 until the end - saves computation.
      difference = self(1).position(:) - atomvec(1).position(:)
      distance = dot_product(difference,difference)

      do i=1,dim1
       do j=1,dim2
         difference = self(i).position(:) - atomvec(j).position(:)
         dist = dot_product(difference,difference)
         if (dist < TOL(6)) dist = ZERO
         if (dist < distance) then
           distance = dist
           if (present(t1)) then
             t1=i; t2=j
           end
         end
       end
      end

      distance = sqrt(distance)
   end

   get_distance_from(pos,distance,t1)
   ! Calculates the shortest distance of "pos" to an atom in self.
   ! If present, t1 is the index of the closest atom.
      pos :: VEC{REAL}(3), IN
      self :: IN
      distance :: REAL
      t1 :: INT, optional
      dist :: REAL
      difference :: VEC{REAL}(3)
      i :: INT

      ! Do the first pair explicitly to set a starting distance.
      ! We also work with distance^2 until the end - saves computation.
      difference = self(1).position(:) - pos(:)
      distance = dot_product(difference,difference)

      do i = 1, .dim
       difference = self(i).position(:) - pos(:)
       dist = dot_product(difference,difference)
       if (dist < TOL(6)) dist = ZERO
       if (dist < distance) then
         distance = dist
         if (present(t1)) t1=i
       end
      end

      distance = sqrt(distance)
   end

   same_as(atomvec) result (res)
   ! Returns true if the two atomvecs contain the same atoms, though maybe in a
   ! different order.  Checks atomic number and position of each atom, but not
   ! the basis sets.
      atomvec :: VEC{ATOM}, IN
      res :: BIN
      matched :: VEC{BIN}(size(self))
      match_pos,match_kind,match :: BIN
      n,q,dim :: INT

      res = FALSE
      dim = .dim
      if (dim/=size(atomvec)) return ! different number of atoms in each.
      matched = FALSE

      do n = 1, dim
         match=FALSE
         do q = 1, dim
            match_kind =  (self(n).atomic_number == atomvec(q).atomic_number)
            match_pos  =  self(n).position.same_as( atomvec(q).position, TOL(3) )
            if (match_pos AND match_kind AND (NOT matched(q))) then
               matched(q) = TRUE
               match = TRUE
               exit
            end
         end
         if (NOT match) return ! atom n doesn't have a match.
      end

      do q = 1, dim           ! If not all of q are matched then atomvecs not same.
         if (NOT matched(q)) return
      end

      res = TRUE

   end

!  *************
!  Crystal stuff
!  *************

   translate_by(vector)
   ! Translate self by vector.
      self :: INOUT
      vector :: VEC{REAL}(3), IN

      n :: INT

      do n = 1,.dim
         self(n).position = self(n).position + vector
      end

   end

   rotate_by(matrix)
   ! Rotate the atom positions by the rotation matrix
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN
      .rotate_positions_by(matrix)
      .rotate_ADP_tensors_by(matrix)
   end

   rotate_positions_by(matrix)
   ! Rotate the atom positions by the rotation matrix
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN

      n :: INT

      do n = 1,.dim
         self(n).position = matmul(matrix,self(n).position)
      end

   end

   rotate_ADP_tensors_by(matrix)
   ! Rotate the atom ADP (thermal) tensors by the rotation matrix: this is the
   ! rotation matrix which transforms the cartesian position to a new position.
      self :: INOUT
      matrix :: MAT{REAL}(3,3), IN
      n :: INT
      do n = 1,.dim
       self(n).ADP_tensor.back_transform_using(matrix)
      end
   end

   ADP_tensor_to(cell)
   ! Convert all ADP (thermal) tensors from cartesians to crystal coordinates.
      cell :: UNIT_CELL, IN
      n :: INT
      do n = 1,.dim
        self(n).ADP_tensor_to(cell)
      end
   end

   ADP_tensor_from(cell)
   ! Convert all ADP (thermal) tensors from crystal coordinates to cartesians.
      cell :: UNIT_CELL, IN
      n :: INT
      do n = 1,.dim
        self(n).ADP_tensor_from(cell)
      end
   end

!   B_iso_to_U_iso
!   ! Pretend all the U_iso values are B_iso values, and divide them all by 
!   ! 8 PI^2 ... this maybe needed when the U_iso's are entered as B_iso values
!   ! in a cif file.
!     n :: INT
!     do n=1,.dim
!       self(n).U_iso = self(n).U_iso/(EIGHT*PI*PI)
!     end
!   end

   default_multiplicity result (res)
   ! Return the default multiplicity for an atomvec/molecule.
      self :: IN
      res :: REAL
      if (.dim==1) then
        res = self(1).ground_state_multiplicity
      else
        res = mod(.no_of_electrons,2) + 1
      end
   end

!  *********
!  Integrals
!  *********

!   make_nuclear_matrix(Z)
!   ! Calculate the nuclear attraction matrix "Z" for the atoms in the list.
!   ! Includes dummay atoms
!      self :: target
!      Z :: MAT{REAL}
!   ENSURE(.bases_are_resolved, "no basis set")
!   ENSURE(Z.is_square,"Z is not square")
!   ENSURE(Z.dim1==.n_bf,"wrong size, Z")
!      atom :: ATOM*
!      Z_c :: MAT{REAL}*
!      q,c,fa,la,fb,lb :: INT
!      sh :: SHELL2
!      .make_index_info
!      Z = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(sh,q,fa,la,fb,lb)
!        Z_c.create(sh.a.n_comp,sh.b.n_comp)
!        do c = 1,.dim
!           atom => self(c)
!           sh.get_nuc(Z_c,atom.mass,atom.position)
!           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.nuclear_charge * Z_c
!        end
!        Z_c.destroy
!        sh.destroy_ptr_part
!      end
!      Z.symmetric_reflect
!      .destroy_index_info
!   end
!
!   make_nuclear_matrix(Z,nuclei)
!   ! Calculate the nuclear attraction matrix "Z" for the basis functions on all
!   ! atoms in the list, but only for the positive nuclei specified in the
!   ! "nuclei" list.  Includes dummay atoms
!      self :: target
!      Z :: MAT{REAL}
!      nuclei :: VEC{INT}
!   ENSURE(.bases_are_resolved, "no basis set")
!   ENSURE(Z.is_square,"Z is not square")
!   ENSURE(Z.dim1==.n_bf,"wrong size, Z")
!      atom :: ATOM*
!      Z_c :: MAT{REAL}*
!      q,c,fa,la,fb,lb :: INT
!      sh :: SHELL2
!      .make_index_info
!      Z = ZERO
!      do q = 1,.n_shell_pairs
!        .get_shell_pair(sh,q,fa,la,fb,lb)
!        Z_c.create(sh.a.n_comp,sh.b.n_comp)
!        do c = 1,size(nuclei)
!           atom => self(nuclei(c))
!           sh.get_nuc(Z_c,atom.mass,atom.position)
!           Z(fa:la,fb:lb) = Z(fa:la,fb:lb) - atom.nuclear_charge * Z_c
!        end
!        Z_c.destroy
!        sh.destroy_ptr_part
!      end
!      Z.symmetric_reflect
!      .destroy_index_info
!   end
!
!   make_index_info ::: leaky
!   ! Define a vector of atom numbers corresponding to the molecule
!   ! basis set shell numbers; also define a vector of atom shell numbers
!   ! corresponding to the molecule basis set shell number
!      atom_4_shell       => .atom_for_shell
!      atom_shell_4_shell => .atom_shell_for_shell
!      first_shell_4_atom => .first_shell_for_atom
!      .make_shell_limits(first_basis_fn_4_shell,last_basis_fn_4_shell,angular_moment_4_shell)
!      .make_atom_basis_fn_limits(first_basis_fn_4_atom,last_basis_fn_4_atom)
!      index_info_created = TRUE
!   end
!
!   destroy_index_info ::: leaky
!   ! Destroythe private index information. There may be problems with this for
!   ! compilers without default initialisation ...
!      atom_4_shell.destroy
!      atom_shell_4_shell.destroy
!      first_shell_4_atom.destroy
!      first_basis_fn_4_shell.destroy
!      last_basis_fn_4_shell.destroy
!      first_basis_fn_4_atom.destroy
!      last_basis_fn_4_atom.destroy
!      index_info_created = FALSE
!   end

!  ***********
!  Shell pairs
!  ***********

!   get_shell_pair(shell,index,fa,la,fb,lb) ::: leaky
!   ! Get the SHELL2 object "shell" correponding to the pair index "index"
!   ! Also return the basis function start indices "fa", "la", etc ...
!      index :: INT, IN
!      shell :: SHELL2, OUT
!      fa,la,fb,lb :: INT, OUT
!   ENSURE(index_info_created,"no index information")
!      a,b,aa,sa,bb,sb :: INT
!      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
!      b  = index - a*(a-1)/2
!      fa = first_basis_fn_4_shell(a) ! These are module variables
!      fb = first_basis_fn_4_shell(b)
!      la = last_basis_fn_4_shell(a)
!      lb = last_basis_fn_4_shell(b)
!      aa = atom_4_shell(a)
!      bb = atom_4_shell(b)
!      sa = atom_shell_4_shell(a)
!      sb = atom_shell_4_shell(b)
!      shell.copy(self(aa).basis.shell(sa), self(bb).basis.shell(sb), &
!                 self(aa).position, self(bb).position )
!   end
!
!   get_shell_pair(shell,index,fa,la,fb,lb,atom_a,atom_b) ::: leaky
!   ! Get the SHELL2 object "shell" correponding to the pair index "index"
!   ! Also return the basis function start indices "fa", "la", etc ...
!   ! Plus the atoms the shells are located on, "atom_a" and "atom_b".
!      index :: INT, IN
!      shell :: SHELL2, OUT
!      fa,la,fb,lb,atom_a,atom_b :: INT, OUT
!   ENSURE(index_info_created,"no index information")
!      a,b,sa,sb :: INT
!      a  = (1+int(sqrt(8.0d0*index-7.0d0)))/2
!      b  = index - a*(a-1)/2
!      fa = first_basis_fn_4_shell(a)
!      fb = first_basis_fn_4_shell(b)
!      la = last_basis_fn_4_shell(a)
!      lb = last_basis_fn_4_shell(b)
!      atom_a = atom_4_shell(a)
!      atom_b = atom_4_shell(b)
!      sa = atom_shell_4_shell(a)
!      sb = atom_shell_4_shell(b)
!      shell.copy(self(atom_a).basis.shell(sa), self(atom_b).basis.shell(sb), &
!                self(atom_a).position, self(atom_b).position )
!   end

!  *************
!  Interpolators
!  *************

   max_interpolator_table_length(tol) result (res)
   ! Returns the maximum interpolator table length for a given table cutoff
   ! tolerance "tol".  This table length is used for setting the cluster radius,
   ! for calculations where the cluster size must be determined so that the
   ! Hirshfeld surface is accurate.
      tol,res :: REAL
      last :: REAL
      i :: INT
      res = ZERO
      select case (self(1).basis_kind)
         case ("slater")
            ENSURE(.has_all_slater_bases,"missing slater bases")
            do i = 1,.dim
               last = self(i).slaterbasis.interpolator_table_length(tol)
               res = max(res,last)
            end
         case ("coppens")
            ENSURE(.has_all_coppens_bases,"missing coppens bases")
            do i = 1,.dim
               last = self(i).coppensbasis.interpolator_table_length(tol)
               res = max(res,last)
            end
         case ("gaussian")
            ENSURE(.has_all_ANO_data,"missing atom ANO data")
            do i = 1,.dim
               last = self(i).interpolator_table_length(tol)
               res = max(res,last)
            end
         case default
            UNKNOWN(self(1).basis_kind)
      end
   end

end
