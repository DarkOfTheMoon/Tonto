!-------------------------------------------------------------------------------
!
! MOL: An object representation of a molecule.
!
! $Id$
!-------------------------------------------------------------------------------
module MOL_DANIEL

   use TYPES
   use SYSTEM
   use DBL
   use STR
   use TIME

   use VEC
   use MAT
   use MAT3, ONLY:create_,destroy_

   use CVEC
   use CMAT, ONLY:create_,destroy_
   use OPMAT, ONLY:spinorbital_kind_,any_created_,created_

   use TEXTFILE
   use ARCHIVE
   use CRYSTAL
   use BASISVEC
   use ATOMVEC

   use SCFDATA
   use MOL

   implicit none         

#  include "macros"
#  include "mol_daniel.int"

!   type mol_type
!
!   STR :: name
!   ! Name of molecule
!
!   INT :: charge
!   ! Electric charge of the molecule
!
!   INT :: mult
!   ! Spin multiplicity of the molecule
!
!   VEC(3) :: E_field
!   ! Applied electric field in atomic units
!
!   VEC(3) :: B_field
!   ! Applied magnetic field in atomic units
!
!   VEC(3) :: gauge_origin
!   ! Global gauge origin for magnetic field
!
!   ATOMVEC* :: atom
!   ! List of atoms in molecule
!
!   BASISVEC* :: basis
!   ! List of basis sets used
!
!   PLOTGRID* :: grid
!   ! Rectangular grid data, for plots
!
!   DFTGRID* :: dftgrid
!   ! DFT integration grid data
!
!   CRYSTAL* :: crystal
!   ! Crystal data for the enclosing crystal
!
!   POINTGROUP* :: pointgroup
!   ! Pointgroup symmetry of the molecule
!
!   INT :: n_e
!   ! No of electrons
!
!   INT :: n_a
!   ! No of alpha electrons
!
!   INT :: n_b
!   ! No of beta electrons
!
!   INT :: n_atom
!   ! No of atoms
!
!   INT :: n_atom_kind
!   ! No of atoms of a different kind
!
!   INT :: n_basis
!   ! No of basis sets
!
!   INT :: n_shell
!   ! Total number of shells in the molecular basis set
!
!   INT :: n_shell_pairs
!   ! Total number of shell pairs in the molecular basis set
!
!   INT :: n_bf
!   ! Total number of basis functions in the molecular basis set
!
!   INT :: n_prim
!   ! Total number of primitives in the molecular basis set
!
!   IVEC* :: atom_for_shell
!   ! Atom index for molecular shell index array
!
!   IVEC* :: atom_shell_for_shell
!   ! Atom shell index for molecular shell index array
!
!   IVEC* :: first_shell_for_atom
!   ! First molecule shell index for an atom
!
!   IVEC* :: first_basis_fn_for_shell
!   ! First basis function for a given shell
!
!   IVEC* :: last_basis_fn_for_shell
!   ! Last basis function for a given shell
!
!   IVEC* :: atom_kind
!   ! The unique kind of each atom in .atom
!
!   IVEC* :: unique_atom
!   ! List of the unique atoms (of different kind)
!
!   IVEC* :: first_basis_fn_for_atom
!   ! For the atom basis function limits
!
!   IVEC* :: last_basis_fn_for_atom
!   ! For the atom basis function limits
!
!   SCFDATA* :: scfdata
!   ! SCF data object
!
!   OPVEC* :: orbital_energies
!   ! The orbital energies
!
!   OPMAT* :: molecular_orbitals
!   ! The (real) molecular orbitals
!
!   OPMAT* :: density_matrix
!   ! The real density matrix
!
!   OPMAT* :: natural_orbitals
!   ! The natural orbitals
!
!   OPVEC* :: occupation
!   ! The associated occupation numbers
!
!   OPMAT* :: fock_matrix
!   ! The real fock matrix
!
!   MAT4VEC* :: ab_ab_ERI
!   ! The two electron integrals of the form ab|ab
!
!   BIN :: optimise_thermals
!   ! Whether to optimise the thermal parameters
!
!   end

contains

!*******************************************************************************
!                      Thermal parameter fitting
!*******************************************************************************

  force_thermal_symmetry
  ! Impose crystal symmetry on the thermal tensors.
    INOUT :: self
    INT :: n,u,s,n_unique
    MAT3* :: unique_thermals,seitz
    MAT(3,3) :: thermal,seitz_inv
    IVEC* :: n_equiv

    n_unique = .crystal.n_unique_unit_cell_atoms
    seitz => .crystal.spacegroup.seitz
    unique_thermals.create(3,3,n_unique)
    unique_thermals = ZERO
    n_equiv.create(n_unique)
    n_equiv = 0

    ! change to crystal coordinates.
    do n=1,.n_atom
      u = .crystal.unique_atom_for(n)
      s = .crystal.unique_atom_symop_for(n)
      seitz_inv.to_inverse_of(seitz(1:3,1:3,s))
      thermal = .atom(n).thermal_tensor
      thermal.change_basis(.crystal.reciprocal_U_cell_matrix)
      thermal.change_basis(seitz_inv)
      unique_thermals(:,:,u) = unique_thermals(:,:,u) + thermal
      n_equiv(u) = n_equiv(u) + 1
    end

    ! Average them.
    do u=1,n_unique
      unique_thermals(:,:,u) = unique_thermals(:,:,u) / n_equiv(u)
    end

    ! change back to cartesians.
    do n=1,.n_atom
      u = .crystal.unique_atom_for(n)
      s = .crystal.unique_atom_symop_for(n)
      thermal = unique_thermals(:,:,u)
      thermal.change_basis(seitz(1:3,1:3,s))
      thermal.change_basis(.crystal.direct_U_cell_matrix)
      .atom(n).thermal_tensor = thermal
    end

    n_equiv.destroy
    unique_thermals.destroy
  end

  fit_thermal_parameters [leaky]
  ! Fit the thermal parameters to the calculated structure factors.
  ! Uses a line search method.
    INT :: dim
    DBL :: chi2_min
    VEC* :: U
    ENSURE(.crystal.created, "no crystal")
    ENSURE(.atom.created, "no atoms to fit")
    dim = .n_atom * 6
    U.create(dim)
    .get_thermal_parameters(U)
    .crystal.optimise_extinction = FALSE
    .crystal.optimise_scale = FALSE
    .make_structure_factors
    .minimise_BFGS(U,chi2_min,tol=TOL(4),step=TOL(2))
    U.destroy
!  .atom.put_thermal_tensors
  end

  get_thermal_parameters(U) [private]
  ! Set a new set of thermal parameters for all the atoms, assuming
  ! "U" is a vector of the independent thermal parameters.
     VEC :: U
     INT :: n,base
     ENSURE(size(U)==6*.n_atom, "wrong size, U")
     do n = 1,.n_atom      ! get thermal parameters into array
       base = (n-1) * 6
       U(base+1) = .atom(n).thermal_tensor(1,1)
       U(base+2) = .atom(n).thermal_tensor(1,2)
       U(base+3) = .atom(n).thermal_tensor(1,3)
       U(base+4) = .atom(n).thermal_tensor(2,2)
       U(base+5) = .atom(n).thermal_tensor(2,3)
       U(base+6) = .atom(n).thermal_tensor(3,3)
     end
  end

  set_thermal_parameters(U) [private]
  ! Set a new set of thermal parameters for all the atoms, assuming
  ! "U" is a vector of the independent thermal parameters.
     VEC :: U
     INT :: n,base
     ENSURE(size(U)==6*.n_atom, "wrong size, U")
     do n = 1,.n_atom      ! get thermal parameters into array
       base = (n-1) * 6
       .atom(n).thermal_tensor(1,1) = U(base+1)
       .atom(n).thermal_tensor(1,2) = U(base+2)
       .atom(n).thermal_tensor(1,3) = U(base+3)
       .atom(n).thermal_tensor(2,2) = U(base+4)
       .atom(n).thermal_tensor(2,3) = U(base+5)
       .atom(n).thermal_tensor(3,3) = U(base+6)
       .atom(n).thermal_tensor(2,1) = .atom(n).thermal_tensor(1,2)
       .atom(n).thermal_tensor(3,1) = .atom(n).thermal_tensor(1,3)
       .atom(n).thermal_tensor(3,2) = .atom(n).thermal_tensor(2,3)
     end
     .force_thermal_symmetry
  end

  chi2(U) result(res) [leaky] [private]
  ! Evaluate the gradient of the chi2 with respect to the thermal parameters.
  ! Size of res is [n_atom * 6]
    VEC :: U
    DBL :: res
    ENSURE(.crystal.created, "no crystal")
    .set_thermal_parameters(U)
    .make_structure_factors 
    res = .crystal.F_chi2
!  stdout.show("new F_chi2 =",res)
  end

  d_chi2(U) result(res) [leaky] [private]
  ! Evaluate the gradient of the chi2 with respect to the thermal parameters.
  ! Size of res is [n_atom * 6]
    VEC :: U
    VEC(size(U)) :: res
    CMAT* :: sf_deriv,sf_deriv_eq
    MAT* :: k_pts
    BIN :: complex
    ENSURE(.crystal.created, "no crystal")
    ENSURE(.density_matrix.created, "no density matrix")
    .set_thermal_parameters(U)
    k_pts.create(.crystal.n_unique_k_pts,3)
    .crystal.make_unique_k_pts(k_pts)
    sf_deriv.create( .crystal.n_refl, .n_atom * 6) ! d_Fc/d_U
    sf_deriv_eq.create(.n_atom * 6,.crystal.n_unique_k_pts)
    complex = .density_matrix.spinorbital_kind.includes("complex")
    if (complex) then
      .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted_complex,k_pts) 
    else 
      .make_ft_deriv_U(sf_deriv_eq,.density_matrix.restricted,k_pts) 
    end
    .crystal.sum_unique_sf_deriv_U(sf_deriv,sf_deriv_eq)
    sf_deriv_eq.destroy
    ! Do the derivative with respect to chi2
    res = .crystal.d_chi2_dU(sf_deriv)
    sf_deriv.destroy
    k_pts.destroy
  end

   minimise_BFGS(p,fret,tol,step) [private]
      VEC, INOUT :: p
      DBL :: fret,tol
      DBL, optional :: step
      INT :: n,iter,i
      DBL :: fac,fad,fae,sumdg,sumxi,eps,stp
      DBL :: a,x,b,fx,xmin,nrm
      VEC* :: g,dg,hdg,pnew,xi
      MAT* :: hessian
      BIN :: fail
      eps = tol/FOUR
      stp = ONE
      if (present(step)) stp = step
      n = size(p)
      g.create(n)
      dg.create(n)
      hdg.create(n)
      pnew.create(n)
      xi.create(n)
      allocate(hessian(n,n))
      fret = .chi2(p)
      g = .d_chi2(p)
      hessian = ZERO
      do i = 1,n
         hessian(i,i) = ONE
      end
      xi = -g
      fail = TRUE
      do iter = 1,500
         pnew = p
         nrm = xi.norm
!      WARN_IF(nrm<TOL(10), "nrm<TOL(15)")
!         if (nrm <TOL(15)) exit
!         xi = (stp/nrm) * xi ! This is new
         if (nrm > TOL(15)) then
           xi = (stp/nrm) * xi ! This is new
         end
         .find_initial_bracket(pnew,xi,a,x,b,fx,fret)
         if (nrm/n > TOL(5)) then
           .minimise_brent(pnew,fx,xi,a,x,b,xmin,fret,TOL(1))
         else
           .minimise_brent(pnew,fx,xi,a,x,b,xmin,fret,TOL(2))
         end
  stdout.show("nrm/n =",nrm/n)
  stdout.show("xmin =",xmin)
         xi = pnew - p
         p = pnew
         dg = g
         g = .d_chi2(p)
  stdout.show("g max =", g.largest_value )
!         if (g.largest_value<gtol) then
         if (g.largest_value< 0.001) then
           fail = FALSE
           exit
         end
         dg = g - dg
         hdg.to_product(hessian,dg)
         fac = sum(dg*xi)
         sumdg = sum(dg*dg)
         sumxi = sum(xi*xi)
         if (fac*fac > eps*sumdg*sumxi) then
            fac = ONE/fac
            fae = sum(dg*hdg)
            fad = ONE/fae
            dg = fac*xi - fad*hdg
            hessian = hessian + fac * xi.outer_product(xi)   &
                              - fad * hdg.outer_product(hdg) & 
                              + fae * dg.outer_product(dg)
            xi.minus_product(hessian,g)
         end
  .atom.put_thermal_tensors
      end
      if (fail) stdout.text("Exceeded maximum number of iterations.")
      deallocate(hessian)
      xi.destroy
      pnew.destroy
      hdg.destroy
      dg.destroy
      g.destroy
   end

   find_initial_bracket(p,direction,a,b,c,fb,fa) [private]
   ! Must input fa = f(a) first.
      VEC, IN :: p,direction
      DBL :: a,b,c,fa,fb,fc
      DBL :: gold = 1.618034
      DBL :: glimit = 100
      DBL :: tiny = 1.0d-20
      DBL :: fu,q,r,u,ulim
      INT :: iter
      BIN :: fail
      ENSURE(size(p)==size(direction),"incompatible vectors")
      fb = .chi2(p + direction)
      a = ZERO
      b = ONE
      if (fb>fa) then
        a.swap_with(b)
        fa.swap_with(fb)
      end
      c  = b + gold*(b-a)
      fc = .chi2(p + c*direction)
      fail = TRUE
      do iter = 1, 100
         if (fb<fc) then
           fail = FALSE
           exit                  ! bracket found
         end
         r = (b-a)*(fb-fc)                ! get u by parabolic extrapolation
         q = (b-c)*(fb-fa)
         u = b - ((b-c)*q-(b-a)*r)/(TWO*sign(max(abs(q-r),tiny),q-r))
         ulim = b + glimit*(c-b)
         if ((b-u)*(u-c)>ZERO) then       ! Parabolic u lies between b and c
            fu = .chi2(p + u*direction)
            if (fu<fc) then               ! got a minimum between b and c
               a = b; fa = fb
               b = u; fb = fu
               fail = FALSE
               exit
            else if (fu>fb) then          ! got a minimum between a and u
               c = u; fc = fu
               fail = FALSE
               exit
            end
            u = c + gold*(c-b)            ! parabolic fit no use, so magnify 
            fu = .chi2(p + u*direction)
         else if ((c-u)*(u-ulim)>0) then     ! Fit is between c and
            fu = .chi2(p + u*direction)      ! its allowed limit
            if (fu<fc) then
               b = c; fb = fc
               c = u; fc = fu
               u = c + gold*(c-b)
               fu = .chi2(p + u*direction)
            end 
         else if ((u-ulim)*(ulim-c)>0) then
            u = ulim
            fu = .chi2(p + u*direction)
         else
            u = c + gold*(c-b)            ! magnify 
            fu = .chi2(p + u*direction)
         end
         a = b; fa = fb
         b = c; fb = fc
         c = u; fc = fu
      end
      WARN_IF(fail, "exceeded maximum iterations")
      if (a>c) then
         a.swap_with(c)
         fa.swap_with(fc)
      end
   end

  minimise_brent(p,fp,direction,a,b,c,xmin,f,tol) [private]
    VEC :: p,direction
    DBL :: a,b,c,xmin,f,tol,fp
    INT :: itmax = 100
    DBL :: cgold = 0.3819660
    DBL :: zeps = TOL(10)
    DBL :: d,e,etemp,fu,fv,fw,fx,pp,qq,r,tol1,tol2,u,v,w,x,xm
    INT :: iter
    BIN :: fail
    ENSURE(size(p)==size(direction),"incompatible vectors")
 stdout.text("start brent")
    if (a>c) a.swap_with(c)
    v = b
    w = b
    x = b
    fx = fp
    fv = fp
    fw = fp
    e = ZERO
    d = ZERO
    fail = TRUE
    b = c
    do iter = 1,itmax
      xm = HALF*(a+b)
      tol1 = tol*abs(x) + zeps
      tol2 = TWO*tol1
      if (abs(x-xm)<(tol2-HALF*(b-a))) then
        fail = FALSE
        exit
      end
      if (abs(e)>tol1) then
        r = (x-w)*(fx-fv)
        qq = (x-v)*(fx-fw)
        pp = (x-v)*qq - (x-w)*r
        qq = TWO*(qq-r)
        if (qq>ZERO) pp = -pp
        qq = abs(qq)
        etemp = e
        if (abs(pp)>=abs(HALF*qq*etemp) OR pp<=qq*(a-x) OR pp>=qq*(b-x)) then
          if (x>xm) then;  e = a-x
          else;            e = b-x
          end
          d = cgold*e
        else
          e = d
          d = pp/qq
          u = x + d
          if ((u-a)<tol2 OR (b-u)<tol2) d = sign(tol1,xm-x)
        end
      else
        if (x>=xm) then; e = a-x
        else;            e = b-x
        end
        d = cgold*e
      end
      if (abs(d)>=tol1) then; u = x + d
      else;                   u = x + sign(tol1,d)
      end
      fu = .chi2(p + u*direction)
 stdout.put_text("u = ")
 stdout.put_text(trim(u.to_str))
 stdout.put_text(", fu = ")
 stdout.put_text(trim(fu.to_str))
 stdout.put_text(", a = ")
 stdout.put_text(trim(a.to_str))
 stdout.put_text(", b = ")
 stdout.text(trim(b.to_str))
      if (fu<=fx) then
        if (u>=x) then; a = x
        else;           b = x
        end
        v = w; fv = fw
        w = x; fw = fx
        x = u; fx = fu
      else
        if (u<x) then; a = u
        else;          b = u
        end
        if (fu<=fw OR w==x) then
          v = w; fv = fw
          w = u; fw = fu
        else if (fu<=fv OR v==x OR v==w) then
          v = u; fv = fu
        end
      end
    end
 stdout.text("end brent")
    DIE_IF(fail,"maximum iterations exceeded")
    f = fx
    xmin = x
    p = p + x*direction
  end

!*******************************************************************************
!                            Cluster stuff.
!*******************************************************************************

  put_cluster_input
  ! Outputs the input data for a cluster of molecules around the centre of the
  ! molecule.
  ! Optional input position must be in crystal coordinates.
  ! Output atom positions are in crystal coordinates.
  ! Output of thermal tensors is optional.
    IMAT* :: op_list
    VEC* :: dist_list
    VEC(3) :: pos
    STR :: word,thermal_axis,thermal_units,axis,units
    MAT3* :: therm1
    MAT(3,3) :: therm,d
    MAT* :: pos1,pos2
    VEC(3) :: position
    INT :: s,h,k,l,n,q
    DBL :: dist_max
    BIN :: put_thermal

    ENSURE(.crystal.created,            "no crystal data")
    ENSURE(.atom.created,               "no atom data")
    ENSURE(.atom.bases_are_all_labeled, "atoms must all have basis labes")

    ! defaults
    dist_max  = 5
    position = (/ZERO,ZERO,ZERO/)
    put_thermal = FALSE
    thermal_units = "bohr^2"
    axis = "crystal"
    units = "bohr"

    do
      stdin.read(word)
      word.to_lower_case
      select case (word)
         case("end");                      exit
         case("put_thermal_tensors=");     stdin.read(put_thermal)
         case("distance=");                stdin.read(dist_max)
         case("position=");                stdin.read(position)
         case("centre=");                  stdin.read(position)
         case("axis=");                    stdin.read(axis)
         case("thermal_units=");           stdin.read(thermal_units)
         case("units=");                   stdin.read(units)
         case default; DIE("unknown keyword : " // trim(word))
      end
    end
    position.rotate_by(.crystal.direct_cell_matrix)

    .crystal.create_closest_molecule_list(op_list,dist_list,position,dist_max)

    q=size(op_list,2)
    if (op_list(1,1) == 0) q=0

    stdout.flush
    stdout.text("Cluster input.")
    stdout.show("No of molecules                   = ", q)
    stdout.show("Cutoff radius of cluster (au)     = ", dist_max)
    stdout.show("Centre of cluster (cartesians au) = ", position)
    if (put_thermal) then
    stdout.show("Thermal tensor axis system        = ", "crystal")
    end
    stdout.flush

    if (q>0) then

!      stdout.flush
!      do q=1,size(dist_list)
!        if (op_list(1,q)==0) exit
!        stdout.put(op_list(1,q))
!        stdout.put(op_list(2,q))
!        stdout.put(op_list(3,q))
!        stdout.put(op_list(4,q))
!        stdout.flush
!      end

      stdout.put_text("atoms")
      stdout.flush
      stdout.put_text("data_order= { label ")
      if (axis/="cartesian") stdout.put_text('"axis_system ' // trim(axis) // '" ')
      stdout.put_text("pos basis_label")
      if (put_thermal) stdout.put_text(' thermal_tensor ')
      stdout.text(" }")
      stdout.text("{")

      pos1.create(3,.n_atom)
      pos2.create(3,.n_atom)
      pos1 = .crystal.fragment_geometry
      .crystal.move_to_unit_cell(pos1)

      therm1.create(3,3,.n_atom)
      do n = 1, .n_atom
        therm1(:,:,n) = .atom(n).thermal_tensor
      end

      d = .crystal.direct_cell_matrix
      do q=1,size(dist_list)
        s = op_list(1,q)
        if (s==0) exit
        h = op_list(2,q)
        k = op_list(3,q)
        l = op_list(4,q)
        pos2 = pos1
        .crystal.transform_geometry(pos2,s)
        stdout.put_text("! seitz op = " // trim(s.to_str) // ", ")
        stdout.put_text(achar(91) // "h k l" // achar(93) // " = ")
        stdout.put_text(achar(91) // trim(h.to_str) // " ")
        stdout.put_text(trim(k.to_str) // " " // trim(l.to_str) // achar(93))
        stdout.put_text(", distance from centre is ")
        stdout.text(trim(dist_list(q).to_str('(f10.5)')) // " au.")
        do n = 1, .n_atom
          therm = therm1(:,:,n)
          therm.change_basis(.crystal.spacegroup.seitz(1:3,1:3,s))
          pos = pos2(:,n) + (/h,k,l/)
          stdout.put_text(trim(.atom(n).label),int_width=TRUE)
          if (axis=="cartesian") pos = matmul(d,pos)
          if (units/="bohr") pos.convert_to(units)
          stdout.put(pos(1))
          stdout.put(pos(2))
          stdout.put(pos(3))
          if (units/="bohr") stdout.put_text(" " // trim(units))
          stdout.put_text(" " // trim(.atom(n).basis.label))
          if (put_thermal) then
            if (thermal_units/="bohr^2") therm.convert_to(thermal_units)
            stdout.put(therm(1,1))
            stdout.put(therm(2,2))
            stdout.put(therm(3,3))
            stdout.put(therm(1,2))
            stdout.put(therm(1,3))
            stdout.put(therm(2,3))
            if (thermal_units/="bohr^2") stdout.put_text(" " // trim(thermal_units))
          end
          stdout.flush
        end
      end
      stdout.text("}",flush=2)

      dist_list.destroy
      therm1.destroy
      pos2.destroy
      pos1.destroy
    end
    op_list.destroy
  end

  create_cluster [leaky]
  ! Self gets shifted to saved_self, and self becomes a new molecule which is a
  ! cluster defined by the original molecule.
  ! Optional input position must be in crystal coordinates.
  ! If you specify the partition factors explicitly, the length of the array
  ! must be the number of atoms in the new cluster - you may have to run it a
  ! first time to get the number of atoms.
  ! The unit_factor is useful if you know that nothing is repeated in the
  ! cluster.
    PTR :: self
    IMAT* :: op_list
    VEC* :: dist_list,factors
    VEC(3) :: pos
    STR :: word
    MAT3* :: therm1
    MAT(3,3) :: therm
    MAT* :: pos1,pos2
    VEC(3) :: position
    IVEC* :: map,count
    INT :: s,h,k,l,n,q
    DBL :: dist_max
    BIN :: have_factors,unit_factors

    ENSURE(.crystal.created, "no crystal data")
    ENSURE(.atom.created, "no atom data")
    ! defaults
    dist_max  = 5
    position = (/ZERO,ZERO,ZERO/)
    have_factors = FALSE
    unit_factors = FALSE

    read_loop : do
      stdin.read(word)
      word.to_lower_case
      select case (word)
         case("end");                      exit read_loop
         case("distance=");                stdin.read(dist_max)
         case("position=");                stdin.read(position)
         case("centre=");                  stdin.read(position)
         case("factors=");                 stdin.read_ptr(factors)
                                           have_factors = TRUE
         case("unit_factors=");            stdin.read(unit_factors)
         case("symops=");                  stdin.read_ptr(op_list,n_rows=4)
         case default; DIE("unknown keyword : " // trim(word))
      end
    end do read_loop
    if (unit_factors) have_factors=TRUE
    position.rotate_by(.crystal.direct_cell_matrix)

    if (NOT op_list.created) then
      .crystal.create_closest_molecule_list(op_list,dist_list,position,dist_max)
      dist_list.destroy
    end

    .save
    .crystal.create
    .crystal.set_to(.saved.crystal)
    .crystal.destroy_fragment_data

    .set_defaults
    .name  =  trim(.saved.name) // "_cluster"
    .create_cluster_from_molecule(op_list,map,count)

    .mult = .atom.default_multiplicity
    .set_atom_info
    if (.saved.basis.created) then
      .basis.create_copy(.saved.basis)
      .resolve_basis_labels
      .set_basis_info
      .set_scf_defaults
      if (.saved.density_matrix.created) then
        if (.saved.density_matrix.any_created) then
          if (NOT have_factors) then
            factors.create(size(count))
            do n=1,size(count)
              factors(n) = ONE/count(n)
            end
          else
            if (unit_factors) then
              factors.create(size(count))
              factors = ONE
            else
              word = "inputted partition factor array must be length" // &
                      trim( size(count).to_str)
              ENSURE(size(factors)==size(count),word)
            end
          end
          .create_cluster_density_from_molecule(op_list,map,factors)
        end
      end
    end

    count.destroy
    factors.destroy
    map.destroy
    op_list.destroy

    stdout.flush
    stdout.text("new molecule created with name " // trim(.name))
    stdout.text('input file now acting on new molecule until "end_new_molecule" keyword found')
    .put_atoms
  end

  create_cluster_from_molecule(symops,map,count) [leaky]
  ! Make a cluster "mol" as a single molecule, make from one molecule and
  ! symmetry operations "symops".  WARNING: dont destroy basis of mol !
  ! The "map" vector is a n_symops*n_atom vector that contains the a mapping of
  ! the symmetry operated atoms in self onto the atoms in mol.
  ! The "count" vector contains the number of atoms that have the same
  ! position as each corresponding atom in the list.
    IMAT :: symops
    POINTGROUP* :: pg
    MAT* :: old_pos,new_pos,dens,dtr,ftr,w,old_dens,tra,trb
    MAT(3,3), target :: seitz
    MAT(1,1), target :: mat1
    SHELL1 :: sh
    VEC(3) :: np
    IVEC* :: map,count
    INT :: n_atoms,n_symops,n_unique,n,x,q,s,h,k,l,fs,fbf,lbf
    INT :: na,nb,a,b,fa,la,fb,lb,fi,li,fj,lj,newx,jj,j,y
    BIN :: found
    ENSURE(.saved.crystal.created, "no crystal data")
    ENSURE(.saved.atom.created, "no atom data")
    ENSURE(.saved.atom.bases_are_all_labeled, "atoms must all have basis labes")
    n_symops = size(symops,2)
    n_unique = size(.saved.atom)
    n_atoms = n_symops * n_unique
    map.create(n_atoms)
    count.create(n_atoms)
    .atom.create(n_atoms)

    old_pos.create(3,n_unique)
    old_pos = .saved.crystal.fragment_geometry
    .saved.crystal.move_to_unit_cell(old_pos)
    new_pos.create(3,n_unique)
    .saved.atom.change_thermal_axis_system_to("crystal",.saved.crystal)

    count=0
    x=0 ! The counter in the new unique   array
    y=0 ! The counter in the new complete array
    do q=1,n_symops
      s = symops(1,q)
      DIE_IF(s==0, "no symmetry operations within distance specified")
      h = symops(2,q)
      k = symops(3,q)
      l = symops(4,q)

      ! Transform geometry and thermal tensors.
      new_pos = old_pos
      .saved.crystal.transform_geometry(new_pos,s)
      seitz = .saved.crystal.spacegroup.seitz(1:3,1:3,s)
      do n=1,n_unique
        np = new_pos(:,n) + (/h,k,l/)
        y=y+1
        found = FALSE
        do j=1,x
          if (.atom(j).pos.same_as(np)) then
            jj=j
            found=TRUE
            exit
          end
        end
        if (found) then
          map(y)=jj
          count(jj)=count(jj)+1
        else
          x=x+1
          map(y)=x
          count(x)=count(x)+1
          .atom(x).copy(.saved.atom(n))                    ! make copy of basis
          .atom(x).nullify_ptr_part                        ! so it/self can be
          .atom(x).basis.create
          .atom(x).basis.copy(.saved.atom(n).basis) ! destroyed later.
          .atom(x).pos = np
          .atom(x).axis_system = "crystal"
          .atom(x).thermal_tensor = .saved.atom(n).thermal_tensor
          .atom(x).thermal_tensor.change_basis(seitz)
        end
      end
    end
    count.shrink(x)
    .atom.shrink(x)
    .saved.atom.change_thermal_axis_system_to("cartesian",.saved.crystal)
    .atom.change_axis_system_to("cartesian",.saved.crystal)
    .crystal.make_reduced_group_data(.atom)
  end

  create_cluster_density_from_molecule(symops,map,factors) [leaky]
  ! Given the cluster "mol", defined from "self" by "symops", "map", and
  ! "factors", create the density matrix for "mol" from that of "self".
  ! Can only do up to f functions.
    IMAT, IN :: symops
    IVEC, IN :: map
    VEC, IN :: factors
    MAT* :: new_dens,dtr,ftr,w,old_dens,tra,trb
    MAT(3,3), target :: seitz,tmp
    MAT(1,1), target :: mat1
    VEC(3) :: np
    IVEC* :: first,last
    DBL :: c1,c2
    INT :: n_atoms,n_symops,n_unique,n,x,q,s,h,k,l,fs,fbf,lbf
    INT :: na,nb,a,b,fa,la,fb,lb,fi,li,fj,lj
    INT :: f1,l1,f2,l2,nf1,nf2,nl1,nl2,s1,s2,of1,of2,newa2,oabf2
    INT :: na1fbf,na2fbf,oabf1,bf_offset,newa1,oa2
    INT :: ol2,na2,atom_offset,oa1,ol1
    ENSURE(.saved.crystal.created, "no crystal data")
    ENSURE(.saved.atom.created, "no atom data")
    ENSURE(.saved.atom.bases_are_all_labeled, "atoms must all have basis labes")
    ENSURE(.saved.density_matrix.created,"no density matrix")
    ENSURE(.saved.density_matrix.restricted.created,"no density matrix")
    n_symops = size(symops,2)
    n_unique = size(.saved.atom)
    n_atoms = n_symops * n_unique
    .density_matrix.create("restricted")
    dtr.create(6,6)
    ftr.create(10,10)

    first => .saved.first_basis_fn_for_shell
    last => .saved.last_basis_fn_for_shell
    .density_matrix.restricted = ZERO
    mat1 = ONE
    old_dens => .saved.density_matrix.restricted
    x=0
    do q=1,n_symops
      s = symops(1,q)
      DIE_IF(s==0, "no symmetry operations within distance specified")
      h = symops(2,q)
      k = symops(3,q)
      l = symops(4,q)

      ! Transform geometry and thermal tensors.
      atom_offset = (q-1) * n_unique
      seitz = .saved.crystal.spacegroup.seitz(1:3,1:3,s)
      tmp.to_product(seitz,.saved.crystal.inverse_cell_matrix)
      seitz.to_product(.saved.crystal.direct_cell_matrix,tmp)
      .saved.make_rotation_matrices(seitz,dtr,ftr)

      ! Have to do it one shell pair at a time.
      do s1 = 1, .saved.n_shell
        oa1 = .saved.atom_for_shell(s1)
        of1 = .saved.first_basis_fn_for_shell(s1)
        ol1 = .saved.last_basis_fn_for_shell(s1)
        newa1= map(oa1+atom_offset)                  ! the new atom
        na1fbf = .first_basis_fn_for_atom(newa1) ! first basis fn on new atom
        oabf1 = .saved.first_basis_fn_for_atom(oa1)       ! first basis fn on old atom
        na=ol1-of1+1                                ! number of basis funtions
        bf_offset = of1 - oabf1            ! shell offset wrt that atom's shells
        nf1=na1fbf+bf_offset
        nl1=nf1+na-1
        select case (na)
          case (1); tra => mat1
          case (3); tra => seitz
          case (6); tra => dtr
          case (10); tra => ftr
        end

        do s2 = 1, .saved.n_shell
          oa2 = .saved.atom_for_shell(s2)
          of2 = .saved.first_basis_fn_for_shell(s2)
          ol2 = .saved.last_basis_fn_for_shell(s2)
          newa2= map(oa2+atom_offset)
          oabf2 = .saved.first_basis_fn_for_atom(oa2)
          nb=ol2-of2+1
          bf_offset = of2 - oabf2
          na2fbf = .first_basis_fn_for_atom(newa2)
          nf2=na2fbf+bf_offset
          nl2=nf2+nb-1
          select case (nb)
            case (1); trb => mat1
            case (3); trb => seitz
            case (6); trb => dtr
            case (10); trb => ftr
          end

          ! Transform density matrix.
          new_dens => .density_matrix.restricted(nf1:nl1,nf2:nl2)
          old_dens => .saved.density_matrix.restricted(of1:ol1,of2:ol2)
          w.create(na,nb)
          w = matmul(tra,old_dens)
          new_dens = new_dens + matmul(w,transpose(trb))
          w.destroy
        end
      end
    end
    ftr.destroy
    dtr.destroy

    ! now to put the right factors in.
    new_dens => .density_matrix.restricted
    do s1=1,.n_shell
      oa1= .atom_for_shell(s1)
      f1= .first_basis_fn_for_shell(s1)
      l1= .last_basis_fn_for_shell(s1)
!      c1= ONE/count(oa1)
      c1= factors(oa1)
      do s2=1,.n_shell
        oa2= .atom_for_shell(s2)
        f2= .first_basis_fn_for_shell(s2)
        l2= .last_basis_fn_for_shell(s2)
!        c2= ONE/count(oa2)
        c2= factors(oa2)
        new_dens(f1:l1,f2:l2) = new_dens(f1:l1,f2:l2) * HALF * (c1 + c2)
      end
    end
  end

  make_rotation_matrices(ptr,dtr,ftr)
  ! This routine generates the rotation matrices for d and f functions from the
  ! seitz matrix.
  ! ptr is the seitz matrix.
  ! dtr is a 6x6 matrix, ftr is a 10x10 matrix.
    IN :: self
    MAT, IN :: ptr
    MAT, OUT :: dtr,ftr
    INT :: n,j,i1,i2,i3
    IVEC(6)  :: d1 = (/1,2,3,1,1,2/)
    IVEC(6)  :: d2 = (/1,2,3,2,3,3/)
    IVEC(10) :: f1 = (/1,2,3,1,1,2,2,3,3,1/)
    IVEC(10) :: f2 = (/1,2,3,1,1,2,2,3,3,2/)
    IVEC(10) :: f3 = (/1,2,3,2,3,1,3,1,2,3/)
    do j = 1,6
      i1=d1(j)
      i2=d2(j)
      dtr(1,j)  = ptr(1,i1)*ptr(1,i2)
      dtr(2,j)  = ptr(2,i1)*ptr(2,i2)
      dtr(3,j)  = ptr(3,i1)*ptr(3,i2)
      dtr(4,j)  = ptr(1,i1)*ptr(2,i2) + ptr(2,i1)*ptr(1,i2)
      dtr(5,j)  = ptr(1,i1)*ptr(3,i2) + ptr(3,i1)*ptr(1,i2)
      dtr(6,j)  = ptr(2,i1)*ptr(3,i2) + ptr(3,i1)*ptr(2,i2)
    end
    dtr(1:6,4:6) = dtr(1:6,4:6)*sqrt(THREE)
    dtr(4:6,1:6) = dtr(4:6,1:6)*(ONE/sqrt(THREE))
    do j = 1,10
      i1=f1(j)
      i2=f2(j)
      i3=f3(j)
      ftr(1,j)  = ptr(1,i1)*ptr(1,i2)*ptr(1,i3)
      ftr(2,j)  = ptr(2,i1)*ptr(2,i2)*ptr(2,i3)
      ftr(3,j)  = ptr(3,i1)*ptr(3,i2)*ptr(3,i3)
      ftr(4,j)  = ptr(1,i1)*ptr(1,i2)*ptr(2,i3) &
                + ptr(1,i1)*ptr(2,i2)*ptr(1,i3) &
                + ptr(2,i1)*ptr(1,i2)*ptr(1,i3)
      ftr(5,j)  = ptr(1,i1)*ptr(1,i2)*ptr(3,i3) &
                + ptr(1,i1)*ptr(3,i2)*ptr(1,i3) &
                + ptr(3,i1)*ptr(1,i2)*ptr(1,i3)
      ftr(6,j)  = ptr(1,i1)*ptr(2,i2)*ptr(2,i3) &
                + ptr(2,i1)*ptr(1,i2)*ptr(2,i3) &
                + ptr(2,i1)*ptr(2,i2)*ptr(1,i3)
      ftr(7,j)  = ptr(3,i1)*ptr(2,i2)*ptr(2,i3) &
                + ptr(2,i1)*ptr(3,i2)*ptr(2,i3) &
                + ptr(2,i1)*ptr(2,i2)*ptr(3,i3)
      ftr(8,j)  = ptr(1,i1)*ptr(3,i2)*ptr(3,i3) &
                + ptr(3,i1)*ptr(1,i2)*ptr(3,i3) &
                + ptr(3,i1)*ptr(3,i2)*ptr(1,i3)
      ftr(9,j)  = ptr(2,i1)*ptr(3,i2)*ptr(3,i3) &
                + ptr(3,i1)*ptr(2,i2)*ptr(3,i3) &
                + ptr(3,i1)*ptr(3,i2)*ptr(2,i3)
      ftr(10,j) = ptr(1,i1)*ptr(2,i2)*ptr(3,i3) &
                + ptr(1,i1)*ptr(3,i2)*ptr(2,i3) &
                + ptr(2,i1)*ptr(1,i2)*ptr(3,i3) &
                + ptr(2,i1)*ptr(3,i2)*ptr(1,i3) &
                + ptr(3,i1)*ptr(1,i2)*ptr(2,i3) &
                + ptr(3,i1)*ptr(2,i2)*ptr(1,i3)
    end
    ftr(1:10, 4:9 ) = ftr(1:10, 4:9 )*sqrt(FIVE)
    ftr(1:10,10:10) = ftr(1:10,10:10)*sqrt(FIVE*THREE)
    ftr(4:9 , 1:10) = ftr(4:9 , 1:10)*(ONE/sqrt(FIVE))
    ftr(10:10,1:10) = ftr(10:10,1:10)*(ONE/sqrt(FIVE*THREE))
  end



  factor_density [leaky]
  ! Applies atomic partition factors to the density matrix, useful for zeroing
  ! out certain atoms.
  ! reads in the density factors from stdin.
    PTR :: self
    STR :: word
    VEC* :: list
    INT :: a1,a2,nf1,nl1,nf2,nl2
    DBL :: factor

    ENSURE(.atom.created, "no atom data")
    ENSURE(.scfdata.spinorbital_kind=="restricted",can only do restricted density)
    ! defaults

    list.create(.n_atom)

    read_loop : do
      stdin.read(word)
      word.to_lower_case
      select case (word)
         case("end");                      exit read_loop
         case("factors=");                 stdin.read(list)
         case default; DIE("unknown keyword : " // trim(word))
      end
    end do read_loop

    do a1 = 1, .n_atom
      nf1 = .first_basis_fn_for_atom(a1)
      nl1 = .last_basis_fn_for_atom(a1)
      do a2 = 1, .n_atom
        nf2 = .first_basis_fn_for_atom(a2)
        nl2 = .last_basis_fn_for_atom(a2)
        factor = (list(a1)+list(a2))/TWO ! mulliken partitioning
        .density_matrix.restricted(nf1:nl1,nf2:nl2).to_product(factor)
      end
    end
    list.destroy

  end

end 
