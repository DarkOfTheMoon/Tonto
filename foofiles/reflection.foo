!-------------------------------------------------------------------------------
!
! REFLECTION: Reflection data for crystals
!
! (c) daniel grimwood, 2000
!
! $Id$
!-------------------------------------------------------------------------------
module REFLECTION

   use TYPES
   use SYSTEM
   use STR
   use TEXTFILE

   implicit none

#  include "macros"
#  include "reflection.int"

!   type reflection_type
! 
!   INT :: h
!   ! Miller h index for the reflection
! 
!   INT :: k
!   ! Miller k index for the reflection
! 
!   INT :: l
!   ! Miller l index for the reflection
! 
!   DBL :: F_exp
!   ! Experimental structure factor
! 
!   DBL :: F_sigma
!   ! Experimental error in the structure factor
! 
!   CDBL :: F_calc
!   ! Calculated complex structure factor without including corrections
! 
!   DBL :: F_pred
!   ! Calculated structure factor including scale and extinction corrections
! 
!   DBL :: I_exp
!   ! Experimental intensity
! 
!   DBL :: I_sigma
!   ! Experimental error in the intensity
! 
!   DBL :: I_pred
!   ! Calculated intensity including scale and extinction corrections
! 
!   end

contains

!*******************************************************************************
!                        Create and Destroy Routines
!*******************************************************************************

   create
   ! Create an crystal object
      PTR :: self
      nullify(self)
      allocate(self)
      ADD_MEM(REFLECTION_SIZE)
      .set_default
   end

   destroy
   ! Destroy an crystal object
      PTR :: self
      if (.destroyed) return
      DELETE_MEM(CRYSTAL_SIZE)
      deallocate(self)
   end

   created result(res)
   ! Returns true if self has been created
      PTR :: self
      BIN :: res
      res = associated(self)
   end

   destroyed result(res)
   ! Returns true if self has *not* been created
      PTR :: self
      BIN :: res
      res = NOT associated(self)
   end

   set_default
   ! Set up a default crystal object
     .h = 0
     .k = 0
     .l = 0
     .F_exp = ZERO
     .F_calc = ZERO
     .F_pred = ZERO
     .F_sigma = ZERO
     .I_exp = ZERO
     .I_pred = ZERO
     .I_sigma = ZERO
   end

!*******************************************************************************
!                           Read Routines
!*******************************************************************************

  read [recursive]
  ! Read data from "stdin" using keyword style input.
    STR :: word
    read_loop: do          ! Loop over keywords
      stdin.read(word)
      if (stdin.reverted) exit read_loop
      if (word=="end")    exit read_loop
      .process_input(word)
    end do read_loop
  end

  process_input(word) [recursive]
  ! Process a keyword "word". Data is inputted from "stdin", unless
  ! "word" is a sequence of blank separated strings.  In this case,
  ! the sequence is processed as if it were a separate file.
    STR(*) :: word
    DBL :: tmp_dbl
    CDBL :: tmp_cdbl
    if (word.includes(" ")) then
      stdin.redirect([word])
      .read
    else
      select case (word)
        case("end");          ! exit surrounding loop
        case("h");            stdin.read(.h)
        case("k");            stdin.read(.l)
        case("l");            stdin.read(.k)
        case("indices");      stdin.read(.h)
                              stdin.read(.k)
                              stdin.read(.l)
        case("F_exp");        stdin.read(.F_exp)
        case("F_calc");       stdin.read(.F_calc)
        case("F_pred");       stdin.read(.F_pred)
        case("F_sigma");      stdin.read(.F_sigma)
        case("I_exp");        stdin.read(.I_exp)
        case("I_pred");       stdin.read(.I_pred)
        case("I_sigma");      stdin.read(.I_sigma)
        case("add_F_calc");   stdin.read(tmp_cdbl)
                              .F_calc = .F_calc + tmp_cdbl
        case("add_F_pred");   stdin.read(tmp_dbl)
                              .F_pred = .F_pred + tmp_dbl
        case("add_F_exp");    stdin.read(tmp_dbl)
                              .F_exp = .F_exp + tmp_dbl
        case("add_F_sigma");  stdin.read(tmp_dbl)
                              .F_sigma = .F_sigma + tmp_dbl
        case("add_I_pred");   stdin.read(tmp_dbl)
                              .I_pred = .I_pred + tmp_dbl
        case("add_I_exp");    stdin.read(tmp_dbl)
                              .I_exp = .I_exp + tmp_dbl
        case("add_I_sigma");  stdin.read(tmp_dbl)
                              .I_sigma = .I_sigma + tmp_dbl
        case default;         DIE("unknown keyword, "//trim(word))
      end
    end
  end
 
  process_input(keyword)
  ! Process each of the words in the "keyword" list.
    STRVEC :: keyword
    INT :: k,n_key
    n_key = size(keyword)
    do k = 1,n_key
      if (keyword(k)=="end") exit
      .process_input(keyword(k))
    end
    ENSURE(k>=n_key,"unprocessed words remain in the keyword list")
  end

!*******************************************************************************
!                           Enquiry Routines
!*******************************************************************************

  F_z result (res) [pure]
  ! Return the z statistic for the predicted structure factor.
    IN :: self
    DBL :: res
    res = sign(ONE,real(.F_calc)) * (.F_pred - .F_exp) / .F_sigma
  end

  F_z2 result (res) [pure]
  ! Return the z**2 statistic for the predicted structure factor.
    IN :: self
    DBL :: z,res
    z = (.F_pred - .F_exp) / .F_sigma
    res = z*z
  end

  F_r result(res) [pure]
  ! Return the r factor for the predicted structure factor.
    IN :: self
    DBL :: res
    res = (.F_pred - .F_exp) / .F_exp
  end

  I_z result (res) [pure]
  ! Return the z statistic for the predicted intensity.
    IN :: self
    DBL :: res
    res = (.I_pred - .I_exp) / .I_sigma
  end

end
